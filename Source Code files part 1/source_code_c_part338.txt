een blit to copy
     * the font data. For the last 16 font data columns (constant data
     * of zero), do a paint blit with colour zero. This will yield
     * one character of font data per line. Since we have already
     * switched to display via the VGA, this will not affect the
     * on-screen image.
     *
     * Note that this is only possible on a Mach 32 with the VGA enabled.
     */

    /*
     * Initialize the drawing engine to 8BPP with a pitch of 128. Don't
     * set up the CRT, since we are only trying to fill in the appropriate
     * bytes of video memory, and the results of our drawing are not
     * intended to be seen.
     */
    ExtGeConfig = INPW(R_EXT_GE_CONFIG);
    MiscOptions = INPW(MISC_OPTIONS);
    OUTPW(MISC_OPTIONS, (WORD)(MiscOptions | 0x0002));  /* 8 bit host data I/O */
    OUTPW(EXT_GE_CONFIG, (WORD)(PIX_WIDTH_8BPP | 0x000A));
    OUTPW(GE_PITCH, (128 >> 3));
    OUTPW(GE_OFFSET_HI, 0);
    OUTPW(GE_OFFSET_LO, 0);

    /*
     * We must now do our 32 rectangular blits, each 1 pixel wide by
     * 256 pixels high. These start at column 2 (zero-based), and are
     * done every 4 columns.
     */
    for(Column = 0; Column <= 31; Column++)
        {
        ScreenColumn = (Column * 4) + 2;
        /*
         * If this is one of the first 16 columns, we need to do a
         * host-to-screen blit.
         */
        if (Column <= 15)
            {
            WaitForIdle_m();
            OUTPW(DP_CONFIG, (WORD)(FG_COLOR_SRC_HOST | BG_COLOR_SRC_BG | EXT_MONO_SRC_ONE | DRAW | READ_WRITE));
            OUTPW(CUR_X, ScreenColumn);
            OUTPW(CUR_Y, 0);
            OUTPW(DEST_X_START, ScreenColumn);
            OUTPW(DEST_X_END, (WORD)(ScreenColumn + 1));
            OUTPW(DEST_Y_END, 256);

            /*
             * The nth column contains the nth byte of character bitmap
             * data for each of the 256 characters. There are 16 bytes
             * of bitmap data per character, so the nth byte of data for
             * character x (n and x both zero-based) is at offset
             * (x * 16) + n.
             */
            for (Row = 0; Row < 256; Row++)
                {
                OUTP_HBLW(PIX_TRANS, FontData_m[(Row * 16) + Column]);
                }
            }
        else
            {
            /*
             * This is one of the "padding" zero bytes which must be
             * added to each character in the font to bring it up
             * to 32 bytes of data per character.
             */
            WaitForIdle_m();
            OUTPW(DP_CONFIG, (WORD)(FG_COLOR_SRC_FG | DRAW | READ_WRITE));
            OUTPW(ALU_FG_FN, MIX_FN_PAINT);
            OUTPW(FRGD_COLOR, 0);
            OUTPW(CUR_X, ScreenColumn);
            OUTPW(CUR_Y, 0);
            OUTPW(DEST_X_START, ScreenColumn);
            OUTPW(DEST_X_END, (WORD)(ScreenColumn + 1));
            OUTPW(DEST_Y_END, 256);
            }
        }

    /*
     * Restore the graphics engine registers we changed.
     */
    OUTPW(EXT_GE_CONFIG, ExtGeConfig);
    OUTPW(MISC_OPTIONS, MiscOptions);

    /*
     * Restore the registers we changed to load the font.
     */
    OUTPW(reg3CE, (WORD) ((Gra06 << 8) | 6));
    OUTPW(reg3CE, (WORD) ((Gra05 << 8) | 5));
    OUTPW(HI_SEQ_ADDR, (WORD) ((Seq04 << 8) | 4));
    OUTPW(HI_SEQ_ADDR, (WORD) ((Seq02 << 8) | 2));

    /*
     * Set up the engine and CRT pitches for 1024x768, to avoid screen
     * doubling when warm-booting from our driver to the 8514/A driver.
     * This is only necessary on the Mach 32 (Mach 8 never reaches this
     * point in the code) because on the Mach 8, writing to ADVFUNC_CNTL
     * (done as part of Passth8514_m()) sets both registers up for
     * 1024x768.
     */
    OUTPW(GE_PITCH, 128);
    OUTPW(CRT_PITCH, 128);

    return;

}   /* SetTextMode_m() */

/*****************************	 end  of  MODES_M.C  **********************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\ati\mini\query_cx.h ===
/************************************************************************/
/*                                                                      */
/*                              QUERY_CX.H                              */
/*                                                                      */
/*       Oct 19  1993 (c) 1993, ATI Technologies Incorporated.          */
/************************************************************************/

/**********************       PolyTron RCS Utilities
   
  $Revision:   1.14  $
      $Date:   01 May 1996 14:11:26  $
	$Author:   RWolff  $
	   $Log:   S:/source/wnt/ms11/miniport/archive/query_cx.h_v  $
 * 
 *    Rev 1.14   01 May 1996 14:11:26   RWolff
 * Added prototype for new routine DenseOnAlpha().
 * 
 *    Rev 1.13   23 Apr 1996 17:24:00   RWolff
 * Split mapping of memory types reported by BIOS into our enumeration
 * of memory types according to ASIC type, since ?T and ?X use the same
 * memory type code to refer to different memory types.
 * 
 *    Rev 1.12   15 Apr 1996 16:58:22   RWolff
 * Added prototype for routine which identifies which flavour of the
 * Mach 64 is in use.
 * 
 *    Rev 1.11   20 Mar 1996 13:45:38   RWolff
 * Increased size of buffer where screen is stored prior to video memory
 * being used to hold query information.
 * 
 *    Rev 1.10   01 Mar 1996 12:16:02   RWolff
 * Added definitions used for Alpha "blue screen" preservation.
 * 
 *    Rev 1.9   11 Jan 1996 19:43:32   RWolff
 * New definitions and structures to support use of AX=A?07 BIOS call rather
 * than special cases to restrict refresh rates.
 * 
 *    Rev 1.8   24 Feb 1995 12:29:18   RWOLFF
 * Prototype for TextBanding_cx()
 * 
 *    Rev 1.7   18 Nov 1994 11:54:14   RWOLFF
 * Split structures and internal variables so that they can be included
 * separately, as needed for no-BIOS support.
 * 
 *    Rev 1.6   14 Sep 1994 15:20:26   RWOLFF
 * Added definitions for all 32BPP colour orderings.
 * 
 *    Rev 1.5   31 Aug 1994 16:28:18   RWOLFF
 * Added support for 1152x864.
 * 
 *    Rev 1.4   30 Jun 1994 18:12:56   RWOLFF
 * Removed prototype for IsApertureConflict_cx() and definitions used
 * only by this function. Function moved to SETUP_CX.C because the
 * new method of checking for conflict requires access to definitions
 * and data structures which are only available in this module.
 * 
 *    Rev 1.3   12 May 1994 11:21:02   RWOLFF
 * Updated comment.
 * 
 *    Rev 1.2   27 Apr 1994 14:11:22   RWOLFF
 * Removed unused lookup table.
 * 
 *    Rev 1.1   07 Feb 1994 14:13:02   RWOLFF
 * Removed prototype for GetMemoryNeeded_cx().
 * 
 *    Rev 1.0   31 Jan 1994 11:43:00   RWOLFF
 * Initial revision.
 * 
 *    Rev 1.2   14 Jan 1994 15:24:32   RWOLFF
 * Updated CX query structure to match BIOS version 0.13, added 1600x1200
 * support, prototype for BlockWriteAvail_cx()
 * 
 *    Rev 1.1   30 Nov 1993 18:27:38   RWOLFF
 * Prototypes for new routines, fields of cx_query structure now match
 * fields in structure returned by BIOS query call.
 * 
 *    Rev 1.0   05 Nov 1993 13:36:52   RWOLFF
 * Initial revision.

End of PolyTron RCS section                             *****************/

#ifdef DOC
QUERY_CX.H - Header file for QUERY_CX.C

#endif


/*
 * Definitions for deep colour and RAMDAC special features support,
 * stored in q_shadow_1 field (Mach 64 does not use shadow sets)
 * of query_structure.
 */
#define S1_SYNC_ON_GREEN    0x8000
#define S1_GAMMA_CORRECT    0x4000
#define S1_GREYSCALE_256    0x2000
#define S1_SLEEPMODE        0x1000
#define S1_32BPP            0x00F0
#define S1_32BPP_xRGB       0x0080
#define S1_32BPP_BGRx       0x0040
#define S1_32BPP_RGBx       0x0020
#define S1_32BPP_xBGR       0x0010
#define S1_24BPP            0x000C
#define S1_24BPP_BGR        0x0008
#define S1_24BPP_RGB        0x0004
#define S1_16BPP            0x0003
#define S1_16BPP_555        0x0002
#define S1_16BPP_565        0x0001



/*
 * Prototypes for functions provided by QUERY_CX.C
 */
extern int DetectMach64(void);
extern VP_STATUS QueryMach64(struct query_structure *Query);
extern BOOL BlockWriteAvail_cx(struct query_structure *Query);
extern BOOL TextBanding_cx(struct query_structure *Query);
extern PWSTR IdentifyMach64Asic(struct query_structure *Query, PULONG AsicStringLength);
#if defined(ALPHA)
extern BOOL DenseOnAlpha(struct query_structure *Query);
#endif


/*
 * Structures used in QUERY_CX.C and (on non-x86 machines with no
 * emulation, so VideoPortInt10() is not available) modules which
 * emulate the query functions of the BIOS.
 */
#ifdef STRUCTS_QUERY_CX

/*
 * Hardware capability structure returned by BIOS call AX=0xA?07.
 */
#pragma pack(1)
struct cx_hw_cap{
    BYTE cx_HorRes;             /* Horizontal resolution in units of 8 pixels */
    BYTE cx_RamOrDacType;       /* RAM type or bitmask of DAC types */
    BYTE cx_MemReq;             /* Minimum memory to support the mode in question */
    BYTE cx_MaxDotClock;        /* Maximum dot clock, in megahertz */
    BYTE cx_MaxPixDepth;        /* Code for maximum pixel depth for the mode in question */
};

/*
 * Query structure returned by CX BIOS call AX=0xA?09. This structure
 * is NOT interchangeable with query_structure from AMACH1.H.
 *
 * The alignment of fields within the BIOS query and mode table
 * structures does not match the default structure alignment of the
 * Windows NT C compiler, so we must force byte alignment.
 */
struct cx_query{
    WORD cx_sizeof_struct;      /* Size of the structure in bytes */
    BYTE cx_structure_rev;      /* Structure revision number */
    BYTE cx_number_modes;       /* Number of mode tables */
    WORD cx_mode_offset;        /* Offset in bytes to first mode table */
    BYTE cx_mode_size;          /* Size of each mode table */
    BYTE cx_vga_type;           /* VGA enabled/disabled status */
    WORD cx_asic_rev;           /* ASIC revision */
    BYTE cx_vga_boundary;       /* VGA boundary */
    BYTE cx_memory_size;        /* Amount of memory installed */
    BYTE cx_dac_type;           /* DAC type */
    BYTE cx_memory_type;        /* Type of memory chips installed */
    BYTE cx_bus_type;           /* Bus type */
    BYTE cx_special_sync;       /* Flags for composite sync and sync on green */
    WORD cx_aperture_addr;      /* Aperture address in megabytes (0-4095) */
    BYTE cx_aperture_cfg;       /* Aperture configuration */
    BYTE cx_deep_colour;        /* Deep colour support information */
    BYTE cx_ramdac_info;        /* Special features available from DAC */
    BYTE cx_reserved_1;         /* Reserved */
    WORD cx_current_mode;       /* Offset of current mode table */
    WORD cx_io_base;            /* I/O base address */
    BYTE cx_reserved_2[6];      /* Reserved */
};

/*
 * Mode table structure returned by CX BIOS call AX=0xA?09. This structure
 * is NOT interchangeable with st_mode_table from AMACH1.H.
 */
struct cx_mode_table{
    WORD cx_x_size;             /* Horizontal resolution in pixels */
    WORD cx_y_size;             /* Vertical resolution in pixels */
    BYTE cx_pixel_depth;        /* Maximum pixel depth */
    BYTE cx_reserved_1;         /* Reserved */
    WORD cx_eeprom_offset;      /* Offset of table into EEPROM */
    WORD cx_reserved_2;         /* Reserved */
    WORD cx_reserved_3;         /* Reserved */
    WORD cx_crtc_gen_cntl;      /* Interlace and double scan status */
    BYTE cx_crtc_h_total;       /* CRTC_H_TOTAL value */
    BYTE cx_crtc_h_disp;        /* CRTC_H_DISP value */
    BYTE cx_crtc_h_sync_strt;   /* CRTC_H_SYNC_STRT value */
    BYTE cx_crtc_h_sync_wid;    /* CRTC_H_SYNC_WID value */
    WORD cx_crtc_v_total;       /* CRTC_V_TOTAL value */
    WORD cx_crtc_v_disp;        /* CRTC_V_DISP value */
    WORD cx_crtc_v_sync_strt;   /* CRTC_V_SYNC_STRT value */
    BYTE cx_crtc_v_sync_wid;    /* CRTC_V_SYNC_WID value */
    BYTE cx_clock_cntl;         /* Clock selector and divider */
    WORD cx_dot_clock;          /* Dot clock for programmable clock chip */
    WORD cx_h_overscan;         /* Horizontal overscan information */
    WORD cx_v_overscan;         /* Vertical overscan information */
    WORD cx_overscan_8b;        /* 8BPP and blue overscan colour */
    WORD cx_overscan_gr;        /* Green and red overscan colour */
};
#pragma pack()

#endif  /* defined STRUCTS_QUERY_CX */


#ifdef INCLUDE_QUERY_CX
/*
 * Private definitions used in QUERY_CX.C
 */

#define FORMAT_DACMASK  0   /* cx_hw_cap.cx_RamOrDacType is mask of DAC types */
#define FORMAT_RAMMASK  1   /* cx_hw_cap.cx_RamOrDacType is mask of RAM types */
#define FORMAT_DACTYPE  2   /* cx_hw_cap.cx_RamOrDacType is DAC type */
#define FORMAT_RAMTYPE  3   /* cx_hw_cap.cx_RamOrDacType is RAM type */

/*
 * The following definitions are used in creating a buffer where the
 * contents of an existing VGA graphics screen and specific VGA registers
 * are stored in preparation for using the screen as a buffer below
 * 1M physical in order to store the BIOS query information. It is
 * assumed that the temporary buffer used to store this information
 * is an array of unsigned characters.
 *
 * According to Arthur Lai, older BIOSes determined the required size
 * of the query buffer at runtime by examining the installed modes,
 * while newer BIOSes take a buffer large enough to handle the worst
 * case scenario in order to reduce code size. This should never be
 * larger than 1 kilobyte. In the unlikely event that this is exceeded,
 * we will save the first kilobyte and allow the remainder to be
 * overwritten by query data, rather than overflowing our save buffer.
 */
#define VGA_SAVE_SIZE   1024    /* Array location where size of buffer is stored */
#define VGA_SAVE_SIZE_H 1025
#define VGA_SAVE_SEQ02  1026    /* Array location where sequencer register 2 value stored */
#define VGA_SAVE_GRA08  1027    /* Array location where graphics register 8 value stored */
#define VGA_SAVE_GRA01  1028    /* Array location where graphics register 1 value stored */
#define VGA_TOTAL_SIZE  1029    /* Size of screen/register save buffer */

/*
 * Pixel depths for use as an array index. Two columns will be wasted
 * since there is no depth code equal to zero and we don't use 15BPP,
 * but this allows direct indexing using the pixel width field of the
 * hardware capabilities structure returned by BIOS call AX=0xA?07.
 */
enum {
    DEPTH_NOTHING = 0,
    DEPTH_4BPP,
    DEPTH_8BPP,
    DEPTH_15BPP,
    DEPTH_16BPP,
    DEPTH_24BPP,
    DEPTH_32BPP,
    HOW_MANY_DEPTHS
    };    

/*
 * Mappings of Mach 64 query values to enumerations from AMACH1.H
 */
UCHAR CXMapMemSize[8] =
    {
    VRAM_512k,
    VRAM_1mb,
    VRAM_2mb,
    VRAM_4mb,
    VRAM_6mb,
    VRAM_8mb
    };

UCHAR CXMapRamType[7] =
    {
    VMEM_DRAM_256Kx16,
    VMEM_VRAM_256Kx4_SER512,
    VMEM_VRAM_256Kx16_SER256,
    VMEM_DRAM_256Kx4,
    VMEM_DRAM_256Kx4_GRAP,  /* Space filler - type 4 not documented */
    VMEM_VRAM_256Kx4_SPLIT512,
    VMEM_VRAM_256Kx16_SPLIT256
    };

UCHAR CTMapRamType[7] =
    {
    VMEM_GENERIC_DRAM,      /* Space filler - type 0 not documented */
    VMEM_GENERIC_DRAM,
    VMEM_EDO_DRAM,
    VMEM_BRRAM,
    VMEM_SDRAM,
    VMEM_GENERIC_DRAM,      /* Space filler - type 5 not documented */
    VMEM_GENERIC_DRAM       /* Space filler - type 6 not documented */
    };

UCHAR CXMapBus[8] =
    {
    BUS_ISA_16,     /* ISA bus */
    BUS_EISA,
    BUS_ISA_8,      /* Use "weakest" bus for types marked as reserved */
    BUS_ISA_8,      /* Reserved */
    BUS_ISA_8,      /* Reserved */
    BUS_ISA_8,      /* Reserved */
    BUS_LB_486,     /* Mach 64 lumps all VLB types together */
    BUS_PCI
    };

/*
 * Lookup table to translate the code for maximum colour depth returned
 * in the BIOS mode tables into bits per pixel.
 */
USHORT CXPixelDepth[7] =
    {
    0,      /* Undefined */
    4,
    8,
    16,     /* xRRR RRGG GGGB BBBB */
    16,     /* RRRR RGGG GGGB BBBB */
    24,
    32
    };

/*
 * Used in searching mode tables for desired resolution.
 */
USHORT CXHorRes[6] =
    {
    640,
    800,
    1024,
    1152,
    1280,
    1600
    };

/*
 * Flags to show that a given resolution is supported.
 */
UCHAR CXStatusFlags[6] =
    {
    VRES_640x480,
    VRES_800x600,
    VRES_1024x768,
    VRES_1152x864,
    VRES_1280x1024,
    VRES_1600x1200
    };

#endif  /* defined INCLUDE_QUERY_CX */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\ati\mini\services.c ===
/************************************************************************/
/*                                                                      */
/*                              SERVICES.C                              */
/*                                                                      */
/*        Aug 26  1993 (c) 1993, ATI Technologies Incorporated.         */
/************************************************************************/

/**********************       PolyTron RCS Utilities
   
  $Revision:   1.33  $
      $Date:   15 Apr 1996 16:59:44  $
	$Author:   RWolff  $
	   $Log:   S:/source/wnt/ms11/miniport/archive/services.c_v  $
 * 
 *    Rev 1.33   15 Apr 1996 16:59:44   RWolff
 * Now calls new routine to report which flavour of the Mach 64 is
 * in use, rather than reporting "Mach 64" for all ASIC types.
 * 
 *    Rev 1.32   12 Apr 1996 16:18:16   RWolff
 * Now rejects 24BPP modes if linear aperture is not present, since new
 * source stream display driver can't do 24BPP in a paged aperture. This
 * rejection should be done in the display driver (the card still supports
 * the mode, but the display driver doesn't want to handle it), but at
 * the point where the display driver must decide to either accept or reject
 * modes, it doesn't have access to the aperture information.
 * 
 *    Rev 1.31   10 Apr 1996 17:05:28   RWolff
 * Made routine delay() nonpageable.
 * 
 *    Rev 1.30   01 Mar 1996 12:16:38   RWolff
 * Fix for DEC Alpha under NT 4.0: memory-mapped register access is
 * via direct pointer read/write in dense space and via VideoPort
 * routines in sparse space (VideoPort routines no longer work in
 * dense space - this is a HAL bug).
 * 
 *    Rev 1.29   09 Feb 1996 13:27:36   RWolff
 * Now reports only accelerator memory to display applet for Mach 8 combo
 * cards.
 * 
 *    Rev 1.28   02 Feb 1996 17:20:10   RWolff
 * DDC/VDIF merge source information is now stored in hardware device
 * extension rather than static variables, added DEC's workaround to
 * Lio[Inp|Outp]([w|d])() routines for NT 4.0 memory mapped register
 * access, added routine GetVgaBuffer() to (nondestructively) obtain
 * a buffer in physical memory below 1M.
 * 
 *    Rev 1.27   23 Jan 1996 11:49:20   RWolff
 * Added debug print statements.
 * 
 *    Rev 1.26   11 Jan 1996 19:44:34   RWolff
 * SetFixedModes() now restricts modes based on pixel clock frequency.
 * 
 *    Rev 1.25   22 Dec 1995 14:54:30   RWolff
 * Added support for Mach 64 GT internal DAC, switched to TARGET_BUILD
 * to identify the NT version for which the driver is being built.
 * 
 *    Rev 1.24   21 Nov 1995 11:02:54   RWolff
 * Now reads DDC timing data rather than VDIF file if card and monitor
 * both support DDC.
 * 
 *    Rev 1.23   08 Sep 1995 16:35:52   RWolff
 * Added support for AT&T 408 DAC (STG1703 equivalent).
 * 
 *    Rev 1.22   28 Jul 1995 14:40:14   RWolff
 * Added support for the Mach 64 VT (CT equivalent with video overlay).
 * 
 *    Rev 1.21   26 Jul 1995 13:08:30   mgrubac
 * Moved mode tables merging from SetFixedModes to VDIFCallback()
 * routine.
 * 
 *    Rev 1.20   20 Jul 1995 18:00:26   mgrubac
 * Added support for VDIF files.
 * 
 *    Rev 1.19   02 Jun 1995 14:32:58   RWOLFF
 * Added routine UpperCase() to change string into upper case because
 * toupper() was coming back as unresolved external on some platforms.
 * 
 *    Rev 1.18   10 Apr 1995 17:05:06   RWOLFF
 * Made LioInpd() and LioOutpd() nonpageable, since they are called
 * (indirectly) by ATIMPResetHw(), which must be nonpageable.
 * 
 *    Rev 1.17   31 Mar 1995 11:53:14   RWOLFF
 * Changed from all-or-nothing debug print statements to thresholds
 * depending on importance of the message.
 * 
 *    Rev 1.16   08 Mar 1995 11:35:28   ASHANMUG
 * Modified return values to be correct
 * 
 *    Rev 1.15   30 Jan 1995 11:55:52   RWOLFF
 * Now reports presence of CT internal DAC.
 * 
 *    Rev 1.14   25 Jan 1995 14:08:24   RWOLFF
 * Fixed "ampersand is reserved character" bug in FillInRegistry() that
 * caused AT&T 49[123] and AT&T 498 to drop the ampersand and underline
 * the second T.
 * 
 *    Rev 1.13   18 Jan 1995 15:40:14   RWOLFF
 * Chrontel DAC now supported as separate type rather than being
 * lumped in with STG1702.
 * 
 *    Rev 1.12   11 Jan 1995 14:03:16   RWOLFF
 * Replaced VCS logfile comment that was accidentally deleted when
 * checking in the last revision.
 * 
 *    Rev 1.11   04 Jan 1995 13:22:06   RWOLFF
 * Removed dead code.
 * 
 *    Rev 1.10   23 Dec 1994 10:48:10   ASHANMUG
 * ALPHA/Chrontel-DAC
 * 
 *    Rev 1.9   18 Nov 1994 11:46:44   RWOLFF
 * GetSelector() now increases the size of the frequency "window" and checks
 * again, rather than giving up and taking the selector/divisor pair that
 * produces the highest freqency that does not exceed the target frequency,
 * if a match is not found on the first pass. Added support for split rasters.
 * 
 *    Rev 1.8   31 Aug 1994 16:28:56   RWOLFF
 * Now uses VideoPort[Read|Write]Register[Uchar|Ushort|Ulong]() instead
 * of direct memory writes for memory mapped registers under Daytona
 * (functions didn't work properly under NT retail), added support
 * for 1152x864 and 1600x1200.
 * 
 *    Rev 1.7   19 Aug 1994 17:14:50   RWOLFF
 * Added support for SC15026 DAC and non-standard pixel clock generators.
 * 
 *    Rev 1.6   20 Jul 1994 13:00:08   RWOLFF
 * Added routine FillInRegistry() which writes to new registry fields that
 * let the display applet know what chipset and DAC the graphics card is
 * using, along with the amount of video memory and the type of adapter.
 * 
 *    Rev 1.5   12 May 1994 11:20:06   RWOLFF
 * Added routine SetFixedModes() which adds predefined refresh rates
 * to list of mode tables.
 * 
 *    Rev 1.4   27 Apr 1994 13:51:30   RWOLFF
 * Now sets Mach 64 1280x1024 pitch to 2048 when disabling LFB.
 * 
 *    Rev 1.3   26 Apr 1994 12:35:58   RWOLFF
 * Added routine ISAPitchAdjust() which increases screen pitch to 1024
 * and removes mode tables for which there is no longer enough memory.
 * 
 *    Rev 1.2   14 Mar 1994 16:36:14   RWOLFF
 * Functions used by ATIMPResetHw() are not pageable.
 * 
 *    Rev 1.1   07 Feb 1994 14:13:44   RWOLFF
 * Added alloc_text() pragmas to allow miniport to be swapped out when
 * not needed.
 * 
 *    Rev 1.0   31 Jan 1994 11:20:16   RWOLFF
 * Initial revision.
        
           Rev 1.7   24 Jan 1994 18:10:38   RWOLFF
        Added routine TripleClock() which returns the selector/divisor pair that
        will produce the lowest clock frequency that is at least three times
        that produced by the input selector/divisor pair.
        
           Rev 1.6   14 Jan 1994 15:26:14   RWOLFF
        No longer prints message each time memory mapped registers
        are read or written.
        
           Rev 1.5   15 Dec 1993 15:31:46   RWOLFF
        Added routine used for SC15021 DAC at 24BPP and above.
        
           Rev 1.4   30 Nov 1993 18:29:38   RWOLFF
        Speeded up IsBufferBacked(), fixed LioOutpd()
        
           Rev 1.3   05 Nov 1993 13:27:02   RWOLFF
        Added routines to check whether a buffer is backed by physical memory,
        double pixel clock frequency, and get pixel clock frequency for a given
        selector/divisor pair.
        
           Rev 1.2   24 Sep 1993 11:46:06   RWOLFF
        Switched to direct memory writes instead of VideoPortWriteRegister<length>()
        calls which don't work properly.
        
           Rev 1.1   03 Sep 1993 14:24:40   RWOLFF
        Card-independent service routines.

End of PolyTron RCS section                             *****************/

#ifdef DOC
SERVICES.C - Service routines required by the miniport.

DESCRIPTION
    This file contains routines which provide miscelaneous services
    used by the miniport. All routines in this module are independent
    of the type of ATI accelerator being used.

    To secure this independence, routines here may make calls to
    the operating system, or call routines from other modules
    which read or write registers on the graphics card, but must
    not make INP/OUTP calls directly.

OTHER FILES

#endif

#include "dderror.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "miniport.h"
#include "ntddvdeo.h"
#include "video.h"

#include "stdtyp.h"
#include "amach1.h"
#include "atimp.h"
#include "atint.h"
#include "cvtvga.h"
#include "query_cx.h"
#define INCLUDE_SERVICES
#include "services.h"
#include "cvtvdif.h"
#include "cvtddc.h"


/*
 * Allow miniport to be swapped out when not needed.
 */
#if defined (ALLOC_PRAGMA)
#pragma alloc_text(PAGE_COM, short_delay)
/* delay() can't be made pageable */
#pragma alloc_text(PAGE_COM, IsBufferBacked)
#pragma alloc_text(PAGE_COM, DoubleClock)
#pragma alloc_text(PAGE_COM, ThreeHalvesClock)
#pragma alloc_text(PAGE_COM, TripleClock)
#pragma alloc_text(PAGE_COM, GetFrequency)
#pragma alloc_text(PAGE_COM, GetSelector)
#pragma alloc_text(PAGE_COM, GetShiftedSelector)
#pragma alloc_text(PAGE_COM, ISAPitchAdjust)
#pragma alloc_text(PAGE_COM, SetFixedModes)
#pragma alloc_text(PAGE_COM, FillInRegistry)
#pragma alloc_text(PAGE_COM, MapFramebuffer)
#pragma alloc_text(PAGE_COM, Get_BIOS_Seg)
#pragma alloc_text(PAGE_COM, UpperCase)
#pragma alloc_text(PAGE_COM, GetVgaBuffer)
/* LioInp() can't be made pageable */
/* LioOutp() can't be made pageable */
/* LioInpw() can't be made pageable */
/* LioOutpw() can't be made pageable */
/* LioInpd() can't be made pageable */
/* LioOutpd() can't be made pageable */
#endif


/*
 * Static variables used by this module.
 */
static BYTE ati_signature[] = "761295520";



/*
 * void short_delay(void);
 *
 * Wait a minimum of 26 microseconds.
 */
void short_delay(void)
{
	VideoPortStallExecution (26);

    return;
}


/*
 * void delay(delay_time);
 *
 * int delay_time;      How many milliseconds to wait
 *
 * Wait for the specified amount of time to pass.
 */
void delay(int delay_time)
{
    unsigned long Counter;

    /*
     * This must NOT be done as a single call to
     * VideoPortStallExecution() with the parameter equal to the
     * total delay desired. According to the documentation for this
     * function, we're already pushing the limit in order to minimize
     * the effects of function call overhead.
     */
    for (Counter = 10*delay_time; Counter > 0; Counter--)
        VideoPortStallExecution (100);

    return;
}



/***************************************************************************
 *
 * BOOL IsBufferBacked(StartAddress, Size);
 *
 * PUCHAR StartAddress;     Pointer to the beginning of the buffer
 * ULONG Size;              Size of the buffer in bytes
 *
 * DESCRIPTION:
 *  Check to see whether the specified buffer is backed by physical
 *  memory.
 *
 * RETURN VALUE:
 *  TRUE if the buffer is backed by physical memory
 *  FALSE if the buffer contains a "hole" in physical memory
 *
 * GLOBALS CHANGED:
 *  None, but the contents of the buffer are overwritten.
 *
 * CALLED BY:
 *  This function may be called by any routine.
 *
 * AUTHOR:
 *  Robert Wolff
 *
 * CHANGE HISTORY:
 *
 * TEST HISTORY:
 *
 ***************************************************************************/

BOOL IsBufferBacked(PUCHAR StartAddress, ULONG Size)
{
    ULONG Count;        /* Loop counter */
    ULONG NumDwords;    /* Number of doublewords filled by Size bytes */
    ULONG NumTailChars; /* Number of bytes in the last (partially-filled) DWORD) */
    PULONG TestAddress; /* Address to start doing DWORD testing */
    PUCHAR TailAddress; /* Address of the last (partially-filled) DWORD */

    /*
     * Fill the buffer with our test value. The value 0x5A is used because
     * it contains odd bits both set and clear, and even bits both set and
     * clear. Since nonexistent memory normally reads as either all bits set
     * or all bits clear, it is highly unlikely that we will read back this
     * value if there is no physical RAM.
     *
     * For performance reasons, check as much as possible of the buffer
     * in DWORDs, then only use byte-by-byte testing for that portion
     * of the buffer which partially fills a DWORD.
     */
    NumDwords = Size/(sizeof(ULONG)/sizeof(UCHAR));
    TestAddress = (PULONG) StartAddress;
    NumTailChars = Size%(sizeof(ULONG)/sizeof(UCHAR));
    TailAddress = StartAddress + NumDwords * (sizeof(ULONG)/sizeof(UCHAR));

    for (Count = 0; Count < NumDwords; Count++)
        {
        VideoPortWriteRegisterUlong(&(TestAddress[Count]), 0x5A5A5A5A);
        }

    if (NumTailChars != 0)
        {
        for (Count = 0; Count < NumTailChars; Count++)
            {
            VideoPortWriteRegisterUchar(&(TailAddress[Count]), (UCHAR)0x5A);
            }
        }

    /*
     * Read back the contents of the buffer. If we find even one byte that
     * does not contain our test value, then assume that the buffer is not
     * backed by physical memory.
     */
    for (Count = 0; Count < NumDwords; Count++)
        {
        if (VideoPortReadRegisterUlong(&(TestAddress[Count])) != 0x5A5A5A5A)
            {
            return FALSE;
            }
        }

    /*
     * If the buffer contains a partially filled DWORD at the end, check
     * the bytes in this DWORD.
     */
    if (NumTailChars != 0)
        {
        for (Count = 0; Count < NumTailChars; Count++)
            {
            if (VideoPortReadRegisterUchar(&(TailAddress[Count])) != 0x5A)
                {
                return FALSE;
                }
            }
        }

    /*
     * We were able to read back our test value from every byte in the
     * buffer, so we know it is backed by physical memory.
     */
    return TRUE;

}   /* IsBufferBacked() */



/***************************************************************************
 *
 * UCHAR DoubleClock(ClockSelector);
 *
 * UCHAR ClockSelector;    Initial clock selector
 *
 * DESCRIPTION:
 *  Find the clock selector and divisor pair which will produce the
 *  lowest clock frequency that is at least double that produced by
 *  the input selector/divisor pair (format 000DSSSS).
 *
 *  A divisor of 0 is treated as divide-by-1, while a divisor of 1
 *  is treated as divide-by-2.
 *
 * RETURN VALUE:
 *  Clock selector/devisor pair (format 000DSSSS) if an appropriate pair
 *  exists, 0x0FF if no such pair exists.
 *
 * GLOBALS CHANGED:
 *  none
 *
 * CALLED BY:
 *  May be called by any function.
 *
 * AUTHOR:
 *  Robert Wolff
 *
 * CHANGE HISTORY:
 *
 * TEST HISTORY:
 *
 ***************************************************************************/

UCHAR DoubleClock(UCHAR ClockSelector)
{
    ULONG MinimumFreq;          /* Minimum acceptable pixel clock frequency */
    ULONG ThisFreq;             /* Current frequency being tested */
    ULONG BestFreq=0x0FFFFFFFF; /* Closest match to double the original frequency */
    UCHAR BestSelector=0x0FF;   /* Divisor/selector pair to produce BestFreq */
    short Selector;             /* Used to loop through the selector */
    short Divisor;              /* Used to loop through the divisor */

    /*
     * Easy way out: If the current pixel clock frequency is obtained by
     * dividing by 2, switch to divide-by-1.
     */
    if ((ClockSelector & DIVISOR_MASK) != 0)
        return (ClockSelector ^ DIVISOR_MASK);

    /*
     * Cycle through the selector/divisor pairs to get the closest
     * match to double the original frequency. We already know that
     * we are using a divide-by-1 clock, since divide-by-2 will have
     * been caught by the shortcut above.
     */
    MinimumFreq = ClockGenerator[ClockSelector & SELECTOR_MASK] * 2;
    for (Selector = 0; Selector < 16; Selector++)
        {
        for (Divisor = 0; Divisor <= 1; Divisor++)
            {
            ThisFreq = ClockGenerator[Selector] >> Divisor;

            /*
             * If the frequency being tested is at least equal
             * to double the original frequency and is closer
             * to the ideal (double the original) than the previous
             * "best", make it the new "best".
             */
            if ((ThisFreq >= MinimumFreq) && (ThisFreq < BestFreq))
                {
                BestFreq = ThisFreq;
                BestSelector = Selector | (Divisor << DIVISOR_SHIFT);
                }
            }
        }
    return BestSelector;

}   /* DoubleClock() */



/***************************************************************************
 *
 * UCHAR ThreeHalvesClock(ClockSelector);
 *
 * UCHAR ClockSelector;    Initial clock selector
 *
 * DESCRIPTION:
 *  Find the clock selector and divisor pair which will produce the
 *  lowest clock frequency that is at least 50% greater than that
 *  produced by the input selector/divisor pair (format 000DSSSS).
 *
 *  A divisor of 0 is treated as divide-by-1, while a divisor of 1
 *  is treated as divide-by-2.
 *
 * RETURN VALUE:
 *  Clock selector/devisor pair (format 000DSSSS) if an appropriate pair
 *  exists, 0x0FF if no such pair exists.
 *
 * GLOBALS CHANGED:
 *  none
 *
 * CALLED BY:
 *  May be called by any function.
 *
 * AUTHOR:
 *  Robert Wolff
 *
 * CHANGE HISTORY:
 *
 * TEST HISTORY:
 *
 ***************************************************************************/

UCHAR ThreeHalvesClock(UCHAR ClockSelector)
{
    ULONG MinimumFreq;          /* Minimum acceptable pixel clock frequency */
    ULONG ThisFreq;             /* Current frequency being tested */
    ULONG BestFreq=0x0FFFFFFFF; /* Closest match to 1.5x the original frequency */
    UCHAR BestSelector=0x0FF;   /* Divisor/selector pair to produce BestFreq */
    short Selector;             /* Used to loop through the selector */
    short Divisor;              /* Used to loop through the divisor */

    /*
     * Cycle through the selector/divisor pairs to get the closest
     * match to 1.5 times the original frequency.
     */
    MinimumFreq = ClockGenerator[ClockSelector & SELECTOR_MASK];
    if (ClockSelector & DIVISOR_MASK)
        MinimumFreq /= 2;
    MinimumFreq *= 3;
    MinimumFreq /= 2;
    for (Selector = 0; Selector < 16; Selector++)
        {
        for (Divisor = 0; Divisor <= 1; Divisor++)
            {
            ThisFreq = ClockGenerator[Selector] >> Divisor;

            /*
             * If the frequency being tested is at least equal
             * to 1.5 times the original frequency and is closer
             * to the ideal (1.5 times the original) than the previous
             * "best", make it the new "best".
             */
            if ((ThisFreq >= MinimumFreq) && (ThisFreq < BestFreq))
                {
                BestFreq = ThisFreq;
                BestSelector = Selector | (Divisor << DIVISOR_SHIFT);
                }
            }
        }
    return BestSelector;

}   /* ThreeHalvesClock() */



/***************************************************************************
 *
 * UCHAR TripleClock(ClockSelector);
 *
 * UCHAR ClockSelector;    Initial clock selector
 *
 * DESCRIPTION:
 *  Find the clock selector and divisor pair which will produce the
 *  lowest clock frequency that is at least triple that produced by
 *  the input selector/divisor pair (format 000DSSSS).
 *
 *  A divisor of 0 is treated as divide-by-1, while a divisor of 1
 *  is treated as divide-by-2.
 *
 * RETURN VALUE:
 *  Clock selector/devisor pair (format 000DSSSS) if an appropriate pair
 *  exists, 0x0FF if no such pair exists.
 *
 * GLOBALS CHANGED:
 *  none
 *
 * CALLED BY:
 *  May be called by any function.
 *
 * AUTHOR:
 *  Robert Wolff
 *
 * CHANGE HISTORY:
 *
 * TEST HISTORY:
 *
 ***************************************************************************/

UCHAR TripleClock(UCHAR ClockSelector)
{
    ULONG MinimumFreq;          /* Minimum acceptable pixel clock frequency */
    ULONG ThisFreq;             /* Current frequency being tested */
    ULONG BestFreq=0x0FFFFFFFF; /* Closest match to triple the original frequency */
    UCHAR BestSelector=0x0FF;   /* Divisor/selector pair to produce BestFreq */
    short Selector;             /* Used to loop through the selector */
    short Divisor;              /* Used to loop through the divisor */

    /*
     * Cycle through the selector/divisor pairs to get the closest
     * match to triple the original frequency.
     */
    MinimumFreq = ClockGenerator[ClockSelector & SELECTOR_MASK];
    if (ClockSelector & DIVISOR_MASK)
        MinimumFreq /= 2;
    MinimumFreq *= 3;
    for (Selector = 0; Selector < 16; Selector++)
        {
        for (Divisor = 0; Divisor <= 1; Divisor++)
            {
            ThisFreq = ClockGenerator[Selector] >> Divisor;

            /*
             * If the frequency being tested is at least equal
             * to triple the original frequency and is closer
             * to the ideal (triple the original) than the previous
             * "best", make it the new "best".
             */
            if ((ThisFreq >= MinimumFreq) && (ThisFreq < BestFreq))
                {
                BestFreq = ThisFreq;
                BestSelector = Selector | (Divisor << DIVISOR_SHIFT);
                }
            }
        }
    return BestSelector;

}   /* TripleClock() */



/***************************************************************************
 *
 * ULONG GetFrequency(ClockSelector);
 *
 * UCHAR ClockSelector;    Clock selector/divisor pair
 *
 * DESCRIPTION:
 *  Find the clock frequency for the specified selector/divisor pair
 *  (format 000DSSSS).
 *
 *  A divisor of 0 is treated as divide-by-1, while a divisor of 1
 *  is treated as divide-by-2.
 *
 * RETURN VALUE:
 *  Clock frequency in hertz.
 *
 * GLOBALS CHANGED:
 *  none
 *
 * CALLED BY:
 *  May be called by any function.
 *
 * AUTHOR:
 *  Robert Wolff
 *
 * NOTE:
 *  This routine is the inverse of GetSelector()
 *
 * CHANGE HISTORY:
 *
 * TEST HISTORY:
 *
 ***************************************************************************/

ULONG GetFrequency(UCHAR ClockSelector)
{
    ULONG BaseFrequency;
    short Divisor;

    Divisor = (ClockSelector & DIVISOR_MASK) >> DIVISOR_SHIFT;
    BaseFrequency = ClockGenerator[ClockSelector & SELECTOR_MASK];

    return BaseFrequency >> Divisor;

}   /* GetFrequency() */



/***************************************************************************
 *
 * UCHAR GetSelector(Frequency);
 *
 * ULONG *Frequency;    Clock frequency in hertz
 *
 * DESCRIPTION:
 *  Find the pixel clock selector and divisor values needed to generate
 *  the best possible approximation of the input pixel clock frequency.
 *  The first value found which is within FREQ_TOLERANCE of the input
 *  value will be used (worst case error would be 0.6% frequency
 *  difference on 18811-1 clock chip if FREQ_TOLERANCE is 100 kHz).
 *
 *  If no selector/divisor pair produces a frequency which is within
 *  FREQ_TOLERANCE (very rare - I have only seen it happen in 24BPP
 *  on a DAC that needs the clock frequency multiplied by 1.5 at
 *  this pixel depth), increase the tolerance and try again. If we
 *  still can't find a selector/divisor pair before the tolerance
 *  gets too large, use the pair which produces the highest frequency
 *  not exceeding the input value.
 *  
 * RETURN VALUE:
 *  Clock selector/divisor pair (format 000DSSSS). A divisor of 0
 *  indicates divide-by-1, while a divisor of 1 indicates divide-by-2.
 *
 *  If all available selector/divisor pairs produce clock frequencies
 *  greater than (*Frequency + FREQ_TOLERANCE), 0xFF is returned.
 *
 * GLOBALS CHANGED:
 *  *Frequency is changed to the actual frequency produced by the
 *  selector/divisor pair.
 *
 * CALLED BY:
 *  May be called by any function.
 *
 * AUTHOR:
 *  Robert Wolff
 *
 * NOTE:
 *  This routine is the inverse of GetFrequency()
 *  Since the input frequency may be changed, do not use a
 *  constant as the parameter.
 *
 * CHANGE HISTORY:
 *
 * TEST HISTORY:
 *
 ***************************************************************************/

UCHAR GetSelector(ULONG *Frequency)
{
    long Select;        /* Clock select value */
    long Divisor;       /* Clock divisor */
    long TestFreq;      /* Clock frequency under test */
    long TPIRFreq;      /* Highest frequency found that doesn't exceed *Frequency */
    long TPIRSelect;    /* Selector to produce TIPRFreq */
    long TPIRDivisor;   /* Divisor to produce TPIRFreq */
    long Tolerance;     /* Maximum acceptable deviation from desired frequency */

    /*
     * Set up for no match.
     */
    TPIRFreq = 0;
    TPIRSelect = 0xFF;

    /*
     * To accomodate DACs which occasionally require a frequency
     * which is significantly different from the available frequencies,
     * we need a large tolerance. On the other hand, to avoid selecting
     * a poor match that happens earlier in the search sequence than
     * a better match, we need a small tolerance. These conflicting
     * goals can be met if we start with a small tolerance and increase
     * it if we don't find a match.
     *
     * The maximum tolerance before we give up and take the highest
     * frequency which does not exceed the target frequency was chosen
     * by trial-and-error. On a card with an STG1702/1703 DAC in 24BPP
     * (requires a pixel clock which is 1.5x normal, and which can
     * miss available frequencies by a wide margin), I increased
     * this value until all supported 24BPP modes remained on-screen.
     */
    for (Tolerance = FREQ_TOLERANCE; Tolerance <= 16*FREQ_TOLERANCE; Tolerance *= 2)
        {
        /*
         * Go through all the possible frequency/divisor pairs
         * looking for a match.
         */
        for(Select = 0; Select < 16; Select++)
            {
            for(Divisor = 1; Divisor <= 2; Divisor++)
                {
                TestFreq = ClockGenerator[Select] / Divisor;

                /*
                 * If this pair is close enough, use it.
                 */
                if ( ((TestFreq - (signed long)*Frequency) < Tolerance) &&
                     ((TestFreq - (signed long)*Frequency) > -Tolerance))
                    {
                    *Frequency = (unsigned long) TestFreq;
                    return ((UCHAR)(Select) | ((UCHAR)(Divisor - 1) << 4));
                    }

                /*
                 * If this pair produces a frequency higher than TPIRFreq
                 * but not exceeding *Frequency, use it as the new TPIRFreq.
                 * The equality test is redundant, since equality would
                 * have been caught in the test above.
                 *
                 * Except on the first pass through the outermost loop
                 * (tightest "window"), this test should never succeed,
                 * since TPIRFreq should already match the highest
                 * frequency that doesn't exceed the target frequency.
                 */
                if ((TestFreq > TPIRFreq) && (TestFreq <= (signed long)*Frequency))
                    {
                    TPIRFreq = TestFreq;
                    TPIRSelect = Select;
                    TPIRDivisor = Divisor;
                    }

                }   /* end for (loop on Divisor) */

            }   /* end for (loop on Select) */

        }   /* end for (loop on Tolerance) */

    /*
     * We didn't find a selector/divisor pair which was within tolerance,
     * so settle for second-best: the pair which produced the highest
     * frequency not exceeding the input frequency.
     */
    *Frequency = (unsigned long) TPIRFreq;
    return ((UCHAR)(TPIRSelect) | ((UCHAR)(TPIRDivisor - 1) << 4));

}   /* GetSelector() */



/***************************************************************************
 *
 * UCHAR GetShiftedSelector(Frequency);
 *
 * ULONG Frequency;     Clock frequency in hertz
 *
 * DESCRIPTION:
 *  Find the pixel clock selector and divisor values needed to generate
 *  the best possible approximation of the input pixel clock frequency.
 *  The first value found which is within FREQ_TOLERANCE of the input
 *  value will be used (worst case error would be 0.6% frequency
 *  difference on 18811-1 clock chip if FREQ_TOLERANCE is 100 kHz).
 *
 *  If no selector/divisor pair produces a frequency which is within
 *  FREQ_TOLERANCE, use the pair which produces the highest frequency
 *  not exceeding the input value.
 *  
 * RETURN VALUE:
 *  Clock selector/divisor pair (format 0DSSSS00). A divisor of 0
 *  indicates divide-by-1, while a divisor of 1 indicates divide-by-2.
 *  This format is the same as is used by the CLOCK_SEL register
 *  on Mach 8 and Mach 32 cards.
 *
 *  If all available selector/divisor pairs produce clock frequencies
 *  greater than (Frequency + FREQ_TOLERANCE), 0xFF is returned.
 *
 * GLOBALS CHANGED:
 *  None
 *
 * CALLED BY:
 *  May be called by any function.
 *
 * AUTHOR:
 *  Robert Wolff
 *
 * NOTE:
 *  The selector/divisor pair returned may produce a frequency
 *  different from the input.
 *
 * CHANGE HISTORY:
 *
 * TEST HISTORY:
 *
 ***************************************************************************/

UCHAR GetShiftedSelector(ULONG Frequency)
{
    UCHAR RawPair;  /* Selector/divisor pair returned by GetSelector() */
    ULONG TempFreq; /* Temporary copy of input parameter */

    TempFreq = Frequency;
    RawPair = GetSelector(&TempFreq);

    /*
     * If GetSelector() was unable to find a match, pass on this
     * information. Otherwise, shift the selector/divisor pair
     * into the desired format.
     */
    if (RawPair == 0xFF)
        return RawPair;
    else
        return (RawPair << 2);

}   /* GetShiftedSelector() */


/***************************************************************************
 *
 * void ISAPitchAdjust(QueryPtr);
 *
 * struct query_structure *QueryPtr;    Query structure for video card
 *
 * DESCRIPTION:
 *  Eliminates split rasters by setting the screen pitch to 1024 for
 *  all mode tables with a horizontal resolution less than 1024, then
 *  packs the list of mode tables to eliminate any for which there is
 *  no longer enough video memory due to the increased pitch.
 *
 * GLOBALS CHANGED:
 *  QueryPtr->q_number_modes
 *
 * CALLED BY:
 *  IsApertureConflict_m() and IsApertureConflict_cx()
 *
 * AUTHOR:
 *  Robert Wolff
 *
 * CHANGE HISTORY:
 *
 * TEST HISTORY:
 *
 ***************************************************************************/

void ISAPitchAdjust(struct query_structure *QueryPtr)
{
struct st_mode_table *ReadPtr;      /* Mode table pointer to read from */
struct st_mode_table *WritePtr;     /* Mode table pointer to write to */
UCHAR AvailModes;                   /* Number of available modes */
int Counter;                        /* Loop counter */
ULONG BytesNeeded;                  /* Bytes of video memory needed for current mode */
ULONG MemAvail;                     /* Bytes of video memory available */

    /*
     * Set both mode table pointers to the beginning of the list of
     * mode tables. We haven't yet found any video modes, and all
     * video modes must fit into the memory space above the VGA boundary.
     */
    ReadPtr = (struct st_mode_table *)QueryPtr; /* First mode table at end of query structure */
    ((struct query_structure *)ReadPtr)++;
    WritePtr = ReadPtr;
    AvailModes = 0;
    MemAvail = (QueryPtr->q_memory_size - QueryPtr->q_VGA_boundary) * QUARTER_MEG;

    /*
     * Go through the list of mode tables, and adjust each table as needed.
     */
    VideoDebugPrint((DEBUG_DETAIL, "Original: %d modes\n", QueryPtr->q_number_modes));
    for (Counter = 0; Counter < QueryPtr->q_number_modes; Counter++, ReadPtr++)
        {
        /*
         * The pitch only needs to be adjusted if the horizontal resolution
         * is less than 1024.
         */
#if !defined (SPLIT_RASTERS)
        if (ReadPtr->m_x_size < 1024)
            ReadPtr->m_screen_pitch = 1024;

        /*
         * Temporary until split raster support for Mach 64 is added
         * (no engine-only driver for Mach 64).
         */
        if ((phwDeviceExtension->ModelNumber == MACH64_ULTRA) &&
            (ReadPtr->m_x_size > 1024))
            ReadPtr->m_screen_pitch = 2048;
#endif

        /*
         * Get the amount of video memory needed for the current mode table
         * now that the pitch has been increased. If there is no longer
         * enough memory for this mode, skip it.
         */
        BytesNeeded = (ReadPtr->m_screen_pitch * ReadPtr->m_y_size * ReadPtr->m_pixel_depth)/8;
        if (BytesNeeded >= MemAvail)
            {
            VideoDebugPrint((DEBUG_DETAIL, "Rejected: %dx%d, %dBPP\n", ReadPtr->m_x_size, ReadPtr->m_y_size, ReadPtr->m_pixel_depth));
            continue;
            }

        /*
         * Our new source stream display driver needs a linear aperture
         * in order to handle 24BPP. Since the display driver doesn't
         * have access to the aperture information when it is deciding
         * which modes to pass on to the display applet, it can't make
         * the decision to reject 24BPP modes for cards with only a
         * VGA aperture. This decision must therefore be made in the
         * miniport, so in a paged aperture configuration there are no
         * 24BPP modes for the display driver to accept or reject.
         */
        if (ReadPtr->m_pixel_depth == 24)
            {
            VideoDebugPrint((1, "Rejected %dx%d, %dBPP - need LFB for 24BPP\n", ReadPtr->m_x_size, ReadPtr->m_y_size, ReadPtr->m_pixel_depth));
            continue;
            }

        /*
         * There is enough memory for this mode even with the pitch increased.
         * If we have not yet skipped a mode (read and write pointers are
         * the same), the mode table is already where we need it. Otherwise,
         * copy it to the next available slot in the list of mode tables.
         * In either case, move to the next slot in the list of mode tables
         * and increment the number of modes that can still be used.
         */
        if (ReadPtr != WritePtr)
            {
            VideoPortMoveMemory(WritePtr, ReadPtr, sizeof(struct st_mode_table));
            VideoDebugPrint((DEBUG_DETAIL, "Moved: %dx%d, %dBPP\n", ReadPtr->m_x_size, ReadPtr->m_y_size, ReadPtr->m_pixel_depth));
            }
        else
            {
            VideoDebugPrint((DEBUG_DETAIL, "Untouched: %dx%d, %dBPP\n", ReadPtr->m_x_size, ReadPtr->m_y_size, ReadPtr->m_pixel_depth));
            }
        AvailModes++;
        WritePtr++;
        }

    /*
     * Record the new number of available modes
     */
    QueryPtr->q_number_modes = AvailModes;
    VideoDebugPrint((DEBUG_DETAIL, "New: %d modes\n", QueryPtr->q_number_modes));
    return;

}   /* ISAPitchAdjust() */


/***************************************************************************
 *
 * WORD SetFixedModes(StartIndex, EndIndex, Multiplier, PixelDepth, 
 *                    Pitch, FreeTables, MaxDotClock, ppmode);
 *
 * WORD StartIndex;     First entry from "book" tables to use
 * WORD EndIndex;       Last entry from "book" tables to use
 * WORD Multiplier;     What needs to be done to the pixel clock
 * WORD PixelDepth;     Number of bits per pixel
 * WORD Pitch;          Screen pitch to use
 * WORD FreeTables;     Number of free mode tables that can be added
 * ULONG MaxDotClock;   Maximum pixel clock frequency, in hertz
 * struct st_mode_table **ppmode;   Pointer to list of mode tables
 *
 * DESCRIPTION:
 *  Generates a list of "canned" mode tables merged with tables found
 *  in VDIF file (either ASCII or binary file), so the tables are in
 *  increasing order of frame rate, with the "canned" entry discarded
 *  if two with matching frame rates are found. This allows the user 
 *  to select either a resolution which was not configured using 
 *  INSTALL, or a refresh rate other than the one which was configured,
 *  allowing the use of uninstalled cards, and dropping
 *  the refresh rate for high pixel depths.
 *
 * RETURN VALUE:
 *  Number of mode tables added to the list
 *
 * GLOBALS CHANGED:
 *  pCallbackArgs
 *
 * CALLED BY:
 *  QueryMach32(), QueryMach64(), OEMGetParms(), ReadAST()
 *
 * AUTHOR:
 *  Robert Wolff
 *
 * CHANGE HISTORY:
 *  95 11 20  Robert Wolff
 *  Now obtains tables from EDID structure rather than VDIF file if
 *  both monitor and card support DDC
 *
 *  95 07 12  Miroslav Grubac
 *  Now produces a merged list of fixed mode tables and tables found in
 *  VDIF file
 *
 * TEST HISTORY:
 *
 ***************************************************************************/

WORD SetFixedModes(WORD StartIndex,
                   WORD EndIndex,
                   WORD Multiplier,
                   WORD PixelDepth,
                   WORD Pitch,
                   short FreeTables,
                   ULONG MaxDotClock,
                   struct st_mode_table **ppmode)
{
    WORD HighBound;     /* The highest frame rate  */
    struct stVDIFCallbackData stCallbArgs;

    pCallbackArgs = (void *) (& stCallbArgs);

    /*
     * Assign values to members of stCallbArgs structure which is used
     * to pass input variables to VDIFCallback() and also to return output
     * values back to SetFixedModes(),i.e. this is the way these two routines 
     * exchange data, because callback routines cannot be passed arguments
     * as ordinary functions. Global pointer variable pCallbackArgs is
     * used to pass pointer to stCallbArgs from SetFixedModes to VDIFCallback().
     * In this manner only one global variable is required to transfer 
     * any number of parameters to the callback routine. 
     * 
     */
    stCallbArgs.FreeTables = FreeTables;
    stCallbArgs.NumModes = 0;
    stCallbArgs.EndIndex = EndIndex;
    stCallbArgs.LowBound = 1;
    stCallbArgs.Multiplier = Multiplier;  
    stCallbArgs.HorRes = (BookValues[StartIndex].HDisp + 1) * 8;
    stCallbArgs.VerRes = (((BookValues[StartIndex].VDisp >> 1) & 
                  0x0FFFC) | (BookValues[StartIndex].VDisp & 0x03)) + 1;
    stCallbArgs.PixelDepth = PixelDepth;
    stCallbArgs.Pitch = Pitch;
    stCallbArgs.MaxDotClock = MaxDotClock;
    stCallbArgs.ppFreeTables = ppmode;

    /*
     * Determine which method we should use to find the
     * mode tables corresponding to the monitor. Only the
     * Mach 64 supports DDC, so all non-Mach 64 cards
     * go directly to VDIF files read from disk.
     */
    if (phwDeviceExtension->MergeSource == MERGE_UNKNOWN)
        {
        if (phwDeviceExtension->ModelNumber == MACH64_ULTRA)
            {
            phwDeviceExtension->MergeSource = IsDDCSupported();
            }
        else
            {
            phwDeviceExtension->MergeSource = MERGE_VDIF_FILE;
            VideoDebugPrint((DEBUG_DETAIL, "Not Mach 64, so DDC is not supported\n"));
            }
        }
    

    for (stCallbArgs.Index = StartIndex;
         stCallbArgs.Index <= EndIndex && stCallbArgs.FreeTables > 0; 
                                                  stCallbArgs.Index++)
        {
        HighBound = BookValues[stCallbArgs.Index].Refresh;


        /*
         * If we can use DDC to get mode tables, merge the tables
         * obtained via DDC with our "canned" tables. 
         *
         * If MergeEDIDTables() can't get the mode tables via
         * DDC, it will not fill in any mode tables. For this
         * reason, we use two separate "if" statements rather
         * than an "if/else if" pair.
         */
        if (phwDeviceExtension->MergeSource == MERGE_EDID_DDC)
            {
            if (MergeEDIDTables() != NO_ERROR)
                phwDeviceExtension->MergeSource = MERGE_VDIF_FILE;
            }

        if ((stCallbArgs.LowBound <= HighBound) &&
            (BookValues[stCallbArgs.Index].ClockFreq <= MaxDotClock) &&
            (stCallbArgs.FreeTables > 0) )
            {
            /*
             * Unsuccesful MiniPort Function call to process VDIF file.
             * Fill the next table with this value of Index from
             * BookValues[] 
             */
            BookVgaTable(stCallbArgs.Index, *stCallbArgs.ppFreeTables);
            SetOtherModeParameters(PixelDepth, Pitch, Multiplier, 
                                        *stCallbArgs.ppFreeTables);

            ++ *stCallbArgs.ppFreeTables;  
            ++stCallbArgs.NumModes;  
            --stCallbArgs.FreeTables;
            stCallbArgs.LowBound = BookValues[stCallbArgs.Index].Refresh + 1;
            }
            
        }  /* for(Index in range and space left) */

    return stCallbArgs.NumModes;

}   /* SetFixedModes() */


/***************************************************************************
 *
 * void FillInRegistry(QueryPtr);
 *
 * struct query_structure *QueryPtr;    Pointer to query structure
 *
 * DESCRIPTION:
 *  Fill in the Chip Type, DAC Type, Memory Size, and Adapter String
 *  fields in the registry.
 *
 * GLOBALS CHANGED:
 *  None
 *
 * CALLED BY:
 *  ATIMPInitialize()
 *
 * AUTHOR:
 *  Robert Wolff
 *
 * CHANGE HISTORY:
 *  Robert Wolff 96 04 15
 *  Now identifies specific Mach 64 ASIC types rather than reporting
 *  a single value for all types of Mach 64.
 *
 * TEST HISTORY:
 *
 ***************************************************************************/

void FillInRegistry(struct query_structure *QueryPtr)
{
    PWSTR ChipString;       /* Identification string for the ASIC in use */
    PWSTR DACString;        /* Identification string for the DAC in use */
    PWSTR AdapterString;    /* Identifies this as an ATI accelerator */
    ULONG MemorySize;       /* Number of bytes of accelerator memory */
    ULONG ChipLen;          /* Length of ChipString */
    ULONG DACLen;           /* Length of DACString */
    ULONG AdapterLen;       /* Length of AdapterString */

    /*
     * Report that this is an ATI graphics accelerator.
     */
    AdapterString = L"ATI Graphics Accelerator";
    AdapterLen = sizeof(L"ATI Graphics Accelerator");

    /*
     * Report which of our accelerators is in use.
     */
    switch (QueryPtr->q_asic_rev)
        {
        case CI_38800_1:
            ChipString = L"Mach 8";
            ChipLen = sizeof(L"Mach 8");
            break;

        case CI_68800_3:
            ChipString = L"Mach 32 rev. 3";
            ChipLen = sizeof(L"Mach 32 rev. 3");
            break;

        case CI_68800_6:
            ChipString = L"Mach 32 rev. 6";
            ChipLen = sizeof(L"Mach 32 rev. 6");
            break;

        case CI_68800_UNKNOWN:
            ChipString = L"Mach 32 unknown revision";
            ChipLen = sizeof(L"Mach 32 unknown revision");
            break;

        case CI_68800_AX:
            ChipString = L"Mach 32 AX";
            ChipLen = sizeof(L"Mach 32 AX");
            break;

        case CI_88800_GX:
            ChipString = IdentifyMach64Asic(QueryPtr, &ChipLen);
            break;

        default:
            ChipString = L"Unknown ATI accelerator";
            ChipLen = sizeof(L"Unknown ATI accelerator");
            break;
        }

    /*
     * Report which DAC we are using.
     */
    switch(QueryPtr->q_DAC_type)
        {
        case DAC_ATI_68830:
            DACString = L"ATI 68830";
            DACLen = sizeof(L"ATI 68830");
            break;

        case DAC_SIERRA:
            DACString = L"Sierra SC1148x";
            DACLen = sizeof(L"Sierra SC1148x");
            break;

        case DAC_TI34075:
            DACString = L"TI 34075/ATI 68875";
            DACLen = sizeof(L"TI 34075/ATI 68875");
            break;

        case DAC_BT47x:
            DACString = L"Brooktree BT47x";
            DACLen = sizeof(L"Brooktree BT47x");
            break;

        case DAC_BT48x:
            DACString = L"Brooktree BT48x";
            DACLen = sizeof(L"Brooktree BT48x");
            break;

        case DAC_ATI_68860:
            DACString = L"ATI 68860";
            DACLen = sizeof(L"ATI 68860");
            break;

        case DAC_STG1700:
            DACString = L"S.G. Thompson STG170x";
            DACLen = sizeof(L"S.G. Thompson STG170x");
            break;

        case DAC_SC15021:
            DACString = L"Sierra SC15021";
            DACLen = sizeof(L"Sierra SC15021");
            break;

        case DAC_ATT491:
            DACString = L"AT&&T 49[123]";
            DACLen = sizeof(L"AT&&T 49[123]");
            break;

        case DAC_ATT498:
            DACString = L"AT&&T 498";
            DACLen = sizeof(L"AT&&T 498");
            break;

        case DAC_SC15026:
            DACString = L"Sierra SC15026";
            DACLen = sizeof(L"Sierra SC15026");
            break;

        case DAC_TVP3026:
            DACString = L"Texas Instruments TVP3026";
            DACLen = sizeof(L"Texas Instruments TVP3026");
            break;

        case DAC_IBM514:
            DACString = L"IBM RGB514";
            DACLen = sizeof(L"IBM RGB514");
            break;

        case DAC_STG1702:
            DACString = L"S.G. Thompson STG1702/1703";
            DACLen = sizeof(L"S.G. Thompson STG1702/1703");
            break;

        case DAC_STG1703:
            DACString = L"S.G. Thompson STG1703";
            DACLen = sizeof(L"S.G. Thompson STG1703");
            break;

        case DAC_CH8398:
            DACString = L"Chrontel CH8398";
            DACLen = sizeof(L"Chrontel CH8398");
            break;

        case DAC_ATT408:
            DACString = L"AT&&T 408";
            DACLen = sizeof(L"AT&&T 408");
            break;

        case DAC_INTERNAL_CT:
        case DAC_INTERNAL_GT:
        case DAC_INTERNAL_VT:
            DACString = L"DAC built into ASIC";
            DACLen = sizeof(L"DAC built into ASIC");
            break;

        default:
            DACString = L"Unknown DAC type";
            DACLen = sizeof(L"Unknown DAC type");
            break;
        }

    /*
     * Report the amount of accelerator memory. On Mach 8
     * combo cards, the q_memory_size field includes VGA-only
     * memory which the accelerator can't access. On all
     * other cards, it reports accelerator-accessible memory.
     */
    if (phwDeviceExtension->ModelNumber == GRAPHICS_ULTRA)
        {
        switch (QueryPtr->q_memory_size)
            {
            case VRAM_768k:     /* 512k accelerator/256k VGA */
            case VRAM_1mb:      /* 512k accelerator/512k VGA */
                MemorySize = HALF_MEG;
                break;

            case VRAM_1_25mb:   /* 1M accelerator/256k VGA */
            case VRAM_1_50mb:   /* 1M accelerator/512k VGA */
                MemorySize = ONE_MEG;
                break;

            default:            /* Should never happen */
                VideoDebugPrint((DEBUG_ERROR, "Non-production Mach 8 combo\n"));
                MemorySize = ONE_MEG;
                break;
            }
        }
    else
        {
        MemorySize = QueryPtr->q_memory_size * QUARTER_MEG;
        }


    /*
     * Write the information to the registry.
     */
    VideoPortSetRegistryParameters(phwDeviceExtension,
                                   L"HardwareInformation.ChipType",
                                   ChipString,
                                   ChipLen);

    VideoPortSetRegistryParameters(phwDeviceExtension,
                                   L"HardwareInformation.DacType",
                                   DACString,
                                   DACLen);

    VideoPortSetRegistryParameters(phwDeviceExtension,
                                   L"HardwareInformation.MemorySize",
                                   &MemorySize,
                                   sizeof(ULONG));

    VideoPortSetRegistryParameters(phwDeviceExtension,
                                   L"HardwareInformation.AdapterString",
                                   AdapterString,
                                   AdapterLen);

    return;

}   /* FillInRegistry() */




/*
 * PVOID MapFramebuffer(StartAddress, Size);
 *
 * ULONG StartAddress;  Physical address of start of framebuffer
 * long Size;           Size of framebuffer in bytes
 *
 * Map the framebuffer into Windows NT's address space.
 *
 * Returns:
 *  Pointer to start of framebuffer if successful
 *  Zero if unable to map the framebuffer
 */
PVOID MapFramebuffer(ULONG StartAddress, long Size)
{
    VIDEO_ACCESS_RANGE  FramebufferData;

    FramebufferData.RangeLength = Size;
    FramebufferData.RangeStart.LowPart = StartAddress;
    FramebufferData.RangeStart.HighPart = 0;
    FramebufferData.RangeInIoSpace = 0;
    FramebufferData.RangeVisible = 0;

    return VideoPortGetDeviceBase(phwDeviceExtension,
                    FramebufferData.RangeStart,
                    FramebufferData.RangeLength,
                    FramebufferData.RangeInIoSpace);

}   /* MapFrameBuffer() */




/**************************************************************************
 *
 * unsigned short *Get_BIOS_Seg(void);
 *
 * DESCRIPTION:
 *  Verify BIOS presence and return BIOS segment
 *  Check for ATI Video BIOS, by checking for product signature
 *  near beginning of BIOS segment.  It should be ASCII string  "761295520"
 *
 * RETURN VALUE:
 *  Segment of BIOS code. If multiple ATI Video BIOS segments are
 *  found, return the highest one (probable cause: VGAWonder and
 *  8514/ULTRA, this will return the BIOS segment for the 8514/ULTRA).
 *
 *  If no ATI video BIOS segment is found, returns FALSE.
 *
 * GLOBALS CHANGED:
 *  none
 *
 * CALLED BY:
 *  ATIMPFindAdapter(), DetectMach64()
 *
 **************************************************************************/

unsigned short *Get_BIOS_Seg(void)
{
    /*
     * Offset of the start of the video BIOS segment
     * from the start of the BIOS area
     */
    long SegmentOffset;
    PUCHAR SegmentStart;    /* Start address of the BIOS segment being tested */
    ULONG SigOffset;        /* Offset of signature string from start of BIOS segment */
    ULONG SigLoop;          /* Counter to check for match */
    BOOL SigFound;          /* Whether or not the signature string was found */


    /*
     * Try to allocate the block of address space where the BIOS
     * is found. If we can't, report that we didn't find the BIOS.
     */
    if ((phwDeviceExtension->RomBaseRange =
        VideoPortGetDeviceBase(phwDeviceExtension,
            RawRomBaseRange.RangeStart,
            RawRomBaseRange.RangeLength,
            RawRomBaseRange.RangeInIoSpace)) == NULL)
        {
        VideoDebugPrint((DEBUG_NORMAL, "Get_BIOS_Seg() can't allocate BIOS address range, assuming no BIOS\n"));
        return FALSE;
        }

    /*
     * For each candidate for the start of the video BIOS segment,
     * check to see if it is the start of a BIOS segment. Start at
     * the top and work down because if the system contains both a
     * VGAWonder and an 8514/ULTRA, the 8514/ULTRA BIOS will be at
     * a higher address than the VGAWonder BIOS, and we want to get
     * information from the 8514/ULTRA BIOS.
     */
    for (SegmentOffset = MAX_BIOS_START; SegmentOffset >= 0; SegmentOffset -= ROM_GRANULARITY)
        {
        SegmentStart = (PUCHAR)phwDeviceExtension->RomBaseRange + SegmentOffset;

        /*
         * If this candidate does not begin with the "start of BIOS segment"
         * identifier, then it is not the start of the video BIOS segment.
         */
        if (VideoPortReadRegisterUshort((PUSHORT)SegmentStart) == VIDEO_ROM_ID)
            {
            /*
             * We've found the start of a BIOS segment. Search through
             * the range of offsets from the start of the segment where
             * the ATI signature string can start. If we find it,
             * then we know that this is the video BIOS segment.
             */
            for (SigOffset = SIG_AREA_START; SigOffset <= SIG_AREA_END; SigOffset++)
                {
                /*
                 * If the first character of the signature string isn't at the
                 * current offset into the segment, then we haven't found the
                 * signature string yet.
                 */
                if (VideoPortReadRegisterUchar(SegmentStart + SigOffset) != ati_signature[0])
                    continue;

                /*
                 * We have found the first character of the signature string. Scan
                 * through the following characters to see if they contain the
                 * remainder of the signature string. If, before we reach the
                 * null terminator on the test string, we find a character that
                 * does not match the test string, then what we thought was the
                 * signature string is actually unrelated data that happens to
                 * match the first few characters.
                 */
                SigFound = TRUE;
                for (SigLoop = 1; ati_signature[SigLoop] != 0; SigLoop++)
                    {
                    if (VideoPortReadRegisterUchar(SegmentStart + SigOffset + SigLoop) != ati_signature[SigLoop])
                        {
                        SigFound = FALSE;
                        continue;
                        }
                    }   /* end for (checking for entire signature string) */

                /*
                 * We have found the entire signature string.
                 */
                if (SigFound == TRUE)
                    {
                    VideoDebugPrint((DEBUG_NORMAL, "Get_BIOS_Seg() found the BIOS signature string\n"));
                    return (unsigned short *)SegmentStart;
                    }

                }   /* end for (checking BIOS segment for signature string) */

            }   /* end if (a BIOS segment starts here) */

        }   /* end for (check each possible BIOS start address) */

    /*
     * We have checked all the candidates for the start of the BIOS segment,
     * and none contained the signature string.
     */
    VideoDebugPrint((DEBUG_NORMAL, "Get_BIOS_Seg() didn't find the BIOS signature string\n"));
    return FALSE;

}   /* Get_BIOS_Seg() */




/***************************************************************************
 *
 * void UpperCase(TxtString);
 *
 * PUCHAR TxtString;        Text string to process
 *
 * DESCRIPTION:
 *  Convert a null-terminated string to uppercase. This function wouldn't
 *  be necessary if strupr() were available in all versions of the
 *  NT build environment.
 *
 * GLOBALS CHANGED:
 *  None, but the contents of the buffer are overwritten.
 *
 * CALLED BY:
 *  This function may be called by any routine.
 *
 * AUTHOR:
 *  Robert Wolff
 *
 * CHANGE HISTORY:
 *
 * TEST HISTORY:
 *
 ***************************************************************************/

void UpperCase(PUCHAR TxtString)
{
    PUCHAR CurrentChar;         /* Current character being processed */

    CurrentChar = TxtString;

    /*
     * Continue until we encounter the null terminator.
     */
    while (*CurrentChar != '\0')
        {
        /*
         * If the current character is a lower case letter,
         * convert it to upper case. Don't change any characters
         * that aren't lower case letters.
         */
        if ((*CurrentChar >= 'a') && (*CurrentChar <= 'z'))
            *CurrentChar -= ('a' - 'A');

        CurrentChar++;
        }

    return;

}   /* UpperCase() */



/***************************************************************************
 *
 * PUCHAR GetVgaBuffer(Size, Offset, Segment, SaveBuffer);
 *
 * ULONG Size;          Size of the buffer in bytes
 * ULONG Offset;        How far into the VGA segment we want
 *                      the buffer to start
 * PULONG Segment;      Pointer to storage location for the segment
 *                      where the buffer is located
 * PUCHAR SaveBuffer;   Pointer to temporary storage location where the
 *                      original contents of the buffer are to be saved,
 *                      NULL if there is no need to save the original
 *                      contents of the buffer.
 *
 * DESCRIPTION:
 *  Map a buffer of a specified size at a specified offset (must be
 *  a multiple of 16 bytes) into VGA memory. If desired, the original
 *  contents of the buffer are saved. This function tries the 3 VGA
 *  apertures in the following order - colour text screen, mono text
 *  screen, graphics screen - until it finds one where we can place
 *  the buffer. If we can't map the desired buffer, we return failure
 *  rather than forcing a mode set to create the buffer. On return,
 *  *Segment:0 is the physical address of the start of the buffer
 *  (this is why Offset must be a multiple of 16 bytes).
 *
 *  This function is used to find a buffer below 1 megabyte physical,
 *  since some of the Mach 64 BIOS routines require a buffer in this
 *  region. If future versions of Windows NT add a function which can
 *  give us a buffer below 1 megabyte physical, such a routine would
 *  be preferable to using VGA memory as the buffer.
 *
 * RETURN VALUE:
 *  Pointer to start of buffer if successful
 *  Zero if unable to obtain a buffer
 *
 * NOTE
 *  If zero is returned, the values returned in Segment and SaveBuffer
 *  are undefined.
 *
 *  On VGA text screens (colour and mono), we try to use the offscreen
 *  portion of video memory.
 *
 * GLOBALS CHANGED:
 *  None
 *
 * CALLED BY:
 *  This function may be called by any routine, so long as the entry
 *  point resulting in the call is ATIMPInitialize() or ATIMPStartIO().
 *
 * AUTHOR:
 *  Robert Wolff
 *
 * CHANGE HISTORY:
 *
 * TEST HISTORY:
 *
 ***************************************************************************/

PUCHAR GetVgaBuffer(ULONG Size, ULONG Offset, PULONG Segment, PUCHAR SaveBuffer)
{
    PUCHAR MappedBuffer;                /* Pointer to buffer under test */
    ULONG BufferSeg;                    /* Segment to use for buffer */
    ULONG Scratch;                      /* Temporary variable */

    /*
     * Check for a valid offset.
     */
    if (Offset & 0x0000000F)
        {
        VideoDebugPrint((DEBUG_ERROR, "GetVgaBuffer() - Offset must be a multiple of 16\n"));
        return 0;
        }

    BufferSeg = 0x0BA00 + Offset;           /* Colour text */
    MappedBuffer = MapFramebuffer((BufferSeg << 4), Size);
    if (MappedBuffer != 0)
        {
        if (SaveBuffer != NULL)
            {
            for (Scratch = 0; Scratch < Size; Scratch++)
                SaveBuffer[Scratch] = VideoPortReadRegisterUchar(&(MappedBuffer[Scratch]));
            }
        if (IsBufferBacked(MappedBuffer, Size) == FALSE)
            {
            VideoDebugPrint((DEBUG_NORMAL, "Colour text screen not backed by physical memory\n"));
            VideoPortFreeDeviceBase(phwDeviceExtension, MappedBuffer);
            MappedBuffer = 0;
            }
        }
    else
        {
        VideoDebugPrint((DEBUG_NORMAL, "Can't map colour text screen\n"));
        }

    /*
     * If we were unable to allocate a large enough buffer in the
     * colour text screen, try the monochrome text screen.
     */
    if (MappedBuffer == 0)
        {
        VideoDebugPrint((DEBUG_NORMAL, "Can't use colour text screen, trying monochrome text screen\n"));
        BufferSeg = 0x0B200 + Offset;
        if ((MappedBuffer = MapFramebuffer((BufferSeg << 4), Size)) != 0)
            {
            if (SaveBuffer != NULL)
                {
                for (Scratch = 0; Scratch < Size; Scratch++)
                    SaveBuffer[Scratch] = VideoPortReadRegisterUchar(&(MappedBuffer[Scratch]));
                }
            if (IsBufferBacked(MappedBuffer, Size) == FALSE)
                {
                VideoDebugPrint((DEBUG_NORMAL, "Monochrome text screen not backed by physical memory\n"));
                VideoPortFreeDeviceBase(phwDeviceExtension, MappedBuffer);
                MappedBuffer = 0;
                }
            }
        else
            {
            VideoDebugPrint((DEBUG_NORMAL, "Can't map monochrome text screen\n"));
            }
        }

    /*
     * If we were unable to allocate a large enough buffer in either of
     * the text screens, try the VGA graphics screen.
     */
    if (MappedBuffer == 0)
        {
        VideoDebugPrint((DEBUG_NORMAL, "Can't use monochrome text screen, trying graphics screen\n"));
        BufferSeg = 0x0A000 + Offset;
        if ((MappedBuffer = MapFramebuffer((BufferSeg << 4), Size)) == 0)
            {
            VideoDebugPrint((DEBUG_ERROR, "Can't map graphics screen - aborting DDC query\n"));
            return 0;
            }

        if (SaveBuffer != NULL)
            {
            for (Scratch = 0; Scratch < Size; Scratch++)
                SaveBuffer[Scratch] = VideoPortReadRegisterUchar(&(MappedBuffer[Scratch]));
            }

        if (IsBufferBacked(MappedBuffer, Size) == FALSE)
            {
            VideoDebugPrint((DEBUG_ERROR, "Graphics screen not backed by memory - aborting\n"));
            VideoPortFreeDeviceBase(phwDeviceExtension, MappedBuffer);
            return 0;
            }
        }

    /*
     * Report the segment where we found the buffer.
     */
    *Segment = BufferSeg;

    return MappedBuffer;

}   /* GetVgaBuffer() */




/*
 * Low level Input/Output routines. These are not needed on an MS-DOS
 * platform because the standard inp<size>() and outp<size>() routines
 * are available.
 */

/*
 * UCHAR LioInp(Port, Offset);
 *
 * int Port;    Register to read from
 * int Offset;  Offset into desired register
 *
 * Read an unsigned character from a given register. Works with both normal
 * I/O ports and memory-mapped registers. Offset is zero for 8 bit registers
 * and the least significant byte of 16 and 32 bit registers, 1 for the
 * most significant byte of 16 bit registers and the second least significant
 * byte of 32 bit registers, up to 3 for the most significant byte of 32 bit
 * registers.
 *
 * Returns:
 *  Value held in the register.
 */
UCHAR LioInp(int Port, int Offset)
{
    if (phwDeviceExtension->aVideoAddressMM[Port] != 0)
        {
        /*
         * In early versions of Windows NT, VideoPort[Read|Write]Register<size>()
         * didn't work properly, but these routines are preferable to
         * direct pointer read/write for versions where they do work.
         *
         * On the DEC Alpha, these routines no longer work for memory
         * in dense space as of NT 4.0, so we must revert to the old
         * method. Microsoft doesn't like this, but until DEC fixes
         * the HAL there's nothing else we can do. All Alpha machines
         * with PCI bus support dense space, but some older (Jensen)
         * systems only support sparse space. Since these systems have
         * only an EISA bus, we use the bus type of the card to determine
         * whether to use dense or sparse memory space (PCI cards can
         * use dense space since all machines with PCI buses support
         * it, ISA cards may be in either an older or a newer machine,
         * so they must use sparse space, no Alpha machines support
         * VLB, and there are no EISA Mach 64 cards).
         */
#if (TARGET_BUILD < 350)
        return *(PUCHAR)((PUCHAR)(phwDeviceExtension->aVideoAddressMM[Port]) + Offset);
#else
#if ((defined (ALPHA) || defined(_ALPHA_)) && (TARGET_BUILD >= 400))
        if (((struct query_structure *)phwDeviceExtension->CardInfo)->q_bus_type == BUS_PCI)
            return *(PUCHAR)((PUCHAR)(phwDeviceExtension->aVideoAddressMM[Port]) + Offset);
        else
#endif
        return VideoPortReadRegisterUchar ((PUCHAR)(((PHW_DEVICE_EXTENSION)phwDeviceExtension)->aVideoAddressMM[Port]) + Offset);
#endif
        }
    else
        {
        return VideoPortReadPortUchar ((PUCHAR)(((PHW_DEVICE_EXTENSION)phwDeviceExtension)->aVideoAddressIO[Port]) + Offset);
        }
}



/*
 * USHORT LioInpw(Port, Offset);
 *
 * int Port;    Register to read from
 * int Offset;  Offset into desired register
 *
 * Read an unsigned short integer from a given register. Works with both
 * normal I/O ports and memory-mapped registers. Offset is either zero for
 * 16 bit registers and the least significant word of 32 bit registers, or
 * 2 for the most significant word of 32 bit registers.
 *
 * Returns:
 *  Value held in the register.
 */
USHORT LioInpw(int Port, int Offset)
{
    if (phwDeviceExtension->aVideoAddressMM[Port] != 0)
        {
#if (TARGET_BUILD < 350)
        return *(PUSHORT)((PUCHAR)(phwDeviceExtension->aVideoAddressMM[Port]) + Offset);
#else
#if ((defined (ALPHA) || defined(_ALPHA_)) && (TARGET_BUILD >= 400))
        if (((struct query_structure *)phwDeviceExtension->CardInfo)->q_bus_type == BUS_PCI)
            return *(PUSHORT)((PUCHAR)(phwDeviceExtension->aVideoAddressMM[Port]) + Offset);
        else
#endif
        return VideoPortReadRegisterUshort ((PUSHORT)((PUCHAR)(((PHW_DEVICE_EXTENSION)phwDeviceExtension)->aVideoAddressMM[Port]) + Offset));
#endif
        }
    else
        {
        return VideoPortReadPortUshort ((PUSHORT)((PUCHAR)(((PHW_DEVICE_EXTENSION)phwDeviceExtension)->aVideoAddressIO[Port]) + Offset));
        }
}



/*
 * ULONG LioInpd(Port);
 *
 * int Port;    Register to read from
 *
 * Read an unsigned long integer from a given register. Works with both
 * normal I/O ports and memory-mapped registers.
 *
 * Returns:
 *  Value held in the register.
 */
ULONG LioInpd(int Port)
{
    if (phwDeviceExtension->aVideoAddressMM[Port] != 0)
        {
#if (TARGET_BUILD < 350)
        return *(PULONG)((PUCHAR)(phwDeviceExtension->aVideoAddressMM[Port]));
#else
#if ((defined (ALPHA) || defined(_ALPHA_)) && (TARGET_BUILD >= 400))
        if (((struct query_structure *)phwDeviceExtension->CardInfo)->q_bus_type == BUS_PCI)
            return *(PULONG)((PUCHAR)(phwDeviceExtension->aVideoAddressMM[Port]));
        else
#endif
        return VideoPortReadRegisterUlong (((PHW_DEVICE_EXTENSION)phwDeviceExtension)->aVideoAddressMM[Port]);
#endif
        }
    else
        {
        return VideoPortReadPortUlong (((PHW_DEVICE_EXTENSION)phwDeviceExtension)->aVideoAddressIO[Port]);
        }
}



/*
 * VOID LioOutp(Port, Data, Offset);
 *
 * int Port;    Register to write to
 * UCHAR Data;  Data to write
 * int Offset;  Offset into desired register
 *
 * Write an unsigned character to a given register. Works with both normal
 * I/O ports and memory-mapped registers. Offset is zero for 8 bit registers
 * and the least significant byte of 16 and 32 bit registers, 1 for the
 * most significant byte of 16 bit registers and the second least significant
 * byte of 32 bit registers, up to 3 for the most significant byte of 32 bit
 * registers.
 */
VOID LioOutp(int Port, UCHAR Data, int Offset)
{
    if (phwDeviceExtension->aVideoAddressMM[Port] != 0)
        {
#if (TARGET_BUILD < 350)
        *(PUCHAR)((PUCHAR)(phwDeviceExtension->aVideoAddressMM[Port]) + Offset) = Data;
#else
#if ((defined (ALPHA) || defined(_ALPHA_)) && (TARGET_BUILD >= 400))
        if (((struct query_structure *)phwDeviceExtension->CardInfo)->q_bus_type == BUS_PCI)
            *(PUCHAR)((PUCHAR)(phwDeviceExtension->aVideoAddressMM[Port]) + Offset) = Data;
        else
#endif
        VideoPortWriteRegisterUchar ((PUCHAR)(phwDeviceExtension->aVideoAddressMM[Port]) + Offset, (BYTE)(Data));
#endif
        }
    else
        {
        VideoPortWritePortUchar ((PUCHAR)(phwDeviceExtension->aVideoAddressIO[Port]) + Offset, (BYTE)(Data));
        }

    return;
}



/*
 * VOID LioOutpw(Port, Data, Offset);
 *
 * int Port;    Register to write to
 * USHORT Data; Data to write
 * int Offset;  Offset into desired register
 *
 * Write an unsigned short integer to a given register. Works with both
 * normal I/O ports and memory-mapped registers. Offset is either zero for
 * 16 bit registers and the least significant word of 32 bit registers, or
 * 2 for the most significant word of 32 bit registers.
 */
VOID LioOutpw(int Port, USHORT Data, int Offset)
{
    if (phwDeviceExtension->aVideoAddressMM[Port] != 0)
        {
#if (TARGET_BUILD < 350)
        *(PUSHORT)((PUCHAR)(phwDeviceExtension->aVideoAddressMM[Port]) + Offset) = (WORD)(Data);
#else
#if ((defined (ALPHA) || defined(_ALPHA_)) && (TARGET_BUILD >= 400))
        if (((struct query_structure *)phwDeviceExtension->CardInfo)->q_bus_type == BUS_PCI)
            *(PUSHORT)((PUCHAR)(phwDeviceExtension->aVideoAddressMM[Port]) + Offset) = Data;
        else
#endif
        VideoPortWriteRegisterUshort ((PUSHORT)((PUCHAR)(phwDeviceExtension->aVideoAddressMM[Port]) + Offset), (WORD)(Data));
#endif
        }
    else
        {
        VideoPortWritePortUshort ((PUSHORT)((PUCHAR)(phwDeviceExtension->aVideoAddressIO[Port]) + Offset), (WORD)(Data));
        }

    return;
}



/*
 * VOID LioOutpd(Port, Data);
 *
 * int Port;    Register to write to
 * ULONG Data;  Data to write
 *
 * Write an unsigned long integer to a given register. Works with both
 * normal I/O ports and memory-mapped registers.
 */
VOID LioOutpd(int Port, ULONG Data)
{
    if (phwDeviceExtension->aVideoAddressMM[Port] != 0)
        {
#if (TARGET_BUILD < 350)
        *(PULONG)((PUCHAR)(phwDeviceExtension->aVideoAddressMM[Port])) = (ULONG)(Data);
#else
#if ((defined (ALPHA) || defined(_ALPHA_)) && (TARGET_BUILD >= 400))
        if (((struct query_structure *)phwDeviceExtension->CardInfo)->q_bus_type == BUS_PCI)
            *(PULONG)((PUCHAR)(phwDeviceExtension->aVideoAddressMM[Port])) = Data;
        else
#endif
        VideoPortWriteRegisterUlong (phwDeviceExtension->aVideoAddressMM[Port], Data);
#endif
        }
    else
        {
        VideoPortWritePortUlong (phwDeviceExtension->aVideoAddressIO[Port], Data);
        }

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\ati\mini\query_m.h ===
/************************************************************************/
/*                                                                      */
/*                              QUERY_M.H                               */
/*                                                                      */
/*       Sept 07  1993 (c) 1993, ATI Technologies Incorporated.         */
/************************************************************************/

/**********************       PolyTron RCS Utilities
   
  $Revision:   1.4  $
      $Date:   30 Jun 1994 18:20:40  $
	$Author:   RWOLFF  $
	   $Log:   S:/source/wnt/ms11/miniport/vcs/query_m.h  $
 * 
 *    Rev 1.4   30 Jun 1994 18:20:40   RWOLFF
 * Removed prototype for IsApertureConflict_m() (routine moved to SETUP_M.C).
 * 
 *    Rev 1.3   27 Apr 1994 13:54:02   RWOLFF
 * Added prototype for IsMioBug_m()
 * 
 *    Rev 1.2   03 Mar 1994 12:41:16   ASHANMUG
 * Remove some get memory need stuff
 * 
 *    Rev 1.4   14 Jan 1994 15:25:58   RWOLFF
 * Added prototype for BlockWriteAvail_m()
 * 
 *    Rev 1.3   30 Nov 1993 18:29:04   RWOLFF
 * Removed defined values which were no longer used.
 * 
 *    Rev 1.2   10 Nov 1993 19:22:46   RWOLFF
 * Added definitions used by new way of checking memory size.
 * 
 *    Rev 1.1   08 Oct 1993 11:15:20   RWOLFF
 * Added prototype for new function.
 * 
 *    Rev 1.0   24 Sep 1993 11:52:50   RWOLFF
 * Initial revision.

End of PolyTron RCS section                             *****************/

#ifdef DOC
QUERY_M.H - Header file for QUERY_M.C

#endif


/*
 * Prototypes for functions provided by QUERY_M.C
 */
extern VP_STATUS    QueryMach32 (struct query_structure *, BOOL);
extern VP_STATUS    Query8514Ultra (struct query_structure *);
extern VP_STATUS    QueryGUltra (struct query_structure *);
extern long         GetMemoryNeeded_m(long XPixels,
                                      long YPixels,
                                      long ColourDepth,
                                      struct query_structure *QueryPtr);
extern BOOL         BlockWriteAvail_m(struct query_structure *);
extern BOOL         IsMioBug_m(struct query_structure *);


#ifdef INCLUDE_QUERY_M
/*
 * Private definitions used in QUERY_M.C
 */
#define SETUP_ENGINE    0
#define RESTORE_ENGINE  1

/*
 * Bit pattern which is extremely unlikely to show up when reading
 * from nonexistant memory (which normally shows up as either all
 * bits set or all bits clear).
 */
#define TEST_COLOUR     0x05AA5

#endif  /* defined INCLUDE_QUERY_M */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\ati\mini\services.h ===
/************************************************************************/
/*                                                                      */
/*                              SERVICES.H                              */
/*                                                                      */
/*        Aug 26  1993 (c) 1993, ATI Technologies Incorporated.         */
/************************************************************************/

/**********************       PolyTron RCS Utilities
   
  $Revision:   1.9  $
      $Date:   02 Feb 1996 17:22:20  $
	$Author:   RWolff  $
	   $Log:   S:/source/wnt/ms11/miniport/archive/services.h_v  $
 * 
 *    Rev 1.9   02 Feb 1996 17:22:20   RWolff
 * Added prototype for new routine GetVgaBuffer().
 * 
 *    Rev 1.8   11 Jan 1996 19:45:02   RWolff
 * SetFixedModes() now restricts modes based on pixel clock frequency.
 * 
 *    Rev 1.7   20 Jul 1995 18:01:16   mgrubac
 * Added support for VDIF files.
 * 
 *    Rev 1.6   02 Jun 1995 14:34:06   RWOLFF
 * Added prototype for UpperCase().
 * 
 *    Rev 1.5   23 Dec 1994 10:48:14   ASHANMUG
 * ALPHA/Chrontel-DAC
 * 
 *    Rev 1.4   19 Aug 1994 17:14:34   RWOLFF
 * Added support for non-standard pixel clock generators.
 * 
 *    Rev 1.3   20 Jul 1994 13:01:36   RWOLFF
 * Added prototype for new routine FillInRegistry().
 * 
 *    Rev 1.2   12 May 1994 11:05:06   RWOLFF
 * Prototype and definitions for new function SetFixedModes()
 * 
 *    Rev 1.1   26 Apr 1994 12:35:44   RWOLFF
 * Added prototype for ISAPitchAdjust()
 * 
 *    Rev 1.0   31 Jan 1994 11:49:22   RWOLFF
 * Initial revision.
 * 
 *    Rev 1.3   24 Jan 1994 18:10:24   RWOLFF
 * Added prototype for new routine TripleClock().
 * 
 *    Rev 1.2   15 Dec 1993 15:32:16   RWOLFF
 * Added prototype for new clock multiplier routine.
 * 
 *    Rev 1.1   05 Nov 1993 13:27:50   RWOLFF
 * Headers for new routines in SERVICES.C, added array of pixel clock
 * frequencies (initialized for 18811-1 clock chip, may be changed by other
 * routines for other clock chips).
 * 
 *    Rev 1.0   03 Sep 1993 14:29:06   RWOLFF
 * Initial revision.

End of PolyTron RCS section                             *****************/

#ifdef DOC
SERVICES.H - Header file for SERVICES.C

#endif

/*
 * Global definitions used in detecting card capabilities.
 */
#define VIDEO_ROM_ID    0x0AA55     /* Found at start of any BIOS block */

/*
 * Permitted values for clock multiplication at high pixel depths.
 */
enum {
    CLOCK_SINGLE = 1,
    CLOCK_THREE_HALVES,
    CLOCK_DOUBLE,
    CLOCK_TRIPLE
    };

/*
 * Prototypes for functions supplied by SERVICES.C
 */
extern void short_delay (void);
extern void delay(int);
extern BOOL IsBufferBacked(PUCHAR StartAddress, ULONG Size);
extern UCHAR DoubleClock(UCHAR ClockSelector);
extern UCHAR ThreeHalvesClock(UCHAR ClockSelector);
extern UCHAR TripleClock(UCHAR ClockSelector);
extern ULONG GetFrequency(UCHAR ClockSelector);
extern UCHAR GetSelector(ULONG *Frequency);
extern UCHAR GetShiftedSelector(ULONG Frequency);
extern void ISAPitchAdjust(struct query_structure *QueryPtr);
extern WORD SetFixedModes(WORD StartIndex,
                          WORD EndIndex,
                          WORD Multiplier,
                          WORD PixelDepth,
                          WORD Pitch,
                          short FreeTables,
                          ULONG MaxDotClock,
                          struct st_mode_table **ppmode);
extern void FillInRegistry(struct query_structure *QueryPtr);

extern PVOID MapFramebuffer(ULONG StartAddress, long Size);

extern unsigned short *Get_BIOS_Seg(void);
extern void UpperCase(PUCHAR TxtString);
extern PUCHAR GetVgaBuffer(ULONG Size, ULONG Offset, PULONG Segment, PUCHAR SaveBuffer);

extern UCHAR LioInp(int Port, int Offset);
extern USHORT LioInpw(int Port, int Offset);
extern ULONG LioInpd(int Port);
extern VOID LioOutp(int Port, UCHAR Data, int Offset);
extern VOID LioOutpw(int Port, USHORT Data, int Offset);
extern VOID LioOutpd(int Port, ULONG Data);

#ifdef INCLUDE_SERVICES
/*
 * Definitions and variables used in SERVICES.C
 */

/*
 * The following definitions are used in finding the video BIOS segment.
 */
#define ISA_ROM_BASE        0xC0000 /* Lowest address where BIOS can be found */
#define ROM_LOOK_SIZE       0x40000 /* Size of block where BIOS can be found */
#define ROM_GRANULARITY     0x00800 /* BIOS starts on a 2k boundary */
/*
 * Offset from ISA_ROM_BASE of highest possible start of video BIOS segment
 */
#define MAX_BIOS_START      ROM_LOOK_SIZE - ROM_GRANULARITY
/*
 * The ATI signature string will start at an offset into the video BIOS
 * segment no less than SIG_AREA_START and no greater than SIG_AREA_END.
 */
#define SIG_AREA_START      0x30
#define SIG_AREA_END        0x80

/*
 * ROM block containing ATI Graphics product signature,
 * extended base address, and ASIC chip revision
 */
VIDEO_ACCESS_RANGE RawRomBaseRange = {
    ISA_ROM_BASE, 0, ROM_LOOK_SIZE, FALSE, FALSE, FALSE
    };

/*
 * Clock selector and divisor as used by DoubleClock(). These do not
 * match the divisor ans selector masks in the CLOCK_SEL register.
 */
#define SELECTOR_MASK   0x0F
#define DIVISOR_MASK    0x10
#define DIVISOR_SHIFT   4       /* Bits to shift divisor before ORing with selector */

/*
 * Frequencies (in hertz) produced by the clock generator for
 * each select value. External clock values should be set to 0
 * (won't match anything).
 */
ULONG ClockGenerator[16] =
{
    100000000L,
    126000000L,
     92400000L,
     36000000L,
     50350000L,
     56640000L,
            0L,
     44900000L,
    135000000L,
     32000000L,
    110000000L,
     80000000L,
     39910000L,
     44900000L,
     75000000L,
     65000000L
};

/*
 * Frequency tolerance (in hertz) used by GetSelector().
 * Any selector/divisor pair which produces a frequency
 * within FREQ_TOLERANCE of the input is considered a match.
 */
#define FREQ_TOLERANCE  100000L

#else   /* Not defined INCLUDE_SERVICES */

extern ULONG ClockGenerator[16];

#endif  /* defined INCLUDE_SERVICES */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\ati\mini\setup_cx.c ===
/************************************************************************/
/*                                                                      */
/*                              SETUP_CX.C                              */
/*                                                                      */
/*        Aug 27  1993 (c) 1993, ATI Technologies Incorporated.         */
/************************************************************************/

/**********************       PolyTron RCS Utilities
   
  $Revision:   1.21  $
      $Date:   15 May 1996 16:36:04  $
	$Author:   RWolff  $
	   $Log:   S:/source/wnt/ms11/miniport/archive/setup_cx.c_v  $
 * 
 *    Rev 1.21   15 May 1996 16:36:04   RWolff
 * Now records in registry if we have to cut back on BIOS claim
 * size (conflict with SCSI card having BIOS segment below 0xD000:0000)
 * so we only get event log messages on the first boot, rather
 * than on every boot.
 * 
 *    Rev 1.20   03 May 1996 15:16:42   RWolff
 * Made new temporary variable conditional on platform type to avoid
 * warning when compiling for non-Alpha platforms.
 * 
 *    Rev 1.19   03 May 1996 14:07:26   RWolff
 * Fixed drawing problem with GX-F ASIC on DEC Alpha.
 * 
 *    Rev 1.18   15 Apr 1996 13:51:30   RWolff
 * Fallback to claiming 32k of BIOS if we can't get the full 64k, to avoid
 * conflict with Adaptec 154x adapters with their BIOS segment set to
 * 0xC800:0000 or 0xCC00:0000
 * 
 *    Rev 1.17   29 Jan 1996 17:01:56   RWolff
 * Now uses VideoPortInt10() rather than no-BIOS code on PPC, now
 * rejects exhaustive list of non-Mach 64 cards and accepts all
 * others when looking for block I/O cards, rather than accepting
 * exhaustive list of Mach 64 cards and rejecting all others.
 * 
 *    Rev 1.16   23 Jan 1996 17:52:16   RWolff
 * Added GT to list of Mach 64 cards capable of supporting block I/O.
 * 
 *    Rev 1.15   23 Jan 1996 11:49:38   RWolff
 * Eliminated level 3 warnings, added debug print statements, removed
 * conditionally-compilec code to use VideoPortGetAccessRanges() to
 * find block I/O cards, since this function remaps the I/O base address
 * and this is incompatible with the use of INT 10.
 * 
 *    Rev 1.14   12 Jan 1996 11:18:50   RWolff
 * Reduced size of buffer requested through VideoPortGetBusData()
 * 
 *    Rev 1.13   23 Nov 1995 11:31:42   RWolff
 * Now searches each PCI slot for our cards, rather than using
 * VideoPortGetAccessRanges(), since that routine won't detect
 * block-relocatable GX-F2s properly. This change is not sanctioned
 * by Microsoft, and must be backed out if they fix their routine.
 * 
 *    Rev 1.12   24 Aug 1995 15:39:06   RWolff
 * Changed detection of block I/O cards to match Microsoft's
 * standard for plug-and-play.
 * 
 *    Rev 1.11   13 Jun 1995 15:11:18   RWOLFF
 * On Alpha systems, now only uses dense space for the memory mapped
 * registers on PCI cards. This is to allow support for ISA cards on
 * the Jensen (EISA machine, no PCI support), which doesn't support
 * dense space.
 * 
 *    Rev 1.10   30 Mar 1995 12:02:14   RWOLFF
 * WaitForIdle_cx() and CheckFIFOSpace_cx() now time out and reset
 * the engine after 3 seconds (no operation should take this long)
 * to clear a hung engine, changed permanent debug print statements
 * to use new debug level thresholds.
 * 
 *    Rev 1.9   08 Mar 1995 11:35:44   ASHANMUG
 * Modified return values to be correct
 * 
 *    Rev 1.7   27 Feb 1995 17:53:26   RWOLFF
 * Added routine that reports whether the I/O registers are packed
 * (relocatable) or not.
 * 
 *    Rev 1.6   24 Feb 1995 12:30:44   RWOLFF
 * Added code to support relocatable I/O. This is not yet fully
 * operational, so it is disabled for this release.
 * 
 *    Rev 1.5   23 Dec 1994 10:47:12   ASHANMUG
 * ALPHA/Chrontel-DAC
 * 
 *    Rev 1.4   18 Nov 1994 11:48:18   RWOLFF
 * Added support for Mach 64 with no BIOS, routine to get the I/O base
 * address for the card being used.
 * 
 *    Rev 1.3   20 Jul 1994 12:59:12   RWOLFF
 * Added support for multiple I/O base addresses for accelerator registers.
 * 
 *    Rev 1.2   30 Jun 1994 18:16:50   RWOLFF
 * Added IsApertureConflict_cx() (moved from QUERY_CX.C). Instead of checking
 * to see if we can read back what we have written to the aperture, then
 * looking for the proper text attribute, we now make a call to
 * VideoPortVerifyAccessRanges() which includes the aperture in the list of
 * ranges we are trying to claim. If this call fails, we make another call
 * which does not include the LFB. We always claim the VGA aperture (shareable),
 * since we need to use it when querying the card.
 * 
 *    Rev 1.1   07 Feb 1994 14:14:12   RWOLFF
 * Added alloc_text() pragmas to allow miniport to be swapped out when
 * not needed.
 * 
 *    Rev 1.0   31 Jan 1994 11:20:42   RWOLFF
 * Initial revision.
 * 
 *    Rev 1.1   30 Nov 1993 18:30:06   RWOLFF
 * Fixed calculation of offset for memory mapped address ranges.
 * 
 *    Rev 1.0   05 Nov 1993 13:36:14   RWOLFF
 * Initial revision.

End of PolyTron RCS section                             *****************/

#ifdef DOC
SETUP_CX.C - Setup routines for 68800CX accelerators.

DESCRIPTION
    This file contains routines which provide services specific to
    the 68800CX-compatible family of ATI accelerators.

OTHER FILES

#endif

#include "dderror.h"

#include "miniport.h"
#include "ntddvdeo.h"
#include "video.h"

#include "stdtyp.h"
#include "amachcx.h"
#include "amach1.h"
#include "atimp.h"

#include "query_cx.h"
#include "services.h"
#define INCLUDE_SETUP_CX
#include "setup_cx.h"


static ULONG FindNextBlockATICard(void);

/*
 * Allow miniport to be swapped out when not needed.
 */
#if defined (ALLOC_PRAGMA)
#pragma alloc_text(PAGE_CX, CompatIORangesUsable_cx)
#pragma alloc_text(PAGE_CX, CompatMMRangesUsable_cx)
#pragma alloc_text(PAGE_CX, WaitForIdle_cx)
#pragma alloc_text(PAGE_CX, CheckFIFOSpace_cx)
#pragma alloc_text(PAGE_CX, IsApertureConflict_cx)
#pragma alloc_text(PAGE_CX, GetIOBase_cx)
#pragma alloc_text(PAGE_CX, IsPackedIO_cx)
#pragma alloc_text(PAGE_CX, FindNextBlockATICard)
#endif



UCHAR LookForAnotherCard = 1;


/***************************************************************************
 *
 * VP_STATUS CompatIORangesUsable_cx(void);
 *
 * DESCRIPTION:
 *  Ask Windows NT for permission to use the I/O space address ranges
 *  needed by the 68800CX accelerator.
 *
 * RETURN VALUE:
 *  NO_ERROR if successful
 *  error code if unable to gain access to the ranges we need.
 *
 * GLOBALS CHANGED:
 *  none
 *
 * CALLED BY:
 *  ATIMPFindAdapter()
 *
 * AUTHOR:
 *  Robert Wolff
 *
 * CHANGE HISTORY:
 *
 * TEST HISTORY:
 *
 ***************************************************************************/

VP_STATUS CompatIORangesUsable_cx(INTERFACE_TYPE SystemBus)
{
    VP_STATUS Status;               /* Value returned by operating system calls */
    short Count;                    /* Loop counter */
    VIDEO_ACCESS_RANGE SaveFirstMM; /* Place to save the first memory mapped registers */
    USHORT BaseIndex;               /* Index into register base array */
    USHORT VariableIndex;           /* Index into array of variable part of register array */
    ULONG BaseAddress;              /* I/O base address for relocatable I/O */
    ULONG ClaimSize;                /* Size of VGA aperture/BIOS block to claim */
    ULONG InitialClaimSize;         /* Initial size of the BIOS block to claim */
    BOOL FoundSafeClaim = FALSE;    /* Have we found a BIOS block we can claim safely? */


    /*
     * Check to see if someone has added or deleted I/O ranges without
     * changing the defined value. I/O registers start at index 0.
     *
     * All the I/O mapped registers are before the first register which
     * exists only in memory-mapped form.
     */
    if ((DriverIORange_cx[NUM_IO_REGISTERS-1].RangeStart.HighPart == DONT_USE) ||
        (DriverIORange_cx[NUM_IO_REGISTERS].RangeStart.HighPart != DONT_USE))
        {
        VideoDebugPrint((DEBUG_ERROR, "Wrong defined value for number of I/O ranges\n"));
        return ERROR_INSUFFICIENT_BUFFER;
        }

    /*
     * Clear the list of mapped I/O addresses so we can identify
     * which ones have been mapped in order to unmap them if
     * there is a failure partway through the mapping.
     */
    for (Count = 0; Count < NUM_IO_REGISTERS; Count++)
        {
        phwDeviceExtension->aVideoAddressIO[Count] = 0;
        }

    /*
     * Run through the list of base addresses, trying each
     * until we find the one that the Mach 64 is using.
     */
    for (BaseIndex = 0; BaseIndex < NUM_BASE_ADDRESSES; BaseIndex++)
        {
        /*
         * Possible problem area: if this is the first bus to be
         * tested which contains a fixed-base Mach 64, but a previous
         * bus had at least one block-relocatable card without
         * having the maximum number we support (which would have
         * been caught in ATIMPFindAdapter()), we don't want to
         * look for fixed-base cards. This is because we don't
         * support a mixture of fixed-base and block-relocatable
         * cards.
         */
        if (NumBlockCardsFound != 0)
            {
            VideoDebugPrint((DEBUG_NORMAL, "Skipping fixed base because block cards found\n"));
            break;
            }

        /*
         * Build up the accelerator registers using the current
         * base address.
         */
        for (VariableIndex = 0; VariableIndex < NUM_REGS_TO_BUILD; VariableIndex++)
            {
            DriverIORange_cx[VariableIndex+FIRST_REG_TO_BUILD].RangeStart.LowPart =
                VariableRegisterBases[BaseIndex] + VariableRegisterOffsets[VariableIndex];
            }

        /*
         * If we encounter a conflict claiming the full 64k of the BIOS
         * area, it will generate two messages in the event log even
         * though this is not a fatal error. To avoid this, we must
         * store claim restrictions in the registry, and on subsequent
         * boots start claiming where we were successful last time.
         *
         * If we can't read the registry entry, assume that we can
         * claim the full 64k area starting at 0xC000:0000.
         *
         * Don't worry about a user upgrading to a Mach 64 with a 64k
         * video BIOS and moving the SCSI card above 0xD000:0000, since
         * our install script will clear this registry entry to its
         * "claim 64k" value.
         */
        if (VideoPortGetRegistryParameters(phwDeviceExtension,
                                           L"BiosClaimSize",
                                           FALSE,
                                           RegistryParameterCallback,
                                           NULL) == NO_ERROR)
            {
            InitialClaimSize = *RegistryBuffer;
            VideoDebugPrint((DEBUG_DETAIL, "Read initial claim size 0x%X\n", VgaResourceSize[InitialClaimSize]));
            }
        else
            {
            InitialClaimSize = CLAIM_32k_BIOS;
            VideoDebugPrint((DEBUG_DETAIL, "Using default initial claim size 0x%X\n", VgaResourceSize[InitialClaimSize]));
            }

        if ((InitialClaimSize < CLAIM_32k_BIOS) || (InitialClaimSize > CLAIM_APERTURE_ONLY) )
            InitialClaimSize = CLAIM_32k_BIOS;

        /*
         * Claim as much as possible of our BIOS area. If we fail to
         * claim the full 64k, try restricting ourselves to 32k and
         * finally no BIOS area, only giving up on the current I/O
         * base address if we can't claim our access ranges even with
         * no BIOS area.
         */
        for (ClaimSize = InitialClaimSize; ClaimSize <= CLAIM_APERTURE_ONLY; ClaimSize++)
            {
            /*
             * Set up our VGA resource claim size.
             */
            DriverApertureRange_cx[0].RangeLength = VgaResourceSize[ClaimSize];

            /*
             * Check to see if there is a hardware resource conflict. We must save
             * the information for the first memory mapped register, copy in
             * the information for the VGA aperture (which we always need),
             * and restore the memory mapped register information after
             * we have verified that we can use the required address ranges.
             */
            VideoPortMoveMemory(&SaveFirstMM, DriverIORange_cx+VGA_APERTURE_ENTRY, sizeof(VIDEO_ACCESS_RANGE));
            VideoPortMoveMemory(DriverIORange_cx+VGA_APERTURE_ENTRY, DriverApertureRange_cx, sizeof(VIDEO_ACCESS_RANGE));

            Status = VideoPortVerifyAccessRanges(phwDeviceExtension,
                                                NUM_IO_REGISTERS + 1,
                                                DriverIORange_cx);

            VideoPortMoveMemory(DriverIORange_cx+VGA_APERTURE_ENTRY, &SaveFirstMM, sizeof(VIDEO_ACCESS_RANGE));

            /*
             * If there is a hardware resource conflict, we can't use this
             * base address and BIOS region size, so try the next. If there
             * is no conflict, use the current size.
             *
             * If the size of the BIOS block we were able to claim
             * differs from our initial attempt, record the "maximum
             * possible BIOS block size" in the registry so that on
             * subsequent boots we won't generate event log entries
             * by claiming a BIOS region that conflicts with another
             * card.
             */
            if (Status != NO_ERROR)
                {
                VideoDebugPrint((DEBUG_DETAIL, "Rejecting VGA aperture/BIOS block size of 0x%X bytes\n", VgaResourceSize[ClaimSize]));
                continue;
                }
            else
                {
                VideoDebugPrint((DEBUG_DETAIL, "VGA aperture/BIOS block size = 0x%X bytes\n", VgaResourceSize[ClaimSize]));
                if (FoundSafeClaim == FALSE)
                    {
                    FoundSafeClaim = TRUE;
                    if (ClaimSize != InitialClaimSize)
                        {
                        //ClaimSize = 1;
                        VideoDebugPrint((DEBUG_DETAIL, "Writing claim size 0x%X\n", VgaResourceSize[ClaimSize]));
                        VideoPortSetRegistryParameters(phwDeviceExtension,
                                                       L"BiosClaimSize",
                                                       &ClaimSize,
                                                       sizeof(ULONG));
                        }
                    }
                break;
                }
            }   /* end for (decreasing claim size) */

        /*
         * If we fell out of the above loop, rather than breaking out,
         * go on to the next I/O base address, since we have run into
         * a hardware resource conflict.
         */
        if ((Status != NO_ERROR) && (ClaimSize > CLAIM_APERTURE_ONLY))
            continue;

        /*
         * Map the video controller address ranges we need to identify
         * our cards into the system virtual address space. If a register
         * only exists in memory-mapped form, set its I/O mapped address
         * to zero (won't be used because memory-mapped takes precedence
         * over I/O mapped).
         *
         * Initialize the mapped addresses for memory mapped registers
         * to 0 (flag to show the registers are not memory mapped) in
         * case they were initialized to a nonzero value.
         */
        for (Count=0; Count < NUM_DRIVER_ACCESS_RANGES; Count++)
            {
            if (Count < NUM_IO_REGISTERS)
                {
                if ((phwDeviceExtension->aVideoAddressIO[Count] =
                    VideoPortGetDeviceBase(phwDeviceExtension,
                        DriverIORange_cx[Count].RangeStart,
                        DriverIORange_cx[Count].RangeLength,
                        DriverIORange_cx[Count].RangeInIoSpace)) == NULL)
                    {
                    /*
                     * There was an error in mapping. Remember this
                     * so we don't try to find a Mach 64 without all
                     * the registers being mapped properly, then
                     * break out of the mapping loop. We will have
                     * another shot at mapping all the addresses
                     * when we try the next base address for the
                     * accelerator registers.
                     */
                    Status = ERROR_INVALID_PARAMETER;
                    VideoDebugPrint((DEBUG_ERROR, "Mapping error 1\n"));
                    break;
                    }
                }
            else
                {
                phwDeviceExtension->aVideoAddressIO[Count] = 0;
                }
            phwDeviceExtension->aVideoAddressMM[Count] = 0;
            }   /* End for */

        /*
         * If all I/O registers were successfully mapped, check to see
         * if a Mach 64 is present at the current base address. If it
         * is, report that we have successfully mapped our registers
         * and found a Mach 64. Since this means we have found a
         * card which is not block relocatable, we do not want to
         * look for further cards. Also, since this is the only
         * Mach 64 in the system, assume that its VGA is enabled.
         */
        if (Status == NO_ERROR)
            {
            if (DetectMach64() == MACH64_ULTRA)
                {
                FoundNonBlockCard = TRUE;
                LookForAnotherCard = 0;
                phwDeviceExtension->BiosPrefix = BIOS_PREFIX_VGA_ENAB;
                return NO_ERROR;
                }
            }

        /*
         * We did not find a Mach 64 at this base address, so unmap
         * the I/O mapped registers in preparation for trying the
         * next base address. Only unmap those registers which were
         * mapped, in case the mapping loop aborted due to a failure
         * to map one register.
         */
        for (Count = 1; Count < NUM_IO_REGISTERS; Count++)
            {
            if (phwDeviceExtension->aVideoAddressIO[Count] != 0)
                {
                VideoPortFreeDeviceBase(phwDeviceExtension,
                                        phwDeviceExtension->aVideoAddressIO[Count]);
                phwDeviceExtension->aVideoAddressIO[Count] = 0;
                }
            }

        }   /* End for (loop of base addresses) */

    /*
     * The video card in the machine isn't a Mach 64 that uses one of
     * the standard I/O base addresses. Check if it's a Mach 64 with
     * relocatable I/O.
     *
     * All our relocatable cards are PCI implementations. The code we
     * use to detect them is PCI-specific, so if the bus we are currently
     * dealing with is not PCI, don't look for relocatable cards.
     */
    if (SystemBus != PCIBus)
        {
        VideoDebugPrint((DEBUG_DETAIL, "Not PCI bus - can't check for relocatable card\n"));
        return ERROR_DEV_NOT_EXIST;
        }

    BaseAddress = FindNextBlockATICard();

    /*
     * BaseAddress will be zero if FindNextBlockATICard()
     * couldn't find a block-relocatable ATI card.
     */
    if (BaseAddress == 0)
        {
        LookForAnotherCard = 0;
        VideoDebugPrint((DEBUG_NORMAL, "Finished checking for relocatable cards\n"));
        return ERROR_DEV_NOT_EXIST;
        }

    /*
     * We have found a block relocatable ATI card. Save its I/O base
     * address so we can (during ATIMPInitialize()) match it up to
     * the accelerator prefix for the card, and set the initial prefix
     * to show that this card needs its I/O base and accelerator prefix
     * matched.
     */
    phwDeviceExtension->BaseIOAddress = BaseAddress;
    phwDeviceExtension->BiosPrefix = BIOS_PREFIX_UNASSIGNED;
    NumBlockCardsFound++;
    VideoDebugPrint((DEBUG_NORMAL, "Block relocatable card found, I/O base 0x%X\n", BaseAddress));


    /*
     * We now have the I/O base address. Map in the I/O addresses,
     * then check to see if we have a Mach 64 card. Depending on
     * the results, either report success or unmap the addresses
     * and report failure.
     */
    VideoDebugPrint((DEBUG_DETAIL, "About to map I/O addresses\n"));
    for (VariableIndex = 0; VariableIndex < NUM_REGS_TO_BUILD; VariableIndex++)
        {
        DriverIORange_cx[VariableIndex+FIRST_REG_TO_BUILD].RangeStart.LowPart =
            BaseAddress + (RelocatableRegisterOffsets[VariableIndex] * 4);
        }

    /*
     * Claim as much as possible of our BIOS area. If we fail to
     * claim the full 64k, try restricting ourselves to 32k and
     * finally no BIOS area, only giving up on the current I/O
     * base address if we can't claim our access ranges even with
     * no BIOS area.
     */
    for (ClaimSize = InitialClaimSize; ClaimSize <= CLAIM_APERTURE_ONLY; ClaimSize++)
        {
        /*
         * Set up our VGA resource claim size.
         */
        DriverApertureRange_cx[0].RangeLength = VgaResourceSize[ClaimSize];

        /*
         * Check to see if there is a hardware resource conflict. We must save
         * the information for the first memory mapped register, copy in
         * the information for the VGA aperture (which we always need),
         * and restore the memory mapped register information after
         * we have verified that we can use the required address ranges.
         */
        VideoPortMoveMemory(&SaveFirstMM, DriverIORange_cx+VGA_APERTURE_ENTRY, sizeof(VIDEO_ACCESS_RANGE));
        VideoPortMoveMemory(DriverIORange_cx+VGA_APERTURE_ENTRY, DriverApertureRange_cx, sizeof(VIDEO_ACCESS_RANGE));

        Status = VideoPortVerifyAccessRanges(phwDeviceExtension,
                                            NUM_IO_REGISTERS + 1,
                                            DriverIORange_cx);

        VideoPortMoveMemory(DriverIORange_cx+VGA_APERTURE_ENTRY, &SaveFirstMM, sizeof(VIDEO_ACCESS_RANGE));

        /*
         * If there is a hardware resource conflict, we are either trying
         * to claim a bigger BIOS block than we need, and someone else is
         * sitting in (and claiming as nonshareable) the "slack", or we have
         * a conflict over the I/O base address. Try the next smallest BIOS
         * block.
         *
         * If the size of the BIOS block we were able to claim
         * differs from our initial attempt, record the "maximum
         * possible BIOS block size" in the registry so that on
         * subsequent boots we won't generate event log entries
         * by claiming a BIOS region that conflicts with another
         * card.
         */
        if (Status != NO_ERROR)
            {
            VideoDebugPrint((DEBUG_DETAIL, "Rejecting VGA aperture/BIOS block size of 0x%X bytes\n", VgaResourceSize[ClaimSize]));
            continue;
            }
        else
            {
            VideoDebugPrint((DEBUG_DETAIL, "VGA aperture/BIOS block size = 0x%X bytes\n", VgaResourceSize[ClaimSize]));
            if (FoundSafeClaim == FALSE)
                {
                FoundSafeClaim = TRUE;
                if (ClaimSize != InitialClaimSize)
                    {
                    //ClaimSize = 1;
                    VideoDebugPrint((DEBUG_DETAIL, "Writing claim size 0x%X\n", VgaResourceSize[ClaimSize]));
                    VideoPortSetRegistryParameters(phwDeviceExtension,
                                                   L"BiosClaimSize",
                                                   &ClaimSize,
                                                   sizeof(ULONG));
                    }
                }
            break;
            }
        }   /* end for (decreasing claim size) */

    /*
     * If there is a conflict over the I/O base address, we can't use
     * it. Since this is our last chance to find a Mach 64, report failure.
     */
    if (Status != NO_ERROR)
        {
        VideoDebugPrint((DEBUG_ERROR, "VideoPortVerifyAccessRanges() failed in check for relocatable Mach 64\n"));
        return ERROR_DEV_NOT_EXIST;
        }

    /*
     * Map the video controller address ranges we need to identify
     * our cards into the system virtual address space. If a register
     * only exists in memory-mapped form, set its I/O mapped address
     * to zero (won't be used because memory-mapped takes precedence
     * over I/O mapped).
     *
     * Initialize the mapped addresses for memory mapped registers
     * to 0 (flag to show the registers are not memory mapped) in
     * case they were initialized to a nonzero value.
     */
    for (Count=0; Count < NUM_DRIVER_ACCESS_RANGES; Count++)
        {
        if (Count < NUM_IO_REGISTERS)
            {
            if ((phwDeviceExtension->aVideoAddressIO[Count] =
                VideoPortGetDeviceBase(phwDeviceExtension,
                    DriverIORange_cx[Count].RangeStart,
                    DriverIORange_cx[Count].RangeLength,
                    DriverIORange_cx[Count].RangeInIoSpace)) == NULL)
                {
                /*
                 * There was an error in mapping. Remember this
                 * so we don't try to find a Mach 64 without all
                 * the registers being mapped properly, then
                 * break out of the mapping loop.
                 */
                Status = ERROR_INVALID_PARAMETER;
                VideoDebugPrint((DEBUG_ERROR, "Mapping error 2\n"));
                break;
                }
            }
        else
            {
            phwDeviceExtension->aVideoAddressIO[Count] = 0;
            }
        phwDeviceExtension->aVideoAddressMM[Count] = 0;
        }   /* End for */

    /*
     * If all I/O registers were successfully mapped, check to see
     * if a Mach 64 is present at the current base address. If it
     * is, report that we have successfully mapped our registers
     * and found a Mach 64.
     */
    if (Status == NO_ERROR)
        {
        if (DetectMach64() == MACH64_ULTRA)
            {
            return NO_ERROR;
            }
        }

    /*
     * We did not find a Mach 64 at this base address, so clean
     * up after ourselves by unmapping the I/O mapped registers
     * before reporting failure. Only unmap those registers which
     * were mapped, in case the mapping loop aborted due to a
     * failure to map one register.
     */
    for (Count = 1; Count < NUM_IO_REGISTERS; Count++)
        {
        if (phwDeviceExtension->aVideoAddressIO[Count] != 0)
            {
            VideoPortFreeDeviceBase(phwDeviceExtension,
                                    phwDeviceExtension->aVideoAddressIO[Count]);
            phwDeviceExtension->aVideoAddressIO[Count] = 0;
            }
        }


    /*
     * We haven't found a Mach 64 at any of the allowable base addresses,
     * so report that there is no Mach 64 in the machine.
     */
    VideoDebugPrint((DEBUG_NORMAL, "No Mach 64 found at this address\n"));
    return ERROR_DEV_NOT_EXIST;

}   /* CompatIORangesUsable_cx() */

/***************************************************************************
 *
 * VP_STATUS CompatMMRangesUsable_cx(void);
 *
 * DESCRIPTION:
 *  Ask Windows NT for permission to use the memory mapped registers
 *  needed by the 68800CX accelerator.
 *
 * RETURN VALUE:
 *  NO_ERROR if successful
 *  error code if unable to gain access to the ranges we need.
 *
 * GLOBALS CHANGED:
 *  none
 *
 * CALLED BY:
 *  ATIMPFindAdapter()
 *
 * AUTHOR:
 *  Robert Wolff
 *
 * CHANGE HISTORY:
 *
 * TEST HISTORY:
 *
 ***************************************************************************/

VP_STATUS CompatMMRangesUsable_cx(void)
{
    PHYSICAL_ADDRESS MMrange;   /* Used in translating offset to memory address */
    ULONG RegisterOffset;       /* Offset of memory mapped registers start of address space */
    int Count;                  /* Loop counter */
    struct query_structure *QueryPtr;  /* Query information for the card */
    UCHAR InIOSpace;
#if defined (ALPHA)
    ULONG Scratch;
#endif


    /*
     * Get a formatted pointer into the query section of HwDeviceExtension.
     * The CardInfo[] field is an unformatted buffer.
     */
    QueryPtr = (struct query_structure *) (phwDeviceExtension->CardInfo);

    /*
     * Set the offset of the memory mapped registers from the start of
     * the aperture to the appropriate value for the aperture size
     * being used.
     */
    if ((QueryPtr->q_aperture_cfg & BIOS_AP_SIZEMASK) == BIOS_AP_8M)
        RegisterOffset = phwDeviceExtension->PhysicalFrameAddress.LowPart + OFFSET_8M;
    else if ((QueryPtr->q_aperture_cfg & BIOS_AP_SIZEMASK) == BIOS_AP_4M)
        RegisterOffset = phwDeviceExtension->PhysicalFrameAddress.LowPart + OFFSET_4M;
    else
        RegisterOffset = OFFSET_VGA;

    /*
     * We are working in a 32 bit address space, so the upper DWORD
     * of the quad word address is always zero.
     */
    MMrange.HighPart = 0;

#if defined (ALPHA)
    /*
     * All Alpha systems are capable of supporting sparse space
     * (normal memory mapped space for the Alpha). Newer systems
     * (those that have PCI buses) are also able to support dense
     * space, but older systems can't. In almost all cases, non-PCI
     * cards are a sign that we are using an older system, but
     * assuming this is an older system when it is actually an ISA
     * card in a newer system is mostly harmless (slight performance
     * penalty). Assuming that dense space is available on all Alpha
     * systems will crash a Jensen (older system).
     */
    if (QueryPtr->q_bus_type == BUS_PCI)
        InIOSpace = 4; // DENSE Space
    else
        InIOSpace = 0;

    /*
     * The GX-F ASIC has a bug where burst reads of a quadword of
     * memory will result in the high doubleword being corrupted.
     * The memory-mapped form of CONFIG_CHIP_ID is the high doubleword,
     * and on the Alpha in dense space (on PCI cards we always use
     * dense space for our memory-mapped registers) all read access
     * to memory is by quadwords, so we will run into the burst mode
     * problem. The I/O mapped form of this register is safe to use.
     */
    Scratch = INPD(CONFIG_CHIP_ID);
    if (((Scratch & CONFIG_CHIP_ID_TypeMask) == CONFIG_CHIP_ID_TypeGX) &&
        ((Scratch & CONFIG_CHIP_ID_RevMask) == CONFIG_CHIP_ID_RevF))
        {
        VideoDebugPrint((DEBUG_DETAIL, "GX-F detected, must use I/O mapped form of CRTC_OFF_PITCH\n"));
        DriverMMRange_cx[CRTC_OFF_PITCH].RangeStart.HighPart = DONT_USE;
        }
#else
    InIOSpace = 0; // memory mapped I/O Space
#endif

    for (Count=1; Count < NUM_DRIVER_ACCESS_RANGES;  Count++)
        {
        /*
         * In a 32-bit address space, the high doubleword of all
         * physical addresses is zero. Setting this value to DONT_USE
         * indicates that this accelerator register isn't memory mapped.
         */
        if (DriverMMRange_cx[Count].RangeStart.HighPart != DONT_USE)
            {
            /*
             * DriverMMRange_cx[Count].RangeStart.LowPart is the offset
             * (in doublewords) of the memory mapped register from the
             * beginning of the block of memory mapped registers. We must
             * convert this to bytes, add the offset of the start of the
             * memory mapped register area from the start of the aperture
             * and the physical address of the start of the linear
             * framebuffer to get the physical address of this
             * memory mapped register.
             */
            MMrange.LowPart = (DriverMMRange_cx[Count].RangeStart.LowPart * 4) + RegisterOffset;
            phwDeviceExtension->aVideoAddressMM[Count] =
                VideoPortGetDeviceBase(phwDeviceExtension,  
                    MMrange,
                    DriverMMRange_cx[Count].RangeLength,
                    InIOSpace);                     // not in IO space

            /*
             * If we were unable to claim the memory-mapped version of
             * this register, and it exists only in memory-mapped form,
             * then we have a register which we can't access. Report
             * this as an error condition.
             */
            if ((phwDeviceExtension->aVideoAddressMM[Count] == 0) &&
                (DriverIORange_cx[Count].RangeStart.HighPart == DONT_USE))
                {
                VideoDebugPrint((DEBUG_ERROR, "Mapping error 3\n"));
                return ERROR_INVALID_PARAMETER;
                }
            }
        }

    VideoDebugPrint((DEBUG_DETAIL, "CompatMMRangesUsable_cx() succeeded\n"));
    return NO_ERROR;

}   /* CompatMMRangesUsable_cx() */




/***************************************************************************
 *
 * int WaitForIdle_cx(void);
 *
 * DESCRIPTION:
 *  Poll GUI_STAT waiting for GuiActive field to go low. If it does not go
 *  low within 3 seconds (arbitrary value, but no operation should take
 *  that long), time out.
 *
 * RETURN VALUE:
 *  FALSE if timeout
 *  TRUE  if engine is idle
 *
 * GLOBALS CHANGED:
 *  none
 *
 * CALLED BY:
 *  Any 68800CX-specific routine may call this routine.
 *
 * AUTHOR:
 *  Robert Wolff
 *
 * CHANGE HISTORY:
 *
 * TEST HISTORY:
 *
 ***************************************************************************/

int WaitForIdle_cx(void)
{
    int	i;
    ULONG Scratch;

    for (i=0; i<300; i++)
        {
        if ((INPD(GUI_STAT) & GUI_STAT_GuiActive) == 0)
            return TRUE;

        /*
         * Wait 1/100th of a second
         */
        delay(10);
        }

    /*
     * Something has happened, so reset the engine and return FALSE.
     */
    VideoDebugPrint((DEBUG_ERROR, "ATI: Timeout on WaitForIdle_cx()\n"));
    Scratch = INPD(GEN_TEST_CNTL) & ~GEN_TEST_CNTL_GuiEna;
    OUTPD(GEN_TEST_CNTL, Scratch);
    Scratch |= GEN_TEST_CNTL_GuiEna;
    OUTPD(GEN_TEST_CNTL, Scratch);
    return FALSE;

}   /* WaitForIdle_cx() */



/***************************************************************************
 *
 * void CheckFIFOSpace_cx(SpaceNeeded);
 *
 * WORD SpaceNeeded;    Number of free FIFO entries needed
 *
 * DESCRIPTION:
 *  Wait until the specified number of FIFO entries are free
 *  on a 68800CX-compatible ATI accelerator.
 *
 *  If the specified number of entries does not become free in
 *  3 seconds (arbitrary value greater than any operation should
 *  take), assume the engine has locked and reset it.
 *
 * GLOBALS CHANGED:
 *  none
 *
 * CALLED BY:
 *  Any 68800CX-specific routine may call this routine.
 *
 * AUTHOR:
 *  Robert Wolff
 *
 * CHANGE HISTORY:
 *
 * TEST HISTORY:
 *
 ***************************************************************************/

void CheckFIFOSpace_cx(WORD SpaceNeeded)
{
    ULONG LoopCount;
    ULONG Scratch;

    for (LoopCount = 0; LoopCount < 300; LoopCount++)
        {
        /*
         * Return from test if enough entries are free
         */
        if (!(INPD(FIFO_STAT)&SpaceNeeded))
            return;

        /*
         * Wait 1/100th of a second
         */
        delay(10);
        }

    /*
     * Something has happened, so reset the engine and return FALSE.
     */
    VideoDebugPrint((DEBUG_ERROR, "ATI: Timeout on CheckFIFOSpace_cx()\n"));
    Scratch = INPD(GEN_TEST_CNTL) & ~GEN_TEST_CNTL_GuiEna;
    OUTPD(GEN_TEST_CNTL, Scratch);
    Scratch |= GEN_TEST_CNTL_GuiEna;
    OUTPD(GEN_TEST_CNTL, Scratch);
    return;

}   /* CheckFIFOSpace_cx() */



/*
 * BOOL IsApertureConflict_cx(QueryPtr);
 *
 * struct query_structure *QueryPtr;    Pointer to query structure
 *
 * Check to see if the linear aperture conflicts with other memory.
 * If a conflict exists, disable the linear aperture.
 *
 * Returns:
 *  TRUE if a conflict exists (aperture unusable)
 *  FALSE if the aperture is usable.
 */
BOOL IsApertureConflict_cx(struct query_structure *QueryPtr)
{
DWORD Scratch;                      /* Used in manipulating registers */
VP_STATUS Status;                   /* Return value from VideoPortVerifyAccessRanges() */
VIDEO_X86_BIOS_ARGUMENTS Registers; /* Used in VideoPortInt10() calls */
VIDEO_ACCESS_RANGE SaveFirstMM[2];  /* Place to save the first two memory mapped registers */
USHORT VariableIndex;               /* Index into array of variable part of register array */

    /*
     * Set up by disabling the memory boundary (must be disabled in order
     * to access accelerator memory through the VGA aperture).
     */
    Scratch = INPD(MEM_CNTL);
    Scratch &= ~MEM_CNTL_MemBndryEn;
    OUTPD(MEM_CNTL, Scratch);

    /*
     * If there is an aperture conflict, a call to
     * VideoPortVerifyAccessRanges() including our linear framebuffer in
     * the range list will return an error. If there is no conflict, it
     * will return success.
     *
     * We must save the contents of the first 2 memory mapped register
     * entries, copy in the aperture ranges (VGA and linear) we need
     * to claim, then restore the memory mapped entries after we
     * have verified that we can use the aperture(s).
     *
     * DriverIORange_cx[] contains the physical addresses of the registers
     * for the last card we have dealt with. In a single-card setup, this
     * is no problem, but in a multi-card setup we must re-load this
     * array with the physical addresses of the card we want to claim
     * the aperture for.
     */
    if (NumBlockCardsFound > 1)
        {
        for (VariableIndex = 0; VariableIndex < NUM_REGS_TO_BUILD; VariableIndex++)
            {
            DriverIORange_cx[VariableIndex+FIRST_REG_TO_BUILD].RangeStart.LowPart =
                phwDeviceExtension->BaseIOAddress + (RelocatableRegisterOffsets[VariableIndex] * 4);
            }
        }
    DriverApertureRange_cx[LFB_ENTRY].RangeStart.LowPart = QueryPtr->q_aperture_addr*ONE_MEG;
    if ((QueryPtr->q_aperture_cfg & BIOS_AP_SIZEMASK) == BIOS_AP_8M)
        DriverApertureRange_cx[LFB_ENTRY].RangeLength = 8*ONE_MEG;
    else
        DriverApertureRange_cx[LFB_ENTRY].RangeLength = 4*ONE_MEG;

    VideoPortMoveMemory(SaveFirstMM, DriverIORange_cx+VGA_APERTURE_ENTRY, 2*sizeof(VIDEO_ACCESS_RANGE));
    VideoPortMoveMemory(DriverIORange_cx+VGA_APERTURE_ENTRY, DriverApertureRange_cx, 2*sizeof(VIDEO_ACCESS_RANGE));

    Status = VideoPortVerifyAccessRanges(phwDeviceExtension,
                                         NUM_IO_REGISTERS+2,
                                         DriverIORange_cx);
    if (Status != NO_ERROR)
        {
        /*
         * If there is an aperture conflict, reclaim our I/O ranges without
         * asking for the LFB. This call should not fail, since we would not
         * have reached this point if there were a conflict.
         */
        Status = VideoPortVerifyAccessRanges(phwDeviceExtension,
                                             NUM_IO_REGISTERS+1,
                                             DriverIORange_cx);
        if (Status != NO_ERROR)
            VideoDebugPrint((DEBUG_ERROR, "ERROR: Can't reclaim I/O ranges\n"));

        VideoPortMoveMemory(DriverIORange_cx+VGA_APERTURE_ENTRY, SaveFirstMM, 2*sizeof(VIDEO_ACCESS_RANGE));
        ISAPitchAdjust(QueryPtr);
        return TRUE;
        }
    else
        {
        VideoPortMoveMemory(DriverIORange_cx+VGA_APERTURE_ENTRY, SaveFirstMM, 2*sizeof(VIDEO_ACCESS_RANGE));

        /*
         * There is no aperture conflict, so enable the linear aperture.
         */
        VideoPortZeroMemory(&Registers, sizeof(VIDEO_X86_BIOS_ARGUMENTS));
        Registers.Eax = BIOS_APERTURE;
        Registers.Ecx = BIOS_LINEAR_APERTURE;
        VideoPortInt10(phwDeviceExtension, &Registers);

        return FALSE;
        }

}   /* IsApertureConflict_cx() */



/***************************************************************************
 *
 * USHORT GetIOBase_cx(void);
 *
 * DESCRIPTION:
 *  Get the I/O base address being used by this card.
 *
 * RETURN VALUE:
 *  I/O base register
 *
 * GLOBALS CHANGED:
 *  none
 *
 * CALLED BY:
 *  Any 68800CX-specific routine may call this routine after
 *  CompatIORangesUsable_cx() has returned success. Results
 *  are undefined if this routine is called either before
 *  CompatIORangesUsable_cx() is called, or after it retunrs
 *  failure.
 *
 * AUTHOR:
 *  Robert Wolff
 *
 * CHANGE HISTORY:
 *
 * TEST HISTORY:
 *
 ***************************************************************************/

USHORT GetIOBase_cx(void)
{

    /*
     * CRTC_H_TOTAL_DISP is at offset 0 from the base address.
     * In a single-card setup, after CompatIORangesUsable_cx()
     * returns, the value in
     * DriverIORange_cx[CRTC_H_TOTAL_DISP].RangeStart.LowPart
     * will be either the I/O base address in use (returned
     * success) or the last I/O base address tried (returned
     * failure).
     *
     * In a multi-card setup, this value will hold the I/O base
     * for the last card which was set up, but the I/O base for
     * each card is stored in its hardware device extension
     * structure. This second storage location is not guaranteed
     * for single-card setups, so use the DriverIORange location
     * for them.
     */
    if (NumBlockCardsFound > 1)
        return (USHORT)(phwDeviceExtension->BaseIOAddress);
    else
        return (USHORT)(DriverIORange_cx[CRTC_H_TOTAL_DISP].RangeStart.LowPart);

}   /* GetIOBase_cx() */



/***************************************************************************
 *
 * BOOL IsPackedIO_cx(void);
 *
 * DESCRIPTION:
 *  Report whether or not we are using packed (relocatable) I/O.
 *
 * RETURN VALUE:
 *  TRUE if using packed I/O
 *  FALSE if using sparse I/O
 *
 * GLOBALS CHANGED:
 *  none
 *
 * CALLED BY:
 *  Any 68800CX-specific routine may call this routine after
 *  CompatIORangesUsable_cx() has returned success. Results
 *  are undefined if this routine is called either before
 *  CompatIORangesUsable_cx() is called, or after it retunrs
 *  failure.
 *
 * AUTHOR:
 *  Robert Wolff
 *
 * CHANGE HISTORY:
 *
 * TEST HISTORY:
 *
 ***************************************************************************/

BOOL IsPackedIO_cx(void)
{

    /*
     * CRTC_H_TOTAL_DISP and CRTC_H_SYNC_STRT_WID are the registers
     * with the lowest I/O addresses (CRTC_H_TOTAL_DISP is at
     * offset 0 from the base address). If we are using packed I/O,
     * the DriverIORange_cx[].RangeStart.LowPart entries for these
     * two registers will differ by 4 bytes, while if we are using
     * normal (sparse) I/O, they will differ by 0x400 bytes.
     */
    if (DriverIORange_cx[CRTC_H_SYNC_STRT_WID].RangeStart.LowPart -
        DriverIORange_cx[CRTC_H_TOTAL_DISP].RangeStart.LowPart == 4)
        {
        VideoDebugPrint((DEBUG_DETAIL, "Reporting dense I/O\n"));
        return TRUE;
        }
    else
        {
        VideoDebugPrint((DEBUG_DETAIL, "Reporting sparse I/O\n"));
        return FALSE;
        }

}   /* IsPackedIO_cx() */



/***************************************************************************
 *
 * ULONG FindNextBlockATICard(void);
 *
 * DESCRIPTION:
 *  Find the next Mach 64 which uses block relocatable I/O.
 *
 * RETURN VALUE:
 *  I/O base address if card is found
 *  0 if no card is found
 *
 * GLOBALS CHANGED:
 *  none
 *
 * CALLED BY:
 *  CompatIORangesUsable_cx()
 *
 * AUTHOR:
 *  Robert Wolff
 *
 * CHANGE HISTORY:
 *
 * TEST HISTORY:
 *
 ***************************************************************************/

static ULONG FindNextBlockATICard(void)
{
    PCI_COMMON_CONFIG ConfigData;   /* Configuration information about PCI device */
    PCI_SLOT_NUMBER SlotNumber;     /* PCI slot under test */
    static ULONG DeviceNumber=0;    /* PCI device number */
    static ULONG FunctionNumber=0;  /* PCI function number */
    ULONG BaseAddress=0;            /* I/O base address */
    ULONG RetVal;                   /* Value returned by function calls */

    /*
     * The PCI_SLOT_NUMBER union allows 32 slot numbers with 8
     * function numbers each. The upper 24 bits are reserved.
     */
    while (DeviceNumber < 32)
        {
        while (FunctionNumber < 8)
            {
            VideoDebugPrint((DEBUG_DETAIL, "Checking device 0x%X function 0x%X\n", DeviceNumber, FunctionNumber));
            SlotNumber.u.bits.DeviceNumber = DeviceNumber;
            SlotNumber.u.bits.FunctionNumber = FunctionNumber;
            SlotNumber.u.bits.Reserved = 0;
            ConfigData.VendorID = PCI_INVALID_VENDORID;

            RetVal = VideoPortGetBusData(phwDeviceExtension,
                                        PCIConfiguration,
                                        SlotNumber.u.AsULONG,
                                        &ConfigData,
                                        0,
                                        PCI_COMMON_HDR_LENGTH);
            FunctionNumber++;

            /*
             * If we received an error return, skip to the
             * next possible slot.
             */
            if (RetVal != PCI_COMMON_HDR_LENGTH)
                {
                VideoDebugPrint((DEBUG_DETAIL, "Error return 0x%X, skipping to next slot\n", RetVal));
                continue;
                }

            /*
             * If this is not an ATI card, we are not interested.
             * Instead, go on to the next candidate.
             */
            VideoDebugPrint((DEBUG_DETAIL, "Vendor ID = 0x%X\n", ConfigData.VendorID));
            if (ConfigData.VendorID != 0x1002)
                continue;

            /*
             * We have found an ATI card. On all our block-relocatable
             * cards, we must mask off the lowest order bit of the
             * reported address, since this is always reported as 1
             * (I/O space), but its actual value is always 0.
             *
             * Not all ATI PCI cards are block-relocatable Mach 64
             * cards. Since we only look for block-relocatable cards
             * if we have failed to find a fixed-base Mach 64, we can
             * safely assume that any Mach 64 we find is block-relocatable.
             *
             * Despite this assumption, we must still distinguish Mach 64
             * cards from non-Mach 64 cards, either by recognizing and
             * accepting all Mach 64 device IDs and rejecting other
             * device IDs, or by recognizing and rejecting all non-Mach 64
             * device IDs and accepting other device IDs. The latter
             * route is safer, since new device IDs are more likely
             * to be Mach 64 than non-Mach 64, and this route will
             * not falsely reject new Mach 64 cards. Currently, our
             * only non-Mach 64 PCI card is the Mach 32 AX.
             *
             * Resetting BaseAddress to zero for non-Mach 64 cards
             * will result in the same treatment as for non-ATI
             * cards, i.e. we will treat the current slot as not
             * containing a block-relocatable Mach 64, and search
             * the next slot.
             */
            BaseAddress = (ConfigData.u.type0.BaseAddresses[PCI_ADDRESS_IO_SPACE]) & 0xFFFFFFFE;
            VideoDebugPrint((DEBUG_NORMAL, "Found card with device ID 0x%X\n", ConfigData.DeviceID));
            switch (ConfigData.DeviceID)
                {
                case ATI_DEVID_M32AX:
                    VideoDebugPrint((DEBUG_NORMAL, "Mach 32 AX card found, skipping it\n"));
                    BaseAddress = 0;
                    break;

                // GT, exclude GTBs
                case 0x4754:

                    if ((ConfigData.RevisionID == 0x9A) ||
                        (ConfigData.RevisionID == 0x5A) ||
                        (ConfigData.RevisionID == 0x1A) ||
                        (ConfigData.RevisionID == 0x19) ||
                        (ConfigData.RevisionID == 0x41) ||
                        (ConfigData.RevisionID == 0x01))
                        {
                        VideoDebugPrint((DEBUG_NORMAL, "Rejecting GT card with revision ID 0x%X, treating as Mach 64\n", ConfigData.RevisionID));
                        BaseAddress = 0;
                        continue;
                        }

                    VideoDebugPrint((DEBUG_NORMAL, "Found ATI card with device ID 0x%X, treating as Mach 64\n", ConfigData.DeviceID));
                    break;

                // VT, exclude VTBs
                case 0x5654:

                    if ((ConfigData.RevisionID == 0x9A) ||
                        (ConfigData.RevisionID == 0x5A) ||
                        (ConfigData.RevisionID == 0x01))
                        {
                        VideoDebugPrint((DEBUG_NORMAL, "Rejecting VT card with revision ID 0x%X, treating as Mach 64\n", ConfigData.RevisionID));
                        BaseAddress = 0;
                        continue;
                        }

                    VideoDebugPrint((DEBUG_NORMAL, "Found ATI card with device ID 0x%X, treating as Mach 64\n", ConfigData.DeviceID));
                    break;

                // Other supported PCI chips.
                case 0x00D7: // mach64 GX
                case 0x0057: // mach64 CX
                case 0x4354: /* CT */
                case 0x4554: /* ET */
                case 0x4C54: /* LT */
                case 0x4D54: /* MT */
                case 0x5254: /* RT */
                case 0x3354: /* 3T */
                VideoDebugPrint((DEBUG_NORMAL, "Found ATI card with device ID 0x%X, treating as Mach 64\n", ConfigData.DeviceID));

                    break;

                default:
                    VideoDebugPrint((DEBUG_NORMAL, "Unsupported ATI card with device ID 0x%X\n", ConfigData.DeviceID));
                    continue;

                }

            /*
             * We will only reach this point if we find an ATI card.
             * If it is a block-relocatable card, BaseAddress will
             * be set to the I/O base address, and we must get out
             * of the loop. If it is not a block-relocatable card,
             * BaseAddress will be zero, and we must continue looking.
             */
            if (BaseAddress != 0)
                break;

            }   /* end while (FunctionNumber < 8) */

        /*
         * If we have found a Mach 64 relocatable card, we will have
         * broken out of the inner loop, but we will still be in the
         * outer loop. Since BaseAddress is zero if we have not found
         * a card, and nonzero if we have found one, check this value
         * to determine whether we should break out of the outer loop.
         */
        if (BaseAddress != 0)
            break;

        VideoDebugPrint((DEBUG_DETAIL, "Finished inner loop, zeroing function number and incrementing device number\n"));
        FunctionNumber = 0;
        DeviceNumber++;

        }   /* end while (DeviceNumber < 32) */

    return BaseAddress;

}   /* FindNextBlockATICard() */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\ati\mini\setup_cx.h ===
/************************************************************************/
/*                                                                      */
/*                              SETUP_CX.H                              */
/*                                                                      */
/*        Aug 27  1993 (c) 1993, ATI Technologies Incorporated.         */
/************************************************************************/

/**********************       PolyTron RCS Utilities
   
  $Revision:   1.17  $
      $Date:   15 Apr 1996 13:52:36  $
	$Author:   RWolff  $
	   $Log:   S:/source/wnt/ms11/miniport/archive/setup_cx.h_v  $
 * 
 *    Rev 1.17   15 Apr 1996 13:52:36   RWolff
 * Fallback to claiming 32k of BIOS if we can't get the full 64k, to avoid
 * conflict with Adaptec 154x adapters with their BIOS segment set to
 * 0xC800:0000 or 0xCC00:0000
 * 
 *    Rev 1.16   10 Apr 1996 17:04:48   RWolff
 * Now claims our BIOS segment in order to allow access to our hardware
 * capability table in the BIOS on P6 Alder machines.
 * 
 *    Rev 1.15   01 Mar 1996 12:12:34   RWolff
 * VGA Graphics Index and Graphics Data are now handled as separate
 * registers rather than as offsets into the block of VGA registers.
 * 
 *    Rev 1.14   29 Jan 1996 17:03:12   RWolff
 * Replaced list of device IDs for Mach 64 cards with list of device IDs
 * for non-Mach 64 cards.
 * 
 *    Rev 1.13   23 Jan 1996 17:53:04   RWolff
 * Added GT to list of Mach 64 cards capable of supporting block I/O.
 * 
 *    Rev 1.12   23 Jan 1996 11:51:24   RWolff
 * Removed conditionally-compiled code to use VideoPortGetAccessRanges()
 * to find block I/O cards, since this function remaps the I/O base
 * address and this is incompatible with the use of INT 10.
 * 
 *    Rev 1.11   12 Jan 1996 11:19:12   RWolff
 * ASIC type definitions used in workaround for VideoPortGetBaseAddress()
 * not working are now conditionally compiled.
 * 
 *    Rev 1.10   23 Nov 1995 11:35:12   RWolff
 * Temporary fixes to allow detection of block-relocatable GX-F2s until
 * Microsoft fixes VideoPortGetAccessRanges().
 * 
 *    Rev 1.9   24 Aug 1995 15:40:46   RWolff
 * Changed detection of block I/O cards to match Microsoft's
 * standard for plug-and-play.
 * 
 *    Rev 1.8   27 Feb 1995 17:47:32   RWOLFF
 * Added prototype for new routine IsPackedIO_cx().
 * 
 *    Rev 1.7   24 Feb 1995 12:28:04   RWOLFF
 * Added support for relocatable I/O
 * 
 *    Rev 1.6   04 Jan 1995 13:23:36   RWOLFF
 * Locked out two memory-mapped registers that were causing problems
 * on some platforms.
 * 
 *    Rev 1.5   23 Dec 1994 10:48:10   ASHANMUG
 * ALPHA/Chrontel-DAC
 * 
 *    Rev 1.4   18 Nov 1994 11:55:02   RWOLFF
 * Prototype for new routine, renamed register to CLOCK_CNTL to match latest
 * documentation, restricted this register to I/O operation only, since it
 * isn't reliable in memory mapped form.
 * 
 *    Rev 1.3   31 Aug 1994 16:31:20   RWOLFF
 * No longer claims VGA_SLEEP register, which we didn't access and which
 * conflicted with DigiBoard.
 * 
 *    Rev 1.3   31 Aug 1994 16:30:36   RWOLFF
 * No longer claims VGA_SLEEP register, which we didn't access and which
 * conflicted with DigiBoard.
 * 
 *    Rev 1.2   20 Jul 1994 12:58:38   RWOLFF
 * Added support for multiple I/O base addresses for accelerator registers.
 * 
 *    Rev 1.1   30 Jun 1994 18:16:08   RWOLFF
 * Added prototype and definitions for IsApertureConflict_cx() (moved from
 * QUERY_CX.C).
 * 
 *    Rev 1.0   31 Jan 1994 11:48:44   RWOLFF
 * Initial revision.
 * 
 *    Rev 1.0   05 Nov 1993 13:37:06   RWOLFF
 * Initial revision.

End of PolyTron RCS section                             *****************/

#ifdef DOC
SETUP_CX.H - Header file for SETUP_CX.C

#endif

/*
 * Prototypes for functions supplied by SETUP_CX.C
 */
extern VP_STATUS CompatIORangesUsable_cx(INTERFACE_TYPE SystemBus);
extern VP_STATUS CompatMMRangesUsable_cx(void);
extern int WaitForIdle_cx(void);
extern void CheckFIFOSpace_cx(WORD SpaceNeeded);
extern BOOL IsApertureConflict_cx(struct query_structure *QueryPtr);
extern USHORT GetIOBase_cx(void);
extern BOOL IsPackedIO_cx(void);


/*
 * Definitions and global variables used in searching for
 * block I/O relocatable cards.
 */
#define ATI_MAX_BLOCK_CARDS 16  /* AH values A0 through AF for INT 10 */

extern UCHAR LookForAnotherCard;



/*
 * Definitions used internally by SETUP_CX.C
 */
#ifdef INCLUDE_SETUP_CX


/*
 * Avoid runtime bugs due to overflowing the address range arrays
 * in the HW_DEVICE_EXTENSION structure.
 *
 * If more address ranges are added without increasing
 * NUM_DRIVER_ACCESS_RANGES, we will get a compile-time error because
 * too many entries in DriverIORange[] will be initialized. If
 * NUM_DRIVER_ACCESS_RANGES is increased beyond the size of
 * the arrays in the HW_DEVICE_EXTENSION structure, the "#if"
 * statement will generate a compile-time error.
 *
 * We can't use an implicit size on DriverIORange[] and define
 * NUM_DRIVER_ACCESS_RANGES as sizeof(DriverIORange)/sizeof(VIDEO_ACCESS_RANGE)
 * because the expression in a #if statement can't use the
 * sizeof() operator.
 */
#define NUM_DRIVER_ACCESS_RANGES    107

/*
 * Indicate whether the specified address range is in I/O space or
 * memory mapped space. These values are intended to make it easier
 * to read the Driver??Range[] structures.
 */
#define ISinIO          TRUE           
#define ISinMEMORY      FALSE

/*
 * Indicate that this register is not available in the current (either
 * I/O or memory mapped) form.
 */
#define DONT_USE -1

/*
 * Definitions and arrays to allow accelerator registers with variable
 * bases to be built in DriverIORange_cx[]. Definitions mark the first
 * accelerator register in the array (VGA registers have a fixed base),
 * and the number of registers to loop through while building the
 * accelerator registers. The arrays contain the variable portions
 * of the registers in the order they appear in DriverIORange_cx[],
 * and the base addresses.
 */
#define FIRST_REG_TO_BUILD  8
#define NUM_REGS_TO_BUILD   30

USHORT VariableRegisterBases[NUM_BASE_ADDRESSES] = {
    M64_STD_BASE_ADDR,
    M64_ALT_BASE_ADDR_1,
    M64_ALT_BASE_ADDR_2
};

USHORT VariableRegisterOffsets[NUM_REGS_TO_BUILD] = {
    IO_CRTC_H_TOTAL_DISP,
    IO_CRTC_H_SYNC_STRT_WID,
    IO_CRTC_V_TOTAL_DISP,
    IO_CRTC_V_SYNC_STRT_WID,
    IO_CRTC_CRNT_VLINE,

    IO_CRTC_OFF_PITCH,
    IO_CRTC_INT_CNTL,
    IO_CRTC_GEN_CNTL,
    IO_OVR_CLR,
    IO_OVR_WID_LEFT_RIGHT,

    IO_OVR_WID_TOP_BOTTOM,
    IO_CUR_CLR0,
    IO_CUR_CLR1,
    IO_CUR_OFFSET,
    IO_CUR_HORZ_VERT_POSN,

    IO_CUR_HORZ_VERT_OFF,
    IO_SCRATCH_REG0,
    IO_SCRATCH_REG1,
    IO_CLOCK_CNTL,
    IO_BUS_CNTL,

    IO_MEM_CNTL,
    IO_MEM_VGA_WP_SEL,
    IO_MEM_VGA_RP_SEL,
    IO_DAC_REGS,
    IO_DAC_CNTL,

    IO_GEN_TEST_CNTL,
    IO_CONFIG_CNTL,
    IO_CONFIG_CHIP_ID,
    IO_CONFIG_STAT0,
    IO_CONFIG_STAT1
};

/*
 * For cards with relocatable I/O, the I/O registers
 * are in a dense block, with each register at the
 * same DWORD index into the block as it is into the
 * block of memory mapped registers.
 */
USHORT RelocatableRegisterOffsets[NUM_REGS_TO_BUILD] = {
    MM_CRTC_H_TOTAL_DISP,
    MM_CRTC_H_SYNC_STRT_WID,
    MM_CRTC_V_TOTAL_DISP,
    MM_CRTC_V_SYNC_STRT_WID,
    MM_CRTC_CRNT_VLINE,

    MM_CRTC_OFF_PITCH,
    MM_CRTC_INT_CNTL,
    MM_CRTC_GEN_CNTL,
    MM_OVR_CLR,
    MM_OVR_WID_LEFT_RIGHT,

    MM_OVR_WID_TOP_BOTTOM,
    MM_CUR_CLR0,
    MM_CUR_CLR1,
    MM_CUR_OFFSET,
    MM_CUR_HORZ_VERT_POSN,

    MM_CUR_HORZ_VERT_OFF,
    MM_SCRATCH_REG0,
    MM_SCRATCH_REG1,
    MM_CLOCK_CNTL,
    MM_BUS_CNTL,

    MM_MEM_CNTL,
    MM_MEM_VGA_WP_SEL,
    MM_MEM_VGA_RP_SEL,
    MM_DAC_REGS,
    MM_DAC_CNTL,

    MM_GEN_TEST_CNTL,
    MM_CONFIG_CNTL,
    MM_CONFIG_CHIP_ID,
    MM_CONFIG_STAT0,
    MM_CONFIG_STAT1
};

/*
 * Number of registers which exist in I/O mapped form. When we claim the
 * VGA and linear apertures, we will temporarily park their address
 * ranges immediately after the I/O mapped registers.
 */
#define NUM_IO_REGISTERS    38
#define VGA_APERTURE_ENTRY  NUM_IO_REGISTERS
#define LFB_ENTRY           1   /* Offset into DriverApertureRange_cx[] */

/*
 * Size of BIOS block to claim. On some machines, we must claim the
 * region occupied by our video BIOS in order to be able to detect
 * a Mach 64, but if we claim the full 64k when we have only a 32k
 * BIOS (Mach 64 cards are available with both 32k and 64k BIOSes)
 * and the driver for a SCSI card with its BIOS segment in the second
 * 32k claims its BIOS segment, we will be rejected.
 */
#define CLAIM_64k_BIOS      0
#define CLAIM_32k_BIOS      1
#define CLAIM_APERTURE_ONLY 2
#define NUM_CLAIM_SIZES     3

ULONG VgaResourceSize[NUM_CLAIM_SIZES] =
{
    0x30000,        /* Text and graphics screens, and 64k BIOS area */
    0x28000,        /* Text and graphics screens, and 32k BIOS area */
    0x20000         /* Text and graphics screens only */
};

/*
 * Memory ranges we need to claim. The first is the VGA aperture, which
 * is always at a fixed location. The second is the linear framebuffer,
 * which we don't yet know where or how big it is. This information
 * will be filled in when we get it.
 *
 * In the VGA aperture, we must claim the graphics screen (A0000-AFFFF)
 * since this is used as the paged aperture, the text screens (B0000-B7FFF
 * and B8000-BFFFF) since the memory-mapped registers are here when we
 * use the paged aperture, and we use off-screen memory here to store our
 * query information, and the video BIOS (C0000-CFFFF) since we must
 * retrieve some information (signature string, table of maximum pixel
 * clock frequency for each resolution/refresh pair) from this region.
 * Since these areas are contiguous, and we do not need exclusive access
 * to any of them, claim them as a single block.
 */
VIDEO_ACCESS_RANGE DriverApertureRange_cx[2] = {
    {0xA0000,   0,  0,          ISinMEMORY, TRUE,   TRUE},
    {0,         0,  0,          ISinMEMORY, TRUE,   FALSE}
};


/*
 * Structure list is address, 0 or "not available" flag, length,
 * inIOspace, visible, shareable. This order matches the enumeration
 * in AMACHCX.H.
 *
 * VGAWonder-compatible I/O ranges come first in no particular order,
 * followed by the coprocessor registers in increasing order of I/O and
 * memory mapped addresses. This order was chosen because all the VGA
 * addresses are I/O mapped, as are the non-GUI coprocessor registers,
 * while the GUI coprocessor registers are only available as memory mapped.
 *
 * Since all the I/O mapped registers are in a block at the beginning of
 * the structure, we can feed VideoPortVerifyAccessRanges() a truncated
 * version of the structure (all I/O mapped registers, but none that are
 * only available as memory-mapped) to claim the I/O address space we need.
 *
 * The I/O addresses shown for accelerator registers are for reference only,
 * to show which register goes in which location. The actual register
 * value will be built "on the fly", since these registers have variable
 * base addresses.
 */
VIDEO_ACCESS_RANGE DriverIORange_cx[NUM_DRIVER_ACCESS_RANGES] = {
    {IO_VGA_BASE_IO_PORT        , 0         , IO_VGA_START_BREAK_PORT - IO_VGA_BASE_IO_PORT + 1, ISinIO, TRUE, TRUE},
    {IO_VGA_END_BREAK_PORT      , 0         , IO_VGA_MAX_IO_PORT    - IO_VGA_END_BREAK_PORT + 1, ISinIO, TRUE, TRUE},
    {IO_VGA_SEQ_IND             , 0         , 2, ISinIO, TRUE   , TRUE},
    {IO_VGA_SEQ_DATA            , 0         , 1, ISinIO, TRUE   , TRUE},
    {IO_VGA_GRAX_IND            , 0         , 2, ISinIO, TRUE   , TRUE},

    {IO_VGA_GRAX_DATA           , 0         , 1, ISinIO, TRUE   , TRUE},
    {IO_reg1CE                  , 0         , 2, ISinIO, TRUE   , TRUE},
    {IO_reg1CF                  , 0         , 1, ISinIO, TRUE   , TRUE},
    {IO_CRTC_H_TOTAL_DISP       , 0         , 4, ISinIO, TRUE   , FALSE},
    {IO_CRTC_H_SYNC_STRT_WID    , 0         , 4, ISinIO, TRUE   , FALSE},

    {IO_CRTC_V_TOTAL_DISP       , 0         , 4, ISinIO, TRUE   , FALSE},   // 10
    {IO_CRTC_V_SYNC_STRT_WID    , 0         , 4, ISinIO, TRUE   , FALSE},
    {IO_CRTC_CRNT_VLINE         , 0         , 4, ISinIO, TRUE   , FALSE},
    {IO_CRTC_OFF_PITCH          , 0         , 4, ISinIO, TRUE   , FALSE},
    {IO_CRTC_INT_CNTL           , 0         , 4, ISinIO, TRUE   , FALSE},

    {IO_CRTC_GEN_CNTL           , 0         , 4, ISinIO, TRUE   , FALSE},
    {IO_OVR_CLR                 , 0         , 4, ISinIO, TRUE   , FALSE},
    {IO_OVR_WID_LEFT_RIGHT      , 0         , 4, ISinIO, TRUE   , FALSE},
    {IO_OVR_WID_TOP_BOTTOM      , 0         , 4, ISinIO, TRUE   , FALSE},
    {IO_CUR_CLR0                , 0         , 4, ISinIO, TRUE   , FALSE},

    {IO_CUR_CLR1                , 0         , 4, ISinIO, TRUE   , FALSE},   // 20
    {IO_CUR_OFFSET              , 0         , 4, ISinIO, TRUE   , FALSE},
    {IO_CUR_HORZ_VERT_POSN      , 0         , 4, ISinIO, TRUE   , FALSE},
    {IO_CUR_HORZ_VERT_OFF       , 0         , 4, ISinIO, TRUE   , FALSE},
    {IO_SCRATCH_REG0            , 0         , 4, ISinIO, TRUE   , FALSE},

    {IO_SCRATCH_REG1            , 0         , 4, ISinIO, TRUE   , FALSE},
    {IO_CLOCK_CNTL              , 0         , 4, ISinIO, TRUE   , FALSE},
    {IO_BUS_CNTL                , 0         , 4, ISinIO, TRUE   , FALSE},
    {IO_MEM_CNTL                , 0         , 4, ISinIO, TRUE   , FALSE},
    {IO_MEM_VGA_WP_SEL          , 0         , 4, ISinIO, TRUE   , FALSE},

    {IO_MEM_VGA_RP_SEL          , 0         , 4, ISinIO, TRUE   , FALSE},   // 30
    {IO_DAC_REGS                , 0         , 4, ISinIO, TRUE   , FALSE},
    {IO_DAC_CNTL                , 0         , 4, ISinIO, TRUE   , FALSE},
    {IO_GEN_TEST_CNTL           , 0         , 4, ISinIO, TRUE   , FALSE},
    {IO_CONFIG_CNTL             , 0         , 4, ISinIO, TRUE   , FALSE},

    {IO_CONFIG_CHIP_ID          , 0         , 4, ISinIO, TRUE   , FALSE},
    {IO_CONFIG_STAT0            , 0         , 4, ISinIO, TRUE   , FALSE},
    {IO_CONFIG_STAT1            , 0         , 4, ISinIO, TRUE   , FALSE},
    {FALSE                      , DONT_USE  , 0, ISinIO, TRUE   , FALSE},
    {FALSE                      , DONT_USE  , 0, ISinIO, TRUE   , FALSE},

    {FALSE                      , DONT_USE  , 0, ISinIO, TRUE   , FALSE},   // 40
    {FALSE                      , DONT_USE  , 0, ISinIO, TRUE   , FALSE},
    {FALSE                      , DONT_USE  , 0, ISinIO, TRUE   , FALSE},
    {FALSE                      , DONT_USE  , 0, ISinIO, TRUE   , FALSE},
    {FALSE                      , DONT_USE  , 0, ISinIO, TRUE   , FALSE},

    {FALSE                      , DONT_USE  , 0, ISinIO, TRUE   , FALSE},
    {FALSE                      , DONT_USE  , 0, ISinIO, TRUE   , FALSE},
    {FALSE                      , DONT_USE  , 0, ISinIO, TRUE   , FALSE},
    {FALSE                      , DONT_USE  , 0, ISinIO, TRUE   , FALSE},
    {FALSE                      , DONT_USE  , 0, ISinIO, TRUE   , FALSE},

    {FALSE                      , DONT_USE  , 0, ISinIO, TRUE   , FALSE},   // 50
    {FALSE                      , DONT_USE  , 0, ISinIO, TRUE   , FALSE},
    {FALSE                      , DONT_USE  , 0, ISinIO, TRUE   , FALSE},
    {FALSE                      , DONT_USE  , 0, ISinIO, TRUE   , FALSE},
    {FALSE                      , DONT_USE  , 0, ISinIO, TRUE   , FALSE},

    {FALSE                      , DONT_USE  , 0, ISinIO, TRUE   , FALSE},
    {FALSE                      , DONT_USE  , 0, ISinIO, TRUE   , FALSE},
    {FALSE                      , DONT_USE  , 0, ISinIO, TRUE   , FALSE},
    {FALSE                      , DONT_USE  , 0, ISinIO, TRUE   , FALSE},
    {FALSE                      , DONT_USE  , 0, ISinIO, TRUE   , FALSE},

    {FALSE                      , DONT_USE  , 0, ISinIO, TRUE   , FALSE},   // 60
    {FALSE                      , DONT_USE  , 0, ISinIO, TRUE   , FALSE},
    {FALSE                      , DONT_USE  , 0, ISinIO, TRUE   , FALSE},
    {FALSE                      , DONT_USE  , 0, ISinIO, TRUE   , FALSE},
    {FALSE                      , DONT_USE  , 0, ISinIO, TRUE   , FALSE},

    {FALSE                      , DONT_USE  , 0, ISinIO, TRUE   , FALSE},
    {FALSE                      , DONT_USE  , 0, ISinIO, TRUE   , FALSE},
    {FALSE                      , DONT_USE  , 0, ISinIO, TRUE   , FALSE},
    {FALSE                      , DONT_USE  , 0, ISinIO, TRUE   , FALSE},
    {FALSE                      , DONT_USE  , 0, ISinIO, TRUE   , FALSE},

    {FALSE                      , DONT_USE  , 0, ISinIO, TRUE   , FALSE},   // 70
    {FALSE                      , DONT_USE  , 0, ISinIO, TRUE   , FALSE},
    {FALSE                      , DONT_USE  , 0, ISinIO, TRUE   , FALSE},
    {FALSE                      , DONT_USE  , 0, ISinIO, TRUE   , FALSE},
    {FALSE                      , DONT_USE  , 0, ISinIO, TRUE   , FALSE},

    {FALSE                      , DONT_USE  , 0, ISinIO, TRUE   , FALSE},
    {FALSE                      , DONT_USE  , 0, ISinIO, TRUE   , FALSE},
    {FALSE                      , DONT_USE  , 0, ISinIO, TRUE   , FALSE},
    {FALSE                      , DONT_USE  , 0, ISinIO, TRUE   , FALSE},
    {FALSE                      , DONT_USE  , 0, ISinIO, TRUE   , FALSE},

    {FALSE                      , DONT_USE  , 0, ISinIO, TRUE   , FALSE},   // 80
    {FALSE                      , DONT_USE  , 0, ISinIO, TRUE   , FALSE},
    {FALSE                      , DONT_USE  , 0, ISinIO, TRUE   , FALSE},
    {FALSE                      , DONT_USE  , 0, ISinIO, TRUE   , FALSE},
    {FALSE                      , DONT_USE  , 0, ISinIO, TRUE   , FALSE},

    {FALSE                      , DONT_USE  , 0, ISinIO, TRUE   , FALSE},
    {FALSE                      , DONT_USE  , 0, ISinIO, TRUE   , FALSE},
    {FALSE                      , DONT_USE  , 0, ISinIO, TRUE   , FALSE},
    {FALSE                      , DONT_USE  , 0, ISinIO, TRUE   , FALSE},
    {FALSE                      , DONT_USE  , 0, ISinIO, TRUE   , FALSE},

    {FALSE                      , DONT_USE  , 0, ISinIO, TRUE   , FALSE},   // 90
    {FALSE                      , DONT_USE  , 0, ISinIO, TRUE   , FALSE},
    {FALSE                      , DONT_USE  , 0, ISinIO, TRUE   , FALSE},
    {FALSE                      , DONT_USE  , 0, ISinIO, TRUE   , FALSE},
    {FALSE                      , DONT_USE  , 0, ISinIO, TRUE   , FALSE},

    {FALSE                      , DONT_USE  , 0, ISinIO, TRUE   , FALSE},
    {FALSE                      , DONT_USE  , 0, ISinIO, TRUE   , FALSE},
    {FALSE                      , DONT_USE  , 0, ISinIO, TRUE   , FALSE},
    {FALSE                      , DONT_USE  , 0, ISinIO, TRUE   , FALSE},
    {FALSE                      , DONT_USE  , 0, ISinIO, TRUE   , FALSE},

    {FALSE                      , DONT_USE  , 0, ISinIO, TRUE   , FALSE},   // 100
    {FALSE                      , DONT_USE  , 0, ISinIO, TRUE   , FALSE},
    {FALSE                      , DONT_USE  , 0, ISinIO, TRUE   , FALSE},
    {FALSE                      , DONT_USE  , 0, ISinIO, TRUE   , FALSE},
    {FALSE                      , DONT_USE  , 0, ISinIO, TRUE   , FALSE},

    {FALSE                      , DONT_USE  , 0, ISinIO, TRUE   , FALSE},
    {FALSE                      , DONT_USE  , 0, ISinIO, TRUE   , FALSE}
    };

#if NUM_DRIVER_ACCESS_RANGES > NUM_ADDRESS_RANGES_ALLOWED
    Insufficient address ranges for 68800CX-compatible graphics cards.
#endif

#define DONT_USE -1     /* Shows that this register is not memory mapped */

/*
 * Structure list is address, 0 or "not available" flag, length,
 * inIOspace, visible, shareable. This order matches the enumeration
 * in AMACHCX.H.
 *
 * The registers in this structure are in the same order as in
 * DriverIORange_cx[], except here we are defining memory mapped
 * registers instead of I/O mapped registers.
 *
 * Some registers are grouped to allow block writes larger than
 * the 32 bit register size. To allow this, let Windows NT think
 * that the size of this register is actually the total size (in
 * bytes) of all remaining registers in the group.
 */
VIDEO_ACCESS_RANGE DriverMMRange_cx[NUM_DRIVER_ACCESS_RANGES] = {
    {FALSE                      , DONT_USE  , 0, ISinMEMORY,    TRUE,   FALSE},
    {FALSE                      , DONT_USE  , 0, ISinMEMORY,    TRUE,   FALSE},
    {FALSE                      , DONT_USE  , 0, ISinMEMORY,    TRUE,   FALSE},
    {FALSE                      , DONT_USE  , 0, ISinMEMORY,    TRUE,   FALSE},
    {FALSE                      , DONT_USE  , 0, ISinMEMORY,    TRUE,   FALSE},

    {FALSE                      , DONT_USE  , 0, ISinMEMORY,    TRUE,   FALSE},
    {FALSE                      , DONT_USE  , 0, ISinMEMORY,    TRUE,   FALSE},
    {FALSE                      , DONT_USE  , 0, ISinMEMORY,    TRUE,   FALSE},
    {MM_CRTC_H_TOTAL_DISP       , 0         , 4, ISinMEMORY,    TRUE,   FALSE},
    {MM_CRTC_H_SYNC_STRT_WID    , 0         , 4, ISinMEMORY,    TRUE,   FALSE},

    {MM_CRTC_V_TOTAL_DISP       , 0         , 4, ISinMEMORY,    TRUE,   FALSE}, // 10
    {MM_CRTC_V_SYNC_STRT_WID    , 0         , 4, ISinMEMORY,    TRUE,   FALSE},
    {MM_CRTC_CRNT_VLINE         , 0         , 4, ISinMEMORY,    TRUE,   FALSE},
    {MM_CRTC_OFF_PITCH          , 0         , 4, ISinMEMORY,    TRUE,   FALSE},
    {MM_CRTC_INT_CNTL           , 0         , 4, ISinMEMORY,    TRUE,   FALSE},

    {MM_CRTC_GEN_CNTL           , 0         , 4, ISinMEMORY,    TRUE,   FALSE},
    {MM_OVR_CLR                 , 0         , 4, ISinMEMORY,    TRUE,   FALSE},
    {MM_OVR_WID_LEFT_RIGHT      , 0         , 4, ISinMEMORY,    TRUE,   FALSE},
    {MM_OVR_WID_TOP_BOTTOM      , 0         , 4, ISinMEMORY,    TRUE,   FALSE},
    {MM_CUR_CLR0                , 0         , 4, ISinMEMORY,    TRUE,   FALSE},

    {MM_CUR_CLR1                , 0         , 4, ISinMEMORY,    TRUE,   FALSE}, // 20
    {MM_CUR_OFFSET              , 0         , 4, ISinMEMORY,    TRUE,   FALSE},
    {MM_CUR_HORZ_VERT_POSN      , 0         , 4, ISinMEMORY,    TRUE,   FALSE},
    {MM_CUR_HORZ_VERT_OFF       , 0         , 4, ISinMEMORY,    TRUE,   FALSE},
    {MM_SCRATCH_REG0            , 0         , 4, ISinMEMORY,    TRUE,   FALSE},

    {MM_SCRATCH_REG1            , 0         , 4, ISinMEMORY,    TRUE,   FALSE},
    {FALSE                      , DONT_USE  , 0, ISinMEMORY,    TRUE,   FALSE},
    {MM_BUS_CNTL                , 0         , 4, ISinMEMORY,    TRUE,   FALSE},
    {MM_MEM_CNTL                , 0         , 4, ISinMEMORY,    TRUE,   FALSE},
    {MM_MEM_VGA_WP_SEL          , 0         , 4, ISinMEMORY,    TRUE,   FALSE},

    {MM_MEM_VGA_RP_SEL          , 0         , 4, ISinMEMORY,    TRUE,   FALSE}, // 30
    {FALSE                      , DONT_USE  , 0, ISinMEMORY,    TRUE,   FALSE},
    {FALSE                      , DONT_USE  , 0, ISinMEMORY,    TRUE,   FALSE},
    {MM_GEN_TEST_CNTL           , 0         , 4, ISinMEMORY,    TRUE,   FALSE},
    {FALSE                      , DONT_USE  , 0, ISinMEMORY,    TRUE,   FALSE},

    {MM_CONFIG_CHIP_ID          , 0         , 4, ISinMEMORY,    TRUE,   FALSE},
    {MM_CONFIG_STAT0            , 0         , 4, ISinMEMORY,    TRUE,   FALSE},
    {MM_CONFIG_STAT1            , 0         , 4, ISinMEMORY,    TRUE,   FALSE},
    {MM_DST_OFF_PITCH           , 0         , 4, ISinMEMORY,    TRUE,   FALSE},
    {MM_DST_X                   , 0         , 4, ISinMEMORY,    TRUE,   FALSE},

    {MM_DST_Y                   , 0         , 4, ISinMEMORY,    TRUE,   FALSE}, // 40
    {MM_DST_Y_X                 , 0         , 4, ISinMEMORY,    TRUE,   FALSE},
    {MM_DST_WIDTH               , 0         , 4, ISinMEMORY,    TRUE,   FALSE},
    {MM_DST_HEIGHT              , 0         , 4, ISinMEMORY,    TRUE,   FALSE},
    {MM_DST_HEIGHT_WIDTH        , 0         , 4, ISinMEMORY,    TRUE,   FALSE},

    {MM_DST_X_WIDTH             , 0         , 4, ISinMEMORY,    TRUE,   FALSE},
    {MM_DST_BRES_LNTH           , 0         , 4, ISinMEMORY,    TRUE,   FALSE},
    {MM_DST_BRES_ERR            , 0         , 4, ISinMEMORY,    TRUE,   FALSE},
    {MM_DST_BRES_INC            , 0         , 4, ISinMEMORY,    TRUE,   FALSE},
    {MM_DST_BRES_DEC            , 0         , 4, ISinMEMORY,    TRUE,   FALSE},

    {MM_DST_CNTL                , 0         , 4, ISinMEMORY,    TRUE,   FALSE}, // 50
    {MM_SRC_OFF_PITCH           , 0         , 4, ISinMEMORY,    TRUE,   FALSE},
    {MM_SRC_X                   , 0         , 4, ISinMEMORY,    TRUE,   FALSE},
    {MM_SRC_Y                   , 0         , 4, ISinMEMORY,    TRUE,   FALSE},
    {MM_SRC_Y_X                 , 0         , 4, ISinMEMORY,    TRUE,   FALSE},

    {MM_SRC_WIDTH1              , 0         , 4, ISinMEMORY,    TRUE,   FALSE},
    {MM_SRC_HEIGHT1             , 0         , 4, ISinMEMORY,    TRUE,   FALSE},
    {MM_SRC_HEIGHT1_WIDTH1      , 0         , 4, ISinMEMORY,    TRUE,   FALSE},
    {MM_SRC_X_START             , 0         , 4, ISinMEMORY,    TRUE,   FALSE},
    {MM_SRC_Y_START             , 0         , 4, ISinMEMORY,    TRUE,   FALSE},

    {MM_SRC_Y_X_START           , 0         , 4, ISinMEMORY,    TRUE,   FALSE}, // 60
    {MM_SRC_WIDTH2              , 0         , 4, ISinMEMORY,    TRUE,   FALSE},
    {MM_SRC_HEIGHT2             , 0         , 4, ISinMEMORY,    TRUE,   FALSE},
    {MM_SRC_HEIGHT2_WIDTH2      , 0         , 4, ISinMEMORY,    TRUE,   FALSE},
    {MM_SRC_CNTL                , 0         , 4, ISinMEMORY,    TRUE,   FALSE},

    {MM_HOST_DATA0              , 0         ,64, ISinMEMORY,    TRUE,   FALSE},
    {MM_HOST_DATA1              , 0         ,60, ISinMEMORY,    TRUE,   FALSE},
    {MM_HOST_DATA2              , 0         ,56, ISinMEMORY,    TRUE,   FALSE},
    {MM_HOST_DATA3              , 0         ,52, ISinMEMORY,    TRUE,   FALSE},
    {MM_HOST_DATA4              , 0         ,48, ISinMEMORY,    TRUE,   FALSE},

    {MM_HOST_DATA5              , 0         ,44, ISinMEMORY,    TRUE,   FALSE}, // 70
    {MM_HOST_DATA6              , 0         ,40, ISinMEMORY,    TRUE,   FALSE},
    {MM_HOST_DATA7              , 0         ,36, ISinMEMORY,    TRUE,   FALSE},
    {MM_HOST_DATA8              , 0         ,32, ISinMEMORY,    TRUE,   FALSE},
    {MM_HOST_DATA9              , 0         ,28, ISinMEMORY,    TRUE,   FALSE},

    {MM_HOST_DATA10             , 0         ,24, ISinMEMORY,    TRUE,   FALSE},
    {MM_HOST_DATA11             , 0         ,20, ISinMEMORY,    TRUE,   FALSE},
    {MM_HOST_DATA12             , 0         ,16, ISinMEMORY,    TRUE,   FALSE},
    {MM_HOST_DATA13             , 0         ,12, ISinMEMORY,    TRUE,   FALSE},
    {MM_HOST_DATA14             , 0         , 8, ISinMEMORY,    TRUE,   FALSE},

    {MM_HOST_DATA15             , 0         , 4, ISinMEMORY,    TRUE,   FALSE}, // 80
    {MM_HOST_CNTL               , 0         , 4, ISinMEMORY,    TRUE,   FALSE},
    {MM_PAT_REG0                , 0         , 8, ISinMEMORY,    TRUE,   FALSE},
    {MM_PAT_REG1                , 0         , 4, ISinMEMORY,    TRUE,   FALSE},
    {MM_PAT_CNTL                , 0         , 4, ISinMEMORY,    TRUE,   FALSE},

    {MM_SC_LEFT                 , 0         , 4, ISinMEMORY,    TRUE,   FALSE},
    {MM_SC_RIGHT                , 0         , 4, ISinMEMORY,    TRUE,   FALSE},
    {MM_SC_LEFT_RIGHT           , 0         , 4, ISinMEMORY,    TRUE,   FALSE},
    {MM_SC_TOP                  , 0         , 4, ISinMEMORY,    TRUE,   FALSE},
    {MM_SC_BOTTOM               , 0         , 4, ISinMEMORY,    TRUE,   FALSE},

    {MM_SC_TOP_BOTTOM           , 0         , 4, ISinMEMORY,    TRUE,   FALSE}, // 90
    {MM_DP_BKGD_CLR             , 0         , 4, ISinMEMORY,    TRUE,   FALSE},
    {MM_DP_FRGD_CLR             , 0         , 4, ISinMEMORY,    TRUE,   FALSE},
    {MM_DP_WRITE_MASK           , 0         , 4, ISinMEMORY,    TRUE,   FALSE},
    {MM_DP_CHAIN_MASK           , 0         , 4, ISinMEMORY,    TRUE,   FALSE},

    {MM_DP_PIX_WIDTH            , 0         , 4, ISinMEMORY,    TRUE,   FALSE},
    {MM_DP_MIX                  , 0         , 4, ISinMEMORY,    TRUE,   FALSE},
    {MM_DP_SRC                  , 0         , 4, ISinMEMORY,    TRUE,   FALSE},
    {MM_CLR_CMP_CLR             , 0         , 4, ISinMEMORY,    TRUE,   FALSE},
    {MM_CLR_CMP_MSK             , 0         , 4, ISinMEMORY,    TRUE,   FALSE},

    {MM_CLR_CMP_CNTL            , 0         , 4, ISinMEMORY,    TRUE,   FALSE}, // 100
    {MM_FIFO_STAT               , 0         , 4, ISinMEMORY,    TRUE,   FALSE},
    {MM_CONTEXT_MASK            , 0         , 4, ISinMEMORY,    TRUE,   FALSE},
    {MM_CONTEXT_SAVE_CNTL       , 0         , 4, ISinMEMORY,    TRUE,   FALSE},
    {MM_CONTEXT_LOAD_CNTL       , 0         , 4, ISinMEMORY,    TRUE,   FALSE},

    {MM_GUI_TRAJ_CNTL           , 0         , 4, ISinMEMORY,    TRUE,   FALSE},
    {MM_GUI_STAT                , 0         , 4, ISinMEMORY,    TRUE,   FALSE}
    };


/*
 * Device IDs for PCI configuration registers. Only non-Mach 64
 * IDs are listed here, since future IDs will (for the forseeable
 * future) almost certainly be Mach 64 cards, so we can assume
 * that any ID we haven't rejected is a Mach 64, which we should
 * accept.
 *
 * Currently, the Mach 32 AX is our only PCI card which is not
 * a Mach 64.
 */
#define ATI_DEVID_M32AX 0x4158


#endif  /* defined INCLUDE_SETUP_CX */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\ati\mini\setup_m.h ===
/************************************************************************/
/*                                                                      */
/*                              SETUP_M.H                               */
/*                                                                      */
/*        Aug 27  1993 (c) 1993, ATI Technologies Incorporated.         */
/************************************************************************/

/**********************       PolyTron RCS Utilities
   
  $Revision:   1.5  $
      $Date:   18 May 1995 14:14:34  $
	$Author:   RWOLFF  $
	   $Log:   S:/source/wnt/ms11/miniport/vcs/setup_m.h  $
 * 
 *    Rev 1.5   18 May 1995 14:14:34   RWOLFF
 * No longer uses the memory-mapped form of CLOCK_SEL (sometimes the
 * value written wouldn't "take" even though a readback showed the
 * correct value).
 * 
 *    Rev 1.4   23 Dec 1994 10:48:16   ASHANMUG
 * ALPHA/Chrontel-DAC
 * 
 *    Rev 1.3   07 Jul 1994 14:00:48   RWOLFF
 * Andre Vachon's fix: re-sized DriverMMRange_m[] from NUM_DRIVER_ACCESS_RANGES
 * entries to NUM_IO_ACCESS_RANGES entries because this array doesn't need
 * a slot for the framebuffer.
 * 
 *    Rev 1.2   30 Jun 1994 18:22:38   RWOLFF
 * Added prototypes for IsApertureConflict_m() and IsVGAConflict_m(), and
 * definitions used by these routines.
 * 
 *    Rev 1.1   20 May 1994 14:04:18   RWOLFF
 * Ajith's change: removed unused register SRC_CMP_COLOR from lists to be mapped
 * 
 *    Rev 1.0   31 Jan 1994 11:49:36   RWOLFF
 * Initial revision.
 * 
 *    Rev 1.5   14 Jan 1994 15:27:02   RWOLFF
 * Added prototype for MemoryMappedEnabled_m()
 * 
 *    Rev 1.4   15 Dec 1993 15:32:40   RWOLFF
 * No longer claims EISA configuration registers and placeholder for
 * the linear framebuffer.
 * 
 *    Rev 1.3   05 Nov 1993 13:32:50   RWOLFF
 * Added prototype of function to unmap I/O address ranges.
 * 
 *    Rev 1.1   08 Oct 1993 11:16:46   RWOLFF
 * Added I/O vs. Memory Mapped definitions formerly in ATIMP.H.
 * 
 *    Rev 1.0   03 Sep 1993 14:29:26   RWOLFF
 * Initial revision.

End of PolyTron RCS section                             *****************/

#ifdef DOC
SETUP_M.H - Header file for SETUP_M.C

#endif

/*
 * Prototypes for functions supplied by SETUP_M.C
 */
extern VP_STATUS CompatIORangesUsable_m(void);
extern void CompatMMRangesUsable_m(void);
extern void UnmapIORanges_m(void);
extern BOOL MemoryMappedEnabled_m(void);
extern int WaitForIdle_m(void);
extern void CheckFIFOSpace_m(WORD SpaceNeeded);
extern BOOL IsApertureConflict_m(struct query_structure *QueryPtr);
extern BOOL IsVGAConflict_m(void);


/*
 * Definitions used internally by SETUP_M.C
 */
#ifdef INCLUDE_SETUP_M


/*
 * Avoid runtime bugs due to overflowing the address range arrays
 * in the HW_DEVICE_EXTENSION structure.
 *
 * If more address ranges are added without increasing
 * NUM_DRIVER_ACCESS_RANGES, we will get a compile-time error because
 * too many entries in DriverIORange[] will be initialized. If
 * NUM_DRIVER_ACCESS_RANGES is increased beyond the size of
 * the arrays in the HW_DEVICE_EXTENSION structure, the "#if"
 * statement will generate a compile-time error.
 *
 * We can't use an implicit size on DriverIORange[] and define
 * NUM_DRIVER_ACCESS_RANGES as sizeof(DriverIORange)/sizeof(VIDEO_ACCESS_RANGE)
 * because the expression in a #if statement can't use the
 * sizeof() operator.
 */
#define NUM_DRIVER_ACCESS_RANGES    20*5+2
#define FRAMEBUFFER_ENTRY           NUM_DRIVER_ACCESS_RANGES - 1
#define NUM_IO_ACCESS_RANGES        FRAMEBUFFER_ENTRY

/*
 * Indicate whether the specified address range is in I/O space or
 * memory mapped space. These values are intended to make it easier
 * to read the Driver??Range[] structures.
 */
#define ISinIO          TRUE           
#define ISinMEMORY      FALSE


//------------------------------------------------------------------
// struct list is address, 0, length, inIOspace, visible, sharable   
// this order MATCHES  AMACH.H ENUM data  structure
// all entries are in INCREASING IO address.
VIDEO_ACCESS_RANGE DriverIORange_m[NUM_DRIVER_ACCESS_RANGES] = {
     {IO_DAC_MASK          , 0, 1, ISinIO, 1, FALSE},    // Mach DAC registers
     {IO_DAC_R_INDEX       , 0, 1, ISinIO, 1, FALSE},
     {IO_DAC_W_INDEX       , 0, 1, ISinIO, 1, FALSE},       
     {IO_DAC_DATA          , 0, 3, ISinIO, 1, FALSE},       
     {IO_DISP_STATUS       , 0, 1, ISinIO, 1, FALSE},    // First Mach register

     {IO_OVERSCAN_COLOR_8  , 0, 2, ISinIO, 1, FALSE},
     {IO_H_DISP            , 0, 2, ISinIO, 1, FALSE},
     {IO_OVERSCAN_GREEN_24 , 0, 2, ISinIO, 1, FALSE},
     {IO_H_SYNC_STRT       , 0, 1, ISinIO, 1, FALSE},
     {IO_CURSOR_OFFSET_LO  , 0, 2, ISinIO, 1, FALSE},

     {IO_H_SYNC_WID        , 0, 1, ISinIO, 1, FALSE},                // 10
     {IO_CURSOR_OFFSET_HI  , 0, 2, ISinIO, 1, FALSE},
     {IO_V_TOTAL           , 0, 2, ISinIO, 1, FALSE},
     {IO_CONFIG_STATUS_1   , 0, 2, ISinIO, 1, FALSE},
     {IO_V_DISP            , 0, 2, ISinIO, 1, FALSE},

     {IO_CONFIG_STATUS_2   , 0, 2, ISinIO, 1, FALSE},
     {IO_V_SYNC_STRT       , 0, 2, ISinIO, 1, FALSE},
     {IO_CURSOR_COLOR_0    , 0, 2, ISinIO, 1, FALSE},
     {IO_CURSOR_COLOR_1    , 0, 1, ISinIO, 1, FALSE},
     {IO_V_SYNC_WID        , 0, 2, ISinIO, 1, FALSE},

     {IO_HORZ_CURSOR_OFFSET, 0, 1, ISinIO, 1, FALSE},                // 20
     {IO_VERT_CURSOR_OFFSET, 0, 1, ISinIO, 1, FALSE},
     {IO_DISP_CNTL         , 0, 1, ISinIO, 1, FALSE},
     {IO_CRT_PITCH         , 0, 2, ISinIO, 1, FALSE},
     {IO_CRT_OFFSET_LO     , 0, 2, ISinIO, 1, FALSE},

     {IO_CRT_OFFSET_HI     , 0, 2, ISinIO, 1, FALSE},
     {IO_LOCAL_CONTROL     , 0, 2, ISinIO, 1, FALSE},
     {IO_FIFO_OPT          , 0, 2, ISinIO, 1, FALSE},
     {IO_EXT_CURSOR_COLOR_0, 0, 2, ISinIO, 1, FALSE},
     {IO_EXT_CURSOR_COLOR_1, 0, 2, ISinIO, 1, FALSE},

     {IO_SUBSYS_CNTL       , 0, 2, ISinIO, 1, FALSE},                // 30
     {IO_MEM_BNDRY         , 0, 1, ISinIO, 1, FALSE},
     {IO_ROM_PAGE_SEL      , 0, 2, ISinIO, 1, FALSE},
     {IO_SHADOW_CTL        , 0, 2, ISinIO, 1, FALSE},
     {IO_ADVFUNC_CNTL      , 0, 2, ISinIO, 1, FALSE},

     {IO_CLOCK_SEL         , 0, 2, ISinIO, 1, FALSE},
     {IO_ROM_ADDR_1        , 0, 2, ISinIO, 1, FALSE},
     {IO_ROM_ADDR_2        , 0, 2, ISinIO, 1, FALSE},
     {IO_SHADOW_SET        , 0, 2, ISinIO, 1, FALSE},
     {IO_MEM_CFG           , 0, 2, ISinIO, 1, FALSE},

     {IO_EXT_GE_STATUS     , 0, 2, ISinIO, 1, FALSE},                // 40
     {IO_VERT_OVERSCAN     , 0, 2, ISinIO, 1, FALSE},
     {IO_MAX_WAITSTATES    , 0, 2, ISinIO, 1, FALSE},
     {IO_GE_OFFSET_LO      , 0, 2, ISinIO, 1, FALSE},
     {IO_BOUNDS_LEFT       , 0, 2, ISinIO, 1, FALSE},

     {IO_BOUNDS_TOP        , 0, 2, ISinIO, 1, FALSE},
     {IO_BOUNDS_RIGHT      , 0, 2, ISinIO, 1, FALSE},
     {IO_BOUNDS_BOTTOM     , 0, 2, ISinIO, 1, FALSE},
     {IO_CUR_Y             , 0, 2, ISinIO, 1, FALSE},
     {IO_PATT_DATA_INDEX   , 0, 2, ISinIO, 1, FALSE},

     {IO_CUR_X             , 0, 2, ISinIO, 1, FALSE},                // 50
     {IO_SRC_Y             , 0, 2, ISinIO, 1, FALSE},
     {IO_SRC_X             , 0, 2, ISinIO, 1, FALSE},
     {IO_PATT_DATA         , 0, 2, ISinIO, 1, FALSE},
     {IO_ERR_TERM          , 0, 2, ISinIO, 1, FALSE},

     {IO_R_MISC_CNTL       , 0, 2, ISinIO, 1, FALSE},
     {IO_MAJ_AXIS_PCNT     , 0, 2, ISinIO, 1, FALSE},
     {IO_BRES_COUNT        , 0, 2, ISinIO, 1, FALSE},
     {IO_CMD               , 0, 2, ISinIO, 1, FALSE},
     {IO_LINEDRAW_INDEX    , 0, 2, ISinIO, 1, FALSE},

     {IO_SHORT_STROKE      , 0, 2, ISinIO, 1, FALSE},                // 60
     {IO_BKGD_COLOR        , 0, 2, ISinIO, 1, FALSE},
     {IO_LINEDRAW_OPT      , 0, 2, ISinIO, 1, FALSE},
     {IO_FRGD_COLOR        , 0, 2, ISinIO, 1, FALSE},
     {IO_DEST_X_START      , 0, 2, ISinIO, 1, FALSE},

     {IO_WRT_MASK          , 0, 2, ISinIO, 1, FALSE},
     {IO_DEST_X_END        , 0, 2, ISinIO, 1, FALSE},
     {IO_RD_MASK           , 0, 2, ISinIO, 1, FALSE},
     {IO_DEST_Y_END        , 0, 2, ISinIO, 1, FALSE},
     {IO_CMP_COLOR         , 0, 2, ISinIO, 1, FALSE},

     {IO_SRC_X_START       , 0, 2, ISinIO, 1, FALSE},                // 70
     {IO_BKGD_MIX          , 0, 2, ISinIO, 1, FALSE},
     {IO_ALU_BG_FN         , 0, 2, ISinIO, 1, FALSE},
     {IO_FRGD_MIX          , 0, 2, ISinIO, 1, FALSE},
     {IO_ALU_FG_FN         , 0, 2, ISinIO, 1, FALSE},

     {IO_MULTIFUNC_CNTL    , 0, 2, ISinIO, 1, FALSE},
     {IO_SRC_X_END         , 0, 2, ISinIO, 1, FALSE},
     {IO_SRC_Y_DIR         , 0, 2, ISinIO, 1, FALSE},
     {IO_EXT_SSV           , 0, 2, ISinIO, 1, FALSE},
     {IO_SCAN_X            , 0, 2, ISinIO, 1, FALSE},

     {IO_DP_CONFIG         , 0, 2, ISinIO, 1, FALSE},                // 80
     {IO_PATT_LENGTH       , 0, 2, ISinIO, 1, FALSE},
     {IO_PATT_INDEX        , 0, 2, ISinIO, 1, FALSE},
     {IO_EXT_SCISSOR_L     , 0, 2, ISinIO, 1, FALSE},
     {IO_EXT_SCISSOR_T     , 0, 2, ISinIO, 1, FALSE},

     {IO_PIX_TRANS         , 0, 2, ISinIO, 1, FALSE},
     {IO_PIX_TRANS_HI      , 0, 1, ISinIO, 1, FALSE},
     {IO_EXT_SCISSOR_R     , 0, 2, ISinIO, 1, FALSE},
     {IO_EXT_SCISSOR_B     , 0, 2, ISinIO, 1, FALSE},
     {IO_DEST_CMP_FN       , 0, 2, ISinIO, 1, FALSE},

     {IO_ASIC_ID           , 0, 2, ISinIO, 1, FALSE},                // 90
     {IO_LINEDRAW          , 0, 2, ISinIO, 1, FALSE},
     {IO_SEQ_IND           , 0, 1, ISinIO, 1, TRUE},           // VGA
     {IO_HI_SEQ_ADDR       , 0, 2, ISinIO, TRUE, TRUE},
     {IO_SEQ_DATA          , 0, 1, ISinIO, TRUE, TRUE},     

     {VGA_BASE_IO_PORT     , 0, VGA_START_BREAK_PORT - VGA_BASE_IO_PORT + 1, ISinIO, TRUE, TRUE},
     {VGA_END_BREAK_PORT   , 0, VGA_MAX_IO_PORT    - VGA_END_BREAK_PORT + 1, ISinIO, TRUE, TRUE},
     {0x000001ce           , 0, 1, ISinIO, TRUE, TRUE},   /* VGAWonder uses these ports for bank switching */
     {0x000001cf           , 0, 1, ISinIO, TRUE, TRUE},
     {IO_EXT_CUR_Y         , 0, 2, ISinIO, 1, FALSE},

     {0x000003CE           , 0, 2, ISinIO, TRUE, TRUE},              // 100
     {0x00000000, 0, 0, ISinMEMORY, TRUE, FALSE}
    };

#if NUM_DRIVER_ACCESS_RANGES > NUM_ADDRESS_RANGES_ALLOWED
    Insufficient address ranges for 8514/A-compatible graphics cards.
#endif

#define DONT_USE -1     /* Shows that this register is not memory mapped */

/* struct list is address, 0, length, inIOspace, visible, sharable      */
// this order MATCHES  AMACH.H ENUM data  structure

VIDEO_ACCESS_RANGE DriverMMRange_m[NUM_IO_ACCESS_RANGES] = {
     {FALSE                 , DONT_USE  , 4, ISinMEMORY , TRUE  , FALSE},   // Mach DAC registers
     {FALSE                 , DONT_USE  , 4, ISinMEMORY , TRUE  , FALSE},
     {FALSE                 , DONT_USE  , 4, ISinMEMORY , TRUE  , FALSE},       
     {FALSE                 , DONT_USE  , 4, ISinMEMORY , TRUE  , FALSE},       
     {MM_DISP_STATUS        , 0         , 4, ISinMEMORY , TRUE  , FALSE},   // First Mach register

     {FALSE                 , DONT_USE  , 2, ISinMEMORY , TRUE  , FALSE},
     {FALSE                 , DONT_USE  , 2, ISinMEMORY , TRUE  , FALSE},
     {FALSE                 , DONT_USE  , 2, ISinMEMORY , TRUE  , FALSE},
     {FALSE                 , DONT_USE  , 1, ISinMEMORY , TRUE  , FALSE},
     {MM_CURSOR_OFFSET_LO   , 0         , 4, ISinMEMORY , TRUE  , FALSE},

     {FALSE                 , DONT_USE  , 1, ISinIO     , TRUE  , FALSE},   // 10
     {MM_CURSOR_OFFSET_HI   , 0         , 4, ISinMEMORY , TRUE  , FALSE},
     {FALSE                 , DONT_USE  , 2, ISinIO     , TRUE  , FALSE},
     {MM_CONFIG_STATUS_1    , 0         , 4, ISinMEMORY , TRUE  , FALSE},
     {FALSE                 , DONT_USE  , 2, ISinIO     , TRUE  , FALSE},

     {MM_CONFIG_STATUS_2    , 0         , 4, ISinMEMORY , TRUE  , FALSE},
     {FALSE                 , DONT_USE  , 2, ISinIO     , TRUE  , FALSE},
     {MM_CURSOR_COLOR_0     , 0         , 4, ISinMEMORY , TRUE  , FALSE},
     {MM_CURSOR_COLOR_1     , 0         , 4, ISinMEMORY , TRUE  , FALSE},
     {FALSE                 , DONT_USE  , 2, ISinIO     , TRUE  , FALSE},

     {MM_HORZ_CURSOR_OFFSET , 0         , 4, ISinMEMORY , TRUE  , FALSE},   // 20
     {MM_VERT_CURSOR_OFFSET , 0         , 4, ISinMEMORY , TRUE  , FALSE},
     {MM_DISP_CNTL          , 0         , 4, ISinMEMORY , TRUE  , FALSE},
     {MM_CRT_PITCH          , 0         , 4, ISinMEMORY , TRUE  , FALSE},
     {MM_CRT_OFFSET_LO      , 0         , 4, ISinMEMORY , TRUE  , FALSE},

     {MM_CRT_OFFSET_HI      , 0         , 4, ISinMEMORY , TRUE  , FALSE},
     {FALSE                 , DONT_USE  , 2, ISinIO     , TRUE  , FALSE},
     {FALSE                 , DONT_USE  , 2, ISinIO     , TRUE  , FALSE},
     {MM_EXT_CURSOR_COLOR_0 , 0         , 4, ISinMEMORY , TRUE  , FALSE},
     {MM_EXT_CURSOR_COLOR_1 , 0         , 4, ISinMEMORY , TRUE  , FALSE},

     {MM_SUBSYS_CNTL        , 0         , 4, ISinMEMORY , TRUE  , FALSE},   // 30
     {FALSE                 , DONT_USE  , 1, ISinIO     , TRUE  , FALSE},
     {FALSE                 , DONT_USE  , 2, ISinIO     , TRUE  , FALSE},
     {FALSE                 , DONT_USE  , 2, ISinIO     , TRUE  , FALSE},
     {MM_ADVFUNC_CNTL       , 0         , 4, ISinMEMORY , TRUE  , FALSE},

     {FALSE                 , DONT_USE  , 2, ISinIO     , TRUE  , FALSE},
     {FALSE                 , DONT_USE  , 2, ISinIO     , TRUE  , FALSE},
     {FALSE                 , DONT_USE  , 2, ISinIO     , TRUE  , FALSE},
     {FALSE                 , DONT_USE  , 2, ISinIO     , TRUE  , FALSE},
     {FALSE                 , DONT_USE  , 2, ISinIO     , TRUE  , FALSE},

     {MM_EXT_GE_STATUS      , 0         , 4, ISinMEMORY , TRUE  , FALSE},   // 40
     {FALSE                 , DONT_USE  , 2, ISinIO     , TRUE  , FALSE},
     {FALSE                 , DONT_USE  , 2, ISinIO     , TRUE  , FALSE},
     {MM_GE_OFFSET_LO       , 0         , 4, ISinMEMORY , TRUE  , FALSE},
     {MM_BOUNDS_LEFT        , 0         , 4, ISinMEMORY , TRUE  , FALSE},

     {MM_BOUNDS_TOP         , 0         , 4, ISinMEMORY , TRUE  , FALSE},
     {MM_BOUNDS_RIGHT       , 0         , 4, ISinMEMORY , TRUE  , FALSE},
     {MM_BOUNDS_BOTTOM      , 0         , 4, ISinMEMORY , TRUE  , FALSE},
     {MM_CUR_Y              , 0         , 4, ISinMEMORY , TRUE  , FALSE},
     {MM_PATT_DATA_INDEX    , 0         , 4, ISinMEMORY , TRUE  , FALSE},

     {MM_CUR_X              , 0         , 4, ISinMEMORY , TRUE  , FALSE},   // 50
     {MM_SRC_Y              , 0         , 4, ISinMEMORY , TRUE  , FALSE},
     {MM_SRC_X              , 0         , 4, ISinMEMORY , TRUE  , FALSE},
     {MM_PATT_DATA          , 0         , 4, ISinMEMORY , TRUE  , FALSE},
     {MM_ERR_TERM           , 0         , 4, ISinMEMORY , TRUE  , FALSE},

     {FALSE                 , DONT_USE  , 2, ISinIO     , TRUE  , FALSE},
     {MM_MAJ_AXIS_PCNT      , 0         , 4, ISinMEMORY , TRUE  , FALSE},
     {MM_BRES_COUNT         , 0         , 4, ISinMEMORY , TRUE  , FALSE},
     {FALSE                 , DONT_USE  , 2, ISinIO     , TRUE  , FALSE},
     {MM_LINEDRAW_INDEX     , 0         , 4, ISinMEMORY , TRUE  , FALSE},

     {MM_SHORT_STROKE       , 0         , 4, ISinMEMORY , TRUE  , FALSE},   // 60
     {MM_BKGD_COLOR         , 0         , 4, ISinMEMORY , TRUE  , FALSE},
     {MM_LINEDRAW_OPT       , 0         , 4, ISinMEMORY , TRUE  , FALSE},
     {MM_FRGD_COLOR         , 0         , 4, ISinMEMORY , TRUE  , FALSE},
     {MM_DEST_X_START       , 0         , 4, ISinMEMORY , TRUE  , FALSE},

     {MM_WRT_MASK           , 0         , 4, ISinMEMORY , TRUE  , FALSE},
     {MM_DEST_X_END         , 0         , 4, ISinMEMORY , TRUE  , FALSE},
     {MM_RD_MASK            , 0         , 4, ISinMEMORY , TRUE  , FALSE},
     {MM_DEST_Y_END         , 0         , 4, ISinMEMORY , TRUE  , FALSE},
     {MM_CMP_COLOR          , 0         , 4, ISinMEMORY , TRUE  , FALSE},

     {MM_SRC_X_START        , 0         , 4, ISinMEMORY , TRUE  , FALSE},   // 70
     {MM_BKGD_MIX           , 0         , 4, ISinMEMORY , TRUE  , FALSE},
     {MM_ALU_BG_FN          , 0         , 4, ISinMEMORY , TRUE  , FALSE},
     {MM_FRGD_MIX           , 0         , 4, ISinMEMORY , TRUE  , FALSE},
     {MM_ALU_FG_FN          , 0         , 4, ISinMEMORY , TRUE  , FALSE},

     {MM_MULTIFUNC_CNTL     , 0         , 4, ISinMEMORY , TRUE  , FALSE},
     {MM_SRC_X_END          , 0         , 4, ISinMEMORY , TRUE  , FALSE},
     {MM_SRC_Y_DIR          , 0         , 4, ISinMEMORY , TRUE  , FALSE},
     {MM_EXT_SSV            , 0         , 4, ISinMEMORY , TRUE  , FALSE},
     {MM_SCAN_X             , 0         , 4, ISinMEMORY , TRUE  , FALSE},

     {MM_DP_CONFIG          , 0         , 4, ISinMEMORY , TRUE  , FALSE},   // 80
     {MM_PATT_LENGTH        , 0         , 4, ISinMEMORY , TRUE  , FALSE},
     {MM_PATT_INDEX         , 0         , 4, ISinMEMORY , TRUE  , FALSE},
     {MM_EXT_SCISSOR_L      , 0         , 4, ISinMEMORY , TRUE  , FALSE},
     {MM_EXT_SCISSOR_T      , 0         , 4, ISinMEMORY , TRUE  , FALSE},

     {MM_PIX_TRANS          , 0         , 4, ISinMEMORY , TRUE  , FALSE},
     {MM_PIX_TRANS_HI       , 0         , 4, ISinMEMORY , TRUE  , FALSE},
     {MM_EXT_SCISSOR_R      , 0         , 4, ISinMEMORY , TRUE  , FALSE},
     {MM_EXT_SCISSOR_B      , 0         , 4, ISinMEMORY , TRUE  , FALSE},
     {MM_DEST_CMP_FN        , 0         , 4, ISinMEMORY , TRUE  , FALSE},

     {FALSE                 , DONT_USE  , 2, ISinIO     , TRUE  , FALSE},   // 90
     {MM_LINEDRAW           , 0         , 4, ISinMEMORY , TRUE  , FALSE},
     {FALSE                 , DONT_USE  , 1, ISinMEMORY , TRUE  , TRUE},    // VGA
     {FALSE                 , DONT_USE  , 2, ISinMEMORY , TRUE  , TRUE},
     {FALSE                 , DONT_USE  , 1, ISinMEMORY , TRUE  , TRUE},     

     {FALSE                 , DONT_USE  , 1, ISinMEMORY , TRUE  , TRUE},
     {FALSE                 , DONT_USE  , 1, ISinMEMORY , TRUE  , TRUE},
     {FALSE                 , DONT_USE  , 1, ISinMEMORY , TRUE  , TRUE},
     {FALSE                 , DONT_USE  , 1, ISinMEMORY , TRUE  , TRUE},
     {MM_EXT_CUR_Y          , 0         , 4, ISinMEMORY , TRUE  , FALSE},

     {FALSE                 , DONT_USE  , 2, ISinIO     , TRUE  , TRUE}     // 100
    };



#endif  /* defined INCLUDE_SETUP_M */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\ati\mini\setup_m.c ===
/************************************************************************/
/*                                                                      */
/*                              SETUP_M.C                               */
/*                                                                      */
/*        Aug 27  1993 (c) 1993, ATI Technologies Incorporated.         */
/************************************************************************/

/**********************       PolyTron RCS Utilities

  $Revision:   1.11  $
      $Date:   23 Jan 1996 11:52:14  $
	$Author:   RWolff  $
	   $Log:   S:/source/wnt/ms11/miniport/archive/setup_m.c_v  $
 *
 *    Rev 1.11   23 Jan 1996 11:52:14   RWolff
 * Eliminated level 3 warnings.
 *
 *    Rev 1.10   31 Mar 1995 11:52:06   RWOLFF
 * Changed from all-or-nothing debug print statements to thresholds
 * depending on importance of the message.
 *
 *    Rev 1.9   14 Mar 1995 18:17:18   ASHANMUG
 * Reset engine on fifo space check time-out.
 *
 *    Rev 1.8   14 Mar 1995 15:59:42   ASHANMUG
 * Timeout on idle check and fifo check.
 *
 *    Rev 1.7   08 Mar 1995 11:35:50   ASHANMUG
 * Modified return values to be correct
 *
 *    Rev 1.5   22 Jul 1994 17:47:28   RWOLFF
 * Merged with Richard's non-x86 code stream.
 *
 *    Rev 1.4   06 Jul 1994 16:41:00   RWOLFF
 * Changed a few loops that I missed for the last checkin to use
 * NUM_IO_ACCESS_RANGES instead of NUM_DRIVER_ACCESS_RANGES.
 *
 *    Rev 1.3   30 Jun 1994 18:23:14   RWOLFF
 * Moved IsApertureConflict_m() from QUERY_M.C. Instead of checking to see if
 * we can read back a value we write to the aperture, then looking for the
 * correct text attribute, we now call VideoPortVerifyAccessRanges() with
 * the LFB included in the list of address ranges we are trying to claim.
 * If the call succeeds, the aperture is enabled. If it fails, we make another
 * call that does not try to claim the LFB (this call shouldn't fail, since
 * it's a duplicate of a call which has succeeded previously). Added routine
 * IsVGAConflict_m(), which does the same thing except for the VGA aperture
 * instead of the LFB.
 *
 *    Rev 1.2   14 Mar 1994 16:36:42   RWOLFF
 * Functions used by ATIMPResetHw() are not pageable.
 *
 *    Rev 1.1   07 Feb 1994 14:14:48   RWOLFF
 * Added alloc_text() pragmas to allow miniport to be swapped out when
 * not needed.
 *
 *    Rev 1.0   31 Jan 1994 11:20:58   RWOLFF
 * Initial revision.
 *
 *    Rev 1.4   14 Jan 1994 15:26:36   RWOLFF
 * Fixed de-initialization of memory mapped registers, added routine
 * to see if memory mapped registers are available.
 *
 *    Rev 1.3   15 Dec 1993 16:02:26   RWOLFF
 * No longer allows use of memory mapped registers on EISA machines,
 * starts mapping of memory mapped registers at index 0 due to removal
 * of placeholder for linear framebuffer.
 *
 *    Rev 1.2   05 Nov 1993 13:32:36   RWOLFF
 * Can now unmap I/O address ranges.
 *
 *    Rev 1.1   08 Oct 1993 11:18:24   RWOLFF
 * Now checks to see if memory mapped registers can be used, and unmaps them
 * if they aren't usable (NCR Dual Pentium fix).
 *
 *    Rev 1.0   03 Sep 1993 14:25:36   RWOLFF
 * Initial revision.

End of PolyTron RCS section                             *****************/

#ifdef DOC
SETUP_M.C - Setup routines for 8514/A compatible accelerators.

DESCRIPTION
    This file contains routines which provide services specific to
    the 8514/A-compatible family of ATI accelerators.

OTHER FILES

#endif

#include "dderror.h"

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "miniport.h"
#include "ntddvdeo.h"
#include "video.h"

#include "stdtyp.h"
#include "amach.h"
#include "amach1.h"
#include "atimp.h"

#include "services.h"
#define INCLUDE_SETUP_M
#include "setup_m.h"


/*
 * Allow miniport to be swapped out when not needed.
 *
 * WaitForIdle_m() is called by ATIMPResetHw(), which
 * must be in nonpageable memory.
 */
#if defined (ALLOC_PRAGMA)
#pragma alloc_text(PAGE_M, CompatIORangesUsable_m)
#pragma alloc_text(PAGE_M, CompatMMRangesUsable_m)
#pragma alloc_text(PAGE_M, UnmapIORanges_m)
#pragma alloc_text(PAGE_M, MemoryMappedEnabled_m)
#pragma alloc_text(PAGE_M, CheckFIFOSpace_m)
#pragma alloc_text(PAGE_M, IsApertureConflict_m)
#pragma alloc_text(PAGE_M, IsVGAConflict_m)
#endif



/*
 * VP_STATUS CompatIORangesUsable_m(void);
 *
 * Ask Windows NT for permission to use the I/O space address ranges
 * needed by the 8514/A compatible ATI accelerators.
 *
 * Returns:
 *  NO_ERROR if successful
 *  error code if unable to gain access to the ranges we need.
 */
VP_STATUS CompatIORangesUsable_m(void)
{
    VP_STATUS Status;   /* Value returned by operating system calls */
    short Count;        /* Loop counter */


    /*
     * Check to see if there is a hardware resource conflict.
     */
    Status = VideoPortVerifyAccessRanges(phwDeviceExtension,
                                         NUM_IO_ACCESS_RANGES,
                                         DriverIORange_m);
    if (Status != NO_ERROR)
        {
        return Status;
        }

    /*
     * Clear the list of I/O mapped registers. This is done so
     * that if the loop below fails because one I/O range can't
     * be mapped, and we need to unmap these registers before,
     * mapping the registers needed for another accelerator type,
     * we don't unmap nonexistant address ranges due to the
     * array of processed addresses containing random data.
     */
    memset(phwDeviceExtension->aVideoAddressIO, 0, NUM_IO_ACCESS_RANGES * sizeof(ULONG));

    /*
     * Map the video controller address ranges we need to identify
     * our cards into the system virtual address space.
     *
     * Since we only use I/O mapped registers here, set the
     * mapped addresses for memory mapped registers to
     * 0 (flag to show the registers are not memory mapped)
     * in case they were initialized to a nonzero value.
     */
    for (Count=0; Count < NUM_IO_ACCESS_RANGES; Count++)
        {
        if ((phwDeviceExtension->aVideoAddressIO[Count] =
            VideoPortGetDeviceBase(phwDeviceExtension,
                DriverIORange_m[Count].RangeStart,
                DriverIORange_m[Count].RangeLength,
                DriverIORange_m[Count].RangeInIoSpace)) == NULL)
            {
            return ERROR_INVALID_PARAMETER;
            }
        phwDeviceExtension->aVideoAddressMM[Count] = 0;
        }   /* End for */

    return NO_ERROR;

}   /* CompatIORangesUsable_m() */

/*
 * void CompatMMRangesUsable_m(void);
 *
 * Ask Windows NT for permission to use the memory mapped registers
 * needed by the 8514/A compatible ATI accelerators.
 */
void CompatMMRangesUsable_m(void)
{
    PHYSICAL_ADDRESS MMrange;   /* Used in translating offset to memory address */
    USHORT USTemp;              /* Used to enable memory mapped registers */
    int Count;                  /* Loop counter */
    WORD SrcX;                  /* Saved contents of SRC_X register */
    ULONG_PTR ExtGeStatusMM;    /* Memory mapped address for EXT_GE_STATUS */
    struct query_structure *QueryPtr;   /* Query information for the card */

    /*
     * Get a formatted pointer into the query section of HwDeviceExtension.
     * The CardInfo[] field is an unformatted buffer.
     */
    QueryPtr = (struct query_structure *) (phwDeviceExtension->CardInfo);

    /*
     * Memory mapped registers are not available on EISA cards.
     */
    if (QueryPtr->q_bus_type == BUS_EISA)
        {
        return;
        }

    /*
     * ALPHA machines crash during the test to see whether memory-mapped
     * registers are usable, so on these machines we assume that
     * memory-mapped registers are not available.
     */
#if defined (ALPHA) || defined (_ALPHA_)
    return;
#endif

    /*
     * Use an I/O mapped read on the register we're going to use to see
     * if memory mapped registers are usable, because if they aren't usable
     * we won't get a valid result if we wait until we've enabled
     * memory mapped registers before reading it.
     */
    SrcX = INPW(R_SRC_X);

    USTemp = INPW(LOCAL_CONTROL);
    USTemp |= 0x0020;   // Enable memory mapped registers
    OUTPW(LOCAL_CONTROL, USTemp);
    MMrange.HighPart = 0;

    for (Count=0; Count < NUM_IO_ACCESS_RANGES;  Count++)
        {
        /*
         * In a 32-bit address space, the high doubleword of all
         * physical addresses is zero. Setting this value to DONT_USE
         * indicates that this accelerator register isn't memory mapped.
         */
        if (DriverMMRange_m[Count].RangeStart.HighPart != DONT_USE)
            {
            /*
             * DriverMMRange_m[Count].RangeStart.LowPart is the offset of
             * the memory mapped register from the beginning of the
             * block of memory mapped registers. We must add the offset
             * of the start of the memory mapped register area from
             * the start of the linear framebuffer (4M aperture assumed)
             * and the physical address of the start of the linear
             * framebuffer to get the physical address of this
             * memory mapped register.
             */
            MMrange.LowPart = DriverMMRange_m[Count].RangeStart.LowPart + 0x3FFE00 + phwDeviceExtension->PhysicalFrameAddress.LowPart;
            phwDeviceExtension->aVideoAddressMM[Count] =
                VideoPortGetDeviceBase(phwDeviceExtension,
                    MMrange,
                    DriverMMRange_m[Count].RangeLength,
                    FALSE);                     // not in IO space
            }
        }

    /*
     * Some cards use an ASIC which is capable of using memory mapped
     * registers, but an older board design which doesn't allow their
     * use. To test this, check whether the SRC_X register (this register
     * is available as memory mapped on any card which is capable of
     * supporting memory mapped registers) remembers a value that is written
     * to it. If it doesn't, then undo the memory mapping, since this
     * test shows that memory mapped registers are not available.
     */
    VideoDebugPrint((DEBUG_DETAIL, "About to test whether memory mapped registers can be used\n"));
    OUTPW(SRC_X, 0x0AAAA);

    /*
     * WaitForIdle_m() uses the EXT_GE_STATUS register, which is handled
     * as memory mapped if available. Since we don't know if memory mapped
     * registers are available, work around this by saving the address
     * of the memory mapped EXT_GE_STATUS register, setting the address
     * to zero to force the use of the I/O mapped EXT_GE_STATUS, then
     * restoring the address after WaitForIdle_m() has finished.
     */
    ExtGeStatusMM = (ULONG_PTR) phwDeviceExtension->aVideoAddressMM[EXT_GE_STATUS];
    phwDeviceExtension->aVideoAddressMM[EXT_GE_STATUS] = 0;
    WaitForIdle_m();
    phwDeviceExtension->aVideoAddressMM[EXT_GE_STATUS] = (PVOID) ExtGeStatusMM;

    if (INPW(R_SRC_X) != 0x02AA)
        {
        VideoDebugPrint((DEBUG_DETAIL, "Can't use memory mapped ranges\n"));
        for (Count = 0; Count < NUM_IO_ACCESS_RANGES; Count++)
            {
            if (phwDeviceExtension->aVideoAddressMM[Count] != 0)
                {
                VideoPortFreeDeviceBase(phwDeviceExtension,
                                        phwDeviceExtension->aVideoAddressMM[Count]);
                phwDeviceExtension->aVideoAddressMM[Count] = 0;
                }
            }
        USTemp = INPW(LOCAL_CONTROL);
        USTemp &= 0x0FFDF;              /* Disable memory mapped registers */
        OUTPW(LOCAL_CONTROL, USTemp);
        }
    else
        {
        VideoDebugPrint((DEBUG_DETAIL, "Memory mapped registers are usable\n"));
        }
    OUTPW(SRC_X, SrcX);
    VideoDebugPrint((DEBUG_DETAIL, "Memory mapped register test complete\n"));

    return;

}   /* CompatMMRangesUsable_m() */



/***************************************************************************
 *
 * void UnmapIORanges_m(void);
 *
 * DESCRIPTION:
 *  Unmap the I/O address ranges mapped by CompatIORangesUsable_m() prior
 *  to mapping the I/O address ranges used by a non-8514/A-compatible
 *  ATI accelerator.
 *
 * GLOBALS CHANGED:
 *  phwDeviceExtension->aVideoAddressIO[]
 *
 * CALLED BY:
 *  ATIMPFindAdapter()
 *
 * AUTHOR:
 *  Robert Wolff
 *
 * CHANGE HISTORY:
 *
 * TEST HISTORY:
 *
 ***************************************************************************/

void UnmapIORanges_m(void)
{
    short Count;    /* Loop counter */

    for (Count=1; Count < NUM_IO_ACCESS_RANGES;  Count++)
        {
        /*
         * Only unmap those ranges which have been mapped. We don't need
         * to worry about unmapping nonexistant addresses (due to
         * uninitialized data) if CompatIORangesUsable_m() failed
         * partway through mapping because this routine initialized all
         * phwDeviceExtension->aVideoAddressIO[] entries to zero
         * before it started mapping the I/O ranges.
         */
        if (phwDeviceExtension->aVideoAddressIO[Count] != 0)
            {
            VideoPortFreeDeviceBase(phwDeviceExtension,
                                    phwDeviceExtension->aVideoAddressIO[Count]);
            phwDeviceExtension->aVideoAddressIO[Count] = 0;
            }
        }
    return;

}   /* UnmapIORanges_m() */



/***************************************************************************
 *
 * BOOL MemoryMappedEnabled_m(void);
 *
 * DESCRIPTION:
 *  Check to see whether we are using memory mapped registers.
 *
 * RETURN VALUE:
 *  TRUE if memory mapped registers are available
 *  FALSE if they are not
 *
 * GLOBALS CHANGED:
 *  None
 *
 * CALLED BY:
 *  May be called by any function after CompatMMRangesUsable_m()
 *  has been called.
 *
 * AUTHOR:
 *  Robert Wolff
 *
 * CHANGE HISTORY:
 *
 * TEST HISTORY:
 *
 ***************************************************************************/

BOOL MemoryMappedEnabled_m(void)
{
    /*
     * If memory mapped registers are enabled, EXT_GE_STATUS will be
     * available in memory mapped form.
     */
    if (phwDeviceExtension->aVideoAddressMM[EXT_GE_STATUS] != 0)
        return TRUE;
    else
        return FALSE;

}   /* MemoryMappedEnabled_m() */




/*
 * int WaitForIdle_m(void);
 *
 * Poll GE_STAT waiting for GE_BUSY to go low. If GE_BUSY does not go
 * low within a reasonable number of attempts, time out.
 *
 * Returns:
 *  FALSE if timeout: 3 seconds is an arbitrary value
 *  TRUE  if engine is idle
 */
int WaitForIdle_m(void)
{
    int	i;

    for (i=0; i<300; i++)
        {
        if ((INPW(EXT_GE_STATUS) & GE_ACTIVE) == 0)
            return(TRUE);

        /* Delay for 1/100th of a second */
        delay(10);
        }

    /* Something has happened, reset the engine and return false */
    VideoDebugPrint((DEBUG_ERROR, "ATI: Timeout on WaitForIdle_m()\n"));
    OUTPW(SUBSYS_CNTL, 0x900F);
    OUTPW(SUBSYS_CNTL, 0x500F);

    return(FALSE);

}   /* WaitForIdle_m() */



/*
 * void CheckFIFOSpace_m(SpaceNeeded);
 *
 * WORD SpaceNeeded;    Number of free FIFO entries needed
 *
 * Wait until the specified number of FIFO entries are free
 * on an 8514/A-compatible ATI accelerator.
 *
 * Timeout after 3 seconds
 */
void CheckFIFOSpace_m(WORD SpaceNeeded)
{
    int i;

    for (i=0; i<300; i++)
        {
        /* Return from test if no more space is needed */
        if ( !(INPW(EXT_FIFO_STATUS)&SpaceNeeded) )
            return;

        delay(10);
        }

    /* Something bad has happened, just return */
    VideoDebugPrint((DEBUG_ERROR, "ATI: Timeout on CheckFIFOSpace_m()\n"));
    OUTPW(SUBSYS_CNTL, 0x900F);
    OUTPW(SUBSYS_CNTL, 0x500F);
    return;

}   /* CheckFIFOSpace_m() */



/*
 * BOOL IsApertureConflict_m(QueryPtr);
 *
 * struct query_structure *QueryPtr;    Pointer to query structure
 *
 * Check to see if the linear aperture conflicts with other memory.
 * If a conflict exists, disable the linear aperture.
 *
 * Returns:
 *  TRUE if a conflict exists (aperture unusable)
 *  FALSE if the aperture is usable.
 */
BOOL IsApertureConflict_m(struct query_structure *QueryPtr)
{
WORD ApertureData;                  /* Value read from MEM_CFG register */
VP_STATUS Status;                   /* Return value from VideoPortVerifyAccessRanges() */

    /*
     * If there is an aperture conflict, a call to
     * VideoPortVerifyAccessRanges() including our linear framebuffer in
     * the range list will return an error. If there is no conflict, it
     * will return success.
     */
    DriverIORange_m[FRAMEBUFFER_ENTRY].RangeStart.LowPart = QueryPtr->q_aperture_addr*ONE_MEG;
    DriverIORange_m[FRAMEBUFFER_ENTRY].RangeLength = 4*ONE_MEG;
    Status = VideoPortVerifyAccessRanges(phwDeviceExtension,
                                         NUM_DRIVER_ACCESS_RANGES,
                                         DriverIORange_m);
    if (Status != NO_ERROR)
        {
        /*
         * If there is an aperture conflict, reclaim our I/O ranges without
         * asking for the LFB. This call should not fail, since we would not
         * have reached this point if there were a conflict.
         */
        Status = VideoPortVerifyAccessRanges(phwDeviceExtension,
                                             NUM_IO_ACCESS_RANGES,
                                             DriverIORange_m);
        if (Status != NO_ERROR)
            VideoDebugPrint((DEBUG_ERROR, "ERROR: Can't reclaim I/O ranges\n"));

        /*
         * Adjust the list of mode tables to take into account the
         * fact that we're using the VGA aperture instead of the LFB.
         */
        ISAPitchAdjust(QueryPtr);
        return TRUE;
        }
    else
        {
        /*
         * Enable the linear aperture
         */
        ApertureData = INPW(MEM_CFG) & 0x0fffc;     /* Preserve bits 2-15 */
        ApertureData |= 0x0002;                     /* 4M aperture        */
        OUTPW(MEM_CFG, ApertureData);

        return FALSE;
        }

}   /* IsApertureConflict_m() */



/*
 * BOOL IsVGAConflict_m(void);
 *
 * Check to see if the VGA aperture conflicts with other memory.
 *
 * Returns:
 *  TRUE if a conflict exists (VGA aperture unusable)
 *  FALSE if the VGA aperture is usable.
 */
BOOL IsVGAConflict_m(void)
{
VP_STATUS Status;                   /* Return value from VideoPortVerifyAccessRanges() */

    /*
     * If there is an aperture conflict, a call to
     * VideoPortVerifyAccessRanges() including the VGA aperture in
     * the range list will return an error. If there is no conflict, it
     * will return success.
     */
    DriverIORange_m[FRAMEBUFFER_ENTRY].RangeStart.LowPart = 0xA0000;
    DriverIORange_m[FRAMEBUFFER_ENTRY].RangeLength = 0x10000;
    DriverIORange_m[FRAMEBUFFER_ENTRY].RangeShareable = TRUE;
    Status = VideoPortVerifyAccessRanges(phwDeviceExtension,
                                         NUM_DRIVER_ACCESS_RANGES,
                                         DriverIORange_m);
    if (Status != NO_ERROR)
        {
        /*
         * If there is an aperture conflict, reclaim our I/O ranges without
         * asking for the LFB. This call should not fail, since we would not
         * have reached this point if there were a conflict.
         */
        Status = VideoPortVerifyAccessRanges(phwDeviceExtension,
                                             NUM_IO_ACCESS_RANGES,
                                             DriverIORange_m);
        if (Status != NO_ERROR)
            VideoDebugPrint((DEBUG_ERROR, "ERROR: Can't reclaim I/O ranges\n"));

        return TRUE;
        }
    else
        {
        return FALSE;
        }

}   /* IsVGAConflict_m() */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\ati\mini\stdtyp.h ===
#ifndef STDTYP_H
#define STDTYP_H
/*******************************************************************
    Filename: STDTYP.H
   (c) 1989, ATI Technologies Incorporated.
  $Revision:   1.1  $
      $Date:   23 Dec 1994 10:48:20  $
   $Author:   ASHANMUG  $
      $Log:   S:/source/wnt/ms11/miniport/vcs/stdtyp.h  $
 *
 *    Rev 1.1   23 Dec 1994 10:48:20   ASHANMUG
 * ALPHA/Chrontel-DAC
 *
 *    Rev 1.0   31 Jan 1994 11:49:02   RWOLFF
 * Initial revision.

           Rev 1.1   03 Sep 1993 14:29:46   RWOLFF
        Type definitions used by Windows NT driver.

           Rev 1.1   24 Feb 1993 11:05:20   Ajith_S
        Check for MSDOS and not far as #ifdef far always returns FALSE

           Rev 1.0   13 Jan 1993 14:16:12   Robert_Wolff
        Initial revision.

      Rev 1.14   15 Apr 1991 16:26:30   Bryan_Sniderman
   Corrected WORD definition from 'unsigned int' to 'unsigned short'
   This will force a WORD to 16-bits (even in HIGH-C)

      Rev 1.13   06 Dec 1990 12:02:22   Chris_Brady
   Added support for Metaware HIGHC compiler.  Define P386.

      Rev 1.12   04 Jun 1990 15:54:18   Sandy_Lum
   Corrected syntax error

      Rev 1.11   17 May 1990 10:02:00   Robin_Davies
   Added TINY, UTINY base types.

      Rev 1.10   28 Sep 1989 11:41:14   Robin_Davies
   Made PRIVATE declarator conditional, allowing all PRIVATE labels
   to be published from the command line by adding /DPRIVATE option
   to CL options. Useful for debugging purposes.

      Rev 1.9   17 Sep 1989 16:10:16   Robin_Davies
   "define HUGE huge" conflicts with ANSI definition of HUGE in
   MATH.H. Replaced with "define ENORMOUSE huge".

      Rev 1.8   15 Sep 1989 16:39:10   Peter Liepa
   added HUGE keyword

      Rev 1.7   30 Jun 1989 11:06:52   Peter Michalek
   FALSE , TRUE added

      Rev 1.6   28 Jun 1989 15:00:28   Robin_Davies
   Added FLOAT and DOUBLE.

      Rev 1.5   28 Jun 1989 14:34:54   Robin_Davies
   Removed double-slash comments.

      Rev 1.4   21 Jun 1989 15:34:06   Peter Liepa
   removed hard tabs

      Rev 1.3   20 Jun 1989 15:45:20   Peter Liepa
   corrected spelling of "SUCCESS", fixed up line overflows

      Rev 1.2   16 Jun 1989  9:51:56   Robin_Davies
   Made headers consistent.

      Rev 1.1   14 Jun 1989 15:27:38   Robin_Davies
   Added OFFSET, SEGMENT macros.

      Rev 1.0   14 Jun 1989  9:20:24   Robin_Davies
   Initial revision.
********************************************************************/

#ifdef DOC
STDTYP.H - Portable types for C programs.

DESCRIPTION
     This file contains standard augmented types for C programs. Types
     are based on and are compatible with Microsoft OS/2 types.
     In addition, several Plum-Hall/Whitesmith standard types
     have been added.

     This header currently supports the Microsoft C 5.1 compiler.
     and the Metaware High C 386 Protected mode Version 1.6  compiler
     by defining P386.
#endif

#ifndef INT_MAX /* Defined in limits.h */
#include <limits.h> /* Ansi type limits, matching augmented types */
#endif
/*
*****************************
    Standard Defines
*****************************
*/
#define YES 1
#define NO 0

/*
 * Some platforms have already defined TRUE and/or FALSE.
 */
#ifndef TRUE
    #define TRUE    (1)     /* Function TRUE  value */
#endif
#ifndef FALSE
    #define FALSE   (0)     /* Function FALSE value */
#endif

#ifndef  P386
#define SUCCESS 0
#define FAIL 1
#endif

/*
 * Non-portable types. Data size references are not needed
 * for Windows NT, since it's a 32 bit operating system.
 * Only define the basic types for platforms (e.g. Windows NT)
 * where they aren't already defined.
 */

typedef unsigned char BYTE;     /* 8 bits unsigned  */
typedef unsigned short WORD;    /* 16 bits unsigned */

/*
**************************
    BASE TYPES
**************************
*/
typedef char CHAR;              /* At least 8 bits, sign indeterminate */
typedef short SHORT;            /* At least 16 bits signed */
typedef long LONG;              /* At least 32 bits signed */
typedef float FLOAT;            /* Floating point, unspecified precision */
typedef double DOUBLE;          /* Floating point, unspecified precision */

typedef unsigned char UCHAR;    /* At least 8 bits, unsigned */
typedef signed char SCHAR;      /* At least 8 bits, signed */
typedef unsigned short USHORT;  /* At least 16 bits, unsigned */
typedef unsigned long ULONG;    /* At least 32 bits, signed */

typedef unsigned char UTINY;    /* Scalar, at least 8 bits , unsigned */
typedef char TINY;              /* Scalar, at least 8 bits, signed */

/*
****************************
    ARTIFICIAL TYPES
****************************
*/
#ifndef PRIVATE
   #define PRIVATE static           /* Local functions and variables */
#endif

typedef int METACHAR;            /* Sufficient to hold any character and EOF */
typedef int BOOL;                /* Most efficient Boolean,
                                         compare against zero only! */
typedef char TBOOL;              /* Smallest boolean, e.g. for use in arrays.
                                        Compare against zero only */
typedef unsigned int BITS;       /* At least 16 bits, used for bit manipulation */
typedef unsigned char TBITS;     /* At least 8 bits, used for bit manipulation */
typedef unsigned long int LBITS; /* At least 32 bits, used for bit manipulation */

#ifndef  _BASETSD_H_
typedef unsigned int SIZE_T;    /* sufficent for sizeof(anything)
                                 e.g. malloc size. Equivalent to ansi size_t */
#endif

#if     defined(__LARGE__) || defined(__HUGE__) || defined(__COMPACT__)
typedef long    PTRDIFF_T;      /* difference between pointers.
                                         Equivalent to ansi ptrdiff_t */
#else
typedef int     PTRDIFF_T;      /* difference between pointers.
                                        Equivalent to ansi ptrdiff_t */
#endif


/*
****************************
     POINTERS
****************************
*/


typedef void *PVOID;                   /* Generic untyped pointer */

typedef int (*PFUNC)();                /* Pointer to Function (model dependent) */

/*
****************************
   Useful Macros
****************************
*/

#define FOREVER for(;;)
#define NOTHING /**/        /* e.g. while (condition) NOTHING */

/* Create untyped far pointer from selector and offset */
#define MAKEP(sel, off)     ((PVOID)MAKEULONG(off, sel))

/* Extract selector or offset from far pointer. e.g. OFFSET(&x) */
#define OFFSET(p)           LOWORD((VOID FAR *) (p))
#define SEGMENT(p)          HIWORD((VOID FAR *) (p))

/* Cast any variable to an instance of the specified type. */
#define MAKETYPE(v, type)   (*((type *)&v))

/* Calculate the byte offset of a field in a structure of type type. */
#define FIELDOFFSET(type, field)    ((SHORT)&(((type *)0)->field))

/* Combine l & h to form a 32 bit quantity. */
#define MAKEULONG(l, h)  ((ULONG)(((USHORT)(l)) | ((ULONG)((USHORT)(h))) << 16))
#define MAKELONG(l, h)   ((LONG)MAKEULONG(l, h))

/* Combine l & h to form a 16 bit quantity. */
#define MAKEWORD(l, h) (((WORD)(l)) | ((WORD)(h)) << 8)
#define MAKESHORT(l, h)  ((SHORT)MAKEUSHORT(l, h))

/* Extract high and low order parts of 16 and 32 bit quantity */
#define LOBYTE(w)       ((BYTE)(w))
#define HIBYTE(w)       ((BYTE)(((WORD)(w) >> 8) & 0xff))
#define LOWORD(l)     ((WORD)(l))
#define HIWORD(l)     ((WORD)(((ULONG)(l) >> 16) & 0xffff))

#endif /* defined STDTYP_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\ati\mini\query_cx.c ===
/************************************************************************/
/*                                                                      */
/*                              QUERY_CX.C                              */
/*                                                                      */
/*  Copyright (c) 1993, ATI Technologies Incorporated.                  */
/************************************************************************/

/**********************       PolyTron RCS Utilities

    $Revision:   1.61  $
    $Date:   01 May 1996 14:10:14  $
    $Author:   RWolff  $
    $Log:   S:/source/wnt/ms11/miniport/archive/query_cx.c_v  $
 *
 *    Rev 1.61   01 May 1996 14:10:14   RWolff
 * Calls new routine DenseOnAlpha() to determine dense space support rather
 * than assuming all PCI cards support dense space, routine treats only
 * PCI cards with ?T ASICs as supporting dense space.
 *
 *    Rev 1.60   23 Apr 1996 17:21:18   RWolff
 * Split mapping of memory types reported by BIOS into our enumeration
 * of memory types according to ASIC type, since ?T and ?X use the same
 * memory type code to refer to different memory types.
 *
 *    Rev 1.59   15 Apr 1996 16:57:56   RWolff
 * Added routine to identify which flavour of the Mach 64 is in use.
 *
 *    Rev 1.58   12 Apr 1996 16:14:48   RWolff
 * Now rejects 24BPP modes if linear aperture is not present, since new
 * source stream display driver can't do 24BPP in a paged aperture. This
 * rejection should be done in the display driver (the card still supports
 * the mode, but the display driver doesn't want to handle it), but at
 * the point where the display driver must decide to either accept or reject
 * modes, it doesn't have access to the aperture information.
 *
 *    Rev 1.57   20 Mar 1996 13:45:02   RWolff
 * Fixed truncation of screen buffer save size.
 *
 *    Rev 1.56   01 Mar 1996 12:14:20   RWolff
 * Can now use the existing VGA graphics screen used as the startup
 * "blue screen" on the DEC Alpha to store the results of the BIOS
 * query call rather than forcing a mode switch and destroying the
 * contents of the "blue screen".
 *
 *    Rev 1.55   06 Feb 1996 16:01:00   RWolff
 * Updated start and end indices for 1600x1200 to take into account addition
 * of 66Hz and 76Hz, and deletion of 52Hz.
 *
 *    Rev 1.54   02 Feb 1996 17:17:38   RWolff
 * DDC/VDIF merge source information is now stored in hardware device
 * extension rather than static variables, switches back to a VGA text
 * screen after we have finished with the query information if we needed
 * to switch into a graphics screen in order to obtain a buffer below
 * 1M physical (more information needed from DEC in order to make this
 * work on the Alpha), moved redundant cleanup code to its own routine.
 *
 *    Rev 1.53   29 Jan 1996 17:00:48   RWolff
 * Now uses VideoPortInt10() rather than no-BIOS code on PPC, restricted
 * 4BPP to 1M cards, and only for resolutions where 8BPP won't fit.
 *
 *    Rev 1.52   23 Jan 1996 11:47:26   RWolff
 * Protected against false values of TARGET_BUILD.
 *
 *    Rev 1.51   11 Jan 1996 19:42:16   RWolff
 * Now restricts refresh rates for each resolution/pixel depth combination
 * using data from AX=A?07 BIOS call rather than special cases.
 *
 *    Rev 1.50   22 Dec 1995 14:54:02   RWolff
 * Added support for Mach 64 GT internal DAC.
 *
 *    Rev 1.49   21 Dec 1995 14:04:02   RWolff
 * Locked out modes that ran into trouble at high refresh rates.
 *
 *    Rev 1.48   19 Dec 1995 13:57:02   RWolff
 * Added support for refresh rates up to 100Hz at 640x480, 800x600, and
 * 1024x768, and 76Hz at 1280x1024.
 *
 *    Rev 1.47   29 Nov 1995 14:36:16   RWolff
 * Fix for EPR#08840. The mode that was causing problems (1152x864 32BPP
 * 80Hz on IBM DAC) was one that (according to the INSTALL program)
 * shouldn't be available on the card.
 *
 *    Rev 1.46   28 Nov 1995 18:14:58   RWolff
 * Added debug print statements.
 *
 *    Rev 1.45   21 Nov 1995 11:02:02   RWolff
 * Restricted maximum size of BIOS query structure to allow space below
 * 1M for reading DDC data.
 *
 *    Rev 1.44   27 Oct 1995 14:23:54   RWolff
 * No longer checks for block write on non-LFB configurations, moved
 * mapping and unmapping of LFB into the block write check routine
 * rather than using the (no longer exists) mapped LFB in the hardware
 * device extension.
 *
 *    Rev 1.43   08 Sep 1995 16:35:32   RWolff
 * Added support for AT&T 408 DAC (STG1703 equivalent).
 *
 *    Rev 1.42   24 Aug 1995 15:37:20   RWolff
 * Changed detection of block I/O cards to match Microsoft's
 * standard for plug-and-play.
 *
 *    Rev 1.41   28 Jul 1995 14:40:36   RWolff
 * Added support for the Mach 64 VT (CT equivalent with video overlay).
 *
 *    Rev 1.40   26 Jul 1995 12:44:54   mgrubac
 * Locked out modes that didn't work on 4M CX cards with STG1703
 * and similar DACs.
 *
 *    Rev 1.39   20 Jul 1995 17:57:54   mgrubac
 * Added support for VDIF files.
 *
 *    Rev 1.38   13 Jun 1995 15:13:14   RWOLFF
 * Now uses VideoPortReadRegisterUlong() instead of direct memory
 * reads in BlockWriteAvailable_cx(), since direct reads don't
 * work on the DEC Alpha. Breaks out of block write test on
 * finding first mismatch, rather than testing the whole block,
 * to save time. One mismatch is enough to indicate that block
 * write mode is not supported, so after we find one we don't
 * need to check the rest of the block.
 *
 *    Rev 1.37   02 Jun 1995 14:31:44   RWOLFF
 * Added debug print statements, locked out modes that don't work properly
 * on some DACs.
 *
 *    Rev 1.36   10 Apr 1995 15:58:20   RWOLFF
 * Now replaces BookValues[] entries where the Mach 64 needs different CRT
 * parameters from the Mach 8/Mach 32 (fixes Chrontel DAC 1M 640x480 72Hz
 * 24BPP noise problem), locked out 800x600 16BPP 72Hz on 1M cards with
 * STG170x and equivalent DACs (another noise problem, this mode is not
 * supposed to be supported on 1M cards).
 *
 *    Rev 1.35   31 Mar 1995 11:56:16   RWOLFF
 * Changed from all-or-nothing debug print statements to thresholds
 * depending on importance of the message.
 *
 *    Rev 1.34   27 Mar 1995 16:12:14   RWOLFF
 * Locked out modes that didn't work on 1M cards with STG1702 and
 * similar DACs.
 *
 *    Rev 1.33   16 Mar 1995 14:41:08   ASHANMUG
 * Limit 1024x768 24 bpp on a STG17xx DAC to 87Hz interlaced
 *
 *    Rev 1.32   03 Mar 1995 10:51:22   ASHANMUG
 * Lock-out high refresh rates on CT and '75 DACs
 *
 *    Rev 1.31   24 Feb 1995 12:29:54   RWOLFF
 * Added routine to check if the card is susceptible to 24BPP text banding
 *
 *    Rev 1.30   20 Feb 1995 18:02:28   RWOLFF
 * Locked out block write on GX rev. E with IBM RAM.
 *
 *    Rev 1.29   14 Feb 1995 15:54:22   RWOLFF
 * Now checks CFG_CHIP_TYPE field of CONFIG_CHIP_ID against values found
 * in this field for all Mach 64 ASICs, and reports "no Mach 64" if
 * no match is found. This fixes a problem on an Apricot FT\\2E with
 * a Mach 32 MCA card, where the Mach 32 supplied the BIOS signature
 * string, and the machine cached our writes to SCRATCH_PAD0 so it
 * looked like the register was present, falsely identifying a Mach 64
 * as being present.
 *
 *    Rev 1.28   09 Feb 1995 14:58:14   RWOLFF
 * Fix for GX-E IBM DAC screen tearing in 800x600 8BPP.
 *
 *    Rev 1.27   07 Feb 1995 18:21:14   RWOLFF
 * Locked out some more resolution/pixel depth/refresh rate combinations
 * that are not supported.
 *
 *    Rev 1.26   30 Jan 1995 17:44:20   RWOLFF
 * Mach 64 detection now does a low word test before the doubleword test
 * to avoid hanging a VLB Mach 32 by writing garbage to the MEM_BNDRY register.
 *
 *    Rev 1.25   30 Jan 1995 11:56:12   RWOLFF
 * Now detects CT internal DAC.
 *
 *    Rev 1.24   19 Jan 1995 15:38:18   RWOLFF
 * Removed 24BPP no-BIOS lockout and comment explaining why it was
 * locked out. 24BPP now works on no-BIOS implementations.
 *
 *    Rev 1.23   18 Jan 1995 15:41:08   RWOLFF
 * Added support for Chrontel DAC, now clips maximum colour depth from BIOS
 * mode tables to the maximum identified in the query header, locks out
 * high refresh rate 1152x864 16BPP modes (8BPP can still be handled through
 * double-pixel mode), re-enabled 24BPP on no-BIOS implementations (work
 * in progress).
 *
 *    Rev 1.22   11 Jan 1995 14:00:28   RWOLFF
 * 1280x1024 no longer restricted to 60Hz maximum on DRAM cards. This
 * restriction was a carryover from the Mach 32, since at the time I wrote
 * this code, I did not have any information to show that the Mach 64 didn't
 * need it.
 *
 *    Rev 1.21   04 Jan 1995 13:20:10   RWOLFF
 * Now uses VGA graphics memory if neither text screen is backed by
 * physical memory (needed on some DEC Alpha machines), temporarily
 * locked out 24BPP on no-BIOS implementations.
 *
 *    Rev 1.20   23 Dec 1994 10:48:10   ASHANMUG
 * ALPHA/Chrontel-DAC
 *
 *    Rev 1.19   18 Nov 1994 11:41:54   RWOLFF
 * Added support for Mach 64 without BIOS, separated handling of STG1703 from
 * other STG170x DACs, no longer creates mode tables for resolutions that the
 * DAC doesn't support, added handling for split rasters, rejects 4BPP on
 * TVP3026 DAC, recognizes that the Power PC doesn't support block write mode.
 *
 *    Rev 1.18   14 Sep 1994 15:21:30   RWOLFF
 * Now stores most desirable supported colour ordering for 24 and 32 BPP
 * in the query structure.
 *
 *    Rev 1.17   06 Sep 1994 10:47:32   ASHANMUG
 * Force 4bpp on mach64 to have one meg ram
 *
 *    Rev 1.16   31 Aug 1994 16:26:10   RWOLFF
 * Now uses VideoPort[Read|Write]Register[Uchar|Ushort|Ulong]() instead
 * of direct assignments when accessing structures stored in VGA text
 * screen off-screen memory, added support for TVP3026 DAC and new
 * list of DAC subtypes, updates maximum supported pixel depth to
 * correspond to the card being used rather than taking the normal
 * maximum values for the DAC type, added 1152x864 and 1600x1200 support.
 *
 *    Rev 1.15   19 Aug 1994 17:11:56   RWOLFF
 * Added support for SC15026 and AT&T 49[123] DACs, fixed reporting
 * of "canned" mode tables for resolutions that do not have a
 * hardware default refresh rate, added support for 1280x1024 70Hz and 74Hz.
 *
 *    Rev 1.14   30 Jun 1994 18:14:28   RWOLFF
 * Moved IsApertureConflict_cx() to SETUP_CX.C because the new method
 * of checking for conflict requires access to definitions and data
 * structures which are only available in this module.
 *
 *    Rev 1.13   15 Jun 1994 11:08:02   RWOLFF
 * Now lists block write as unavailable on DRAM cards.
 *
 *    Rev 1.12   17 May 1994 15:59:48   RWOLFF
 * No longer sets a higher pixel clock for "canned" mode tables on some
 * DACs. The BIOS will increase the pixel clock frequency for DACs that
 * require it.
 *
 *    Rev 1.11   12 May 1994 11:15:26   RWOLFF
 * No longer does 1600x1200, now lists predefined refresh rates as available
 * instead of only the refresh rate stored in EEPROM.
 *
 *    Rev 1.10   05 May 1994 13:41:00   RWOLFF
 * Now reports block write unavailable on Rev. C and earlier ASICs.
 *
 *    Rev 1.9   27 Apr 1994 14:02:26   RWOLFF
 * Fixed detection of "LFB disabled" case, no longer creates 4BPP mode tables
 * for 68860 DAC (this DAC doesn't do 4BPP), fixed query of DAC type (DAC
 * list in BIOS guide is wrong).
 *
 *    Rev 1.8   26 Apr 1994 12:49:16   RWOLFF
 * Fixed handling of 640x480 and 800x600 if LFB configured but not available.
 *
 *    Rev 1.7   31 Mar 1994 15:03:40   RWOLFF
 * Added 4BPP support, debugging code to see why some systems were failing.
 *
 *    Rev 1.6   15 Mar 1994 16:27:00   RWOLFF
 * Rounds 8M aperture down to 8M boundary, not 16M boundary.
 *
 *    Rev 1.5   14 Mar 1994 16:34:40   RWOLFF
 * Fixed handling of 8M linear aperture installed so it doesn't start on
 * an 8M boundary (retail version of install program shouldn't allow this
 * condition to exist), fix for tearing on 2M boundary.
 *
 *    Rev 1.4   09 Feb 1994 15:32:22   RWOLFF
 * Corrected name of variable for best colour depth found, closed
 * comment that had been left open in previous revision.
 *
 *    Rev 1.3   08 Feb 1994 19:02:34   RWOLFF
 * No longer makes 1024x768 87Hz interlaced available if Mach 64 card is
 * configured with 1024x768 set to "Not installed".
 *
 *    Rev 1.2   07 Feb 1994 14:12:00   RWOLFF
 * Added alloc_text() pragmas to allow miniport to be swapped out when
 * not needed, removed GetMemoryNeeded_cx() which was only called by
 * LookForSubstitute(), a routine removed from ATIMP.C.
 *
 *    Rev 1.1   03 Feb 1994 16:43:20   RWOLFF
 * Fixed "ceiling check" on right scissor registers (documentation
 * had maximum value wrong).
 *
 *    Rev 1.0   31 Jan 1994 11:12:08   RWOLFF
 * Initial revision.
 *
 *    Rev 1.2   14 Jan 1994 15:23:34   RWOLFF
 * Gives unambiguous value for ASIC revision, uses deepest mode table for
 * a given resolution rather than the first one it finds, added routine
 * to check if block write mode is available, support for 1600x1200.
 *
 *    Rev 1.1   30 Nov 1993 18:26:30   RWOLFF
 * Fixed hang bug in DetectMach64(), moved query buffer off visible screen,
 * changed QueryMach64() to correspond to latest BIOS specifications,
 * added routines to check for aperture conflict and to find the
 * amount of video memory needed by a given mode.
 *
 *    Rev 1.0   05 Nov 1993 13:36:28   RWOLFF
 * Initial revision.

End of PolyTron RCS section                             *****************/

#ifdef DOC
QUERY_CX.C - Functions to detect the presence of and find out the
             configuration of 68800CX-compatible ATI accelerators.

#endif

#include "dderror.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "miniport.h"
#include "ntddvdeo.h"
#include "video.h"

#include "stdtyp.h"

#include "amachcx.h"
#include "amach1.h"
#include "atimp.h"
#include "atint.h"
#include "cvtvga.h"
#define INCLUDE_QUERY_CX
#define STRUCTS_QUERY_CX
#include "query_cx.h"
#include "services.h"
#include "setup_cx.h"
#include "cvtddc.h"



/*
 * Prototypes for static functions.
 */
static void CleanupQuery(PUCHAR CapBuffer, PUCHAR SupBuffer, PUCHAR MappedBuffer, long BufferSeg, PUCHAR SavedScreen);


/*
 * Allow miniport to be swapped out when not needed.
 */
#if defined (ALLOC_PRAGMA)
#pragma alloc_text(PAGE_CX, DetectMach64)
#pragma alloc_text(PAGE_CX, QueryMach64)
#pragma alloc_text(PAGE_CX, BlockWriteAvail_cx)
#pragma alloc_text(PAGE_CX, TextBanding_cx)
#pragma alloc_text(PAGE_CX, CleanupQuery)
#endif



/***************************************************************************
 *
 * int DetectMach64(void);
 *
 * DESCRIPTION:
 *  Detect whether or not a Mach 64 accelerator is present.
 *
 * RETURN VALUE:
 *  MACH64_ULTRA if Mach 64 accelerator found
 *  NO_ATI_ACCEL if no Mach 64 accelerator found
 *
 * GLOBALS CHANGED:
 *  none
 *
 * CALLED BY:
 *  ATIMPFindAdapter()
 *
 * AUTHOR:
 *  Robert Wolff
 *
 * CHANGE HISTORY:
 *
 * TEST HISTORY:
 *
 ***************************************************************************/

int DetectMach64(void)
{
    int CardType = MACH64_ULTRA;    /* Initially assume Mach 64 is present */
    DWORD ScratchReg0;              /* Saved contents of SCRATCH_REG0 */
    WORD CfgChipType;               /* CFG_CHIP_TYPE field of CONFIG_CHIP_ID */

    /*
     * Some other brands of video card will pass the write/read back
     * test for the Mach 64. To avoid falsely identifying them as
     * Mach 64 cards, check for the ATI signature string in the BIOS.
     *
     * Failure cases use DEBUG_DETAIL rather than DEBUG_ERROR because
     * failed detection of the Mach 64 is a normal case for Mach 8 and
     * Mach 32 cards, and for non-ATI cards in "run all the miniports
     * and see which ones find their cards" video determination.
     */
    if (Get_BIOS_Seg() == FALSE)
        {
        VideoDebugPrint((DEBUG_DETAIL, "DetectMach64() no ATI BIOS signature found\n"));
        }

    /*
     * On a machine with a Mach 32 to provide an ATI video BIOS
     * segment, a card with a 32 bit read/write register matching
     * SCRATCH_REG0 would be falsely detected as a Mach 64. To
     * avoid this, check the CFG_CHIP_TYPE field of CONFIG_CHIP_ID
     * against values found in this field for known Mach 64 ASICs
     * as an additional test. Since this test is non-destructive,
     * do it first.
     */
    CfgChipType = INPW(CONFIG_CHIP_ID);
    if ((CfgChipType != CONFIG_CHIP_ID_TypeGX) &&   /* GX */
        (CfgChipType != CONFIG_CHIP_ID_TypeCX) &&   /* CX */
        (CfgChipType != 0x4354) &&  /* CT */
        (CfgChipType != 0x4554) &&  /* ET */
        (CfgChipType != 0x4754) &&  /* GT */
        (CfgChipType != 0x4C54) &&  /* LT */
        (CfgChipType != 0x4D54) &&  /* MT */
        (CfgChipType != 0x5254) &&  /* RT */
        (CfgChipType != 0x5654) &&  /* VT */
        (CfgChipType != 0x3354))    /* 3T */
        {
        VideoDebugPrint((DEBUG_DETAIL, "DetectMach64() - CFG_CHIP_TYPE = 0x%X doesn't match known Mach 64 ASIC\n", CfgChipType));
        return NO_ATI_ACCEL;
        }

    /*
     * Save the contents of SCRATCH_REG0, since they are destroyed in
     * the test for Mach 64 accelerators.
     */
    ScratchReg0 = INPD(SCRATCH_REG0);

    /*
     * On a Mach 64 card, any 32 bit pattern written to SCRATCH_REG0
     * will be read back as the same value. Since unimplemented registers
     * normally drift to either all set or all clear, test this register
     * with two patterns (second is the complement of the first) containing
     * alternating set and clear bits. If either of them is not read back
     * unchanged, then assume that no Mach 64 card is present.
     *
     * After writing, we must wait long enough for the contents of
     * SCRATCH_REG0 to settle down. We can't use a WaitForIdle_cx() call
     * because this function uses a register which only exists in
     * memory-mapped form, and we don't initialize the memory-mapped
     * registers until we know that we are dealing with a Mach 64 card.
     * Instead, assume that it will settle down in 1 millisecond.
     *
     * Test the low word of SCRATCH_REG0 before testing the whole
     * doubleword. This is because the high word of this register
     * corresponds to the MEM_BNDRY register on the Mach 32 (low
     * word not used). If we do a doubleword write on a Mach 32
     * card (Mach 64 detection is before Mach 32 detection), we
     * will plug garbage data into MEM_BNDRY, which will hang the machine.
     */
    OUTPW(SCRATCH_REG0,0x05555);
    delay(1);
    if (INPW(SCRATCH_REG0) != 0x05555)
        CardType = NO_ATI_ACCEL;

    OUTPW(SCRATCH_REG0, 0x0AAAA);
    delay(1);
    if (INPW(SCRATCH_REG0) != 0x0AAAA)
        CardType = NO_ATI_ACCEL;

    /*
     * Failure - restore the register and return.
     */
    if (CardType == NO_ATI_ACCEL)
        {
        OUTPW(SCRATCH_REG0, (WORD)(ScratchReg0 & 0x0000FFFF));
        VideoDebugPrint((DEBUG_DETAIL, "DetectMach64() - SCRATCH_REG0 word readback doesn't match value written\n"));
        return CardType;
        }

    /*
     * Success - test the register as a doubleword.
     */
    OUTPD(SCRATCH_REG0, 0x055555555);
    delay(1);
    if (INPD(SCRATCH_REG0) != 0x055555555)
        CardType = NO_ATI_ACCEL;

    OUTPD(SCRATCH_REG0, 0x0AAAAAAAA);
    delay(1);
    if (INPD(SCRATCH_REG0) != 0x0AAAAAAAA)
        CardType = NO_ATI_ACCEL;

    /*
     * Restore the contents of SCRATCH_REG0 and let the caller know
     * whether or not we found a Mach 64.
     */
    OUTPD(SCRATCH_REG0, ScratchReg0);

    return CardType;

}   /* DetectMach64() */



/***************************************************************************
 *
 * VP_STATUS QueryMach64(Query);
 *
 * struct query_structure *Query;   Query structure to fill in
 *
 * DESCRIPTION:
 *  Fill in the query structure and mode tables for the
 *  Mach 64 accelerator.
 *
 * RETURN VALUE:
 *  NO_ERROR if successful
 *  ERROR_INSUFFICIENT_BUFFER if not enough space to collect data
 *  any error code returned by operating system calls.
 *
 * GLOBALS CHANGED:
 *  none
 *
 * CALLED BY:
 *  ATIMPFindAdapter()
 *
 * AUTHOR:
 *  Robert Wolff
 *
 * CHANGE HISTORY:
 *
 * TEST HISTORY:
 *
 ***************************************************************************/

VP_STATUS QueryMach64(struct query_structure *Query)
{
    VIDEO_X86_BIOS_ARGUMENTS Registers; /* Used in VideoPortInt10() calls */
    VP_STATUS RetVal;                   /* Status returned by VideoPortInt10() */
    short MaxModes;                     /* Maximum number of modes possible in query structure */
    short AbsMaxDepth;                  /* Maximum pixel depth supported by the DAC */
    struct cx_query *CxQuery;           /* Query header from BIOS call */
    struct cx_mode_table *CxModeTable;  /* Mode tables from BIOS call */
    struct st_mode_table ThisRes;       /* All-depth mode table for current resolution */
    short CurrentRes;                   /* Current resolution we are working on */
    long BufferSeg;                     /* Segment of buffer used for BIOS query */
    long BufferSize;                    /* Size of buffer needed for BIOS query */
    PUCHAR MappedBuffer;                /* Pointer to buffer used for BIOS query */
    short Count;                        /* Loop counter */
    DWORD Scratch;                      /* Temporary variable */
    long MemAvail;                      /* Memory available, in bytes */
    long NumPixels;                     /* Number of pixels for the current mode */
    struct st_mode_table *pmode;        /* Mode table to be filled in */
    short StartIndex;                   /* First mode for SetFixedModes() to set up */
    short EndIndex;                     /* Last mode for SetFixedModes() to set up */
    BOOL ModeInstalled;                 /* Is this resolution configured? */
    short FreeTables;                   /* Number of remaining free mode tables */
    short FormatType;                   /* Which table format is in use */
    UCHAR DacTypeMask;                  /* Bitmask for DAC type on the card */
    UCHAR OrigDacType;                  /* DAC type before processing into AMACH1.H ordering */
    UCHAR OrigRamType;                  /* RAM type before processing into AMACH1.H ordering */
    UCHAR OrigRamSize;                  /* Amount of RAM before processing into number of 256k banks */
    PUCHAR HwCapBuffer;                 /* Pointer to buffer of hardware capabilities */
    PUCHAR HwSupBuffer;                 /* Pointer to supplemental buffer */
    PUCHAR HwCapWalker;                 /* Pointer to walk through above buffer */
    struct cx_hw_cap *HwCapEntry;       /* Pointer to single entry in table of hardware capabilities */
    UCHAR HwCapBytesPerRow;             /* Number of bytes in each hardware capability entry */
    UCHAR MaxDotClock[HOW_MANY_DEPTHS]; /* Maximum dot clock at each pixel depth for the current resolution */
    UCHAR CurrentDepth;                 /* Pixel depth for current hardware capability entry */
    /*
     * Place to save the contents of the VGA screen before making a BIOS
     * query using the VGA memory as a buffer. Needed only when using
     * the existing graphics screen as a buffer, since we use an offscreen
     * portion of the text screen, and if we have to switch into a VGA
     * graphics mode there will be nothing to save.
     */
    UCHAR SavedVgaBuffer[VGA_TOTAL_SIZE];


    /*
     * If we do not yet know the BIOS prefix for this card (i.e.
     * it is a block relocatable card where we must match the
     * BIOS prefix to the I/O base in case we have multiple
     * cards.
     */
    if (phwDeviceExtension->BiosPrefix == BIOS_PREFIX_UNASSIGNED)
        {
        /*
         * We don't support block relocatable cards in the
         * no-BIOS configuration.
         */
        phwDeviceExtension->BiosPrefix = BIOS_PREFIX_VGA_ENAB;

        /*
         * We shouldn't need to check for equality, but this allows
         * us to catch the "too many cards - this one doesn't have
         * a BIOS prefix" case by checking for an out-of-range
         * prefix after the loop exits.
         */
        while (phwDeviceExtension->BiosPrefix <= BIOS_PREFIX_MAX_DISAB)
            {
            VideoDebugPrint((DEBUG_DETAIL, "Testing BIOS prefix 0x%X\n", phwDeviceExtension->BiosPrefix));
            VideoPortZeroMemory(&Registers, sizeof(VIDEO_X86_BIOS_ARGUMENTS));
            Registers.Eax = BIOS_QUERY_IOBASE;
            if ((RetVal = VideoPortInt10(phwDeviceExtension, &Registers)) != NO_ERROR)
                {
                VideoDebugPrint((DEBUG_ERROR, "QueryMach64() - failed BIOS_QUERY_IOBASE\n"));
                return RetVal;
                }
            /*
             * If the card with the current BIOS prefix uses our I/O base
             * address, we have found the correct prefix. Otherwise,
             * try the next prefix.
             */
            if (Registers.Edx == phwDeviceExtension->BaseIOAddress)
                {
                VideoDebugPrint((DEBUG_DETAIL, "Card with I/O base address 0x%X uses BIOS prefix 0x%X\n", Registers.Edx, phwDeviceExtension->BiosPrefix));
                break;
                }
            else
                {
                VideoDebugPrint((DEBUG_DETAIL, "Reported I/O base of 0x%X - no match\n", Registers.Edx));
                }

            phwDeviceExtension->BiosPrefix += BIOS_PREFIX_INCREMENT;

            }   /* end while (searching for the correct prefix) */

        /*
         * The equality test on the loop will result in an illegal
         * prefix on exit if there are too many cards for us to
         * handle, and this is one of the "orphans".
         */
        if (phwDeviceExtension->BiosPrefix > BIOS_PREFIX_MAX_DISAB)
            {
            VideoDebugPrint((DEBUG_ERROR, "QueryMach64() - can't find BIOS prefix for card with I/O base 0x%X\n", phwDeviceExtension->BaseIOAddress));
            return ERROR_DEV_NOT_EXIST;
            }

        }   /* endif (unassigned BIOS prefix) */

    /*
     * Find out how large a buffer we need when making a BIOS query call.
     */
    VideoPortZeroMemory(&Registers, sizeof(VIDEO_X86_BIOS_ARGUMENTS));

    Registers.Eax = BIOS_GET_QUERY_SIZE;
    Registers.Ecx = BIOS_QUERY_FULL;
    if ((RetVal = VideoPortInt10(phwDeviceExtension, &Registers)) != NO_ERROR)
        {
        VideoDebugPrint((DEBUG_ERROR, "QueryMach64() - failed BIOS_GET_QUERY_SIZE\n"));
        return RetVal;
        }
    BufferSize = Registers.Ecx & 0x0000FFFF;

    /*
     * Allocate a buffer to store the query information. Due to the BIOS
     * being real mode, this buffer must be below 1M. When this function
     * is called, we are on the "blue screen", so there is a 32k window
     * below 1M that we can use without risk of corrupting executable code.
     *
     * To avoid the need to save and restore our buffer, use only the
     * offscreen portion of this window (video memory contents will be
     * initialized before they are used, so the leftover query structure
     * won't harm anything). Assume a 50 line text screen.
     *
     * Check to see if the query structure is small enough to fit into
     * this region, and fail if it's too big. If it fits, try to allocate
     * the memory in the colour text window and see if there's enough
     * physical memory to meet our needs. If this fails, try again for
     * the monochrome text window (since VGA can run as either colour
     * or monochrome).
     *
     * If both fail (will happen on some DEC ALPHA machines), try using
     * the existing VGA graphics screen. Since we will be using an
     * on-screen portion of this buffer, we must save and restore the
     * contents of this buffer.
     *
     * If this fails (haven't run into any machines where this is the
     * case), switch into SVGA 640x480 8BPP and use the VGA graphics
     * screen. This is a last resort, since unlike using an existing
     * screen, this will destroy the "blue screen", and is therefore not
     * transparent to the user. If we can't even get this to work, report
     * that there isn't enough buffer space. This would only happen when
     * the onboard VGA is disabled and a low-end (MDA - even CGA has 16k
     * of memory available) card is used to provide the text screen.
     */
    /*
     * Leave some room for the EDID structure, which must also be
     * read into a buffer below 1M physical.
     */
    if (BufferSize > 0x5000)
        {
        VideoDebugPrint((DEBUG_ERROR, "QueryMach64() - query needs more buffer than we have\n"));
        return ERROR_INSUFFICIENT_BUFFER;
        }

    BufferSeg = 0x0BA00;    /* Colour text */
    MappedBuffer = MapFramebuffer((BufferSeg << 4), BufferSize);
    if (MappedBuffer != 0)
        {
        if (IsBufferBacked(MappedBuffer, BufferSize) == FALSE)
            {
            VideoDebugPrint((DEBUG_NORMAL, "Colour text screen not backed by physical memory\n"));
            VideoPortFreeDeviceBase(phwDeviceExtension, MappedBuffer);
            MappedBuffer = 0;
            }
        }
    else
        {
        VideoDebugPrint((DEBUG_NORMAL, "Can't map colour text screen\n"));
        }

    /*
     * If we were unable to allocate a large enough buffer in the
     * colour text screen, try the monochrome text screen.
     */
    if (MappedBuffer == 0)
        {
        VideoDebugPrint((DEBUG_NORMAL, "Can't use colour text screen, trying monochrome text screen\n"));
        BufferSeg = 0x0B200;
        if ((MappedBuffer = MapFramebuffer((BufferSeg << 4), BufferSize)) != 0)
            {
            if (IsBufferBacked(MappedBuffer, BufferSize) == FALSE)
                {
                VideoDebugPrint((DEBUG_NORMAL, "Monochrome text screen not backed by physical memory\n"));
                VideoPortFreeDeviceBase(phwDeviceExtension, MappedBuffer);
                MappedBuffer = 0;
                }
            }
        else
            {
            VideoDebugPrint((DEBUG_NORMAL, "Can't map monochrome text screen\n"));
            }
        }

    if (MappedBuffer == 0)
        {
        /*
         * We were unable to use the offscreen portion of video memory
         * in either of the text screens. Try to use an existing graphics
         * screen.
         *
         * Currently, only the DEC Alpha will fail to find the offscreen
         * portion of either text screen.
         */
        VideoDebugPrint((DEBUG_NORMAL, "Can't use monochrome text screen, trying existing graphics screen\n"));
        BufferSeg = 0x0A000;
        if ((MappedBuffer = MapFramebuffer((BufferSeg << 4), BufferSize)) != 0)
            {
            /*
             * Preserve the contents of VGA registers which affect the
             * manner in which graphics memory is accessed, then set
             * the values we need.
             */
            OUTP(VGA_SEQ_IND, 2);
            SavedVgaBuffer[VGA_SAVE_SEQ02] = INP(VGA_SEQ_DATA);
            OUTP(VGA_SEQ_IND, 2);
            OUTP(VGA_SEQ_DATA, 0x01);
            OUTP(VGA_GRAX_IND, 8);
            SavedVgaBuffer[VGA_SAVE_GRA08] = INP(VGA_GRAX_DATA);
            OUTP(VGA_GRAX_IND, 8);
            OUTP(VGA_GRAX_DATA, 0xFF);
            OUTP(VGA_GRAX_IND, 1);
            SavedVgaBuffer[VGA_SAVE_GRA01] = INP(VGA_GRAX_DATA);
            OUTP(VGA_GRAX_IND, 1);
            OUTP(VGA_GRAX_DATA, 0x00);

            /*
             * Save the contents of the screen to our private
             * buffer, so we can restore the screen later.
             */
            if (BufferSize > VGA_SAVE_SIZE)
                {
                VideoDebugPrint((DEBUG_ERROR, "Buffer too big to fully save/restore\n"));
                Scratch = VGA_SAVE_SIZE;
                }
            else
                {
                Scratch = BufferSize;
                }
            SavedVgaBuffer[VGA_SAVE_SIZE] = (UCHAR)(Scratch & 0x00FF);
            SavedVgaBuffer[VGA_SAVE_SIZE_H] = (UCHAR)((ULONG)((Scratch & 0xFF00) >> 8));

            for (Count = 0; (short)Count < (short)Scratch; Count++)
                {
                SavedVgaBuffer[Count] = VideoPortReadRegisterUchar(&(MappedBuffer[Count]));
                }

            if (IsBufferBacked(MappedBuffer, BufferSize) == FALSE)
                {
                VideoDebugPrint((DEBUG_NORMAL, "Existing graphics screen not backed by physical memory\n"));
                VideoPortFreeDeviceBase(phwDeviceExtension, MappedBuffer);
                MappedBuffer = 0;
                OUTP(VGA_SEQ_IND, 2);
                OUTP(VGA_SEQ_DATA, SavedVgaBuffer[VGA_SAVE_SEQ02]);
                OUTP(VGA_GRAX_IND, 8);
                OUTP(VGA_GRAX_DATA, SavedVgaBuffer[VGA_SAVE_GRA08]);
                OUTP(VGA_GRAX_IND, 1);
                OUTP(VGA_GRAX_DATA, SavedVgaBuffer[VGA_SAVE_GRA01]);
                }
            }
        else
            {
            VideoDebugPrint((DEBUG_NORMAL, "Can't map existing graphics screen\n"));
            }
        }   /* end if (previous buffer allocation failed) */

    /*
     * If we were unable to allocate a large enough buffer in an existing
     * screen, try the VGA graphics screen. This will wipe out
     * the Windows NT "blue screen", but it gives us one last chance
     * to get a block of memory below 1M.
     * Don't start at the beginning of the VGA graphics window, since
     * we will need to distinguish this case from the nondestructive
     * access to the VGA graphics screen at cleanup time, and the
     * different buffer segment for the two cases will allow us to
     * do this.
     */
    if (MappedBuffer == 0)
        {
        VideoDebugPrint((DEBUG_NORMAL, "Nondestructive VGA memory access failed, trying graphics screen\n"));
        Registers.Eax = 0x62;       /* 640x480 8BPP */
        VideoPortInt10(phwDeviceExtension, &Registers);
        BufferSeg = 0x0A100;
        if ((MappedBuffer = MapFramebuffer((BufferSeg << 4), BufferSize)) == 0)
            {
            VideoDebugPrint((DEBUG_ERROR, "Can't map graphics screen - aborting query\n"));
            return ERROR_INSUFFICIENT_BUFFER;
            }

        if (IsBufferBacked(MappedBuffer, BufferSize) == FALSE)
            {
            VideoDebugPrint((DEBUG_ERROR, "Graphics screen not backed by memory - aborting query\n"));
            VideoPortFreeDeviceBase(phwDeviceExtension, MappedBuffer);
            return ERROR_INSUFFICIENT_BUFFER;
            }
        }

    /*
     * We now have a buffer big enough to hold the query structure,
     * so make the BIOS call to fill it in.
     */
    Registers.Ebx = 0;
    Registers.Edx = BufferSeg;
    Registers.Eax = BIOS_QUERY;
    Registers.Ecx = BIOS_QUERY_FULL;
    if ((RetVal = VideoPortInt10(phwDeviceExtension, &Registers)) != NO_ERROR)
        {
        VideoDebugPrint((DEBUG_ERROR, "QueryMach64() - failed BIOS_QUERY_FULL call\n"));
        return RetVal;
        }
    CxQuery = (struct cx_query *)MappedBuffer;

    /*
     * The Mach 64 query structure and mode tables may be a different size
     * from their equivalents (query_structure and st_mode_table). To avoid
     * overflowing our buffer, find out how many mode tables we have space
     * to hold.
     *
     * Later, when we are filling the mode tables, we will check to see
     * whether the current mode table would exceed this limit. If it would,
     * we will return ERROR_INSUFFICIENT_BUFFER rather than overflowing
     * the table.
     */
    MaxModes = (QUERYSIZE - sizeof(struct query_structure)) / sizeof(struct st_mode_table);

    /*
     * Fill in the header of the query stucture.
     */
    Query->q_structure_rev = VideoPortReadRegisterUchar(&(CxQuery->cx_structure_rev));
    VideoDebugPrint((DEBUG_DETAIL, "Structure revision = 0x%X\n", VideoPortReadRegisterUchar(&(CxQuery->cx_structure_rev))));
    Query->q_mode_offset = VideoPortReadRegisterUshort(&(CxQuery->cx_mode_offset));
    VideoDebugPrint((DEBUG_DETAIL, "Mode offset = 0x%X\n", VideoPortReadRegisterUshort(&(CxQuery->cx_mode_offset))));
    Query->q_sizeof_mode = VideoPortReadRegisterUchar(&(CxQuery->cx_mode_size));
    VideoDebugPrint((DEBUG_DETAIL, "Mode size = 0x%X\n", VideoPortReadRegisterUchar(&(CxQuery->cx_mode_size))));

    /*
     * Currently only one revision of Mach 64. Will need to
     * set multiple values once new (production) revisions come out.
     */
    Query->q_asic_rev = CI_88800_GX;
    Query->q_number_modes = 0;      /* Initially assume no modes supported */
    Query->q_status_flags = 0;

    /*
     * If the on-board VGA is enabled, set shared VGA/accelerator memory.
     * Whether or not it is enabled, the accelerator will be able to
     * access all the video memory.
     */
    if ((Query->q_VGA_type = VideoPortReadRegisterUchar(&(CxQuery->cx_vga_type)) != 0))
        {
        Scratch = INPD(MEM_CNTL) & 0x0FFFBFFFF; /* Clear MEM_BNDRY_EN bit */
        OUTPD(MEM_CNTL, Scratch);
        VideoDebugPrint((DEBUG_DETAIL, "VGA enabled on this card\n"));
        }
    else
        {
        VideoDebugPrint((DEBUG_DETAIL, "VGA disabled on this card\n"));
        }
    Query->q_VGA_boundary = 0;

    OrigRamSize = VideoPortReadRegisterUchar(&(CxQuery->cx_memory_size));
    VideoDebugPrint((DEBUG_DETAIL, "Raw memory size = 0x%X\n", OrigRamSize));
    Query->q_memory_size = CXMapMemSize[OrigRamSize];
    MemAvail = Query->q_memory_size * QUARTER_MEG;

    /*
     * DAC types are not contiguous, so a lookup table would be
     * larger than necessary and restrict future expansion.
     */
    OrigDacType = VideoPortReadRegisterUchar(&(CxQuery->cx_dac_type));
    VideoDebugPrint((DEBUG_DETAIL, "cx_dac_type = 0x%X\n", OrigDacType));
    switch(OrigDacType)
        {
        case 0x00:
            VideoDebugPrint((DEBUG_DETAIL, "Internal DAC\n"));
            Scratch = VideoPortReadRegisterUshort(&(CxQuery->cx_asic_rev));
            if ((Scratch & 0xFF00) == 0x4300)
                {
                VideoDebugPrint((DEBUG_DETAIL, "Mach 64 CT internal DAC\n"));
                Query->q_DAC_type = DAC_INTERNAL_CT;
                }
            else if ((Scratch & 0xFF00) == 0x5600)
                {
                VideoDebugPrint((DEBUG_DETAIL, "Mach 64 VT internal DAC\n"));
                Query->q_DAC_type = DAC_INTERNAL_VT;
                }
            else if ((Scratch & 0xFF00) == 0x4700)
                {
                VideoDebugPrint((DEBUG_DETAIL, "Mach 64 GT internal DAC\n"));
                Query->q_DAC_type = DAC_INTERNAL_GT;
                }
            else
                {
                VideoDebugPrint((DEBUG_ERROR, "Unknown internal DAC (ASIC ID = 0x%X), treating as BT47x\n", Scratch));
                Query->q_DAC_type = DAC_BT47x;
                }
            DacTypeMask = 0x01;
            break;

        case 0x01:
            VideoDebugPrint((DEBUG_DETAIL, "IBM 514 DAC\n"));
            Query->q_DAC_type = DAC_IBM514;
            DacTypeMask = 0x02;
            break;

        case 0x02:
            VideoDebugPrint((DEBUG_DETAIL, "TI34075 DAC\n"));
            Query->q_DAC_type = DAC_TI34075;
            DacTypeMask = 0x04;
            break;

        case 0x72:
            VideoDebugPrint((DEBUG_DETAIL, "TVP 3026 DAC\n"));
            Query->q_DAC_type = DAC_TVP3026;
            DacTypeMask = 0x04;
            break;

        case 0x04:
            VideoDebugPrint((DEBUG_DETAIL, "BT48x DAC\n"));
            Query->q_DAC_type = DAC_BT48x;
            DacTypeMask = 0x10;
            break;

        case 0x14:
            VideoDebugPrint((DEBUG_DETAIL, "AT&T 49[123] DAC\n"));
            Query->q_DAC_type = DAC_ATT491;
            DacTypeMask = 0x10;
            break;

        case 0x05:
        case 0x15:
            VideoDebugPrint((DEBUG_DETAIL, "ATI68860 DAC\n"));
            Query->q_DAC_type = DAC_ATI_68860;
            DacTypeMask = 0x20;
            break;

        case 0x06:
            VideoDebugPrint((DEBUG_DETAIL, "STG1700 DAC\n"));
            Query->q_DAC_type = DAC_STG1700;
            DacTypeMask = 0x40;
            break;

        case 0x07:
        case 0x67:
        case 0x77:
        case 0x87:
        case 0x97:
        case 0xA7:
        case 0xB7:
        case 0xC7:
        case 0xD7:
        case 0xE7:
        case 0xF7:
            VideoDebugPrint((DEBUG_DETAIL, "STG1702 DAC\n"));
            Query->q_DAC_type = DAC_STG1702;
            DacTypeMask = 0x80;
            break;

        case 0x37:
            VideoDebugPrint((DEBUG_DETAIL, "STG1703 DAC\n"));
            Query->q_DAC_type = DAC_STG1703;
            DacTypeMask = 0x80;
            break;

        case 0x47:
            VideoDebugPrint((DEBUG_DETAIL, "CH8398 DAC\n"));
            Query->q_DAC_type = DAC_CH8398;
            DacTypeMask = 0x80;
            break;

        case 0x57:
            VideoDebugPrint((DEBUG_DETAIL, "AT&T 408 DAC\n"));
            Query->q_DAC_type = DAC_ATT408;
            DacTypeMask = 0x80;
            break;

        case 0x16:
        case 0x27:
            VideoDebugPrint((DEBUG_DETAIL, "AT&T 498 DAC\n"));
            Query->q_DAC_type = DAC_ATT498;
            DacTypeMask = 0x80;
            break;

        case 0x17:
            VideoDebugPrint((DEBUG_DETAIL, "SC15021 DAC\n"));
            Query->q_DAC_type = DAC_SC15021;
            DacTypeMask = 0x80;
            break;

        case 0x75:
            VideoDebugPrint((DEBUG_DETAIL, "TVP 3026 DAC\n"));
            Query->q_DAC_type = DAC_TVP3026;
            DacTypeMask = 0x20;
            break;

        case 0x03:
            VideoDebugPrint((DEBUG_DETAIL, "BT 47x DAC\n"));
            Query->q_DAC_type = DAC_BT47x;
            DacTypeMask = 0x04;
            break;

        default:
            VideoDebugPrint((DEBUG_ERROR, "Unknown DAC, treating as BT 47x\n"));
            Query->q_DAC_type = DAC_BT47x;
            DacTypeMask = 0x04;
            break;
            }
    VideoDebugPrint((DEBUG_DETAIL, "Raw memory type = 0x%X\n", VideoPortReadRegisterUchar(&(CxQuery->cx_memory_type))));

    /*
     * Bit 7 of the memory type is used to indicate lack of block write
     * capability on recent BIOSes, but not on older ones. Strip it
     * before mapping the RAM type in order to avoid the need for an
     * additional 128 entries, most of which are unused, in the
     * mapping table.
     *
     * Even though the absence of this flag is not a reliable indicator
     * of block write capability, its presence is a reliable indicator
     * of a lack of block write capability.
     *
     * We can strip this flag after setting the block write status since
     * this is the only place it is used, and subsequent references to
     * the memory type require only the lower 7 bits.
     */
    OrigRamType = VideoPortReadRegisterUchar(&(CxQuery->cx_memory_type));
    if (OrigRamType & 0x80)
        Query->q_BlockWrite = BLOCK_WRITE_NO;
    OrigRamType &= 0x7F;
    /*
     * A given memory type value will have different meanings for
     * different ASIC types. While the GX and CX use different
     * RAM types, none of them require special-case handling,
     * so we can treat these ASIC types as equivalent.
     */
    Scratch = INPD(CONFIG_CHIP_ID) & CONFIG_CHIP_ID_TypeMask;
    if ((Scratch == CONFIG_CHIP_ID_TypeGX) ||
        (Scratch == CONFIG_CHIP_ID_TypeCX))
        {
        VideoDebugPrint((DEBUG_DETAIL, "Setting q_memory_type for CX or GX\n"));
        Query->q_memory_type = CXMapRamType[OrigRamType];
        }
    else
        {
        VideoDebugPrint((DEBUG_DETAIL, "Setting q_memory_type for CT/VT/GT\n"));
        Query->q_memory_type = CTMapRamType[OrigRamType];
        }

    VideoDebugPrint((DEBUG_DETAIL, "Raw bus type = 0x%X\n", VideoPortReadRegisterUchar(&(CxQuery->cx_bus_type))));
    Query->q_bus_type = CXMapBus[VideoPortReadRegisterUchar(&(CxQuery->cx_bus_type))];

    /*
     * Get the linear aperture configuration. If the linear aperture and
     * VGA aperture are both disabled, return ERROR_DEV_NOT_EXIST, since
     * some Mach 64 registers exist only in memory mapped form and are
     * therefore not available without an aperture.
     */
    Query->q_aperture_cfg = VideoPortReadRegisterUchar(&(CxQuery->cx_aperture_cfg)) & BIOS_AP_SIZEMASK;
    VideoDebugPrint((DEBUG_DETAIL, "Aperture configuration = 0x%X\n", VideoPortReadRegisterUchar(&(CxQuery->cx_aperture_cfg))));
    if (Query->q_aperture_cfg == 0)
        {
        if (Query->q_VGA_type == 0)
            {
            VideoDebugPrint((DEBUG_ERROR, "Neither linear nor VGA aperture exists - aborting query\n"));
            return ERROR_DEV_NOT_EXIST;
            }
        Query->q_aperture_addr = 0;
        }
    else
        {
        Query->q_aperture_addr = VideoPortReadRegisterUshort(&(CxQuery->cx_aperture_addr));
        VideoDebugPrint((DEBUG_DETAIL, "Aperture at %d megabytes\n", Query->q_aperture_addr));
        /*
         * If the 8M aperture is configured on a 4M boundary that is
         * not also an 8M boundary, it will actually start on the 8M
         * boundary obtained by truncating the reported value to a
         * multiple of 8M.
         */
        if ((Query->q_aperture_cfg & BIOS_AP_SIZEMASK) == BIOS_AP_8M)
            {
            VideoDebugPrint((DEBUG_DETAIL, "8 megabyte aperture\n"));
            Query->q_aperture_addr &= 0xFFF8;
            }
        }

    /*
     * The Mach 64 does not support shadow sets, so re-use the shadow
     * set 1 definition to hold deep colour support and RAMDAC special
     * features information.
     */
    Query->q_shadow_1 = VideoPortReadRegisterUchar(&(CxQuery->cx_deep_colour)) | (VideoPortReadRegisterUchar(&(CxQuery->cx_ramdac_info)) << 8);
    VideoDebugPrint((DEBUG_DETAIL, "Deep colour support = 0x%X\n", VideoPortReadRegisterUchar(&(CxQuery->cx_deep_colour))));

    /*
     * If this card supports non-palette modes, choose which of the supported
     * colour orderings to use at each pixel depth. Record the maximum
     * pixel depth the card supports, since some of the mode tables
     * may list a maximum pixel depth beyond the DAC's capabilities.
     *
     * Assume that no DAC will support nBPP (n > 8) without also supporting
     * all colour depths between 8 and n.
     */
    AbsMaxDepth = 8;    /* Cards without high colour support */
    if (Query->q_shadow_1 & S1_16BPP_565)
        {
        Query->q_HiColourSupport = RGB16_565;
        AbsMaxDepth = 16;
        }
    if (Query->q_shadow_1 & S1_24BPP)
        {
        if (Query->q_shadow_1 & S1_24BPP_RGB)
            {
            VideoDebugPrint((DEBUG_DETAIL, "24BPP order RGB\n"));
            Query->q_HiColourSupport |= RGB24_RGB;
            }
        else
            {
            VideoDebugPrint((DEBUG_DETAIL, "24BPP order BGR\n"));
            Query->q_HiColourSupport |= RGB24_BGR;
            }
        AbsMaxDepth = 24;
        }
    if (Query->q_shadow_1 & S1_32BPP)
        {
        if (Query->q_shadow_1 & S1_32BPP_RGBx)
            {
            VideoDebugPrint((DEBUG_DETAIL, "32BPP order RGBx\n"));
            Query->q_HiColourSupport |= RGB32_RGBx;
            }
        else if (Query->q_shadow_1 & S1_32BPP_xRGB)
            {
            VideoDebugPrint((DEBUG_DETAIL, "32BPP order xRGB\n"));
            Query->q_HiColourSupport |= RGB32_xRGB;
            }
        else if (Query->q_shadow_1 & S1_32BPP_BGRx)
            {
            VideoDebugPrint((DEBUG_DETAIL, "32BPP order BGRx\n"));
            Query->q_HiColourSupport |= RGB32_BGRx;
            }
        else
            {
            VideoDebugPrint((DEBUG_DETAIL, "32BPP order xBGR\n"));
            Query->q_HiColourSupport |= RGB32_xBGR;
            }
        AbsMaxDepth = 32;
        }

    /*
     * Get the hardware capability list.
     */
    Registers.Eax = BIOS_CAP_LIST;
    Registers.Ecx = 0xFFFF;
    if ((RetVal = VideoPortInt10(phwDeviceExtension, &Registers)) != NO_ERROR)
        {
        VideoDebugPrint((DEBUG_ERROR, "QueryMach64() - failed BIOS_CAP_LIST\n"));
        return RetVal;
        }

    FormatType = (short)(Registers.Eax & 0x000000FF);

    /*
     * Map in the table of hardware capabilities whose pointer was returned
     * by the BIOS call. The call does not return the size of the table,
     * but according to Steve Stefanidis 1k is plenty of space.
     *
     * We must include the 2 bytes immediately preceeding the table when
     * we map it, since they contain information about the way the table
     * is arranged.
     */
    if ((HwCapBuffer = MapFramebuffer(((Registers.Edx << 4) | (Registers.Ebx - 2)), 1024)) == 0)
        {
        VideoDebugPrint((DEBUG_ERROR, "Can't map hardware capability table at 0x%X:0x%X\n", Registers.Edx, Registers.Ebx));
        return ERROR_INSUFFICIENT_BUFFER;
        }

    /*
     * If the value in the CX register was changed, there is a second
     * table with supplemental values. According to Arthur Lai, this
     * second table will only extend the original table, and never
     * detract from it. If this table exists, but we can't map it,
     * we can still work with the primrary table rather than treating
     * the failure as a fatal error.
     *
     * While the BIOS will leave the CX register alone if the second
     * table doesn't exist, there is no guarantee that Windows NT will
     * leave the upper 16 bits of ECX alone.
     */
    if ((Registers.Ecx & 0x0000FFFF) == 0xFFFF)
        {
        HwSupBuffer = 0;
        }
    else
        {
        HwSupBuffer = MapFramebuffer(((Registers.Edx << 4) | Registers.Ecx), 1024);
        }

    HwCapBytesPerRow = VideoPortReadRegisterUchar(HwCapBuffer + 1);
    VideoDebugPrint((DEBUG_DETAIL, "Table has %d bytes per row\n", HwCapBytesPerRow));

    pmode = (struct st_mode_table *)Query;
    ((struct query_structure *)pmode)++;

    /*
     * Initially, we do not know whether to merge our "canned" mode
     * tables with tables from an EDID structure returned via DDC,
     * or with tables from a VDIF file. If we are dealing with an
     * EDID structure, we have not yet read any data, so the initial
     * checksum is zero.
     */
    phwDeviceExtension->MergeSource = MERGE_UNKNOWN;
    phwDeviceExtension->EdidChecksum = 0;

    /*
     * Search through the returned mode tables, and fill in the query
     * structure's mode tables using the information we find there.
     *
     * DOES NOT ASSUME: Order of mode tables, or number of mode
     *                  tables per resolution.
     */
    for (CurrentRes = RES_640; CurrentRes <= RES_1600; CurrentRes++)
        {
        CxModeTable = (struct cx_mode_table *)(MappedBuffer + VideoPortReadRegisterUshort(&(CxQuery->cx_mode_offset)));

        /*
         * The list of maximum pixel clock frequencies contains either
         * garbage (640x480), or the results for the previous resolution.
         * Clear it.
         */
        for (Count = DEPTH_NOTHING; Count <= DEPTH_32BPP; Count++)
            MaxDotClock[Count] = 0;

        /*
         * Search through the list of hardware capabilities. If we find
         * an entry for the current resolution, the DAC/RAM type is
         * correct, and we have enough memory, update the list of
         * maximum pixel clock frequencies.
         *
         * If we have switched to the supplemental table on a previous
         * resolution, switch back to the primrary table.
         */
        HwCapWalker = HwCapBuffer + 2;
        HwCapEntry = (struct cx_hw_cap *)HwCapWalker;
        if (FormatType >= FORMAT_DACTYPE)
            FormatType -= FORMAT_DACTYPE;

        while (VideoPortReadRegisterUchar(&(HwCapEntry->cx_HorRes)) != 0)
            {
            /*
             * Assigning HwCapEntry is redundant on the first pass
             * through the loop, but by assigning it and then incrementing
             * HwCapWalker at the beginning of the loop it reduces the
             * complexity of each "skip this entry because it doesn't
             * apply to us" decision point.
             *
             * A side effect of this is that we will check each entry
             * to see if its horizontal resolution is zero (end-of-table
             * flag) only after we have examined it in an attempt to
             * add its pixel clock data to our list. This is harmless,
             * since a horizontal resolution of zero will not match any
             * of the resolutions we are looking for, so the check to
             * see if the current entry is for the correct resolution
             * will always interpret the end-of-table flag as being
             * an entry for the wrong resolution, and skip to the next
             * entry. This will take us to the top of the loop, where
             * we will see that we have hit the end of the table.
             */
            HwCapEntry = (struct cx_hw_cap *)HwCapWalker;
            HwCapWalker += HwCapBytesPerRow;

            /*
             * If we have run into the end of the first table and
             * the second (supplemental) table exists, switch to
             * it. If we have hit the end of the supplemental
             * table, the check to see if we're looking at an
             * entry corresponding to the desired resolution will
             * catch it and get us out of the loop.
             *
             * The format type returned by the BIOS is the same
             * regardless of whether we are working with the
             * primrary or supplemental table. Since the primrary
             * table uses masks based on the type, while the
             * supplemental table requires an exact match, we
             * must distinguish between the tables when looking
             * at the format type. By making a duplicate set of
             * format types for "exact match", with each defined
             * value in this set being greater than its "mask"
             * counterpart by the number of format types the BIOS
             * can return, we can also use the format type to
             * determine which table we are working with. The
             * DAC-formatted table is the lowest (zero for "mask",
             * number of format types for "exact match").
             */
            if ((VideoPortReadRegisterUchar(&(HwCapEntry->cx_HorRes)) == 0) &&
                (FormatType < FORMAT_DACTYPE))
                {
                VideoDebugPrint((DEBUG_DETAIL, "Switching to supplemental table\n"));
                HwCapWalker = HwSupBuffer;
                HwCapEntry = (struct cx_hw_cap *)HwCapWalker;
                HwCapWalker += HwCapBytesPerRow;
                FormatType += FORMAT_DACTYPE;
                }

            /*
             * Reject entries dealing with resolutions other than the
             * one we are interested in. The cx_HorRes field is in units
             * of 8 pixels.
             */
            Scratch = VideoPortReadRegisterUchar(&(HwCapEntry->cx_HorRes));
            if (((CurrentRes == RES_640) && (Scratch != 80)) ||
                ((CurrentRes == RES_800) && (Scratch != 100)) ||
                ((CurrentRes == RES_1024) && (Scratch != 128)) ||
                ((CurrentRes == RES_1152) && (Scratch != 144)) ||
                ((CurrentRes == RES_1280) && (Scratch != 160)) ||
                ((CurrentRes == RES_1600) && (Scratch != 200)))
                {
                VideoDebugPrint((DEBUG_DETAIL, "Incorrect resolution - %d pixels wide\n", (Scratch*8)));
                continue;
                }
            VideoDebugPrint((DEBUG_DETAIL, "Correct resolution"));

            /*
             * Reject entries which require a DAC or RAM type other
             * than that installed on the card.
             *
             * Reminder - Unlike loops, switch statements are affected
             *            by "break" but not by "continue".
             */
            switch(FormatType)
                {
                case FORMAT_DACMASK:
                    if ((VideoPortReadRegisterUchar(&(HwCapEntry->cx_RamOrDacType)) & DacTypeMask) == 0)
                        {
                        VideoDebugPrint((DEBUG_DETAIL, " but wrong DAC type (mask)\n"));
                        continue;
                        }
                    break;

                case FORMAT_RAMMASK:
                    /*
                     * Although the BIOS query structure definition allows bits
                     * 0 through 3 of the memory type field to be used as a
                     * memory type identifier, we must use only bits 0 through
                     * 2 to avoid shifting past the end of the 8-bit mask. Since
                     * even the ASIC which supports the most memory types (GX)
                     * only supports 7 types according to my BIOS guide, this
                     * should not be a problem.
                     */
                    if ((VideoPortReadRegisterUchar(&(HwCapEntry->cx_RamOrDacType)) & (1 << (OrigRamType & 0x07))) == 0)
                        {
                        VideoDebugPrint((DEBUG_DETAIL, " but wrong RAM type (mask)\n"));
                        continue;
                        }
                    break;

                case FORMAT_DACTYPE:
                    if (VideoPortReadRegisterUchar(&(HwCapEntry->cx_RamOrDacType)) != OrigDacType)
                        {
                        VideoDebugPrint((DEBUG_DETAIL, " but wrong DAC type (exact match)\n"));
                        continue;
                        }
                    break;

                case FORMAT_RAMTYPE:
                    if (VideoPortReadRegisterUchar(&(HwCapEntry->cx_RamOrDacType)) != OrigRamType)
                        {
                        VideoDebugPrint((DEBUG_DETAIL, " but wrong RAM type (exact match)\n"));
                        continue;
                        }
                    break;

                default:
                    VideoDebugPrint((DEBUG_ERROR, "\nInvalid format type %d\n", FormatType));
                    continue;
                    break;
                }
            VideoDebugPrint((DEBUG_DETAIL, ", correct DAC/RAM type"));

            /*
             * Reject entries which require more RAM than is
             * installed on the card. The amount of RAM required
             * for a given mode may vary between VRAM and DRAM
             * cards.
             *
             * The same RAM type code may represent different
             * types of RAM for different Mach 64 ASICs. Since
             * only the GX supports VRAM (as of the time of printing
             * of my BIOS guide), it is safe to assume that any
             * non-GX ASIC is using DRAM.
             */
            Scratch = OrigRamType;
            if ((INPW(CONFIG_CHIP_ID) == CONFIG_CHIP_ID_TypeGX) &&
                ((Scratch == 1) ||
                (Scratch == 2) ||
                (Scratch == 5) ||
                (Scratch == 6)))
                {
                Scratch = VideoPortReadRegisterUchar(&(HwCapEntry->cx_MemReq)) & 0x0F;
                }
            else /* if (card uses DRAM) */
                {
                Scratch = VideoPortReadRegisterUchar(&(HwCapEntry->cx_MemReq)) & 0xF0;
                Scratch >>= 4;
                }

            if (Scratch > OrigRamSize)
                {
                VideoDebugPrint((DEBUG_DETAIL, " but insufficient RAM\n"));
                continue;
                }
            VideoDebugPrint((DEBUG_DETAIL, ", and enough RAM to support the mode\n"));

            /*
             * We have found an entry corresponding to this card's
             * capabilities. For each pixel depth up to and including
             * the maximum applicable for this entry, set the maximum
             * pixel clock rate to the higher of its current value
             * and the value for this entry.
             *
             * We must mask off the high bit of the maximum pixel depth
             * because it is a flag which is irrelevant for our purposes.
             */
            Scratch = VideoPortReadRegisterUchar(&(HwCapEntry->cx_MaxPixDepth)) & 0x7F;
            for (CurrentDepth = DEPTH_NOTHING; CurrentDepth <= Scratch; CurrentDepth++)
                {
                if (VideoPortReadRegisterUchar(&(HwCapEntry->cx_MaxDotClock)) > MaxDotClock[CurrentDepth])
                    {
                    MaxDotClock[CurrentDepth] = VideoPortReadRegisterUchar(&(HwCapEntry->cx_MaxDotClock));
                    VideoDebugPrint((DEBUG_DETAIL, "Increased MaxDotClock[%d] to %d MHz\n", CurrentDepth, MaxDotClock[CurrentDepth]));
                    }
                }
            }   /* end while (more entries in hardware capability table) */

        /*
         * On some cards, the BIOS will report in AX=0xA?07 maximum pixel
         * clock rates for pixel depths which AX=0xA?09 byte 0x13 reports
         * as unsupported. Since switching into these modes will produce
         * bizarre displays, we must mark these pixel depths as unavailable.
         */
        switch (AbsMaxDepth)
            {
            case 8:
                VideoDebugPrint((DEBUG_DETAIL, "Forcing cutback to 8BPP maximum\n"));
                MaxDotClock[DEPTH_16BPP] = 0;
                MaxDotClock[DEPTH_24BPP] = 0;
                MaxDotClock[DEPTH_32BPP] = 0;
                break;

            case 16:
                VideoDebugPrint((DEBUG_DETAIL, "Forcing cutback to 16BPP maximum\n"));
                MaxDotClock[DEPTH_24BPP] = 0;
                MaxDotClock[DEPTH_32BPP] = 0;
                break;

            case 24:
                VideoDebugPrint((DEBUG_DETAIL, "Forcing cutback to 24BPP maximum\n"));
                MaxDotClock[DEPTH_32BPP] = 0;
                break;

            case 32:
            default:
                VideoDebugPrint((DEBUG_DETAIL, "No forced cutback needed\n"));
                break;
            }

        /*
         * Our new source stream display driver needs a linear aperture
         * in order to handle 24BPP. Since the display driver doesn't
         * have access to the aperture information when it is deciding
         * which modes to pass on to the display applet, it can't make
         * the decision to reject 24BPP modes for cards with only a
         * VGA aperture. This decision must therefore be made in the
         * miniport, so in a paged aperture configuration there are no
         * 24BPP modes for the display driver to accept or reject.
         *
         * On the DEC Alpha, we treat machines using sparse space as
         * a synthetic no-aperture case even if the LFB is enabled,
         * so we must lock out 24BPP on these machines as well.
         */
        if (Query->q_aperture_cfg == 0)
            {
            VideoDebugPrint((DEBUG_DETAIL, "24BPP not available because we don't have a linear aperture\n"));
            MaxDotClock[DEPTH_24BPP] = 0;
            }

#if defined(ALPHA)
        if (DenseOnAlpha(Query) == FALSE)
            {
            VideoDebugPrint((DEBUG_DETAIL, "24BPP not available in sparse space on Alpha\n"));
            MaxDotClock[DEPTH_24BPP] = 0;
            }
#endif

        VideoDebugPrint((DEBUG_NORMAL, "Horizontal resolution = %d\n", CXHorRes[CurrentRes]));
        VideoDebugPrint((DEBUG_NORMAL, "Maximum dot clock for 4BPP = %d MHz\n", MaxDotClock[DEPTH_4BPP]));
        VideoDebugPrint((DEBUG_NORMAL, "Maximum dot clock for 8BPP = %d MHz\n", MaxDotClock[DEPTH_8BPP]));
        VideoDebugPrint((DEBUG_NORMAL, "Maximum dot clock for 16BPP = %d MHz\n", MaxDotClock[DEPTH_16BPP]));
        VideoDebugPrint((DEBUG_NORMAL, "Maximum dot clock for 24BPP = %d MHz\n", MaxDotClock[DEPTH_24BPP]));
        VideoDebugPrint((DEBUG_NORMAL, "Maximum dot clock for 32BPP = %d MHz\n", MaxDotClock[DEPTH_32BPP]));

        /*
         * Search through the list of installed mode tables to see if there
         * are any for the current resolution. We need this information
         * in order to decide whether or not to make the hardware default
         * refresh rate available for this resolution (BIOS behaviour is
         * undefined when trying to load CRT parameters for the hardware
         * default refresh rate at a given resolution if that resolution
         * is not among the installed modes).
         */
        ModeInstalled = FALSE;
        for (Count = 1; Count <= VideoPortReadRegisterUchar(&(CxQuery->cx_number_modes)); Count++)
            {
            /*
             * If the current mode table matches the resolution we are
             * looking for, then we know that there is a hardware
             * default refresh rate available for this resolution.
             * Since we only need to find one such mode table, there
             * is no need to search the remainder of the mode tables.
             */
            if (VideoPortReadRegisterUshort(&(CxModeTable->cx_x_size)) == CXHorRes[CurrentRes])
                {
                ModeInstalled = TRUE;
                VideoDebugPrint((DEBUG_DETAIL, "%d table found\n", CXHorRes[CurrentRes]));
                break;
                }

            ((PUCHAR)CxModeTable) += VideoPortReadRegisterUchar(&(CxQuery->cx_mode_size));
            }

        /*
         * The MaxDotClock[] entry for any pixel depth will
         * contain either the maximum pixel clock for that
         * pixel depth at the current resolution, or zero
         * if that pixel depth is not supported at the
         * current resolution. For any resolution, the
         * maximum supported pixel clock rate will either
         * remain the same or decrease as the pixel depth
         * increases, but it will never increase.
         *
         * The pixel clock rate for 4BPP (lowest pixel depth
         * we support) will only be zero if the card does not
         * support the current resolution. If this is the case,
         * skip to the next resolution.
         */
        if (MaxDotClock[DEPTH_4BPP]  == 0)
            {
            VideoDebugPrint((DEBUG_NORMAL, "Current resolution not supported on this card - skipping to next.\n"));
            continue;
            }

        Query->q_status_flags |= CXStatusFlags[CurrentRes];
        VideoPortZeroMemory(&ThisRes, sizeof(struct st_mode_table));

        /*
         * Replace the "canned" mode tables with the Mach 64 versions
         * in cases where the Mach 64 needs CRT parameters the
         * Mach 8 and Mach 32 can't handle.
         */
        SetMach64Tables();

        /*
         * Set up the ranges of "canned" mode tables to use for each
         * resolution. Initially assume that all tables at the desired
         * resolution are available, later we will cut out those that
         * are unavailable because the DAC and/or memory type doesn't
         * support them at specific resolutions.
         */
        switch (CurrentRes)
            {
            case RES_640:
                StartIndex = B640F60;
                EndIndex = B640F100;
                ThisRes.m_x_size = 640;
                ThisRes.m_y_size = 480;
                break;

            case RES_800:
                StartIndex = B800F89;
                EndIndex = B800F100;
                ThisRes.m_x_size = 800;
                ThisRes.m_y_size = 600;
                break;

            case RES_1024:
                StartIndex = B1024F87;
                EndIndex = B1024F100;
                ThisRes.m_x_size = 1024;
                ThisRes.m_y_size = 768;
                break;

            case RES_1152:
                StartIndex = B1152F87;
                EndIndex = B1152F80;
                ThisRes.m_x_size = 1152;
                ThisRes.m_y_size = 864;
                break;

            case RES_1280:
                StartIndex = B1280F87;
                EndIndex = B1280F75;
                ThisRes.m_x_size = 1280;
                ThisRes.m_y_size = 1024;
                break;

            case RES_1600:
                StartIndex = B1600F60;
                EndIndex = B1600F76;
                ThisRes.m_x_size = 1600;
                ThisRes.m_y_size = 1200;
                break;
            }

        /*
         * Use a screen pitch equal to the horizontal resolution for
         * linear aperture, and of 1024 or the horizontal resolution
         * (whichever is higher) for VGA aperture.
         */
        ThisRes.m_screen_pitch = ThisRes.m_x_size;
#if !defined (SPLIT_RASTERS)
        if (((Query->q_aperture_cfg & BIOS_AP_SIZEMASK) == 0) &&
            (ThisRes.m_x_size < 1024))
            ThisRes.m_screen_pitch = 1024;

        /*
         * Temporary until split rasters implemented.
         */
        if (((Query->q_aperture_cfg & BIOS_AP_SIZEMASK) == 0) &&
            (ThisRes.m_x_size > 1024))
            ThisRes.m_screen_pitch = 2048;
#endif

        /*
         * Get the parameters we need out of the table returned
         * by the BIOS call.
         */
        ThisRes.m_h_total = VideoPortReadRegisterUchar(&(CxModeTable->cx_crtc_h_total));
        ThisRes.m_h_disp = VideoPortReadRegisterUchar(&(CxModeTable->cx_crtc_h_disp));
        ThisRes.m_h_sync_strt = VideoPortReadRegisterUchar(&(CxModeTable->cx_crtc_h_sync_strt));
        ThisRes.m_h_sync_wid = VideoPortReadRegisterUchar(&(CxModeTable->cx_crtc_h_sync_wid));
        ThisRes.m_v_total = VideoPortReadRegisterUshort(&(CxModeTable->cx_crtc_v_total));
        ThisRes.m_v_disp = VideoPortReadRegisterUshort(&(CxModeTable->cx_crtc_v_disp));
        ThisRes.m_v_sync_strt = VideoPortReadRegisterUshort(&(CxModeTable->cx_crtc_v_sync_strt));
        ThisRes.m_v_sync_wid = VideoPortReadRegisterUchar(&(CxModeTable->cx_crtc_v_sync_wid));
        ThisRes.m_h_overscan = VideoPortReadRegisterUshort(&(CxModeTable->cx_h_overscan));
        ThisRes.m_v_overscan = VideoPortReadRegisterUshort(&(CxModeTable->cx_v_overscan));
        ThisRes.m_overscan_8b = VideoPortReadRegisterUshort(&(CxModeTable->cx_overscan_8b));
        ThisRes.m_overscan_gr = VideoPortReadRegisterUshort(&(CxModeTable->cx_overscan_gr));
        ThisRes.m_clock_select = VideoPortReadRegisterUchar(&(CxModeTable->cx_clock_cntl));
        ThisRes.control = VideoPortReadRegisterUshort(&(CxModeTable->cx_crtc_gen_cntl));
        ThisRes.Refresh = DEFAULT_REFRESH;

        /*
         * For each supported pixel depth at the given resolution,
         * copy the mode table, fill in the colour depth field,
         * and increment the counter for the number of supported modes.
         * Test 4BPP before 8BPP so the mode tables will appear in
         * increasing order of pixel depth.
         *
         * If filling in the mode table would overflow the space available
         * for mode tables, return the appropriate error code instead
         * of continuing.
         *
         * All the DACs we support can handle 8 BPP at all the
         * resolutions they support if there is enough memory on
         * the card, and all but the 68860, IBM514, and TVP3026
         * can support 4BPP under the same circumstances. If a
         * DAC doesn't support a given resolution (e.g. 1600x1200),
         * the MaxDotClock[] array will be zero for the resolution,
         * and the INSTALL program won't set up any mode tables for
         * that resolution. This will result in a kick-out at an
         * earlier point in the code (when we found that 4BPP has a
         * maximum pixel clock rate of zero), so we will never reach
         * this point on resolutions the DAC doesn't support.
         *
         * 4BPP is only needed for resolutions where we don't have
         * enough video memory to support 8BPP. At Microsoft's request,
         * we must lock out 4BPP for resolutions where we can support
         * 8BPP. We only support 4BPP on 1M cards since a BIOS quirk
         * on some cards requires that we set the memory size to 1M
         * when we switch into 4BPP. The DACs where we lock out 4BPP
         * unconditionally are only found on VRAM cards, where the
         * minimum configuration is 2M.
         */
        NumPixels = ThisRes.m_screen_pitch * ThisRes.m_y_size;
        if((NumPixels < ONE_MEG*2) &&
            ((MemAvail == ONE_MEG) && (NumPixels >= ONE_MEG)) &&
            (MaxDotClock[DEPTH_4BPP] > 0) &&
            (Query->q_DAC_type != DAC_ATI_68860) &&
            (Query->q_DAC_type != DAC_TVP3026) &&
            (Query->q_DAC_type != DAC_IBM514))
            {
            if (ModeInstalled)
                {
                if (Query->q_number_modes >= MaxModes)
                    {
                    VideoDebugPrint((DEBUG_ERROR, "Exceeded maximum allowable number of modes - aborting query\n"));
                    CleanupQuery(HwCapBuffer, HwSupBuffer, MappedBuffer, BufferSeg, SavedVgaBuffer);
                    return ERROR_INSUFFICIENT_BUFFER;
                    }
                VideoPortMoveMemory(pmode, &ThisRes, sizeof(struct st_mode_table));
                pmode->m_pixel_depth = 4;
                pmode++;    /* ptr to next mode table */
                Query->q_number_modes++;
                }

            /*
             * Add "canned" mode tables after verifying that the
             * worst case (all possible "canned" modes can actually
             * be loaded) won't exceed the maximum possible number
             * of mode tables.
             */

            if ((FreeTables = MaxModes - Query->q_number_modes) <= 0)
                {
                VideoDebugPrint((DEBUG_ERROR, "Exceeded maximum allowable number of modes - aborting query\n"));
                CleanupQuery(HwCapBuffer, HwSupBuffer, MappedBuffer, BufferSeg, SavedVgaBuffer);
                return ERROR_INSUFFICIENT_BUFFER;
                }
            Query->q_number_modes += SetFixedModes(StartIndex,
                                                   EndIndex,
                                                   CLOCK_SINGLE,
                                                   4,
                                                   ThisRes.m_screen_pitch,
                                                   FreeTables,
                                                   (ULONG)(MaxDotClock[DEPTH_4BPP] * 1000000L),
                                                   &pmode);
            }
        if ((NumPixels < MemAvail) &&
            (MaxDotClock[DEPTH_8BPP] > 0))
            {
            /*
             * On some Mach 64 cards (depends on ASIC revision, RAM type,
             * and DAC type), screen tearing will occur in 8BPP if the
             * pitch is not a multiple of 64 pixels (800x600 is the only
             * resolution where this is possible).
             *
             * If the pitch has already been boosted to 1024 (VGA aperture
             * with no split rasters), it is already a multiple of 64, so
             * no change is needed.
             */
            if (ThisRes.m_screen_pitch == 800)
                ThisRes.m_screen_pitch = 832;

            if (ModeInstalled)
                {
                if (Query->q_number_modes >= MaxModes)
                    {
                    VideoDebugPrint((DEBUG_ERROR, "Exceeded maximum allowable number of modes - aborting query\n"));
                    CleanupQuery(HwCapBuffer, HwSupBuffer, MappedBuffer, BufferSeg, SavedVgaBuffer);
                    return ERROR_INSUFFICIENT_BUFFER;
                    }
                VideoPortMoveMemory(pmode, &ThisRes, sizeof(struct st_mode_table));
                pmode->m_pixel_depth = 8;
                pmode++;    /* ptr to next mode table */
                Query->q_number_modes++;
                }

            /*
             * Add "canned" mode tables after verifying that the
             * worst case (all possible "canned" modes can actually
             * be loaded) won't exceed the maximum possible number
             * of mode tables.
             */
            if ((FreeTables = MaxModes - Query->q_number_modes) <= 0)
                {
                VideoDebugPrint((DEBUG_ERROR, "Exceeded maximum allowable number of modes - aborting query\n"));
                CleanupQuery(HwCapBuffer, HwSupBuffer, MappedBuffer, BufferSeg, SavedVgaBuffer);
                return ERROR_INSUFFICIENT_BUFFER;
                }
            Query->q_number_modes += SetFixedModes(StartIndex,
                                                   EndIndex,
                                                   CLOCK_SINGLE,
                                                   8,
                                                   ThisRes.m_screen_pitch,
                                                   FreeTables,
                                                   (ULONG)(MaxDotClock[DEPTH_8BPP] * 1000000L),
                                                   &pmode);
            /*
             * If we have boosted the screen pitch to avoid tearing,
             * cut it back to normal, since the boost is only needed
             * in 8BPP. We will only have a pitch of 832 in 800x600
             * with the pitch boost in place.
             */
            if (ThisRes.m_screen_pitch == 832)
                ThisRes.m_screen_pitch = 800;
            }

        if ((NumPixels*2 < MemAvail) &&
            (MaxDotClock[DEPTH_16BPP] > 0))
            {
            if (ModeInstalled)
                {
                if (Query->q_number_modes >= MaxModes)
                    {
                    VideoDebugPrint((DEBUG_ERROR, "Exceeded maximum allowable number of modes - aborting query\n"));
                    CleanupQuery(HwCapBuffer, HwSupBuffer, MappedBuffer, BufferSeg, SavedVgaBuffer);
                    return ERROR_INSUFFICIENT_BUFFER;
                    }
                VideoPortMoveMemory(pmode, &ThisRes, sizeof(struct st_mode_table));
                pmode->m_pixel_depth = 16;
                pmode++;    /* ptr to next mode table */
                Query->q_number_modes++;
                }

            /*
             * Add "canned" mode tables after verifying that the
             * worst case (all possible "canned" modes can actually
             * be loaded) won't exceed the maximum possible number
             * of mode tables.
             */

            if ((FreeTables = MaxModes - Query->q_number_modes) <= 0)
                {
                VideoDebugPrint((DEBUG_ERROR, "Exceeded maximum allowable number of modes - aborting query\n"));
                CleanupQuery(HwCapBuffer, HwSupBuffer, MappedBuffer, BufferSeg, SavedVgaBuffer);
                return ERROR_INSUFFICIENT_BUFFER;
                }
            Query->q_number_modes += SetFixedModes(StartIndex,
                                                   EndIndex,
                                                   CLOCK_SINGLE,
                                                   16,
                                                   ThisRes.m_screen_pitch,
                                                   FreeTables,
                                                   (ULONG)(MaxDotClock[DEPTH_16BPP] * 1000000L),
                                                   &pmode);
            }

        if ((NumPixels*3 < MemAvail) &&
            (MaxDotClock[DEPTH_24BPP] > 0))
            {
            if (ModeInstalled)
                {
                if (Query->q_number_modes >= MaxModes)
                    {
                    VideoDebugPrint((DEBUG_ERROR, "Exceeded maximum allowable number of modes - aborting query\n"));
                    CleanupQuery(HwCapBuffer, HwSupBuffer, MappedBuffer, BufferSeg, SavedVgaBuffer);
                    return ERROR_INSUFFICIENT_BUFFER;
                    }
                VideoPortMoveMemory(pmode, &ThisRes, sizeof(struct st_mode_table));
                pmode->m_pixel_depth = 24;
                pmode++;    /* ptr to next mode table */
                Query->q_number_modes++;
                }

            /*
             * Add "canned" mode tables after verifying that the
             * worst case (all possible "canned" modes can actually
             * be loaded) won't exceed the maximum possible number
             * of mode tables.
             */
            if ((FreeTables = MaxModes - Query->q_number_modes) <= 0)
                {
                VideoDebugPrint((DEBUG_ERROR, "Exceeded maximum allowable number of modes - aborting query\n"));
                CleanupQuery(HwCapBuffer, HwSupBuffer, MappedBuffer, BufferSeg, SavedVgaBuffer);
                return ERROR_INSUFFICIENT_BUFFER;
                }

            Query->q_number_modes += SetFixedModes(StartIndex,
                                                   EndIndex,
                                                   CLOCK_SINGLE,
                                                   24,
                                                   ThisRes.m_screen_pitch,
                                                   FreeTables,
                                                   (ULONG)(MaxDotClock[DEPTH_24BPP] * 1000000L),
                                                   &pmode);
            }

        if ((NumPixels*4 < MemAvail) &&
            (MaxDotClock[DEPTH_32BPP] > 0))
            {
            if (ModeInstalled)
                {
                if (Query->q_number_modes > MaxModes)
                    {
                    VideoDebugPrint((DEBUG_ERROR, "Exceeded maximum allowable number of modes - aborting query\n"));
                    CleanupQuery(HwCapBuffer, HwSupBuffer, MappedBuffer, BufferSeg, SavedVgaBuffer);
                    return ERROR_INSUFFICIENT_BUFFER;
                    }
                VideoPortMoveMemory(pmode, &ThisRes, sizeof(struct st_mode_table));
                pmode->m_pixel_depth = 32;
                pmode++;    /* ptr to next mode table */
                Query->q_number_modes++;
                }

            /*
             * Add "canned" mode tables after verifying that the
             * worst case (all possible "canned" modes can actually
             * be loaded) won't exceed the maximum possible number
             * of mode tables.
             */

            if ((FreeTables = MaxModes - Query->q_number_modes) <= 0)
                {
                VideoDebugPrint((DEBUG_ERROR, "Exceeded maximum allowable number of modes - aborting query\n"));
                CleanupQuery(HwCapBuffer, HwSupBuffer, MappedBuffer, BufferSeg, SavedVgaBuffer);
                return ERROR_INSUFFICIENT_BUFFER;
                }
            Query->q_number_modes += SetFixedModes(StartIndex,
                                                   EndIndex,
                                                   CLOCK_SINGLE,
                                                   32,
                                                   ThisRes.m_screen_pitch,
                                                   FreeTables,
                                                   (ULONG)(MaxDotClock[DEPTH_32BPP] * 1000000L),
                                                   &pmode);
            }
        }   /* end for */

    Query->q_sizeof_struct = Query->q_number_modes * sizeof(struct st_mode_table) + sizeof(struct query_structure);
    CleanupQuery(HwCapBuffer, HwSupBuffer, MappedBuffer, BufferSeg, SavedVgaBuffer);
    return NO_ERROR;

}   /* QueryMach64() */



/***************************************************************************
 *
 * BOOL BlockWriteAvail_cx(Query);
 *
 * struct query_structure *Query;   Query information for the card
 *
 * DESCRIPTION:
 *  Test to see whether block write mode is available. This function
 *  assumes that the card has been set to an accelerated mode.
 *
 * RETURN VALUE:
 *  TRUE if this mode is available
 *  FALSE if it is not available
 *
 * GLOBALS CHANGED:
 *  None
 *
 * CALLED BY:
 *  IOCTL_VIDEO_SET_CURRENT_MODE packet of ATIMPStartIO()
 *
 * AUTHOR:
 *  Robert Wolff
 *
 * CHANGE HISTORY:
 *
 * TEST HISTORY:
 *
 ***************************************************************************/

#define BLOCK_WRITE_LENGTH 120

BOOL BlockWriteAvail_cx(struct query_structure *Query)
{
    BOOL RetVal = TRUE;
    ULONG ColourMask;           /* Mask off unneeded bits of Colour */
    ULONG Colour;               /* Colour to use in testing */
    USHORT Width, excess = 8;   /* Width of test block */
    USHORT Column;              /* Column being checked */
    ULONG ScreenPitch;          /* Pitch in units of 8 pixels */
    ULONG PixelDepth;           /* Colour depth of screen */
    ULONG HorScissors;          /* Horizontal scissor values */
    PULONG FrameAddress;        /* Pointer to base of LFB */
    PULONG ReadPointer;         /* Used in reading test block */
    ULONG DstOffPitch;          /* Saved contents of DST_OFF_PITCH register */

#if defined (PPC)
    /*
     * Block write does not work properly on the power PC. Under some
     * circumstances, we will detect that the card is capable of using
     * block write mode, but it will hang the machine when used for
     * a large block (our test is for a small block).
     */
    VideoDebugPrint((DEBUG_DETAIL, "Can't do block write on a PPC\n"));
    return FALSE;
#else

    /*
     * Our block write test involves an engine draw followed by
     * a read back through the linear framebuffer. If the linear
     * framebuffer is unavailable, assume that we can't do block
     * write, since all our cards are able to function without
     * block write.
     */
    if (!(Query->q_aperture_cfg))
        {
        VideoDebugPrint((DEBUG_DETAIL, "LFB unavailable, can't do block write check\n"));
        return FALSE;
        }

    /*
     * Mach 64 ASICs prior to revision D have a hardware bug that does
     * not allow transparent block writes (special handling is required
     * that in some cases can cut performance).
     */
    if ((INPD(CONFIG_CHIP_ID) & CONFIG_CHIP_ID_RevMask) < CONFIG_CHIP_ID_RevD)
        {
        VideoDebugPrint((DEBUG_DETAIL, "ASIC/memory combination doesn't allow block write\n"));
        return FALSE;
        }

    /*
     * Block write is only available on "special VRAM" cards.
     */
    if (Query->q_memory_type != VMEM_VRAM_256Kx4_SPLIT512
    &&  Query->q_memory_type != VMEM_VRAM_256Kx16_SPLIT256)
        {
        VideoDebugPrint((DEBUG_DETAIL, "*** No block write - wrong RAM type\n" ));
        return FALSE;
        }

    /*
     * Special case: block write doesn't work properly on the
     * GX rev. E with IBM RAM.
     */
    if ((INPD(CONFIG_CHIP_ID) == (CONFIG_CHIP_ID_GXRevE)) &&
        (Query->q_memory_type == VMEM_VRAM_256Kx16_SPLIT256))
        {
        VideoDebugPrint((DEBUG_DETAIL, "*** No block write - GX/E with IBM RAM\n"));
        return FALSE;
        }

    /*
     * Use a 480 byte test block. This size will fit on a single line
     * even at the lowest resolution (640x480) and pixel depth supported
     * by the display driver (8BPP), and is divisible by all the supported
     * pixel depths. Get the depth-specific values for the pixel depth we
     * are using.
     *
     * True 24BPP acceleration is not available, so 24BPP is actually
     * handled as an 8BPP engine mode with a width 3 times the display
     * width.
     */
    switch(Query->q_pix_depth)
        {
        case 4:
            ColourMask = 0x0000000F;
            Width = BLOCK_WRITE_LENGTH*8;
            ScreenPitch = Query->q_screen_pitch / 8;
            PixelDepth = BIOS_DEPTH_4BPP;
            HorScissors = (Query->q_desire_x) << 16;
            break;

        case 8:
            ColourMask = 0x000000FF;
            Width = BLOCK_WRITE_LENGTH*4;
            ScreenPitch = Query->q_screen_pitch / 8;
            PixelDepth = BIOS_DEPTH_8BPP;
            HorScissors = (Query->q_desire_x) << 16;
            break;

        case 16:
            ColourMask = 0x0000FFFF;
            Width = BLOCK_WRITE_LENGTH*2;
            ScreenPitch = Query->q_screen_pitch / 8;
            PixelDepth = BIOS_DEPTH_16BPP_565;
            HorScissors = (Query->q_desire_x) << 16;
            break;

        case 24:
            ColourMask = 0x000000FF;
            Width = BLOCK_WRITE_LENGTH*4;
            ScreenPitch = (Query->q_screen_pitch * 3) / 8;
            PixelDepth = BIOS_DEPTH_8BPP;
            /*
             * Horizontal scissors are only valid in the range
             * -4096 to +4095. If the horizontal resolution
             * is high enough to put the scissor outside this
             * range, clamp the scissors to the maximum
             * permitted value.
             */
            HorScissors = Query->q_desire_x * 3;
            if (HorScissors > 4095)
                HorScissors = 4095;
            HorScissors <<= 16;
            break;

        case 32:
            ColourMask = 0xFFFFFFFF;
            Width = BLOCK_WRITE_LENGTH;
            ScreenPitch = Query->q_screen_pitch / 8;
            PixelDepth = BIOS_DEPTH_32BPP;
            HorScissors = (Query->q_desire_x) << 16;
            break;

        default:
            return FALSE;   /* Unsupported pixel depths */
        }

    /*
     * Get a pointer to the beginning of the framebuffer. If we
     * can't do this, assume block write is unavailable.
     */
    if ((FrameAddress = MapFramebuffer(phwDeviceExtension->PhysicalFrameAddress.LowPart,
                                       phwDeviceExtension->FrameLength)) == (PVOID) 0)
        {
        VideoDebugPrint((DEBUG_ERROR, "Couldn't map LFB - assuming no block write\n"));
        return FALSE;
        }


    /*
     * To use block write mode, the pixel widths for destination,
     * source, and host must be the same.
     */
    PixelDepth |= ((PixelDepth << 8) | (PixelDepth << 16));

    /*
     * Save the contents of the DST_OFF_PITCH register.
     */
    DstOffPitch = INPD(DST_OFF_PITCH);

    /*
     * Clear the block we will be testing.
     */
    CheckFIFOSpace_cx(ELEVEN_WORDS);
    OUTPD(DP_WRITE_MASK, 0xFFFFFFFF);
    OUTPD(DST_OFF_PITCH, ScreenPitch << 22);
    OUTPD(DST_CNTL, (DST_CNTL_XDir | DST_CNTL_YDir));
    OUTPD(DP_PIX_WIDTH, PixelDepth);
    OUTPD(DP_SRC, (DP_FRGD_SRC_FG | DP_BKGD_SRC_BG | DP_MONO_SRC_ONE));
    OUTPD(DP_MIX, ((MIX_FN_PAINT << 16) | MIX_FN_PAINT));
    OUTPD(DP_FRGD_CLR, 0);
    OUTPD(SC_LEFT_RIGHT, HorScissors);
    OUTPD(SC_TOP_BOTTOM, (Query->q_desire_y) << 16);
    OUTPD(DST_Y_X, 0);
    OUTPD(DST_HEIGHT_WIDTH, ((Width+excess) << 16) | 1);
    WaitForIdle_cx();

    /*
     * To test block write mode, try painting each of the alternating bit
     * patterns, then read the block back. If there is at least one
     * mismatch, then block write is not supported.
     */
    for (Colour = 0x55555555; Colour <= 0xAAAAAAAA; Colour += 0x55555555)
        {
        /*
         * Paint the block.
         */
        CheckFIFOSpace_cx(FIVE_WORDS);
        OUTPD(GEN_TEST_CNTL, (INPD(GEN_TEST_CNTL) | GEN_TEST_CNTL_BlkWrtEna));
        OUTPD(DP_MIX, ((MIX_FN_PAINT << 16) | MIX_FN_LEAVE_ALONE));
        OUTPD(DP_FRGD_CLR, (Colour & ColourMask));
        OUTPD(DST_Y_X, 0);
        OUTPD(DST_HEIGHT_WIDTH, (Width << 16) | 1);
        WaitForIdle_cx();

        /*
         * Check to see if the block was written properly. Mach 64 cards
         * can't do a screen to host blit, but we can read the test block
         * back through the aperture.
         */
        ReadPointer = FrameAddress;
        for (Column = 0; Column < BLOCK_WRITE_LENGTH; Column++)
            {
            if (VideoPortReadRegisterUlong(ReadPointer + Column) != Colour)
                {
                VideoDebugPrint((DEBUG_NORMAL, "*** No block write - bad pattern\n" ));
                RetVal = FALSE;
                break;
                }
            }

        /*
         * Check the next dword beyond the block.
         */
        if (VideoPortReadRegisterUlong(ReadPointer + BLOCK_WRITE_LENGTH) != 0)
            {
            VideoDebugPrint((DEBUG_NORMAL, "*** No block write - corruption\n" ));
            RetVal = FALSE;
            }
        }

    /*
     * If block write is unavailable, turn off the block write bit.
     */
    if (RetVal == FALSE)
        OUTPD(GEN_TEST_CNTL, (INPD(GEN_TEST_CNTL) & ~GEN_TEST_CNTL_BlkWrtEna));

    /*
     * Restore the contents of the DST_OFF_PITCH register.
     */
    OUTPD(DST_OFF_PITCH, DstOffPitch);

    /*
     * Free the pointer to the start of the framebuffer.
     */
    VideoPortFreeDeviceBase(phwDeviceExtension, FrameAddress);

    return RetVal;

#endif  /* Not Power PC */

}   /* BlockWriteAvail_cx() */



/***************************************************************************
 *
 * BOOL TextBanding_cx(Query);
 *
 * struct query_structure *Query;   Query information for the card
 *
 * DESCRIPTION:
 *  Test to see whether the current mode is susceptible to text
 *  banding. This function assumes that the card has been set to
 *  an accelerated mode.
 *
 * RETURN VALUE:
 *  TRUE if this mode is susceptible to text banding
 *  FALSE if it is immune to text banding
 *
 * GLOBALS CHANGED:
 *  None
 *
 * CALLED BY:
 *  IOCTL_VIDEO_ATI_GET_MODE_INFORMATION packet of ATIMPStartIO()
 *
 * AUTHOR:
 *  Robert Wolff
 *
 * CHANGE HISTORY:
 *
 * TEST HISTORY:
 *
 ***************************************************************************/

BOOL TextBanding_cx(struct query_structure *Query)
{
    DWORD ConfigChipId;

    ConfigChipId = INPD(CONFIG_CHIP_ID);

    /*
     * Text banding only occurs in 24BPP with the Mach 64
     * GX rev. E & rev. F ASICs.
     */
    if ((Query->q_pix_depth == 24) &&
        ((ConfigChipId == (CONFIG_CHIP_ID_GXRevE)) || (ConfigChipId == (CONFIG_CHIP_ID_GXRevF))))
        {
        return TRUE;
        }
    else
        {
        return FALSE;
        }

}   /* TextBanding_cx() */



/***************************************************************************
 *
 * PWSTR IdentifyMach64Asic(Query, AsicStringLength);
 *
 * struct query_structure *Query;   Query information for the card
 * PULONG AsicStringLength;         Length of ASIC identification string
 *
 * DESCRIPTION:
 *  Generate a string describing which Mach 64 ASIC is in use on
 *  this particular card.
 *
 * RETURN VALUE:
 *  Pointer to a string identifying which Mach 64 ASIC is present. The
 *  length of this string is returned in *AsicStringLength.
 *
 * GLOBALS CHANGED:
 *  None
 *
 * CALLED BY:
 *  FillInRegistry()
 *
 * AUTHOR:
 *  Robert Wolff
 *
 * CHANGE HISTORY:
 *
 * TEST HISTORY:
 *
 ***************************************************************************/

PWSTR IdentifyMach64Asic(struct query_structure *Query, PULONG AsicStringLength)
{
    PWSTR ChipString;       /* Identification string for the ASIC in use */
    DWORD ConfigChipId;     /* Contents of chip identification register */

    ConfigChipId = INPD(CONFIG_CHIP_ID);
    if (Query->q_DAC_type == DAC_INTERNAL_CT)
        {
        ChipString = L"Mach 64 CT";
        *AsicStringLength = sizeof(L"Mach 64 CT");
        }
    else if (Query->q_DAC_type == DAC_INTERNAL_GT)
        {
        ChipString        = L"ATI 3D RAGE (GT-A)";
        *AsicStringLength = sizeof(L"ATI 3D RAGE (GT-A)");
        }
    else if (Query->q_DAC_type == DAC_INTERNAL_VT)
        {    switch (ConfigChipId & CONFIG_CHIP_ID_RevMask)
            {
                case ASIC_ID_SGS_VT_A4:

                    ChipString        = L"ATI mach64 (SGS VT-A4)";
                    *AsicStringLength = sizeof(L"ATI mach64 (SGS VT-A4)");
                    break;

                case ASIC_ID_NEC_VT_A4:

                    ChipString        = L"ATI mach64 (NEC VT-A4)";
                    *AsicStringLength = sizeof(L"ATI mach64 (NEC VT-A4)");
                    break;

                case ASIC_ID_NEC_VT_A3:

                    ChipString        = L"ATI mach64 (NEC VT-A3)";
                    *AsicStringLength = sizeof(L"ATI mach64 (NEC VT-A3)");
                    break;

                default:

        ChipString        = L"ATI 3D RAGE (VT-A) Internal DAC";
        *AsicStringLength = sizeof(L"ATI 3D RAGE (VT-A) Internal DAC");
                    //ChipString        = L"ATI mach64 (VT-A)";
                    //*AsicStringLength = sizeof(L"ATI mach64 (VT-A)");
                    break;
            }
        }
    else if ((ConfigChipId & CONFIG_CHIP_ID_TypeMask) == CONFIG_CHIP_ID_TypeCX)
        {
        ChipString = L"Mach 64 CX";
        *AsicStringLength = sizeof(L"Mach 64 CX");
        }
    else if ((ConfigChipId & CONFIG_CHIP_ID_TypeMask) == CONFIG_CHIP_ID_TypeGX)
        {
        switch(ConfigChipId & CONFIG_CHIP_ID_RevMask)
            {
            case CONFIG_CHIP_ID_RevC:
                ChipString = L"Mach 64 GX Rev. C";
                *AsicStringLength = sizeof(L"Mach 64 GX Rev. C");
                break;

            case CONFIG_CHIP_ID_RevD:
                ChipString = L"Mach 64 GX Rev. D";
                *AsicStringLength = sizeof(L"Mach 64 GX Rev. D");
                break;

            case CONFIG_CHIP_ID_RevE:
                ChipString = L"Mach 64 GX Rev. E";
                *AsicStringLength = sizeof(L"Mach 64 GX Rev. E");
                break;

            case CONFIG_CHIP_ID_RevF:
                ChipString = L"Mach 64 GX Rev. F";
                *AsicStringLength = sizeof(L"Mach 64 GX Rev. F");
                break;

            default:
                ChipString = L"Mach 64 GX";
                *AsicStringLength = sizeof(L"Mach 64 GX");
                break;
            }
        }
    else
        {
        ChipString = L"Miscellaneous Mach 64";
        *AsicStringLength = sizeof(L"Miscelaneous Mach 64");
        }

    return ChipString;

}   /* IdentifyMach64Asic() */



/***************************************************************************
 *
 * void CleanupQuery(CapBuffer, SupBuffer, MappedBuffer, BufferSeg, SavedScreen);
 *
 * PUCHAR CapBuffer;        Pointer to the main capabilities table
 *                          for the card
 * PUCHAR SupBuffer;        Pointer to the supplementary capabilities
 *                          table for the card
 * PUCHAR MappedBuffer;     Pointer to the buffer used to query the
 *                          card's capabilities
 * long BufferSeg;          Physical segment associated with MappedBuffer
 * PUCHAR SavedScreen;      Buffer containing data to be restored to the
 *                          memory region used to store the query data.
 *                          Depending on the buffer used, this data may
 *                          or may not need to be restored.
 *
 * DESCRIPTION:
 *  Clean up after we have finished querying the card by restoring
 *  the VGA screen if needed, then freeing the buffers we used to query
 *  the card. We only need to restore the VGA screen if we used the
 *  graphics screen (either write back the information we saved if we
 *  used the existing screen, or switch into text mode if we had to
 *  switch into graphics mode) since we use the offscreen portion of
 *  video memory in cases where we use the text screen.
 *
 *
 * GLOBALS CHANGED:
 *  None
 *
 * CALLED BY:
 *  QueryMach64()
 *
 * AUTHOR:
 *  Robert Wolff
 *
 * CHANGE HISTORY:
 *
 * TEST HISTORY:
 *
 ***************************************************************************/

static void CleanupQuery(PUCHAR CapBuffer, PUCHAR SupBuffer, PUCHAR MappedBuffer, long BufferSeg, PUCHAR SavedScreen)
{
    VIDEO_X86_BIOS_ARGUMENTS Registers; /* Used in VideoPortInt10() calls */
    ULONG CurrentByte;                  /* Buffer byte being restored */
    ULONG BytesToRestore;               /* Number of bytes of graphics screen to restore */

    /*
     * BufferSeg will be 0xBA00 if we stored our query information on
     * the VGA colour text screen, 0xB200 if we used the VGA mono text
     * screen, 0xA000 if we switched into accelerator mode withoug
     * disturbing the VGA controller, and 0xA100 if we forced a VGA
     * graphics mode in order to use the VGA graphics screen.
     *
     * Since we use the offscreen portion of the text screens, which
     * leaves the information displayed on boot undisturbed, it is not
     * only unnecessary but also undesirable (since this would destroy pre-
     * query information printed to the blue screen) to change modes.
     * If we used the existing graphics screen, we merely need to restore
     * the screen contents and the registers we changed. If we changed
     * into a graphics mode, the pre-query information has already been
     * lost when changed modes, but switching back to text mode should
     * allow the user to see information that is printed after our query
     * is complete (not guarranteed, since we will only need to do this
     * on extremely ill-behaved systems, which may have been using something
     * other than a standard VGA text screen as the blue screen).
     */
    if (BufferSeg == 0xA000)
        {
        BytesToRestore = SavedScreen[VGA_SAVE_SIZE_H];
        BytesToRestore <<= 8;
        BytesToRestore += SavedScreen[VGA_SAVE_SIZE];
        VideoDebugPrint((DEBUG_NORMAL, "Restoring %d bytes of the VGA graphics screen\n", BytesToRestore));
        for (CurrentByte = 0; CurrentByte < BytesToRestore; CurrentByte++)
            {
            VideoPortWriteRegisterUchar(&(MappedBuffer[CurrentByte]), SavedScreen[CurrentByte]);
            }
            OUTP(VGA_SEQ_IND, 2);
            OUTP(VGA_SEQ_DATA, SavedScreen[VGA_SAVE_SEQ02]);
            OUTP(VGA_GRAX_IND, 8);
            OUTP(VGA_GRAX_DATA, SavedScreen[VGA_SAVE_GRA08]);
            OUTP(VGA_GRAX_IND, 1);
            OUTP(VGA_GRAX_DATA, SavedScreen[VGA_SAVE_GRA01]);
        }
    else if (BufferSeg == 0xA100)
        {
        VideoDebugPrint((DEBUG_NORMAL, "Switching back to VGA text mode\n"));
        VideoPortZeroMemory(&Registers, sizeof(VIDEO_X86_BIOS_ARGUMENTS));
        Registers.Eax = 3;
        VideoPortInt10(phwDeviceExtension, &Registers);
        }

    /*
     * For each of the three buffers, free it if it exists.
     */
    if (CapBuffer != 0)
        VideoPortFreeDeviceBase(phwDeviceExtension, CapBuffer);

    if (SupBuffer != 0)
        VideoPortFreeDeviceBase(phwDeviceExtension, SupBuffer);

    if (MappedBuffer != 0)
        VideoPortFreeDeviceBase(phwDeviceExtension, MappedBuffer);

    return;

}   /* CleanupQuery() */



#if defined(ALPHA)
/***************************************************************************
 *
 * BOOL DenseOnAlpha(Query);
 *
 * struct query_structure *Query;   Query information for the card
 *
 * DESCRIPTION:
 *  Reports whether or not we can use dense space on this card
 *  in a DEC Alpha.
 *
 * RETURN VALUE:
 *  TRUE if this card can use dense space
 *  FALSE if it can't
 *
 * GLOBALS CHANGED:
 *  None
 *
 * CALLED BY:
 *  Any routine after the query structure is filled in.
 *
 * AUTHOR:
 *  Robert Wolff
 *
 * CHANGE HISTORY:
 *
 * TEST HISTORY:
 *
 ***************************************************************************/

BOOL DenseOnAlpha(struct query_structure *Query)
{
    /*
     * Some older Alpha machines are unable to support dense space,
     * so these must be mapped as sparse. The easiest way to distinguish
     * dense-capable from older machines is that all PCI Alpha systems
     * are dense-capable, so if we are dealing with a PCI card the
     * machine must be capable of handling dense space.
     *
     * Our older cards will generate drawing bugs if GDI handles
     * the screen in dense mode (we made different assumptions from
     * DEC about the PCI interface), so only use dense space for
     * cards which will not have this problem.
     */
    if ((Query->q_bus_type == BUS_PCI) &&
        ((Query->q_DAC_type == DAC_INTERNAL_CT) ||
         (Query->q_DAC_type == DAC_INTERNAL_GT) ||
         (Query->q_DAC_type == DAC_INTERNAL_VT)))
        return TRUE;
    else
        return FALSE;

}   /* DenseOnAlpha() */
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\ati\mini\vdptocrt.h ===
/************************************************************************/
/*                                                                      */
/*                              VDPTOCRT.H                              */
/*                                                                      */
/*  Copyright (c) 1993, ATI Technologies Incorporated.	                */
/************************************************************************/

/**********************       PolyTron RCS Utilities
   
    $Revision:   1.2  $
    $Date:   20 Jul 1995 18:04:36  $
    $Author:   mgrubac  $
    $Log:   S:/source/wnt/ms11/miniport/vcs/vdptocrt.h  $
 * 
 *    Rev 1.2   20 Jul 1995 18:04:36   mgrubac
 * Added support for VDIF files.
 * 
 *    Rev 1.1   31 Aug 1994 16:33:56   RWOLFF
 * Eliminated redundant resolution definitions.
 * 
 *    Rev 1.0   31 Jan 1994 11:51:12   RWOLFF
 * Initial revision.
        
           Rev 1.0   16 Aug 1993 13:31:18   Robert_Wolff
        Initial revision.
        
           Rev 1.0   30 Apr 1993 16:46:06   RWOLFF
        Initial revision.


End of PolyTron RCS section                             *****************/

#ifdef DOC
    VDPTOCRT.H -  Constants and prototypes for the VDPTOCRT.C module.

#endif



// constants

/*
 * Headers for the VDP file sections we are interested in
 */
#define LIMITSSECTION   "[OPERATIONAL_LIMITS]"
#define TIMINGSSECTION  "[PREADJUSTED_TIMINGS]"

/*
 * Frequently-referenced character definitions
 */
#define HORIZTAB    '\x09'  /* Horizontal tab */
#define LINEFEED    '\x0A'  /* Line feed */

extern long normal_to_skip2(long normal_number);

#ifdef INCLUDE_VDPTOCRT
BOOL skip1 = FALSE;
#else
extern BOOL skip1;
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\ati\mini\vdptocrt.c ===
/************************************************************************/
/*                                                                      */
/*                              VDPTOCRT.C                              */
/*                                                                      */
/*  Copyright (c) 1993, ATI Technologies Incorporated.	                */
/************************************************************************/

/**********************       PolyTron RCS Utilities
   
    $Revision:   1.8  $
    $Date:   20 Jul 1995 18:03:48  $
    $Author:   mgrubac  $
    $Log:   S:/source/wnt/ms11/miniport/vcs/vdptocrt.c  $
 * 
 *    Rev 1.8   20 Jul 1995 18:03:48   mgrubac
 * Added support for VDIF files.
 * 
 *    Rev 1.7   02 Jun 1995 14:34:28   RWOLFF
 * Switched from toupper() to UpperCase(), since toupper() led to unresolved
 * externals on some platforms.
 * 
 *    Rev 1.6   08 Mar 1995 11:35:52   ASHANMUG
 * Cleaned-up Warnings
 * 
 *    Rev 1.5   31 Aug 1994 16:33:38   RWOLFF
 * Now gets resolution definitions from ATIMP.H.
 * 
 *    Rev 1.4   19 Aug 1994 17:15:14   RWOLFF
 * Added support for non-standard pixel clock generators.
 * 
 *    Rev 1.3   22 Mar 1994 15:39:12   RWOLFF
 * Workaround for abs() not working properly.
 * 
 *    Rev 1.2   03 Mar 1994 12:38:46   ASHANMUG
 * 
 *    Rev 1.0   31 Jan 1994 11:24:14   RWOLFF
 * Initial revision.
        
           Rev 1.1   05 Nov 1993 13:34:12   RWOLFF
        Fixed "Hang on read from file" bug.
        
           Rev 1.0   16 Aug 1993 13:21:32   Robert_Wolff
        Initial revision.
        
           Rev 1.2   24 Jun 1993 14:30:12   RWOLFF
        Microsoft-originated change: added #include statements for additional
        NT-supplied headers which are needed in build 47x of NT
        
           Rev 1.1   04 May 1993 16:52:14   RWOLFF
        Switched from floating point calculations to long integer calculations due
        to lack of floating point support in Windows NT kernel-mode code.
        
           Rev 1.0   30 Apr 1993 16:45:18   RWOLFF
        Initial revision.


End of PolyTron RCS section                             *****************/

#ifdef DOC
    VDPTOCRT.C - Source file for Windows NT function to return a table of 
                 register values for setting a requested mode. The values
                 are calculated from a raw ASCII list of timing values
                 following the .VDP standard.  The entry point to this module
                 is the function "VdpToCrt" found at the end of the file.

    Written by Bill Hopkins

#endif


// COMPILER INCLUDES
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <errno.h>
#include <math.h>

// NT INCLUDES
#include "dderror.h"
#include "devioctl.h"
#include "miniport.h"

#include "ntddvdeo.h"
#include "video.h"

// APPLICATION INCLUDES
#define INCLUDE_VDPDATA
#define INCLUDE_VDPTOCRT

#include "stdtyp.h"       
#include "amach1.h"
#include "atimp.h"
#include "cvtvga.h"
#include "services.h"
#include "vdptocrt.h"
#include "vdpdata.h"      

/*
 * STATIC VARIABLES
 */
static long MaxHorz,MaxVert;     // used to record maximum resolution
static unsigned long MaxRate;    // used to record maximum vert scan rate


/*
 * FUNCTION PROTYPES
 */


/*
 * Allow miniport to be swapped out when not needed.
 */
#if defined (ALLOC_PRAGMA)
#pragma alloc_text(PAGE_COM, normal_to_skip2)
#endif



/*
 *****************************************************************************
 */
/*
 * long normal_to_skip2(normal_number);
 *
 * long normal_number;  Number to be converted
 *
 * Convert a number into either skip_1_2 or skip_2 representation.
 * Representation chosen depends on global skip1, which is nonzero
 * if skip_1_2 is desired and zero if skip_2 is desired.
 *
 * Returns
 *  Number converted into desired representation
 */
long normal_to_skip2(long normal_number)
{
    if (skip1)
        return (((normal_number << 2) & 0xFFF8) | (normal_number & 0x1));
    else
        return (((normal_number << 1) & 0xFFF8) | (normal_number & 0x3));
}   /* end normal_to_skip2() */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\ati\mini\vdpdata.h ===
/************************************************************************/
/*                                                                      */
/*                              VDPDATA.H                               */
/*                                                                      */
/*  Copyright (c) 1993, ATI Technologies Incorporated.	                */
/************************************************************************/

/**********************       PolyTron RCS Utilities
   
    $Revision:   1.1  $
    $Date:   20 Jul 1995 18:02:24  $
    $Author:   mgrubac  $
    $Log:   S:/source/wnt/ms11/miniport/vcs/vdpdata.h  $
 * 
 *    Rev 1.1   20 Jul 1995 18:02:24   mgrubac
 * Added support for VDIF files.
 * 
 *    Rev 1.0   31 Jan 1994 11:50:04   RWOLFF
 * Initial revision.
        
           Rev 1.1   05 Nov 1993 13:33:58   RWOLFF
        Fixed clock frequency table.
        
           Rev 1.0   16 Aug 1993 13:32:32   Robert_Wolff
        Initial revision.
        
           Rev 1.1   04 May 1993 16:51:10   RWOLFF
        Switched from floating point to long integers due to lack of floating point
        support in Windows NT kernel-mode code.
        
           Rev 1.0   30 Apr 1993 16:47:18   RWOLFF
        Initial revision.


End of PolyTron RCS section                             *****************/

#ifdef DOC
    VDPDATA.H -  Definitions and structures used internally by VDPTOCRT.C.

#endif



/*
 * Sync polarities. INTERNAL_ERROR is an error code for functions
 * which have 0 as a legitimate return (e.g. GetPolarity). Functions
 * which do not have zero as a legitimate return value should follow
 * the "Zero = failure, Nonzero = success" convention.
 */
#define POSITIVE        0
#define NEGATIVE        1
#define INTERNAL_ERROR -1

// GENERAL CONSTANTS
#define NONINTERLACED	0
#define INTERLACED		1

/*
 * Constants used in pseudo-floating point calculations
 */
#define THOUSAND          1000L
#define HALF_MILLION    500000L
#define MILLION        1000000L


/*
 * Data structure used for horz and vert information from the vddp file
 */
typedef struct _HALFDATA
    {
    long    Resolution;             // pixels
    unsigned long ScanFrequency;    // horz - Hz, vert - mHz
    char    Polarity;               // positive or negative
    unsigned long SyncWidth,        // horz - ns, vert - us
                    FrontPorch,     // horz - ns, vert - us
                    BackPorch,      // horz - ns, vert - us
                    ActiveTime,     // horz - ns, vert - us
                    BlankTime;      // horz - ns, vert - us
    } HALFDATA, *P_HALFDATA;



/*
 * Data structure used for complete preadjusted timing data set
 */
typedef struct _TIMINGDATA
    {
    char ModeName[33];  // name of the video mode
    char Interlaced;    // interlaced or non-interlaced mode
    HALFDATA HorzData;  // horizontal data
    HALFDATA VertData;  // vertical data
    } TIMINGDATA, *P_TIMINGDATA;

/*
 * Data structure used to hold number of timings sections and pointers to
 * timings buffer for each limits section
 */
typedef struct _LIMITSDATA
    {	
    unsigned long DotClock;     // maximum pixel clock -- for all assoc. timings
    long  TimingsCount;         // number of timings section for this limits sec.
    P_TIMINGDATA TimingsPtr;    // pointer to buffer holding timings data
    }LIMITSDATA, *P_LIMITSDATA;

typedef struct {
    char video_mode[33];
    unsigned char h_total, h_disp, h_sync_strt, h_sync_wid;
    unsigned long v_total, v_disp, v_sync_strt;
    unsigned char v_sync_wid, disp_cntl, crt_pitch, clk_sel;
    unsigned long pixel_clk;

	 // ***** the values below this comment were added for instvddp.exe *****

	 unsigned char lock,fifo_depth,vga_refresh_rate_code;
	 unsigned long control,hi_color_ctl,hi_color_vfifo;
} crtT;


#if 0
typedef enum {
    clk_43MHz  = 0,
    clk_49MHz  = 1,
    clk_93MHz  = 2,
    clk_36MHz  = 3,
    clk_50MHz  = 4,
    clk_57MHz  = 5,
    clk_extrn1 = 6,
    clk_45MHz  = 7,
    clk_30MHz  = 8,
    clk_32MHz  = 9,
    clk_110MHz = 10,
    clk_80MHz  = 11,
    clk_40MHz  = 12,
    clk_75MHz  = 14,
    clk_65MHz  = 15
} clockT;
#endif


#if 1
typedef enum {
    clk_100MHz = 0,
    clk_126MHz = 1,
    clk_93MHz  = 2,
    clk_36MHz  = 3,
    clk_50MHz  = 4,
    clk_57MHz  = 5,
    clk_extrn1 = 6,
    clk_45MHz  = 7,
    clk_135MHz = 8,
    clk_32MHz  = 9,
    clk_110MHz = 10,
    clk_80MHz  = 11,
    clk_40MHz  = 12,
    clk_75MHz  = 14,
    clk_65MHz  = 15
} clockT;
#endif

typedef struct {
    long clock_selector;
    long clock_freq;
} clk_infoT;

#ifdef INCLUDE_VDPDATA
#if 0
/* These are the pixel clocks for the 18810 Clock Chip */
clk_infoT clock_info[16] = {
    { clk_43MHz  , 42.95E+6 },
    { clk_49MHz  , 48.77E+6 },
    { clk_93MHz  , 92.40E+6 },
    { clk_36MHz  , 36.00E+6 },
    { clk_50MHz  , 50.35E+6 },
    { clk_57MHz  , 56.64E+6 },
    { clk_extrn1 , 0.000000 },
    { clk_45MHz  , 44.90E+6 },
    { clk_30MHz  , 30.24E+6 },
    { clk_32MHz  , 32.00E+6 },
    { clk_110MHz , 110.0E+6 },
    { clk_80MHz  , 80.00E+6 },
    { clk_40MHz  , 40.00E+6 },
    { clk_75MHz  , 75.00E+6 },
    { clk_65MHz  , 65.00E+6 },
    { -1         , 0.000000 }
};
#endif

#if 1
/* These are the pixel clocks for the 18811-1 Clock Chip */
clk_infoT clock_info[16] = {
    { clk_100MHz , 100000000L },
    { clk_126MHz , 126000000L },
    { clk_93MHz  ,  92400000L },
    { clk_36MHz  ,  36000000L },
    { clk_50MHz  ,  50350000L },
    { clk_57MHz  ,  56640000L },
    { clk_extrn1 ,         0L },
    { clk_45MHz  ,  44900000L },
    { clk_135MHz , 135000000L },
    { clk_32MHz  ,  32000000L },
    { clk_110MHz , 110000000L },
    { clk_80MHz  ,  80000000L },
    { clk_40MHz  ,  40000000L },
    { clk_75MHz  ,  75000000L },
    { clk_65MHz  ,  65000000L },
    { -1         ,         0L }
};
#endif
#else
extern clk_infoT clock_info[16];
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\cirrus\disp\7555bw.h ===
/**********************************************************
* Copyright Cirrus Logic, Inc. 1996. All rights reserved.
***********************************************************
*
* 7555BW.H
*
* Contains preprocessor definitions needed for CL-GD7555
*  bandwidth equations.
*
***********************************************************
*
*  WHO WHEN     WHAT/WHY/HOW
*  --- ----     ------------
*  RT  11/07/96 Created.
*  TT  02-24-97 Modified from 5446misc.h for 7555.
*
***********************************************************/

//#ifndef _7555BW_H
//#define _7555BW_H
//
//#include <Windows.h>
//#include <Windowsx.h>
//
//#include "VPM_Cir.h"
//#include "Debug.h"
//#include "BW.h"

/* type definitions & structures -------------------------*/

typedef struct _BWEQ_STATE_INFO
{
    RECTL rVPort;            /* Rect. at video port, if capture enabled */
    RECTL rCrop;             /* Rect. after cropping, if capture enabled */
    RECTL rPrescale;         /* Rect. after scaling, if capture enabled */
    RECTL rSrc;              /* Rect. in memory for display */
    RECTL rDest;             /* Rect. on the screen for display */
    DWORD dwSrcDepth;       /* Bits per pixel of data, in memory */
    DWORD dwPixelsPerSecond;/* Rate of data into video port, if capture enabled */
    DWORD dwFlags;          /* See FLG_ in OVERLAY.H */
} BWEQ_STATE_INFO, *PBWEQ_STATE_INFO;

/* preprocessor definitions ------------------------------*/
#define WIDTH(a)  ((a).right - (a).left)
#define HEIGHT(a) ((a).bottom - (a).top)

#define REF_XTAL  (14318182ul)      // Crystal reference frequency (Hz)

/*
 * VGA MISC Register
 */
#define MISC_WRITE            0x03C2  // Miscellaneous Output Register (Write)
#define MISC_READ             0x03CC  // Miscellaneous Output Register (Read)
#define MISC_VCLK_SELECT      0x0C    // Choose one of the four VCLKs
#define MISC_MEMORY_ACCESS    0x02    // Enable memory access

/*
 * VGA CRTC Registers
 */

#define CR01                  0x01    // Horizontal Display End Register
#define CR01_HORZ_END         0xFF    // Horizontal Display End

#define CR42                  0x42    // VW FIFO Threshold and Chroma Key
                                      //  Mode Select Register
#define CR42_MVWTHRESH        0x0C    // VW FIFO Threshold

#define CR51                  0x51    // V-Port Data Format Register
#define CR51_VPORTMVW_THRESH  0xE0    // V-Port FIFO Threshold in VW

#define CR5A                  0x5A    // V-Port Cycle and V-Port FIFO Control
#define CR5A_VPORTGFX_THRESH  0x07    // V-Port FIFO Threshold in Surrounding
                                      //  graphics

#define CR5D                  0x5D    // Number of Memory Cycles per Scanline
                                      //  Override Register
#define CR5D_MEMCYCLESPERSCAN 0xFF    // Number of Memory Cycles per Scanline
                                      //  Override

#define CR80                  0x80    // Power Management Control Register
#define CR80_LCD_ENABLE       0x01    // Flat Panel Enable

#define CR83                  0x83    // Flat Panel Type Register
#define CR83_LCD_TYPE         0x70    // Flat Panel Type Select

/*
 * VGA GRC Registers
 */
#define GRC_INDEX             0x03CE  // Graphics controller index register
#define GRC_DATA              0x03CF  // Graphics controller data register

#define GR18                  0x18    // EDO RAM Control Register
#define GR18_LONG_RAS         0x04    // EDO DRAM Long RAS# Cycle Enable

/*
 * VGA Sequencer Registers
 */
#define SR0F                  0x0F    // Display Memory Control Register
#define SR0F_DISPLAY_RAS      0x04    // Display Memory RAS# Cycle Select

#define SR0B                  0x0B    // VCLK0 Numerator
#define SR0C                  0x0C    // VCLK1 Numerator
#define SR0D                  0x0D    // VCLK2 Numerator
#define SR0E                  0x0E    // VCLK3 Numerator
#define SR0X_VCLK_NUMERATOR   0x7F    // VCLK Numerator

#define SR1B                  0x1B    // VCLK0 Denomintor and Post-Scalar
#define SR1C                  0x1C    // VCLK1 Denomintor and Post-Scalar
#define SR1D                  0x1D    // VCLK2 Denomintor and Post-Scalar
#define SR1E                  0x1E    // VCLK3 Denomintor and Post-Scalar
#define SR1X_VCLK_DENOMINATOR 0x3E    // VCLK Denominator
#define SR1X_VCLK_POST_SCALAR 0x01    // VCLK Post-Scalar
#define SR1E_VCLK_MCLK_DIV2   0x01    // MCLK Divide by 2 (when SR1F[6] = 1)

#define SR1F                  0x1F    // MCLK Frequency and VCLK Source Select
#define SR1F_VCLK_SRC         0x40    // VCLK Source Select
#define SR1F_MCLK_FREQ        0x3F    // MCLK Frequency

#define SR20                  0x20    // Miscellaneous Control Register 2
#define SR20_9MCLK_RAS        0x40    // Select 9-MCLK RAS# Cycles for EDO DRAMs
#define SR20_VCLKDIV4         0x02    // Set VCLK0, 1 Source to VCLK VCO/4

#define SR2F                  0x2F    // HFA FIFO Threshold for Surrounding
                                      //  Graphics Register
#define SR2F_HFAFIFOGFX_THRESH 0x0F    // HFA FIFO Threshold for Surr. Gfx

#define SR32                  0x32    // HFA FIFO Threshold in VW and DAC
                                      //  IREF Power Control Register
#define SR32_HFAFIFOMVW_THRESH 0x07    // HFA FIFO Thresh in VW

#define SR34                  0x34    // Host CPU Cycle Stop Control Register
#define SR34_CPUSTOP_ENABLE   0x10    // Terminate Paged Host CPU Cycles when
                                      //  Re-starting is Disabled
#define SR34_DSTN_CPUSTOP     0x08    // Stop Host CPU Cycle before Half-
                                      //  Frame Accelerator Cycle
#define SR34_VPORT_CPUSTOP    0x04    // Stop Host CPU Cycle before V-Port cycle
#define SR34_MVW_CPUSTOP      0x02    // Stop Host CPU Cycle before VW cycle
#define SR34_GFX_CPUSTOP      0x01    // Stop Host CPU Cycle before CRT
                                      //  Monitor cycle

#define GFXFIFO_THRESH        8

//typedef struct PROGREGS_
//{
//  BYTE bSR2F;
//  BYTE bSR32;
//  BYTE bSR34;
//
//  BYTE bCR42;
//  BYTE bCR51;
//  BYTE bCR5A;
//  BYTE bCR5D;
//}PROGREGS, FAR *LPPROGREGS;
//
#if 0   //myf32
typedef struct BWREGS_
{
  BYTE bSR2F;
  BYTE bSR32;
  BYTE bSR34;
  BYTE bCR42;

  BYTE bCR51;
  BYTE bCR5A;
  BYTE bCR5D;
  BYTE bCR5F;



}BWREGS, FAR *LPBWREGS;
#endif

/*
 * Function prototypes
 */
//BOOL IsSufficientBandwidth7555 (WORD, WORD, DWORD, DWORD, DWORD, DWORD,
//DWORD, DWORD, LPBWREGS);
//BOOL IsSufficientBandwidth7555 (WORD, LPRECTL, LPRECTL, DWORD);

// 7555BW.c
//static int ScaleMultiply(DWORD,         // Factor 1
//                         DWORD,         // Factor 2
//                         LPDWORD);      // Pointer to returned product
//BOOL ChipCalcMCLK(LPBWREGS,             // Current register settings
//                  LPDWORD);             // Pointer to returned MCLK
//BOOL ChipCalcVCLK(LPBWREGS,             // Current register settings
//                  LPDWORD);             // Pointer to returned VCLK
//BOOL ChipGetMCLK(LPDWORD);              // Pointer to returned MCLK
//BOOL ChipGetVCLK(LPDWORD);              // Pointer to returned VCLK
//BOOL ChipIsDSTN(LPBWREGS);              // Current register settings
//BOOL ChipCheckBandwidth(LPVIDCONFIG,    // Current video configuration
//                        LPBWREGS,       // Current register values
//                        LPPROGREGS);    // Holds return value for regs
//                                        //  (may be NULL)
//BOOL ChipIsEnoughBandwidth(LPVIDCONFIG, // Current video configuration
//                           LPPROGREGS); // Holds return value for regs
//                                        //  (may be NULL)
//// 7555IO.c
//BOOL ChipIOReadBWRegs(LPBWREGS);        // Filled with current reg settings
//BOOL ChipIOWriteProgRegs(LPPROGREGS);   // Writes register values
//BOOL ChipIOReadProgRegs(LPPROGREGS);    // Get current register settings
//
//#endif // _7555BW_H

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\cirrus\disp\bank.c ===
/******************************Module*Header*******************************\
* Module Name: bank.c
*
* Contains all the banking code for the display driver.
*
* It's helpful not to have to implement all the DDI drawing functionality
* in a driver (who wants to write the code to support true ROP4's with
* arbitrary sized patterns?).  Fortunately, we can punt to GDI for any
* drawing we don't want to do.  And if GDI can write directly on the frame
* buffer bits, performance won't even be toooo bad.
*
* NT's GDI can draw on any standard format frame buffer.  When the entire
* frame buffer can be mapped into main memory, it's very simple to set up:
* the display driver tells GDI the frame buffer format and location, and
* GDI can then just draw directly.
*
* When only one bank of the frame buffer can be mapped into main memory
* at one time (e.g., there is a moveable 64k aperture) things are not
* nearly so easy.  For every bank spanned by a drawing operation, we have
* to set the hardware to the bank, and call back to GDI.  We tell GDI
* to draw only on the mapped-in bank by mucking with the drawing call's
* CLIPOBJ.
*
* This module contains the code for doing all banking support.
*
* This code supports 8, 16 and 32bpp colour depths, arbitrary bank
* sizes, and handles 'broken rasters' (which happens when the bank size
* is not a multiple of the scan length; some scans will end up being
* split over two separate banks).
*
* Note:  If you mess with this code and break it, you can expect to get
*        random access violations on call-backs in internal GDI routines
*        that are very hard to debug.
*
* Copyright (c) 1993-1995 Microsoft Corporation
\**************************************************************************/

#include "precomp.h"

typedef struct _BANKDATA {
    ULONG nothing_yet;
} BANKDATA;                      /* bd, pbd */

////////////////////////////////////////////////////////////////////////////
// Banking code
//

VOID vBankSelectMode(
PPDEV       ppdev,
BANK_MODE   bankm)
{
    // BANK_ENABLE   - We've exited full-screen; re-enable banking
    // BANK_ON       - We're about to use the memory aperture
    // BANK_OFF      - We've finished using the memory aperture
    // BANK_DISABLE  - We're about to enter full-screen; shut down banking

    switch(bankm){

        case BANK_ENABLE:   DISPDBG((115,"vBankSelectMode(BANK_ENABLE)"));
                            break;

        case BANK_ON:       DISPDBG((115,"vBankSelectMode(BANK_ON)"));
                            //
                            // [BUGFIX] -   I don't know why, but the CL542x
                            //              needs the color register set to
                            //              0 when drawing to the framebuffer
                            //
                            if (ppdev->flCaps & CAPS_MM_IO)
                            {
                                CP_MM_WAIT_FOR_BLT_COMPLETE(ppdev, ppdev->pjBase);
                                CP_MM_FG_COLOR(ppdev, ppdev->pjBase, 0);
                            }
                            else
                            {
                                CP_IO_WAIT_FOR_BLT_COMPLETE(ppdev, ppdev->pjPorts);
                                CP_IO_FG_COLOR(ppdev, ppdev->pjPorts, 0);
                            }
                            CP_EIEIO();
                            break;

        case BANK_OFF:      DISPDBG((115,"vBankSelectMode(BANK_OFF)"));
                            break;

        case BANK_DISABLE:  DISPDBG((115,"vBankSelectMode(BANK_DISABLE)"));
                            break;

        default:            DISPDBG((115,"vBankSelectMode(UNKNOWN=%d)", bankm));
                            RIP("Bad BANK_MODE selected");
                            break;
    }
}

VOID vBankMap(
PPDEV       ppdev,
LONG        iBank)
{
    WORD w;

    //
    // map the segement to iBank
    //

    DISPDBG((10,"vBankMap(iBank=%d)", iBank));

    w = (WORD) (0x9 | (iBank << ppdev->ulBankShiftFactor));
    CP_OUT_WORD(ppdev->pjPorts,INDEX_REG,w);
    CP_EIEIO();
}

VOID vBankInitialize(
PPDEV       ppdev,
BOOL        bMmIo)
{
}

/******************************Public*Routine******************************\
* BOOL bEnableBanking
*
\**************************************************************************/

BOOL bEnableBanking(
PDEV*   ppdev)
{
    CLIPOBJ*            pcoBank;
    SURFOBJ*            psoBank;
    SIZEL               sizl;
    HSURF               hsurf;
    static FNBANKINITIALIZE*   pfnBankInitialize;
    LONG                lDelta;
    LONG                cjBank;
    LONG                cPower2;

    // This routine may be called multiple times (e.g., each time
    // full-screen is exited), so make sure we do any allocations
    // only once:

    if (ppdev->pcoBank == NULL)
    {
        // Create a temporary clip object that we'll use for the bank
        // when we're given a Null or DC_TRIVIAL clip object:

        pcoBank = EngCreateClip();
        if (pcoBank == NULL)
            goto ReturnFalse;

        // We break every per-bank GDI call-back into simple rectangles:

        pcoBank->iDComplexity = DC_RECT;
        pcoBank->fjOptions    = OC_BANK_CLIP;

        // Create a GDI surface that we'll wrap around our bank in
        // call-backs:

        sizl.cx = ppdev->cxMemory;
        sizl.cy = ppdev->cyMemory;

        hsurf = (HSURF) EngCreateBitmap(sizl,
                                        ppdev->lDelta,
                                        ppdev->iBitmapFormat,
                                        BMF_TOPDOWN,
                                        ppdev->pjScreen);

        // Note that we hook zero calls -- after all, the entire point
        // of all this is to have GDI do all the drawing on the bank.
        // Once we're done the association, we can leave the surface
        // permanently locked:

        if ((hsurf == 0)                                        ||
            (!EngAssociateSurface(hsurf, ppdev->hdevEng, 0))    ||
            (!(psoBank = EngLockSurface(hsurf))))
        {
            DISPDBG((0, "Failed wrapper surface creation"));

            EngDeleteSurface(hsurf);
            EngDeleteClip(pcoBank);

            goto ReturnFalse;
        }

        ppdev->pcoBank    = pcoBank;
        ppdev->psoBank    = psoBank;
        ppdev->pvBankData = &ppdev->aulBankData[0];

        DISPDBG((2, "pcoBank = %x", pcoBank));
        DISPDBG((2, "psoBank = %x", psoBank));

        ppdev->pfnBankMap        = vBankMap;
        ppdev->pfnBankSelectMode = vBankSelectMode;
        pfnBankInitialize        = vBankInitialize;

        lDelta = ppdev->lDelta;
        cjBank = ppdev->cjBank;

        ASSERTDD(lDelta > 0, "Bad things happen with negative lDeltas");
        ASSERTDD(cjBank > lDelta, "Worse things happen with bad bank sizes");

        if (((lDelta & (lDelta - 1)) != 0) || ((cjBank & (cjBank - 1)) != 0))
        {
            // When either the screen stride or the bank size is not a power
            // of two, we have to use the slower 'bBankComputeNonPower2'
            // function for bank calculations, 'cause there can be broken
            // rasters and stuff:

            ppdev->pfnBankCompute = bBankComputeNonPower2;
        }
        else
        {
            // We can use the super duper fast bank calculator.  Yippie,
            // yahoo!  (I am easily amused.)

            cPower2 = 0;
            while (cjBank != lDelta)
            {
                cjBank >>= 1;
                cPower2++;
            }

            // We've just calculated that cjBank / lDelta = 2 ^ cPower2:

            ppdev->cPower2ScansPerBank = cPower2;

            while (cjBank != 1)
            {
                cjBank >>= 1;
                cPower2++;
            }

            // Continuing on, we've calculated that cjBank = 2 ^ cPower2:

            ppdev->cPower2BankSizeInBytes = cPower2;

            ppdev->pfnBankCompute = bBankComputePower2;
        }

    }

	// Warm up the hardware:

	pfnBankInitialize(ppdev, FALSE);

	ppdev->pfnBankSelectMode(ppdev, BANK_ENABLE);

    DISPDBG((5, "Passed bEnableBanking"));

    return(TRUE);

ReturnFalse:

    DISPDBG((0, "Failed bEnableBanking!"));

    return(FALSE);
}

/******************************Public*Routine******************************\
* VOID vDisableBanking
*
\**************************************************************************/

VOID vDisableBanking(PDEV* ppdev)
{
    HSURF hsurf;

    if (ppdev->psoBank != NULL)
    {
        hsurf = ppdev->psoBank->hsurf;
        EngUnlockSurface(ppdev->psoBank);
        EngDeleteSurface(hsurf);
    }

    if (ppdev->pcoBank != NULL)
        EngDeleteClip(ppdev->pcoBank);
}

/******************************Public*Routine******************************\
* VOID vAssertModeBanking
*
\**************************************************************************/

VOID vAssertModeBanking(
PDEV*   ppdev,
BOOL    bEnable)
{
    // Inform the miniport bank code about the change in state:

    ppdev->pfnBankSelectMode(ppdev,
                             bEnable ? BANK_ENABLE : BANK_DISABLE);
}

/******************************Public*Routine******************************\
* BOOL bBankComputeNonPower2
*
* Given the bounds of the drawing operation described by 'prclDraw',
* computes the bank number and rectangle bounds for the first engine
* call back.
*
* Returns the bank number, 'prclBank' is the bounds for the first
* call-back, and 'pcjOffset' is the adjustment for 'pvScan0'.
*
* This routine does a couple of divides for the bank calculation.  We
* don't use a look-up table for banks because it's not straight forward
* to use with broken rasters, and with large amounts of video memory
* and small banks, the tables could get large.  We'd probably use it
* infrequently enough that the memory manager would be swapping it
* in and out whenever we touched it.
*
* Returns TRUE if prclDraw is entirely contained in one bank; FALSE if
* prclDraw spans multiple banks.
*
\**************************************************************************/

BOOL bBankComputeNonPower2( // Type FNBANKCOMPUTE
PDEV*       ppdev,
RECTL*      prclDraw,       // Extents of drawing operation, in absolute
                            //  coordinates
RECTL*      prclBank,       // Returns bounds of drawing operation for this
                            //  bank, in absolute coordinates
LONG*       pcjOffset,      // Returns the byte offset for this bank
LONG*       piBank)         // Returns the bank number
{
    LONG cjBufferOffset;
    LONG iBank;
    LONG cjBank;
    LONG cjBankOffset;
    LONG cjBankRemainder;
    LONG cjScan;
    LONG cScansInBank;
    LONG cjScanRemainder;
    LONG lDelta;
    BOOL bOneBank;

    bOneBank = FALSE;
    lDelta   = ppdev->lDelta;

    cjBufferOffset  = prclDraw->top * lDelta
                    + PELS_TO_BYTES(prclDraw->left);

    cjBank          = ppdev->cjBank;

    // iBank        = cjBufferOffset / cjBank;
    // cjBankOffset = cjBufferOffset % cjBank;

    QUOTIENT_REMAINDER(cjBufferOffset, cjBank, iBank, cjBankOffset);

    *piBank         = iBank;
    *pcjOffset      = iBank * cjBank;
    cjBankRemainder = cjBank - cjBankOffset;
    cjScan          = PELS_TO_BYTES(prclDraw->right - prclDraw->left);

    if (cjBankRemainder < cjScan)
    {
        // Oh no, we've got a broken raster!

        prclBank->left   = prclDraw->left;
        prclBank->right  = prclDraw->left +
                           BYTES_TO_PELS(cjBankRemainder);
        prclBank->top    = prclDraw->top;
        prclBank->bottom = prclDraw->top + 1;
    }
    else
    {
        // cScansInBank    = cjBankRemainder / lDelta;
        // cjScanRemainder = cjBankRemainder % lDelta;

        ASSERTDD(lDelta > 0, "We assume positive lDelta here");

        QUOTIENT_REMAINDER(cjBankRemainder, lDelta,
                           cScansInBank, cjScanRemainder);

        if (cjScanRemainder >= cjScan)
        {
            // The bottom scan of the bank may be broken, but it breaks after
            // any drawing we'll be doing on that scan.  So we can simply
            // add the scan to this bank:

            cScansInBank++;
        }

        prclBank->left   = prclDraw->left;
        prclBank->right  = prclDraw->right;
        prclBank->top    = prclDraw->top;
        prclBank->bottom = prclDraw->top + cScansInBank;

        if (prclBank->bottom >= prclDraw->bottom)
        {
            prclBank->bottom  = prclDraw->bottom;
            bOneBank          = TRUE;
        }
    }

    return(bOneBank);
}

/******************************Public*Routine******************************\
* BOOL bBankComputePower2
*
* Functions the same as 'bBankComputeNonPower2', except that it is
* an accelerated special case for when both the screen stride and bank
* size are powers of 2.
*
\**************************************************************************/

BOOL bBankComputePower2(    // Type FNBANKCOMPUTE
PDEV*       ppdev,
RECTL*      prclDraw,       // Extents of drawing operation, in absolute
                            //  coordinates
RECTL*      prclBank,       // Returns bounds of drawing operation for this
                            //  bank, in absolute coordinates
LONG*       pcjOffset,      // Returns the byte offset for this bank
LONG*       piBank)         // Returns the bank number
{
    LONG iBank;
    LONG yTopNextBank;
    BOOL bOneBank;

    iBank        = prclDraw->top >> ppdev->cPower2ScansPerBank;
    yTopNextBank = (iBank + 1) << ppdev->cPower2ScansPerBank;
    *piBank      = iBank;
    *pcjOffset   = iBank << ppdev->cPower2BankSizeInBytes;

    prclBank->left   = prclDraw->left;
    prclBank->right  = prclDraw->right;
    prclBank->top    = prclDraw->top;
    prclBank->bottom = yTopNextBank;

    bOneBank = FALSE;
    if (prclBank->bottom >= prclDraw->bottom)
    {
        prclBank->bottom  = prclDraw->bottom;
        bOneBank          = TRUE;
    }

    return(bOneBank);
}

/******************************Public*Routine******************************\
* VOID vBankStart
*
* Given the bounds of the drawing operation described by 'prclDraw' and
* the original clip object, maps in the first bank and returns in
* 'pbnk->pco' and 'pbnk->pso' the CLIPOBJ and SURFOBJ to be passed to the
* engine for the first banked call-back.
*
* Note: This routine only supports the screen being the destination, and
*       not the source.  We have a separate, faster routine for doing
*       SRCCOPY reads from the screen, so it isn't worth the extra code
*       size to implement.
*
\**************************************************************************/

VOID vBankStart(
PDEV*       ppdev,      // Physical device information.
RECTL*      prclDraw,   // Rectangle bounding the draw area, in relative
                        //  coordinates.  Note that 'left' and 'right'
                        //  should be set for correct handling with broken
                        //  rasters.
CLIPOBJ*    pco,        // Original drawing clip object (may be modified).
BANK*       pbnk)       // Resulting bank information.
{
    LONG cjOffset;
    LONG xOffset;
    LONG yOffset;
    LONG xyOffset;

    DISPDBG((3, "vBankStart"));

    xOffset  = ppdev->xOffset;
    yOffset  = ppdev->yOffset;
    xyOffset = ppdev->xyOffset;

    if ((pco == NULL) || (pco->iDComplexity == DC_TRIVIAL))
    {
        pco = ppdev->pcoBank;

        // Reset the clipping flag to trivial because we may have left
        // it as rectangular in a previous call:

        pco->iDComplexity = DC_TRIVIAL;

        // At the same time we convert to absolute coordinates, make sure
        // we won't try to enumerate past the bounds of the screen:

        pbnk->rclDraw.left       = prclDraw->left   + xOffset;
        pbnk->rclDraw.right      = prclDraw->right  + xOffset;

        pbnk->rclDraw.top
            = max(0,               prclDraw->top    + yOffset);
        pbnk->rclDraw.bottom
            = min(ppdev->cyMemory, prclDraw->bottom + yOffset);
    }
    else
    {
        pbnk->rclSaveBounds    = pco->rclBounds;
        pbnk->iSaveDComplexity = pco->iDComplexity;
        pbnk->fjSaveOptions    = pco->fjOptions;

        // Let GDI know that it has to pay attention to the clip object:

        pco->fjOptions |= OC_BANK_CLIP;

        // We have to honour the original clip object's rclBounds, so
        // intersect the drawing region with it, then convert to absolute
        // coordinates:

        pbnk->rclDraw.left
            = max(prclDraw->left,   pco->rclBounds.left)   + xOffset;
        pbnk->rclDraw.right
            = min(prclDraw->right,  pco->rclBounds.right)  + xOffset;
        pbnk->rclDraw.top
            = max(prclDraw->top,    pco->rclBounds.top)    + yOffset;
        pbnk->rclDraw.bottom
            = min(prclDraw->bottom, pco->rclBounds.bottom) + yOffset;
    }

    if ((pbnk->rclDraw.left > pbnk->rclDraw.right)
     || (pbnk->rclDraw.top  > pbnk->rclDraw.bottom))
    {
        // It's conceivable that we could get a situation where we have
        // an empty draw rectangle.  Make sure we won't puke on our shoes:

        pbnk->rclDraw.left   = 0;
        pbnk->rclDraw.right  = 0;
        pbnk->rclDraw.top    = 0;
        pbnk->rclDraw.bottom = 0;
    }

    if (!ppdev->pfnBankCompute(ppdev, &pbnk->rclDraw, &pco->rclBounds,
                               &cjOffset, &pbnk->iBank))
    {
        // The drawing operation spans multiple banks.  If the original
        // clip object was marked as trivial, we have to make sure to
        // change it to rectangular so that GDI knows to pay attention
        // to the bounds of the bank:

        if (pco->iDComplexity == DC_TRIVIAL)
            pco->iDComplexity = DC_RECT;
    }

    pbnk->ppdev = ppdev;
    pbnk->pco   = pco;
    pbnk->pso   = ppdev->psoBank;

    // Convert rclBounds and pvScan0 from absolute coordinates back to
    // relative.  When GDI calculates where to start drawing, it computes
    // pjDst = pso->pvScan0 + y * pso->lDelta + PELS_TO_BYTES(x), where 'x'
    // and 'y' are relative coordinates.  We'll muck with pvScan0 to get
    // it pointing to the correct spot in the bank:

    pbnk->pso->pvScan0 = (ppdev->pjScreen - cjOffset) + xyOffset;

    pbnk->pso->lDelta = ppdev->lDelta;  // Other functions muck with this value

    ASSERTDD((((ULONG_PTR) pbnk->pso->pvScan0) & 3) == 0,
             "Off-screen bitmaps must be dword aligned");

    pco->rclBounds.left   -= xOffset;
    pco->rclBounds.right  -= xOffset;
    pco->rclBounds.top    -= yOffset;
    pco->rclBounds.bottom -= yOffset;

    // Enable banking and map in bank iBank:

    ppdev->pfnBankSelectMode(ppdev, BANK_ON);
    ppdev->pfnBankMap(ppdev, pbnk->iBank);
}

/******************************Public*Routine******************************\
* BOOL bBankEnum
*
* If there is another bank to be drawn on, maps in the bank and returns
* TRUE and the CLIPOBJ and SURFOBJ to be passed in the banked call-back.
*
* If there were no more banks to be drawn, returns FALSE.
*
\**************************************************************************/

BOOL bBankEnum(
BANK* pbnk)
{
    LONG     iBank;
    LONG     cjOffset;
    PDEV*    ppdev;
    CLIPOBJ* pco;
    LONG     xOffset;
    LONG     yOffset;

    DISPDBG((3, "vBankEnum"));

    ppdev   = pbnk->ppdev;
    pco     = pbnk->pco;
    xOffset = ppdev->xOffset;
    yOffset = ppdev->yOffset;

    // We check here to see if we have to handle the second part of
    // a broken raster.  Recall that pbnk->rclDraw is in absolute
    // coordinates, but pco->rclBounds is in relative coordinates:

    if (pbnk->rclDraw.right - xOffset != pco->rclBounds.right)
    {
        // The clip object's 'top' and 'bottom' are already correct:

        pco->rclBounds.left  = pco->rclBounds.right;
        pco->rclBounds.right = pbnk->rclDraw.right - xOffset;

        pbnk->pso->pvScan0 = (BYTE*) pbnk->pso->pvScan0 - ppdev->cjBank;
        pbnk->iBank++;

        ppdev->pfnBankMap(ppdev, pbnk->iBank);

        return(TRUE);
    }

    if (pbnk->rclDraw.bottom > pco->rclBounds.bottom + yOffset)
    {
        // Advance the drawing area 'top' to account for the bank we've
        // just finished, and map in the new bank:

        pbnk->rclDraw.top = pco->rclBounds.bottom + yOffset;

        ppdev->pfnBankCompute(ppdev, &pbnk->rclDraw, &pco->rclBounds,
                              &cjOffset, &iBank);

        // Convert rclBounds back from absolute to relative coordinates:

        pco->rclBounds.left   -= xOffset;
        pco->rclBounds.right  -= xOffset;
        pco->rclBounds.top    -= yOffset;
        pco->rclBounds.bottom -= yOffset;

        // If we just finished handling a broken raster, we've already
        // got the bank mapped in:

        if (iBank != pbnk->iBank)
        {
            pbnk->iBank = iBank;
            pbnk->pso->pvScan0 = (BYTE*) pbnk->pso->pvScan0 - ppdev->cjBank;
            ppdev->pfnBankMap(ppdev, iBank);
        }

        return(TRUE);
    }

    // We're done!  Turn off banking and reset the clip object if necessary:

    ppdev->pfnBankSelectMode(ppdev, BANK_OFF);

    if (pco != ppdev->pcoBank)
    {
        pco->rclBounds    = pbnk->rclSaveBounds;
        pco->iDComplexity = pbnk->iSaveDComplexity;
        pco->fjOptions    = pbnk->fjSaveOptions;
    }

    return(FALSE);
}

/******************************Public*Routine******************************\
* VOID vAlignedCopy
*
* Copies the given portion of a bitmap, using dword alignment for the
* screen.  Note that this routine has no notion of banking.
*
* Updates ppjDst and ppjSrc to point to the beginning of the next scan.
*
\**************************************************************************/

VOID vAlignedCopy(
PDEV*   ppdev,
BYTE**  ppjDst,
LONG    lDstDelta,
BYTE**  ppjSrc,
LONG    lSrcDelta,
LONG    cjScan,
LONG    cyScan,
BOOL    bDstIsScreen)
{
    BYTE* pjDst;
    BYTE* pjSrc;
    LONG  cjMiddle;
    LONG  culMiddle;
    LONG  cjStartPhase;
    LONG  cjEndPhase;

    pjSrc = *ppjSrc;
    pjDst = *ppjDst;

    cjStartPhase = (ULONG)((0 - ((bDstIsScreen) ? (ULONG_PTR)pjDst
                                                : (ULONG_PTR)pjSrc)) & 3);
    cjMiddle     = cjScan - cjStartPhase;

    if (cjMiddle < 0)
    {
        cjStartPhase = 0;
        cjMiddle     = cjScan;
    }

    lSrcDelta -= cjScan;
    lDstDelta -= cjScan;            // Account for middle

    cjEndPhase = cjMiddle & 3;
    culMiddle  = cjMiddle >> 2;

    if (DIRECT_ACCESS(ppdev))
    {
        LONG i;

        ///////////////////////////////////////////////////////////////////
        // Portable bus-aligned copy
        //
        // 'memcpy' usually aligns to the destination, so we could call
        // it for that case, but unfortunately we can't be sure.  We
        // always want to align to the frame buffer:

        if (bDstIsScreen)
        {
            // Align to the destination (implying that the source may be
            // unaligned):

            for (; cyScan > 0; cyScan--)
            {
                for (i = cjStartPhase; i > 0; i--)
                {
                    *pjDst++ = *pjSrc++;
                }

                for (i = culMiddle; i > 0; i--)
                {
                    *((ULONG*) pjDst) = *((ULONG UNALIGNED *) pjSrc);
                    pjSrc += sizeof(ULONG);
                    pjDst += sizeof(ULONG);
                }

                for (i = cjEndPhase; i > 0; i--)
                {
                    *pjDst++ = *pjSrc++;
                }

                pjSrc += lSrcDelta;
                pjDst += lDstDelta;
            }
        }
        else
        {
            // Align to the source (implying that the destination may be
            // unaligned):

            for (; cyScan > 0; cyScan--)
            {
                for (i = cjStartPhase; i > 0; i--)
                {
                    *pjDst++ = *pjSrc++;
                }

                for (i = culMiddle; i > 0; i--)
                {
                    *((ULONG UNALIGNED *) pjDst) = *((ULONG*) (pjSrc));

                    pjSrc += sizeof(ULONG);
                    pjDst += sizeof(ULONG);
                }

                for (i = cjEndPhase; i > 0; i--)
                {
                    *pjDst++ = *pjSrc++;
                }

                pjSrc += lSrcDelta;
                pjDst += lDstDelta;
            }
        }

        *ppjSrc = pjSrc;            // Save the updated pointers
        *ppjDst = pjDst;
    }

#if !defined(_X86_)

    else
    {
        LONG i;

        ///////////////////////////////////////////////////////////////////
        // No direct dword reads bus-aligned copy
        //
        // We go through this code path if doing dword reads would
        // crash a non-x86 system.

        MEMORY_BARRIER();

        if (bDstIsScreen)
        {
            // Align to the destination (implying that the source may be
            // unaligned):

            for (; cyScan > 0; cyScan--)
            {
                for (i = cjStartPhase; i > 0; i--)
                {
                    WRITE_REGISTER_UCHAR(pjDst, *pjSrc);
                    pjSrc++;
                    pjDst++;
                }

                for (i = culMiddle; i > 0; i--)
                {
                    WRITE_REGISTER_ULONG(pjDst, *((ULONG UNALIGNED *) pjSrc));
                    pjSrc += sizeof(ULONG);
                    pjDst += sizeof(ULONG);
                }

                for (i = cjEndPhase; i > 0; i--)
                {
                    WRITE_REGISTER_UCHAR(pjDst, *pjSrc);
                    pjSrc++;
                    pjDst++;
                }

                pjSrc += lSrcDelta;
                pjDst += lDstDelta;
            }
        }
        else
        {
            // Align to the source (implying that the destination may be
            // unaligned):

            for (; cyScan > 0; cyScan--)
            {
                for (i = cjStartPhase; i > 0; i--)
                {
                    *pjDst = READ_REGISTER_UCHAR(pjSrc);
                    pjSrc++;
                    pjDst++;
                }

                for (i = culMiddle; i > 0; i--)
                {
                    *((ULONG UNALIGNED *) pjDst) = READ_REGISTER_ULONG(pjSrc);

                    pjSrc += sizeof(ULONG);
                    pjDst += sizeof(ULONG);
                }

                for (i = cjEndPhase; i > 0; i--)
                {
                    *pjDst = READ_REGISTER_UCHAR(pjSrc);
                    pjSrc++;
                    pjDst++;
                }

                pjSrc += lSrcDelta;
                pjDst += lDstDelta;
            }
        }

        *ppjSrc = pjSrc;            // Save the updated pointers
        *ppjDst = pjDst;
    }

#endif

}

/******************************Public*Routine******************************\
* VOID vPutBits
*
* Copies the bits from the given surface to the screen, using the memory
* aperture.  Must be pre-clipped.
*
\**************************************************************************/

VOID vPutBits(
PDEV*       ppdev,
SURFOBJ*    psoSrc,
RECTL*      prclDst,            // Absolute coordinates!
POINTL*     pptlSrc)            // Absolute coordinates!
{
    RECTL   rclDraw;
    RECTL   rclBank;
    LONG    iBank;
    LONG    cjOffset;
    LONG    cyScan;
    LONG    lDstDelta;
    LONG    lSrcDelta;
    BYTE*   pjDst;
    BYTE*   pjSrc;
    LONG    cjScan;
    LONG    iNewBank;
    LONG    cjRemainder;

    BYTE* pjPorts = ppdev->pjPorts;

    // We need a local copy of 'rclDraw' because we'll be iteratively
    // modifying 'top' and passing the modified rectangle back into
    // bBankComputeNonPower2:

    DISPDBG((5, "vPutBits -- enter"));

    rclDraw = *prclDst;

    ASSERTDD((rclDraw.left   >= 0) &&
             (rclDraw.top    >= 0) &&
             (rclDraw.right  <= ppdev->cxMemory) &&
             (rclDraw.bottom <= ppdev->cyMemory),
             "Rectangle wasn't fully clipped");

    // Compute the first bank, enable banking, then map in iBank:

    ppdev->pfnBankCompute(ppdev, &rclDraw, &rclBank, &cjOffset, &iBank);
    ppdev->pfnBankSelectMode(ppdev, BANK_ON);
    ppdev->pfnBankMap(ppdev, iBank);

    // Calculate the pointer to the upper-left corner of both rectangles:

    lDstDelta = ppdev->lDelta;
    pjDst     = ppdev->pjScreen + rclDraw.top  * lDstDelta
                                + PELS_TO_BYTES(rclDraw.left)
                                - cjOffset;

    lSrcDelta = psoSrc->lDelta;
    pjSrc     = (BYTE*) psoSrc->pvScan0 + pptlSrc->y * lSrcDelta
                                        + PELS_TO_BYTES(pptlSrc->x);

    while (TRUE)
    {
        cjScan = PELS_TO_BYTES(rclBank.right  - rclBank.left);
        cyScan = (rclBank.bottom - rclBank.top);

        vAlignedCopy(ppdev, &pjDst, lDstDelta, &pjSrc, lSrcDelta, cjScan, cyScan,
                     TRUE);             // Screen is the destination

        if (rclDraw.right != rclBank.right)
        {
            // Handle the second part of the broken raster:

            iBank++;
            ppdev->pfnBankMap(ppdev, iBank);

            // Number of bytes we've yet to do on the broken scan:

            cjRemainder = PELS_TO_BYTES(rclDraw.right - rclBank.right);

            // Account for the fact that we're now one bank lower in the
            // destination:

            pjDst -= ppdev->cjBank;

            // Implicitly back up the source and destination pointers to the
            // unfinished portion of the scan:

            if (DIRECT_ACCESS(ppdev))
            {
                memcpy(pjDst + (cjScan - lDstDelta),
                       pjSrc + (cjScan - lSrcDelta),
                       cjRemainder);
            }
            else
            {
                BYTE* pjTmpDst = pjDst + (cjScan - lDstDelta);
                BYTE* pjTmpSrc = pjSrc + (cjScan - lSrcDelta);

                vAlignedCopy(ppdev, &pjTmpDst, 0, &pjTmpSrc, 0, cjRemainder, 1,
                             TRUE);    // Screen is the destination
            }
        }

        if (rclDraw.bottom > rclBank.bottom)
        {
            rclDraw.top = rclBank.bottom;
            ppdev->pfnBankCompute(ppdev, &rclDraw, &rclBank, &cjOffset,
                                  &iNewBank);

            // If we just handled the second part of a broken raster,
            // then we've already got the bank correctly mapped in:

            if (iNewBank != iBank)
            {
                pjDst -= ppdev->cjBank;
                iBank = iNewBank;
                ppdev->pfnBankMap(ppdev, iBank);
            }
        }
        else
        {
            // We're done!  Turn off banking and leave:

            ppdev->pfnBankSelectMode(ppdev, BANK_OFF);
            DISPDBG((5, "vPutBits -- exit"));
            return;
        }
    }
}

/******************************Public*Routine******************************\
* VOID vPutBitsLinear
*
* Copies the bits from the given surface to the screen, using the memory
* aperture.  Must be pre-clipped.
*
\**************************************************************************/

VOID vPutBitsLinear(
PDEV*       ppdev,
SURFOBJ*    psoSrc,
RECTL*      prclDst,        // Absolute coordinates!
POINTL*     pptlSrc)        // Absolute coordinates!
{
    RECTL   rclDraw;
    LONG    cyScan;
    LONG    lDstDelta;
    LONG    lSrcDelta;
    BYTE*   pjDst;
    BYTE*   pjSrc;
    LONG    cjScan;

    BYTE* pjPorts = ppdev->pjPorts;

    DISPDBG((5, "vPutBitsLinear -- enter"));

    rclDraw = *prclDst;

    ASSERTDD((rclDraw.left   >= 0) &&
             (rclDraw.top    >= 0) &&
             (rclDraw.right  <= ppdev->cxMemory) &&
             (rclDraw.bottom <= ppdev->cyMemory),
             "vPutBitsLinear: rectangle wasn't fully clipped");

    // Calculate the pointer to the upper-left corner of both rectangles:

    lDstDelta = ppdev->lDelta;
    pjDst     = ppdev->pjScreen + rclDraw.top  * lDstDelta
                                + PELS_TO_BYTES(rclDraw.left);

    lSrcDelta = psoSrc->lDelta;
    pjSrc     = (BYTE*) psoSrc->pvScan0 + (pptlSrc->y  * lSrcDelta)
                                        + PELS_TO_BYTES(pptlSrc->x);

    cjScan = PELS_TO_BYTES(rclDraw.right  - rclDraw.left);
    cyScan = (rclDraw.bottom - rclDraw.top);

    ppdev->pfnBankSelectMode(ppdev, BANK_ON);

    vAlignedCopy(ppdev, &pjDst, lDstDelta, &pjSrc, lSrcDelta, cjScan, cyScan,
                 TRUE);            // Screen is the dest
    DISPDBG((5, "vPutBitsLinear -- exit"));
}

/******************************Public*Routine******************************\
* VOID vGetBits
*
* Copies the bits to the given surface from the screen, using the memory
* aperture.  Must be pre-clipped.
*
\**************************************************************************/

VOID vGetBits(
PDEV*       ppdev,
SURFOBJ*    psoDst,
RECTL*      prclDst,        // Absolute coordinates!
POINTL*     pptlSrc)        // Absolute coordinates!
{
    RECTL   rclDraw;
    RECTL   rclBank;
    LONG    iBank;
    LONG    cjOffset;
    LONG    cyScan;
    LONG    lDstDelta;
    LONG    lSrcDelta;
    BYTE*   pjDst;
    BYTE*   pjSrc;
    LONG    cjScan;
    LONG    iNewBank;
    LONG    cjRemainder;

    BYTE* pjPorts = ppdev->pjPorts;

    DISPDBG((5, "vGetBits -- enter"));

    rclDraw.left   = pptlSrc->x;
    rclDraw.top    = pptlSrc->y;
    rclDraw.right  = rclDraw.left + (prclDst->right  - prclDst->left);
    rclDraw.bottom = rclDraw.top  + (prclDst->bottom - prclDst->top);

    ASSERTDD((rclDraw.left   >= 0) &&
             (rclDraw.top    >= 0) &&
             (rclDraw.right  <= ppdev->cxMemory) &&
             (rclDraw.bottom <= ppdev->cyMemory),
             "Rectangle wasn't fully clipped");

    // Compute the first bank, enable banking, then map in iBank.

    ppdev->pfnBankCompute(ppdev, &rclDraw, &rclBank, &cjOffset, &iBank);
    ppdev->pfnBankSelectMode(ppdev, BANK_ON);
    ppdev->pfnBankMap(ppdev, iBank);

    // Calculate the pointer to the upper-left corner of both rectangles:

    lSrcDelta = ppdev->lDelta;
    pjSrc     = ppdev->pjScreen + rclDraw.top  * lSrcDelta
                                + PELS_TO_BYTES(rclDraw.left)
                                - cjOffset;

    lDstDelta = psoDst->lDelta;
    pjDst     = (BYTE*) psoDst->pvScan0 + prclDst->top  * lDstDelta
                                        + PELS_TO_BYTES(prclDst->left);

    while (TRUE)
    {
        cjScan = PELS_TO_BYTES(rclBank.right  - rclBank.left);
        cyScan = (rclBank.bottom - rclBank.top);

        vAlignedCopy(ppdev, &pjDst, lDstDelta, &pjSrc, lSrcDelta, cjScan, cyScan,
                     FALSE);            // Screen is the source

        if (rclDraw.right != rclBank.right)
        {
            // Handle the second part of the broken raster:

            iBank++;
            ppdev->pfnBankMap(ppdev, iBank);

            // Number of bytes we've yet to do on the broken scan:

            cjRemainder = PELS_TO_BYTES(rclDraw.right - rclBank.right);

            // Account for the fact that we're now one bank lower in the
            // source:

            pjSrc -= ppdev->cjBank;

            // Implicitly back up the source and destination pointers to the
            // unfinished portion of the scan.  Note that we don't have to
            // advance the pointers because they're already pointing to the
            // beginning of the next scan:

            if (DIRECT_ACCESS(ppdev))
            {
                memcpy(pjDst + (cjScan - lDstDelta),
                       pjSrc + (cjScan - lSrcDelta),
                       cjRemainder);
            }
            else
            {
                BYTE* pjTmpDst = pjDst + (cjScan - lDstDelta);
                BYTE* pjTmpSrc = pjSrc + (cjScan - lSrcDelta);

                vAlignedCopy(ppdev, &pjTmpDst, 0, &pjTmpSrc, 0, cjRemainder, 1,
                             FALSE);    // Screen is the source
            }
        }

        if (rclDraw.bottom > rclBank.bottom)
        {
            rclDraw.top = rclBank.bottom;
            ppdev->pfnBankCompute(ppdev, &rclDraw, &rclBank, &cjOffset,
                                  &iNewBank);

            // If we just handled the second part of a broken raster,
            // then we've already got the bank correctly mapped in:

            if (iNewBank != iBank)
            {
                pjSrc -= ppdev->cjBank;
                iBank = iNewBank;
                ppdev->pfnBankMap(ppdev, iBank);
            }
        }
        else
        {
            // We're done!  Turn off banking and leave:

            ppdev->pfnBankSelectMode(ppdev, BANK_OFF);
            DISPDBG((5, "vGetBits -- exit"));
            return;
        }
    }
}

/******************************Public*Routine******************************\
* VOID vGetBitsLinear
*
* Copies the bits to the given surface from the screen, using the memory
* aperture.  Must be pre-clipped.
*
\**************************************************************************/

VOID vGetBitsLinear(
PDEV*       ppdev,
SURFOBJ*    psoDst,
RECTL*      prclDst,        // Absolute coordinates!
POINTL*     pptlSrc)        // Absolute coordinates!
{
    RECTL   rclDraw;
    LONG    cyScan;
    LONG    lDstDelta;
    LONG    lSrcDelta;
    BYTE*   pjDst;
    BYTE*   pjSrc;
    LONG    cjScan;

    BYTE* pjPorts = ppdev->pjPorts;

    DISPDBG((5, "vGetBitsLinear -- enter"));

    rclDraw.left   = pptlSrc->x;
    rclDraw.top    = pptlSrc->y;
    rclDraw.right  = rclDraw.left + (prclDst->right  - prclDst->left);
    rclDraw.bottom = rclDraw.top  + (prclDst->bottom - prclDst->top);

    ASSERTDD((rclDraw.left   >= 0) &&
             (rclDraw.top    >= 0) &&
             (rclDraw.right  <= ppdev->cxMemory) &&
             (rclDraw.bottom <= ppdev->cyMemory),
             "vGetBitsLinear: rectangle wasn't fully clipped");

    // Calculate the pointer to the upper-left corner of both rectangles:

    lSrcDelta = ppdev->lDelta;
    pjSrc     = ppdev->pjScreen + rclDraw.top  * lSrcDelta
                                + PELS_TO_BYTES(rclDraw.left);

    lDstDelta = psoDst->lDelta;
    pjDst     = (BYTE*) psoDst->pvScan0 + prclDst->top  * lDstDelta
                                        + PELS_TO_BYTES(prclDst->left);

    cjScan = PELS_TO_BYTES(rclDraw.right  - rclDraw.left);
    cyScan = (rclDraw.bottom - rclDraw.top);

    ppdev->pfnBankSelectMode(ppdev, BANK_ON);

    vAlignedCopy(ppdev, &pjDst, lDstDelta, &pjSrc, lSrcDelta, cjScan, cyScan,
                 FALSE);            // Screen is the source
    DISPDBG((5, "vGetBitsLinear -- exit"));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\ati\mini\query_m.c ===
/************************************************************************/
/*                                                                      */
/*                              QUERY_M.C                               */
/*                                                                      */
/*  Copyright (c) 1992, ATI Technologies Incorporated.                  */
/************************************************************************/

/**********************       PolyTron RCS Utilities
   
    $Revision:   1.24  $
    $Date:   01 May 1996 14:11:40  $
    $Author:   RWolff  $
    $Log:   S:/source/wnt/ms11/miniport/archive/query_m.c_v  $
 * 
 *    Rev 1.24   01 May 1996 14:11:40   RWolff
 * Locked out 24BPP on Alpha.
 * 
 *    Rev 1.23   23 Apr 1996 17:27:24   RWolff
 * Expanded lockout of 800x600 16BPP 72Hz to all Mach 32 cards, since
 * some VRAM cards are also affected.
 * 
 *    Rev 1.22   12 Apr 1996 16:16:36   RWolff
 * Now rejects 24BPP modes if linear aperture is not present, since new
 * source stream display driver can't do 24BPP in a paged aperture. This
 * rejection should be done in the display driver (the card still supports
 * the mode, but the display driver doesn't want to handle it), but at
 * the point where the display driver must decide to either accept or reject
 * modes, it doesn't have access to the aperture information.
 * 
 *    Rev 1.21   10 Apr 1996 17:02:04   RWolff
 * Locked out 800x600 16BPP 72Hz on DRAM cards, fix for checking
 * resolution-dependent special cases against a value which is
 * only set if the mode is installed.
 * 
 * 
 *    Rev 1.20   23 Jan 1996 11:48:12   RWolff
 * Eliminated level 3 warnings, protected against false values of
 * TARGET_BUILD, added debug print statements, now assumes DEC Alpha
 * has a 2M card since the memory size check routine generates a
 * false value (4M) on this platform.
 * 
 *    Rev 1.19   11 Jan 1996 19:37:10   RWolff
 * Added maximum pixel clock rate to all calls to SetFixedModes().
 * This is required as part of a Mach 64 fix.
 * 
 *    Rev 1.18   20 Jul 1995 17:58:56   mgrubac
 * Added support for VDIF files.
 * 
 *    Rev 1.17   31 Mar 1995 11:52:36   RWOLFF
 * Changed from all-or-nothing debug print statements to thresholds
 * depending on importance of the message.
 * 
 *    Rev 1.16   14 Mar 1995 15:59:58   ASHANMUG
 * Check wait for idle status before continuing block write test.
 * This fixes an Intel AX problem where the engine was hanging.
 * 
 *    Rev 1.15   23 Dec 1994 10:47:42   ASHANMUG
 * ALPHA/Chrontel-DAC
 * 
 *    Rev 1.14   18 Nov 1994 11:44:22   RWOLFF
 * Now detects STG1702/1703 DACs in native mode, added support for
 * split rasters.
 * 
 *    Rev 1.13   19 Aug 1994 17:13:16   RWOLFF
 * Added support for SC15026 DAC, Graphics Wonder, non-standard pixel
 * clock generators, and 1280x1024 70Hz and 74Hz.
 * 
 *    Rev 1.12   22 Jul 1994 17:48:24   RWOLFF
 * Merged with Richard's non-x86 code stream.
 * 
 *    Rev 1.11   30 Jun 1994 18:21:06   RWOLFF
 * Removed routine IsApertureConflict_m() (moved to SETUP_M.C), no longer
 * enables aperture while querying the card (aperture is now enabled in
 * IsApertureConflict_m() after we find that there is no conflict).
 * 
 *    Rev 1.10   15 Jun 1994 11:08:34   RWOLFF
 * Now lists block write as unavailable on DRAM cards, gives correct
 * vertical resolution if CRT parameters are stored in skip-1-2 format
 * (as is the case on some Graphics Ultra cards which were upgraded from
 * 512k to 1M) instead of the normal skip-2 format.
 * 
 *    Rev 1.9   20 May 1994 19:19:38   RWOLFF
 * No longer inserts phantom 16BPP mode table for resolutions where
 * 16BPP can be supported but which are not configured.
 * 
 *    Rev 1.8   20 May 1994 16:08:44   RWOLFF
 * Fix for 800x600 screen tearing on Intel BATMAN PCI motherboards.
 * 
 *    Rev 1.7   20 May 1994 14:02:58   RWOLFF
 * Ajith's change: no longer falsely detects NCR dual Pentium MCA card
 * as being susceptible to MIO bug.
 * 
 *    Rev 1.6   12 May 1994 11:17:44   RWOLFF
 * For Mach 32, now lists predefined refresh rates as available instead of
 * only the refresh rate stored in EEPROM, no longer makes 1024x768 87Hz
 * interlaced available if no 1024x768 mode configured, since the predefined
 * rates will allow all resolutions even on uninstalled cards.
 * For all cards, writes refresh rate to mode tables.
 * 
 *    Rev 1.5   27 Apr 1994 13:56:30   RWOLFF
 * Added routine IsMioBug_m() which checks to see if card has multiple
 * input/output bug.
 * 
 *    Rev 1.4   26 Apr 1994 12:43:44   RWOLFF
 * Put back use of 1024x768 interlaced when no 1024 resolution installed,
 * no longer uses 32BPP.
 * 
 *    Rev 1.3   31 Mar 1994 15:07:16   RWOLFF
 * Added debugging code.
 * 
 *    Rev 1.2   08 Feb 1994 19:01:32   RWOLFF
 * Removed unused routine get_num_modes_m(), no longer makes 1024x768 87Hz
 * interlaced available if Mach 32 card is configured with 1024x768
 * set to "Not installed".
 * 
 *    Rev 1.1   07 Feb 1994 14:03:26   RWOLFF
 * Added alloc_text() pragmas to allow miniport to be swapped out when
 * not needed, removed routine GetMemoryNeeded_m() which was only called
 * by LookForSubstitute(), a routine removed from ATIMP.C.
 * 
 *    Rev 1.0   31 Jan 1994 11:12:34   RWOLFF
 * Initial revision.
 * 
 *    Rev 1.7   24 Jan 1994 18:08:16   RWOLFF
 * Now fills in 16 and 24 BPP mode tables for BT48x and AT&T 49[123] DACs
 * using dedicated (and undocumented) mode tables in the EEPROM rather
 * than expecting the mode set routine to multiply the pixel clock from
 * the 8BPP mode tables.
 * 
 *    Rev 1.6   14 Jan 1994 15:25:32   RWOLFF
 * Uses defined values for bus types, added routine to see if block write
 * mode is available.
 * 
 *    Rev 1.5   15 Dec 1993 15:28:14   RWOLFF
 * Added support for SC15021 DAC, hardcoded aperture location for
 * DEC ALPHA (BIOS can't initialize the registers).
 * 
 *    Rev 1.4   30 Nov 1993 18:28:44   RWOLFF
 * Added support for AT&T 498 DAC, removed dead code.
 * 
 *    Rev 1.3   10 Nov 1993 19:26:00   RWOLFF
 * GetTrueMemSize_m() now handles 1M cards correctly, doesn't depend on the
 * VGA aperture being available.
 * 
 *    Rev 1.2   05 Nov 1993 13:26:34   RWOLFF
 * Added support for PCI bus and STG1700 DAC.
 * 
 *    Rev 1.1   08 Oct 1993 11:13:40   RWOLFF
 * Added routine to get true amount of memory needed for a particular mode
 * on 8514/A-compatible ATI accelerators, and fix for BIOS bug that reports
 * less than the true amount of memory in MEM_SIZE_ALIAS field of MISC_OPTIONS.
 * 
 *    Rev 1.0   24 Sep 1993 11:52:28   RWOLFF
 * Initial revision.
 * 
 *    Rev 1.0   03 Sep 1993 14:24:08   RWOLFF
 * Initial revision.
        
           Rev 1.0   16 Aug 1993 13:28:54   Robert_Wolff
        Initial revision.
        
           Rev 1.31   06 Jul 1993 15:52:08   RWOLFF
        No longer sets mach32_split_fixup (support for non-production hardware).
        
           Rev 1.30   24 Jun 1993 16:18:18   RWOLFF
        Now inverts COMPOSITE_SYNC bit of m_clock_select field on Mach 8 cards,
        since the EEPROM holds the value to use when using the shadow sets and
        we use the primrary CRT register set. Now takes the proper byte of
        EEPROM word 0x13 when calculating the clock select for 1280x1024
        on an 8514/ULTRA.
        
           Rev 1.29   18 Jun 1993 16:09:40   RWOLFF
        Fix for 68800 Rev. 3 hardware problem (screen pitch must be a multiple of
        128 pixels, but no symptoms exhibited except at high colour depths with
        fast pixel clock).
        
           Rev 1.28   10 Jun 1993 15:55:18   RWOLFF
        Now uses static buffer rather than dynamic allocation for CRT
        parameter read by BIOS function call.
        Change originated by Andre Vachon at Microsoft.
        
           Rev 1.27   07 Jun 1993 11:44:00   BRADES
        Rev 6 split transfer fixup.
        
           Rev 1.25   12 May 1993 16:33:42   RWOLFF
        Changed test order for aperture calculations to avoid trouble due to
        undefined bits being 1 instead of 0.
        
           Rev 1.24   10 May 1993 16:39:28   RWOLFF
        Now recognizes maximum pixel depth of each possible DAC at all supported
        resolutions rather than assuming that TI34075 can handle 32 BPP at all
        resolutions while all other DACs can do 16 BPP at all resolutions but
        can't do 24 BPP.
        
           Rev 1.23   30 Apr 1993 16:42:24   RWOLFF
        Buffer for CRT parameter read via BIOS call is now dynamically allocated.
        
           Rev 1.22   24 Apr 1993 16:32:24   RWOLFF
        Now recognizes that 800x600 8BPP is not available on Mach 8 cards with
        512k of accelerator memory, Mach 32 ASIC revision number is now recorded
        as the value read from the "revision code" register rather than the chip
        revision (i.e. Rev. 3 chip is recorded as Rev. 0), no longer falls back to
        56Hz in 800x600 16BPP on 1M Mach 32 cards.
        
           Rev 1.21   21 Apr 1993 17:33:38   RWOLFF
        Now uses AMACH.H instead of 68800.H/68801.H.
        Added include file for error definitions.
        Added function to fill in the CRT tables on a Mach 32 using the BIOS
        function call <video segment>:006C if extended BIOS functions are available.
        
           Rev 1.20   15 Apr 1993 13:35:58   BRADES
        will not report a mode if Mach32 and 1 Meg and 1280 res.
        add ASIC revision from register.
        
           Rev 1.19   25 Mar 1993 11:21:50   RWOLFF
        Brought a function header comment up to date, assumes that 1024x768
        87Hz interlaced is available if no 1024x768 mode is configured,
        query functions return failure if no EEPROM is present. It is assumed
        that an absent EEPROM will produce a read value of 0xFFFF, and the
        check is made at the start of mode table filling so the remainder
        of the query structure will contain valid data in the fields our
        driver uses.
        
           Rev 1.18   21 Mar 1993 15:58:28   BRADES
        use 1024 pitch for Mach32 if using VGA aperture.
        
           Rev 1.17   16 Mar 1993 17:00:54   BRADES
        Set Pitch to 1024 on the Mach32 for 640 and 800 resolutions.
        Allows VGA bank mgr to function.
        
           Rev 1.16   15 Mar 1993 22:21:04   BRADES
        use m_screen_pitch for the # pixels per display line
        
           Rev 1.15   08 Mar 1993 19:30:10   BRADES
        clean up, submit to MS NT
        
           Rev 1.13   19 Jan 1993 09:35:38   Robert_Wolff
        Removed commented-out code.
        
           Rev 1.12   13 Jan 1993 13:46:16   Robert_Wolff
        Added support for the Corsair and other machines where the aperture
        location is not kept in the EEPROM.
        
           Rev 1.11   06 Jan 1993 11:06:04   Robert_Wolff
        Eliminated dead code and compile warnings.
        
           Rev 1.10   24 Dec 1992 14:38:02   Chris_Brady
        fix up warnings
        
           Rev 1.9   09 Dec 1992 10:28:48   Robert_Wolff
        Mach 8 information gathering routines now accept a parameter to
        indicate whether 1280x1024 mode table should be ignored. This is
        because on cards with an old BIOS which can't do 1280x1024, the
        same mode table is used for 132 column text mode, so if we don't
        ignore the mode table we'd generate a garbage entry in the query
        structure.
        
           Rev 1.8   02 Dec 1992 18:26:08   Robert_Wolff
        On a Mach32 card with 1M of memory and 800x600 installed for
        a noninterlaced mode with a vertical frequency other than 56Hz,
        force the mode table for 800x600 16 bits per pixel to use the
        parameters for the 56Hz (lowest vertical frequency available for
        800x600) mode in the Programmer's Guide to the Mach 32 Registers.
        This is done because this hardware is unable to deliver video data
        fast enough to do 800x600 16 BPP in noninterlaced modes with a
        higher vertical frequency than 56Hz.
        
           Rev 1.7   27 Nov 1992 18:39:16   Chris_Brady
        update ASIC rev to 3.
        
           Rev 1.6   25 Nov 1992 09:37:58   Robert_Wolff
        Routine s_query() now accepts an extra parameter which tells it to
        check for modes available when VGA boundary is set to shared, rather
        than left at its current value. This is for use with programs that force
        the boundary to shared, so that they will have access to all modes.
        
           Rev 1.5   20 Nov 1992 16:01:52   Robert_Wolff
        Functions Query8514Ultra() and QueryGUltra() are now
        available to Windows NT driver.
        
           Rev 1.4   17 Nov 1992 17:16:18   Robert_Wolff
        Fixed gathering of CRT parameters for 68800 card with minimal
        install (EEPROM blank, then predefined monitor type selected).
        
           Rev 1.3   13 Nov 1992 17:10:20   Robert_Wolff
        Now includes 68801.H, which consists of the now-obsolete MACH8.H
        and elements moved from VIDFIND.H.
        
           Rev 1.2   12 Nov 1992 17:10:32   Robert_Wolff
        Same source file can now be used for both Windows NT driver and
        VIDEO.EXE test program. Code specific to one or the other is
        under conditional compilation.
        
           Rev 1.1   06 Nov 1992 19:04:28   Robert_Wolff
        Moved prototypes for routines to initialize DAC to specified pixel
        depths to VIDFIND.H.
    
           Rev 1.0   05 Nov 1992 14:03:40   Robert_Wolff
        Initial revision.
        
           Rev 1.4   15 Oct 1992 16:26:36   Robert_Wolff
        Now builds one mode table for each resolution/colour depth
        combination, rather than one for each resolution. Mode tables
        no longer trash memory beyond the query structure.
        
           Rev 1.3   01 Oct 1992 17:31:08   Robert_Wolff
        Routines get_num_modes() and s_query() now count only those modes
        which are available with the monitor selected in "Power on configuration"
        when the install program is run.
        
           Rev 1.2   01 Oct 1992 15:23:54   Robert_Wolff
        Now handles the case where EEPROM values are stored in VGA format
        rather than 8514 format, Mach 32 card with shared memory now reports
        VGA boundary as 0 rather than -256.
        
           Rev 1.1   09 Sep 1992 17:42:40   Chris_Brady
        CRTC table for Graphics Ultra NOT enabled if == 0xFFFF
        
           Rev 1.0   02 Sep 1992 12:12:26   Chris_Brady
        Initial revision.
        

End of PolyTron RCS section                             *****************/

#ifdef DOC
    QUERY_M.C - Functions to find out the configuration of 8514/A-compatible
                ATI accelerators.

#endif

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "dderror.h"
#include "miniport.h"
#include "ntddvdeo.h"
#include "video.h"

#include "stdtyp.h"

#include "amach.h"
#include "amach1.h"
#include "atimp.h"
#include "atint.h"
#include "cvtvga.h"
#include "eeprom.h"

#define INCLUDE_QUERY_M
#include "modes_m.h"
#include "query_m.h"
#include "services.h"
#include "setup_m.h"

/*
 * String written to the aperture to see if we can read it back, and
 * its length (including the null terminator).
 */
#define APERTURE_TEST       "ATI"
#define APERTURE_TEST_LEN   4

//  
// HACK to remove call to exallocate pool
//  

UCHAR gBiosRaw[QUERYSIZE];

//----------------------------------------------------------------------
//  Local  Prototyping statements

static void short_query_m (struct query_structure *query, struct st_eeprom_data *ee);
short   fill_mode_table_m (WORD, struct st_mode_table *, struct st_eeprom_data *);
BOOL BiosFillTable_m(short, PUCHAR, struct st_mode_table *, struct query_structure *);
static UCHAR BrooktreeOrATT_m(void);
static void ClrDacCmd_m(BOOL ReadIndex);
static BOOL ChkATTDac_m(BYTE MaskVal);
static UCHAR ThompsonOrATT_m(void);
static UCHAR SierraOrThompson_m(void);
short GetTrueMemSize_m(void);
void SetupRestoreEngine_m(int DesiredStatus);
USHORT ReadPixel_m(short XPos, short YPos);
void WritePixel_m(short XPos, short YPos, short Colour);
void SetupRestoreVGAPaging_m(int DesiredStatus);


/*
 * Allow miniport to be swapped out when not needed.
 */
#if defined (ALLOC_PRAGMA)
#pragma alloc_text(PAGE_M, Query8514Ultra)
#pragma alloc_text(PAGE_M, QueryGUltra)
#pragma alloc_text(PAGE_M, short_query_m)
#pragma alloc_text(PAGE_M, QueryMach32)
#pragma alloc_text(PAGE_M, fill_mode_table_m)
#pragma alloc_text(PAGE_M, BiosFillTable_m)
#pragma alloc_text(PAGE_M, BrooktreeOrATT_m)
#pragma alloc_text(PAGE_M, ChkATTDac_m)
#pragma alloc_text(PAGE_M, ClrDacCmd_m)
#pragma alloc_text(PAGE_M, ThompsonOrATT_m)
#pragma alloc_text(PAGE_M, SierraOrThompson_m)
#pragma alloc_text(PAGE_M, GetTrueMemSize_m)
#pragma alloc_text(PAGE_M, SetupRestoreEngine_m)
#pragma alloc_text(PAGE_M, ReadPixel_m)
#pragma alloc_text(PAGE_M, WritePixel_m)
#pragma alloc_text(PAGE_M, BlockWriteAvail_m)
#pragma alloc_text(PAGE_M, IsMioBug_m)
#endif



//----------------------------------------------------------------------
//                        Query8514Ultra
//  
//  Fill in the query structure with the eeprom and register info
//  for the 8514/Ultra  adapters.
//
//  Returns:
//      NO_ERROR if successful
//      ERROR_DEV_NOT_EXIST if unable to read EEPROM
//  

VP_STATUS Query8514Ultra (struct query_structure *query)
{
//  8514/Ultra initially only supported 1024x768 and 640x480.
//  Later 800x600 and then 1280x1024 support was added.

struct st_eeprom_data *ee = phwDeviceExtension->ee;
BOOL    is800, is1280;
WORD    jj, kk;
struct st_mode_table *pmode;    /* CRT table parameters */
long    MemAvail;   /* Bytes of memory available for the accelerator */
struct st_mode_table    ThisRes;    /* Mode table for the given resolution */


    query->q_structure_rev      = 0;
    query->q_mode_offset        = sizeof(struct query_structure);
    query->q_sizeof_mode        = sizeof(struct st_mode_table);
    query->q_status_flags       = 0;            // will indicate resolutions 

    query->q_mouse_cfg = 0;             // no MOUSE
    query->q_DAC_type  = DAC_ATI_68830; // one DAC type similar to 68830
    query->q_aperture_addr = 0;         // no aperture address
    query->q_aperture_cfg  = 0;         // no aperture configuration
    query->q_asic_rev  = CI_38800_1;    // only one ASIC revision  

    query->q_VGA_type = 0;              // 8514_ONLY == no VGA ever installed
    query->q_VGA_boundary = 0;      /* No VGA, so accelerator gets all the memory */

    kk = INPW (CONFIG_STATUS_1);
    query->q_memory_size = (kk & MEM_INSTALLED) ? VRAM_1mb : VRAM_512k;
    query->q_memory_type = (kk & DRAM_ENA) ? VMEM_DRAM_256Kx4 : VMEM_VRAM_256Kx4_SER512; 

    if (kk & MC_BUS)                    // is microchannel bus
        query->q_bus_type = BUS_MC_16;  // 16 bit bus
    else
        query->q_bus_type = kk & BUS_16 ? BUS_ISA_16 : BUS_ISA_8;

    /*
     * We don't use the q_monitor_alias field, so plug in a typical
     * value rather than reading it from the EEPROM, in case we are
     * dealing with a card that doesn't have an EEPROM.
     */
    query->q_monitor_alias = 0x0F;
    query->q_shadow_1  = 0;             // do not know what to put here
    query->q_shadow_2  = 0;

    /*
     * Record the number of bytes available for the coprocessor, so we
     * can determine what pixel depths are available at which resolutions.
     */
    MemAvail = (query->q_memory_size == VRAM_1mb) ? ONE_MEG : HALF_MEG;

    /*
     * If the EEPROM is not present, we can't fill in the mode
     * tables. Return and let the user know that the mode tables
     * have not been filled in.
     */
    if (query->q_eeprom == FALSE)
        return ERROR_DEV_NOT_EXIST;

    /*
     * Fill in the mode tables. The mode tables are sorted in increasing
     * order of resolution, and in increasing order of pixel depth.
     * Ensure pmode is initialized to the END of query structure
     */
    pmode = (struct st_mode_table *) query;
    ((struct query_structure *) pmode)++;

    /*
     * Initially assume 640x480 4BPP.
     */
    query->q_number_modes = 1;
    query->q_status_flags |= VRES_640x480;

    ThisRes.control = 0x140;    // no equal to 68800 CRT 0 entry
    ThisRes.m_reserved = 3;     /* Put EEPROM base address here, shadow sets are combined */
    jj = (ee->EEread) (3);      /* Composite and Vfifo */
    kk = (ee->EEread) (4);      /* Clock select and divisor */
    ThisRes.m_clock_select = ((jj & 0x1F) << 8) | ((kk & 0x003F) << 2);
    ThisRes.ClockFreq = GetFrequency((BYTE)((ThisRes.m_clock_select & 0x007C) >> 2));

    /*
     * The COMPOSITE_SYNC bit of the m_clock_select field is set up
     * to handle composite sync with shadow sets. We use the primrary
     * CRT register set, so we must invert it.
     */
    ThisRes.m_clock_select ^= 0x1000;

    kk = (ee->EEread) (17);                     // H_total
    ThisRes.m_h_total =  kk & 0xFF;
    kk = (ee->EEread) (16);                     // H_display
    ThisRes.m_h_disp  =  kk & 0xFF;
    ThisRes.m_x_size  = (ThisRes.m_h_disp+1) * 8;
    ThisRes.m_screen_pitch = ThisRes.m_x_size;

    kk = (ee->EEread) (15);                     // H_sync_strt
    ThisRes.m_h_sync_strt =  kk & 0xFF;

    kk = (ee->EEread) (14);                     // H_sync_width
    ThisRes.m_h_sync_wid  =  kk & 0xFF;

    kk = (ee->EEread) (7);                      // V_sync_width
    ThisRes.m_v_sync_wid =  kk & 0xFF;

    kk = (ee->EEread) (6);                      // Display_cntl
    ThisRes.m_disp_cntl  =  kk & 0xFF;

    ThisRes.m_v_total = (ee->EEread) (13);
    ThisRes.m_v_disp  = (ee->EEread) (11);
    ThisRes.m_y_size  = (((ThisRes.m_v_disp >> 1) & 0xFFFC) | (ThisRes.m_v_disp & 0x03)) +1;

    ThisRes.m_v_sync_strt = (ee->EEread) (9);

    ThisRes.enabled  = 0x80;            // use stored values from eeprom

    ThisRes.m_status_flags = 0;

    ThisRes.m_h_overscan  = 0;     // not supported
    ThisRes.m_v_overscan  = 0;
    ThisRes.m_overscan_8b = 0;
    ThisRes.m_overscan_gr = 0;
    ThisRes.m_vfifo_24    = 0;   
    ThisRes.m_vfifo_16    = 0;
    ThisRes.Refresh       = DEFAULT_REFRESH;

    /*
     * Copy the mode table we have just built into the 4 BPP
     * mode table, and fill in the pixel depth field.
     */
    VideoPortMoveMemory(pmode, &ThisRes, sizeof(struct st_mode_table));
    pmode->m_pixel_depth = 4;
    pmode++;

    /*
     * We don't support 640x480 256 colour minimum mode, so 8BPP
     * is only available on 1M cards.
     */
    if (query->q_memory_size == VRAM_1mb)
        {
        VideoPortMoveMemory(pmode, &ThisRes, sizeof(struct st_mode_table));
        pmode->m_pixel_depth = 8;
        pmode++;
        query->q_number_modes++;
        }

    /*
     * Look for more mode tables defined.  Original 8514 did not define these
     *   -- undefined if = 0xFFFF
     *
     * Some cards with a BIOS too early to support 1280x1024 use the
     * same mode table for 132 column text mode. On these cards,
     * query->q_ignore1280 will be TRUE when this function is called.
     */
    kk = (ee->EEread) (20);             // are 800 and 1280 defined ??
    jj = kk & 0xFF00;                   // 1280 by 1024
    kk &= 0xFF;                         // 800 by 600
    if ((kk == 0) || (kk == 0xFF))
        is800 = FALSE;
    else
        is800 = TRUE;
    if ((jj == 0) || (jj == 0xFF00) || (query->q_ignore1280 == TRUE))
        is1280 = FALSE;
    else
        is1280 = TRUE;

    /*
     * If we support 800x600, fill in its mode tables. Both 4 and 8 BPP
     * can be handled by a 512k card.
     */
    if (is800)
        {
        query->q_status_flags |= VRES_800x600;

        ThisRes.control  = 0x140;                // no equal to 68800 CRT 0 entry
        ThisRes.m_reserved = 19;                 // shadow sets are combined

        jj = (ee->EEread) (19);                  // Composite and Vfifo
        kk = (ee->EEread) (20);                  // clock select and divisor
        ThisRes.m_clock_select = ((jj & 0x1F) << 8) | ((kk & 0x003F) << 2);
        ThisRes.m_clock_select ^= 0x1000;
        ThisRes.ClockFreq = GetFrequency((BYTE)((ThisRes.m_clock_select & 0x007C) >> 2));
    
        kk = (ee->EEread) (30);                  // H_total
        ThisRes.m_h_total = kk & 0xFF;
        kk = (ee->EEread) (29);                  // H_display
        ThisRes.m_h_disp  = kk & 0xFF;
        ThisRes.m_x_size  = (ThisRes.m_h_disp+1) * 8;
        // Mach8 must be a multiple of 128
        ThisRes.m_screen_pitch = 896;    
    
        kk = (ee->EEread) (28);                  // H_sync_strt
        ThisRes.m_h_sync_strt = kk & 0xFF;
    
        kk = (ee->EEread) (27);                  // H_sync_width
        ThisRes.m_h_sync_wid  = kk & 0xFF;
    
        kk = (ee->EEread) (23);                  // V_sync_width
        ThisRes.m_v_sync_wid = kk & 0xFF;
    
        kk = (ee->EEread) (22);                  // Display_cntl
        ThisRes.m_disp_cntl  = kk & 0xFF;
    
        ThisRes.m_v_total = (ee->EEread) (26);
        ThisRes.m_v_disp  = (ee->EEread) (25);
        ThisRes.m_y_size  = (((ThisRes.m_v_disp >> 1) & 0xFFFC) | (ThisRes.m_v_disp & 0x03)) +1;
    
        ThisRes.m_v_sync_strt = (ee->EEread) (24);
    
        ThisRes.enabled  = 0x80;       // use stored values from eeprom

        ThisRes.m_status_flags = 0;
        ThisRes.m_h_overscan  = 0;     // not supported
        ThisRes.m_v_overscan  = 0;
        ThisRes.m_overscan_8b = 0;
        ThisRes.m_overscan_gr = 0;
        ThisRes.m_vfifo_24    = 0;   
        ThisRes.m_vfifo_16    = 0;
        ThisRes.Refresh       = DEFAULT_REFRESH;

        /*
         * Copy the mode table we have just built into the 4 and 8 BPP
         * mode tables, and fill in the pixel depth field of each.
         */
        VideoPortMoveMemory(pmode, &ThisRes, sizeof(struct st_mode_table));
        pmode->m_pixel_depth = 4;
        pmode++;
        query->q_number_modes++;
        /*
         * 800x600 8BPP needs 1M because it is actually 896x600
         * (screen pitch must be a multiple of 128).
         */
        if (MemAvail == ONE_MEG)
            {
            VideoPortMoveMemory(pmode, &ThisRes, sizeof(struct st_mode_table));
            pmode->m_pixel_depth = 8;
            pmode++;
            query->q_number_modes++;
            }
        }

    /*
     * Take care of 1024x768, which is always supported (even though
     * a 512k card can only do 4 BPP).
     */
    query->q_status_flags |= VRES_1024x768;

    ThisRes.control = 0x140;    // no equal to 68800 CRT 0 entry
    ThisRes.m_reserved = 3;     /* Put EEPROM base address here, shadow sets are combined */
    ThisRes.enabled  = 0x80;    /* Use stored values from EEPROM */

    kk = (ee->EEread) (16);                     // H_display
    ThisRes.m_h_disp  = (kk >> 8) & 0xFF;

    /*
     * An 8514/ULTRA configured for a monitor which does not support
     * 1024x768 will have the 640x480 parameters in the high-res
     * shadow set. Force the use of 1024x768 87Hz interlaced instead.
     */
    if (ThisRes.m_h_disp != 0x7F)
        {
        BookVgaTable(B1024F87, &ThisRes);
        ThisRes.m_screen_pitch = ThisRes.m_x_size;
        }
    else{
        /*
         * Configured for a monitor which supports 1024x768,
         * so use actual parameters.
         */
        jj = (ee->EEread) (3);                  /* Composite and Vfifo */
        kk = (ee->EEread) (4);                  /* Clock select and divisor */
        ThisRes.m_clock_select = (jj & 0x1F00) | ((kk & 0x3F00) >> 6);
        ThisRes.m_clock_select ^= 0x1000;
        ThisRes.ClockFreq = GetFrequency((BYTE)((ThisRes.m_clock_select & 0x007C) >> 2));

        kk = (ee->EEread) (17);                 // H_total
        ThisRes.m_h_total = (kk >> 8) & 0xFF;
        ThisRes.m_x_size  = (ThisRes.m_h_disp+1) * 8;
        ThisRes.m_screen_pitch = ThisRes.m_x_size;

        kk = (ee->EEread) (15);                 // H_sync_strt
        ThisRes.m_h_sync_strt = (kk >> 8) & 0xFF;

        kk = (ee->EEread) (14);                 // H_sync_width
        ThisRes.m_h_sync_wid  = (kk >> 8) & 0xFF;

        kk = (ee->EEread) (7);                  // V_sync_width
        ThisRes.m_v_sync_wid = (kk >> 8) & 0xFF;

        kk = (ee->EEread) (6);                  // Display_cntl
        ThisRes.m_disp_cntl  = (kk >> 8) & 0xFF;

        ThisRes.m_v_total = (ee->EEread) (12);
        ThisRes.m_v_disp  = (ee->EEread) (10);
        ThisRes.m_y_size  = (((ThisRes.m_v_disp >> 1) & 0xFFFC) | (ThisRes.m_v_disp & 0x03)) +1;

        ThisRes.m_v_sync_strt = (ee->EEread) (8);

        ThisRes.m_status_flags = 0;

        ThisRes.m_h_overscan  = 0;     // not supported
        ThisRes.m_v_overscan  = 0;
        ThisRes.m_overscan_8b = 0;
        ThisRes.m_overscan_gr = 0;
        ThisRes.m_vfifo_24    = 0;   
        ThisRes.m_vfifo_16    = 0;
        }

    ThisRes.Refresh = DEFAULT_REFRESH;

    /*
     * Copy the mode table we have just built into the 4 and 8 BPP
     * mode tables.
     */
    VideoPortMoveMemory(pmode, &ThisRes, sizeof(struct st_mode_table));
    pmode->m_pixel_depth = 4;
    pmode++;
    query->q_number_modes++;

    if (MemAvail == ONE_MEG)            // 1024 needs this memory amount
        {
        VideoPortMoveMemory(pmode, &ThisRes, sizeof(struct st_mode_table));
        pmode->m_pixel_depth = 8;
        pmode++;
        query->q_number_modes++;
        }

    // Finally do 1280x1024. 4 bpp is the only color depth supported
    if (is1280 && (MemAvail == ONE_MEG))
        {
        query->q_number_modes++;
        query->q_status_flags |= VRES_1280x1024;

        pmode->control  = 0x140;                // no equal to 68800 CRT 0 entry
        pmode->m_pixel_depth = 4;               // 4 bits per pixel
        pmode->m_reserved = 19;                 // shadow sets are combined

        jj = (ee->EEread) (19);                 // Composite and Vfifo
        kk = (ee->EEread) (20);                 // clock select and divisor
        pmode->m_clock_select = (jj & 0x1F00) | ((kk & 0x3F00) >> 6);
        pmode->m_clock_select ^= 0x1000;
        ThisRes.ClockFreq = GetFrequency((BYTE)((ThisRes.m_clock_select & 0x007C) >> 2));
    
        kk = (ee->EEread) (30);                 // H_total
        pmode->m_h_total = (kk >> 8) & 0xFF;
        kk = (ee->EEread) (29);                 // H_display
        pmode->m_h_disp  = (kk >> 8) & 0xFF;
        pmode->m_x_size  = (pmode->m_h_disp+1) * 8;
        pmode->m_screen_pitch = pmode->m_x_size;
    
        kk = (ee->EEread) (28);                 // H_sync_strt
        pmode->m_h_sync_strt = (kk >> 8) & 0xFF;
    
        kk = (ee->EEread) (27);                 // H_sync_width
        pmode->m_h_sync_wid  = (kk >> 8) & 0xFF;
    
        kk = (ee->EEread) (23);                 // V_sync_width
        pmode->m_v_sync_wid = (kk >> 8) & 0xFF;
    
        kk = (ee->EEread) (22);                 // Display_cntl
        pmode->m_disp_cntl  = (kk >> 8) & 0xFF;
    
        pmode->m_v_total = (ee->EEread) (51);
        pmode->m_v_disp  = (ee->EEread) (50);
        pmode->m_y_size  = (((pmode->m_v_disp >> 1) & 0xFFFC) | (pmode->m_v_disp & 0x03)) +1;
    
        pmode->m_v_sync_strt = (ee->EEread) (49);
    
        pmode->enabled  = 0x80;       // use stored values from eeprom

        pmode->m_status_flags = 0;
        pmode->m_h_overscan  = 0;     // not supported
        pmode->m_v_overscan  = 0;
        pmode->m_overscan_8b = 0;
        pmode->m_overscan_gr = 0;
        pmode->m_vfifo_24    = 0;   
        pmode->m_vfifo_16    = 0;
        pmode->Refresh       = DEFAULT_REFRESH;
        }

    query->q_sizeof_struct = query->q_number_modes * sizeof(struct st_mode_table) + sizeof(struct query_structure);

    return NO_ERROR;

}   /* Query8514Ultra */



//----------------------------------------------------------------------
//                        QueryGUltra
//  
//  Fill in the query structure with the eeprom and register info
//  for the Graphics Ultra  adapters.  (Similar to Mach32 layout)
//  There are a maximum of 7 mode tables, two each for 640x480,
//  800x600, and 1024x768, and one for 1280x1024.
//
//  Returns:
//      NO_ERROR if successful
//      ERROR_DEV_NOT_EXIST if EEPROM read fails
//  

VP_STATUS QueryGUltra (struct query_structure *query)
{

struct st_eeprom_data *ee = phwDeviceExtension->ee;
short   crttable[4] = {13, 24, 35, 46};         // start of eeprom crt table
WORD    ee_value, table_offset,  jj, kk, ee_word;
BYTE    bhigh, blow;
struct st_mode_table *pmode;                    // CRT table parameters
short   VgaTblEntry;    /* VGA parameter table entry to use if translation needed */
short   BookTblEntry;   /* Appendix D parameter table entry to use if parameters not in EEPROM */
long    NumPixels;  /* Number of pixels at the selected resolution */
long    MemAvail;   /* Bytes of memory available for the accelerator */
struct st_mode_table    ThisRes;    /* Mode table for the given resolution */
BYTE    VgaMem;     /* Code for amount of VGA memory on board */


    query->q_structure_rev      = 0;
    query->q_mode_offset        = sizeof(struct query_structure);
    query->q_sizeof_mode        = sizeof(struct st_mode_table);
    query->q_status_flags       = 0;            // will indicate resolutions

    /*
     * We don't use the q_mouse_cfg field, so fill in a typical value
     * (mouse disabled) rather than reading from the EEPROM in case we
     * are dealing with a card without an EEPROM.
     */
    kk = 0x0000;
    bhigh    = (kk >> 8) & 0xFF;
    blow     = kk & 0xFF;
    query->q_mouse_cfg = (bhigh >> 3) | ((blow & 0x18) >> 1);    // mouse configuration

    query->q_DAC_type  = DAC_ATI_68830; // one DAC type similar to 68830
    query->q_aperture_addr = 0;         // no aperture address
    query->q_aperture_cfg  = 0;         // no aperture configuration
    query->q_asic_rev  = CI_38800_1;    // only one ASIC revision  

    query->q_VGA_type = 1;              // VGA always Enabled

    OUTP (ati_reg, 0xB0);		    // find out how much VGA memory
    VgaMem = INP(ati_reg+1);
    switch (VgaMem & 0x18)
        {
        case 0x00:          
            jj =  256;      
            query->q_VGA_boundary = VRAM_256k;
            break;

        case 0x10:          
            jj =  512;      
            query->q_VGA_boundary = VRAM_512k;
            break;

        case 0x08:          
            jj = 1024;      
            query->q_VGA_boundary = VRAM_1mb; 
            break;

        default:            // assume most likely VGA amount
            jj = 512;
            query->q_VGA_boundary = VRAM_512k;
            break;
        }

    kk = INPW (CONFIG_STATUS_1);
    query->q_memory_type = kk & DRAM_ENA ? VMEM_DRAM_256Kx4 : VMEM_VRAM_256Kx4_SER512; 
    jj += (kk & MEM_INSTALLED) ? 1024 : 512;            // 8514 memory
    switch (jj)
        {
        case  0x300:
            jj = VRAM_768k;
            MemAvail = HALF_MEG;            // Accelerator amount
            break;

        case  0x400:
            jj = VRAM_1mb;
            MemAvail = HALF_MEG;            // Accelerator amount
            break;

        case  0x500:
            jj = VRAM_1_25mb;
            MemAvail = ONE_MEG;
            break;

        case  0x600:
            jj = VRAM_1_50mb;
            if (query->q_VGA_boundary == VRAM_1mb)
                    MemAvail = HALF_MEG;        // Accelerator amount
            else    MemAvail = ONE_MEG;
            break;

        case  0x800:
            jj = VRAM_2mb;
            MemAvail = ONE_MEG;
            break;
        }
    query->q_memory_size = (UCHAR)jj;

    if (kk & MC_BUS)                    // is microchannel bus
        query->q_bus_type = BUS_MC_16;  // 16 bit bus
    else
        query->q_bus_type = kk & BUS_16 ? BUS_ISA_16 : BUS_ISA_8;

    /*
     * We don't use the q_monitor_alias field, so fill in a typical
     * value rather than reading from the EEPROM in case we are
     * dealing with a card without an EEPROM.
     */
    query->q_monitor_alias = 0x0F;
    query->q_shadow_1  = 0;             // do not know what to put here
    query->q_shadow_2  = 0;


    /*
     * If the EEPROM is not present, we can't fill in the mode
     * tables. Return and let the user know that the mode tables
     * have not been filled in.
     */
    if (query->q_eeprom == FALSE)
        return ERROR_DEV_NOT_EXIST;

    /*
     * Fill in the mode tables. The mode tables are sorted in increasing
     * order of resolution, and in increasing order of pixel depth.
     * Ensure pmode is initialized to the END of query structure
     */
    pmode = (struct st_mode_table *) query;
    ((struct query_structure *) pmode)++;     // first  mode table at end of query
    query->q_number_modes       = 0;

    ee_word = 7;            // starting ee word to read, 7,8,9 and 10 are 
                            // the resolutions supported.

    for (jj=0; jj < 4; jj++, ee_word++)
        {
        ee_value = (ee->EEread) (ee_word);

        /*
         * If no 1024x768 mode is configured, assume that
         * 87Hz interlaced is avialable (Windows 3.1 compatibility).
         */
        if ((ee_word == 9) && !(ee_value & 0x001F))
            ee_value |= M1024F87;

        table_offset = crttable[jj];    // offset to resolution table

        /*
         * If we have found a resolution which is supported with
         * the currently installed card and monitor, set the flag
         * to show that this resolution is available, record which
         * VGA parameter table to use if translation is needed,
         * get the #define for the 4BPP mode at that resolution,
         * and get the pixel count for the resolution.
         *
         * In 640x480, ee_value will be zero if IBM Default
         * was selected for vertical scan frequency,
         * For all other resolutions, the resolution is unsupported if
         * ee_value is zero.
         *
         * Some Graphics Ultra cards (due to an early BIOS)
         * have a 132 column text mode where the 1280x1024
         * graphics mode should be. If we have one of these
         * cards, we must treat it as if the mode table
         * were empty, otherwise we'd generate a 1280x1024
         * mode table full of garbage values.
         */
        if ((ee_value | (jj == 0))
            && !((ee_word == 10) && (query->q_ignore1280 == TRUE)))
            {    
            switch (ee_word)
                {
                case 7:
                    query->q_status_flags |= VRES_640x480;
                    ThisRes.m_screen_pitch = 640;
                    if (ee_value & M640F72)
                        {
                        VgaTblEntry = T640F72;
                        BookTblEntry = B640F72;
                        }
                    else{
                        VgaTblEntry = T640F60;
                        BookTblEntry = B640F60;
                        }
                    NumPixels = (long) 640*480;
                    break;

                case 8:
                    query->q_status_flags |= VRES_800x600;
                    // mach8 must be multiple of 128
                    ThisRes.m_screen_pitch = 896;  
                    if (ee_value & M800F72)
                        {
                        VgaTblEntry = T800F72;
                        BookTblEntry = B800F72;
                        }
                    else if (ee_value & M800F70)
                        {
                        VgaTblEntry = T800F70;
                        BookTblEntry = B800F70;
                        }
                    else if (ee_value & M800F60)
                        {
                        VgaTblEntry = T800F60;
                        BookTblEntry = B800F60;
                        }
                    else if (ee_value & M800F56)
                        {
                        VgaTblEntry = T800F56;
                        BookTblEntry = B800F56;
                        }
                    else if (ee_value & M800F89)
                        {
                        VgaTblEntry = T800F89;
                        BookTblEntry = B800F89;
                        }
                    else if (ee_value & M800F95)
                        {
                        VgaTblEntry = T800F95;
                        BookTblEntry = B800F95;
                        }
                    else
                        {
                        VgaTblEntry = NO_TBL_ENTRY;
                        BookTblEntry = NO_TBL_ENTRY;
                        }
                    NumPixels = (long) ThisRes.m_screen_pitch*600;
                    break;

                case 9:
                    query->q_status_flags |= VRES_1024x768;
                    ThisRes.m_screen_pitch = 1024;  
                    if (ee_value & M1024F66)
                        {
                        VgaTblEntry = T1024F66;
                        BookTblEntry = B1024F66;
                        }
                    else if (ee_value & M1024F72)
                        {
                        VgaTblEntry = T1024F72;
                        BookTblEntry = B1024F72;
                        }
                    else if (ee_value & M1024F70)
                        {
                        VgaTblEntry = T1024F70;
                        BookTblEntry = B1024F70;
                        }
                    else if (ee_value & M1024F60)
                        {
                        VgaTblEntry = T1024F60;
                        BookTblEntry = B1024F60;
                        }
                    else if (ee_value & M1024F87)
                        {
                        VgaTblEntry = T1024F87;
                        BookTblEntry = B1024F87;
                        }
                    else
                        {
                        VgaTblEntry = NO_TBL_ENTRY;
                        BookTblEntry = NO_TBL_ENTRY;
                        }
                    NumPixels = (long) 1024*768;
                    break;

                case 10:
                    query->q_status_flags |= VRES_1280x1024;
                    ThisRes.m_screen_pitch = 1280;  
                    if (ee_value & M1280F95)
                        {
                        VgaTblEntry = T1280F95;
                        BookTblEntry = B1280F95;
                        }
                    else if (ee_value & M1280F87)
                        {
                        VgaTblEntry = T1280F87;
                        BookTblEntry = B1280F87;
                        }
                    else
                        {
                        VgaTblEntry = NO_TBL_ENTRY;
                        BookTblEntry = NO_TBL_ENTRY;
                        }
                    NumPixels = (long) 1280*1024;
                    break;
                }

            /*
             * For a given resolution, there will be one mode table
             * per colour depth. Replicate it for ALL pixel depths
             */
            ThisRes.enabled = ee_value;     /* Which vertical scan frequency */
            ThisRes.m_reserved = table_offset;  /* Put EEPROM base address here */

        
            /*
             * Assume that the EEPROM parameters are in 8514 format
             * and try to fill the pmode table. If they are in
             * VGA format, translate them and fill as much of the
             * table as we can.
             * The case where the CRT parameters aren't stored in
             * the EEPROM is handled inside XlateVgaTable().
             * If the parameters aren't stored in the EEPROM, 
             * both the FMT_8514 bit and the CRTC_USAGE bit 
             * will be clear.
             */
            if (!fill_mode_table_m (table_offset, &ThisRes, ee))
                {
                XlateVgaTable(phwDeviceExtension, table_offset, &ThisRes, VgaTblEntry, BookTblEntry, ee, FALSE);
                }
            else{
                ThisRes.m_h_overscan  = 0;
                ThisRes.m_v_overscan  = 0;
                ThisRes.m_overscan_8b = 0;
                ThisRes.m_overscan_gr = 0;
                }

            ThisRes.Refresh = DEFAULT_REFRESH;

            /*
             * The COMPOSITE_SYNC bit of the m_clock_select field is
             * set up to handle composite sync with shadow sets. We use
             * the primrary CRT register set, so we must invert it.
             */
            ThisRes.m_clock_select ^= 0x1000;

            ThisRes.m_status_flags = 0;
            ThisRes.m_vfifo_24 = 0;
            ThisRes.m_vfifo_16 = 0;

            /*
             * For each supported pixel depth at the given resolution,
             * copy the mode table, fill in the colour depth field, set
             * a flag to show that this resolution/depth pair is supported,
             * and increment the counter for the number of supported modes.
             * Test 4BPP before 8BPP so the mode tables will appear in
             * increasing order of pixel depth.
             *
             * We don't support 640x480 256 colour minimum mode, so there
             * are no 8BPP modes available on a 512k card.
             */
            if (NumPixels <= MemAvail*2)
                {
                VideoPortMoveMemory(pmode, &ThisRes, sizeof(struct st_mode_table));
                pmode->m_pixel_depth = 4;
                query->q_number_modes++;
                pmode++;
                }

            if ((NumPixels <= MemAvail) && (MemAvail == ONE_MEG))
                {
                VideoPortMoveMemory(pmode, &ThisRes, sizeof(struct st_mode_table));
                pmode->m_pixel_depth = 8;
                query->q_number_modes++;
                pmode++;
                }

            }
        }
    query->q_sizeof_struct = query->q_number_modes * sizeof(struct st_mode_table) + sizeof(struct query_structure);

    return NO_ERROR;

}   /* QueryGUltra */


//----------------------------------------------------------------------
//;   QueryMach32                   Mach32 -- 68800 query function
//;
//;   INPUT: QUERY_GET_SIZE, return query structure size   (varying modes)
//;          QUERY_LONG    , return query structure filled in
//;          QUERY_SHORT   , return short query
//;
//;   OUTPUT: ax = size of query structure
//;       or  query structure is filled in
//----------------------------------------------------------------------
                

static void short_query_m (struct query_structure *query, struct st_eeprom_data *ee)
{
WORD    kk;
BYTE    bhigh, blow;
WORD    ApertureLocation;   /* Aperture location, in megabytes */

    
    /*
     * We don't use the q_mouse_cfg field, so fill in a typical value
     * (mouse disabled) rather than reading from the EEPROM in case we
     * are dealing with a card without an EEPROM.
     */
    kk = 0x0000;
    bhigh    = (kk >> 8) & 0xFF;
    blow     = kk & 0xFF;

    query->q_mouse_cfg = (bhigh >> 3) | ((blow & 0x18) >> 1);    // mouse configuration
    kk	= INPW (CONFIG_STATUS_1);		    // get DAC type
    query->q_DAC_type  = ((kk >> 8) & 0x0E) >> 1;

    /*
     * The BT48x and AT&T 491/2/3 families of DAC are incompatible, but
     * CONFIG_STATUS_1 reports the same value for both. If this value
     * was reported, determine which DAC type we have.
     */
    if (query->q_DAC_type == DAC_BT48x)
        query->q_DAC_type = BrooktreeOrATT_m();
    /*
     * The STG1700 and AT&T498 are another pair of incompatible DACs that
     * share a reporting code.
     */
    else if (query->q_DAC_type == DAC_STG1700)
        query->q_DAC_type = ThompsonOrATT_m();

    /*
     * The SC15021 and STG1702/1703 are yet another pair of DACs that
     * share a reporting code.
     */
    else if (query->q_DAC_type == DAC_SC15021)
        query->q_DAC_type = SierraOrThompson_m();

    /*
     * Chip subfamily is stored in bits 0-9 of ASIC_ID. Each subfamily
     * starts the revision counter over from 0.
     */
    switch (INPW(ASIC_ID) & 0x03FF)
        {
        /*
         * 68800-3 does not implement this register, a read returns
         * all 0 bits.
         */
        case 0:
            query->q_asic_rev = CI_68800_3;
            break;

        /*
         * Subsequent revisions of 68800 store the revision count.
         * 68800-6 stores a "2" in the top 4 bits.
         */
        case 0x2F7:
            VideoDebugPrint(( DEBUG_DETAIL, "ASIC_ID = 0x%X\n", INPW(ASIC_ID) ));
            if ((INPW(ASIC_ID) & 0x0F000) == 0x2000)
                {
                query->q_asic_rev = CI_68800_6;
                }
            else
                {
                query->q_asic_rev = CI_68800_UNKNOWN;
                VideoDebugPrint(( DEBUG_ERROR, "*/n*/n* ASIC_ID has invalid value/n*/n*/n"));
                }
            break;

        /*
         * 68800AX
         */
        case 0x17:
            query->q_asic_rev = CI_68800_AX;
            break;

        /*
         * Chips we don't know about yet.
         */
        default:
            query->q_asic_rev = CI_68800_UNKNOWN;
            VideoDebugPrint((DEBUG_ERROR, "*/n*/n* Unknown Mach 32 ASIC type/n*/n*/n"));
            break;
        }


    /*
     * If the query->q_m32_aper_calc field is set, then we read bits
     * 0-6 of the aperture address from bits 8-14 of MEM_CFG
     * and bits 7-11 from bits 0-4 of the high word of SCRATCH_PAD_0.
     */
    if (query->q_m32_aper_calc)
        {
        ApertureLocation = (INPW(MEM_CFG) & 0x7F00) >> 8;
        ApertureLocation |= ((INPW(SCRATCH_PAD_0) & 0x1F00) >> 1);
        }
    /*
     * If the query->q_m32_aper_calc field is clear, and we have an ASIC
     * other than 68800-3 set up to allow the aperture anywhere in the
     * CPU's address space, bits 0-11 of the aperture address are read
     * from bits 4-15 of MEM_CFG. PCI bus always uses this setup, even
     * if CONFIG_STATUS_2 says to use 128M aperture range.
     */
    else if (((query->q_asic_rev != CI_68800_3) && (INPW(CONFIG_STATUS_2) & 0x2000))
        || ((INPW(CONFIG_STATUS_1) & 0x0E) == 0x0E))
        {
        ApertureLocation = (INPW(MEM_CFG) & 0xFFF0) >> 4;
        }
    /*
     * If the query->q_m32_aper_calc field is clear, and we have either
     * a revision 0 ASIC or a newer ASIC set up for a limited range of
     * aperture locations, bits 0-7 of the aperture address are read
     * from bits 8-15 of MEM_CFG.
     */
    else
        {
    	ApertureLocation = (INPW(MEM_CFG) & 0xFF00) >> 8;
        }

#if !defined (i386) && !defined (_i386_)

    //RKE: MEM_CFG expect aperture location in <4:15> for PCI and <8:15>
    //     for VLB.
    kk = (query->q_system_bus_type == PCIBus)? 4:8;
#if defined (ALPHA)
    kk = 4; // Problem with alpha
#endif

    /*
     * Force aperture location to a fixed address.
     * Since there is no BIOS on Alpha, can't depend on MEM_CFG being preset.
     */
    ApertureLocation = 0x78;   // 120 Mb
    OUTPW(MEM_CFG, (USHORT)((ApertureLocation << kk) | 0x02));
    VideoDebugPrint(( DEBUG_DETAIL, "ATI.SYS: MEM_CFG = %x (%x)\n", 
                    (INPW(MEM_CFG)), ((ApertureLocation << kk) | 0x02) ));

#endif  /* defined Alpha */
    query->q_aperture_addr = ApertureLocation;

    /*
     * If the aperture address is zero, then the aperture has not
     * been set up. We can't use the aperture size field of
     * MEM_CFG, since it is cleared on system boot, disabling the
     * aperture until an application explicitly enables it.
     */
    if (ApertureLocation == 0)
        {
        query->q_aperture_cfg = 0;
        }
    /*
     * If the aperture has been set up and the card has no more
     * than 1M of memory, indicate that a 1M aperture could be
     * used, otherwise indicate that a 4M aperture is needed.
     *
     * In either case, set memory use to shared VGA/coprocessor.
     * When the aperture is enabled later in the execution of the
     * miniport, we will always use a 4M aperture. No address space
     * will be wasted, because we will only ask NT to use a block the
     * size of the installed video memory.
     *
     * The format of data in bits 2-15 of MEM_CFG differs
     * between various Mach 32 cards. To avoid having to identify
     * which Mach 32 we are dealing with, read the current value
     * and only change the aperture size bits.
     */
    else{
        if ((INP(MISC_OPTIONS) & MEM_SIZE_ALIAS) <= MEM_SIZE_1M) 
            query->q_aperture_cfg = 1;
        else
            query->q_aperture_cfg = 2;

        OUTP(MEM_BNDRY,0);
        }

    return;

}   /* short_query_m */


//---------------------------------------------------------------------

VP_STATUS   QueryMach32 (struct query_structure *query, BOOL ForceShared)
{
struct st_eeprom_data *ee = phwDeviceExtension->ee;
struct st_mode_table *pmode;
short   jj, kk, ee_word;
WORD    pitch, ee_value, table_offset, config_status_1, current_mode;
short   VgaTblEntry;  /* VGA parameter table entry to use if translation needed */
short   BookTblEntry;   /* Appendix D parameter table entry to use if parameters not in EEPROM */
long    NumPixels;  /* Number of pixels at the selected resolution */
long    MemAvail;   /* Bytes of memory available for the accelerator */
struct st_mode_table    ThisRes;    /* Mode table for the given resolution */
PUCHAR   BiosRaw;       /* Storage for information retrieved by BIOS call */
short   CurrentRes;     /* Array index based on current resolution. */
UCHAR   Scratch;        /* Scratch variable */
short   StartIndex;     /* First mode for SetFixedModes() to set up */
short   EndIndex;       /* Last mode for SetFixedModes() to set up */
BOOL    ModeInstalled;  /* Is this resolution configured? */
WORD    Multiplier;     /* Pixel clock multiplier */
short MaxModes;         /* Maximum number of modes possible */
short FreeTables;        /* Number of remaining free mode tables */



    /*
     * Checking the number of modes available would involve
     * duplicating most of the code to fill in the mode tables.
     * Since this is to determine how much memory is needed
     * to hold the query structure, we can assume the worst
     * case (all possible modes are present). This would be:
     *
     * Resolution   Pixel Depths (BPP)  Refresh rates (Hz)      Number of modes
     * 640x480      4,8,16,24           HWD,60,72               12
     * 800x600      4,8,16,24           HWD,56,60,70,72,89,95   28
     * 1024x768     4,8,16              HWD,60,66,70,72,87      18
     * 1280x1024    4,8                 HWD,60,70,74,87,95      12
     *
     * HWD = hardware default refresh rate (rate set by INSTALL)
     *
     * Total: 70 modes
     */
    if (QUERYSIZE < (70 * sizeof(struct st_mode_table) + sizeof(struct query_structure)))
        return ERROR_INSUFFICIENT_BUFFER;
    MaxModes = (QUERYSIZE - sizeof(struct query_structure)) /
                                          sizeof(struct st_mode_table); 

    query->q_structure_rev      = 0;
    query->q_mode_offset        = sizeof(struct query_structure);
    query->q_sizeof_mode        = sizeof(struct st_mode_table);

    query->q_number_modes = 0;  /* Initially assume no modes available */
    query->q_status_flags       = 0;            // will indicate resolutions 

    short_query_m (query, ee);

    config_status_1   = INPW (CONFIG_STATUS_1);
    query->q_VGA_type = config_status_1  & 0x01 ? 0 : 1;

    /*
     * If the program using this routine is going to force the
     * use of shared memory, assume a VGA boundary of 0 when
     * calculating the amount of available memory.
     */
    kk = INP (MEM_BNDRY);
    if ((kk & 0x10) && !ForceShared)
        query->q_VGA_boundary = kk & 0x0F;
    else    query->q_VGA_boundary = 0x00;       // shared by both

    switch (INPW(MISC_OPTIONS) & MEM_SIZE_ALIAS)
        {
        case  MEM_SIZE_512K:
            jj = VRAM_512k;
            MemAvail = HALF_MEG;
            VideoDebugPrint((DEBUG_NORMAL, "MISC_OPTIONS register reports 512k of video memory\n"));
            break;

        case  MEM_SIZE_1M:
            jj = VRAM_1mb;
            MemAvail = ONE_MEG;
            VideoDebugPrint((DEBUG_NORMAL, "MISC_OPTIONS register reports 1M of video memory\n"));
            break;

        case  MEM_SIZE_2M:
            jj = VRAM_2mb;
            MemAvail = 2*ONE_MEG;
            VideoDebugPrint((DEBUG_NORMAL, "MISC_OPTIONS register reports 2M of video memory\n"));
            break;

        case  MEM_SIZE_4M:
            jj = VRAM_4mb;
            MemAvail = 4*ONE_MEG;
            VideoDebugPrint((DEBUG_NORMAL, "MISC_OPTIONS register reports 4M of video memory\n"));
            break;
        }

    query->q_memory_type = (config_status_1 >> 4)  &  0x07;  // CONFIG_STATUS_1.MEM_TYPE

    /*
     * Some 68800-6 and later cards have a bug where one VGA mode (not used
     * by Windows NT VGA miniport, so we don't need to worry about it in
     * full-screen sessions) doesn't work properly if the card has more than
     * 1M of memory. The "fix" for this bug involves telling the memory size
     * field of MISC_OPTIONS to report a memory size smaller than the true
     * amount of memory (most cards with this "fix" report 1M, but some
     * only report 512k).
     *
     * On these cards (DRAM only), get the true memory size.
     *
     * On non-x86 platforms, GetTrueMemSize_m() may either hang
     * (MIPS) or report a false value (Alpha) (on the Power PC,
     * we only support Mach 64). Since we can't rely on the value
     * in MISC_OPTIONS being correct either (the video BIOS may
     * not be executed properly on startup, or we may have a card
     * that reports 1M instead of the true size), assume that
     * non-x86 machines have 2M of video memory available.
     */
#if defined (i386) || defined (_i386_)

    if (((query->q_asic_rev == CI_68800_6) || (query->q_asic_rev == CI_68800_AX)) &&
        (query->q_VGA_type == 1) &&
        ((query->q_memory_type == VMEM_DRAM_256Kx4) ||
         (query->q_memory_type == VMEM_DRAM_256Kx16) ||
         (query->q_memory_type == VMEM_DRAM_256Kx4_GRAP)))
        {
        jj = GetTrueMemSize_m();
        MemAvail = jj * QUARTER_MEG;
        }

#else   /* non-x86 system */

    jj = VRAM_2mb;
    MemAvail = 2*ONE_MEG;

#endif

    query->q_memory_size = (UCHAR)jj;

    /*
     * Subtract the "reserved for VGA" memory size from the total
     * memory to get the amount available to the accelerator.
     */
    MemAvail -= (query->q_VGA_boundary) * QUARTER_MEG;



    jj = (config_status_1 >> 1) & 0x07; // CONFIG_STATUS_1.BUS_TYPE
    if (jj == BUS_ISA_16)               // is ISA bus
        {
        if (query->q_VGA_type)          // is VGA enabled  and  ISA BUS
            jj = BUS_ISA_8;
        }
    query->q_bus_type = (UCHAR)jj;

    /*
     * We don't use the q_monitor_alias field, so fill in a typical
     * value rather than reading from the EEPROM in case we are
     * dealing with a card without an EEPROM.
     */
    query->q_monitor_alias = 0x0F;

    kk = INPW (SCRATCH_PAD_1);
    pitch = (kk & 0x20) | ((kk & 0x01) << 4);

    kk = INP (SCRATCH_PAD_0+1) & 0x07;
    switch (kk)
        {
        case 0:                             // 800x600?
            pitch |=  0x01;
            break;

        case 1:                             // 1280x1024?
            pitch |=  0x03;
            break;

        case 4:                             // alternate mode?
            pitch |=  0x04;
            break;

        case 2:                             // 640x480?
            pitch |=  0x0;
            break;

        default:                            // 1024x768
            pitch |=  0x02;
            break;
        }

    query->q_shadow_1  = pitch + 1;


    kk = INP(SCRATCH_PAD_1+1);
    pitch = (kk & 0x20) | ((kk & 0x01) << 4);

    kk = INP(SCRATCH_PAD_0+1) & 0x30;
    switch (kk)
        {
        case 0:                             // 800x600?
            pitch |=  0x01;
            break;

        case 0x10:                          // 1280x1024?
            pitch |=  0x03;
            break;

        case 0x40:                          // alternate mode?
            pitch |=  0x04;
            break;

        case 0x20:                          // 640x480?
            pitch |=  0x0;
            break;

        default:                            // 1024x768
            pitch |=  0x02;
            break;
        }
    query->q_shadow_2  = pitch + 1;


    /*
     * If extended BIOS functions are available, set up a buffer
     * for the call to the BIOS query function, then make the call.
     */
    if (query->q_ext_bios_fcn)
        {
        BiosRaw = gBiosRaw;
        /* Make the BIOS call (not yet supported by Windows NT) */
        }

    /*
     * If neither the extended BIOS functions nor the EEPROM
     * is present, we can't fill in the mode tables. Return
     * and let the user know that the mode tables have not
     * been filled in.
     */
    else if (query->q_eeprom == FALSE)
        return ERROR_DEV_NOT_EXIST;

    /*
     * Fill in the mode tables. The mode tables are sorted in increasing
     * order of resolution, and in increasing order of pixel depth.
     * Ensure pmode is initialized to the END of query structure
     */
    pmode = (struct st_mode_table *)query;  // first mode table at end of query
    ((struct query_structure *)pmode)++;
    ee_word = 7;            // starting ee word to read, 7,8,9,10 and 11 are 
                            // the resolutions supported.

    for (jj=0; jj < 4; jj++, ee_word++)
        {
        /*
         * Get the pixel depth-independent portion of the
         * mode tables at the current resolution. Use the
         * extended BIOS functions if available, otherwise
         * read from the EEPROM.
         */
        if (query->q_ext_bios_fcn)
            {
            if (BiosFillTable_m(ee_word, BiosRaw, &ThisRes, query) == FALSE)
                ModeInstalled = FALSE;
            else
                ModeInstalled = TRUE;
            switch (ee_word)
                {
                case 7:
                    CurrentRes = RES_640;
                    StartIndex = B640F60;
                    EndIndex = B640F72;
                    break;

                case 8:
                    CurrentRes = RES_800;
                    StartIndex = B800F89;
                    EndIndex = B800F72;
                    break;

                case 9:
                    CurrentRes = RES_1024;
                    StartIndex = B1024F87;
                    EndIndex = B1024F72;
                    break;

                case 10:
                    CurrentRes = RES_1280;
                    StartIndex = B1280F87;
                    /*
                     * 1280x1024 modes above 60Hz noninterlaced
                     * are only available on VRAM cards.
                     */
                    if ((query->q_memory_type == VMEM_DRAM_256Kx4) ||
                        (query->q_memory_type == VMEM_DRAM_256Kx16) ||
                        (query->q_memory_type == VMEM_DRAM_256Kx4_GRAP))
                        EndIndex = B1280F60;
                    else
                        EndIndex = B1280F74;
                    break;
                }
            }
        else{
            ee_value = (ee->EEread) (ee_word);

            current_mode = ee_value & 0x00FF;
            table_offset = (ee_value >> 8) & 0xFF;   // offset to resolution table

            /*
             * Record whether or not this resolution is enabled.
             * We will report "canned" mode tables for all resolutions,
             * but calculations dependent on the configured refresh
             * rate can only be made if this resolution was enabled
             * by the install program.
             *
             * For all modes except 640x480, there will be a bit set
             * to show which vertical scan rate is used. If no bit is
             * set, then that resolution is not configured.
             *
             * In 640x480, no bit is set if "IBM Default" was selected
             * during monitor configuration, so we assume that 640x480
             * is configured.
             */
            if ((!jj) | ((current_mode) && (current_mode != 0xFF)))
                ModeInstalled = TRUE;
            else
                ModeInstalled = FALSE;

            switch (ee_word)            // are defined for resolutions
                {
                case 7:
                    query->q_status_flags |= VRES_640x480;
                    CurrentRes = RES_640;
                    StartIndex = B640F60;
                    EndIndex = B640F72;

                    // 1024 pitch ONLY if NO aperture on a Mach32
#if !defined (SPLIT_RASTERS)
                    if (query->q_aperture_cfg == 0)
                        ThisRes.m_screen_pitch = 1024;  
                    else
#endif
                        ThisRes.m_screen_pitch = 640;  

                    NumPixels = (long) ThisRes.m_screen_pitch * 480;
                    if (ModeInstalled)
                        {
                        if (ee_value & M640F72)
                            {
                            VgaTblEntry = T640F72;
                            BookTblEntry = B640F72;
                            }
                        else
                            {
                            VgaTblEntry = T640F60;
                            BookTblEntry = B640F60;
                            }
                        }
                    break;

                case 8:
                    query->q_status_flags |= VRES_800x600;
                    CurrentRes = RES_800;
                    StartIndex = B800F89;
                    EndIndex = B800F72;

#if defined (SPLIT_RASTERS)
                    if ((query->q_asic_rev == CI_68800_3) ||
#else
                    // 1024 pitch ONLY if NO aperture on a Mach32
                    if (query->q_aperture_cfg == 0)
                        ThisRes.m_screen_pitch = 1024;
                    // Original production revision has trouble
                    // with deep colour if screen pitch not
                    // divisible by 128.
                    else if ((query->q_asic_rev == CI_68800_3) ||
#endif
                            (query->q_bus_type == BUS_PCI))
                        ThisRes.m_screen_pitch = 896;
                    else
                        ThisRes.m_screen_pitch = 800;

                    NumPixels = (long) ThisRes.m_screen_pitch * 600;
                    if (ModeInstalled)
                        {
                        if (ee_value & M800F72)
                            {
                            VgaTblEntry = T800F72;
                            BookTblEntry = B800F72;
                            }
                        else if (ee_value & M800F70)
                            {
                            VgaTblEntry = T800F70;
                            BookTblEntry = B800F70;
                            }
                        else if (ee_value & M800F60)
                            {
                            VgaTblEntry = T800F60;
                            BookTblEntry = B800F60;
                            }
                        else if (ee_value & M800F56)
                            {
                            VgaTblEntry = T800F56;
                            BookTblEntry = B800F56;
                            }
                        else if (ee_value & M800F89)
                            {
                            VgaTblEntry = T800F89;
                            BookTblEntry = B800F89;
                            }
                        else if (ee_value & M800F95)
                            {
                            VgaTblEntry = T800F95;
                            BookTblEntry = B800F95;
                            }
                        else
                            {
                            VgaTblEntry = NO_TBL_ENTRY;
                            BookTblEntry = NO_TBL_ENTRY;
                            }
                        }
                    break;

                case 9:
                    query->q_status_flags |= VRES_1024x768;
                    CurrentRes = RES_1024;
                    StartIndex = B1024F87;
                    EndIndex = B1024F72;
                    ThisRes.m_screen_pitch = 1024;  
                    NumPixels = (long) ThisRes.m_screen_pitch * 768;
                    if (ModeInstalled)
                        {
                        if (ee_value & M1024F66)
                            {
                            VgaTblEntry = T1024F66;
                            BookTblEntry = B1024F66;
                            }
                        else if (ee_value & M1024F72)
                            {
                            VgaTblEntry = T1024F72;
                            BookTblEntry = B1024F72;
                            }
                        else if (ee_value & M1024F70)
                            {
                            VgaTblEntry = T1024F70;
                            BookTblEntry = B1024F70;
                            }
                        else if (ee_value & M1024F60)
                            {
                            VgaTblEntry = T1024F60;
                            BookTblEntry = B1024F60;
                            }
                        else if (ee_value & M1024F87)
                            {
                            VgaTblEntry = T1024F87;
                            BookTblEntry = B1024F87;
                            }
                        else
                            {
                            VgaTblEntry = NO_TBL_ENTRY;
                            BookTblEntry = NO_TBL_ENTRY;
                            }
                        }
                    break;

                case 10:
                    query->q_status_flags |= VRES_1280x1024;
                    CurrentRes = RES_1280;
                    ThisRes.m_screen_pitch = 1280;  
                    StartIndex = B1280F87;
                    /*
                     * 1280x1024 modes above 60Hz noninterlaced
                     * are only available on VRAM cards.
                     */
                    if ((query->q_memory_type == VMEM_DRAM_256Kx4) ||
                        (query->q_memory_type == VMEM_DRAM_256Kx16) ||
                        (query->q_memory_type == VMEM_DRAM_256Kx4_GRAP))
                        EndIndex = B1280F60;
                    else
                        EndIndex = B1280F74;
                    NumPixels = (long) ThisRes.m_screen_pitch * 1024;

                    // 68800-3 cannot support 4 bpp with 1 meg ram.
                    if ((query->q_asic_rev == CI_68800_3) && (MemAvail == ONE_MEG))
                        NumPixels *= 2;             //ensures mode failure

                    if (ModeInstalled)
                        {
                        if (ee_value & M1280F95)
                            {
                            VgaTblEntry = T1280F95;
                            BookTblEntry = B1280F95;
                            }
                        else if (ee_value & M1280F87)
                            {
                            VgaTblEntry = T1280F87;
                            BookTblEntry = B1280F87;
                            }
                        else
                            {
                            VgaTblEntry = NO_TBL_ENTRY;
                            BookTblEntry = NO_TBL_ENTRY;
                            }
                        }
                    break;

                }   /* end switch(ee_word) */

            /*
             * For a given resolution, there will be one mode table
             * per colour depth. Since the mode tables will differ
             * only in the bits per pixel field, make up one mode
             * table and copy its contents as many times as needed,
             * changing only the colour depth field.
             */
            ThisRes.enabled = ee_value;     /* Which vertical scan frequency */

    
            /*
             * Assume that the EEPROM parameters are in 8514
             * format and try to fill the pmode table. If they
             * are in VGA format, translate them and fill as much
             * of the table as we can.
             * The case where the CRT parameters aren't stored in
             * the EEPROM is handled inside XlateVgaTable().
             * If the parameters aren't stored in the EEPROM, 
             * both the FMT_8514 bit and the CRTC_USAGE bit 
             * will be clear.
             */
            if (!fill_mode_table_m (table_offset, &ThisRes, ee))
                XlateVgaTable(phwDeviceExtension, table_offset, &ThisRes, VgaTblEntry, BookTblEntry, ee, TRUE);
            }   /* endif reading CRT parameters from EEPROM */

        ThisRes.Refresh = DEFAULT_REFRESH;

        /*
         * For each supported pixel depth at the given resolution,
         * copy the mode table, fill in the colour depth field, set
         * a flag to show that this resolution/depth pair is supported,
         * and increment the counter for the number of supported modes.
         * Test 4BPP before 8BPP so the mode tables will appear in
         * increasing order of pixel depth.
         *
         * All the DACs we support can handle 4 and 8 BPP if there
         * is enough memory on the card.
         */
        if (NumPixels <= MemAvail*2)
            {
            if (ModeInstalled)
                {
                VideoPortMoveMemory(pmode, &ThisRes, sizeof(struct st_mode_table));
                pmode->m_pixel_depth = 4;
                pmode++;    /* ptr to next mode table */
                query->q_number_modes++;
                }

            /*
             * Some DAC and card types don't support 1280x1024 noninterlaced.
             */
            if ((CurrentRes == RES_1280) &&
                ((query->q_DAC_type == DAC_BT48x) ||
                 (query->q_DAC_type == DAC_ATT491) ||
                 (query->q_DAC_type == DAC_SC15026) ||
                 (query->q_DAC_type == DAC_ATI_68830) ||
                 (query->q_GraphicsWonder == TRUE)))
                EndIndex = B1280F95;

            /*
             * Add "canned" mode tables
             */

            if ((FreeTables = MaxModes - query->q_number_modes) <= 0)
                {
                VideoDebugPrint((DEBUG_ERROR, "Exceeded maximum allowable number of modes - aborting query\n"));
                return ERROR_INSUFFICIENT_BUFFER;
                }
            query->q_number_modes += SetFixedModes(StartIndex,
                                                   EndIndex,
                                                   CLOCK_SINGLE,
                                                   4,
                                                   ThisRes.m_screen_pitch,
                                                   FreeTables,
                                                   BookValues[EndIndex].ClockFreq,
                                                   &pmode);
            }
        if (NumPixels <= MemAvail)
            {
            if (ModeInstalled)
                {
                VideoPortMoveMemory(pmode, &ThisRes, sizeof(struct st_mode_table));
                pmode->m_pixel_depth = 8;
                pmode++;    /* ptr to next mode table */
                query->q_number_modes++;
                }

            /*
             * Some DAC and card types don't support 1280x1024 noninterlaced.
             */
            if ((CurrentRes == RES_1280) &&
                ((query->q_DAC_type == DAC_BT48x) ||
                 (query->q_DAC_type == DAC_ATT491) ||
                 (query->q_DAC_type == DAC_SC15026) ||
                 (query->q_DAC_type == DAC_ATI_68830) ||
                 (query->q_GraphicsWonder == TRUE)))
                EndIndex = B1280F95;

            /*
             * Add "canned" mode tables
             */

            if ((FreeTables = MaxModes - query->q_number_modes) <= 0)
                {
                VideoDebugPrint((DEBUG_ERROR, "Exceeded maximum allowable number of modes - aborting query\n"));
                return ERROR_INSUFFICIENT_BUFFER;
                }
            query->q_number_modes += SetFixedModes(StartIndex,
                                                   EndIndex,
                                                   CLOCK_SINGLE,
                                                   8,
                                                   ThisRes.m_screen_pitch,
                                                   FreeTables,
                                                   BookValues[EndIndex].ClockFreq,
                                                   &pmode);
            }

        /*
         * 16, 24, and 32 BPP require a DAC which can support
         * the selected pixel depth at the current resolution
         * as well as enough memory.
         *
         * The BT48x and AT&T 49[123] DACs have separate mode
         * tables for 4/8, 16, and 24 BPP (32 BPP not supported).
         * Since the refresh rate for 16 and 24 BPP may differ from
         * that for the paletted modes, we can't be sure that the
         * same tables can be used for translation from VGA to
         * 8514 format. Fortunately, the 16 and 24 BPP tables
         * are always supposed to be written in 8514 format.
         * If the high colour depth is not supported, the
         * table will be empty.
         */
        if ((NumPixels*2 <= MemAvail) &&
            (MaxDepth[query->q_DAC_type][CurrentRes] >= 16))
            {
            if ((query->q_DAC_type == DAC_BT48x) ||
                (query->q_DAC_type == DAC_SC15026) ||
                (query->q_DAC_type == DAC_ATT491))
                {
                Multiplier = CLOCK_DOUBLE;
                if (CurrentRes == RES_640)
                    {
                    Scratch = (UCHAR)fill_mode_table_m(0x49, pmode, ee);
                    }
                else if (CurrentRes == RES_800)
                    {
                    Scratch = (UCHAR)fill_mode_table_m(0x67, pmode, ee);
                    EndIndex = B800F60;     /* 70 Hz and up not supported at 16BPP */
                    }
                else /* Should never hit this case */
                    {
                    Scratch = 0;
                    }

                /*
                 * If the mode table is present and in 8514 format,
                 * move to the next mode table and increment the
                 * table counter. If it is not usable, the table
                 * will be overwritten by the table for the next
                 * resolution.
                 */
                if (ModeInstalled && (Scratch != 0))
                    {
                    pmode->m_screen_pitch = ThisRes.m_screen_pitch;
                    pmode->m_pixel_depth = 16;
                    pmode->Refresh = DEFAULT_REFRESH;
                    pmode++;    /* ptr to next mode table */
                    query->q_number_modes++;
                    }
                }
            else
                {
                Multiplier = CLOCK_SINGLE;
                if (ModeInstalled)
                    {
                    VideoPortMoveMemory(pmode, &ThisRes, sizeof(struct st_mode_table));
                    pmode->m_pixel_depth = 16;
                    pmode++;    /* ptr to next mode table */
                    query->q_number_modes++;
                    }

                /*
                 * If this is a Graphics Wonder with a TI34075 DAC
                 * (only other DAC is BT48x, which is handled in
                 * "if" section above), 70 Hz and up are not
                 * supported in 800x600 16BPP.
                 *
                 * On some but not all non-Graphics Wonder cards, 800x600
                 * 16BPP 72Hz will overdrive the DAC (cards with fast
                 * RAM are less likely to be affected than cards with
                 * slow RAM, VRAM or DRAM does not seem to make a
                 * difference). Since we have no way to tell whether
                 * or not any given card is affected, we must lock out
                 * this mode for all non-Graphics Wonder cards (this
                 * mode and a number of others are already locked out
                 * on the Graphics Wonder).
                 */
                if ((query->q_GraphicsWonder) && (CurrentRes == RES_800))
                    {
                    EndIndex = B800F60;
                    }
                else if (CurrentRes == RES_800)
                    {
                    EndIndex = B800F70;
                    }

                }

            /*
             * Add "canned" mode tables
             */

            if ((FreeTables = MaxModes - query->q_number_modes) <= 0)
                {
                VideoDebugPrint((DEBUG_ERROR, "Exceeded maximum allowable number of modes - aborting query\n"));
                return ERROR_INSUFFICIENT_BUFFER;
                }
            query->q_number_modes += SetFixedModes(StartIndex,
                                                   EndIndex,
                                                   Multiplier,
                                                   16,
                                                   ThisRes.m_screen_pitch,
                                                   FreeTables,
                                                   BookValues[EndIndex].ClockFreq,
                                                   &pmode);
            }


        /*
         * Our new source stream display driver needs a linear aperture
         * in order to handle 24BPP. Since the display driver doesn't
         * have access to the aperture information when it is deciding
         * which modes to pass on to the display applet, it can't make
         * the decision to reject 24BPP modes for cards with only a
         * VGA aperture. This decision must therefore be made in the
         * miniport, so in a paged aperture configuration there are no
         * 24BPP modes for the display driver to accept or reject.
         *
         * On the Alpha, we can't use dense space on the Mach 32 LFB,
         * so we treat it as a no-aperture case.
         */
        if (query->q_aperture_cfg == 0)
            {
            VideoDebugPrint((DEBUG_DETAIL, "24BPP not available because we don't have a linear aperture\n"));
            continue;
            }

#if defined(ALPHA)
        VideoDebugPrint((DEBUG_DETAIL, "24BPP not available in sparse space on Alpha\n"));
        continue;
#endif

        /*
         * 800x600 24BPP exhibits screen tearing unless the pitch
         * is a multiple of 128 (only applies to Rev. 6, since Rev. 3
         * and PCI implementations already have a pitch of 896).
         * Other pixel depths are not affected, and other resolutions
         * are already a multiple of 128 pixels wide.
         *
         * Expand the 800x600 pitch to 896 here, rather than for
         * all pixel depths, because making the change for all
         * pixel depths would disable 16BPP (which doesn't have
         * the problem) on 1M cards. The screen pitch will only
         * be 800 on cards which will exhibit this problem - don't
         * check for a resolution of 800x600 because we don't want
         * to cut the pitch from 1024 down to 896 if SPLIT_RASTERS
         * is not defined.
         */
        if (ThisRes.m_screen_pitch == 800)
            {
            ThisRes.m_screen_pitch = 896;
            NumPixels = (long) ThisRes.m_screen_pitch * 600;
            }

        if ((NumPixels*3 <= MemAvail) &&
            (MaxDepth[query->q_DAC_type][CurrentRes] >= 24))
            {
            if ((query->q_DAC_type == DAC_BT48x) ||
                (query->q_DAC_type == DAC_SC15026) ||
                (query->q_DAC_type == DAC_ATT491))
                {
                Multiplier = CLOCK_TRIPLE;
                if (CurrentRes == RES_640)
                    {
                    EndIndex = B640F60; /* Only refresh rate supported at 24BPP */
                    Scratch = (UCHAR)fill_mode_table_m(0x58, pmode, ee);
                    }
                else /* Should never hit this case */
                    {
                    Scratch = 0;
                    }

                /*
                 * If the mode table is present and in 8514 format,
                 * move to the next mode table and increment the
                 * table counter. If it is not usable, the table
                 * will be overwritten by the table for the next
                 * resolution.
                 */
                if (ModeInstalled && (Scratch != 0))
                    {
                    pmode->m_screen_pitch = ThisRes.m_screen_pitch;
                    pmode->m_pixel_depth = 24;
                    pmode->Refresh = DEFAULT_REFRESH;
                    pmode++;    /* ptr to next mode table */
                    query->q_number_modes++;
                    }
                }
            else
                {
                VideoPortMoveMemory(pmode, &ThisRes, sizeof(struct st_mode_table));
                pmode->m_pixel_depth = 24;

                /*
                 * Handle DACs that require higher pixel clocks for 24BPP.
                 */
                Scratch = 0;
                if ((query->q_DAC_type == DAC_STG1700) ||
                    (query->q_DAC_type == DAC_ATT498))
                    {
                    Multiplier = CLOCK_DOUBLE;
                    Scratch = (UCHAR)(pmode->m_clock_select & 0x007C) >> 2;
                    Scratch = DoubleClock(Scratch);
                    pmode->m_clock_select &= 0x0FF83;
                    pmode->m_clock_select |= (Scratch << 2);
                    pmode->ClockFreq <<= 1;
                    }
                else if ((query->q_DAC_type == DAC_SC15021) ||
                    (query->q_DAC_type == DAC_STG1702) ||
                    (query->q_DAC_type == DAC_STG1703))
                    {
                    Multiplier = CLOCK_THREE_HALVES;
                    Scratch = (UCHAR)(pmode->m_clock_select & 0x007C) >> 2;
                    Scratch = ThreeHalvesClock(Scratch);
                    pmode->m_clock_select &= 0x0FF83;
                    pmode->m_clock_select |= (Scratch << 2);
                    pmode->ClockFreq *= 3;
                    pmode->ClockFreq >>= 1;
                    }
                else
                    {
                    Multiplier = CLOCK_SINGLE;
                    if ((query->q_DAC_type == DAC_TI34075) && (CurrentRes == RES_800))
                        EndIndex = B800F70;
                    }

                /*
                 * If we needed to alter the clock frequency, and couldn't
                 * generate an appropriate selector/divisor pair,
                 * then ignore this mode.
                 */
                if (ModeInstalled && (Scratch != 0x0FF))
                    {
                    pmode++;    /* ptr to next mode table */
                    query->q_number_modes++;
                    }

                /*
                 * If this is a Graphics Wonder with a TI34075 DAC
                 * (only other DAC is BT48x, which is handled in
                 * "if" section above), 72 Hz is not supported in
                 * 640x480 24BPP.
                 */
                if ((query->q_GraphicsWonder) && (CurrentRes == RES_640))
                    {
                    EndIndex = B640F60;
                    }
                }

            /*
             * Add "canned" mode tables
             */

            if ((FreeTables = MaxModes - query->q_number_modes) <= 0)
                {
                VideoDebugPrint((DEBUG_ERROR, "Exceeded maximum allowable number of modes - aborting query\n"));
                return ERROR_INSUFFICIENT_BUFFER;
                }
            query->q_number_modes += SetFixedModes(StartIndex,
                                                   EndIndex,
                                                   Multiplier,
                                                   24,
                                                   ThisRes.m_screen_pitch,
                                                   FreeTables,
                                                   BookValues[EndIndex].ClockFreq,
                                                   &pmode);
            }

        }   /* end for (list of resolutions) */

    query->q_sizeof_struct = query->q_number_modes * sizeof(struct st_mode_table) + sizeof(struct query_structure);

    return NO_ERROR;

}   /* QueryMach32 */


/****************************************************************
 * fill_mode_table_m
 *   INPUT: table_offset = EEPROM address to start of table
 *          pmode        = ptr to mode table to fill in
 *
 *   RETURN: Nonzero if EEPROM data was in 8514 format.
 *           Zero if EEPROM data was in VGA format. Only those
 *            table entries which are the same in both formats
 *            will be filled in.
 *
 ****************************************************************/

short fill_mode_table_m(WORD table_offset, struct st_mode_table *pmode, 
                        struct st_eeprom_data *ee)
{
    WORD    kk;

    /*
     * Fill in the values which are the same in 8514 and VGA formats.
     */
    pmode->control  = (ee->EEread) ((WORD)(table_offset+0));

    pmode->m_pixel_depth = (pmode->control >> 8) & 0x07;
    pmode->m_reserved = table_offset;       /* EEPROM word with start of mode table */

    /*
     * Check the VGA/8514 mode bit of the control word. 
     * If the parameters are in VGA format, fail so can be translated
     */
    if (!(pmode->control & FMT_8514))
        return 0;

    /*
     * The parameters in the EEPROM are in 8514 format, so we can
     * fill in the structure.
     */
    kk = (ee->EEread) ((WORD)(table_offset+3));
    pmode->m_h_total = (kk >> 8) & 0xFF;
    pmode->m_h_disp  =  kk & 0xFF;
    pmode->m_x_size  = (pmode->m_h_disp+1) * 8;

    kk = (ee->EEread) ((WORD)(table_offset+4));
    pmode->m_h_sync_strt = (kk >> 8) & 0xFF;
    pmode->m_h_sync_wid  =  kk & 0xFF;

    kk = (ee->EEread) ((WORD)(table_offset+8));
    pmode->m_v_sync_wid = (kk >> 8) & 0xFF;
    pmode->m_disp_cntl  =  kk & 0xFF;

    pmode->m_v_total = (ee->EEread) ((WORD)(table_offset+5));
    pmode->m_v_disp  = (ee->EEread) ((WORD)(table_offset+6));

    //  y_size is derived by removing bit 2
    pmode->m_y_size  = (((pmode->m_v_disp >> 1) & 0xFFFC) | (pmode->m_v_disp & 0x03)) +1;

    pmode->m_v_sync_strt = (ee->EEread) ((WORD)(table_offset+7));

    /*
     * On some cards, the vertical information may be stored in skip-1-2
     * format instead of the normal skip-2 format. If this happens, m_y_size
     * will exceed m_x_size (we don't support any resolutions that are
     * taller than they are wide). Re-calculate m_y_size for skip-1-2 format.
     */
    if (pmode->m_y_size > pmode->m_x_size)
        {
        pmode->m_y_size  = (((pmode->m_v_disp >> 2) & 0xFFFE) | (pmode->m_v_disp & 0x01)) +1;
        }


    pmode->m_h_overscan = (ee->EEread)  ((WORD)(table_offset+11));
    pmode->m_v_overscan = (ee->EEread)  ((WORD)(table_offset+12));
    pmode->m_overscan_8b = (ee->EEread) ((WORD)(table_offset+13));
    pmode->m_overscan_gr = (ee->EEread) ((WORD)(table_offset+14));

    pmode->m_status_flags = ((ee->EEread) ((WORD)(table_offset+10)) >> 8) & 0xC0;
    pmode->m_clock_select = (ee->EEread)  ((WORD)(table_offset+9));
    pmode->ClockFreq = GetFrequency((BYTE)((pmode->m_clock_select & 0x007C) >> 2));

    kk = (ee->EEread) ((WORD)(table_offset+2));
    pmode->m_vfifo_24 = (kk >> 8) & 0xFF;
    pmode->m_vfifo_16 =  kk & 0xFF;

    return 1;                   // table filled in successfully

}   /* fill_mode_table_m() */


/*
 * BOOL BiosFillTable_m(ResWanted, BiosRaw, OutputTable, QueryPtr);
 *
 * short ResWanted;     Indicates which resolution is wanted
 * PUCHAR BiosRaw;      Raw data read in from BIOS query function
 * struct st_mode_table *OutputTable;   Mode table to fill in
 * struct query_structure *QueryPtr;    Query structure for video card
 *
 * Fill in pixel depth-independent fields of OutputTable using
 * CRT parameters retrieved from a BIOS query.
 *
 * Returns:
 *  TRUE if table filled in
 *  FALSE if table not filled in (resolution not supported?)
 */
BOOL BiosFillTable_m(short ResWanted, PUCHAR BiosRaw,
                    struct st_mode_table *OutputTable,
                    struct query_structure *QueryPtr)
{
WORD ResFlag;       /* Flag to show which mode is supported */
short PixelsWide;   /* Horizontal resolution of desired mode */
long NumPixels;     /* Number of pixels on-screen at desired resolution */
short Count;        /* Loop counter */
struct query_structure *BiosQuery;  /* QueryStructure read in by BIOS query */
struct st_mode_table *BiosMode;     /* Pointer to first mode table returned by BIOS query */

    /*
     * Set up pointers to the query information and first mode table
     * stored in BiosRaw.
     */
    BiosQuery = (struct query_structure *)BiosRaw;
    BiosMode = (struct st_mode_table *)BiosRaw;
    ((PUCHAR)BiosMode) += BiosQuery->q_mode_offset;

    /*
     * Determine which resolution we are looking for.
     */
    switch (ResWanted)
        {
        case 7:
            ResFlag = VRES_640x480;
            PixelsWide = 640;
            /*
             * 1024 pitch ONLY if NO aperture on a Mach32
             */
#if !defined (SPLIT_RASTERS)
            if (QueryPtr->q_aperture_cfg == 0)
                OutputTable->m_screen_pitch = 1024;  
            else
#endif
                OutputTable->m_screen_pitch = 640;
            NumPixels = (long) OutputTable->m_screen_pitch * 480;
            break;

        case 8:
            ResFlag = VRES_800x600;
            PixelsWide = 800;
            /*
             * 1024 pitch ONLY if NO aperture on a Mach32
             */
#if defined (SPLIT_RASTERS)
            if (QueryPtr->q_asic_rev != CI_68800_3)
#else
            if (QueryPtr->q_aperture_cfg == 0)
                OutputTable->m_screen_pitch = 1024;
            /*
             * Original production revision has trouble with deep colour
             * if screen pitch not divisible by 128.
             */
            else if (QueryPtr->q_asic_rev != CI_68800_3)
#endif
                OutputTable->m_screen_pitch = 896;
            else
                OutputTable->m_screen_pitch = 800;
            NumPixels = (long) OutputTable->m_screen_pitch * 600;
            break;

        case 9:
            ResFlag = VRES_1024x768;
            PixelsWide = 1024;
            OutputTable->m_screen_pitch = 1024;  
            NumPixels = (long) OutputTable->m_screen_pitch * 768;
            break;

        case 10:
            ResFlag = VRES_1280x1024;
            PixelsWide = 1280;
            OutputTable->m_screen_pitch = 1280;  
            NumPixels = (long) OutputTable->m_screen_pitch * 1024;
            /*
             * 68800-3 cannot support 4 bpp with 1 meg ram.
             */
            if ((QueryPtr->q_asic_rev == CI_68800_3) && (QueryPtr->q_memory_size == VRAM_1mb))
                NumPixels *= 2;     /* Ensures mode failure */
            break;

        case 11:
            ResFlag = VRES_ALT_1;
            PixelsWide = 1120;
            OutputTable->m_screen_pitch = 1120;  
            NumPixels = (long) OutputTable->m_screen_pitch * 750;
            break;
        }

    /*
     * Check if the card is configured for the desired mode.
     */
    for (Count = 0; Count < BiosQuery->q_number_modes; Count++)
        {
        /*
         * If the current mode is the one we want, go to the
         * next step. Otherwise, look at the next mode table.
         */
        if (BiosMode->m_x_size == PixelsWide)
            break;
        else
            ((PUCHAR)BiosMode) += BiosQuery->q_sizeof_mode;
        }

    /*
     * Special case: If 1024x768 is not configured, assume that
     * it is available at 87Hz interlaced (Windows 3.1 compatibility).
     */
    if ((Count == BiosQuery->q_number_modes) && (PixelsWide == 1024))
        {
        BookVgaTable(B1024F87, OutputTable);
        QueryPtr->q_status_flags |= ResFlag;
        return TRUE;
        }

    /*
     * All other cases where mode is not configured: report
     * that the mode is not available.
     */
    else if (Count == BiosQuery->q_number_modes)
        return FALSE;

    /*
     * We have found the mode table for the current resolution.
     * Transfer it to OutputTable.
     */
    QueryPtr->q_status_flags |= ResFlag;
    OutputTable->m_h_total = BiosMode->m_h_total;
    OutputTable->m_h_disp = BiosMode->m_h_disp;
    OutputTable->m_x_size = BiosMode->m_x_size;
    OutputTable->m_h_sync_strt = BiosMode->m_h_sync_strt;
    OutputTable->m_h_sync_wid = BiosMode->m_h_sync_wid;
    OutputTable->m_v_total = BiosMode->m_v_total;
    OutputTable->m_v_disp = BiosMode->m_v_disp;
    OutputTable->m_y_size = BiosMode->m_y_size;
    OutputTable->m_v_sync_strt = BiosMode->m_v_sync_strt;
    OutputTable->m_v_sync_wid = BiosMode->m_v_sync_wid;
    OutputTable->m_disp_cntl = BiosMode->m_disp_cntl;
    OutputTable->m_clock_select = BiosMode->m_clock_select;
    OutputTable->ClockFreq = GetFrequency((BYTE)((OutputTable->m_clock_select & 0x007C) >> 2));
    OutputTable->m_h_overscan = BiosMode->m_h_overscan;
    OutputTable->m_v_overscan = BiosMode->m_v_overscan;
    OutputTable->m_overscan_8b = BiosMode->m_overscan_8b;
    OutputTable->m_overscan_gr = BiosMode->m_overscan_gr;
    OutputTable->m_status_flags = BiosMode->m_status_flags;

    /*
     * Assume 8 FIFO entries for 16 and 24 bit colour.
     */
    OutputTable->m_vfifo_24 = 8;
    OutputTable->m_vfifo_16 = 8;
    return TRUE;

}   /* BiosFillTable_m() */



/*
 * static UCHAR BrooktreeOrATT_m(void);
 *
 * Function to determine whether the DAC is a BT48x, a SC15026,
 * or an AT&T 49x. These three DAC families are incompatible,
 * but CONFIG_STATUS_1 contains the same value for all.
 *
 * Returns:
 *  DAC_BT48x if Brooktree DAC found
 *  DAC_ATT491 if AT&T 49[123] DAC found
 *  DAC_SC15026 if Sierra SC15026 DAC found
 *
 * NOTE: Results are undefined if called after CONFIG_STATUS_1
 *       reports a DAC that does not belong to either of these
 *       two families.
 */
static UCHAR BrooktreeOrATT_m(void)
{
    BYTE OriginalMask;  /* Original value from VGA DAC_MASK register */
    WORD ValueRead;     /* Value read during AT&T 490 check */
    BYTE Scratch;       /* Temporary variable */
    short RetVal;       /* Value to be returned */

    /*
     * Get the DAC to a known state and get the original value
     * from the VGA DAC_MASK register.
     */
    ClrDacCmd_m(TRUE);
    OriginalMask = LioInp(regVGA_END_BREAK_PORT, 6);    /* VGA DAC_MASK */

    /*
     * Re-clear the DAC state, and set the extended register
     * programming flag in the DAC command register.
     */
    ClrDacCmd_m(TRUE);
    Scratch = (BYTE)((OriginalMask & 0x00FF) | 0x10);
    LioOutp(regVGA_END_BREAK_PORT, Scratch, 6);     /* VGA DAC_MASK */

    /*
     * Select ID register byte #1, and read its contents.
     */
    LioOutp(regVGA_END_BREAK_PORT, 0x09, 7);        /* Look-up table read index */
    Scratch = LioInp(regVGA_END_BREAK_PORT, 8);     /* Look-up table write index */

    /*
     * Put the DAC back in a known state and restore
     * the original pixel mask value.
     */
    ClrDacCmd_m(TRUE);
    LioOutp(regVGA_END_BREAK_PORT, OriginalMask, 6);    /* VGA DAC_MASK */

    /*
     * Sierra SC15026 DACs will have 0x53 in ID register byte 1.
     */
    if (Scratch == 0x53)
        {
        VideoDebugPrint((DEBUG_DETAIL, "BrooktreeOrATT_m() - SC15026 found\n"));
        return DAC_SC15026;
        }

    /*
     * Get the DAC to a known state and get the original value
     * from the VGA DAC_MASK register. Assume AT&T DAC.
     */
    ClrDacCmd_m(FALSE);
    OriginalMask = LioInp(regVGA_END_BREAK_PORT, 6);    /* VGA DAC_MASK */
    RetVal = DAC_ATT491;

    /*
     * Check the two opposite alternating bit patterns. If both succeed,
     * this is an AT&T 491 DAC. If either or both fails, it is either
     * another AT&T DAC or a Brooktree DAC. In either case, restore
     * the value from the VGA DAC_MASK register, since the test will
     * have corrupted it.
     */
    if (!ChkATTDac_m(0x0AA))
        {
        RetVal = DAC_BT48x;
        }
    if (!ChkATTDac_m(0x055))
        {
        RetVal = DAC_BT48x;
        }
    ClrDacCmd_m(FALSE);
    LioOutp(regVGA_END_BREAK_PORT, OriginalMask, 6);    /* VGA DAC_MASK */
    LioOutp(regVGA_END_BREAK_PORT, 0x0FF, 6);           /* VGA DAC_MASK */

    /*
     * If we know that the DAC is an AT&T 491, we don't need
     * to do further testing.
     */
    if (RetVal == DAC_ATT491)
        {
        VideoDebugPrint((DEBUG_DETAIL, "BrooktreeOrATT_m() - AT&T 491 found\n"));
        return (UCHAR)RetVal;
        }

    /*
     * The DAC is either an AT&T 490 or a Brooktree 48x. Determine
     * which one.
     */
    ClrDacCmd_m(TRUE);        /* Get the DAC to a known state */
    LioOutp(regVGA_END_BREAK_PORT, 0x0FF, 6);       /* VGA DAC_MASK */
    ClrDacCmd_m(TRUE);
    Scratch = LioInp(regVGA_END_BREAK_PORT, 6);     /* VGA DAC_MASK */
    ValueRead = Scratch << 8;

    ClrDacCmd_m(TRUE);
    LioOutp(regVGA_END_BREAK_PORT, 0x07F, 6);       /* VGA DAC_MASK */
    ClrDacCmd_m(TRUE);
    Scratch = LioInp(regVGA_END_BREAK_PORT, 6);     /* VGA DAC_MASK */
    ValueRead |= Scratch;
    ValueRead &= 0x0E0E0;

    ClrDacCmd_m(TRUE);
    LioOutp(regVGA_END_BREAK_PORT, 0, 6);           /* VGA_DAC_MASK */
    if (ValueRead == 0x0E000)
        {
        VideoDebugPrint((DEBUG_DETAIL, "BrooktreeOrATT_m() - AT&T 490 found\n"));
        return DAC_ATT491;
        }
    else
        {
        VideoDebugPrint((DEBUG_DETAIL, "BrooktreeOrATT_m() - BT48x found\n"));
        /*
         * The test to find an AT&T 491 scrambles the DAC_MASK register
         * on a BT48x. Simply resetting this register doesn't work -
         * the DAC needs to be re-initialized. This is done when the
         * video mode is set, but for now the "blue screen" winds up
         * as magenta on blue instead of white on blue.
         *
         * This "blue screen" change is harmless, but may result in
         * user complaints. To get around it, change palette entry 5
         * from magenta to white.
         */
        LioOutp(regVGA_END_BREAK_PORT, 5, 8);       /* VGA DAC_W_INDEX */
        LioOutp(regVGA_END_BREAK_PORT, 0x2A, 9);    /* VGA DAC_DATA */
        LioOutp(regVGA_END_BREAK_PORT, 0x2A, 9);    /* VGA DAC_DATA */
        LioOutp(regVGA_END_BREAK_PORT, 0x2A, 9);    /* VGA DAC_DATA */
        return DAC_BT48x;
        }

}   /* BrooktreeOrATT_m() */
    


/*
 * static BOOL ChkATTDac_m(MaskVal);
 *
 * BYTE MaskVal;    Value to write to VGA DAC_MASK register
 *
 * Low-level test routine called by BrooktreeOrATT_m() to determine
 * whether an AT&T 491 DAC is present.
 *
 * Returns:
 *  TRUE if AT&T 491 DAC found
 *  FALSE if AT&T 491 DAC not found (may still be other AT&T DAC)
 */
static BOOL ChkATTDac_m(BYTE MaskVal)
{
    BYTE ValueRead;     /* Value read back from VGA DAC_MASK register */

    ClrDacCmd_m(FALSE);   /* Get things to a known state */
    LioOutp(regVGA_END_BREAK_PORT, MaskVal, 6);     /* VGA DAC_MASK */
    short_delay();
    LioOutp(regVGA_END_BREAK_PORT, (BYTE)(~MaskVal), 6);    /* VGA DAC_MASK */
    ClrDacCmd_m(FALSE);   /* See if inverted value was cleared */
    ValueRead = LioInp(regVGA_END_BREAK_PORT, 6);   /* VGA DAC_MASK */

    return (ValueRead == MaskVal);

}   /* ChkATTDac_m() */



/*
 * static void ClrDacCmd_m(ReadIndex);
 *
 * BOOL ReadIndex;  TRUE if VGA DAC_W_INDEX must be read
 *
 * Read various VGA registers from the DAC. This is done as part
 * of the BT48x/ATT491 identification.
 */
static void ClrDacCmd_m(BOOL ReadIndex)
{
    short Count;    /* Loop counter */
    BYTE Dummy;     /* Used to collect the values we read */

    if (ReadIndex)
        {
        Dummy = LioInp(regVGA_END_BREAK_PORT, 8);   /* VGA DAC_W_INDEX */
        }

    for (Count = 4; Count > 0; Count--)
        {
        short_delay();
        Dummy = LioInp(regVGA_END_BREAK_PORT, 6);   /* VGA DAC_MASK */
        }
    return;

}   /* ClrDacCmd_m() */



/***************************************************************************
 *
 * static UCHAR ThompsonOrATT_m(void);
 *
 * DESCRIPTION:
 *  Checks the AT&T 498 device identification number register to
 *  determine whether we are dealing with an AT&T 498 or a
 *  STG 1700 DAC (both types report the same value in CONFIG_STATUS_1).
 *  This is a non-destructive test, since no register writes
 *  are involved.
 *
 * RETURN VALUE:
 *  DAC_STG1700 if S.G. Thompson 1700 DAC found
 *  DAC_ATT498 if AT&T 498 DAC found
 *
 * NOTE:
 *  Results are undefined if called after CONFIG_STATUS_1 reports
 *  a DAC that does not belong to either of these two families.
 *
 * GLOBALS CHANGED:
 *  none
 *
 * CALLED BY:
 *  short_query_m()
 *
 * AUTHOR:
 *  Robert Wolff
 *
 * CHANGE HISTORY:
 *
 * TEST HISTORY:
 *
 ***************************************************************************/

static UCHAR ThompsonOrATT_m(void)
{
    BYTE Scratch;       /* Temporary variable */
    UCHAR DacType;      /* Type of DAC we are dealing with */

    VideoDebugPrint((DEBUG_NORMAL, "ThompsonOrATT_m() entry\n"));
    /*
     * The extended registers hidden behind DAC_MASK on the AT&T 498
     * and STG1700 are accessed by making a specified number of reads
     * from the DAC_MASK register. Read from another register to reset
     * the read counter to 0.
     */
    Scratch = INP(DAC_W_INDEX);

    /*
     * The AT&T 498 Manufacturer Identification Register is accessed on
     * the sixth read from DAC_MASK, and the Device Identification
     * Register is accessed on the seventh. If these registers contain
     * 0x84 and 0x98 respectively, then this is an AT&T 498. Initially
     * assume that an AT&T 498 is present.
     */
    DacType = DAC_ATT498;
    Scratch = INP(DAC_MASK);
    Scratch = INP(DAC_MASK);
    Scratch = INP(DAC_MASK);
    Scratch = INP(DAC_MASK);
    Scratch = INP(DAC_MASK);
    Scratch = INP(DAC_MASK);
    if (Scratch != 0x84)
        {
        VideoDebugPrint((DEBUG_DETAIL, "STG1700 found\n"));
        DacType = DAC_STG1700;
        }
    Scratch = INP(DAC_MASK);
    if (Scratch != 0x98)
        {
        VideoDebugPrint((DEBUG_DETAIL, "STG1700 found\n"));
        DacType = DAC_STG1700;
        }

    VideoDebugPrint((DEBUG_DETAIL, "If no STG1700 message, AT&T498 found\n"));
    /*
     * Reset the read counter so subsequent accesses to DAC_MASK don't
     * accidentally write a hidden register.
     */
    Scratch = INP(DAC_W_INDEX);
    return DacType;

}   /* ThompsonOrATT_m() */
    


/***************************************************************************
 *
 * static UCHAR SierraOrThompson_m(void);
 *
 * DESCRIPTION:
 *  Checks the first 2 bytes of the Sierra SC15021 device
 *  identification register to determine whether we are dealing
 *  with an SC15021 or a STG1702/1703 in native mode (STG170x
 *  can also be strapped to emulate the STG1700, but this DAC
 *  has different capabilities, and so strapped STG170x DACs won't
 *  be reported as SC15021).
 *
 * RETURN VALUE:
 *  DAC_STG1702 if S.G. Thompson 1702/1703 DAC found
 *  DAC_SC15021 if Sierra SC15021 DAC found
 *
 * NOTE:
 *  Results are undefined if called after CONFIG_STATUS_1 reports
 *  a DAC that does not belong to either of these two families.
 *
 * GLOBALS CHANGED:
 *  none
 *
 * CALLED BY:
 *  short_query_m()
 *
 * AUTHOR:
 *  Robert Wolff
 *
 * CHANGE HISTORY:
 *
 * TEST HISTORY:
 *
 ***************************************************************************/

static UCHAR SierraOrThompson_m(void)
{
    BYTE Scratch;       /* Temporary variable */
    UCHAR DacType;      /* Type of DAC we are dealing with */

    VideoDebugPrint((DEBUG_NORMAL, "SierraOrThompson_m() entry\n"));
    /*
     * The extended registers hidden behind DAC_MASK on the SC15021
     * and STG1702/1703 are accessed by making a specified number of
     * reads from the DAC_MASK register. Read from another register
     * to reset the read counter to 0.
     */
    Scratch = INP(DAC_W_INDEX);

    /*
     * Set the extended register programming flag in the DAC command
     * register so we don't need to hit the "magic" reads for each
     * register access. Initially assume that a SC15021 is present.
     */
    DacType = DAC_SC15021;
    Scratch = INP(DAC_MASK);
    Scratch = INP(DAC_MASK);
    Scratch = INP(DAC_MASK);
    Scratch = INP(DAC_MASK);
    OUTP(DAC_MASK, 0x10);

    /*
     * Check the ID registers. If either of them doesn't match the
     * values for the SC15021, we are dealing with a STG1702/1703.
     */
    OUTP(DAC_R_INDEX, 0x09);
    Scratch = INP(DAC_W_INDEX);
    if (Scratch != 0x53)
        {
        VideoDebugPrint((DEBUG_DETAIL, "STG1702/1703 found\n"));
        DacType = DAC_STG1702;
        }
    OUTP(DAC_R_INDEX, 0x0A);
    Scratch = INP(DAC_W_INDEX);
    if (Scratch != 0x3A)
        {
        VideoDebugPrint((DEBUG_DETAIL, "STG1702/1703 found\n"));
        DacType = DAC_STG1702;
        }

    VideoDebugPrint((DEBUG_DETAIL, "If no STG1702/1703 message, SC15021 found\n"));
    /*
     * Clear the ERPF and reset the read counter so subsequent accesses
     * to DAC_MASK don't accidentally write a hidden register.
     */
    OUTP(DAC_MASK, 0);
    Scratch = INP(DAC_W_INDEX);
    return DacType;

}   /* SierraOrThompson_m() */
    


/***************************************************************************
 *
 * short GetTrueMemSize_m(void);
 *
 * DESCRIPTION:
 *  Determine the amount of video memory installed on the graphics card.
 *  This is done because the 68800-6 contains a bug which causes MISC_OPTIONS
 *  to report 1M rather than the true amount of memory.
 *
 * RETURN VALUE:
 *  Enumerated value for amount of memory (VRAM_512k, VRAM_1mb, VRAM_2mb,
 *  or VRAM_4mb)
 *
 * GLOBALS CHANGED:
 *  none
 *
 * CALLED BY:
 *  QueryMach32()
 *
 * AUTHOR:
 *  Robert Wolff
 *
 * CHANGE HISTORY:
 *
 * TEST HISTORY:
 *
 ***************************************************************************/

short GetTrueMemSize_m(void)
{
    USHORT SavedPixel;      /* Saved value from pixel being tested */

    /*
     * Switch into accelerator mode, and initialize the engine to
     * a pitch of 1024 pixels in 16BPP.
     */
    SetupRestoreEngine_m(SETUP_ENGINE);


    /*
     * Given the current engine settings, only a 4M card will have
     * enough memory to back up the 1025th line of the display.
     * Since the pixel coordinates are zero-based, line 1024 will
     * be the first one which is only backed on 4M cards.
     *
     * Save the first pixel of line 1024, paint it in our test colour,
     * then read it back. If it is the same as the colour we painted
     * it, then this is a 4M card.
     */
    SavedPixel = ReadPixel_m(0, 1024);
    WritePixel_m(0, 1024, TEST_COLOUR);
    if (ReadPixel_m(0, 1024) == TEST_COLOUR)
        {
        /*
         * This is a 4M card. Restore the pixel and the graphics engine.
         */
        VideoDebugPrint((DEBUG_NORMAL, "GetTrueMemSize_m() found 4M card\n"));
        WritePixel_m(0, 1024, SavedPixel);
        SetupRestoreEngine_m(RESTORE_ENGINE);
        return VRAM_4mb;
        }

    /*
     * We know this card has 2M or less. On a 1M card, the first 2M
     * of the card's memory will have even doublewords backed by
     * physical memory and odd doublewords unbacked.
     *
     * Pixels 0 and 1 of a row will be in the zeroth doubleword, while
     * pixels 2 and 3 will be in the first. Check both pixels 2 and 3
     * in case this is a pseudo-1M card (one chip pulled to turn a 2M
     * card into a 1M card).
     */
    SavedPixel = ReadPixel_m(2, 0);
    WritePixel_m(2, 0, TEST_COLOUR);
    if (ReadPixel_m(2, 0) == TEST_COLOUR)
        {
        /*
         * This is a either a 2M card or a pseudo-1M card. Restore
         * the pixel, then test the other half of the doubleword.
         */
        WritePixel_m(2, 0, SavedPixel);
        SavedPixel = ReadPixel_m(3, 0);
        WritePixel_m(3, 0, TEST_COLOUR);
        if (ReadPixel_m(3, 0) == TEST_COLOUR)
            {
            /*
             * This is a 2M card. Restore the pixel and the graphics engine.
             */
            VideoDebugPrint((DEBUG_NORMAL, "GetTrueMemSize_m() found 2M card\n"));
            WritePixel_m(3, 0, SavedPixel);
            SetupRestoreEngine_m(RESTORE_ENGINE);
            return VRAM_2mb;
            }
        }

    /*
     * This is a either a 1M card or a 512k card. Test pixel 1, since
     * it is an odd word in an even doubleword.
     *
     * NOTE: We have not received 512k cards for testing - this is an
     *       extrapolation of the 1M/2M determination code.
     */
    SavedPixel = ReadPixel_m(1, 0);
    WritePixel_m(1, 0, TEST_COLOUR);
    if (ReadPixel_m(1, 0) == TEST_COLOUR)
        {
        /*
         * This is a 1M card. Restore the pixel and the graphics engine.
         */
        VideoDebugPrint((DEBUG_NORMAL, "GetTrueMemSize_m() found 1M card\n"));
        WritePixel_m(1, 0, SavedPixel);
        SetupRestoreEngine_m(RESTORE_ENGINE);
        return VRAM_1mb;
        }

    /*
     * This is a 512k card.
     */
    VideoDebugPrint((DEBUG_NORMAL, "GetTrueMemSize_m() found 512k card\n"));
    SetupRestoreEngine_m(RESTORE_ENGINE);
    return VRAM_512k;

}   /* GetTrueMemSize_m() */



/***************************************************************************
 *
 * void SetupRestoreEngine_m(DesiredStatus);
 *
 * int DesiredStatus;   Whether the user wants to set up or restore
 *
 * DESCRIPTION:
 *  Set engine to 1024 pitch 16BPP with 512k of VGA memory,
 *  or restore the engine and boundary status, as selected by the user.
 *
 * GLOBALS CHANGED:
 *  none
 *
 * CALLED BY:
 *  GetTrueMemSize_m()
 *
 * AUTHOR:
 *  Robert Wolff
 *
 * CHANGE HISTORY:
 *
 * TEST HISTORY:
 *
 ***************************************************************************/
void SetupRestoreEngine_m(int DesiredStatus)
{
    static WORD MiscOptions;    /* Contents of MISC_OPTIONS register */
    static WORD ExtGeConfig;    /* Contents of EXT_GE_CONFIG register */
    static WORD MemBndry;       /* Contents of MEM_BNDRY register */


    if (DesiredStatus == SETUP_ENGINE)
        {
        Passth8514_m(SHOW_ACCEL);

        /*
         * Set up a 512k VGA boundary so "blue screen" writes that happen
         * when we are in accelerator mode won't show up in the wrong place.
         */
        MemBndry = INPW(MEM_BNDRY);     /* Set up shared memory */
        OUTPW(MEM_BNDRY, 0);

        /*
         * Save the contents of the MISC_OPTIONS register, then
         * tell it that we have 4M of video memory. Otherwise,
         * video memory will wrap when it hits the boundary
         * in the MEM_SIZE_ALIAS field.
         */
        MiscOptions = INPW(MISC_OPTIONS);
        OUTPW(MISC_OPTIONS, (WORD) (MiscOptions | MEM_SIZE_4M));

        /*
         * Set 16BPP with pitch of 1024. Only set up the drawing
         * engine, and not the CRT, since the results of this test
         * are not intended to be seen.
         */
        ExtGeConfig = INPW(R_EXT_GE_CONFIG);
        OUTPW(EXT_GE_CONFIG, (WORD)(PIX_WIDTH_16BPP | ORDER_16BPP_565 | 0x000A));
        OUTPW(GE_PITCH, (1024 >> 3));
        OUTPW(GE_OFFSET_HI, 0);
        OUTPW(GE_OFFSET_LO, 0);
        }
    else    /* DesiredStatus == RESTORE_ENGINE */
        {
        /*
         * Restore the memory boundary, MISC_OPTIONS register,
         * and EXT_GE_CONFIG. It is not necessary to reset the
         * drawing engine pitch and offset, because they don't
         * affect what is displayed and they will be set to
         * whatever values are needed when the desired video
         * mode is set.
         */
        OUTPW(EXT_GE_CONFIG, ExtGeConfig);
        OUTPW(MISC_OPTIONS, MiscOptions);
        OUTPW(MEM_BNDRY, MemBndry);

        /*
         * Give the VGA control of the screen.
         */
        Passth8514_m(SHOW_VGA);
        }
    return;

}   /* SetupRestoreEngine_m() */



/***************************************************************************
 *
 * USHORT ReadPixel_m(XPos, YPos);
 *
 * short XPos;      X coordinate of pixel to read
 * short YPos;      Y coordinate of pixel to read
 *
 * DESCRIPTION:
 *  Read a single pixel from the screen.
 *
 * RETURN VALUE:
 *  Colour of pixel at the desired location.
 *
 * GLOBALS CHANGED:
 *  none
 *
 * CALLED BY:
 *  GetTrueMemSize_m()
 *
 * AUTHOR:
 *  Robert Wolff
 *
 * CHANGE HISTORY:
 *
 * TEST HISTORY:
 *
 ***************************************************************************/

USHORT ReadPixel_m(short XPos, short YPos)
{
    USHORT RetVal;

    /*
     * Don't read if the engine is busy.
     */
    WaitForIdle_m();

    /*
     * Set up the engine to read colour data from the screen.
     */
    CheckFIFOSpace_m(SEVEN_WORDS);
    OUTPW(RD_MASK, 0x0FFFF);
    OUTPW(DP_CONFIG, (WORD)(FG_COLOR_SRC_BLIT | DATA_WIDTH | DRAW | DATA_ORDER));
    OUTPW(CUR_X, XPos);
    OUTPW(CUR_Y, YPos);
    OUTPW(DEST_X_START, XPos);
    OUTPW(DEST_X_END, (WORD)(XPos+1));
    OUTPW(DEST_Y_END, (WORD)(YPos+1));

    /*
     * Wait for the engine to process the orders we just gave it and
     * start asking for data.
     */
    CheckFIFOSpace_m(SIXTEEN_WORDS);
    while (!(INPW(GE_STAT) & DATA_READY));

    RetVal = INPW(PIX_TRANS);
    WaitForIdle_m();
    return RetVal;

}   /* ReadPixel_m() */



/***************************************************************************
 *
 * void WritePixel_m(XPos, YPos, Colour);
 *
 * short XPos;      X coordinate of pixel to read
 * short YPos;      Y coordinate of pixel to read
 * short Colour;    Colour to paint the pixel
 *
 * DESCRIPTION:
 *  Write a single pixel to the screen.
 *
 * GLOBALS CHANGED:
 *  none
 *
 * CALLED BY:
 *  GetTrueMemSize_m()
 *
 * AUTHOR:
 *  Robert Wolff
 *
 * CHANGE HISTORY:
 *
 * TEST HISTORY:
 *
 ***************************************************************************/

void WritePixel_m(short XPos, short YPos, short Colour)
{
    /*
     * Set up the engine to paint to the screen.
     */
    CheckFIFOSpace_m(EIGHT_WORDS);
    OUTPW(DP_CONFIG, (WORD)(FG_COLOR_SRC_FG | DRAW | READ_WRITE));
    OUTPW(ALU_FG_FN, MIX_FN_PAINT);
    OUTPW(FRGD_COLOR, Colour);
    OUTPW(CUR_X, XPos);
    OUTPW(CUR_Y, YPos);
    OUTPW(DEST_X_START, XPos);
    OUTPW(DEST_X_END, (WORD)(XPos+1));
    OUTPW(DEST_Y_END, (WORD)(YPos+1));

    return;

}   /* WritePixel_m() */



/***************************************************************************
 *
 * BOOL BlockWriteAvail_m(Query);
 *
 * struct query_structure *Query;   Query information for the card
 *
 * DESCRIPTION:
 *  Test to see whether block write mode is available. This function
 *  assumes that the card has been set to an accelerated mode.
 *
 * RETURN VALUE:
 *  TRUE if this mode is available
 *  FALSE if it is not available
 *
 * GLOBALS CHANGED:
 *  None
 *
 * CALLED BY:
 *  IOCTL_VIDEO_SET_CURRENT_MODE packet of ATIMPStartIO()
 *
 * AUTHOR:
 *  Robert Wolff
 *
 * CHANGE HISTORY:
 *
 * TEST HISTORY:
 *
 ***************************************************************************/

BOOL BlockWriteAvail_m(struct query_structure *Query)
{
    BOOL RetVal = TRUE;
    ULONG ColourMask;   /* Masks off unneeded bits of Colour */
    ULONG Colour;       /* Colour to use in testing */
    USHORT LimitColumn; /* Used to determine when we have finished reading */
    USHORT Column;      /* Column being checked */


    /*
     * Block write mode is only possible on 68800-6 and later cards.
     * If we don't have an appropriate card, then report that this
     * mode is not available.
     */
    if ((Query->q_asic_rev != CI_68800_6) && (Query->q_asic_rev != CI_68800_AX))
        return FALSE;

    /*
     * Block write is only available on VRAM cards.
     */
    if ((Query->q_memory_type == VMEM_DRAM_256Kx4) ||
        (Query->q_memory_type == VMEM_DRAM_256Kx16) ||
        (Query->q_memory_type == VMEM_DRAM_256Kx4_GRAP))
        return FALSE;

    /*
     * Acceleration is not available for pixel depths above 16BPP.
     * Since block write is only used when we are in an accelerated
     * mode, it is not available for high pixel depths.
     */
    if (Query->q_pix_depth > 16)
        return FALSE;

    /*
     * Set up according to the current pixel depth. At 16BPP, we must make
     * one read per pixel, but at 8BPP we only make one read per two pixels,
     * since we will be reading 16 bits at a time. Our display driver
     * does not support 4BPP.
     */
    if (Query->q_pix_depth == 16)
        {
        ColourMask = 0x0000FFFF;
        LimitColumn = 512;
        }
    else
        {
        ColourMask = 0x000000FF;
        LimitColumn = 256;
        }

    /*
     * Clear the block we will be testing.
     */
    CheckFIFOSpace_m(TEN_WORDS);
    OUTPW(WRT_MASK, 0x0FFFF);
    OUTPW(DEST_CMP_FN, 0);
    OUTPW(DP_CONFIG, (WORD)(FG_COLOR_SRC_FG | DRAW | READ_WRITE));
    OUTPW(ALU_FG_FN, MIX_FN_PAINT);
    OUTPW(FRGD_COLOR, 0);
    OUTPW(CUR_X, 0);
    OUTPW(CUR_Y, 0);
    OUTPW(DEST_X_START, 0);
    OUTPW(DEST_X_END, 512);
    OUTPW(DEST_Y_END, 1);
    WaitForIdle_m();

    /*
     * To test block write mode, try painting each of the alternating bit
     * patterns, then read the block back one pixel at a time. If there
     * is at least one mismatch, then block write is not supported.
     */
    for (Colour = 0x5555; Colour < 0x10000; Colour *= 2)
        {
        /*
         * Paint the block.
         */
        CheckFIFOSpace_m(ELEVEN_WORDS);
        OUTPW(MISC_OPTIONS, (WORD)(INPW(MISC_OPTIONS) | BLK_WR_ENA));
        OUTPW(WRT_MASK, 0x0FFFF);
        OUTPW(DEST_CMP_FN, 0);
        OUTPW(DP_CONFIG, (WORD)(FG_COLOR_SRC_FG | DRAW | READ_WRITE));
        OUTPW(ALU_FG_FN, MIX_FN_PAINT);
        OUTPW(FRGD_COLOR, (WORD)(Colour & ColourMask));
        OUTPW(CUR_X, 0);
        OUTPW(CUR_Y, 0);
        OUTPW(DEST_X_START, 0);
        OUTPW(DEST_X_END, 512);
        OUTPW(DEST_Y_END, 1);

        if(!WaitForIdle_m())
            {
            RetVal = FALSE;
            break;
            }

        /*
         * Set up the engine to read colour data from the screen.
         */
        CheckFIFOSpace_m(SEVEN_WORDS);
        OUTPW(RD_MASK, 0x0FFFF);
        OUTPW(DP_CONFIG, (WORD)(FG_COLOR_SRC_BLIT | DATA_WIDTH | DRAW | DATA_ORDER));
        OUTPW(CUR_X, 0);
        OUTPW(CUR_Y, 0);
        OUTPW(DEST_X_START, 0);
        OUTPW(DEST_X_END, 512);
        OUTPW(DEST_Y_END, 1);

        /*
         * Wait for the engine to process the orders we just gave it and
         * start asking for data.
         */
        CheckFIFOSpace_m(SIXTEEN_WORDS);
        for (Column = 0; Column < LimitColumn; Column++)
            {
            /*
             * Ensure that the next word is available to be read
             */
            while (!(INPW(GE_STAT) & DATA_READY));
            
            /*
             * If even one pixel is not the colour we tried to paint it,
             * then block write is not available.
             */
            if (INPW(PIX_TRANS) != (WORD)Colour)
                {
                RetVal = FALSE;
                }
            }
        }


    /*
     * If block write is unavailable, turn off the block write bit.
     */
    if (RetVal == FALSE)
        OUTPW(MISC_OPTIONS, (WORD)(INPW(MISC_OPTIONS) & ~BLK_WR_ENA));

    return RetVal;

}   /* BlockWriteAvail_m() */



/***************************************************************************
 *
 * BOOL IsMioBug_m(Query);
 *
 * struct query_structure *Query;   Query information for the card
 *
 * DESCRIPTION:
 *  Test to see whether the card has the multiple input/output
 *  hardware bug, which results in corrupted draw operations
 *  on fast machines.
 *
 * RETURN VALUE:
 *  TRUE if this bug is present
 *  FALSE if it is not present
 *
 * GLOBALS CHANGED:
 *  None
 *
 * CALLED BY:
 *  IOCTL_VIDEO_ATI_GET_MODE_INFORMATION packet of ATIMPStartIO()
 *
 * AUTHOR:
 *  Robert Wolff
 *
 * CHANGE HISTORY:
 *
 * TEST HISTORY:
 *
 ***************************************************************************/

BOOL IsMioBug_m(struct query_structure *Query)
{
    /*
     * This hardware problem is only present on 68800-3 VLB cards.
     * Assume that all these cards are affected.
     */
    if ((Query->q_asic_rev == CI_68800_3) &&
        (Query->q_system_bus_type != MicroChannel) &&
        ((Query->q_bus_type == BUS_LB_386SX) ||
         (Query->q_bus_type == BUS_LB_386DX) ||
         (Query->q_bus_type == BUS_LB_486)))
        {
        VideoDebugPrint((DEBUG_DETAIL, "MIO bug found\n"));
        return TRUE;
        }
    else
        {
        VideoDebugPrint((DEBUG_DETAIL, "MIO bug not found\n"));
        return FALSE;
        }

}   /* IsMioBug_m() */

//********************   end  of  QUERY_M.C   ***************************
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\cirrus\disp\7555over.c ===
/**********************************************************
*  Copyright (c) 1996-1997 Microsoft Corporation.
*  Copyright (c) 1996-1997 Cirrus Logic, Inc.
***********************************************************
*       File Name:  7555OVER.C
*
*       Module Abstract:
*       ----------------
*       This contains functions needed to support overlay hardware.
*
*       Functions:
*       ----------
*
***********************************************************
*       Author: Teresa Tao
*       Date:   10/22/96
*
*  Revision History:
*  -----------------
* myf31 :02-24-97 : Fixed enable HW Video, panning scrolling enable,screen move
*                   video window have follow moving
* myf34 :04-15-97 : Supported YUY2 format for NT.
***********************************************************/


/* #includes ---------------------------------------------*/
#include "PreComp.h"

#if DIRECTDRAW
#include "overlay.h"
#include "7555bw.h"

static int ScaleMultiply(DWORD   dw1,
                         DWORD   dw2,
                         LPDWORD pdwResult);


/**********************************************************
*
*       Name:  RegInit7555Video
*
*       Module Abstract:
*       ----------------
*       This function is called to program the video format and
*       the physicall offset of the video data in the frame buffer.
*
*       Output Parameters:
*       ------------------
*       none
*
***********************************************************
*       Author: Teresa Tao
*       Date:   10/22/96
*
*  Revision History:
*  -----------------
*
*********************************************************/

VOID RegInit7555Video (PDEV * ppdev,PDD_SURFACE_LOCAL lpSurface)
{
    DWORD dwTemp;
    DWORD dwFourcc;
    WORD  wBitCount;

    LONG lPitch;
    WORD wTemp;
    RECTL rDest;
    WORD wSrcWidth;
    WORD wSrcWidth_clip;
    WORD wDestWidth;
    WORD wSrcHeight;
    WORD wSrcHeight_clip;
    WORD wDestHeight;
    DWORD dwFBOffset;
    BYTE bRegCR31;
    BYTE bRegCR32;
    BYTE bRegCR33;
    BYTE bRegCR34;
    BYTE bRegCR35;
    BYTE bRegCR36;
    BYTE bRegCR37;
    BYTE bRegCR38;
    BYTE bRegCR39;
    BYTE bRegCR3A;
    BYTE bRegCR3B;
    BYTE bRegCR3C;
    BYTE bRegCR3D;
    BYTE bRegCR3E;
    BYTE bRegCR3F;
    BYTE bRegCR40;
    BYTE bRegCR41;
    BYTE bRegCR42;
    BYTE bRegCR51;
    BYTE bRegCR5D;              //myf32
    BYTE bRegCR5F;              //myf32
    BYTE bRegSR2F;              //myf32
    BYTE bRegSR32;              //myf32
    BYTE bRegSR34;              //myf32
    BYTE bTemp;
    BYTE bVZoom;
    WORD fTemp=0;
    ULONG ulTemp=0;
    BOOL  bOverlayTooSmall = FALSE;
    static DWORD giAdjustSource;

    //myf32 added
    bRegSR2F = Regs.bSR2F;
    bRegSR32 = Regs.bSR32;
    bRegSR34 = Regs.bSR34;

    bRegCR5D = Regs.bCR5D;
    CP_OUT_BYTE(ppdev->pjPorts, CRTC_INDEX, 0x5F);
    bRegCR5F = CP_IN_BYTE(ppdev->pjPorts, CRTC_DATA);
    bRegCR5F |= (Regs.bCR5F & 0x80);
    //myf32 end

    /*
     * Init some values
     */
    CP_OUT_BYTE(ppdev->pjPorts, CRTC_INDEX, 0x42);
//  bRegCR42 = CP_IN_BYTE(ppdev->pjPorts, CRTC_DATA) & 0xFC;  //mask Chroma key
                                                              // & FIFO
    bRegCR42 = CP_IN_BYTE(ppdev->pjPorts, CRTC_DATA) & 0xF0;  //mask Chroma key
                                                              // & FIFO, myf32
    bRegCR42 |= (Regs.bCR42 & CR42_MVWTHRESH);   //myf32
    bRegCR42 |= 0x10;
    CP_OUT_BYTE(ppdev->pjPorts, CRTC_INDEX, 0x36);              //myf29
    bRegCR36 = CP_IN_BYTE(ppdev->pjPorts, CRTC_DATA) & 0x40;    //myf29
    bRegCR36 |= 0x20;                   //set Excess 128 Data Format, myf29

    /*
     * Determine the format of the video data
     */
    if (lpSurface->dwFlags & DDRAWISURF_HASPIXELFORMAT)
    {
        GetFormatInfo (ppdev,&(lpSurface->lpGbl->ddpfSurface),
                             &dwFourcc, &wBitCount);
    }
    else
    {
        // This needs to be changed when primary surface is RGB 5:6:5
        dwFourcc = BI_RGB;
        wBitCount = (WORD) ppdev->cBitsPerPixel;
    }

    /*
     * Determine the rectangle for the video window
     */
    PanOverlay1_Init(ppdev, lpSurface, &rDest, &ppdev->rOverlaySrc,
                     &ppdev->rOverlayDest, dwFourcc, wBitCount);
    // rVideoRect is now adjusted and clipped to the panning viewport.
    // disable overlay if totally clipped by viewport

    if (((rDest.right - rDest.left) <= 0) ||
        ((rDest.bottom - rDest.top) <= 0))
    {
        bOverlayTooSmall = TRUE;
    }
    dwTemp = (DWORD)(ppdev->min_Yscreen - ppdev->rOverlayDest.top);
    if ((ppdev->rOverlaySrc.bottom - ppdev->rOverlaySrc.top -(LONG)dwTemp) <=0)
        bOverlayTooSmall = TRUE;

    lPitch = lpSurface->lpGbl->lPitch;

    wSrcWidth_clip  = (WORD)(LONG)(ppdev->rOverlaySrc.right - srcLeft_clip);
    wSrcHeight_clip = (WORD)(LONG)(ppdev->rOverlaySrc.bottom - srcTop_clip);

    wSrcWidth  = (WORD)(LONG)(ppdev->rOverlaySrc.right - ppdev->rOverlaySrc.left);
    wDestWidth = (WORD)(LONG)(ppdev->rOverlayDest.right - ppdev->rOverlayDest.left);
    wSrcHeight = (WORD)(LONG)(ppdev->rOverlaySrc.bottom - ppdev->rOverlaySrc.top);
    wDestHeight = (WORD)(LONG)(ppdev->rOverlayDest.bottom - ppdev->rOverlayDest.top);

    // Determine horizontal upscale coefficient (CR31[7:0],CR39[7:4])
    wTemp = ((WORD)(((DWORD)wSrcWidth  << 12) / (DWORD)wDestWidth)) & 0x0FFF;
    if (wTemp != 0 && bLeft_clip)
    {
        srcLeft_clip = srcLeft_clip *(LONG)wTemp/4096 + ppdev->rOverlaySrc.left;
        wSrcWidth_clip = (WORD)(LONG)(ppdev->rOverlaySrc.right - srcLeft_clip);
    }
    else if (bLeft_clip)
    {
        srcLeft_clip = srcLeft_clip + ppdev->rOverlaySrc.left;
        wSrcWidth_clip = (WORD)(LONG)(ppdev->rOverlaySrc.right - srcLeft_clip);
    }

    bRegCR39 = (BYTE)((wTemp & 0x0F) << 4);
    bRegCR31 = (BYTE)(wTemp >> 4) & 0xFF;

    // Determine vertical upscale coefficient (CR32[7:0],CR39[3:0])
    bVZoom=0;
    wTemp = ((WORD)(((DWORD)wSrcHeight << 12) / (DWORD)wDestHeight)) & 0x0FFF;
    if (wTemp != 0) {
        bVZoom=1;
        fTemp = wTemp;
        if (fTemp < 2048 ) // Zoom > 2.0
            wTemp=((WORD)(((DWORD)wSrcHeight << 12) / (DWORD)(wDestHeight+1))) & 0x0FFF;
    }
    if (wTemp != 0 && bTop_clip)
    {
        srcTop_clip = srcTop_clip * (LONG)wTemp/4096 + ppdev->rOverlaySrc.top;
        wSrcHeight_clip = (WORD)(LONG)(ppdev->rOverlaySrc.bottom -srcTop_clip);
    }
    else if (bTop_clip)
    {
        srcTop_clip = srcTop_clip + ppdev->rOverlaySrc.top;
        wSrcHeight_clip = (WORD)(LONG)(ppdev->rOverlaySrc.bottom -srcTop_clip);
    }

    bRegCR39 |= (BYTE)(wTemp & 0x0F);
    bRegCR32 = (BYTE)(wTemp >> 4) & 0xFF;
    DISPDBG((0,"wTemp = 0x%x",wTemp));

    // Determine Vertical Height (CR38[7:0], CR36[3:2])
//    wTemp = wSrcHeight;
    wTemp = wSrcHeight_clip;    //myf32
    DISPDBG((0,"fTemp = 0x%x",fTemp));
    if (wTemp != 0 &&
        (fTemp > 2730 || fTemp ==0 || ( fTemp > 1365 && fTemp < 2048 ) ) )
        wTemp--;       //#tt10, Height minus one only if upscale rate <1.5
                       //#tt10  2 <    <3

    bRegCR38 = (BYTE)wTemp;
    bRegCR36 |= (wTemp & 0x0300) >> 6;


    // Determine Horizontal position start (CR34[7:0], CR33[7:5])
    // handle 7555-BB MVA pitch bug (QWORD should be DWORD)
    wTemp    = (WORD)rDest.left;
    bRegCR34 = (BYTE)wTemp;
    bRegCR33 = (wTemp & 0x0700) >> 3;

    // Reset Brightness control (CR35[7:0])
    bRegCR35 = 0x0;

    // Determine Vertical Start (CR37[7:0], CR36[1:0])
    wTemp    = (WORD)rDest.top;
    bRegCR37 = (BYTE)wTemp;
    bRegCR36 |= (wTemp & 0x0300) >> 8;


    // Determine Video Start Address (CR40[0], CR3A[6:0], CR3E[7:0], CR3F[3:0])
    giAdjustSource = (srcTop_clip * lpSurface->lpGbl->lPitch)
                   + ((srcLeft_clip * wBitCount) >> 3); //myf32
//  giAdjustSource = (ppdev->rOverlaySrc.top * lpSurface->lpGbl->lPitch)
//                     + ((ppdev->rOverlaySrc.left * wBitCount) >> 3);
    ppdev->sOverlay1.lAdjustSource = giAdjustSource;    //myf32
    dwFBOffset = (DWORD)(lpSurface->lpGbl->fpVidMem + giAdjustSource);
//  dwFBOffset = (lpSurface->lpGbl->fpVidMem - ppdev->dwScreenFlatAddr)
//             + giAdjustSource;        //myf32

    DISPDBG((0,"lpSurface->lpGbl->fpVidMem = 0x%08x",
                                  lpSurface->lpGbl->fpVidMem));
    DISPDBG((0,"giAdjustSource = 0x%08x",giAdjustSource));
    DISPDBG((0,"dwFBOffset = 0x%08x",dwFBOffset));

    dwFBOffset >>= 2;

    CP_OUT_BYTE(ppdev->pjPorts, CRTC_INDEX, 0x3A);
    bTemp = CP_IN_BYTE(ppdev->pjPorts, CRTC_DATA) ;

    bRegCR3A = (bTemp & ~0x7F) | (BYTE)((dwFBOffset & 0x0FE000) >> 13);
    bRegCR3E = (BYTE)((dwFBOffset & 0x001FE0) >> 5);

    CP_OUT_BYTE(ppdev->pjPorts, CRTC_INDEX, 0x3F);
    bTemp = CP_IN_BYTE(ppdev->pjPorts, CRTC_DATA);
    bRegCR3F = (bTemp & ~0x0F) | (BYTE)((dwFBOffset & 0x00001E) >> 1);

    CP_OUT_BYTE(ppdev->pjPorts, CRTC_INDEX, 0x40);
    bTemp = CP_IN_BYTE(ppdev->pjPorts, CRTC_DATA) ;
    bRegCR40 = (bTemp & ~0x01) | (BYTE)(dwFBOffset & 0x000001);

    //Determine Video Pitch (CR3B[7:0], CR36[4])
    wTemp = (WORD)(lpSurface->lpGbl->lPitch >> 4);              //QWORDs

    bRegCR3B = (BYTE)wTemp;
    bRegCR36 |= (wTemp & 0x0100) >> 4;

    // Determine Data Format (CR3E[3:0])
    CP_OUT_BYTE(ppdev->pjPorts, CRTC_INDEX, 0x3C);
    bRegCR3C = CP_IN_BYTE(ppdev->pjPorts, CRTC_DATA) & 0x10;
                                                //mask out prev VW width

    switch (dwFourcc)
    {
       case FOURCC_PACKJR:
           bRegCR3C |= 0x02;                    // Pack JR
           break;

       case BI_RGB:
           switch(wBitCount)
           {
             case 8:
                bRegCR3C |= 0x09;               // 8 bit palettized
                break;

             case 16:
                bRegCR3C |= 0x01;               // RGB 5:5:5
                break;
           }
           break;

       //myf32 added
       case BI_BITFIELDS:
           switch(wBitCount)
           {
             case 8:
                bRegCR3C |= 0x09;               // 8 bit palettized
                break;

             case 16:
                bRegCR3C |= 0x04;               // RGB 5:6:5
                break;
           }
           break;
       //myf32 end

       case FOURCC_YUV422:
           bRegCR3C |= 0x03;                    // YUV 4:2:2
           break;

       case FOURCC_YUY2:                //myf34 test
           bRegCR3C |= 0x03;                    // YUY2
//         CP_OUT_BYTE(ppdev->pjPorts, SR_INDEX, 0x2C);
//         bRegSR2C = CP_IN_BYTE(ppdev->pjPorts, SR_DATA) ;
//         bRegSR2C |= 0x40;            //SR2c[6] = 1
//         CP_OUT_WORD(ppdev->pjPorts, SR_INDEX, 0x2C |(WORD)bRegSR2C << 8);
           break;
    }


    // Determine Horizontal width (CR3D[7:0], CR3C[7:5])
    // NOTE: assumes Horz Pixel Width [0] = 0

    wTemp = wSrcWidth_clip;     //myf32
//  wTemp = wSrcWidth;

    if (wTemp != 0 ) wTemp--;                   //Width minus one for laptop
    bRegCR3D = (BYTE)((WORD)wTemp >> 1);
    bRegCR3C |= (wTemp & 0x0600) >> 3;
    bRegCR3C |= (BYTE)((wTemp & 0x0001) << 5) ;


    // Enable Horizontal Pixel Interpolation (CR3F[7])
    bRegCR3F |= 0x80;

    // Enable Vertical Pixel Interpolation (CR3F[6])
    //#tt Debug- The CE rev. has problem when vertical interpolation is on
    //#tt Debug- Disable it for now.
    //#tt   bRegCR3F |= 0x40;

    // Enable Right Side transition threshold (CR41[5:0])
    bRegCR41 = 0x3E;

    // Disable V-PORT (CR58[7:0])
    bRegCR51 = 0x0;

    /*
     * If we are color keying, we will set that up now
     */
    if (lpSurface->dwReserved1 & OVERLAY_FLG_COLOR_KEY)
    {
        bRegCR3F |= 0x20;               //Enable Occlusion
        bRegCR42 &= ~0x1;               //Disable Chroma Key
        bRegCR5F &= ~0x80;      //myf32 //Disable CR5D[7:0] if color key,
                                        //so disable CR5F[7]
        bRegCR5D = 0;           //myf32

        CP_OUT_BYTE(ppdev->pjPorts, CRTC_INDEX, 0x1A);
        bTemp = CP_IN_BYTE(ppdev->pjPorts, CRTC_DATA);

        // Set CR1A[3:2] to timing ANDed w/ color
        bTemp &= ~0x0C;
        CP_OUT_BYTE(ppdev->pjPorts, CRTC_DATA, bTemp);

        CP_OUT_BYTE(ppdev->pjPorts, CRTC_INDEX, 0x1D);
        bTemp = CP_IN_BYTE(ppdev->pjPorts, CRTC_DATA) ;

        if (ppdev->cBitsPerPixel == 8)
        {
            CP_OUT_BYTE(ppdev->pjPorts, CRTC_DATA, (bTemp & ~0x38));
            ulTemp= 0x0C | (ppdev->wColorKey << 8);
            CP_OUT_WORD(ppdev->pjPorts, INDEX_REG, ulTemp);// Output color to GRC
            ulTemp= 0x0D;
            CP_OUT_WORD(ppdev->pjPorts, INDEX_REG, ulTemp);// Output color to GRD

        }
        else
        {
            CP_OUT_BYTE(ppdev->pjPorts, CRTC_DATA, (bTemp & ~0x30) | 0x08);
            ulTemp= 0x0C | (ppdev->wColorKey << 8);
            CP_OUT_WORD(ppdev->pjPorts, INDEX_REG, ulTemp);// Output color to GRC
            ulTemp= 0x0D | (ppdev->wColorKey & 0xff00);
            CP_OUT_WORD(ppdev->pjPorts, INDEX_REG, ulTemp);// Output color to GRD

        }
    }
    else if (lpSurface->dwReserved1 & OVERLAY_FLG_SRC_COLOR_KEY)
    {
        BYTE bYMax, bYMin, bUMax, bUMin, bVMax, bVMin;

        bRegCR3F |= 0x20;               //Enable Occlusion
        bRegCR42 |= 0x1;                //Enable Chroma Key
        bRegCR5F &= ~0x80;      //myf32 //Disable CR5D[7:0] if color key,
                                        //so disable CR5F[7]
        bRegCR5D = 0;           //myf32

        CP_OUT_BYTE(ppdev->pjPorts, CRTC_INDEX,  0x1A);
        bTemp = CP_IN_BYTE(ppdev->pjPorts, CRTC_DATA) ;
        // Set CR1A[3:2] to timing ANDed w/ color
        bTemp &= ~0x0C;
        CP_OUT_BYTE(ppdev->pjPorts, CRTC_DATA,  bTemp);

        /*
         * Determine min/max values
         */
        if ((dwFourcc == FOURCC_YUV422) || (dwFourcc == FOURCC_YUVPLANAR) ||
            (dwFourcc == FOURCC_YUY2) ||                //myf34
            (dwFourcc == FOURCC_PACKJR))                //myf32
        {
            bYMax = (BYTE)(DWORD)(ppdev->dwSrcColorKeyHigh >> 16);
            bYMin = (BYTE)(DWORD)(ppdev->dwSrcColorKeyLow >> 16);
            bUMax = (BYTE)(DWORD)((ppdev->dwSrcColorKeyHigh >> 8) & 0xff);
            bUMin = (BYTE)(DWORD)((ppdev->dwSrcColorKeyLow >> 8) & 0xff);
            bVMax = (BYTE)(ppdev->dwSrcColorKeyHigh & 0xff);
            bVMin = (BYTE)(ppdev->dwSrcColorKeyLow & 0xff);
            if (dwFourcc == FOURCC_PACKJR)
            {
                bYMax |= 0x07;
                bUMax |= 0x03;
                bVMax |= 0x03;
                bYMin &= ~0x07;
                bUMin &= ~0x03;
                bVMin &= ~0x03;
            }
        }
        else if ((dwFourcc == 0) && (wBitCount == 16))
        {
            /*
             * RGB 5:5:5
             */
            bYMax = (BYTE)(DWORD)((ppdev->dwSrcColorKeyHigh >> 7) & 0xF8);
            bYMin = (BYTE)(DWORD)((ppdev->dwSrcColorKeyLow >> 7) & 0xF8);
            bUMax = (BYTE)(DWORD)((ppdev->dwSrcColorKeyHigh >> 2) & 0xF8);
            bUMin = (BYTE)(DWORD)((ppdev->dwSrcColorKeyLow >> 2) & 0xF8);
            bVMax = (BYTE)(ppdev->dwSrcColorKeyHigh << 3);
            bVMin = (BYTE)(ppdev->dwSrcColorKeyLow << 3);
            bYMax |= 0x07;
            bUMax |= 0x07;
            bVMax |= 0x07;

        }
        else if (dwFourcc == BI_BITFIELDS)
        {
            /*
             * RGB 5:6:5
             */
            bYMax = (BYTE)(DWORD)((ppdev->dwSrcColorKeyHigh >> 8) & 0xF8);
            bYMin = (BYTE)(DWORD)((ppdev->dwSrcColorKeyLow >> 8) & 0xF8);
            bUMax = (BYTE)(DWORD)((ppdev->dwSrcColorKeyHigh >> 3) & 0xFC);
            bUMin = (BYTE)(DWORD)((ppdev->dwSrcColorKeyLow >> 3) & 0xFC);
            bVMax = (BYTE)(ppdev->dwSrcColorKeyHigh << 3);
            bVMin = (BYTE)(ppdev->dwSrcColorKeyLow << 3);
            bYMax |= 0x07;
            bUMax |= 0x03;
            bVMax |= 0x07;
        }
        CP_OUT_WORD(ppdev->pjPorts, INDEX_REG, (0x0C | (WORD)bYMin <<8));//GRC
        CP_OUT_WORD(ppdev->pjPorts, INDEX_REG, (0x0D | (WORD)bYMax <<8));//GRd
        CP_OUT_WORD(ppdev->pjPorts, INDEX_REG, (0x1C | (WORD)bUMin <<8));//GR1C
        CP_OUT_WORD(ppdev->pjPorts, INDEX_REG, (0x1D | (WORD)bUMax <<8));//GR1D
        CP_OUT_WORD(ppdev->pjPorts, INDEX_REG, (0x1E | (WORD)bVMin <<8));//GR1E
        CP_OUT_WORD(ppdev->pjPorts, INDEX_REG, (0x1F | (WORD)bVMax <<8));//GR1F

    }
    else
    {
        CP_OUT_BYTE(ppdev->pjPorts, CRTC_INDEX,  0x1A);
        bTemp = CP_IN_BYTE(ppdev->pjPorts, CRTC_DATA) ;
        CP_OUT_BYTE(ppdev->pjPorts, CRTC_INDEX,  (bTemp & ~0x0C));
        bRegCR3F &= ~0x20;                      // disable occlusion

    }

    /*
     * Set up alignment info
     */
    if (ppdev->cBitsPerPixel != 24)
    {
        WORD wXAlign;
        WORD wXSize;

        if (ppdev->cBitsPerPixel == 8)
        {
            wXAlign = (WORD)rDest.left & 0x03;
            wXSize = (WORD)(rDest.right - rDest.left) & 0x03;
        }
        else
        {
            wXAlign = (WORD)(rDest.left & 0x01) << 1;
            wXSize = (WORD)((rDest.right - rDest.left) & 0x01) << 1;
        }
    }

    //  disable overlay if totally clipped by viewport
    //  or overlay is too small to be supported by HW
    //
    if (bOverlayTooSmall)
    {
        DisableVideoWindow(ppdev);                      // disable overlay
        ppdev->dwPanningFlag |= OVERLAY_OLAY_REENABLE;  // totally clipped
    }
    else
    {

        /*
         * Program the video window registers
        */
        //myf32 added
        CP_OUT_WORD(ppdev->pjPorts, SR_INDEX, 0x2F |(WORD)bRegSR2F << 8);//SR2F
        CP_OUT_WORD(ppdev->pjPorts, SR_INDEX, 0x32 |(WORD)bRegSR32 << 8);//SR32
        CP_OUT_WORD(ppdev->pjPorts, SR_INDEX, 0x34 |(WORD)bRegSR34 << 8);//SR34
        //myf32 end

        CP_OUT_WORD(ppdev->pjPorts, CRTC_INDEX, 0x31 | (WORD)bRegCR31 << 8);//CR31
        CP_OUT_WORD(ppdev->pjPorts, CRTC_INDEX, 0x32 | (WORD)bRegCR32 << 8);//CR32

        CP_OUT_WORD(ppdev->pjPorts, CRTC_INDEX, 0x34 | (WORD)bRegCR34 << 8);//CR34
        CP_OUT_WORD(ppdev->pjPorts, CRTC_INDEX, 0x33 | (WORD)bRegCR33 << 8);//CR33

        CP_OUT_WORD(ppdev->pjPorts, CRTC_INDEX, 0x35 | (WORD)bRegCR35 << 8);//CR35
        CP_OUT_WORD(ppdev->pjPorts, CRTC_INDEX, 0x36 | (WORD)bRegCR36 << 8);//CR36
        CP_OUT_WORD(ppdev->pjPorts, CRTC_INDEX, 0x37 | (WORD)bRegCR37 << 8);//CR37
        CP_OUT_WORD(ppdev->pjPorts, CRTC_INDEX, 0x38 | (WORD)bRegCR38 << 8);//CR38
        CP_OUT_WORD(ppdev->pjPorts, CRTC_INDEX, 0x39 | (WORD)bRegCR39 << 8);//CR39
        CP_OUT_WORD(ppdev->pjPorts, CRTC_INDEX, 0x3B | (WORD)bRegCR3B << 8);//CR3B

        CP_OUT_WORD(ppdev->pjPorts, CRTC_INDEX, 0x3C | (WORD)bRegCR3C << 8);//CR3C
        CP_OUT_WORD(ppdev->pjPorts, CRTC_INDEX, 0x3D | (WORD)bRegCR3D << 8);//CR3D
        CP_OUT_WORD(ppdev->pjPorts, CRTC_INDEX, 0x41 | (WORD)bRegCR41 << 8);//CR41
        CP_OUT_WORD(ppdev->pjPorts, CRTC_INDEX, 0x42 | (WORD)bRegCR42 << 8);//CR42
        CP_OUT_WORD(ppdev->pjPorts, CRTC_INDEX, 0x51 | (WORD)bRegCR51 << 8);//CR51

        CP_OUT_WORD(ppdev->pjPorts, CRTC_INDEX, 0x40 | (WORD)bRegCR40 << 8);//CR40
        CP_OUT_WORD(ppdev->pjPorts, CRTC_INDEX, 0x3A | (WORD)bRegCR3A << 8);//CR3A
        CP_OUT_WORD(ppdev->pjPorts, CRTC_INDEX, 0x3E | (WORD)bRegCR3E << 8);//CR3E
        CP_OUT_WORD(ppdev->pjPorts, CRTC_INDEX, 0x3F | (WORD)bRegCR3F << 8);//CR3F
        CP_OUT_WORD(ppdev->pjPorts, CRTC_INDEX, 0x5D | (WORD)bRegCR5D << 8);//CR5D
        CP_OUT_WORD(ppdev->pjPorts, CRTC_INDEX, 0x5F | (WORD)bRegCR5F << 8);//CR5F

        if (lpSurface->dwReserved1 & OVERLAY_FLG_YUVPLANAR)
            CP_OUT_WORD(ppdev->pjPorts, CRTC_INDEX, 0x3F |(WORD)0x10 <<8);

        EnableVideoWindow (ppdev);
    }
}
/**********************************************************
*
*       Name:  RegMoveVideo
*
*       Module Abstract:
*       ----------------
*       This function is called to move the video window that has
*       already been programed.
*
*       Output Parameters:
*       ------------------
*       none
*
***********************************************************
*       Author: Teresa Tao
*       Date:   10/22/96
*
*  Revision History:
*  -----------------
*
*********************************************************/

VOID RegMove7555Video (PDEV * ppdev,PDD_SURFACE_LOCAL lpSurface)
{
     RegInitVideo (ppdev,lpSurface);
}



/**********************************************************
*
*       Name:  DisableVideoWindow
*
*       Module Abstract:
*       ----------------
*       turn off video window
*
*       Output Parameters:
*       ------------------
*       none
*
***********************************************************
*       Author: Teresa Tao
*       Date:   10/22/96
*
*  Revision History:
*  -----------------
*
*********************************************************/
VOID DisableVideoWindow (PDEV * ppdev)
{
    UCHAR    temp;

    DISPDBG((0, "DisableVideoWindow"));

    CP_OUT_BYTE(ppdev->pjPorts, CRTC_INDEX, 0x3c);
    temp = CP_IN_BYTE(ppdev->pjPorts, CRTC_DATA);

    CP_OUT_BYTE(ppdev->pjPorts, CRTC_DATA, (temp & ~0x10));

}

/**********************************************************
*
*       Name:  EnableVideoWindow
*
*       Module Abstract:
*       ----------------
*       turn on video window
*
*       Output Parameters:
*       ------------------
*       none
*
***********************************************************
*       Author: Teresa Tao
*       Date:   10/22/96
*
*  Revision History:
*  -----------------
*
*********************************************************/
VOID EnableVideoWindow (PDEV * ppdev)
{
    UCHAR    temp;
    DISPDBG((0, "EnableVideoWindow"));

    CP_OUT_BYTE(ppdev->pjPorts, CRTC_INDEX, 0x3c);
    temp  = CP_IN_BYTE(ppdev->pjPorts, CRTC_DATA);

    CP_OUT_BYTE(ppdev->pjPorts, CRTC_DATA, (temp | 0x10));

}

/**********************************************************
*
*       Name:  ClearAltFIFOThreshold
*
*       Module Abstract:
*       ----------------
*
*
*       Output Parameters:
*       ------------------
*       none
*
***********************************************************
*       Author: Teresa Tao
*       Date:   10/22/96
*
*  Revision History:
*  -----------------
*
*********************************************************/
VOID ClearAltFIFOThreshold (PDEV * ppdev)
{
    UCHAR    temp;
    DISPDBG((0, "ClearAltFIFOThreshold"));

    CP_OUT_BYTE(ppdev->pjPorts, CRTC_INDEX, 0x41);
    temp  = CP_IN_BYTE(ppdev->pjPorts, CRTC_DATA);

    CP_OUT_BYTE(ppdev->pjPorts, CRTC_DATA, (temp & ~0x20));
}



/**********************************************************
*
*       Name:  Is7555SufficientBandwidth
*
*       Module Abstract:
*       ----------------
*       Determines is sufficient bandwidth exists for the requested
*       configuration.
*
*       Output Parameters:
*       ------------------
*       TRUE/FALSE
*       It also sets the global parameter lFifoThresh, which gets
*       programed in RegInitVideo().
*
***********************************************************
*       Author: Teresa Tao
*       Date:   10/22/96
*
*  Revision History:
*  -----------------
*
*
*
***********************************************************
*
* The FIFOs:
*
*       CRT  FIFO is 28 levels x 64-bits wide (SR7[0])
*       MVA  FIFO is ?? levels x ??-bits wide (????)
*       DSTN FIFO is 16 levels x 32-bits wide (SR2F[3:0])
*
*
***********************************************************/
BOOL Is7555SufficientBandwidth (PDEV * ppdev,WORD wVideoDepth, LPRECTL lpSrc, LPRECTL lpDest, DWORD dwFlags)
{
    //myf33 - New Bandwith Code
    BOOL  fSuccess = FALSE;
    DWORD dwVCLK, dwMCLK;

    USHORT  uMCLKsPerRandom;      //RAS# cycles in MCLKs
    USHORT  uMCLKsPerPage;        //CAS# cycles in MCLKs
    USHORT  uGfxThresh;           //Graphic FIFO Threshold (always 8)
    USHORT  uMVWThresh;           //MVW FIFO Threshold (8,16 or 32)
    USHORT  uDSTNGfxThresh, uDSTNMVWThresh;

    //VPort BW document variables
    USHORT  uGfx, uMVW;           //Graphics, Video Window
    USHORT  uDSTNGfxA, uDSTNGfxB, uDSTNMVWA, uDSTNMVWB;

    USHORT  nVW = 0;              //n (VW), n (Graphics)
    USHORT  nGfx = 0x40;          //n (VW), n (Graphics)
    USHORT  vVW, vGfx;            //v (VW), v (Gfx)

    DWORD dwTemp;
    BOOL fDSTN;
    BYTE bSR0F, bSR20, bSR2F, bSR32, bSR34;
    BYTE bGR18, bCR42;
    BYTE bCR51, bCR5A, bCR5D, bCR01, bCR5F;
    BYTE b3V;
    BOOL fColorKey = FALSE;     //myf32
    DWORD dwSrcWidth, dwDestWidth;

    if (dwFlags & (OVERLAY_FLG_COLOR_KEY | OVERLAY_FLG_SRC_COLOR_KEY))
        fColorKey = TRUE;

//  if ((ppdev->cBitsPerPixel == 16) && (ppdev->cxScreen == 1024))
//      fColorKey = FALSE;

    CP_OUT_BYTE(ppdev->pjPorts, CRTC_INDEX, 0x80);
    bSR0F = CP_IN_BYTE(ppdev->pjPorts, CRTC_DATA) ;
    if ((ppdev->cBitsPerPixel == 16) && fColorKey)
    {
        if (((ppdev->Hres == 1024) && (bSR0F & 1)) ||
            (ppdev->cxScreen == 1024))
        {
            DISPDBG((0, "IsSufficientBandwidth() : 16bpp XGA PANEL || 1K mode"));
            return (FALSE);
        }
    }

    //myf32 begin
    if (ppdev->flCaps & CAPS_TV_ON)            //if TV on disable HW video
    {
//      ppdev->ulCAPS |= CAPS_SW_POINTER;
        DISPDBG((0, "IsSufficientBandwidth() : TV Enable"));
        return (FALSE);
    }

#if 0           //don't support panning scrolling
    if ((ppdev->cxScreen > ppdev->Hres) && (bSR0F & 1))
    {
        DISPDBG((0, "IsSufficientBandwidth() : Panning Scroll Enable"));
        return (FALSE);
    }
#endif

     //myf32 end

    /*
     * Don's support overlay if >=24bpp
     */
    if (ppdev->cBitsPerPixel == 24 || ppdev->cBitsPerPixel == 32)
    {
        DISPDBG((0, "IsSufficientBandwidth() : 24bpp Mode enable"));
        return (FALSE);
    }

    /*
     * Get current register settings from the chip
     */
    CP_OUT_BYTE(ppdev->pjPorts, SR_INDEX, 0x0f);
    bSR0F = CP_IN_BYTE(ppdev->pjPorts, SR_DATA) ;

    CP_OUT_BYTE(ppdev->pjPorts, SR_INDEX, 0x20);
    bSR20 = CP_IN_BYTE(ppdev->pjPorts, SR_DATA);

    CP_OUT_BYTE(ppdev->pjPorts, SR_INDEX, 0x2f);
    bSR2F = CP_IN_BYTE(ppdev->pjPorts, SR_DATA) & ~(BYTE)SR2F_HFAFIFOGFX_THRESH;

    CP_OUT_BYTE(ppdev->pjPorts, SR_INDEX, 0x32);
    bSR32 = CP_IN_BYTE(ppdev->pjPorts, SR_DATA) & ~(BYTE)SR32_HFAFIFOMVW_THRESH;

    CP_OUT_BYTE(ppdev->pjPorts, INDEX_REG, 0x18);
    bGR18 = CP_IN_BYTE(ppdev->pjPorts, DATA_REG) ;

    CP_OUT_BYTE(ppdev->pjPorts, CRTC_INDEX, 0x01);
    bCR01 = CP_IN_BYTE(ppdev->pjPorts, CRTC_DATA);

    CP_OUT_BYTE(ppdev->pjPorts, CRTC_INDEX, 0x5F);
    bCR5F = CP_IN_BYTE(ppdev->pjPorts, CRTC_DATA) & ~0x80;

    bCR5D = 0;
    bCR51 = 0;
    bCR5A = 0x40;       //Alan Kobayashi
    bSR34 = 0;  // @@@ Is this right?


    /*
     * Determine MCLK and VCLK
     */
    dwMCLK = Get7555MCLK(ppdev);        // Measured in KHz
    dwVCLK = GetVCLK(ppdev);            // Measured in KHz
    if ( dwVCLK ==0 )
        return (FALSE);

//myf32 added
    // check if 3.3 voltage, (SR2F[5] =0 : 3V, =1 : 5V)
    if (bSR2F & 0x40)
        b3V = 0;
    else
        b3V = 1;

    if (ppdev->ulChipID == CL7556_ID)
    {
        if (dwVCLK > 80000)
        {
            DISPDBG ((0,"Insuffieint bandwidth() : dwVCLK > 80MHz"));
            return(FALSE);
        }
    }
    else if (ppdev->ulChipID == CL7555_ID)
    {
        if (b3V)
        {
            if (dwVCLK > 65000)
            {
                DISPDBG ((0,"Insuffieint bandwidth() : dwVCLK > 65MHz"));
                return(FALSE);
            }
        }
        else
        {
            if (dwVCLK > 75000)
            {
                DISPDBG ((0,"Insuffieint bandwidth() : dwVCLK > 75MHz"));
                return(FALSE);
            }
        }
    }
//myf32 end


    /*
     * See if there is enough bandwidth.
     *
     * CL-GD7555 has sufficient bandwidth when the following
     *  equation is satisfied:
     *
     * (Gfx + MVW + VP + DSTN) * MCLK Period <= v * VCLK period
     *
     * (Gfx = Graphics, MVW = Motion Video Window, VP = Video
     *  Port, DSTN = Dual Scan Transistor Network, MCLK =
     *  Memory Clock, VCLK = Video Clock)
     *
     * In color/chroma key mode, this equation is checked once
     *  with VP based on n(Gfx), and using v(Gfx).  In non-color/chroma
     *  key mode, this equation is checked twice, once without the
     *  MVW term, basing VP on n(Gfx), using DSTN for Gfx, and using
     *  v(Gfx), and once without the Gfx term, basing VP on n(MVW),
     *  using DSTN for MVW, and using v(MVW).
     */

    /*
     * Graphics = R + (GFX FIFO Threshold - 1)P
     */

    // Get R based on the table (from AHRM v1.1):
    //
    // SR20[6] GR18[2] SR0F[2]  R(MCLKs)
    //
    //   0       1       0         8
    //   1       1       0         9
    //
    uMCLKsPerRandom = 100;    // Start with an invalid value
    if (!(bSR20 & SR20_9MCLK_RAS))
    {
        if (bGR18 & GR18_LONG_RAS)
        {
            if (!(bSR0F & SR0F_DISPLAY_RAS))
                uMCLKsPerRandom = 8;
        }
    }
    else
    {
        if (bGR18 & GR18_LONG_RAS)
        {
            if (!(bSR0F & SR0F_DISPLAY_RAS))
                uMCLKsPerRandom = 9;
        }
    }

    // See if we got a valid value
    if (100 == uMCLKsPerRandom)
    {
        DISPDBG ((0,"IsSufficientBandwidth(): Unknown RAS# cycle timing."));
        goto Error;
    }
    DISPDBG ((0," uMCLKsPerRandom = %u", uMCLKsPerRandom));

    // Get P - We assume 2 MCLKs per page cycle
    uMCLKsPerPage = 2;
    DISPDBG ((0," uMCLKsPerPage = %u", uMCLKsPerPage));

    // Get GFX FIFO Threshold - It's hardwired to 8
    uGfxThresh = GFXFIFO_THRESH;
    DISPDBG ((0," uGfxThresh = %u", uGfxThresh));

    // Graphics = R + (GFX FIFO Threshold - 1) * P
    uGfx = uMCLKsPerRandom + ((uGfxThresh - 1) * uMCLKsPerPage);
    DISPDBG ((0," uGfx = %u", uGfx));


    /*
     * Video Window = R + (VW FIFO Threshold - 1) * P
     */

    // Get VW FIFO Threshold - From table (on BW sheet)
    //
    // GFX Depth  MVW Depth  VW FIFO Thresh
    //
    //     8          8            8
    //    16          8            8
    //     8         16           16
    //    16         16            8
    //
    if (fColorKey)
    {
        if (wVideoDepth > 8)
        {
            if (ppdev->cBitsPerPixel > 8)
                uMVWThresh = 8;
            else
                uMVWThresh = 16;
        }
        else
            uMVWThresh = 8;
    }
    else
    {
        if (wVideoDepth > 8)
            uMVWThresh = 8;
        else
            uMVWThresh = 16;
    }
    DISPDBG ((0," uMVWThresh = %u", uMVWThresh));

    // Video Window = R + (VW FIFO Threshold - 1) * P
    uMVW = uMCLKsPerRandom + ((uMVWThresh - 1) * uMCLKsPerPage);
    DISPDBG ((0," uMVW = %u", uMVW));


    // Determine Source and Destination VW Widths
    dwSrcWidth = lpSrc->right - lpSrc->left;
    dwDestWidth = lpDest->right - lpDest->left;
    DISPDBG ((0," dwSrcWidth = %d", dwSrcWidth));
    DISPDBG ((0," dwDestWidth = %d", dwDestWidth));


    // If the video port capture is enabled, calculate VPort stuff
#if 0   //00 for New structure Code
    if (dwFlags & OVERLAY_FLG_CAPTURE )
    {
        int iNumShift, iDenomShift;
        DWORD dwNum, dwDenom;
        DWORD dwXferRate;
        DWORD dwVPortFreq;

        // Convert transfer rate to video port frequency, which assumes
        //  16-bits per clock
        if (!dwMaxPixelsPerSecond)
            dwXferRate = 14750000ul;
        else
            dwXferRate = dwMaxPixelsPerSecond;

         dwXferRate = 14750000ul;       //hardcoded temporarily

         dwVPortFreq = (dwXferRate * (DWORD)wVideoDepth) / 16;
         DISPDBG ((0," dwVPortFreq = %lu", dwVPortFreq));

        /*
         * V-Port = R + (n - 1) * P
         *
         * n is calculated for graphics and video window.
         */

        // Calculate n(Gfx) and VPort(Gfx)

        // n(Gfx) = VPort freq * Gfx Thresh * VPort depth   cap wdth
        //          ------------------------------------- * ---------
        //                    VCLK * Gfx depth              xfer wdth

        // Being very careful to avoid overflows while maintaining decent
        //  accuracy.

        iNumShift = ScaleMultiply(dwVPortFreq, (DWORD)uGfxThresh, &dwNum);
        DISPDBG ((0," dwNum = %lu, iNumShift = %d", dwNum, iNumShift));
        iNumShift += ScaleMultiply(dwNum, (DWORD)wVideoDepth, &dwNum);
        DISPDBG ((0," dwNum = %lu, iNumShift = %d", dwNum, iNumShift));
        iNumShift += ScaleMultiply(dwNum, (DWORD)dwPrescaleWidth, &dwNum);
        DISPDBG ((0," dwNum = %lu, iNumShift = %d", dwNum, iNumShift));

        iDenomShift = ScaleMultiply(dwVCLK, (DWORD)wGfxDepth,&dwDenom);
        DISPDBG ((0," dwDenom = %lu, iDenomShift = %d", dwDenom, iDenomShift));
        iDenomShift += ScaleMultiply(dwDenom, (DWORD)dwCropWidth, &dwDenom);
        DISPDBG ((0," dwDenom = %lu, iDenomShift = %d", dwDenom, iDenomShift));

        // Even things up for the divide
        if (iNumShift > iDenomShift)
        {
            dwDenom >>= (iNumShift - iDenomShift);
        }
        else if (iDenomShift > iNumShift)
        {
            dwNum >>= (iDenomShift - iNumShift);
        }
        DISPDBG ((0," dwNum = %lu, dwDenom = %lu", dwNum, dwDenom));

        // Be sure rounding below doesn't overflow
        if ((0xFFFFFFFF - dwDenom) < dwNum)
        {
            dwNum >>= 1;
            dwDenom >>= 1;
        }
        DISPDBG ((0," dwNum = %lu, dwDenom = %lu", dwNum, dwDenom));

        // Protect from a divide by 0 - this should never happen
        if (0 == dwDenom)
        {
            DISPDBG ((0,"ChipCheckBandwidth(): Invalid n(Gfx) denominator (0)."));
            goto Error;
        }

        // Round up
        nGfx = (UINT)((dwNum + dwDenom - 1ul) / dwDenom);
        DISPDBG ((0," nGfx = %u", nGfx));

        // Only 3 bits for nGfx, so scale it and save factor
        uGfxFactor = 1;
        while (nGfx > 7)
        {
            nGfx++;
            nGfx >>= 1;
            uGfxFactor <<= 1;
            DISPDBG ((0," nGfx = %u, uGfxFactor = %u", nGfx, uGfxFactor));
        }

        // For a 0 n(Gfx), we assume the overhead is negligible.
        if (0 == nGfx)
        {
            uVPortGfx = 0;
        }
        else
        {
            // V-Port = R + (n - 1) * P
            uVPortGfx = uMCLKsPerRandom + ((nGfx - 1) * uMCLKsPerPage);
            uVPortGfx *= uGfxFactor;
        }
        DISPDBG ((0," uVPortGfx = %u", uVPortGfx));

        // If the video window is enabled, calculate n(MVW) and VPort(MVW)
        if (dwFlags & OVERLAY_FLG_CAPTURE)
        {
            // n(VW) = VPort freq * VW Thresh * VPort depth   disp wdth   cap wdth
            //         ------------------------------------ * --------- * ---------
            //                   VCLK * VW depth              src wdth    xfer wdth

            // Being very careful to avoid overflows while maintaining decent
            //  accuracy.

            iNumShift = ScaleMultiply(dwVPortFreq, (DWORD)uMVWThresh, &dwNum);
            DISPDBG ((0," dwNum = %lu, iNumShift = %d", dwNum, iNumShift));
            iNumShift += ScaleMultiply(dwNum, (DWORD)wVideoDepth, &dwNum);
            DISPDBG ((0," dwNum = %lu, iNumShift = %d", dwNum, iNumShift));
            iNumShift += ScaleMultiply(dwNum, (DWORD)dwDestWidth, &dwNum);
            DISPDBG ((0," dwNum = %lu, iNumShift = %d", dwNum, iNumShift));
            iNumShift += ScaleMultiply(dwNum, (DWORD)dwPrescaleWidth, &dwNum);
            DISPDBG ((0," dwNum = %lu, iNumShift = %d", dwNum, iNumShift));

            iDenomShift = ScaleMultiply(dwVCLK, (DWORD)wVideoDepth, &dwDenom);
            DISPDBG ((0," dwDenom = %lu, iDenomShift = %d", dwDenom, iDenomShift));
            iDenomShift += ScaleMultiply(dwDenom, (DWORD)dwSrcWidth, &dwDenom);
            DISPDBG ((0," dwDenom = %lu, iDenomShift = %d", dwDenom, iDenomShift));
            iDenomShift += ScaleMultiply(dwDenom, (DWORD)dwCropWidth, &dwDenom);
            DISPDBG ((0," dwDenom = %lu, iDenomShift = %d", dwDenom, iDenomShift));

            // Even things up for the divide
            if (iNumShift > iDenomShift)
            {
                dwDenom >>= (iNumShift - iDenomShift);
            }
            else if (iDenomShift > iNumShift)
            {
                dwNum >>= (iDenomShift - iNumShift);
            }
            DISPDBG ((0," dwNum = %lu, dwDenom = %lu", dwNum, dwDenom));

            // Be sure rounding below doesn't overflow
            if ((0xFFFFFFFF - dwDenom) < dwNum)
            {
                dwNum >>= 1;
                dwDenom >>= 1;
            }
            DISPDBG ((0," dwNum = %lu, dwDenom = %lu", dwNum, dwDenom));

            // Protect from a divide by 0 even though this should never happen
            if (0 == dwDenom)
            {
                DISPDBG ((0,"ChipCheckBandwidth(): Invalid n(VW) denominator (0)."));
                goto Error;
            }

            // Divide (round up)
            nVW = (UINT)((dwNum + dwDenom - 1) / dwDenom);
            DISPDBG ((0," nVW = %u", nVW));

            // Only 3 bits for nVW, so scale it and save factor
            uMVWFactor = 1;
            while (nVW > 7)
            {
                nVW++;
                nVW >>= 1;
                uMVWFactor <<= 1;
                DISPDBG ((0," nVW = %u, uMVWFactor = %u", nVW, uMVWFactor));
            }

            // For a 0 n(VW), we assume the overhead is negligible.
            if (0 == nVW)
            {
                uVPortMVW = 0;
            }
            else
            {
                // V-Port = R + (n - 1) * P
                uVPortMVW = uMCLKsPerRandom + ((nVW - 1) * uMCLKsPerPage);
                uVPortMVW *= uMVWFactor;
            }
            DISPDBG((0," uVPortMVW = %u", uVPortMVW));
        }
    }
#endif  //00 -- fr new structure code

    /*
     * DSTN Frame Buffer = [R + P] + [1 + (2 * P)]           (a)
     *                or = [R + (2 * P)] + [1 + (3 * P)]     (b)
     */
    dwTemp = (DWORD)(uMCLKsPerRandom + uMCLKsPerPage + 1 + (2 * uMCLKsPerPage));
    uDSTNGfxA = (UINT)dwTemp;
    dwTemp *= dwDestWidth;
    dwTemp /= dwSrcWidth;
    uDSTNMVWA = (UINT)dwTemp;

    dwTemp = (DWORD)(uMCLKsPerRandom + (2 * uMCLKsPerPage) + 1 + (3 * uMCLKsPerPage));
    uDSTNGfxB = (UINT)dwTemp;
    dwTemp *= dwDestWidth;
    dwTemp /= dwSrcWidth;
    uDSTNMVWB = (UINT)dwTemp;

    DISPDBG((0,"uDSTNGfxA = %u, uDSTNMVWA = %u, uDSTNGfxB = %u,uDSTNMVWB = %u",
                uDSTNGfxA, uDSTNMVWA, uDSTNGfxB, uDSTNMVWB));

    /*
     * (Gfx + MVW + VP + DSTN) * MCLK Period <= VCLK period
     */

    // Calculate v(VW) and v(Graphics) for comparison below

    // Div 0 Protection done above
    vVW = (UINT)((64ul * (DWORD)uMVWThresh * dwDestWidth)
                 / (wVideoDepth * dwSrcWidth));
    DISPDBG((0," vVW = %u", vVW));

    // Div 0 Protection done above
    vGfx = (USHORT)((64 * uGfxThresh) / ppdev->cBitsPerPixel);
    DISPDBG((0," vGfx = %u", vGfx));

    // See if DSTN is enabled
    fDSTN = IsDSTN(ppdev);

    // Check main equation, starting with Gfx-based equation (we won't
    //  do MVW-based equation below unless we are non-color/chroma keyed
    //  and the MVW is enabled.

    {
        DWORD dwLeft, dwRight, dwScaledRandomMCLKPeriod;

        // Begin building left side of equation with DSTN contribution
        if (fDSTN)
        {
            if (16 == ppdev->cBitsPerPixel)
            {
                dwLeft = (DWORD)uDSTNGfxA;
                uDSTNGfxThresh = 4;
            }
            else
            {
                dwLeft = (DWORD)uDSTNGfxB;
                uDSTNGfxThresh = 6;
            }
            if (uMVWThresh == wVideoDepth)
                uDSTNMVWThresh = 6;
            else
                uDSTNMVWThresh = 4;
        }
        else
        {
            dwLeft = 0;
        }
        DISPDBG((0," dwLeft = %lu", dwLeft));

        // Are we being displayed and color or chroma keyed?
        if (fColorKey)
        {
            // Add graphics contribution (scaled)
            dwLeft += ((DWORD)uGfx * dwDestWidth) / dwSrcWidth;

            DISPDBG((0," dwLeft = %lu", dwLeft));

            // Add video window contribution
            dwLeft += (DWORD)uMVW;
        }
        else
        {
            // Add graphics contribution (1x)
            dwLeft += (DWORD)uGfx;
        }
        DISPDBG((0," dwLeft = %lu", dwLeft));

        if (fColorKey)
            dwRight = (DWORD)vVW;
        else
            dwRight = (DWORD)vGfx;
        DISPDBG((0," dwLeft = %lu, dwRight = %lu", dwLeft, dwRight));

        // Only add video port if it's in use
#if 0   //00 - for new structure code
        if (dwFlags & OVERLAY_FLG_CAPTURE)
        {
            if (fColorKey)
                dwLeft += (DWORD)uVPortMVW;
            else
                dwLeft += (DWORD)uVPortGfx;
        }
#endif  //0 - for new structure code

        DISPDBG((0," dwLeft = %lu, dwRight = %lu", dwLeft, dwRight));

        // To avoid the divisions in (left/MCLK) <= (right/VCLK), we'll
        // instead multiply left * VCLK and right * MCLK since the relationship
        // will be the same.
        {
           int iLeftShift, iRightShift, iRandomMCLKShift;

            iLeftShift = ScaleMultiply(dwLeft, dwVCLK, &dwLeft);
            DISPDBG((0," dwLeft = %lu, iLeftShift = %d", dwLeft, iLeftShift));

            iRightShift = ScaleMultiply(dwRight, dwMCLK, &dwRight);
            DISPDBG((0," dwRight = %lu, iRightShift = %d", dwRight, iRightShift));

            iRandomMCLKShift = ScaleMultiply((DWORD)uMCLKsPerRandom, dwVCLK,
                                         &dwScaledRandomMCLKPeriod);
            DISPDBG((0," dwScaledRandomMCLKPeriod = %lu,iRandomMCLKShift = %d",
                         dwScaledRandomMCLKPeriod, iRandomMCLKShift));

            // Even things up
            {
            int iShift = iLeftShift;

                if (iRightShift > iShift)
                    iShift = iRightShift;

                if (iRandomMCLKShift > iShift)
                    iShift = iRandomMCLKShift;

                if (iShift > iLeftShift)
                    dwLeft >>= (iShift - iLeftShift);

                if (iShift > iRightShift)
                    dwRight >>= (iShift - iRightShift);

                if (iShift > iRandomMCLKShift)
                    dwScaledRandomMCLKPeriod >>= (iShift - iRandomMCLKShift);
            }
        }
        DISPDBG((0," dwLeft = %lu, dwRight = %lu", dwLeft, dwRight));
        DISPDBG((0," dwScaledRandomMCLKPeriod = %lu", dwScaledRandomMCLKPeriod));

        // See if there is enough bandwidth
        if (dwLeft > dwRight)
        {
            DISPDBG((0,"IsSufficientBandwidth(): Insufficient bandwidth (Gfx)."));
           goto Error;
        }

        if (dwLeft > (dwRight - dwScaledRandomMCLKPeriod))
        {
            // Set CPU stop bits
            DISPDBG((0,"IsSufficientBandwidth(): CPU stop bits set (Gfx)."));
            bSR34 = SR34_CPUSTOP_ENABLE | SR34_GFX_CPUSTOP | SR34_MVW_CPUSTOP;
            if (fDSTN)
                bSR34 |= SR34_DSTN_CPUSTOP;
            DISPDBG((0," bSR34 = 0x%x", bSR34));
        }
    }

    // Check main equation using MVW-based values if we are not
    //  color/chroma keyed and the MVW is enabled.
    if (!fColorKey)
    {
        DWORD dwLeft, dwRight, dwScaledRandomMCLKPeriod;

        // Begin building left side of equation with DSTN contribution
        if (fDSTN)
        {
            if (uMVWThresh == wVideoDepth)
                dwLeft = (DWORD)uDSTNMVWB;
            else
                dwLeft = (DWORD)uDSTNMVWA;
        }
        else
        {
            dwLeft = 0;
        }
        DISPDBG((0," dwLeft = %lu", dwLeft));

        // Add MVW contribution
        dwLeft += (DWORD)uMVW;
        DISPDBG((0," dwLeft = %lu", dwLeft));

        // Use v(MVW) for right
        dwRight = (DWORD)vVW;
        DISPDBG((0," dwLeft = %lu, dwRight = %lu", dwLeft, dwRight));

        // To avoid the divisions in (left/MCLK) <= (right/VCLK), we'll
        // instead multiply left * VCLK and right * MCLK since the relationship
        // will be the same.
        {
            int iLeftShift, iRightShift, iRandomMCLKShift;

            iLeftShift = ScaleMultiply(dwLeft, dwVCLK, &dwLeft);
            DISPDBG((0," dwLeft = %lu, iLeftShift = %d", dwLeft, iLeftShift));

            iRightShift = ScaleMultiply(dwRight, dwMCLK, &dwRight);
            DISPDBG((0," dwRight = %lu, iRightShift = %d", dwRight, iRightShift));

            iRandomMCLKShift = ScaleMultiply((DWORD)uMCLKsPerRandom, dwVCLK,
                                         &dwScaledRandomMCLKPeriod);
            DISPDBG((0," dwScaledRandomMCLKPeriod = %lu, iRandomMCLKShift = %d",
                         dwScaledRandomMCLKPeriod, iRandomMCLKShift));

            // Even things up
            {
                int iShift = iLeftShift;

                if (iRightShift > iShift)
                    iShift = iRightShift;

                if (iRandomMCLKShift > iShift)
                    iShift = iRandomMCLKShift;

                if (iShift > iLeftShift)
                    dwLeft >>= (iShift - iLeftShift);

                if (iShift > iRightShift)
                    dwRight >>= (iShift - iRightShift);

                if (iShift > iRandomMCLKShift)
                    dwScaledRandomMCLKPeriod >>= (iShift - iRandomMCLKShift);
            }
        }

        DISPDBG((0," dwLeft = %lu, dwRight = %lu", dwLeft, dwRight));
        DISPDBG((0," dwScaledRandomMCLKPeriod = %lu", dwScaledRandomMCLKPeriod));

        // See if there is enough bandwidth
        if (dwLeft > dwRight)
        {
            DISPDBG((0,"IsSufficientBandwidth(): Insufficient bandwidth (MVW)."));
            goto Error;
        }

        if (dwLeft > (dwRight - dwScaledRandomMCLKPeriod))
        {
            // Set CPU stop bits
            DISPDBG((0,"IsSufficientBandwidth(): CPU stop bits set (MVW)."));

            bSR34 = SR34_CPUSTOP_ENABLE | SR34_MVW_CPUSTOP;

            if (fDSTN)
                bSR34 |= SR34_DSTN_CPUSTOP;
            DISPDBG((0," bSR34 = 0x%x", bSR34));
        }
    }

    // Return register settings
    bSR2F |= (BYTE)uDSTNGfxThresh & SR2F_HFAFIFOGFX_THRESH;
    bSR32 |= (BYTE)uDSTNMVWThresh & SR32_HFAFIFOMVW_THRESH;

    switch (uMVWThresh)
    {
        case 8:
           bCR42 = 0x04;
           break;

        case 16:
           bCR42 = 0x00;
           break;

        default:
          DISPDBG((0,"IsSufficientBandwidth(): Illegal MVW Thresh (%u).", uMVWThresh));
          goto Error;
    }

    bCR51 |= ((BYTE)nVW << 5) & CR51_VPORTMVW_THRESH;
    DISPDBG((0," bCR51 = 0x%02X", (int)bCR51));

    bCR5A |= (BYTE)nGfx & CR5A_VPORTGFX_THRESH;
    DISPDBG((0," bCR5A = 0x%02X", (int)bCR5A));

     bCR5D=(BYTE)(((8 * (WORD)(bCR01 + 1)) + dwSrcWidth - dwDestWidth) / 8);
     DISPDBG((0," bCR5D = 0x%02X", (int)bCR5D));
     if (bCR5D)
         bCR5F |= 0x80;


     // Set global registers to be programmed in RegInitVideo()
//myf33   if (lpRegs)
     {
         Regs.bSR2F = bSR2F;
         Regs.bSR32 = bSR32;
         Regs.bSR34 = bSR34;

         Regs.bCR42 = bCR42;
         Regs.bCR51 = bCR51;
         Regs.bCR5A = bCR5A;
         Regs.bCR5D = bCR5D;
         Regs.bCR5F = bCR5F;
    }

    fSuccess = TRUE;
    DISPDBG((0,"IsSufficientBandwidth: OK!"));
Error:
    return(fSuccess);
}

/**********************************************************
*
* Get7555MCLK()
*
* Determines the current MCLK frequency.
*
* Return: The MCLK frequency in KHz (Since the frequency
*         could exceed 65535KHz, a DWORD is used).
*
***********************************************************
* Author: Rick Tillery
* Date:   09/27/95
*
* Revision History:
* -----------------
* WHO             WHEN     WHAT/WHY/HOW
* ---             ----     ------------
*
*********************************************************/
DWORD Get7555MCLK(PDEV * ppdev)
{
    DWORD dwMCLK;
    int   nMCLK;
    BYTE  bTemp;

    // Get MCLK register value
    CP_OUT_BYTE(ppdev->pjPorts, SR_INDEX, 0x1f);
    nMCLK = CP_IN_BYTE(ppdev->pjPorts, SR_DATA) & 0x3F;


    // Calculate actual MCLK frequency
    dwMCLK = (14318l * (DWORD)nMCLK) >> 3;
    CP_OUT_BYTE(ppdev->pjPorts, SR_INDEX, 0x12);
    bTemp = CP_IN_BYTE(ppdev->pjPorts, SR_DATA) ;

    // Account for MCLK scaling
    if (bTemp & 0x10)
    {
        dwMCLK >>= 1;
    }

    return(dwMCLK);
}

/**********************************************************
*
* IsDSTN()
*
* Determines whether a DSTN panel is being used for display.
*
* Return: TRUE/FALSE
*
***********************************************************
* Author: Teresa Tao
* Date:   10/22/96
*
* Revision History:
* -----------------
* WHO             WHEN     WHAT/WHY/HOW
* ---             ----     ------------
*
*********************************************************/
BOOL IsDSTN(PDEV * ppdev)
{
    BOOL bTemp;

    /*
     * Is this an LCD?
     */
    CP_OUT_BYTE(ppdev->pjPorts, CRTC_INDEX, 0x80);
    bTemp = CP_IN_BYTE(ppdev->pjPorts, CRTC_DATA);

    if (bTemp & 0x01)
    {
        /*
         * Determine type of LCD.
         */
        CP_OUT_BYTE(ppdev->pjPorts, CRTC_INDEX, 0x83);
        bTemp = CP_IN_BYTE(ppdev->pjPorts, CRTC_DATA) & 0x70;
        bTemp >>= 4 ;
        if (bTemp == 0)
            return (TRUE);
    }
    return(FALSE);
}

/**********************************************************
*
* IsXGA()
*
* Determines whether a XGA panel is being used for display.
*
* Return: TRUE/FALSE
*
***********************************************************
* Author: Teresa Tao
* Date:   10/22/96
*
* Revision History:
* -----------------
* WHO             WHEN     WHAT/WHY/HOW
* ---             ----     ------------
*
*********************************************************/
BOOL IsXGA(PDEV * ppdev)
{
    BOOL bTemp;

    /*
     * Is this an LCD?
     */
    CP_OUT_BYTE(ppdev->pjPorts, CRTC_INDEX, 0x80);
    bTemp = CP_IN_BYTE(ppdev->pjPorts, CRTC_DATA);

    if (bTemp & 0x01)
    {
        /*
         * Determine size of LCD.
         */
        CP_OUT_BYTE(ppdev->pjPorts, CRTC_INDEX, 0x83);
        bTemp = CP_IN_BYTE(ppdev->pjPorts, CRTC_DATA) & 0x03;
        if (bTemp == 0x02)
            return (TRUE);
    }
    return (FALSE);
}


/**********************************************************
*
* ScaleMultiply()
*
* Calculates product of two DWORD factors supplied.  If the
*  result would overflow a DWORD, the larger of the two factors
*  is divided by 2 (shifted right) until the overflow will
*  not occur.
*
* Returns: Number of right shifts applied to the product.
*          Product of the factors shifted by the value above.
*
***********************************************************
* Author: Rick Tillery
* Date:   11/18/95
*
* Revision History:
* -----------------
* WHO WHEN     WHAT/WHY/HOW
* --- ----     ------------
*********************************************************/
static int ScaleMultiply(DWORD   dw1,
                         DWORD   dw2,
                         LPDWORD pdwResult)
{
    int   iShift = 0;   // Start with no shifts
    DWORD dwLimit;

    // Either factor 0 will be a zero result and also cause a problem
    //  in our divide below.
    if ((0 == dw1) || (0 == dw2))
    {
        *pdwResult = 0;
    }
    else
    {
        // Determine which factor is larger
        if (dw1 > dw2)
        {
            // Determine largest number by with dw2 can be multiplied without
            // overflowing a DWORD.
            dwLimit = 0xFFFFFFFFul / dw2;

            // Shift dw1, keeping track of how many times, until it won't
            //  overflow when multiplied by dw2.
            while (dw1 > dwLimit)
            {
                dw1 >>= 1;
                iShift++;
            }
        }
        else
        {
            // Determine largest number by with dw1 can be multiplied without
            //  overflowing a DWORD.
            dwLimit = 0xFFFFFFFFul / dw1;

            // Shift dw2, keeping track of how many times, until it won't
            //  overflow when multiplied by dw1.
            while (dw2 > dwLimit)
            {
                dw2 >>= 1;
                iShift++;
            }
        }
        // Calculate (scaled) product
        *pdwResult = dw1 * dw2;
    }
    // Return the number of shifts we had to use
    return(iShift);
}


//myf31 :
#if 1
/**********************************************************
*
* PanOverlay7555
*
* If panning scrolling enable, and enable HW video, modified video window value
*
* Return: none
*
***********************************************************
* Author: Rita Ma
* Date:   02/24/97
*
* Revision History:
* -----------------
*********************************************************/
VOID PanOverlay7555 (PDEV * ppdev,LONG x,LONG y)
// RegInit7555Video (PDEV * ppdev,PDD_SURFACE_LOCAL lpSurface)
{
    DWORD dwTemp;
    DWORD dwFourcc;
    WORD  wBitCount;

    LONG lPitch;
    WORD wTemp;
    RECTL rDest;
    WORD wSrcWidth;
    WORD wSrcWidth_clip;
    WORD wDestWidth;
    WORD wSrcHeight;
    WORD wSrcHeight_clip;
    WORD wDestHeight;
    DWORD dwFBOffset;
    BYTE bRegCR31;
    BYTE bRegCR32;
    BYTE bRegCR33;
    BYTE bRegCR34;
    BYTE bRegCR35;
    BYTE bRegCR36;
    BYTE bRegCR37;
    BYTE bRegCR38;
    BYTE bRegCR39;
    BYTE bRegCR3A;
    BYTE bRegCR3B;
    BYTE bRegCR3C;
    BYTE bRegCR3D;
    BYTE bRegCR3E;
    BYTE bRegCR3F;
    BYTE bRegCR40;
    BYTE bRegCR41;
    BYTE bRegCR42;

    BYTE bRegCR51;
    BYTE bTemp;
    BYTE bVZoom;
    WORD fTemp=0;
    ULONG ulTemp=0;
    BOOL  bOverlayTooSmall = FALSE;
    static DWORD giAdjustSource;

//  USHORT VW_h_position, VW_v_position;
//  USHORT VW_h_width, VW_v_height;
//  ULONG  VW_s_addr;

    // PanOverlay1_Init return FALSE, exit here
    if (!PanOverlay1_7555(ppdev, &rDest))
        return;

	// rDest is now adjusted & clipped to the panning viewport
    // Disable overlay if totally clipped by viewport
    //
    if (((rDest.right - rDest.left) <= 15) ||
        ((rDest.bottom - rDest.top) <= 0) )
    {
        DisableVideoWindow(ppdev);                      // disable overlay
        return;
    }

    // Initial some value

    CP_OUT_BYTE(ppdev->pjPorts, CRTC_INDEX, 0x42);
    bRegCR42 = CP_IN_BYTE(ppdev->pjPorts, CRTC_DATA) & 0xFC; //mask Chroma Key

    // keep bit6 video LUT enable
    CP_OUT_BYTE(ppdev->pjPorts, CRTC_INDEX, 0x36);
    bRegCR36 = (CP_IN_BYTE(ppdev->pjPorts, CRTC_DATA) & 0x40) | 0x20;

    //
    // Get video format and color depth of overlay data
    //
    dwFourcc = ppdev->sOverlay1.dwFourcc;
    wBitCount= ppdev->sOverlay1.wBitCount;
    lPitch = ppdev->lPitch_gbls;                //??????????

    wSrcWidth = (WORD)(LONG)(ppdev->rOverlaySrc.right - ppdev->rOverlaySrc.left);
    wSrcHeight = (WORD)(LONG)(ppdev->rOverlaySrc.bottom - ppdev->rOverlaySrc.top);

    wSrcWidth_clip = (WORD)(LONG)(ppdev->rOverlaySrc.right - srcLeft_clip);
    wSrcHeight_clip = (WORD)(LONG)(ppdev->rOverlaySrc.bottom - srcTop_clip);

    wDestWidth = (WORD)(LONG)(ppdev->rOverlayDest.right - ppdev->rOverlayDest.left);
    wDestHeight = (WORD)(LONG)(ppdev->rOverlayDest.bottom - ppdev->rOverlayDest.top);

    // Determine horizontal upscale coefficient (CR39[7:4],CR31[7:0])
    wTemp = ((WORD)(((DWORD)wSrcWidth  << 12) / (DWORD)wDestWidth)) & 0x0FFF;

    if (wTemp != 0 && bLeft_clip)
    {
        srcLeft_clip = srcLeft_clip * (LONG)wTemp/4096 +ppdev->rOverlaySrc.left;
        wSrcWidth_clip = (WORD)(LONG)(ppdev->rOverlaySrc.right - srcLeft_clip);
        DISPDBG((0,"srcLeft_clip after zoom:%x",srcLeft_clip));
    }
    else if (bLeft_clip)
    {
        srcLeft_clip = srcLeft_clip + ppdev->rOverlaySrc.left;
        wSrcWidth_clip = (WORD)(LONG)(ppdev->rOverlaySrc.right - srcLeft_clip);
        DISPDBG((0,"srcLeft_clip after zoom:%x",srcLeft_clip));
    }

    bRegCR39 = (BYTE)((wTemp & 0x0F) << 4);
    bRegCR31 = (BYTE)(wTemp >> 4) & 0xFF;

    // Determine vertical upscale coefficient (CR39[3:0],CR32[7:0])
    bVZoom=0;
    wTemp = ((WORD)(((DWORD)wSrcHeight << 12) / (DWORD)wDestHeight)) & 0x0FFF;
    if (wTemp != 0) {
        bVZoom=1;
        fTemp = wTemp;
        if ( fTemp < 2048 ) // Zoom > 2.0
             wTemp=((WORD)(((DWORD)wSrcHeight << 12) / (DWORD)(wDestHeight+1))) & 0x0FFF;
    }
    if (wTemp != 0 && bTop_clip)
    {
        srcTop_clip = srcTop_clip * (LONG)wTemp/4096 + ppdev->rOverlaySrc.top;
        wSrcHeight_clip = (WORD)(LONG)(ppdev->rOverlaySrc.bottom - srcTop_clip);
        DISPDBG((0,"srcTop_clip after zoom:%x",srcTop_clip));
    }
    else if (bTop_clip)
    {
        srcTop_clip = srcTop_clip + ppdev->rOverlaySrc.top;
        wSrcHeight_clip = (WORD)(LONG)(ppdev->rOverlaySrc.bottom - srcTop_clip);
        DISPDBG((0,"srcTop_clip after zoom:%x",srcTop_clip));
    }

    bRegCR39 |= (BYTE)(wTemp & 0x0F);
    bRegCR32 = (BYTE)(wTemp >> 4) & 0xFF;
    DISPDBG((0,"wTemp = 0x%x",wTemp));

    // Determine Vertical Height (CR38[7:0], CR36[3:2])
    wTemp = wSrcHeight_clip;
    if (wTemp != 0 &&
        ( fTemp > 2730 || fTemp ==0 || ( fTemp > 1365 && fTemp < 2048 ) ) )
        wTemp--; //#tt10, Height minus one only if upscale rate <1.5
              //#tt10  2 <    <3

    bRegCR38 = (BYTE)wTemp;
    bRegCR36 |= (wTemp & 0x0300) >> 6;

    // Determine Horizontal position start (CR34[7:0], CR33[7:5])
    wTemp    = (WORD)rDest.left;
    bRegCR34 = (BYTE)wTemp;
    bRegCR33 = (wTemp & 0x0700) >> 3;

    // Reset Brightness control (CR35[7:0])
    bRegCR35 = 0x0;

    // Determine Vertical Start (CR37[7:0], CR36[1:0])
    wTemp    = (WORD)rDest.top;
    bRegCR37 = (BYTE)wTemp;
    bRegCR36 |= (wTemp & 0x0300) >> 8;


    // Determine Video Start Address (CR40[0], CR3A[6:0], CR3E[7:0], CR3F[3:0])
//  giAdjustSource = (ppdev->rOverlaySrc.top * lpSurface->lpGbl->lPitch)
//                     + ((ppdev->rOverlaySrc.left * wBitCount) >> 3);
    dwTemp = srcTop_clip * lPitch;
    dwTemp = (srcLeft_clip * wBitCount) >> 3;
    giAdjustSource = (srcTop_clip * lPitch)
                       + ((srcLeft_clip * wBitCount) >> 3);

    ppdev->sOverlay1.lAdjustSource = giAdjustSource;    //myf32
    dwFBOffset = (DWORD)(ppdev->fpVidMem_gbls + giAdjustSource);

    DISPDBG((0,"giAdjustSource = 0x%08x",giAdjustSource));
    DISPDBG((0,"dwFBOffset = 0x%08x",dwFBOffset));

    dwFBOffset >>= 2;

    CP_OUT_BYTE(ppdev->pjPorts, CRTC_INDEX, 0x3A);
    bTemp = CP_IN_BYTE(ppdev->pjPorts, CRTC_DATA) ;

    bRegCR3A = (bTemp & ~0x7F) | (BYTE)((dwFBOffset & 0x0FE000) >> 13);
    bRegCR3E = (BYTE)((dwFBOffset & 0x001FE0) >> 5);

    CP_OUT_BYTE(ppdev->pjPorts, CRTC_INDEX, 0x3F);
    bTemp = CP_IN_BYTE(ppdev->pjPorts, CRTC_DATA);
    bRegCR3F = (bTemp & ~0x0F) | (BYTE)((dwFBOffset & 0x00001E) >> 1);

    CP_OUT_BYTE(ppdev->pjPorts, CRTC_INDEX, 0x40);
    bTemp = CP_IN_BYTE(ppdev->pjPorts, CRTC_DATA) ;
    bRegCR40 = (bTemp & ~0x01) | (BYTE)(dwFBOffset & 0x000001);

    //Determine Video Pitch (CR3B[7:0], CR36[4])
    wTemp = (WORD)(lPitch >> 4);              //QWORDs

    bRegCR3B = (BYTE)wTemp;
    bRegCR36 |= (wTemp & 0x0100) >> 4;

    // Determine Data Format (CR3E[3:0])
    CP_OUT_BYTE(ppdev->pjPorts, CRTC_INDEX, 0x3C);
    bRegCR3C = CP_IN_BYTE(ppdev->pjPorts, CRTC_DATA) & 0x10;

    switch (dwFourcc)
    {
       case FOURCC_PACKJR:
           bRegCR3C |= 0x02;                    // Pack JR
           break;

       case BI_RGB:
           switch(wBitCount)
           {
             case 8:
                bRegCR3C |= 0x09;               // 8 bit palettized
                break;

             case 16:
                bRegCR3C |= 0x01;               // RGB 5:5:5
                break;
           }
           break;

       case BI_BITFIELDS:
           switch(wBitCount)
           {
             case 8:
                bRegCR3C |= 0x09;               // 8 bit palettized
                break;

             case 16:
                bRegCR3C |= 0x04;               // RGB 5:6:5
                break;
           }
           break;

       case FOURCC_YUV422:
           bRegCR3C |= 0x03;                    // YUV 4:2:2
           break;

       case FOURCC_YUY2:                //myf34 test
           bRegCR3C |= 0x03;                    // YUY2
//         CP_OUT_BYTE(ppdev->pjPorts, SR_INDEX, 0x2C);
//         bRegSR2C = CP_IN_BYTE(ppdev->pjPorts, SR_DATA) ;
//         bRegSR2C |= 0x40;            //SR2c[6] = 1
//         CP_OUT_WORD(ppdev->pjPorts, SR_INDEX, 0x2C |(WORD)bRegSR2C << 8);
           break;
    }


    // Determine Horizontal width (CR3D[7:0], CR3C[7:5])
    // NOTE: assumes Horz Pixel Width [0] = 0

    wTemp = wSrcWidth_clip;

    if (wTemp != 0 ) wTemp--;                   //Width minus one for laptop
    bRegCR3D = (BYTE)((WORD)wTemp >> 1);
    bRegCR3C |= (wTemp & 0x0600) >> 3;
    bRegCR3C |= (BYTE)((wTemp & 0x0001) << 5) ;

    // Enable Horizontal Pixel Interpolation (CR3F[7])
    bRegCR3F |= 0x80;

    // Enable Vertical Pixel Interpolation (CR3F[6])
    //#tt Debug- The CE rev. has problem when vertical interpolation is on
    //#tt Debug- Disable it for now.
    //#tt   bRegCR3F |= 0x40;

    // Enable Right Side transition threshold (CR41[5:0])
    bRegCR41 = 0x3E;

    // Disable V-PORT (CR58[7:0])
    bRegCR51 = 0x0;

    // Disable CR5D if in panning & upscaling
    CP_OUT_BYTE(ppdev->pjPorts, CRTC_INDEX, 0x80);
//myf33 if (bVZoom && (BYTE)wPanFlag)
    if (bVZoom && (CP_IN_BYTE(ppdev->pjPorts, CRTC_DATA) & 0x01))     //myf33
    {
        CP_OUT_BYTE(ppdev->pjPorts, CRTC_INDEX, 0x5F);
        bTemp = CP_IN_BYTE(ppdev->pjPorts, CRTC_DATA) & ~0x80;
        CP_OUT_BYTE(ppdev->pjPorts, CRTC_DATA, (UCHAR)bTemp);
    }

#if 0   // bad ideal code
    CP_OUT_BYTE(ppdev->pjPorts, CRTC_INDEX, 0x3C);
    bRegCR3C = CP_IN_BYTE(ppdev->pjPorts, CRTC_DATA) & 0x10;

    if (bRegCR3C)
    {
        // Horizontal position start (CR33[7:5], CR34[7:0])
        CP_OUT_BYTE(ppdev->pjPorts, CRTC_INDEX, 0x34);
        bRegCR34 = CP_IN_BYTE(ppdev->pjPorts, CRTC_DATA);
        CP_OUT_BYTE(ppdev->pjPorts, CRTC_INDEX, 0x33);
        bRegCR33 = CP_IN_BYTE(ppdev->pjPorts, CRTC_DATA);
        VW_h_position = ((USHORT)(bRegCR33 & 0xE0)) << 3;
        VW_h_position |= (USHORT)bRegCR34;

        // Vertical position start (CR36[1:0], CR37[7:0])
        CP_OUT_BYTE(ppdev->pjPorts, CRTC_INDEX, 0x37);
        bRegCR37 = CP_IN_BYTE(ppdev->pjPorts, CRTC_DATA);
        CP_OUT_BYTE(ppdev->pjPorts, CRTC_INDEX, 0x36);
        bRegCR36 = CP_IN_BYTE(ppdev->pjPorts, CRTC_DATA);
        VW_v_position = ((USHORT)(bRegCR36 & 0x03)) << 8;
        VW_v_position |= (USHORT)bRegCR37;

        //Video horizontal width (CR3C[7:6], CR3D[7:0], CR3C[5])
        CP_OUT_BYTE(ppdev->pjPorts, CRTC_INDEX, 0x3D);
        bRegCR3D = CP_IN_BYTE(ppdev->pjPorts, CRTC_DATA);
        CP_OUT_BYTE(ppdev->pjPorts, CRTC_INDEX, 0x3C);
        bRegCR3C = CP_IN_BYTE(ppdev->pjPorts, CRTC_DATA);
        VW_h_width = (WORD)(bRegCR3C & 0x01);
        VW_h_width |= (((USHORT)(bRegCR3C & 0xC0)) << 3);
        VW_h_width |= (((USHORT)bRegCR3D) << 1);

        //Video vertical height (CR36[3:2], CR38[7:0])
        CP_OUT_BYTE(ppdev->pjPorts, CRTC_INDEX, 0x38);
        bRegCR38 = CP_IN_BYTE(ppdev->pjPorts, CRTC_DATA);
//      CP_OUT_BYTE(ppdev->pjPorts, CRTC_INDEX, 0x36);
//      bRegCR36 = CP_IN_BYTE(ppdev->pjPorts, CRTC_DATA);
        VW_v_height = ((USHORT)(bRegCR36 & 0x0C)) << 6;
        VW_v_height |= ((USHORT)bRegCR38);

        //Video memory offset register (CR36[4], CR3B[7:0])
        CP_OUT_BYTE(ppdev->pjPorts, CRTC_INDEX, 0x3B);
        bRegCR3B = CP_IN_BYTE(ppdev->pjPorts, CRTC_DATA);
        lPitch = ((USHORT)(bRegCR36 & 0x10)) << 4;
        lPitch |= ((USHORT)bRegCR3B);
        lPitch <<= 4;

        //Video memory start address (CR3A[6:0], CR3E[7:0], CR3F[3:0], CR40[0])
        // update sequence CR40[0], CR3A[6:0], CR3E[7:0], CR3F[3:0]
        CP_OUT_BYTE(ppdev->pjPorts, CRTC_INDEX, 0x40);
        bRegCR40 = CP_IN_BYTE(ppdev->pjPorts, CRTC_DATA);
        CP_OUT_BYTE(ppdev->pjPorts, CRTC_INDEX, 0x3A);
        bRegCR3A = CP_IN_BYTE(ppdev->pjPorts, CRTC_DATA);
        CP_OUT_BYTE(ppdev->pjPorts, CRTC_INDEX, 0x3E);
        bRegCR3E = CP_IN_BYTE(ppdev->pjPorts, CRTC_DATA);
        CP_OUT_BYTE(ppdev->pjPorts, CRTC_INDEX, 0x3F);
        bRegCR3F = CP_IN_BYTE(ppdev->pjPorts, CRTC_DATA);
#if 0
        VW_s_addr = (ULONG)(bRegCR40 & 0x01);
        VW_s_addr |= (((ULONG)(bRegCR3F & 0x0F)) << 1);
        VW_s_addr |= (((ULONG)bRegCR3E) << 5);
        VW_s_addr |= (((ULONG)(bRegCR3A & 0x7F)) << 13);
        VW_s_addr <<= 2;
#endif

        // Update Video window Horizontal & Vertical position
        DISPDBG((0,"PAN--Xmin=%x, Xmax=%x\n",ppdev->min_Xscrren,ppdev->max_Xscrren));
        DISPDBG((0,"PAN--Ymin=%x, Ymax=%x\n",ppdev->min_Yscrren,ppdev->max_Yscrren));
        DISPDBG((0,"PAN--h_position=%x, v_position=%x\n",VW_h_position,
                         VW_v_position));
        DISPDBG((0,"PAN--h_height=%x, v_width=%x\n",VW_h_height,VW_v_width));

        if (((ppdev->min_Xscreen <= VW_h_position) &&
             (ppdev->max_Xscreen >= VW_h_position)) &&
            ((ppdev->min_Yscreen <= VW_v_position) &&
             (ppdev->max_Yscreen >= VW_v_position)))
        {
            VW_h_position -= ppdev->min_Xscreen;
            VW_v_position -= ppdev->min_Yscreen;
        DISPDBG((0,"(1)--h_position=%x, v_position=%x\n",VW_h_position,
                         VW_v_position));
        DISPDBG((0,"(1)--h_height=%x, v_width=%x\n",VW_h_height,VW_v_width));
        }
        // Video window in the left or right
        else if ((ppdev->max_Xscreen < VW_h_position) ||
                 (ppdev->min_Xscreen > (VW_h_position+VW_h_width)))
        {
            DisableVideoWindow(ppdev);                      // disable overlay
            ppdev->dwPanningFlag |= OVERLAY_OLAY_REENABLE;  // totally clipped
        DISPDBG((0,"(2)--DisableVideoWindow\n"));
        }
        // Video window in the top or bottom
        else if ((ppdev->max_Yscreen < VW_v_position) ||
                 (ppdev->min_Yscreen > (VW_v_position+VW_v_height)))
        {
            DisableVideoWindow(ppdev);                      // disable overlay
            ppdev->dwPanningFlag |= OVERLAY_OLAY_REENABLE;  // totally clipped
        DISPDBG((0,"(3)--DisableVideoWindow\n"));
        }
        // Update Video window memory start address
        else if ((ppdev->min_Xscreen > VW_h_position) &&
                 (ppdev->min_Xscreen < (VW_h_position+VW_h_width)))
        {
            if ((ppdev->min_Xscreen-VW_h_position) > 0)
            {
                ppdev->rOverlaySrc.left = ppdev->min_Xscreen - VW_h_position;
                VW_h_position = ppdev->min_Xscreen;
                VW_h_width -= ppdev->rOverlaySrc.left;
            }
            if ((ppdev->min_Yscreen-VW_v_position) > 0)
            {
                ppdev->rOverlaySrc.top = ppdev->min_Yscreen - VW_v_position;
                VW_v_position = ppdev->min_Yscreen;
                VW_v_height -= ppdev->rOverlaySrc.top;
            }
        DISPDBG((0,"(4)--h_position=%x, v_position=%x\n",VW_h_position,
                         VW_v_position));
        DISPDBG((0,"(4)--h_height=%x, v_width=%x\n",VW_h_height,VW_v_width));
        DISPDBG((0,"(4)--Overlay.top=%x, left=%x\n",ppdev->rOverlaySrc.top,
                         ppdev->rOverlaySrc.left));
        }
        else if  ((ppdev->min_Yscreen > VW_v_position) &&
                  (ppdev->min_Yscreen < (VW_v_position+VW_v_height)))
        {
            if ((ppdev->min_Xscreen-VW_h_position) > 0)
            {
                ppdev->rOverlaySrc.left = ppdev->min_Xscreen - VW_h_position;
                VW_h_position = ppdev->min_Xscreen;
                VW_h_width -= ppdev->rOverlaySrc.left;
            }
            if ((ppdev->min_Yscreen-VW_v_position) > 0)
            {
                ppdev->rOverlaySrc.top = ppdev->min_Yscreen - VW_v_position;
                VW_v_position = ppdev->min_Yscreen;
                VW_v_height -= ppdev->rOverlaySrc.top;
            }
        DISPDBG((0,"(5)--h_position=%x, v_position=%x\n",VW_h_position,
                         VW_v_position));
        DISPDBG((0,"(5)--h_height=%x, v_width=%x\n",VW_h_height,VW_v_width));
        }
        giAdjustSource = (ppdev->rOverlaySrc.top * lPitch)
//                        ppdev->lpSrcColorSurface->lpGbl->lPitch)
                       + ((ppdev->rOverlaySrc.left
                          * ppdev->sOverlay1.wBitCount) >> 3);

//      DISPDBG((0,"lpSurface->fpVisibleOverlay= \n0x%08x\n",
//                             ppdev->fpVisibleOverlay));
//      DISPDBG((0,"lpSurface->fpBaseOverlay = 0x%08x\n",
//                             ppdev->fpBaseOverlay));
        DISPDBG((0,"PAN--fpVidMem=0x%8x\t",ppdev->fpVidMem));
        DISPDBG((0,"PAN--giAdjustSource = 0x%08x\n",giAdjustSource));
        dwFBOffset = (ppdev->fpVidMem_gbls - ) + giAdjustSource;

        DISPDBG((0,"PAN--dwFBOffset = 0x%08x\n",dwFBOffset));

        dwFBOffset >>= 2;

        //Update Horizontal position start (CR33[7:5], CR34[7:0])
        bRegCR34 = (BYTE)(VW_h_position & 0xFF);
        bRegCR33 &= 0x1F;
        bRegCR33 |= ((BYTE)((VW_h_position & 0x0700) >> 3));

        // Vertical position start (CR36[1:0], CR37[7:0])
        bRegCR37 = (BYTE)(VW_v_position & 0xFF);
        bRegCR36 &= 0xFC;
        bRegCR36 |= ((BYTE)((VW_v_position & 0x0300) >> 8));

        //Video horizontal width (CR3C[7:6], CR3D[7:0], CR3C[5])
        bRegCR3D = (BYTE)((VW_h_width & 0x1FE) >> 1);
        bRegCR3C &= 0x1F;
        bRegCR3C |= ((BYTE)(VW_h_width & 0x01)) << 5;
        bRegCR3C |= ((BYTE)((VW_h_width & 0x0600) >> 3));

        //Video vertical height (CR36[3:2], CR38[7:0])
        bRegCR38 = (BYTE)(VW_v_height & 0xFF);
        bRegCR36 &= 0xF3;
        bRegCR36 |= ((BYTE)((VW_v_height & 0x0300) >> 6));

        //Video memory start address (CR3A[6:0], CR3E[7:0], CR3F[3:0], CR40[0])
        // update sequence CR40[0], CR3A[6:0], CR3E[7:0], CR3F[3:0]
        bRegCR40 &= 0xFE;
        bRegCR40 |= (BYTE)(dwFBOffset & 0x01);
        bRegCR3F &= 0xF0;
        bRegCR3F |= ((BYTE)(dwFBOffset & 0x1E)) >> 1;
        bRegCR3E = (BYTE)((dwFBOffset & 0x1FE0) >> 5);
        bRegCR3A &= 0x80;
        bRegCR3A |= ((BYTE)((dwFBOffset & 0xFE000) >> 13));
#endif  /0 - bad ideal
//
        /*
         * Program the video window registers
        */
        CP_OUT_WORD(ppdev->pjPorts, CRTC_INDEX, 0x31 | (WORD)bRegCR31 << 8);//CR31
        CP_OUT_WORD(ppdev->pjPorts, CRTC_INDEX, 0x32 | (WORD)bRegCR32 << 8);//CR32
        CP_OUT_WORD(ppdev->pjPorts, CRTC_INDEX, 0x33 | (WORD)bRegCR33 << 8);//CR33
        CP_OUT_WORD(ppdev->pjPorts, CRTC_INDEX, 0x34 | (WORD)bRegCR34 << 8);//CR34

        CP_OUT_WORD(ppdev->pjPorts, CRTC_INDEX, 0x35 | (WORD)bRegCR35 << 8);//CR35
        CP_OUT_WORD(ppdev->pjPorts, CRTC_INDEX, 0x36 | (WORD)bRegCR36 << 8);//CR36
        CP_OUT_WORD(ppdev->pjPorts, CRTC_INDEX, 0x37 | (WORD)bRegCR37 << 8);//CR37
        CP_OUT_WORD(ppdev->pjPorts, CRTC_INDEX, 0x38 | (WORD)bRegCR38 << 8);//CR38
        CP_OUT_WORD(ppdev->pjPorts, CRTC_INDEX, 0x39 | (WORD)bRegCR39 << 8);//CR39
        CP_OUT_WORD(ppdev->pjPorts, CRTC_INDEX, 0x3B | (WORD)bRegCR3B << 8);//CR3B
        CP_OUT_WORD(ppdev->pjPorts, CRTC_INDEX, 0x3C | (WORD)bRegCR3C << 8);//CR3C
        CP_OUT_WORD(ppdev->pjPorts, CRTC_INDEX, 0x3D | (WORD)bRegCR3D << 8);//CR3D
        CP_OUT_WORD(ppdev->pjPorts, CRTC_INDEX, 0x41 | (WORD)bRegCR41 << 8);//CR41
        CP_OUT_WORD(ppdev->pjPorts, CRTC_INDEX, 0x42 | (WORD)bRegCR42 << 8);//CR42
        CP_OUT_WORD(ppdev->pjPorts, CRTC_INDEX, 0x51 | (WORD)bRegCR51 << 8);//CR51

        CP_OUT_WORD(ppdev->pjPorts, CRTC_INDEX, 0x40 | (WORD)bRegCR40 << 8);//CR40
        CP_OUT_WORD(ppdev->pjPorts, CRTC_INDEX, 0x3A | (WORD)bRegCR3A << 8);//CR3A
        CP_OUT_WORD(ppdev->pjPorts, CRTC_INDEX, 0x3E | (WORD)bRegCR3E << 8);//CR3E
        CP_OUT_WORD(ppdev->pjPorts, CRTC_INDEX, 0x3F | (WORD)bRegCR3F << 8);//CR3F

        // enable overlay if overlay was totally clipped by pnning viewport
        //
        if (ppdev->dwPanningFlag & OVERLAY_OLAY_REENABLE)
            EnableVideoWindow (ppdev);
}
#endif
//myf31 end

#endif   // DirectDraw
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\cirrus\disp\brush.c ===
/******************************************************************************\
*
* $Workfile:   brush.c  $
*
* Handles all brush/pattern initialization and realization.
*
* Copyright (c) 1992-1995 Microsoft Corporation
* Copyright (c) 1996 Cirrus Logic, Inc.
*
* $Log:   S:/projects/drivers/ntsrc/display/brush.c_v  $
 * 
 *    Rev 1.3   Nov 26 1996 14:28:48   unknown
 * Use second aperture for blt.
 * 
 *    Rev 1.2   Nov 07 1996 16:44:50   unknown
 * Clean up CAPS flags
 * 
 *    Rev 1.1   Oct 10 1996 15:36:16   unknown
 *  
* 
*    Rev 1.5   13 Aug 1996 11:55:34   frido
* Fixed misalignment in brush cache.
* 
*    Rev 1.4   12 Aug 1996 17:08:08   frido
* Commented brush cache.
* Removed unaccessed local variables.
* 
*    Rev 1.3   05 Aug 1996 11:17:50   frido
* Added more check for XLATEOBJ.
* 
*    Rev 1.2   31 Jul 1996 15:43:28   frido
* Added new brush caches.
*
* jl01  10-08-96  Do Transparent BLT w/o Solid Fill.  Refer to PDRs#5511/6817.
*
*    sge01   11/26/96   Use second aperture when doing 24bpp cache blt.
* 
*
\******************************************************************************/

#include "precomp.h"

//bc#1 Handy macros.
#define BUSY_BLT(ppdev, pjBase)        (CP_MM_ACL_STAT(ppdev, pjBase) & 0x10)

/******************************Public*Routine******************************\
* VOID vRealizeDitherPattern
*
* Generates an 8x8 dither pattern, in our internal realization format, for
* the color ulRGBToDither.  Note that the high byte of ulRGBToDither does
* not need to be set to zero, because vComputeSubspaces ignores it.
\**************************************************************************/

VOID vRealizeDitherPattern(
RBRUSH*     prb,
ULONG       ulRGBToDither)
{
    ULONG        ulNumVertices;
    VERTEX_DATA  vVertexData[4];
    VERTEX_DATA* pvVertexData;

    // Calculate what color subspaces are involved in the dither:

    pvVertexData = vComputeSubspaces(ulRGBToDither, vVertexData);

    // Now that we have found the bounding vertices and the number of
    // pixels to dither for each vertex, we can create the dither pattern

    ulNumVertices = (ULONG)(pvVertexData - vVertexData);
                      // # of vertices with more than zero pixels in the dither

    // Do the actual dithering:

    vDitherColor(&prb->aulPattern[0], vVertexData, pvVertexData, ulNumVertices);

    // Initialize the fields we need:

    prb->ptlBrushOrg.x = LONG_MIN;
    prb->fl            = 0;
    prb->pbe = NULL;
}

/******************************Public*Routine******************************\
* BOOL DrvRealizeBrush
*
* This function allows us to convert GDI brushes into an internal form
* we can use.  It may be called directly by GDI at SelectObject time, or
* it may be called by GDI as a result of us calling BRUSHOBJ_pvGetRbrush
* to create a realized brush in a function like DrvBitBlt.
*
* Note that we have no way of determining what the current Rop or brush
* alignment are at this point.
*
\**************************************************************************/

BOOL DrvRealizeBrush(
BRUSHOBJ*   pbo,
SURFOBJ*    psoDst,
SURFOBJ*    psoPattern,
SURFOBJ*    psoMask,
XLATEOBJ*   pxlo,
ULONG       iHatch)
{
    ULONG    iPatternFormat;
    BYTE*    pjSrc;
    BYTE*    pjDst;
    LONG     lSrcDelta;
    LONG     cj;
    LONG     i;
    LONG     j;
    RBRUSH*  prb;
    ULONG*   pulXlate;
    SURFOBJ* psoPunt;
    RECTL    rclDst;
    FLONG     flXlate;    //bc#1

    PDEV* ppdev = (PPDEV)psoDst->dhpdev;

#if 1 //bc#1 Dither cache.
    // Dithers...
    if (iHatch & RB_DITHERCOLOR)
    {
        if (ppdev->flStatus & STAT_DITHER_CACHE)
        {
            DITHERCACHE* pdc;
            ULONG        ulColor;
        
            // Save the color.
            ulColor = iHatch & 0xFFFFFF;

            // Allocate the brush.
            prb = BRUSHOBJ_pvAllocRbrush(pbo, sizeof(RBRUSH));
            if (prb == NULL)
            {
                DISPDBG((2, "DrvRealizeBrush: BRUSHOBJ_pvAllocRbrush failed"));
                return(FALSE);
            }
    
            // Set the dithered brush flags.
            prb->fl     = RBRUSH_DITHER;
            prb->ulUniq = ulColor;

            // Look for a match with the cached dithers.
            pdc = &ppdev->aDithers[0];
            for (i = 0; i < NUM_DITHERS; i++)
            {
                if (pdc->ulColor == ulColor)
                {
                    // We have a match, just set the brush pointers.
                    DISPDBG((20, "DrvRealizeBrush: DitherCache match (0x%06X)",
                             ulColor));
                    prb->ulSlot  = (ULONG)((ULONG_PTR)pdc - (ULONG_PTR)ppdev);
                    prb->ulBrush = pdc->ulBrush;
                    return(TRUE);
                }
                pdc++;
            }

            // Create the dither and cache it.
            return(bCacheDither(ppdev, prb));
        }

        if (!(ppdev->flStatus & (STAT_BRUSH_CACHE | STAT_PATTERN_CACHE)))
        {
            DISPDBG((2, "DrvRealizeBrush: No brush cache to create dither"));
            return(FALSE);
        }

        // Allocate the brush.
        prb = BRUSHOBJ_pvAllocRbrush(pbo, sizeof(RBRUSH) +
                                          PELS_TO_BYTES(TOTAL_BRUSH_SIZE));
        if (prb == NULL)
        {
            DISPDBG((2, "DrvRealizeBrush: BRUSHOBJ_pvAllocRbrush failed"));
            return(FALSE);
        }

        // Realize the dither.
        vRealizeDitherPattern(prb, iHatch);
        if (ppdev->flStatus & STAT_PATTERN_CACHE)
        {
            prb->cjBytes = PELS_TO_BYTES(8) * 8;
            prb->ulSlot  = 0;
            return(bCachePattern(ppdev, prb));
        }

        return(TRUE);
    }
#endif

    // We only accelerate 8x8 patterns.
    if ((psoPattern->sizlBitmap.cx != 8) || (psoPattern->sizlBitmap.cy != 8))
    {
        DISPDBG((2, "DrvRealizeBrush: psoPattern too big (%d x %d)",
                 psoPattern->sizlBitmap.cx, psoPattern->sizlBitmap.cy));
        return(FALSE);
    }

    // We don't support masks just yet.
    if ((psoMask != NULL) && (psoMask->pvScan0 != psoPattern->pvScan0))
    {
        DISPDBG((2, "DrvRealizeBrush: psoMask not supported"));
        return(FALSE);
    }

    // Get the brush type.
    iPatternFormat = psoPattern->iBitmapFormat;
    if (psoPattern->iType != STYPE_BITMAP)
    {
        DISPDBG((2, "DrvRealizeBrush: psoPattern->iType (=%d) not supported",
                 psoPattern->iType));
        return(FALSE);
    }

    // Get the color translation table.
    flXlate = (pxlo == NULL) ? XO_TRIVIAL : pxlo->flXlate;
    if (flXlate & XO_TRIVIAL)
    {
        pulXlate = NULL;
    }
    else if (flXlate & XO_TABLE)
    {
        pulXlate = pxlo->pulXlate;
    }
    else
    {
        pulXlate = XLATEOBJ_piVector(pxlo);
    }

#if 1 //bc#1 Monochrome cache.
    if ((iPatternFormat == BMF_1BPP) &&
        (ppdev->flStatus & STAT_MONOCHROME_CACHE))
    {
        MONOCACHE* pmc;

        // We need a translation table.
        if (pulXlate == NULL)
        {
            DISPDBG((2, "DrvRealizeBrush: psoPattern(monochrome) pxlo=NULL"));
            return(FALSE);
        }

        // Allocate the brush.
        prb = BRUSHOBJ_pvAllocRbrush(pbo, sizeof(RBRUSH) + 8);
        if (prb == NULL)
        {
            DISPDBG((2, "DrvRealizeBrush: BRUSHOBJ_pvAllocRbrush failed"));
            return(FALSE);
        }

        // Initialize the realized brush.
        prb->fl             = RBRUSH_MONOCHROME;
        prb->ulBackColor = pulXlate[0];
        prb->ulForeColor = pulXlate[1];

        pjSrc     = psoPattern->pvScan0;
        lSrcDelta = psoPattern->lDelta;

        // Copy the pattern to the realized brush.
        for (i = 0; i < 8; i++)
        {
            ((BYTE*) prb->aulPattern)[i] = *pjSrc;

            pjSrc += lSrcDelta;
        }

        // Lookup the pattern in te monochrome cache.
        pmc = &ppdev->aMonochromes[0];
        if (ppdev->cBpp == 3)
        {
            for (i = 0; i < NUM_MONOCHROMES; i++)
            {
                if ((pmc->aulPattern[0] == prb->aulPattern[0]) &&
                    (pmc->aulPattern[1] == prb->aulPattern[1]) &&
                    (pmc->ulBackColor   == prb->ulBackColor)   &&
                    (pmc->ulForeColor   == prb->ulForeColor))
                {
                    // We have a match! Just copy the brush pointers.
                    DISPDBG((20, "DrvRealizeBrush: Monochrome hit"));
                    prb->ulUniq  = pmc->ulUniq;
                    prb->ulSlot  = (ULONG)((ULONG_PTR)pmc - (ULONG_PTR)ppdev);
                    prb->ulBrush = pmc->ulBrush;
                    return(TRUE);
                }
                pmc++;
            }
        }
        else
        {
            for (i = 0; i < NUM_MONOCHROMES; i++)
            {
                if ((pmc->aulPattern[0] == prb->aulPattern[0]) &&
                    (pmc->aulPattern[1] == prb->aulPattern[1]))
                {
                    // We have a match! Just copy the brush pointers.
                    DISPDBG((20, "DrvRealizeBrush: Monochrome hit"));
                    prb->ulUniq  = pmc->ulUniq;
                    prb->ulSlot  = (ULONG)((ULONG_PTR)pmc - (ULONG_PTR)ppdev);
                    prb->ulBrush = pmc->ulBrush;
                    return(TRUE);
                }
                pmc++;
            }
        }

        return(bCacheMonochrome(ppdev, prb));
    }
#endif

    // We must have either an old-style brush cache or a new-style pattern
    // cache to continue.
    if (!(ppdev->flStatus & (STAT_BRUSH_CACHE | STAT_PATTERN_CACHE)))
    {
        DISPDBG((2, "DrvRealizeBrush: No brush cache"));
        return(FALSE);
    }

    // Allocate the brush.
    prb = BRUSHOBJ_pvAllocRbrush(pbo, sizeof(RBRUSH) +
                                      PELS_TO_BYTES(TOTAL_BRUSH_SIZE));
    if (prb == NULL)
    {
        DISPDBG((2, "DrvRealizeBrush: BRUSHOBJ_pvAllocRbrush failed"));
        return(FALSE);
    }

    // Initialize the realized brush.
    prb->ptlBrushOrg.x = LONG_MIN;
    prb->fl            = RBRUSH_PATTERN;
    prb->pbe           = NULL;

    lSrcDelta = psoPattern->lDelta;
    pjSrc     = (BYTE*) psoPattern->pvScan0;
    pjDst     = (BYTE*) &prb->aulPattern[0];

    //bc#1
    if ((ppdev->iBitmapFormat == iPatternFormat) && (flXlate & XO_TRIVIAL))
    {
        // The pattern is the same color depth as the screen, and there's no
        // translation to be done.
        cj = PELS_TO_BYTES(8);

        // Copy the pattern to the realized brush.
        for (i = 8; i != 0; i--)
        {
            RtlCopyMemory(pjDst, pjSrc, cj);

            pjSrc += lSrcDelta;
            pjDst += cj;
        }
    }
    else if ((iPatternFormat == BMF_4BPP) && (ppdev->iBitmapFormat == BMF_8BPP))
    {
        // Translate the 16-color brush.
        for (i = 8; i != 0; i--)
        {
            // Inner loop is repeated only 4 times because each loop handles 2
            // pixels.
            for (j = 4; j != 0; j--)
            {
                *pjDst++ = (BYTE) pulXlate[*pjSrc >> 4];
                *pjDst++ = (BYTE) pulXlate[*pjSrc & 0x0F];
                pjSrc++;
            }

            pjSrc += lSrcDelta - 4;
        }
    }
    else
    {
        // We've got a brush whose format we haven't special cased. No problem,
        // we can have GDI convert it to our device's format. We simply use a
        // temporary surface object that was created with the same format as
        // the display, and point it to our brush realization.
        psoPunt          = ppdev->psoBank;
        psoPunt->pvScan0 = pjDst;
        psoPunt->lDelta  = PELS_TO_BYTES(8);

        rclDst.left   = 0;
        rclDst.top    = 0;
        rclDst.right  = 8;
        rclDst.bottom = 8;

        if (!EngCopyBits(psoPunt, psoPattern, NULL, pxlo, &rclDst,
                         (POINTL*) &rclDst))
        {
            DISPDBG((2, "DrvRealizeBrush: Unable to create funky brush"));
            return(FALSE);
        }
    }

#if 1 //bc#1
    // If we have a pattern cache, cache the brush now.
    if (ppdev->flStatus & STAT_PATTERN_CACHE)
    {
        prb->cjBytes = PELS_TO_BYTES(8) * 8;
        return(bCachePattern(ppdev, prb));
    }
#endif
    return(TRUE);
}

/******************************Public*Routine******************************\
* BOOL bEnableBrushCache
*
* Allocates off-screen memory for storing the brush cache.
\**************************************************************************/

BOOL bEnableBrushCache(
PDEV*   ppdev)
{
    OH*         poh;                // Points to off-screen chunk of memory
    BRUSHENTRY* pbe;                // Pointer to the brush-cache entry
    LONG        i;
    LONG        cBrushAlign;        // 0 = no alignment,
                                    //   n = align to n pixels
    LONG x;
    LONG y;

#if 1 //bc#1 Dither cache.
    if ((ppdev->cBpp == 1) &&
        (ppdev->flCaps & CAPS_AUTOSTART) &&
        (ppdev->bLinearMode))
    {
        LONG lDelta;

        // Allocate the dither cache horizontally.
        poh    = pohAllocatePermanent(ppdev, 64 * NUM_DITHERS + 63, 1);
        lDelta = 64;
        if (poh == NULL)
        {
            // Allocate the dither cache vertically.
            poh    = pohAllocatePermanent(ppdev, 64 + 63, NUM_DITHERS);
            lDelta = ppdev->lDelta;
        }

        if (poh != NULL)
        {
            // Align the cache to a 64-byte boundary.
            ULONG ulBase = (poh->xy + 63) & ~63;

            // Initialize the dither cache.
            DISPDBG((4, "DitherCache allocated at %d,%d (%d x %d)",
                     poh->x, poh->y, poh->cx, poh->cy));
            for (i = 0; i < NUM_DITHERS; i++)
            {
                ppdev->aDithers[i].ulColor = (ULONG) -1;
                ppdev->aDithers[i].ulBrush = ulBase;

                ulBase += lDelta;
            }

            // The dither cache has been initialized.
            ppdev->iDitherCache = 0;
            ppdev->flStatus    |= STAT_DITHER_CACHE;
        }
    }
#endif

#if 1 //bc#1 Pattern cache.
    if ((ppdev->flCaps & CAPS_AUTOSTART) &&
        (ppdev->bLinearMode))
    {
        LONG  lDelta;
        LONG  cBrushSize;
        ULONG ulAlignment;

        // Calculate the width of brush in pixels.
        if (ppdev->cBpp == 3)
        {
            cBrushSize  = (256 + 2) / 3;
            ulAlignment = 256;
        }
        else
        {
            cBrushSize  = 64;
            ulAlignment = PELS_TO_BYTES(64);
        }

        // Allocate the pattern cache horizontally.
        poh    = pohAllocatePermanent(ppdev, cBrushSize * NUM_PATTERNS +
                                             (cBrushSize - 1), 1);
        lDelta = ulAlignment;
        if (poh == NULL)
        {
            // Allocate the pattern cache vertically.
            poh    = pohAllocatePermanent(ppdev, cBrushSize + (cBrushSize - 1),
                                          NUM_PATTERNS);
            lDelta = ppdev->lDelta;
        }

        if (poh != NULL)
        {
            // Align the cache to a 64-pixel boundary.
            ULONG ulBase = (poh->xy + (ulAlignment - 1)) & ~(ulAlignment - 1);

            // Initialize the pattern cache.
            DISPDBG((4, "PatternCache allocated at %d,%d (%d x %d)",
                     poh->x, poh->y, poh->cx, poh->cy));
            for (i = 0; i < NUM_PATTERNS; i++)
            {
                ppdev->aPatterns[i].ulBrush = ulBase;
                ppdev->aPatterns[i].prbUniq = NULL;

                ulBase += lDelta;
            }

            // The pattern cache has been initialized.
            ppdev->iPatternCache = 0;
            ppdev->flStatus     |= STAT_PATTERN_CACHE;
        }
    }
#endif

#if 1 //bc#1 Monochrome cache.
    if ((ppdev->flCaps & CAPS_AUTOSTART) &&
        (ppdev->bLinearMode))
    {
        LONG  lDelta;
        LONG  cBrushSize;
        ULONG ulAlignment;

        // Calculate the width of brush in pixels.
        if (ppdev->cBpp == 3)
        {
            cBrushSize  = (256 + 2) / 3;
            ulAlignment = 256;
        }
        else
        {
            cBrushSize  = BYTES_TO_PELS(8);
            ulAlignment = 8;
        }

        // Allocate the pattern cache horizontally.
        poh       = pohAllocatePermanent(ppdev, cBrushSize * NUM_MONOCHROMES +
                                             (cBrushSize - 1), 1);
        lDelta = ulAlignment;
        if (poh == NULL)
        {
            // Allocate the pattern cache vertically.
            poh    = pohAllocatePermanent(ppdev, cBrushSize + (cBrushSize - 1),
                                          NUM_MONOCHROMES);
            lDelta = ppdev->lDelta;
        }

        if (poh != NULL)
        {
            // Align the cache to an 8-byte boundary.
            ULONG ulBase = (poh->xy + (ulAlignment - 1)) & ~(ulAlignment - 1);

            // Initialize the monochrome cache.
            DISPDBG((4, "MonochromeCache allocated at %d,%d (%d x %d)",
                     poh->x, poh->y, poh->cx, poh->cy));
            for (i = 0; i < NUM_MONOCHROMES; i++)
            {
                ppdev->aMonochromes[i].ulBrush          = ulBase;
                ppdev->aMonochromes[i].aulPattern[0] = 0;
                ppdev->aMonochromes[i].aulPattern[1] = 0;

                ulBase += lDelta;
            }

            // The monochrome cache has been initialized.
            ppdev->iMonochromeCache = 0;
            ppdev->flStatus        |= STAT_MONOCHROME_CACHE;
        }
    }
#endif

       cBrushAlign = 64;               // Align all brushes to 64 pixels

    DISPDBG((2, "cBrushAlign = %d", cBrushAlign));

       pbe = &ppdev->abe[0];           // Points to where we'll put the first
                                       //   brush cache entry

    {

           // Reserve the offscreen space that is required for the CP to do
        // solid fills.  If this fails, our solid fill code will not work.
        // We need two DWORD storage locations if we're going to do any
        // monochrome expansion stuff (font painting...).

           // Note: these must be 8 byte aligned for the cirrus chips

           // Not having a solid color work area is a
        // fatal error for this driver.

        DISPDBG((2,"Allocating solid brush work area"));
        poh = pohAllocatePermanent(ppdev, 16, 1);

        ASSERTDD((poh != NULL),
                 "We couldn't allocate offscreen space for the solid colors");

        ppdev->ulSolidColorOffset = ((((poh->y * ppdev->lDelta) +
                                           PELS_TO_BYTES(poh->x)) + 7) & ~7);

        DISPDBG((2,"ppdev->ulSolidColorOffset = %xh", ppdev->ulSolidColorOffset));


#if 1 //bc#1 Only one pattern cache.
        if (ppdev->flStatus & STAT_PATTERN_CACHE)
        {
            goto ReturnTrue;
        }
#endif

        ///////////////////////////////////////////////////////////////////////
        // Special cases where we want no brush cache...
        //
        // There are a couple of instances where we have no xfer buffer to
        // the HW blt engine.  In that case, we are unable to realize
        // patterns, so don't enable the cache.
        //
        // (1)  NEC Mips nachines lock up on xfers, so they're diabled.
        // (2)  At 1280x1024 on a 2MB card, we currently have no room for
        //      the buffer because of stretched scans.  This will be fixed.

        {
            if (ppdev->pulXfer == NULL)
                goto ReturnTrue;

        }

        //
        // Allocate single brush location for intermediate alignment purposes
        //
#if 1 //bc#1
        if (ppdev->cBpp == 3)
        {
            poh = pohAllocatePermanent(ppdev,
                                       (8 * 8 * 4) / 3 + (cBrushAlign - 1), 1);
        }
        else
#endif
        {
            poh = pohAllocatePermanent(ppdev, (8 * 8) + (cBrushAlign - 1), 1);
        }

        if (poh == NULL)
           {
               DISPDBG((2,"Failed to allocate aligned brush area"));
               goto ReturnTrue;    // See note about why we can return TRUE...
        }
           ppdev->ulAlignedPatternOffset = ((poh->xy) +
                                         (PELS_TO_BYTES(cBrushAlign) - 1)) &
                                           ~(PELS_TO_BYTES(cBrushAlign) - 1);
        DISPDBG((2,"ppdev->ulAlignedPatternOffset = %xh", ppdev->ulAlignedPatternOffset));

           //
           // Allocate brush cache
        //

#if 1 //bc#1
        if (ppdev->cBpp == 3)
        {
            poh = pohAllocatePermanent(ppdev,
                       (BRUSH_TILE_FACTOR * 8 * 8 * 4) / 3 + cBrushAlign - 1,
                       FAST_BRUSH_COUNT);
        }
        else
#endif
        {
            poh = pohAllocatePermanent(ppdev,
                       // remember this is pixels, not bytes
                       (BRUSH_TILE_FACTOR * 8 * 8) + (cBrushAlign - 1),
                    FAST_BRUSH_COUNT);
        }

           if (poh == NULL)
        {
               DISPDBG((2,"Failed to allocate brush cache"));
               goto ReturnTrue;    // See note about why we can return TRUE...
        }

           ppdev->cBrushCache = FAST_BRUSH_COUNT;

           // Hardware brushes require that the bits start on a 64 (height*width)
        // pixel boundary.  The heap manager doesn't guarantee us any such
        // alignment, so we allocate a bit of extra room so that we can
        // do the alignment ourselves:

           x = poh->x;
           y = poh->y;

        for (i = FAST_BRUSH_COUNT; i != 0; i--)
           {
               ULONG ulOffset;
               ULONG ulCeil;
            ULONG ulDiff;

               // Note:  I learned the HARD way that you can't just align x
            //        to your pattern size, because the lDelta of your screen
            //        is not guaranteed to be a multiple of your pattern size.
            //        Since y is changing in this loop, the recalc must
            //        be done inside this loop.  I really need to set these
            //        up with a hardcoded linear buffer or else make the
            //        heap linear.

               ulOffset = (y * ppdev->lDelta) + PELS_TO_BYTES(x);
               ulCeil = (ulOffset + (PELS_TO_BYTES(cBrushAlign)-1)) & ~(PELS_TO_BYTES(cBrushAlign)-1);
               ulDiff = (ulCeil - ulOffset)/ppdev->cBpp;

            // If we hadn't allocated 'ppdev' with FL_ZERO_MEMORY,
               // we would have to initialize pbe->prbVerify too...

               pbe->x = x + ulDiff;
               pbe->y = y;
            pbe->xy = (pbe->y * ppdev->lDelta) + PELS_TO_BYTES(pbe->x);

               DISPDBG((2, "BrushCache[%d] pos(%d,%d) offset(%d)", i, pbe->x,
                        pbe->y, pbe->xy ));

               y++;
               pbe++;
        }
       }

    // Note that we don't have to remember 'poh' for when we have
       // to disable brushes -- the off-screen heap frees any
    // off-screen heap allocations automatically.

    // We successfully allocated the brush cache, so let's turn
    // on the switch showing that we can use it:
    
    ppdev->flStatus |= STAT_BRUSH_CACHE;

ReturnTrue:

    // If we couldn't allocate a brush cache, it's not a catastrophic
    // failure; patterns will still work, although they'll be a bit
    // slower since they'll go through GDI.  As a result we don't
    // actually have to fail this call:

    vAssertModeBrushCache(ppdev, TRUE);

    DISPDBG((5, "Passed bEnableBrushCache"));

    return(TRUE);
}

/******************************Public*Routine******************************\
* VOID vDisableBrushCache
*
* Cleans up anything done in bEnableBrushCache.
\**************************************************************************/

VOID vDisableBrushCache(PDEV* ppdev)
{
    // We ain't gotta do nothin'
}

/******************************Public*Routine******************************\
* VOID vAssertModeBrushCache
*
* Resets the brush cache when we exit out of full-screen.
\**************************************************************************/

VOID vAssertModeBrushCache(
PDEV*   ppdev,
BOOL    bEnable)
{
    BRUSHENTRY* pbe;
    LONG        i;

    if (bEnable)
    {
        //bc#1 Invalidate the dither cache.
        if (ppdev->flStatus & STAT_DITHER_CACHE)
        {
            for (i = 0; i < NUM_DITHERS; i++)
            {
                ppdev->aDithers[i].ulColor = (ULONG) -1;
            }
        }

        //bc#1 Invalidate the pattern cache.
        if (ppdev->flStatus & STAT_PATTERN_CACHE)
        {
            for (i = 0; i < NUM_PATTERNS; i++)
            {
                ppdev->aPatterns[i].prbUniq = NULL;
            }
        }

        //bc#1 Invalidate the monochrome cache.
        if (ppdev->flStatus & STAT_MONOCHROME_CACHE)
        {
            for (i = 0; i < NUM_MONOCHROMES; i++)
            {
                ppdev->aMonochromes[i].ulUniq         = 0;
                ppdev->aMonochromes[i].aulPattern[0] = 0;
                ppdev->aMonochromes[i].aulPattern[1] = 0;
            }
        }

        // Invalidate the brush cache.
        if (ppdev->flStatus & STAT_BRUSH_CACHE)
        {
            pbe = &ppdev->abe[0];
    
            for (i = ppdev->cBrushCache; i != 0; i--)
            {
                pbe->prbVerify = NULL;
                pbe++;
            }
        }

        // Create a solid 8 x 8 monochrome bitmap in offscreen memory which
        // will be used for solid fills.
        if (ppdev->flCaps & CAPS_MM_IO)
        {
            BYTE* pjBase = ppdev->pjBase;

            CP_MM_WAIT_FOR_BLT_COMPLETE(ppdev, pjBase);
            CP_MM_XCNT(ppdev, pjBase, 7);
            CP_MM_YCNT(ppdev, pjBase, 0);
            CP_MM_DST_WRITE_MASK(ppdev, pjBase, 0);
            CP_MM_BLT_MODE(ppdev, pjBase, 0);
            CP_MM_ROP(ppdev, pjBase, CL_WHITENESS);
            CP_MM_DST_ADDR_ABS(ppdev, pjBase, ppdev->ulSolidColorOffset);
            CP_MM_START_BLT(ppdev, pjBase);
        }
        else
        {
            BYTE* pjPorts = ppdev->pjPorts;

            CP_IO_WAIT_FOR_BLT_COMPLETE(ppdev, pjPorts);
            CP_IO_XCNT(ppdev, pjPorts, 7);
            CP_IO_YCNT(ppdev, pjPorts, 0);
            CP_IO_BLT_MODE(ppdev, pjPorts, 0);
            CP_IO_ROP(ppdev, pjPorts, CL_WHITENESS);
            CP_IO_DST_ADDR_ABS(ppdev, pjPorts, ppdev->ulSolidColorOffset);
            CP_IO_START_BLT(ppdev, pjPorts);
        }
    }
}

////////////////////////////////////////////////////////////////////////////////
//                                                                              //
//                        B R U S H   C A C H E   S T U F F                      //
//                                                                              //
////////////////////////////////////////////////////////////////////////////////
/*
    Dither Cache:
    ============
    The dither cache is very important (at least with a slow CPU). Since the
    dithering process (in 8-bpp) takes quite a long time we must somehow cache
    the dithering process so it doesn't have to be executed over and over again.
    We do this by comparing the requested logical color with the cached dithers.
    If we have a match we simply copy the cached parameters and return. If we
    don't have a match we create a new cache slot and create the dither in
    off-screen memory.

    Pattern Cache:
    =============
    The pattern cache holds the colored brushes. Whenever we are requested to
    realize the same brush again, we can simply return. We don't check for the
    brush bits since that will take up too much time.

    Monochrome Cache:
    ================
    The monochrome cache holds the monochrome brushes. Whenever a monochrome
    brush needs to be realized we check to see if it is already cached
    off-screen. If it is we simply copy the cached parameters and return.
    Otherwise we have to create a new cache slot and realize the monochrome
    brush directly in off-screen memory. This has a slight performance hit since
    the bitblt engine is interrupted (on CL5436) or must be idle (in 24-bpp).

    Translation Cache:
    =================
    Is not yet implemented.
*/

/******************************************************************************\
*
* Function:     bCacheDither
*
* Cache a dithered color.
*
* Parameters:   ppdev        Pointer to physicsl device.
*                prb            Pointer to physical brush.
*
* Returns:      TRUE.
*
\******************************************************************************/
BOOL bCacheDither(
PDEV*   ppdev,
RBRUSH* prb)
{
    ULONG         ulNumVertices;
    VERTEX_DATA     vVertexData[4];
    VERTEX_DATA* pvVertexData;
    DITHERCACHE* pdc;
    ULONG         ulIndex;

    // New dither cache entry.
    ulIndex = ppdev->iDitherCache++ % NUM_DITHERS;
    pdc        = &ppdev->aDithers[ulIndex];

    // Store the color in the cache slot.
    pdc->ulColor = prb->ulUniq;

    // Update the brush cache variables.
    prb->ulSlot  = (ULONG)((ULONG_PTR)pdc - (ULONG_PTR)ppdev);
    prb->ulBrush = pdc->ulBrush;

    // Create the dither.
    pvVertexData  = vComputeSubspaces(prb->ulUniq, vVertexData);
    ulNumVertices = (ULONG)(pvVertexData - vVertexData);
    vDitherColorToVideoMemory((ULONG*) (ppdev->pjScreen + pdc->ulBrush), vVertexData,
                 pvVertexData, ulNumVertices);

    DISPDBG((20, "Caching dithered brush ulIndex=%d ulColor=%06X",
             ulIndex, pdc->ulColor));
    return(TRUE);
}

/******************************************************************************\
*
* Function:     bCacheColor
*
* Cache a patterned brush.
*
* Parameters:   ppdev        Pointer to physicsl device.
*                prb            Pointer to physical brush.
*
* Returns:      TRUE.
*
\******************************************************************************/
BOOL bCachePattern(
PDEV*   ppdev,
RBRUSH* prb
)
{
    PATTERNCACHE* ppc;
    LONG          lDstDelta;
    SIZEL          sizlDst;
    ULONG*          pulSrc;
    LONG          i;
    ULONG*          pulDst;
    ULONG          ulIndex;

    BYTE* pjBase = ppdev->pjBase;

    // New pattern cache entry.
    ulIndex = ppdev->iPatternCache++ % NUM_PATTERNS;
    ppc     = &ppdev->aPatterns[ulIndex];

    // Update the brush cache variables.
    ppc->prbUniq = prb;
    prb->ulSlot  = (ULONG)((ULONG_PTR)ppc - (ULONG_PTR)ppdev);
    prb->ulBrush = ppc->ulBrush;

    // Calculate the sizes for the pattern.
    pulSrc     = prb->aulPattern;
    pulDst       = (ULONG*) ppdev->pulXfer;
    lDstDelta  = (ppdev->cBpp == 3) ? (8 * 4) : PELS_TO_BYTES(8);
    sizlDst.cx = PELS_TO_BYTES(8) - 1;
    sizlDst.cy = 8 - 1;

    // Wait for the bitblt engine.
    CP_MM_WAIT_FOR_BLT_COMPLETE(ppdev, pjBase);

    // Setup the blit registers.
    CP_MM_XCNT(ppdev, pjBase, sizlDst.cx);
    CP_MM_YCNT(ppdev, pjBase, sizlDst.cy);
    CP_MM_DST_Y_OFFSET(ppdev, pjBase, lDstDelta);
    CP_MM_DST_WRITE_MASK(ppdev, pjBase, 0);
    CP_MM_BLT_MODE(ppdev, pjBase, SRC_CPU_DATA);
    CP_MM_ROP(ppdev, pjBase, CL_SRC_COPY);
    CP_MM_DST_ADDR_ABS(ppdev, pjBase, ppc->ulBrush);

    // Copy the brush to off-screen cache memory.
    for (i = prb->cjBytes; i > 0; i -= sizeof(ULONG))
    {
        WRITE_REGISTER_ULONG(pulDst, *pulSrc++);
    }

    DISPDBG((20, "Caching patterned brush at slot %d", ulIndex));
    return(TRUE);
}

/******************************************************************************\
*
* Function:     bCacheMonochrome
*
* Cache a monochrome brush.
*
* Parameters:   ppdev        Pointer to physicsl device.
*                prb            Pointer to physical brush.
*
* Returns:      TRUE.
*
\******************************************************************************/
BOOL bCacheMonochrome(
PDEV*   ppdev,
RBRUSH* prb
)
{
    MONOCACHE* pmc;
    ULONG       ulIndex;
    BYTE*       pjDst;
    ULONG*     pulDst;

    // New monochrome cache entry.
    ulIndex = ppdev->iMonochromeCache++ % NUM_MONOCHROMES;
    pmc     = &ppdev->aMonochromes[ulIndex];

    // Update the brush cache variables.
    pmc->aulPattern[0] = prb->aulPattern[0];
    pmc->aulPattern[1] = prb->aulPattern[1];

    pmc->ulUniq     = ppdev->iMonochromeCache;
    prb->ulUniq     = ppdev->iMonochromeCache;
    prb->ulSlot  = (ULONG)((ULONG_PTR)pmc - (ULONG_PTR)ppdev);
    prb->ulBrush = pmc->ulBrush;

    // Copy the brush to off-screen cache memory.
    if (ppdev->cBpp == 3)
    {
        BYTE* pjBase = ppdev->pjBase;

        // Copy colors to brush cache.
        pmc->ulBackColor = prb->ulBackColor;
        pmc->ulForeColor = prb->ulForeColor;

        pulDst = (ULONG*)ppdev->pulXfer;

        // Wait for bitblt engine.
        while (BUSY_BLT(ppdev, pjBase));

        // Fill the background.
        CP_MM_FG_COLOR(ppdev, pjBase, pmc->ulBackColor);
        CP_MM_XCNT(ppdev, pjBase, (8 * 3) - 1);
        CP_MM_YCNT(ppdev, pjBase, (8) - 1);
        CP_MM_DST_Y_OFFSET(ppdev, pjBase, 8 * 4);
        CP_MM_DST_WRITE_MASK(ppdev, pjBase, 0);
        CP_MM_BLT_MODE(ppdev, pjBase, ENABLE_COLOR_EXPAND |
                                      ENABLE_8x8_PATTERN_COPY |
                                      SET_24BPP_COLOR);
        CP_MM_ROP(ppdev, pjBase, CL_SRC_COPY);
        CP_MM_BLT_EXT_MODE(ppdev, pjBase, ENABLE_SOLID_FILL);
        CP_MM_DST_ADDR_ABS(ppdev, pjBase, pmc->ulBrush);

        // Wait for bitblt engine.
        CP_MM_WAIT_FOR_BLT_COMPLETE(ppdev, pjBase);

        // Expand the pattern.
        CP_MM_FG_COLOR(ppdev, pjBase, pmc->ulForeColor);
        CP_MM_BLT_MODE(ppdev, pjBase, ENABLE_COLOR_EXPAND |
                                      SET_24BPP_COLOR |
                                      ENABLE_TRANSPARENCY_COMPARE |
                                      SRC_CPU_DATA);
        CP_MM_BLT_EXT_MODE(ppdev, pjBase, 0)                // jl01
        CP_MM_DST_ADDR_ABS(ppdev, pjBase, pmc->ulBrush);

        WRITE_REGISTER_ULONG(pulDst, pmc->aulPattern[0]);
        WRITE_REGISTER_ULONG(pulDst, pmc->aulPattern[1]);
    }

    else
    {
        pulDst = (ULONG *)(ppdev->pjScreen + prb->ulBrush);

        WRITE_REGISTER_ULONG(pulDst++, prb->aulPattern[0]);
        WRITE_REGISTER_ULONG(pulDst,   prb->aulPattern[1]);
    }

    DISPDBG((20, "Caching monochrome brush ulIndex=%d pattern=%08X%08X",
             ulIndex, prb->aulPattern[0], prb->aulPattern[1]));
    return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\cirrus\disp\bitblt.c ===
/******************************Module*Header*******************************\
* Module Name: bitblt.c
*
* Contains the high-level DrvBitBlt and DrvCopyBits functions.  The low-
* level stuff lives in the 'blt??.c' files.
*
* !!! Change note about 'iType'
*
* Note: Since we've implemented device-bitmaps, any surface that GDI passes
*       to us can have 3 values for its 'iType': STYPE_BITMAP, STYPE_DEVICE
*       or STYPE_DEVBITMAP.  We filter device-bitmaps that we've stored
*       as DIBs fairly high in the code, so after we adjust its 'pptlSrc',
*       we can treat STYPE_DEVBITMAP surfaces the same as STYPE_DEVICE
*       surfaces (e.g., a blt from an off-screen device bitmap to the screen
*       gets treated as a normal screen-to-screen blt).  So throughout
*       this code, we will compare a surface's 'iType' to STYPE_BITMAP:
*       if it's equal, we've got a true DIB, and if it's unequal, we have
*       a screen-to-screen operation.
*
* Copyright (c) 1992-1995 Microsoft Corporation
\**************************************************************************/

#include "precomp.h"

/******************************Public*Table********************************\
* BYTE gajLeftMask[] and BYTE gajRightMask[]
*
* Edge tables for vXferScreenTo1bpp.
\**************************************************************************/

BYTE gajLeftMask[]  = { 0xff, 0x7f, 0x3f, 0x1f, 0x0f, 0x07, 0x03, 0x01 };
BYTE gajRightMask[] = { 0xff, 0x80, 0xc0, 0xe0, 0xf0, 0xf8, 0xfc, 0xfe };

/******************************Public*Routine******************************\
* VOID vXferNativeSrccopy
*
* Does a SRCCOPY transfer of a bitmap to the screen using the frame
* buffer, because on the Cirrus chips it's faster than using the data
* transfer register.
*
\**************************************************************************/

VOID vXferNativeSrccopy(        // Type FNXFER
PDEV*       ppdev,
LONG        c,                  // Count of rectangles, can't be zero
RECTL*      prcl,               // List of destination rectangles, in relative
                                //   coordinates
ULONG       rop4,               // Not used
SURFOBJ*    psoSrc,             // Source surface
POINTL*     pptlSrc,            // Original unclipped source point
RECTL*      prclDst,            // Original unclipped destination rectangle
XLATEOBJ*   pxlo)               // Not used
{
    LONG    xOffset;
    LONG    yOffset;
    LONG    dx;
    LONG    dy;
    RECTL   rclDst;
    POINTL  ptlSrc;

    ASSERTDD((pxlo == NULL) || (pxlo->flXlate & XO_TRIVIAL),
            "Can handle trivial xlate only");
    ASSERTDD(psoSrc->iBitmapFormat == ppdev->iBitmapFormat,
            "Source must be same colour depth as screen");
    ASSERTDD(c > 0, "Can't handle zero rectangles");
    ASSERTDD(rop4 == 0xcccc, "Must be a SRCCOPY rop");

    xOffset = ppdev->xOffset;
    yOffset = ppdev->yOffset;

    dx = pptlSrc->x - prclDst->left;
    dy = pptlSrc->y - prclDst->top;     // Add to destination to get source

    while (TRUE)
    {
        ptlSrc.x      = prcl->left   + dx;
        ptlSrc.y      = prcl->top    + dy;

        // 'ppdev->pfnPutBits' takes only absolute coordinates, so add in the
        // off-screen bitmap offset here:

        rclDst.left   = prcl->left   + xOffset;
        rclDst.right  = prcl->right  + xOffset;
        rclDst.top    = prcl->top    + yOffset;
        rclDst.bottom = prcl->bottom + yOffset;

        ppdev->pfnPutBits(ppdev, psoSrc, &rclDst, &ptlSrc);

        if (--c == 0)
            return;

        prcl++;
    }
}

/******************************Public*Routine******************************\
* VOID vXferScreenTo1bpp
*
* Performs a SRCCOPY transfer from the screen (when it's 8bpp) to a 1bpp
* bitmap.
*
\**************************************************************************/

#if defined(_X86_)

VOID vXferScreenTo1bpp(         // Type FNXFER
PDEV*       ppdev,
LONG        c,                  // Count of rectangles, can't be zero
RECTL*      prcl,               // List of destination rectangles, in relative
                                //   coordinates
ULONG       ulHwMix,            // Not used
SURFOBJ*    psoDst,             // Destination surface
POINTL*     pptlSrc,            // Original unclipped source point
RECTL*      prclDst,            // Original unclipped destination rectangle
XLATEOBJ*   pxlo)               // Provides colour-compressions information
{
    LONG    cBpp;
    VOID*   pfnCompute;
    SURFOBJ soTmp;
    ULONG*  pulXlate;
    ULONG   ulForeColor;
    POINTL  ptlSrc;
    RECTL   rclTmp;
    BYTE*   pjDst;
    BYTE    jLeftMask;
    BYTE    jRightMask;
    BYTE    jNotLeftMask;
    BYTE    jNotRightMask;
    LONG    cjMiddle;
    LONG    lDstDelta;
    LONG    lSrcDelta;
    LONG    cyTmpScans;
    LONG    cyThis;
    LONG    cyToGo;

    ASSERTDD(c > 0, "Can't handle zero rectangles");
    ASSERTDD(psoDst->iBitmapFormat == BMF_1BPP, "Only 1bpp destinations");
    ASSERTDD(TMP_BUFFER_SIZE >= PELS_TO_BYTES(ppdev->cxMemory),
                "Temp buffer has to be larger than widest possible scan");

    // When the destination is a 1bpp bitmap, the foreground colour
    // maps to '1', and any other colour maps to '0'.

    if (ppdev->iBitmapFormat == BMF_8BPP)
    {
        // When the source is 8bpp or less, we find the forground colour
        // by searching the translate table for the only '1':

        pulXlate = pxlo->pulXlate;
        while (*pulXlate != 1)
            pulXlate++;

        ulForeColor = pulXlate - pxlo->pulXlate;
    }
    else
    {
        ASSERTDD((ppdev->iBitmapFormat == BMF_16BPP) ||
                 (ppdev->iBitmapFormat == BMF_32BPP),
                 "This routine only supports 8, 16 or 32bpp");

        // When the source has a depth greater than 8bpp, the foreground
        // colour will be the first entry in the translate table we get
        // from calling 'piVector':

        pulXlate = XLATEOBJ_piVector(pxlo);

        ulForeColor = 0;
        if (pulXlate != NULL)           // This check isn't really needed...
            ulForeColor = pulXlate[0];
    }

    // We use the temporary buffer to keep a copy of the source
    // rectangle:

    soTmp.pvScan0 = ppdev->pvTmpBuffer;

    do {
        // ptlSrc points to the upper-left corner of the screen rectangle
        // for the current batch:

        ptlSrc.x = prcl->left + (pptlSrc->x - prclDst->left);
        ptlSrc.y = prcl->top  + (pptlSrc->y - prclDst->top);

        // ppdev->pfnGetBits takes absolute coordinates for the source point:

        ptlSrc.x += ppdev->xOffset;
        ptlSrc.y += ppdev->yOffset;

        pjDst = (BYTE*) psoDst->pvScan0 + (prcl->top * psoDst->lDelta)
                                        + (prcl->left >> 3);

        cBpp = ppdev->cBpp;

        soTmp.lDelta = PELS_TO_BYTES(((prcl->right + 7L) & ~7L) - (prcl->left & ~7L));

        // Our temporary buffer, into which we read a copy of the source,
        // may be smaller than the source rectangle.  In that case, we
        // process the source rectangle in batches.
        //
        // cyTmpScans is the number of scans we can do in each batch.
        // cyToGo is the total number of scans we have to do for this
        // rectangle.
        //
        // We take the buffer size less four so that the right edge case
        // can safely read one dword past the end:

        cyTmpScans = (TMP_BUFFER_SIZE - 4) / soTmp.lDelta;
        cyToGo     = prcl->bottom - prcl->top;

        ASSERTDD(cyTmpScans > 0, "Buffer too small for largest possible scan");

        // Initialize variables that don't change within the batch loop:

        rclTmp.top    = 0;
        rclTmp.left   = prcl->left & 7L;
        rclTmp.right  = (prcl->right - prcl->left) + rclTmp.left;

        // Note that we have to be careful with the right mask so that it
        // isn't zero.  A right mask of zero would mean that we'd always be
        // touching one byte past the end of the scan (even though we
        // wouldn't actually be modifying that byte), and we must never
        // access memory past the end of the bitmap (because we can access
        // violate if the bitmap end is exactly page-aligned).

        jLeftMask     = gajLeftMask[rclTmp.left & 7];
        jRightMask    = gajRightMask[rclTmp.right & 7];
        cjMiddle      = ((rclTmp.right - 1) >> 3) - (rclTmp.left >> 3) - 1;

        if (cjMiddle < 0)
        {
            // The blt starts and ends in the same byte:

            jLeftMask &= jRightMask;
            jRightMask = 0;
            cjMiddle   = 0;
        }

        jNotLeftMask  = ~jLeftMask;
        jNotRightMask = ~jRightMask;
        lDstDelta     = psoDst->lDelta - cjMiddle - 2;
                                // Delta from the end of the destination
                                //  to the start on the next scan, accounting
                                //  for 'left' and 'right' bytes

        lSrcDelta     = soTmp.lDelta - PELS_TO_BYTES(8 * (cjMiddle + 2));
                                // Compute source delta for special cases
                                //  like when cjMiddle gets bumped up to '0',
                                //  and to correct aligned cases

        do {
            // This is the loop that breaks the source rectangle into
            // manageable batches.

            cyThis  = cyTmpScans;
            cyToGo -= cyThis;
            if (cyToGo < 0)
                cyThis += cyToGo;

            rclTmp.bottom = cyThis;

            ppdev->pfnGetBits(ppdev, &soTmp, &rclTmp, &ptlSrc);

            ptlSrc.y += cyThis;         // Get ready for next batch loop

            _asm {
                mov     eax,ulForeColor     ;eax = foreground colour
                                            ;ebx = temporary storage
                                            ;ecx = count of middle dst bytes
                                            ;dl  = destination byte accumulator
                                            ;dh  = temporary storage
                mov     esi,soTmp.pvScan0   ;esi = source pointer
                mov     edi,pjDst           ;edi = destination pointer

                ; Figure out the appropriate compute routine:

                mov     ebx,cBpp
                mov     pfnCompute,offset Compute_Destination_Byte_From_8bpp
                dec     ebx
                jz      short Do_Left_Byte
                mov     pfnCompute,offset Compute_Destination_Byte_From_16bpp
                dec     ebx
                jz      short Do_Left_Byte
                mov     pfnCompute,offset Compute_Destination_Byte_From_32bpp

            Do_Left_Byte:
                call    pfnCompute
                and     dl,jLeftMask
                mov     dh,jNotLeftMask
                and     dh,[edi]
                or      dh,dl
                mov     [edi],dh
                inc     edi
                mov     ecx,cjMiddle
                dec     ecx
                jl      short Do_Right_Byte

            Do_Middle_Bytes:
                call    pfnCompute
                mov     [edi],dl
                inc     edi
                dec     ecx
                jge     short Do_Middle_Bytes

            Do_Right_Byte:
                call    pfnCompute
                and     dl,jRightMask
                mov     dh,jNotRightMask
                and     dh,[edi]
                or      dh,dl
                mov     [edi],dh
                inc     edi

                add     edi,lDstDelta
                add     esi,lSrcDelta
                dec     cyThis
                jnz     short Do_Left_Byte

                mov     pjDst,edi               ;save for next batch

                jmp     All_Done

            Compute_Destination_Byte_From_8bpp:
                mov     bl,[esi]
                sub     bl,al
                cmp     bl,1
                adc     dl,dl                   ;bit 0

                mov     bl,[esi+1]
                sub     bl,al
                cmp     bl,1
                adc     dl,dl                   ;bit 1

                mov     bl,[esi+2]
                sub     bl,al
                cmp     bl,1
                adc     dl,dl                   ;bit 2

                mov     bl,[esi+3]
                sub     bl,al
                cmp     bl,1
                adc     dl,dl                   ;bit 3

                mov     bl,[esi+4]
                sub     bl,al
                cmp     bl,1
                adc     dl,dl                   ;bit 4

                mov     bl,[esi+5]
                sub     bl,al
                cmp     bl,1
                adc     dl,dl                   ;bit 5

                mov     bl,[esi+6]
                sub     bl,al
                cmp     bl,1
                adc     dl,dl                   ;bit 6

                mov     bl,[esi+7]
                sub     bl,al
                cmp     bl,1
                adc     dl,dl                   ;bit 7

                add     esi,8                   ;advance the source
                ret

            Compute_Destination_Byte_From_16bpp:
                mov     bx,[esi]
                sub     bx,ax
                cmp     bx,1
                adc     dl,dl                   ;bit 0

                mov     bx,[esi+2]
                sub     bx,ax
                cmp     bx,1
                adc     dl,dl                   ;bit 1

                mov     bx,[esi+4]
                sub     bx,ax
                cmp     bx,1
                adc     dl,dl                   ;bit 2

                mov     bx,[esi+6]
                sub     bx,ax
                cmp     bx,1
                adc     dl,dl                   ;bit 3

                mov     bx,[esi+8]
                sub     bx,ax
                cmp     bx,1
                adc     dl,dl                   ;bit 4

                mov     bx,[esi+10]
                sub     bx,ax
                cmp     bx,1
                adc     dl,dl                   ;bit 5

                mov     bx,[esi+12]
                sub     bx,ax
                cmp     bx,1
                adc     dl,dl                   ;bit 6

                mov     bx,[esi+14]
                sub     bx,ax
                cmp     bx,1
                adc     dl,dl                   ;bit 7

                add     esi,16                  ;advance the source
                ret

            Compute_Destination_Byte_From_32bpp:
                mov     ebx,[esi]
                sub     ebx,eax
                cmp     ebx,1
                adc     dl,dl                   ;bit 0

                mov     ebx,[esi+4]
                sub     ebx,eax
                cmp     ebx,1
                adc     dl,dl                   ;bit 1

                mov     ebx,[esi+8]
                sub     ebx,eax
                cmp     ebx,1
                adc     dl,dl                   ;bit 2

                mov     ebx,[esi+12]
                sub     ebx,eax
                cmp     ebx,1
                adc     dl,dl                   ;bit 3

                mov     ebx,[esi+16]
                sub     ebx,eax
                cmp     ebx,1
                adc     dl,dl                   ;bit 4

                mov     ebx,[esi+20]
                sub     ebx,eax
                cmp     ebx,1
                adc     dl,dl                   ;bit 5

                mov     ebx,[esi+24]
                sub     ebx,eax
                cmp     ebx,1
                adc     dl,dl                   ;bit 6

                mov     ebx,[esi+28]
                sub     ebx,eax
                cmp     ebx,1
                adc     dl,dl                   ;bit 7

                add     esi,32                  ;advance the source
                ret

            All_Done:
            }
        } while (cyToGo > 0);

        prcl++;
    } while (--c != 0);
}

#endif // i386

/******************************Public*Routine******************************\
* BOOL bPuntBlt
*
* Has GDI do any drawing operations that we don't specifically handle
* in the driver.
*
\**************************************************************************/

BOOL bPuntBlt(
SURFOBJ*    psoDst,
SURFOBJ*    psoSrc,
SURFOBJ*    psoMsk,
CLIPOBJ*    pco,
XLATEOBJ*   pxlo,
RECTL*      prclDst,
POINTL*     pptlSrc,
POINTL*     pptlMsk,
BRUSHOBJ*   pbo,
POINTL*     pptlBrush,
ROP4        rop4)
{
    PDEV*    ppdev;

    if (psoDst->dhsurf != NULL)
        ppdev = (PDEV*) psoDst->dhpdev;
    else
        ppdev = (PDEV*) psoSrc->dhpdev;

    #if DBG
    {
        //////////////////////////////////////////////////////////////////////
        // Diagnostics
        //
        // Since calling the engine to do any drawing can be rather painful,
        // particularly when the source is an off-screen DFB (since GDI will
        // have to allocate a DIB and call us to make a temporary copy before
        // it can even start drawing), we'll try to avoid it as much as
        // possible.
        //
        // Here we simply spew out information describing the blt whenever
        // this routine gets called (checked builds only, of course):

        ULONG ulClip;

        ulClip = (pco == NULL) ? DC_TRIVIAL : pco->iDComplexity;

        DISPDBG((4, ">> Punt << Dst format: %li Dst type: %li Clip: %li Rop: %lx",
            psoDst->iBitmapFormat, psoDst->iType, ulClip, rop4));

        if (psoSrc != NULL)
        {
            DISPDBG((4, "        << Src format: %li Src type: %li",
                psoSrc->iBitmapFormat, psoSrc->iType));

            if (psoSrc->iBitmapFormat == BMF_1BPP)
            {
                DISPDBG((4, "        << Foreground: %lx  Background: %lx",
                    pxlo->pulXlate[1], pxlo->pulXlate[0]));
            }
        }

        if ((pxlo != NULL) && !(pxlo->flXlate & XO_TRIVIAL) && (psoSrc != NULL))
        {
            if (((psoSrc->dhsurf == NULL) &&
                 (psoSrc->iBitmapFormat != ppdev->iBitmapFormat)) ||
                ((psoDst->dhsurf == NULL) &&
                 (psoDst->iBitmapFormat != ppdev->iBitmapFormat)))
            {
                // Don't bother printing the 'xlate' message when the source
                // is a different bitmap format from the destination -- in
                // those cases we know there always has to be a translate.
            }
            else
            {
                DISPDBG((4, "        << With xlate"));
            }
        }

        // If the rop4 requires a pattern, and it's a non-solid brush...

        if (((((rop4 >> 4) ^ (rop4)) & 0x0f0f) != 0) &&
            (pbo->iSolidColor == -1))
        {
            if (pbo->pvRbrush == NULL)
                DISPDBG((4, "        << With brush -- Not created"));
            else
                DISPDBG((4, "        << With brush -- Created Ok"));
        }
    }
    #endif

    if (DIRECT_ACCESS(ppdev))
    {
        //////////////////////////////////////////////////////////////////////
        // Banked Framebuffer bPuntBlt
        //
        // This section of code handles a PuntBlt when GDI can directly draw
        // on the framebuffer, but the drawing has to be done in banks:

        BANK     bnk;
        BOOL     b;
        HSURF    hsurfTmp;
        SURFOBJ* psoTmp;
        SIZEL    sizl;
        POINTL   ptlSrc;
        RECTL    rclTmp;
        RECTL    rclDst;

        if (ppdev->bLinearMode)
        {
            DSURF*  pdsurfDst;
            DSURF*  pdsurfSrc;
            OH*     pohSrc;
            OH*     pohDst;

            if (psoDst->dhsurf != NULL)
            {
                pdsurfDst       = (DSURF*) psoDst->dhsurf;
                psoDst          = ppdev->psoPunt;
                psoDst->pvScan0 = pdsurfDst->poh->pvScan0;

                if (psoSrc != NULL)
                {
                    pdsurfSrc = (DSURF*) psoSrc->dhsurf;
                    if ((pdsurfSrc != NULL) &&
                        (pdsurfSrc != pdsurfDst))
                    {
                        // If we're doing a BitBlt between different off-screen
                        // surfaces, we have to be sure to give GDI different
                        // surfaces, otherwise it may get confused when it has
                        // to do screen-to-screen blts with a translate...

                        pohSrc = pdsurfSrc->poh;
                        pohDst = pdsurfDst->poh;

                        psoSrc          = ppdev->psoPunt2;
                        psoSrc->pvScan0 = pohSrc->pvScan0;

                        // Undo the source pointer adjustment we did earlier:

                        ptlSrc.x = pptlSrc->x + (pohDst->x - pohSrc->x);
                        ptlSrc.y = pptlSrc->y + (pohDst->y - pohSrc->y);
                        pptlSrc  = &ptlSrc;
                    }
                }
            }
            else
            {
                ppdev           = (PDEV*)  psoSrc->dhpdev;
                pdsurfSrc       = (DSURF*) psoSrc->dhsurf;
                psoSrc          = ppdev->psoPunt;
                psoSrc->pvScan0 = pdsurfSrc->poh->pvScan0;
            }

            ppdev->pfnBankSelectMode(ppdev, BANK_ON);
            return(EngBitBlt(psoDst, psoSrc, psoMsk, pco, pxlo, prclDst, pptlSrc,
                             pptlMsk, pbo, pptlBrush, rop4));
        }

        // We copy the original destination rectangle, and use that in every
        // GDI call-back instead of the original because sometimes GDI is
        // sneaky and points 'prclDst' to '&pco->rclBounds'.  Because we
        // modify 'rclBounds', that would affect 'prclDst', which we don't
        // want to happen:

        rclDst = *prclDst;

        if ((psoSrc == NULL) || (psoSrc->iType == STYPE_BITMAP))
        {
            ASSERTDD(psoDst->iType != STYPE_BITMAP,
                     "Dest should be the screen when given a DIB source");

            // Do a memory-to-screen blt:

            vBankStart(ppdev, &rclDst, pco, &bnk);

            b = TRUE;
            do {
                b &= EngBitBlt(bnk.pso, psoSrc, psoMsk, bnk.pco, pxlo,
                               &rclDst, pptlSrc, pptlMsk, pbo, pptlBrush,
                               rop4);
            } while (bBankEnum(&bnk));
        }
        else
        {
            b = FALSE;  // Assume failure

            // The screen is the source (it may be the destination too...)

            ptlSrc.x = pptlSrc->x + ppdev->xOffset;
            ptlSrc.y = pptlSrc->y + ppdev->yOffset;

            if ((pco != NULL) && (pco->iDComplexity != DC_TRIVIAL))
            {
                // We have to intersect the destination rectangle with
                // the clip bounds if there is one (consider the case
                // where the app asked to blt a really, really big
                // rectangle from the screen -- prclDst would be really,
                // really big but pco->rclBounds would be the actual
                // area of interest):

                rclDst.left   = max(rclDst.left,   pco->rclBounds.left);
                rclDst.top    = max(rclDst.top,    pco->rclBounds.top);
                rclDst.right  = min(rclDst.right,  pco->rclBounds.right);
                rclDst.bottom = min(rclDst.bottom, pco->rclBounds.bottom);

                // Correspondingly, we have to offset the source point:

                ptlSrc.x += (rclDst.left - prclDst->left);
                ptlSrc.y += (rclDst.top - prclDst->top);
            }

            // We're now either going to do a screen-to-screen or screen-to-DIB
            // blt.  In either case, we're going to create a temporary copy of
            // the source.  (Why do we do this when GDI could do it for us?
            // GDI would create a temporary copy of the DIB for every bank
            // call-back!)

            sizl.cx = rclDst.right  - rclDst.left;
            sizl.cy = rclDst.bottom - rclDst.top;

            // Don't forget to convert from relative to absolute coordinates
            // on the source!  (vBankStart takes care of that for the
            // destination.)

            rclTmp.right  = sizl.cx;
            rclTmp.bottom = sizl.cy;
            rclTmp.left   = 0;
            rclTmp.top    = 0;

            // GDI does guarantee us that the blt extents have already been
            // clipped to the surface boundaries (we don't have to worry
            // here about trying to read where there isn't video memory).
            // Let's just assert to make sure:

            ASSERTDD((ptlSrc.x >= 0) &&
                     (ptlSrc.y >= 0) &&
                     (ptlSrc.x + sizl.cx <= ppdev->cxMemory) &&
                     (ptlSrc.y + sizl.cy <= ppdev->cyMemory),
                     "Source rectangle out of bounds!");

            hsurfTmp = (HSURF) EngCreateBitmap(sizl,
                                               0,    // Let GDI choose ulWidth
                                               ppdev->iBitmapFormat,
                                               0,    // Don't need any options
                                               NULL);// Let GDI allocate

            if (hsurfTmp != 0)
            {
                psoTmp = EngLockSurface(hsurfTmp);

                if (psoTmp != NULL)
                {
                    ppdev->pfnGetBits(ppdev, psoTmp, &rclTmp, &ptlSrc);

                    if (psoDst->iType == STYPE_BITMAP)
                    {
                        // It was a Screen-to-DIB blt; now it's a DIB-to-DIB
                        // blt.  Note that the source point is (0, 0) in our
                        // temporary surface:

                        b = EngBitBlt(psoDst, psoTmp, psoMsk, pco, pxlo,
                                      &rclDst, (POINTL*) &rclTmp, pptlMsk,
                                      pbo, pptlBrush, rop4);
                    }
                    else
                    {
                        // It was a Screen-to-Screen blt; now it's a DIB-to-
                        // screen blt.  Note that the source point is (0, 0)
                        // in our temporary surface:

                        vBankStart(ppdev, &rclDst, pco, &bnk);

                        b = TRUE;
                        do {
                            b &= EngBitBlt(bnk.pso, psoTmp, psoMsk, bnk.pco,
                                           pxlo, &rclDst, (POINTL*) &rclTmp,
                                           pptlMsk, pbo, pptlBrush, rop4);

                        } while (bBankEnum(&bnk));
                    }

                    EngUnlockSurface(psoTmp);
                }

                EngDeleteSurface(hsurfTmp);
            }
        }

        return(b);
    }

#if !defined(_X86_)

    else
    {
        //////////////////////////////////////////////////////////////////////
        // Really Slow bPuntBlt
        //
        // Here we handle a PuntBlt when GDI can't draw directly on the
        // framebuffer (as on the Alpha, which can't do it because of its
        // 32 bit bus).  If you thought the banked version was slow, just
        // look at this one.  Guaranteed, there will be at least one bitmap
        // allocation and extra copy involved; there could be two if it's a
        // screen-to-screen operation.

        POINTL  ptlSrc;
        RECTL   rclDst;
        SIZEL   sizl;
        BOOL    bSrcIsScreen;
        HSURF   hsurfSrc;
        RECTL   rclTmp;
        BOOL    b;
        LONG    lDelta;
        BYTE*   pjBits;
        BYTE*   pjScan0;
        HSURF   hsurfDst;
        RECTL   rclScreen;

        b = FALSE;          // For error cases, assume we'll fail

        rclDst = *prclDst;
        if (pptlSrc != NULL)
            ptlSrc = *pptlSrc;

        if ((pco != NULL) && (pco->iDComplexity != DC_TRIVIAL))
        {
            // We have to intersect the destination rectangle with
            // the clip bounds if there is one (consider the case
            // where the app asked to blt a really, really big
            // rectangle from the screen -- prclDst would be really,
            // really big but pco->rclBounds would be the actual
            // area of interest):

            rclDst.left   = max(rclDst.left,   pco->rclBounds.left);
            rclDst.top    = max(rclDst.top,    pco->rclBounds.top);
            rclDst.right  = min(rclDst.right,  pco->rclBounds.right);
            rclDst.bottom = min(rclDst.bottom, pco->rclBounds.bottom);

            ptlSrc.x += (rclDst.left - prclDst->left);
            ptlSrc.y += (rclDst.top  - prclDst->top);
        }

        sizl.cx = rclDst.right  - rclDst.left;
        sizl.cy = rclDst.bottom - rclDst.top;

        // We only need to make a copy from the screen if the source is
        // the screen, and the source is involved in the rop.  Note that
        // we have to check the rop before dereferencing 'psoSrc'
        // (because 'psoSrc' may be NULL if the source isn't involved):

        bSrcIsScreen = (((((rop4 >> 2) ^ (rop4)) & 0x3333) != 0) &&
                        (psoSrc->iType != STYPE_BITMAP));

        if (bSrcIsScreen)
        {
            // We need to create a copy of the source rectangle:

            hsurfSrc = (HSURF) EngCreateBitmap(sizl, 0, ppdev->iBitmapFormat,
                                               0, NULL);
            if (hsurfSrc == 0)
                goto Error_0;

            psoSrc = EngLockSurface(hsurfSrc);
            if (psoSrc == NULL)
                goto Error_1;

            rclTmp.left   = 0;
            rclTmp.top    = 0;
            rclTmp.right  = sizl.cx;
            rclTmp.bottom = sizl.cy;

            // ppdev->pfnGetBits takes absolute coordinates for the source point:

            ptlSrc.x += ppdev->xOffset;
            ptlSrc.y += ppdev->yOffset;

            ppdev->pfnGetBits(ppdev, psoSrc, &rclTmp, &ptlSrc);

            // The source will now come from (0, 0) of our temporary source
            // surface:

            ptlSrc.x = 0;
            ptlSrc.y = 0;
        }

        if (psoDst->iType == STYPE_BITMAP)
        {
            b = EngBitBlt(psoDst, psoSrc, psoMsk, pco, pxlo, &rclDst, &ptlSrc,
                          pptlMsk, pbo, pptlBrush, rop4);
        }
        else
        {
            // We need to create a temporary work buffer.  We have to do
            // some fudging with the offsets so that the upper-left corner
            // of the (relative coordinates) clip object bounds passed to
            // GDI will be transformed to the upper-left corner of our
            // temporary bitmap.

            // The alignment doesn't have to be as tight as this at 16bpp
            // and 32bpp, but it won't hurt:

            lDelta = PELS_TO_BYTES(((rclDst.right + 3) & ~3L) -
                                   ((rclDst.left) & ~3L));

            // We're actually only allocating a bitmap that is 'sizl.cx' x
            // 'sizl.cy' in size:

            pjBits = EngAllocMem(0, lDelta * sizl.cy, ALLOC_TAG);
            if (pjBits == NULL)
                goto Error_2;

            // We now adjust the surface's 'pvScan0' so that when GDI thinks
            // it's writing to pixel (rclDst.top, rclDst.left), it will
            // actually be writing to the upper-left pixel of our temporary
            // bitmap:

            pjScan0 = pjBits - (rclDst.top * lDelta)
                             - (PELS_TO_BYTES(rclDst.left & ~3L));

            ASSERTDD((((ULONG_PTR)pjScan0) & 3) == 0,
                    "pvScan0 must be dword aligned!");

            // The checked build of GDI sometimes checks on blts that
            // prclDst->right <= pso->sizl.cx, so we lie to it about
            // the size of our bitmap:

            sizl.cx = rclDst.right;
            sizl.cy = rclDst.bottom;

            hsurfDst = (HSURF) EngCreateBitmap(
                        sizl,                   // Bitmap covers rectangle
                        lDelta,                 // Use this delta
                        ppdev->iBitmapFormat,   // Same colour depth
                        BMF_TOPDOWN,            // Must have a positive delta
                        pjScan0);               // Where (0, 0) would be

            if ((hsurfDst == 0) ||
                (!EngAssociateSurface(hsurfDst, ppdev->hdevEng, 0)))
                goto Error_3;

            psoDst = EngLockSurface(hsurfDst);
            if (psoDst == NULL)
                goto Error_4;

            // Make sure that the rectangle we Get/Put from/to the screen
            // is in absolute coordinates:

            rclScreen.left   = rclDst.left   + ppdev->xOffset;
            rclScreen.right  = rclDst.right  + ppdev->xOffset;
            rclScreen.top    = rclDst.top    + ppdev->yOffset;
            rclScreen.bottom = rclDst.bottom + ppdev->yOffset;

            // It would be nice to get a copy of the destination rectangle
            // only when the ROP involves the destination (or when the source
            // is an RLE), but we can't do that.  If the brush is truly NULL,
            // GDI will immediately return TRUE from EngBitBlt, without
            // modifying the temporary bitmap -- and we would proceed to
            // copy the uninitialized temporary bitmap back to the screen.

            ppdev->pfnGetBits(ppdev, psoDst, &rclDst, (POINTL*) &rclScreen);

            b = EngBitBlt(psoDst, psoSrc, psoMsk, pco, pxlo, &rclDst, &ptlSrc,
                          pptlMsk, pbo, pptlBrush, rop4);

            ppdev->pfnPutBits(ppdev, psoDst, &rclScreen, (POINTL*) &rclDst);

            EngUnlockSurface(psoDst);

        Error_4:

            EngDeleteSurface(hsurfDst);

        Error_3:

            EngFreeMem(pjBits);
        }

        Error_2:

        if (bSrcIsScreen)
        {
            EngUnlockSurface(psoSrc);

        Error_1:

            EngDeleteSurface(hsurfSrc);
        }

        Error_0:

        return(b);
    }

#endif

}

/******************************Public*Routine******************************\
* BOOL DrvBitBlt
*
* Implements the workhorse routine of a display driver.
*
\**************************************************************************/

BOOL DrvBitBlt(
SURFOBJ*    psoDst,
SURFOBJ*    psoSrc,
SURFOBJ*    psoMsk,
CLIPOBJ*    pco,
XLATEOBJ*   pxlo,
RECTL*      prclDst,
POINTL*     pptlSrc,
POINTL*     pptlMsk,
BRUSHOBJ*   pbo,
POINTL*     pptlBrush,
ROP4        rop4)
{
    PDEV*           ppdev;
    DSURF*          pdsurfDst;
    DSURF*          pdsurfSrc;
    POINTL          ptlSrc;
    BYTE            jClip;
    OH*             poh;
    BOOL            bMore;
    CLIPENUM        ce;
    LONG            c;
    RECTL           rcl;
    BYTE            rop3;
    FNFILL*         pfnFill;
    RBRUSH_COLOR    rbc;        // Realized brush or solid colour
    FNXFER*         pfnXfer;
    ULONG           iSrcBitmapFormat;
    ULONG           iDir;
    BOOL            bRet;
    XLATECOLORS     xlc;
    XLATEOBJ        xlo;

    bRet = TRUE;                // Assume success

    pdsurfDst = (DSURF*) psoDst->dhsurf;    // May be NULL

    if (psoSrc == NULL)
    {
        ///////////////////////////////////////////////////////////////////
        // Fills
        ///////////////////////////////////////////////////////////////////

        // Fills are this function's "raison d'etre", so we handle them
        // as quickly as possible:

        ASSERTDD(pdsurfDst != NULL,
                 "Expect only device destinations when no source");

        if (pdsurfDst->dt == DT_SCREEN)
        {
            ppdev = (PDEV*) psoDst->dhpdev;

            poh = pdsurfDst->poh;
            ppdev->xOffset  = poh->x;
            ppdev->yOffset  = poh->y;
            ppdev->xyOffset = poh->xy;

            // Make sure it doesn't involve a mask (i.e., it's really a
            // Rop3):

            rop3 = (BYTE) rop4;

            if ((BYTE) (rop4 >> 8) == rop3)
            {
                // Since 'psoSrc' is NULL, the rop3 had better not indicate
                // that we need a source.

                ASSERTDD((((rop4 >> 2) ^ (rop4)) & 0x33) == 0,
                         "Need source but GDI gave us a NULL 'psoSrc'");

            // Fill_It:

                pfnFill = ppdev->pfnFillSolid;   // Default to solid fill

                if ((((rop3 >> 4) ^ (rop3)) & 0xf) != 0)
                {
                    // The rop says that a pattern is truly required
                    // (blackness, for instance, doesn't need one):

                    rbc.iSolidColor = pbo->iSolidColor;
                    if (rbc.iSolidColor == -1)
                    {

                        if (ppdev->cBpp > 3)
                        {
                            // [HWBUG]
                            goto Punt_It;
                        }

                        // Try and realize the pattern brush; by doing
                        // this call-back, GDI will eventually call us
                        // again through DrvRealizeBrush:

                        rbc.prb = pbo->pvRbrush;
                        if (rbc.prb == NULL)
                        {
                            rbc.prb = BRUSHOBJ_pvGetRbrush(pbo);
                            if (rbc.prb == NULL)
                            {
                                // If we couldn't realize the brush, punt
                                // the call (it may have been a non 8x8
                                // brush or something, which we can't be
                                // bothered to handle, so let GDI do the
                                // drawing):

                                goto Punt_It;
                            }
                        }
                        pfnFill = ppdev->pfnFillPat;
                    }
                }

                // Note that these 2 'if's are more efficient than
                // a switch statement:

                if ((pco == NULL) || (pco->iDComplexity == DC_TRIVIAL))
                {
                    pfnFill(ppdev, 1, prclDst, rop4, rbc, pptlBrush);
                    goto All_Done;
                }
                else if (pco->iDComplexity == DC_RECT)
                {
                    if (bIntersect(prclDst, &pco->rclBounds, &rcl))
                        pfnFill(ppdev, 1, &rcl, rop4, rbc, pptlBrush);
                    goto All_Done;
                }
                else
                {
                    CLIPOBJ_cEnumStart(pco, FALSE, CT_RECTANGLES, CD_ANY, 0);

                    do {
                        bMore = CLIPOBJ_bEnum(pco, sizeof(ce), (ULONG*) &ce);

                        c = cIntersect(prclDst, ce.arcl, ce.c);

                        if (c != 0)
                            pfnFill(ppdev, c, ce.arcl, rop4, rbc, pptlBrush);

                    } while (bMore);
                    goto All_Done;
                }
            }
        }
    }

    jClip = (pco == NULL) ? DC_TRIVIAL : pco->iDComplexity;

    if ((psoSrc != NULL) && (psoSrc->dhsurf != NULL))
    {
        pdsurfSrc = (DSURF*) psoSrc->dhsurf;
        if (pdsurfSrc->dt == DT_DIB)
        {
            // Here we consider putting a DIB DFB back into off-screen
            // memory.  If there's a translate, it's probably not worth
            // moving since we won't be able to use the hardware to do
            // the blt (a similar argument could be made for weird rops
            // and stuff that we'll only end up having GDI simulate, but
            // those should happen infrequently enough that I don't care).

            if ((pxlo == NULL) || (pxlo->flXlate & XO_TRIVIAL))
            {
                ppdev = (PDEV*) psoSrc->dhpdev;

                // See 'DrvCopyBits' for some more comments on how this
                // moving-it-back-into-off-screen-memory thing works:

                if (pdsurfSrc->iUniq == ppdev->iHeapUniq)
                {
                    if (--pdsurfSrc->cBlt == 0)
                    {
                        if (bMoveDibToOffscreenDfbIfRoom(ppdev, pdsurfSrc))
                            goto Continue_It;
                    }
                }
                else
                {
                    // Some space was freed up in off-screen memory,
                    // so reset the counter for this DFB:

                    pdsurfSrc->iUniq = ppdev->iHeapUniq;
                    pdsurfSrc->cBlt  = HEAP_COUNT_DOWN;
                }
            }

            psoSrc = pdsurfSrc->pso;

            // Handle the case where the source is a DIB DFB and the
            // destination is a regular bitmap:

            if (psoDst->dhsurf == NULL)
                goto EngBitBlt_It;

        }
    }

Continue_It:

    if (pdsurfDst != NULL)
    {
        if (pdsurfDst->dt == DT_DIB)
        {
            psoDst = pdsurfDst->pso;

            // If the destination is a DIB, we can only handle this
            // call if the source is not a DIB:

            if ((psoSrc == NULL) || (psoSrc->dhsurf == NULL))
                goto EngBitBlt_It;
        }
    }

    // At this point, we know that either the source or the destination is
    // not a DIB.  Check for a DFB to screen, DFB to DFB, or screen to DFB
    // case:

    if ((psoSrc != NULL) &&
        (psoDst->dhsurf != NULL) &&
        (psoSrc->dhsurf != NULL))
    {
        pdsurfSrc = (DSURF*) psoSrc->dhsurf;
        pdsurfDst = (DSURF*) psoDst->dhsurf;

        ASSERTDD(pdsurfSrc->dt == DT_SCREEN, "Expected screen source");
        ASSERTDD(pdsurfDst->dt == DT_SCREEN, "Expected screen destination");

        ptlSrc.x = pptlSrc->x - (pdsurfDst->poh->x - pdsurfSrc->poh->x);
        ptlSrc.y = pptlSrc->y - (pdsurfDst->poh->y - pdsurfSrc->poh->y);

        pptlSrc  = &ptlSrc;
    }

    if (psoDst->dhsurf != NULL)
    {
        pdsurfDst = (DSURF*) psoDst->dhsurf;
        ppdev     = (PDEV*)  psoDst->dhpdev;

        ppdev->xOffset  = pdsurfDst->poh->x;
        ppdev->yOffset  = pdsurfDst->poh->y;
        ppdev->xyOffset = pdsurfDst->poh->xy;
    }
    else
    {
        pdsurfSrc = (DSURF*) psoSrc->dhsurf;
        ppdev     = (PDEV*)  psoSrc->dhpdev;

        ppdev->xOffset  = pdsurfSrc->poh->x;
        ppdev->yOffset  = pdsurfSrc->poh->y;
        ppdev->xyOffset = pdsurfSrc->poh->xy;
    }

    if (((rop4 >> 8) & 0xff) == (rop4 & 0xff))
    {
        // Since we've already handled the cases where the ROP4 is really
        // a ROP3 and no source is required, we can assert...

        ASSERTDD((psoSrc != NULL) && (pptlSrc != NULL),
                 "Expected no-source case to already have been handled");

        ///////////////////////////////////////////////////////////////////
        // Bitmap transfers
        ///////////////////////////////////////////////////////////////////

        // Since the foreground and background ROPs are the same, we
        // don't have to worry about no stinking masks (it's a simple
        // Rop3).

        rop3 = (BYTE) rop4;     // Make it into a Rop3 (we keep the rop4
                                //  around in case we decide to punt)

        if (psoDst->dhsurf != NULL)
        {
            // The destination is the screen:

            if ((rop3 >> 4) == (rop3 & 0xf))
            {
                // The ROP3 doesn't require a pattern:

                if (psoSrc->dhsurf == NULL)
                {
                    //////////////////////////////////////////////////
                    // DIB-to-screen blt

                    if (HOST_XFERS_DISABLED(ppdev))
                    {
                        goto Punt_It;
                    }

                    iSrcBitmapFormat = psoSrc->iBitmapFormat;
                    if (iSrcBitmapFormat == BMF_1BPP)
                    {
                        if (rop3 == 0xcc)
                        {
                            //
                            // 542x and 5446 family chips will hang when doing
                            // monochrome expansion. We have seen this problem
                            // extremely infrequently in stress testing. Often
                            // on 32x16 blts with the 2x chips. We were unable
                            // to programmatically reproduce it with the exact
                            // machine that was causing the problem. We even
                            // wrote some testing program to excessively test
                            // this function while running stress. The test
                            // run several weeks and we couldn't repro it.
                            // 
                            // So, for the sake of boosting stress success rate,
                            // we just ask GDI do the work for us 
                            //
                            if ( ( ppdev->flCaps & CAPS_IS_542x )   // 542x
                               ||( ppdev->ulChipID == 0xB8) )       // 5446
                            {
                                //
                                // For chips like 542x, 5446, it will cause
                                // hang from time to time when doing stress
                                // testing. So we have to let GDI to do it
                                //
                                goto Punt_It;
                            }
                            else
                            {
                                // [HWBUG]

                                // This driver can't handle a monochrome
                                // expansion with a foreground rop other
                                // than SRCCOPY.  The reason is that we
                                // separately blt the opaque part first and
                                // then blt the foreground over it.  The
                                // destination bits are no longer valid to
                                // be used in a rop requiring them.

                                pfnXfer = ppdev->pfnXfer1bpp;
                                goto Xfer_It;
                            }// if 542x or 5446 chips
                        }
                    }
                    else if ((iSrcBitmapFormat == ppdev->iBitmapFormat) &&
                             ((pxlo == NULL) || (pxlo->flXlate & XO_TRIVIAL)))
                    {
                        if ((rop3 & 0xf) != 0xc)
                        {
                            pfnXfer = ppdev->pfnXferNative;
                        }
                        else
                        {
                            // Plain SRCCOPY blts will be somewhat faster
                            // if we go through the memory aperture:

                            pfnXfer = vXferNativeSrccopy;
                        }
                        goto Xfer_It;
                    }
                    else if ((iSrcBitmapFormat == BMF_4BPP) &&
                             (ppdev->iBitmapFormat == BMF_8BPP))
                    {
                        pfnXfer = ppdev->pfnXfer4bpp;
                        goto Xfer_It;
                    }
                }
                else // psoSrc->dhsurf != NULL
                {
                    if ((pxlo == NULL) || (pxlo->flXlate & XO_TRIVIAL))
                    {
                        //////////////////////////////////////////////////
                        // Screen-to-screen blt with no translate

                        if (jClip == DC_TRIVIAL)
                        {
                            (ppdev->pfnCopyBlt)(ppdev, 1, prclDst, rop4,
                                                pptlSrc, prclDst);
                            goto All_Done;
                        }
                        else if (jClip == DC_RECT)
                        {
                            if (bIntersect(prclDst, &pco->rclBounds, &rcl))
                            {
                                (ppdev->pfnCopyBlt)(ppdev, 1, &rcl, rop4,
                                                    pptlSrc, prclDst);
                            }
                            goto All_Done;
                        }
                        else
                        {
                            // Don't forget that we'll have to draw the
                            // rectangles in the correct direction:

                            if (pptlSrc->y >= prclDst->top)
                            {
                                if (pptlSrc->x >= prclDst->left)
                                    iDir = CD_RIGHTDOWN;
                                else
                                    iDir = CD_LEFTDOWN;
                            }
                            else
                            {
                                if (pptlSrc->x >= prclDst->left)
                                    iDir = CD_RIGHTUP;
                                else
                                    iDir = CD_LEFTUP;
                            }

                            CLIPOBJ_cEnumStart(pco, FALSE, CT_RECTANGLES,
                                               iDir, 0);

                            do {
                                bMore = CLIPOBJ_bEnum(pco, sizeof(ce),
                                                      (ULONG*) &ce);

                                c = cIntersect(prclDst, ce.arcl, ce.c);

                                if (c != 0)
                                {
                                    (ppdev->pfnCopyBlt)(ppdev, c, ce.arcl,
                                            rop4, pptlSrc, prclDst);
                                }

                            } while (bMore);
                            goto All_Done;
                        }
                    }
                }
            }
            else if (psoSrc->iBitmapFormat == BMF_1BPP)
            {
                if (HOST_XFERS_DISABLED(ppdev))
                {
                    goto Punt_It;
                }

                if ((rop4 == 0xE2E2) &&
                    (pbo->iSolidColor != 0xffffffff) &&
                    //pxlo must be non NULL since the rop is E2E2
                    (pxlo->pulXlate[0] == 0) &&
                    (pxlo->pulXlate[1] == (ULONG)((1<<PELS_TO_BYTES(8)) - 1)))
                {
                    if ( (ppdev->flCaps & CAPS_IS_542x)
                       ||(ppdev->ulChipID == 0xB8) )
                    {
                        //
                        // For chips like 542x, 5446, it will cause
                        // hang from time to time when doing stress
                        // testing. We have seen this problem
                        // extremely infrequently in stress testing. Often
                        // on 32x16 blts with the 2x chips. We were unable
                        // to programmatically reproduce it with the exact
                        // machine that was causing the problem. We even
                        // wrote some testing program to excessively test
                        // this function while running stress. The test
                        // run several weeks and we couldn't repro it.
                        //
                        // So, for the sake of boosting stress success rate,
                        // we just ask GDI do the work for us 
                        //
                        goto Punt_It;
                    }
                    else
                    {
                        //
                        // A BitBlt with the rop E2E2 (DSPDxax), a monochrome
                        // source, a foreground color of white, and a background
                        //color of black is equivalent to a monochrome expansion
                        // with transparency.  All ones in the source expand to
                        //the brush color, and all zeros in the source expand to
                        // the destination color.
                        //

                        xlo.pulXlate   = (ULONG*) &xlc;
                        xlc.iForeColor = pbo->iSolidColor;
                        xlc.iBackColor = 0;
                        pxlo = &xlo;
                        rop4 = 0xCCAA;

                        pfnXfer = ppdev->pfnXfer1bpp;
                        goto Xfer_It;
                    }// if 542x or 5446 chips
                }
            }
        }
        else
        {
            #if defined(_X86_)
            {
                // We special case screen to monochrome blts because they
                // happen fairly often.  We only handle SRCCOPY rops and
                // monochrome destinations (to handle a true 1bpp DIB
                // destination, we would have to do near-colour searches
                // on every colour; as it is, the foreground colour gets
                // mapped to '1', and everything else gets mapped to '0'):

                if ((psoDst->iBitmapFormat == BMF_1BPP) &&
                    (rop3 == 0xcc) &&
                    (pxlo->flXlate & XO_TO_MONO) &&
                    (ppdev->iBitmapFormat != BMF_24BPP))
                {
                    pfnXfer = vXferScreenTo1bpp;
                    psoSrc  = psoDst;               // A misnomer, I admit
                    goto Xfer_It;
                }
            }
            #endif // i386
        }
    }

#if 0
    // [WORK] - Implement transparent brushes and then uncomment this block
    //          and the Fill_It label above.

    else if ((psoMsk == NULL) &&
             (rop4 & 0xff00) == (0xaa00) &&
             ((((rop4 >> 2) ^ (rop4)) & 0x33) == 0))
    {
        // The only time GDI will ask us to do a true rop4 using the brush
        // mask is when the brush is 1bpp, and the background rop is AA
        // (meaning it's a NOP):

        rop3 = (BYTE) rop4;

        goto Fill_It;
    }
#endif

    // Just fall through to Punt_It...

Punt_It:

    bRet = bPuntBlt(psoDst,
                    psoSrc,
                    psoMsk,
                    pco,
                    pxlo,
                    prclDst,
                    pptlSrc,
                    pptlMsk,
                    pbo,
                    pptlBrush,
                    rop4);
    goto All_Done;

//////////////////////////////////////////////////////////////////////
// Common bitmap transfer

Xfer_It:
    if (jClip == DC_TRIVIAL)
    {
        pfnXfer(ppdev, 1, prclDst, rop4, psoSrc, pptlSrc, prclDst, pxlo);
        goto All_Done;
    }
    else if (jClip == DC_RECT)
    {
        if (bIntersect(prclDst, &pco->rclBounds, &rcl))
            pfnXfer(ppdev, 1, &rcl, rop4, psoSrc, pptlSrc, prclDst, pxlo);
        goto All_Done;
    }
    else
    {
        CLIPOBJ_cEnumStart(pco, FALSE, CT_RECTANGLES,
                           CD_ANY, 0);

        do {
            bMore = CLIPOBJ_bEnum(pco, sizeof(ce),
                                  (ULONG*) &ce);

            c = cIntersect(prclDst, ce.arcl, ce.c);

            if (c != 0)
            {
                pfnXfer(ppdev, c, ce.arcl, rop4, psoSrc,
                        pptlSrc, prclDst, pxlo);
            }

        } while (bMore);
        goto All_Done;
    }

////////////////////////////////////////////////////////////////////////
// Common DIB blt

EngBitBlt_It:

    // Our driver doesn't handle any blt's between two DIBs.  Normally
    // a driver doesn't have to worry about this, but we do because
    // we have DFBs that may get moved from off-screen memory to a DIB,
    // where we have GDI do all the drawing.  GDI does DIB drawing at
    // a reasonable speed (unless one of the surfaces is a device-
    // managed surface...)
    //
    // If either the source or destination surface in an EngBitBlt
    // call-back is a device-managed surface (meaning it's not a DIB
    // that GDI can draw with), GDI will automatically allocate memory
    // and call the driver's DrvCopyBits routine to create a DIB copy
    // that it can use.  So this means that this could handle all 'punts',
    // and we could conceivably get rid of bPuntBlt.  But this would have
    // a bad performance impact because of the extra memory allocations
    // and bitmap copies -- you really don't want to do this unless you
    // have to (or your surface was created such that GDI can draw
    // directly onto it) -- I've been burned by this because it's not
    // obvious that the performance impact is so bad.
    //
    // That being said, we only call EngBitBlt when all the surfaces
    // are DIBs:

    bRet = EngBitBlt(psoDst, psoSrc, psoMsk, pco, pxlo, prclDst,
                     pptlSrc, pptlMsk, pbo, pptlBrush, rop4);

All_Done:
    return(bRet);
}

/******************************Public*Routine******************************\
* BOOL DrvCopyBits
*
* Do fast bitmap copies.
*
* Note that GDI will (usually) automatically adjust the blt extents to
* adjust for any rectangular clipping, so we'll rarely see DC_RECT
* clipping in this routine (and as such, we don't bother special casing
* it).
*
* I'm not sure if the performance benefit from this routine is actually
* worth the increase in code size, since SRCCOPY BitBlts are hardly the
* most common drawing operation we'll get.  But what the heck.
*
* It's faster to do straight SRCCOPY bitblt's through the memory
* aperture than to use the data transfer register; as such, this
* routine is the logical place to put this special case.
*
\**************************************************************************/

BOOL DrvCopyBits(
SURFOBJ*  psoDst,
SURFOBJ*  psoSrc,
CLIPOBJ*  pco,
XLATEOBJ* pxlo,
RECTL*    prclDst,
POINTL*   pptlSrc)
{
    PDEV*   ppdev;
    DSURF*  pdsurfSrc;
    DSURF*  pdsurfDst;
    RECTL   rcl;
    POINTL  ptl;
    OH*     pohSrc;
    OH*     pohDst;

    // DrvCopyBits is a fast-path for SRCCOPY blts.  But it can still be
    // pretty complicated: there can be translates, clipping, RLEs,
    // bitmaps that aren't the same format as the screen, plus
    // screen-to-screen, DIB-to-screen or screen-to-DIB operations,
    // not to mention DFBs (device format bitmaps).
    //
    // Rather than making this routine almost as big as DrvBitBlt, I'll
    // handle here only the speed-critical cases, and punt the rest to
    // our DrvBitBlt routine.
    //
    // We'll try to handle anything that doesn't involve clipping:

    if (((pco  == NULL) || (pco->iDComplexity == DC_TRIVIAL)) &&
        ((pxlo == NULL) || (pxlo->flXlate & XO_TRIVIAL)))
    {
        if (psoDst->dhsurf != NULL)
        {
            // We know the destination is either a DFB or the screen:

            ppdev     = (PDEV*)  psoDst->dhpdev;
            pdsurfDst = (DSURF*) psoDst->dhsurf;

            // See if the source is a plain DIB:

            if (psoSrc->dhsurf != NULL)
            {
                pdsurfSrc = (DSURF*) psoSrc->dhsurf;

                // Make sure the destination is really the screen or an
                // off-screen DFB (i.e., not a DFB that we've converted
                // to a DIB):

                if (pdsurfDst->dt == DT_SCREEN)
                {
                    ASSERTDD(psoSrc->dhsurf != NULL, "Can't be a DIB");

                    if (pdsurfSrc->dt == DT_SCREEN)
                    {

                    Screen_To_Screen:

                        //////////////////////////////////////////////////////
                        // Screen-to-screen

                        ASSERTDD((psoSrc->dhsurf != NULL) &&
                                 (pdsurfSrc->dt == DT_SCREEN)    &&
                                 (psoDst->dhsurf != NULL) &&
                                 (pdsurfDst->dt == DT_SCREEN),
                                 "Should be a screen-to-screen case");

                        // pfnCopyBlt takes relative coordinates (relative
                        // to the destination surface, that is), so we have
                        // to change the start point to be relative to the
                        // destination surface too:


                        pohSrc = pdsurfSrc->poh;
                        pohDst = pdsurfDst->poh;

                        ptl.x = pptlSrc->x - (pohDst->x - pohSrc->x);
                        ptl.y = pptlSrc->y - (pohDst->y - pohSrc->y);

                        ppdev->xOffset  = pohDst->x;
                        ppdev->yOffset  = pohDst->y;
                        ppdev->xyOffset = pohDst->xy;

                        (ppdev->pfnCopyBlt)(ppdev, 1, prclDst, 0xcccc, &ptl,
                            prclDst);

                        return(TRUE);
                    }
                    else // (pdsurfSrc->dt != DT_SCREEN)
                    {
                        // Ah ha, the source is a DFB that's really a DIB.

                        ASSERTDD(psoDst->dhsurf != NULL,
                                "Destination can't be a DIB here");

                        /////////////////////////////////////////////////////
                        // Put It Back Into Off-screen?
                        //
                        // We take this opportunity to decide if we want to
                        // put the DIB back into off-screen memory.  This is
                        // a pretty good place to do it because we have to
                        // copy the bits to some portion of the screen,
                        // anyway.  So we would incur only an extra screen-to-
                        // screen blt at this time, much of which will be
                        // over-lapped with the CPU.
                        //
                        // The simple approach we have taken is to move a DIB
                        // back into off-screen memory only if there's already
                        // room -- we won't throw stuff out to make space
                        // (because it's tough to know what ones to throw out,
                        // and it's easy to get into thrashing scenarios).
                        //
                        // Because it takes some time to see if there's room
                        // in off-screen memory, we only check one in
                        // HEAP_COUNT_DOWN times if there's room.  To bias
                        // in favour of bitmaps that are often blt, the
                        // counters are reset every time any space is freed
                        // up in off-screen memory.  We also don't bother
                        // checking if no space has been freed since the
                        // last time we checked for this DIB.

                        if (pdsurfSrc->iUniq == ppdev->iHeapUniq)
                        {
                            if (--pdsurfSrc->cBlt == 0)
                            {
                                if (bMoveDibToOffscreenDfbIfRoom(ppdev,
                                                                 pdsurfSrc))
                                    goto Screen_To_Screen;
                            }
                        }
                        else
                        {
                            // Some space was freed up in off-screen memory,
                            // so reset the counter for this DFB:

                            pdsurfSrc->iUniq = ppdev->iHeapUniq;
                            pdsurfSrc->cBlt  = HEAP_COUNT_DOWN;
                        }

                        // Since the destination is definitely the screen,
                        // we don't have to worry about creating a DIB to
                        // DIB copy case (for which we would have to call
                        // EngCopyBits):

                        psoSrc = pdsurfSrc->pso;

                        goto DIB_To_Screen;
                    }
                }
                else // (pdsurfDst->dt != DT_SCREEN)
                {
                    // Because the source is not a DIB, we don't have to
                    // worry about creating a DIB to DIB case here (although
                    // we'll have to check later to see if the source is
                    // really a DIB that's masquerading as a DFB...)

                    ASSERTDD(psoSrc->dhsurf != NULL,
                             "Source can't be a DIB here");

                    psoDst = pdsurfDst->pso;

                    goto Screen_To_DIB;
                }
            }
            else if (psoSrc->iBitmapFormat == ppdev->iBitmapFormat)
            {
                // Make sure the destination is really the screen:

                if (pdsurfDst->dt == DT_SCREEN)
                {

                DIB_To_Screen:

                    //////////////////////////////////////////////////////
                    // DIB-to-screen

                    ASSERTDD((psoDst->dhsurf != NULL) &&
                             (pdsurfDst->dt == DT_SCREEN)    &&
                             (psoSrc->dhsurf == NULL) &&
                             (psoSrc->iBitmapFormat == ppdev->iBitmapFormat),
                             "Should be a DIB-to-screen case");

                    // ppdev->pfnPutBits takes absolute screen coordinates, so
                    // we have to muck with the destination rectangle:

                    pohDst = pdsurfDst->poh;

                    rcl.left   = prclDst->left   + pohDst->x;
                    rcl.right  = prclDst->right  + pohDst->x;
                    rcl.top    = prclDst->top    + pohDst->y;
                    rcl.bottom = prclDst->bottom + pohDst->y;

                    // We use the memory aperture to do the transfer,
                    // because that is supposed to be faster for SRCCOPY
                    // blts than using the data-transfer register:

                    ppdev->pfnPutBits(ppdev, psoSrc, &rcl, pptlSrc);
                    return(TRUE);
                }
            }
        }
        else // (psoDst->dhsurf == NULL)
        {

        Screen_To_DIB:

            pdsurfSrc = (DSURF*) psoSrc->dhsurf;
            ppdev     = (PDEV*)  psoSrc->dhpdev;

            if (psoDst->iBitmapFormat == ppdev->iBitmapFormat)
            {
                if (pdsurfSrc->dt == DT_SCREEN)
                {
                    //////////////////////////////////////////////////////
                    // Screen-to-DIB

                    ASSERTDD((psoSrc->dhsurf != NULL) &&
                             (pdsurfSrc->dt == DT_SCREEN)    &&
                             (psoDst->dhsurf == NULL) &&
                             (psoDst->iBitmapFormat == ppdev->iBitmapFormat),
                             "Should be a screen-to-DIB case");

                    // ppdev->pfnGetBits takes absolute screen coordinates, so we have
                    // to muck with the source point:

                    pohSrc = pdsurfSrc->poh;

                    ptl.x = pptlSrc->x + pohSrc->x;
                    ptl.y = pptlSrc->y + pohSrc->y;

                    ppdev->pfnGetBits(ppdev, psoDst, prclDst, &ptl);
                    return(TRUE);
                }
                else
                {
                    // The source is a DFB that's really a DIB.  Since we
                    // know that the destination is a DIB, we've got a DIB
                    // to DIB operation, and should call EngCopyBits:

                    psoSrc = pdsurfSrc->pso;
                    goto EngCopyBits_It;
                }
            }
        }
    }

    // We can't call DrvBitBlt if we've accidentally converted both
    // surfaces to DIBs, because it isn't equipped to handle it:

    ASSERTDD((psoSrc->dhsurf != NULL) ||
             (psoDst->dhsurf != NULL),
             "Accidentally converted both surfaces to DIBs");

    /////////////////////////////////////////////////////////////////
    // A DrvCopyBits is after all just a simplified DrvBitBlt:

    return(DrvBitBlt(psoDst, psoSrc, NULL, pco, pxlo, prclDst, pptlSrc, NULL,
                     NULL, NULL, 0x0000CCCC));

EngCopyBits_It:

    ASSERTDD((psoDst->dhsurf == NULL) &&
             (psoSrc->dhsurf == NULL),
             "Both surfaces should be DIBs to call EngCopyBits");

    return(EngCopyBits(psoDst, psoSrc, pco, pxlo, prclDst, pptlSrc));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\cirrus\disp\bltmm.c ===
/******************************************************************************\
*
* $Workfile:   bltmm.c  $
*
* Contains the low-level MM blt functions.
*
* Hopefully, if you're basing your display driver on this code, to support all
* of DrvBitBlt and DrvCopyBits, you'll only have to implement the following
* routines. You shouldn't have to modify much in 'bitblt.c'. I've tried to make
* these routines as few, modular, simple, and efficient as I could, while still
* accelerating as many calls as possible that would be cost-effective in terms
* of performance wins versus size and effort.
*
* Note: In the following, 'relative' coordinates refers to coordinates that
*        haven't yet had the offscreen bitmap (DFB) offset applied. 'Absolute'
*        coordinates have had the offset applied. For example, we may be told to
*        blt to (1, 1) of the bitmap, but the bitmap may be sitting in offscreen
*        memory starting at coordinate (0, 768) -- (1, 1) would be the
*        'relative' start coordinate, and (1, 769) would be the 'absolute' start
*        coordinate'.
*
* Copyright (c) 1992-1995 Microsoft Corporation
* Copyright (c) 1996 Cirrus Logic, Inc.
*
* $Log:   S:/projects/drivers/ntsrc/display/bltmm.c_v  $
 * 
 *    Rev 1.4   Jan 14 1997 15:16:14   unknown
 * take out GR33 clearing after 80 blt.
 * 
 *    Rev 1.2   Nov 07 1996 16:47:52   unknown
 *  
 * 
 *    Rev 1.1   Oct 10 1996 15:36:14   unknown
 *  
* 
*    Rev 1.4   12 Aug 1996 16:58:56   frido
* Removed unaccessed local variables.
* Renamed vMmPatternBlt into vMmFillPat36.
* 
*    Rev 1.3   08 Aug 1996 16:55:10   frido
* Added new vMmCopyBlt36 routine.
* 
*    Rev 1.2   08 Aug 1996 12:59:28   frido
* bank#1 - Removed banking code since MMIO is always linear.
*
*    Rev 1.1   31 Jul 1996 15:43:14   frido
* Added new pattern blit.
*
* jl01  10-08-96  Do Transparent BLT w/o Solid Fill.  Refer to PDRs#5511/6817.
* chu01 01-09-97  Make sure to reset GR33.
*
\******************************************************************************/

#include "precomp.h"


/**************************************************************************
* VOID vMmFastPatRealize
*
* Realizes a pattern into offscreen memory.
*
**************************************************************************/

VOID vMmFastPatRealize(
PDEV*   ppdev,
RBRUSH* prb)                    // Points to brush realization structure
{
    BRUSHENTRY* pbe;
    LONG        iBrushCache;
    BYTE*       pjPattern;
    LONG        cjPattern;
    BYTE*       pjBase = ppdev->pjBase;
    LONG        lDelta = ppdev->lDelta;
    LONG        lDeltaPat;
    LONG        lDeltaSrc;
    LONG        xCnt;
    LONG        yCnt;
    ULONG       ulDst;

    DISPDBG((10,"vFastPatRealize called"));

    pbe = prb->pbe;

    if ((pbe == NULL) || (pbe->prbVerify != prb))
    {
        // We have to allocate a new offscreen cache brush entry for
        // the brush:

        iBrushCache = ppdev->iBrushCache;
        pbe         = &ppdev->abe[iBrushCache];

        iBrushCache++;
        if (iBrushCache >= ppdev->cBrushCache)
            iBrushCache = 0;

        ppdev->iBrushCache = iBrushCache;

        // Update our links:

        pbe->prbVerify = prb;
        prb->pbe       = pbe;
    }

    //
    // Download brush into cache
    //

    pjPattern = (PBYTE) &prb->aulPattern[0];        // Copy from brush buffer
    cjPattern = PELS_TO_BYTES(TOTAL_BRUSH_SIZE);

    lDeltaPat = PELS_TO_BYTES(8);
    xCnt = PELS_TO_BYTES(8);
    yCnt = 8;

    if (ppdev->cBitsPerPixel == 24)
    {
        lDeltaSrc = 32;  // same as PELS_TO_BYTES(8) for 32bpp
    }
    else
    {
        lDeltaSrc = lDeltaPat;  // PELS_TO_BYTES(8)
    }

    ulDst = (pbe->y * ppdev->lDelta) + PELS_TO_BYTES(pbe->x);

#if BANKING //bank#1
    ppdev->pfnBankMap(ppdev, ppdev->lXferBank);
#endif

    CP_MM_WAIT_FOR_BLT_COMPLETE(ppdev, pjBase);

    CP_MM_DST_Y_OFFSET(ppdev, pjBase, (lDeltaSrc * 2));
    CP_MM_XCNT(ppdev, pjBase, (xCnt - 1));
    CP_MM_YCNT(ppdev, pjBase, (yCnt - 1));
#if 1 // D5480
    CP_MM_BLT_MODE_PACKED(ppdev, pjBase, CL_PACKED_SRC_COPY | SRC_CPU_DATA);
#else
    CP_MM_BLT_MODE(ppdev, pjBase, SRC_CPU_DATA);
    CP_MM_BLT_EXT_MODE(ppdev, pjBase, 0);
    CP_MM_ROP(ppdev, pjBase, CL_SRC_COPY);
#endif // D5480
    CP_MM_DST_ADDR_ABS(ppdev, pjBase, ulDst);

    CP_MM_START_BLT(ppdev, pjBase);

    vImageTransfer(ppdev, pjPattern, lDeltaPat, xCnt, yCnt);

    //
    // Duplicate brush horizontally
    //

    CP_MM_WAIT_FOR_BLT_COMPLETE(ppdev, pjBase);

    CP_MM_XCNT(ppdev, pjBase, (xCnt - 1));
    CP_MM_YCNT(ppdev, pjBase, (yCnt - 1));
    CP_MM_BLT_MODE(ppdev, pjBase, 0);
    CP_MM_SRC_Y_OFFSET(ppdev, pjBase, (lDeltaSrc * 2));
    CP_MM_SRC_ADDR(ppdev, pjBase, ulDst);
    CP_MM_DST_ADDR_ABS(ppdev, pjBase, (ulDst + lDeltaPat));

    CP_MM_START_BLT(ppdev, pjBase);

    //
    // Duplicate brush vertically
    //

    CP_MM_WAIT_FOR_BLT_COMPLETE(ppdev, pjBase);

    CP_MM_SRC_Y_OFFSET(ppdev, pjBase, (lDeltaSrc * 2));
    CP_MM_DST_Y_OFFSET(ppdev, pjBase, (lDeltaSrc * 2));
    CP_MM_BLT_MODE(ppdev, pjBase, 0);
    CP_MM_XCNT(ppdev, pjBase, ((lDeltaSrc * 2) - 1));
    CP_MM_YCNT(ppdev, pjBase, (yCnt - 1));
    CP_MM_SRC_ADDR(ppdev, pjBase, ulDst);

    if (ppdev->cBitsPerPixel == 24)
    {
        CP_MM_DST_ADDR_ABS(ppdev, pjBase, (ulDst + 512)); // 128 * 4
    }
    else
    {
        CP_MM_DST_ADDR_ABS(ppdev, pjBase, (ulDst + PELS_TO_BYTES(128)));
    }

    CP_MM_START_BLT(ppdev, pjBase);

    #if 0
    {
        ////////////////////////////////////////////////////////////////
        // DEBUG TILED PATTERNS
        //
        // The following code helps to debug patterns if you break the
        // realization code.  It copies the 2x2 tiled copy of the brush
        // to the visible screen.
        //

        POINTL ptl;
        RECTL rcl;

        ptl.x = pbe->x;
        ptl.y = pbe->y;

        rcl.left = 10;
        rcl.right = 10 + 16;
        rcl.top = ppdev->cyScreen - 10 - 16;
        rcl.bottom = ppdev->cyScreen - 10;

        {
            LONG        lDelta = ppdev->lDelta;
            BYTE        jHwRop;
            BYTE        jMode;

            //
            // Make sure we can write to the video registers.
            //

            CP_MM_WAIT_FOR_BLT_COMPLETE(ppdev, pjBase);

            CP_MM_ROP(ppdev, pjBase, CL_SRC_COPY);
            CP_MM_SRC_Y_OFFSET(ppdev, pjBase, PELS_TO_BYTES(16));
            CP_MM_DST_Y_OFFSET(ppdev, pjBase, lDelta);

            {
                //
                // Top to Bottom - Left to Right
                //

                jMode |= DIR_TBLR;
                CP_MM_BLT_MODE(ppdev, pjBase, ppdev->jModeColor);

                {

                    CP_MM_WAIT_FOR_BLT_COMPLETE(ppdev, pjBase);

                    CP_MM_XCNT(ppdev, pjBase, (PELS_TO_BYTES(rcl.right - rcl.left) - 1));
                    CP_MM_YCNT(ppdev, pjBase, (rcl.bottom - rcl.top - 1));

                    CP_MM_SRC_ADDR(ppdev, pjBase, (0 + ((ptl.y) * lDelta) + PELS_TO_BYTES(ptl.x)));
                    CP_MM_DST_ADDR_ABS(ppdev, pjBase, ((rcl.top * lDelta) + PELS_TO_BYTES(rcl.left)));
                    CP_MM_START_BLT(ppdev, pjBase);
                }
            }
        }
    }
    #endif
}

/**************************************************************************
* VOID vMmFillPat
*
* This routine uses the pattern hardware to draw a patterned list of
* rectangles.
*
**************************************************************************/

VOID vMmFillPat(
PDEV*           ppdev,
LONG            c,          // Can't be zero
RECTL*          prcl,       // Array of relative coordinate destination rects
ROP4            rop4,       // Obvious?
RBRUSH_COLOR    rbc,        // Drawing color is rbc.iSolidColor
POINTL*         pptlBrush)  //
{
    BYTE*       pjBase = ppdev->pjBase;
    LONG        lDelta = ppdev->lDelta;
    ULONG       ulAlignedPatternOffset = ppdev->ulAlignedPatternOffset;
    ULONG       ulPatternAddrBase;
    BYTE        jHwRop;
    BYTE        jMode;
    BRUSHENTRY* pbe;        // Pointer to brush entry data, which is used
                            //   for keeping track of the location and status
                            //   of the pattern bits cached in off-screen
                            //   memory

    DISPDBG((10,"vFillPat called"));

    ASSERTDD(c > 0, "Can't handle zero rectangles");
    ASSERTDD(ppdev->cBpp < 4, "vFillPat only works at 8bpp, 16bpp, and 24bpp");

    if ((rbc.prb->pbe == NULL) ||
        (rbc.prb->pbe->prbVerify != rbc.prb))
    {
        vMmFastPatRealize(ppdev, rbc.prb);
        DISPDBG((5, " -- Brush cache miss, put it at (%d,%d)", rbc.prb->pbe->x, rbc.prb->pbe->y));
    }
    else
    {
        DISPDBG((5, " -- Brush cache hit on brush at (%d,%d)", rbc.prb->pbe->x, rbc.prb->pbe->y));
    }

    pbe = rbc.prb->pbe;

    //
    // Fill the list of rectangles
    //

    ulPatternAddrBase = pbe->xy;
    jHwRop = gajHwMixFromRop2[(rop4 >> 2) & 0xf];
    jMode = ppdev->jModeColor | ENABLE_8x8_PATTERN_COPY;

    do {
        ULONG offset = 0;
        ULONG XOffset, YOffset;

        YOffset = ((prcl->top - pptlBrush->y) & 7) << 4;
        XOffset = (prcl->left - pptlBrush->x) & 7;

        // align the pattern to a new location

        CP_MM_WAIT_FOR_BLT_COMPLETE(ppdev, pjBase);
#if 1 // D5480
        CP_MM_BLT_MODE_PACKED(ppdev, pjBase, CL_PACKED_SRC_COPY);
#else
        CP_MM_BLT_MODE(ppdev, pjBase, 0);
        CP_MM_ROP(ppdev, pjBase, CL_SRC_COPY);
#endif // D5480
        if (ppdev->cBitsPerPixel == 24)
        {
            offset = (YOffset * 4) + (XOffset * 3);

            CP_MM_SRC_Y_OFFSET(ppdev, pjBase, 64);
            CP_MM_DST_Y_OFFSET(ppdev, pjBase, 32);
        }
        else
        {
            offset = PELS_TO_BYTES(YOffset + XOffset);

            CP_MM_SRC_Y_OFFSET(ppdev, pjBase, PELS_TO_BYTES(16));
            CP_MM_DST_Y_OFFSET(ppdev, pjBase, PELS_TO_BYTES(8));
        }

        CP_MM_SRC_ADDR(ppdev, pjBase, (ulPatternAddrBase + offset));
        CP_MM_XCNT(ppdev, pjBase, (PELS_TO_BYTES(8) - 1));
        CP_MM_YCNT(ppdev, pjBase, (8 - 1));
        CP_MM_DST_ADDR_ABS(ppdev, pjBase, ulAlignedPatternOffset);
        CP_MM_START_BLT(ppdev, pjBase);

        // fill using aligned pattern

        CP_MM_WAIT_FOR_BLT_COMPLETE(ppdev, pjBase);

        CP_MM_BLT_MODE(ppdev, pjBase, jMode);
        CP_MM_ROP(ppdev, pjBase, jHwRop);
        CP_MM_DST_Y_OFFSET(ppdev, pjBase, lDelta);
        CP_MM_SRC_ADDR(ppdev, pjBase, ulAlignedPatternOffset);
        CP_MM_XCNT(ppdev, pjBase, (PELS_TO_BYTES(prcl->right - prcl->left) - 1));
        CP_MM_YCNT(ppdev, pjBase, (prcl->bottom - prcl->top - 1));
        CP_MM_DST_ADDR(ppdev, pjBase, ((prcl->top * lDelta) + PELS_TO_BYTES(prcl->left)));
        CP_MM_START_BLT(ppdev, pjBase);

        prcl++;

    } while (--c != 0);
}


/**************************************************************************
* VOID vMmFillSolid
*
* Does a solid fill to a list of rectangles.
*
**************************************************************************/

VOID vMmFillSolid(
PDEV*           ppdev,
LONG            c,          // Can't be zero
RECTL*          prcl,       // Array of relative coordinate destination rects
ROP4            rop4,       // Obvious?
RBRUSH_COLOR    rbc,        // Drawing color is rbc.iSolidColor
POINTL*         pptlBrush)  // Not used
{
    BYTE*       pjBase = ppdev->pjBase;
    LONG        lDelta = ppdev->lDelta;
    LONG        cBpp = ppdev->cBpp;
    ULONG       ulSolidColor;
    BYTE        jHwRop;

    DISPDBG((10,"vFillSolid called"));

    ASSERTDD(c > 0, "Can't handle zero rectangles");

    ulSolidColor = rbc.iSolidColor;

    if (cBpp == 1)
    {
        ulSolidColor |= ulSolidColor << 8;
        ulSolidColor |= ulSolidColor << 16;
    }
    else if (cBpp == 2)
    {
        ulSolidColor |= ulSolidColor << 16;
    }

    jHwRop = gajHwMixFromRop2[(rop4 >> 2) & 0xf];

    //
    // Make sure we can write to the video registers.
    //

    CP_MM_WAIT_FOR_BLT_COMPLETE(ppdev, pjBase);

    CP_MM_ROP(ppdev, pjBase, jHwRop);
    CP_MM_SRC_ADDR(ppdev, pjBase, ppdev->ulSolidColorOffset);
    CP_MM_DST_Y_OFFSET(ppdev, pjBase, lDelta);
    CP_MM_BLT_MODE(ppdev, pjBase, ENABLE_COLOR_EXPAND |
                                ENABLE_8x8_PATTERN_COPY |
                                ppdev->jModeColor);
    CP_MM_FG_COLOR(ppdev, pjBase, ulSolidColor);

    if (ppdev->flCaps & CAPS_AUTOSTART)
    {
        CP_MM_BLT_EXT_MODE(ppdev, pjBase, ENABLE_SOLID_FILL);
    }

    //
    // Fill the list of rectangles
    //

    while (TRUE)
    {
        CP_MM_XCNT(ppdev, pjBase, (PELS_TO_BYTES(prcl->right - prcl->left) - 1));
        CP_MM_YCNT(ppdev, pjBase, (prcl->bottom - prcl->top - 1));
        CP_MM_DST_ADDR(ppdev, pjBase, ((prcl->top * lDelta) + PELS_TO_BYTES(prcl->left)));
        CP_MM_START_BLT(ppdev, pjBase);

        if (--c == 0)
            return;

        prcl++;
        CP_MM_WAIT_FOR_BLT_COMPLETE(ppdev, pjBase);
    }
}


/**************************************************************************
* VOID vMmCopyBlt
*
* Does a screen-to-screen blt of a list of rectangles.
*
**************************************************************************/

VOID vMmCopyBlt(
PDEV*   ppdev,
LONG    c,          // Can't be zero
RECTL*  prcl,       // Array of relative coordinates destination rectangles
ROP4    rop4,       // Obvious?
POINTL* pptlSrc,    // Original unclipped source point
RECTL*  prclDst)    // Original unclipped destination rectangle
{
    LONG        dx;
    LONG        dy;     // Add delta to destination to get source

    LONG        xyOffset = ppdev->xyOffset;
    BYTE*       pjBase = ppdev->pjBase;
    LONG        lDelta = ppdev->lDelta;
    BYTE        jHwRop;

    DISPDBG((10,"vCopyBlt called"));

    ASSERTDD(c > 0, "Can't handle zero rectangles");

    //
    // The src-dst delta will be the same for all rectangles
    //

    dx = pptlSrc->x - prclDst->left;
    dy = pptlSrc->y - prclDst->top;

    //
    // Make sure we can write to the video registers.
    //

    CP_MM_WAIT_FOR_BLT_COMPLETE(ppdev, pjBase);

    jHwRop = gajHwMixFromRop2[rop4 & 0xf];
    CP_MM_ROP(ppdev, pjBase, jHwRop);

    CP_MM_SRC_Y_OFFSET(ppdev, pjBase, lDelta);
    CP_MM_DST_Y_OFFSET(ppdev, pjBase, lDelta);

    //
    // The accelerator may not be as fast at doing right-to-left copies, so
    // only do them when the rectangles truly overlap:
    //

    if (!OVERLAP(prclDst, pptlSrc) ||
        (prclDst->top < pptlSrc->y) ||
        ((prclDst->top == pptlSrc->y) && (prclDst->left <= pptlSrc->x))
        )
    {
        //
        // Top to Bottom - Left to Right
        //

        DISPDBG((12,"Top to Bottom - Left to Right"));

        CP_MM_BLT_MODE(ppdev, pjBase, DIR_TBLR);

        while (TRUE)
        {
            CP_MM_XCNT(ppdev, pjBase, (PELS_TO_BYTES(prcl->right - prcl->left) - 1));
            CP_MM_YCNT(ppdev, pjBase, (prcl->bottom - prcl->top - 1));

            CP_MM_SRC_ADDR(ppdev, pjBase, (xyOffset + ((prcl->top + dy) * lDelta) + PELS_TO_BYTES(prcl->left + dx)));
            CP_MM_DST_ADDR(ppdev, pjBase, ((prcl->top * lDelta) + PELS_TO_BYTES(prcl->left)));
            CP_MM_START_BLT(ppdev, pjBase);

            if (--c == 0)
                return;

            prcl++;
            CP_MM_WAIT_FOR_BLT_COMPLETE(ppdev, pjBase);
        }
    }
    else
    {
        //
        // Bottom to Top - Right to Left
        //

        DISPDBG((12,"Bottom to Top - Right to Left"));

        CP_MM_BLT_MODE(ppdev, pjBase, DIR_BTRL);

        while (TRUE)
        {
            CP_MM_XCNT(ppdev, pjBase, (PELS_TO_BYTES(prcl->right - prcl->left) - 1));
            CP_MM_YCNT(ppdev, pjBase, (prcl->bottom - prcl->top - 1));

            CP_MM_SRC_ADDR(ppdev, pjBase, (xyOffset + ((prcl->bottom - 1 + dy) * lDelta) + PELS_TO_BYTES(prcl->right + dx) - 1));
            CP_MM_DST_ADDR(ppdev, pjBase, (((prcl->bottom - 1) * lDelta) + PELS_TO_BYTES(prcl->right) - 1));
            CP_MM_START_BLT(ppdev, pjBase);

            if (--c == 0)
                return;

            prcl++;
            CP_MM_WAIT_FOR_BLT_COMPLETE(ppdev, pjBase);
        }
    }
}

/******************************Public*Routine******************************\
* VOID vMmXfer1bpp
*
* Low-level routine used to transfer monochrome data to the screen using
* DWORD writes to the blt engine.
*
* This can handle opaque or transparent expansions.  It does opaque
* expansions by drawing the opaque rectangle first and then transparently
* expands the foreground bits.
*
\**************************************************************************/

VOID vMmXfer1bpp(
PDEV*       ppdev,
LONG        c,          // Count of rectangles, can't be zero
RECTL*      prcl,       // List of destination rectangles, in relative
                        //   coordinates
ROP4        rop4,       // Actually had better be a rop3
SURFOBJ*    psoSrc,     // Source surface
POINTL*     pptlSrc,    // Original unclipped source point
RECTL*      prclDst,    // Original unclipped destination rectangle
XLATEOBJ*   pxlo)       // Translate that provides color-expansion information
{
    ULONG* pulXfer;
    ULONG* pul;
    LONG   ix;
    LONG   iy;
    LONG   cxWidthInBytes;
    BYTE*  pjBits;
    POINTL ptlDst;
    POINTL ptlSrc;
    SIZEL  sizlDst;
    LONG   cxLeftMask;
    LONG   cxRightMask;
    ULONG  ulDstAddr;
    INT    nDwords;
    ULONG  ulLeftMask;
    ULONG  ulRightMask;
    LONG   dx;
    LONG   dy;

    BYTE* pjBase    = ppdev->pjBase;
    LONG  lDelta    = ppdev->lDelta;
    LONG  lDeltaSrc = psoSrc->lDelta;
    LONG  cBpp      = ppdev->cBpp;
    ULONG ulFgColor = pxlo->pulXlate[1];
    ULONG ulBgColor = pxlo->pulXlate[0];

    // Since the hardware clipping on some of the Cirrus chips is broken, we
    // do the clipping by rounding out the edges to dword boundaries and then
    // doing the blt transparently.  In the event that we want the expansion
    // to be opaque, we do the opaquing blt in advance.  One side effect of
    // this is that the destination bits are no longer valid for processing
    // the rop.  This could probably be optimized by doing the edges seperately
    // and then doing the middle section in one pass.  However, this is
    // complicated by a 5434 bug that breaks blts less than 10 pixels wide.

    ASSERTDD(c > 0, "Can't handle zero rectangles");
    ASSERTDD(((rop4 & 0xff00) == 0xcc00), "Expected foreground rop of 0xcc");

    //
    // The src-dst delta will be the same for all rectangles
    //

    dx = pptlSrc->x - prclDst->left;
    dy = pptlSrc->y - prclDst->top;

    if (cBpp == 1)
    {
        ulFgColor = (ulFgColor << 8) | (ulFgColor & 0xff);
        ulBgColor = (ulBgColor << 8) | (ulBgColor & 0xff);
        ulFgColor = (ulFgColor << 16) | (ulFgColor & 0xffff);
        ulBgColor = (ulBgColor << 16) | (ulBgColor & 0xffff);
    }
    else if (cBpp == 2)
    {
        ulFgColor = (ulFgColor << 16) | (ulFgColor & 0xffff);
        ulBgColor = (ulBgColor << 16) | (ulBgColor & 0xffff);
    }

    pulXfer = ppdev->pulXfer;
#if BANKING //bank#1
    ppdev->pfnBankMap(ppdev, ppdev->lXferBank);
#endif

    CP_MM_WAIT_FOR_BLT_COMPLETE(ppdev, pjBase);
    CP_MM_DST_Y_OFFSET(ppdev, pjBase, lDelta);

    if (rop4 != 0xCCAA)
    {
        LONG    lCnt = c;
        RECTL*  prclTmp = prcl;
        BYTE    jHwBgRop = gajHwMixFromRop2[rop4 & 0xf];

        CP_MM_ROP(ppdev, pjBase, jHwBgRop);
        CP_MM_FG_COLOR(ppdev, pjBase, ulBgColor);
        CP_MM_SRC_ADDR(ppdev, pjBase, ppdev->ulSolidColorOffset);
        CP_MM_BLT_MODE(ppdev, pjBase, ppdev->jModeColor |
                                    ENABLE_COLOR_EXPAND |
                                    ENABLE_8x8_PATTERN_COPY);

        do
        {
            // calculate the size of the blt

            ptlDst.x = prclTmp->left;
            ptlDst.y = prclTmp->top;
            sizlDst.cx = prclTmp->right - ptlDst.x;
            sizlDst.cy = prclTmp->bottom - ptlDst.y;

            //
            // Fill the background rectangle with the background color
            //

            // Set the dest addresses

            ulDstAddr = (ptlDst.y * lDelta) + PELS_TO_BYTES(ptlDst.x);

            CP_MM_WAIT_FOR_BLT_COMPLETE(ppdev, pjBase);

            CP_MM_XCNT(ppdev, pjBase, PELS_TO_BYTES(sizlDst.cx) - 1);
            CP_MM_YCNT(ppdev, pjBase, sizlDst.cy - 1);
            CP_MM_DST_ADDR(ppdev, pjBase, ulDstAddr);

            // Start the blt operation

            CP_MM_START_BLT(ppdev, pjBase);
            prclTmp++;
        } while (--lCnt != 0);

        CP_MM_WAIT_FOR_BLT_COMPLETE(ppdev, pjBase);
    }

    CP_MM_FG_COLOR(ppdev, pjBase, ulFgColor);
    CP_MM_BG_COLOR(ppdev, pjBase, ~ulFgColor);
    CP_IO_XPAR_COLOR(ppdev, pjBase, ~ulFgColor);
    CP_MM_ROP(ppdev, pjBase, CL_SRC_COPY);
    CP_MM_BLT_MODE(ppdev, pjBase, ppdev->jModeColor |
                                ENABLE_COLOR_EXPAND |
                                ENABLE_TRANSPARENCY_COMPARE |
                                SRC_CPU_DATA);
    CP_MM_BLT_EXT_MODE(ppdev, pjBase, 0);                // jl01

    do
    {
        // calculate the size of the blt

        ptlDst.x = prcl->left;
        ptlDst.y = prcl->top;
        sizlDst.cx = prcl->right - ptlDst.x;
        sizlDst.cy = prcl->bottom - ptlDst.y;

        // calculate the number of dwords per scan line

        ptlSrc.x = prcl->left + dx;
        ptlSrc.y = prcl->top + dy;

        // Floor the source.
        // Extend the width by the amount required to floor to a dword boundary.
        // Set the size of the left mask.
        // Floor the dest, so it aligns with the floored source.

        if ((cxLeftMask = (ptlSrc.x & 31)))
        {
            sizlDst.cx += cxLeftMask;
            ptlSrc.x &= ~31;
            ptlDst.x -= cxLeftMask;
        }

        ulLeftMask = gaulLeftClipMask[cxLeftMask];

        // Ceil the cx to a dword boundary.

        if (cxRightMask = (sizlDst.cx & 31))
        {
            cxRightMask = 32 - cxRightMask;
            sizlDst.cx = (sizlDst.cx + 31) & ~31;
        }

        ulRightMask = gaulRightClipMask[cxRightMask];

        if (sizlDst.cx == 32)
        {
            ulLeftMask &= ulRightMask;
            ulRightMask = 0;
        }

        // Note: At this point sizlDst.cx is the width of the blt in pixels,
        //       floored to a dword boundary, and ceiled to a dword boundary.

        // Calculate the width in Bytes

        cxWidthInBytes  = sizlDst.cx >> 3;

        // Calculate the number of Dwords and any remaining bytes

        nDwords = cxWidthInBytes >> 2;

        ASSERTDD(((cxWidthInBytes & 0x03) == 0),
                 "cxWidthInBytes is not a DWORD multiple");

        // Calculate the address of the source bitmap
        // This is to a byte boundary.

        pjBits  = (PBYTE) psoSrc->pvScan0;
        pjBits += ptlSrc.y * lDeltaSrc;
        pjBits += ptlSrc.x >> 3;

        ASSERTDD((((ULONG_PTR)pjBits & 0x03) == 0),
                 "pjBits not DWORD aligned like it should be");

        //
        // Blt the 1 bpp bitmap
        //

        ulDstAddr = (ptlDst.y * lDelta) + PELS_TO_BYTES(ptlDst.x);

        CP_MM_WAIT_FOR_BLT_COMPLETE(ppdev, pjBase);

		//
		// Tell the hardware that we want to write (sizlDst.cx) X amd (sizlDst.cy) Y bytes
		//
        CP_MM_XCNT(ppdev, pjBase, PELS_TO_BYTES(sizlDst.cx) - 1);
        CP_MM_YCNT(ppdev, pjBase, sizlDst.cy - 1);

        //
        // The 542x chips require a write to the Src Address Register when
        // doing a host transfer with color expansion.  The value is
        // irrelevant, but the write is crucial.  This is documented in
        // the manual, not the errata.  Go figure.
        //

        CP_MM_SRC_ADDR(ppdev, pjBase, 0);
        CP_MM_DST_ADDR(ppdev, pjBase, ulDstAddr);

        CP_MM_START_BLT(ppdev, pjBase);

        //
        // Transfer the host bitmap.
        //

        if (ulRightMask)
        {
            //
            // Blt is > 1 DWORD wide (nDwords > 1)
            //			
            for (iy = 0; iy < sizlDst.cy; iy++)
            {
                pul = (ULONG*) pjBits;

                //*pulXfer++ = *(((ULONG*)pul)++) & ulLeftMask;
                WRITE_REGISTER_ULONG(pulXfer, (*((ULONG*)pul) & ulLeftMask));
                pul++;

                for (ix = 0; ix < (nDwords-2); ix++)
                {
                    //*pulXfer++ = *(((ULONG*)pul)++);
                    WRITE_REGISTER_ULONG(pulXfer, (*((ULONG*)pul)));
                    pul++;
                }
                //*pulXfer++ = *(((ULONG*)pul)++) & ulRightMask;
                WRITE_REGISTER_ULONG(pulXfer, (*((ULONG*)pul) & ulRightMask));
                pul++;

                pjBits += lDeltaSrc;
                //pulXfer = ppdev->pulXfer;
                CP_MEMORY_BARRIER();     // Flush memory cache when we reset the address

            }
        }
        else
        {
            //
            // Blt is 1 DWORD wide (nDwords == 1)
            //

            for (iy = 0; iy < sizlDst.cy; iy++)
            {
                //*pulXfer = *((ULONG*)pjBits) & ulLeftMask;
                WRITE_REGISTER_ULONG(pulXfer, (*((ULONG*)pjBits) & ulLeftMask));
                pjBits += lDeltaSrc;
                
                CP_MEMORY_BARRIER();     // Flush memory cache
            }
        }

        prcl++;
    } while (--c != 0);
}

/******************************Public*Routine******************************\
* VOID vMmXfer4bpp
*
* Does a 4bpp transfer from a bitmap to the screen.
*
* NOTE: The screen must be 8bpp for this function to be called!
*
* The reason we implement this is that a lot of resources are kept as 4bpp,
* and used to initialize DFBs, some of which we of course keep off-screen.
*
\**************************************************************************/

// XLATE_BUFFER_SIZE defines the size of the stack-based buffer we use
// for doing the translate.  Note that in general stack buffers should
// be kept as small as possible.  The OS guarantees us only 8k for stack
// from GDI down to the display driver in low memory situations; if we
// ask for more, we'll access violate.  Note also that at any time the
// stack buffer cannot be larger than a page (4k) -- otherwise we may
// miss touching the 'guard page' and access violate then too.

#define XLATE_BUFFER_SIZE 256

VOID vMmXfer4bpp(
PDEV*     ppdev,
LONG      c,          // Count of rectangles, can't be zero
RECTL*    prcl,       // List of destination rectangles, in relative coordinates
ULONG     rop4,       // rop4
SURFOBJ*  psoSrc,     // Source surface
POINTL*   pptlSrc,    // Original unclipped source point
RECTL*    prclDst,    // Original unclipped destination rectangle
XLATEOBJ* pxlo)       // Translate that provides colour-expansion information
{
    ULONG  ulDstAddr;
    LONG   dx;
    LONG   dy;
    LONG   cx;
    LONG   cy;
    LONG   lSrcDelta;
    BYTE*  pjSrcScan0;
    BYTE*  pjScan;
    BYTE*  pjSrc;
    BYTE*  pjDst;
    LONG   cxThis;
    LONG   cxToGo;
    LONG   xSrc;
    LONG   iLoop;
    BYTE   jSrc;
    ULONG* pulXlate;
    LONG   cdwThis;
    BYTE*  pjBuf;
    BYTE   ajBuf[XLATE_BUFFER_SIZE];

    ULONG* pulXfer = ppdev->pulXfer;
    BYTE*  pjBase  = ppdev->pjBase;
    LONG   lDelta  = ppdev->lDelta;

    ASSERTDD(ppdev->iBitmapFormat == BMF_8BPP, "Screen must be 8bpp");
    ASSERTDD(psoSrc->iBitmapFormat == BMF_4BPP, "Source must be 4bpp");
    ASSERTDD(c > 0, "Can't handle zero rectangles");
    ASSERTDD(((rop4 & 0xff00) >> 8) == (rop4 & 0xff),
             "Expect only a rop2");

    DISPDBG((5, "vXfer4bpp: entry"));

    dx = pptlSrc->x - prclDst->left;
    dy = pptlSrc->y - prclDst->top;     // Add to destination to get source

    lSrcDelta  = psoSrc->lDelta;
    pjSrcScan0 = psoSrc->pvScan0;

#if BANKING //bank#1
    ppdev->pfnBankMap(ppdev, ppdev->lXferBank);
#endif

    CP_MM_WAIT_FOR_BLT_COMPLETE(ppdev, pjBase);

    CP_MM_DST_Y_OFFSET(ppdev, pjBase, lDelta);

#if 1 // D5480
    CP_MM_BLT_MODE_PACKED(ppdev, pjBase, gajHwPackedMixFromRop2[rop4 & 0xf] | SRC_CPU_DATA);
#else
    CP_MM_ROP(ppdev, pjBase, gajHwMixFromRop2[rop4 & 0xf]);
    CP_MM_BLT_MODE(ppdev, pjBase, SRC_CPU_DATA);
#endif

    while(TRUE)
    {
        ulDstAddr = (prcl->top * lDelta) + PELS_TO_BYTES(prcl->left);
        cx = prcl->right  - prcl->left;
        cy = prcl->bottom - prcl->top;

        CP_MM_WAIT_FOR_BLT_COMPLETE(ppdev, pjBase);

        CP_MM_XCNT(ppdev, pjBase, PELS_TO_BYTES(cx) - 1);
        CP_MM_YCNT(ppdev, pjBase, cy - 1);
        CP_MM_DST_ADDR(ppdev, pjBase, ulDstAddr);

        pulXlate  =  pxlo->pulXlate;
        xSrc      =  prcl->left + dx;
        pjScan    =  pjSrcScan0 + (prcl->top + dy) * lSrcDelta + (xSrc >> 1);

        CP_MM_START_BLT(ppdev, pjBase);

        do {
            pjSrc  = pjScan;
            cxToGo = cx;            // # of pels per scan in 4bpp source
            do {
                cxThis  = XLATE_BUFFER_SIZE;
                                    // We can handle XLATE_BUFFER_SIZE number
                                    //   of pels in this xlate batch
                cxToGo -= cxThis;   // cxThis will be the actual number of
                                    //   pels we'll do in this xlate batch
                if (cxToGo < 0)
                    cxThis += cxToGo;

                pjDst = ajBuf;      // Points to our temporary batch buffer

                // We handle alignment ourselves because it's easy to
                // do, rather than pay the cost of setting/resetting
                // the scissors register:

                if (xSrc & 1)
                {
                    // When unaligned, we have to be careful not to read
                    // past the end of the 4bpp bitmap (that could
                    // potentially cause us to access violate):

                    iLoop = cxThis >> 1;        // Each loop handles 2 pels;
                                                //   we'll handle odd pel
                                                //   separately
                    jSrc  = *pjSrc;
                    while (iLoop-- != 0)
                    {
                        *pjDst++ = (BYTE) pulXlate[jSrc & 0xf];
                        jSrc = *(++pjSrc);
                        *pjDst++ = (BYTE) pulXlate[jSrc >> 4];
                    }

                    if (cxThis & 1)
                        *pjDst = (BYTE) pulXlate[jSrc & 0xf];
                }
                else
                {
                    iLoop = (cxThis + 1) >> 1;  // Each loop handles 2 pels
                    do {
                        jSrc = *pjSrc++;

                        *pjDst++ = (BYTE) pulXlate[jSrc >> 4];
                        *pjDst++ = (BYTE) pulXlate[jSrc & 0xf];

                    } while (--iLoop != 0);
                }

                // The number of bytes we'll transfer is equal to the number
                // of pels we've processed in the batch.  Since we're
                // transferring words, we have to round up to get the word
                // count:

                cdwThis = (cxThis + 3) >> 2;
                pjBuf  = ajBuf;

                TRANSFER_DWORD_ALIGNED(ppdev, pulXfer, pjBuf, cdwThis);

            } while (cxToGo > 0);

            pjScan += lSrcDelta;        // Advance to next source scan.  Note
                                        //   that we could have computed the
                                        //   value to advance 'pjSrc' directly,
                                        //   but this method is less
                                        //   error-prone.

        } while (--cy != 0);

        if (--c == 0)
            return;

        prcl++;
    }
}

/******************************Public*Routine******************************\
* VOID vMmXferNative
*
* Transfers a bitmap that is the same color depth as the display to
* the screen via the data transfer register, with no translation.
*
\**************************************************************************/

VOID vMmXferNative(
PDEV*       ppdev,
LONG        c,          // Count of rectangles, can't be zero
RECTL*      prcl,       // Array of relative coordinates destination rectangles
ULONG       rop4,       // rop4
SURFOBJ*    psoSrc,     // Source surface
POINTL*     pptlSrc,    // Original unclipped source point
RECTL*      prclDst,    // Original unclipped destination rectangle
XLATEOBJ*   pxlo)       // Not used
{
    ULONG ulDstAddr;
    LONG  dx;
    LONG  dy;
    LONG  cx;
    LONG  cy;
    LONG  lSrcDelta;
    BYTE* pjSrcScan0;
    BYTE* pjSrc;
    LONG  cjSrc;

    ULONG* pulXfer = ppdev->pulXfer;
    BYTE*  pjBase  = ppdev->pjBase;
    LONG   lDelta  = ppdev->lDelta;

    ASSERTDD((pxlo == NULL) || (pxlo->flXlate & XO_TRIVIAL),
            "Can handle trivial xlate only");
    ASSERTDD(psoSrc->iBitmapFormat == ppdev->iBitmapFormat,
            "Source must be same color depth as screen");
    ASSERTDD(c > 0, "Can't handle zero rectangles");
    ASSERTDD(((rop4 & 0xff00) >> 8) == (rop4 & 0xff),
             "Expect only a rop2");

    dx = pptlSrc->x - prclDst->left;
    dy = pptlSrc->y - prclDst->top;     // Add to destination to get source

    lSrcDelta  = psoSrc->lDelta;
    pjSrcScan0 = psoSrc->pvScan0;

#if BANKING //bank#1
    ppdev->pfnBankMap(ppdev, ppdev->lXferBank);
#endif

    CP_MM_WAIT_FOR_BLT_COMPLETE(ppdev, pjBase);

    CP_MM_DST_Y_OFFSET(ppdev, pjBase, lDelta);
#if 1 // D5480
    CP_MM_BLT_MODE_PACKED(ppdev, pjBase, gajHwPackedMixFromRop2[rop4 & 0xf] | SRC_CPU_DATA);
#else
    CP_MM_ROP(ppdev, pjBase, gajHwMixFromRop2[rop4 & 0xf]);
    CP_MM_BLT_MODE(ppdev, pjBase, SRC_CPU_DATA);
#endif

    while(TRUE)
    {
        ulDstAddr = (prcl->top * lDelta) + PELS_TO_BYTES(prcl->left);
        cx = prcl->right  - prcl->left;
        cy = prcl->bottom - prcl->top;

        CP_MM_WAIT_FOR_BLT_COMPLETE(ppdev, pjBase);

        CP_MM_XCNT(ppdev, pjBase, PELS_TO_BYTES(cx) - 1);
        CP_MM_YCNT(ppdev, pjBase, cy - 1);
        CP_MM_DST_ADDR(ppdev, pjBase, ulDstAddr);

        cjSrc = PELS_TO_BYTES(cx);
        pjSrc = pjSrcScan0 + (prcl->top  + dy) * lSrcDelta
                           + (PELS_TO_BYTES(prcl->left + dx));

        CP_MM_START_BLT(ppdev, pjBase);
        vImageTransfer(ppdev, pjSrc, lSrcDelta, cjSrc, cy);

        if (--c == 0)
            return;

        prcl++;
    }
}

////////////////////////////////////////////////////////////////////////////////
//                                                                              //
//         N E W   B L T   R O U T I N E S   F O R   B R U S H   C A C H E      //
//                                                                              //
////////////////////////////////////////////////////////////////////////////////

VOID vMmFillSolid36(
PDEV*        ppdev,
LONG         c,
RECTL*       prcl,
ROP4         rop4,
RBRUSH_COLOR rbc,
POINTL*      pptlBrush)
{
    BYTE* pjBase = ppdev->pjBase;
    LONG  lDelta = ppdev->lDelta;
    BYTE  jHwRop = gajHwMixFromRop2[(rop4 >> 2) & 0x0F];
    BYTE  jMode  = ppdev->jModeColor
                 | ENABLE_8x8_PATTERN_COPY
                 | ENABLE_COLOR_EXPAND;

    while (c-- > 0)
    {
        ULONG ulDstOffset;
        SIZEL sizlDst;

        // Calculate the destination address and size.
        ulDstOffset = (prcl->top * lDelta) + PELS_TO_BYTES(prcl->left);
        sizlDst.cx    = PELS_TO_BYTES(prcl->right - prcl->left) - 1;
        sizlDst.cy    = (prcl->bottom - prcl->top) - 1;

        // Wait for the bitblt engine.
        WAIT_BUSY_BLT(ppdev, pjBase);

        // Setup the bitblt registers.
        CP_MM_FG_COLOR(ppdev, pjBase, rbc.iSolidColor);
        CP_MM_XCNT(ppdev, pjBase, sizlDst.cx);
        CP_MM_YCNT(ppdev, pjBase, sizlDst.cy);
        CP_MM_DST_Y_OFFSET(ppdev, pjBase, lDelta);
        CP_MM_DST_WRITE_MASK(ppdev, pjBase, 0);        // Disable clipping.
        CP_MM_BLT_MODE(ppdev, pjBase, jMode);
        CP_MM_ROP(ppdev, pjBase, jHwRop);
        CP_MM_BLT_EXT_MODE(ppdev, pjBase, ENABLE_SOLID_FILL);
        CP_MM_DST_ADDR(ppdev, pjBase, ulDstOffset);

        // Next rectangle.
        prcl++;
    }
}

VOID vMmFillPat36(
PDEV*        ppdev,
LONG         c,
RECTL*       prcl,
ROP4         rop4,
RBRUSH_COLOR rbc,
POINTL*      pptlBrush)
{
    BYTE* pjBase = ppdev->pjBase;
    LONG  lDelta = ppdev->lDelta;
    BYTE  jHwRop = gajHwMixFromRop2[(rop4 >> 2) & 0x0F];

    CP_MM_BLT_EXT_MODE(ppdev, pjBase, 0) ;                           // chu01

    // Dithered brush...
    if (rbc.prb->fl == RBRUSH_DITHER)
    {
        DITHERCACHE* pdc;

        pdc = (DITHERCACHE*) ((ULONG_PTR)ppdev + rbc.prb->ulSlot);
        if (pdc->ulColor != rbc.prb->ulUniq)
        {
            // Cache entry is invalid, realize the brush again.
            bCacheDither(ppdev, rbc.prb);
        }

        while (c-- > 0)
        {
            ULONG ulDstOffset, ulSrcOffset;
            SIZEL sizlDst;
            LONG  xOffset, yOffset;
            LONG  x;

            // Calculate the brush rotation.
            xOffset     = (prcl->left - pptlBrush->x) & 7;
            yOffset     = (prcl->top  - pptlBrush->y) & 7;
            ulSrcOffset = rbc.prb->ulBrush | yOffset;

            // Calculate the destination and size.
            x            = prcl->left - xOffset;
            ulDstOffset = (prcl->top * lDelta) + x;
            sizlDst.cx  = (prcl->right - x) - 1;
            sizlDst.cy  = (prcl->bottom - prcl->top) - 1;

            // Wait for the bitblt engine.
            WAIT_BUSY_BLT(ppdev, pjBase);

            // Setup the bitblt registers.
            CP_MM_XCNT(ppdev, pjBase, sizlDst.cx);
            CP_MM_YCNT(ppdev, pjBase, sizlDst.cy);
            CP_MM_DST_Y_OFFSET(ppdev, pjBase, lDelta);
            CP_MM_SRC_ADDR(ppdev, pjBase, ulSrcOffset);
            CP_MM_DST_WRITE_MASK(ppdev, pjBase, xOffset);
            CP_MM_BLT_MODE(ppdev, pjBase, ENABLE_8x8_PATTERN_COPY);
            CP_MM_ROP(ppdev, pjBase, jHwRop);
            CP_MM_DST_ADDR(ppdev, pjBase, ulDstOffset);

            // Next rectangle.
            prcl++;
        }
    }

    // Monochrome brush...
    else if (rbc.prb->fl == RBRUSH_MONOCHROME)
    {
        MONOCACHE* pmc;
        BYTE       jMode;
        ULONG       ulBgColor, ulFgColor;

        pmc = (MONOCACHE*) ((ULONG_PTR)ppdev + rbc.prb->ulSlot);
        if (pmc->ulUniq != rbc.prb->ulUniq)
        {
            // Cache entry is invalid, realize the brush again.
            bCacheMonochrome(ppdev, rbc.prb);
        }

        // Setup the common parameters.
        jMode        = ppdev->jModeColor
                     | ENABLE_8x8_PATTERN_COPY
                     | ENABLE_COLOR_EXPAND;
        ulBgColor  = rbc.prb->ulBackColor;
        ulFgColor  = rbc.prb->ulForeColor;

        // Monochrome brushes in 24-bpp are already cached expanded.
        if (ppdev->cBpp == 3)
        {
            jMode = ppdev->jModeColor
                  |    ENABLE_8x8_PATTERN_COPY;
        }

        // Walk through all rectangles.
        while (c-- > 0)
        {
            ULONG ulDstOffset, ulSrcOffset;
            SIZEL sizlDst;
            LONG  xOffset, yOffset;
            LONG  x;

            // Calculate the brush rotation.
            xOffset     = (prcl->left - pptlBrush->x) & 7;
            yOffset     = (prcl->top  - pptlBrush->y) & 7;
            ulSrcOffset = rbc.prb->ulBrush | yOffset;

            // Calculate the destination and size.
            x            = prcl->left - xOffset;
            ulDstOffset = (prcl->top * lDelta) + PELS_TO_BYTES(x);
            sizlDst.cx  = PELS_TO_BYTES(prcl->right - x) - 1;
            sizlDst.cy  = (prcl->bottom - prcl->top) - 1;
            if (ppdev->cBpp == 3)
            {
                xOffset *= 3;
            }

            // Wait for the bitblt engine.
            WAIT_BUSY_BLT(ppdev, pjBase);

            // Setup the bitblt registers.
            CP_MM_BG_COLOR(ppdev, pjBase, ulBgColor);
            CP_MM_FG_COLOR(ppdev, pjBase, ulFgColor);
            CP_MM_XCNT(ppdev, pjBase, sizlDst.cx);
            CP_MM_YCNT(ppdev, pjBase, sizlDst.cy);
            CP_MM_DST_Y_OFFSET(ppdev, pjBase, lDelta);
            CP_MM_SRC_ADDR(ppdev, pjBase, ulSrcOffset);
            CP_MM_DST_WRITE_MASK(ppdev, pjBase, xOffset);
            CP_MM_BLT_MODE(ppdev, pjBase, jMode);
            CP_MM_ROP(ppdev, pjBase, jHwRop);
            CP_MM_BLT_EXT_MODE(ppdev, pjBase, 0);
            CP_MM_DST_ADDR(ppdev, pjBase, ulDstOffset);

            // Next rectangle.
            prcl++;
        }
    }

    // Patterned brush...
    else if    (ppdev->flStatus & STAT_PATTERN_CACHE)
    {
        PATTERNCACHE* ppc;

        BYTE jMode = ppdev->jModeColor
                   | ENABLE_8x8_PATTERN_COPY;

        ppc = (PATTERNCACHE*) ((ULONG_PTR)ppdev + rbc.prb->ulSlot);
        if (ppc->prbUniq != rbc.prb)
        {
            // Cache entry is invalid, realize the brush again.
            bCachePattern(ppdev, rbc.prb);
        }

        while (c-- > 0)
        {
            ULONG ulDstOffset, ulSrcOffset;
            SIZEL sizlDst;
            LONG  xOffset, yOffset;
            LONG  x;

            // Calculate the brush rotation.
            xOffset     = (prcl->left - pptlBrush->x) & 7;
            yOffset     = (prcl->top  - pptlBrush->y) & 7;
            ulSrcOffset = rbc.prb->ulBrush | yOffset;

            // Calculate the destination and size.
            x            = prcl->left - xOffset;
            ulDstOffset = (prcl->top * lDelta) + PELS_TO_BYTES(x);
            sizlDst.cx  = PELS_TO_BYTES(prcl->right - x) - 1;
            sizlDst.cy  = (prcl->bottom - prcl->top) - 1;
            if (ppdev->cBpp == 3)
            {
                xOffset *= 3;
            }

            // Wait for the bitblt engine.
            WAIT_BUSY_BLT(ppdev, pjBase);

            // Setup the bitblt registers.
            CP_MM_XCNT(ppdev, pjBase, sizlDst.cx);
            CP_MM_YCNT(ppdev, pjBase, sizlDst.cy);
            CP_MM_DST_Y_OFFSET(ppdev, pjBase, lDelta);
            CP_MM_SRC_ADDR(ppdev, pjBase, ulSrcOffset);
            CP_MM_DST_WRITE_MASK(ppdev, pjBase, xOffset);
            CP_MM_BLT_MODE(ppdev, pjBase, jMode);
            CP_MM_ROP(ppdev, pjBase, jHwRop);
            CP_MM_BLT_EXT_MODE(ppdev, pjBase, 0);
            CP_MM_DST_ADDR(ppdev, pjBase, ulDstOffset);

            // Next rectangle.
            prcl++;
        }
    }

    // Old-style brush cache.
    else
    {
        vMmFillPat(ppdev, c, prcl, rop4, rbc, pptlBrush);
    }
}

VOID vMmCopyBlt36(
PDEV*   ppdev,
LONG    c,
RECTL*  prcl,
ROP4    rop4,
POINTL* pptlSrc,
RECTL*  prclDst)
{
    LONG  xy;
    LONG  cx, cy;
    ULONG ulSrc, ulDst;

    BYTE  jHwRop   = gajHwMixFromRop2[rop4 & 0x0F];
    LONG  xyOffset = ppdev->xyOffset;
    BYTE* pjBase   = ppdev->pjBase;
    LONG  lDelta   = ppdev->lDelta;

    DISPDBG((10, "vMmCopyBlt36 called"));

    // The src-dst delta will be the same for all rectangles.
    xy = ((pptlSrc->y - prclDst->top) * lDelta)
       + PELS_TO_BYTES(pptlSrc->x - prclDst->left);

    // Determine the direction of the blit.
    if ((xy >= 0) || !OVERLAP(prclDst, pptlSrc))
    {
        DISPDBG((12, "Top to Bottom - Left to Right"));

        while (c-- > 0)
        {
            // Calculate the blit size and offsets.
            cx    = PELS_TO_BYTES(prcl->right - prcl->left) - 1;
            cy    = (prcl->bottom - prcl->top) - 1;
            ulDst = xyOffset + (prcl->top * lDelta) + PELS_TO_BYTES(prcl->left);
            ulSrc = ulDst + xy;

            // Wait for the bitblt engine.
            WAIT_BUSY_BLT(ppdev, pjBase);

            // Perform the move.
            CP_MM_XCNT(ppdev, pjBase, cx);
            CP_MM_YCNT(ppdev, pjBase, cy);
            CP_MM_SRC_Y_OFFSET(ppdev, pjBase, lDelta);
            CP_MM_DST_Y_OFFSET(ppdev, pjBase, lDelta);
            CP_MM_SRC_ADDR(ppdev, pjBase, ulSrc);
            CP_MM_BLT_MODE(ppdev, pjBase, DIR_TBLR);
            CP_MM_ROP(ppdev, pjBase, jHwRop);
            CP_MM_DST_ADDR_ABS(ppdev, pjBase, ulDst);

            // Next rectangle.
            prcl++;
        }
    }

    else
    {
        DISPDBG((12, "Bottom to Top - Right to Left"));

        while (c-- > 0)
        {
            // Calculate the blit size and offsets.
            cx    = PELS_TO_BYTES(prcl->right - prcl->left) - 1;
            cy    = (prcl->bottom - prcl->top) - 1;
            ulDst = xyOffset + ((prcl->bottom - 1) * lDelta)
                  + (PELS_TO_BYTES(prcl->right) - 1);
            ulSrc = ulDst + xy;

            // Wait for the bitblt engine.
            WAIT_BUSY_BLT(ppdev, pjBase);

            // Perform the move.
            CP_MM_XCNT(ppdev, pjBase, cx);
            CP_MM_YCNT(ppdev, pjBase, cy);
            CP_MM_SRC_Y_OFFSET(ppdev, pjBase, lDelta);
            CP_MM_DST_Y_OFFSET(ppdev, pjBase, lDelta);
            CP_MM_SRC_ADDR(ppdev, pjBase, ulSrc);
            CP_MM_BLT_MODE(ppdev, pjBase, DIR_BTRL);
            CP_MM_ROP(ppdev, pjBase, jHwRop);
            CP_MM_DST_ADDR_ABS(ppdev, pjBase, ulDst);

            // Next rectangle.
            prcl++;
        }
    }
}

#if 1 // D5480
VOID vMmFillSolid80(
PDEV*        ppdev,
LONG         c,
RECTL*       prcl,
ROP4         rop4,
RBRUSH_COLOR rbc,
POINTL*      pptlBrush)
{
    ULONG_PTR*  ulCLStart;
    ULONG   ulWidthHeight;
    ULONG   xCLOffset;
    ULONG   ulDstOffset = 0;
    BYTE*   pjBase   = ppdev->pjBase;
    LONG    lDelta   = ppdev->lDelta;
    DWORD   jHwRop   = gajHwPackedMixFromRop2[(rop4 >> 2) & 0x0F];
    DWORD   jExtMode = ENABLE_SOLID_FILL_PACKED
                       | ENABLE_XY_POSITION_PACKED
                       | ppdev->jModeColor  
                       | ENABLE_8x8_PATTERN_COPY
                       | ENABLE_COLOR_EXPAND;

    //
    // Make sure we can write to the video registers.
    //
    // We need to change to wait for buffer ready
    CP_MM_WAIT_FOR_BLT_COMPLETE(ppdev, pjBase);

    // Setup the bitblt registers.
    CP_MM_FG_COLOR(ppdev, pjBase, rbc.iSolidColor);
    // Do we really need to set it every time?
    CP_MM_DST_Y_OFFSET(ppdev, pjBase, lDelta);

    // Do we need to clear Source XY?
    CP_MM_SRC_XY_PACKED(ppdev, pjBase, 0);
    CP_MM_DST_WRITE_MASK(ppdev, pjBase, 0);        // Disable clipping.
    
    // Setup first set registers
    xCLOffset = prcl->left;
    CP_MM_DST_Y(ppdev, pjBase, prcl->top);
    CP_MM_XCNT(ppdev, pjBase, (prcl->right - prcl->left) - 1);
    CP_MM_YCNT(ppdev, pjBase, (prcl->bottom - prcl->top) - 1);

    if (--c)
    {
        // There are more than one rectangle
        prcl++;
        jExtMode |= ENABLE_COMMAND_LIST_PACKED;
        ulCLStart = ppdev->pCommandList;
        ulDstOffset |= ((ULONG)((ULONG_PTR)ulCLStart
                              - (ULONG_PTR)ppdev->pjScreen) << 14);
        CP_MM_CL_SWITCH(ppdev);
        while (TRUE)
        {
            // Command List

            // Calculate the destination address and size.
            ulWidthHeight = PACKXY_FAST((prcl->right - prcl->left) - 1, 
                                        (prcl->bottom - prcl->top) - 1);
            ulWidthHeight |= COMMAND_NOSRC_NOTHING;
            // XY
            *(ulCLStart + 1) = PACKXY_FAST(prcl->left, prcl->top);
          
            // Source Start address
            *(ulCLStart + 2) = 0;

            if (c == 1)
            {
                ulWidthHeight |= COMMAND_LAST_PACKET;
                *ulCLStart = ulWidthHeight;
                // Last Command
                break;
            }
        
            *ulCLStart = ulWidthHeight;
            // Next rectangle.
            prcl++;
            c--;
            ulCLStart += 4;
        }
    }
    CP_MM_BLT_MODE_PACKED(ppdev, pjBase, jExtMode | jHwRop );
    CP_MM_DST_ADDR(ppdev, pjBase, ulDstOffset);
    CP_MM_DST_X(ppdev, pjBase, xCLOffset);
}

VOID vMmFillPat80(
PDEV*        ppdev,
LONG         c,
RECTL*       prcl,
ROP4         rop4,
RBRUSH_COLOR rbc,
POINTL*      pptlBrush)
{
    ULONG   xOffset, yOffset;
    ULONG   ulSrcOffset;
    ULONG_PTR*  ulCLStart;
    ULONG   ulWidthHeight;
    ULONG   xCLOffset;
    ULONG   ulDstOffset = 0;
    BYTE*   pjBase = ppdev->pjBase;
    LONG    lDelta = ppdev->lDelta;
    DWORD   jHwRop = gajHwPackedMixFromRop2[(rop4 >> 2) & 0x0F];
    DWORD   jExtMode = ENABLE_XY_POSITION_PACKED
                       | ENABLE_8x8_PATTERN_COPY;

    // Dithered brush...
    if (rbc.prb->fl == RBRUSH_DITHER)
    {
        DITHERCACHE* pdc;

        pdc = (DITHERCACHE*) ((ULONG_PTR)ppdev + rbc.prb->ulSlot);
        if (pdc->ulColor != rbc.prb->ulUniq)
        {
            // Cache entry is invalid, realize the brush again.
            bCacheDither(ppdev, rbc.prb);
        }

        // Calculate the brush rotation.
        xOffset     = (prcl->left - pptlBrush->x) & 7;
        yOffset     = (prcl->top  - pptlBrush->y) & 7;
        ulSrcOffset = rbc.prb->ulBrush | yOffset | (xOffset << 24);

        // Calculate the destination and size.
        xCLOffset   = prcl->left - xOffset;

        //
        // Make sure we can write to the video registers.
        //
        // We need to change to wait for buffer ready
        CP_MM_WAIT_FOR_BLT_COMPLETE(ppdev, pjBase);

        // Do we really need to set it every time?
        CP_MM_DST_Y_OFFSET(ppdev, pjBase, lDelta);

        // Do we need to clear Source XY?
        CP_MM_SRC_XY_PACKED(ppdev, pjBase, 0);
    
        // Setup first set registers
        CP_MM_SRC_ADDR(ppdev, pjBase, ulSrcOffset);
        CP_MM_DST_Y(ppdev, pjBase, prcl->top);
        CP_MM_XCNT(ppdev, pjBase, (prcl->right - xCLOffset) - 1);
        CP_MM_YCNT(ppdev, pjBase, (prcl->bottom - prcl->top) - 1);

        if (--c)
        {
            // There are more than one rectangle
            prcl++;
            jExtMode |= ENABLE_COMMAND_LIST_PACKED;
            ulCLStart = ppdev->pCommandList;
            ulDstOffset |= ((ULONG)((ULONG_PTR)ulCLStart
                                  - (ULONG_PTR)ppdev->pjScreen) << 14);
            CP_MM_CL_SWITCH(ppdev);
            while (TRUE)
            {
                // Command List
    
                // Calculate the brush rotation.
                xOffset     = (prcl->left - pptlBrush->x) & 7;
                yOffset     = (prcl->top  - pptlBrush->y) & 7;

                // Calculate the destination address and size.
                ulWidthHeight = PACKXY_FAST((prcl->right - prcl->left + xOffset ) - 1, 
                                            (prcl->bottom - prcl->top) - 1);
                ulWidthHeight |= COMMAND_FOURTH_NOTHING;
                // XY
                *(ulCLStart + 1) = PACKXY_FAST(prcl->left - xOffset, prcl->top);
            
                // Source Start address
                *(ulCLStart + 2) = rbc.prb->ulBrush | yOffset | (xOffset << 24);

                if (c == 1)
                {
                    ulWidthHeight |= COMMAND_LAST_PACKET;
                    *ulCLStart = ulWidthHeight;
                    // Last Command
                    break;
                }
        
                *ulCLStart = ulWidthHeight;
                // Next rectangle.
                prcl++;
                c--;
                ulCLStart += 4;
            }
        }
        CP_MM_BLT_MODE_PACKED(ppdev, pjBase, jExtMode | jHwRop );
        CP_MM_DST_ADDR(ppdev, pjBase, ulDstOffset);
        CP_MM_DST_X(ppdev, pjBase, xCLOffset);
    }

    // Monochrome brush...
    else if (rbc.prb->fl == RBRUSH_MONOCHROME)
    {
        MONOCACHE* pmc;
        BYTE       jMode;
        ULONG       ulBgColor, ulFgColor;

        pmc = (MONOCACHE*) ((ULONG_PTR) ppdev + rbc.prb->ulSlot);
        if (pmc->ulUniq != rbc.prb->ulUniq)
        {
            // Cache entry is invalid, realize the brush again.
            bCacheMonochrome(ppdev, rbc.prb);
        }

        ulBgColor  = rbc.prb->ulBackColor;
        ulFgColor  = rbc.prb->ulForeColor;
        // Calculate the brush rotation.
        xOffset     = (prcl->left - pptlBrush->x) & 7;
        yOffset     = (prcl->top  - pptlBrush->y) & 7;
        // Monochrome brushes in 24-bpp are already cached expanded.
        if (ppdev->cBpp == 3)
        {
            jExtMode |= ppdev->jModeColor;
            ulSrcOffset = rbc.prb->ulBrush | yOffset | ((xOffset * 3) << 24);
        }
        else
        {
            jExtMode |= (ppdev->jModeColor | ENABLE_COLOR_EXPAND);
            ulSrcOffset = rbc.prb->ulBrush | yOffset | (xOffset << 24);
        }


        // Calculate the destination and size.
        xCLOffset   = prcl->left - xOffset;
        //
        // Make sure we can write to the video registers.
        //
        // We need to change to wait for buffer ready
        CP_MM_WAIT_FOR_BLT_COMPLETE(ppdev, pjBase);

        // Do we really need to set it every time?
        CP_MM_DST_Y_OFFSET(ppdev, pjBase, lDelta);

        // Do we need to clear Source XY?
        CP_MM_SRC_XY_PACKED(ppdev, pjBase, 0);
    
        // Setup first set registers
        CP_MM_SRC_ADDR(ppdev, pjBase, ulSrcOffset);
        CP_MM_DST_Y(ppdev, pjBase, prcl->top);
        CP_MM_XCNT(ppdev, pjBase, (prcl->right - xCLOffset) - 1);
        CP_MM_YCNT(ppdev, pjBase, (prcl->bottom - prcl->top) - 1);
        CP_MM_BG_COLOR(ppdev, pjBase, ulBgColor);
        CP_MM_FG_COLOR(ppdev, pjBase, ulFgColor);

        if (--c)
        {
            // There are more than one rectangle
            prcl++;
            jExtMode |= ENABLE_COMMAND_LIST_PACKED;
            ulCLStart = ppdev->pCommandList;
            ulDstOffset
              |= (ULONG)(((ULONG_PTR)ulCLStart - (ULONG_PTR)ppdev->pjScreen)<<14);
            CP_MM_CL_SWITCH(ppdev);
            while (TRUE)
            {
                // Command List
    
                // Calculate the brush rotation.
                xOffset     = (prcl->left - pptlBrush->x) & 7;
                yOffset     = (prcl->top  - pptlBrush->y) & 7;

                // Calculate the destination address and size.
                ulWidthHeight = PACKXY_FAST((prcl->right - prcl->left + xOffset ) - 1, 
                                            (prcl->bottom - prcl->top) - 1);
                ulWidthHeight |= COMMAND_FOURTH_NOTHING;
                // XY
                *(ulCLStart + 1) = PACKXY_FAST(prcl->left - xOffset, prcl->top);
            
                // Source Start address
                if(ppdev->cBpp == 3)
                    *(ulCLStart + 2) = rbc.prb->ulBrush | yOffset | ((xOffset * 3) << 24);
                else
                    *(ulCLStart + 2) = rbc.prb->ulBrush | yOffset | (xOffset << 24);

                if (c == 1)
                {
                    ulWidthHeight |= COMMAND_LAST_PACKET;
                    *ulCLStart = ulWidthHeight;
                    // Last Command
                    break;
                }
        
                *ulCLStart = ulWidthHeight;
                // Next rectangle.
                prcl++;
                c--;
                ulCLStart += 4;
            }
        }
        CP_MM_BLT_MODE_PACKED(ppdev, pjBase, jExtMode | jHwRop );
        CP_MM_DST_ADDR(ppdev, pjBase, ulDstOffset);
        CP_MM_DST_X(ppdev, pjBase, xCLOffset);
    }

    // Patterned brush...
    else if    (ppdev->flStatus & STAT_PATTERN_CACHE)
    {
        PATTERNCACHE* ppc;

        ppc = (PATTERNCACHE*) ((ULONG_PTR) ppdev + rbc.prb->ulSlot);
        if (ppc->prbUniq != rbc.prb)
        {
            // Cache entry is invalid, realize the brush again.
            bCachePattern(ppdev, rbc.prb);
        }

        // Calculate the brush rotation.
        xOffset     = (prcl->left - pptlBrush->x) & 7;
        yOffset     = (prcl->top  - pptlBrush->y) & 7;
        // Monochrome brushes in 24-bpp are already cached expanded.
        jExtMode |= ppdev->jModeColor;
        if (ppdev->cBpp == 3)
        {
            ulSrcOffset = rbc.prb->ulBrush | yOffset | ((xOffset * 3) << 24);
        }
        else
        {
            ulSrcOffset = rbc.prb->ulBrush | yOffset | (xOffset << 24);
        }


        // Calculate the destination and size.
        xCLOffset   = prcl->left - xOffset;
        //
        // Make sure we can write to the video registers.
        //
        // We need to change to wait for buffer ready
        CP_MM_WAIT_FOR_BLT_COMPLETE(ppdev, pjBase);

        // Do we really need to set it every time?
        CP_MM_DST_Y_OFFSET(ppdev, pjBase, lDelta);

        // Do we need to clear Source XY?
        CP_MM_SRC_XY_PACKED(ppdev, pjBase, 0);
    
        // Setup first set registers
        CP_MM_SRC_ADDR(ppdev, pjBase, ulSrcOffset);
        CP_MM_DST_Y(ppdev, pjBase, prcl->top);
        CP_MM_XCNT(ppdev, pjBase, (prcl->right - xCLOffset) - 1);
        CP_MM_YCNT(ppdev, pjBase, (prcl->bottom - prcl->top) - 1);

        if (--c)
        {
            // There are more than one rectangle
            prcl++;
            jExtMode |= ENABLE_COMMAND_LIST_PACKED;
            ulCLStart = ppdev->pCommandList;
            ulDstOffset
              |= (ULONG)(((ULONG_PTR)ulCLStart-(ULONG_PTR)ppdev->pjScreen)<<14);
            CP_MM_CL_SWITCH(ppdev);
            while (TRUE)
            {
                // Command List
    
                // Calculate the brush rotation.
                xOffset     = (prcl->left - pptlBrush->x) & 7;
                yOffset     = (prcl->top  - pptlBrush->y) & 7;

                // Calculate the destination address and size.
                ulWidthHeight = PACKXY_FAST((prcl->right - prcl->left + xOffset ) - 1, 
                                            (prcl->bottom - prcl->top) - 1);
                ulWidthHeight |= COMMAND_FOURTH_NOTHING;
                // XY
                *(ulCLStart + 1) = PACKXY_FAST(prcl->left - xOffset, prcl->top);
            
                // Source Start address
                if(ppdev->cBpp == 3)
                    *(ulCLStart + 2) = rbc.prb->ulBrush | yOffset | ((xOffset * 3) << 24);
                else
                    *(ulCLStart + 2) = rbc.prb->ulBrush | yOffset | (xOffset << 24);

                if (c == 1)
                {
                    ulWidthHeight |= COMMAND_LAST_PACKET;
                    *ulCLStart = ulWidthHeight;
                    // Last Command
                    break;
                }
        
                *ulCLStart = ulWidthHeight;
                // Next rectangle.
                prcl++;
                c--;
                ulCLStart += 4;
            }
        }
        CP_MM_BLT_MODE_PACKED(ppdev, pjBase, jExtMode | jHwRop );
        CP_MM_DST_ADDR(ppdev, pjBase, ulDstOffset);
        CP_MM_DST_X(ppdev, pjBase, xCLOffset);
    }

    // Old-style brush cache.
    else
    {
        vMmFillPat(ppdev, c, prcl, rop4, rbc, pptlBrush);
    }
}


VOID vMmCopyBlt80(
PDEV*   ppdev,
LONG    c,          // Can't be zero
RECTL*  prcl,       // Array of relative coordinates destination rectangles
ROP4    rop4,       // Obvious?
POINTL* pptlSrc,    // Original unclipped source point
RECTL*  prclDst)    // Original unclipped destination rectangle
{
    LONG    dx;
    LONG    dy;     // Add delta to destination to get source

    ULONG   jHwRop;
    ULONG_PTR*  ulCLStart;
    ULONG   ulWidthHeight;
    ULONG   xCLOffset;
    ULONG   ulDstOffset = 0;
    LONG    xyOffset = ppdev->xyOffset;
    BYTE*   pjBase   = ppdev->pjBase;
    LONG    lDelta   = ppdev->lDelta;
    DWORD   jExtMode = ENABLE_XY_POSITION_PACKED |
                       ppdev->jModeColor;

    DISPDBG((10,"vCopyBlt called"));

    ASSERTDD(c > 0, "Can't handle zero rectangles");

    //
    // The src-dst delta will be the same for all rectangles
    //

    dx = pptlSrc->x - prclDst->left;
    dy = pptlSrc->y - prclDst->top;

    //
    // Make sure we can write to the video registers.
    //
    // We need to change to wait for buffer ready
    CP_MM_WAIT_FOR_BLT_COMPLETE(ppdev, pjBase);

    jHwRop = gajHwPackedMixFromRop2[rop4 & 0xf];

    CP_MM_SRC_Y_OFFSET(ppdev, pjBase, lDelta);
    // Do we really need to set it every time?
    CP_MM_DST_Y_OFFSET(ppdev, pjBase, lDelta);

    //
    // The accelerator may not be as fast at doing right-to-left copies, so
    // only do them when the rectangles truly overlap:
    //

    if (!OVERLAP(prclDst, pptlSrc) ||
        (prclDst->top < pptlSrc->y) ||
        ((prclDst->top == pptlSrc->y) && (prclDst->left <= pptlSrc->x))
        )
    {
        //
        // Top to Bottom - Left to Right
        //

        DISPDBG((12,"Top to Bottom - Left to Right"));

        // Setup first set registers
        xCLOffset = prcl->left;
        CP_MM_DST_Y(ppdev, pjBase, prcl->top);
        CP_MM_XCNT(ppdev, pjBase, (prcl->right - prcl->left) - 1);
        CP_MM_YCNT(ppdev, pjBase, (prcl->bottom - prcl->top) - 1);
        CP_MM_SRC_ADDR(ppdev, pjBase, (xyOffset + ((prcl->top + dy) * lDelta) + PELS_TO_BYTES(prcl->left + dx)));
        CP_MM_SRC_XY_PACKED(ppdev, pjBase, 0);

        if (--c)
        {
            // There are more than one rectangle
            prcl++;
            jExtMode |= ENABLE_COMMAND_LIST_PACKED;
            ulCLStart = ppdev->pCommandList;
            ulDstOffset
              |= (ULONG)(((ULONG_PTR)ulCLStart - (ULONG_PTR)ppdev->pjScreen)<<14);
            CP_MM_CL_SWITCH(ppdev);
            while (TRUE)
            {
                // Command List
    
                // Calculate the destination address and size.
                ulWidthHeight = PACKXY_FAST((prcl->right - prcl->left) - 1, 
                                            (prcl->bottom - prcl->top) - 1);
                ulWidthHeight |= COMMAND_FOURTH_NOTHING;
                // XY
                *(ulCLStart + 1) = PACKXY_FAST(prcl->left, prcl->top);
                // Source Start address
                *(ulCLStart + 2) = xyOffset + (prcl->top + dy) * lDelta + PELS_TO_BYTES(prcl->left + dx);
            
                if (c == 1)
                {
                    ulWidthHeight |= COMMAND_LAST_PACKET;
                    *ulCLStart = ulWidthHeight;
                    // Last Command
                    break;
                }
            
                *ulCLStart = ulWidthHeight;
                // Next rectangle.
                prcl++;
                c--;
                ulCLStart += 4;
            }
        }
        CP_MM_BLT_MODE_PACKED(ppdev, pjBase, jExtMode | jHwRop);
        CP_MM_DST_ADDR(ppdev, pjBase, ulDstOffset);
        CP_MM_DST_X(ppdev, pjBase, xCLOffset);
    }
    else
    {
        //
        // Bottom to Top - Right to Left
        //

        DISPDBG((12,"Bottom to Top - Right to Left"));

        // Setup first set registers
        xCLOffset = prcl->right - 1;
        CP_MM_DST_Y(ppdev, pjBase, prcl->bottom - 1);
        CP_MM_XCNT(ppdev, pjBase, (prcl->right - prcl->left) - 1);
        CP_MM_YCNT(ppdev, pjBase, (prcl->bottom - prcl->top) - 1);
        CP_MM_SRC_ADDR(ppdev, pjBase, (xyOffset + ((prcl->bottom - 1 + dy) * lDelta) + PELS_TO_BYTES(prcl->right + dx - 1)));
        CP_MM_SRC_XY_PACKED(ppdev, pjBase, 0);

        if (--c)
        {
            // There are more than one rectangle
            prcl++;
            jExtMode |= ENABLE_COMMAND_LIST_PACKED;
            ulCLStart = ppdev->pCommandList;
            ulDstOffset
             |=(ULONG)(((ULONG_PTR)ulCLStart - (ULONG_PTR)ppdev->pjScreen) << 14);
            CP_MM_CL_SWITCH(ppdev);
            while (TRUE)
            {
                // Command List
    
                // Calculate the destination address and size.
                ulWidthHeight = PACKXY_FAST((prcl->right - prcl->left) - 1, 
                                            (prcl->bottom - prcl->top) - 1);
                ulWidthHeight |= COMMAND_FOURTH_NOTHING;
                // XY
                *(ulCLStart + 1) = PACKXY_FAST(prcl->right - 1, prcl->bottom - 1);
                // Source Start address
                *(ulCLStart + 2) = xyOffset + (prcl->bottom - 1 + dy) * lDelta + PELS_TO_BYTES(prcl->right + dx - 1);
            
                if (c == 1)
                {
                    ulWidthHeight |= COMMAND_LAST_PACKET;
                    *ulCLStart = ulWidthHeight;
                    // Last Command
                    break;
                }
            
                *ulCLStart = ulWidthHeight;
                // Next rectangle.
                prcl++;
                c--;
                ulCLStart += 4;
            }
        }
        CP_MM_BLT_MODE_PACKED(ppdev, pjBase, jExtMode | jHwRop | DIR_BTRL);
        CP_MM_DST_ADDR(ppdev, pjBase, ulDstOffset);
        CP_MM_DST_X(ppdev, pjBase, xCLOffset);
    }
}

/******************************Public*Routine******************************\
* VOID vMmXfer1bpp80
*
* Low-level routine used to transfer monochrome data to the screen using
* DWORD writes to the blt engine.
*
* This can handle opaque or transparent expansions.  It does opaque
* expansions by drawing the opaque rectangle first and then transparently
* expands the foreground bits.
*
\**************************************************************************/

VOID vMmXfer1bpp80(
PDEV*       ppdev,
LONG        c,          // Count of rectangles, can't be zero
RECTL*      prcl,       // List of destination rectangles, in relative
                        //   coordinates
ROP4        rop4,       // Actually had better be a rop3
SURFOBJ*    psoSrc,     // Source surface
POINTL*     pptlSrc,    // Original unclipped source point
RECTL*      prclDst,    // Original unclipped destination rectangle
XLATEOBJ*   pxlo)       // Translate that provides color-expansion information
{
    ULONG* pulXfer;
    ULONG* pul;
    LONG   ix;
    LONG   iy;
    LONG   cxWidthInBytes;
    BYTE*  pjBits;
    POINTL ptlDst;
    POINTL ptlSrc;
    SIZEL  sizlDst;
    LONG   cxLeftMask;
    LONG   cxRightMask;
    ULONG  ulDstAddr;
    INT    nDwords;
    ULONG  ulLeftMask;
    ULONG  ulRightMask;
    LONG   dx;
    LONG   dy;

    BYTE* pjBase    = ppdev->pjBase;
    LONG  lDelta    = ppdev->lDelta;
    LONG  lDeltaSrc = psoSrc->lDelta;
    LONG  cBpp      = ppdev->cBpp;
    ULONG ulFgColor = pxlo->pulXlate[1];
    ULONG ulBgColor = pxlo->pulXlate[0];

    // Since the hardware clipping on some of the Cirrus chips is broken, we
    // do the clipping by rounding out the edges to dword boundaries and then
    // doing the blt transparently.  In the event that we want the expansion
    // to be opaque, we do the opaquing blt in advance.  One side effect of
    // this is that the destination bits are no longer valid for processing
    // the rop.  This could probably be optimized by doing the edges seperately
    // and then doing the middle section in one pass.  However, this is
    // complicated by a 5434 bug that breaks blts less than 10 pixels wide.

    ASSERTDD(c > 0, "Can't handle zero rectangles");
    ASSERTDD(((rop4 & 0xff00) == 0xcc00), "Expected foreground rop of 0xcc");

    //
    // The src-dst delta will be the same for all rectangles
    //

    dx = pptlSrc->x - prclDst->left;
    dy = pptlSrc->y - prclDst->top;

#if 0
    if (cBpp == 1)
    {
        ulFgColor = (ulFgColor << 8) | (ulFgColor & 0xff);
        ulBgColor = (ulBgColor << 8) | (ulBgColor & 0xff);
        ulFgColor = (ulFgColor << 16) | (ulFgColor & 0xffff);
        ulBgColor = (ulBgColor << 16) | (ulBgColor & 0xffff);
    }
    else if (cBpp == 2)
    {
        ulFgColor = (ulFgColor << 16) | (ulFgColor & 0xffff);
        ulBgColor = (ulBgColor << 16) | (ulBgColor & 0xffff);
    }
#endif

    pulXfer = ppdev->pulXfer;

    CP_MM_WAIT_FOR_BLT_COMPLETE(ppdev, pjBase);
    CP_MM_DST_Y_OFFSET(ppdev, pjBase, lDelta);
    CP_MM_SRC_XY_PACKED(ppdev, pjBase, 0);

                if (rop4 != 0xCCAA)
    {
        LONG    lCnt = c;
        RECTL*  prclTmp = prcl;
        DWORD   jHwBgRop = gajHwPackedMixFromRop2[rop4 & 0xf];

        CP_MM_FG_COLOR(ppdev, pjBase, ulBgColor);
        CP_MM_BLT_MODE_PACKED(ppdev, pjBase, ENABLE_XY_POSITION_PACKED |
                                    ENABLE_SOLID_FILL_PACKED |
                                    jHwBgRop |
                                    ppdev->jModeColor |
                                    ENABLE_COLOR_EXPAND |
                                    ENABLE_8x8_PATTERN_COPY);

        CP_MM_DST_ADDR(ppdev, pjBase, 0);
        do
        {
            // calculate the size of the blt

            ptlDst.x = prclTmp->left;
            ptlDst.y = prclTmp->top;

            //
            // Fill the background rectangle with the background color
            //

            // Set the dest addresses

            ulDstAddr = (ptlDst.y * lDelta) + PELS_TO_BYTES(ptlDst.x);

            CP_MM_WAIT_FOR_BLT_COMPLETE(ppdev, pjBase);

            CP_MM_XCNT(ppdev, pjBase, prclTmp->right - ptlDst.x - 1);
            CP_MM_YCNT(ppdev, pjBase, prclTmp->bottom - ptlDst.y - 1);
            CP_MM_DST_Y(ppdev, pjBase, ptlDst.y);
            CP_MM_DST_X(ppdev, pjBase, ptlDst.x);
            prclTmp++;
        } while (--lCnt != 0);

        CP_MM_WAIT_FOR_BLT_COMPLETE(ppdev, pjBase);
    }

    CP_MM_FG_COLOR(ppdev, pjBase, ulFgColor);
    CP_MM_BG_COLOR(ppdev, pjBase, ~ulFgColor);
    //    CP_IO_XPAR_COLOR(ppdev, pjBase, ~ulFgColor);
    CP_MM_BLT_MODE_PACKED(ppdev, pjBase, ENABLE_XY_POSITION_PACKED |
                                ENABLE_CLIP_RECT_PACKED |
                                CL_PACKED_SRC_COPY |
                                ppdev->jModeColor |
                                ENABLE_COLOR_EXPAND |
                                ENABLE_TRANSPARENCY_COMPARE |
                                SRC_CPU_DATA |
                                SOURCE_GRANULARITY_PACKED);

    CP_MM_DST_ADDR(ppdev, pjBase, 0);
    do
    {
        // calculate the size of the blt

        ptlDst.x = prcl->left;
        ptlDst.y = prcl->top;
        sizlDst.cx = prcl->right - ptlDst.x;
        sizlDst.cy = prcl->bottom - ptlDst.y;

        // calculate the number of dwords per scan line

        ptlSrc.x = prcl->left + dx;
        ptlSrc.y = prcl->top + dy;

        // Floor the source.
        // Extend the width by the amount required to floor to a dword boundary.
        // Set the size of the left mask.
        // Floor the dest, so it aligns with the floored source.

        if ((cxLeftMask = (ptlSrc.x & 31)))
        {
            sizlDst.cx += cxLeftMask;
            ptlSrc.x &= ~31;
            ptlDst.x -= cxLeftMask;
        }

        // Calculate the width in Bytes

        cxWidthInBytes  = (sizlDst.cx + 7) >> 3;

        // Calculate the address of the source bitmap
        // This is to a byte boundary.

        pjBits  = (PBYTE) psoSrc->pvScan0;
        pjBits += ptlSrc.y * lDeltaSrc;
        pjBits += ptlSrc.x >> 3;

        ASSERTDD((((ULONG_PTR)pjBits & 0x03) == 0),
                 "pjBits not DWORD aligned like it should be");

        //
        // Blt the 1 bpp bitmap
        //
        CP_MM_WAIT_FOR_BLT_COMPLETE(ppdev, pjBase);
        // set clipping register
        CP_MM_CLIP_ULXY(ppdev, pjBase, prcl->left, prcl->top);
        CP_MM_CLIP_LRXY(ppdev, pjBase, prcl->right - 1, prcl->bottom - 1);

        CP_MM_DST_Y(ppdev, pjBase, ptlDst.y);
        CP_MM_XCNT(ppdev, pjBase, sizlDst.cx - 1);
        CP_MM_YCNT(ppdev, pjBase, sizlDst.cy - 1);
        CP_MM_DST_X(ppdev, pjBase, ptlDst.x);

        //
        // Transfer the host bitmap.
        //
        vImageTransfer(ppdev, pjBits, lDeltaSrc, cxWidthInBytes, sizlDst.cy);
        prcl++;
    } while (--c != 0);
}

/******************************Public*Routine******************************\
* VOID vMmXferNative80
*
* Transfers a bitmap that is the same color depth as the display to
* the screen via the data transfer register, with no translation.
*
\**************************************************************************/

VOID vMmXferNative80(
PDEV*       ppdev,
LONG        c,          // Count of rectangles, can't be zero
RECTL*      prcl,       // Array of relative coordinates destination rectangles
ULONG       rop4,       // rop4
SURFOBJ*    psoSrc,     // Source surface
POINTL*     pptlSrc,    // Original unclipped source point
RECTL*      prclDst,    // Original unclipped destination rectangle
XLATEOBJ*   pxlo)       // Not used
{
    LONG    dx;
    LONG    dy;
    LONG    cx;
    LONG    cy;
    LONG    lSrcDelta;
    BYTE*    pjSrcScan0;
    BYTE*    pjSrc;
    LONG    cjSrc;

    BYTE*    pjBase    = ppdev->pjBase;
    LONG    lDelta    = ppdev->lDelta;
    DWORD    jHwRop    = gajHwPackedMixFromRop2[rop4 & 0x0F];
    DWORD    jExtMode= ENABLE_XY_POSITION_PACKED | 
                       SRC_CPU_DATA |
                       ppdev->jModeColor;

    ASSERTDD((pxlo == NULL) || (pxlo->flXlate & XO_TRIVIAL),
            "Can handle trivial xlate only");
    ASSERTDD(psoSrc->iBitmapFormat == ppdev->iBitmapFormat,
            "Source must be same color depth as screen");
    ASSERTDD(c > 0, "Can't handle zero rectangles");
    ASSERTDD(((rop4 & 0xff00) >> 8) == (rop4 & 0xff),
             "Expect only a rop2");

    dx = pptlSrc->x - prclDst->left;
    dy = pptlSrc->y - prclDst->top;     // Add to destination to get source

    lSrcDelta  = psoSrc->lDelta;
    pjSrcScan0 = psoSrc->pvScan0;


    //
    // Make sure we can write to the video registers.
    //
    CP_MM_WAIT_FOR_BLT_COMPLETE(ppdev, pjBase);

    CP_MM_DST_Y_OFFSET(ppdev, pjBase, lDelta);
    CP_MM_BLT_MODE_PACKED(ppdev, pjBase, jHwRop | jExtMode);
    CP_MM_SRC_XY_PACKED(ppdev, pjBase, 0);


    while(TRUE)
    {
    
        cx = prcl->right  - prcl->left;
        cy = prcl->bottom - prcl->top;

        cjSrc = PELS_TO_BYTES(cx);
        pjSrc = pjSrcScan0 + (prcl->top  + dy) * lSrcDelta
                           + (PELS_TO_BYTES(prcl->left + dx));

        CP_MM_WAIT_FOR_BLT_COMPLETE(ppdev, pjBase);
        CP_MM_XCNT(ppdev, pjBase, cx - 1);
        CP_MM_YCNT(ppdev, pjBase, cy - 1);

        CP_MM_DST_Y(ppdev, pjBase, prcl->top);
        CP_MM_DST_ADDR(ppdev, pjBase, 0);
        CP_MM_DST_X(ppdev, pjBase, prcl->left);
        vImageTransfer(ppdev, pjSrc, lSrcDelta, cjSrc, cy);

        if (--c == 0)
            break;

        prcl++;
    }
}

#endif // endif D5480
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\cirrus\disp\bltio.c ===
/******************************************************************************\
*
* $Workfile:   bltio.c  $
*
* Contains the low-level IO blt functions.
*
* Hopefully, if you're basing your display driver on this code, to
* support all of DrvBitBlt and DrvCopyBits, you'll only have to implement
* the following routines.  You shouldn't have to modify much in
* 'bitblt.c'.  I've tried to make these routines as few, modular, simple,
* and efficient as I could, while still accelerating as many calls as
* possible that would be cost-effective in terms of performance wins
* versus size and effort.
*
* Note: In the following, 'relative' coordinates refers to coordinates
*       that haven't yet had the offscreen bitmap (DFB) offset applied.
*       'Absolute' coordinates have had the offset applied.  For example,
*       we may be told to blt to (1, 1) of the bitmap, but the bitmap may
*       be sitting in offscreen memory starting at coordinate (0, 768) --
*       (1, 1) would be the 'relative' start coordinate, and (1, 769)
*       would be the 'absolute' start coordinate'.
*
* Copyright (c) 1992-1995 Microsoft Corporation
* Copyright (c) 1996 Cirrus Logic, Inc.
*
* $Log:   S:/projects/drivers/ntsrc/display/bltio.c_v  $
 * 
 *    Rev 1.2   Nov 07 1996 16:47:52   unknown
 * Clean up CAPS flags
 * 
 *    Rev 1.1   Oct 10 1996 15:36:10   unknown
 *  
* 
*    Rev 1.1   12 Aug 1996 16:49:42   frido
* Removed unaccessed local parameters.
*
* jl01  10-08-96  Do Transparent BLT w/o Solid Fill.  Refer to PDRs#5511/6817.
\******************************************************************************/

#include "precomp.h"

/**************************************************************************
* VOID vIoFastPatRealize
*
* Realizes a pattern into offscreen memory.
*
**************************************************************************/

VOID vIoFastPatRealize(
PDEV*   ppdev,
RBRUSH* prb)                    // Points to brush realization structure
{
    BRUSHENTRY* pbe;
    LONG        iBrushCache;
    BYTE*       pjPattern;
    LONG        cjPattern;
    BYTE*       pjPorts = ppdev->pjPorts;
    LONG        lDelta = ppdev->lDelta;
    LONG        lDeltaPat;
    LONG        xCnt;
    LONG        yCnt;
    ULONG       ulDst;

    DISPDBG((10,"vFastPatRealize called"));

    pbe = prb->pbe;
    if ((pbe == NULL) || (pbe->prbVerify != prb))
    {
        // We have to allocate a new offscreen cache brush entry for
        // the brush:

        iBrushCache = ppdev->iBrushCache;
        pbe         = &ppdev->abe[iBrushCache];

        iBrushCache++;
        if (iBrushCache >= ppdev->cBrushCache)
            iBrushCache = 0;

        ppdev->iBrushCache = iBrushCache;

        // Update our links:

        pbe->prbVerify           = prb;
        prb->pbe = pbe;
    }

    //
    // Download brush into cache
    //

    pjPattern = (PBYTE) &prb->aulPattern[0];        // Copy from brush buffer
    cjPattern = PELS_TO_BYTES(TOTAL_BRUSH_SIZE);

    lDeltaPat = PELS_TO_BYTES(8);
    xCnt = PELS_TO_BYTES(8);
    yCnt = 8;

    ulDst = (pbe->y * ppdev->lDelta) + PELS_TO_BYTES(pbe->x);

    ppdev->pfnBankMap(ppdev, ppdev->lXferBank);

    CP_IO_WAIT_FOR_BLT_COMPLETE(ppdev, pjPorts);

    CP_IO_DST_Y_OFFSET(ppdev, pjPorts, (lDeltaPat * 2));
    CP_IO_XCNT(ppdev, pjPorts, (xCnt - 1));
    CP_IO_YCNT(ppdev, pjPorts, (yCnt - 1));
    CP_IO_BLT_MODE(ppdev, pjPorts, SRC_CPU_DATA);
    CP_IO_ROP(ppdev, pjPorts, CL_SRC_COPY);
    CP_IO_DST_ADDR_ABS(ppdev, pjPorts, ulDst);

    CP_IO_START_BLT(ppdev, pjPorts);

    vImageTransfer(ppdev, pjPattern, lDeltaPat, xCnt, yCnt);

    //
    // Duplicate brush horizontally
    //

    CP_IO_WAIT_FOR_BLT_COMPLETE(ppdev, pjPorts);

    CP_IO_XCNT(ppdev, pjPorts, (xCnt - 1));
    CP_IO_YCNT(ppdev, pjPorts, (yCnt - 1));
    CP_IO_BLT_MODE(ppdev, pjPorts, 0);
    CP_IO_SRC_Y_OFFSET(ppdev, pjPorts, (lDeltaPat * 2));
    CP_IO_SRC_ADDR(ppdev, pjPorts, ulDst);
    CP_IO_DST_ADDR_ABS(ppdev, pjPorts, (ulDst + lDeltaPat));

    CP_IO_START_BLT(ppdev, pjPorts);

    //
    // Duplicate brush vertically
    //

    CP_IO_WAIT_FOR_BLT_COMPLETE(ppdev, pjPorts);

    CP_IO_SRC_Y_OFFSET(ppdev, pjPorts, (xCnt * 2));
    CP_IO_DST_Y_OFFSET(ppdev, pjPorts, (xCnt * 2));
    CP_IO_BLT_MODE(ppdev, pjPorts, 0);
    CP_IO_XCNT(ppdev, pjPorts, ((xCnt * 2) - 1));
    CP_IO_YCNT(ppdev, pjPorts, (yCnt - 1));
    CP_IO_SRC_ADDR(ppdev, pjPorts, ulDst);
    CP_IO_DST_ADDR_ABS(ppdev, pjPorts, (ulDst + PELS_TO_BYTES(128)));
    CP_IO_START_BLT(ppdev, pjPorts);

    #if 0
    {
        ////////////////////////////////////////////////////////////////
        // DEBUG TILED PATTERNS
        //
        // The following code helps to debug patterns if you break the
        // realization code.  It copies the 2x2 tiled copy of the brush
        // to the visible screen.
        //

        POINTL ptl;
        RECTL rcl;

        ptl.x = pbe->x;
        ptl.y = pbe->y;

        rcl.left = 10;
        rcl.right = 10 + 16;
        rcl.top = ppdev->cyScreen - 10 - 16;
        rcl.bottom = ppdev->cyScreen - 10;

        {
            LONG        lDelta = ppdev->lDelta;
            BYTE        jHwRop;
            BYTE        jMode;

            //
            // Make sure we can write to the video registers.
            //

            CP_IO_WAIT_FOR_BLT_COMPLETE(ppdev, pjPorts);

            CP_IO_ROP(ppdev, pjPorts, CL_SRC_COPY);
            CP_IO_SRC_Y_OFFSET(ppdev, pjPorts, PELS_TO_BYTES(16));
            CP_IO_DST_Y_OFFSET(ppdev, pjPorts, lDelta);

            {
                //
                // Top to Bottom - Left to Right
                //

                jMode |= DIR_TBLR;
                CP_IO_BLT_MODE(ppdev, pjPorts, ppdev->jModeColor);

                {

                    CP_IO_WAIT_FOR_BLT_COMPLETE(ppdev, pjPorts);

                    CP_IO_XCNT(ppdev, pjPorts, (PELS_TO_BYTES(rcl.right - rcl.left) - 1));
                    CP_IO_YCNT(ppdev, pjPorts, (rcl.bottom - rcl.top - 1));

                    CP_IO_SRC_ADDR(ppdev, pjPorts, (0 + ((ptl.y) * lDelta) + PELS_TO_BYTES(ptl.x)));
                    CP_IO_DST_ADDR_ABS(ppdev, pjPorts, ((rcl.top * lDelta) + PELS_TO_BYTES(rcl.left)));
                    CP_IO_START_BLT(ppdev, pjPorts);
                }
            }
        }
    }
    #endif
}

/**************************************************************************
* VOID vIoFillPat
*
* This routine uses the pattern hardware to draw a patterned list of
* rectangles.
*
**************************************************************************/

VOID vIoFillPat(
PDEV*           ppdev,
LONG            c,          // Can't be zero
RECTL*          prcl,       // Array of relative coordinate destination rects
ROP4            rop4,       // Obvious?
RBRUSH_COLOR    rbc,        // Drawing color is rbc.iSolidColor
POINTL*         pptlBrush)  //
{
    BYTE*       pjPorts = ppdev->pjPorts;
    LONG        lDelta = ppdev->lDelta;
    ULONG       ulAlignedPatternOffset = ppdev->ulAlignedPatternOffset;
    ULONG       ulPatternAddrBase;
    BYTE        jHwRop;
    BYTE        jMode;
    BRUSHENTRY* pbe;        // Pointer to brush entry data, which is used
                            //   for keeping track of the location and status
                            //   of the pattern bits cached in off-screen
                            //   memory

    DISPDBG((10,"vFillPat called"));

    ASSERTDD(c > 0, "Can't handle zero rectangles");
    ASSERTDD(ppdev->cBpp < 3, "vFillPat only works at 8bpp and 16bpp");

    if ((rbc.prb->pbe == NULL) ||
        (rbc.prb->pbe->prbVerify != rbc.prb))
    {
        vIoFastPatRealize(ppdev, rbc.prb);
        DISPDBG((5, " -- Brush cache miss, put it at (%d,%d)", rbc.prb->pbe->x, rbc.prb->pbe->y));
    }
    else
    {
        DISPDBG((5, " -- Brush cache hit on brush at (%d,%d)", rbc.prb->pbe->x, rbc.prb->pbe->y));
    }

    pbe = rbc.prb->pbe;

    //
    // Fill the list of rectangles
    //

    ulPatternAddrBase = pbe->xy;
    jHwRop = gajHwMixFromRop2[(rop4 >> 2) & 0xf];
    jMode = ppdev->jModeColor | ENABLE_8x8_PATTERN_COPY;

    do {
        ULONG offset = 0;

        offset = PELS_TO_BYTES(
            (((prcl->top-pptlBrush->y)&7) << 4)
            +((prcl->left-pptlBrush->x)&7)
        );

        // align the pattern to a new location

        CP_IO_WAIT_FOR_BLT_COMPLETE(ppdev, pjPorts);

        CP_IO_BLT_MODE(ppdev, pjPorts, 0);
        CP_IO_ROP(ppdev, pjPorts, CL_SRC_COPY);
        CP_IO_SRC_Y_OFFSET(ppdev, pjPorts, PELS_TO_BYTES(16));
        CP_IO_DST_Y_OFFSET(ppdev, pjPorts, PELS_TO_BYTES(8));
        CP_IO_SRC_ADDR(ppdev, pjPorts, (ulPatternAddrBase + offset));
        CP_IO_XCNT(ppdev, pjPorts, (PELS_TO_BYTES(8) - 1));
        CP_IO_YCNT(ppdev, pjPorts, (8 - 1));
        CP_IO_DST_ADDR_ABS(ppdev, pjPorts, ulAlignedPatternOffset);
        CP_IO_START_BLT(ppdev, pjPorts);

        // fill using aligned pattern

        CP_IO_WAIT_FOR_BLT_COMPLETE(ppdev, pjPorts);

        CP_IO_BLT_MODE(ppdev, pjPorts, jMode);
        CP_IO_ROP(ppdev, pjPorts, jHwRop);
        CP_IO_DST_Y_OFFSET(ppdev, pjPorts, lDelta);
        CP_IO_SRC_ADDR(ppdev, pjPorts, ulAlignedPatternOffset);
        CP_IO_XCNT(ppdev, pjPorts, (PELS_TO_BYTES(prcl->right - prcl->left) - 1));
        CP_IO_YCNT(ppdev, pjPorts, (prcl->bottom - prcl->top - 1));
        CP_IO_DST_ADDR(ppdev, pjPorts, ((prcl->top * lDelta) + PELS_TO_BYTES(prcl->left)));
        CP_IO_START_BLT(ppdev, pjPorts);

        prcl++;

    } while (--c != 0);
}


/**************************************************************************
* VOID vIoFillSolid
*
* Does a solid fill to a list of rectangles.
*
**************************************************************************/

VOID vIoFillSolid(
PDEV*           ppdev,
LONG            c,          // Can't be zero
RECTL*          prcl,       // Array of relative coordinate destination rects
ROP4            rop4,       // Obvious?
RBRUSH_COLOR    rbc,        // Drawing color is rbc.iSolidColor
POINTL*         pptlBrush)  // Not used
{
    BYTE*       pjPorts = ppdev->pjPorts;
    LONG        lDelta = ppdev->lDelta;
    LONG        cBpp = ppdev->cBpp;
    ULONG       ulSolidColor;
    BYTE        jHwRop;

    DISPDBG((10,"vFillSolid called"));

    ASSERTDD(c > 0, "Can't handle zero rectangles");

    ulSolidColor = rbc.iSolidColor;

    if (cBpp == 1)
    {
        ulSolidColor |= ulSolidColor << 8;
        ulSolidColor |= ulSolidColor << 16;
    }
    else if (cBpp == 2)
    {
        ulSolidColor |= ulSolidColor << 16;
    }

    jHwRop = gajHwMixFromRop2[(rop4 >> 2) & 0xf];

    //
    // Make sure we can write to the video registers.
    //

    CP_IO_WAIT_FOR_BLT_COMPLETE(ppdev, pjPorts);

    CP_IO_ROP(ppdev, pjPorts, jHwRop);
    CP_IO_SRC_ADDR(ppdev, pjPorts, ppdev->ulSolidColorOffset);
    CP_IO_DST_Y_OFFSET(ppdev, pjPorts, lDelta);
    CP_IO_BLT_MODE(ppdev, pjPorts, ENABLE_COLOR_EXPAND |
                                ENABLE_8x8_PATTERN_COPY |
                                ppdev->jModeColor);
    CP_IO_FG_COLOR(ppdev, pjPorts, ulSolidColor);

    //
    // Fill the list of rectangles
    //

    while (TRUE)
    {
        CP_IO_XCNT(ppdev, pjPorts, (PELS_TO_BYTES(prcl->right - prcl->left) - 1));
        CP_IO_YCNT(ppdev, pjPorts, (prcl->bottom - prcl->top - 1));
        CP_IO_DST_ADDR(ppdev, pjPorts, ((prcl->top * lDelta) + PELS_TO_BYTES(prcl->left)));
        CP_IO_START_BLT(ppdev, pjPorts);

        if (--c == 0)
            return;

        prcl++;
        CP_IO_WAIT_FOR_BLT_COMPLETE(ppdev, pjPorts);
    }
}


/**************************************************************************
* VOID vIoCopyBlt
*
* Does a screen-to-screen blt of a list of rectangles.
*
**************************************************************************/

VOID vIoCopyBlt(
PDEV*   ppdev,
LONG    c,          // Can't be zero
RECTL*  prcl,       // Array of relative coordinates destination rectangles
ROP4    rop4,       // Obvious?
POINTL* pptlSrc,    // Original unclipped source point
RECTL*  prclDst)    // Original unclipped destination rectangle
{
    LONG        dx;
    LONG        dy;     // Add delta to destination to get source

    LONG        xyOffset = ppdev->xyOffset;
    BYTE*       pjPorts = ppdev->pjPorts;
    LONG        lDelta = ppdev->lDelta;
    BYTE        jHwRop;

    DISPDBG((10,"vCopyBlt called"));

    ASSERTDD(c > 0, "Can't handle zero rectangles");

    //
    // The src-dst delta will be the same for all rectangles
    //

    dx = pptlSrc->x - prclDst->left;
    dy = pptlSrc->y - prclDst->top;

    //
    // Make sure we can write to the video registers.
    //

    CP_IO_WAIT_FOR_BLT_COMPLETE(ppdev, pjPorts);

    jHwRop = gajHwMixFromRop2[rop4 & 0xf];
    CP_IO_ROP(ppdev, pjPorts, jHwRop);

    CP_IO_SRC_Y_OFFSET(ppdev, pjPorts, lDelta);
    CP_IO_DST_Y_OFFSET(ppdev, pjPorts, lDelta);

    //
    // The accelerator may not be as fast at doing right-to-left copies, so
    // only do them when the rectangles truly overlap:
    //

    if (!OVERLAP(prclDst, pptlSrc) ||
        (prclDst->top < pptlSrc->y) ||
        ((prclDst->top == pptlSrc->y) && (prclDst->left <= pptlSrc->x))
        )
    {
        //
        // Top to Bottom - Left to Right
        //

        DISPDBG((12,"Top to Bottom - Left to Right"));

        CP_IO_BLT_MODE(ppdev, pjPorts, DIR_TBLR);

        while (TRUE)
        {
            CP_IO_XCNT(ppdev, pjPorts, (PELS_TO_BYTES(prcl->right - prcl->left) - 1));
            CP_IO_YCNT(ppdev, pjPorts, (prcl->bottom - prcl->top - 1));

            CP_IO_SRC_ADDR(ppdev, pjPorts, (xyOffset + ((prcl->top + dy) * lDelta) + PELS_TO_BYTES(prcl->left + dx)));
            CP_IO_DST_ADDR(ppdev, pjPorts, ((prcl->top * lDelta) + PELS_TO_BYTES(prcl->left)));
            CP_IO_START_BLT(ppdev, pjPorts);

            if (--c == 0)
                return;

            prcl++;
            CP_IO_WAIT_FOR_BLT_COMPLETE(ppdev, pjPorts);
        }
    }
    else
    {
        //
        // Bottom to Top - Right to Left
        //

        DISPDBG((12,"Bottom to Top - Right to Left"));

        CP_IO_BLT_MODE(ppdev, pjPorts, DIR_BTRL);

        while (TRUE)
        {
            CP_IO_XCNT(ppdev, pjPorts, (PELS_TO_BYTES(prcl->right - prcl->left) - 1));
            CP_IO_YCNT(ppdev, pjPorts, (prcl->bottom - prcl->top - 1));

            CP_IO_SRC_ADDR(ppdev, pjPorts, (xyOffset + ((prcl->bottom - 1 + dy) * lDelta) + PELS_TO_BYTES(prcl->right + dx) - 1));
            CP_IO_DST_ADDR(ppdev, pjPorts, (((prcl->bottom - 1) * lDelta) + PELS_TO_BYTES(prcl->right) - 1));
            CP_IO_START_BLT(ppdev, pjPorts);

            if (--c == 0)
                return;

            prcl++;
            CP_IO_WAIT_FOR_BLT_COMPLETE(ppdev, pjPorts);
        }
    }
}

/******************************Public*Routine******************************\
* VOID vIoXfer1bpp
*
* Low-level routine used to transfer monochrome data to the screen using
* DWORD writes to the blt engine.
*
* This can handle opaque or transparent expansions.  It does opaque
* expansions by drawing the opaque rectangle first and then transparently
* expands the foreground bits.
*
\**************************************************************************/
VOID vIoXfer1bpp(
PDEV*       ppdev,
LONG        c,          // Count of rectangles, can't be zero
RECTL*      prcl,       // List of destination rectangles, in relative
                        //   coordinates
ROP4        rop4,       // Actually had better be a rop3
SURFOBJ*    psoSrc,     // Source surface
POINTL*     pptlSrc,    // Original unclipped source point
RECTL*      prclDst,    // Original unclipped destination rectangle
XLATEOBJ*   pxlo)       // Translate that provides color-expansion information
{
    ULONG* pulXfer;
    ULONG* pul;
    LONG   ix;
    LONG   iy;
    LONG   cxWidthInBytes;
    BYTE*  pjBits;
    POINTL ptlDst;
    POINTL ptlSrc;
    SIZEL  sizlDst;
    LONG   cxLeftMask;
    LONG   cxRightMask;
    ULONG  ulDstAddr;
    INT    nDwords;
    ULONG  ulLeftMask;
    ULONG  ulRightMask;
    LONG   dx;
    LONG   dy;

    BYTE* pjPorts   = ppdev->pjPorts;
    LONG  lDelta    = ppdev->lDelta;
    LONG  lDeltaSrc = psoSrc->lDelta;
    LONG  cBpp      = ppdev->cBpp;
    ULONG ulFgColor = pxlo->pulXlate[1];
    ULONG ulBgColor = pxlo->pulXlate[0];

    // Since the hardware clipping on some of the Cirrus chips is broken, we
    // do the clipping by rounding out the edges to dword boundaries and then
    // doing the blt transparently.  In the event that we want the expansion
    // to be opaque, we do the opaquing blt in advance.  One side effect of
    // this is that the destination bits are no longer valid for processing
    // the rop.  This could probably be optimized by doing the edges seperately
    // and then doing the middle section in one pass.  However, this is
    // complicated by a 5434 bug that breaks blts less than 10 pixels wide.

    ASSERTDD(c > 0, "Can't handle zero rectangles");
    ASSERTDD(((rop4 & 0xff00) == 0xcc00), "Expected foreground rop of 0xcc");

    //
    // The src-dst delta will be the same for all rectangles
    //

    dx = pptlSrc->x - prclDst->left;
    dy = pptlSrc->y - prclDst->top;

    if (cBpp == 1)
    {
        ulFgColor = (ulFgColor << 8) | (ulFgColor & 0xff);
        ulBgColor = (ulBgColor << 8) | (ulBgColor & 0xff);
        ulFgColor = (ulFgColor << 16) | (ulFgColor & 0xffff);
        ulBgColor = (ulBgColor << 16) | (ulBgColor & 0xffff);
    }
    else if (cBpp == 2)
    {
        ulFgColor = (ulFgColor << 16) | (ulFgColor & 0xffff);
        ulBgColor = (ulBgColor << 16) | (ulBgColor & 0xffff);
    }

    pulXfer = ppdev->pulXfer;
    ppdev->pfnBankMap(ppdev, ppdev->lXferBank);

    CP_IO_WAIT_FOR_BLT_COMPLETE(ppdev, pjPorts);
    CP_IO_DST_Y_OFFSET(ppdev, pjPorts, lDelta);

    if (rop4 != 0xCCAA)
    {
        LONG    lCnt = c;
        RECTL*  prclTmp = prcl;
        BYTE    jHwBgRop = gajHwMixFromRop2[rop4 & 0xf];

        CP_IO_ROP(ppdev, pjPorts, jHwBgRop);
        CP_IO_FG_COLOR(ppdev, pjPorts, ulBgColor);
        CP_IO_SRC_ADDR(ppdev, pjPorts, ppdev->ulSolidColorOffset);
        CP_IO_BLT_MODE(ppdev, pjPorts, ppdev->jModeColor |
                                    ENABLE_COLOR_EXPAND |
                                    ENABLE_8x8_PATTERN_COPY);
		
        do
        {
            // calculate the size of the blt

            ptlDst.x = prclTmp->left;
            ptlDst.y = prclTmp->top;
            sizlDst.cx = prclTmp->right - ptlDst.x;
            sizlDst.cy = prclTmp->bottom - ptlDst.y;

            //
            // Fill the background rectangle with the background color
            //

            // Set the dest addresses

            ulDstAddr = (ptlDst.y * lDelta) + PELS_TO_BYTES(ptlDst.x);

            CP_IO_WAIT_FOR_BLT_COMPLETE(ppdev, pjPorts);

			//
			// Tell the hardware how many bytes we'd like to write:
			// sizlDst.cx * sizelDst.cy
			//
            CP_IO_XCNT(ppdev, pjPorts, PELS_TO_BYTES(sizlDst.cx) - 1);
            CP_IO_YCNT(ppdev, pjPorts, sizlDst.cy - 1);
            CP_IO_DST_ADDR(ppdev, pjPorts, ulDstAddr);

            // Start the blt operation

            CP_IO_START_BLT(ppdev, pjPorts);
            prclTmp++;
        } while (--lCnt != 0);

        CP_IO_WAIT_FOR_BLT_COMPLETE(ppdev, pjPorts);
    }

    CP_IO_FG_COLOR(ppdev, pjPorts, ulFgColor);

    CP_IO_BG_COLOR(ppdev, pjPorts, ~ulFgColor);
    CP_IO_XPAR_COLOR(ppdev, pjPorts, ~ulFgColor);
    CP_IO_ROP(ppdev, pjPorts, CL_SRC_COPY);
    CP_IO_BLT_MODE(ppdev, pjPorts, ppdev->jModeColor |
                                ENABLE_COLOR_EXPAND |
                                ENABLE_TRANSPARENCY_COMPARE |
                                SRC_CPU_DATA);
    CP_IO_BLT_EXT_MODE(ppdev, pjPorts, 0);            // jl01

    do
    {
        // calculate the size of the blt

        ptlDst.x = prcl->left;
        ptlDst.y = prcl->top;
        sizlDst.cx = prcl->right - ptlDst.x;
        sizlDst.cy = prcl->bottom - ptlDst.y;

        // calculate the number of dwords per scan line

        ptlSrc.x = prcl->left + dx;
        ptlSrc.y = prcl->top + dy;

        // Floor the source.
        // Extend the width by the amount required to floor to a dword boundary.
        // Set the size of the left mask.
        // Floor the dest, so it aligns with the floored source.

        if ((cxLeftMask = (ptlSrc.x & 31)))
        {
            sizlDst.cx += cxLeftMask;
            ptlSrc.x &= ~31;
            ptlDst.x -= cxLeftMask;
        }

        ulLeftMask = gaulLeftClipMask[cxLeftMask];

        // Ceil the cx to a dword boundary.

        if (cxRightMask = (sizlDst.cx & 31))
        {
            cxRightMask = 32 - cxRightMask;
            sizlDst.cx = (sizlDst.cx + 31) & ~31;
        }

        ulRightMask = gaulRightClipMask[cxRightMask];

        if (sizlDst.cx == 32)
        {
            ulLeftMask &= ulRightMask;
            ulRightMask = 0;
        }

        // Note: At this point sizlDst.cx is the width of the blt in pixels,
        //       floored to a dword boundary, and ceiled to a dword boundary.

        // Calculate the width in Bytes

        cxWidthInBytes  = sizlDst.cx >> 3;

        // Calculate the number of Dwords and any remaining bytes

        nDwords = cxWidthInBytes >> 2;

        ASSERTDD(((cxWidthInBytes & 0x03) == 0),
                 "cxWidthInBytes is not a DWORD multiple");

        // Calculate the address of the source bitmap
        // This is to a byte boundary.

        pjBits  = (PBYTE) psoSrc->pvScan0;
        pjBits += ptlSrc.y * lDeltaSrc;
        pjBits += ptlSrc.x >> 3;

        ASSERTDD((((ULONG_PTR)pjBits & 0x03) == 0),
                 "pjBits not DWORD aligned like it should be");

        //
        // Blt the 1 bpp bitmap
        //

        ulDstAddr = (ptlDst.y * lDelta) + PELS_TO_BYTES(ptlDst.x);

        CP_IO_WAIT_FOR_BLT_COMPLETE(ppdev, pjPorts);

        CP_IO_XCNT(ppdev, pjPorts, PELS_TO_BYTES(sizlDst.cx) - 1);
        CP_IO_YCNT(ppdev, pjPorts, sizlDst.cy - 1);

        //
        // The 542x chips require a write to the Src Address Register when
        // doing a host transfer with color expansion.  The value is
        // irrelevant, but the write is crucial.  This is documented in
        // the manual, not the errata.  Go figure.
        //

        CP_IO_SRC_ADDR(ppdev, pjPorts, 0);
        CP_IO_DST_ADDR(ppdev, pjPorts, ulDstAddr);

        CP_IO_START_BLT(ppdev, pjPorts);

        //
        // Transfer the host bitmap.
        //
        if (ulRightMask)
        {
            //
            // Blt is > 1 DWORD wide (nDwords > 1)
            //

            for (iy = 0; iy < sizlDst.cy; iy++)
            {
                pul = (ULONG*) pjBits;

                //*pulXfer++ = *(((ULONG*)pul)++) & ulLeftMask;
                WRITE_REGISTER_ULONG(pulXfer, (*((ULONG*)pul) & ulLeftMask));
                pul++;

                for (ix = 0; ix < (nDwords-2); ix++)
                {
                    //*pulXfer++ = *(((ULONG*)pul)++);
                    WRITE_REGISTER_ULONG(pulXfer, (*((ULONG*)pul)));
                    pul++;
                }
                //*pulXfer++ = *(((ULONG*)pul)++) & ulRightMask;
                WRITE_REGISTER_ULONG(pulXfer, (*((ULONG*)pul) & ulRightMask));
                pul++;

                pjBits += lDeltaSrc;
                //pulXfer = ppdev->pulXfer;
                CP_MEMORY_BARRIER();     // Flush memory cache when we reset the address

            }
        }
        else
        {
            //
            // Blt is 1 DWORD wide (nDwords == 1)
            //

            for (iy = 0; iy < sizlDst.cy; iy++)
            {
                //*pulXfer = *((ULONG*)pjBits) & ulLeftMask;
                WRITE_REGISTER_ULONG(pulXfer, (*((ULONG*)pjBits) & ulLeftMask));
                pjBits += lDeltaSrc;
                CP_MEMORY_BARRIER();     // Flush memory cache
            }
        }

        prcl++;
    } while (--c != 0);
}

/******************************Public*Routine******************************\
* VOID vIoXfer4bpp
*
* Does a 4bpp transfer from a bitmap to the screen.
*
* NOTE: The screen must be 8bpp for this function to be called!
*
* The reason we implement this is that a lot of resources are kept as 4bpp,
* and used to initialize DFBs, some of which we of course keep off-screen.
*
\**************************************************************************/

// XLATE_BUFFER_SIZE defines the size of the stack-based buffer we use
// for doing the translate.  Note that in general stack buffers should
// be kept as small as possible.  The OS guarantees us only 8k for stack
// from GDI down to the display driver in low memory situations; if we
// ask for more, we'll access violate.  Note also that at any time the
// stack buffer cannot be larger than a page (4k) -- otherwise we may
// miss touching the 'guard page' and access violate then too.

#define XLATE_BUFFER_SIZE 256

VOID vIoXfer4bpp(
PDEV*       ppdev,
LONG        c,          // Count of rectangles, can't be zero
RECTL*      prcl,       // List of destination rectangles, in relative
                        //   coordinates
ULONG       rop4,       // rop4
SURFOBJ*    psoSrc,     // Source surface
POINTL*     pptlSrc,    // Original unclipped source point
RECTL*      prclDst,    // Original unclipped destination rectangle
XLATEOBJ*   pxlo)       // Translate that provides colour-expansion information
{
    ULONG*          pulXfer = ppdev->pulXfer;
    BYTE*           pjPorts = ppdev->pjPorts;
    LONG            lDelta  = ppdev->lDelta;
    ULONG           ulDstAddr;
    LONG            dx;
    LONG            dy;
    LONG            cx;
    LONG            cy;
    LONG            lSrcDelta;
    BYTE*           pjSrcScan0;
    BYTE*           pjScan;
    BYTE*           pjSrc;
    BYTE*           pjDst;
    LONG            cxThis;
    LONG            cxToGo;
    LONG            xSrc;
    LONG            iLoop;
    BYTE            jSrc;
    ULONG*          pulXlate;
    LONG            cdwThis;
    BYTE*           pjBuf;
    BYTE            ajBuf[XLATE_BUFFER_SIZE];

    ASSERTDD(ppdev->iBitmapFormat == BMF_8BPP, "Screen must be 8bpp");
    ASSERTDD(psoSrc->iBitmapFormat == BMF_4BPP, "Source must be 4bpp");
    ASSERTDD(c > 0, "Can't handle zero rectangles");
    ASSERTDD(((rop4 & 0xff00) >> 8) == (rop4 & 0xff),
             "Expect only a rop2");

    DISPDBG((5, "vXfer4bpp: entry"));

    dx = pptlSrc->x - prclDst->left;
    dy = pptlSrc->y - prclDst->top;     // Add to destination to get source

    lSrcDelta  = psoSrc->lDelta;
    pjSrcScan0 = psoSrc->pvScan0;

    ppdev->pfnBankMap(ppdev, ppdev->lXferBank);

    CP_IO_WAIT_FOR_BLT_COMPLETE(ppdev, pjPorts);

    CP_IO_DST_Y_OFFSET(ppdev, pjPorts, lDelta);
    CP_IO_ROP(ppdev, pjPorts, gajHwMixFromRop2[rop4 & 0xf]);
    CP_IO_BLT_MODE(ppdev, pjPorts, SRC_CPU_DATA);

    while(TRUE)
    {
        ulDstAddr = (prcl->top * lDelta) + PELS_TO_BYTES(prcl->left);
        cx = prcl->right  - prcl->left;
        cy = prcl->bottom - prcl->top;

        CP_IO_WAIT_FOR_BLT_COMPLETE(ppdev, pjPorts);

        CP_IO_XCNT(ppdev, pjPorts, PELS_TO_BYTES(cx) - 1);
        CP_IO_YCNT(ppdev, pjPorts, cy - 1);
        CP_IO_DST_ADDR(ppdev, pjPorts, ulDstAddr);

        pulXlate  =  pxlo->pulXlate;
        xSrc      =  prcl->left + dx;
        pjScan    =  pjSrcScan0 + (prcl->top + dy) * lSrcDelta + (xSrc >> 1);

        CP_IO_START_BLT(ppdev, pjPorts);

        do {
            pjSrc  = pjScan;
            cxToGo = cx;            // # of pels per scan in 4bpp source
            do {
                cxThis  = XLATE_BUFFER_SIZE;
                                    // We can handle XLATE_BUFFER_SIZE number
                                    //   of pels in this xlate batch
                cxToGo -= cxThis;   // cxThis will be the actual number of
                                    //   pels we'll do in this xlate batch
                if (cxToGo < 0)
                    cxThis += cxToGo;

                pjDst = ajBuf;      // Points to our temporary batch buffer

                // We handle alignment ourselves because it's easy to
                // do, rather than pay the cost of setting/resetting
                // the scissors register:

                if (xSrc & 1)
                {
                    // When unaligned, we have to be careful not to read
                    // past the end of the 4bpp bitmap (that could
                    // potentially cause us to access violate):

                    iLoop = cxThis >> 1;        // Each loop handles 2 pels;
                                                //   we'll handle odd pel
                                                //   separately
                    jSrc  = *pjSrc;
                    while (iLoop-- != 0)
                    {
                        *pjDst++ = (BYTE) pulXlate[jSrc & 0xf];
                        jSrc = *(++pjSrc);
                        *pjDst++ = (BYTE) pulXlate[jSrc >> 4];
                    }

                    if (cxThis & 1)
                        *pjDst = (BYTE) pulXlate[jSrc & 0xf];
                }
                else
                {
                    iLoop = (cxThis + 1) >> 1;  // Each loop handles 2 pels
                    do {
                        jSrc = *pjSrc++;

                        *pjDst++ = (BYTE) pulXlate[jSrc >> 4];
                        *pjDst++ = (BYTE) pulXlate[jSrc & 0xf];

                    } while (--iLoop != 0);
                }

                // The number of bytes we'll transfer is equal to the number
                // of pels we've processed in the batch.  Since we're
                // transferring words, we have to round up to get the word
                // count:

                cdwThis = (cxThis + 3) >> 2;
                pjBuf  = ajBuf;

                TRANSFER_DWORD_ALIGNED(ppdev, pulXfer, pjBuf, cdwThis);

            } while (cxToGo > 0);

            pjScan += lSrcDelta;        // Advance to next source scan.  Note
                                        //   that we could have computed the
                                        //   value to advance 'pjSrc' directly,
                                        //   but this method is less
                                        //   error-prone.

        } while (--cy != 0);

        if (--c == 0)
            return;

        prcl++;
    }
}

/******************************Public*Routine******************************\
* VOID vIoXferNative
*
* Transfers a bitmap that is the same color depth as the display to
* the screen via the data transfer register, with no translation.
*
\**************************************************************************/

VOID vIoXferNative(
PDEV*       ppdev,
LONG        c,          // Count of rectangles, can't be zero
RECTL*      prcl,       // Array of relative coordinates destination rectangles
ULONG       rop4,       // rop4
SURFOBJ*    psoSrc,     // Source surface
POINTL*     pptlSrc,    // Original unclipped source point
RECTL*      prclDst,    // Original unclipped destination rectangle
XLATEOBJ*   pxlo)       // Not used
{
    ULONG*          pulXfer = ppdev->pulXfer;
    BYTE*           pjPorts = ppdev->pjPorts;
    LONG            lDelta  = ppdev->lDelta;
    ULONG           ulDstAddr;
    LONG            dx;
    LONG            dy;
    LONG            cx;
    LONG            cy;
    LONG            lSrcDelta;
    BYTE*           pjSrcScan0;
    BYTE*           pjSrc;
    LONG            cjSrc;

    ASSERTDD((pxlo == NULL) || (pxlo->flXlate & XO_TRIVIAL),
            "Can handle trivial xlate only");
    ASSERTDD(psoSrc->iBitmapFormat == ppdev->iBitmapFormat,
            "Source must be same color depth as screen");
    ASSERTDD(c > 0, "Can't handle zero rectangles");
    ASSERTDD(((rop4 & 0xff00) >> 8) == (rop4 & 0xff),
             "Expect only a rop2");

    dx = pptlSrc->x - prclDst->left;
    dy = pptlSrc->y - prclDst->top;     // Add to destination to get source

    lSrcDelta  = psoSrc->lDelta;
    pjSrcScan0 = psoSrc->pvScan0;

    ppdev->pfnBankMap(ppdev, ppdev->lXferBank);

    CP_IO_WAIT_FOR_BLT_COMPLETE(ppdev, pjPorts);

    CP_IO_DST_Y_OFFSET(ppdev, pjPorts, lDelta);
    CP_IO_ROP(ppdev, pjPorts, gajHwMixFromRop2[rop4 & 0xf]);
    CP_IO_BLT_MODE(ppdev, pjPorts, SRC_CPU_DATA);

    while(TRUE)
    {
        ulDstAddr = (prcl->top * lDelta) + PELS_TO_BYTES(prcl->left);
        cx = prcl->right  - prcl->left;
        cy = prcl->bottom - prcl->top;

        CP_IO_WAIT_FOR_BLT_COMPLETE(ppdev, pjPorts);

        CP_IO_XCNT(ppdev, pjPorts, PELS_TO_BYTES(cx) - 1);
        CP_IO_YCNT(ppdev, pjPorts, cy - 1);
        CP_IO_DST_ADDR(ppdev, pjPorts, ulDstAddr);

        cjSrc = PELS_TO_BYTES(cx);
        pjSrc = pjSrcScan0 + (prcl->top  + dy) * lSrcDelta
                           + (PELS_TO_BYTES(prcl->left + dx));

        CP_IO_START_BLT(ppdev, pjPorts);
        vImageTransfer(ppdev, pjSrc, lSrcDelta, cjSrc, cy);

        if (--c == 0)
            return;

        prcl++;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\cirrus\disp\clioctl.h ===
//---------------------------------------------------------------------------
//
//  file: CLIOCTL.H
//
// (c) Copyright 1993, Cirrus Logic, Inc.
// Copyright (c) 1996-1997  Microsoft Corporation
// Copyright (c) 1996-1997  Cirrus Logic, Inc.,
// All rights reserved.
//
//  date: 1 July 1993
//---------------------------------------------------------------------------
// The maximum GDI ESCAPE value defined in WINGDI.H is 4110(decimal). So here
// we pick an arbitrary value of...
//
// chu01 : 12-16-96 Enable color correction
// myf17 : 10-29-96 supported special Escape call
// myf28 : 01-23-96 supported 755x gamma correction
// jl01  : 02-24-97 Implement Feature Connector's functions


//---------------------------------------------------------------------------
//
// The following macro(CTL_CODE) is defined in WINIOCTL.H. That file states
// that functions 2048-4095 are reserved for "customers". So I picked an
// arbitrary value of 0x900=2304.
//
#define IOCTL_CIRRUS_GET_CAPABILITIES  \
    CTL_CODE(FILE_DEVICE_VIDEO, 0x901, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_CIRRUS_SET_DISPLAY_PITCH \
    CTL_CODE(FILE_DEVICE_VIDEO, 0x902, METHOD_BUFFERED, FILE_ANY_ACCESS)

//
// chu01 : GAMMACORRECT
//
#define IOCTL_CIRRUS_GET_GAMMA_FACTOR \
    CTL_CODE(FILE_DEVICE_VIDEO, 0x908, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_CIRRUS_GET_CONTRAST_FACTOR \
    CTL_CODE(FILE_DEVICE_VIDEO, 0x909, METHOD_BUFFERED, FILE_ANY_ACCESS)

//myf28
#define IOCTL_CIRRUS_GET_755x_GAMMA_FACTOR \
    CTL_CODE(FILE_DEVICE_VIDEO, 0x90A, METHOD_BUFFERED, FILE_ANY_ACCESS)


//---------------------------------------------------------------------------
// Structure for miniport to indicate to display driver the capabilities
// of the chip.  The flag currently indicates HW Cursor and BLT Engine
// support.
//
// Also included is the size of memory, and the top of available offscreen
// memory. (Actually it's top+1).
//
typedef struct {
   ULONG size;              // size of this structure
   ULONG fl;                // see bit description below
   ULONG ulChipId;          // Chip ID read from CR27[7:2] - e.g CL5434 = 0x2A
   ULONG ulMemSize;         // Size of memory in bytes=end of HW cursor buffers
   ULONG ulOffscreenMemTop; // Offset of 1st byte of unusable video memory
                            // [1st byte of cursor buffers on all but 754x]
                            // [1st byte of split screen buffer on 754x]
} CIRRUS_CAPABILITIES, *PCIRRUS_CAPABILITIES;

//#define CL_ALLOW_HW_CURSOR 0x01     // Flag to enable HW Cursor in
//capabilities
//#define CL_BLT_SUPPORT 0x02         // Flag set if chip has BLT Engine
//support
//#define CL_ALLOW_OPAQUE_TEXT 0x04   // Flag to enable HW Cursor in
//capabilities
//#define CL_LINEAR_MODE 0x08         // Flag set if addressing mode is linear
//#define CL_CURSOR_VERT_EXP 0x10     // Flag set if 8x6 panel, 6x4 resolution
//#define CL_DSTN_PANEL      0x20     // Flag set if DSTN panel connect

//---------------------------------------------------------------------------
//
// this is the structure used to pass arguments to the CIRRUS_PRIVATE_ESCAPE
// call done in DrvEscape(). The size of this struct limits the size of the
// returned arguments also. See the DrvEscape() function in enable.c (in the
// display driver DLL) for more information.
//
// NOTE: to enable the definition of these parameters, the following sequence
//       is recommended!
//
// #define ENABLE_BIOS_ARGUMENTS    // put this before the include
// #include "clioctl.h"


#ifdef ENABLE_BIOS_ARGUMENTS

typedef struct _VIDEO_X86_BIOS_ARGUMENTS {
    ULONG Eax;
    ULONG Ebx;
    ULONG Ecx;
    ULONG Edx;
    ULONG Esi;
    ULONG Edi;
    ULONG Ebp;
} VIDEO_X86_BIOS_ARGUMENTS, *PVIDEO_X86_BIOS_ARGUMENTS;

#endif

//---------------------------------------------------------------------------

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\cirrus\disp\ddraw.c ===
/******************************************************************************\
*
* Copyright (c) 1996-1997  Microsoft Corporation.
* Copyright (c) 1996-1997  Cirrus Logic, Inc.
*
* Module Name:
*
*    D    D    R    A    W  .  C
*
*
* Implements all the DirectDraw components for the driver.
*
*
* $Log:   S:/projects/drivers/ntsrc/display/ddraw.c_v  $
 *
 *    Rev 1.14   07 Apr 1997 11:37:02   PLCHU
 *
 *
 *    Rev 1.13   Apr 03 1997 15:38:44   unknown
 *
*
 *
 *    Rev 1.10   Jan 14 1997 15:15:12   unknown
 * Add new double clock detecting method.
 *
 *    Rev 1.8   Jan 08 1997 11:23:34   unknown
 * Add 2x clock support and double scan line counter support
 *
 *    Rev 1.7   Dec 17 1996 18:31:12   unknown
 * Update the bandwidth equation again.
 *
 *    Rev 1.6   Dec 13 1996 12:15:04   unknown
 * update bandwith equation.
 *
 *    Rev 1.5   Dec 12 1996 11:09:52   unknown
 * Add double scan line counter support
 *
 *    Rev 1.5   Dec 12 1996 11:02:12   unknown
 * Add double scan line counter support.
 *
 *    Rev 1.5   Nov 26 1996 14:29:58   unknown
 * Turn off the video window before the moving and then turn it on.
 *
 *    Rev 1.4   Nov 25 1996 14:39:32   unknown
 * Fixed AVI file playback and 16bpp transparent Blt bugs.
 *
 *    Rev 1.4   Nov 18 1996 13:58:58   JACKIEC
 *
*
*    Rev 1.3   Nov 07 1996 16:47:56   unknown
*
*
*    Rev 1.2   Oct 16 1996 14:41:04   unknown
* NT 3.51 does not have DDRAW support, So turn off overlay.h in NT 3.51
*
*    Rev 1.1   Oct 10 1996 15:36:28   unknown
*
*
*    Rev 1.10   12 Aug 1996 16:51:04   frido
* Added NT 3.5x/4.0 auto detection.
*
*    Rev 1.9   06 Aug 1996 18:37:12   frido
* DirectDraw works! Video mapping is the key!
*
*    Rev 1.8   24 Jul 1996 14:38:44   frido
* Cleaned up font cache after DirectDraw is done.
*
*    Rev 1.7   24 Jul 1996 14:30:04   frido
* Added a call to destroy all cached fonts to make more room.
*
*    Rev 1.6   20 Jul 1996 00:00:44   frido
* Fixed filling of DirectDraw in 24-bpp.
* Changed off-screen alignment to 4 bytes.
* Added compile switch to manage DirectDraw support in 24-bpp.
*
*    Rev 1.5   16 Jul 1996 18:55:22   frido
* Fixed DirectDraw in 24-bpp mode.
*
*    Rev 1.4   15 Jul 1996 18:03:22   frido
* Changed CP_MM_DST_ADDR to CP_MM_DST_ADDR_ABS.
*
*    Rev 1.3   15 Jul 1996 10:58:28   frido
* Changed back to S3 base.
*
*    Rev 1.1   09 Jul 1996 14:52:30   frido
* Only support chips 5436 and 5446.
*
*    Rev 1.0   03 Jul 1996 13:53:02   frido
* Ported from S3 DirectDraw code.
*
* jl01  10-08-96  Do Transparent BLT w/o Solid Fill.  Refer to PDRs#5511/6817.
*
* chu01 11-17-96  For 24-bpp, aligned destination boundary/size values are
*                 wrong.  Refer to PDR#7312.
*
* sge01 11-19-96  Write CR37 at last For 5480.
*
*
* sge02 11-21-96  We have to set the Color Expand Width even in
*                 non-expand transparency mode.
*
*
* sge03 12-04-96  Add double scan line counter support .
*
* sge04 12-13-96  Change bandwidth for 5446BE and later chips.
*
* sge05 01-07-97  Use dword align for double clock mode.
*
* chu02 01-08-97  Disable ActiveX/Active Movie Player for interlaced modes.
*                 Refer to PDR#7312, 7866.
*
* jc01  10-18-96  Port Microsoft recent change.
* tao1  10-21-96  Added direct draw support for CL-GD7555.
* myf21 11-21-96  Change CAPS_IS_7555 to check ppdev->ulChipID
*
* sge06 01-27-97  Extend VCLK Denominator to 7 bits from 5 bits.
* sge07 02-13-97  Use replication when in 1280x1024x8 mode.
* myf31 02-24-97  Fixed enable HW Video, panning scrolling enable,screen move
*                 video window have follow moving
* chu03 03-26-97  Bandwidth eqution for the CL-GD5480.
* myf33 :03-31-97 : Fixed PDR #8709, read true VCLK in getVCLK()
*                   & panning scrolling enable, support HW Video
* chu04 04-02-97  No matterwhat color depth is, always turn on COLORKEY and
*                 SRCBLT in the DD/DD colorkey capabilities for the 5480.
*
\******************************************************************************/

#include "PreComp.h"
#if DIRECTDRAW
#include "overlay.h"

LONG MIN_OLAY_WIDTH = 4;

//#define ONLY54x6    // Comment this line out if DirectDraw should be 'generic'

// The next flag controls DirectDraw support in 24-bpp.
#define DIRECTX_24        2    // 0 - no support
                               // 1 - blt support, no heap (flip)
                               // 2 - full support

//
// Some handy macros.
//
#define BLT_BUSY(ppdev, pjBase)  (CP_MM_ACL_STAT(ppdev, pjBase) & 0x01)
#ifdef ONLY54x6
#define BLT_READY(ppdev, pjBase) (!(CP_MM_ACL_STAT(ppdev, pjBase) & 0x10))
#else
#define BLT_READY(ppdev, pjBase) (!(CP_MM_ACL_STAT(ppdev, pjBase) &     \
                                 ((ppdev->flCaps & CAPS_AUTOSTART) ? 0x10 : 0x01)))
#endif

#define NUM_VBLANKS_TO_MEASURE   1
#define NUM_MEASUREMENTS_TO_TAKE 8


/******************************Public*Routine******************************\
*
* DWORD dwGetPaletteEntry
*
\**************************************************************************/

DWORD dwGetPaletteEntry(
PDEV* ppdev,
DWORD iIndex)
{
    BYTE*   pjPorts;
    DWORD   dwRed;
    DWORD   dwGreen;
    DWORD   dwBlue;

    pjPorts = ppdev->pjPorts;

    CP_OUT_BYTE(pjPorts, DAC_PEL_READ_ADDR, iIndex);

    dwRed   = CP_IN_BYTE(pjPorts, DAC_PEL_DATA);
    dwGreen = CP_IN_BYTE(pjPorts, DAC_PEL_DATA);
    dwBlue  = CP_IN_BYTE(pjPorts, DAC_PEL_DATA);

    return((dwRed << 16) | (dwGreen << 8) | (dwBlue));
}

/******************************Public*Routine******************************\
* VOID vGetDisplayDuration
*
* Get the length, in EngQueryPerformanceCounter() ticks, of a refresh cycle.
*
* If we could trust the miniport to return back and accurate value for
* the refresh rate, we could use that.  Unfortunately, our miniport doesn't
* ensure that it's an accurate value.
*
\**************************************************************************/

VOID vGetDisplayDuration(
PDEV* ppdev)
{
    BYTE*    pjPorts;
    DWORD    dwTemp;
    LONG     i, j;
    LONGLONG li;
    LONGLONG liMin;
    LONGLONG aliMeasurement[NUM_MEASUREMENTS_TO_TAKE + 1];

    pjPorts = ppdev->pjPorts;

    memset(&ppdev->flipRecord, 0, sizeof(ppdev->flipRecord));

    // Warm up EngQUeryPerformanceCounter to make sure it's in the working set.
    EngQueryPerformanceCounter(&li);

    // Unfortunately, since NT is a proper multitasking system, we can't just
    // disable interrupts to take an accurate reading. We also can't do anything
    // so goofy as dynamically change our thread's priority to real-time.
    //
    // So we just do a bunch of short measurements and take the minimum.
    //
    // It would be 'okay' if we got a result that's longer than the actual
    // VBlank cycle time -- nothing bad would happen except that the app would
    // run a little slower. We don't want to get a result that's shorter than
    // the actual VBlank cycle time -- that could cause us to start drawing over
    // a frame before the Flip has occured.

    while (CP_IN_BYTE(pjPorts, STATUS_1) & VBLANK_ACTIVE)
        ;
    while (!(CP_IN_BYTE(pjPorts, STATUS_1) & VBLANK_ACTIVE))
        ;

    for (i = 0; i < NUM_MEASUREMENTS_TO_TAKE; i++)
    {
        // We're at the start of the VBlank active cycle!
        EngQueryPerformanceCounter(&aliMeasurement[i]);

        // Okay, so life in a multi-tasking environment isn't all that simple.
        // What if we had taken a context switch just before the above
        // EngQueryPerformanceCounter call, and now were half way through the
        // VBlank inactive cycle? Then we would measure only half a VBlank
        // cycle, which is obviously bad. The worst thing we can do is get a
        // time shorter than the actual VBlank cycle time.
        //
        // So we solve this by making sure we're in the VBlank active time
        // before and after we query the time. If it's not, we'll sync up to the
        // next VBlank (it's okay to measure this period -- it will be
        // guaranteed to be longer than the VBlank cycle and will likely be
        // thrown out when we select the minimum sample). There's a chance that
        // we'll take a context switch and return just before the end of the
        // active VBlank time -- meaning that the actual measured time would be
        // less than the true amount -- but since the VBlank is active less than
        // 1% of the time, this means that we would have a maximum of 1% error
        // approximately 1% of the times we take a context switch. An acceptable
        // risk.
        //
        // This next line will cause us wait if we're no longer in the VBlank
        // active cycle as we should be at this point.
        while (!(CP_IN_BYTE(pjPorts, STATUS_1) & VBLANK_ACTIVE))
            ;

        for (j = 0; j < NUM_VBLANKS_TO_MEASURE; j++)
        {
            while (CP_IN_BYTE(pjPorts, STATUS_1) & VBLANK_ACTIVE)
                ;
            while (!(CP_IN_BYTE(pjPorts, STATUS_1) & VBLANK_ACTIVE))
                ;
        }
    }

    EngQueryPerformanceCounter(&aliMeasurement[NUM_MEASUREMENTS_TO_TAKE]);

    // Use the minimum.
    liMin = aliMeasurement[1] - aliMeasurement[0];

    DISPDBG((2, "Refresh count: %li - %li", 1, (ULONG) liMin));

    for (i = 2; i <= NUM_MEASUREMENTS_TO_TAKE; i++)
    {
        li = aliMeasurement[i] - aliMeasurement[i - 1];

        DISPDBG((2, "               %li - %li", i, (ULONG) li));

        if (li < liMin)
        {
            liMin = li;
        }
    }

    // Round the result:

    ppdev->flipRecord.liFlipDuration =
        (DWORD) (liMin + (NUM_VBLANKS_TO_MEASURE / 2)) / NUM_VBLANKS_TO_MEASURE;

    DISPDBG((2, "Frequency %li.%03li Hz",
             (ULONG) (EngQueryPerformanceFrequency(&li),
                      li / ppdev->flipRecord.liFlipDuration),
             (ULONG) (EngQueryPerformanceFrequency(&li),
                      ((li * 1000) / ppdev->flipRecord.liFlipDuration) % 1000)));

    ppdev->flipRecord.liFlipTime = aliMeasurement[NUM_MEASUREMENTS_TO_TAKE];
    ppdev->flipRecord.bFlipFlag  = FALSE;
    ppdev->flipRecord.fpFlipFrom = 0;

    // sge
    // Get the line on which the VSYNC occurs
    CP_OUT_BYTE(pjPorts, CRTC_INDEX, 0x7);
    dwTemp = (DWORD)CP_IN_BYTE(pjPorts, CRTC_DATA);
    ppdev->dwVsyncLine = ((dwTemp & 0x80) << 2);
    ppdev->dwVsyncLine |= ((dwTemp & 0x04) << 6);
    CP_OUT_BYTE(pjPorts, CRTC_INDEX, 0x10);
    ppdev->dwVsyncLine |= CP_IN_BYTE(pjPorts, CRTC_DATA);
}

/******************************Public*Routine******************************\
* HRESULT dwUpdateFlipStatus
*
* Checks and sees if the most recent flip has occurred.
*
\**************************************************************************/

HRESULT UpdateFlipStatus(PDEV* ppdev, FLATPTR fpVidMem)
{
    BYTE*    pjPorts;
    LONGLONG liTime;

    pjPorts = ppdev->pjPorts;

    if ((ppdev->flipRecord.bFlipFlag) &&
//#jc01        ((fpVidMem == 0) || (fpVidMem == ppdev->flipRecord.fpFlipFrom)))
        ((fpVidMem == 0xffffffff) || (fpVidMem == ppdev->flipRecord.fpFlipFrom))) //#jc01
    {
#if 0 // sge use scanline
        if (CP_IN_BYTE(pjPorts, STATUS_1) & VBLANK_ACTIVE)
        {
            if (ppdev->flipRecord.bWasEverInDisplay)
            {
                ppdev->flipRecord.bHaveEverCrossedVBlank = TRUE;
            }
        }
        else if (!(CP_IN_BYTE(pjPorts, STATUS_1) & DISPLAY_MODE_INACTIVE))
        {
            if( ppdev->flipRecord.bHaveEverCrossedVBlank )
            {
                ppdev->flipRecord.bFlipFlag = FALSE;
                return(DD_OK);
            }
            ppdev->flipRecord.bWasEverInDisplay = TRUE;
        }

        EngQueryPerformanceCounter(&liTime);

        if (liTime - ppdev->flipRecord.liFlipTime
                                <= ppdev->flipRecord.liFlipDuration)
        {
            return(DDERR_WASSTILLDRAWING);
        }
#else
        /*
        * if we aren't in the vertical retrace, we can use the scanline
        * to help decide on what to do
        */
        if( !(CP_IN_BYTE(pjPorts, STATUS_1) & VBLANK_ACTIVE) )
        {
            if( ppdev->flipRecord.bHaveEverCrossedVBlank == FALSE )
            {
                ppdev->flipRecord.bWasEverInDisplay = TRUE;
                if( GetCurrentVLine(ppdev) >= ppdev->flipRecord.dwFlipScanLine )
                {
                    EngQueryPerformanceCounter(&liTime);

                    if (liTime - ppdev->flipRecord.liFlipTime
                                        <= ppdev->flipRecord.liFlipDuration)
                    {
                        return(DDERR_WASSTILLDRAWING);
                    }
                }
            }
        }
        /*
        * in the vertical retrace, scanline is useless
        */
        else
        {
            if( ppdev->flipRecord.bWasEverInDisplay )
            {
                ppdev->flipRecord.bHaveEverCrossedVBlank = TRUE;
//                return DD_OK;
            }
            EngQueryPerformanceCounter(&liTime);
            if (liTime - ppdev->flipRecord.liFlipTime
                                <= ppdev->flipRecord.liFlipDuration)
            {
                return(DDERR_WASSTILLDRAWING);
            }
        }
#endif // endif use scanline
        ppdev->flipRecord.bFlipFlag = FALSE;
    }

    return(DD_OK);
}

/******************************Public*Routine******************************\
* DWORD DdBlt
*
\**************************************************************************/

DWORD DdBlt(
PDD_BLTDATA lpBlt)
{
    PDD_SURFACE_GLOBAL srcSurf;
    PDD_SURFACE_GLOBAL dstSurf;
    PDEV*              ppdev;
    BYTE*              pjBase;
    DWORD              dstOffset;
    DWORD              dstPitch;
    DWORD              dstX, dstY;
    DWORD              dwFlags;
    DWORD              width, height;
    DWORD              srcOffset;
    DWORD              srcPitch;
    DWORD              srcX, srcY;
    ULONG              ulBltCmd;
    DWORD              xExt, yExt;
    DWORD              xDiff, yDiff;

    ppdev   = lpBlt->lpDD->dhpdev;
    pjBase  = ppdev->pjBase;
    dstSurf = lpBlt->lpDDDestSurface->lpGbl;

    // Is a flip in progress?
    if (UpdateFlipStatus(ppdev, dstSurf->fpVidMem) != DD_OK)
    {
        lpBlt->ddRVal = DDERR_WASSTILLDRAWING;
        return(DDHAL_DRIVER_HANDLED);
    }

    dwFlags = lpBlt->dwFlags;

    if (dwFlags & DDBLT_ASYNC)
    {
        // If async, then only work if we won't have to wait on the accelerator
        // to start the command.
        if (!BLT_READY(ppdev, pjBase))
        {
            lpBlt->ddRVal = DDERR_WASSTILLDRAWING;
               return(DDHAL_DRIVER_HANDLED);
        }
    }

    DISPDBG((2, "DdBlt Entered"));

    // Calculate destination parameters.
    dstX      = lpBlt->rDest.left;
    dstY      = lpBlt->rDest.top;
    width     = PELS_TO_BYTES(lpBlt->rDest.right - dstX) - 1;
    height    = (lpBlt->rDest.bottom - dstY) - 1;
    dstPitch  = dstSurf->lPitch;
    dstOffset = (DWORD)(dstSurf->fpVidMem + PELS_TO_BYTES(dstX)
                    + (dstY * dstPitch));

    // Color fill?
    if (dwFlags & DDBLT_COLORFILL)
    {
        ULONG ulBltMode = ENABLE_COLOR_EXPAND
                        | ENABLE_8x8_PATTERN_COPY
                        | ppdev->jModeColor;

        // Wait for the accelerator.
        while (!BLT_READY(ppdev, pjBase))
            ;

        // Program bitblt engine.
        CP_MM_ROP(ppdev, pjBase, HW_P);
        CP_MM_DST_Y_OFFSET(ppdev, pjBase, dstPitch);
        CP_MM_BLT_MODE(ppdev, pjBase, ulBltMode);
        CP_MM_FG_COLOR(ppdev, pjBase, lpBlt->bltFX.dwFillColor);
        if (ppdev->flCaps & CAPS_AUTOSTART)
        {
            CP_MM_BLT_EXT_MODE(ppdev, pjBase, ENABLE_SOLID_FILL);
        }
        else
        {
            CP_MM_SRC_ADDR(ppdev, pjBase, ppdev->ulSolidColorOffset);
        }
        CP_MM_XCNT(ppdev, pjBase, width);
        CP_MM_YCNT(ppdev, pjBase, height);
        CP_MM_DST_ADDR_ABS(ppdev, pjBase, dstOffset);
        CP_MM_START_BLT(ppdev, pjBase);

        lpBlt->ddRVal = DD_OK;
        return(DDHAL_DRIVER_HANDLED);
    }


    // We specified with Our ddCaps.dwCaps that we handle a limited number of
    // commands, and by this point in our routine we've handled everything
    // except DDBLT_ROP. DirectDraw and GDI shouldn't pass us anything else;
    // we'll assert on debug builds to prove this.
    ASSERTDD((dwFlags & DDBLT_ROP) && (lpBlt->lpDDSrcSurface),
        "Expected dwFlags commands of only DDBLT_ASYNC and DDBLT_COLORFILL");

    // Get offset, width, and height for source.
    srcSurf   = lpBlt->lpDDSrcSurface->lpGbl;
    srcX      = lpBlt->rSrc.left;
    srcY      = lpBlt->rSrc.top;
    srcPitch  = srcSurf->lPitch;
    srcOffset = (DWORD)(srcSurf->fpVidMem + PELS_TO_BYTES(srcX)
                    + (srcY * srcPitch));

    /*
     * Account for PackJR.  If the start and the width are not 4 pixel
     * aligned, we need to BLT this by hand.  Otherwsie, if they think
     * they are BLTing 16 bit data, we must adjust the parameters now.
     *
     * This is also a good place to check that YUV BLTs are 2 pixel
     * aligned.
     */
    if (lpBlt->lpDDDestSurface->dwReserved1 & (OVERLAY_FLG_PACKJR | OVERLAY_FLG_YUV422))
    {

        ASSERTDD(0, "Who will get here?");
#if 0  // software blt
        /*
         * Check YUV first.  We can fail this if incorrect because the client
         * should know better (since they are explicitly use YUV).
         */
        if ((lpBlt->lpDDDestSurface->dwReserved1 & OVERLAY_FLG_YUV422) &&
            ((lpBlt->rSrc.left & 0x01) != (lpBlt->rDest.left & 0x01)))
        {
            lpBlt->ddRVal = DDERR_XALIGN;
            return (DDHAL_DRIVER_HANDLED);
        }

        /*
         * If PackJR is wrong, we must make this work ourselves because we
         * may be converting to this w/o the client knowing.
         */
        else if (lpBlt->lpDDDestSurface->dwReserved1 & OVERLAY_FLG_PACKJR)
        {
            if (dwFlags & DDBLT_COLORFILL)
            {
                lpBlt->ddRVal = DDERR_XALIGN;
                return (DDHAL_DRIVER_HANDLED);
            }

            if ((lpBlt->rSrc.left & 0x03) || (lpBlt->rDest.left & 0x03))
            {
                /*
                 * The start doesn't align - we have to do this the slow way
                 */
                PackJRBltAlign ((LPBYTE) ppdev->pjScreen + srcOffset,
                (LPBYTE) ppdev->pjScreen + dstOffset,
                lpBlt->rDest.right - lpBlt->rDest.left,
                lpBlt->rDest.bottom - lpBlt->rDest.top,
                srcPitch, dstPitch);

                lpBlt->ddRVal = DD_OK;
                return (DDHAL_DRIVER_HANDLED);
            }
            else if (lpBlt->rSrc.right & 0x03)
            {
                /*
                 * The end doesn't align - we will do the BLT as normal, but
                 * write the last pixels the slow way
                 */
                if (lpBlt->lpDDDestSurface->dwReserved1 & (OVERLAY_FLG_CONVERT_PACKJR | OVERLAY_FLG_MUST_RASTER))
                {
                    srcPitch  >>= 1;
                    srcOffset = srcSurf->fpVidMem + PELS_TO_BYTES(srcX) + (srcY * srcPitch);
                    dstPitch  >>= 1;
                    dstOffset = dstSurf->fpVidMem + PELS_TO_BYTES(dstX) + (dstY * dstPitch);
                }
                width = ((WORD)lpBlt->rSrc.right & ~0x03) - (WORD)lpBlt->rSrc.left;
                PackJRBltAlignEnd ((LPBYTE) ppdev->pjScreen + srcOffset + width,
                (LPBYTE) ppdev->pjScreen + dstOffset + width,
                lpBlt->rSrc.right & 0x03,
                lpBlt->rDest.bottom - lpBlt->rDest.top, srcPitch, dstPitch);
            }
            else if (lpBlt->lpDDDestSurface->dwReserved1 & (OVERLAY_FLG_CONVERT_PACKJR | OVERLAY_FLG_MUST_RASTER))
            {
                /*
                 * Everything aligns, but we have to re-calculate the start
                 * address and the pitch.
                 */
                srcPitch  >>= 1;
                srcOffset = srcSurf->fpVidMem + PELS_TO_BYTES(srcX) + (srcY * srcPitch);
                dstPitch  >>= 1;
                dstOffset = dstSurf->fpVidMem + PELS_TO_BYTES(dstX) + (dstY * dstPitch);
                width     >>= 1;
            }
        }
#endif
    }

    if ((dstSurf == srcSurf) && (srcOffset < dstOffset))
    {
        // Okay, we have to do the blt bottom-to-top, right-to-left.
        ulBltCmd = DIR_BTRL;
;
        srcOffset += width + (srcPitch * height);
        dstOffset += width + (dstPitch * height);
    }
    else
    {
        // Okay, we have to do the blt top-to-bottom, left-to-right.
        ulBltCmd = DIR_TBLR;
    }

    // Wait for the accelerator.
    while (!BLT_READY(ppdev, pjBase))
        ;

    //
    // What about source color key
    //
    ASSERTDD((!(dwFlags & DDBLT_KEYSRC)), "Do not expected source color key");

    if (dwFlags & DDBLT_KEYSRCOVERRIDE)
    {
        ULONG ulColor;

        //
        // sge02
        //
        ulBltCmd |= ENABLE_TRANSPARENCY_COMPARE | ppdev->jModeColor;
        ulColor = lpBlt->bltFX.ddckSrcColorkey.dwColorSpaceLowValue;
        if (ppdev->cBpp == 1)
        {
            ulColor |= ulColor << 8;
        }
        CP_WRITE_USHORT(pjBase, MM_BLT_COLOR_KEY, ulColor);
    }

	if (   (ulBltCmd & DIR_BTRL)
		&& (ulBltCmd & ENABLE_TRANSPARENCY_COMPARE)
		&& (ppdev->cBpp > 1)
	)
	{
		ulBltCmd &= ~DIR_BTRL;
		xExt = lpBlt->rDest.right - lpBlt->rDest.left;
		yExt = lpBlt->rDest.bottom - lpBlt->rDest.top;
		xDiff = dstX - srcX;
		yDiff = dstY - srcY;

		if (yDiff == 0)
		{
	        srcOffset -= srcPitch * height - 1;
	        dstOffset -= dstPitch * height - 1;

			while (xExt)
			{
				width = PELS_TO_BYTES(min(xDiff, xExt));
				srcOffset -= width;
				dstOffset -= width;

			    while (!BLT_READY(ppdev, pjBase)) ;

			    CP_MM_ROP(ppdev, pjBase, CL_SRC_COPY);
			    CP_MM_BLT_MODE(ppdev, pjBase, ulBltCmd);
			    CP_MM_BLT_EXT_MODE(ppdev, pjBase, 0);
			    CP_MM_SRC_Y_OFFSET(ppdev, pjBase, srcPitch);
			    CP_MM_DST_Y_OFFSET(ppdev, pjBase, dstPitch);
			    CP_MM_XCNT(ppdev, pjBase, width - 1);
			    CP_MM_YCNT(ppdev, pjBase, height);
			    CP_MM_SRC_ADDR(ppdev, pjBase, srcOffset);
			    CP_MM_DST_ADDR_ABS(ppdev, pjBase, dstOffset);
			    CP_MM_START_BLT(ppdev, pjBase);

				xExt -= min(xDiff, xExt);
			}
		}
		else
		{
			srcOffset -= width - srcPitch;
			dstOffset -= width - dstPitch;

			while (yExt)
			{
				height = min(yDiff, yExt);
				srcOffset -= height * srcPitch;
				dstOffset -= height * dstPitch;

			    while (!BLT_READY(ppdev, pjBase)) ;

			    CP_MM_ROP(ppdev, pjBase, CL_SRC_COPY);
			    CP_MM_BLT_MODE(ppdev, pjBase, ulBltCmd);
			    CP_MM_BLT_EXT_MODE(ppdev, pjBase, 0);
			    CP_MM_SRC_Y_OFFSET(ppdev, pjBase, srcPitch);
			    CP_MM_DST_Y_OFFSET(ppdev, pjBase, dstPitch);
			    CP_MM_XCNT(ppdev, pjBase, width);
			    CP_MM_YCNT(ppdev, pjBase, height - 1);
			    CP_MM_SRC_ADDR(ppdev, pjBase, srcOffset);
			    CP_MM_DST_ADDR_ABS(ppdev, pjBase, dstOffset);
			    CP_MM_START_BLT(ppdev, pjBase);

				yExt -= min(yDiff, yExt);
			}
		}
	}

	else
	{
	    CP_MM_ROP(ppdev, pjBase, CL_SRC_COPY);
	    CP_MM_BLT_MODE(ppdev, pjBase, ulBltCmd);
	    CP_MM_BLT_EXT_MODE(ppdev, pjBase, 0);                // jl01
	    CP_MM_SRC_Y_OFFSET(ppdev, pjBase, srcPitch);
	    CP_MM_DST_Y_OFFSET(ppdev, pjBase, dstPitch);
	    CP_MM_XCNT(ppdev, pjBase, width);
	    CP_MM_YCNT(ppdev, pjBase, height);
	    CP_MM_SRC_ADDR(ppdev, pjBase, srcOffset);
	    CP_MM_DST_ADDR_ABS(ppdev, pjBase, dstOffset);
	    CP_MM_START_BLT(ppdev, pjBase);
	}

    lpBlt->ddRVal = DD_OK;
    return(DDHAL_DRIVER_HANDLED);
}

/******************************Public*Routine******************************\
* DWORD DdFlip
*
\**************************************************************************/

DWORD DdFlip(
PDD_FLIPDATA lpFlip)
{
    PDEV* ppdev;
    BYTE* pjPorts;
    ULONG ulMemoryOffset;
    ULONG ulLowOffset;
    ULONG ulMiddleOffset;
    ULONG ulHighOffset1, ulHighOffset2;

    ppdev    = lpFlip->lpDD->dhpdev;
    pjPorts  = ppdev->pjPorts;

    DISPDBG((2, "DdFlip: %d x %d at %08x(%d, %d) Pitch=%d",
                 lpFlip->lpSurfTarg->lpGbl->wWidth,
                 lpFlip->lpSurfTarg->lpGbl->wHeight,
                 lpFlip->lpSurfTarg->lpGbl->fpVidMem,
                 lpFlip->lpSurfTarg->lpGbl->xHint,
                 lpFlip->lpSurfTarg->lpGbl->yHint,
                 lpFlip->lpSurfTarg->lpGbl->lPitch));

    // Is the current flip still in progress?
    //
    // Don't want a flip to work until after the last flip is done, so we ask
    // for the general flip status and ignore the vmem.
//#jc01    if ((UpdateFlipStatus(ppdev, 0) != DD_OK) ||
    if ((UpdateFlipStatus(ppdev, 0xffffffff) != DD_OK) ||   /* #jc01 */
        (BLT_BUSY(ppdev, ppdev->pjBase)))
    {
        lpFlip->ddRVal = DDERR_WASSTILLDRAWING;
        return(DDHAL_DRIVER_HANDLED);
    }

    ulMemoryOffset = (ULONG)(lpFlip->lpSurfTarg->lpGbl->fpVidMem);
    // Make sure that the border/blanking period isn't active; wait if it is. We
    // could return DDERR_WASSTILLDRAWING in this case, but that will increase
    // the odds that we can't flip the next time.
    while (CP_IN_BYTE(pjPorts, STATUS_1) & DISPLAY_MODE_INACTIVE)
       ;
    DISPDBG((2, "DdFlip Entered"));
#if 1 // OVERLAY #sge
    if (lpFlip->lpSurfCurr->ddsCaps.dwCaps & DDSCAPS_OVERLAY)
    {
        DWORD   dwOffset;
        BYTE    bRegCR3A;
        BYTE    bRegCR3B;
        BYTE    bRegCR3C;
        // Make sure that the overlay surface we're flipping from is
        // currently visible.  If you don't do this check, you'll get
        // really weird results when someone starts up two ActiveMovie
        // or DirectVideo movies simultaneously!

        if (lpFlip->lpSurfCurr->lpGbl->fpVidMem == ppdev->fpVisibleOverlay)
        {
            ppdev->fpVisibleOverlay = ulMemoryOffset;
            /*
            * Determine the offset to the new area.
            */
//            dwOffset = ((ulMemoryOffset - (ULONG)ppdev->pjScreen) + ppdev->sOverlay1.lAdjustSource) >> 2; // sss
            dwOffset = ((ulMemoryOffset + ppdev->sOverlay1.lAdjustSource) >> 2);

            /*
            * Flip the overlay surface by changing CR3A, CR3B, and CR3C
            */
            bRegCR3A = (BYTE) dwOffset & 0xfe;    // Align on word boundary (5446 bug)
            dwOffset >>= 8;
            bRegCR3B = (BYTE) dwOffset;
            dwOffset >>= 8;
            bRegCR3C = (BYTE) (dwOffset & 0x0f);
//            if(GetOverlayFlipStatus(0) != DD_OK || DRAW_ENGINE_BUSY || IN_VBLANK)
//            {
//                lpFlipData->ddRVal = DDERR_WASSTILLDRAWING;
//                return DDHAL_DRIVER_HANDLED;
//            }

            CP_OUT_BYTE(pjPorts, CRTC_INDEX, 0x3C);
            CP_OUT_BYTE(pjPorts, CRTC_DATA, (CP_IN_BYTE(pjPorts, CRTC_DATA) & 0xf0) | bRegCR3C);
            CP_OUT_WORD(pjPorts, CRTC_INDEX, ((WORD)bRegCR3A << 8) | 0x3A);
            CP_OUT_WORD(pjPorts, CRTC_INDEX, ((WORD)bRegCR3B << 8) | 0x3B);
        }
        else
        {
            lpFlip->ddRVal = DDERR_OUTOFCAPS;
            return(DDHAL_DRIVER_HANDLED);
        }
    }
    else
#endif // OVERLAY
    {
        // Do the flip.
        ulMemoryOffset >>= 2;

        ulLowOffset    = 0x0D | ((ulMemoryOffset & 0x0000FF) << 8);
        ulMiddleOffset = 0x0C | ((ulMemoryOffset & 0x00FF00));
        ulHighOffset1  = 0x1B | ((ulMemoryOffset & 0x010000) >> 8)
                              | ((ulMemoryOffset & 0x060000) >> 7)
                              | ppdev->ulCR1B;
        ulHighOffset2  = 0x1D | ((ulMemoryOffset & 0x080000) >> 4)
                              | ppdev->ulCR1D;

        // Too bad that the Cirrus flip can't be done in a single atomic register
        // write; as it is, we stand a small chance of being context-switched out
        // and exactly hitting the vertical blank in the middle of doing these outs,
        // possibly causing the screen to momentarily jump.
        //
        // There are some hoops we could jump through to minimize the chances of
        // this happening; we could try to align the flip buffer such that the minor
        // registers are ensured to be identical for either flip position, ans so
        // that only the high address need be written, an obviously atomic
        // operation.
        //
        // However, I'm simply not going to worry about it.

        CP_OUT_WORD(pjPorts, CRTC_INDEX, ulHighOffset2);
        CP_OUT_WORD(pjPorts, CRTC_INDEX, ulHighOffset1);
        CP_OUT_WORD(pjPorts, CRTC_INDEX, ulMiddleOffset);
        CP_OUT_WORD(pjPorts, CRTC_INDEX, ulLowOffset);
    }
    // Remember where and when we were when we did the flip.
    EngQueryPerformanceCounter(&ppdev->flipRecord.liFlipTime);

    ppdev->flipRecord.bFlipFlag              = TRUE;
    ppdev->flipRecord.bHaveEverCrossedVBlank = FALSE;

    ppdev->flipRecord.fpFlipFrom = lpFlip->lpSurfCurr->lpGbl->fpVidMem;

    if((CP_IN_BYTE(pjPorts, STATUS_1) & VBLANK_ACTIVE))
    {
        ppdev->flipRecord.dwFlipScanLine = 0;
        ppdev->flipRecord.bWasEverInDisplay = FALSE;
    }
    else
    {
        ppdev->flipRecord.dwFlipScanLine = GetCurrentVLine(ppdev);
        ppdev->flipRecord.bWasEverInDisplay = TRUE;
    }

    lpFlip->ddRVal = DD_OK;
    return(DDHAL_DRIVER_HANDLED);
}

/******************************Public*Routine******************************\
* DWORD DdLock
*
\**************************************************************************/

DWORD DdLock(PDD_LOCKDATA lpLock)
{
    PDEV*   ppdev = lpLock->lpDD->dhpdev;
    BYTE*   pjPorts = ppdev->pjPorts;

    // Check to see if any pending physical flip has occurred. Don't allow a
    // lock if a blt is in progress.
    if (UpdateFlipStatus(ppdev, lpLock->lpDDSurface->lpGbl->fpVidMem)
            != DD_OK)
    {
        lpLock->ddRVal = DDERR_WASSTILLDRAWING;
        return(DDHAL_DRIVER_HANDLED);
    }
    if (lpLock->dwFlags & DDLOCK_WAIT)
    {
        CP_MM_WAIT_FOR_BLT_COMPLETE(ppdev, ppdev->pjBase);
    }
    if (BLT_BUSY(ppdev, ppdev->pjBase))
    {
        lpLock->ddRVal = DDERR_WASSTILLDRAWING;
        return(DDHAL_DRIVER_HANDLED);
    }

    /*
     * Force them to use the video apperture
     */
    if ((lpLock->lpDDSurface->dwReserved1 & OVERLAY_FLG_OVERLAY) &&
        (lpLock->dwFlags == DDLOCK_SURFACEMEMORYPTR) &&
		(ppdev->fpBaseOverlay != 0xffffffff))
    {

        if (lpLock->lpDDSurface->dwReserved1 & OVERLAY_FLG_DECIMATE)
        {
            /*
            * Turn on decimation
            */
            CP_OUT_BYTE(pjPorts, CRTC_INDEX, 0x3f);
            CP_OUT_BYTE(pjPorts, CRTC_DATA, CP_IN_BYTE(pjPorts, CRTC_DATA) | 0x10);

        }
        if( lpLock->lpDDSurface->lpGbl->ddpfSurface.dwFourCC == FOURCC_YUY2)
            lpLock->lpSurfData = (LPVOID)(ppdev->fpBaseOverlay + lpLock->lpDDSurface->lpGbl->fpVidMem + 0x400000);
        else
            lpLock->lpSurfData = (LPVOID)(ppdev->fpBaseOverlay + lpLock->lpDDSurface->lpGbl->fpVidMem + 0x400000 * 3);

        // When a driver returns DD_OK and DDHAL_DRIVER_HANDLED from DdLock,
        // DirectDraw expects it to have adjusted the resulting pointer
        // to point to the upper left corner of the specified rectangle, if
        // any:

        if (lpLock->bHasRect)
        {
            lpLock->lpSurfData = (VOID*) ((BYTE*) lpLock->lpSurfData
                + lpLock->rArea.top * lpLock->lpDDSurface->lpGbl->lPitch
                + lpLock->rArea.left
                    * (lpLock->lpDDSurface->lpGbl->ddpfSurface.dwYUVBitCount >> 3));
        }

        lpLock->ddRVal = DD_OK;
        return(DDHAL_DRIVER_HANDLED);
    }
    return(DDHAL_DRIVER_NOTHANDLED);
}

/******************************Public*Routine******************************\
* DWORD DdUnlock
*
\**************************************************************************/

DWORD DdUnlock(PDD_UNLOCKDATA lpUnlock)
{
    PDEV*   ppdev = lpUnlock->lpDD->dhpdev;
    BYTE*   pjPorts = ppdev->pjPorts;

    if ((lpUnlock->lpDDSurface->dwReserved1 & OVERLAY_FLG_YUVPLANAR) &&
        !(lpUnlock->lpDDSurface->dwReserved1 & OVERLAY_FLG_ENABLED))
    {
        CP_OUT_WORD(pjPorts, CRTC_INDEX, (0x00 << 8) | 0x3f);  // Turn off YUV Planar
    }

    else if (lpUnlock->lpDDSurface->dwReserved1 & OVERLAY_FLG_DECIMATE)
    {
        CP_OUT_WORD(pjPorts, CRTC_INDEX, (0x00 << 8) | 0x3f);  // Turn off YUV Planar
    }

    return(DDHAL_DRIVER_NOTHANDLED);
}

/******************************Public*Routine******************************\
* DWORD DdGetBltStatus
*
* Doesn't currently really care what surface is specified, just checks
* and goes.
*
\**************************************************************************/

DWORD DdGetBltStatus(PDD_GETBLTSTATUSDATA lpGetBltStatus)
{
    PDEV*   ppdev;
    HRESULT ddRVal;
    PBYTE   pjBase;

    ppdev  = lpGetBltStatus->lpDD->dhpdev;
    pjBase = ppdev->pjBase;

    ddRVal = DD_OK;
    if (lpGetBltStatus->dwFlags == DDGBS_CANBLT)
    {
        // DDGBS_CANBLT case: can we add a blt?
        ddRVal = UpdateFlipStatus(ppdev, lpGetBltStatus->lpDDSurface->lpGbl->fpVidMem);

        if (ddRVal == DD_OK)
        {
            // There was no flip going on, so can the blitter accept new
            // register writes?
            if (!BLT_READY(ppdev, pjBase))
            {
                ddRVal = DDERR_WASSTILLDRAWING;
            }
        }
    }
    else
    {
        // DDGBS_ISBLTDONE case: is a blt in progress?
        if (BLT_BUSY(ppdev, pjBase))
        {
            ddRVal = DDERR_WASSTILLDRAWING;
        }
    }

    lpGetBltStatus->ddRVal = ddRVal;
    return(DDHAL_DRIVER_HANDLED);
}

/******************************Public*Routine******************************\
* DWORD DdMapMemory
*
* This is a new DDI call specific to Windows NT that is used to map
* or unmap all the application modifiable portions of the frame buffer
* into the specified process's address space.
*
\**************************************************************************/

DWORD DdMapMemory(PDD_MAPMEMORYDATA lpMapMemory)
{
    PDEV*                          ppdev;
    VIDEO_SHARE_MEMORY             ShareMemory;
    VIDEO_SHARE_MEMORY_INFORMATION ShareMemoryInformation;
    DWORD                          ReturnedDataLength;

    ppdev = lpMapMemory->lpDD->dhpdev;

    if (lpMapMemory->bMap)
    {
        ShareMemory.ProcessHandle = lpMapMemory->hProcess;

        // 'RequestedVirtualAddress' isn't actually used for the SHARE IOCTL.
        ShareMemory.RequestedVirtualAddress = 0;

        // We map in starting at the top of the frame buffer.
        ShareMemory.ViewOffset = 0;

        // We map down to the end of the frame buffer.
        //
        // Note: There is a 64k granularity on the mapping (meaning that we
        //       have to round up to 64k).
        //
        // Note: If there is any portion of the frame buffer that must not be
        //       modified by an application, that portion of memory MUST NOT be
        //       mapped in by this call. This would include any data that, if
        //       modified by a malicious application, would cause the driver to
        //       crash. This could include, for example, any DSP code that is
        //       kept in off-screen memory.

        ShareMemory.ViewSize = ROUND_UP_TO_64K(ppdev->cyMemory * ppdev->lDelta + 0x400000 * 3);

        if (EngDeviceIoControl(ppdev->hDriver,
                               IOCTL_VIDEO_SHARE_VIDEO_MEMORY,
                               &ShareMemory,
                               sizeof(VIDEO_SHARE_MEMORY),
                               &ShareMemoryInformation,
                               sizeof(VIDEO_SHARE_MEMORY_INFORMATION),
                               &ReturnedDataLength))
        {
            DISPDBG((0, "Failed IOCTL_VIDEO_SHARE_MEMORY"));

            lpMapMemory->ddRVal = DDERR_GENERIC;
            return(DDHAL_DRIVER_HANDLED);
        }

        lpMapMemory->fpProcess  =(FLATPTR)ShareMemoryInformation.VirtualAddress;
        ppdev->fpBaseOverlay = lpMapMemory->fpProcess;
    }
    else
    {
        ShareMemory.ProcessHandle           = lpMapMemory->hProcess;
        ShareMemory.ViewOffset              = 0;
        ShareMemory.ViewSize                = 0;
        ShareMemory.RequestedVirtualAddress = (VOID*) lpMapMemory->fpProcess;
        //
        // Active movie will unmap memory twice
        //
        //if (ppdev->fpBaseOverlay == lpMapMemory->fpProcess)
        //    ppdev->fpBaseOverlay = 0;

        if (EngDeviceIoControl(ppdev->hDriver,
                               IOCTL_VIDEO_UNSHARE_VIDEO_MEMORY,
                               &ShareMemory,
                               sizeof(VIDEO_SHARE_MEMORY),
                               NULL,
                               0,
                               &ReturnedDataLength))
        {
            RIP("Failed IOCTL_VIDEO_UNSHARE_MEMORY");
        }
    }

    lpMapMemory->ddRVal = DD_OK;
    return(DDHAL_DRIVER_HANDLED);
}

/******************************Public*Routine******************************\
* DWORD DdGetFlipStatus
*
* If the display has gone through one refresh cycle since the flip
* occurred, we return DD_OK.  If it has not gone through one refresh
* cycle we return DDERR_WASSTILLDRAWING to indicate that this surface
* is still busy "drawing" the flipped page.   We also return
* DDERR_WASSTILLDRAWING if the bltter is busy and the caller wanted
* to know if they could flip yet.
*
\**************************************************************************/

DWORD DdGetFlipStatus(
PDD_GETFLIPSTATUSDATA lpGetFlipStatus)
{
    HRESULT ddRVal;
    PDEV*   ppdev = lpGetFlipStatus->lpDD->dhpdev;

    // We don't want a flip to work until after the last flip is done, so we ask
    // for the general flip status and ignore the vmem.

//#jc01    ddRVal = UpdateFlipStatus(ppdev, 0);
    ddRVal = UpdateFlipStatus(ppdev, 0xffffffff);  //#jc01

    // Check if the blitter is busy if someone wants to know if they can flip.
    if ((lpGetFlipStatus->dwFlags == DDGFS_CANFLIP) && (ddRVal == DD_OK))
    {
        if (BLT_BUSY(ppdev, ppdev->pjBase))
        {
            ddRVal = DDERR_WASSTILLDRAWING;
        }
    }

    lpGetFlipStatus->ddRVal = ddRVal;
    return(DDHAL_DRIVER_HANDLED);
}

/******************************Public*Routine******************************\
* DWORD DdWaitForVerticalBlank
*
\**************************************************************************/

DWORD DdWaitForVerticalBlank(
PDD_WAITFORVERTICALBLANKDATA lpWaitForVerticalBlank)
{
    PDEV* ppdev;
    BYTE* pjPorts;

    ppdev    = lpWaitForVerticalBlank->lpDD->dhpdev;
    pjPorts = ppdev->pjPorts;

    lpWaitForVerticalBlank->ddRVal = DD_OK;

    switch (lpWaitForVerticalBlank->dwFlags)
    {
    case DDWAITVB_I_TESTVB:

        // If TESTVB, it's just a request for the current vertical blank status.
        if (CP_IN_BYTE(pjPorts, STATUS_1) & VBLANK_ACTIVE)
            lpWaitForVerticalBlank->bIsInVB = TRUE;
        else
            lpWaitForVerticalBlank->bIsInVB = FALSE;

        return(DDHAL_DRIVER_HANDLED);

    case DDWAITVB_BLOCKBEGIN:

        // If BLOCKBEGIN is requested, we wait until the vertical blank is over,
        // and then wait for the display period to end.
        while (CP_IN_BYTE(pjPorts, STATUS_1) & VBLANK_ACTIVE)
            ;
        while (!(CP_IN_BYTE(pjPorts, STATUS_1) & VBLANK_ACTIVE))
            ;

        return(DDHAL_DRIVER_HANDLED);

    case DDWAITVB_BLOCKEND:

        // If BLOCKEND is requested, we wait for the vblank interval to end.
        while (!(CP_IN_BYTE(pjPorts, STATUS_1) & VBLANK_ACTIVE))
            ;
        while (CP_IN_BYTE(pjPorts, STATUS_1) & VBLANK_ACTIVE)
            ;

        return(DDHAL_DRIVER_HANDLED);
    }

    return(DDHAL_DRIVER_NOTHANDLED);
}

/******************************Public*Routine******************************\
* DWORD DdGetScanLine
*
* Reads the scan line currently being scanned by the CRT.
*
\**************************************************************************/

DWORD DdGetScanLine(
PDD_GETSCANLINEDATA lpGetScanLine)
{
    PDEV*   ppdev;
    BYTE*   pjPorts;

    ppdev   = (PDEV*) lpGetScanLine->lpDD->dhpdev;
    pjPorts = ppdev->pjPorts;

    /*
     * If a vertical blank is in progress the scan line is in
     * indeterminant. If the scan line is indeterminant we return
     * the error code DDERR_VERTICALBLANKINPROGRESS.
     * Otherwise we return the scan line and a success code
     */
    if( CP_IN_BYTE(pjPorts, STATUS_1) & VBLANK_ACTIVE )
    {
        lpGetScanLine->ddRVal = DDERR_VERTICALBLANKINPROGRESS;
    }
    else
    {
        lpGetScanLine->dwScanLine = GetCurrentVLine(ppdev);
        lpGetScanLine->ddRVal = DD_OK;
    }
    return(DDHAL_DRIVER_HANDLED);
}

/******************************Public*Routine******************************\
* DWORD DdCanCreateSurface
*
\**************************************************************************/

DWORD DdCanCreateSurface(
PDD_CANCREATESURFACEDATA lpCanCreateSurface)
{
    PDEV*           ppdev;
    DWORD           dwRet;
    LPDDSURFACEDESC lpSurfaceDesc;

    ppdev = (PDEV*) lpCanCreateSurface->lpDD->dhpdev;
    lpSurfaceDesc = lpCanCreateSurface->lpDDSurfaceDesc;

    dwRet = DDHAL_DRIVER_NOTHANDLED;

    DISPDBG((2, "DdCanCreateSurface Entered"));

    if (!lpCanCreateSurface->bIsDifferentPixelFormat)
    {
        // It's trivially easy to create plain surfaces that are the same
        // type as the primary surface:

        dwRet = DDHAL_DRIVER_HANDLED;
    }

    else if (ppdev->flStatus & STAT_STREAMS_ENABLED)
    {
        // When using the Streams processor, we handle only overlays of
        // different pixel formats -- not any off-screen memory:

        if (lpSurfaceDesc->ddsCaps.dwCaps & DDSCAPS_OVERLAY)
        {
            /*
            * YUV Planar surfaces cannot co-exist with other overlay surfaces.
            */
            if (ppdev->OvlyCnt >= 1)
            {
                lpCanCreateSurface->ddRVal = DDERR_OUTOFCAPS;
                return (DDHAL_DRIVER_HANDLED);
            }
            if ((lpSurfaceDesc->ddpfPixelFormat.dwFourCC == FOURCC_YUVPLANAR) &&
                ppdev->OvlyCnt)
            {
                lpCanCreateSurface->ddRVal = DDERR_INVALIDPIXELFORMAT;
                return (DDHAL_DRIVER_HANDLED);
            }
            else if (ppdev->PlanarCnt)
            {
                lpCanCreateSurface->ddRVal = DDERR_INVALIDPIXELFORMAT;
                return (DDHAL_DRIVER_HANDLED);
            }
            // We handle four types of YUV overlay surfaces:

            if (lpSurfaceDesc->ddpfPixelFormat.dwFlags & DDPF_FOURCC)
            {
                // Check first for a supported YUV type:

                if (lpSurfaceDesc->ddpfPixelFormat.dwFourCC == FOURCC_YUV422)
                {
                    lpSurfaceDesc->ddpfPixelFormat.dwYUVBitCount = 16;
                    dwRet = DDHAL_DRIVER_HANDLED;
                }
                else if ((lpSurfaceDesc->ddpfPixelFormat.dwFourCC == FOURCC_YUY2) &&
                         ((ppdev->ulChipID != 0x40) && (ppdev->ulChipID != 0x4C)) )     //tao1
                {
                    lpSurfaceDesc->ddpfPixelFormat.dwYUVBitCount = 16;
                    dwRet = DDHAL_DRIVER_HANDLED;
                }
                else if (lpSurfaceDesc->ddpfPixelFormat.dwFourCC == FOURCC_PACKJR)
                {
                    if( ppdev->cBitsPerPixel <= 16)
                    {
                        lpSurfaceDesc->ddpfPixelFormat.dwYUVBitCount = 8;
                        dwRet = DDHAL_DRIVER_HANDLED;
                    }
                }
                else if (lpSurfaceDesc->ddpfPixelFormat.dwFourCC == FOURCC_YUVPLANAR)
                {
                    lpSurfaceDesc->ddpfPixelFormat.dwYUVBitCount = 8;
                    dwRet = DDHAL_DRIVER_HANDLED;
                }
            }

            else if (lpSurfaceDesc->ddpfPixelFormat.dwFlags & DDPF_RGB)
            {
                if((lpSurfaceDesc->ddpfPixelFormat.dwFlags & DDPF_PALETTEINDEXED8) &&
                    ppdev->cBitsPerPixel == 16 )
                {
                    dwRet = DDHAL_DRIVER_HANDLED;
                }
                else if (lpSurfaceDesc->ddpfPixelFormat.dwRGBBitCount == 16)
                {
                    dwRet = DDHAL_DRIVER_HANDLED;
                }

            }
        }
    }


    // Print some spew if this was a surface we refused to create:

    if (dwRet == DDHAL_DRIVER_NOTHANDLED)
    {
        if (lpSurfaceDesc->ddpfPixelFormat.dwFlags & DDPF_RGB)
        {
            DISPDBG((0, "Failed creation of %libpp RGB surface %lx %lx %lx",
                lpSurfaceDesc->ddpfPixelFormat.dwRGBBitCount,
                lpSurfaceDesc->ddpfPixelFormat.dwRBitMask,
                lpSurfaceDesc->ddpfPixelFormat.dwGBitMask,
                lpSurfaceDesc->ddpfPixelFormat.dwBBitMask));
        }
        else
        {
            DISPDBG((0, "Failed creation of type 0x%lx YUV 0x%lx surface",
                lpSurfaceDesc->ddpfPixelFormat.dwFlags,
                lpSurfaceDesc->ddpfPixelFormat.dwFourCC));
        }
    }


    lpCanCreateSurface->ddRVal = DD_OK;
    return(dwRet);
}

/******************************Public*Routine******************************\
* DWORD DdCreateSurface
*
\**************************************************************************/

DWORD DdCreateSurface(
PDD_CREATESURFACEDATA lpCreateSurface)
{
    PDEV*               ppdev;
    DD_SURFACE_LOCAL*   lpSurfaceLocal;
    DD_SURFACE_GLOBAL*  lpSurfaceGlobal;
    LPDDSURFACEDESC     lpSurfaceDesc;
    DWORD               dwByteCount;
    LONG                lLinearPitch;
    DWORD               dwHeight;

    ppdev = (PDEV*) lpCreateSurface->lpDD->dhpdev;

    DISPDBG((2, "DdCreateSurface Entered"));
    // On Windows NT, dwSCnt will always be 1, so there will only ever
    // be one entry in the 'lplpSList' array:

    lpSurfaceLocal  = lpCreateSurface->lplpSList[0];
    lpSurfaceGlobal = lpSurfaceLocal->lpGbl;
    lpSurfaceDesc   = lpCreateSurface->lpDDSurfaceDesc;

    // We repeat the same checks we did in 'DdCanCreateSurface' because
    // it's possible that an application doesn't call 'DdCanCreateSurface'
    // before calling 'DdCreateSurface'.

    ASSERTDD(lpSurfaceGlobal->ddpfSurface.dwSize == sizeof(DDPIXELFORMAT),
        "NT is supposed to guarantee that ddpfSurface.dwSize is valid");

    // DdCanCreateSurface already validated whether the hardware supports
    // the surface, so we don't need to do any validation here.  We'll
    // just go ahead and allocate it.
    //
    // Note that we don't do anything special for RGB surfaces that are
    // the same pixel format as the display -- by returning DDHAL_DRIVER_
    // NOTHANDLED, DirectDraw will automatically handle the allocation
    // for us.
    //
    // Also, since we'll be making linear surfaces, make sure the width
    // isn't unreasonably large.
    //
    // Note that on NT, an overlay can be created only if the driver
    // okay's it here in this routine.  Under Win95, the overlay will be
    // created automatically if it's the same pixel format as the primary
    // display.

    if ((lpSurfaceLocal->ddsCaps.dwCaps & DDSCAPS_OVERLAY)   ||
        (lpSurfaceGlobal->ddpfSurface.dwFlags & DDPF_FOURCC) ||
        (lpSurfaceGlobal->ddpfSurface.dwRBitMask != ppdev->flRed))
    {
        if (lpSurfaceGlobal->wWidth <= (DWORD) ppdev->cxMemory)
        {

            lLinearPitch = (lpSurfaceGlobal->wWidth + 7) & ~7;
            if (lpSurfaceGlobal->ddpfSurface.dwFlags & DDPF_FOURCC)
            {
                ASSERTDD((lpSurfaceGlobal->ddpfSurface.dwFourCC == FOURCC_YUV422) ||
                         (lpSurfaceGlobal->ddpfSurface.dwFourCC == FOURCC_YUY2)   ||
                         (lpSurfaceGlobal->ddpfSurface.dwFourCC == FOURCC_PACKJR) ||
                         (lpSurfaceGlobal->ddpfSurface.dwFourCC == FOURCC_YUVPLANAR),
                        "Expected our DdCanCreateSurface to allow only UYVY, YUY2, CLPJ, CLPL");
                if((lpSurfaceGlobal->ddpfSurface.dwFourCC == FOURCC_YUV422) ||
                   (lpSurfaceGlobal->ddpfSurface.dwFourCC == FOURCC_YUY2))
                {
                    dwByteCount = 2;
                    lLinearPitch <<= 1;
                    lpSurfaceLocal->dwReserved1 |= OVERLAY_FLG_YUV422;
                }
                else if((lpSurfaceGlobal->ddpfSurface.dwFourCC == FOURCC_PACKJR))
                {
                    dwByteCount = 1;
                    lpSurfaceLocal->dwReserved1 |= OVERLAY_FLG_PACKJR;
                }
                else if((lpSurfaceGlobal->ddpfSurface.dwFourCC == FOURCC_YUVPLANAR))
                {
                    dwByteCount = 1;
                    lpSurfaceLocal->dwReserved1 |= OVERLAY_FLG_YUVPLANAR;
                }
                else
                {
                    dwByteCount = 1;
                    DISPDBG((1, "Created RGB %libpp: %li x %li Red: %lx",
                        8 * dwByteCount, lpSurfaceGlobal->wWidth, lpSurfaceGlobal->wHeight,
                        lpSurfaceGlobal->ddpfSurface.dwRBitMask));
                }

                // We have to fill in the bit-count for FourCC surfaces:

                lpSurfaceGlobal->ddpfSurface.dwYUVBitCount = 8 * dwByteCount;
                lpSurfaceGlobal->ddpfSurface.dwYBitMask = (DWORD)-1;
                lpSurfaceGlobal->ddpfSurface.dwUBitMask = (DWORD)-1;
                lpSurfaceGlobal->ddpfSurface.dwVBitMask = (DWORD)-1;

                DISPDBG((1, "Created YUV: %li x %li",
                    lpSurfaceGlobal->wWidth, lpSurfaceGlobal->wHeight));
            }
            else
            {
                dwByteCount = lpSurfaceGlobal->ddpfSurface.dwRGBBitCount >> 3;


                if (dwByteCount == 2)
                    lLinearPitch <<= 1;

                DISPDBG((1, "Created RGB %libpp: %li x %li Red: %lx",
                    8 * dwByteCount, lpSurfaceGlobal->wWidth, lpSurfaceGlobal->wHeight,
                    lpSurfaceGlobal->ddpfSurface.dwRBitMask));

            }

            // We want to allocate a linear surface to store the FourCC
            // surface, but DirectDraw is using a 2-D heap-manager because
            // the rest of our surfaces have to be 2-D.  So here we have to
            // convert the linear size to a 2-D size.
            //
            // The stride has to be a dword multiple:

            dwHeight = (lpSurfaceGlobal->wHeight * lLinearPitch
                     + ppdev->lDelta - 1) / ppdev->lDelta;

            // Now fill in enough stuff to have the DirectDraw heap-manager
            // do the allocation for us:

            lpSurfaceGlobal->fpVidMem     = DDHAL_PLEASEALLOC_BLOCKSIZE;
            lpSurfaceGlobal->dwBlockSizeX = ppdev->lDelta; // Specified in bytes
            lpSurfaceGlobal->dwBlockSizeY = dwHeight;
            lpSurfaceGlobal->lPitch       = lLinearPitch;

            lpSurfaceDesc->lPitch   = lLinearPitch;
            lpSurfaceDesc->dwFlags |= DDSD_PITCH;
            lpSurfaceLocal->dwReserved1 |= OVERLAY_FLG_OVERLAY;
            if (lpSurfaceGlobal->ddpfSurface.dwFourCC == FOURCC_YUVPLANAR)
            {
                ppdev->PlanarCnt++;
            }
            else
            {
                ppdev->OvlyCnt++;
            }
            ppdev->fpBaseOverlay = 0xffffffff;
        }
        else
        {
            DISPDBG((1, "Refused to create surface with large width"));
        }
    }

    return(DDHAL_DRIVER_NOTHANDLED);
}

/******************************Public*Routine******************************\
* DWORD DdDestroySurface
*
\**************************************************************************/

DWORD DdDestroySurface (PDD_DESTROYSURFACEDATA lpDestroySurface)
{
    PDEV*   ppdev;
    BYTE*   pjPorts;

    ppdev = (PDEV*) lpDestroySurface->lpDD->dhpdev;
    pjPorts = ppdev->pjPorts;

    DISPDBG((2, "In DestroyOverlaySurface"));
    if (lpDestroySurface->lpDDSurface->dwReserved1 & OVERLAY_FLG_ENABLED)
    {
        BYTE bTemp;
        /*
         * Turn the video off
         */
        DISPDBG((1,"Turning off video in DestroySurface"));
        ppdev->pfnDisableOverlay(ppdev);
        ppdev->pfnClearAltFIFOThreshold(ppdev);

        if (lpDestroySurface->lpDDSurface->dwReserved1 & OVERLAY_FLG_COLOR_KEY)
        {
            CP_OUT_BYTE(pjPorts, CRTC_INDEX, 0x1a);
            bTemp = CP_IN_BYTE(pjPorts, CRTC_DATA);      // Clear CR1A[3:2]
            CP_OUT_BYTE(pjPorts, CRTC_DATA, bTemp & ~0x0C);
        }

        /*
         * Turn off YUV Planar
         */
        if (lpDestroySurface->lpDDSurface->dwReserved1 & OVERLAY_FLG_YUVPLANAR)
        {
            CP_OUT_WORD(pjPorts, CRTC_INDEX, (0x00 << 8) | 0x3f);  // Turn off YUV Planar
        }
        ppdev->fpVisibleOverlay = (FLATPTR)NULL;

        ppdev->dwPanningFlag &= ~OVERLAY_OLAY_SHOW;
    }
    if (lpDestroySurface->lpDDSurface->dwReserved1 & OVERLAY_FLG_YUVPLANAR)
    {
        if (ppdev->PlanarCnt > 0)
            ppdev->PlanarCnt--;
    }
    else
    {
        if (ppdev->OvlyCnt > 0)
            ppdev->OvlyCnt--;
    }

    if (lpDestroySurface->lpDDSurface->ddsCaps.dwCaps & DDSCAPS_LIVEVIDEO)
    {
        BYTE bTemp;
        CP_OUT_BYTE(pjPorts, CRTC_INDEX, 0x51);
        bTemp= CP_IN_BYTE(pjPorts, CRTC_DATA);
        CP_OUT_BYTE(pjPorts, CRTC_DATA, bTemp & ~0x08);
    }

    return(DDHAL_DRIVER_NOTHANDLED);
}

/******************************Public*Routine******************************\
* DWORD DdSetColorKey
*
\**************************************************************************/

DWORD DdSetColorKey(
PDD_SETCOLORKEYDATA lpSetColorKey)
{
    PDEV*               ppdev;
    BYTE*               pjPorts;
    BYTE*               pjBase;
    DD_SURFACE_GLOBAL*  lpSurface;
    DWORD               dwKeyLow;
    DWORD               dwKeyHigh;

    ppdev = (PDEV*) lpSetColorKey->lpDD->dhpdev;

    DISPDBG((2, "DdSetColorKey Entered"));

    ASSERTDD(ppdev->flStatus & STAT_STREAMS_ENABLED, "Shouldn't have hooked call");

    pjPorts  = ppdev->pjPorts;
    pjBase   = ppdev->pjBase;
    lpSurface = lpSetColorKey->lpDDSurface->lpGbl;

    // We don't have to do anything for normal blt source colour keys:

    if (lpSetColorKey->dwFlags & DDCKEY_SRCBLT)
    {
        lpSetColorKey->ddRVal = DD_OK;
        return(DDHAL_DRIVER_HANDLED);
    }
    else if ((lpSetColorKey->dwFlags & DDCKEY_DESTOVERLAY) &&
             (lpSetColorKey->lpDDSurface == ppdev->lpColorSurface))
    {
        if (lpSurface->fpVidMem == ppdev->fpVisibleOverlay)
        {
            ppdev->wColorKey = (WORD) lpSetColorKey->ckNew.dwColorSpaceLowValue;
            ppdev->pfnRegInitVideo(ppdev, lpSetColorKey->lpDDSurface);
        }
        lpSetColorKey->ddRVal = DD_OK;
        return(DDHAL_DRIVER_HANDLED);
    }
    else if ((lpSetColorKey->dwFlags & DDCKEY_SRCOVERLAY) &&
             (lpSetColorKey->lpDDSurface == ppdev->lpSrcColorSurface))
    {
        if (lpSurface->fpVidMem == ppdev->fpVisibleOverlay)
        {
            ppdev->dwSrcColorKeyLow = lpSetColorKey->ckNew.dwColorSpaceLowValue;
            ppdev->dwSrcColorKeyHigh = lpSetColorKey->ckNew.dwColorSpaceHighValue;
            if (ppdev->dwSrcColorKeyLow > ppdev->dwSrcColorKeyHigh)
            {
                ppdev->dwSrcColorKeyHigh = ppdev->dwSrcColorKeyLow;
            }
            ppdev->pfnRegInitVideo(ppdev, lpSetColorKey->lpDDSurface);
        }
        lpSetColorKey->ddRVal = DD_OK;
        return(DDHAL_DRIVER_HANDLED);
    }

    DISPDBG((1, "DdSetColorKey: Invalid command"));
    return(DDHAL_DRIVER_NOTHANDLED);
}

/******************************Public*Routine******************************\
* DWORD DdUpdateOverlay
*
\**************************************************************************/

DWORD DdUpdateOverlay(
PDD_UPDATEOVERLAYDATA lpUpdateOverlay)
{
    PDEV*               ppdev;
    BYTE*               pjPorts;
    BYTE*               pjBase;
    DD_SURFACE_GLOBAL*  lpSource;
    DD_SURFACE_GLOBAL*  lpDestination;
    DWORD               dwStride;
    LONG                srcWidth;
    LONG                srcHeight;
    LONG                dstWidth;
    LONG                dstHeight;
    DWORD               dwBitCount;
    DWORD               dwStart;
    DWORD               dwTmp;
    BOOL                bColorKey;
    DWORD               dwKeyLow;
    DWORD               dwKeyHigh;
    DWORD               dwBytesPerPixel;

    DWORD               dwSecCtrl;
    DWORD               dwBlendCtrl;

    DWORD               dwFourcc;
    BOOL                bCheckBandwidth;
    WORD                wBitCount;
    DWORD_PTR           dwOldStatus;
    BYTE                bTemp;

    ppdev = (PDEV*) lpUpdateOverlay->lpDD->dhpdev;

    DISPDBG((2, "DdUpdateOverlay Entered"));
    ASSERTDD(ppdev->flStatus & STAT_STREAMS_ENABLED, "Shouldn't have hooked call");

    pjPorts = ppdev->pjPorts;
    pjBase  = ppdev->pjBase;

    //myf33 begin
    // Initialize the bandwidth registers
    Regs.bSR2F = 0;
    Regs.bSR32 = 0;
    Regs.bSR34 = 0;
    Regs.bCR42 = 0;
    //myf33 end

    if (lpUpdateOverlay->lpDDSrcSurface->dwFlags & DDRAWISURF_HASPIXELFORMAT)
    {
        GetFormatInfo(ppdev, &(lpUpdateOverlay->lpDDSrcSurface->lpGbl->ddpfSurface),
            &dwFourcc, &wBitCount);
    }
    else
    {
        // This needs to be changed when primary surface is RGB 5:6:5
        dwFourcc = BI_RGB;
        wBitCount = (WORD) ppdev->cBitsPerPixel;
    }

    /*
     * Are we color keying?
     */
    bCheckBandwidth = TRUE;
    ppdev->lpColorSurface = ppdev->lpSrcColorSurface = NULL;
    dwOldStatus = lpUpdateOverlay->lpDDSrcSurface->dwReserved1;
    if ((lpUpdateOverlay->dwFlags & (DDOVER_KEYDEST | DDOVER_KEYDESTOVERRIDE)) &&
        (lpUpdateOverlay->dwFlags & (DDOVER_KEYSRC | DDOVER_KEYSRCOVERRIDE)))
    {
        /*
         * Cannot perform src colorkey and dest colorkey at the same time
         */
        lpUpdateOverlay->ddRVal = DDERR_NOCOLORKEYHW;
        return (DDHAL_DRIVER_HANDLED);
    }
    lpUpdateOverlay->lpDDSrcSurface->dwReserved1 &= ~(OVERLAY_FLG_COLOR_KEY|OVERLAY_FLG_SRC_COLOR_KEY);
    if (lpUpdateOverlay->dwFlags & (DDOVER_KEYDEST | DDOVER_KEYDESTOVERRIDE))
    {
        if (ppdev->pfnIsSufficientBandwidth(ppdev, wBitCount, &(lpUpdateOverlay->rSrc),
            &(lpUpdateOverlay->rDest), OVERLAY_FLG_COLOR_KEY))
        {
            bCheckBandwidth = FALSE;
            lpUpdateOverlay->lpDDSrcSurface->dwReserved1 |= OVERLAY_FLG_COLOR_KEY;
            if (lpUpdateOverlay->dwFlags & DDOVER_KEYDEST)
            {
                ppdev->wColorKey = (WORD)
                    lpUpdateOverlay->lpDDDestSurface->ddckCKDestOverlay.dwColorSpaceLowValue;
                ppdev->lpColorSurface = lpUpdateOverlay->lpDDDestSurface;
            }
            else
            {
                ppdev->wColorKey = (WORD)
                    lpUpdateOverlay->overlayFX.dckDestColorkey.dwColorSpaceLowValue;
            }
        }
        else
        {
            lpUpdateOverlay->ddRVal = DDERR_NOCOLORKEYHW;
            return (DDHAL_DRIVER_HANDLED);
        }
    }
    else if (lpUpdateOverlay->dwFlags & (DDOVER_KEYSRC | DDOVER_KEYSRCOVERRIDE))
    {
        if (ppdev->pfnIsSufficientBandwidth(ppdev, wBitCount, &(lpUpdateOverlay->rSrc),
            &(lpUpdateOverlay->rDest), OVERLAY_FLG_SRC_COLOR_KEY))
        {
            bCheckBandwidth = FALSE;
            lpUpdateOverlay->lpDDSrcSurface->dwReserved1 |= OVERLAY_FLG_SRC_COLOR_KEY;
            ppdev->lpSrcColorSurface = lpUpdateOverlay->lpDDSrcSurface;
            if (lpUpdateOverlay->dwFlags & DDOVER_KEYSRC)
            {
                ppdev->dwSrcColorKeyLow =
                    lpUpdateOverlay->lpDDSrcSurface->ddckCKSrcOverlay.dwColorSpaceLowValue;
                ppdev->dwSrcColorKeyHigh =
                    lpUpdateOverlay->lpDDSrcSurface->ddckCKSrcOverlay.dwColorSpaceHighValue;
            }
            else
            {
                ppdev->dwSrcColorKeyLow =
                    lpUpdateOverlay->overlayFX.dckSrcColorkey.dwColorSpaceLowValue;
                ppdev->dwSrcColorKeyHigh =
                    lpUpdateOverlay->overlayFX.dckSrcColorkey.dwColorSpaceHighValue;
            }
            if (ppdev->dwSrcColorKeyHigh < ppdev->dwSrcColorKeyHigh)
            {
                ppdev->dwSrcColorKeyHigh = ppdev->dwSrcColorKeyLow;
            }
        }
        else
        {
            DISPDBG((0, "Insufficient bandwidth for colorkeying"));
            lpUpdateOverlay->ddRVal = DDERR_NOCOLORKEYHW;
            return (DDHAL_DRIVER_HANDLED);
        }
    }

    // 'Source' is the overlay surface, 'destination' is the surface to
    // be overlayed:

    lpSource = lpUpdateOverlay->lpDDSrcSurface->lpGbl;

    if (lpUpdateOverlay->dwFlags & DDOVER_HIDE)
    {
        if (lpSource->fpVidMem == ppdev->fpVisibleOverlay)
        {
            /*
             * Turn the video off
             */
            ppdev->pfnDisableOverlay(ppdev);
            ppdev->pfnClearAltFIFOThreshold(ppdev);

            /*
             * If we are color keying, we will disable that now
             */
            if (dwOldStatus & OVERLAY_FLG_COLOR_KEY)
            {
                CP_OUT_BYTE(pjPorts, CRTC_INDEX, 0x1a);
                bTemp = CP_IN_BYTE(pjPorts, CRTC_DATA);      // Clear CR1A[3:2]
                CP_OUT_BYTE(pjPorts, CRTC_DATA, bTemp & ~0x0C);
            }

            ppdev->dwPanningFlag &= ~OVERLAY_OLAY_SHOW;
            lpUpdateOverlay->lpDDSrcSurface->dwReserved1 &= ~OVERLAY_FLG_ENABLED;
            ppdev->fpVisibleOverlay = 0;
        }

        lpUpdateOverlay->ddRVal = DD_OK;
        return(DDHAL_DRIVER_HANDLED);
    }
    // Dereference 'lpDDDestSurface' only after checking for the DDOVER_HIDE
    // case:
#if 0
    /*
     * Turn the video off first to protect side effect when moving.
     * Later RegIniVideo will turn it on if needed.
     */
    CP_OUT_BYTE(pjPorts, CRTC_INDEX, 0x3e);
    bTemp = CP_IN_BYTE(pjPorts, CRTC_DATA);
    CP_OUT_BYTE(pjPorts, CRTC_DATA, bTemp & ~0x01);  // Clear CR3E[0]
#endif

    lpDestination = lpUpdateOverlay->lpDDDestSurface->lpGbl;

    if (lpSource->fpVidMem != ppdev->fpVisibleOverlay)
    {
        if (lpUpdateOverlay->dwFlags & DDOVER_SHOW)
        {
            if (ppdev->fpVisibleOverlay != 0)
            {
                // Some other overlay is already visible:

                DISPDBG((0, "DdUpdateOverlay: An overlay is already visible"));

                lpUpdateOverlay->ddRVal = DDERR_OUTOFCAPS;
                return(DDHAL_DRIVER_HANDLED);
            }
            else
            {
                // We're going to make the overlay visible, so mark it as
                // such:

                ppdev->fpVisibleOverlay = lpSource->fpVidMem;
            }
        }
        else
        {
            // The overlay isn't visible, and we haven't been asked to make
            // it visible, so this call is trivially easy:

            lpUpdateOverlay->ddRVal = DD_OK;
            return(DDHAL_DRIVER_HANDLED);
        }
    }

    /*
     * Is there sufficient bandwidth to work?
     */
    if (bCheckBandwidth && !ppdev->pfnIsSufficientBandwidth(ppdev, wBitCount,
        &(lpUpdateOverlay->rSrc), &(lpUpdateOverlay->rDest), 0))
    {
        lpUpdateOverlay->ddRVal = DDERR_OUTOFCAPS;
        return (DDHAL_DRIVER_HANDLED);
    }

    /*
     * Save the rectangles
     */
    ppdev->rOverlaySrc  =  lpUpdateOverlay->rSrc;
    ppdev->rOverlayDest =  lpUpdateOverlay->rDest;

    if (lpUpdateOverlay->lpDDSrcSurface->dwReserved1 & OVERLAY_FLG_DECIMATE)
    {
        ppdev->rOverlaySrc.right = ppdev->rOverlaySrc.left +
            ((ppdev->rOverlaySrc.right - ppdev->rOverlaySrc.left) >> 1);
    }

    if (ppdev->rOverlaySrc.right - ppdev->rOverlaySrc.left <= MIN_OLAY_WIDTH)
    {
        lpUpdateOverlay->ddRVal = DDERR_OUTOFCAPS;
        return (DDHAL_DRIVER_HANDLED);
    }

    lpUpdateOverlay->lpDDSrcSurface->dwReserved1 |= OVERLAY_FLG_ENABLED;

    //
    // Assign 5c to 1F when video is on while no color key for 5446BE.
    //
    // sge04
    //if (bCheckBandwidth && ppdev->flCaps & CAPS_SECOND_APERTURE)
    if (ppdev->flCaps & CAPS_SECOND_APERTURE)
        ppdev->lFifoThresh = 0x0E;

    ppdev->pfnRegInitVideo(ppdev, lpUpdateOverlay->lpDDSrcSurface);

    lpUpdateOverlay->ddRVal = DD_OK;
    return(DDHAL_DRIVER_HANDLED);
}

/******************************Public*Routine******************************\
* DWORD DdSetOverlayPosition
*
\**************************************************************************/

DWORD DdSetOverlayPosition(
PDD_SETOVERLAYPOSITIONDATA lpSetOverlayPosition)
{
    PDEV*   ppdev;
    BYTE*   pjPorts;
    BYTE*   pjBase;

    ppdev = (PDEV*) lpSetOverlayPosition->lpDD->dhpdev;
    pjPorts = ppdev->pjPorts;
    pjBase  = ppdev->pjBase;

    DISPDBG((2, "DdSetOverlayPosition Entered"));
    ASSERTDD(ppdev->flStatus & STAT_STREAMS_ENABLED, "Shouldn't have hooked call");

    if(lpSetOverlayPosition->lpDDSrcSurface->lpGbl->fpVidMem == ppdev->fpVisibleOverlay)
    {
        /*
         * Update the rectangles
         */
        ppdev->rOverlayDest.right = (ppdev->rOverlayDest.right - ppdev->rOverlayDest.left)
            + lpSetOverlayPosition->lXPos;
        ppdev->rOverlayDest.left = lpSetOverlayPosition->lXPos;
        ppdev->rOverlayDest.bottom = (ppdev->rOverlayDest.bottom - ppdev->rOverlayDest.top)
            + lpSetOverlayPosition->lYPos;
        ppdev->rOverlayDest.top = lpSetOverlayPosition->lYPos;

//myf29 RegMoveVideo(ppdev, lpSetOverlayPosition->lpDDSrcSurface);
        ppdev->pfnRegMoveVideo(ppdev, lpSetOverlayPosition->lpDDSrcSurface);
    }

    lpSetOverlayPosition->ddRVal = DD_OK;
    return(DDHAL_DRIVER_HANDLED);
}


/******************************************************************************\
*
* Function:     DrvGetDirectDrawInfo
*
* This function returns te capabilities of the DirectDraw implementation. It is
* called twice during the connect phase.
*
* Parameters:   dhpdev            Handle to physical device.
*                pHalInfo        Pointer to a DD_HALINFO structure.
*                pdwNumHeaps        Pointer to a variable that holds the number of
*                                heaps.
*                pvmList            Pointer to the heap array.
*                pdwNumFourCC    Pointer to a variable that holds the number of
*                                FourCC IDs.
*                pdwFourCC        Pointer to FourCC IDs.
*
* Returns:      TRUE if successful.
*
\******************************************************************************/
BOOL DrvGetDirectDrawInfo(
DHPDEV       dhpdev,
DD_HALINFO*  pHalInfo,
DWORD*       pdwNumHeaps,
VIDEOMEMORY* pvmList,
DWORD*       pdwNumFourCC,
DWORD*       pdwFourCC)
{
    BOOL        bCanFlip;
    PDEV*       ppdev = (PPDEV) dhpdev;
    LONGLONG    li;
    OH*         poh;
    RECTL       rSrc, rDest;
    LONG        lZoom;
    BYTE*       pjPorts = ppdev->pjPorts;
    BYTE        bTemp;

    // We may not support DirectDraw on this card.
    if (!(ppdev->flStatus & STAT_DIRECTDRAW))
    {
        return(FALSE);
    }

    DISPDBG((2, "DrvGetDirectDrawInfo Entered"));
    pHalInfo->dwSize = sizeof(DD_HALINFO);

    // Current primary surface attributes. Since HalInfo is zero-initialized by
    // GDI, we only have to fill in the fields which should be non-zero.

    pHalInfo->vmiData.pvPrimary        = ppdev->pjScreen;
    pHalInfo->vmiData.dwDisplayWidth   = ppdev->cxScreen;
    pHalInfo->vmiData.dwDisplayHeight  = ppdev->cyScreen;
    pHalInfo->vmiData.lDisplayPitch    = ppdev->lDelta;
    pHalInfo->vmiData.dwOffscreenAlign = 4;

    pHalInfo->vmiData.ddpfDisplay.dwSize  = sizeof(DDPIXELFORMAT);
    pHalInfo->vmiData.ddpfDisplay.dwFlags = DDPF_RGB;

    pHalInfo->vmiData.ddpfDisplay.dwRGBBitCount = ppdev->cBitsPerPixel;

    if (ppdev->cBpp == 1)
    {
        pHalInfo->vmiData.ddpfDisplay.dwFlags |= DDPF_PALETTEINDEXED8;
    }

    // These masks will be zero at 8bpp.
    pHalInfo->vmiData.ddpfDisplay.dwRBitMask = ppdev->flRed;
    pHalInfo->vmiData.ddpfDisplay.dwGBitMask = ppdev->flGreen;
    pHalInfo->vmiData.ddpfDisplay.dwBBitMask = ppdev->flBlue;

    if (ppdev->cBpp == 4)
    {
        pHalInfo->vmiData.ddpfDisplay.dwRGBAlphaBitMask =
                            ~(ppdev->flRed | ppdev->flGreen | ppdev->flBlue);
    }

    // Set up the pointer to the first available video memory after the primary
    // surface.
    bCanFlip     = FALSE;
    *pdwNumHeaps = 0;

    // Free up as much off-screen memory as possible.
    bMoveAllDfbsFromOffscreenToDibs(ppdev);    // Move all DFBs to DIB.s
    vAssertModeText(ppdev, FALSE);            // Destroy all cached fonts.

    if ((ppdev->ulChipID == CL7555_ID) || (ppdev->ulChipID == CL7556_ID))//myf32
    {
        MIN_OLAY_WIDTH = 16;
#if (_WIN32_WINNT >= 0x0400)
        ppdev->flCaps |= CAPS_VIDEO;
#endif
        ppdev->pfnIsSufficientBandwidth=Is7555SufficientBandwidth;
        ppdev->pfnRegInitVideo=RegInit7555Video;
        ppdev->pfnRegMoveVideo=RegMove7555Video;
        ppdev->pfnDisableOverlay=DisableVideoWindow;
        ppdev->pfnClearAltFIFOThreshold=ClearAltFIFOThreshold;
    }
    else
    {
        ppdev->pfnIsSufficientBandwidth =
            (ppdev->ulChipID != 0xBC) ?
                IsSufficientBandwidth : Is5480SufficientBandwidth ;  // chu03

        ppdev->pfnRegInitVideo=RegInitVideo;
        ppdev->pfnRegMoveVideo=RegMoveVideo;
        ppdev->pfnDisableOverlay=DisableOverlay_544x;
        ppdev->pfnClearAltFIFOThreshold=ClearAltFIFOThreshold_544x;
    }

    // Now simply reserve the biggest chunk for use by DirectDraw.
    poh = ppdev->pohDirectDraw;
#if (DIRECTX_24 < 2)
    if ((poh == NULL) && (ppdev->cBpp != 3))
#else
    if (poh == NULL)
#endif
    {
        LONG cxMax, cyMax;

        cxMax = ppdev->heap.cxMax & ~(HEAP_X_ALIGNMENT - 1);
        cyMax = ppdev->heap.cyMax;

        poh = pohAllocatePermanent(ppdev, cxMax, cyMax);
        if (poh == NULL)
        {
            // Could not allocate all memory, find the biggest area now.
            cxMax = cyMax = 0;
            for (poh = ppdev->heap.ohAvailable.pohNext;
                 poh != &ppdev->heap.ohAvailable; poh = poh->pohNext)
            {
                if ((poh->cx * poh->cy) > (cxMax * cyMax))
                {
                    cxMax = poh->cx & ~(HEAP_X_ALIGNMENT - 1);
                    cyMax = poh->cy;
                }
            }

            poh = pohAllocatePermanent(ppdev, cxMax, cyMax);
        }

        ppdev->pohDirectDraw = poh;
    }

    if (poh != NULL)
    {
        *pdwNumHeaps = 1;

        // Fill in the list of off-screen rectangles if we've been asked to do
        // so.
        if (pvmList != NULL)
        {
            DISPDBG((1, "DirectDraw gets %d x %d surface at (%d, %d)",
                     poh->cx, poh->cy, poh->x, poh->y));

#if 0
            if (PELS_TO_BYTES(poh->cx) != ppdev->lDelta)
            {
#endif
                pvmList->dwFlags  = VIDMEM_ISRECTANGULAR;
                pvmList->fpStart  = poh->xy;
                pvmList->dwWidth  = PELS_TO_BYTES(poh->cx);
                pvmList->dwHeight = poh->cy;
#if 0
            }
            else
            {
                pvmList->dwFlags = VIDMEM_ISLINEAR;
                pvmList->fpStart = poh->xy;
                pvmList->fpEnd   = poh->xy - 1
                    + PELS_TO_BYTES(poh->cx)
                    + poh->cy * ppdev->lDelta;
            }
#endif

            pvmList->ddsCaps.dwCaps = DDSCAPS_OFFSCREENPLAIN;
            if ((poh->cx >= ppdev->cxScreen) && (poh->cy >= ppdev->cyScreen))
            {
                bCanFlip = TRUE;
            }
        }
    }

    // Capabilities supported.
    pHalInfo->ddCaps.dwFXCaps = 0;
    pHalInfo->ddCaps.dwCaps   = DDCAPS_BLT
                              | DDCAPS_BLTCOLORFILL
                              | DDCAPS_READSCANLINE;                                // sge08 add this bit

    pHalInfo->ddCaps.dwCaps2  = DDCAPS2_COPYFOURCC;

    if ( (ppdev->flCaps & CAPS_VIDEO) && (ppdev->cBpp <= 2) )
    {
        pHalInfo->ddCaps.dwCaps    |= DDCAPS_COLORKEY;
        pHalInfo->ddCaps.dwCKeyCaps = DDCKEYCAPS_SRCBLT;
    }

    pHalInfo->ddCaps.ddsCaps.dwCaps = DDSCAPS_OFFSCREENPLAIN
                                    | DDSCAPS_PRIMARYSURFACE;
    if (bCanFlip)
    {
        pHalInfo->ddCaps.ddsCaps.dwCaps |= DDSCAPS_FLIP;
    }

    // FourCCs supported.
    *pdwNumFourCC = 0;

#if 0    // smac - disable overlays due to too many bugs
{

    //
    // Interlaced mode ?
    //
    BOOL Interlaced ;                                                // chu02

    CP_OUT_BYTE(pjPorts, CRTC_INDEX, 0x1a) ;
    Interlaced = CP_IN_BYTE(pjPorts, CRTC_DATA) & 0x01 ;

    //
    // Needs check more later
    //
    if ((ppdev->flCaps & CAPS_VIDEO) && (!Interlaced))               // chu02
        ppdev->flStatus |= STAT_STREAMS_ENABLED;

    if (ppdev->flStatus & STAT_STREAMS_ENABLED)
    {

        /*
         * Are we double clocked?
        */
        ppdev->bDoubleClock = FALSE;
        //
        // use SR7 to check the double clock instead of hidden register
        //
        //
        CP_OUT_BYTE(pjPorts, SR_INDEX, 0x7);
        bTemp = CP_IN_BYTE(pjPorts, SR_DATA);

        if ((((bTemp & 0x0E) == 0x06) && ppdev->cBitsPerPixel == 8) ||
            (((bTemp & 0x0E) == 0x08) && ppdev->cBitsPerPixel == 16))
        {
            ppdev->bDoubleClock = TRUE;
        }

        pHalInfo->vmiData.dwOverlayAlign = 8;

        pHalInfo->ddCaps.dwCaps |= DDCAPS_OVERLAY
                                | DDCAPS_OVERLAYSTRETCH
                                | DDCAPS_OVERLAYFOURCC
                                | DDCAPS_OVERLAYCANTCLIP
                                | DDCAPS_ALIGNSTRIDE;

        pHalInfo->ddCaps.dwFXCaps |= DDFXCAPS_OVERLAYSTRETCHX
                                  | DDFXCAPS_OVERLAYSTRETCHY
                                  | DDFXCAPS_OVERLAYARITHSTRETCHY;

        pHalInfo->ddCaps.dwCKeyCaps |= DDCKEYCAPS_DESTOVERLAY
                                    | DDCKEYCAPS_DESTOVERLAYYUV
                                    | DDCKEYCAPS_DESTOVERLAYONEACTIVE;

        pHalInfo->ddCaps.dwCKeyCaps |= DDCKEYCAPS_SRCOVERLAY
                                    | DDCKEYCAPS_SRCOVERLAYCLRSPACE
                                    | DDCKEYCAPS_SRCOVERLAYCLRSPACEYUV
                                    | DDCKEYCAPS_SRCOVERLAYONEACTIVE
                                    | DDCKEYCAPS_SRCOVERLAYYUV;

        pHalInfo->ddCaps.ddsCaps.dwCaps |= DDSCAPS_OVERLAY;

        *pdwNumFourCC = 3;
        if ((ppdev->ulChipID == 0x40) || (ppdev->ulChipID == 0x4C))   //tao1
            *pdwNumFourCC = 2;                                        //tao1

        if (pdwFourCC)
        {
            pdwFourCC[0] = FOURCC_YUV422;
            pdwFourCC[1] = FOURCC_PACKJR;
            if ((ppdev->ulChipID != 0x40) && (ppdev->ulChipID != 0x4C)) //tao1
                pdwFourCC[2] = FOURCC_YUY2;                             //tao1
        }

        pHalInfo->ddCaps.dwMaxVisibleOverlays = 1;
        pHalInfo->ddCaps.dwCurrVisibleOverlays = 0;
        pHalInfo->ddCaps.dwNumFourCCCodes = 2;
# if 1
        pHalInfo->ddCaps.dwAlignBoundarySrc = 1;
        pHalInfo->ddCaps.dwAlignSizeSrc = 1;
// chu01 sge05
#if 1
        if ((ppdev->cBpp == 3) || ppdev->bDoubleClock )
        {
            pHalInfo->ddCaps.dwAlignBoundaryDest = 4;
            pHalInfo->ddCaps.dwAlignSizeDest = 4;
        }
        else
        {
            pHalInfo->ddCaps.dwAlignBoundaryDest = 1;
            pHalInfo->ddCaps.dwAlignSizeDest = 1;
        }
#else
        pHalInfo->ddCaps.dwAlignBoundaryDest = 1;
        pHalInfo->ddCaps.dwAlignSizeDest = 1;
#endif // 1
        pHalInfo->ddCaps.dwAlignStrideAlign = 8;
        pHalInfo->ddCaps.dwMinOverlayStretch    = 8000;
        pHalInfo->ddCaps.dwMinLiveVideoStretch  = 8000;
        pHalInfo->ddCaps.dwMinHwCodecStretch    = 8000;
        pHalInfo->ddCaps.dwMaxOverlayStretch    = 8000;
        pHalInfo->ddCaps.dwMaxLiveVideoStretch  = 8000;
        pHalInfo->ddCaps.dwMaxHwCodecStretch    = 8000;
        //
        // maybe there are special requirement for VCLK > 85Hz
        //
#endif
        rSrc.left = rSrc.top = 0;
        rSrc.right = 320;
        rSrc.bottom = 240;
        rDest.left = rDest.top = 0;
        rDest.right = 1280;
        rDest.bottom = 960;
        lZoom = 1000;
        do
        {
            rDest.right = (320 * lZoom)/ 1000;
            rDest.bottom = (240 * lZoom)/1000;
            if (ppdev->pfnIsSufficientBandwidth(ppdev, 16, (LPRECTL) &rSrc, (LPRECTL) &rDest, 0))
            {
                DISPDBG((1, "Minimum zoom factor: %d", lZoom));
                pHalInfo->ddCaps.dwMinOverlayStretch    = lZoom;
                pHalInfo->ddCaps.dwMinLiveVideoStretch  = lZoom;
                pHalInfo->ddCaps.dwMinHwCodecStretch    = lZoom;
                lZoom = 4000;
            }
            lZoom += 100;
        } while (lZoom < 4000);
    }
}
#endif // smac

    return(TRUE);
}


/******************************************************************************\
*
* Function:     DrvEnableDirectDraw
*
* Enable DirectDraw. This function is called when an application opens a
* DirectDraw connection.
*
* Parameters:   dhpdev                Handle to physical device.
*                pCallBacks            Pointer to DirectDraw callbacks.
*                pSurfaceCallBacks    Pointer to surface callbacks.
*                pPaletteCallBacks    Pointer to palette callbacks.
*
* Returns:      TRUE if successful.
*
\******************************************************************************/
BOOL DrvEnableDirectDraw(
DHPDEV               dhpdev,
DD_CALLBACKS*        pCallBacks,
DD_SURFACECALLBACKS* pSurfaceCallBacks,
DD_PALETTECALLBACKS* pPaletteCallBacks)
{
    PDEV*    ppdev = (PPDEV) dhpdev;

    pCallBacks->WaitForVerticalBlank = DdWaitForVerticalBlank;
    pCallBacks->MapMemory            = DdMapMemory;
    pCallBacks->GetScanLine          = DdGetScanLine;
    pCallBacks->dwFlags              = DDHAL_CB32_WAITFORVERTICALBLANK
                                     | DDHAL_CB32_MAPMEMORY
                                     | DDHAL_CB32_GETSCANLINE;

    pSurfaceCallBacks->Blt           = DdBlt;
    pSurfaceCallBacks->Flip          = DdFlip;
    pSurfaceCallBacks->Lock          = DdLock;
    pSurfaceCallBacks->GetBltStatus  = DdGetBltStatus;
    pSurfaceCallBacks->GetFlipStatus = DdGetFlipStatus;
    pSurfaceCallBacks->dwFlags       = DDHAL_SURFCB32_BLT
                                     | DDHAL_SURFCB32_FLIP
                                     | DDHAL_SURFCB32_LOCK
                                     | DDHAL_SURFCB32_GETBLTSTATUS
                                     | DDHAL_SURFCB32_GETFLIPSTATUS;

    if (ppdev->flStatus & STAT_STREAMS_ENABLED)
    {
        pCallBacks->CreateSurface             = DdCreateSurface;
        pCallBacks->CanCreateSurface          = DdCanCreateSurface;
        pCallBacks->dwFlags                  |= DDHAL_CB32_CREATESURFACE
                                              | DDHAL_CB32_CANCREATESURFACE;

        pSurfaceCallBacks->SetColorKey        = DdSetColorKey;
        pSurfaceCallBacks->UpdateOverlay      = DdUpdateOverlay;
        pSurfaceCallBacks->SetOverlayPosition = DdSetOverlayPosition;
        pSurfaceCallBacks->DestroySurface     = DdDestroySurface;
        pSurfaceCallBacks->dwFlags           |= DDHAL_SURFCB32_SETCOLORKEY
                                              | DDHAL_SURFCB32_UPDATEOVERLAY
                                              | DDHAL_SURFCB32_SETOVERLAYPOSITION
                                              | DDHAL_SURFCB32_DESTROYSURFACE;

        // The DrvEnableDirectDraw call can occur while we're in full-
        // screen DOS mode.  Do not turn on the streams processor now
        // if that's the case, instead wait until AssertMode switches
        // us back to graphics mode:

    }

    // Note that we don't call 'vGetDisplayDuration' here, for a couple of
    // reasons:
    //
    //  o Because the system is already running, it would be disconcerting
    //    to pause the graphics for a good portion of a second just to read
    //    the refresh rate;
    //  o More importantly, we may not be in graphics mode right now.
    //
    // For both reasons, we always measure the refresh rate when we switch
    // to a new mode.

    return(TRUE);
}

/******************************************************************************\
*
* Function:     DrvDisableDirectDraw
*
* Disable DirectDraw. This function is called when an application closes the
* DirectDraw connection.
*
* Parameters:   dhpdev        Handle to physical device.
*
* Returns:      Nothing.
*
\******************************************************************************/
VOID DrvDisableDirectDraw(
DHPDEV dhpdev)
{
    PDEV* ppdev;
    OH*   poh;

    // DirectDraw is done with the display, so we can go back to using
    // all of off-screen memory ourselves.
    ppdev = (PPDEV) dhpdev;
    poh   = ppdev->pohDirectDraw;

    if (poh)
    {
        DISPDBG((1, "Releasing DirectDraw surface %d x %d at (%d, %d)",
                 poh->cx, poh->cy, poh->x, poh->y));
    }

    pohFree(ppdev, poh);
    ppdev->pohDirectDraw = NULL;

    // Invalidate all cached fonts.
    vAssertModeText(ppdev, TRUE);
}

/******************************************************************************\
*
* Function:     vAssertModeDirectDraw
*
* Perform specific DirectDraw initialization when the screen switches focus
* (from graphics to full screen MS-DOS and vice versa).
*
* Parameters:   ppdev        Pointer to physical device.
*                bEnabled    True if the screen is in graphics mode.
*
* Returns:      Nothing.
*
\******************************************************************************/
VOID vAssertModeDirectDraw(
PDEV* ppdev,
BOOL  bEnabled)
{
}

/******************************************************************************\
*
* Function:     bEnableDirectDraw
*
* Enable DirectDraw. Called from DrvEnableSurface.
*
* Parameters:   ppdev        Pointer to phsyical device.
*
* Returns:      Nothing.
*
\******************************************************************************/
BOOL bEnableDirectDraw(
PDEV* ppdev)
{

    if (DIRECT_ACCESS(ppdev) &&             // Direct access must be enabled.
#if (DIRECTX_24 < 1)
       (ppdev->cBpp != 3) &&                // Turn off DirectDraw in 24-bpp.
#endif
       (ppdev->flCaps & CAPS_ENGINEMANAGED) &&  // Only support CL-GD5436/5446.
       (ppdev->flCaps & CAPS_MM_IO))        // Memory Mapped I/O must be on.
    {
        // We have to preserve the contents of the CR1B and CR1D registers on a
        // page flip.
        CP_OUT_BYTE(ppdev->pjPorts, CRTC_INDEX, 0x1B);
        ppdev->ulCR1B = (CP_IN_BYTE(ppdev->pjPorts, CRTC_DATA) & 0xF2) << 8;
        CP_OUT_BYTE(ppdev->pjPorts, CRTC_INDEX, 0x1D);
        ppdev->ulCR1D = (CP_IN_BYTE(ppdev->pjPorts, CRTC_DATA) & 0x7F) << 8;

        // Accurately measure the refresh rate for later.
        vGetDisplayDuration(ppdev);

        // DirectDraw is all set to be used on this card.
        ppdev->flStatus |= STAT_DIRECTDRAW;

#if 1 // sge
        EnableStartAddrDoubleBuffer(ppdev);
#endif // sge
    }

    return(TRUE);
}

/******************************************************************************\
*
* Function:     vDisableDirectDraw
*
* Disbale DirectDraw. Called from DrvDisableSurface.
*
* Parameters:   ppdev        Pointer to physical device.
*
* Returns:      Nothing.
*
\******************************************************************************/
VOID vDisableDirectDraw(
PDEV* ppdev)
{
}

#if 1 // OVERLAY #sge
/******************************************************************************\
*
* Function:     GetFormatInfo
*
* Get DirectDraw information,
*
* Parameters:   ppdev        Pointer to physical device.
*
* Returns:      Nothing.
*
\******************************************************************************/
VOID GetFormatInfo(PDEV* ppdev, LPDDPIXELFORMAT lpFormat, LPDWORD lpFourcc,
                   LPWORD lpBitCount)
{

    if (lpFormat->dwFlags & DDPF_FOURCC)
    {
        *lpFourcc = lpFormat->dwFourCC;
        if (lpFormat->dwFourCC == BI_RGB)
        {
            *lpBitCount = (WORD) lpFormat->dwRGBBitCount;
#ifdef DEBUG
            if (lpFormat->dwRGBBitCount == 8)
            {
               DISPDBG((1, "Format: RGB 8"));
            }
            else if (lpFormat->dwRGBBitCount == 16)
            {
               DISPDBG ((1,"Format: RGB 5:5:5"));
            }
#endif
        }
        else if (lpFormat->dwFourCC == BI_BITFIELDS)
        {
            if ((lpFormat->dwRGBBitCount != 16) ||
                (lpFormat->dwRBitMask != 0xf800) ||
                (lpFormat->dwGBitMask != 0x07e0) ||
                (lpFormat->dwBBitMask != 0x001f))
            {
                *lpFourcc = (DWORD) -1;
            }
            else
            {
                *lpBitCount = 16;
                DISPDBG((1,"Format: RGB 5:6:5"));
            }
        }
        else
        {
            lpFormat->dwRBitMask = (DWORD) -1;
            lpFormat->dwGBitMask = (DWORD) -1;
            lpFormat->dwBBitMask = (DWORD) -1;
            if (lpFormat->dwFourCC == FOURCC_PACKJR)
            {
                *lpBitCount = 8;
                DISPDBG((1, "Format: CLJR"));
            }
            else if (lpFormat->dwFourCC == FOURCC_YUY2)
            {
                *lpBitCount = 16;
                DISPDBG((1,"Format: YUY2"));
            }
            else
            {
                *lpBitCount = 16;
                DISPDBG((1,"Format: UYVY"));
            }
        }
    }
    else if (lpFormat->dwFlags & DDPF_RGB)
    {
         if (lpFormat->dwRGBBitCount == 8)
         {
              *lpFourcc = BI_RGB;
              DISPDBG((1, "Format: RGB 8"));
         }
         else if ((lpFormat->dwRGBBitCount == 16) &&
              (lpFormat->dwRBitMask == 0xf800) &&
              (lpFormat->dwGBitMask == 0x07e0) &&
              (lpFormat->dwBBitMask == 0x001f))
         {
              *lpFourcc = BI_BITFIELDS;
              DISPDBG((1,"Format: RGB 5:6:5"));
         }
         else if ((lpFormat->dwRGBBitCount == 16) &&
              (lpFormat->dwRBitMask == 0x7C00) &&
              (lpFormat->dwGBitMask == 0x03e0) &&
              (lpFormat->dwBBitMask == 0x001f))
         {
              *lpFourcc = BI_RGB;
              DISPDBG((1,"Format: RGB 5:5:5"));
         }
         else if (((lpFormat->dwRGBBitCount == 24) ||
              (lpFormat->dwRGBBitCount == 32)) &&
              (lpFormat->dwRBitMask == 0xff0000) &&
              (lpFormat->dwGBitMask == 0x00ff00) &&
              (lpFormat->dwBBitMask == 0x0000ff))
         {
              *lpFourcc = BI_RGB;
              DISPDBG((1, "Format: RGB 8:8:8"));
         }
         else
         {
              *lpFourcc = (DWORD) -1;
         }
         *lpBitCount = (WORD) lpFormat->dwRGBBitCount;
    }
    else if (ppdev->cBitsPerPixel == 16)
    {
         *lpFourcc = BI_RGB;
         *lpBitCount = (WORD) lpFormat->dwRGBBitCount;
    }
    else
    {
         *lpFourcc = (DWORD) -1;
    }
}

/**********************************************************
*
*       Name:  RegInitVideo
*
*       Module Abstract:
*       ----------------
*       This function is called to program the video format and
*       the physicall offset of the video data in the frame buffer.
*
*       Output Parameters:
*       ------------------
*       none
*
***********************************************************
*       Author: Shuhua Ge
*       Date:   09/24/96
*
*       Revision History:
*       -----------------
*       WHO             WHEN     WHAT/WHY/HOW
*       ---             ----     ------------
*
*********************************************************/

VOID RegInitVideo(PDEV* ppdev, PDD_SURFACE_LOCAL lpSurface)
{
    DWORD dwTemp;
    DWORD dwFourcc;
    LONG  lPitch;
    LONG  lLeft;
    WORD  wTemp;
    WORD  wBitCount = 0;
    RECTL rVideoRect;
    BYTE  bRegCR31;
    BYTE  bRegCR32;
    BYTE  bRegCR33;
    BYTE  bRegCR34;
    BYTE  bRegCR35;
    BYTE  bRegCR36;
    BYTE  bRegCR37;
    BYTE  bRegCR38;
    BYTE  bRegCR39;
    BYTE  bRegCR3A;
    BYTE  bRegCR3B;
    BYTE  bRegCR3C;
    BYTE  bRegCR3D;
    BYTE  bRegCR3E;
    BYTE  bRegCR5C;
    BYTE  bRegCR5D;
    BYTE  bTemp;
    DWORD dwTemp1;
    BOOL  bOverlayTooSmall = FALSE;
    BYTE*   pjPorts = ppdev->pjPorts;


    /*
     * Determine the format of the video data
     */
    if (lpSurface->dwFlags & DDRAWISURF_HASPIXELFORMAT)
    {
        GetFormatInfo(ppdev, &(lpSurface->lpGbl->ddpfSurface),
            &dwFourcc, &wBitCount);
    }
    else
    {
        // This needs to be changed when primary surface is RGB 5:6:5
        dwFourcc = BI_RGB;
        wBitCount = (WORD) ppdev->cBitsPerPixel;
    }

    rVideoRect = ppdev->rOverlayDest;
    lPitch = lpSurface->lpGbl->lPitch;

    /*
     * Determine value in CR31 (Horizontal Zoom Code)
     */
    if ((ppdev->rOverlayDest.right - ppdev->rOverlayDest.left) ==
        (ppdev->rOverlaySrc.right - ppdev->rOverlaySrc.left))
    {
        /*
         * No zooming is occuring
         */
        bRegCR31 = 0;
    }
    else
    {
        /*
         * The zoom code = (256 * <src width>) / <dest width>
         */
        dwTemp = (DWORD) ((DWORD) (ppdev->rOverlaySrc.right
            - ppdev->rOverlaySrc.left)) *  256;
        if (ppdev->bDoubleClock)
        {
            dwTemp <<= 1;
        }
        dwTemp1= (DWORD) (ppdev->rOverlayDest.right - ppdev->rOverlayDest.left);
        dwTemp= ((2 * dwTemp) + dwTemp1) / (2*dwTemp1);
        bRegCR31= (BYTE) dwTemp;
    }

    /*
     * Determine value in CR32 (Vertical Zoom Code)
     */
    if ((ppdev->rOverlayDest.bottom - ppdev->rOverlayDest.top) ==
        (ppdev->rOverlaySrc.bottom - ppdev->rOverlaySrc.top))
    {
        /*
         * No zooming is occuring
         */
        bRegCR32 = 0;
    }
    else
    {
        /*
         * The zoom code = (256 * <src height>) / <dest height>
         * The -1 is so that it won't mangle the last line by mixing it
         * with garbage data while Y interpolating.
         */
        dwTemp = (DWORD) ((DWORD) ((ppdev->rOverlaySrc.bottom - 1)
            - ppdev->rOverlaySrc.top)) * 256;
        dwTemp /= (DWORD) (ppdev->rOverlayDest.bottom - ppdev->rOverlayDest.top);
        bRegCR32 = (BYTE) dwTemp;
    }

    /*
     * Determine value in CR33 (Region 1 Size)
     */
    wTemp = (WORD) rVideoRect.left;
    if (ppdev->cBitsPerPixel == 8)
    {
        wTemp >>= 2;     // 4 Pixels per DWORD
    }
    else if (ppdev->cBitsPerPixel == 16)
    {
        wTemp >>= 1;     // 2 Pixels per DWORD
    }
    else if (ppdev->cBitsPerPixel == 24)
    {
        wTemp *= 3;
        wTemp /= 4;
    }
    bRegCR33 = (BYTE) wTemp;
    bRegCR36 = (BYTE) (WORD) (wTemp >> 8);

    /*
     * Determine value in CR34 (Region 2 size)
     */
    wTemp = (WORD) (rVideoRect.right - rVideoRect.left);
    if (ppdev->cBitsPerPixel == 8)
    {
        wTemp >>= 2;                           // 4 Pixels per DWORD
    }
    else if (ppdev->cBitsPerPixel == 16)
    {
        wTemp >>= 1;                           // 2 Pixels per DWORD
    }
    else if (ppdev->cBitsPerPixel == 24)
    {
        wTemp *= 3;
        wTemp /= 4;
    }
    bRegCR34 = (BYTE) wTemp;
    wTemp >>= 6;
    bRegCR36 |= (BYTE) (wTemp & 0x0C);

    /*
     * Determine value in CR35 (Region 2 SDSize)
     */
    dwTemp = (DWORD) (rVideoRect.right - rVideoRect.left);
    dwTemp *= (DWORD) (ppdev->rOverlaySrc.right - ppdev->rOverlaySrc.left);
    dwTemp /= (DWORD) (ppdev->rOverlayDest.right - ppdev->rOverlayDest.left);
    wTemp = (WORD) dwTemp;
    if ((dwFourcc == FOURCC_PACKJR) || (wBitCount == 8))
    {
        wTemp >>= 2;                           // 4 Pixels per DWORD
    }
    else
    {
        wTemp >>= 1;                           // 2 Pixels per DWORD
    }
    bRegCR35 = (BYTE) wTemp;
    wTemp >>= 4;
    bRegCR36 |= (BYTE) (wTemp & 0x30);

    //
    // Check double scan line counter feature
    //
    CP_OUT_BYTE(pjPorts, CRTC_INDEX, 0x17);
    bTemp = CP_IN_BYTE(pjPorts, CRTC_DATA);
    if (bTemp & 0x04)
    {
        //
        // Double scan line count
        //
        /*
         * Determine value in CR37 (Vertical Start)
         */
        wTemp = (WORD) rVideoRect.top;
        bRegCR37 = (BYTE)(wTemp >> 1);
        if ( wTemp & 0x01 )
        {
            wTemp >>= 9;
            bRegCR39 = (BYTE) wTemp | 0x10;
            //
            // Odd scan line trigger
            // Hardware has a bug now.
            // So reduce dest end by 1
            //
            wTemp = (WORD) rVideoRect.bottom - 1 - 1;
        }
        else
        {
            wTemp >>= 9;
            bRegCR39 = (BYTE) wTemp;
            /*
             * Determine value in CR38 (Vertical End)
             */
            wTemp = (WORD) rVideoRect.bottom - 1;
        }
        bRegCR38 = (BYTE)(wTemp >> 1);
        if (wTemp & 0x01)
            bRegCR39 |= 0x20;
        wTemp >>= 7;
        bRegCR39 |= (BYTE) (wTemp & 0x0C);
    }
    else
    {
        /*
         * Determine value in CR37 (Vertical Start)
         */
        wTemp = (WORD) rVideoRect.top;
        bRegCR37 = (BYTE) wTemp;
        wTemp >>= 8;
        bRegCR39 = (BYTE) wTemp;

        /*
         * Determine value in CR38 (Vertical End)
         */
        wTemp = (WORD) rVideoRect.bottom - 1;
        bRegCR38 = (BYTE) wTemp;
        wTemp >>= 6;
        bRegCR39 |= (BYTE) (wTemp & 0x0C);
    }
    /*
     * Determine values in CR3A, CR3B, CR3C (Start Address)
     */
    dwTemp = 0;


    if (bRegCR31 != 0)
    {
        //
        // overlay is zoomed, re-initialize zoom factor
        //
        CalculateStretchCode(ppdev->rOverlaySrc.right - ppdev->rOverlaySrc.left,
          ppdev->rOverlayDest.right - ppdev->rOverlayDest.left, ppdev->HorStretchCode);
    }

    //
    // Here, we want to ensure the source rectangle's clipped width is bigger
    // than what the HW can support, sigh!
    //
    if (!bOverlayTooSmall)
    {
        LONG   lSrcPels;

        //
        // compute non-clip amount on right edge
        //
        lSrcPels = rVideoRect.right - rVideoRect.left;

        if (bRegCR31 != 0)         // source is zoomed if non-zero
        {
            WORD  wRightCnt;

            wRightCnt = 0;
            while (lSrcPels > 0)
            {
                lSrcPels -= ppdev->HorStretchCode[wRightCnt];
                if (lSrcPels >= 0)
                {
                    wRightCnt++;
                }
            }
            lSrcPels = (LONG)wRightCnt;
        }

        if ((lSrcPels == 0) || (lSrcPels <= MIN_OLAY_WIDTH))
        {
            bOverlayTooSmall = TRUE;
        }
    }

    lLeft = ppdev->rOverlaySrc.left;
    if (dwFourcc == FOURCC_PACKJR)
    {
        lLeft &= ~0x03;
    }
    else if (dwFourcc == FOURCC_YUV422 || dwFourcc == FOURCC_YUY2 )
    {
        lLeft &= ~0x01;
    }

    //
    // dwTemp has adjusted dest. rect., add in source adjustment
    //
    dwTemp += (ppdev->rOverlaySrc.top * lPitch) + ((lLeft * wBitCount) >>3);

    ppdev->sOverlay1.lAdjustSource = dwTemp;
//    dwTemp += ((BYTE*)lpSurface->lpGbl->fpVidMem - ppdev->pjScreen); // sss
    dwTemp += (DWORD)(lpSurface->lpGbl->fpVidMem);

    bRegCR5D = (BYTE) ((dwTemp << 2) & 0x0C);
    dwTemp >>= 2;
    bRegCR3A = (BYTE) dwTemp & 0xfe;  // Align to even byte (5446 bug)
    dwTemp >>= 8;
    bRegCR3B = (BYTE) dwTemp;
    dwTemp >>= 8;
    bRegCR3C = (BYTE) (dwTemp & 0x0f);

    /*
     * Determine value in CR3D (Address Offset/Pitch)
     */
    wTemp = (WORD) (lPitch >> 3);
    if (lpSurface->dwReserved1 & OVERLAY_FLG_DECIMATE)
    {
        wTemp >>= 1;
    }
    bRegCR3D = (BYTE) wTemp;
    wTemp >>= 3;
    bRegCR3C |= (BYTE) (wTemp & 0x20);

    /*
     * Determine value in CR3E (Master Control Register)
     */
    bRegCR3E = 0;
    if (lpSurface->dwReserved1 & OVERLAY_FLG_ENABLED)
    {
        bRegCR3E = 0x01;
    }
    if (dwFourcc == FOURCC_PACKJR)
    {
        bRegCR3E |= 0x20;          // Always error difuse when using PackJR
    }
    if ((bRegCR32 == 0) || MustLineReplicate (ppdev, lpSurface, wBitCount))
    {
        bRegCR3E |= 0x10;
        lpSurface->dwReserved1 &= ~OVERLAY_FLG_INTERPOLATE;
    }
    else
    {
        lpSurface->dwReserved1 |= OVERLAY_FLG_INTERPOLATE;
    }
    if (dwFourcc == FOURCC_PACKJR)
    {
        bRegCR3E |= 0x02;
    }
    else if (dwFourcc == BI_RGB)
    {
        if (wBitCount == 16)
        {
            bRegCR3E |= 0x08;
        }
        else if (wBitCount == 8)
        {
            bRegCR3E |= 0x04;
        }
    }
    else if (dwFourcc == BI_BITFIELDS)
    {
        bRegCR3E |= 0x0A;
    }

    /*
     * If we are color keying, we will set that up now
     */
    if (lpSurface->dwReserved1 & OVERLAY_FLG_COLOR_KEY)
    {
        bRegCR3E |= 0x80;

        CP_OUT_BYTE(pjPorts, CRTC_INDEX, 0x1a);
        bTemp = CP_IN_BYTE(pjPorts, CRTC_DATA);      // Set CR1A[3:2] to timing ANDed w/ color
        bTemp &= ~0x0C;
        CP_OUT_BYTE(pjPorts, CRTC_DATA, bTemp);

        CP_OUT_BYTE(pjPorts, CRTC_INDEX, 0x1d);       // Clear CR1D[5:4]
        bTemp = CP_IN_BYTE(pjPorts, CRTC_DATA);
        if (ppdev->cBitsPerPixel == 8)
        {
            CP_OUT_BYTE(pjPorts, CRTC_DATA, bTemp & ~0x38);
            CP_OUT_WORD(pjPorts, INDEX_REG, (ppdev->wColorKey << 8) | 0x0c); // Output color to GRC
            CP_OUT_WORD(pjPorts, INDEX_REG, 0x0d);                     // Output color to GRD
        }
        else
        {
            CP_OUT_BYTE(pjPorts, CRTC_DATA, (bTemp & ~0x30) | 0x08);
            CP_OUT_WORD(pjPorts, INDEX_REG, (ppdev->wColorKey << 8) | 0x0c);    // Output color to GRC
            CP_OUT_WORD(pjPorts, INDEX_REG, (ppdev->wColorKey & 0xff00) | 0x0d);// Output color to GRD
        }
    }
    else if (lpSurface->dwReserved1 & OVERLAY_FLG_SRC_COLOR_KEY)
    {
        BYTE bYMax, bYMin, bUMax, bUMin, bVMax, bVMin;

        bRegCR3E |= 0x80;

        CP_OUT_BYTE(pjPorts, CRTC_INDEX, 0x1a);
        bTemp = CP_IN_BYTE(pjPorts, CRTC_DATA);      // Set CR1A[3:2] to timing ANDed w/ color
        bTemp &= ~0x0C;
        CP_OUT_BYTE(pjPorts, CRTC_DATA, bTemp);

        CP_OUT_BYTE(pjPorts, CRTC_INDEX, 0x1d);       // Set CR1D[5:4] to 10
        CP_OUT_BYTE(pjPorts, CRTC_DATA, CP_IN_BYTE(pjPorts, CRTC_DATA) | 0x20);

        /*
         * Determine min/max values
         */
        if ((dwFourcc == FOURCC_YUV422) ||
            (dwFourcc == FOURCC_YUY2) ||
            (dwFourcc == FOURCC_PACKJR))
        {
            bYMax = (BYTE)(DWORD)(ppdev->dwSrcColorKeyHigh >> 16);
            bYMin = (BYTE)(DWORD)(ppdev->dwSrcColorKeyLow >> 16);
            bUMax = (BYTE)(DWORD)((ppdev->dwSrcColorKeyHigh >> 8) & 0xff);
            bUMin = (BYTE)(DWORD)((ppdev->dwSrcColorKeyLow >> 8) & 0xff);
            bVMax = (BYTE)(ppdev->dwSrcColorKeyHigh & 0xff);
            bVMin = (BYTE)(ppdev->dwSrcColorKeyLow & 0xff);
            if (dwFourcc == FOURCC_PACKJR)
            {
                bYMax |= 0x07;
                bUMax |= 0x03;
                bVMax |= 0x03;
                bYMin &= ~0x07;
                bUMin &= ~0x03;
                bVMin &= ~0x03;
            }
        }
        else if ((dwFourcc == 0) && (wBitCount == 16))
        {
            /*
             * RGB 5:5:5
             */
            bYMax = (BYTE)(DWORD)((ppdev->dwSrcColorKeyHigh >> 7) & 0xF8);
            bYMin = (BYTE)(DWORD)((ppdev->dwSrcColorKeyLow >> 7) & 0xF8);
            bUMax = (BYTE)(DWORD)((ppdev->dwSrcColorKeyHigh >> 2) & 0xF8);
            bUMin = (BYTE)(DWORD)((ppdev->dwSrcColorKeyLow >> 2) & 0xF8);
            bVMax = (BYTE)(ppdev->dwSrcColorKeyHigh << 3);
            bVMin = (BYTE)(ppdev->dwSrcColorKeyLow << 3);
            bYMax |= 0x07;
            bUMax |= 0x07;
            bVMax |= 0x07;

        }
        else if (dwFourcc == BI_BITFIELDS)
        {
            /*
             * RGB 5:6:5
             */
            bYMax = (BYTE)(DWORD)((ppdev->dwSrcColorKeyHigh >> 8) & 0xF8);
            bYMin = (BYTE)(DWORD)((ppdev->dwSrcColorKeyLow >> 8) & 0xF8);
            bUMax = (BYTE)(DWORD)((ppdev->dwSrcColorKeyHigh >> 3) & 0xFC);
            bUMin = (BYTE)(DWORD)((ppdev->dwSrcColorKeyLow >> 3) & 0xFC);
            bVMax = (BYTE)(ppdev->dwSrcColorKeyHigh << 3);
            bVMin = (BYTE)(ppdev->dwSrcColorKeyLow << 3);
            bYMax |= 0x07;
            bUMax |= 0x03;
            bVMax |= 0x07;
        }

        CP_OUT_WORD(pjPorts, INDEX_REG, ((WORD)bYMin << 8) | 0x0C);  // GRC
        CP_OUT_WORD(pjPorts, INDEX_REG, ((WORD)bYMax << 8) | 0x0D);  // GRD
        CP_OUT_WORD(pjPorts, INDEX_REG, ((WORD)bUMin << 8) | 0x1C);  // GR1C
        CP_OUT_WORD(pjPorts, INDEX_REG, ((WORD)bUMax << 8) | 0x1D);  // GR1D
        CP_OUT_WORD(pjPorts, INDEX_REG, ((WORD)bVMin << 8) | 0x1E);  // GR1E
        CP_OUT_WORD(pjPorts, INDEX_REG, ((WORD)bVMax << 8) | 0x1F);  // GR1F
    }
    else
    {
        CP_OUT_BYTE(pjPorts, CRTC_INDEX, 0x1a);
        bTemp = CP_IN_BYTE(pjPorts, CRTC_DATA);      // Clear CR1A[3:2]
        CP_OUT_BYTE(pjPorts, CRTC_DATA, bTemp & ~0x0C);
    }

    /*
     * Set up alignment info
     */
    if (ppdev->cBitsPerPixel != 24)
    {
        WORD wXAlign;
        WORD wXSize;

        if (ppdev->cBitsPerPixel == 8)
        {
            wXAlign = (WORD)rVideoRect.left & 0x03;
            wXSize = (WORD)(rVideoRect.right - rVideoRect.left) & 0x03;
        }
        else
        {
            wXAlign = (WORD)(rVideoRect.left & 0x01) << 1;
            wXSize = (WORD)((rVideoRect.right - rVideoRect.left) & 0x01) << 1;
        }
        bRegCR5D |= (BYTE) (wXAlign | (wXSize << 4));
    }
    else
    {
        bRegCR5D = 0;
    }

    /*
     * Set up the FIFO threshold value.  Make sure that the value we use is
     * not less than the default value.
     */
    CP_OUT_BYTE(pjPorts, SR_INDEX, 0x16);
    bTemp = CP_IN_BYTE(pjPorts, SR_DATA) & 0x0f;
    if (bTemp > (ppdev->lFifoThresh & 0x0f))
    {
        ppdev->lFifoThresh = bTemp;
    }
    if (ppdev->lFifoThresh < 0x0f)
    {
        ppdev->lFifoThresh++;      // Eliminates possible errata
    }
    bRegCR5C = 0x10 | ((BYTE) ppdev->lFifoThresh & 0x0f);


    /*
     * Now start programming the registers
     */
    CP_OUT_WORD(pjPorts, CRTC_INDEX, ((WORD) bRegCR31 << 8) | 0x31);   // CR31
    CP_OUT_WORD(pjPorts, CRTC_INDEX, ((WORD) bRegCR32 << 8) | 0x32);   // CR32
    if (lpSurface->dwReserved1 & OVERLAY_FLG_YUVPLANAR)
    {
        CP_OUT_WORD(pjPorts, CRTC_INDEX, ((WORD) 0x10 << 8) | 0x3F);   // CR3F
    }
    CP_OUT_WORD(pjPorts, CRTC_INDEX, ((WORD) bRegCR5C << 8) | 0x5C);   // CR5C

    //
    // disable overlay if overlay is too small to be supported by HW
    //
    if (bOverlayTooSmall)
    {
        bRegCR3E &= ~0x01;                                    // disable overlay
        ppdev->dwPanningFlag |= OVERLAY_OLAY_REENABLE;        // totally clipped
    }
    else
    {
        CP_OUT_WORD(pjPorts, CRTC_INDEX, ((WORD) bRegCR33 << 8) | 0x33);   // CR33
        CP_OUT_WORD(pjPorts, CRTC_INDEX, ((WORD) bRegCR34 << 8) | 0x34);   // CR34
        CP_OUT_WORD(pjPorts, CRTC_INDEX, ((WORD) bRegCR35 << 8) | 0x35);   // CR35
        CP_OUT_WORD(pjPorts, CRTC_INDEX, ((WORD) bRegCR36 << 8) | 0x36);   // CR36
//        CP_OUT_WORD(pjPorts, CRTC_INDEX, ((WORD) bRegCR37 << 8) | 0x37);   // CR37
        CP_OUT_WORD(pjPorts, CRTC_INDEX, ((WORD) bRegCR38 << 8) | 0x38);   // CR38
        CP_OUT_WORD(pjPorts, CRTC_INDEX, ((WORD) bRegCR39 << 8) | 0x39);   // CR39
        CP_OUT_WORD(pjPorts, CRTC_INDEX, ((WORD) bRegCR3A << 8) | 0x3A);   // CR3A
        CP_OUT_WORD(pjPorts, CRTC_INDEX, ((WORD) bRegCR3B << 8) | 0x3B);   // CR3B
        CP_OUT_WORD(pjPorts, CRTC_INDEX, ((WORD) bRegCR3C << 8) | 0x3C);   // CR3C
        CP_OUT_WORD(pjPorts, CRTC_INDEX, ((WORD) bRegCR3D << 8) | 0x3D);   // CR3D
        CP_OUT_WORD(pjPorts, CRTC_INDEX, ((WORD) bRegCR5D << 8) | 0x5D);   // CR5D
        //
        // Write Vertical start first
        //
        CP_OUT_WORD(pjPorts, CRTC_INDEX, ((WORD) bRegCR37 << 8) | 0x37);   // CR37
    }
    CP_OUT_WORD(pjPorts, CRTC_INDEX, ((WORD) bRegCR3E << 8) | 0x3E);   // CR3E
}


/**********************************************************
 *  Name: DisableOverlay_544x
 *
 *  Module Abstract:
 *  ----------------
 *  This is called when an overlay window is totally clipped by
 *  the panning viewport.
 **********************************************************/
VOID DisableOverlay_544x(PDEV* ppdev)
{
    WORD wCR3E;
    BYTE*   pjPorts = ppdev->pjPorts;

    ppdev->dwPanningFlag |= OVERLAY_OLAY_REENABLE;
    CP_OUT_BYTE(pjPorts, CRTC_INDEX,0x3e);            //Video Window Master Control
    wCR3E = CP_IN_WORD(pjPorts, CRTC_INDEX) & ~0x100; //clear bit one
    CP_OUT_WORD(pjPorts, CRTC_INDEX, wCR3E);          //disable overlay window
}


/**********************************************************
 *  Name: EnableOverlay_544x
 *
 *  Module Abstract:
 *  ----------------
 *  Show the overlay window.
 **********************************************************/
VOID EnableOverlay_544x(PDEV* ppdev)
{
    WORD wCR3E;
    BYTE*   pjPorts = ppdev->pjPorts;

    ppdev->dwPanningFlag &= ~OVERLAY_OLAY_REENABLE;
    CP_OUT_BYTE(pjPorts, CRTC_INDEX,0x3e);            //Video Window Master Control
    wCR3E = CP_IN_WORD(pjPorts, CRTC_INDEX) | 0x100;  //clear bit one
    CP_OUT_WORD(pjPorts, CRTC_INDEX, wCR3E);          //disable overlay window
}


/**********************************************************
*
*       Name:  ClearAltFIFOThreshold_544x
*
*       Module Abstract:
*       ----------------
*
*
*       Output Parameters:
*       ------------------
*       none
*
***********************************************************
*       Author: Shuhua Ge
*       Date:   02/03/97
*
*       Revision History:
*       -----------------
*       WHO             WHEN     WHAT/WHY/HOW
*       ---             ----     ------------
*
*********************************************************/
VOID ClearAltFIFOThreshold_544x(PDEV * ppdev)
{
    UCHAR    bTemp;

    BYTE*   pjPorts = ppdev->pjPorts;
    DISPDBG((1, "ClearAltFIFOThreshold"));

    CP_OUT_BYTE(pjPorts, CRTC_INDEX, 0x5c);          // Clear Alt FIFO Threshold
    bTemp = CP_IN_BYTE(pjPorts, CRTC_DATA);
    CP_OUT_BYTE(pjPorts, CRTC_DATA, bTemp & ~0x10);
}

/**********************************************************
*
*       Name:  RegMoveVideo
*
*       Module Abstract:
*       ----------------
*       This function is called to move the video window that has
*       already been programed.
*
*       Output Parameters:
*       ------------------
*       none
*
***********************************************************
*       Author: Shuhua Ge
*       Date:   09/25/96
*
*       Revision History:
*       -----------------
*       WHO             WHEN     WHAT/WHY/HOW
*       ---             ----     ------------
*
*********************************************************/

VOID RegMoveVideo(PDEV* ppdev, PDD_SURFACE_LOCAL lpSurface)
{
    BOOL    bZoomX;
    DWORD   dwTemp;
    DWORD   dwFourcc;
    LONG    lLeft;
    LONG    lPitch;
    WORD    wTemp;
    WORD    wBitCount = 0;
    RECTL   rVideoRect;
    BYTE    bRegCR33;
    BYTE    bRegCR34;
    BYTE    bRegCR35;
    BYTE    bRegCR36;
    BYTE    bRegCR37;
    BYTE    bRegCR38;
    BYTE    bRegCR39;
    BYTE    bRegCR3A;
    BYTE    bRegCR3B;
    BYTE    bRegCR3C;
    BYTE    bRegCR3D;
    BYTE    bRegCR5D;
    BYTE    bTemp;
    BYTE*   pjPorts = ppdev->pjPorts;

    /*
     * Determine the format of the video data
     */
    if (lpSurface->dwFlags & DDRAWISURF_HASPIXELFORMAT)
    {
        GetFormatInfo(ppdev, &(lpSurface->lpGbl->ddpfSurface),
            &dwFourcc, &wBitCount);
    }
    else
    {
        // This needs to be changed when primary surface is RGB 5:6:5
        dwFourcc = BI_RGB;
        wBitCount = (WORD) ppdev->cBitsPerPixel;
    }

    rVideoRect = ppdev->rOverlayDest;
    //
    // rVideoRect is now adjusted and clipped to the panning viewport.
    // Disable overlay if totally clipped by viewport.
    //
    if (((rVideoRect.right - rVideoRect.left) <= 0) ||
        ((rVideoRect.bottom- rVideoRect.top ) <= 0))
    {
       DisableOverlay_544x(ppdev);  // #ew1 cannot display below min. overlay size
       return;
    }

    lPitch = lpSurface->lpGbl->lPitch;

    /*
     * Determine value in CR33 (Region 1 Size)
     */
    wTemp = (WORD) rVideoRect.left;
    if (ppdev->cBitsPerPixel == 8)
    {
        wTemp >>= 2;     // 4 Pixels per DWORD
    }
    else if (ppdev->cBitsPerPixel == 16)
    {
        wTemp >>= 1;     // 2 Pixels per DWORD
    }
    else if (ppdev->cBitsPerPixel == 24)
    {
        wTemp *= 3;
        wTemp /= 4;
    }
    bRegCR33 = (BYTE) wTemp;
    bRegCR36 = (BYTE) (WORD) (wTemp >> 8);

    /*
     * Determine value in CR34 (Region 2 size)
     */
    wTemp = (WORD) (rVideoRect.right - rVideoRect.left);
    if (ppdev->cBitsPerPixel == 8)
    {
        wTemp >>= 2;                           // 4 Pixels per DWORD
    }
    else if (ppdev->cBitsPerPixel == 16)
    {
        wTemp >>= 1;                           // 2 Pixels per DWORD
    }
    else if (ppdev->cBitsPerPixel == 24)
    {
        wTemp *= 3;
        wTemp /= 4;
    }
    bRegCR34 = (BYTE) wTemp;
    wTemp >>= 6;
    bRegCR36 |= (BYTE) (wTemp & 0x0C);

    /*
     * Determine value in CR35 (Region 2SD Size)
     */
    dwTemp = (DWORD) (rVideoRect.right - rVideoRect.left);
    dwTemp *= (DWORD) (ppdev->rOverlaySrc.right - ppdev->rOverlaySrc.left);
    dwTemp /= (DWORD) (ppdev->rOverlayDest.right - ppdev->rOverlayDest.left);
    wTemp = (WORD) dwTemp;
    if ((dwFourcc == FOURCC_PACKJR) || (wBitCount == 8))
    {
        wTemp >>= 2;                           // 4 Pixels per DWORD
    }
    else
    {
        wTemp >>= 1;                           // 2 Pixels per DWORD
    }
    bRegCR35 = (BYTE) wTemp;
    wTemp >>= 4;
    bRegCR36 |= (BYTE) (wTemp & 0x30);

    //
    // Check double scan line counter feature
    //
    CP_OUT_BYTE(pjPorts, CRTC_INDEX, 0x17);
    bTemp = CP_IN_BYTE(pjPorts, CRTC_DATA);
    if (bTemp & 0x04)
    {
        //
        // Double scan line count
        //
        /*
         * Determine value in CR37 (Vertical Start)
         */
        wTemp = (WORD) rVideoRect.top;
        bRegCR37 = (BYTE)(wTemp >> 1);
        if ( wTemp & 0x01 )
        {
            wTemp >>= 9;
            bRegCR39 = (BYTE) wTemp | 0x10;
            //
            // Odd scan line trigger
            // Hardware has a bug now.
            // So reduce dest end by 1
            //
            wTemp = (WORD) rVideoRect.bottom - 1 - 1;
        }
        else
        {
            wTemp >>= 9;
            bRegCR39 = (BYTE) wTemp;
            /*
             * Determine value in CR38 (Vertical End)
             */
            wTemp = (WORD) rVideoRect.bottom - 1;
        }
        bRegCR38 = (BYTE)(wTemp >> 1);
        if (wTemp & 0x01)
            bRegCR39 |= 0x20;
        wTemp >>= 7;
        bRegCR39 |= (BYTE) (wTemp & 0x0C);
    }
    else
    {
        /*
         * Determine value in CR37 (Vertical Start)
        */
        wTemp = (WORD) rVideoRect.top;
        //if (ppdev->bDoubleClock)
        //{
        //    wTemp >>= 1;
        //}
        bRegCR37 = (BYTE) wTemp;
        wTemp >>= 8;
        bRegCR39 = (BYTE) wTemp;

        /*
         * Determine value in CR38 (Vertical End)
        */
        wTemp = (WORD) rVideoRect.bottom - 1;
        //if (ppdev->bDoubleClock)
        //{
        //    wTemp >>= 1;
        //}
        bRegCR38 = (BYTE) wTemp;
        wTemp >>= 6;
        bRegCR39 |= (BYTE) (wTemp & 0x0C);
    }


    /*
     * Determine values in CR3A, CR3B, CR3C (Start Address)
     */
    dwTemp = 0;


    bZoomX = ((ppdev->rOverlayDest.right - ppdev->rOverlayDest.left) !=
             (ppdev->rOverlaySrc.right - ppdev->rOverlaySrc.left));

    if (bZoomX)
    {
       //
       // overlay is zoomed, re-initialize zoom factor
       //
       CalculateStretchCode(ppdev->rOverlaySrc.right - ppdev->rOverlaySrc.left,
          ppdev->rOverlayDest.right - ppdev->rOverlayDest.left, ppdev->HorStretchCode);
    }


    //
    // Here, we want to ensure the source rectangle's clipped width is bigger
    // than what the HW can support, sigh!
    //
//    if (grOverlayDest.right > sData->rViewport.right)
    {
       int   iSrcPels;

       //
       // compute non-clip amount on right edge
       //
       iSrcPels = (int)(rVideoRect.right - rVideoRect.left);

       if (bZoomX)
       {
          WORD  wRightCnt;

          wRightCnt = 0;
          while (iSrcPels > 0)
          {
             iSrcPels -= ppdev->HorStretchCode[wRightCnt];
             if (iSrcPels >= 0)
             {
                wRightCnt++;
             }
          }
          iSrcPels = (int)wRightCnt;
       }

       if ((iSrcPels == 0) || (iSrcPels <= MIN_OLAY_WIDTH))
       {
          DisableOverlay_544x(ppdev);  // cannot display below min. overlay size
          return;
       }
     }


    lLeft = ppdev->rOverlaySrc.left;
    if (dwFourcc == FOURCC_PACKJR)
    {
        lLeft &= ~0x03;
    }
    else if (dwFourcc == FOURCC_YUV422 || dwFourcc == FOURCC_YUY2)
    {
        lLeft &= ~0x01;
    }

    //
    // #ew1 dwTemp has adjusted dest. rect., add in source adjustment
    //
    dwTemp += (ppdev->rOverlaySrc.top * lPitch) + ((lLeft * wBitCount) >>3);

    ppdev->sOverlay1.lAdjustSource = dwTemp;

//    dwTemp += ((BYTE*)lpSurface->lpGbl->fpVidMem - ppdev->pjScreen); // sss
    dwTemp += (DWORD)(lpSurface->lpGbl->fpVidMem);

    bRegCR5D = (BYTE) ((dwTemp << 2) & 0x0C);
    dwTemp >>= 2;
    bRegCR3A = (BYTE) dwTemp & 0xfe;  // Align to even byte (5446 bug)
    dwTemp >>= 8;
    bRegCR3B = (BYTE) dwTemp;
    dwTemp >>= 8;
    bRegCR3C = (BYTE) (dwTemp & 0x0f);

    /*
     * Determine value in CR3D (Address Offset/Pitch)
     */
    wTemp = (WORD) (lPitch >> 3);
    if (lpSurface->dwReserved1 & OVERLAY_FLG_DECIMATE)
    {
        wTemp >>= 1;
    }
    bRegCR3D = (BYTE) wTemp;
    wTemp >>= 3;
    bRegCR3C |= (BYTE) (wTemp & 0x20);

    /*
     * Set up alignment info
     */
    if (ppdev->cBitsPerPixel != 24)
    {
        WORD wXAlign;
        WORD wXSize;

        if (ppdev->cBitsPerPixel == 8)
        {
            wXAlign = (WORD)rVideoRect.left & 0x03;
            wXSize = (WORD)(rVideoRect.right - rVideoRect.left) & 0x03;
        }
        else
        {
            wXAlign = (WORD)(rVideoRect.left & 0x01) << 1;
            wXSize = (WORD)((rVideoRect.right - rVideoRect.left) & 0x01) << 1;
        }
        bRegCR5D |= (BYTE) (wXAlign | (wXSize << 4));
    }

    /*
     * Now we will write the actual register values.
     */
    CP_OUT_WORD(pjPorts, CRTC_INDEX, ((WORD) bRegCR33 << 8) | 0x33);   // CR33
    CP_OUT_WORD(pjPorts, CRTC_INDEX, ((WORD) bRegCR34 << 8) | 0x34);   // CR34
    CP_OUT_WORD(pjPorts, CRTC_INDEX, ((WORD) bRegCR35 << 8) | 0x35);   // CR35
    CP_OUT_WORD(pjPorts, CRTC_INDEX, ((WORD) bRegCR36 << 8) | 0x36);   // CR36
    CP_OUT_WORD(pjPorts, CRTC_INDEX, ((WORD) bRegCR38 << 8) | 0x38);   // CR38
    CP_OUT_WORD(pjPorts, CRTC_INDEX, ((WORD) bRegCR39 << 8) | 0x39);   // CR39
    CP_OUT_WORD(pjPorts, CRTC_INDEX, ((WORD) bRegCR3A << 8) | 0x3A);   // CR3A
    CP_OUT_WORD(pjPorts, CRTC_INDEX, ((WORD) bRegCR3B << 8) | 0x3B);   // CR3B
    CP_OUT_WORD(pjPorts, CRTC_INDEX, ((WORD) bRegCR3C << 8) | 0x3C);   // CR3C
    CP_OUT_WORD(pjPorts, CRTC_INDEX, ((WORD) bRegCR3D << 8) | 0x3D);   // CR3D
    CP_OUT_WORD(pjPorts, CRTC_INDEX, ((WORD) bRegCR5D << 8) | 0x5D);   // CR5D
    CP_OUT_WORD(pjPorts, CRTC_INDEX, ((WORD) bRegCR37 << 8) | 0x37);   // CR37

    if (ppdev->dwPanningFlag & OVERLAY_OLAY_REENABLE)
       EnableOverlay_544x(ppdev);
}


/**********************************************************
*
*       Name:  CalculateStretchCode
*
*       Module Abstract:
*       ----------------
*       This code was originally written by Intel and distributed
*       with the DCI development kit.
*
*       This function takes the zoom factor and determines exactly
*       how many times we need to replicate each row/column.
*
*       Output Parameters:
*       ------------------
*       none
*
***********************************************************
*       Author: Intel
*       Date:   ??/??/??
*
*       Revision History:
*       -----------------
*       WHO             WHEN     WHAT/WHY/HOW
*       ---             ----     ------------
*       Scott MacDonald 10/06/94 Incorporated code into DCI provider.
*
*********************************************************/

VOID CalculateStretchCode (LONG srcLength, LONG dstLength, LPBYTE code)
{
    LONG  dwDeltaX, dwDeltaY, dwConst1, dwConst2, dwP;
    LONG  i, j, k;
    BYTE  bStretchIndex = 0;
    LONG  total = 0;

    /*
     * for some strange reason I'd like to figure out but haven't got time to, the
     * replication code generation seems to have a problem between 1:1 and 2:1 stretch
     * ratios.  Fix is to zero-initialize index (the problem occurs in the first one
     * generated) when stretch is betw. those ratios, and one-initialize it otherwise.
     */
    if ((dstLength <= srcLength * 2L) && (dstLength >= srcLength))
    {
         bStretchIndex = 0;
    }
    else
    {
         bStretchIndex = 1;
    }

    /*
     * initialize code array, to get rid of anything which might have been
     * left over in it.
     */
    for (i = 0; i < srcLength; i++)
    {
         code[i] = 0;
    }

    /*
     * Variable names roughly represent what you will find in any graphics
     * text.  Consult text for an explanation of Bresenham line alg., it's
     * beyond the scope of my comments here.
     */
    dwDeltaX = srcLength;
    dwDeltaY = dstLength;

    if (dstLength < srcLength)
    {
         /*
          * Size is shrinking, use standard Bresenham alg.
          */
         dwConst1 = 2L * dwDeltaY;
         dwConst2 = 2L * (dwDeltaY - dwDeltaX);
         dwP = 2L * dwDeltaY - dwDeltaX;

         for (i = 0; i < dwDeltaX; i++)
         {
              if (dwP <= 0L)
              {
                   dwP += dwConst1;
              }
              else
              {
                   dwP += dwConst2;
                   code[i]++;
                   total++;
              }
         }
    }
    else
    {
         /*
          * Size is increasing.  Use Bresenham adapted for slope > 1, and
          * use a loop invariant to generate code array.  Run index i from
          * 0 to dwDeltaY - 1, and when i = dwDeltaY - 1, j will
          * be = dwDeltaX - 1.
          */
         dwConst1 = 2L * dwDeltaX;
         dwConst2 = 2L * (dwDeltaX - dwDeltaY);
         dwP = 2L * dwDeltaX - dwDeltaY;
         j = 0;

         for (i = 0; i < dwDeltaY; i++)
         {
              if (dwP <= 0L)
              {
                   dwP += dwConst1;
                   bStretchIndex++;
              }
              else
              {
                   dwP += dwConst2;
                   code[j++] = ++bStretchIndex;
                   bStretchIndex = 0;
                   total += (int)code[j - 1];
              }
         }

         /*
          * UGLY fix up for wacky bug which I have no time to fix properly.
          * The 'total' of entries is messed up for slopes > 4, so add the
          * difference back into the array.
          */
         if (total < dwDeltaY)
         {
              while (total < dwDeltaY)
              {
                   j = (int)dwDeltaY - total;
                   k = (int)dwDeltaY / j;
                   for (i = 0; i < dwDeltaX; i++)
                   {
                        if (!(i % k) && (total < dwDeltaY))
                        {
                             code[i]++;
                             total++;
                        }
                   }
              }
         }
    }
}


/**********************************************************
*
*       Name:  GetThresholdValue
*
*       Module Abstract:
*       ----------------
*       Determines the best threshold for the specified
*       surface.
*
*       Output Parameters:
*       ------------------
*       Threshold
*
***********************************************************
*       Author: Shuhua Ge
*       Date:   09/25/95
*
*       Revision History:
*       -----------------
*       WHO             WHEN     WHAT/WHY/HOW
*       ---             ----     ------------
*
*********************************************************/

BYTE GetThresholdValue(VOID)
{
    return ((BYTE) 0x0A);
}


/**********************************************************
*
*       Name:  MustLineRelicate
*
*       Module Abstract:
*       ----------------
*       Checks to see if we must line replicate or if we can
*       interpolate.
*
*       Output Parameters:
*       ------------------
*       TRUE/FALSE
*
***********************************************************
*       Author: Shuhua Ge
*       Date:   09/25/96
*
*       Revision History:
*       -----------------
*       WHO             WHEN     WHAT/WHY/HOW
*       ---             ----     ------------
*
*********************************************************/

BOOL MustLineReplicate (PDEV* ppdev, PDD_SURFACE_LOCAL lpSurface, WORD wVideoDepth)
{
    LONG lTempThresh;

    /*
     * If we are double clocking the data (1280x1024 mode), we must
     * replicate.  We should also always replicate in Performance mode
     */
    if (ppdev->bDoubleClock)
    {
        return (TRUE);
    }

                                //
    // Check the VCLK
    //
    // sge07
    if (GetVCLK(ppdev) > 130000)
    {
        return (TRUE);
    }

    /*
     * If we are using the chroma key feature, we can't interpolate
     */
    if (lpSurface->dwReserved1 & (OVERLAY_FLG_COLOR_KEY | OVERLAY_FLG_SRC_COLOR_KEY))
    {
         return (TRUE);
    }

    lTempThresh = ppdev->lFifoThresh;
    if (ppdev->pfnIsSufficientBandwidth(ppdev, wVideoDepth,
        &ppdev->rOverlaySrc, &ppdev->rOverlayDest, OVERLAY_FLG_INTERPOLATE))
    {
        ppdev->lFifoThresh = lTempThresh;
        return (FALSE);
    }
    ppdev->lFifoThresh = lTempThresh;

    return (TRUE);
}


/**********************************************************
*
*       Name:  IsSufficientBandwidth
*
*       Module Abstract:
*       ----------------
*       Determines is sufficient bandwidth exists for the requested
*       configuration.
*
*       Output Parameters:
*       ------------------
*       TRUE/FALSE
*       It also sets the global parameter lFifoThresh, which gets
*       programed in RegInitVideo().
*
***********************************************************
*       Author: Shuhua Ge
*       Date:   09/25/96
*
*       Revision History:
*       -----------------
*       WHO             WHEN     WHAT/WHY/HOW
*       ---             ----     ------------
*
*********************************************************/

BOOL IsSufficientBandwidth(PDEV* ppdev, WORD wVideoDepth, LPRECTL lpSrc, LPRECTL lpDest, DWORD dwFlags)
{
    LONG lVideoPixelsPerDWORD;
    LONG lGraphicsPixelsPerDWORD;
    LONG lVCLKPeriod;
    LONG lTransferTime;
    LONG lDWORDsWritten;
    LONG lZoom;
    LONG lReadPeriod;
    LONG lEffReadPeriod;
    LONG lWritePeriod;
    LONG lEffWritePeriod;
    LONG K1,K2;
    LONG lTrFifoAFirst4;
    LONG lTrFifoB2;
    LONG lDWORDsRead;
    LONG lFifoAReadPeriod;
    LONG lFifoBReadPeriod;
    LONG lFifoAEffWritePeriod;
    LONG lFifoBEffWritePeriod;
    LONG lFifoALevels;
    LONG lFifoBLevels;
    LONG lFifoAThresh;
    LONG lFifoBThresh;
    LONG lVCLK;

    BYTE*   pjPorts = ppdev->pjPorts;

//#define BLIT_LATENCY  8
#define CRT_FIFO_DEPTH 28

    //
    // Add 8 clock for BLT_LATENCY for 54446BE and later chips
    //
    // sge04

    LONG BLIT_LATENCY = 8;
    if (ppdev->flCaps & CAPS_SECOND_APERTURE)
        BLIT_LATENCY += 2;

    /*
     * Convert input parameters
     */
    if (wVideoDepth == 16)
    {
        lVideoPixelsPerDWORD = 2;
    }
    else
    {
        lVideoPixelsPerDWORD = 4;
    }

    if (ppdev->cBitsPerPixel == 8)
    {
        lGraphicsPixelsPerDWORD = 4;
    }
    else if (ppdev->cBitsPerPixel == 16)
    {
        lGraphicsPixelsPerDWORD = 2;
    }
    else if (ppdev->cBitsPerPixel == 24)
    {
        lGraphicsPixelsPerDWORD = 1;
    }
    else
        return (FALSE);

    lZoom = ((lpDest->right - lpDest->left) * 256) /
        (lpSrc->right - lpSrc->left);

    /*
     * If we are double clocked, fail if we are not zoomed at least 2X
     */
    if (ppdev->bDoubleClock && (lZoom < 512))
    {
        return (FALSE);
    }

    /*
     * We need to get the VCLK every time since this can change
     * at run-time
     */
    lVCLK = GetVCLK(ppdev);
    if (lVCLK == 0)
    {
        return (FALSE);
    }
    lVCLKPeriod = (LONG) ((1000000/lVCLK) + 1);

    /*
     * We only need to setup the following variables once!
     */
    if (!ppdev->lBusWidth)
    {
        /*
         * We will read the bus width from SR0F[4:3]
         */
        CP_OUT_BYTE(pjPorts, SR_INDEX, 0x0F);
        if ((CP_IN_BYTE(pjPorts, SR_DATA) & 0x18) == 0x18)
        {
            ppdev->lBusWidth = 8;  // 64 bit bus
        }
        else
        {
            ppdev->lBusWidth = 4;  // 32 bit bus
        }
    }
    if (!ppdev->lRandom)
    {
        /*
         * Is this EDO or regular?
         */
        CP_OUT_BYTE(pjPorts, SR_INDEX, 0x0f);
        if (!(CP_IN_BYTE(pjPorts, SR_DATA) & 0x4))
        {
            ppdev->lRandom   = 7;
            ppdev->lPageMiss = 7;
        }
        else
        {
            ppdev->lRandom   = 6;
            ppdev->lPageMiss = 6;
        }
    }

    if (!ppdev->lMCLKPeriod)
    {
        LONG lMCLK;

        /*
         * The MCLK period is the amount of time required for one cycle.
         * We will round up.
         */
        CP_OUT_BYTE(pjPorts, SR_INDEX, 0x1f);   // First get the MCLK frequency
        lMCLK = CP_IN_BYTE(pjPorts, SR_DATA);
        lMCLK *= 14318;
        lMCLK >>= 3;
        ppdev->lMCLKPeriod = ((1000000/lMCLK) + 1);
    }

    /*
     * Check for the case with no color key or Y interpolation
     */
    if (dwFlags == 0)
    {
        /*
         * This mode utilizes only FIFO A. The fifo is filled with
         * graphics data during regions 1 and 3, and video data during
         * region 2.
         *
         * The normal memory sequence for this mode goes as follows.
         *
         *      ------------------------------------------------
         *     | cpu/blit cycle | FIFO A fill   | cpu/blit cycle ....
         *      ------------------------------------------------
         *
         *     The cpu/blit cycle is interrupted when the CRT
         *     fifo is depleted to its threshold. Once the
         *     crt cycle is started, it continues until the
         *     FIFO A is full.
         *
         *     Worst case condition for filling the CRT fifo :
         *
         *     1) CPU/blit latency ->
         *     2)  Random cycle for region 2 video ->
         *     3)   Page miss for region 2 video ->
         *     4)    Page miss for region 2 to region 3 transition ->
         *     5)     Page miss for region 3 graphics
         *
         *     Conditions 3 and 5 depend on the location of the
         *     graphic screen within display memory. For 1024x768, where
         *     the graphics screen starts at location 0 and is offset by
         *     1024 or 2048 bytes each line, condition 5 is never met.
         *     If a video window starts at beginning of a memory page,
         *     and is offset at the beggining of each line by an even
         *     multiple of a memory page, condition 3 is never met.
         *
         *     Based on this worst case condition, the amount of time
         *     required to complete 4 transfers into the crt fifo
         *     is approximately:
         *        lTransferTime = (BLIT_LATENCY + lRandom + 3*(lPageMiss)) *
         *                         lMCLKPeriod.
         *        the number of dwords transferred to the fifo
         *        during this time is 4 for 32 bit memory interface
         *        or 8 for 64 bit interface.
         *        lDWORDsWritten = 4 * (lBusWidth/4)
         *
         *     During this period, data continues to be read from the crt
         *     fifo for screen refresh. The amount of data read,
         *     assuming a 1x scale is approximately:
         *        lDWORDsRead = tr_time/(lVideoPixelsPerDWORD * lVCLKPeriod)
         *
         *     The difference between the dwords read and dwords
         *     written must be accounted for in the fifo trheshold setting
         *
         *     lFifoThresh = (lDWORDsRead - lDWORDsWritten) rounded
         *                 up to next even value.
         *
         *     To determine if there is adequate bandwidth to support
         *     the mode, the lFifoThresh must not exceed the fifo depth.
         *     For the mode to work, the fifo read rate must not exceed the
         *     fifo write rate.
         *        read_rate = min(lGraphicsPixelsPerDWORD,lVideoPixelsPerDWORD) * lVCLKPeriod.
         *        write_rate = lMCLKPeriod * 2;  -- 2 clocks per cas
         *
         * A special case occurs if the fifo read rate is very close to the peak
         * fifo write rate. In this case the crt fill may result in a continuous
         * page cycle for the entire active line. This could result in 1 extra
         * page miss at the start of region2. To account for this, I will
         * add 3 DWORDS to the trheshold if the read and write rates are very close
         * (arbitrarily defined as within 10% of each other.
         *
         * Zooming
         *  Some modes can only be supported at video scale factors greater than 1X.
         *  Even when the video is zoomed, a small number of  dwords must be read
         *  from the crt fifo at the unzoomed rate in order to prime the video
         *  pipeline. The video pipeline requires 10 pixel before it slows the fifo
         *  reads to the zoomed rate.
         *
         *                    tr_time - (lVCLKPeriod * 10/lVideoPixelsPerDWORD)
         *    lDWORDsRead =   --------------------------------------------- + 10/lVideoPixelsPerDWORDord
         *                    (lVideoPixelsPerDWORD * lVCLKPeriod * lZoom)
         */
        lTransferTime = (BLIT_LATENCY + ppdev->lRandom + (3*(ppdev->lPageMiss))) *
            ppdev->lMCLKPeriod;

        lDWORDsWritten = 3 * (ppdev->lBusWidth/4);

        /*
         * If read rate exceeds write rate, calculate minumum zoom
         * to keep everything as ints, spec the zoom as 256 times
         * the fractional zoom
         */
        lWritePeriod = ppdev->lMCLKPeriod * 2/(ppdev->lBusWidth/4);
        lReadPeriod   = lVideoPixelsPerDWORD * lVCLKPeriod;

        /*
         * Pick worst case of graphics and video depths for calculation
         * of dwords read. This may be a little pessimistic for the
         * when the graphics bits per pixel exceeds the video bits per pixel.
         */
        lEffReadPeriod = (lVideoPixelsPerDWORD * lVCLKPeriod * lZoom)/256;
        if (lEffReadPeriod < lWritePeriod)
        {
            /*
             * Cannot support overlay at this zoom factor
             */
            return (0);
        }

        if (lGraphicsPixelsPerDWORD > lVideoPixelsPerDWORD)   // handle zoom factor
        {
            lDWORDsRead =   ((lTransferTime -
                (lVCLKPeriod * 10/lVideoPixelsPerDWORD))/
                (lEffReadPeriod)) +
                (10 / lVideoPixelsPerDWORD) + 1;
        }
        else
        {
            lDWORDsRead    = (lTransferTime/
                (lGraphicsPixelsPerDWORD * lVCLKPeriod)) + 1;
        }

        // Calculate the fifo threshold setting
        ppdev->lFifoThresh = lDWORDsRead - lDWORDsWritten;

        // if read rate is within 10% of write rate, up by 3 dwords
        if ((11*lEffReadPeriod) < ((10*lWritePeriod*256)/lZoom))
        {
            ppdev->lFifoThresh += 3;
        }

        // fifo trheshold spec'd in QWORDS, so round up by 1 and divide by 2)
        ppdev->lFifoThresh = (ppdev->lFifoThresh + 1)/2;

        // Add a extra QWORD to account for fifo level sync logic
        ppdev->lFifoThresh = ppdev->lFifoThresh + 1;
        if (ppdev->bDoubleClock)
        {
            ppdev->lFifoThresh <<= 1;
        }

        if ((ppdev->lFifoThresh >= CRT_FIFO_DEPTH) ||
            ((lEffReadPeriod) < lWritePeriod))
        {
            return (0);
        }
        else
        {
            return (1);
        }
    }

    /*
     * Check bandwidth for Y Interpolation
     */
    else if (dwFlags & OVERLAY_FLG_INTERPOLATE)
    {
        /*
         * This mode utilizes both FIFOs A and B. During horizontal blank,
         * both fifos are filled.  FIFO a is then filled with graphics
         * data during regions 1 and 3, and video data during region 2.
         * FIFO B is filled with video data during region 2, and is idle
         * during regions 1 and 3.
         *
         * The normal memory sequence for this mode goes as follows.
         *
         *      ----------------------------------------------------------------
         *     | cpu/blit cycle | FIFO A fill   | FIFO B fill | cpu/blit cycle .
         *      ----------------------------------------------------------------
         *     or
         *      ----------------------------------------------------------------
         *     | cpu/blit cycle | FIFO B fill   | FIFO A fill | cpu/blit cycle .
         *      ----------------------------------------------------------------
         *
         * For this mode, the FIFO threshold must be set high enough to allow
         * enough time to abort the cpu/blt, fill FIFO A, then transfer data
         * into FIFO B before underflow occurs.
         *
         * Worst case condition for filling the CRT fifo :
         *
         * 1) CPU/blit latency ->
         * 2) FIFO A random cycle for region 2 video ->
         * 3) FIFO A page miss for region 2 video ->
         * 4) FIFO A page miss for region 2 to region 3 transition ->
         * 5) FIFO A page miss for region 3 graphics
         * 6) FIFO A page mode fill
         * 7) FIFO B random cycle
         * 8) FIFO B page miss
         *
         * lTransferTime = lMCLKPeriod *
         *                 (BLIT_LATENCY + lRandom + 3*(lPageMiss) +
         *                 fifoa_remaining +
         *                 lRandom + lPageMiss;
         *
         *
         * The time required to fill FIFO A depends upon the read rate
         * of FIFO A and the number of levels that must be filled,
         * as determined by the threshold setting.
         *
         * The worst case fill time for the first four levels of fifo A is
         *   lTrFifoAFirst4   = (BLIT_LATENCY + lRandom + 3*(lPageMiss)) *
         *                        lMCLKPeriod;
         *
         * The number of dwords depleted from fifo A during the
         * fill of the first four levels is
         *     lReadPeriod        = lVCLKPeriod * lVideoPixelsPerDWORD * lZoom;
         *     fifoa_reads_4      = lTrFifoAFirst4/lReadPeriod;
         *
         * The number of empty levels remaining in the fifo after
         * the fill of the first four levels is
         *     fifoa_remaining = FIFO_DEPTH - lFifoThresh + ((4*ramwidth)/4)
         *                       - lTrFifoAFirst4/lReadPeriod;
         *
         * The amount of time required to fill the remaining levels of
         * fifo A is determined by the write rate and the read rate.
         *    lWritePeriod = lMCLKPeriod * 2; // 2 clks per cas
         *    lEffWritePeriod = ((lReadPeriod * lWritePeriod)/
         *                       (lReadPeriod - lWritePeriod));
         *
         *    tr_fifoa_remaining = fifoa_remaining * lEffWritePeriod;
         *
         *
         * The total amount of time for the cpu/blt latency and the
         * fifo A fill is
         *    tr_fifoa_total = lTrFifoAFirst4  + tr_fifoa_remaining;
         *
         * The worse case fill time for fifo B is as follows:
         *    lTrFifoB2 = (lRandom + lPageMiss) * lMCLKPeriod;
         *
         * The total amount of time elapsed from the crt request until
         * the first 2 fifob cycles are completed is
         *    lTransferTime = tr_fifoa_total + lTrFifoB2;
         *
         * The number of dwords transferred to the fifo during this
         * time is 2 for 32 bit memory interface or 4 for 64 bit interface.
         *    lDWORDsWritten = 2 * (lBusWidth/4)
         *
         * During this period, data continues to be read from the crt
         * fifo B for screen refresh. The amount of data read,
         * is approximately:
         *    dwords_read = lTransferTime/lReadPeriod
         *
         * The difference between the dwords read and dwords
         * written must be accounted for in the fifo trheshold setting
         *
         *    lFifoThresh = (dwords_read - lDWORDsWritten) rounded
         *               up to next even value.
         *
         * Since the lTransferTime and dwords_read depends on
         * the threshold setting, a bit of algebra is required to determine
         * the minimum setting to prevent fifo underflow.
         *
         *    lFifoThresh = (lTransferTime/lReadPeriod) - lDWORDsWritten;
         *             = ((tr_fifoa_4 + lTrFifoB2 + tr_fifoa_remaining)/lReadPeriod)
         *               - lDWORDsWritten
         * to simplify calcuation, break out constant part of equation
         *    K1        = ((tr_fifoa_4 + lTrFifoB2)/lReadPeriod) - lDWORDsWritten;
         *
         *    lFifoThresh =  K1 + (tr_fifoa_remaining/lReadPeriod);
         *             =  K1 + (fifoa_remaining * lEffWritePeriod)/lReadPeriod;
         *    lFifoThresh =  K1 +
         *                ((FIFO_DEPTH - lFifoThresh + 4 - (lTrFifoAFirst4/lReadPeriod)) *
         *                 lEffWritePeriod)/lReadPeriod;
         *
         * break out another constant to simplify reduction
         *    K2       =  (FIFO_DEPTH + 4 - (lTrFifoAFirst4/lReadPeriod))
         *                * (lEffWritePeriod/lReadPeriod);
         *    lFifoThresh = K1 + K2 - (lFifoThresh * (lEffWritePeriod/lReadPeriod));
         *    lFifoThresh * (1 +  (lEffWritePeriod/lReadPeriod)) = K1 + K2;
         *    lFifoThresh = (K1 + K2)/(1 +  (lEffWritePeriod/lReadPeriod);
         *
         * Once the threshold setting is determined, another calculation must
         * be performed to determine if available bandwidth exists given the
         * zoom factor. The worst case is assumed to be when FIFO A and
         * FIFO B reach the threshold point at the same time. The sequence
         * is then to abort the cpu/blt, fill fifo a, then fill fifo b.
         *
         * Since FIFO A is full when the fill B operation starts, I only have
         * to determine how long it takes to fill FIFO B and then calculate
         * the the number of dwords read from A during that time.
         *
         *   lTransferTime = (lTrFifoB2 + (CRT_FIFO_DEPTH * lEffWritePeriod))/lReadPeriod;
         *   lFifoALevels = CRT_FIFO_DEPTH - (lTransferTime/lReadPeriod);
         *
         * if lFifoALevels < 1, then underflow condition may occur.
         */
        if (lZoom < 512)
        {
            // 5446 requires at least a 2X zoom for Y interpolation
            return (FALSE);
        }

        lWritePeriod = ppdev->lMCLKPeriod * 2/(ppdev->lBusWidth/4);
        lReadPeriod  = (lVideoPixelsPerDWORD * lVCLKPeriod * lZoom)/256;

        lEffWritePeriod = ((lReadPeriod * lWritePeriod)/
                           (lReadPeriod - lWritePeriod));
        lTrFifoAFirst4 = (BLIT_LATENCY + ppdev->lRandom + 3*(ppdev->lPageMiss)) *
                          ppdev->lMCLKPeriod;
        lTrFifoB2 = (ppdev->lRandom + ppdev->lPageMiss) * ppdev->lMCLKPeriod;

        lDWORDsWritten = 2 * (ppdev->lBusWidth/4);
        K1 = ((lTrFifoAFirst4 + lTrFifoB2)/lReadPeriod) - lDWORDsWritten;
        K2 = (CRT_FIFO_DEPTH + (4*(ppdev->lBusWidth/4)) -
             (lTrFifoAFirst4/lReadPeriod))
             * (lEffWritePeriod/lReadPeriod);
        ppdev->lFifoThresh = (1 + ((K1 + K2)/(1 +  (lEffWritePeriod/lReadPeriod))));

        ppdev->lFifoThresh += 3;

        lTransferTime = (lTrFifoB2 + (CRT_FIFO_DEPTH * lEffWritePeriod));
        lFifoALevels = ((CRT_FIFO_DEPTH - (lTransferTime/lReadPeriod))/2);
        if (ppdev->bDoubleClock)
        {
            ppdev->lFifoThresh <<= 1;
        }

        if ((lFifoALevels < 2) || (ppdev->lFifoThresh > (CRT_FIFO_DEPTH/2)))
        {
            return (0);
        }
        else
        {
            return (1);
        }
    }

    /*
     * Check bandwidth for color keying
     */
    else if (dwFlags & (OVERLAY_FLG_COLOR_KEY | OVERLAY_FLG_SRC_COLOR_KEY))
    {
        /*
         * This mode utilizes both FIFOs A and B.  During horizontal blank,
         * both fifos are filled.  FIFO a is then filled with graphics data
         * during regions 1,2 and 3.  FIFO B is filled with video data
         * during region 2, and is idle during regions 1 and 3.
         *
         * The normal memory sequence for this mode goes as follows.
         *
         *      ----------------------------------------------------------------
         *     | cpu/blit cycle | FIFO A fill   | FIFO B fill | cpu/blit cycle .
         *      ----------------------------------------------------------------
         *     or
         *      ----------------------------------------------------------------
         *     | cpu/blit cycle | FIFO B fill   | FIFO A fill | cpu/blit cycle .
         *      ----------------------------------------------------------------
         *
         * For this mode, the FIFO threshold must be set high enough to allow
         * enough time to abort the cpu/blt, fill FIFO A, then transfer data
         * into FIFO B before underflow occurs. If the fifob read rate is
         * greater than the fifoa read rate, then allow eough time for
         * a t CPU/blt abort, followed by a fifo B fill, then a FIFO A fill.
         *
         * Worst case condition for filling the CRT fifo :
         *
         *   1) CPU/blit latency ->
         *   2) FIFO A random  ->
         *   3) FIFO A page miss  ->
         *   6) FIFO A page mode fill -->
         *   7) FIFO B random  -->
         *   8) FIFO B page miss
         *
         *  or
         *
         *   1) CPU/blit latency ->
         *   2) FIFO B random  ->
         *   3) FIFO A page miss  ->
         *   6) FIFO A page mode fill -->
         *   7) FIFO B random -->
         *   8) FIFO B page miss
         *
         *
         * 1)  lTransferTime = lMCLKPeriod *
         *                   (BLIT_LATENCY + lRandom + lPageMiss +
         *                    fifoa_remaining +
         *                    lRandom + lPageMiss;
         *
         * or
         * 2)  lTransferTime = lMCLKPeriod *
         *                   (BLIT_LATENCY + lRandom + lPageMiss +
         *                    fifob_remaining +
         *                    lRandom + lPageMiss;
         *
         *
         *     lFifoAReadPeriod  = lVCLKPeriod * lGraphicsPixelsPerDWORD;
         *     lFifoBReadPeriod  = (lVCLKPeriod * lVideoPixelsPerDWORD * lZoom)*256;
         *
         * if (lFifoAReadPeriod > lFifoBReadPeriod), then
         * first fifo is fifo B, otherwise first is fifo A.
         * The followinf euqations are written for a fifoa->fifob,
         * sequence, but the fifob->fifoa sequence can be obtained simply
         * by swapping the fifo read periods.
         *
         * The time required to fill a FIFO depends upon the read rate
         * of the FIFO and the number of levels that must be filled,
         * as determined by the threshold setting.
         *
         * The worst case fill time for the first four levels of fifo A is
         *     lTrFifoAFirst4   = (BLIT_LATENCY + lRandom + lPageMiss) *
         *                          lMCLKPeriod;
         *
         * The number of dwords depleted from fifo A during the
         *   fill of the first four levels is
         *     fifoa_reads_4      = lTrFifoAFirst4/lFifoAReadPeriod;
         *
         * The number of empty levels remaining in the fifo after
         * the fill of the first four levels is
         *     fifoa_remaining = FIFO_DEPTH - lFifoThresh + ((4*ramwidth)/4)
         *                             - lTrFifoAFirst4/lFifoAReadPeriod;
         *
         * The amount of time required to fill the remaining levels of
         * fifo A is determined by the write rate and the read rate.
         *     lWritePeriod = lMCLKPeriod * 2; * 2 clks per cas
         *     eff_write_period = ((lFifoAReadPeriod * lWritePeriod)/
         *                           (lFifoAReadPeriod - lWritePeriod));
         *
         *     tr_fifoa_remaining = fifoa_remaining * eff_write_period;
         *
         *
         * The total amount of time for the cpu/blt latency and the
         * fifo A fill is
         *     tr_fifoa_total = lTrFifoAFirst4  + tr_fifoa_remaining;
         *
         * The worse case fill time for fifo B is as follows:
         *     lTrFifoB2 = (lRandom + lPageMiss) * lMCLKPeriod;
         *
         * The total amount of time elapsed from the crt request until
         * the first 2 fifob cycles are completed is
         *     lTransferTime = tr_fifoa_total + lTrFifoB2;
         *
         * The number of dwords transferred to the fifo during this time
         * is 2 for 32 bit memory interface or 4 for 64 bit interface.
         *     lDWORDsWritten = 2 * (lBusWidth/4)
         *
         * During this period, data continues to be read from the crt
         * fifo B for screen refresh. The amount of data read,
         * is approximately:
         *     lFifoBReadPeriod  = (lVCLKPeriod * lVideoPixelsPerDWORD * lZoom)/256;
         *     dwords_read = lTransferTime/lFifoBReadPeriod
         *
         * The difference between the dwords read and dwords
         * written must be accounted for in the fifo trheshold setting
         *
         *     lFifoThresh = (dwords_read - lDWORDsWritten) rounded
         *                 up to next even value.
         *
         * Since the lTransferTime and dwords_read depends on the
         * threshold setting, a bit of algebra is required to determine
         * the minimum setting to prevent fifo underflow.
         *
         *    lFifoThresh = (lTransferTime/lFifoBReadPeriod) - lDWORDsWritten;
         *             = ((tr_fifoa_4 + lTrFifoB2 + tr_fifoa_remaining)/lFifoBReadPeriod)
         *                - lDWORDsWritten
         * to simplify calcuation, break out constant part of equation
         *    K1        = ((tr_fifoa_4 + lTrFifoB2)/lFifoBReadPeriod) - lDWORDsWritten;
         *
         *    lFifoThresh =  K1 + (tr_fifoa_remaining/lFifoBReadPeriod);
         *             =  K1 + (fifoa_remaining * eff_write_period)/lFifoBReadPeriod;
         *    lFifoThresh =  K1 +
         *                ((FIFO_DEPTH - lFifoThresh + 4 - (lTrFifoAFirst4/lFifoAReadPeriod)) *
         *                 eff_write_period)/read_period;
         *
         * break out another constant to simplify reduction
         *    K2       =  (FIFO_DEPTH + 4 - (lTrFifoAFirst4/lFifoAReadPeriod))
         *                   * (eff_write_period/lFifoBReadPeriod);
         *    lFifoThresh = K1 + K2 - (lFifoThresh * (eff_write_period/lFifoBReadPeriod));
         *    lFifoThresh * (1 +  (eff_write_period/read_period)) = K1 + K2;
         *    lFifoThresh = (K1 + K2)/(1 +  (eff_write_period/lFifoBReadPeriod);
         *
         * Once the threshold setting is determined, another calculation must
         * be performed to determine if available bandwidth exists given the
         * zoom factor. The worst case is assumed to be when FIFO A and
         * FIFO B reach the threshold point at the same time. The sequence
         * is then to abort the cpu/blt, fill fifo a, then fill fifo b.
         *
         * Since FIFO A is full when the fill B operation starts, I only have
         * to determine how long it takes to fill FIFO B and then calculate
         * the the number of dwords read from A during that time.
         *
         *   lTransferTime = (lTrFifoB2 + (CRT_FIFO_DEPTH * fifob_eff_write_period))/read_period;
         *   fifoa_levels = CRT_FIFO_DEPTH - (lTransferTime/read_period);
         *
         * if fifoa_levels < 1, then underflow condition may occur.
         */
        lWritePeriod = ppdev->lMCLKPeriod * 2/(ppdev->lBusWidth/4);
        lFifoAReadPeriod = lGraphicsPixelsPerDWORD  * lVCLKPeriod;
        lFifoBReadPeriod = (lVideoPixelsPerDWORD * lVCLKPeriod * lZoom)/256;

        if (lFifoAReadPeriod <= lWritePeriod) // this fails, so set a big#
        {
            lFifoAEffWritePeriod = 5000;
        }
        else
        {
            lFifoAEffWritePeriod = ((lFifoAReadPeriod * lWritePeriod)/
                (lFifoAReadPeriod - lWritePeriod));
        }

        if (lFifoBReadPeriod <= lWritePeriod) // this fails, so set a big#
        {
            lFifoBEffWritePeriod = 5000;
        }
        else
        {
            lFifoBEffWritePeriod = ((lFifoBReadPeriod * lWritePeriod)/
                (lFifoBReadPeriod - lWritePeriod));
        }

        if ((lFifoAReadPeriod == 0) || (lFifoBReadPeriod == 0) ||
            (lWritePeriod == 0))
        {
            return (FALSE);
        }

        // These values should be the same for bot the fifoa->fifob
        // and fifob->fifoa sequences
        lTrFifoAFirst4 = (BLIT_LATENCY + ppdev->lRandom + 2*(ppdev->lPageMiss)) *
                         ppdev->lMCLKPeriod;
        lTrFifoB2 = (ppdev->lRandom + ppdev->lPageMiss) * ppdev->lMCLKPeriod;

        lDWORDsWritten     = 2 * (ppdev->lBusWidth/4);

        // Since I'm not sure which sequence is worse
        // Try both then pick worse case results

        // For fifoa->fifob sequence
        K1 = ((lTrFifoAFirst4 + lTrFifoB2)/lFifoBReadPeriod) - lDWORDsWritten;
        K2 = (CRT_FIFO_DEPTH + (4*(ppdev->lBusWidth/4)) -
            (lTrFifoAFirst4/lFifoAReadPeriod))
            * (lFifoAEffWritePeriod/lFifoBReadPeriod);
        lFifoAThresh   = (1 + ((K1 + K2)/
            (1 +  (lFifoAEffWritePeriod/lFifoBReadPeriod))));

        lFifoAThresh += 3;

        lTransferTime = (lTrFifoB2 + (CRT_FIFO_DEPTH * lFifoBEffWritePeriod));
        lFifoALevels = ((CRT_FIFO_DEPTH - (lTransferTime/lFifoAReadPeriod))/2);

        // For fifob->fifoa sequence
        K1 = ((lTrFifoAFirst4 + lTrFifoB2)/lFifoAReadPeriod) - lDWORDsWritten;
        K2 = (CRT_FIFO_DEPTH + (4*(ppdev->lBusWidth/4)) -
            (lTrFifoAFirst4/lFifoBReadPeriod))
            * (lFifoBEffWritePeriod/lFifoAReadPeriod);

        lFifoBThresh = (1 + ((K1 + K2)/
            (1 +  (lFifoBEffWritePeriod/lFifoAReadPeriod))));

        lFifoBThresh += 3;

        lTransferTime = (lTrFifoB2 + (CRT_FIFO_DEPTH * lFifoAEffWritePeriod));
        lFifoBLevels = ((CRT_FIFO_DEPTH - (lTransferTime/lFifoBReadPeriod))/2);

        if (lFifoAThresh > lFifoBThresh)
        {
            ppdev->lFifoThresh = lFifoAThresh;
        }
        else
        {
            ppdev->lFifoThresh = lFifoBThresh;
        }
        if (ppdev->bDoubleClock)
        {
            ppdev->lFifoThresh <<= 1;
        }

        if ((lFifoBLevels <0) || (lFifoALevels < 0) ||
            (ppdev->lFifoThresh > (CRT_FIFO_DEPTH/2)))
        {
            return (0);
        }
        else
        {
            return (1);
        }
    }
    return (1);  // Should never get here!!
}



// chu03
/**********************************************************
*
*       Name:  Is5480SufficientBandwidth
*
*       Module Abstract:
*       ----------------
*       This function reads the current MCLK, VLCK, bus width, etc.
*       and determines whether the chip has sufficient bandwidth
*       to handle the requested mode.
*
*       Output Parameters:
*       ------------------
*       none
*
***********************************************************/

// -------------------------------------------------------------
// Overview by John Schafer
// -------------------------------------------------------------
// The memory arbitration scheme for the 5480 has changed
// significantly from the 5446. The 5480 is set up on a first
// come, first serve basis. If more than 1 request arrive at
// the same clock edge, then the BankSelect is used to determine
// which request to acknowledge first. Using SDRAM, the row
// access to a differennt bank can be hidden, which saves up to
// 7 MCLKs. If all bank selects for the concurrent requests are
// the same, the default prority is FIFOA->FIFOB->FIFOC->VCAP.
//
// The FIFO sizes for the 5480 are as follows:
//      FIFOA, FIFOB, FIFOC :  32x64
//      VCAP                :  16x64 (two 8x64 fifos)
//
// The Y interpolation mode for the 5480 is "free" due to
// the embedded line store. The available mode combinations
// for the 5480 which effect bandwidth are :
//
//  1)  Capture enabled,  1 video window, no occlusion, not 420 format
//  2)  Capture enabled,  1 video window, no occlusion, 420 format
//  3)  Capture enabled,  1 video window, occlusion, not 420 format
//  4)  Capture enabled,  1 video window, occlusion, 420 format
//  5)  Capture enabled,  2 video windows (occlusion implied)
//  6)  Capture disabled, 1 video window, no occlusion, not 420 format
//  7)  Capture disabled, 1 video window, no occlusion, 420 format
//  8)  Capture disabled, 1 video window, occlusion, not 420 format
//  9)  Capture disabled, 1 video window, occlusion, 420 format
//  10) Capture disabled, 2 video windows (occlusion implied)
//
//
// -------------------------------------------------------------
// FIFO threshold description
// -------------------------------------------------------------
// The memory requests are generated based on the threshold settings
// of each FIFO. CRT FIFO thresholds during non-video window lines
// are determined by SR16(3:0). CRT FIFO thresholds during video
// window lines are determined by CR5C(3:0).
// The VCAP fifo threshold is a fixed setting of 8 QWORDS (half).
//
// The 4 bit threshold for FIFOs A,B, and C indicate the FIFO
// level in double QWORDS at which the FIFO request is asserted.
// For example, a setting of 4 indicates that the request is
// generated when the FIFO level is reduced to 8 QWORDS.
// A setting of 0 is a special case which indicates that the
// FIFO must be full to prevent a request (i.e. 32 QWORDS).
//
// The objective of the bandwidth equations is to calculate
// the optimum threshold setting and determine which display
// modes may be supported for given MCLK and VCLK frequencies.
//
// The critical parameters which determine the bandwidth limits
// are the read and effective write rates for each FIFO.
//
// -------------------------------------------------------------
// FIFO read/write rates for CRT FIFOs
// -------------------------------------------------------------
// The read rate for FIFO A (graphics FIFO) is determined by
// the graphics pixel depth and the VCLK frequency.
//     fa_read_rate = gr_bytes_per_pixel * vclk_period
//
// The read rates for FIFO B and C are determined differently
// depending on display mode. For 420 format the read periods
// in nanosecs per byte are as follows:
//     fb_read_period = ((vclk_period*4) * hzoom) / hdecimate;
//     fc_read_period = ((vclk_period*4) * hzoom) / hdecimate;
//
// In this equation hdecimate is specified as 1/decimation_scale,
// i.e a 1/2 decimate implies hdecimate = 2
//
// For non 420 format the rates are:
//     fb_read_period = ((vclk_period/vw_bytes_per_pixel) * hzoom) /
//                      hdecimate;
//     fc_read_period = (vclk_period/vw_bytes_per_pixel);
//
// Since the FIFOs can be read and written simultaneously,
// the effective write rate is determined by the actual fifo
// write rate and tje fifo read rate. The actual write rate is based
// on single mclk display memory reads. The memory read period is
// calculated in terms of nanoseconds per byte.
//
//    bytes_per_memory_transfer is equal to 4 for 32 bit i/f, 8 for 64 bit i/f
//    mem_read_period     = mclk_period/bytes_per_mem_transfer
//    fa_eff_write_period = (mem_read_period * fa_read_period)/
//                           (fa_read_period - mem_read_period);
//    fb_eff_write_period = (mem_read_period * fb_read_period)/
//                           (fb_read_period - mem_read_period);
//    fc_eff_write_period = (mem_read_period * fc_read_period)/
//                           (fc_read_period - mem_read_period);
// -------------------------------------------------------------
// FIFO read/write rates for VCAP fifo
// -------------------------------------------------------------
//  The video capture write rate is based on the data rate
// from the video capture interface. Since the video capture
// interface can perform format conversion (e.g. 422->PackJR) and
// decimation, the capture data rate may be smaller than the actual
// video port data rate. The capture period in the following equation
// is defined in terms of nanoseconds per byte. The decimation factor
// may vary from 1 to 1/256.
//
//     vcap_write_period  = (vport_pixel_period/capture_bytes_per_pixel) *
//                        (vport_decimation);
// In this equation vport_decimation is specified as 1/decimation_scale,
// i.e a 1/2 decimate implies vport_decimation = 2
//
//
// Since the VCAP fifo can be read and written simultaneously,
// the effective read rate is determined by the fifo write rate as well
// as the actual fifo read rate. The actual fifo read rate is based on two
// memory clock cycle display memory writes. The calculations are in terms
// of nanoseconds per byte.
//    bytes_per_memory_transfer = 4 for 32 bit i/f, or 8 for 64 bit i/f
//   mem_write_period = 2 *  mclk_period/bytes_per_mem_transfer
//
//   vcap_eff_read_period = (mem_write_period * vcap_write_period)/
//                           (vcap_write_period - mem_write_period);
//
// -------------------------------------------------------------------
// How to determine if FIFO ABC underflow or VCAP fifo overflow occurs
// -------------------------------------------------------------------
//
// I will examine a few worst case scenarios to determine if adequate
// bandwidth exists to support a given mode.
//
// Case #1 - start of graphics line where all 3 CRT fifos must be filled
//
//     This condition occurs after hsync when the 3 CRT FIFOs are being
//  prefilled before the start of the active line. The only risk here is
//  that the video capture fifo may overflow during the consecutive fills
//  of fifos A,B, and C. The threshold setting does not matter since the
//  CRT fifos are cleared on reset and thus guaranteed to be empty.
//
//  For a 32 bit memory interface :
//      fabc_fill_time = (BLIT_LATENCY * mclk_period) +
//                       3 * ((RAS_PRECHARGE + 64) * mclk_period)
//
//  For a 64 bit memory interface :
//      fabc_fill_time = (BLIT_LATENCY * mclk_period) +
//                       3 * ((RAS_PRECHARGE + 32) * mclk_period)
//
//  A capture fifo overflow occurs if fabc_fill_time is greater than
//  VCAP fill time based on the worst case 30 MB/s capture rate.
//
//  For a worst case memory interface scenario, let's assume a 32 bit
//  interface with a 66 MHz memory clock, a blit latency of 10 mclks,
//  and a ras precharge of 7 mclks. The fabc_fill_time is
//  then
//      fabc_fill_time =   (10 * 15.2) +
//                          3 * ((64 + 7) * 15.2) = 3390 ns
//
//  Assuming the worst case 30 MB/s capture rate, the number of
//  bytes written to the capture fifo during the fabc_fill_time is
//       3390 ns * (1 byte/33 ns)  = 103 bytes
//
//  Since the capture fifo is 128 bytes deep, the worst case scenario
//  is OK so long as the capture fifo is emptied prior to the fabc_fill.
//
//
//
// Case #2 - Consecutive requests
//
//  It seems that the worst case for servicing of requests is when the requests occur
//  on consecutive mclks with the order of requests being from the slowest to the
//  fastest data consumer. In other words, the first to be serviced is the capture fifo,
//  then the 3 CRT fifos in the order of decreasing read_period.
//
//  First calculate actual and effective read and write periods as decribed above.
//  Then determine how many requests are active, this is a maximum of 4 if capture
//  is enabled and all 3 CRT fifos are enabled. Assume that the capture rate
//  is the slowest and thus is always serviced first. Then order the active
//  CRT requests as f1 through f3, where f1 has the longest read period and
//  f3 has the shortest.
//
//  The sequence of events then becomes:
//    empty vcap -> fill 1 -> fill 2 -> fill 3
//
//
//  Depending on the number of active crt fifos, the fill 2 and fill 3 operations may
//  be ommitted. The vcap empty is obviously ommitted if capture is not enabled.
//
//  Now step through the sequence and verify that crt fifo underflows and capture
//  underflows do not occur.
//
//     If capture is enabled, calculate the latency and empty times
//         vcap_latency        =  (BLIT_LATENCY + RAS_PRECHARGE) * mclk_period;
//         vcap_bytes_to_empty   = CAP_FIFO_DEPTH;
//         vcap_empty_time       = (vcap_read_period * vcap_bytes_to_empty);
//      Since one of the capture fifos continues to fill while the other is being
//      emptied, calculate the number of filled levels in the capture fifo at
//      the end of the memory transfer.
//         vcap_levels_remaining =  (vcap_latency + vcap_empty_time)/vcap_write_period;
//      If the number of levels filled exceeds the fifo depth, then an overflow occurred.
//
//  Note that the VCAP FIFO operates differently than the CRT fifos. The VCAP
//  FIFO operates as 2 8x64 FIFOs. A memory request is asserted when one of the
//  FIFOs is full. The capture interface then fills the other fifo while the
//  full fifo is being serviced by the sequencer. Using this method, the transfer
//  to memory is always 16 QWORDs for VCAP data (except special end of line conditions).
//
//     Now check fifo 1. If capture was enabled then the latency for fifo 1 is:
//         f1_latency       = vcap_latency + vcap_empty_time +
//                           (BLIT_LATENCY + RAS_PRECHARGE) * mclk_period;
//
//     otherwise the latency is:
//         f1_latency     =  (BLIT_LATENCY + RAS_PRECHARGE) * mclk_period;
//
//     Calculate the number of empty levels in fifo 1, i.e. the number of bytes
//     that must be filled.
//       f1_bytes_to_fill = ((16-threshold) * 16) + (f1_latency/f1_read_period);
//      If the number of levels to be filled exceeds the fifo depth, then an underflow occurred.
//     Calculate the fill time based on the effective fifo write rate.
//       f1_fill_time     = (f1_eff_write_period * f1_bytes_to_fill);
//
//     If fifo_2 is active, calculate its latency and bytes to be filled.
//          f2_latency       = f1_latency + f1_fill_time +
//                          (RAS_PRECHARGE * mclk_period);
//          f2_bytes_to_fill = ((16-threshold) * 16) + (f2_latency/f2_read_period);
//      If the number of levels to be filled exceeds the fifo depth, then an underflow occurred.
//     Calculate the fill time based on the effective fifo write rate.
//          f2_fill_time     = (f2_eff_write_period * f2_bytes_to_fill);
//
//     If fifo_2 is active, calculate its latency and bytes to be filled.
//          f3_latency       = f2_latency + f2_fill_time +
//                             (RAS_PRECHARGE * mclk_period);
//          f3_bytes_to_fill = ((16-threshold) * 16) + (f3_latency/f3_read_period);
//      If the number of levels to be filled exceeds the fifo depth, then an underflow occurred.
//     Calculate the fill time based on the effective fifo write rate.
//          f3_fill_time     = (f3_eff_write_period * f3_bytes_to_fill);
//
//      Now go back to the start of sequence and make sure that none of the FIFOs
//      have already initiated another request. The totla latency is the amount
//      of time required to execute the entire sequence.
//
//      Check vcap fif status if capture is enabled,
//        vcap_latency        = total_latency;
//        vcap_bytes_to_empty = (total_latency/vcap_write_period);
//
//      Check fifo 1 status
//        f1_latency = (total_latency - f1_latency - f1_fill_time);
//        f1_bytes_to_fill = (f1_latency/f1_read_period);
//
//      Check fifo 2 status if active
//        f2_latency = (total_latency - f1_latency - f1_fill_time);
//        f3_bytes_to_fill = (f1_latency/f1_read_period);
//
//***************************************************************************
static BOOL Is5480SufficientBandwidth (PDEV* ppdev,
                                   WORD wVideoDepth,
                                   LPRECTL lpSrc,
                                   LPRECTL lpDest,
                                   DWORD dwFlags)
{
    long  lVideoPixelsPerDWORD;
    long  lGraphicsPixelsPerDWORD;
    long  lCapturePixelsPerDWORD;
    long  lVideoBytesPerPixel;
    long  lGraphicsBytesPerPixel;
    long  lCaptureBytesPerPixel;
    long  lVCLKPeriod;
    long  lZoom;
    long  lFifoAReadPeriod;
    long  lFifoBReadPeriod;
    long  lFifoCReadPeriod;
    long  lFifoAEffWritePeriod;
    long  lFifoBEffWritePeriod;
    long  lFifoCEffWritePeriod;
    long  lMemReadPeriod;
    long  lVPortPixelPeriod;
    long  lVCapReadPeriod;
    long  lVCapWritePeriod;
    long  lFifo1ReadPeriod;
    long  lFifo2ReadPeriod;
    long  lFifo3ReadPeriod;
    long  lFifo1EffWritePeriod;
    long  lFifo2EffWritePeriod;
    long  lFifo3EffWritePeriod;
    long  lVCapLatency;
    long  lVCapBytesToEmpty;
    long  lVCapEmptyTime;
    long  lVCapLevelRemaining;
    long  lFifo1Latency;
    long  lFifo1BytesToFill;
    long  lFifo1FillTime;
    long  lFifo2Latency;
    long  lFifo2BytesToFill;
    long  lFifo2FillTime;
    long  lFifo3Latency;
    long  lFifo3BytesToFill;
    long  lFifo3FillTime;
    long  lThreshold;
    int   CrtFifoCount;
    BOOL  bCapture;
    BOOL  bFifoAEnable;
    BOOL  bFifoBEnable;
    BOOL  bFifoCEnable;
    BOOL  bModePass;
    long  lHorizDecimate;
    long  lVPortDecimate;
    long  lTotalLatency;
    long  lVCLK;
    UCHAR tempB ;
    BYTE* pjPorts = ppdev->pjPorts ;

#define  CAP_FIFO_DEPTH 64
#define  RAS_PRECHARGE   7
#define  BLIT_LATENCY    9

    //
    // Parameter checking
    //
    lFifo2EffWritePeriod = 0;
    lFifo3EffWritePeriod = 0;
    lHorizDecimate = 1;
    lVPortDecimate = 1;

    //
    // Convert input parameters
    //
    if (wVideoDepth == 16)
    {
        lVideoPixelsPerDWORD   = 2;
        lCapturePixelsPerDWORD = 2;
    }
    else if (wVideoDepth == 8)
    {
        lVideoPixelsPerDWORD   = 4;
        lCapturePixelsPerDWORD = 4;
    }
    else return (FALSE);

    if (ppdev->cBitsPerPixel == 8)
    {
        lGraphicsPixelsPerDWORD = 4;
    }
    else if (ppdev->cBitsPerPixel == 16)
    {
        lGraphicsPixelsPerDWORD = 2;
    }
    else if (ppdev->cBitsPerPixel == 24)
    {
        lGraphicsPixelsPerDWORD = 1;
    }
    else return (FALSE);


    lGraphicsBytesPerPixel = 4 / lGraphicsPixelsPerDWORD;
    lVideoBytesPerPixel =  4 / lVideoPixelsPerDWORD;
    lCaptureBytesPerPixel = 4 / lCapturePixelsPerDWORD;

    lZoom = (lpDest->right - lpDest->left) /
        (lpSrc->right - lpSrc->left);

    if (lZoom < 1)
        lZoom = 1;

    //
    // We need to get the VCLK every time since this can change at run-time
    //
    lVCLK = GetVCLK(ppdev);
    lVCLKPeriod = (long) ((1024000000l/lVCLK) + 1);

    //
    // Video port at 13.5 MHz
    //
    lVPortPixelPeriod = (long) ((10240000) / 135);


    //
    // Graphics CRT FIFO read rate
    //
    lFifoAReadPeriod = lGraphicsBytesPerPixel * lVCLKPeriod;

    //
    // Video FIFO read rate
    //
    if(dwFlags & OVERLAY_FLG_YUVPLANAR)
    {
        lFifoBReadPeriod = ((lVCLKPeriod * 4) * lZoom) / lHorizDecimate;
        lFifoCReadPeriod = ((lVCLKPeriod * 4) * lZoom) / lHorizDecimate;
    }
    else
    {
        lFifoBReadPeriod = ((lVCLKPeriod / lVideoBytesPerPixel) * lZoom)
                / lHorizDecimate;
        lFifoCReadPeriod = lVCLKPeriod / lVideoBytesPerPixel;
    }


    DISPDBG ((2, "lFifoAReadPeriod = %ld, lFifoBReadPeriod=%ld\n",
        lFifoAReadPeriod, lFifoBReadPeriod));

    DISPDBG ((2, "lFifoCReadPeriod = %ld\n", lFifoCReadPeriod));

    //
    // Video capture write period
    //
    lVCapWritePeriod = (lVPortPixelPeriod / lCaptureBytesPerPixel)
                                                * lVPortDecimate;

    if (!ppdev->lBusWidth)
    {
        //
        // We will read the bus width from SR0F[4:3]
        //
        CP_OUT_BYTE (pjPorts, SR_INDEX, 0x0F) ;

        if ((CP_IN_BYTE(pjPorts, SR_DATA) & 0x18) == 0x18)
            ppdev->lBusWidth = 8;  // 64 bit bus
        else
            ppdev->lBusWidth = 4;  // 32 bit bus
    }

    if (!ppdev->lMCLKPeriod)
    {
        LONG lMCLK;

        //
        // The MCLK period is the amount of time required for one cycle.
        // We will round up.
        //
        CP_OUT_BYTE (pjPorts, SR_INDEX, 0x1F) ; // First get the MCLK frequency
        lMCLK = CP_IN_BYTE(pjPorts, SR_DATA);
        lMCLK *= 14318;
        lMCLK >>= 3;
        ppdev->lMCLKPeriod = (long) ((1024000000l/lMCLK) + 1);
    }

    //
    // Calculate CRT effective read and write periods
    //
    lMemReadPeriod = ppdev->lMCLKPeriod / ppdev->lBusWidth;

    if (lFifoAReadPeriod == lMemReadPeriod)
        lFifoAEffWritePeriod = 1000000000;
    else
        lFifoAEffWritePeriod = (lMemReadPeriod * lFifoAReadPeriod) /
                                    (lFifoAReadPeriod - lMemReadPeriod);

    if (lFifoBReadPeriod == lMemReadPeriod)
        lFifoBEffWritePeriod = 1000000000;
    else
        lFifoBEffWritePeriod = (lMemReadPeriod * lFifoBReadPeriod) /
                                    (lFifoBReadPeriod - lMemReadPeriod);

    if (lFifoCReadPeriod == lMemReadPeriod)
        lFifoCEffWritePeriod = 1000000000;
    else
        lFifoCEffWritePeriod = (lMemReadPeriod * lFifoCReadPeriod) /
                                    (lFifoCReadPeriod - lMemReadPeriod);

    //
    // Video capture read period
    //
    lVCapReadPeriod = (2 * ppdev->lMCLKPeriod) / ppdev->lBusWidth;


    if (dwFlags & OVERLAY_FLG_CAPTURE)  // is capture enable ?
        bCapture = TRUE;
    else
        bCapture = FALSE;


    if (dwFlags & OVERLAY_FLG_YUVPLANAR)    // is 420 format
    {
        if (dwFlags & (OVERLAY_FLG_COLOR_KEY | OVERLAY_FLG_SRC_COLOR_KEY))  // occlusion
        {   // one video window, occlusion, 420 format
            bFifoAEnable = TRUE;
            bFifoBEnable = TRUE;
            bFifoCEnable = TRUE;
        }
        else
        {   // one video window, no occlusion, 420 format
            bFifoAEnable = FALSE;
            bFifoBEnable = TRUE;
            bFifoCEnable = TRUE;
        }
    }
    else    // not 420 format
    {
        if (dwFlags & (OVERLAY_FLG_COLOR_KEY | OVERLAY_FLG_SRC_COLOR_KEY))  // occlusion
        {
            if (dwFlags & OVERLAY_FLG_TWO_VIDEO)
            {   // Two video windows, occlusion, not 420 format
                bFifoAEnable = TRUE;
                bFifoBEnable = TRUE;
                bFifoCEnable = TRUE;
            }
            else
            {   // one video window, occlusion, not 420 format
                bFifoAEnable = TRUE;
                bFifoBEnable = TRUE;
                bFifoCEnable = FALSE;
            }
        }
        else
        {
            // one video window, no occlusion, not 420 format
            bFifoAEnable = FALSE;
            bFifoBEnable = TRUE;
            bFifoCEnable = FALSE;
        }
    }

    DISPDBG ((4, "   FIFOA = %s, FIFOB= %s, FIFOC = %s\n",
        bFifoAEnable ? "yes" : "no",
        bFifoBEnable ? "yes" : "no",
        bFifoCEnable ? "yes" : "no"));

    lFifo1ReadPeriod = 0;
    lFifo2ReadPeriod = 0;
    lFifo3ReadPeriod = 0;

    if (bFifoAEnable)
    {
        if (((lFifoAReadPeriod >= lFifoBReadPeriod) || !bFifoBEnable) &&
        // A slower than or equal than B) and
            ((lFifoAReadPeriod >= lFifoCReadPeriod) || !bFifoCEnable))
        // A slower than or equal C
        {
            lFifo1ReadPeriod = lFifoAReadPeriod;
            lFifo1EffWritePeriod = lFifoAEffWritePeriod;
        }
        else if (((lFifoAReadPeriod >= lFifoBReadPeriod) || !bFifoBEnable) ||
        // A slower than or equal B
                ((lFifoAReadPeriod >= lFifoCReadPeriod) || !bFifoCEnable))
        // A slower than or equal C
        {
            lFifo2ReadPeriod = lFifoAReadPeriod;
            lFifo2EffWritePeriod = lFifoAEffWritePeriod;
        }
        else    // A not slower than A or B
        {
            lFifo3ReadPeriod = lFifoAReadPeriod;
            lFifo3EffWritePeriod = lFifoAEffWritePeriod;
        }
    }

    DISPDBG ((2, "After bFifoAEnable")) ;
    DISPDBG ((2, "lFifo1ReadPeriod = %ld, lFifo2ReadPeriod=%ld",
        lFifo1ReadPeriod, lFifo2ReadPeriod)) ;
    DISPDBG ((2, "lFifo3ReadPeriod = %ld", lFifo3ReadPeriod)) ;


    if (bFifoBEnable)
    {
        if (((lFifoBReadPeriod > lFifoAReadPeriod) || !bFifoAEnable) &&
        // B slower than A and
            ((lFifoBReadPeriod >= lFifoCReadPeriod) || !bFifoCEnable))
        // slower than or equal A
        {
            lFifo1ReadPeriod = lFifoBReadPeriod;
            lFifo1EffWritePeriod = lFifoBEffWritePeriod;
        }
        else if (((lFifoBReadPeriod > lFifoAReadPeriod) || !bFifoAEnable) ||
        // B slower than A or
                    ((lFifoBReadPeriod >= lFifoCReadPeriod) || !bFifoCEnable))
        // B slower than or equal C
        {

            lFifo2ReadPeriod = lFifoBReadPeriod;
            lFifo2EffWritePeriod = lFifoBEffWritePeriod;

        }
        else
        // (B not slower than A ) and (B not slower than or equal C)
        {
            lFifo3ReadPeriod = lFifoBReadPeriod;
            lFifo3EffWritePeriod = lFifoBEffWritePeriod;
        }
    }
    else



    DISPDBG ((4, "After bFifoBEnable")) ;
    DISPDBG ((4, "lFifo1ReadPeriod = %ld, lFifo2ReadPeriod=%ld",
        lFifo1ReadPeriod, lFifo2ReadPeriod)) ;
    DISPDBG ((4, "lFifo3ReadPeriod = %ld", lFifo3ReadPeriod)) ;

    if (bFifoCEnable)
    {
        if (((lFifoCReadPeriod > lFifoAReadPeriod) || !bFifoAEnable) &&
        // C slower than A  and
            ((lFifoCReadPeriod > lFifoBReadPeriod) || !bFifoBEnable))
        // C slower than B
        {
            lFifo1ReadPeriod = lFifoCReadPeriod;
            lFifo1EffWritePeriod = lFifoCEffWritePeriod;
        }
        else if (((lFifoCReadPeriod > lFifoAReadPeriod) || !bFifoAEnable) ||
        // C slower than A or
                 ((lFifoCReadPeriod > lFifoBReadPeriod) || !bFifoBEnable))
        // C slower than B
        {
            lFifo2ReadPeriod = lFifoCReadPeriod;
            lFifo2EffWritePeriod = lFifoCEffWritePeriod;
        }
        else
        {
        // C not slower than A and C not slower than B
            lFifo3ReadPeriod = lFifoCReadPeriod;
            lFifo3EffWritePeriod = lFifoCEffWritePeriod;
        }
    }

    DISPDBG ((4, "After bFifoCEnable")) ;
    DISPDBG ((4, "lFifo1ReadPeriod = %ld, lFifo2ReadPeriod=%ld",
        lFifo1ReadPeriod, lFifo2ReadPeriod)) ;
    DISPDBG ((4, "lFifo3ReadPeriod = %ld", lFifo3ReadPeriod)) ;
    DISPDBG ((4, "lFifo1EffWritePeriod = %ld, lFifo2EffWritePeriod = %ld",
         lFifo1EffWritePeriod, lFifo2EffWritePeriod)) ;
    DISPDBG ((4, " lFifo3EffWritePeriod = %ld", lFifo3EffWritePeriod)) ;
    DISPDBG ((4, " lFifoAEffWritePeriod = %ld, lFifoBEffWritePeriod = %ld",
         lFifoAEffWritePeriod, lFifoBEffWritePeriod)) ;
    DISPDBG ((4, " lFifoCEffWritePeriod = %ld", lFifoCEffWritePeriod)) ;

    bModePass = FALSE;
    lThreshold = 1;

    CrtFifoCount = 0;
    if (bFifoAEnable) CrtFifoCount++;
    if (bFifoBEnable) CrtFifoCount++;
    if (bFifoCEnable) CrtFifoCount++;

    while ((!bModePass) && (lThreshold < 16))
    {
        bModePass = TRUE;   // assume pass until proven otherwise.

        //
        // Checking capture
        //
        if (bCapture)
        {
            lVCapLatency = (BLIT_LATENCY + RAS_PRECHARGE) * ppdev->lMCLKPeriod;
            lVCapBytesToEmpty = CAP_FIFO_DEPTH;
            lVCapEmptyTime = lVCapReadPeriod * lVCapBytesToEmpty;
            lVCapLevelRemaining = (lVCapLatency + lVCapEmptyTime) / lVCapWritePeriod;
            if (lVCapLevelRemaining > CAP_FIFO_DEPTH)
                  return(FALSE);
        }

        //
        // Fill FIFO 1
        //
        if (bCapture)
            lFifo1Latency = lVCapLatency + lVCapEmptyTime + (BLIT_LATENCY + RAS_PRECHARGE) * ppdev->lMCLKPeriod;
        else
            lFifo1Latency = (BLIT_LATENCY + RAS_PRECHARGE) * ppdev->lMCLKPeriod;

        lFifo1BytesToFill = ((16 - lThreshold) * 16)
                        + (lFifo1Latency / lFifo1ReadPeriod);
        lFifo1FillTime = lFifo1EffWritePeriod * lFifo1BytesToFill;
        if (lFifo1BytesToFill > 256)
            bModePass = FALSE;

        DISPDBG ((4, "After Fill FIFO1, lFifo1BytesToFillb=%ld, ModePass = %s",
            lFifo1BytesToFill, bModePass ? "yes" : "no")) ;
        DISPDBG ((4, "f1_latency=%ld, f1_read_period=%ld",
            lFifo1Latency, lFifo1ReadPeriod)) ;
        DISPDBG ((4, "mclkperiod= %ld, vclkperiod=%ld",
            ppdev->lMCLKPeriod, lVCLKPeriod)) ;

        //
        // Fill FIFO 2
        //
        if (CrtFifoCount > 1)
        {
            lFifo2Latency = lFifo1Latency + lFifo1FillTime +
                                    (RAS_PRECHARGE * ppdev->lMCLKPeriod);
            lFifo2BytesToFill = ((16 - lThreshold) * 16) +
                                (lFifo2Latency / lFifo2ReadPeriod);
            lFifo2FillTime = lFifo2EffWritePeriod * lFifo2BytesToFill;
            if (lFifo2BytesToFill > 256)
                bModePass = FALSE;
        }
        else
        {
            lFifo2Latency = lFifo1Latency + lFifo1FillTime;
            lFifo2BytesToFill = 0;
            lFifo2FillTime = 0;
        }

        DISPDBG ((4, "After Fill FIFO2, lFifo2BytesToFill=%ld, ModePass = %s",
            lFifo2BytesToFill, bModePass ? "yes" : "no"));

        //
        // Fill FIFO 3
        //
        if (CrtFifoCount > 2)
        {
            lFifo3Latency = lFifo2Latency + lFifo2FillTime + (RAS_PRECHARGE * ppdev->lMCLKPeriod);
            lFifo3BytesToFill = ((16 - lThreshold) * 16) + (lFifo3Latency / lFifo3ReadPeriod);
            lFifo3FillTime = lFifo3EffWritePeriod * lFifo3BytesToFill;
            if (lFifo3BytesToFill > 256)
                bModePass = FALSE;
        }
        else
        {
            lFifo3Latency = lFifo2Latency + lFifo2FillTime;
            lFifo3BytesToFill = 0;
            lFifo3FillTime = 0;
        }

        DISPDBG ((4, "After Fill FIFO3, lFifo3BytesToFill=%ld, ModePass = %s",
            lFifo3BytesToFill, bModePass ? "yes" : "no")) ;

        //
        // Determine total latency through the sequence
        //
        lTotalLatency = lFifo3Latency + lFifo3FillTime;

        //
        // Now back to start of sequence, make sure that none of the FIFOs
        //   have already initiated another request.
        //

        //
        // Check capture FIFO status
        //
        if (bCapture)
        {
            lVCapLatency = lTotalLatency;
            lVCapBytesToEmpty = lTotalLatency / lVCapWritePeriod;
            if (lVCapBytesToEmpty > CAP_FIFO_DEPTH)
                  bModePass = FALSE;
        }

        //
        // Check FIFO 1 status
        //
        lFifo1Latency = lTotalLatency - lFifo1Latency - lFifo1FillTime;
        lFifo1BytesToFill = lFifo1Latency / lFifo1ReadPeriod;
        if (lFifo1BytesToFill > ((16 - lThreshold) * 16))
            bModePass = FALSE;

        DISPDBG ((4, "After CheckF FIFO1, fifo1bytestofill %ld,bModePass = %s",
            lFifo1BytesToFill, bModePass ? "yes" : "no")) ;

        //
        // Check FIFO 2 status
        //
        if (CrtFifoCount > 1)
        {
            lFifo2Latency = lTotalLatency - lFifo2Latency - lFifo2FillTime;
            lFifo2BytesToFill = lFifo2Latency / lFifo2ReadPeriod;
            if (lFifo2BytesToFill > ((16 - lThreshold) * 16))
                  bModePass = FALSE;

        DISPDBG ((4, "After Check FIFO 2, fifo1bytestofill=%ld, bModePass = %s",
            lFifo2BytesToFill, bModePass ? "yes" : "no")) ;

        }

        if (!bModePass)
            lThreshold++;

    }


    if (bModePass)
    {

        DISPDBG ((1, "Is sufficient Bandwidth, thresh = %ld, return TRUE\n", lThreshold));

        if (ppdev->cBitsPerPixel == 24)
            lThreshold = 0x0F;

        ppdev->lFifoThresh = lThreshold;

        return TRUE ;
    }

    DISPDBG ((2, "Is sufficient Bandwidth, thresh = %ld, rerurn FALSE", lThreshold));
    return FALSE;

}



/**********************************************************
*
*       Name:  GetVCLK
*
*       Module Abstract:
*       ----------------
*       Returns the VCLK frequency * 1000.
*
*       Input Parameters:
*       -----------------
*       none
*
*       Output Parameters:
*       ------------------
*       MCLK
*
***********************************************************
*       Author: Shuhua Ge
*       Date:   09/25/96
*
*       Revision History:
*       -----------------
*       WHO             WHEN     WHAT/WHY/HOW
*       ---             ----     ------------
*
*********************************************************/

LONG GetVCLK(PDEV* ppdev)
{
    LONG    lTemp;
    LONG    lRegSR1F;
    LONG    lRegMISC;
    LONG    lNR;
    LONG    lDR;
    LONG    lPS;
    BYTE*   pjPorts = ppdev->pjPorts;

    /*
     * First read SR1F.  This tells us if VCLK is derived from MCLK
     * or if it's derived normally.
     */
    CP_OUT_BYTE(pjPorts, SR_INDEX, 0x1f);
    lRegSR1F = (LONG) CP_IN_BYTE(pjPorts, SR_DATA);
    if (lRegSR1F & 0x40)
    {
         LONG lMCLK;

         /*
          * It is derived from MCLK, but now we need to read SR1E to see
          * if VCLK = MCLK or if VCLK = MCLK/2.
          */
         lMCLK = (lRegSR1F & 0x3F) * 14318;
         CP_OUT_BYTE(pjPorts, SR_INDEX, 0x1e);
         if (CP_IN_BYTE(pjPorts, SR_DATA) & 0x01)
         {
              return (lMCLK >> 4);
         }
         else
         {
              return (lMCLK >> 3);
         }
    }
    else
    {
         /*
          * Read MISC[3:2], which tells us where to find our VCLK
          */
         lRegMISC = (LONG) CP_IN_BYTE(pjPorts, 0x3cc);
         lRegMISC >>= 2;

        //myf33 begin
         CP_OUT_BYTE(pjPorts, CRTC_INDEX, (BYTE)0x80);
         if (((ppdev->ulChipID == CL7555_ID) || (ppdev->ulChipID == CL7556_ID)) &&
			 (CP_IN_BYTE(pjPorts, CRTC_DATA) & 0x01))
             lRegMISC &= 0x02;          // Fixed PDR 8709
         else
        //myf33 end
         lRegMISC &= 0x03;

         lNR = 0x0B + lRegMISC;
         lDR = 0x1B + lRegMISC;

         /*
          * Read the values for bP, bDR, and bNR
          */
         CP_OUT_BYTE(pjPorts, SR_INDEX, (BYTE) lDR);
         lPS = lDR = (LONG)CP_IN_BYTE(pjPorts, SR_DATA);
         CP_OUT_BYTE(pjPorts, SR_INDEX, (BYTE) lNR);
         lNR = (LONG)CP_IN_BYTE(pjPorts, SR_DATA);
         lPS &= 0x01;
         lPS += 1;
         lDR >>= 1;
         //
         // Extended the VCLK bits.
         //
         // sge06
         lDR &= 0x7f;
         lNR &= 0x7f;

         /*
          * VCLK = (14.31818 * bNR) / (bDR * bPS)
          */
         lTemp = (14318 * lNR);
         if (!lPS || !lDR)
         {
             return (0);
         }
         lTemp /= (lDR * lPS);
    }

    return (lTemp);
}
/**********************************************************
*
*       Name:  EnableStartAddrDoubleBuffer
*
*       Module Abstract:
*       ----------------
*       Enable the double buffering of the start addresses.   This allows the page
*       flipping operation to proceed without the system CPU waiting for VRT.
*
*       Input Parameters:
*       -----------------
*       none
*
*       Output Parameters:
*       ------------------
*
***********************************************************
*       Author: Shuhua Ge
*       Date:   10/01/96
*
*       Revision History:
*       -----------------
*       WHO             WHEN     WHAT/WHY/HOW
*       ---             ----     ------------
*
*********************************************************/
VOID EnableStartAddrDoubleBuffer(PDEV* ppdev)
{

    BYTE*   pjPorts = ppdev->pjPorts;
    BYTE    cTemp;


    CP_OUT_BYTE(pjPorts, CRTC_INDEX, 0x1a);
    cTemp = CP_IN_BYTE(pjPorts, CRTC_DATA);
    CP_OUT_BYTE(pjPorts, CRTC_DATA, cTemp | 2);
}

/**********************************************************
*
*       Name:  GetCurrentVLine
*
*       Module Abstract:
*       ----------------
*       Get the current scan line
*
*       Input Parameters:
*       -----------------
*       none
*
*       Output Parameters:
*       ------------------
*
***********************************************************
*       Author: Shuhua Ge
*       Date:   10/01/96
*
*       Revision History:
*       -----------------
*       WHO             WHEN     WHAT/WHY/HOW
*       ---             ----     ------------
*
*********************************************************/
DWORD GetCurrentVLine(PDEV* ppdev)
{

    DWORD   dwLine;
    BYTE    cTemp;
    BYTE*   pjPorts = ppdev->pjPorts;

    CP_OUT_BYTE(pjPorts, INDEX_REG, 0x16);  /* Index to the low byte. */
    dwLine = (ULONG)CP_IN_BYTE(pjPorts, DATA_REG);

    CP_OUT_BYTE(pjPorts, INDEX_REG, 0x17);  /* Index to the high bits. */
    cTemp = CP_IN_BYTE(pjPorts, DATA_REG);
    dwLine |= (cTemp & 3) << 8;

    CP_OUT_BYTE(pjPorts, INDEX_REG, 0x16);  /* Index to the low byte. */

    /* If we wrapped around while getting the high bits we have a problem. */
    /* The high bits may be wrong. */
    if((CP_IN_BYTE(pjPorts, DATA_REG)) < (dwLine & 0xff))
    {
        DISPDBG((1, "Recursive call to GetCurrentVLine."));
        return GetCurrentVLine(ppdev);
    }
    if (dwLine > ppdev->dwVsyncLine)
    {
        return 0;
    }
    return dwLine;
}
#endif

#endif // DIRECTDRAW
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\cirrus\disp\color.c ===
/******************************Module*Header*******************************\
* Module Name: color.c
*
* This algorithm for color dithering is patent pending and its use is
* restricted to Microsoft products and drivers for Microsoft products.
* Use in non-Microsoft products or in drivers for non-Microsoft products
* is prohibited without the expressed written consent of Microsoft Corp.
*
* The patent application is the primary reference for the operation of the
* color dithering code.
*
* Note that in the comments and variable names, "vertex" means "vertex of
* either the inner (half intensity) or outer (full intensity) color cube."
* Vertices map to colors 0-7 and 9-15 of the Windows standard (required)
* 16-color palette, where vertices 0-7 are the vertices of the inner color
* cube, and 0 plus 9-15 are the vertices of the full color cube. Vertex 8 is
* 75% gray; this could be used in the dither, but that would break apps that
* depend on the exact Windows 3.1 dithering. This code is Window 3.1
* compatible.
*
* Note that as a result of the compatibility requirement, the dither
* produced by this algorithm is the exact same dither as that produced
* by the default Windows 3.1 16 color and 256 color VGA drivers.
*
* Copyright (c) 1992-1995 Microsoft Corporation
\**************************************************************************/

#include "precomp.h"

/**************************************************************************\
* This function takes a value from 0 - 255 and uses it to create an
* 8x8 pile of bits in the form of a 1BPP bitmap.  It can also take an
* RGB value and make an 8x8 bitmap.  These can then be used as brushes
* to simulate color unavaible on the device.
*
* For monochrome the basic algorithm is equivalent to turning on bits
* in the 8x8 array according to the following order:
*
*  00 32 08 40 02 34 10 42
*  48 16 56 24 50 18 58 26
*  12 44 04 36 14 46 06 38
*  60 28 52 20 62 30 54 22
*  03 35 11 43 01 33 09 41
*  51 19 59 27 49 17 57 25
*  15 47 07 39 13 45 05 37
*  63 31 55 23 61 29 53 21
*
* Reference: A Survey of Techniques for the Display of Continous
*            Tone Pictures on Bilevel Displays,;
*            Jarvis, Judice, & Ninke;
*            COMPUTER GRAPHICS AND IMAGE PROCESSING 5, pp 13-40, (1976)
\**************************************************************************/

#define SWAP_RB 0x00000004
#define SWAP_GB 0x00000002
#define SWAP_RG 0x00000001

#define SWAPTHEM(a,b) (ulTemp = a, a = b, b = ulTemp)

// PATTERNSIZE is the number of pixels in a dither pattern.
#define PATTERNSIZE 64

typedef union _PAL_ULONG {
    PALETTEENTRY pal;
    ULONG ul;
} PAL_ULONG;

// Tells which row to turn a pel on in when dithering for monochrome bitmaps.
static BYTE ajByte[] = {
    0, 4, 0, 4, 2, 6, 2, 6,
    0, 4, 0, 4, 2, 6, 2, 6,
    1, 5, 1, 5, 3, 7, 3, 7,
    1, 5, 1, 5, 3, 7, 3, 7,
    0, 4, 0, 4, 2, 6, 2, 6,
    0, 4, 0, 4, 2, 6, 2, 6,
    1, 5, 1, 5, 3, 7, 3, 7,
    1, 5, 1, 5, 3, 7, 3, 7
};

// The array of monochrome bits used for monc
static BYTE ajBits[] = {
    0x80, 0x08, 0x08, 0x80, 0x20, 0x02, 0x02, 0x20,
    0x20, 0x02, 0x02, 0x20, 0x80, 0x08, 0x08, 0x80,
    0x40, 0x04, 0x04, 0x40, 0x10, 0x01, 0x01, 0x10,
    0x10, 0x01, 0x01, 0x10, 0x40, 0x04, 0x04, 0x40,
    0x40, 0x04, 0x04, 0x40, 0x10, 0x01, 0x01, 0x10,
    0x10, 0x01, 0x01, 0x10, 0x40, 0x04, 0x04, 0x40,
    0x80, 0x08, 0x08, 0x80, 0x20, 0x02, 0x02, 0x20,
    0x20, 0x02, 0x02, 0x20, 0x80, 0x08, 0x08, 0x80
};

// Translates vertices back to the original subspace. Each row is a subspace,
// as encoded in ulSymmetry, and each column is a vertex between 0 and 15.
BYTE jSwapSubSpace[8*16] = {
    0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,
    0, 2, 1, 3, 4, 6, 5, 7, 8, 10, 9, 11, 12, 14, 13, 15,
    0, 1, 4, 5, 2, 3, 6, 7, 8, 9, 12, 13, 10, 11, 14, 15,
    0, 4, 1, 5, 2, 6, 3, 7, 8, 12, 9, 13, 10, 14, 11, 15,
    0, 4, 2, 6, 1, 5, 3, 7, 8, 12, 10, 14, 9, 13, 11, 15,
    0, 2, 4, 6, 1, 3, 5, 7, 8, 10, 12, 14, 9, 11, 13, 15,
    0, 4, 1, 5, 2, 6, 3, 7, 8, 12, 9, 13, 10, 14, 11, 15,
    0, 1, 4, 5, 2, 3, 6, 7, 8, 9, 12, 13, 10, 11, 14, 15,
};

// Converts a nibble value in the range 0-15 to a dword value containing the
// nibble value packed 8 times.
ULONG ulNibbleToDword[16] = {
    0x00000000,
    0x01010101,
    0x02020202,
    0x03030303,
    0x04040404,
    0x05050505,
    0x06060606,
    0xF8F8F8F8,
    0x07070707,
    0xF9F9F9F9,
    0xFAFAFAFA,
    0xFBFBFBFB,
    0xFCFCFCFC,
    0xFDFDFDFD,
    0xFEFEFEFE,
    0xFFFFFFFF
};

// Specifies where in the dither pattern colors should be placed in order
// of increasing intensity.
ULONG aulDitherOrder[] = {
  0, 36,  4, 32, 18, 54, 22, 50,
  2, 38,  6, 34, 16, 52, 20, 48,
  9, 45, 13, 41, 27, 63, 31, 59,
 11, 47, 15, 43, 25, 61, 29, 57,
  1, 37,  5, 33, 19, 55, 23, 51,
  3, 39,  7, 35, 17, 53, 21, 49,
  8, 44, 12, 40, 26, 62, 30, 58,
 10, 46, 14, 42, 24, 60, 28, 56,
};

// Array to convert to 256 color from 16 color. Maps from index that represents
// a 16-color vertex (color) to value that specifies the color index in the
// 256-color palette.
BYTE ajConvert[] =
{
    0,
    1,
    2,
    3,
    4,
    5,
    6,
    248,
    7,
    249,
    250,
    251,
    252,
    253,
    254,
    255
};

/******************************Public*Routine******************************\
* vComputeSubspaces
*
* Calculates the subspace data associated with rgb, stores the data at
* pvVertexData, in the form of an array of VERTEX_DATA structures,
* suitable for vDitherColor. Returns a pointer to the byte after the
* last VERTEX_DATA structure.
*
* Ignores the high byte of rgb.
*
\**************************************************************************/

VERTEX_DATA* vComputeSubspaces(
ULONG           rgb,
VERTEX_DATA*    pvVertexData)
{
    ULONG   ulRedTemp, ulGreenTemp, ulBlueTemp, ulSymmetry;
    ULONG   ulRed, ulGre, ulBlu, ulTemp;
    ULONG   ulVertex0Temp, ulVertex1Temp, ulVertex2Temp, ulVertex3Temp;

    // Split the color into red, green, and blue components
    ulRedTemp   = ((PAL_ULONG *)&rgb)->pal.peRed;
    ulGreenTemp   = ((PAL_ULONG *)&rgb)->pal.peGreen;
    ulBlueTemp   = ((PAL_ULONG *)&rgb)->pal.peBlue;

    // Sort the RGB so that the point is transformed into subspace 0, and
    // keep track of the swaps in ulSymmetry so we can unravel it again
    // later.  We want r >= g >= b (subspace 0).
    ulSymmetry = 0;
    if (ulBlueTemp > ulRedTemp) {
        SWAPTHEM(ulBlueTemp,ulRedTemp);
        ulSymmetry = SWAP_RB;
    }

    if (ulBlueTemp > ulGreenTemp) {
        SWAPTHEM(ulBlueTemp,ulGreenTemp);
        ulSymmetry |= SWAP_GB;
    }

    if (ulGreenTemp > ulRedTemp) {
        SWAPTHEM(ulGreenTemp,ulRedTemp);
        ulSymmetry |= SWAP_RG;
    }

    ulSymmetry <<= 4;   // for lookup purposes

    // Scale the values from 0-255 to 0-64. Note that the scaling is not
    // symmetric at the ends; this is done to match Windows 3.1 dithering
    ulRed = (ulRedTemp + 1) >> 2;
    ulGre = (ulGreenTemp + 1) >> 2;
    ulBlu = (ulBlueTemp + 1) >> 2;

    // Compute the subsubspace within subspace 0 in which the point lies,
    // then calculate the # of pixels to dither in the colors that are the
    // four vertexes of the tetrahedron bounding the color we're emulating.
    // Only vertices with more than zero pixels are stored, and the
    // vertices are stored in order of increasing intensity, saving us the
    // need to sort them later
    if ((ulRedTemp + ulGreenTemp) > 256) {
        // Subsubspace 2 or 3
        if ((ulRedTemp + ulBlueTemp) > 256) {
            // Subsubspace 3
            // Calculate the number of pixels per vertex, still in
            // subsubspace 3, then convert to original subspace. The pixel
            // counts and vertex numbers are matching pairs, stored in
            // ascending intensity order, skipping vertices with zero
            // pixels. The vertex intensity order for subsubspace 3 is:
            // 7, 9, 0x0B, 0x0F
            if ((ulVertex0Temp = (64 - ulRed) << 1) != 0) {
                pvVertexData->ulCount = ulVertex0Temp;
                pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x07];
            }
            ulVertex2Temp = ulGre - ulBlu;
            ulVertex3Temp = (ulRed - 64) + ulBlu;
            if ((ulVertex1Temp = ((PATTERNSIZE - ulVertex0Temp) -
                    ulVertex2Temp) - ulVertex3Temp) != 0) {
                pvVertexData->ulCount = ulVertex1Temp;
                pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x09];
            }
            if (ulVertex2Temp != 0) {
                pvVertexData->ulCount = ulVertex2Temp;
                pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x0B];
            }
            if (ulVertex3Temp != 0) {
                pvVertexData->ulCount = ulVertex3Temp;
                pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x0F];
            }
        } else {
            // Subsubspace 2
            // Calculate the number of pixels per vertex, still in
            // subsubspace 2, then convert to original subspace. The pixel
            // counts and vertex numbers are matching pairs, stored in
            // ascending intensity order, skipping vertices with zero
            // pixels. The vertex intensity order for subsubspace 2 is:
            // 3, 7, 9, 0x0B
            ulVertex1Temp = ulBlu << 1;
            ulVertex2Temp = ulRed - ulGre;
            ulVertex3Temp = (ulRed - 32) + (ulGre - 32);
            if ((ulVertex0Temp = ((PATTERNSIZE - ulVertex1Temp) -
                        ulVertex2Temp) - ulVertex3Temp) != 0) {
                pvVertexData->ulCount = ulVertex0Temp;
                pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x03];
            }
            if (ulVertex1Temp != 0) {
                pvVertexData->ulCount = ulVertex1Temp;
                pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x07];
            }
            if (ulVertex2Temp != 0) {
                pvVertexData->ulCount = ulVertex2Temp;
                pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x09];
            }
            if (ulVertex3Temp != 0) {
                pvVertexData->ulCount = ulVertex3Temp;
                pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x0B];
            }
        }
    } else {
        // Subsubspace 0 or 1
        if (ulRedTemp > 128) {
            // Subsubspace 1
            // Calculate the number of pixels per vertex, still in
            // subsubspace 1, then convert to original subspace. The pixel
            // counts and vertex numbers are matching pairs, stored in
            // ascending intensity order, skipping vertices with zero
            // pixels. The vertex intensity order for subsubspace 1 is:
            // 1, 3, 7, 9
            if ((ulVertex0Temp = ((32 - ulGre) + (32 - ulRed)) << 1) != 0) {
                pvVertexData->ulCount = ulVertex0Temp;
                pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x01];
            }
            ulVertex2Temp = ulBlu << 1;
            ulVertex3Temp = (ulRed - 32) << 1;
            if ((ulVertex1Temp = ((PATTERNSIZE - ulVertex0Temp) -
                    ulVertex2Temp) - ulVertex3Temp) != 0) {
                pvVertexData->ulCount = ulVertex1Temp;
                pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x03];
            }
            if (ulVertex2Temp != 0) {
                pvVertexData->ulCount = ulVertex2Temp;
                pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x07];
            }
            if (ulVertex3Temp != 0) {
                pvVertexData->ulCount = ulVertex3Temp;
                pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x09];
            }
        } else {
            // Subsubspace 0
            // Calculate the number of pixels per vertex, still in
            // subsubspace 0, then convert to original subspace. The pixel
            // counts and vertex numbers are matching pairs, stored in
            // ascending intensity order, skipping vertices with zero
            // pixels. The vertex intensity order for subsubspace 0 is:
            // 0, 1, 3, 7
            if ((ulVertex0Temp = (32 - ulRed) << 1) != 0) {
                pvVertexData->ulCount = ulVertex0Temp;
                pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x00];
            }
            if ((ulVertex1Temp = (ulRed - ulGre) << 1) != 0) {
                pvVertexData->ulCount = ulVertex1Temp;
                pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x01];
            }
            ulVertex3Temp = ulBlu << 1;
            if ((ulVertex2Temp = ((PATTERNSIZE - ulVertex0Temp) -
                    ulVertex1Temp) - ulVertex3Temp) != 0) {
                pvVertexData->ulCount = ulVertex2Temp;
                pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x03];
            }
            if (ulVertex3Temp != 0) {
                pvVertexData->ulCount = ulVertex3Temp;
                pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x07];
            }
        }
    }

    return(pvVertexData);
}

/******************************Public*Routine******************************\
* vDitherColor
*
* Dithers the ulNumVertices vertices described by vVertexData into pulDest.
*
\**************************************************************************/

VOID vDitherColor(
ULONG*          pulDest,
VERTEX_DATA*    vVertexData,
VERTEX_DATA*    pvVertexDataEnd,
ULONG           ulNumVertices)
{
    ULONG ulTemp, ulNumPixels, ulColor;
    VERTEX_DATA *pvMaxVertex, *pvVertexData;
    ULONG  *pulDitherOrder;
    BYTE    jColor;
    BYTE   *pjDither = (BYTE *)pulDest;

    if (ulNumVertices > 2) {

        // There are 3 or 4 vertices in this dither
        if (ulNumVertices == 3) {

            // There are 3 vertices in this dither

            // Find the vertex with the most pixels, and fill the whole
            // destination bitmap with that vertex's color, which is faster
            // than dithering it
            if (vVertexData[1].ulCount >= vVertexData[2].ulCount) {
                pvMaxVertex = &vVertexData[1];
                ulTemp = vVertexData[1].ulCount;
            } else {
                pvMaxVertex = &vVertexData[2];
                ulTemp = vVertexData[2].ulCount;
            }

        } else {

            // There are 4 vertices in this dither

            // Find the vertex with the most pixels, and fill the whole
            // destination bitmap with that vertex's color, which is faster
            // than dithering it
            if (vVertexData[2].ulCount >= vVertexData[3].ulCount) {
                pvMaxVertex = &vVertexData[2];
                ulTemp = vVertexData[2].ulCount;
            } else {
                pvMaxVertex = &vVertexData[3];
                ulTemp = vVertexData[3].ulCount;
            }
        }

        if (vVertexData[1].ulCount > ulTemp) {
            pvMaxVertex = &vVertexData[1];
            ulTemp = vVertexData[1].ulCount;
        }
        if (vVertexData[0].ulCount > ulTemp) {
            pvMaxVertex = &vVertexData[0];
        }

        // Prepare a dword version of the most common vertex number (color)
        ulColor = ulNibbleToDword[pvMaxVertex->ulVertex];

        // Mark that the vertex we're about to do doesn't need to be done
        // later
        pvMaxVertex->ulVertex = 0xFF;

        // Block fill the dither pattern with the more common vertex
        *pulDest = ulColor;
        *(pulDest+1) = ulColor;
        *(pulDest+2) = ulColor;
        *(pulDest+3) = ulColor;
        *(pulDest+4) = ulColor;
        *(pulDest+5) = ulColor;
        *(pulDest+6) = ulColor;
        *(pulDest+7) = ulColor;
        *(pulDest+8) = ulColor;
        *(pulDest+9) = ulColor;
        *(pulDest+10) = ulColor;
        *(pulDest+11) = ulColor;
        *(pulDest+12) = ulColor;
        *(pulDest+13) = ulColor;
        *(pulDest+14) = ulColor;
        *(pulDest+15) = ulColor;

        // Now dither all the remaining vertices in order 0->2 or 0->3
        // (in order of increasing intensity)
        pulDitherOrder = aulDitherOrder;
        pvVertexData = vVertexData;
        do {
            if (pvVertexData->ulVertex == 0xFF) {
                // This is the max vertex, which we already did, but we
                // have to account for it in the dither order
                pulDitherOrder += pvVertexData->ulCount;
            } else {
                jColor = (BYTE) ajConvert[pvVertexData->ulVertex];
                ulNumPixels = pvVertexData->ulCount;
                switch (ulNumPixels & 3) {
                    case 3:
                        pjDither[*(pulDitherOrder+2)] = jColor;
                    case 2:
                        pjDither[*(pulDitherOrder+1)] = jColor;
                    case 1:
                        pjDither[*(pulDitherOrder+0)] = jColor;
                        pulDitherOrder += ulNumPixels & 3;
                    case 0:
                        break;
                }
                if ((ulNumPixels >>= 2) != 0) {
                    do {
                        pjDither[*pulDitherOrder] = jColor;
                        pjDither[*(pulDitherOrder+1)] = jColor;
                        pjDither[*(pulDitherOrder+2)] = jColor;
                        pjDither[*(pulDitherOrder+3)] = jColor;
                        pulDitherOrder += 4;
                    } while (--ulNumPixels);
                }
            }
        } while (++pvVertexData < pvVertexDataEnd);

    } else if (ulNumVertices == 2) {

        // There are exactly two vertices with more than zero pixels; fill
        // in the dither array as follows: block fill with vertex with more
        // points first, then dither in the other vertex
        if (vVertexData[0].ulCount >= vVertexData[1].ulCount) {
            // There are no more vertex 1 than vertex 0 pixels, so do
            // the block fill with vertex 0
            ulColor = ulNibbleToDword[vVertexData[0].ulVertex];
            // Do the dither with vertex 1
            jColor = (BYTE) ajConvert[vVertexData[1].ulVertex];
            ulNumPixels = vVertexData[1].ulCount;
            // Set where to start dithering with vertex 1 (vertex 0 is
            // lower intensity, so its pixels come first in the dither
            // order)
            pulDitherOrder = aulDitherOrder + vVertexData[0].ulCount;
        } else {
            // There are more vertex 1 pixels, so do the block fill
            // with vertex 1
            ulColor = ulNibbleToDword[vVertexData[1].ulVertex];
            // Do the dither with vertex 0
            jColor = (BYTE) ajConvert[vVertexData[0].ulVertex];
            ulNumPixels = vVertexData[0].ulCount;
            // Set where to start dithering with vertex 0 (vertex 0 is
            // lower intensity, so its pixels come first in the dither
            // order)
            pulDitherOrder = aulDitherOrder;
        }

        // Block fill the dither pattern with the more common vertex
        *pulDest = ulColor;
        *(pulDest+1) = ulColor;
        *(pulDest+2) = ulColor;
        *(pulDest+3) = ulColor;
        *(pulDest+4) = ulColor;
        *(pulDest+5) = ulColor;
        *(pulDest+6) = ulColor;
        *(pulDest+7) = ulColor;
        *(pulDest+8) = ulColor;
        *(pulDest+9) = ulColor;
        *(pulDest+10) = ulColor;
        *(pulDest+11) = ulColor;
        *(pulDest+12) = ulColor;
        *(pulDest+13) = ulColor;
        *(pulDest+14) = ulColor;
        *(pulDest+15) = ulColor;

        // Dither in the less common vertex
        switch (ulNumPixels & 3) {
            case 3:
                pjDither[*(pulDitherOrder+2)] = jColor;
            case 2:
                pjDither[*(pulDitherOrder+1)] = jColor;
            case 1:
                pjDither[*(pulDitherOrder+0)] = jColor;
                pulDitherOrder += ulNumPixels & 3;
            case 0:
                break;
        }
        if ((ulNumPixels >>= 2) != 0) {
            do {
                pjDither[*pulDitherOrder] = jColor;
                pjDither[*(pulDitherOrder+1)] = jColor;
                pjDither[*(pulDitherOrder+2)] = jColor;
                pjDither[*(pulDitherOrder+3)] = jColor;
                pulDitherOrder += 4;
            } while (--ulNumPixels);
        }

    } else {

        // There is only one vertex in this dither

        // No sorting or dithering is needed for just one color; we can
        // just generate the final DIB directly
        ulColor = ulNibbleToDword[vVertexData[0].ulVertex];
        *pulDest = ulColor;
        *(pulDest+1) = ulColor;
        *(pulDest+2) = ulColor;
        *(pulDest+3) = ulColor;
        *(pulDest+4) = ulColor;
        *(pulDest+5) = ulColor;
        *(pulDest+6) = ulColor;
        *(pulDest+7) = ulColor;
        *(pulDest+8) = ulColor;
        *(pulDest+9) = ulColor;
        *(pulDest+10) = ulColor;
        *(pulDest+11) = ulColor;
        *(pulDest+12) = ulColor;
        *(pulDest+13) = ulColor;
        *(pulDest+14) = ulColor;
        *(pulDest+15) = ulColor;
    }
}

VOID vDitherColorToVideoMemory(
ULONG*          pulDest,
VERTEX_DATA*    vVertexData,
VERTEX_DATA*    pvVertexDataEnd,
ULONG           ulNumVertices)
{
    ULONG ulTemp, ulNumPixels, ulColor;
    VERTEX_DATA *pvMaxVertex, *pvVertexData;
    ULONG  *pulDitherOrder;
    BYTE    jColor;
    BYTE   *pjDither = (BYTE *)pulDest;
    ULONG i;

    if (ulNumVertices > 2) {

        // There are 3 or 4 vertices in this dither
        if (ulNumVertices == 3) {

            // There are 3 vertices in this dither

            // Find the vertex with the most pixels, and fill the whole
            // destination bitmap with that vertex's color, which is faster
            // than dithering it
            if (vVertexData[1].ulCount >= vVertexData[2].ulCount) {
                pvMaxVertex = &vVertexData[1];
                ulTemp = vVertexData[1].ulCount;
            } else {
                pvMaxVertex = &vVertexData[2];
                ulTemp = vVertexData[2].ulCount;
            }

        } else {

            // There are 4 vertices in this dither

            // Find the vertex with the most pixels, and fill the whole
            // destination bitmap with that vertex's color, which is faster
            // than dithering it
            if (vVertexData[2].ulCount >= vVertexData[3].ulCount) {
                pvMaxVertex = &vVertexData[2];
                ulTemp = vVertexData[2].ulCount;
            } else {
                pvMaxVertex = &vVertexData[3];
                ulTemp = vVertexData[3].ulCount;
            }
        }

        if (vVertexData[1].ulCount > ulTemp) {
            pvMaxVertex = &vVertexData[1];
            ulTemp = vVertexData[1].ulCount;
        }
        if (vVertexData[0].ulCount > ulTemp) {
            pvMaxVertex = &vVertexData[0];
        }

        // Prepare a dword version of the most common vertex number (color)
        ulColor = ulNibbleToDword[pvMaxVertex->ulVertex];

        // Mark that the vertex we're about to do doesn't need to be done
        // later
        pvMaxVertex->ulVertex = 0xFF;

        // Block fill the dither pattern with the more common vertex

        for (i=0; i<16; i++) {
            WRITE_REGISTER_ULONG(pulDest+i, ulColor);
        }

        // Now dither all the remaining vertices in order 0->2 or 0->3
        // (in order of increasing intensity)
        pulDitherOrder = aulDitherOrder;
        pvVertexData = vVertexData;
        do {
            if (pvVertexData->ulVertex == 0xFF) {
                // This is the max vertex, which we already did, but we
                // have to account for it in the dither order
                pulDitherOrder += pvVertexData->ulCount;
            } else {
                jColor = (BYTE) ajConvert[pvVertexData->ulVertex];
                ulNumPixels = pvVertexData->ulCount;
                switch (ulNumPixels & 3) {
                    case 3:
                        WRITE_REGISTER_UCHAR(&pjDither[*(pulDitherOrder+2)], jColor);
                    case 2:
                        WRITE_REGISTER_UCHAR(&pjDither[*(pulDitherOrder+1)], jColor);
                    case 1:
                        WRITE_REGISTER_UCHAR(&pjDither[*(pulDitherOrder+0)], jColor);
                        pulDitherOrder += ulNumPixels & 3;
                    case 0:
                        break;
                }
                if ((ulNumPixels >>= 2) != 0) {
                    do {
                        WRITE_REGISTER_UCHAR(&pjDither[*pulDitherOrder], jColor);
                        WRITE_REGISTER_UCHAR(&pjDither[*(pulDitherOrder+1)], jColor);
                        WRITE_REGISTER_UCHAR(&pjDither[*(pulDitherOrder+2)], jColor);
                        WRITE_REGISTER_UCHAR(&pjDither[*(pulDitherOrder+3)], jColor);

                        pulDitherOrder += 4;
                    } while (--ulNumPixels);
                }
            }
        } while (++pvVertexData < pvVertexDataEnd);


    } else if (ulNumVertices == 2) {

        // There are exactly two vertices with more than zero pixels; fill
        // in the dither array as follows: block fill with vertex with more
        // points first, then dither in the other vertex
        if (vVertexData[0].ulCount >= vVertexData[1].ulCount) {
            // There are no more vertex 1 than vertex 0 pixels, so do
            // the block fill with vertex 0
            ulColor = ulNibbleToDword[vVertexData[0].ulVertex];
            // Do the dither with vertex 1
            jColor = (BYTE) ajConvert[vVertexData[1].ulVertex];
            ulNumPixels = vVertexData[1].ulCount;
            // Set where to start dithering with vertex 1 (vertex 0 is
            // lower intensity, so its pixels come first in the dither
            // order)
            pulDitherOrder = aulDitherOrder + vVertexData[0].ulCount;
        } else {
            // There are more vertex 1 pixels, so do the block fill
            // with vertex 1
            ulColor = ulNibbleToDword[vVertexData[1].ulVertex];
            // Do the dither with vertex 0
            jColor = (BYTE) ajConvert[vVertexData[0].ulVertex];
            ulNumPixels = vVertexData[0].ulCount;
            // Set where to start dithering with vertex 0 (vertex 0 is
            // lower intensity, so its pixels come first in the dither
            // order)
            pulDitherOrder = aulDitherOrder;
        }

        // Block fill the dither pattern with the more common vertex

        for (i=0; i<16; i++) {
            WRITE_REGISTER_ULONG(pulDest+i, ulColor);
        }

        // Dither in the less common vertex
        switch (ulNumPixels & 3) {
            case 3:
                WRITE_REGISTER_UCHAR(&pjDither[*(pulDitherOrder+2)], jColor);
            case 2:
                WRITE_REGISTER_UCHAR(&pjDither[*(pulDitherOrder+1)], jColor);
            case 1:
                WRITE_REGISTER_UCHAR(&pjDither[*(pulDitherOrder+0)], jColor);
                pulDitherOrder += ulNumPixels & 3;
            case 0:
                break;
        }
        if ((ulNumPixels >>= 2) != 0) {
            do {

                WRITE_REGISTER_UCHAR(&pjDither[*pulDitherOrder], jColor);
                WRITE_REGISTER_UCHAR(&pjDither[*(pulDitherOrder+1)], jColor);
                WRITE_REGISTER_UCHAR(&pjDither[*(pulDitherOrder+2)], jColor);
                WRITE_REGISTER_UCHAR(&pjDither[*(pulDitherOrder+3)], jColor);
                pulDitherOrder += 4;
            } while (--ulNumPixels);
        }

    } else {

        // There is only one vertex in this dither

        // No sorting or dithering is needed for just one color; we can
        // just generate the final DIB directly
        ulColor = ulNibbleToDword[vVertexData[0].ulVertex];

        for (i=0; i<16; i++) {
            WRITE_REGISTER_ULONG(pulDest+i, ulColor);
        }

    }
}

/******************************Public*Routine******************************\
* DrvDitherColor
*
* Dithers an RGB color to an 8X8 approximation using the reserved VGA
* colours.
*
\**************************************************************************/

ULONG DrvDitherColor(
DHPDEV  dhpdev,
ULONG   iMode,
ULONG   rgb,
ULONG*  pul)
{
    ULONG   ulGrey, ulRed, ulGre, ulBlu, ulTemp;
    VERTEX_DATA vVertexData[4];
    VERTEX_DATA *pvVertexData;

    // Figure out if we need a full color dither or only a monochrome dither.

    // Note: we'll get colour dithers only at 8bpp, because that's the
    //       only colour depth at which we set GCAPS_COLOR_DITHER.

    if (iMode != DM_MONOCHROME)
    {
        // Full color dither

        // Calculate what color subspaces are involved in the dither
        pvVertexData = vComputeSubspaces(rgb, vVertexData);

        // Now that we have found the bounding vertices and the number of
        // pixels to dither for each vertex, we can create the dither pattern

        // Handle 1, 2, and 3 & 4 vertices per dither separately
        ulTemp = (ULONG)(pvVertexData - vVertexData);// # of vertices with more
                                                //than zero pixels in the dither

        vDitherColor(pul, vVertexData, pvVertexData, ulTemp);
    }
    else
    {
        // Note: we can get monochrome dithers at any colour depth because
        //       we always set GCAPS_MONO_DITHER.

        // For monochrome we will only use the Intensity (grey level)

        RtlFillMemory((PVOID) pul, PATTERNSIZE/2, 0);  // zero the dither bits

        ulRed   = (ULONG) ((PALETTEENTRY *) &rgb)->peRed;
        ulGre = (ULONG) ((PALETTEENTRY *) &rgb)->peGreen;
        ulBlu  = (ULONG) ((PALETTEENTRY *) &rgb)->peBlue;

        // I = .30R + .59G + .11B
        // For convenience the following ratios are used:
        //
        //  77/256 = 30.08%
        // 151/256 = 58.98%
        //  28/256 = 10.94%

        ulGrey  = (((ulRed * 77) + (ulGre * 151) + (ulBlu * 28)) >> 8) & 255;

        // Convert the RGBI from 0-255 to 0-64 notation.

        ulGrey = (ulGrey + 1) >> 2;

        while(ulGrey) {
            ulGrey--;
            pul[ajByte[ulGrey]] |= ((ULONG) ajBits[ulGrey]);
        }
    }

    return(DCR_DRIVER);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\cirrus\disp\debug.h ===
/******************************************************************************\
*
* $Workfile:   debug.h  $
*
* Commonly used debugging macros.
*
* Copyright (c) 1992-1995 Microsoft Corporation
* Copyright (c) 1996 Cirrus Logic, Inc.
*
* $Log:   S:/projects/drivers/ntsrc/display/debug.h_v  $
 * 
 *    Rev 1.1   Oct 10 1996 15:36:34   unknown
 *  
* 
*    Rev 1.1   12 Aug 1996 16:47:44   frido
* Added NT 3.5x/4.0 auto detection.
*
\******************************************************************************/

//#if DBG
#if (DBG_STRESS_FAILURE || DBG)

    VOID
    DebugPrint(
        ULONG DebugPrintLevel,
        PCHAR DebugMessage,
        ...
        );


    VOID
    PerfPrint(
        ULONG PerfPrintLevel,
        PCHAR PerfMessage,
        ...
        );

    #define DISPDBG(arg) DebugPrint arg
    #define DISPPRF(arg) PerfPrint arg
#if (NT_VERSION < 0x0400)
    #define RIP(x) { DebugPrint(0, x); DebugBreak(); }
#else
    #define RIP(x) { DebugPrint(0, x); EngDebugBreak(); }
#endif
    #define ASSERTDD(x, y) if (!(x)) RIP (y)
    #define STATEDBG(level)    0
    #define LOGDBG(arg)        0

#else

    #define DISPDBG(arg)    0
    #define DISPPRF(arg)    0
    #define RIP(x)            0
    #define ASSERTDD(x, y)    0
    #define STATEDBG(level)    0
    #define LOGDBG(arg)        0

#endif

#define DUMPVAR(x,format_str)   DISPDBG((0,#x" = "format_str,x));
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\cirrus\disp\debug.c ===
/******************************************************************************\
*
* $Workfile:   debug.c  $
*
* Debug helpers routine.
*
* Copyright (c) 1992-1995 Microsoft Corporation
* Copyright (c) 1996 Cirrus Logic, Inc.
*
* $Log:   S:/projects/drivers/ntsrc/display/debug.c_v  $
 * 
 *    Rev 1.2   Nov 26 1996 14:30:30   unknown
 * change to debug level 0
 * 
 *    Rev 1.1   Oct 10 1996 15:36:30   unknown
 *  
* 
*    Rev 1.1   12 Aug 1996 16:51:20   frido
* Added NT 3.5x/4.0 auto detection.
*
\******************************************************************************/

#include "precomp.h"

//#if DBG
#if (DBG_STRESS_FAILURE || DBG)

ULONG DebugLevel = 0;
ULONG PerfLevel = 0;

ULONG gulLastBltLine = 0;
CHAR* glpszLastBltFile = "Uninitialized";
BOOL  gbResetOnTimeout = TRUE;

/*****************************************************************************
 *
 *   Routine Description:
 *
 *      This function is variable-argument, level-sensitive debug print
 *      routine.
 *      If the specified debug level for the print statement is lower or equal
 *      to the current debug level, the message will be printed.
 *
 *   Arguments:
 *
 *      DebugPrintLevel - Specifies at which debugging level the string should
 *          be printed
 *
 *      DebugMessage - Variable argument ascii c string
 *
 *   Return Value:
 *
 *      None.
 *
 ***************************************************************************/

VOID
DebugPrint(
    ULONG DebugPrintLevel,
    PCHAR DebugMessage,
    ...
    )

{

    va_list ap;

    va_start(ap, DebugMessage);

    if (DebugPrintLevel <= DebugLevel)
    {
#if (NT_VERSION < 0x0400)
        char szBuffer[256];

        vsprintf(szBuffer, DebugMessage, ap);
        OutputDebugString(szBuffer);
#else
        EngDebugPrint(STANDARD_DEBUG_PREFIX, DebugMessage, ap);
        EngDebugPrint("", "\n", ap);
#endif
    }

    va_end(ap);

}


/*****************************************************************************
 *
 *   Routine Description:
 *
 *      This function is variable-argument, level-sensitive Perf print
 *      routine.
 *      If the specified Perf level for the print statement is lower or equal
 *      to the current Perf level, the message will be printed.
 *
 *   Arguments:
 *
 *      PerfPrintLevel - Specifies at which perf level the string should
 *          be printed
 *
 *      PerfMessage - Variable argument ascii c string
 *
 *   Return Value:
 *
 *      None.
 *
 ***************************************************************************/

VOID
PerfPrint(
    ULONG PerfPrintLevel,
    PCHAR PerfMessage,
    ...
    )

{

    va_list ap;

    va_start(ap, PerfMessage);

    if (PerfPrintLevel <= PerfLevel)
    {
#if (NT_VERSION < 0x0400)
        char szBuffer[256];

        vsprintf(szBuffer, PerfMessage, ap);
        OutputDebugString(szBuffer);
#else
        EngDebugPrint(STANDARD_PERF_PREFIX, PerfMessage, ap);
        EngDebugPrint("", "\n", ap);
#endif
    }

    va_end(ap);

}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\cirrus\disp\driver.h ===
/******************************************************************************\
*
* $Workfile:   driver.h  $
*
* Contains prototypes for the display driver.
*
* Copyright (c) 1992-1995 Microsoft Corporation
* Copyright (c) 1996 Cirrus Logic, Inc.
*
*
* $Log:   S:/projects/drivers/ntsrc/display/driver.h_v  $
 *
 *    Rev 1.7   Apr 03 1997 15:38:48   unknown
 *
 *
 *    Rev 1.6   28 Mar 1997 16:08:38   PLCHU
 *
 *
 *    Rev 1.5   18 Dec 1996 13:44:08   PLCHU
 *
 *
 *    Rev 1.4   Dec 13 1996 12:16:18   unknown
 *
 *
 *    Rev 1.3   Nov 07 1996 16:43:40   unknown
 * Clean up CAPS flags
 *
 *    Rev 1.1   Oct 10 1996 15:36:36   unknown
 *
*
*    Rev 1.13   12 Aug 1996 16:47:58   frido
* Added NT 3.5x/4.0 auto detection.
*
*    Rev 1.12   08 Aug 1996 16:20:06   frido
* Added vMmCopyBlt36.
*
*    Rev 1.11   31 Jul 1996 15:43:42   frido
* Added new brush caches.
*
*    Rev 1.10   24 Jul 1996 14:38:24   frido
* Added ulFontCacheID for font cache cleanup.
*
*    Rev 1.9   24 Jul 1996 14:30:26   frido
* Changed some structures for a new FONTCACHE chain.
*
*    Rev 1.8   22 Jul 1996 20:45:48   frido
* Added font cache.
*
*    Rev 1.7   19 Jul 1996 01:00:00   frido
* Added Dbg... declarations.
*
*    Rev 1.6   15 Jul 1996 10:58:58   frido
* Changed back to old DirectDraw structures.
*
*    Rev 1.5   12 Jul 1996 17:45:38   frido
* Change DirectDraw structures.
*
*    Rev 1.4   10 Jul 1996 13:07:34   frido
* Changed LineTo function.
*
*    Rev 1.3   09 Jul 1996 17:58:30   frido
* Added LineTo code.
*
*    Rev 1.2   03 Jul 1996 13:44:36   frido
* Fixed a typo.
*
*    Rev 1.1   03 Jul 1996 13:38:54   frido
* Added DirectDraw support.
*
*    sge01  10-23-96 Add 5446BE flag
*
*    chu01  12-16-96 Enable color correction
*
* myf0 : 08-19-96  added 85hz supported
* myf1 : 08-20-96  supported panning scrolling
* myf2 : 08-20-96 : fixed hardware save/restore state bug for matterhorn
* myf3 : 09-01-96 : Added IOCTL_CIRRUS_PRIVATE_BIOS_CALL for TV supported
* myf4 : 09-01-96 : patch Viking BIOS bug, PDR #4287, begin
* myf5 : 09-01-96 : Fixed PDR #4365 keep all default refresh rate
* myf6 : 09-17-96 : Merged Desktop SRC1001 & MINI102
* myf7 : 09-19-96 : Fixed exclude 60Hz refresh rate selected
* myf8 :*09-21-96*: May be need change CheckandUpdateDDC2BMonitor --keystring[]
* myf9 : 09-21-96 : 8x6 panel in 6x4x256 mode, cursor can't move to bottom scrn
* ms0809:09-25-96 : fixed dstn panel icon corrupted
* ms923 :09-25-96 : merge MS-923 Disp.zip code
* myf10 :09-26-96 : Fixed DSTN reserved half-frame buffer bug.
* myf11 :09-26-96 : Fixed 755x CE chip HW bug, access ramdac before disable HW
*                   icons and cursor
* myf12 :10-01-96 : Supported Hot Key switch display
* myf13 :10-05-96 : Fixed /w panning scrolling, vertical expension on bug
* myf14 :10-15-96 : Fixed PDR#6917, 6x4 panel can't panning scrolling for 754x
* myf15 :10-16-96 : Fixed disable memory mapped IO for 754x, 755x
* myf16 :10-22-96 : Fixed PDR #6933,panel type set different demo board setting
* tao1 : 10-21-96 : added direct draw support for 7555.
* pat04: 12-20-96 : Supported NT3.51 software cursor with panning scrolling
* myf33 :03-21-97 : Support TV ON/OFF
*

\******************************************************************************/

//////////////////////////////////////////////////////////////////////
// Warning:  The following defines are for private use only.  They
//           should only be used in such a fashion that when defined as 0,
//           all code specific to punting is optimized out completely.

#define DRIVER_PUNT_ALL         0

#define DRIVER_PUNT_LINES       0
#define DRIVER_PUNT_BLT         0
#define DRIVER_PUNT_STRETCH     0
#define DRIVER_PUNT_PTR         1
#define DRIVER_PUNT_BRUSH       0

// myf1 09-01-96
//myf17   #define PANNING_SCROLL              //myf1

//////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////
// Put all the conditional-compile constants here.  There had better
// not be many!

// Some Mips machines have bus problems that prevent GDI from being able
// to draw on the frame buffer.  The DIRECT_ACCESS() macro is used to
// determine if we are running on one of these machines.  Also, we map
// video memory as sparse on the ALPHA, so we need to control access to
// the framebuffer through the READ/WRITE_REGISTER macros.

#if defined(_ALPHA_)
    #define DIRECT_ACCESS(ppdev)    FALSE
#else
    #define DIRECT_ACCESS(ppdev)    TRUE
#endif

#define BANKING                     TRUE        //ms923

#define HOST_XFERS_DISABLED(ppdev)  (ppdev->pulXfer == NULL)

// Useful for visualizing the 2-d heap:

#define DEBUG_HEAP              FALSE

//////////////////////////////////////////////////////////////////////
// Miscellaneous shared stuff

#if (_WIN32_WINNT < 0x0400)
        // NT 3.51
        #define DLL_NAME                                L"cirrus35"     // Name of the DLL in UNICODE
        #define NT_VERSION                              0x0351
        #define ALLOC(c)                                LocalAlloc(LPTR, c)
        #define FREE(ptr)                               LocalFree(ptr)
        #define IOCONTROL(h, ctrl, in, cin, out, cout, c)                          \
                (DeviceIoControl(h, ctrl, in, cin, out, cout, c, NULL) == TRUE)
#else
        // NT 4.0
        #define DLL_NAME                L"cirrus"   // Name of the DLL in UNICODE
        #define NT_VERSION                              0x0400
        #define ALLOC(c)                                EngAllocMem(FL_ZERO_MEMORY, c, ALLOC_TAG)
        #define FREE(ptr)                               EngFreeMem(ptr)
        #define IOCONTROL(h, ctrl, in, cin, out, cout, c)                          \
                   (EngDeviceIoControl(h, ctrl, in, cin, out, cout, c) == ERROR_SUCCESS)
#endif

// Default values if not yet defined.
#ifndef GDI_DRIVER_VERSION
    #define GDI_DRIVER_VERSION              0x3500
#endif
#ifndef VIDEO_MODE_MAP_MEM_LINEAR
    #define VIDEO_MODE_MAP_MEM_LINEAR       0x40000000
#endif

#define STANDARD_PERF_PREFIX    "Cirrus [perf]: " // All perf output is prefixed
                                                  //   by this string
#define STANDARD_DEBUG_PREFIX   "Cirrus: "  // All debug output is prefixed
                                            //   by this string
#define ALLOC_TAG               ' lcD'      // Dcl
                                            // Four byte tag (characters in
                                            // reverse order) used for memory
                                            // allocations

#define CLIP_LIMIT          50  // We'll be taking 800 bytes of stack space

#define DRIVER_EXTRA_SIZE   0   // Size of the DriverExtra information in the
                                //   DEVMODE structure

#define TMP_BUFFER_SIZE     8192  // Size in bytes of 'pvTmpBuffer'.  Has to
                                  //   be at least enough to store an entire
                                  //   scan line (i.e., 6400 for 1600x1200x32).

typedef struct _CLIPENUM {
    LONG    c;
    RECTL   arcl[CLIP_LIMIT];   // Space for enumerating complex clipping

} CLIPENUM;                         /* ce, pce */

////////////////////////////////////////////////////////////////////////////////
//         D R I V E R   C A P A B I L I T I E S                  //
////////////////////////////////////////////////////////////////////////////////

#if (NT_VERSION < 0x0400)
        #define DIRECTDRAW              0       // DirectDraw not supported in NT 3.5x
        #define LINETO                  0       // DrvLineTo not supported in NT 3.5x
#else
        #define DIRECTDRAW              1       // DirectDraw supported in NT 4.0
        #define LINETO                  0       // DrvLineTo not supported in NT 4.0
#endif

typedef struct _PDEV PDEV;      // Handy forward declaration

//////////////////////////////////////////////////////////////////////
// Text stuff

#if 1 // Font cache.
#define MAX_GLYPHS      256     // Maximum number of glyphs per font.
#define FONT_ALLOC_X    128     // X allocation per font block in bytes.
#define FONT_ALLOC_Y    32      // Maximum height of font.

typedef struct _OH                      OH;
typedef struct _FONTMEMORY      FONTMEMORY;
typedef struct _FONTCACHE       FONTCACHE;

typedef struct _FONTMEMORY {
OH*             poh;            // Pointer to allocated memory block.
LONG            x;              // Last x of allocation.
LONG            cx, cy;         // Size of allocation in bytes.
LONG            xy;             // Linear address of current line.
FONTMEMORY* pfmNext;            // Pointer to next allocated memory block.
} FONTMEMORY;

#define GLYPH_UNCACHEABLE       -1
#define GLYPH_EMPTY             -2

typedef struct _GLYPHCACHE {
BYTE*  pjGlyph;                 // Linear address of glyph.
        // If pjPos == NULL then glyph has not yet been cached.
POINTL ptlOrigin;               // Origin of glyph.
SIZEL  sizlBytes;               // Adjusted size of glyph.
SIZEL  sizlPixels;              // Size of glyph.
        // If sizlSize.cy == -1 then glyph if uncacheable.
        // If sizlSize.cy == -2 then glyph is empty.
LONG   lDelta;                  // Width of glyph on bytes.
} GLYPHCACHE;

typedef struct _FONTCACHE {
PDEV*           ppdev;          // Pointer to PDEV structure.
FONTMEMORY* pfm;                // Pointer to first FONTMEMORY structure.
LONG            cWidth;         // Width of allocation in pixels.
LONG            cHeight;        // Height of allocation in pixels.
ULONG           ulFontCacheID;  // Font cache ID.
FONTOBJ*        pfo;            // Pointer to FONT object for this cache.
FONTCACHE*      pfcPrev;        // Pointer to previous FONTCACHE structure.
FONTCACHE*      pfcNext;        // Pointer to next FONTCACHE structure.
GLYPHCACHE      aGlyphs[MAX_GLYPHS];    // Array of cached glyphs.
} FONTCACHE;

typedef struct _XLATECOLORS {       // Specifies foreground and background
ULONG   iBackColor;                 //   colours for faking a 1bpp XLATEOBJ
ULONG   iForeColor;
} XLATECOLORS;                      /* xlc, pxlc */

BOOL bEnableText(PDEV*);
VOID vDisableText(PDEV*);
VOID vAssertModeText(PDEV*, BOOL);
VOID vClearMemDword(ULONG*, ULONG);

LONG  cGetGlyphSize(GLYPHBITS*, POINTL*, SIZEL*);
LONG  lAllocateGlyph(FONTCACHE*, GLYPHBITS*, GLYPHCACHE*);
BYTE* pjAllocateFontCache(FONTCACHE*, LONG);
BOOL  bFontCache(PDEV*, STROBJ*, FONTOBJ*, CLIPOBJ*, RECTL*, BRUSHOBJ*,
                                 BRUSHOBJ*);
VOID  vDrawGlyph(PDEV*, GLYPHBITS*, POINTL);
VOID  vClipGlyph(PDEV*, GLYPHBITS*, POINTL, RECTL*, ULONG);
#if 1 // D5480
VOID vMmGlyphOut(PDEV*, FONTCACHE*, STROBJ*, ULONG);
VOID vMmGlyphOutClip(PDEV*, FONTCACHE*, STROBJ*, RECTL*, ULONG);
VOID vMmGlyphOut80(PDEV*, FONTCACHE*, STROBJ*, ULONG);
VOID vMmGlyphOutClip80(PDEV*, FONTCACHE*, STROBJ*, RECTL*, ULONG);
#endif // endif D5480
#endif

//////////////////////////////////////////////////////////////////////
// Dither stuff

// Describes a single colour tetrahedron vertex for dithering:

typedef struct _VERTEX_DATA {
    ULONG ulCount;              // Number of pixels in this vertex
    ULONG ulVertex;             // Vertex number
} VERTEX_DATA;                      /* vd, pv */

VERTEX_DATA*    vComputeSubspaces(ULONG, VERTEX_DATA*);
VOID            vDitherColor(ULONG*, VERTEX_DATA*, VERTEX_DATA*, ULONG);
VOID            vDitherColorToVideoMemory(ULONG*, VERTEX_DATA*, VERTEX_DATA*, ULONG);

//////////////////////////////////////////////////////////////////////
// Brush stuff

// 'Fast' brushes are used when we have hardware pattern capability:

#define FAST_BRUSH_COUNT        16  // Total number of non-hardware brushes
                                    //   cached off-screen
#define FAST_BRUSH_DIMENSION    8   // Every off-screen brush cache entry
                                    //   is 8 pels in both dimensions
#define FAST_BRUSH_ALLOCATION   8   // We have to align ourselves, so this is
                                    //   the dimension of each brush allocation

// Common to both implementations:

#define RBRUSH_2COLOR           1   // For RBRUSH flags
#if 1 // New brush cache.
#define RBRUSH_PATTERN                  0       // Colored brush.
#define RBRUSH_MONOCHROME               1       // Monochrome brush.
#define RBRUSH_DITHER                   2       // Dithered brush.
#define RBRUSH_XLATE                    3       // 16-color translated brush.
#endif

#define TOTAL_BRUSH_COUNT       FAST_BRUSH_COUNT
                                // This is the maximum number of brushes
                                //   we can possibly have cached off-screen
#define TOTAL_BRUSH_SIZE        64  // We'll only ever handle 8x8 patterns,
                                    //   and this is the number of pels

#define BRUSH_TILE_FACTOR       4   // 2x2 tiled patterns require 4x the space

typedef struct _BRUSHENTRY BRUSHENTRY;

// NOTE: Changes to the RBRUSH or BRUSHENTRY structures must be reflected
//       in strucs.inc!

typedef struct _RBRUSH {
    FLONG       fl;             // Type flags
    ULONG       ulForeColor;    // Foreground colour if 1bpp
    ULONG       ulBackColor;    // Background colour if 1bpp
    POINTL      ptlBrushOrg;    // Brush origin of cached pattern.  Initial
                                //   value should be -1
    BRUSHENTRY* pbe;            // Points to brush-entry that keeps track
                                //   of the cached off-screen brush bits
#if 1 // New brush cache.
    ULONG       ulUniq;         // Unique value for cached brushes.
    ULONG       ulSlot;         // Offset to cache slot (PDEV relative).
    ULONG       ulBrush;        // Offset to off-screen brush.
    LONG        cjBytes;        // Number of bytes in pattern.
#endif
    ULONG       aulPattern[0];  // Open-ended array for keeping copy of the
      // Don't put anything     //   actual pattern bits in case the brush
      //   after here, or       //   origin changes, or someone else steals
      //   you'll be sorry!     //   our brush entry (declared as a ULONG
                                //   for proper dword alignment)

} RBRUSH;                           /* rb, prb */

typedef struct _BRUSHENTRY {
    RBRUSH*     prbVerify;      // We never dereference this pointer to
                                //   find a brush realization; it is only
                                //   ever used in a compare to verify
                                //   that for a given realized brush, our
                                //   off-screen brush entry is still valid.
    LONG        x;              // x-position of cached pattern
    LONG        y;              // y-position of cached pattern
    LONG        xy;             // offset of cached pattern

} BRUSHENTRY;                       /* be, pbe */

typedef union _RBRUSH_COLOR {
    RBRUSH*     prb;
    ULONG       iSolidColor;
} RBRUSH_COLOR;                     /* rbc, prbc */

BOOL bEnableBrushCache(PDEV*);
VOID vDisableBrushCache(PDEV*);
VOID vAssertModeBrushCache(PDEV*, BOOL);

#if 1 // New brush cache.
#define NUM_DITHERS             8
#define NUM_PATTERNS    8
#define NUM_MONOCHROMES 20

typedef struct _DITHERCACHE {
        ULONG ulBrush;                          // Offset to off-screen brush.
        ULONG ulColor;                          // Logical color.
} DITHERCACHE;

typedef struct _PATTERNCACHE {
        ULONG   ulBrush;                        // Offset to off-screen brush.
        RBRUSH* prbUniq;                        // Pointer to realized brush.
} PATTERNCACHE;

typedef struct _MONOCACHE {
        ULONG ulBrush;                          // Offset to off-screen brush cache.
        ULONG ulUniq;                           // Unique counter for brush.
        ULONG ulBackColor;                      // Background color for 24-bpp.
        ULONG ulForeColor;                      // Foreground color for 24-bpp.
        ULONG aulPattern[2];            // Monochrome pattern.
} MONOCACHE;

BOOL bCacheDither(PDEV*, RBRUSH*);
BOOL bCachePattern(PDEV*, RBRUSH*);
BOOL bCacheMonochrome(PDEV*, RBRUSH*);
#endif

//////////////////////////////////////////////////////////////////////
// Stretch stuff

typedef struct _STR_BLT {
    PDEV*   ppdev;
    PBYTE   pjSrcScan;
    LONG    lDeltaSrc;
    LONG    XSrcStart;
    PBYTE   pjDstScan;
    LONG    lDeltaDst;
    LONG    XDstStart;
    LONG    XDstEnd;
    LONG    YDstStart;
    LONG    YDstCount;
    ULONG   ulXDstToSrcIntCeil;
    ULONG   ulXDstToSrcFracCeil;
    ULONG   ulYDstToSrcIntCeil;
    ULONG   ulYDstToSrcFracCeil;
    ULONG   ulXFracAccumulator;
    ULONG   ulYFracAccumulator;
} STR_BLT;

typedef VOID (*PFN_DIRSTRETCH)(STR_BLT*);

VOID vDirectStretch8Narrow(STR_BLT*);
VOID vDirectStretch8(STR_BLT*);
VOID vDirectStretch16(STR_BLT*);
VOID vDirectStretch24(STR_BLT*);
VOID vDirectStretch32(STR_BLT*);

#if 1 // D5480 chu01
VOID vDirectStretch8_80(STR_BLT*)  ;
VOID vDirectStretch16_80(STR_BLT*) ;
VOID vDirectStretch24_80(STR_BLT*) ;
#endif // D5480 chu01

/////////////////////////////////////////////////////////////////////////
// Heap stuff

typedef enum {
    OFL_INUSE       = 1,    // The device bitmap is no longer located in
                            //   off-screen memory; it's been converted to
                            //   a DIB
    OFL_AVAILABLE   = 2,    // Space is in-use
    OFL_PERMANENT   = 4     // Space is available
} OHFLAGS;                  // Space is permanently allocated; never free it

typedef struct _DSURF DSURF;
typedef struct _OH OH;
typedef struct _OH
{
    OHFLAGS  ofl;           // OH_ flags
    LONG     x;             // x-coordinate of left edge of allocation
    LONG     y;             // y-coordinate of top edge of allocation
    LONG     xy;            // offset to top left corner of allocation
    LONG     cx;            // Width in pixels of allocation
    LONG     cy;            // Height in pixels of allocation
    OH*      pohNext;       // When OFL_AVAILABLE, points to the next free node,
                            //   in ascending cxcy value.  This is kept as a
                            //   circular doubly-linked list with a sentinel
                            //   at the end.
                            // When OFL_INUSE, points to the next most recently
                            //   blitted allocation.  This is kept as a circular
                            //   doubly-linked list so that the list can be
                            //   quickly be updated on every blt.
    OH*      pohPrev;       // Opposite of 'pohNext'
    ULONG    cxcy;          // Width and height in a dword for searching
    OH*      pohLeft;       // Adjacent allocation when in-use or available
    OH*      pohUp;
    OH*      pohRight;
    OH*      pohDown;
    DSURF*   pdsurf;        // Points to our DSURF structure
    VOID*    pvScan0;       // Points to start of first scan-line
};                              /* oh, poh */

// This is the smallest structure used for memory allocations:

typedef struct _OHALLOC OHALLOC;
typedef struct _OHALLOC
{
    OHALLOC* pohaNext;
    OH       aoh[1];
} OHALLOC;                      /* oha, poha */

typedef struct _HEAP
{
    LONG     cxMax;         // Largest possible free space by area
    LONG     cyMax;
    OH       ohAvailable;   // Head of available list (pohNext points to
                            //   smallest available rectangle, pohPrev
                            //   points to largest available rectangle,
                            //   sorted by cxcy)
    OH       ohDfb;         // Head of the list of all DFBs currently in
                            //   offscreen memory that are eligible to be
                            //   tossed out of the heap (pohNext points to
                            //   the most recently blitted; pohPrev points
                            //   to least recently blitted)
    OH*      pohFreeList;   // List of OH node data structures available
    OHALLOC* pohaChain;     // Chain of allocations
} HEAP;                         /* heap, pheap */

typedef enum {
    DT_SCREEN,              // Surface is kept in screen memory
    DT_DIB                  // Surface is kept as a DIB
} DSURFTYPE;                    /* dt, pdt */

typedef struct _DSURF
{
    DSURFTYPE dt;           // DSURF status (whether off-screen or in a DIB)
    SIZEL     sizl;         // Size of the original bitmap (could be smaller
                            //   than poh->sizl)
    PDEV*     ppdev;        // Need this for deleting the bitmap
    union {
        OH*         poh;    // If DT_SCREEN, points to off-screen heap node
        SURFOBJ*    pso;    // If DT_DIB, points to locked GDI surface
    };

    // The following are used for DT_DIB only...

    ULONG     cBlt;         // Counts down the number of blts necessary at
                            //   the current uniqueness before we'll consider
                            //   putting the DIB back into off-screen memory
    ULONG     iUniq;        // Tells us whether there have been any heap
                            //   'free's since the last time we looked at
                            //   this DIB

} DSURF;                          /* dsurf, pdsurf */

// GDI expects dword alignment for any bitmaps on which it is expected
// to draw.  Since we occasionally ask GDI to draw directly on our off-
// screen bitmaps, this means that any off-screen bitmaps must be dword
// aligned in the frame buffer.  We enforce this merely by ensuring that
// all off-screen bitmaps are four-pel aligned (we may waste a couple of
// pixels at the higher colour depths):

#define HEAP_X_ALIGNMENT    8

// Number of blts necessary before we'll consider putting a DIB DFB back
// into off-screen memory:

#define HEAP_COUNT_DOWN     6

// Flags for 'pohAllocate':

typedef enum {
    FLOH_ONLY_IF_ROOM       = 0x00000001,   // Don't kick stuff out of off-
                                            //   screen memory to make room
} FLOH;

BOOL bEnableOffscreenHeap(PDEV*);
VOID vDisableOffscreenHeap(PDEV*);
BOOL bAssertModeOffscreenHeap(PDEV*, BOOL);

OH*  pohMoveOffscreenDfbToDib(PDEV*, OH*);
BOOL bMoveDibToOffscreenDfbIfRoom(PDEV*, DSURF*);
OH*  pohAllocatePermanent(PDEV*, LONG, LONG);
BOOL bMoveAllDfbsFromOffscreenToDibs(PDEV* ppdev);
OH*  pohAllocate(PDEV*, LONG, LONG, FLOH);
OH*  pohFree(PDEV*, OH*);
VOID vCalculateMaximum(PDEV*);

/////////////////////////////////////////////////////////////////////////
// Bank manager stuff

#define BANK_DATA_SIZE  80      // Number of bytes to allocate for the
                                //   miniport down-loaded bank code working
                                //   space

typedef struct _BANK
{
    // Private data:

    RECTL    rclDraw;           // Rectangle describing the remaining undrawn
                                //   portion of the drawing operation
    RECTL    rclSaveBounds;     // Saved from original CLIPOBJ for restoration
    BYTE     iSaveDComplexity;  // Saved from original CLIPOBJ for restoration
    BYTE     fjSaveOptions;     // Saved from original CLIPOBJ for restoration
    LONG     iBank;             // Current bank
    PDEV*    ppdev;             // Saved copy

    // Public data:

    SURFOBJ* pso;               // Surface wrapped around the bank.  Has to be
                                //   passed as the surface in any banked call-
                                //   back.
    CLIPOBJ* pco;               // Clip object that is the intersection of the
                                //   original clip object with the bounds of the
                                //   current bank.  Has to be passed as the clip
                                //   object in any banked call-back.

} BANK;                         /* bnk, pbnk */

typedef enum {
    BANK_OFF = 0,       // We've finished using the memory aperture
    BANK_ON,            // We're about to use the memory aperture
    BANK_DISABLE,       // We're about to enter full-screen; shut down banking
    BANK_ENABLE,        // We've exited full-screen; re-enable banking

} BANK_MODE;                    /* bankm, pbankm */

typedef VOID (FNBANKMAP)(PDEV*, LONG);
typedef VOID (FNBANKSELECTMODE)(PDEV*, BANK_MODE);
typedef VOID (FNBANKINITIALIZE)(PDEV*, BOOL);
typedef BOOL (FNBANKCOMPUTE)(PDEV*, RECTL*, RECTL*, LONG*, LONG*);

VOID vBankStart(PDEV*, RECTL*, CLIPOBJ*, BANK*);
BOOL bBankEnum(BANK*);

FNBANKCOMPUTE bBankComputeNonPower2;
FNBANKCOMPUTE bBankComputePower2;

BOOL bEnableBanking(PDEV*);
VOID vDisableBanking(PDEV*);
VOID vAssertModeBanking(PDEV*, BOOL);

/////////////////////////////////////////////////////////////////////////
// Pointer stuff

typedef VOID (FNSHOWPOINTER)(VOID*, BOOL);
typedef VOID (FNMOVEPOINTER)(VOID*, LONG, LONG);
typedef BOOL (FNSETPOINTERSHAPE)(VOID*, LONG, LONG, LONG, LONG, LONG, LONG, BYTE*);
typedef VOID (FNENABLEPOINTER)(VOID*, BOOL);

BOOL bEnablePointer(PDEV*);
VOID vDisablePointer(PDEV*);
VOID vAssertModePointer(PDEV*, BOOL);
VOID vAssertHWiconcursor(PDEV*, BOOL);          //myf11

UCHAR HWcur, HWicon0, HWicon1, HWicon2, HWicon3;        //myf11

/////////////////////////////////////////////////////////////////////////
// Palette stuff

BOOL bEnablePalette(PDEV*);
VOID vDisablePalette(PDEV*);
VOID vAssertModePalette(PDEV*, BOOL);

BOOL bInitializePalette(PDEV*, DEVINFO*);
VOID vUninitializePalette(PDEV*);

#define MAX_CLUT_SIZE (sizeof(VIDEO_CLUT) + (sizeof(ULONG) * 256))

#if DIRECTDRAW
//////////////////////////////////////////////////////////////////////
// DirectDraw stuff

#define ROUND_UP_TO_64K(x)      (((ULONG)(x) + 0xFFFF) & ~0xFFFF)

typedef struct _FLIPRECORD
{
     FLATPTR    fpFlipFrom;             // Surface we last flipped from
     LONGLONG   liFlipTime;             // Time at which last flip occured
     LONGLONG   liFlipDuration;         // Precise amount of time it takes from
                                        // vblank to vblank
     BOOL       bFlipFlag;              // True if we think a flip is still
                                        // pending
     BOOL       bHaveEverCrossedVBlank; // True if we noticed that we switched
                                        // from inactive to vblank
     BOOL       bWasEverInDisplay;      // True is we ever noticed that we were
                                        // inactive
// crus
   DWORD    dwFlipScanLine;
} FLIPRECORD;

BOOL bEnableDirectDraw(PDEV*);
VOID vDisableDirectDraw(PDEV*);
VOID vAssertModeDirectDraw(PDEV*, BOOL);
#endif

//////////////////////////////////////////////////////////////////////
// Low-level blt function prototypes

typedef VOID (FNFILL)(PDEV*, LONG, RECTL*, ROP4, RBRUSH_COLOR, POINTL*);
typedef VOID (FNXFER)(PDEV*, LONG, RECTL*, ROP4, SURFOBJ*, POINTL*,
                      RECTL*, XLATEOBJ*);
typedef VOID (FNCOPY)(PDEV*, LONG, RECTL*, ROP4, POINTL*, RECTL*);
typedef VOID (FNFASTPATREALIZE)(PDEV*, RBRUSH*);
typedef VOID (FNBITS)(PDEV*, SURFOBJ*, RECTL*, POINTL*);
typedef BOOL (FNFASTFILL)(PDEV*, LONG, POINTFIX*, ULONG, ULONG, RBRUSH*,
                          POINTL*, RECTL*);
#if LINETO
typedef BOOL (FNLINETO)(PDEV*, LONG, LONG, LONG, LONG, ULONG, MIX, ULONG);
#endif
#if 1 // D5480
typedef VOID (FNGLYPHOUT)(PDEV*, FONTCACHE*, STROBJ*, ULONG);
typedef VOID (FNGLYPHOUTCLIP)(PDEV*, FONTCACHE*, STROBJ*, RECTL*, ULONG);
#endif // endif D5480
#if 1 // OVERLAY #sge
#if (_WIN32_WINNT >= 0x0400)    //myf33
typedef VOID (FNREGINITVIDEO)(PDEV* ppdev, PDD_SURFACE_LOCAL lpSurface);
typedef VOID (FNREGMOVEVIDEO)(PDEV* ppdev, PDD_SURFACE_LOCAL lpSurface);
typedef BOOL (FNBANDWIDTHEQ)(PDEV* ppdev, WORD wVideoDepth, LPRECTL lpSrc, LPRECTL lpDest, DWORD dwFlags);
typedef VOID (FNDISABLEOVERLAY)(PDEV* ppdev);
typedef VOID (FNCLEARALTFIFO)(PDEV* ppdev);
#endif
#endif

FNFILL              vIoFillPat;
FNFILL              vIoFillSolid;
FNXFER              vIoXfer1bpp;
FNXFER              vIoXfer4bpp;
FNXFER              vIoXferNative;
FNCOPY              vIoCopyBlt;
FNFASTPATREALIZE    vIoFastPatRealize;
#if LINETO
FNLINETO            bIoLineTo;
#endif

FNFILL              vMmFillPat;
FNFILL              vMmFillSolid;
#if 1 // New pattern blt routines.
FNFILL              vMmFillPat36;
FNFILL              vMmFillSolid36;
FNCOPY              vMmCopyBlt36;
#endif
FNXFER              vMmXfer1bpp;
FNXFER              vMmXfer4bpp;
FNXFER              vMmXferNative;
FNCOPY              vMmCopyBlt;
FNFASTPATREALIZE    vMmFastPatRealize;
#if LINETO
FNLINETO            bMmLineTo;
#endif

FNFASTFILL          bFastFill;

FNXFER              vXferNativeSrccopy;
FNXFER              vXferScreenTo1bpp;
FNBITS              vPutBits;
FNBITS              vGetBits;
FNBITS              vPutBitsLinear;
FNBITS              vGetBitsLinear;
#if 1 // D5480
FNGLYPHOUT          vMmGlyphOut;
FNGLYPHOUT          vMmGlyphOut80;
FNGLYPHOUTCLIP      vMmGlyphOutClip;
FNGLYPHOUTCLIP      vMmGlyphOutClip80;
FNFILL              vMmFillSolid80;
FNFILL              vMmFillPat80;
FNCOPY              vMmCopyBlt80;
FNXFER              vMmXfer1bpp80;
FNXFER              vMmXferNative80;
#endif // endif D5480

VOID vPutBits(PDEV*, SURFOBJ*, RECTL*, POINTL*);
VOID vGetBits(PDEV*, SURFOBJ*, RECTL*, POINTL*);
VOID vGetBitsLinear(PDEV*, SURFOBJ*, RECTL*, POINTL*);
VOID vIoSlowPatRealize(PDEV*, RBRUSH*, BOOL);

////////////////////////////////////////////////////////////////////////
// Capabilities flags
//
// These are private flags passed to us from the video miniport.  They
// come from the 'DriverSpecificAttributeFlags' field of the
// 'VIDEO_MODE_INFORMATION' structure (found in 'ntddvdeo.h') passed
// to us via an 'VIDEO_QUERY_AVAIL_MODES' or 'VIDEO_QUERY_CURRENT_MODE'
// IOCTL.
//
// NOTE: These definitions must match those in the video miniport

#define CAPS_NO_HOST_XFER       0x00000002   // Do not use host xfers to
                                             //  the blt engine.
#define CAPS_SW_POINTER         0x00000004   // Use software pointer.
#define CAPS_TRUE_COLOR         0x00000008   // Set upper color registers.
#define CAPS_MM_IO              0x00000010   // Use memory mapped IO.
#define CAPS_BLT_SUPPORT        0x00000020   // BLTs are supported
#define CAPS_IS_542x            0x00000040   // This is a 542x
#define CAPS_AUTOSTART          0x00000080   // Autostart feature support.
#define CAPS_CURSOR_VERT_EXP    0x00000100   // Flag set if 8x6 panel,
#define CAPS_DSTN_PANEL         0x00000200   // DSTN panel in use, ms0809
#define CAPS_VIDEO              0x00000400   // Video support.
#define CAPS_SECOND_APERTURE    0x00000800   // Second aperture support.
#define CAPS_COMMAND_LIST       0x00001000   // Command List support.
#define CAPS_GAMMA_CORRECT      0x00002000   // Color correction.
#define CAPS_VGA_PANEL          0x00004000   // use 6x4 VGA PANEL.
#define CAPS_SVGA_PANEL         0x00008000   // use 8x6 SVGA PANEL.
#define CAPS_XGA_PANEL          0x00010000   // use 10x7 XGA PANEL.
#define CAPS_PANNING            0x00020000   // Panning scrolling supported.
#define CAPS_TV_ON              0x00040000   // TV turn on supported., myf33
#define CAPS_TRANSPARENCY       0x00080000   // Transparency is supported
#define CAPS_ENGINEMANAGED      0x00100000   // Engine managed surface
//myf16, end


////////////////////////////////////////////////////////////////////////
// Status flags

typedef enum {
    STAT_GLYPH_CACHE        = 0x0001,   // Glyph cache successfully allocated
    STAT_BRUSH_CACHE        = 0x0002,   // Brush cache successfully allocated
#if 1 // New status flags.
    STAT_DIRECTDRAW         = 0x0004,   // DirectDraw is enabled.
    STAT_FONT_CACHE         = 0x0008,   // Font cache is available.
    STAT_DITHER_CACHE       = 0x0010,   // Dither cache is available.
    STAT_PATTERN_CACHE      = 0x0020,   // Pattern cache is available.
    STAT_MONOCHROME_CACHE   = 0x0040,   // Monochrome cache is available.
// crus
   STAT_STREAMS_ENABLED    = 0x0080    // Overlay support
#endif
} STATUS;

// crus
#if 1 // OVERLAY #sge
#define MAX_STRETCH_SIZE     1024
typedef struct
{
    RECTL          rDest;
    RECTL          rSrc;
    DWORD          dwFourcc;        //overlay video format
    WORD           wBitCount;       //overlay color depth
    LONG           lAdjustSource;   //when video start address needs adjusting
} OVERLAYWINDOW;
#endif

//
// Merger port and register access
//
#if defined(_X86_) || defined(_IA64_) || defined(_AMD64_)

typedef UCHAR   (*FnREAD_PORT_UCHAR)(PVOID Port);
typedef USHORT  (*FnREAD_PORT_USHORT)(PVOID Port);
typedef ULONG   (*FnREAD_PORT_ULONG)(PVOID Port);
typedef VOID    (*FnWRITE_PORT_UCHAR)(PVOID Port, UCHAR Value);
typedef VOID    (*FnWRITE_PORT_USHORT)(PVOID  Port, USHORT Value);
typedef VOID    (*FnWRITE_PORT_ULONG)(PVOID Port, ULONG Value);

#elif defined(_ALPHA_)

typedef UCHAR   (*FnREAD_PORT_UCHAR)(PVOID Port);
typedef USHORT  (*FnREAD_PORT_USHORT)(PVOID Port);
typedef ULONG   (*FnREAD_PORT_ULONG)(PVOID Port);
typedef VOID    (*FnWRITE_PORT_UCHAR)(PVOID Port, ULONG Value);
typedef VOID    (*FnWRITE_PORT_USHORT)(PVOID  Port, ULONG Value);
typedef VOID    (*FnWRITE_PORT_ULONG)(PVOID Port, ULONG Value);

#endif

////////////////////////////////////////////////////////////////////////
// The Physical Device data structure

typedef struct  _PDEV
{
    LONG        xOffset;
    LONG        yOffset;
    LONG        xyOffset;
    BYTE*       pjBase;                 // Video coprocessor base
    BYTE*       pjPorts;                // Video port base
    BYTE*       pjScreen;               // Points to base screen address
    ULONG       iBitmapFormat;          // BMF_8BPP or BMF_16BPP or BMF_24BPP
                                        //   (our current colour depth)
    ULONG       ulChipID;
    ULONG       ulChipNum;

    // -------------------------------------------------------------------
    // NOTE: Changes up to here in the PDEV structure must be reflected in
    // i386\strucs.inc (assuming you're on an x86, of course)!

    HBITMAP     hbmTmpMono;             // Handle to temporary buffer
    SURFOBJ*    psoTmpMono;             // Temporary surface

    ULONG       flCaps;                 // Capabilities flags

//myf1, begin
    // Panning Scrolling Supported for TI
    LONG        min_Xscreen;    //Visible screen boundary.
    LONG        max_Xscreen;    //Visible screen boundary.
    LONG        min_Yscreen;    //Visible screen boundary.
    LONG        max_Yscreen;    //Visible screen boundary.
    LONG        Hres;           //current mode horizontal piexl.
    LONG        Vres;           //current mode vertical piexl.
//myf1, end
    SHORT       bBlockSwitch;   //display switch block flag     //myf12
    SHORT       bDisplaytype;   //display type, 0:LCD, 1:CRT, 2:SIM  //myf12

    STATUS      flStatus;               // Status flags
    BOOL        bEnabled;               // In graphics mode (not full-screen)

    HANDLE      hDriver;                // Handle to \Device\Screen
    HDEV        hdevEng;                // Engine's handle to PDEV
    HSURF       hsurfScreen;            // Engine's handle to screen surface
    DSURF*      pdsurfScreen;           // Our private DSURF for the screen

    LONG        cxScreen;               // Visible screen width
    LONG        cyScreen;               // Visible screen height
    LONG        cxMemory;               // Width of Video RAM
    LONG        cyMemory;               // Height of Video RAM
    ULONG       ulMemSize;              // Amount of video Memory
    ULONG       ulMode;                 // Mode the mini-port driver is in.
    LONG        lDelta;                 // Distance from one scan to the next.

    FLONG       flHooks;                // What we're hooking from GDI
    LONG        cBitsPerPixel;          // 8 if 8bpp, 16 if 16bpp, 32 if 32bpp
    LONG        cBpp;                   // 1 if 8bpp,  2 if 16bpp, 3 if 24bpp, etc.

    //
    // The compiler should maintain DWORD alignment for the values following
    // the BYTE jModeColor.  There will be an ASSERT to guarentee this.
    //

    BYTE        jModeColor;             // HW flag for current color depth

    ULONG       ulWhite;                // 0xff if 8bpp, 0xffff if 16bpp,
                                        //   0xffffffff if 32bpp
    VOID*       pvTmpBuffer;            // General purpose temporary buffer,
                                        //   TMP_BUFFER_SIZE bytes in size
                                        //   (Remember to synchronize if you
                                        //   use this for device bitmaps or
                                        //   async pointers)
    LONG        lXferBank;
    ULONG*      pulXfer;

    ////////// Low-level blt function pointers:

    FNFILL*     pfnFillSolid;
    FNFILL*     pfnFillPat;
    FNXFER*     pfnXfer1bpp;
    FNXFER*     pfnXfer4bpp;
    FNXFER*     pfnXferNative;
    FNCOPY*     pfnCopyBlt;
    FNFASTPATREALIZE* pfnFastPatRealize;
    FNBITS*     pfnGetBits;
    FNBITS*     pfnPutBits;
#if LINETO
    FNLINETO*   pfnLineTo;
#endif

    ////////// Palette stuff:

    PALETTEENTRY* pPal;                 // The palette if palette managed

//
// chu01 : GAMMACORRECT
//
    PALETTEENTRY* pCurrentPalette ;     // The global palette for gamma
                                        // correction.

    HPALETTE    hpalDefault;            // GDI handle to the default palette.
    FLONG       flRed;                  // Red mask for 16/32bpp bitfields
    FLONG       flGreen;                // Green mask for 16/32bpp bitfields
    FLONG       flBlue;                 // Blue mask for 16/32bpp bitfields

    ////////// Heap stuff:

    HEAP        heap;                   // All our off-screen heap data
    ULONG       iHeapUniq;              // Incremented every time room is freed
                                        //   in the off-screen heap
    SURFOBJ*    psoPunt;                // Wrapper surface for having GDI draw
                                        //   on off-screen bitmaps
    SURFOBJ*    psoPunt2;               // Another one for off-screen to off-
                                        //   screen blts
    OH*         pohScreen;              // Allocation structure for the screen

    ////////// Banking stuff:

    ULONG       ulBankShiftFactor;
    BOOL        bLinearMode;            // True if the framebuffer is linear
    LONG        cjBank;                 // Size of a bank, in bytes
    LONG        cPower2ScansPerBank;    // Used by 'bBankComputePower2'
    LONG        cPower2BankSizeInBytes; // Used by 'bBankComputePower2'
    CLIPOBJ*    pcoBank;                // Clip object for banked call backs
    SURFOBJ*    psoBank;                // Surface object for banked call backs
    SURFOBJ*    psoFrameBuffer;         // Surface object for non-banked call backs
    VOID*       pvBankData;             // Points to aulBankData[0]
    ULONG       aulBankData[BANK_DATA_SIZE / 4];
                                        // Private work area for downloaded
                                        //   miniport banking code

    FNBANKMAP*          pfnBankMap;
    FNBANKSELECTMODE*   pfnBankSelectMode;
    FNBANKCOMPUTE*      pfnBankCompute;

    ////////// Pointer stuff:

    LONG        xPointerHot;            // xHot of current hardware pointer
    LONG        yPointerHot;            // yHot of current hardware pointer
    LONG        xPointerShape;          // xPos of current hardware pointer
    LONG        yPointerShape;          // yPos of current hardware pointer
    SIZEL       sizlPointer;            // Size of current hardware pointer
//ms923    LONG        lDeltaPointer;      // Row offset for hardware pointer
    FLONG       flPointer;              // Flags reflecting pointer state
    PBYTE       pjPointerAndMask;
    PBYTE       pjPointerXorMask;
    LONG        iPointerBank;           // Bank containing pointer shape
    VOID*       pvPointerShape;         // Points to pointer shape when bank
                                        //   is mapped in
    LONG        cjPointerOffset;        // Byte offset from start of frame
                                        //   buffer to off-screen memory where
                                        //   we stored the pointer shape
//pat04, for NT 3.51 software cursor, begin
#if (_WIN32_WINNT < 0x0400)
#ifdef PANNING_SCROLL
    OH*         pjCBackground;
    OH*         pjPointerAndCMask;
    OH*         pjPointerCBitmap ;
    LONG        xcount;
    LONG        ppScanLine;
    LONG        oldx;                   // old x cordinate
    LONG        oldy;                   // old y cordinate
    LONG        globdat;
#endif
#endif
//pat04, for NT 3.51 software cursor, end

    FNSHOWPOINTER*      pfnShowPointer;
    FNMOVEPOINTER*      pfnMovePointer;
    FNSETPOINTERSHAPE*  pfnSetPointerShape;
    FNENABLEPOINTER*    pfnEnablePointer;

    ////////// Brush stuff:

    LONG        iBrushCache;            // Index for next brush to be allocated
    LONG        cBrushCache;            // Total number of brushes cached
    BRUSHENTRY  abe[TOTAL_BRUSH_COUNT]; // Keeps track of brush cache
    ULONG       ulSolidColorOffset;
    ULONG       ulAlignedPatternOffset;

#if 1 // New brush caches.
    LONG         iDitherCache;                  // Index to next dither cache entry.
    DITHERCACHE  aDithers[NUM_DITHERS];         // Dither cache.

    LONG         iPatternCache;                 // Index to next pattern cache entry.
    PATTERNCACHE aPatterns[NUM_PATTERNS];
                                                // Pattern cache.

    LONG         iMonochromeCache;              // Index to next monochrome cache entry.
    MONOCACHE    aMonochromes[NUM_MONOCHROMES];
                                                // Monochrome cache.
#endif

    ////////// DCI stuff:

    BOOL        bSupportDCI;            // True if miniport supports DCI

#if DIRECTDRAW
    ////////// DirectDraw stuff:

    FLIPRECORD  flipRecord;             // Used to track VBlank status
    OH*         pohDirectDraw;          // Off-screen heap allocation for use by
                                        //   DirectDraw
    ULONG       ulCR1B;                 // Contents of CR1B register.
    ULONG       ulCR1D;                 // Contents of CR1D register.
    DWORD       dwLinearCnt;            // Number of locks on surface.

// crus
#if 1 // OVERLAY #sge
    PDD_SURFACE_LOCAL lpHardwareOwner;
    PDD_SURFACE_LOCAL lpColorSurface;
    PDD_SURFACE_LOCAL lpSrcColorSurface;
    OVERLAYWINDOW     sOverlay1;
    DWORD   dwPanningFlag;
    WORD    wColorKey;
    DWORD   dwSrcColorKeyLow;
    DWORD   dwSrcColorKeyHigh;
    RECTL   rOverlaySrc;
    RECTL   rOverlayDest;
    BOOL    bDoubleClock;
    LONG    lFifoThresh;
    BYTE    VertStretchCode[MAX_STRETCH_SIZE];
    BYTE    HorStretchCode[MAX_STRETCH_SIZE];
    FLATPTR fpVisibleOverlay;
    FLATPTR fpBaseOverlay;
    LONG    lBusWidth;
    LONG    lMCLKPeriod;
    LONG    lRandom;
    LONG    lPageMiss;
    LONG    OvlyCnt;
    LONG    PlanarCnt;
    DWORD   dwVsyncLine;
    FLATPTR fpVidMem_gbls;      // ptr to video memory, myf33
    LONG    lPitch_gbls;        //pitch of surface, myf33

    FNREGINITVIDEO*     pfnRegInitVideo;
    FNREGMOVEVIDEO*        pfnRegMoveVideo;
    FNBANDWIDTHEQ*        pfnIsSufficientBandwidth;
    FNDISABLEOVERLAY*   pfnDisableOverlay;
    FNCLEARALTFIFO*     pfnClearAltFIFOThreshold;
#endif // OVERLAY

#endif

#if 1 // Font cache.
    ////////// Font cache stuff:
    ULONG       ulFontCacheID;          // Font cache ID.
    FONTCACHE*  pfcChain;               // Pointer to chain of FONTCACHE
                                        //   structures.
#endif

#if 1 // D5480
    FNGLYPHOUT* pfnGlyphOut;
    FNGLYPHOUTCLIP* pfnGlyphOutClip;
    // Command List Stuff:
    ULONG_PTR*      pCommandList;
    ULONG_PTR*      pCLFirst;
    ULONG_PTR*      pCLSecond;
#endif // endif D5480

    FnREAD_PORT_UCHAR   pfnREAD_PORT_UCHAR;
    FnREAD_PORT_USHORT  pfnREAD_PORT_USHORT;
    FnREAD_PORT_ULONG   pfnREAD_PORT_ULONG;
    FnWRITE_PORT_UCHAR  pfnWRITE_PORT_UCHAR;
    FnWRITE_PORT_USHORT pfnWRITE_PORT_USHORT;
    FnWRITE_PORT_ULONG  pfnWRITE_PORT_ULONG;

    ULONG       ulLastField;            // This must remain the last field in
                                        // this structure.

    // Added to support GetAvailDriverMemory callback in DDraw
    ULONG ulTotalAvailVideoMemory;

} PDEV, *PPDEV;


/////////////////////////////////////////////////////////////////////////
// Miscellaneous prototypes:

BOOL bIntersect(RECTL*, RECTL*, RECTL*);
LONG cIntersect(RECTL*, RECTL*, LONG);
VOID vImageTransfer(PDEV*, BYTE*, LONG, LONG, LONG);

#ifdef PANNING_SCROLL
VOID CirrusLaptopViewPoint(PDEV*, PVIDEO_MODE_INFORMATION);   //myf17
#endif

BOOL bInitializeModeFields(PDEV*, GDIINFO*, DEVINFO*, DEVMODEW*);

BOOL bEnableHardware(PDEV*);
VOID vDisableHardware(PDEV*);
BOOL bAssertModeHardware(PDEV*, BOOL);
DWORD getAvailableModes(HANDLE, PVIDEO_MODE_INFORMATION*, DWORD*);

extern BYTE gajHwMixFromMix[];
extern BYTE gaRop3FromMix[];
extern BYTE gajHwMixFromRop2[];
extern ULONG gaulLeftClipMask[];
extern ULONG gaulRightClipMask[];
#if 1 // D5480
extern DWORD gajHwPackedMixFromRop2[];
extern DWORD gajHwPackedMixFromMix[];
#endif // endif D5480

/////////////////////////////////////////////////////////////////////////
// The x86 C compiler insists on making a divide and modulus operation
// into two DIVs, when it can in fact be done in one.  So we use this
// macro.
//
// Note: QUOTIENT_REMAINDER implicitly takes unsigned arguments.

#if defined(i386)

#define QUOTIENT_REMAINDER(ulNumerator, ulDenominator, ulQuotient, ulRemainder) \
{                                                               \
    __asm mov eax, ulNumerator                                  \
    __asm sub edx, edx                                          \
    __asm div ulDenominator                                     \
    __asm mov ulQuotient, eax                                   \
    __asm mov ulRemainder, edx                                  \
}

#else

#define QUOTIENT_REMAINDER(ulNumerator, ulDenominator, ulQuotient, ulRemainder) \
{                                                               \
    ulQuotient  = (ULONG) ulNumerator / (ULONG) ulDenominator;  \
    ulRemainder = (ULONG) ulNumerator % (ULONG) ulDenominator;  \
}

#endif

/////////////////////////////////////////////////////////////////////////
// PELS_TO_BYTES - converts a pel count to a byte count
// BYTES_TO_PELS - converts a byte count to a pel count

#define PELS_TO_BYTES(cPels) ((cPels) * ppdev->cBpp)
#define BYTES_TO_PELS(cPels) ((cPels) / ppdev->cBpp)

/////////////////////////////////////////////////////////////////////////
// OVERLAP - Returns TRUE if the same-size lower-right exclusive
//           rectangles defined by 'pptl' and 'prcl' overlap:

#define OVERLAP(prcl, pptl)                                             \
    (((prcl)->right  > (pptl)->x)                                   &&  \
     ((prcl)->bottom > (pptl)->y)                                   &&  \
     ((prcl)->left   < ((pptl)->x + (prcl)->right - (prcl)->left))  &&  \
     ((prcl)->top    < ((pptl)->y + (prcl)->bottom - (prcl)->top)))

/////////////////////////////////////////////////////////////////////////
// SWAP - Swaps the value of two variables, using a temporary variable

#define SWAP32(a, b)            \
{                               \
    register ULONG tmp;         \
    tmp = (ULONG)(a);           \
    (ULONG)(a) = (ULONG)(b);    \
    (ULONG)(b) = tmp;           \
}

#define SWAP(a, b, tmp) { (tmp) = (a); (a) = (b); (b) = (tmp); }

/////////////////////////////////////////////////////////////////////////
// BSWAP - "byte swap" reverses the bytes in a DWORD

#ifdef  _X86_

    #define BSWAP(ul)\
    {\
        _asm    mov     eax,ul\
        _asm    bswap   eax\
        _asm    mov     ul,eax\
    }

#else

    #define BSWAP(ul)\
    {\
        ul = ((ul & 0xff000000) >> 24) |\
             ((ul & 0x00ff0000) >> 8)  |\
             ((ul & 0x0000ff00) << 8)  |\
             ((ul & 0x000000ff) << 24);\
    }

#endif



// These Dbg prototypes are thunks for debugging:

VOID    DbgDisableDriver(VOID);
ULONG   DbgGetModes(HANDLE, ULONG, DEVMODEW*);
DHPDEV  DbgEnablePDEV(DEVMODEW*, PWSTR, ULONG, HSURF*, ULONG, ULONG*,
                      ULONG, DEVINFO*, HDEV, PWSTR, HANDLE);
VOID    DbgCompletePDEV(DHPDEV, HDEV);
HSURF   DbgEnableSurface(DHPDEV);
BOOL    DbgStrokePath(SURFOBJ*, PATHOBJ*, CLIPOBJ*, XFORMOBJ*, BRUSHOBJ*,
                      POINTL*, LINEATTRS*, MIX);
BOOL    DbgFillPath(SURFOBJ*, PATHOBJ*, CLIPOBJ*, BRUSHOBJ*, POINTL*,
                    MIX, FLONG);
BOOL    DbgBitBlt(SURFOBJ*, SURFOBJ*, SURFOBJ*, CLIPOBJ*, XLATEOBJ*,
                  RECTL*, POINTL*, POINTL*, BRUSHOBJ*, POINTL*, ROP4);
VOID    DbgDisablePDEV(DHPDEV);
VOID    DbgDisableSurface(DHPDEV);
#if (NT_VERSION < 0x0400)       //myf19
VOID    DbgAssertMode(DHPDEV, BOOL);
#else
BOOL    DbgAssertMode(DHPDEV, BOOL);
#endif          //myf19
VOID    DbgMovePointer(SURFOBJ*, LONG, LONG, RECTL*);
ULONG   DbgSetPointerShape(SURFOBJ*, SURFOBJ*, SURFOBJ*, XLATEOBJ*, LONG,
                           LONG, LONG, LONG, RECTL*, FLONG);
ULONG   DbgDitherColor(DHPDEV, ULONG, ULONG, ULONG*);
BOOL    DbgSetPalette(DHPDEV, PALOBJ*, FLONG, ULONG, ULONG);
BOOL    DbgCopyBits(SURFOBJ*, SURFOBJ*, CLIPOBJ*, XLATEOBJ*, RECTL*, POINTL*);
BOOL    DbgTextOut(SURFOBJ*, STROBJ*, FONTOBJ*, CLIPOBJ*, RECTL*, RECTL*,
                   BRUSHOBJ*, BRUSHOBJ*, POINTL*, MIX);
VOID    DbgDestroyFont(FONTOBJ*);
BOOL    DbgPaint(SURFOBJ*, CLIPOBJ*, BRUSHOBJ*, POINTL*, MIX);
BOOL    DbgRealizeBrush(BRUSHOBJ*, SURFOBJ*, SURFOBJ*, SURFOBJ*, XLATEOBJ*,
                        ULONG);
HBITMAP DbgCreateDeviceBitmap(DHPDEV, SIZEL, ULONG);
VOID    DbgDeleteDeviceBitmap(DHSURF);
BOOL    DbgStretchBlt(SURFOBJ*, SURFOBJ*, SURFOBJ*, CLIPOBJ*, XLATEOBJ*,
                      COLORADJUSTMENT*, POINTL*, RECTL*, RECTL*, POINTL*,
                      ULONG);
#if 1 // Font cache
VOID    DbgDestroyFont(FONTOBJ* pfo);
#endif
#if LINETO
BOOL    DbgLineTo(SURFOBJ*, CLIPOBJ*, BRUSHOBJ*, LONG, LONG, LONG, LONG,
                  RECTL*, MIX);
#endif
#if DIRECTDRAW
BOOL    DbgGetDirectDrawInfo(DHPDEV, DD_HALINFO*, DWORD*, VIDEOMEMORY*, DWORD*,
                                                         DWORD*);
BOOL    DbgEnableDirectDraw(DHPDEV, DD_CALLBACKS*, DD_SURFACECALLBACKS*,
                            DD_PALETTECALLBACKS*);
VOID    DbgDisableDirectDraw(DHPDEV);
#endif

//
// chu01 : GAMMACORRECT
//
typedef struct _PGAMMA_VALUE
{

    UCHAR value[4] ;

} GAMMA_VALUE, *PGAMMA_VALUE, *PCONTRAST_VALUE ;

//myf32 begin
//#define  CL754x       0x1000
//#define  CL755x       0x2000
#define  CL7541       0x1000
#define  CL7542       0x2000
#define  CL7543       0x4000
#define  CL7548       0x8000
#define  CL754x       (CL7541 | CL7542 | CL7543 | CL7548)
#define  CL7555       0x10000
#define  CL7556       0x20000
#define  CL755x       (CL7555 | CL7556)
#define  CL756x       0x40000
// crus
#define  CL6245       0x80000
//myf32 end

#define  CL7542_ID    0x2C
#define  CL7541_ID    0x34
#define  CL7543_ID    0x30
#define  CL7548_ID    0x38
#define  CL7555_ID    0x40
#define  CL7556_ID    0x4C

//#define  CHIP754X
//#define  CHIP755X
//myf32 end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\cirrus\disp\enable.c ===
/******************************************************************************\
*
* $Workfile:   enable.c  $
*
* This module contains the functions that enable and disable the driver, the
* pdev, and the surface.
*
* Copyright (c) 1992-1997 Microsoft Corporation.
* Copyright (c) 1996-1997 Cirrus Logic, Inc.,
*
* $Log:   S:/projects/drivers/ntsrc/display/enable.c_v  $
 *
 *    Rev 1.21   Apr 03 1997 15:38:50   unknown
 *
 *
 *    Rev 1.20   28 Mar 1997 16:08:40   PLCHU
 *
 *
 *    Rev 1.12   Jan 15 1997 09:41:32   unknown
 * Change to Version 4.0.5
 *
 *    Rev 1.11   Jan 14 1997 18:00:32   unknown
 * disable command list due to performance drop.
 *
 *    Rev 1.10   Jan 14 1997 15:14:02   unknown
 * Change to version V4.0.4
 *
 *    Rev 1.8   Jan 08 1997 11:22:34   unknown
 * Change to V4.0.3
 *
 *    Rev 1.7   18 Dec 1996 13:44:08   PLCHU
 *
 *
 *    Rev 1.6   Dec 13 1996 12:15:48   unknown
 * update bandwith equation for DDraw.
 *
 *    Rev 1.6   Nov 27 1996 15:07:28   unknown
 * turn on second apertue for 5480
 *
 *    Rev 1.5   Nov 07 1996 16:48:00   unknown
 *
 *
 *    Rev 1.4   Nov 06 1996 15:55:10   unknown
 * Turn off second aperture
 *
 *    Rev 1.3   Nov 05 1996 14:49:00   unknown
 * Turn on second aperture feature for 5480
 *
 *    Rev 1.1   Oct 10 1996 15:36:38   unknown
 *
*
*    Rev 1.9   12 Aug 1996 16:52:42   frido
* Removed unaccessed local variables.
* Added NT 3.5x/4.0 auto detection.
* Renamned vMmPatternBlt into vMmFillPat36.
*
*    Rev 1.8   08 Aug 1996 16:20:54   frido
* Added vMmCopyBlt36 routine.
*
*    Rev 1.7   01 Aug 1996 00:09:28   frido
* Fixed a type causing havoc in new pitch in 24-bpp.
*
*    Rev 1.6   26 Jul 1996 17:46:30   frido
* Added new solid fill routine for 54x6 chips.
*
*    Rev 1.5   26 Jul 1996 14:16:40   frido
* Added new pattern blit routine.
*
*    Rev 1.4   20 Jul 1996 13:48:12   frido
* Hooked DrvDestroyFont.
*
*    Rev 1.3   10 Jul 1996 17:54:50   frido
* Cosmetic change in the flHooks variable.
*
*    Rev 1.2   09 Jul 1996 17:58:24   frido
* Added LineTo code.
*
*    Rev 1.1   03 Jul 1996 13:38:30   frido
* Added DirectDraw support.
*
* sge01   10-23-96   Add second aperture maping
* sge02   10-29-96   Merge port and register access
*                    for VGA relocatable and MMIO registers.
* myf0    08-19-96   added 85hz supported
* myf1    08-20-96   supported panning scrolling
* myf2    08-20-96   fixed hardware save/restore state bug for matterhorn
* myf3    09-01-96   Added IOCTL_CIRRUS_PRIVATE_BIOS_CALL for TV supported
* myf4    09-01-96   patch Viking BIOS bug, PDR #4287, begin
* myf5    09-01-96   Fixed PDR #4365 keep all default refresh rate
* myf6    09-17-96   Merged Desktop SRC1001 & MINI102
* myf7    09-19-96   Fixed exclude 60Hz refresh rate selected
* myf8   *09-21-96*  May be need change CheckandUpdateDDC2BMonitor --keystring[]
* myf9    09-21-96   8x6 panel in 6x4x256 mode, cursor can't move to bottom scrn
* ms0809  09-25-96   fixed dstn panel icon corrupted
* ms923   09-25-96   merge MS-923 Disp.zip code
* myf10   09-26-96   Fixed DSTN reserved half-frame buffer bug.
* myf11   09-26-96   Fixed 755x CE chip HW bug, access ramdac before disable HW
*                    icons and cursor
* myf12   10-01-96   Supported Hot Key switch display
* myf13   10-05-96   Fixed /w panning scrolling, vertical expension on bug
* myf14   10-15-96   Fixed PDR#6917, 6x4 panel can't panning scrolling for 754x
* myf15   10-16-96   Fixed disable memory mapped IO for 754x, 755x
* myf16   10-22-96   Fixed PDR #6933,panel type set different demo board setting
* sge01   10-28-96   Map the ports before we use it and free it in bInitializeModeFields
* myf17   11-04-96   Added special escape code must be use 11/5/96 later NTCTRL,
*                    and added Matterhorn LF Device ID==0x4C
* myf18   11-04-96   Fixed PDR #7075,
* myf19   11-06-96   Fixed Vinking can't work problem, because DEVICEID = 0x30
*                    is different from data book (CR27=0x2C)
* myf20   11-11-96   Fixed PDR#5501 pop-up icon crash problem
* myf21   11-21-96   Change CAPS_IS_7555 to check ppdev->ulChipID
* chu01   12-16-96   Enable color correction
* chu02   02-07-97   Disable command list for 24 bpp modes
* jl01    02-11-97   Fix 542x VLB banking issue
* myf29   02-12-97   Support Gamma Correction for 755x
* pat04 :12-05-96 : Set default Panel bootup mode = 640x480x256colors if
*                   current resolution not supported.
* pat08 :         : Put in changes that didn't make in 1.11 driver
* myf33 : 03-21-97  Fixed 6x4x256 TV on, font cut bug,
*
\******************************************************************************/

#include "precomp.h"

#define DBG_LVL_CAPS    0
#define CIRRUSVERSION   21
//crus
//myf17   #define PANNING_SCROLL       //myf1

BOOL bGetChipIDandRev(BOOL bRetInfo, PPDEV ppdev);

//crus begin
#ifdef PANNING_SCROLL    //myf1
VOID
CirrusLaptopViewPoint(
PDEV* ppdev,
PVIDEO_MODE_INFORMATION  pVideoModeInfo);
#endif
//crus end

/******************************Public*Structure****************************\
* GDIINFO ggdiDefault
*
* This contains the default GDIINFO fields that are passed back to GDI
* during DrvEnablePDEV.
*
* NOTE: This structure defaults to values for an 8bpp palette device.
*       Some fields are overwritten for different colour depths.
\**************************************************************************/

GDIINFO ggdiDefault = {
//  GDI_DRIVER_VERSION,         // ulVersion
    GDI_DRIVER_VERSION+CIRRUSVERSION,        // ulVersion, sge01
    DT_RASDISPLAY,          // ulTechnology
    0,                      // ulHorzSize (filled in later)
    0,                      // ulVertSize (filled in later)
    0,                      // ulHorzRes (filled in later)
    0,                      // ulVertRes (filled in later)
    0,                      // cBitsPixel (filled in later)
    0,                      // cPlanes (filled in later)
    20,                     // ulNumColors (palette managed)
    0,                      // flRaster (DDI reserved field)

    0,                      // ulLogPixelsX (filled in later)
    0,                      // ulLogPixelsY (filled in later)

    TC_RA_ABLE /* | TC_SCROLLBLT */,
                // flTextCaps --
                //   Setting TC_SCROLLBLT tells console to scroll
                //   by repainting the entire window.  Otherwise,
                //   scrolls are done by calling the driver to
                //   do screen to screen copies.

    0,                      // ulDACRed (filled in later)
    0,                      // ulDACGreen (filled in later)
    0,                      // ulDACBlue (filled in later)

    0x0024,                 // ulAspectX
    0x0024,                 // ulAspectY
    0x0033,                 // ulAspectXY (one-to-one aspect ratio)

    1,                      // xStyleStep
    1,                      // yStyleSte;
    3,                      // denStyleStep -- Styles have a one-to-one aspect
                //   ratio, and every 'dot' is 3 pixels long

    { 0, 0 },               // ptlPhysOffset
    { 0, 0 },               // szlPhysSize

    256,                    // ulNumPalReg

    // These fields are for halftone initialization.  The actual values are
    // a bit magic, but seem to work well on our display.

    {                       // ciDevice
       { 6700, 3300, 0 },   //      Red
       { 2100, 7100, 0 },   //      Green
       { 1400,  800, 0 },   //      Blue
       { 1750, 3950, 0 },   //      Cyan
       { 4050, 2050, 0 },   //      Magenta
       { 4400, 5200, 0 },   //      Yellow
       { 3127, 3290, 0 },   //      AlignmentWhite
       20000,               //      RedGamma
       20000,               //      GreenGamma
       20000,               //      BlueGamma
       0, 0, 0, 0, 0, 0     //      No dye correction for raster displays
    },

    0,                       // ulDevicePelsDPI (for printers only)
    PRIMARY_ORDER_CBA,       // ulPrimaryOrder
    HT_PATSIZE_4x4_M,        // ulHTPatternSize
    HT_FORMAT_8BPP,          // ulHTOutputFormat
    HT_FLAG_ADDITIVE_PRIMS,  // flHTFlags
    0,                       // ulVRefresh (filled in later)
#if (NT_VERSION < 0x0400)
    0,                       // ulDesktopHorzRes (filled in later)
    0,                       // ulDesktopVertRes (filled in later)
    0,                       // ulBltAlignment
#else
    0,                       // ulBltAlignment
    0,                       // ulPanningHorzRes (filled in later)
    0,                       // ulPanningVertRes (filled in later)
#endif
};

/******************************Public*Structure****************************\
* DEVINFO gdevinfoDefault
*
* This contains the default DEVINFO fields that are passed back to GDI
* during DrvEnablePDEV.
*
* NOTE: This structure defaults to values for an 8bpp palette device.
*       Some fields are overwritten for different colour depths.
\**************************************************************************/

#define SYSTM_LOGFONT {16,7,0,0,700,0,0,0,ANSI_CHARSET,OUT_DEFAULT_PRECIS,\
               CLIP_DEFAULT_PRECIS,DEFAULT_QUALITY,\
               VARIABLE_PITCH | FF_DONTCARE,L"System"}
#define HELVE_LOGFONT {12,9,0,0,400,0,0,0,ANSI_CHARSET,OUT_DEFAULT_PRECIS,\
               CLIP_STROKE_PRECIS,PROOF_QUALITY,\
               VARIABLE_PITCH | FF_DONTCARE,L"MS Sans Serif"}
#define COURI_LOGFONT {12,9,0,0,400,0,0,0,ANSI_CHARSET,OUT_DEFAULT_PRECIS,\
               CLIP_STROKE_PRECIS,PROOF_QUALITY,\
               FIXED_PITCH | FF_DONTCARE, L"Courier"}

DEVINFO gdevinfoDefault = {

    (GCAPS_OPAQUERECT
     | GCAPS_DITHERONREALIZE
     | GCAPS_PALMANAGED
     | GCAPS_ALTERNATEFILL
     | GCAPS_WINDINGFILL
     | GCAPS_MONO_DITHER
     | GCAPS_COLOR_DITHER
#if DIRECTDRAW
     | GCAPS_DIRECTDRAW
#endif
//crus
#if (NT_VERSION >= 0x0400)
#ifdef PANNING_SCROLL           //myf1
     | GCAPS_PANNING
#endif
#endif
     // This driver can't handle GCAPS_ASYNCMOVE because some of the pointer
     // moves, where the pointer image must be rotated at the left edge,
     // require the blt hardware to download a new pointer shape.
     ),
     // NOTE: Only enable GCAPS_ASYNCMOVE if your code
     //   and hardware can handle DrvMovePointer
     //   calls at any time, even while another
     //   thread is in the middle of a drawing
     //   call such as DrvBitBlt.

                                                // flGraphicsFlags
    SYSTM_LOGFONT,                              // lfDefaultFont
    HELVE_LOGFONT,                              // lfAnsiVarFont
    COURI_LOGFONT,                              // lfAnsiFixFont
    0,                                          // cFonts
    BMF_8BPP,                                   // iDitherFormat
    8,                                          // cxDither
    8,                                          // cyDither
    0                                           // hpalDefault (filled in later)
};

/******************************Public*Structure****************************\
* DFVFN gadrvfn[]
*
* Build the driver function table gadrvfn with function index/address
* pairs.  This table tells GDI which DDI calls we support, and their
* location (GDI does an indirect call through this table to call us).
*
* Why haven't we implemented DrvSaveScreenBits?  To save code.
*
* When the driver doesn't hook DrvSaveScreenBits, USER simulates on-
* the-fly by creating a temporary device-format-bitmap, and explicitly
* calling DrvCopyBits to save/restore the bits.  Since we already hook
* DrvCreateDeviceBitmap, we'll end up using off-screen memory to store
* the bits anyway (which would have been the main reason for implementing
* DrvSaveScreenBits).  So we may as well save some working set.
\**************************************************************************/

#if DBG

// On Checked builds, or when we have to synchronize access, thunk
// everything through Dbg calls...

DRVFN gadrvfn[] = {
    {   INDEX_DrvEnablePDEV,            (PFN) DbgEnablePDEV         },
    {   INDEX_DrvCompletePDEV,          (PFN) DbgCompletePDEV       },
    {   INDEX_DrvDisablePDEV,           (PFN) DbgDisablePDEV        },
    {   INDEX_DrvEnableSurface,         (PFN) DbgEnableSurface      },
    {   INDEX_DrvDisableSurface,        (PFN) DbgDisableSurface     },
    {   INDEX_DrvAssertMode,            (PFN) DbgAssertMode         },
    {   INDEX_DrvCopyBits,              (PFN) DbgCopyBits           },
    {   INDEX_DrvBitBlt,                (PFN) DbgBitBlt             },
    {   INDEX_DrvTextOut,               (PFN) DbgTextOut            },
    {   INDEX_DrvSynchronize,           (PFN) DrvSynchronize        },
#if 1 // Font cache.
    {   INDEX_DrvDestroyFont,           (PFN) DbgDestroyFont        },
#endif
    {   INDEX_DrvGetModes,              (PFN) DbgGetModes           },
    {   INDEX_DrvStrokePath,            (PFN) DbgStrokePath         },
    {   INDEX_DrvSetPalette,            (PFN) DbgSetPalette         },
    {   INDEX_DrvDitherColor,           (PFN) DbgDitherColor        },
    {   INDEX_DrvFillPath,              (PFN) DbgFillPath           },
#if DIRECTDRAW
    {   INDEX_DrvGetDirectDrawInfo,     (PFN) DbgGetDirectDrawInfo  },
    {   INDEX_DrvEnableDirectDraw,      (PFN) DbgEnableDirectDraw   },
    {   INDEX_DrvDisableDirectDraw,     (PFN) DbgDisableDirectDraw  },
#endif
#if LINETO
    {   INDEX_DrvLineTo,                (PFN) DbgLineTo             },
#endif
#if !DRIVER_PUNT_ALL
    #if !DRIVER_PUNT_STRETCH
    {   INDEX_DrvStretchBlt,            (PFN) DbgStretchBlt         },
    #endif
    #if !DRIVER_PUNT_PTR
    {   INDEX_DrvMovePointer,           (PFN) DbgMovePointer        },
    {   INDEX_DrvSetPointerShape,       (PFN) DbgSetPointerShape    },
    #endif
    {   INDEX_DrvCreateDeviceBitmap,    (PFN) DbgCreateDeviceBitmap },
    {   INDEX_DrvDeleteDeviceBitmap,    (PFN) DbgDeleteDeviceBitmap },
    #if !DRIVER_PUNT_BRUSH
    {   INDEX_DrvRealizeBrush,          (PFN) DbgRealizeBrush       },
    #endif
#endif
    {   INDEX_DrvDisableDriver,         (PFN) DbgDisableDriver      }
};

#else

// On Free builds, directly call the appropriate functions...

DRVFN gadrvfn[] = {
    {   INDEX_DrvEnablePDEV,            (PFN) DrvEnablePDEV         },
    {   INDEX_DrvCompletePDEV,          (PFN) DrvCompletePDEV       },
    {   INDEX_DrvDisablePDEV,           (PFN) DrvDisablePDEV        },
    {   INDEX_DrvEnableSurface,         (PFN) DrvEnableSurface      },
    {   INDEX_DrvDisableSurface,        (PFN) DrvDisableSurface     },
    {   INDEX_DrvAssertMode,            (PFN) DrvAssertMode         },
    {   INDEX_DrvCopyBits,              (PFN) DrvCopyBits           },
    {   INDEX_DrvBitBlt,                (PFN) DrvBitBlt             },
    {   INDEX_DrvTextOut,               (PFN) DrvTextOut            },
    {   INDEX_DrvSynchronize,           (PFN) DrvSynchronize        },
#if 1 // Font cache.
    {   INDEX_DrvDestroyFont,           (PFN) DrvDestroyFont        },
#endif
    {   INDEX_DrvGetModes,              (PFN) DrvGetModes           },
    {   INDEX_DrvStrokePath,            (PFN) DrvStrokePath         },
    {   INDEX_DrvSetPalette,            (PFN) DrvSetPalette         },
    {   INDEX_DrvDitherColor,           (PFN) DrvDitherColor        },
    {   INDEX_DrvFillPath,              (PFN) DrvFillPath           },
#if DIRECTDRAW
    {   INDEX_DrvGetDirectDrawInfo,             (PFN) DrvGetDirectDrawInfo      },
    {   INDEX_DrvEnableDirectDraw,              (PFN) DrvEnableDirectDraw       },
    {   INDEX_DrvDisableDirectDraw,             (PFN) DrvDisableDirectDraw      },
#endif
#if LINETO
    {   INDEX_DrvLineTo,                (PFN) DrvLineTo             },
#endif
#if !DRIVER_PUNT_ALL
    #if !DRIVER_PUNT_STRETCH
    {   INDEX_DrvStretchBlt,            (PFN) DrvStretchBlt         },
    #endif
    #if !DRIVER_PUNT_PTR
    {   INDEX_DrvMovePointer,           (PFN) DrvMovePointer        },
    {   INDEX_DrvSetPointerShape,       (PFN) DrvSetPointerShape    },
    #endif
    {   INDEX_DrvCreateDeviceBitmap,    (PFN) DrvCreateDeviceBitmap },
    {   INDEX_DrvDeleteDeviceBitmap,    (PFN) DrvDeleteDeviceBitmap },
    #if !DRIVER_PUNT_BRUSH
    {   INDEX_DrvRealizeBrush,          (PFN) DrvRealizeBrush       },
    #endif
#endif
    {   INDEX_DrvDisableDriver,         (PFN) DrvDisableDriver      }
};

#endif

ULONG gcdrvfn = sizeof(gadrvfn) / sizeof(DRVFN);

//
// Merge port and register access for
// VGA relocatable and MMIO registers.
//
// sge02 begin
#if defined(_X86_)

UCHAR   CirrusREAD_PORT_UCHAR(PVOID Port);
USHORT  CirrusREAD_PORT_USHORT(PVOID Port);
ULONG   CirrusREAD_PORT_ULONG(PVOID Port);
VOID    CirrusWRITE_PORT_UCHAR(PVOID Port,UCHAR Value);
VOID    CirrusWRITE_PORT_USHORT(PVOID  Port, USHORT Value);
VOID    CirrusWRITE_PORT_ULONG(PVOID Port, ULONG Value);

UCHAR   CirrusREAD_REGISTER_UCHAR(PVOID Register);
USHORT  CirrusREAD_REGISTER_USHORT(PVOID Register);
ULONG   CirrusREAD_REGISTER_ULONG(PVOID Register);
VOID    CirrusWRITE_REGISTER_UCHAR(PVOID Register,UCHAR Value);
VOID    CirrusWRITE_REGISTER_USHORT(PVOID  Register, USHORT Value);
VOID    CirrusWRITE_REGISTER_ULONG(PVOID Register, ULONG Value);

UCHAR   CirrusREAD_PORT_UCHAR(PVOID Port)
{
    return((UCHAR)inp(Port));
}
USHORT  CirrusREAD_PORT_USHORT(PVOID Port)
{
    return(inpw(Port));
}
ULONG   CirrusREAD_PORT_ULONG(PVOID Port)
{
    return(inpd(Port));
}
VOID    CirrusWRITE_PORT_UCHAR(PVOID Port,UCHAR Value)
{
    outp(Port, Value);
}
VOID    CirrusWRITE_PORT_USHORT(PVOID  Port, USHORT Value)
{
    outpw(Port, Value);
}
VOID    CirrusWRITE_PORT_ULONG(PVOID Port, ULONG Value)
{
    outpd(Port, Value);
}

UCHAR   CirrusREAD_REGISTER_UCHAR(PVOID Register)
{
    return(*(volatile UCHAR *)(Register));
}
USHORT  CirrusREAD_REGISTER_USHORT(PVOID Register)
{
    return(*(volatile USHORT *)(Register));
}
ULONG   CirrusREAD_REGISTER_ULONG(PVOID Register)
{
    return(*(volatile ULONG *)(Register));
}
VOID    CirrusWRITE_REGISTER_UCHAR(PVOID Register,UCHAR Value)
{
    *(volatile UCHAR *)(Register) = (Value);
}
VOID    CirrusWRITE_REGISTER_USHORT(PVOID  Register, USHORT Value)
{
    *(volatile USHORT *)(Register) = (Value);
}
VOID    CirrusWRITE_REGISTER_ULONG(PVOID Register, ULONG Value)
{
    *(volatile ULONG *)(Register) = (Value);
}
#endif
//sge02 end

/******************************Public*Routine******************************\
* BOOL DrvEnableDriver
*
* Enables the driver by retrieving the drivers function table and version.
*
\**************************************************************************/

BOOL DrvEnableDriver(
ULONG          iEngineVersion,
ULONG          cj,
DRVENABLEDATA* pded)
{
    DISPDBG((2, "---- DrvEnableDriver"));

    // Engine Version is passed down so future drivers can support previous
    // engine versions.  A next generation driver can support both the old
    // and new engine conventions if told what version of engine it is
    // working with.  For the first version the driver does nothing with it.

    // Fill in as much as we can.

    if (cj >= sizeof(DRVENABLEDATA))
        pded->pdrvfn = gadrvfn;

    if (cj >= (sizeof(ULONG) * 2))
        pded->c = gcdrvfn;

    // DDI version this driver was targeted for is passed back to engine.
    // Future graphic's engine may break calls down to old driver format.

    if (cj >= sizeof(ULONG))
        pded->iDriverVersion = DDI_DRIVER_VERSION_NT4;

    return(TRUE);
}

/******************************Public*Routine******************************\
* VOID DrvDisableDriver
*
* Tells the driver it is being disabled. Release any resources allocated in
* DrvEnableDriver.
*
\**************************************************************************/

VOID DrvDisableDriver(VOID)
{
    return;
}

/******************************Public*Routine******************************\
* DHPDEV DrvEnablePDEV
*
* Initializes a bunch of fields for GDI, based on the mode we've been asked
* to do.  This is the first thing called after DrvEnableDriver, when GDI
* wants to get some information about us.
*
* (This function mostly returns back information; DrvEnableSurface is used
* for initializing the hardware and driver components.)
*
\**************************************************************************/

DHPDEV DrvEnablePDEV(
DEVMODEW*   pdm,            // Contains data pertaining to requested mode
PWSTR       pwszLogAddr,    // Logical address
ULONG       cPat,           // Count of standard patterns
HSURF*      phsurfPatterns, // Buffer for standard patterns
ULONG       cjCaps,         // Size of buffer for device caps 'pdevcaps'
ULONG*      pdevcaps,       // Buffer for device caps, also known as 'gdiinfo'
ULONG       cjDevInfo,      // Number of bytes in device info 'pdi'
DEVINFO*    pdi,            // Device information
#if (NT_VERSION < 0x0400)
PWSTR       pwszDataFile,   // DataFile - not used
#else
HDEV        hdev,           // HDEV, used for callbacks
#endif
PWSTR       pwszDeviceName, // Device name
HANDLE      hDriver)        // Kernel driver handle
{
    PDEV*   ppdev;

    // Future versions of NT had better supply 'devcaps' and 'devinfo'
    // structures that are the same size or larger than the current
    // structures:

    DISPDBG((2, "---- DrvEnablePDEV"));

    if ((cjCaps < sizeof(GDIINFO)) || (cjDevInfo < sizeof(DEVINFO)))
    {
        DISPDBG((0, "DrvEnablePDEV - Buffer size too small"));
        goto ReturnFailure0;
    }

    // Allocate a physical device structure.  Note that we definitely
    // rely on the zero initialization:

    ppdev = (PDEV*) ALLOC(sizeof(PDEV));
    if (ppdev == NULL)
    {
        DISPDBG((0, "DrvEnablePDEV - Failed EngAllocMem"));
        goto ReturnFailure0;
    }

    ppdev->hDriver = hDriver;

    // Get the current screen mode information. Set up device caps and devinfo.

    if (!bInitializeModeFields(ppdev, (GDIINFO*) pdevcaps, pdi, pdm))
    {
        goto ReturnFailure1;
    }

    // Initialize palette information.

    if (!bInitializePalette(ppdev, pdi))
    {
        DISPDBG((0, "DrvEnablePDEV - Failed bInitializePalette"));
        goto ReturnFailure1;
    }

    return((DHPDEV) ppdev);

ReturnFailure1:
    DrvDisablePDEV((DHPDEV) ppdev);

ReturnFailure0:
    DISPDBG((0, "Failed DrvEnablePDEV"));
    return(0);
}

/******************************Public*Routine******************************\
* DrvDisablePDEV
*
* Release the resources allocated in DrvEnablePDEV.  If a surface has been
* enabled DrvDisableSurface will have already been called.
*
* Note that this function will be called when previewing modes in the
* Display Applet, but not at system shutdown.  If you need to reset the
* hardware at shutdown, you can do it in the miniport by providing a
* 'HwResetHw' entry point in the VIDEO_HW_INITIALIZATION_DATA structure.
*
* Note: In an error, we may call this before DrvEnablePDEV is done.
*
\**************************************************************************/

VOID DrvDisablePDEV(
DHPDEV  dhpdev)
{
    PDEV*   ppdev;

    ppdev = (PDEV*) dhpdev;

    vUninitializePalette(ppdev);
    FREE(ppdev);
}

/******************************Public*Routine******************************\
* VOID DrvCompletePDEV
*
* Store the HPDEV, the engines handle for this PDEV, in the DHPDEV.
*
\**************************************************************************/

VOID DrvCompletePDEV(
DHPDEV dhpdev,
HDEV   hdev)
{
    ((PDEV*) dhpdev)->hdevEng = hdev;
}


/******************************Public*Routine******************************\
* HSURF DrvEnableSurface
*
* Creates the drawing surface, initializes the hardware, and initializes
* driver components.  This function is called after DrvEnablePDEV, and
* performs the final device initialization.
*
\**************************************************************************/

HSURF DrvEnableSurface(
DHPDEV dhpdev)
{
    PDEV*   ppdev;
    HSURF   hsurf;
    SIZEL   sizl;
    DSURF*  pdsurf;
    VOID*   pvTmpBuffer;
    SURFOBJ*    pso;
    ppdev = (PDEV*) dhpdev;

    DISPDBG((2, "---- DrvEnableSurface"));

    /////////////////////////////////////////////////////////////////////
    // First, enable all the subcomponents.
    //
    // Note that the order in which these 'Enable' functions are called
    // may be significant in low off-screen memory conditions, because
    // the off-screen heap manager may fail some of the later
    // allocations...

    if (!bEnableHardware(ppdev))
        goto ReturnFailure;

    if (!bEnableBanking(ppdev))
        goto ReturnFailure;

    if (!bEnableOffscreenHeap(ppdev))
        goto ReturnFailure;

    if (!bEnablePointer(ppdev))
        goto ReturnFailure;

    if (!bEnableText(ppdev))
        goto ReturnFailure;

    if (!bEnableBrushCache(ppdev))
        goto ReturnFailure;

    if (!bEnablePalette(ppdev))
        goto ReturnFailure;

#if DIRECTDRAW
    if (!bEnableDirectDraw(ppdev))
        goto ReturnFailure;
#endif

    /////////////////////////////////////////////////////////////////////
    // Now create our private surface structure.
    //
    // Whenever we get a call to draw directly to the screen, we'll get
    // passed a pointer to a SURFOBJ whose 'dhpdev' field will point
    // to our PDEV structure, and whose 'dhsurf' field will point to the
    // following DSURF structure.
    //
    // Every device bitmap we create in DrvCreateDeviceBitmap will also
    // have its own unique DSURF structure allocated (but will share the
    // same PDEV).  To make our code more polymorphic for handling drawing
    // to either the screen or an off-screen bitmap, we have the same
    // structure for both.

    pdsurf = ALLOC(sizeof(DSURF));
    if (pdsurf == NULL)
    {
        DISPDBG((0, "DrvEnableSurface - Failed pdsurf EngAllocMem"));
        goto ReturnFailure;
    }

    ppdev->pdsurfScreen = pdsurf;        // Remember it for clean-up

    pdsurf->poh     = ppdev->pohScreen;  // The screen is a surface, too
    pdsurf->dt      = DT_SCREEN;         // Not to be confused with a DIB
    pdsurf->sizl.cx = ppdev->cxScreen;
    pdsurf->sizl.cy = ppdev->cyScreen;
    pdsurf->ppdev   = ppdev;

    /////////////////////////////////////////////////////////////////////
    // Next, have GDI create the actual SURFOBJ.
    //
    // Our drawing surface is going to be 'device-managed', meaning that
    // GDI cannot draw on the framebuffer bits directly, and as such we
    // create the surface via EngCreateDeviceSurface.  By doing this, we ensure
    // that GDI will only ever access the bitmaps bits via the Drv calls
    // that we've HOOKed.
    //
    // If we could map the entire framebuffer linearly into main memory
    // (i.e., we didn't have to go through a 64k aperture), it would be
    // beneficial to create the surface via EngCreateBitmap, giving GDI a
    // pointer to the framebuffer bits.  When we pass a call on to GDI
    // where it can't directly read/write to the surface bits because the
    // surface is device managed, it has to create a temporary bitmap and
    // call our DrvCopyBits routine to get/set a copy of the affected bits.
    // For example, the OpenGL component prefers to be able to write on the
    // framebuffer bits directly.
    //
    // The check for CAPS_AUTOSTART rules out chipsets (like the 7543) that
    // can't be written to directly.

    sizl.cx = ppdev->cxScreen;
    sizl.cy = ppdev->cyScreen;

    if ((ppdev->bLinearMode && DIRECT_ACCESS(ppdev)) && (ppdev->flCaps & CAPS_ENGINEMANAGED))
    {

        // Engine-managed surface:

        hsurf = (HSURF) EngCreateBitmap(sizl,
                        ppdev->lDelta,
                        ppdev->iBitmapFormat,
                        BMF_TOPDOWN,
                        ppdev->pjScreen);
        if (hsurf == 0)
        {
            DISPDBG((0, "DrvEnableSurface - Failed EngCreateBitmap"));
            goto ReturnFailure;
        }

        pso = EngLockSurface(hsurf);
        if (pso == NULL)
        {
            DISPDBG((0, "DrvEnableSurface - Couldn't lock our surface"));
            goto ReturnFailure;
        }
        pso->dhsurf = (DHSURF) pdsurf;
        EngUnlockSurface(pso);
    }
    else
    {
        // Device managed surface
        hsurf = EngCreateDeviceSurface((DHSURF) pdsurf, sizl, ppdev->iBitmapFormat);
        if (hsurf == 0)
        {
            DISPDBG((0, "DrvEnableSurface - Failed EngCreateDeviceSurface"));
            goto ReturnFailure;
        }
    }

    /////////////////////////////////////////////////////////////////////
    // Now associate the surface and the PDEV.
    //
    // We have to associate the surface we just created with our physical
    // device so that GDI can get information related to the PDEV when
    // it's drawing to the surface (such as, for example, the length of
    // styles on the device when simulating styled lines).
    //

    if (!EngAssociateSurface(hsurf, ppdev->hdevEng, ppdev->flHooks))
    {
        DISPDBG((0, "DrvEnableSurface - Failed EngAssociateSurface 2"));
        goto ReturnFailure;
    }

    ppdev->hsurfScreen = hsurf;             // Remember it for clean-up
    ppdev->bEnabled = TRUE;                 // We'll soon be in graphics mode

    // Create our generic temporary buffer, which may be used by any
    // component.

    pvTmpBuffer = ALLOC(TMP_BUFFER_SIZE);
    if (pvTmpBuffer == NULL)
    {
        DISPDBG((0, "DrvEnableSurface - Failed EngAllocMem"));
        goto ReturnFailure;
    }

    ppdev->pvTmpBuffer = pvTmpBuffer;

    DISPDBG((5, "Passed DrvEnableSurface"));

    ppdev->hbmTmpMono = EngCreateBitmap(sizl, sizl.cx, BMF_1BPP, 0, ppdev->pvTmpBuffer);
    if (ppdev->hbmTmpMono == (HBITMAP) 0)
    {
        DISPDBG((0, "Couldn't create temporary 1bpp bitmap"));
        goto ReturnFailure;
    }

    ppdev->psoTmpMono = EngLockSurface((HSURF) ppdev->hbmTmpMono);
    if (ppdev->psoTmpMono == (SURFOBJ*) NULL)
    {
        DISPDBG((0,"Couldn't lock temporary 1bpp surface"));
        goto ReturnFailure;
    }

    return(hsurf);

ReturnFailure:
    DrvDisableSurface((DHPDEV) ppdev);

    DISPDBG((0, "Failed DrvEnableSurface"));

    return(0);
}

VOID
DrvSynchronize(
    IN DHPDEV dhpdev,
    IN RECTL *prcl
    )
{
    PDEV *ppdev = (PDEV *) dhpdev;

    //
    // We need to do a wait for blt complete before we
    // let the engine party on our frame buffer
    //

    if (ppdev->flCaps & CAPS_MM_IO)
    {
        CP_MM_WAIT_FOR_BLT_COMPLETE(ppdev, ppdev->pjBase);
    }
    else
    {
        CP_IO_WAIT_FOR_BLT_COMPLETE(ppdev, ppdev->pjPorts);
    }
}

/******************************Public*Routine******************************\
* VOID DrvDisableSurface
*
* Free resources allocated by DrvEnableSurface.  Release the surface.
*
* Note that this function will be called when previewing modes in th* Display Applet, but not at system shutdown.  If you need to reset the
* hardware at shutdown, you can do it in the miniport by providing a
* 'HwResetHw' entry point in the VIDEO_HW_INITIALIZATION_DATA structure.
*
* Note: In an error case, we may call this before DrvEnableSurface is
*       completely done.
*
\**************************************************************************/

VOID DrvDisableSurface(
DHPDEV dhpdev)
{
    PDEV*   ppdev;

    ppdev = (PDEV*) dhpdev;

    // Note: In an error case, some of the following relies on the
    //       fact that the PDEV is zero-initialized, so fields like
    //       'hsurfScreen' will be zero unless the surface has been
    //       sucessfully initialized, and makes the assumption that
    //       EngDeleteSurface can take '0' as a parameter.

#if DIRECTDRAW
    vDisableDirectDraw(ppdev);
#endif
    vDisablePalette(ppdev);
    vDisableBrushCache(ppdev);
    vDisableText(ppdev);

    vDisablePointer(ppdev);
    vDisableOffscreenHeap(ppdev);

    vDisableBanking(ppdev);
    vDisableHardware(ppdev);

    EngUnlockSurface(ppdev->psoTmpMono);
    EngDeleteSurface((HSURF) ppdev->hbmTmpMono);
    FREE(ppdev->pvTmpBuffer);
    EngDeleteSurface(ppdev->hsurfScreen);
    FREE(ppdev->pdsurfScreen);
}

/******************************Public*Routine******************************\
* VOID DrvAssertMode
*
* This asks the device to reset itself to the mode of the pdev passed in.
*
\**************************************************************************/

#if (NT_VERSION < 0x0400)
VOID
#else
BOOL
#endif
DrvAssertMode(DHPDEV dhpdev, BOOL bEnable)
{
    PDEV* ppdev = (PDEV*) dhpdev;

    if (!bEnable)
    {
        //////////////////////////////////////////////////////////////
        // Disable - Switch to full-screen mode

#if DIRECTDRAW
       vAssertModeDirectDraw(ppdev, FALSE);
#endif

        vAssertModePalette(ppdev, FALSE);

        vAssertModeBrushCache(ppdev, FALSE);

        vAssertModeText(ppdev, FALSE);

        vAssertModePointer(ppdev, FALSE);

        if (bAssertModeOffscreenHeap(ppdev, FALSE))
        {
            vAssertModeBanking(ppdev, FALSE);

            if (bAssertModeHardware(ppdev, FALSE))
            {
                ppdev->bEnabled = FALSE;

#if (NT_VERSION >= 0x0400)
                return (TRUE);
#else
                return;
#endif
            }

            //////////////////////////////////////////////////////////
            // We failed to switch to full-screen.  So undo everything:

            vAssertModeBanking(ppdev, TRUE);

            bAssertModeOffscreenHeap(ppdev, TRUE);  // We don't need to check
        }                                           //   return code with TRUE

        vAssertModePointer(ppdev, TRUE);

        vAssertModeText(ppdev, TRUE);

        vAssertModeBrushCache(ppdev, TRUE);

        vAssertModePalette(ppdev, TRUE);

    }
    else
    {
        //////////////////////////////////////////////////////////////
        // Enable - Switch back to graphics mode

        // We have to enable every subcomponent in the reverse order
        // in which it was disabled:

        if (bAssertModeHardware(ppdev, TRUE))
        {

            vAssertModeBanking(ppdev, TRUE);

            bAssertModeOffscreenHeap(ppdev, TRUE);  // We don't need to check
                                                    //   return code with TRUE

            vAssertModePointer(ppdev, TRUE);

            vAssertModeText(ppdev, TRUE);

            vAssertModeBrushCache(ppdev, TRUE);

            vAssertModePalette(ppdev, TRUE);

#if DIRECTDRAW
            vAssertModeDirectDraw(ppdev, TRUE);
#endif

//
// chu01 begin
//
#ifdef GAMMACORRECT
{
            BYTE          ajClutSpace[MAX_CLUT_SIZE];
            PVIDEO_CLUT   pScreenClut;
            PALETTEENTRY* ppalFrom;
            PALETTEENTRY* ppalTo;
            PALETTEENTRY* ppalEnd;
            BOOL          status;
            ULONG         ulReturn;

            if (ppdev->flCaps & CAPS_GAMMA_CORRECT)
            {
                pScreenClut             = (PVIDEO_CLUT) ajClutSpace;
                pScreenClut->NumEntries = 256;
                pScreenClut->FirstEntry = 0;

                ppalFrom = ppdev->pPal;
                ppalTo   = (PALETTEENTRY*) pScreenClut->LookupTable;
                ppalEnd  = &ppalTo[256];

                for (; ppalTo < ppalEnd; ppalFrom++, ppalTo++)
                {
                   ppalTo->peRed   = ppalFrom->peRed   ;
                   ppalTo->peGreen = ppalFrom->peGreen ;
                   ppalTo->peBlue  = ppalFrom->peBlue  ;
                   ppalTo->peFlags = 0 ;
                }

//myf29 begin
                if (ppdev->ulChipID == 0xBC)
                    status = bEnableGammaCorrect(ppdev) ;
                else if ((ppdev->ulChipID == 0x40) || (ppdev->ulChipID ==0x4C))
                    status = bEnableGamma755x(ppdev) ;
//myf29 end

                CalculateGamma( ppdev, pScreenClut, 256 ) ;

                // Set palette registers:

                if (!IOCONTROL(ppdev->hDriver,
                               IOCTL_VIDEO_SET_COLOR_REGISTERS,
                               pScreenClut,
                               MAX_CLUT_SIZE,
                               NULL,
                               0,
                               &ulReturn))
                {
                    DISPDBG((0, "Failed bEnablePalette"));
                }

            }
}
#endif // GAMMACORRECT
//chu01

            ppdev->bEnabled = TRUE;

#if (NT_VERSION >= 0x0400)
            return(TRUE);
#endif
        }
    }

#if (NT_VERSION >= 0x0400)
    return(FALSE);
#endif
}

/******************************Public*Routine******************************\
* ULONG DrvGetModes
*
* Returns the list of available modes for the device.
*
\**************************************************************************/

ULONG DrvGetModes(
HANDLE      hDriver,
ULONG       cjSize,
DEVMODEW*   pdm)
{

    DWORD cModes;
    DWORD cbOutputSize;
    PVIDEO_MODE_INFORMATION pVideoModeInformation;
    PVIDEO_MODE_INFORMATION pVideoTemp;
    DWORD cOutputModes = cjSize / (sizeof(DEVMODEW) + DRIVER_EXTRA_SIZE);
    DWORD cbModeSize;

    cModes = getAvailableModes(hDriver,
                (PVIDEO_MODE_INFORMATION *) &pVideoModeInformation,
                &cbModeSize);
    if (cModes == 0)
    {
        DISPDBG((0, "DrvGetModes failed to get mode information"));
        return(0);
    }

    if (pdm == NULL)
    {
        cbOutputSize = cModes * (sizeof(DEVMODEW) + DRIVER_EXTRA_SIZE);
    }
    else
    {
        //
        // Now copy the information for the supported modes back into the
        // output buffer
        //

        cbOutputSize = 0;

        pVideoTemp = pVideoModeInformation;

        do
        {
            if (pVideoTemp->Length != 0)
            {
                if (cOutputModes == 0)
                {
                    break;
                }

                //
                // Zero the entire structure to start off with.
                //

                memset(pdm, 0, sizeof(DEVMODEW));

                //
                // Set the name of the device to the name of the DLL.
                //

                memcpy(pdm->dmDeviceName, DLL_NAME, sizeof(DLL_NAME));

                pdm->dmSpecVersion      = DM_SPECVERSION;
                pdm->dmDriverVersion    = DM_SPECVERSION;
                pdm->dmSize             = sizeof(DEVMODEW);
                pdm->dmDriverExtra      = DRIVER_EXTRA_SIZE;

                pdm->dmBitsPerPel       = pVideoTemp->NumberOfPlanes *
                                              pVideoTemp->BitsPerPlane;
                pdm->dmPelsWidth        = pVideoTemp->VisScreenWidth;
                pdm->dmPelsHeight       = pVideoTemp->VisScreenHeight;
                pdm->dmDisplayFrequency = pVideoTemp->Frequency;
                pdm->dmDisplayFlags     = 0;

                pdm->dmFields           = DM_BITSPERPEL       |
                                          DM_PELSWIDTH        |
                                          DM_PELSHEIGHT       |
                                          DM_DISPLAYFREQUENCY |
                                          DM_DISPLAYFLAGS     ;

#if (NT_VERSION < 0x0400)
                if (pVideoTemp->AttributeFlags & VIDEO_MODE_INTERLACED)
                {
                    pdm->dmDisplayFlags |= DM_INTERLACED;
                }
#endif

                //
                // Go to the next DEVMODE entry in the buffer.
                //

                cOutputModes--;

                pdm = (LPDEVMODEW) ( ((ULONG_PTR)pdm) + sizeof(DEVMODEW) +
                           DRIVER_EXTRA_SIZE);

                cbOutputSize += (sizeof(DEVMODEW) + DRIVER_EXTRA_SIZE);

            }

            pVideoTemp = (PVIDEO_MODE_INFORMATION)
                            (((PUCHAR)pVideoTemp) + cbModeSize);

        } while (--cModes);
    }

    FREE(pVideoModeInformation);

    return(cbOutputSize);
}

/******************************Public*Routine******************************\
* BOOL bAssertModeHardware
*
* Sets the appropriate hardware state for graphics mode or full-screen.
*
\**************************************************************************/

BOOL bAssertModeHardware(
PDEV* ppdev,
BOOL  bEnable)
{
    DWORD                   ReturnedDataLength;
    ULONG                   ulReturn;
    VIDEO_MODE_INFORMATION  VideoModeInfo;
    LONG                    cjEndOfFrameBuffer;
    LONG                    cjPointerOffset;
    LONG                    lDelta;
    ULONG                   ulMode;
    ULONG                   pFirstCL, pSecondCL;

    if (bEnable)
    {
        // Call the miniport via an IOCTL to set the graphics mode.

        ulMode = ppdev->ulMode;

    if (ppdev->bLinearMode)
    {
        ulMode |= VIDEO_MODE_MAP_MEM_LINEAR;
    }

    if (!IOCONTROL(ppdev->hDriver,
                   IOCTL_VIDEO_SET_CURRENT_MODE,
                   &ulMode,  // input buffer
                   sizeof(DWORD),
                   NULL,
                   0,
                   &ReturnedDataLength))
    {
        DISPDBG((0, "bAssertModeHardware - Failed VIDEO_SET_CURRENT_MODE"));
        goto ReturnFalse;
    }

    //
    // This driver requires that extended write modes be enabled.
    // Normally, we would put code like this into the miniport, but
    // unfortunately the VGA drivers do not expect extended write
    // modes to be enabled, and thus we have to put the code here.
    //

    #define ENABLE_EXTENDED_WRITE_MODES 0x4

    {
        BYTE    j;

        CP_OUT_BYTE(ppdev->pjPorts, INDEX_REG, 0x0B);
        j = CP_IN_BYTE(ppdev->pjPorts, DATA_REG);
        DISPDBG((3, "Mode extensions register was (%x)", j));
        j &= 0x20;
        j |= ENABLE_EXTENDED_WRITE_MODES;
        CP_OUT_BYTE(ppdev->pjPorts, DATA_REG, j);
        DISPDBG((3, "Mode extensions register now (%x)", j));
    }

    CP_IO_XPAR_COLOR_MASK(ppdev, ppdev->pjPorts, 0);

    if (!IOCONTROL(ppdev->hDriver,
                   IOCTL_VIDEO_QUERY_CURRENT_MODE,
                   NULL,
                   0,
                   &VideoModeInfo,
                   sizeof(VideoModeInfo),
                   &ReturnedDataLength))
    {
        DISPDBG((0, "bAssertModeHardware - failed VIDEO_QUERY_CURRENT_MODE"));
        goto ReturnFalse;
    }

//crus
//myf1, begin
#ifdef PANNING_SCROLL
    if ((ppdev->ulChipID == 0x38) || (ppdev->ulChipID == 0x2C) ||
        (ppdev->ulChipID == 0x30) || (ppdev->ulChipID == 0x34) ||   //myf19
        (ppdev->ulChipID == 0x40) || (ppdev->ulChipID == 0x4C)) //myf17
    {
         CirrusLaptopViewPoint(ppdev,  &VideoModeInfo);
    }
#endif
//myf1, end


    #if DEBUG_HEAP
        VideoModeInfo.VideoMemoryBitmapWidth  = VideoModeInfo.VisScreenWidth;
        VideoModeInfo.VideoMemoryBitmapHeight = VideoModeInfo.VisScreenHeight;
    #endif

    // The following variables are determined only after the initial
    // modeset:

    ppdev->lDelta   = VideoModeInfo.ScreenStride;
    ppdev->flCaps   = VideoModeInfo.DriverSpecificAttributeFlags;

    DISPDBG((1,"ppdev->flCaps = %x",ppdev->flCaps));    //2

#if 1 // Check for 5446 chip.
    CP_OUT_BYTE(ppdev->pjPorts, CRTC_INDEX, 0x27);
    ppdev->ulChipID    = CP_IN_BYTE(ppdev->pjPorts, CRTC_DATA) & 0xFC;
    //
    // add chip flags for 5446BE and 5480
    //
    //sge01 begin
    if ((ppdev->ulChipID == 0xB8) || (ppdev->ulChipID == 0xBC))
    {
        ppdev->flCaps |= CAPS_VIDEO;
        if (ppdev->ulChipID == 0xBC)
        {
            ppdev->flCaps |= CAPS_SECOND_APERTURE;
        }
        else
        {
            // get revision ID
            CP_OUT_BYTE(ppdev->pjPorts, CRTC_INDEX, 0x25);
            ppdev->ulChipNum = CP_IN_BYTE(ppdev->pjPorts, CRTC_DATA);
            if (ppdev->ulChipNum==0x45)
               ppdev->flCaps |= CAPS_SECOND_APERTURE;
        }
    }
//myf30 begin
    else if ((ppdev->ulChipID == 0x40) || (ppdev->ulChipID == 0x4C))
    {
#if (_WIN32_WINNT >= 0x0400)
        ppdev->flCaps |= CAPS_VIDEO;
#endif
    }
//myf30 end
#endif
//sge01 end


    // Set up the shift factor for the banking code.

    if (ppdev->flCaps & CAPS_IS_542x)
    {
        ppdev->ulBankShiftFactor = 12;
    }
    else
    {
        ppdev->ulBankShiftFactor = 10;
    }

    ppdev->cxMemory = VideoModeInfo.VideoMemoryBitmapWidth;
    ppdev->cyMemory = VideoModeInfo.VideoMemoryBitmapHeight;

//pat04, begin
//#if 0
#if (_WIN32_WINNT < 0x0400)
    ppdev->cxScreen = VideoModeInfo.VisScreenWidth;
    ppdev->cyScreen = VideoModeInfo.VisScreenHeight;
#endif
//#endif
//pat04, end

//crus begin
//ms0809, begin
    /********************************************************************
    *
    * If we are on a DSTN panel, then the hardware needs 128K for the
    * half frame accelerator.
    *
    ********************************************************************/

    if ((ppdev->flCaps & CAPS_DSTN_PANEL) &&
        ((ppdev->ulChipID == 0x38) || (ppdev->ulChipID == 0x2C) ||
        (ppdev->ulChipID == 0x30) || (ppdev->ulChipID == 0x34) ||   //myf19
        (ppdev->ulChipID == 0x40) || (ppdev->ulChipID == 0x4C)) ) //myf17
    {
        // figure out how much cyMemory needs to be decremented by
        // to reserve 128K.
        // =====================================================
        // if Matterhorn 2M/4M board needs to be decremented by
        // to reserve 152K+16k(h/w icon)=168K.
        // =====================================================


        // I need to make sure that if there is a remainder that I
        // remove an additional scan.  What is the best way to do
        // this?  Is this the memory the DSTN is using?  Will it ever
        // use more?

        if ((ppdev->ulChipID == 0x38) || (ppdev->ulChipID == 0x2C) ||
            (ppdev->ulChipID == 0x30) || (ppdev->ulChipID == 0x34))     //myf19
            ppdev->cyMemory -= (0x24000 / ppdev->cxMemory); //myf

        else if ((ppdev->ulChipID == 0x40) || (ppdev->ulChipID == 0x4C))//myf17
            ppdev->cyMemory -= (0x2A000 / ppdev->cxMemory); //myf

    }
//  else if (!(ppdev->flCaps & CAPS_DSTN_PANEL) &&
    else if (((ppdev->ulChipID == 0x38) || (ppdev->ulChipID == 0x2C) || //myf20
         (ppdev->ulChipID == 0x30) || (ppdev->ulChipID == 0x34) ||  //myf19
         (ppdev->ulChipID == 0x40) || (ppdev->ulChipID == 0x4C))) //myf17
    {
        // figure out how much cyMemory needs to be decremented by
        // to reserve 16K for H/W icon & cursor
        // =====================================================

           ppdev->cyMemory -= (0x4000 / ppdev->cxMemory); //myf
    }
//ms0809, end
//crus end

//sge01 begin
    if (!(ppdev->flCaps & CAPS_BLT_SUPPORT))
    {
        DISPDBG((1, "Cirrus chip doesn't support BLT's"));
        goto ReturnFalse;
    }
//sge01 end

    //
    // Check to see if we have a non-zero value for pjBase.  If so, we
    // can support memory mapped IO.
    //

    if (ppdev->pjBase)
    {
        CP_ENABLE_MM_IO(ppdev, ppdev->pjPorts);
        CP_MM_START_REG(ppdev, ppdev->pjBase, BLT_RESET);

        if (ppdev->flCaps & CAPS_AUTOSTART)
        {
            //
            // enable second aperture for 5480 and 5446BE
            //
            // sge01 begin
            if (ppdev->flCaps & CAPS_SECOND_APERTURE)
            {
                CP_MM_START_REG(ppdev, ppdev->pjBase, BLT_AUTO_START | BLT_SECOND_APERTURE);
            }
            else
            //sge01 end
            {
                CP_MM_START_REG(ppdev, ppdev->pjBase, BLT_AUTO_START);
            }

        }
    }
    else
    {
        CP_DISABLE_MM_IO(ppdev, ppdev->pjPorts);
        CP_IO_START_REG(ppdev, ppdev->pjPorts, BLT_RESET);

        if (ppdev->flCaps & CAPS_AUTOSTART)
        {
            //
            // enable second aperture for 5480 and 5446BE
            //
            // sge01 begin
            if (ppdev->flCaps & CAPS_SECOND_APERTURE)
            {
                CP_IO_START_REG(ppdev, ppdev->pjBase, BLT_AUTO_START | BLT_SECOND_APERTURE);
            }
            else
            //sge 01 end
            {
                CP_IO_START_REG(ppdev, ppdev->pjBase, BLT_AUTO_START);
            }

        }
    }

    /********************************************************************
    *
    * If we're using the hardware pointer, reserve the last scan of
    * the frame buffer to store the pointer shape.  The pointer MUST be
    * stored in the last 256 bytes of video memory.
    *
    ********************************************************************/

// #pat08 start
//#if 0
#if (_WIN32_WINNT < 0x0400)

 #ifdef PANNING_SCROLL
        // allocate without test
//   if ((ppdev->ulChipID != CL7541_ID) && (ppdev->ulChipID != CL7543_ID) &&
//        (ppdev->ulChipID != CL7542_ID) && (ppdev->ulChipID != CL7548_ID) &&
//        (ppdev->ulChipID != CL7555_ID) && (ppdev->ulChipID != CL7556_ID))
//          if (!(ppdev->flCaps & (CAPS_SW_POINTER)))
//   else
//        ;
 #else
     if (!(ppdev->flCaps & (CAPS_SW_POINTER)))
 #endif

#else // NT 4.0 code
    if (!(ppdev->flCaps & (CAPS_SW_POINTER)))
#endif
//#endif          //0,pat08
// #pat08  end

//pat08    if (!(ppdev->flCaps & (CAPS_SW_POINTER)))
    {
        // We'll reserve the end of off-screen memory for the hardware
        // pointer shape.

        cjPointerOffset = (ppdev->ulMemSize - SPRITE_BUFFER_SIZE);

        // Figure out the coordinate where the pointer shape starts:

        lDelta = ppdev->lDelta;

        ppdev->cjPointerOffset = cjPointerOffset;
        ppdev->yPointerShape   = (cjPointerOffset / lDelta);
        ppdev->xPointerShape   = (cjPointerOffset % lDelta) / ppdev->cBpp;

        if (ppdev->yPointerShape >= ppdev->cyScreen)
        {
            // There's enough room for the pointer shape at the
            // bottom of off-screen memory; reserve its room by
            // lying about how much off-screen memory there is:

            ppdev->cyMemory = min(ppdev->yPointerShape, ppdev->cyMemory);
        }
        else
        {
            // There's not enough room for the pointer shape in
            // off-screen memory; we'll have to simulate:

            DISPDBG((2,"Not enough room for HW pointer...\n"
                           "\tppdev->yPointerShape(%d)\n"
                           "\tppdev->cyScreen(%d)\n"
                           "\tcjPointerOffset(%d)",
                           ppdev->yPointerShape, ppdev->cyScreen,cjPointerOffset));

            ppdev->flCaps |= CAPS_SW_POINTER;
        }
    }

    // !!! No room for a transfer buffer, as in the 1280x1024 case on
    //     a 2 MB card.  This case should go away when the miniport
    //     is fixed to return non-power-of-2 screen strides.

    if ((ppdev->cyMemory == ppdev->cyScreen) ||
        (ppdev->flCaps & CAPS_NO_HOST_XFER))
    {
        //
        // disable host xfer buffer
        //
        ppdev->lXferBank = 0;
        ppdev->pulXfer = NULL;
        DISPDBG((2,"Host transfers disabled"));
    }
    else
    {
        //
        // for chips do not have second aperture
        //
        // sge01 begin
        if (!(ppdev->flCaps & CAPS_SECOND_APERTURE))
        {
            if (ppdev->flCaps & CAPS_AUTOSTART)
            {
                (BYTE*)ppdev->pulXfer = ppdev->pjScreen;
            }
            else
            {
                //
                // enable host xfer buffer
                //
                ASSERTDD(ppdev->cyMemory > ppdev->cyScreen, "No scans left for blt xfer buffer");
                ppdev->cyMemory--;
                cjEndOfFrameBuffer = ppdev->cyMemory * ppdev->lDelta;
                ppdev->lXferBank = cjEndOfFrameBuffer / ppdev->cjBank;
                (BYTE*)ppdev->pulXfer = ppdev->pjScreen + (cjEndOfFrameBuffer % ppdev->cjBank);

                DISPDBG((2, "ppdev->cyMemory = %x", ppdev->cyMemory)) ;
                DISPDBG((2, "ppdev->lDelta = %x", ppdev->lDelta))     ;
                DISPDBG((2, "cjBank: %lx", ppdev->cjBank))            ;
                DISPDBG((2, "pulXfer = %x", ppdev->pulXfer))          ;
                DISPDBG((2, "Host transfers enabled"))                ;
            }
        }
#if 0   // D5480
        //
        // allocate command list buffer
        //
        if ((ppdev->flCaps & CAPS_COMMAND_LIST) && FALSE)
        {
            ppdev->cyMemory -= (COMMAND_BUFFER_SIZE + COMMAND_BUFFER_ALIGN + ppdev->lDelta / 2 ) / ppdev->lDelta;
            cjEndOfFrameBuffer = ppdev->cyMemory * ppdev->lDelta;
            pFirstCL = (ULONG)(((ULONG_PTR)ppdev->pjScreen + cjEndOfFrameBuffer + COMMAND_BUFFER_ALIGN) & ~COMMAND_BUFFER_ALIGN);
            pSecondCL = pFirstCL + (COMMAND_BUFFER_SIZE >> 1);

            ppdev->pCLFirst = (ULONG_PTR*) pFirstCL;
            ppdev->pCLSecond = (ULONG_PTR*) pSecondCL;
            ppdev->pCommandList = ppdev->pCLFirst;
        }
#endif  // endif D5480

        //
        // Make sure we don't try to use command lists.
        //

        ppdev->pCommandList = NULL;
    }

        DISPDBG((2, "ppdev->cxMemory = %x", ppdev->cxMemory)) ;
        DISPDBG((2, "ppdev->cyMemory = %x", ppdev->cyMemory)) ;
        DISPDBG((2, "ppdev->cxScreen = %x", ppdev->cxScreen)) ;
        DISPDBG((2, "ppdev->cyScreen = %x", ppdev->cyScreen)) ;
        DISPDBG((2, "ppdev->lDelta = %x", ppdev->lDelta))     ;
        DISPDBG((2, "cjBank: %lx", ppdev->cjBank))            ;
        DISPDBG((2,"pulXfer = %x", ppdev->pulXfer))           ;

        // Do some paramater checking on the values that the miniport
        // returned to us:

        ASSERTDD(ppdev->cxMemory >= ppdev->cxScreen, "Invalid cxMemory");
        ASSERTDD(ppdev->cyMemory >= ppdev->cyScreen, "Invalid cyMemory");
    }
    else
    {
        CP_DISABLE_MM_IO(ppdev, ppdev->pjPorts);

        // Call the kernel driver to reset the device to a known state.
        // NTVDM will take things from there:

        if (!IOCONTROL(ppdev->hDriver,
                       IOCTL_VIDEO_RESET_DEVICE,
                       NULL,
                       0,
                       NULL,
                       0,
                       &ulReturn))
        {
            DISPDBG((0, "bAssertModeHardware - Failed reset IOCTL"));
            return FALSE;
        }
    }

    DISPDBG((5, "Passed bAssertModeHardware"));

    return(TRUE);

ReturnFalse:

    DISPDBG((0, "Failed bAssertModeHardware"));

    return(FALSE);
}

/******************************Public*Routine******************************\
* BOOL bEnableHardware
*
* Puts the hardware in the requested mode and initializes it.
*
* Note: Should be called before any access is done to the hardware from
*       the display driver.
*
\**************************************************************************/

BOOL bEnableHardware(
PDEV*   ppdev)
{
    VIDEO_PUBLIC_ACCESS_RANGES VideoAccessRange[2];
    VIDEO_MEMORY               VideoMemory;
//sge01  VIDEO_MEMORY_INFORMATION   VideoMemoryInfo;
    VIDEO_MEMORY_INFORMATION   VideoMemoryInfo[2];      // sge01
    DWORD                      ReturnedDataLength;
    BYTE*                      pjPorts = ppdev->pjPorts;
    ULONG                      ulMode;
    BOOL                                   bRet;

    //
    // Check the last field in the PDEV to make sure that the compiler
    // didn't generate unaligned fields following BYTE fields.
    //

    ASSERTDD(!(((ULONG_PTR)(&ppdev->ulLastField)) & 3),
                 "PDEV alignment screwed up... BYTE fields mishandled?");

    // Map the ports.

    bRet = IOCONTROL(ppdev->hDriver,
                         IOCTL_VIDEO_QUERY_PUBLIC_ACCESS_RANGES,
                         NULL,                      // input buffer
                         0,
                         (PVOID) VideoAccessRange,  // output buffer
                         sizeof (VideoAccessRange),
                         &ReturnedDataLength);
    if (bRet == FALSE)
    {
        DISPDBG((0, "bEnableHardware - Error mapping ports"));
        goto ReturnFalse;
    }

    // Set a convienent pointer to the registers in the pdev.

    ppdev->pjPorts = VideoAccessRange[0].VirtualAddress;
    ppdev->pjBase  = VideoAccessRange[1].VirtualAddress;

    //
    // Merge port and register access for
    // VGA relocatable and MMIO registers.
    //
    // sge02 begin
#if defined(_X86_)
    if (VideoAccessRange[0].InIoSpace)
    {
        ppdev->pfnREAD_PORT_UCHAR    = CirrusREAD_PORT_UCHAR;
        ppdev->pfnREAD_PORT_USHORT   = CirrusREAD_PORT_USHORT;
        ppdev->pfnREAD_PORT_ULONG    = CirrusREAD_PORT_ULONG;
        ppdev->pfnWRITE_PORT_UCHAR   = CirrusWRITE_PORT_UCHAR;
        ppdev->pfnWRITE_PORT_USHORT  = CirrusWRITE_PORT_USHORT;
        ppdev->pfnWRITE_PORT_ULONG   = CirrusWRITE_PORT_ULONG;
    }
    else
    {
        ppdev->pfnREAD_PORT_UCHAR    = CirrusREAD_REGISTER_UCHAR;
        ppdev->pfnREAD_PORT_USHORT   = CirrusREAD_REGISTER_USHORT;
        ppdev->pfnREAD_PORT_ULONG    = CirrusREAD_REGISTER_ULONG;
        ppdev->pfnWRITE_PORT_UCHAR   = CirrusWRITE_REGISTER_UCHAR;
        ppdev->pfnWRITE_PORT_USHORT  = CirrusWRITE_REGISTER_USHORT;
        ppdev->pfnWRITE_PORT_ULONG   = CirrusWRITE_REGISTER_ULONG;
    }
#elif defined(_ALPHA_)
    if (VideoAccessRange[0].InIoSpace)
    {
        ppdev->pfnREAD_PORT_UCHAR    = READ_PORT_UCHAR;
        ppdev->pfnREAD_PORT_USHORT   = READ_PORT_USHORT;
        ppdev->pfnREAD_PORT_ULONG    = READ_PORT_ULONG;
        ppdev->pfnWRITE_PORT_UCHAR   = WRITE_PORT_UCHAR;
        ppdev->pfnWRITE_PORT_USHORT  = WRITE_PORT_USHORT;
        ppdev->pfnWRITE_PORT_ULONG   = WRITE_PORT_ULONG;
    }
    else
    {
        ppdev->pfnREAD_PORT_UCHAR    = READ_REGISTER_UCHAR;
        ppdev->pfnREAD_PORT_USHORT   = READ_REGISTER_USHORT;
        ppdev->pfnREAD_PORT_ULONG    = READ_REGISTER_ULONG;
        ppdev->pfnWRITE_PORT_UCHAR   = (FnWRITE_PORT_UCHAR)WRITE_REGISTER_UCHAR;
        ppdev->pfnWRITE_PORT_USHORT  = (FnWRITE_PORT_USHORT)WRITE_REGISTER_USHORT;
        ppdev->pfnWRITE_PORT_ULONG   = (FnWRITE_PORT_ULONG)WRITE_REGISTER_ULONG;
    }
#endif
//sge02 end

    //
    // Try to get the miniport to give us a mode with a linear frame buffer.
    //

    ulMode = ppdev->ulMode | VIDEO_MODE_MAP_MEM_LINEAR;

    if (!IOCONTROL(ppdev->hDriver,
                   IOCTL_VIDEO_SET_CURRENT_MODE,
                   &ulMode,  // input buffer
                   sizeof(DWORD),
                   NULL,
                   0,
                   &ReturnedDataLength))
    {
        //
        // We could not set this mode with a linear frame buffer, so lets try
        // again banked.
        //

        ulMode &= ~VIDEO_MODE_MAP_MEM_LINEAR;

        if (!IOCONTROL(ppdev->hDriver,
                       IOCTL_VIDEO_SET_CURRENT_MODE,
                       &ulMode,  // input buffer
                       sizeof(DWORD),
                       NULL,
                       0,
                       &ReturnedDataLength))
        {
            DISPDBG((0, "bEnableHardware - Failed VIDEO_SET_CURRENT_MODE"));
            goto ReturnFalse;
        }
    }

    ppdev->bLinearMode = (ulMode & VIDEO_MODE_MAP_MEM_LINEAR) ? TRUE : FALSE;

    // Get the linear memory address range.

    VideoMemory.RequestedVirtualAddress = NULL;

    if (!IOCONTROL(ppdev->hDriver,
                   IOCTL_VIDEO_MAP_VIDEO_MEMORY,
                   &VideoMemory,      // input buffer
                   sizeof(VIDEO_MEMORY),
                   VideoMemoryInfo,   // output buffer
                   sizeof(VideoMemoryInfo),
                   &ReturnedDataLength))
    {
        DISPDBG((0, "bEnableHardware - Error mapping video buffer"));
        goto ReturnFalse;
    }

//myfr, 2
    DISPDBG((2, "FrameBufferBase(ie. pjScreen) %lx",
                VideoMemoryInfo[0].FrameBufferBase));
    DISPDBG((2, "FrameBufferLength %d",
                VideoMemoryInfo[0].FrameBufferLength));
    DISPDBG((2, "VideoRamLength(ie. ulMemSize) %d",
                VideoMemoryInfo[0].VideoRamLength));

    // Record the Frame Buffer Linear Address.

//sge01
    ppdev->pjScreen  = (BYTE*) VideoMemoryInfo[0].FrameBufferBase;
    ppdev->cjBank    = VideoMemoryInfo[0].FrameBufferLength;
    ppdev->ulMemSize = VideoMemoryInfo[0].VideoRamLength;

    // Now we can set the mode and unlock the accelerator.

    if (!bAssertModeHardware(ppdev, TRUE))
    {
        goto ReturnFalse;
    }

    //sge01 begin
    if ((ppdev->flCaps & CAPS_SECOND_APERTURE) &&
        !(ppdev->flCaps & CAPS_NO_HOST_XFER))
    {
        ppdev->pulXfer = VideoMemoryInfo[1].VideoRamBase;
    }
    //sge01 end

    if (ppdev->flCaps & CAPS_MM_IO)
    {
        DISPDBG((1,"Memory mapped IO enabled"));
#if 1 // D5480
        if ((ppdev->flCaps & CAPS_COMMAND_LIST) &&
            (ppdev->pCommandList != NULL))
        {
             //
             // Bitmap functions
             //
             ppdev->pfnXfer1bpp      = vMmXfer1bpp80;
             ppdev->pfnXfer4bpp      = vMmXfer4bpp;
             ppdev->pfnXferNative    = vMmXferNative80;

             //
             // Pattern functions
             //
             //
             // chu02 : This is due to hardware error for 24bpp,
             //         GR2f[4..0] != 0, non-color expandsion and 8x8 pattern
             //         copy.
             //
             ppdev->pfnFillPat       = (ppdev->cBpp == 3) ?
                                           vMmFillPat36 : vMmFillPat80;
             ppdev->pfnFillSolid     = vMmFillSolid80;
             ppdev->pfnCopyBlt       = vMmCopyBlt80;

             //
             // Text functions
             //
             ppdev->pfnGlyphOut      = vMmGlyphOut80;
             ppdev->pfnGlyphOutClip  = vMmGlyphOutClip80;
        }
        else if(ppdev->flCaps & CAPS_AUTOSTART)
        {
            // bitmap functions
            ppdev->pfnXfer1bpp      = vMmXfer1bpp;
            ppdev->pfnXfer4bpp      = vMmXfer4bpp;
            ppdev->pfnXferNative    = vMmXferNative;
            // Pattern functions
            ppdev->pfnFillPat       = vMmFillPat36;
            ppdev->pfnFillSolid     = vMmFillSolid36;
            ppdev->pfnCopyBlt       = vMmCopyBlt36;
            // Text functions
            ppdev->pfnGlyphOut      = vMmGlyphOut;
            ppdev->pfnGlyphOutClip  = vMmGlyphOutClip;
        }
        else
        {
            // bitmap functions
            ppdev->pfnXfer1bpp      = vMmXfer1bpp;
            ppdev->pfnXfer4bpp      = vMmXfer4bpp;
            ppdev->pfnXferNative    = vMmXferNative;
            // Pattern functions
            ppdev->pfnFillPat       = vMmFillPat;
            ppdev->pfnFillSolid     = vMmFillSolid;
            ppdev->pfnCopyBlt       = vMmCopyBlt;
            // Text functions
            ppdev->pfnGlyphOut      = vMmGlyphOut;
            ppdev->pfnGlyphOutClip  = vMmGlyphOutClip;
        }
        ppdev->pfnFastPatRealize    = vMmFastPatRealize;
#if LINETO
        ppdev->pfnLineTo            = bMmLineTo;
#endif
#endif // endif D5480
    }
    else
    {
        DISPDBG((1,"Memory mapped IO disabled"));

        ppdev->pfnXfer1bpp          = vIoXfer1bpp;
        ppdev->pfnXfer4bpp          = vIoXfer4bpp;
        ppdev->pfnXferNative        = vIoXferNative;
        ppdev->pfnFillSolid         = vIoFillSolid;
        ppdev->pfnFillPat           = vIoFillPat;
        ppdev->pfnCopyBlt           = vIoCopyBlt;
        ppdev->pfnFastPatRealize    = vIoFastPatRealize;
#if LINETO
        ppdev->pfnLineTo            = bIoLineTo;
#endif
    }

    /////////////////////////////////////////////////////////////
    // Fill in pfns specific to linear vs banked frame buffer

    if (ppdev->bLinearMode)
    {
        ppdev->pfnGetBits = vGetBitsLinear;
        ppdev->pfnPutBits = vPutBitsLinear;
    }
    else
    {
        ppdev->pfnGetBits = vGetBits;
        ppdev->pfnPutBits = vPutBits;
    }

    DISPDBG((5, "Passed bEnableHardware"));

    return(TRUE);

ReturnFalse:

    DISPDBG((0, "Failed bEnableHardware"));

    return(FALSE);
}

/******************************Public*Routine******************************\
* VOID vDisableHardware
*
* Undoes anything done in bEnableHardware.
*
* Note: In an error case, we may call this before bEnableHardware is
*       completely done.
*
\**************************************************************************/

VOID vDisableHardware(
PDEV*   ppdev)
{
    //
    // It is possible that we reached this point without
    // actually mapping memory.  (i.e. if the SET_CURRENT_MODE
    // failed which occurs before we map memory)
    //
    // If this is the case, we should not try to free the
    // memory, because it hasn't been mapped!
    //

    if (ppdev->pjScreen)
    {
        DWORD        ReturnedDataLength;
        VIDEO_MEMORY VideoMemory;

        VideoMemory.RequestedVirtualAddress = ppdev->pjScreen;

        if (!IOCONTROL(ppdev->hDriver,
                       IOCTL_VIDEO_UNMAP_VIDEO_MEMORY,
                       &VideoMemory,
                       sizeof(VIDEO_MEMORY),
                       NULL,
                       0,
                       &ReturnedDataLength))
        {
            DISPDBG((0, "vDisableHardware failed IOCTL_VIDEO_UNMAP_VIDEO"));
        }
    }
}

/******************************Public*Routine******************************\
* BOOL bInitializeModeFields
*
* Initializes a bunch of fields in the pdev, devcaps (aka gdiinfo), and
* devinfo based on the requested mode.
*
\**************************************************************************/

BOOL bInitializeModeFields(
PDEV*     ppdev,
GDIINFO*  pgdi,
DEVINFO*  pdi,
DEVMODEW* pdm)
{
    ULONG                   cModes;
    PVIDEO_MODE_INFORMATION pVideoBuffer;
    PVIDEO_MODE_INFORMATION pVideoModeSelected;
    PVIDEO_MODE_INFORMATION pVideoTemp;
    BOOL                    bSelectDefault;
    VIDEO_MODE_INFORMATION  VideoModeInformation;
    ULONG                   cbModeSize;

    // crus
    VIDEO_PUBLIC_ACCESS_RANGES VideoAccessRange[2];
    VIDEO_MEMORY               VideoMemory;
    DWORD                      ReturnedDataLength;
    BOOL                       bRet;

    DISPDBG((2, "bInitializeModeFields"));

    // crus
    bRet = IOCONTROL(ppdev->hDriver,
                         IOCTL_VIDEO_QUERY_PUBLIC_ACCESS_RANGES,
                         NULL,                      // input buffer
                         0,
                         (PVOID) VideoAccessRange,  // output buffer
                         sizeof (VideoAccessRange),
                         &ReturnedDataLength);
    if (bRet == FALSE)
    {
        DISPDBG((0, "bInitializeModeFields - Error mapping ports"));
        goto ReturnFalse;
    }

    // Set a convienent pointer to the registers in the pdev.

    ppdev->pjPorts = VideoAccessRange[0].VirtualAddress;
    ppdev->pjBase  = VideoAccessRange[1].VirtualAddress;
    //sge01 end

    //
    // Merge port and register access for
    // VGA relocatable and MMIO registers.
    //
    // crus
#if defined(_X86_)
    if (VideoAccessRange[0].InIoSpace)
    {
        ppdev->pfnREAD_PORT_UCHAR    = CirrusREAD_PORT_UCHAR;
        ppdev->pfnREAD_PORT_USHORT   = CirrusREAD_PORT_USHORT;
        ppdev->pfnREAD_PORT_ULONG    = CirrusREAD_PORT_ULONG;
        ppdev->pfnWRITE_PORT_UCHAR   = CirrusWRITE_PORT_UCHAR;
        ppdev->pfnWRITE_PORT_USHORT  = CirrusWRITE_PORT_USHORT;
        ppdev->pfnWRITE_PORT_ULONG   = CirrusWRITE_PORT_ULONG;
    }
    else
    {
        ppdev->pfnREAD_PORT_UCHAR    = CirrusREAD_REGISTER_UCHAR;
        ppdev->pfnREAD_PORT_USHORT   = CirrusREAD_REGISTER_USHORT;
        ppdev->pfnREAD_PORT_ULONG    = CirrusREAD_REGISTER_ULONG;
        ppdev->pfnWRITE_PORT_UCHAR   = CirrusWRITE_REGISTER_UCHAR;
        ppdev->pfnWRITE_PORT_USHORT  = CirrusWRITE_REGISTER_USHORT;
        ppdev->pfnWRITE_PORT_ULONG   = CirrusWRITE_REGISTER_ULONG;
    }
#elif defined(_ALPHA_)
    if (VideoAccessRange[0].InIoSpace)
    {
        ppdev->pfnREAD_PORT_UCHAR    = READ_PORT_UCHAR;
        ppdev->pfnREAD_PORT_USHORT   = READ_PORT_USHORT;
        ppdev->pfnREAD_PORT_ULONG    = READ_PORT_ULONG;
        ppdev->pfnWRITE_PORT_UCHAR   = WRITE_PORT_UCHAR;
        ppdev->pfnWRITE_PORT_USHORT  = WRITE_PORT_USHORT;
        ppdev->pfnWRITE_PORT_ULONG   = WRITE_PORT_ULONG;
    }
    else
    {
        ppdev->pfnREAD_PORT_UCHAR    = READ_REGISTER_UCHAR;
        ppdev->pfnREAD_PORT_USHORT   = READ_REGISTER_USHORT;
        ppdev->pfnREAD_PORT_ULONG    = READ_REGISTER_ULONG;
        ppdev->pfnWRITE_PORT_UCHAR   = (FnWRITE_PORT_UCHAR)WRITE_REGISTER_UCHAR;
        ppdev->pfnWRITE_PORT_USHORT  = (FnWRITE_PORT_USHORT)WRITE_REGISTER_USHORT;
        ppdev->pfnWRITE_PORT_ULONG   = (FnWRITE_PORT_ULONG)WRITE_REGISTER_ULONG;
    }
#endif

//crus
    CP_OUT_BYTE(ppdev->pjPorts, CRTC_INDEX, 0x27);
    ppdev->ulChipID = CP_IN_BYTE(ppdev->pjPorts, CRTC_DATA) & 0xFC;

    // Call the miniport to get mode information
    cModes = getAvailableModes(ppdev->hDriver, &pVideoBuffer, &cbModeSize);

    if (cModes == 0)
    {
        DISPDBG((2, "getAvailableModes returned 0"));
        goto ReturnFalse;
    }

    // Now see if the requested mode has a match in that table.

    pVideoModeSelected = NULL;
    pVideoTemp = pVideoBuffer;

    if ((pdm->dmPelsWidth == 0) &&
        (pdm->dmPelsHeight == 0) &&
        (pdm->dmBitsPerPel == 0) &&
        (pdm->dmDisplayFrequency == 0))
    {
        DISPDBG((2, "Default mode requested"));
        bSelectDefault = TRUE;
    }
    else
    {
        DISPDBG((2, "Requested mode..."));
        DISPDBG((2, "  Screen width  -- %li", pdm->dmPelsWidth));
        DISPDBG((2, "  Screen height -- %li", pdm->dmPelsHeight));
        DISPDBG((2, "  Bits per pel  -- %li", pdm->dmBitsPerPel));
        DISPDBG((2, "  Frequency     -- %li", pdm->dmDisplayFrequency));
        bSelectDefault = FALSE;
    }

    while (cModes--)
    {
        if (pVideoTemp->Length != 0)
        {
//myfr, 2->0
            DISPDBG((2, "Checking against miniport mode:"));
            DISPDBG((2, "  Screen width  -- %li", pVideoTemp->VisScreenWidth));
            DISPDBG((2, "  Screen height -- %li", pVideoTemp->VisScreenHeight));
            DISPDBG((2, "  Bits per pel  -- %li", pVideoTemp->BitsPerPlane *
                              pVideoTemp->NumberOfPlanes));
            DISPDBG((2, "  Frequency     -- %li", pVideoTemp->Frequency));

//pat04, begin
//#if 0
#if (_WIN32_WINNT < 0x0400)
            if ((ppdev->ulChipID == CL7541_ID) || (ppdev->ulChipID == CL7543_ID) ||
                (ppdev->ulChipID == CL7542_ID) || (ppdev->ulChipID == CL7548_ID) ||
                (ppdev->ulChipID == CL7555_ID) || (ppdev->ulChipID == CL7556_ID))
            {
                 if ((pVideoTemp->VisScreenWidth  == 640) &&
                     (pVideoTemp->VisScreenHeight == 480) &&
                     (pVideoTemp->BitsPerPlane *
                      pVideoTemp->NumberOfPlanes  == 8) &&
                     (pVideoTemp->Frequency       == 60))
                 {
                     pVideoModeSelected = pVideoTemp;
                 } // default mode = 640x480x256 !   //#pat4
            }
#endif
//#endif  //0, pat04
//pat04, end

            if (bSelectDefault ||
                ((pVideoTemp->VisScreenWidth  == pdm->dmPelsWidth) &&
                 (pVideoTemp->VisScreenHeight == pdm->dmPelsHeight) &&
                 (pVideoTemp->BitsPerPlane *
                  pVideoTemp->NumberOfPlanes  == pdm->dmBitsPerPel) &&
                 (pVideoTemp->Frequency       == pdm->dmDisplayFrequency)))
            {
                pVideoModeSelected = pVideoTemp;
                DISPDBG((2, "...Found a mode match!"));
                break;
            }
        }
        pVideoTemp = (PVIDEO_MODE_INFORMATION)
            (((PUCHAR)pVideoTemp) + cbModeSize);
    }

    // If no mode has been found, return an error

    if (pVideoModeSelected == NULL)
    {
        DISPDBG((2, "...Couldn't find a mode match!"));
        FREE(pVideoBuffer);             //ms923
        goto ReturnFalse;
    }

    // We have chosen the one we want.  Save it in a stack buffer and
    // get rid of allocated memory before we forget to free it.

    VideoModeInformation = *pVideoModeSelected;
    FREE(pVideoBuffer);

#if DEBUG_HEAP
    VideoModeInformation.VisScreenWidth  = 640;
    VideoModeInformation.VisScreenHeight = 480;
#endif

    // Set up screen information from the mini-port:

    ppdev->ulMode   = VideoModeInformation.ModeIndex;
    ppdev->cxScreen = VideoModeInformation.VisScreenWidth;
    ppdev->cyScreen = VideoModeInformation.VisScreenHeight;

    DISPDBG((2, "ScreenStride: %lx", VideoModeInformation.ScreenStride));

//crus
#ifdef PANNING_SCROLL
    if ((ppdev->ulChipID == 0x38) || (ppdev->ulChipID == 0x2C) ||
        (ppdev->ulChipID == 0x30) || (ppdev->ulChipID == 0x34) || //myf19
        (ppdev->ulChipID == 0x40) || (ppdev->ulChipID == 0x4C))   //myf17
    {
         CirrusLaptopViewPoint(ppdev, &VideoModeInformation);
    }
#endif

    // Setting the SYNCHRONIZEACCESS flag tells GDI that we
    // want all drawing to the bitmaps to be synchronized (GDI
    // is multi-threaded and by default does not synchronize
    // device bitmap drawing -- it would be a Bad Thing for us
    // to have multiple threads using the accelerator at the
    // same time):

    ppdev->flHooks = HOOK_SYNCHRONIZEACCESS
                                | HOOK_FILLPATH
                                | HOOK_BITBLT
                                | HOOK_TEXTOUT
                                | HOOK_COPYBITS
                                | HOOK_STROKEPATH
                                | HOOK_SYNCHRONIZE
#if LINETO
                                | HOOK_LINETO
#endif
#if !DRIVER_PUNT_ALL
#if !DRIVER_PUNT_STRETCH
                                | HOOK_STRETCHBLT
#endif
#endif
                                ;

    // Fill in the GDIINFO data structure with the default 8bpp values:

    *pgdi = ggdiDefault;

    // Now overwrite the defaults with the relevant information returned
    // from the kernel driver:

    pgdi->ulHorzSize        = VideoModeInformation.XMillimeter;
    pgdi->ulVertSize        = VideoModeInformation.YMillimeter;

    pgdi->ulHorzRes         = VideoModeInformation.VisScreenWidth;
    pgdi->ulVertRes         = VideoModeInformation.VisScreenHeight;

#if (NT_VERSION < 0x0400)
    pgdi->ulDesktopHorzRes  = VideoModeInformation.VisScreenWidth;
    pgdi->ulDesktopVertRes  = VideoModeInformation.VisScreenHeight;
#else
    pgdi->ulPanningHorzRes  = VideoModeInformation.VisScreenWidth;
    pgdi->ulPanningVertRes  = VideoModeInformation.VisScreenHeight;
#endif

    pgdi->cBitsPixel        = VideoModeInformation.BitsPerPlane;
    pgdi->cPlanes           = VideoModeInformation.NumberOfPlanes;
    pgdi->ulVRefresh        = VideoModeInformation.Frequency;

    pgdi->ulDACRed          = VideoModeInformation.NumberRedBits;
    pgdi->ulDACGreen        = VideoModeInformation.NumberGreenBits;
    pgdi->ulDACBlue         = VideoModeInformation.NumberBlueBits;

    pgdi->ulLogPixelsX      = pdm->dmLogPixels;
    pgdi->ulLogPixelsY      = pdm->dmLogPixels;

    // Fill in the devinfo structure with the default 8bpp values:

    *pdi = gdevinfoDefault;

    // Several MIPS machines are broken in that 64 bit accesses to the
    // framebuffer don't work.

#ifdef GCAPS_NO64BITMEMACCESS
    if (VideoModeInformation.AttributeFlags & VIDEO_MODE_NO_64_BIT_ACCESS)
    {
        DISPDBG((2, "Disable 64 bit access on this device !\n"));
        pdi->flGraphicsCaps |= GCAPS_NO64BITMEMACCESS;
    }
#endif

    if (VideoModeInformation.BitsPerPlane == 8)
    {
        ppdev->cBpp            = 1;
        ppdev->cBitsPerPixel   = 8;
        ppdev->iBitmapFormat   = BMF_8BPP;
        ppdev->jModeColor      = 0;
        ppdev->ulWhite         = 0xff;
    }
    else if ((VideoModeInformation.BitsPerPlane == 16) ||
         (VideoModeInformation.BitsPerPlane == 15))
    {
        ppdev->cBpp            = 2;
        ppdev->cBitsPerPixel   = 16;
        ppdev->iBitmapFormat   = BMF_16BPP;
        ppdev->jModeColor      = SET_16BPP_COLOR;
        ppdev->ulWhite         = 0xffff;
        ppdev->flRed           = VideoModeInformation.RedMask;
        ppdev->flGreen         = VideoModeInformation.GreenMask;
        ppdev->flBlue          = VideoModeInformation.BlueMask;

        pgdi->ulNumColors      = (ULONG) -1;
        pgdi->ulNumPalReg      = 0;
        pgdi->ulHTOutputFormat = HT_FORMAT_16BPP;

        pdi->iDitherFormat     = BMF_16BPP;
        pdi->flGraphicsCaps   &= ~(GCAPS_PALMANAGED | GCAPS_COLOR_DITHER);
    }
    else if (VideoModeInformation.BitsPerPlane == 24)
    {

        ppdev->cBpp            = 3;
        ppdev->cBitsPerPixel   = 24;
        ppdev->iBitmapFormat   = BMF_24BPP;
        ppdev->jModeColor      = SET_24BPP_COLOR;
        ppdev->ulWhite         = 0xffffff;
        ppdev->flRed           = VideoModeInformation.RedMask;
        ppdev->flGreen         = VideoModeInformation.GreenMask;
        ppdev->flBlue          = VideoModeInformation.BlueMask;

        pgdi->ulNumColors      = (ULONG) -1;
        pgdi->ulNumPalReg      = 0;
        pgdi->ulHTOutputFormat = HT_FORMAT_24BPP;

        pdi->iDitherFormat     = BMF_24BPP;
        pdi->flGraphicsCaps   &= ~(GCAPS_PALMANAGED | GCAPS_COLOR_DITHER);
    }
    else
    {
        ASSERTDD(VideoModeInformation.BitsPerPlane == 32,
             "This driver supports only 8, 16, 24 and 32bpp");

        ppdev->cBpp            = 4;
        ppdev->cBitsPerPixel   = 32;
        ppdev->iBitmapFormat   = BMF_32BPP;
        ppdev->jModeColor      = SET_32BPP_COLOR;
        ppdev->ulWhite         = 0xffffffff;
        ppdev->flRed           = VideoModeInformation.RedMask;
        ppdev->flGreen         = VideoModeInformation.GreenMask;
        ppdev->flBlue          = VideoModeInformation.BlueMask;

        pgdi->ulNumColors      = (ULONG) -1;
        pgdi->ulNumPalReg      = 0;
        pgdi->ulHTOutputFormat = HT_FORMAT_32BPP;

        pdi->iDitherFormat     = BMF_32BPP;
        pdi->flGraphicsCaps   &= ~(GCAPS_PALMANAGED | GCAPS_COLOR_DITHER);
    }

    DISPDBG((5, "Passed bInitializeModeFields"));
    return(TRUE);

ReturnFalse:

    DISPDBG((0, "Failed bInitializeModeFields"));
    return(FALSE);
}

/******************************Public*Routine******************************\
* DWORD getAvailableModes
*
* Calls the miniport to get the list of modes supported by the kernel driver,
* and returns the list of modes supported by the diplay driver among those
*
* returns the number of entries in the videomode buffer.
* 0 means no modes are supported by the miniport or that an error occured.
*
* NOTE: the buffer must be freed up by the caller.
*
\**************************************************************************/

DWORD getAvailableModes(
HANDLE                   hDriver,
PVIDEO_MODE_INFORMATION* modeInformation,
DWORD*                   cbModeSize)
{
    ULONG                   ulTemp;
    VIDEO_NUM_MODES         modes;
    PVIDEO_MODE_INFORMATION pVideoTemp;

    //
    // Get the number of modes supported by the mini-port
    //

    if (!IOCONTROL(hDriver,
                   IOCTL_VIDEO_QUERY_NUM_AVAIL_MODES,
                   NULL,
                   0,
                   &modes,
                   sizeof(VIDEO_NUM_MODES),
                   &ulTemp))
    {
        DISPDBG((0, "getAvailableModes - Failed VIDEO_QUERY_NUM_AVAIL_MODES"));
        return(0);
    }

    *cbModeSize = modes.ModeInformationLength;

    //
    // Allocate the buffer for the mini-port to write the modes in.
    //

    *modeInformation = (PVIDEO_MODE_INFORMATION)
                       ALLOC(modes.NumModes * modes.ModeInformationLength);

    if (*modeInformation == (PVIDEO_MODE_INFORMATION) NULL)
    {
        DISPDBG((0, "getAvailableModes - Failed EngAllocMem"));
        return 0;
    }

    //
    // Ask the mini-port to fill in the available modes.
    //

    if (!IOCONTROL(hDriver,
                   IOCTL_VIDEO_QUERY_AVAIL_MODES,
                   NULL,
                   0,
                   *modeInformation,
                   modes.NumModes * modes.ModeInformationLength,
                   &ulTemp))
    {

        DISPDBG((0, "getAvailableModes - Failed VIDEO_QUERY_AVAIL_MODES"));

        FREE(*modeInformation);
        *modeInformation = (PVIDEO_MODE_INFORMATION) NULL;

        return(0);
    }

    //
    // Now see which of these modes are supported by the display driver.
    // As an internal mechanism, set the length to 0 for the modes we
    // DO NOT support.
    //

    ulTemp = modes.NumModes;
    pVideoTemp = *modeInformation;

    //
    // Mode is rejected if it is not one plane, or not graphics, or is not
    // one of 8, 15, 16, 24 or 32 bits per pel.
    //

    while (ulTemp--)
    {
        if ((pVideoTemp->NumberOfPlanes != 1 ) ||
            !(pVideoTemp->AttributeFlags & VIDEO_MODE_GRAPHICS) ||
//ms923 added
            !(pVideoTemp->DriverSpecificAttributeFlags & CAPS_BLT_SUPPORT)||
            ((pVideoTemp->BitsPerPlane != 8) &&
             (pVideoTemp->BitsPerPlane != 15) &&
             (pVideoTemp->BitsPerPlane != 16) &&
             (pVideoTemp->BitsPerPlane != 24) &&
             (pVideoTemp->BitsPerPlane != 32)))
        {
            DISPDBG((2, "Rejecting miniport mode:"));
            pVideoTemp->Length = 0;
        }
        else
        {
            DISPDBG((2, "Accepting miniport mode:"));
        }

        pVideoTemp = (PVIDEO_MODE_INFORMATION)
            (((PUCHAR)pVideoTemp) + modes.ModeInformationLength);
    }

    return(modes.NumModes);
}


//crus begin
//myf1, begin
#ifdef PANNING_SCROLL
VOID
CirrusLaptopViewPoint(
PDEV* ppdev,
PVIDEO_MODE_INFORMATION  pVideoModeInfo)
{
    UCHAR   ChipID;
    UCHAR   savSEQidx, Panel_Type, LCD;

    // Panning Scrolling Supported for TI

//myf16    savSEQidx = CP_IN_BYTE(ppdev->pjPorts, SR_INDEX);
//myf16    CP_OUT_BYTE(ppdev->pjPorts, SR_INDEX, 0x09);
//myf16    Panel_Type = (CP_IN_BYTE(ppdev->pjPorts, SR_DATA) & 0x70) >> 4;
//myf16    CP_OUT_BYTE(ppdev->pjPorts, SR_INDEX, savSEQidx);

    savSEQidx = CP_IN_BYTE(ppdev->pjPorts, CRTC_INDEX);
    CP_OUT_BYTE(ppdev->pjPorts, CRTC_INDEX, 0x27);
    ChipID = (CP_IN_BYTE(ppdev->pjPorts, CRTC_DATA) & 0xFC) >> 2;

    if ((ChipID == 0x0E) || (ChipID == 0x0B) || (ChipID == 0x0C))
                                                          //7548/7543/7541
    {
        CP_OUT_BYTE(ppdev->pjPorts, CRTC_INDEX, 0x20);
        LCD = CP_IN_BYTE(ppdev->pjPorts, CRTC_DATA) & 0x20;
    }
    else if ((ChipID == 0x10) || (ChipID == 0x13))      //myf17
    {
        CP_OUT_BYTE(ppdev->pjPorts, CRTC_INDEX, 0x80);
        LCD = CP_IN_BYTE(ppdev->pjPorts, CRTC_DATA) & 0x01;
    }
    CP_OUT_BYTE(ppdev->pjPorts, CRTC_INDEX, savSEQidx);

    if ((ChipID == 0x0E) || (ChipID == 0x0B) || (ChipID == 0x0C) ||
        (ChipID == 0x10) || (ChipID == 0x13))       //myf17
    {
        if ((LCD) &&                    //myf33
            !(pVideoModeInfo->DriverSpecificAttributeFlags & CAPS_TV_ON) &&
            (pVideoModeInfo->DriverSpecificAttributeFlags & CAPS_SVGA_PANEL))
        {
            ppdev->Hres = 800;
            ppdev->Vres = 600;
        }
        else if ((LCD) &&               //myf33
            !(pVideoModeInfo->DriverSpecificAttributeFlags & CAPS_TV_ON) &&
             (pVideoModeInfo->DriverSpecificAttributeFlags & CAPS_VGA_PANEL))
        {
            ppdev->Hres = 640;
            ppdev->Vres = 480;
        }
        else if ((LCD) &&               //myf33
            !(pVideoModeInfo->DriverSpecificAttributeFlags & CAPS_TV_ON) &&
             (pVideoModeInfo->DriverSpecificAttributeFlags & CAPS_XGA_PANEL))
        {
            ppdev->Hres = 1024;
            ppdev->Vres = 768;
        }
        else
        {
           ppdev->Hres = pVideoModeInfo->VisScreenWidth;
           ppdev->Vres = pVideoModeInfo->VisScreenHeight;
        }

        ppdev->min_Xscreen = 0;
        ppdev->max_Xscreen = ppdev->Hres - 1;
        ppdev->min_Yscreen = 0;
        ppdev->max_Yscreen = ppdev->Vres - 1;
        DISPDBG((2,"INIT- PANNING SCROLLING : %x\t:%x, %x, \n  %x, %x, %x, %x\n",
            ppdev->ulMode,ppdev->Hres, ppdev->Vres, ppdev->min_Xscreen, ppdev->max_Xscreen,
                 ppdev->min_Yscreen, ppdev->max_Yscreen));
     }
     ppdev->flCaps = pVideoModeInfo->DriverSpecificAttributeFlags; //myf33
}
#endif
//myf1, end
//crus end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\cirrus\disp\dispint.h ===
/**********************************************************
* Copyright Cirrus Logic, 1995. All rights reserved.
***********************************************************
*       File Name:  DISPINT.H
*
*       Module Abstract:
*       ----------------
*       Defines the interface for communicating between the display
*       driver and the Direct Draw driver.
*
***********************************************************
*       Author: Scott MacDonald
*       Date:   03/07/95
*
*       Revision History:
*       -----------------
*  WHO      WHEN     WHAT/WHY/HOW
*  ---      ----     ------------
*
* #mgm1   12/06/95   uncomment CHIPAUTOSTART.  This should now
*                    work when MapSL() works in DriverInit().
* #mgm2   01/02/96   Add 7548 chip ID.
*
***********************************************************/


/*
 * Flags for the StopAsync callback
 */
#define ASYNC_BLT            0x0001       // Async surface halted due to BLT

/*
 * Flags for the DISPDRVINFO structure
 */
#define DI_LCD               0x0001       // LCD panel is in use
#define DI_SOFTCURSOR        0x0002       // Software cursor is in use

/*
 * Display information passed to the Direct Draw driver from the display
 * driver using either SetInfo or GetInfo.
 */
typedef struct
{
    DWORD dwSize;
    DWORD dwResolutionX;
    DWORD dwResolutionY;
    DWORD dwBitCount;
    DWORD dwPitch;
    DWORD dwFlags;
    DWORD dwMemMapSel;
} DISPDRVINFO, FAR * LPDISPDRVINFO;

/*
 * prototypes for communication functions
 */
typedef void (WINAPI *LPGetInfo)  (LPDISPDRVINFO);


/*
 * Structure passed to the Direct Draw driver from the display driver.
 * This contains entry points that we can call for various services.
 */
typedef struct
{
    DWORD           dwSize;
#if 0
    LPMemMgrAlloc   lpfnMemMgrAlloc;
    LPMemMgrPreempt lpfnMemMgrPreempt;
    LPMemMgrLock    lpfnMemMgrLock;
    LPMemMgrUnlock  lpfnMemMgrUnlock;
    LPMemMgrFree    lpfnMemMgrFree;
    LPMemMgrQuery   lpfnMemMgrQueryFreeMem;
#endif
    FARPROC         lpfnExcludeCursor;
    FARPROC         lpfnUnexcludeCursor;
    LPGetInfo       lpfnGetInfo;
    FARPROC         lpfnEnableAsyncCallback;
} DISPDRVCALL, FAR * LPDISPDRVCALL;


/*
 * Structure passed to the display driver from the Direct Draw driver.
 * This allows the display driver to notify us changes, etc.
 */
typedef struct
{
    DWORD dwSize;
    FARPROC lpfnSetInfo;
    FARPROC lpfnStopAsync;
} DCICALL, FAR * LPDCICALL;

// Note if definition changes, cirrus.inc and 5440over.c needs
// to be changed also.
#define CHIP5420 0x0001
#define CHIP5422 0x0002
#define CHIP5424 0x0004
#define CHIP5425 0x0008

#define CHIP5426 0x0010
#define CHIP5428 0x0020
#define CHIP5429 0x0040
#define CHIP542x (CHIP5420 | CHIP5422 | CHIP5424 | CHIP5425 | CHIP5426 |\
                  CHIP5428 | CHIP5429)

#define CHIP5430 0x0100
#define CHIP5434 0x0200
#define CHIP5436 0x0400
#define CHIP5446 0x0800
#define CHIP543x (CHIP5430 | CHIP5434 | CHIP5436 | CHIP5446)

#define CHIP5440 0x1000
#define CHIPM40  0x10000
#define CHIP544x (CHIP5440 | CHIP5446 | CHIPM40)

#define CHIP7541 0x2000
#define CHIP7543 0x4000
#define CHIP7548 0x8000										//#mgm2
#define CHIP754x (CHIP7541 | CHIP7543 | CHIP7548)	//#mgm2

#define CHIPBLTER (CHIP5426 | CHIP5428 | CHIP5429 | CHIP543x | CHIP544x |\
		   CHIP754x)

#define CHIPCOLORKEYBLTER   (CHIP5426 | CHIP5428 | CHIP5436 | CHIP5446 |\
                            CHIP754x | CHIPM40)

#define CHIPCURRENTVLINE    (CHIP5436 | CHIP5446 | CHIPM40)

#define CHIPAUTOSTART  (CHIP5436 | CHIP5446)        //#mgm1
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\cirrus\disp\fastfill.c ===
/******************************************************************************\
*
* $Workfile:   fastfill.c  $
*
* Fast routine for drawing polygons that aren't complex in shape.
*
* Copyright (c) 1993-1997 Microsoft Corporation
* Copyright (c) 1996-1997 Cirrus Logic, Inc.,
*
* $Log:   S:/projects/drivers/ntsrc/display/fastfill.c_v  $
 * 
 *    Rev 1.5   28 Jan 1997 13:46:30   PLCHU
 *  
 * 
 *    Rev 1.3   10 Jan 1997 15:39:44   PLCHU
 *  
 * 
 *    Rev 1.2   Nov 07 1996 16:48:02   unknown
 *  
 * 
 *    Rev 1.1   Oct 10 1996 15:37:30   unknown
 *  
* 
*    Rev 1.1   12 Aug 1996 16:53:14   frido
*        Removed unaccessed local variables.
*
*    chu01  : 01-02-97  5480 BitBLT enhancement
*
\******************************************************************************/

#include "precomp.h"

#define RIGHT 0
#define LEFT  1

typedef struct _TRAPEZOIDDATA TRAPEZOIDDATA;    // Handy forward declaration

typedef VOID (FNTRAPEZOID)(TRAPEZOIDDATA*, LONG, LONG);
                                                // Prototype for trapezoid
                                                //   drawing routines

typedef struct _EDGEDATA {
LONG      x;                // Current x position
LONG      dx;               // # pixels to advance x on each scan
LONG      lError;           // Current DDA error
LONG      lErrorUp;         // DDA error increment on each scan
LONG      dN;               // Signed delta-y in fixed point form (also known
                            //   as the DDA error adjustment, and used to be
                            //   called 'lErrorDown')
LONG      dM;               // Signed delta-x in fixed point form
POINTFIX* pptfx;            // Points to start of current edge
LONG      dptfx;            // Delta (in bytes) from pptfx to next point
LONG      cy;               // Number of scans to go for this edge
LONG      bNew;             // Set to TRUE when a new DDA must be started
                            //   for the edge.
} EDGEDATA;                         /* ed, ped */

typedef struct _TRAPEZOIDDATA {
FNTRAPEZOID*    pfnTrap;    // Pointer to appropriate trapezoid drawing routine,
                            //   or trapezoid clip routine
FNTRAPEZOID*    pfnTrapClip;// Pointer to appropriate trapezoid drawing routine
                            //   if doing clipping
PDEV*           ppdev;      // Pointer to PDEV
EDGEDATA        aed[2];     // DDA information for both edges
POINTL          ptlBrush;   // Brush alignment
LONG            yClipTop;   // Top of clip rectangle
LONG            yClipBottom;// Bottom of clip rectangle
LONG            xClipLeft;  // Left edge of clip rectangle
LONG            xClipRight; // Right edge of clip rectangle
BOOL            bClip;      // Are we clipping?
} TRAPEZOIDDATA;                    /* td, ptd */

/******************************Public*Routine******************************\
* VOID vClipTrapezoid
*
* Clips a trapezoid.
*
* NOTE: This routine assumes that the polygon's dimensions are small
*       enough that its QUOTIENT_REMAINDER calculations won't overflow.
*       This means that large polygons must never make it here.
*
\**************************************************************************/

VOID vClipTrapezoid(
TRAPEZOIDDATA*  ptd,
LONG            yTrapTop,
LONG            cyTrapezoid)
{
    LONG    yTrapBottom;
    LONG    dN;
    LONG    lNum;
    LONG    xDelta;
    LONG    lError;

    DISPDBG((2, "vClipTrapezoid"));

    yTrapBottom = yTrapTop + cyTrapezoid;

    if (yTrapTop < ptd->yClipTop)
    {
        if ((ptd->aed[LEFT].bNew) &&
            (yTrapBottom + ptd->aed[LEFT].cy > ptd->yClipTop))
        {
            dN   = ptd->aed[LEFT].dN;
            lNum = ptd->aed[LEFT].dM * (ptd->yClipTop - yTrapTop)
                 + (ptd->aed[LEFT].lError + dN);

            if (lNum >= 0)
            {
                QUOTIENT_REMAINDER(lNum, dN, xDelta, lError);
            }
            else
            {
                lNum = -lNum;

                QUOTIENT_REMAINDER(lNum, dN, xDelta, lError);

                xDelta = -xDelta;
                if (lError != 0)
                {
                    xDelta--;
                    lError = dN - lError;
                }
            }

            ptd->aed[LEFT].x     += xDelta;
            ptd->aed[LEFT].lError = lError - dN;
        }

        if ((ptd->aed[RIGHT].bNew) &&
            (yTrapBottom + ptd->aed[RIGHT].cy > ptd->yClipTop))
        {
            dN   = ptd->aed[RIGHT].dN;
            lNum = ptd->aed[RIGHT].dM * (ptd->yClipTop - yTrapTop)
                 + (ptd->aed[RIGHT].lError + dN);

            if (lNum >= 0)
            {
                QUOTIENT_REMAINDER(lNum, dN, xDelta, lError);
            }
            else
            {
                lNum = -lNum;

                QUOTIENT_REMAINDER(lNum, dN, xDelta, lError);

                xDelta = -xDelta;
                if (lError != 0)
                {
                    xDelta--;
                    lError = dN - lError;
                }
            }

            ptd->aed[RIGHT].x     += xDelta;
            ptd->aed[RIGHT].lError = lError - dN;
        }
    }

    // If this trapezoid vertically intersects our clip rectangle, draw it:

    if ((yTrapBottom > ptd->yClipTop) &&
        (yTrapTop    < ptd->yClipBottom))
    {
        if (yTrapTop <= ptd->yClipTop)
        {
            yTrapTop = ptd->yClipTop;

            // Have to let trapezoid drawer know that it has to load
            // its DDAs for very first trapezoid drawn:

            ptd->aed[RIGHT].bNew = TRUE;
            ptd->aed[LEFT].bNew  = TRUE;
        }

        if (yTrapBottom >= ptd->yClipBottom)
        {
            yTrapBottom = ptd->yClipBottom;
        }

        ptd->pfnTrapClip(ptd, yTrapTop, yTrapBottom - yTrapTop);
    }
}

/******************************Public*Routine******************************\
* VOID vIoSolidTrapezoid
*
* Draws a solid trapezoid using a software DDA.
*
\**************************************************************************/

VOID vIoSolidTrapezoid(
TRAPEZOIDDATA*  ptd,
LONG            yTrapezoid,
LONG            cyTrapezoid)
{
    PDEV*       ppdev;
    LONG        xOffset;
    LONG        lLeftError;
    LONG        xLeft;
    LONG        lRightError;
    LONG        xRight;
    LONG        lTmp;
    EDGEDATA    edTmp;
    BYTE*       pjPorts;
    LONG        lDelta;

    DISPDBG((2, "vIoSolidTrapezoid"));

    ppdev   = ptd->ppdev;
    pjPorts = ppdev->pjPorts;
    lDelta  = ppdev->lDelta;

    xOffset     = ppdev->xOffset;
    yTrapezoid += ppdev->yOffset;
    yTrapezoid *= lDelta;

    // If the left and right edges are vertical, simply output as
    // a rectangle:

    if (((ptd->aed[LEFT].lErrorUp | ptd->aed[RIGHT].lErrorUp) == 0) &&
        ((ptd->aed[LEFT].dx       | ptd->aed[RIGHT].dx) == 0))
    {
        /////////////////////////////////////////////////////////////////
        // Vertical-edge special case

        xLeft  = ptd->aed[LEFT].x + xOffset;
        xRight = ptd->aed[RIGHT].x + xOffset;

        if (xLeft > xRight)
        {
            SWAP(xLeft,          xRight,          lTmp);
            SWAP(ptd->aed[LEFT], ptd->aed[RIGHT], edTmp);
        }

        if (ptd->bClip)
        {
            xLeft  = max(xLeft, ptd->xClipLeft + xOffset);
            xRight = min(xRight, ptd->xClipRight + xOffset);
        }

        if (xLeft < xRight)
        {
            CP_IO_WAIT_FOR_BLT_COMPLETE(ppdev, pjPorts);

            CP_IO_XCNT(ppdev, pjPorts, (PELS_TO_BYTES(xRight - xLeft) - 1));
            CP_IO_YCNT(ppdev, pjPorts, (cyTrapezoid - 1));
            CP_IO_DST_ADDR_ABS(ppdev, pjPorts, (yTrapezoid + PELS_TO_BYTES(xLeft)));
            CP_IO_START_BLT(ppdev, pjPorts);
        }
    }
    else
    {
        lLeftError  = ptd->aed[LEFT].lError;
        xLeft       = ptd->aed[LEFT].x + xOffset;
        lRightError = ptd->aed[RIGHT].lError;
        xRight      = ptd->aed[RIGHT].x + xOffset;

        while (TRUE)
        {
            LONG    xLeftClipped;
            LONG    xRightClipped;

            if (ptd->bClip)
            {
                xLeftClipped    = max(xLeft, ptd->xClipLeft + xOffset);
                xRightClipped   = min(xRight, ptd->xClipRight + xOffset);
            }
            else
            {
                xLeftClipped = xLeft;
                xRightClipped = xRight;
            }

            /////////////////////////////////////////////////////////////////
            // Run the DDAs

            if (xLeftClipped < xRightClipped)
            {
                CP_IO_WAIT_FOR_BLT_COMPLETE(ppdev, pjPorts);

                CP_IO_XCNT(ppdev, pjPorts, (PELS_TO_BYTES(xRightClipped - xLeftClipped) - 1));
                CP_IO_YCNT(ppdev, pjPorts, 0);
                CP_IO_DST_ADDR_ABS(ppdev, pjPorts, (yTrapezoid + PELS_TO_BYTES(xLeftClipped)));
                CP_IO_START_BLT(ppdev, pjPorts);
            }
            else if (xLeft > xRight)
            {
                // We don't bother optimizing this case because we should
                // rarely get self-intersecting polygons (if we're slow,
                // the app gets what it deserves).

                SWAP(xLeft,          xRight,          lTmp);
                SWAP(lLeftError,     lRightError,     lTmp);
                SWAP(ptd->aed[LEFT], ptd->aed[RIGHT], edTmp);
                continue;
            }

            // Advance the right wall:

            xRight      += ptd->aed[RIGHT].dx;
            lRightError += ptd->aed[RIGHT].lErrorUp;

            if (lRightError >= 0)
            {
                lRightError -= ptd->aed[RIGHT].dN;
                xRight++;
            }

            // Advance the left wall:

            xLeft      += ptd->aed[LEFT].dx;
            lLeftError += ptd->aed[LEFT].lErrorUp;

            if (lLeftError >= 0)
            {
                lLeftError -= ptd->aed[LEFT].dN;
                xLeft++;
            }

            cyTrapezoid--;
            if (cyTrapezoid == 0)
                break;
            yTrapezoid += lDelta;
        }

        ptd->aed[LEFT].lError  = lLeftError;
        ptd->aed[LEFT].x       = xLeft - xOffset;
        ptd->aed[RIGHT].lError = lRightError;
        ptd->aed[RIGHT].x      = xRight - xOffset;
    }
}

/******************************Public*Routine******************************\
* VOID vIoTrapezoidSetup
*
* Initialize the hardware and some state for doing trapezoids.
*
\**************************************************************************/

VOID vIoTrapezoidSetup(
PDEV*          ppdev,
ULONG          rop4,
ULONG          ulSolidColor,
RBRUSH*        prb,
POINTL*        pptlBrush,
TRAPEZOIDDATA* ptd,
RECTL*         prclClip)    // NULL if no clipping
{
    BYTE* pjPorts = ppdev->pjPorts;
    LONG  cBpp    = ppdev->cBpp;
    LONG  lDelta  = ppdev->lDelta;
    BYTE  jHwRop;

    DISPDBG((2, "vIoTrapezoidSetup"));

    ptd->ppdev = ppdev;

    jHwRop = gajHwMixFromRop2[(rop4 >> 2) & 0xf];

    /////////////////////////////////////////////////////////////////
    // Setup the hardware for solid colours

    ptd->pfnTrap = vIoSolidTrapezoid;

    // We initialize the hardware for the color, rop, start address,
    // and blt mode

    if (cBpp == 1)
    {
        ulSolidColor |= ulSolidColor << 8;
        ulSolidColor |= ulSolidColor << 16;
    }
    else if (cBpp == 2)
    {
        ulSolidColor |= ulSolidColor << 16;
    }

    CP_IO_WAIT_FOR_BLT_COMPLETE(ppdev, pjPorts);

    CP_IO_ROP(ppdev, pjPorts, jHwRop);
    CP_IO_SRC_ADDR(ppdev, pjPorts, ppdev->ulSolidColorOffset);
    CP_IO_DST_Y_OFFSET(ppdev, pjPorts, lDelta);
    CP_IO_BLT_MODE(ppdev, pjPorts, ENABLE_COLOR_EXPAND |
                                   ENABLE_8x8_PATTERN_COPY |
                                   ppdev->jModeColor);
    CP_IO_FG_COLOR(ppdev, pjPorts, ulSolidColor);

    if (prclClip != NULL)
    {
        ptd->pfnTrapClip = ptd->pfnTrap;
        ptd->pfnTrap     = vClipTrapezoid;
        ptd->yClipTop    = prclClip->top;
        ptd->yClipBottom = prclClip->bottom;
        ptd->xClipLeft   = prclClip->left;
        ptd->xClipRight  = prclClip->right;
        ptd->bClip       = TRUE;
    }
    else
    {
        ptd->bClip       = FALSE;
    }
}

/******************************Public*Routine******************************\
* VOID vMmSolidTrapezoid
*
* Draws a solid trapezoid using a software DDA.
*
\**************************************************************************/

VOID vMmSolidTrapezoid(
TRAPEZOIDDATA* ptd,
LONG           yTrapezoid,
LONG           cyTrapezoid)
{
    PDEV*    ppdev;
    LONG     xOffset;
    LONG     lLeftError;
    LONG     xLeft;
    LONG     lRightError;
    LONG     xRight;
    LONG     lTmp;
    EDGEDATA edTmp;
    BYTE*    pjBase;
    LONG     lDelta;

    DISPDBG((2, "vMmSolidTrapezoid"));

    ppdev   = ptd->ppdev;
    pjBase  = ppdev->pjBase;
    lDelta  = ppdev->lDelta;

    xOffset     = ppdev->xOffset;
    yTrapezoid += ppdev->yOffset;
    yTrapezoid *= lDelta;

    // If the left and right edges are vertical, simply output as
    // a rectangle:

    if (((ptd->aed[LEFT].lErrorUp | ptd->aed[RIGHT].lErrorUp) == 0) &&
        ((ptd->aed[LEFT].dx       | ptd->aed[RIGHT].dx) == 0))
    {
        /////////////////////////////////////////////////////////////////
        // Vertical-edge special case

        xLeft  = ptd->aed[LEFT].x + xOffset;
        xRight = ptd->aed[RIGHT].x + xOffset;

        if (xLeft > xRight)
        {
            SWAP(xLeft,          xRight,          lTmp);
            SWAP(ptd->aed[LEFT], ptd->aed[RIGHT], edTmp);
        }

        if (ptd->bClip)
        {
            xLeft  = max(xLeft, ptd->xClipLeft + xOffset);
            xRight = min(xRight, ptd->xClipRight + xOffset);
        }

        if (xLeft < xRight)
        {
            CP_MM_WAIT_FOR_BLT_COMPLETE(ppdev, pjBase);

            CP_MM_XCNT(ppdev, pjBase, (PELS_TO_BYTES(xRight - xLeft) - 1));
            CP_MM_YCNT(ppdev, pjBase, (cyTrapezoid - 1));
            CP_MM_DST_ADDR_ABS(ppdev, pjBase, (yTrapezoid + PELS_TO_BYTES(xLeft)));
            CP_MM_START_BLT(ppdev, pjBase);
        }
    }
    else
    {
        lLeftError  = ptd->aed[LEFT].lError;
        xLeft       = ptd->aed[LEFT].x + xOffset;
        lRightError = ptd->aed[RIGHT].lError;
        xRight      = ptd->aed[RIGHT].x + xOffset;

        CP_MM_WAIT_FOR_BLT_COMPLETE(ppdev, pjBase);
        CP_MM_YCNT(ppdev, pjBase, 0);

        while (TRUE)
        {
            LONG    xLeftClipped;
            LONG    xRightClipped;

            if (ptd->bClip)
            {
                xLeftClipped    = max(xLeft, ptd->xClipLeft + xOffset);
                xRightClipped   = min(xRight, ptd->xClipRight + xOffset);
            }
            else
            {
                xLeftClipped = xLeft;
                xRightClipped = xRight;
            }

            /////////////////////////////////////////////////////////////////
            // Run the DDAs

            if (xLeftClipped < xRightClipped)
            {
                CP_MM_WAIT_FOR_BLT_COMPLETE(ppdev, pjBase);

                CP_MM_XCNT(ppdev, pjBase, (PELS_TO_BYTES(xRightClipped - xLeftClipped) - 1));
                //CP_MM_YCNT(ppdev, pjBase, 0);
                CP_MM_DST_ADDR_ABS(ppdev, pjBase, (yTrapezoid + PELS_TO_BYTES(xLeftClipped)));
                CP_MM_START_BLT(ppdev, pjBase);
            }
            else if (xLeft > xRight)
            {
                // We don't bother optimizing this case because we should
                // rarely get self-intersecting polygons (if we're slow,
                // the app gets what it deserves).

                SWAP(xLeft,          xRight,          lTmp);
                SWAP(lLeftError,     lRightError,     lTmp);
                SWAP(ptd->aed[LEFT], ptd->aed[RIGHT], edTmp);
                continue;
            }

            // Advance the right wall:

            xRight      += ptd->aed[RIGHT].dx;
            lRightError += ptd->aed[RIGHT].lErrorUp;

            if (lRightError >= 0)
            {
                lRightError -= ptd->aed[RIGHT].dN;
                xRight++;
            }

            // Advance the left wall:

            xLeft      += ptd->aed[LEFT].dx;
            lLeftError += ptd->aed[LEFT].lErrorUp;

            if (lLeftError >= 0)
            {
                lLeftError -= ptd->aed[LEFT].dN;
                xLeft++;
            }

            cyTrapezoid--;
            if (cyTrapezoid == 0)
                break;
            yTrapezoid += lDelta;
        }

        ptd->aed[LEFT].lError  = lLeftError;
        ptd->aed[LEFT].x       = xLeft - xOffset;
        ptd->aed[RIGHT].lError = lRightError;
        ptd->aed[RIGHT].x      = xRight - xOffset;
    }
}

/******************************Public*Routine******************************\
* VOID vMmTrapezoidSetup
*
* Initialize the hardware and some state for doing trapezoids.
*
\**************************************************************************/

VOID vMmTrapezoidSetup(
PDEV*           ppdev,
ULONG           rop4,
ULONG           ulSolidColor,
RBRUSH*         prb,
POINTL*         pptlBrush,
TRAPEZOIDDATA*  ptd,
RECTL*          prclClip)       // NULL if no clipping
{
    BYTE*       pjBase  = ppdev->pjBase;
    LONG        cBpp = ppdev->cBpp;
    LONG        lDelta = ppdev->lDelta;
    BYTE        jHwRop;

    DISPDBG((2, "vMmTrapezoidSetup"));

    ptd->ppdev = ppdev;

    jHwRop = gajHwMixFromRop2[(rop4 >> 2) & 0xf];

    /////////////////////////////////////////////////////////////////
    // Setup the hardware for solid colours

    ptd->pfnTrap = vMmSolidTrapezoid;

    // We initialize the hardware for the color, rop, start address,
    // and blt mode

    if (cBpp == 1)
    {
        ulSolidColor |= ulSolidColor << 8;
        ulSolidColor |= ulSolidColor << 16;
    }
    else if (cBpp == 2)
    {
        ulSolidColor |= ulSolidColor << 16;
    }

    CP_MM_WAIT_FOR_BLT_COMPLETE(ppdev, pjBase);

    CP_MM_ROP(ppdev, pjBase, jHwRop);
    CP_MM_SRC_ADDR(ppdev, pjBase, ppdev->ulSolidColorOffset);
    CP_MM_DST_Y_OFFSET(ppdev, pjBase, lDelta);
    CP_MM_BLT_MODE(ppdev, pjBase, ENABLE_COLOR_EXPAND |
                                   ENABLE_8x8_PATTERN_COPY |
                                   ppdev->jModeColor);
    CP_MM_FG_COLOR(ppdev, pjBase, ulSolidColor);

    if (prclClip != NULL)
    {
        ptd->pfnTrapClip = ptd->pfnTrap;
        ptd->pfnTrap     = vClipTrapezoid;
        ptd->yClipTop    = prclClip->top;
        ptd->yClipBottom = prclClip->bottom;
        ptd->xClipLeft   = prclClip->left;
        ptd->xClipRight  = prclClip->right;
        ptd->bClip       = TRUE;
    }
    else
    {
        ptd->bClip       = FALSE;
    }
}

// chu01 
/******************************Public*Routine******************************\
*
*     B i t B L T   E n h a n c e m e n t   F o r   C L - G D 5 4 8 0
*
\**************************************************************************/

/******************************Public*Routine******************************\
* VOID vMmSolidTrapezoid80
*
* Draws a solid trapezoid using a software DDA. This is for CL-GD5480 with 
* enhanced BitBLT features.  
*
\**************************************************************************/

VOID vMmSolidTrapezoid80(
TRAPEZOIDDATA* ptd,
LONG           yTrapezoid,
LONG           cyTrapezoid)
{
    PDEV*    ppdev;
    LONG     xOffset;
    LONG     lLeftError;
    LONG     xLeft;
    LONG     lRightError;
    LONG     xRight;
    LONG     lTmp;
    EDGEDATA edTmp;
    BYTE*    pjBase;
    LONG     lDelta;

    DISPDBG((2, "vMmSolidTrapezoid80")) ;

    ppdev       = ptd->ppdev     ;
    pjBase      = ppdev->pjBase  ;
    lDelta      = ppdev->lDelta  ;

    xOffset     = ppdev->xOffset ;
    yTrapezoid += ppdev->yOffset ;

    // If the left and right edges are vertical, simply output as
    // a rectangle:

    if (((ptd->aed[LEFT].lErrorUp | ptd->aed[RIGHT].lErrorUp) == 0) &&
        ((ptd->aed[LEFT].dx       | ptd->aed[RIGHT].dx) == 0))
    {
        /////////////////////////////////////////////////////////////////
        // Vertical-edge special case

        xLeft  = ptd->aed[LEFT].x + xOffset;
        xRight = ptd->aed[RIGHT].x + xOffset;

        if (xLeft > xRight)
        {
            SWAP(xLeft,          xRight,          lTmp);
            SWAP(ptd->aed[LEFT], ptd->aed[RIGHT], edTmp);
        }

        if (ptd->bClip)
        {
            xLeft  = max(xLeft, ptd->xClipLeft + xOffset);
            xRight = min(xRight, ptd->xClipRight + xOffset);
        }

        if (xLeft < xRight)
        {
            CP_MM_WAIT_FOR_BLT_COMPLETE(ppdev, pjBase) ;
            CP_MM_XCNT(ppdev, pjBase, (xRight - xLeft) - 1) ;
            CP_MM_YCNT(ppdev, pjBase, (cyTrapezoid - 1)) ;
            CP_MM_DST_ADDR_ABS(ppdev, pjBase, 0);
            CP_MM_DST_Y(ppdev, pjBase, yTrapezoid) ;
            CP_MM_DST_X(ppdev, pjBase, xLeft) ;
        }
    }
    else
    {
        lLeftError  = ptd->aed[LEFT].lError;
        xLeft       = ptd->aed[LEFT].x + xOffset;
        lRightError = ptd->aed[RIGHT].lError;
        xRight      = ptd->aed[RIGHT].x + xOffset;

        CP_MM_WAIT_FOR_BLT_COMPLETE(ppdev, pjBase);
        CP_MM_YCNT(ppdev, pjBase, 0);

        while (TRUE)
        {
            LONG    xLeftClipped;
            LONG    xRightClipped;

            if (ptd->bClip)
            {
                xLeftClipped    = max(xLeft, ptd->xClipLeft + xOffset);
                xRightClipped   = min(xRight, ptd->xClipRight + xOffset);
            }
            else
            {
                xLeftClipped = xLeft;
                xRightClipped = xRight;
            }

            /////////////////////////////////////////////////////////////////
            // Run the DDAs

            if (xLeftClipped < xRightClipped)
            {
                CP_MM_WAIT_FOR_BLT_COMPLETE(ppdev, pjBase) ;
                CP_MM_XCNT(ppdev, pjBase, (xRightClipped - xLeftClipped) - 1) ;
                // CP_MM_YCNT(ppdev, pjBase, 0) ;
                CP_MM_DST_ADDR_ABS(ppdev, pjBase, 0) ;
                CP_MM_DST_Y(ppdev, pjBase, yTrapezoid) ;
                CP_MM_DST_X(ppdev, pjBase, xLeftClipped) ;
            }
            else if (xLeft > xRight)
            {
                // We don't bother optimizing this case because we should
                // rarely get self-intersecting polygons (if we're slow,
                // the app gets what it deserves).

                SWAP(xLeft,          xRight,          lTmp);
                SWAP(lLeftError,     lRightError,     lTmp);
                SWAP(ptd->aed[LEFT], ptd->aed[RIGHT], edTmp);
                continue;
            }

            // Advance the right wall:

            xRight      += ptd->aed[RIGHT].dx;
            lRightError += ptd->aed[RIGHT].lErrorUp;

            if (lRightError >= 0)
            {
                lRightError -= ptd->aed[RIGHT].dN;
                xRight++;
            }

            // Advance the left wall:

            xLeft      += ptd->aed[LEFT].dx;
            lLeftError += ptd->aed[LEFT].lErrorUp;

            if (lLeftError >= 0)
            {
                lLeftError -= ptd->aed[LEFT].dN;
                xLeft++;
            }

            cyTrapezoid--;
            if (cyTrapezoid == 0)
                break;
            yTrapezoid += 1 ;
        }

        ptd->aed[LEFT].lError  = lLeftError;
        ptd->aed[LEFT].x       = xLeft - xOffset;
        ptd->aed[RIGHT].lError = lRightError;
        ptd->aed[RIGHT].x      = xRight - xOffset;
    }

}

/******************************Public*Routine******************************\
* VOID vMmTrapezoidSetup80
*
* Initialize the hardware and some state for doing trapezoids. This is for 
* CL-GD5480 with enhanced BitBLT features.  
*
\**************************************************************************/

VOID vMmTrapezoidSetup80(
PDEV*           ppdev,
ULONG           rop4,
ULONG           ulSolidColor,
RBRUSH*         prb,
POINTL*         pptlBrush,
TRAPEZOIDDATA*  ptd,
RECTL*          prclClip)       // NULL if no clipping
{
    BYTE*       pjBase  = ppdev->pjBase ;
    LONG        cBpp    = ppdev->cBpp   ;
    LONG        lDelta  = ppdev->lDelta ;

    ULONG       jHwRop ;
    DWORD       jExtMode = 0 ; 

    DISPDBG((2, "vMmTrapezoidSetup80")) ;

    ptd->ppdev = ppdev ;

    jHwRop = gajHwPackedMixFromRop2[(rop4 >> 2) & 0xf] ;

    /////////////////////////////////////////////////////////////////
    // Setup the hardware for solid colours

    ptd->pfnTrap = vMmSolidTrapezoid80 ;

    // We initialize the hardware for the color, rop, start address,
    // and blt mode

    if (cBpp == 1)
    {
        ulSolidColor |= ulSolidColor << 8  ;
        ulSolidColor |= ulSolidColor << 16 ;
    }
    else if (cBpp == 2)
    {
        ulSolidColor |= ulSolidColor << 16 ;
    }

    CP_MM_WAIT_FOR_BLT_COMPLETE(ppdev, pjBase) ;
    CP_MM_SRC_ADDR(ppdev, pjBase, ppdev->ulSolidColorOffset) ;
    CP_MM_DST_Y_OFFSET(ppdev, pjBase, lDelta);

    jExtMode = ( ENABLE_XY_POSITION_PACKED | 
                 ENABLE_COLOR_EXPAND       | 
                 ENABLE_8x8_PATTERN_COPY   |
                 ppdev->jModeColor ) ;

    CP_MM_BLT_MODE_PACKED(ppdev, pjBase, jExtMode | jHwRop) ;
    CP_MM_FG_COLOR(ppdev, pjBase, ulSolidColor) ;

    if (prclClip != NULL)
    {
        ptd->pfnTrapClip = ptd->pfnTrap     ;
        ptd->pfnTrap     = vClipTrapezoid   ;
        ptd->yClipTop    = prclClip->top    ;
        ptd->yClipBottom = prclClip->bottom ;
        ptd->xClipLeft   = prclClip->left   ;
        ptd->xClipRight  = prclClip->right  ;
        ptd->bClip       = TRUE;
    }
    else
    {
        ptd->bClip       = FALSE;
    }

}

/******************************Public*Routine******************************\
* BOOL bFastFill
*
* Draws a non-complex, unclipped polygon.  'Non-complex' is defined as
* having only two edges that are monotonic increasing in 'y'.  That is,
* the polygon cannot have more than one disconnected segment on any given
* scan.  Note that the edges of the polygon can self-intersect, so hourglass
* shapes are permissible.  This restriction permits this routine to run two
* simultaneous DDAs, and no sorting of the edges is required.
*
* Note that NT's fill convention is different from that of Win 3.1 or Win95.
* With the additional complication of fractional end-points, our convention
* is the same as in 'X-Windows'.  But a DDA is a DDA is a DDA, so once you
* figure out how we compute the DDA terms for NT, you're golden.
*
* This routine handles patterns only when the S3 hardware patterns can be
* used.  The reason for this is that once the S3 pattern initialization is
* done, pattern fills appear to the programmer exactly the same as solid
* fills (with the slight difference that different registers and commands
* are used).  Handling 'vIoFillPatSlow' style patterns in this routine
* would be non-trivial...
*
* We take advantage of the fact that the S3 automatically advances the
* current 'y' to the following scan whenever a rectangle is output so that
* we have to write to the accelerator three times for every scan: one for
* the new 'x', one for the new 'width', and one for the drawing command.
*
* Returns TRUE if the polygon was drawn; FALSE if the polygon was complex.
*
\**************************************************************************/

BOOL bFastFill(
PDEV*       ppdev,
LONG        cEdges,         // Includes close figure edge
POINTFIX*   pptfxFirst,
ULONG       rop4,
ULONG       iSolidColor,
RBRUSH*     prb,
POINTL*     pptlBrush,
RECTL*      prclClip)       // NULL if no clipping
{
    LONG      yTrapezoid;   // Top scan for next trapezoid
    LONG      cyTrapezoid;  // Number of scans in current trapezoid
    LONG      yStart;       // y-position of start point in current edge
    LONG      dM;           // Edge delta in FIX units in x direction
    LONG      dN;           // Edge delta in FIX units in y direction
    LONG      i;
    POINTFIX* pptfxLast;    // Points to the last point in the polygon array
    POINTFIX* pptfxTop;     // Points to the top-most point in the polygon
    POINTFIX* pptfxOld;     // Start point in current edge
    POINTFIX* pptfxScan;    // Current edge pointer for finding pptfxTop
    LONG      cScanEdges;   // Number of edges scanned to find pptfxTop
                            //  (doesn't include the closefigure edge)
    LONG      iEdge;
    LONG      lQuotient;
    LONG      lRemainder;

    TRAPEZOIDDATA   td;     // Edge data and stuff
    EDGEDATA*       ped;    // Points to current edge being processed

    /////////////////////////////////////////////////////////////////
    // See if the polygon is convex

    pptfxScan = pptfxFirst;
    pptfxTop  = pptfxFirst;                 // Assume for now that the first
                                            //  point in path is the topmost
    pptfxLast = pptfxFirst + cEdges - 1;

    if (cEdges <= 2)
        goto ReturnTrue;

    // 'pptfxScan' will always point to the first point in the current
    // edge, and 'cScanEdges' will the number of edges remaining, including
    // the current one:

    cScanEdges = cEdges - 1;     // The number of edges, not counting close figure

    if ((pptfxScan + 1)->y > pptfxScan->y)
    {
        // Collect all downs:

        do {
            if (--cScanEdges == 0)
                goto SetUpForFilling;
            pptfxScan++;
        } while ((pptfxScan + 1)->y >= pptfxScan->y);

        // Collect all ups:

        do {
            if (--cScanEdges == 0)
                goto SetUpForFillingCheck;
            pptfxScan++;
        } while ((pptfxScan + 1)->y <= pptfxScan->y);

        // Collect all downs:

        pptfxTop = pptfxScan;

        do {
            if ((pptfxScan + 1)->y > pptfxFirst->y)
                break;

            if (--cScanEdges == 0)
                goto SetUpForFilling;
            pptfxScan++;
        } while ((pptfxScan + 1)->y >= pptfxScan->y);

        goto ReturnFalse;
    }
    else
    {
        // Collect all ups:

        do {
            pptfxTop++;                 // We increment this now because we
                                        //  want it to point to the very last
                                        //  point if we early out in the next
                                        //  statement...
            if (--cScanEdges == 0)
                goto SetUpForFilling;
        } while ((pptfxTop + 1)->y <= pptfxTop->y);

        // Collect all downs:

        pptfxScan = pptfxTop;
        do {
            if (--cScanEdges == 0)
                goto SetUpForFilling;
            pptfxScan++;
        } while ((pptfxScan + 1)->y >= pptfxScan->y);

        // Collect all ups:

        do {
            if ((pptfxScan + 1)->y < pptfxFirst->y)
                break;

            if (--cScanEdges == 0)
                goto SetUpForFilling;
            pptfxScan++;
        } while ((pptfxScan + 1)->y <= pptfxScan->y);

        goto ReturnFalse;
    }

SetUpForFillingCheck:

    // We check to see if the end of the current edge is higher
    // than the top edge we've found so far:

    if ((pptfxScan + 1)->y < pptfxTop->y)
        pptfxTop = pptfxScan + 1;

SetUpForFilling:

    /////////////////////////////////////////////////////////////////
    // Some Initialization

    td.aed[LEFT].pptfx  = pptfxTop;
    td.aed[RIGHT].pptfx = pptfxTop;

    yTrapezoid = (pptfxTop->y + 15) >> 4;

    // Make sure we initialize the DDAs appropriately:

    td.aed[LEFT].cy  = 0;
    td.aed[RIGHT].cy = 0;

    // Guess as to the ordering of the points:

    td.aed[LEFT].dptfx  = sizeof(POINTFIX);
    td.aed[RIGHT].dptfx = -(LONG) sizeof(POINTFIX);

    if (ppdev->flCaps & CAPS_MM_IO)
    {
// chu01
        if ((ppdev->flCaps & CAPS_COMMAND_LIST) && (ppdev->pCommandList != NULL))
        {
            vMmTrapezoidSetup80(ppdev, rop4, iSolidColor, prb, pptlBrush, &td,
                                prclClip) ;
        }
        else
            vMmTrapezoidSetup(ppdev, rop4, iSolidColor, prb, pptlBrush, &td,
                              prclClip) ;
    }
    else
    {
        vIoTrapezoidSetup(ppdev, rop4, iSolidColor, prb, pptlBrush, &td,
                          prclClip);
    }

NewTrapezoid:

    /////////////////////////////////////////////////////////////////
    // DDA initialization

    for (iEdge = 1; iEdge >= 0; iEdge--)
    {
        ped       = &td.aed[iEdge];
        ped->bNew = FALSE;
        if (ped->cy == 0)
        {
            // Our trapezoid drawing routine may want to be notified when
            // it will have to reset its DDA to start a new edge:

            ped->bNew = TRUE;

            // Need a new DDA:

            do {
                cEdges--;
                if (cEdges < 0)
                    goto ReturnTrue;

                // Find the next left edge, accounting for wrapping:

                pptfxOld = ped->pptfx;
                ped->pptfx = (POINTFIX*) ((BYTE*) ped->pptfx + ped->dptfx);

                if (ped->pptfx < pptfxFirst)
                    ped->pptfx = pptfxLast;
                else if (ped->pptfx > pptfxLast)
                    ped->pptfx = pptfxFirst;

                // Have to find the edge that spans yTrapezoid:

                ped->cy = ((ped->pptfx->y + 15) >> 4) - yTrapezoid;

                // With fractional coordinate end points, we may get edges
                // that don't cross any scans, in which case we try the
                // next one:

            } while (ped->cy <= 0);

            // 'pptfx' now points to the end point of the edge spanning
            // the scan 'yTrapezoid'.

            dN = ped->pptfx->y - pptfxOld->y;
            dM = ped->pptfx->x - pptfxOld->x;

            ASSERTDD(dN > 0, "Should be going down only");

            // Compute the DDA increment terms:

            ped->dM = dM;                   // Not used for software trapezoid

            if (dM < 0)
            {
                dM = -dM;
                if (dM < dN)                // Can't be '<='
                {
                    ped->dx       = -1;
                    ped->lErrorUp = dN - dM;
                }
                else
                {
                    QUOTIENT_REMAINDER(dM, dN, lQuotient, lRemainder);

                    ped->dx       = -lQuotient;     // - dM / dN
                    ped->lErrorUp = lRemainder;     // dM % dN
                    if (ped->lErrorUp > 0)
                    {
                        ped->dx--;
                        ped->lErrorUp = dN - ped->lErrorUp;
                    }
                }
            }
            else
            {
                if (dM < dN)                // Can't be '<='
                {
                    ped->dx       = 0;
                    ped->lErrorUp = dM;
                }
                else
                {
                    QUOTIENT_REMAINDER(dM, dN, lQuotient, lRemainder);

                    ped->dx       = lQuotient;      // dM / dN
                    ped->lErrorUp = lRemainder;     // dM % dN
                }
            }

            ped->dN = dN; // DDA limit
            ped->lError     = -1; // Error is initially zero (add dN - 1 for
                                  //  the ceiling, but subtract off dN so that
                                  //  we can check the sign instead of comparing
                                  //  to dN)

            ped->x = pptfxOld->x;
            yStart = pptfxOld->y;

            if ((yStart & 15) != 0)
            {
                // Advance to the next integer y coordinate

                for (i = 16 - (yStart & 15); i != 0; i--)
                {
                    ped->x      += ped->dx;
                    ped->lError += ped->lErrorUp;
                    if (ped->lError >= 0)
                    {
                        ped->lError -= ped->dN;
                        ped->x++;
                    }
                }
            }

            if ((ped->x & 15) != 0)
            {
                ped->lError -= ped->dN * (16 - (ped->x & 15));
                ped->x += 15;       // We'll want the ceiling in just a bit...
            }

            // Chop off those fractional bits:

            ped->x      >>= 4;
            ped->lError >>= 4;
        }
    }

    cyTrapezoid = min(td.aed[LEFT].cy, td.aed[RIGHT].cy); // # of scans in this trap
    td.aed[LEFT].cy  -= cyTrapezoid;
    td.aed[RIGHT].cy -= cyTrapezoid;

    td.pfnTrap(&td, yTrapezoid, cyTrapezoid);

    yTrapezoid += cyTrapezoid;

    goto NewTrapezoid;

ReturnTrue:

    return(TRUE);

ReturnFalse:

    return(FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\cirrus\disp\fillpath.c ===
/******************************************************************************\
*
* $Workfile:   fillpath.c  $
*
* Contains the DrvFillPath routine, which is used for drawing polygons.
*
* Copyright (c) 1992-1995 Microsoft Corporation
* Copyright (c) 1996 Cirrus Logic, Inc.
*
* $Log:   S:/projects/drivers/ntsrc/display/fillpath.c_v  $
 *
 *    Rev 1.1   Oct 10 1996 15:37:36   unknown
 *
*
*    Rev 1.1   12 Aug 1996 16:53:28   frido
* Removed unaccessed local variables.
*
\******************************************************************************/

#include "precomp.h"

// We have to be careful of arithmetic overflow in a number of places.
// Fortunately, the compiler is guaranteed to natively support 64-bit
// signed LONGLONGs and 64-bit unsigned DWORDLONGs.
//
// Int32x32To64(a, b) is a macro defined in 'winnt.h' that multiplies
//      two 32-bit LONGs to produce a 64-bit LONGLONG result.
//      I use it because it is much faster than 64x64 multiplies.

#define UInt64Div32To32(a, b)                   \
    ((((DWORDLONG)(a)) > ULONG_MAX)          ?  \
        (ULONG)((DWORDLONG)(a) / (ULONG)(b)) :  \
        (ULONG)((ULONG)(a) / (ULONG)(b)))

#define NUM_BUFFER_POINTS   96      // Maximum number of points in a path
                                    //   for which we'll attempt to join
                                    //   all the path records so that the
                                    //   path may still be drawn by FastFill

// Describe a single non-horizontal edge of a path to fill.
typedef struct _EDGE {
    PVOID pNext;
    INT iScansLeft;
    INT X;
    INT Y;
    INT iErrorTerm;
    INT iErrorAdjustUp;
    INT iErrorAdjustDown;
    INT iXWhole;
    INT iXDirection;
    INT iWindingDirection;
} EDGE, *PEDGE;

// Maximum number of rects we'll fill per call to
// the fill code
#define MAX_PATH_RECTS  50
#define RECT_BYTES      (MAX_PATH_RECTS * sizeof(RECTL))
#define EDGE_BYTES      (TMP_BUFFER_SIZE - RECT_BYTES)
#define MAX_EDGES       (EDGE_BYTES/sizeof(EDGE))

VOID AdvanceAETEdges(EDGE *pAETHead);
VOID XSortAETEdges(EDGE *pAETHead);
VOID MoveNewEdges(EDGE *pGETHead, EDGE *pAETHead, INT iCurrentY);
EDGE * AddEdgeToGET(EDGE *pGETHead, EDGE *pFreeEdge, POINTFIX *ppfxEdgeStart,
        POINTFIX *ppfxEdgeEnd, RECTL *pClipRect);
BOOL ConstructGET(EDGE *pGETHead, EDGE *pFreeEdges, PATHOBJ *ppo,
        PATHDATA *pd, BOOL bMore, RECTL *pClipRect);
void AdjustErrorTerm(INT *pErrorTerm, INT iErrorAdjustUp, INT iErrorAdjustDown,
        INT yJump, INT *pXStart, INT iXDirection);

/******************************Public*Routine******************************\
* DrvFillPath
*
* Fill the specified path with the specified brush and ROP.  This routine
* detects single convex polygons, and will call to separate faster convex
* polygon code for those cases.  This routine also detects polygons that
* are really rectangles, and handles those separately as well.
*
* Note: Multiple polygons in a path cannot be treated as being disjoint;
*       the fill must consider all the points in the path.  That is, if the
*       path contains multiple polygons, you cannot simply draw one polygon
*       after the other (unless they don't overlap).
*
* Note: This function is optional, but is recommended for good performance.
*       To get GDI to call this function, not only do you have to
*       HOOK_FILLPATH, you have to set GCAPS_ALTERNATEFILL and/or
*       GCAPS_WINDINGFILL.
*
\**************************************************************************/

BOOL DrvFillPath(
SURFOBJ*    pso,
PATHOBJ*    ppo,
CLIPOBJ*    pco,
BRUSHOBJ*   pbo,
POINTL*     pptlBrush,
MIX         mix,
FLONG       flOptions)
{
    BYTE jClipping;     // clipping type
    EDGE *pCurrentEdge;
    EDGE AETHead;       // dummy head/tail node & sentinel for Active Edge Table
    EDGE *pAETHead;     // pointer to AETHead
    EDGE GETHead;       // dummy head/tail node & sentinel for Global Edge Table
    EDGE *pGETHead;     // pointer to GETHead
    EDGE *pFreeEdges;   // pointer to memory free for use to store edges
    ULONG ulNumRects;   // # of rectangles to draw currently in rectangle list
    RECTL *prclRects;   // pointer to start of rectangle draw list
    INT iCurrentY;      // scan line for which we're currently scanning out the
                        //  fill

    ULONG        rop4;           // Hardware mix value
    RBRUSH_COLOR rbc;               // Realized brush or solid color
    ULONG        iSolidColor;       // Copy of pbo->iSolidColor
    FNFILL      *pfnFill;           // Points to appropriate fill routine

    BOOL         bMore;
    PATHDATA     pd;
    RECTL        ClipRect;
    PDEV        *ppdev;
    DSURF       *pdsurf;
    RECTL*       prclClip;

    BOOL         bRetVal=FALSE;     // FALSE until proven TRUE
    BOOL         bMemAlloced=FALSE; // FALSE until proven TRUE

    FLONG        flFirstRecord;
    POINTFIX*    pptfxTmp;
    ULONG        cptfxTmp;
    RECTFX       rcfxBounds;
    POINTFIX     aptfxBuf[NUM_BUFFER_POINTS];

    DISPDBG((1, "DrvFillPath"));

    if (ppo->fl & PO_BEZIERS)   // don't handle beziers
    {
        goto ReturnFalse;
    }

    // Set up the clipping
    if (pco == (CLIPOBJ *) NULL) {
        // No CLIPOBJ provided, so we don't have to worry about clipping
        jClipping = DC_TRIVIAL;
    } else {
        // Use the CLIPOBJ-provided clipping
        jClipping = pco->iDComplexity;
    }

    if (jClipping != DC_TRIVIAL) {
        if (jClipping != DC_RECT) {
            goto ReturnFalse;  // there is complex clipping; let GDI fill the path
        }
        // Clip to the clip rectangle
        ClipRect = pco->rclBounds;
    } else {
        // So the y-clipping code doesn't do any clipping
        // /16 so we don't blow the values out when we scale up to GIQ
        ClipRect.top = (LONG_MIN + 1) / 16; // +1 to avoid compiler problem
        ClipRect.bottom = LONG_MAX / 16;
    }

    // Pass the surface off to GDI if it's a device bitmap that we've
    // converted to a DIB:

    pdsurf = (DSURF*) pso->dhsurf;
    if (pdsurf->dt == DT_DIB)
    {
        bRetVal = EngFillPath(pdsurf->pso, ppo, pco, pbo, pptlBrush, mix,
                           flOptions);
        goto ReturnStatus;
    }

    iSolidColor = 0;                            // Assume we won't need a pattern

    rop4 = (gaRop3FromMix[mix >> 8] << 8) | gaRop3FromMix[mix & 0xff];

    if ((((rop4 & 0xff00) >> 8) != (rop4 & 0x00ff)) ||
        ((((rop4 >> 4) ^ (rop4)) & 0xf0f) != 0))  // Only do if we need a pattern
    {
        iSolidColor     = pbo->iSolidColor;
        rbc.iSolidColor = iSolidColor;
        if (iSolidColor == -1)
        {
            goto ReturnFalse;   // don't handle non solid patterns
        }
    }

    // We'll be drawing to the screen or an off-screen DFB; copy the surface's
    // offset now so that we won't need to refer to the DSURF again:

    ppdev = (PDEV*) pso->dhpdev;
    ppdev->xOffset = pdsurf->poh->x;
    ppdev->yOffset = pdsurf->poh->y;
    ppdev->xyOffset = pdsurf->poh->xy;

    if (ppdev->flCaps & CAPS_MM_IO)
    {
        pfnFill = vMmFillSolid;
    }
    else
    {
        pfnFill = vIoFillSolid;
    }

    // Enumerate path here first time to check for special
    // cases (rectangles and monotone polygons)

    // It is too difficult to determine interaction between
    // multiple paths, if there is more than one, skip this
    PATHOBJ_vEnumStart(ppo);
    bMore = PATHOBJ_bEnum(ppo, &pd);

    {
        prclClip = NULL;
        if (jClipping == DC_RECT)
        {
            prclClip = &ClipRect;

            // Our FastFill routine does cross products and intersection
            // calculations assuming it can use 32 bit math and not
            // overflow.  As such, we have to ensure that the bounds of
            // the polygon fit in a 15 bit space, including the 4 bit fix
            // point fraction.  Note that we don't have to do this check
            // for trivial clipping, because we'll assume the screen
            // dimensions are 2048 x 2048 or smaller:

            PATHOBJ_vGetBounds(ppo, &rcfxBounds);

            if (((rcfxBounds.xRight - rcfxBounds.xLeft) > 0x7fff) ||
                ((rcfxBounds.yBottom - rcfxBounds.yTop) > 0x7fff))
                goto SkipFastFill;
        }

        if (bMore)
        {
            // FastFill only knows how to take a single contiguous buffer
            // of points.  Unfortunately, GDI sometimes hands us paths
            // that are split over multiple path data records.  Convex
            // figures such as Ellipses, Pies and RoundRects are almost
            // always given in multiple records.  Since probably 90% of
            // multiple record paths could still be done by FastFill, for
            // those cases we simply copy the points into a contiguous
            // buffer...

            // First make sure that the entire path would fit in the
            // temporary buffer, and make sure the path isn't comprised
            // of more than one subpath:

            if ((ppo->cCurves >= NUM_BUFFER_POINTS) ||
                (pd.flags & PD_ENDSUBPATH))
                goto SkipFastFill;

            pptfxTmp = &aptfxBuf[0];

            RtlCopyMemory(pptfxTmp, pd.pptfx, sizeof(POINTFIX) * pd.count);

            pptfxTmp     += pd.count;
            cptfxTmp      = pd.count;
            flFirstRecord = pd.flags;       // Remember PD_BEGINSUBPATH flag

            do {
                bMore = PATHOBJ_bEnum(ppo, &pd);

                RtlCopyMemory(pptfxTmp, pd.pptfx, sizeof(POINTFIX) * pd.count);
                cptfxTmp += pd.count;
                pptfxTmp += pd.count;
            } while (!(pd.flags & PD_ENDSUBPATH));

            // Fake up the path data record:

            pd.pptfx  = &aptfxBuf[0];
            pd.count  = cptfxTmp;
            pd.flags |= flFirstRecord;

            // If there's more than one subpath, we can't call FastFill:

            if (bMore)
                goto SkipFastFill;
        }

        if (bFastFill(ppdev, pd.count, pd.pptfx, rop4, iSolidColor,
                       rbc.prb, pptlBrush, prclClip))
        {
            goto ReturnTrue;
        }
    }

    // There's nothing to do if there are only one or two points
    if (ppo->cCurves <= 2) {
        goto ReturnTrue;
    }

SkipFastFill:

    // Set up working storage in the temporary buffer

    prclRects = (RECTL*) ppdev->pvTmpBuffer; // storage for list of rectangles to draw

    if (!bMore) {

        RECTL *rectangle;
        INT cPoints = pd.count;

        // The count can't be less than three, because we got all the edges
        // in this subpath, and above we checked that there were at least
        // three edges

        // If the count is four, check to see if the polygon is really a
        // rectangle since we can really speed that up. We'll also check for
        // five with the first and last points the same, because under Win 3.1,
        // it was required to close polygons

        if ((cPoints == 4) ||
           ((cPoints == 5) &&
            (pd.pptfx[0].x == pd.pptfx[4].x) &&
            (pd.pptfx[0].y == pd.pptfx[4].y))) {

            rectangle = prclRects;

      /* we have to start somewhere so assume that most
         applications specify the top left point  first

         we want to check that the first two points are
         either vertically or horizontally aligned.  if
         they are then we check that the last point [3]
         is either horizontally or  vertically  aligned,
         and finally that the 3rd point [2] is  aligned
         with both the first point and the  last  point */

#define FIX_SHIFT 4L
#define FIX_MASK (- (1 << FIX_SHIFT))

         rectangle->top   = pd.pptfx[0].y - 1 & FIX_MASK;
         rectangle->left  = pd.pptfx[0].x - 1 & FIX_MASK;
         rectangle->right = pd.pptfx[1].x - 1 & FIX_MASK;

         if (rectangle->left ^ rectangle->right) {
            if (rectangle->top  ^ (pd.pptfx[1].y - 1 & FIX_MASK))
               goto not_rectangle;

            if (rectangle->left ^ (pd.pptfx[3].x - 1 & FIX_MASK))
               goto not_rectangle;

            if (rectangle->right ^ (pd.pptfx[2].x - 1 & FIX_MASK))
               goto not_rectangle;

            rectangle->bottom = pd.pptfx[2].y - 1 & FIX_MASK;
            if (rectangle->bottom ^ (pd.pptfx[3].y - 1 & FIX_MASK))
               goto not_rectangle;
         }
         else {
            if (rectangle->top ^ (pd.pptfx[3].y - 1 & FIX_MASK))
               goto not_rectangle;

            rectangle->bottom = pd.pptfx[1].y - 1 & FIX_MASK;
            if (rectangle->bottom ^ (pd.pptfx[2].y - 1 & FIX_MASK))
               goto not_rectangle;

            rectangle->right = pd.pptfx[2].x - 1 & FIX_MASK;
            if (rectangle->right ^ (pd.pptfx[3].x - 1 & FIX_MASK))
                goto not_rectangle;
         }

      /* if the left is greater than the right then
         swap them so the blt code doesn't wig  out */

         if (rectangle->left > rectangle->right) {
            FIX temp;

            temp = rectangle->left;
            rectangle->left = rectangle->right;
            rectangle->right = temp;
         }
         else {

         /* if left == right there's nothing to draw */

            if (rectangle->left == rectangle->right) {
               goto ReturnTrue;
            }
         }

      /* shift the values to get pixel coordinates */

         rectangle->left  = (rectangle->left  >> FIX_SHIFT) + 1;
         rectangle->right = (rectangle->right >> FIX_SHIFT) + 1;

         if (rectangle->top > rectangle->bottom) {
            FIX temp;

            temp = rectangle->top;
            rectangle->top = rectangle->bottom;
            rectangle->bottom = temp;
         }
         else {
            if (rectangle->top == rectangle->bottom) {
               goto ReturnTrue;
            }
         }

      /* shift the values to get pixel coordinates */

         rectangle->top    = (rectangle->top    >> FIX_SHIFT) + 1;
         rectangle->bottom = (rectangle->bottom >> FIX_SHIFT) + 1;

         // Finally, check for clipping
         if (jClipping == DC_RECT) {
            // Clip to the clip rectangle
            if (!bIntersect(rectangle, &ClipRect, rectangle)) {
                // Totally clipped, nothing to do
                goto ReturnTrue;
            }
         }

      /* if we get here then the polygon is a rectangle,
         set count to 1 and  goto  bottom  to  draw  it */

         ulNumRects = 1;
         goto draw_remaining_rectangles;
      }

not_rectangle:

        ;

    }

    // Do we have enough memory for all the edges?
    // LATER does cCurves include closure?
    if (ppo->cCurves > MAX_EDGES) {
        //
        // try to allocate enough memory
        //
        pFreeEdges = (EDGE *) ALLOC(ppo->cCurves * sizeof(EDGE));

        if (pFreeEdges == NULL)
        {
            goto ReturnFalse;  // too many edges; let GDI fill the path
        }
        else
        {
            bMemAlloced = TRUE;
        }
    }
    else {
        pFreeEdges = (EDGE*) ((BYTE*) ppdev->pvTmpBuffer + RECT_BYTES);
            // use our handy temporary buffer (it's big enough)
    }

    // Initialize an empty list of rectangles to fill
    ulNumRects = 0;

    // Enumerate the path edges and build a Global Edge Table (GET) from them
    // in YX-sorted order.
    pGETHead = &GETHead;
    if (!ConstructGET(pGETHead, pFreeEdges, ppo, &pd, bMore, &ClipRect)) {
        goto ReturnFalse;  // outside GDI's 2**27 range
    }

    // Create an empty AET with the head node also a tail sentinel
    pAETHead = &AETHead;
    AETHead.pNext = pAETHead;  // mark that the AET is empty
    AETHead.X = 0x7FFFFFFF;    // this is greater than any valid X value, so
                               //  searches will always terminate

    // Top scan of polygon is the top of the first edge we come to
    iCurrentY = ((EDGE *)GETHead.pNext)->Y;

    // Loop through all the scans in the polygon, adding edges from the GET to
    // the Active Edge Table (AET) as we come to their starts, and scanning out
    // the AET at each scan into a rectangle list. Each time it fills up, the
    // rectangle list is passed to the filling routine, and then once again at
    // the end if any rectangles remain undrawn. We continue so long as there
    // are edges to be scanned out
    while (1) {

        // Advance the edges in the AET one scan, discarding any that have
        // reached the end (if there are any edges in the AET)
        if (AETHead.pNext != pAETHead) {
            AdvanceAETEdges(pAETHead);
        }

        // If the AET is empty, done if the GET is empty, else jump ahead to
        // the next edge in the GET; if the AET isn't empty, re-sort the AET
        if (AETHead.pNext == pAETHead) {
            if (GETHead.pNext == pGETHead) {
                // Done if there are no edges in either the AET or the GET
                break;
            }
            // There are no edges in the AET, so jump ahead to the next edge in
            // the GET
            iCurrentY = ((EDGE *)GETHead.pNext)->Y;
        } else {
            // Re-sort the edges in the AET by X coordinate, if there are at
            // least two edges in the AET (there could be one edge if the
            // balancing edge hasn't yet been added from the GET)
            if (((EDGE *)AETHead.pNext)->pNext != pAETHead) {
                XSortAETEdges(pAETHead);
            }
        }

        // Move any new edges that start on this scan from the GET to the AET;
        // bother calling only if there's at least one edge to add
        if (((EDGE *)GETHead.pNext)->Y == iCurrentY) {
            MoveNewEdges(pGETHead, pAETHead, iCurrentY);
        }

        // Scan the AET into rectangles to fill (there's always at least one
        // edge pair in the AET)
        pCurrentEdge = AETHead.pNext;   // point to the first edge
        do {

            INT iLeftEdge;

            // The left edge of any given edge pair is easy to find; it's just
            // wherever we happen to be currently
            iLeftEdge = pCurrentEdge->X;

            // Find the matching right edge according to the current fill rule
            if ((flOptions & FP_WINDINGMODE) != 0) {

                INT iWindingCount;

                // Do winding fill; scan across until we've found equal numbers
                // of up and down edges
                iWindingCount = pCurrentEdge->iWindingDirection;
                do {
                    pCurrentEdge = pCurrentEdge->pNext;
                    iWindingCount += pCurrentEdge->iWindingDirection;
                } while (iWindingCount != 0);
            } else {
                // Odd-even fill; the next edge is the matching right edge
                pCurrentEdge = pCurrentEdge->pNext;
            }

            // See if the resulting span encompasses at least one pixel, and
            // add it to the list of rectangles to draw if so
            if (iLeftEdge < pCurrentEdge->X) {

                // We've got an edge pair to add to the list to be filled; see
                // if there's room for one more rectangle
                if (ulNumRects >= MAX_PATH_RECTS) {
                    // No more room; draw the rectangles in the list and reset
                    // it to empty

                    (*pfnFill)(ppdev, ulNumRects, prclRects, rop4,
                               rbc, pptlBrush);

                    // Reset the list to empty
                    ulNumRects = 0;
                }

                // Add the rectangle representing the current edge pair
                if (jClipping == DC_RECT) {
                    // Clipped
                    // Clip to left
                    prclRects[ulNumRects].left = max(iLeftEdge, ClipRect.left);
                    // Clip to right
                    prclRects[ulNumRects].right =
                            min(pCurrentEdge->X, ClipRect.right);
                    // Draw only if not fully clipped
                    if (prclRects[ulNumRects].left <
                            prclRects[ulNumRects].right) {
                        prclRects[ulNumRects].top = iCurrentY;
                        prclRects[ulNumRects].bottom = iCurrentY+1;
                        ulNumRects++;
                    }
                }
                else
                {
                    // Unclipped
                    prclRects[ulNumRects].top = iCurrentY;
                    prclRects[ulNumRects].bottom = iCurrentY+1;
                    prclRects[ulNumRects].left = iLeftEdge;
                    prclRects[ulNumRects].right = pCurrentEdge->X;
                    ulNumRects++;
                }
            }
        } while ((pCurrentEdge = pCurrentEdge->pNext) != pAETHead);

        iCurrentY++;    // next scan
    }

/* draw the remaining rectangles,  if there are any */

draw_remaining_rectangles:

    if (ulNumRects > 0) {
        (*pfnFill)(ppdev, ulNumRects, prclRects, rop4, rbc, pptlBrush);
    }

ReturnTrue:
    bRetVal = TRUE; // done successfully

ReturnFalse:

    // bRetVal is originally false.  If you jumped to ReturnFalse from somewhere,
    // then it will remain false, and be returned.

    if (bMemAlloced)
    {
        //
        // we did allocate memory, so release it
        //
        FREE(pFreeEdges);
    }

ReturnStatus:
    return(bRetVal);
}

// Advance the edges in the AET to the next scan, dropping any for which we've
// done all scans. Assumes there is at least one edge in the AET.
VOID AdvanceAETEdges(EDGE *pAETHead)
{
    EDGE *pLastEdge, *pCurrentEdge;

    pLastEdge = pAETHead;
    pCurrentEdge = pLastEdge->pNext;
    do {

        // Count down this edge's remaining scans
        if (--pCurrentEdge->iScansLeft == 0) {
            // We've done all scans for this edge; drop this edge from the AET
            pLastEdge->pNext = pCurrentEdge->pNext;
        } else {
            // Advance the edge's X coordinate for a 1-scan Y advance
            // Advance by the minimum amount
            pCurrentEdge->X += pCurrentEdge->iXWhole;
            // Advance the error term and see if we got one extra pixel this
            // time
            pCurrentEdge->iErrorTerm += pCurrentEdge->iErrorAdjustUp;
            if (pCurrentEdge->iErrorTerm >= 0) {
                // The error term turned over, so adjust the error term and
                // advance the extra pixel
                pCurrentEdge->iErrorTerm -= pCurrentEdge->iErrorAdjustDown;
                pCurrentEdge->X += pCurrentEdge->iXDirection;
            }

            pLastEdge = pCurrentEdge;
        }
    } while ((pCurrentEdge = pLastEdge->pNext) != pAETHead);
}

// X-sort the AET, because the edges may have moved around relative to
// one another when we advanced them. We'll use a multipass bubble
// sort, which is actually okay for this application because edges
// rarely move relative to one another, so we usually do just one pass.
// Also, this makes it easy to keep just a singly-linked list. Assumes there
// are at least two edges in the AET.
VOID XSortAETEdges(EDGE *pAETHead)
{
    BOOL bEdgesSwapped;
    EDGE *pLastEdge, *pCurrentEdge, *pNextEdge;

    do {

        bEdgesSwapped = FALSE;
        pLastEdge = pAETHead;
        pCurrentEdge = pLastEdge->pNext;
        pNextEdge = pCurrentEdge->pNext;

        do {
            if (pNextEdge->X < pCurrentEdge->X) {

                // Next edge is to the left of the current edge; swap them
                pLastEdge->pNext = pNextEdge;
                pCurrentEdge->pNext = pNextEdge->pNext;
                pNextEdge->pNext = pCurrentEdge;
                bEdgesSwapped = TRUE;
                pCurrentEdge = pNextEdge;   // continue sorting before the edge
                                            //  we just swapped; it might move
                                            //  farther yet
            }
            pLastEdge = pCurrentEdge;
            pCurrentEdge = pLastEdge->pNext;
        } while ((pNextEdge = pCurrentEdge->pNext) != pAETHead);
    } while (bEdgesSwapped);
}

// Moves all edges that start on the current scan from the GET to the AET in
// X-sorted order. Parameters are pointer to head of GET and pointer to dummy
// edge at head of AET, plus current scan line. Assumes there's at least one
// edge to be moved.
VOID MoveNewEdges(EDGE *pGETHead, EDGE *pAETHead, INT iCurrentY)
{
    EDGE *pCurrentEdge = pAETHead;
    EDGE *pGETNext = pGETHead->pNext;

    do {

        // Scan through the AET until the X-sorted insertion point for this
        // edge is found. We can continue from where the last search left
        // off because the edges in the GET are in X sorted order, as is
        // the AET. The search always terminates because the AET sentinel
        // is greater than any valid X
        while (pGETNext->X > ((EDGE *)pCurrentEdge->pNext)->X) {
            pCurrentEdge = pCurrentEdge->pNext;
        }

        // We've found the insertion point; add the GET edge to the AET, and
        // remove it from the GET
        pGETHead->pNext = pGETNext->pNext;
        pGETNext->pNext = pCurrentEdge->pNext;
        pCurrentEdge->pNext = pGETNext;
        pCurrentEdge = pGETNext;    // continue insertion search for the next
                                    //  GET edge after the edge we just added
        pGETNext = pGETHead->pNext;

    } while (pGETNext->Y == iCurrentY);
}





// Build the Global Edge Table from the path. There must be enough memory in
// the free edge area to hold all edges. The GET is constructed in Y-X order,
// and has a head/tail/sentinel node at pGETHead.

BOOL ConstructGET(
   EDGE     *pGETHead,
   EDGE     *pFreeEdges,
   PATHOBJ  *ppo,
   PATHDATA *pd,
   BOOL      bMore,
   RECTL    *pClipRect)
{
   POINTFIX pfxPathStart;    // point that started the current subpath
   POINTFIX pfxPathPrevious; // point before the current point in a subpath;
                              //  starts the current edge

/* Create an empty GET with the head node also a tail sentinel */

   pGETHead->pNext = pGETHead; // mark that the GET is empty
   pGETHead->Y = 0x7FFFFFFF;   // this is greater than any valid Y value, so
                                //  searches will always terminate

/* PATHOBJ_vEnumStart is implicitly  performed  by  engine
   already and first path  is  enumerated  by  the  caller */

next_subpath:

/* Make sure the PATHDATA is not empty (is this necessary) */

   if (pd->count != 0) {

   /* If first point starts a subpath, remember it as such
      and go on to the next point,   so we can get an edge */

      if (pd->flags & PD_BEGINSUBPATH) {

      /* the first point starts the subpath;   remember it */


         pfxPathStart    = *pd->pptfx; /* the subpath starts here          */
         pfxPathPrevious = *pd->pptfx; /* this points starts the next edge */
         pd->pptfx++;                  /* advance to the next point        */
         pd->count--;                  /* count off this point             */
      }


   /* add edges in PATHDATA to GET,  in Y-X  sorted  order */

      while (pd->count--) {
        if ((pFreeEdges =
            AddEdgeToGET(pGETHead, pFreeEdges, &pfxPathPrevious, pd->pptfx,
                         pClipRect)) == NULL) {
            goto ReturnFalse;
        }
        pfxPathPrevious = *pd->pptfx; /* current point becomes previous   */
        pd->pptfx++;                  /* advance to the next point        */
      }


   /* If last point ends the subpath, insert the edge that
      connects to first point  (is this built in already?) */

      if (pd->flags & PD_ENDSUBPATH) {
         if ((pFreeEdges = AddEdgeToGET(pGETHead, pFreeEdges, &pfxPathPrevious,
                                   &pfxPathStart, pClipRect)) == NULL) {
            goto ReturnFalse;
        }
      }
   }

/* the initial loop conditions preclude a do, while or for */

   if (bMore) {
       bMore = PATHOBJ_bEnum(ppo, pd);
       goto next_subpath;
   }

    return(TRUE);   // done successfully

ReturnFalse:
    return(FALSE);  // failed
}

// Adds the edge described by the two passed-in points to the Global Edge
// Table, if the edge spans at least one pixel vertically.
EDGE * AddEdgeToGET(EDGE *pGETHead, EDGE *pFreeEdge,
        POINTFIX *ppfxEdgeStart, POINTFIX *ppfxEdgeEnd, RECTL *pClipRect)
{
    INT iYStart, iYEnd, iXStart, iXEnd, iYHeight, iXWidth;
    INT yJump, yTop;

    // Set the winding-rule direction of the edge, and put the endpoints in
    // top-to-bottom order
    iYHeight = ppfxEdgeEnd->y - ppfxEdgeStart->y;
    if (iYHeight == 0) {
        return(pFreeEdge);  // zero height; ignore this edge
    } else if (iYHeight >= 0) {
        iXStart = ppfxEdgeStart->x;
        iYStart = ppfxEdgeStart->y;
        iXEnd = ppfxEdgeEnd->x;
        iYEnd = ppfxEdgeEnd->y;
        pFreeEdge->iWindingDirection = 1;
    } else {
        iYHeight = -iYHeight;
        iXEnd = ppfxEdgeStart->x;
        iYEnd = ppfxEdgeStart->y;
        iXStart = ppfxEdgeEnd->x;
        iYStart = ppfxEdgeEnd->y;
        pFreeEdge->iWindingDirection = -1;
    }

    if (iYHeight & 0x80000000) {
        return(NULL);       // too large; outside 2**27 GDI range
    }

    // Set the error term and adjustment factors, all in GIQ coordinates for
    // now
    iXWidth = iXEnd - iXStart;
    if (iXWidth >= 0) {
        // Left to right, so we change X as soon as we move at all
        pFreeEdge->iXDirection = 1;
        pFreeEdge->iErrorTerm = -1;
    } else {
        // Right to left, so we don't change X until we've moved a full GIQ
        // coordinate
        iXWidth = -iXWidth;
        pFreeEdge->iXDirection = -1;
        pFreeEdge->iErrorTerm = -iYHeight;
    }

    if (iXWidth & 0x80000000) {
        return(NULL);       // too large; outside 2**27 GDI range
    }

    if (iXWidth >= iYHeight) {
        // Calculate base run length (minimum distance advanced in X for a 1-
        // scan advance in Y)
        pFreeEdge->iXWhole = iXWidth / iYHeight;
        // Add sign back into base run length if going right to left
        if (pFreeEdge->iXDirection == -1) {
            pFreeEdge->iXWhole = -pFreeEdge->iXWhole;
        }
        pFreeEdge->iErrorAdjustUp = iXWidth % iYHeight;
    } else {
        // Base run length is 0, because line is closer to vertical than
        // horizontal
        pFreeEdge->iXWhole = 0;
        pFreeEdge->iErrorAdjustUp = iXWidth;
    }
    pFreeEdge->iErrorAdjustDown = iYHeight;

    // Calculate the number of pixels spanned by this edge, accounting for
    // clipping

    // Top true pixel scan in GIQ coordinates
    // Shifting to divide and multiply by 16 is okay because the clip rect
    // always contains positive numbers
    yTop = max(pClipRect->top << 4, (iYStart + 15) & ~0x0F);
    pFreeEdge->Y = yTop >> 4;    // initial scan line on which to fill edge

    // Calculate # of scans to actually fill, accounting for clipping
    if ((pFreeEdge->iScansLeft = min(pClipRect->bottom, ((iYEnd + 15) >> 4))
            - pFreeEdge->Y) <= 0) {

        return(pFreeEdge);  // no pixels at all are spanned, so we can
                            // ignore this edge
    }

    // If the edge doesn't start on a pixel scan (that is, it starts at a
    // fractional GIQ coordinate), advance it to the first pixel scan it
    // intersects. Ditto if there's top clipping. Also clip to the bottom if
    // needed

    if (iYStart != yTop) {
        // Jump ahead by the Y distance in GIQ coordinates to the first pixel
        // to draw
        yJump = yTop - iYStart;

        // Advance x the minimum amount for the number of scans traversed
        iXStart += pFreeEdge->iXWhole * yJump;

        AdjustErrorTerm(&pFreeEdge->iErrorTerm, pFreeEdge->iErrorAdjustUp,
                        pFreeEdge->iErrorAdjustDown, yJump, &iXStart,
                        pFreeEdge->iXDirection);
    }
    // Turn the calculations into pixel rather than GIQ calculations

    // Move the X coordinate to the nearest pixel, and adjust the error term
    // accordingly
    // Dividing by 16 with a shift is okay because X is always positive
    pFreeEdge->X = (iXStart + 15) >> 4; // convert from GIQ to pixel coordinates

    // LATER adjust only if needed (if prestepped above)?
    if (pFreeEdge->iXDirection == 1) {
        // Left to right
        pFreeEdge->iErrorTerm -= pFreeEdge->iErrorAdjustDown *
                (((iXStart + 15) & ~0x0F) - iXStart);
    } else {
        // Right to left
        pFreeEdge->iErrorTerm -= pFreeEdge->iErrorAdjustDown *
                ((iXStart - 1) & 0x0F);
    }

    // Scale the error term down 16 times to switch from GIQ to pixels.
    // Shifts work to do the multiplying because these values are always
    // non-negative
    pFreeEdge->iErrorTerm >>= 4;

    // Insert the edge into the GET in YX-sorted order. The search always ends
    // because the GET has a sentinel with a greater-than-possible Y value
    while ((pFreeEdge->Y > ((EDGE *)pGETHead->pNext)->Y) ||
            ((pFreeEdge->Y == ((EDGE *)pGETHead->pNext)->Y) &&
            (pFreeEdge->X > ((EDGE *)pGETHead->pNext)->X))) {
        pGETHead = pGETHead->pNext;
    }

    pFreeEdge->pNext = pGETHead->pNext; // link the edge into the GET
    pGETHead->pNext = pFreeEdge;

    return(++pFreeEdge);    // point to the next edge storage location for next
                            //  time
}

// Adjust the error term for a skip ahead in y. This is in ASM because there's
// a multiply/divide that may involve a larger than 32-bit value.

void AdjustErrorTerm(INT *pErrorTerm, INT iErrorAdjustUp, INT iErrorAdjustDown,
        INT yJump, INT *pXStart, INT iXDirection)
{
#if defined(_X86_) || defined(i386)
    // Adjust the error term up by the number of y coordinates we'll skip
    //*pErrorTerm += iErrorAdjustUp * yJump;
    _asm    mov ebx,pErrorTerm
    _asm    mov eax,iErrorAdjustUp
    _asm    mul yJump
    _asm    add eax,[ebx]
    _asm    adc edx,-1      // the error term starts out negative

    // See if the error term turned over even once while skipping
    //if (*pErrorTerm >= 0) {
    _asm    js  short NoErrorTurnover

        // # of times we'll turn over the error term and step an extra x
        // coordinate while skipping
        // NumAdjustDowns = (*pErrorTerm / iErrorAdjustDown) + 1;
        _asm    div iErrorAdjustDown
        _asm    inc eax
        // Note that EDX is the remainder; (EDX - iErrorAdjustDown) is where
        // the error term ends up ultimately

        // Advance x appropriately for the # of times the error term
        // turned over
        // if (iXDirection == 1) {
        //     *pXStart += NumAdjustDowns;
        // } else {
        //     *pXStart -= NumAdjustDowns;
        // }
        _asm    mov ecx,pXStart
        _asm    cmp iXDirection,1
        _asm    jz  short GoingRight
        _asm    neg eax
GoingRight:
        _asm    add [ecx],eax

        // Adjust the error term down to its proper post-skip value
        // *pErrorTerm -= iErrorAdjustDown * NumAdjustDowns;
        _asm    sub edx,iErrorAdjustDown
        _asm    mov eax,edx     // put into EAX for storing to pErrorTerm next
        // }
NoErrorTurnover:
        _asm    mov [ebx],eax
#else

    LONGLONG llErrorTerm;
    INT NumAdjustDowns;

    llErrorTerm = *pErrorTerm;

    // Adjust the error term up by the number of y coordinates we'll skip
    llErrorTerm += Int32x32To64(iErrorAdjustUp,yJump);

    // See if the error term turned over even once while skipping
    if (llErrorTerm >= 0) {
        // # of times we'll turn over the error term and step an extra x
        // coordinate while skipping
        NumAdjustDowns = (UInt64Div32To32(llErrorTerm,iErrorAdjustDown)) + 1;

        // Advance x appropriately for the # of times the error term
        // turned over
        if (iXDirection == 1) {
            *pXStart += NumAdjustDowns;
        } else {
            *pXStart -= NumAdjustDowns;
        }

        // Adjust the error term down to its proper post-skip value
        llErrorTerm -= iErrorAdjustDown * NumAdjustDowns;
    }

    *pErrorTerm = (INT) llErrorTerm;
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\cirrus\disp\heap.c ===
/******************************************************************************\
*
* $Workfile:   heap.c  $
*
* This module contains the routines for a 2-d heap.  It is used primarily
* for allocating space for device-format-bitmaps in off-screen memory.
*
* Off-screen bitmaps are a big deal on NT because:
*
*    1) It reduces the working set.  Any bitmap stored in off-screen
*       memory is a bitmap that isn't taking up space in main memory.
*
*    2) There is a speed win by using the accelerator hardware for
*       drawing, in place of NT's GDI code.  NT's GDI is written entirely
*       in 'C++' and perhaps isn't as fast as it could be.
*
*    3) It leads naturally to nifty tricks that can take advantage of
*       the hardware, such as MaskBlt support and cheap double buffering
*       for OpenGL.
*
* The heap algorithm employed herein attempts to solve an unsolvable
* problem: the problem of keeping arbitrary sized bitmaps as packed as
* possible in a 2-d space, when the bitmaps can come and go at random.
*
* This problem is due entirely to the nature of the hardware for which this
* driver is written: the hardware treats everything as 2-d quantities.  If
* the hardware bitmap pitch could be changed so that the bitmaps could be
* packed linearly in memory, the problem would be infinitely easier (it is
* much easier to track the memory, and the accelerator can be used to re-pack
* the heap to avoid segmentation).
*
* If your hardware can treat bitmaps as one dimensional quantities (as can
* the XGA and ATI), by all means please implement a new off-screen heap.
*
* When the heap gets full, old allocations will automatically be punted
* from off-screen and copied to DIBs, which we'll let GDI draw on.
*
* Note that this heap manages reverse-L shape off-screen memory
* configurations (where the scan pitch is longer than the visible screen,
* such as happens at 800x600 when the scan length must be a multiple of
* 1024).
*
* NOTE: All heap operations must be done under some sort of synchronization,
*       whether it's controlled by GDI or explicitly by the driver.  All
*       the routines in this module assume that they have exclusive access
*       to the heap data structures; multiple threads partying in here at
*       the same time would be a Bad Thing.  (By default, GDI does NOT
*       synchronize drawing on device-created bitmaps.)
*
* Copyright (c) 1993-1995 Microsoft Corporation
* Copyright (c) 1996 Cirrus Logic, Inc.
*
* $Log:   S:/projects/drivers/ntsrc/display/heap.c_v  $
 * 
 *    Rev 1.3   Apr 03 1997 15:38:54   unknown
 *  
 *
 *    Rev 1.2   28 Mar 1997 16:08:50   PLCHU
 *
 *
 *    Rev 1.1   Oct 10 1996 15:37:42   unknown
 *
*
*    Rev 1.8   12 Aug 1996 17:11:22   frido
* hp#1 - Commented new heap stuff.
* hp#2 - Keep enough memory for WinBench bitmap.
*
*    Rev 1.7   12 Aug 1996 16:53:30   frido
* Added NT 3.5x/4.0 auto detection.
*
*    Rev 1.6   23 Jul 1996 17:48:38   frido
* Removed creation of small device bitmaps.
* Never reject the WinBench bitmap!
*
*    Rev 1.5   16 Jul 1996 18:55:52   frido
* Changed splitting of new block to cause less fragmentation.
*
* pat04: 12-20-96 : Supported NT3.51 software cursor with panning scrolling
* pat08: 04-01-97 : SW cursor problem due to code merge. Frido had turned
*                   of allocation of small device bitmaps for optimization,
*                   --- winnt to return a null ptr to a color bitmap mask.
*
\******************************************************************************/

#include "precomp.h"

#define OH_ALLOC_SIZE   4000        // Do all memory allocations in 4k chunks
#define OH_QUANTUM      8           // The minimum dimension of an allocation
#define CXCY_SENTINEL   0x7fffffff  // The sentinel at the end of the available
                                    //  list has this very large 'cxcy' value

// This macro results in the available list being maintained with a
// cx-major, cy-minor sort:

#define CXCY(cx, cy) (((cx) << 16) | (cy))

#if DBG
    BOOL gbEnableDFB = TRUE;
#endif

/******************************Public*Routine******************************\
* OH* pohNewNode
*
* Allocates a basic memory unit in which we'll pack our data structures.
*
* Since we'll have a lot of OH nodes, most of which we will be
* occasionally traversing, we do our own memory allocation scheme to
* keep them densely packed in memory.
*
* It would be the worst possible thing for the working set to simply
* call EngAllocMem(sizeof(OH)) every time we needed a new node.  There
* would be no locality; OH nodes would get scattered throughout memory,
* and as we traversed the available list for one of our allocations,
* it would be far more likely that we would hit a hard page fault.
\**************************************************************************/

OH* pohNewNode(
PDEV*   ppdev)
{
    LONG     i;
    LONG     cOhs;
    OHALLOC* poha;
    OH*      poh;

    if (ppdev->heap.pohFreeList == NULL)
    {
        // We zero-init to initialize all the OH flags, and to help in
        // debugging (we can afford to do this since we'll be doing this
        // very infrequently):

        poha = ALLOC(OH_ALLOC_SIZE);
        if (poha == NULL)
            return(NULL);

        // Insert this OHALLOC at the begining of the OHALLOC chain:

        poha->pohaNext  = ppdev->heap.pohaChain;
        ppdev->heap.pohaChain = poha;

        // This has a '+ 1' because OHALLOC includes an extra OH in its
        // structure declaration:

        cOhs = (OH_ALLOC_SIZE - sizeof(OHALLOC)) / sizeof(OH) + 1;

        // The big OHALLOC allocation is simply a container for a bunch of
        // OH data structures in an array.  The new OH data structures are
        // linked together and added to the OH free list:

        poh = &poha->aoh[0];
        for (i = cOhs - 1; i != 0; i--)
        {
            poh->pohNext = poh + 1;
            poh          = poh + 1;
        }

        poh->pohNext      = NULL;
        ppdev->heap.pohFreeList = &poha->aoh[0];
    }

    poh = ppdev->heap.pohFreeList;
    ppdev->heap.pohFreeList = poh->pohNext;

    return(poh);
}

/******************************Public*Routine******************************\
* VOID vOhFreeNode
*
* Frees our basic data structure allocation unit by adding it to a free
* list.
*
\**************************************************************************/

VOID vOhFreeNode(
PDEV*   ppdev,
OH*     poh)
{
    if (poh == NULL)
        return;

    poh->pohNext            = ppdev->heap.pohFreeList;
    ppdev->heap.pohFreeList = poh;
    poh->ofl                = 0;
}

/******************************Public*Routine******************************\
* OH* pohFree
*
* Frees an off-screen heap allocation.  The free space will be combined
* with any adjacent free spaces to avoid segmentation of the 2-d heap.
*
* Note: A key idea here is that the data structure for the upper-left-
*       most node must be kept at the same physical CPU memory so that
*       adjacency links are kept correctly (when two free spaces are
*       merged, the lower or right node can be freed).
*
\**************************************************************************/

OH* pohFree(
PDEV*   ppdev,
OH*     poh)
{
    ULONG cxcy;
    OH*   pohBeside;
    OH*   pohNext;
    OH*   pohPrev;
#if 1 //hp#1
    BOOL  bUpdate;
#endif

    if (poh == NULL)
        return(NULL);

#if 1 //hp#1
    bUpdate = (poh->ofl & OFL_PERMANENT) != 0;
#endif

    DISPDBG((4, "Freeing %d x %d at (%d, %d)", poh->cx, poh->cy, poh->x,
             poh->y));

    #if DEBUG_HEAP
    {
        RECTL           rclBitmap;
        RBRUSH_COLOR    rbc;
        LONG            xOffset;
        LONG            yOffset;
        LONG            xyOffset;

        rclBitmap.left   = poh->x;
        rclBitmap.top    = poh->y;
        rclBitmap.right  = poh->x + poh->cx;
        rclBitmap.bottom = poh->y + poh->cy;

        xOffset  = ppdev->xOffset;
        yOffset  = ppdev->yOffset;
        xyOffset = ppdev->xyOffset;

        ppdev->xOffset  = 0;
        ppdev->yOffset  = 0;
        ppdev->xyOffset = 0;

        ppdev->pfnFillSolid(ppdev, 1, &rclBitmap, 0x0, rbc, NULL);

        ppdev->xOffset  = xOffset;
        ppdev->yOffset  = yOffset;
        ppdev->xyOffset = xyOffset;
    }
    #endif

    // Update the uniqueness to show that space has been freed, so that
    // we may decide to see if some DIBs can be moved back into off-screen
    // memory:

    ppdev->iHeapUniq++;

MergeLoop:

#if 0 //hp#1
    ASSERTDD(!(poh->ofl & OFL_PERMANENT), "Can't free permanents for now");
#endif

    // Try merging with the right sibling:

    pohBeside = poh->pohRight;
    if ((pohBeside->ofl & OFL_AVAILABLE)        &&
        (pohBeside->cy      == poh->cy)         &&
        (pohBeside->pohUp   == poh->pohUp)      &&
        (pohBeside->pohDown == poh->pohDown)    &&
        (pohBeside->pohRight->pohLeft != pohBeside))
    {
        // Add the right rectangle to ours:

        poh->cx      += pohBeside->cx;
        poh->pohRight = pohBeside->pohRight;

        // Remove 'pohBeside' from the ??? list and free it:

        pohBeside->pohNext->pohPrev = pohBeside->pohPrev;
        pohBeside->pohPrev->pohNext = pohBeside->pohNext;

        vOhFreeNode(ppdev, pohBeside);
        goto MergeLoop;
    }

    // Try merging with the lower sibling:

    pohBeside = poh->pohDown;
    if ((pohBeside->ofl & OFL_AVAILABLE)        &&
        (pohBeside->cx       == poh->cx)        &&
        (pohBeside->pohLeft  == poh->pohLeft)   &&
        (pohBeside->pohRight == poh->pohRight)  &&
        (pohBeside->pohDown->pohUp != pohBeside))
    {
        poh->cy     += pohBeside->cy;
        poh->pohDown = pohBeside->pohDown;

        pohBeside->pohNext->pohPrev = pohBeside->pohPrev;
        pohBeside->pohPrev->pohNext = pohBeside->pohNext;

        vOhFreeNode(ppdev, pohBeside);
        goto MergeLoop;
    }

    // Try merging with the left sibling:

    pohBeside = poh->pohLeft;
    if ((pohBeside->ofl & OFL_AVAILABLE)        &&
        (pohBeside->cy       == poh->cy)        &&
        (pohBeside->pohUp    == poh->pohUp)     &&
        (pohBeside->pohDown  == poh->pohDown)   &&
        (pohBeside->pohRight == poh)            &&
        (poh->pohRight->pohLeft != poh))
    {
        // We add our rectangle to the one to the left:

        pohBeside->cx      += poh->cx;
        pohBeside->pohRight = poh->pohRight;

        // Remove 'poh' from the ??? list and free it:

        poh->pohNext->pohPrev = poh->pohPrev;
        poh->pohPrev->pohNext = poh->pohNext;

        vOhFreeNode(ppdev, poh);

        poh = pohBeside;
        goto MergeLoop;
    }

    // Try merging with the upper sibling:

    pohBeside = poh->pohUp;
    if ((pohBeside->ofl & OFL_AVAILABLE)        &&
        (pohBeside->cx       == poh->cx)        &&
        (pohBeside->pohLeft  == poh->pohLeft)   &&
        (pohBeside->pohRight == poh->pohRight)  &&
        (pohBeside->pohDown  == poh)            &&
        (poh->pohDown->pohUp != poh))
    {
        pohBeside->cy      += poh->cy;
        pohBeside->pohDown  = poh->pohDown;

        poh->pohNext->pohPrev = poh->pohPrev;
        poh->pohPrev->pohNext = poh->pohNext;

        vOhFreeNode(ppdev, poh);

        poh = pohBeside;
        goto MergeLoop;
    }

    // Remove the node from the ???list if it was in use (we wouldn't
    // want to do this for a OFL_PERMANENT node that had been freed):

    poh->pohNext->pohPrev = poh->pohPrev;
    poh->pohPrev->pohNext = poh->pohNext;

    cxcy = CXCY(poh->cx, poh->cy);

    // Insert the node into the available list:

    pohNext = ppdev->heap.ohAvailable.pohNext;
    while (pohNext->cxcy < cxcy)
    {
        pohNext = pohNext->pohNext;
    }
    pohPrev = pohNext->pohPrev;

    pohPrev->pohNext = poh;
    pohNext->pohPrev = poh;
    poh->pohPrev     = pohPrev;
    poh->pohNext     = pohNext;
    poh->ofl         = OFL_AVAILABLE;
    poh->cxcy        = cxcy;

#if 1 //hp#1
    if (bUpdate)
    {
        vCalculateMaximum(ppdev);
    }
#endif

    // Return the node pointer for the new and improved available rectangle:
    return(poh);
}

/******************************Public*Routine******************************\
* OH* pohAllocate
*
* Allocates space for an off-screen rectangle.  It will attempt to find
* the smallest available free rectangle, and will allocate the block out
* of its upper-left corner.  The remaining two rectangles will be placed
* on the available free space list.
*
* If the rectangle would have been large enough to fit into off-screen
* memory, but there is not enough available free space, we will boot
* bitmaps out of off-screen and into DIBs until there is enough room.
*
\**************************************************************************/

OH* pohAllocate(
PDEV*   ppdev,
LONG    cxThis,             // Width of rectangle to be allocated
LONG    cyThis,             // Height of rectangle to be allocated
FLOH    floh)               // Allocation flags
{
    ULONG cxcyThis;         // Width and height search key
    OH*   pohThis;          // Points to found available rectangle we'll use
    ULONG cxcy;             // Temporary versions
    OH*   pohNext;
    OH*   pohPrev;

    LONG  cxRem;
    LONG  cyRem;

    OH*   pohBelow;
    LONG  cxBelow;
    LONG  cyBelow;

    OH*   pohBeside;
    LONG  cxBeside;
    LONG  cyBeside;

    DISPDBG((4, "Allocating %d x %d...", cxThis, cyThis));

    ASSERTDD((cxThis > 0) && (cyThis > 0), "Illegal allocation size");

    // Increase the width to get the proper alignment (thus ensuring that all
    // allocations will be properly aligned):

    cxThis = (cxThis + (HEAP_X_ALIGNMENT - 1)) & ~(HEAP_X_ALIGNMENT - 1);

    // We can't succeed if the requested rectangle is larger than the
    // largest possible available rectangle:

    if ((cxThis > ppdev->heap.cxMax) || (cyThis > ppdev->heap.cyMax))
    {
#if 1 //hp#2
        if ((cxThis != 400) && (cyThis != 90))
#endif
        {
            DISPDBG((4, "Failing pohAllocate... rectangle is larger than max allowed"));
            DISPDBG((4, "max = (%d,%d)", ppdev->heap.cxMax, ppdev->heap.cyMax));
            DISPDBG((4, "req = (%d,%d)", cxThis, cyThis));
            return(NULL);
        }
    }

    // Find the first available rectangle the same size or larger than
    // the requested one:

    cxcyThis = CXCY(cxThis, cyThis);
    pohThis  = ppdev->heap.ohAvailable.pohNext;
    while (pohThis->cxcy < cxcyThis)
    {
        pohThis = pohThis->pohNext;
    }

    while (pohThis->cy < cyThis)
    {
        pohThis = pohThis->pohNext;
    }

    if (pohThis->cxcy == CXCY_SENTINEL)
    {
        // There was no space large enough...

        if (floh & FLOH_ONLY_IF_ROOM)
        {
            DISPDBG((4, "Failing pohAllocate... no space large enough"));
            DISPDBG((4, "req = (%d,%d)", cxThis, cyThis));
            return(NULL);
        }

        // We couldn't find an available rectangle that was big enough
        // to fit our request.  So throw things out of the heap until we
        // have room:

        do {
            pohThis = ppdev->heap.ohDfb.pohPrev;  // Least-recently blitted

            ASSERTDD(pohThis != &ppdev->heap.ohDfb, "Ran out of in-use entries");

#if 1 //hp#1
            while (pohThis->ofl == OFL_PERMANENT)
            {
                pohThis = pohThis->pohPrev;
                if (pohThis == &ppdev->heap.ohDfb)
                {
                    DISPDBG((4, "Failing pohAllocate... not enough memory"));
                    DISPDBG((4, "req = (%d,%d)", cxThis, cyThis));
                    return(NULL);
                }
            }
#endif
            // We can safely exit here if we have to:

            pohThis = pohMoveOffscreenDfbToDib(ppdev, pohThis);
            if (pohThis == NULL)
            {
                DISPDBG((4, "Failing pohAllocate... failed to eject a dfb"));
                DISPDBG((4, "req = (%d,%d)", cxThis, cyThis));
                return(NULL);
            }

        } while ((pohThis->cx < cxThis) || (pohThis->cy < cyThis));
    }

    // We've now found an available rectangle that is the same size or
    // bigger than our requested rectangle.  We're going to use the
    // upper-left corner of our found rectangle, and divide the unused
    // remainder into two rectangles which will go on the available
    // list.

    // Compute the width of the unused rectangle to the right, and the
    // height of the unused rectangle below:

    cyRem = pohThis->cy - cyThis;
    cxRem = pohThis->cx - cxThis;

    // Given finite area, we wish to find the two rectangles that are
    // most square -- i.e., the arrangement that gives two rectangles
    // with the least perimiter:

    cyBelow  = cyRem;
    cxBeside = cxRem;

#if 1 //hp#1
    if ((cxRem <= cyRem) || (pohThis->cx >= ppdev->cxScreen))
#else
    if (cxRem <= cyRem)
#endif
    {
        cxBelow  = cxThis + cxRem;
        cyBeside = cyThis;
    }
    else
    {
        cxBelow  = cxThis;
        cyBeside = cyThis + cyRem;
    }

    // We only make new available rectangles of the unused right and bottom
    // portions if they're greater in dimension than OH_QUANTUM (it hardly
    // makes sense to do the book-work to keep around a 2-pixel wide
    // available space, for example):

    pohBeside = NULL;
    if (cxBeside >= OH_QUANTUM)
    {
        pohBeside = pohNewNode(ppdev);
        if (pohBeside == NULL)
            return(NULL);
    }

    pohBelow = NULL;
    if (cyBelow >= OH_QUANTUM)
    {
        pohBelow = pohNewNode(ppdev);
        if (pohBelow == NULL)
        {
            vOhFreeNode(ppdev, pohBeside);
            return(NULL);
        }

        // Insert this rectangle into the available list (which is
        // sorted on ascending cxcy):

        cxcy    = CXCY(cxBelow, cyBelow);
        pohNext = ppdev->heap.ohAvailable.pohNext;
        while (pohNext->cxcy < cxcy)
        {
            pohNext = pohNext->pohNext;
        }
        pohPrev = pohNext->pohPrev;

        pohPrev->pohNext  = pohBelow;
        pohNext->pohPrev  = pohBelow;
        pohBelow->pohPrev = pohPrev;
        pohBelow->pohNext = pohNext;

        // Now update the adjacency information:

        pohBelow->pohLeft  = pohThis->pohLeft;
        pohBelow->pohUp    = pohThis;
        pohBelow->pohRight = pohThis->pohRight;
        pohBelow->pohDown  = pohThis->pohDown;

        // Update the rest of the new node information:

        pohBelow->cxcy = cxcy;
        pohBelow->ofl  = OFL_AVAILABLE;

        pohBelow->x    = pohThis->x;
        pohBelow->y    = pohThis->y + cyThis;
        pohBelow->xy   = PELS_TO_BYTES(pohBelow->x)
                       + (pohBelow->y * ppdev->lDelta);

        pohBelow->cx   = cxBelow;
        pohBelow->cy   = cyBelow;

        // Modify the current node to reflect the changes we've made:

        pohThis->cy = cyThis;
    }

    if (cxBeside >= OH_QUANTUM)
    {
        // Insert this rectangle into the available list (which is
        // sorted on ascending cxcy):

        cxcy    = CXCY(cxBeside, cyBeside);
        pohNext = ppdev->heap.ohAvailable.pohNext;
        while (pohNext->cxcy < cxcy)
        {
            pohNext = pohNext->pohNext;
        }
        pohPrev = pohNext->pohPrev;

        pohPrev->pohNext   = pohBeside;
        pohNext->pohPrev   = pohBeside;
        pohBeside->pohPrev = pohPrev;
        pohBeside->pohNext = pohNext;

        // Now update the adjacency information:

        pohBeside->pohUp    = pohThis->pohUp;
        pohBeside->pohLeft  = pohThis;
        pohBeside->pohDown  = pohThis->pohDown;
        pohBeside->pohRight = pohThis->pohRight;

        // Update the rest of the new node information:

        pohBeside->cxcy = cxcy;
        pohBeside->ofl  = OFL_AVAILABLE;

        pohBeside->x    = pohThis->x + cxThis;
        pohBeside->y    = pohThis->y;
        pohBeside->xy   = PELS_TO_BYTES(pohBeside->x)
                        + (pohBeside->y * ppdev->lDelta);

        pohBeside->cx   = cxBeside;
        pohBeside->cy   = cyBeside;

        // Modify the current node to reflect the changes we've made:

        pohThis->cx = cxThis;
    }

    if (pohBelow != NULL)
    {
        pohThis->pohDown = pohBelow;
        if ((pohBeside != NULL) && (cyBeside == pohThis->cy))
            pohBeside->pohDown = pohBelow;
    }
    if (pohBeside != NULL)
    {
        pohThis->pohRight = pohBeside;
        if ((pohBelow != NULL) && (cxBelow == pohThis->cx))
            pohBelow->pohRight  = pohBeside;
    }

    pohThis->ofl    = OFL_INUSE;
    pohThis->cxcy   = CXCY(pohThis->cx, pohThis->cy);
    pohThis->pdsurf = NULL; // Caller is responsible for setting this field

    // Remove this from the available list:

    pohThis->pohPrev->pohNext = pohThis->pohNext;
    pohThis->pohNext->pohPrev = pohThis->pohPrev;

    // Now insert this at the head of the DFB list:

    pohThis->pohNext                   = ppdev->heap.ohDfb.pohNext;
    pohThis->pohPrev                   = &ppdev->heap.ohDfb;
    ppdev->heap.ohDfb.pohNext->pohPrev = pohThis;
    ppdev->heap.ohDfb.pohNext          = pohThis;

    DISPDBG((4, "   Allocated at (%d, %d)", pohThis->x, pohThis->y));

    // Calculate the effective start address for this bitmap in off-
    // screen memory:

    pohThis->pvScan0 = ppdev->pjScreen + (pohThis->y * ppdev->lDelta)
                                       + PELS_TO_BYTES(pohThis->x);
    return(pohThis);
}

/******************************Public*Routine******************************\
* VOID vCalculateMaxmimum
*
* Traverses the list of in-use and available rectangles to find the one
* with the maximal area.
*
\**************************************************************************/
VOID vCalculateMaximum(
PDEV*   ppdev)
{
    OH*     poh;
    OH*     pohSentinel;
    LONG    lArea;
    LONG    lMaxArea;
    LONG    cxMax;
    LONG    cyMax;
    LONG    i;

    lMaxArea = 0;
    cxMax    = 0;
    cyMax    = 0;

    // First time through, loop through the list of available rectangles:

    pohSentinel = &ppdev->heap.ohAvailable;

    for (i = 2; i != 0; i--)
    {
        for (poh = pohSentinel->pohNext; poh != pohSentinel; poh = poh->pohNext)
        {
#if 1 //hp#1
            if (poh->ofl & OFL_PERMANENT)
            {
                continue;
            }
#else
            ASSERTDD(!(poh->ofl & OFL_PERMANENT),
                     "Permanent in available/DFB chain?");
#endif

            // We don't have worry about this multiply overflowing
            // because we are dealing in physical screen coordinates,
            // which will probably never be more than 15 bits:

            lArea = poh->cx * poh->cy;
            if (lArea > lMaxArea)
            {
                cxMax    = poh->cx;
                cyMax    = poh->cy;
                lMaxArea = lArea;
            }
        }

        // Second time through, loop through the list of in-use rectangles:

        pohSentinel = &ppdev->heap.ohDfb;
    }

    // All that we are interested in is the dimensions of the rectangle
    // that has the largest possible available area (and remember that
    // there might not be any possible available area):

    ppdev->heap.cxMax = cxMax;
    ppdev->heap.cyMax = cyMax;

    DISPDBG((1, "Maximum heap: %d x %d", cxMax, cyMax));
}

/******************************Public*Routine******************************\
* OH* pohAllocatePermanent
*
* Allocates an off-screen rectangle that can never be booted of the heap.
* It's the caller's responsibility to manage the rectangle, which includes
* what to do with the memory in DrvAssertMode when the display is changed
* to full-screen mode.
*
\**************************************************************************/

OH* pohAllocatePermanent(
PDEV*   ppdev,
LONG    cx,
LONG    cy)
{
    OH*     poh;

    poh = pohAllocate(ppdev, cx, cy, 0);
    if (poh != NULL)
    {
        // Mark the rectangle as permanent:

        poh->ofl = OFL_PERMANENT;

#if 0 //hp#1
        // Remove the node from the most-recently blitted list:

        poh->pohPrev->pohNext = poh->pohNext;
        poh->pohNext->pohPrev = poh->pohPrev;
        poh->pohPrev = NULL;
        poh->pohNext = NULL;
#endif

        // Now calculate the new maximum size rectangle available in the
        // heap:
        vCalculateMaximum(ppdev);
    }

    return(poh);
}

/******************************Public*Routine******************************\
* BOOL bMoveDibToOffscreenDfbIfRoom
*
* Converts the DIB DFB to an off-screen DFB, if there's room for it in
* off-screen memory.
*
* Returns: FALSE if there wasn't room, TRUE if successfully moved.
*
\**************************************************************************/

BOOL bMoveDibToOffscreenDfbIfRoom(
PDEV*   ppdev,
DSURF*  pdsurf)
{
    OH*         poh;
    SURFOBJ*    pso;
    RECTL       rclDst;
    POINTL      ptlSrc;
    HSURF       hsurf;

    ASSERTDD(pdsurf->dt == DT_DIB,
             "Can't move a bitmap off-screen when it's already off-screen");

    DISPDBG((4, "Trying to reload %d x %d surface", pdsurf->sizl.cx,
             pdsurf->sizl.cy));

    // If we're in full-screen mode, we can't move anything to off-screen
    // memory:

    if (!ppdev->bEnabled)
        return(FALSE);

    poh = pohAllocate(ppdev, pdsurf->sizl.cx, pdsurf->sizl.cy,
                      FLOH_ONLY_IF_ROOM);
    if (poh == NULL)
    {
        // There wasn't any free room.

        return(FALSE);
    }

    // 'pdsurf->sizl' is the actual bitmap dimension, not 'poh->cx' or
    // 'poh->cy'.

    rclDst.left   = poh->x;
    rclDst.top    = poh->y;
    rclDst.right  = rclDst.left + pdsurf->sizl.cx;
    rclDst.bottom = rclDst.top  + pdsurf->sizl.cy;

    ptlSrc.x      = 0;
    ptlSrc.y      = 0;

    ppdev->pfnPutBits(ppdev, pdsurf->pso, &rclDst, &ptlSrc);

    // Update the data structures to reflect the new off-screen node:

    pso           = pdsurf->pso;
    pdsurf->dt    = DT_SCREEN;
    pdsurf->poh   = poh;
    poh->pdsurf   = pdsurf;

    // Now free the DIB.  Get the hsurf from the SURFOBJ before we unlock
    // it (it's not legal to dereference psoDib when it's unlocked):

    hsurf = pso->hsurf;
    EngUnlockSurface(pso);
    EngDeleteSurface(hsurf);

    return(TRUE);
}

/******************************Public*Routine******************************\
* OH* pohMoveOffscreenDfbToDib
*
* Converts the DFB from being off-screen to being a DIB.
*
* Note: The caller does NOT have to call 'pohFree' on 'poh' after making
*       this call.
*
* Returns: NULL if the function failed (due to a memory allocation).
*          Otherwise, it returns a pointer to the coalesced off-screen heap
*          node that has been made available for subsequent allocations
*          (useful when trying to free enough memory to make a new
*          allocation).
\**************************************************************************/

OH* pohMoveOffscreenDfbToDib(
PDEV*   ppdev,
OH*     poh)
{
    DSURF*   pdsurf;
    HBITMAP  hbmDib;
    SURFOBJ* pso;
    RECTL    rclDst;
    POINTL   ptlSrc;

    DISPDBG((4, "Throwing out %li x %li at (%li, %li)!",
                 poh->cx, poh->cy, poh->x, poh->y));

#if 1 //hp#1
    if (poh->ofl & OFL_PERMANENT)
    {
        return(NULL);
    }
#endif

    pdsurf = poh->pdsurf;

    ASSERTDD((poh->x != 0) || (poh->y != 0),
            "Can't make the visible screen into a DIB");
    ASSERTDD(pdsurf->dt != DT_DIB,
            "Can't make a DIB into even more of a DIB");

    hbmDib = EngCreateBitmap(pdsurf->sizl, 0, ppdev->iBitmapFormat,
                             BMF_TOPDOWN, NULL);
    if (hbmDib)
    {
        if (EngAssociateSurface((HSURF) hbmDib, ppdev->hdevEng, 0))
        {
            pso = EngLockSurface((HSURF) hbmDib);
            if (pso != NULL)
            {
                rclDst.left   = 0;
                rclDst.top    = 0;
                rclDst.right  = pdsurf->sizl.cx;
                rclDst.bottom = pdsurf->sizl.cy;

                ptlSrc.x      = poh->x;
                ptlSrc.y      = poh->y;

                ppdev->pfnGetBits(ppdev, pso, &rclDst, &ptlSrc);

                pdsurf->dt    = DT_DIB;
                pdsurf->pso   = pso;

                // Don't even bother checking to see if this DIB should
                // be put back into off-screen memory until the next
                // heap 'free' occurs:

                pdsurf->iUniq = ppdev->iHeapUniq;
                pdsurf->cBlt  = 0;

                // Remove this node from the off-screen DFB list, and free
                // it.  'pohFree' will never return NULL:

                return(pohFree(ppdev, poh));
            }
        }

        // Fail case:

        EngDeleteSurface((HSURF) hbmDib);
    }

    return(NULL);
}

/******************************Public*Routine******************************\
* BOOL bMoveEverythingFromOffscreenToDibs
*
* This function is used when we're about to enter full-screen mode, which
* would wipe all our off-screen bitmaps.  GDI can ask us to draw on
* device bitmaps even when we're in full-screen mode, and we do NOT have
* the option of stalling the call until we switch out of full-screen.
* We have no choice but to move all the off-screen DFBs to DIBs.
*
* Returns TRUE if all DSURFs have been successfully moved.
*
\**************************************************************************/

BOOL bMoveAllDfbsFromOffscreenToDibs(
PDEV*   ppdev)
{
    OH*  poh;
    OH*  pohNext;
    BOOL bRet;

    bRet = TRUE;
    poh  = ppdev->heap.ohDfb.pohNext;
    while (poh != &ppdev->heap.ohDfb)
    {
        pohNext = poh->pohNext;

        // If something's already a DIB, we shouldn't try to make it even
        // more of a DIB:

#if 1 //hp#1
        if (!(poh->ofl & OFL_PERMANENT) && (poh->pdsurf->dt == DT_SCREEN))
#else
        if (poh->pdsurf->dt == DT_SCREEN)
#endif
        {
            if (!pohMoveOffscreenDfbToDib(ppdev, poh))
                bRet = FALSE;
        }

        poh = pohNext;
    }

    return(bRet);
}

/******************************Public*Routine******************************\
* HBITMAP DrvCreateDeviceBitmap
*
* Function called by GDI to create a device-format-bitmap (DFB).  We will
* always try to allocate the bitmap in off-screen; if we can't, we simply
* fail the call and GDI will create and manage the bitmap itself.
*
* Note: We do not have to zero the bitmap bits.  GDI will automatically
*       call us via DrvBitBlt to zero the bits (which is a security
*       consideration).
*
\**************************************************************************/

HBITMAP DrvCreateDeviceBitmap(
DHPDEV  dhpdev,
SIZEL   sizl,
ULONG   iFormat)
{
    PDEV*   ppdev;
    OH*     poh;
    DSURF*  pdsurf;
    HBITMAP hbmDevice;

    ppdev = (PDEV*) dhpdev;

    // If we're in full-screen mode, we hardly have any off-screen memory
    // in which to allocate a DFB.  LATER: We could still allocate an
    // OH node and put the bitmap on the DIB DFB list for later promotion.

    if (!ppdev->bEnabled)
        return(0);

#if DBG
    if(!gbEnableDFB)
        return(0);
#endif

#if (_WIN32_WINNT >= 0x0400) //#pat08

#if 1 //hp#2
    if ((sizl.cx < 20) || ((sizl.cx >= 32) && (sizl.cx < 100)))
    {
        return(0);
    }
#endif
//pat08 begin
#else
    if ((ppdev->ulChipID != CL7541_ID) && (ppdev->ulChipID == CL7543_ID) &&
        (ppdev->ulChipID != CL7542_ID) && (ppdev->ulChipID == CL7548_ID) &&
        (ppdev->ulChipID != CL7555_ID) && (ppdev->ulChipID == CL7556_ID))
    {
#if 1 //hp#2
         if ((sizl.cx < 20) || ((sizl.cx >= 32) && (sizl.cx < 100)))
         {
             return(0);
         }
#endif
    }
#endif
//pat08 end

    // We only support device bitmaps that are the same colour depth
    // as our display.
    //
    // Actually, those are the only kind GDI will ever call us with,
    // but we may as well check.  Note that this implies you'll never
    // get a crack at 1bpp bitmaps.

    if (iFormat != ppdev->iBitmapFormat)
        return(0);

    // We don't want anything 8x8 or smaller -- they're typically brush
    // patterns which we don't particularly want to stash in off-screen
    // memory:

    if ((sizl.cx <= 8) && (sizl.cy <= 8))
        return(0);

    poh = pohAllocate(ppdev, sizl.cx, sizl.cy, 0);
    if (poh != NULL)
    {
        pdsurf = ALLOC(sizeof(DSURF));
        if (pdsurf != NULL)
        {
            hbmDevice = EngCreateDeviceBitmap((DHSURF) pdsurf, sizl, iFormat);
            if (hbmDevice != NULL)
            {
                if (EngAssociateSurface((HSURF) hbmDevice, ppdev->hdevEng,
                                        ppdev->flHooks))
                {
                    pdsurf->dt    = DT_SCREEN;
                    pdsurf->poh   = poh;
                    pdsurf->sizl  = sizl;
                    pdsurf->ppdev = ppdev;
                    poh->pdsurf   = pdsurf;

                    return(hbmDevice);
                }

                EngDeleteSurface((HSURF) hbmDevice);
            }
            FREE(pdsurf);
        }
        pohFree(ppdev, poh);
    }

    return(0);
}

/******************************Public*Routine******************************\
* VOID DrvDeleteDeviceBitmap
*
* Deletes a DFB.
*
\**************************************************************************/

VOID DrvDeleteDeviceBitmap(
DHSURF  dhsurf)
{
    DSURF*   pdsurf;
    PDEV*    ppdev;
    SURFOBJ* psoDib;
    HSURF    hsurfDib;

    pdsurf = (DSURF*) dhsurf;
    ppdev  = pdsurf->ppdev;

    if (pdsurf->dt == DT_SCREEN)
    {
        pohFree(ppdev, pdsurf->poh);
    }
    else
    {
        ASSERTDD(pdsurf->dt == DT_DIB, "Expected DIB type");

        psoDib = pdsurf->pso;

        // Get the hsurf from the SURFOBJ before we unlock it (it's not
        // legal to dereference psoDib when it's unlocked):

        hsurfDib = psoDib->hsurf;
        EngUnlockSurface(psoDib);
        EngDeleteSurface(hsurfDib);
    }

    FREE(pdsurf);
}

/******************************Public*Routine******************************\
* BOOL bAssertModeOffscreenHeap
*
* This function is called whenever we switch in or out of full-screen
* mode.  We have to convert all the off-screen bitmaps to DIBs when
* we switch to full-screen (because we may be asked to draw on them even
* when in full-screen, and the mode switch would probably nuke the video
* memory contents anyway).
*
\**************************************************************************/

BOOL bAssertModeOffscreenHeap(
PDEV*   ppdev,
BOOL    bEnable)
{
    BOOL b;

    b = TRUE;

    if (!bEnable)
    {
        b = bMoveAllDfbsFromOffscreenToDibs(ppdev);
    }

    return(b);
}

/******************************Public*Routine******************************\
* VOID vDisableOffscreenHeap
*
* Frees any resources allocated by the off-screen heap.
*
\**************************************************************************/

VOID vDisableOffscreenHeap(
PDEV*   ppdev)
{
    OHALLOC* poha;
    OHALLOC* pohaNext;
    SURFOBJ* psoPunt;
    HSURF    hsurf;

    psoPunt = ppdev->psoPunt;
    if (psoPunt != NULL)
    {
        hsurf = psoPunt->hsurf;
        EngUnlockSurface(psoPunt);
        EngDeleteSurface(hsurf);
    }

    psoPunt = ppdev->psoPunt2;
    if (psoPunt != NULL)
    {
        hsurf = psoPunt->hsurf;
        EngUnlockSurface(psoPunt);
        EngDeleteSurface(hsurf);
    }

    poha = ppdev->heap.pohaChain;
    while (poha != NULL)
    {
        pohaNext = poha->pohaNext;  // Grab the next pointer before it's freed
        FREE(poha);
        poha = pohaNext;
    }
}

/******************************Public*Routine******************************\
* BOOL bEnableOffscreenHeap
*
* Initializes the off-screen heap using all available video memory,
* accounting for the portion taken by the visible screen.
*
* Input: ppdev->cxScreen
*        ppdev->cyScreen
*        ppdev->cxMemory
*        ppdev->cyMemory
*
\**************************************************************************/

BOOL bEnableOffscreenHeap(
PDEV*   ppdev)
{
    OH*         poh;
    SIZEL       sizl;
    HSURF       hsurf;
    static      onetimealloc = 0;               //pat04
    FLONG       flPuntSurfaceHooks = ppdev->flHooks & ~HOOK_SYNCHRONIZE;

    DISPDBG((5, "Screen: %li x %li  Memory: %li x %li",
        ppdev->cxScreen, ppdev->cyScreen, ppdev->cxMemory, ppdev->cyMemory));

    ppdev->heap.pohaChain   = NULL;
    ppdev->heap.pohFreeList = NULL;

    // Initialize the available list, which will be a circular
    // doubly-linked list kept in ascending 'cxcy' order, with a
    // 'sentinel' at the end of the list:

    poh = pohNewNode(ppdev);
    if (poh == NULL)
        goto ReturnFalse;

    // The first node describes the entire video memory size:

    poh->pohNext  = &ppdev->heap.ohAvailable;
    poh->pohPrev  = &ppdev->heap.ohAvailable;
    poh->ofl      = OFL_AVAILABLE;
    poh->x        = 0;
    poh->y        = 0;
    poh->xy       = 0;
    poh->cx       = ppdev->cxMemory;
    poh->cy       = ppdev->cyMemory;
    poh->cxcy     = CXCY(ppdev->cxMemory, ppdev->cyMemory);
    poh->pohLeft  = &ppdev->heap.ohAvailable;
    poh->pohUp    = &ppdev->heap.ohAvailable;
    poh->pohRight = &ppdev->heap.ohAvailable;
    poh->pohDown  = &ppdev->heap.ohAvailable;
    poh->pvScan0  = ppdev->pjScreen;

    // The second node is our available list sentinel:

    ppdev->heap.ohAvailable.pohNext = poh;
    ppdev->heap.ohAvailable.pohPrev = poh;
    ppdev->heap.ohAvailable.cxcy    = CXCY_SENTINEL;
    ppdev->heap.ohAvailable.cx      = 0x7fffffff;
    ppdev->heap.ohAvailable.cy      = 0x7fffffff;
    ppdev->heap.ohAvailable.ofl     = OFL_PERMANENT;
    ppdev->heap.ohDfb.pohLeft       = NULL;
    ppdev->heap.ohDfb.pohUp         = NULL;
    ppdev->heap.ohDfb.pohRight      = NULL;
    ppdev->heap.ohDfb.pohDown       = NULL;

    // Initialize the most-recently-blitted DFB list, which will be
    // a circular doubly-linked list kept in order, with a sentinel at
    // the end.  This node is also used for the screen-surface, for its
    // offset:

    ppdev->heap.ohDfb.pohNext  = &ppdev->heap.ohDfb;
    ppdev->heap.ohDfb.pohPrev  = &ppdev->heap.ohDfb;
    ppdev->heap.ohDfb.ofl      = OFL_PERMANENT;

    // For the moment, make the max really big so that the first
    // allocation we're about to do will succeed:

    ppdev->heap.cxMax = 0x7fffffff;
    ppdev->heap.cyMax = 0x7fffffff;

    // Reserve the upper-left corner for the screen.

    poh = pohAllocatePermanent(ppdev, ppdev->cxScreen, ppdev->cyScreen);

    ppdev->pohScreen = poh;

    ASSERTDD((poh != NULL) && (poh->x == 0) && (poh->y == 0),
             "We assumed allocator would use the upper-left corner");

    // Allocate a 'punt' SURFOBJ we'll use when the device-bitmap is in
    // off-screen memory, but we want GDI to draw to it directly as an
    // engine-managed surface:

    sizl.cx = ppdev->cxMemory;
    sizl.cy = ppdev->cyMemory;

    // We want to create it with exactly the same hooks, capabilities,
    // and screen delta as our primary surface:

    hsurf = (HSURF) EngCreateBitmap(sizl,
                                    ppdev->lDelta,
                                    ppdev->iBitmapFormat,
                                    BMF_TOPDOWN,
                                    ppdev->pjScreen);

    if ((hsurf == 0)                                                  ||
        (!EngAssociateSurface(hsurf, ppdev->hdevEng, flPuntSurfaceHooks)) ||
        (!(ppdev->psoPunt = EngLockSurface(hsurf))))
    {
        DISPDBG((0, "Failed punt surface creation"));

        EngDeleteSurface(hsurf);
        goto ReturnFalse;
    }

    // We need another for doing DrvBitBlt and DrvCopyBits when both
    // surfaces are off-screen bitmaps:

    hsurf = (HSURF) EngCreateBitmap(sizl,
                                    ppdev->lDelta,
                                    ppdev->iBitmapFormat,
                                    BMF_TOPDOWN,
                                    ppdev->pjScreen);

    if ((hsurf == 0)                                                  ||
        (!EngAssociateSurface(hsurf, ppdev->hdevEng, flPuntSurfaceHooks)) ||
        (!(ppdev->psoPunt2 = EngLockSurface(hsurf))))
    {
        DISPDBG((0, "Failed punt surface creation"));

        EngDeleteSurface(hsurf);
        goto ReturnFalse;
    }

    DISPDBG((5, "Passed bEnableOffscreenHeap"));

// pat04 : for NT 3.51 S/W cursor, begin
#if (_WIN32_WINNT < 0x0400)
#ifdef PANNING_SCROLL

    if ((ppdev->ulChipID == CL7541_ID) || (ppdev->ulChipID == CL7543_ID) ||
        (ppdev->ulChipID == CL7542_ID) || (ppdev->ulChipID == CL7548_ID) ||
        (ppdev->ulChipID == CL7555_ID) || (ppdev->ulChipID == CL7556_ID))
    {
        if (poh != NULL) {
            if (onetimealloc == 0)
            {
                onetimealloc = 1;
                ppdev->pjPointerAndCMask =
                       pohAllocatePermanent(ppdev, 32 * ppdev->cBpp, 32);
                ppdev->pjCBackground =
                      pohAllocatePermanent (ppdev, 32 * ppdev->cBpp, 32);
                ppdev->pjPointerCBitmap =
                      pohAllocatePermanent (ppdev, 32 * ppdev->cBpp, 32);
            }

            return(TRUE);
        }
    }
    else
    {
        if (poh != NULL)
            return(TRUE);
    }
#else           //myf-pat
    if (poh != NULL)
        return(TRUE);
#endif          //myf-pat
#else  // NT4.0 code
//pat04, end
    if (poh != NULL)
        return(TRUE);
#endif                  //pat04


ReturnFalse:

    DISPDBG((0, "Failed bEnableOffscreenHeap"));

    return(FALSE);
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\cirrus\disp\gamma.c ===
/*++

Copyright (c) 1996-1997  Cirrus Logic, Inc.
Copyright (c) 1996-1997  Microsoft Corporation.

Module Name:

    G    A    M    M    A  .  C

Abstract:

    While the DAC may generate a linear relationship between the value of a
    color and the visual appearence of that color, the human eyes do not work
    in the same manner. The process done by this module manipulates the
    meaning of colors to get the visual linearity effect.

    We cannot use float or double data type in the display driver; therefore,
    we need implement our MATH functions. Also, the driver binary size will
    increase around 30KB if we use the math functions.

    Registry subdirectory : System\CurrentControlSet\Services\cirrus\Device0
    Keys                  : "G Gamma", and "G Contrast"

Environment:

    Kernel mode only

Notes:
*
*
*   chu01  12-16-96  Enable color correction, Start coding
*   myf29  02-12-97  Support Gamma correction for 755x
*
*
--*/


//---------------------------------------------------------------------------
// HEADER FILES
//---------------------------------------------------------------------------

#include "precomp.h"


#ifdef GAMMACORRECT

BOOL bEnableGammaCorrect(PPDEV ppdev);

//---------------------------------------------------------------------------
// MACRO DEFINITION
//---------------------------------------------------------------------------

#define FIXEDPREC       10
#define FIXEDFUDGE      (0x01L << FIXEDPREC)
#define FIXEDIMASK      (0xFFFFFFFFL << FIXEDPREC)
#define FIXEDFMASK      (~FIXEDIMASK)
#define FixedSign(x)    (((x) < 0x00000000) ? -1L : 1L)
#define FixedAbs(x)     (((x) < 0x00000000) ? -(x) : (x))
#define FixedMakeInt(x) (((long) x)*FIXEDFUDGE)
#define FixedTrunc(x)   ((long) ((x) & FIXEDIMASK))
#define FixedRound(x)   (FixedTrunc((x) + (FIXEDFUDGE >> 1)))
#define FixedInt(x)     ((x) /FIXEDFUDGE)
#define FixedFract(x)   ((((FixedAbs(x)) - FixedTrunc(FixedAbs(x)))*1000)/FIXEDFUDGE)
#define FixedAdd(x,y)   ((x) + (y))
#define FixedSub(x,y)   ((x) - (y))
#define FixedMul(x,y)   ((((x) * (y))+(FIXEDFUDGE >> 1))/FIXEDFUDGE)
#define FixedDiv(x,y)   (long) ((y==0) ? 0x7FFFFFFFL : ((x)*FIXEDFUDGE) / (y))

//---------------------------------------------------------------------------
// VARABLES
//---------------------------------------------------------------------------

PGAMMA_VALUE    GammaFactor    ; // gamma facter for All, Blue, Green, Red
PCONTRAST_VALUE ContrastFactor ; // contrast facter for All, Blue, Green, Red


//------------------------------------------------------------------------------
//
// Function: UCHAR GammaCorrect(UCHAR gamma, UCHAR v)
// {
//     UCHAR dv;
//     dv = (UCHAR)(256 * pow(v/256.0, pow(10, (gamma - 128)/128.0)));
//     return dv;
// }
//
// Input:
//     gamma: new gamma factor from 0 to 255
//     color: color value for Red, Green, or Blue
//
// Output:
//     dv: new color value after gamma correction
//
//------------------------------------------------------------------------------
UCHAR GammaCorrect(UCHAR gamma, UCHAR v)
{
    UCHAR dv ;
    long Color, GammaF, Result ;

    DISPDBG((4, "GammaCorrect")) ;

    if ((gamma == 128) ||
        (gamma == 127) ||
        (gamma == 126))
        return v ;

    Color = FixedDiv(v, 256) ;                             // old color value

    if (Color == 0L)      // in case then we don't need go though calculation
        return 0 ;

    GammaF      = FixedDiv(gamma-128, 128) ;              // new gamma factor
    Result      = Power(Color, Power(FixedMake(10, 0, 1000), GammaF)) ;
    Result      = (long)FixedInt(FixedMul(FixedMake(256, 0, 1000), Result)) ;
    dv          = (UCHAR)Result ;

    return dv ;

} // GammaCorrect


//------------------------------------------------------------------------------
// Function:long Power(long Base, long Exp)
//
// Input:
//     Base: base number of power function
//     Exp: exponential number
//
// Output:
//     20 bits format of integer and fraction number
//      0 = not use(or sign),
//      i = integer portion,
//      f = fraction portion
//      0 + i + f = 32 bits
//      format = 000000000000iiiiiiiiiiiiiiiiiiiffffffffffffffffffff
//
//------------------------------------------------------------------------------
long Power(long Base, long Exp)
{
    int i, iSignExp;
    long    lResult, lResultFract, lRoot;

    iSignExp = FixedSign(Exp);        // get sing bit
    Exp = FixedAbs(Exp);                // convert to positive

    // calculate integer expression
    lResult = FixedMakeInt(1);
    for(i = 0; i < FixedInt(Exp); i++)
        lResult = FixedMul(lResult,Base);

    // calculate fraction expression and add to integer result
    if(FixedFract(Exp) != 0) {
        lResultFract = FixedMakeInt(1);
        lRoot = FixedAbs(Base);
        for(i = 0x0; i < FIXEDPREC; i++) {
            lRoot = FixedSqrt(lRoot);
            if(((0x01L << (FIXEDPREC - 1 - i)) & Exp) != 0) {
                lResultFract = FixedMul(lResultFract, lRoot);
            }
        }
        lResult = FixedMul(lResult, lResultFract);
    }
    if(iSignExp == -1)
        lResult = FixedDiv(FixedMakeInt(1), lResult);
    return(lResult);
} // Power


//------------------------------------------------------------------------------
//
// Function:long FixedMake(long x, long y, long z)
//
// Input:
//     x: integer portion of the number
//     y: fraction portion of the number
//     z: precison after decimal
//
// Output:
//     20 bits format of integer and fraction number
//      0 = not use(or sign),
//      i = integer portion,
//      f = fraction portion
//      0 + i + f = 32 bits
//      format = 000000000000iiiiiiiiiiiiiiiiiiiffffffffffffffffffff
//
//------------------------------------------------------------------------------
long FixedMake(long x, long y, long z)
{

    DISPDBG((4, "FixedMake")) ;
    if (x == 0)
        return((y * FIXEDFUDGE) / z);
    else
        return(FixedSign(x) * ((FixedAbs(x)*FIXEDFUDGE) | (((y * FIXEDFUDGE)/ z) & FIXEDFMASK)));
} // FixedMake

//------------------------------------------------------------------------------
//
// Function:long FixedSqrt(long Root)
//
// Input:
//     Root: number to square
//
// Output:
//     20 bits format of integer and fraction number
//      0 = not use(or sign),
//      i = integer portion,
//      f = fraction portion
//      0 + i + f = 32 bits
//      format = 000000000000iiiiiiiiiiiiiiiiiiiffffffffffffffffffff
//
//------------------------------------------------------------------------------
long FixedSqrt(long Root)
{
    long    lApprox;
    long    lStart;
    long    lEnd;

    if(FixedSign(Root) != 1)
        return(0);

    lStart = (long) FixedMakeInt(1);
    lEnd   = Root;
    if(Root < lStart) {
        lEnd   = lStart;
        lStart = Root;
    }

    lApprox = (lStart + lEnd) / 2;
    while(lStart != lEnd) {
        lApprox = (lStart + lEnd) / 2;
        if ((lApprox == lStart) || (lApprox == lEnd)) {
            lStart = lEnd = lApprox;
        }
        else {
            if(FixedMul(lApprox, lApprox) < Root) {
                lStart = lApprox;
            }
            else {
                lEnd = lApprox;
            }
        }
    }    // end of while
    return(lApprox);
}


//
//  C  O  N  T  R  A  S  T    F  A  C  T  O  R
//

//------------------------------------------------------------------------------
//
// Function:long CalcContrast(UCHAR contrast, UCHAR v)
//
// Input:
//
// Output:
//
//------------------------------------------------------------------------------
UCHAR CalcContrast(UCHAR contrast, UCHAR v)
{
    int dv;
    dv = ((((int)v - 128) * (int)contrast) / 128) + 128 ;
    if(dv < 0) dv = 0;
    if(dv > 255) dv = 255;
    return (unsigned char)dv;
} // CalcContrast


//
//  G  A  M  M  A    F  A  C  T  O  R
//

//---------------------------------------------------------------------------
//
// Routine Description:
//
// Arguments:
//
//    Palette: Pointer to palette array
//    NumberOfEntryes: Number of palette entries need modified
//
// Return Value:
//
//    None
//
//---------------------------------------------------------------------------

VOID CalculateGamma(
    PDEV*    ppdev,
    PVIDEO_CLUT pScreenClut,
    long NumberOfEntries )
{

    UCHAR         GammaRed, GammaGreen, GammaBlue, Red, Green, Blue ;
    UCHAR         Contrast, ContrastRed, ContrastGreen, ContrastBlue ;
    UCHAR         Brightness ;
    int           PalSegment, PalOffset, i ;
    int           iGamma ;

    PALETTEENTRY* ppalSrc  ;
    PALETTEENTRY* ppalDest ;
    PALETTEENTRY* ppalEnd  ;

    DISPDBG((2, "CalculateGamma")) ;

    Brightness = (LONG) GammaFactor >> 24 ;
    GammaBlue  = (LONG) GammaFactor >> 16 ;
    GammaGreen = (LONG) GammaFactor >> 8  ;
    GammaRed   = (LONG) GammaFactor >> 0  ;

    iGamma     = (int)(Brightness - 128) + (int)GammaRed ;
    GammaRed   = (UCHAR)iGamma ;
    if (iGamma < 0)
        GammaRed = 0 ;
    if (iGamma > 255)
        GammaRed = 255 ;

    iGamma     = (int)(Brightness - 128) + (int)GammaGreen ;
    GammaGreen = (UCHAR)iGamma ;
    if (iGamma < 0)
        GammaGreen = 0 ;
    if (iGamma > 255)
        GammaGreen = 255 ;

    iGamma     = (int)(Brightness - 128) + (int)GammaBlue ;
    GammaBlue  = (UCHAR)iGamma ;
    if (iGamma < 0)
        GammaBlue = 0 ;
    if (iGamma > 255)
        GammaBlue = 255 ;

    Contrast   = (LONG) ContrastFactor >> 0 ;

    ppalDest = (PALETTEENTRY*) pScreenClut->LookupTable;
    ppalEnd  = &ppalDest[NumberOfEntries];


    i = 0 ;
    for (; ppalDest < ppalEnd; ppalDest++, i++)
    {

        Red   = ppalDest->peRed   ;
        Green = ppalDest->peGreen ;
        Blue  = ppalDest->peBlue  ;

        Red   = GammaCorrect(GammaRed, Red)     ;
        Green = GammaCorrect(GammaGreen, Green) ;
        Blue  = GammaCorrect(GammaBlue, Blue)   ;

        Red   = CalcContrast(Contrast, Red)   ;
        Green = CalcContrast(Contrast, Green) ;
        Blue  = CalcContrast(Contrast, Blue)  ;

        if (ppdev->iBitmapFormat == BMF_8BPP)
        {
            ppalDest->peRed    = Red   >> 2 ;
            ppalDest->peGreen  = Green >> 2 ;
            ppalDest->peBlue   = Blue  >> 2 ;
        }
        else if ((ppdev->iBitmapFormat == BMF_16BPP) ||
                 (ppdev->iBitmapFormat == BMF_24BPP))
        {
            ppalDest->peRed    = Red   ;
            ppalDest->peGreen  = Green ;
            ppalDest->peBlue   = Blue  ;
        }

    }
    return ;

} // CalulateGamma


/******************************************************************************\
*
* Function:     bEnableGammaCorrect
*
* Enable GammaTable. Called from DrvEnableSurface.
*
* Parameters:   ppdev        Pointer to phsyical device.
*
* Returns:      TRUE : successful; FALSE: fail
*
\******************************************************************************/
BOOL bEnableGammaCorrect(PDEV* ppdev)
{

    BYTE  srIndex, srData ;
    BYTE* pjPorts = ppdev->pjPorts ;
    int   i ;

    DISPDBG((4, "bEnableGammaCorrect")) ;

    //
    // Enable Gamma correction. If needed; Otherwise, turn it off.
    //
    srIndex = CP_IN_BYTE(pjPorts, SR_INDEX) ;   // i 3c4 srIndex
    CP_OUT_BYTE(pjPorts, SR_INDEX, 0x12) ;      // o 3c4 12
    srData = CP_IN_BYTE(pjPorts, SR_DATA) ;     // i 3c5 srData

    if (ppdev->flCaps & CAPS_GAMMA_CORRECT)
    {
        if ((ppdev->iBitmapFormat == BMF_16BPP) ||
            (ppdev->iBitmapFormat == BMF_24BPP))
            srData |= 0x40 ;                        // 3c5.12.D6 = 1
        else
            srData &= 0xBF ;                        // 3c5.12.D6 = 0
    }
    else
        srData &= 0xBF ;                            // 3c5.12.D6 = 0

    CP_OUT_BYTE(pjPorts, SR_DATA, srData) ;     // o 3c5 srData
    CP_OUT_BYTE(pjPorts, SR_INDEX, srIndex) ;   // o 3c4 srIndex

    if ( srData & 0x40 )
    {
        return TRUE ;
    }
    else
    {
        return FALSE ;
    }

} // bEnableGammaCorrect


//myf29 : for 755x Gamma Correct support begin
/******************************************************************************\
*
* Function:     bEnableGamma755x
*
* Enable Graphic GammaTable. Called from DrvAssertMode/DrvEscape
*
* Parameters:   ppdev        Pointer to phsyical device.
*
* Returns:      TRUE : successful; FALSE: fail
*
\******************************************************************************/
BOOL bEnableGamma755x(PDEV* ppdev)
{

    BYTE  crIndex, crData ;
    BYTE* pjPorts = ppdev->pjPorts ;
    BOOL  status;

    DISPDBG((4, "bEnableGamma755x")) ;

    //
    // Enable Gamma correction. If needed; Otherwise, turn it off.
    //
    crIndex = CP_IN_BYTE(pjPorts, CRTC_INDEX) ;   // i 3d4 crIndex

    status = FALSE;

    if (ppdev->flCaps & CAPS_GAMMA_CORRECT)
    {
        CP_OUT_BYTE(pjPorts, CRTC_INDEX, 0x8E);      // CR8E[2]=0
        crData = CP_IN_BYTE(pjPorts, CRTC_DATA);
        if ((ppdev->iBitmapFormat == BMF_16BPP) ||
            (ppdev->iBitmapFormat == BMF_24BPP))
        {
            crData &= 0xFB ;                        // CR8E[2] = 0
            status = TRUE;
        }
        else
            crData |= 0x04 ;                        // CR8E[2] = 1
        CP_OUT_BYTE(pjPorts, CRTC_DATA, crData) ;   // o 3d5 crData
    }

    CP_OUT_BYTE(pjPorts, CRTC_INDEX, crIndex) ;   // o 3d4 crIndex

    return(status);

} // bEnableGamma755x

/******************************************************************************\
*
* Function:     bEnableGammaVideo755x
*
* Enable Video GammaTable. Called from DrvAssertMode/DrvEscape
*
* Parameters:   ppdev        Pointer to phsyical device.
*
* Returns:      TRUE : successful; FALSE: fail
*
\******************************************************************************/
BOOL bEnableGammaVideo755x(PDEV* ppdev)
{

    BYTE  crIndex, crData ;
    BYTE* pjPorts = ppdev->pjPorts ;
    BOOL  status;

    DISPDBG((4, "bEnableGammaVideo755x")) ;

    //
    // Enable Gamma correction. If needed; Otherwise, turn it off.
    //
    crIndex = CP_IN_BYTE(pjPorts, CRTC_INDEX) ;   // i 3d4 crIndex

    status = FALSE;

    if (ppdev->flCaps & CAPS_GAMMA_CORRECT)
    {
        CP_OUT_BYTE(pjPorts, CRTC_INDEX, 0x36);    // CR36[6]=1:enable VW LUT
        crData = CP_IN_BYTE(pjPorts, CRTC_DATA);

//      if ((ppdev->iBitmapFormat == BMF_16BPP) ||
//          (ppdev->iBitmapFormat == BMF_24BPP))
        {
            crData |= 0x40 ;                        // CR36[6] = 1
            CP_OUT_BYTE(pjPorts, CRTC_DATA, crData);
            CP_OUT_BYTE(pjPorts, CRTC_INDEX, 0x3F) ;    // CR3F[4]=1:select VW
            crData = CP_IN_BYTE(pjPorts, CRTC_DATA);
            crData |= 0x10 ;                        // CR3F[4] = 1
            CP_OUT_BYTE(pjPorts, CRTC_DATA, crData);
            status = TRUE;
        }
    }

    CP_OUT_BYTE(pjPorts, CRTC_INDEX, crIndex) ;   // o 3d4 crIndex

    return(status);

} // bEnableGammaVideo755x

//myf29 end
#endif // GAMMACORRECT

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\cirrus\disp\escape.c ===
/******************************************************************************\
*
* $Workfile:   ESCAPE.C  $
*
* Cirrus Logic Escapes.
*
* Copyright (c) 1996-1997 Microsoft Corporation.
* Copyright (c) 1993-1997 Cirrus Logic, Inc.,
*
* $Log:   V:/CirrusLogic/CL5446/NT40/Archive/Display/ESCAPE.C_v  $
*
*    Rev 1.0   24 Jun 1996 16:21:18   frido
* Initial revision.
*
* myf17 11-04-96  Added special escape code must be use 11/5/96 later NTCTRL,
*                 and added Matterhorn LF Device ID==0x4C
* myf18 11-04-96  Fixed PDR #7075,
* myf19 11-06-96  Fixed Vinking can't work problem, because DEVICEID = 0x30
*                 is different from data book (CR27=0x2C)
* chu01 12-16-96  Enable color correction.
* pat01 :11-22-96 : Fix panning-scrolling bugs.
*                   (1) Screen messes up when switch to simulscan(with panning)
*                   (2) Software cursor problem in panning scrolling mode
* pat07 :         : Take care of disappering hardware cursor during simulscan
* myf29 02-12-97  Support 755x gamma collection.
* chu02 02-13-97  More thorough checking for color correction.
* jl01  02-24-97  Implement Feature Connector's functions.
*
\******************************************************************************/

#include "precomp.h"

//
// chu01
//
#ifdef GAMMACORRECT

#include "string.h"
#include "stdio.h"

extern PGAMMA_VALUE GammaFactor    ;
extern PGAMMA_VALUE ContrastFactor ;

#endif // GAMMACORRECT

extern

/******************************Public*Routine******************************\
* DrvEscape
*
* Processes the private ESCAPE's for this driver
*
\**************************************************************************/

ULONG DrvEscape(
SURFOBJ  *pso,
ULONG    iEsc,
ULONG    cjIn,
VOID     *pvIn,
ULONG    cjOut,
VOID     *pvOut)
{
   ULONG returnLength;
   PPDEV ppdev = (PPDEV) pso->dhpdev;
   DHPDEV dhpdev = (DHPDEV) pso->dhpdev;     //myf17

   ULONG ulMode;                             //myf17
   BYTE* pjPorts;                            //myf17
   VIDEO_MODE_INFORMATION  VideoModeInfo;    //myf17
   SHORT i;     //myf17
   unsigned char savePaletteR[256];          //pat01
   unsigned char savePaletteG[256];          //pat01
   unsigned char savePaletteB[256];          //pat01
   unsigned char R,G,B;                      //pat01
   unsigned char palettecounter;             //pat01
   LONG savex, savey  ;                      //pat07

UCHAR TempByte;                           //jl01

//
// chu01
//
#ifdef GAMMACORRECT

    PVIDEO_CLUT    pScreenClut ;
    BYTE           ajClutSpace[MAX_CLUT_SIZE] ;
    PALETTEENTRY*  ppalSrc ;
    PALETTEENTRY*  ppalDest ;
    PALETTEENTRY*  ppalEnd ;
    UCHAR          GammaRed, GammaGreen, GammaBlue, Brightness ;
    ULONG          ulReturnedDataLength ;
    UCHAR          tempB ;
    ULONG          *Signature ;
    BOOL           status;      //myf29
    UCHAR*         pvLUT;       //myf29

#endif // GAMMACORRECT

    DISPDBG((2, "---- DrvEscape"));

    DISPDBG((4, "cjIn = %d, cjOut = %d, pvIn = 0x%lx, pvOut = 0x%lx",
        cjIn, cjOut, pvIn, pvOut));


   pjPorts = ppdev->pjPorts;
   DISPDBG((2, "CIRRUS:DrvEscape: entered DrvEscape\n"));
   if (iEsc == QUERYESCSUPPORT) {
      if ( ((*(ULONG *)pvIn) == CIRRUS_PRIVATE_ESCAPE) ||
//myf17 begin
           ((*(ULONG *)pvIn) == CLESCAPE_CRT_CONNECTION) ||
           ((*(ULONG *)pvIn) == CLESCAPE_SET_VGA_OUTPUT) ||
           ((*(ULONG *)pvIn) == CLESCAPE_GET_VGA_OUTPUT) ||
           ((*(ULONG *)pvIn) == CLESCAPE_GET_PANEL_SIZE) ||
           ((*(ULONG *)pvIn) == CLESCAPE_PANEL_MODE)) {
//myf17 end
            return TRUE;
      }

//
// chu01
//
#ifdef GAMMACORRECT
      else if ((*(USHORT *)pvIn) == CLESCAPE_GET_CHIPID)
      {
            return TRUE;
      }
#endif // GAMMACORRECT

      else
      {
            return FALSE;
      }
   }
   else if (iEsc == CIRRUS_PRIVATE_ESCAPE)
   {
      if (!IOCONTROL(ppdev->hDriver,
                    IOCTL_CIRRUS_PRIVATE_BIOS_CALL,
                    pvIn,
                    cjIn,
                    pvIn,
                    cjIn,
                    &returnLength))
      {
          DISPDBG((2, "CIRRUS:DrvEscape: failed private BIOS call.\n"));
          return FALSE;
      }
      else {
         DISPDBG((2, "CIRRUS:DrvEscape: private BIOS call GOOD.\n"));
         // copy the result to the output buffer
         *(VIDEO_X86_BIOS_ARGUMENTS *)pvOut = *(VIDEO_X86_BIOS_ARGUMENTS *)pvIn;

//myf33 begin for TV on bug
         if (((*(ULONG *)pvIn & 0x120F) != 0x1200) &&
             ((*( ((ULONG *)pvIn)+1) & 0x01B0) == 0x01B0))
         {
//           bAssertModeHardware((PDEV *) dhpdev, TRUE);
    DWORD                   ReturnedDataLength;
    ULONG                   ulReturn;
    VIDEO_MODE_INFORMATION  VideoModeInfo;

             IOCONTROL(ppdev->hDriver,
                            IOCTL_VIDEO_QUERY_CURRENT_MODE,
                            NULL,
                            0,
                            &VideoModeInfo,
                            sizeof(VideoModeInfo),
                            &ReturnedDataLength);
#ifdef PANNING_SCROLL
             if ((ppdev->ulChipID == 0x38) || (ppdev->ulChipID == 0x2C) ||
                 (ppdev->ulChipID == 0x30) || (ppdev->ulChipID == 0x34) ||
                 (ppdev->ulChipID == 0x40) || (ppdev->ulChipID == 0x4C))
             {
                 CirrusLaptopViewPoint(ppdev,  &VideoModeInfo);
             }
#endif
         }
//myf33 end
         return TRUE;
      }
   }
   else if (iEsc == CLESCAPE_CRT_CONNECTION)    //myf17
   {

      *(ULONG *)pvOut = (ULONG)0x1200;
      *( ((ULONG *)pvOut)+1) = 0xA1;
      if (!IOCONTROL(ppdev->hDriver,
                    IOCTL_CIRRUS_CRT_CONNECTION,
                    pvOut,
                    cjOut,
                    pvOut,
                    cjOut,
                    &returnLength))
      {
          DISPDBG((2, "CIRRUS:DrvEscape: failed CRT CONNECTION.\n"));
          return FALSE;
      }
      else {
         DISPDBG((2, "CIRRUS:DrvEscape: CRT CONNECTION GOOD.\n"));
         return TRUE;
      }
   }
   else if (iEsc == CLESCAPE_GET_VGA_OUTPUT)    //myf17
   {

      *(ULONG *)pvOut = (ULONG)0x1200;
      *( ((ULONG *)pvOut)+1) = 0x9A;
      if (!IOCONTROL(ppdev->hDriver,
                    IOCTL_CIRRUS_GET_VGA_OUTPUT,
                    pvOut,
                    cjOut,
                    pvOut,
                    cjOut,
                    &returnLength))
      {
          DISPDBG((2, "CIRRUS:DrvEscape: failed GET VGA OUTPUT.\n"));
          return FALSE;
      }
      else {
         DISPDBG((2, "CIRRUS:DrvEscape: GET VGA OUTPUT GOOD.\n"));
         return TRUE;
      }
   }
   else if (iEsc == CLESCAPE_GET_PANEL_SIZE)    //myf17
   {

      *(ULONG *)pvOut = (ULONG)0x1280;
      *( ((ULONG *)pvOut)+1) = 0x9C;
      if (!IOCONTROL(ppdev->hDriver,
                    IOCTL_CIRRUS_CRT_CONNECTION,
                    pvOut,
                    cjOut,
                    pvOut,
                    cjOut,
                    &returnLength))
      {
          DISPDBG((2, "CIRRUS:DrvEscape: failed CRT CONNECTION.\n"));
          return FALSE;
      }
      else {
         DISPDBG((2, "CIRRUS:DrvEscape: CRT CONNECTION GOOD.\n"));
         return TRUE;
      }
   }
   else if (iEsc == CLESCAPE_PANEL_MODE)        //myf17
   {

      *(ULONG *)pvOut = *(ULONG *)pvIn;
      *(ULONG *)pvOut |= (ULONG)0x1200;
      *( ((ULONG *)pvOut)+1) = 0xA0;
      if (!IOCONTROL(ppdev->hDriver,
                    IOCTL_CIRRUS_PANEL_MODE,
                    pvOut,
                    cjOut,
                    pvOut,
                    cjOut,
                    &returnLength))
      {
          DISPDBG((2, "CIRRUS:DrvEscape: failed PANEL MODE.\n"));
          return FALSE;
      }
      else {
         DISPDBG((2, "CIRRUS:DrvEscape: PANEL MODE GOOD.\n"));
         return TRUE;
      }
   }
   else if (iEsc == CLESCAPE_SET_VGA_OUTPUT)
   {
//pat01, begin
#ifdef PANNING_SCROLL
   #if (_WIN32_WINNT < 0x0400)  // #pat1

     if ((ppdev->ulChipID == CL7541_ID) || (ppdev->ulChipID == CL7543_ID) ||
         (ppdev->ulChipID == CL7542_ID) || (ppdev->ulChipID == CL7548_ID) ||
         (ppdev->ulChipID == CL7555_ID) || (ppdev->ulChipID == CL7556_ID))
     {
          palettecounter = 255;
          // Save DAC values
          while (palettecounter --) {
             CP_OUT_BYTE(ppdev->pjPorts, DAC_PEL_READ_ADDR, palettecounter);
             savePaletteR[palettecounter] =  CP_IN_BYTE(ppdev->pjPorts, DAC_PEL_DATA);
             savePaletteG[palettecounter] =  CP_IN_BYTE(ppdev->pjPorts, DAC_PEL_DATA);
             savePaletteB[palettecounter] =  CP_IN_BYTE(ppdev->pjPorts, DAC_PEL_DATA);
          }// while
          // preserver icons + previous bitmaps
          bAssertModeOffscreenHeap(ppdev,FALSE);
     }

  #endif
#endif
//pat01, end

      *(ULONG *)pvOut = *(ULONG *)pvIn;
      *(ULONG *)pvOut |= (ULONG)0x1200;
      *( ((ULONG *)pvOut)+1) = 0x92;
      if (!IOCONTROL(ppdev->hDriver,
                    IOCTL_CIRRUS_SET_VGA_OUTPUT,
                    pvOut,
                    cjOut,
                    pvOut,
                    cjOut,
                    &returnLength))
      {
          DISPDBG((2, "CIRRUS:DrvEscape: failed SET VGA OUTPUT.\n"));
          return FALSE;
      }
      else {
          DISPDBG((2, "CIRRUS:DrvEscape: SET VGA OUTPUT GOOD.\n"));

//#pat01 <start>

#if (_WIN32_WINNT < 0x0400)   // #pat01
    #ifdef PANNING_SCROLL
        // check cursor status
     if ((ppdev->ulChipID == CL7541_ID) || (ppdev->ulChipID == CL7543_ID) ||
         (ppdev->ulChipID == CL7542_ID) || (ppdev->ulChipID == CL7548_ID) ||
         (ppdev->ulChipID == CL7555_ID) || (ppdev->ulChipID == CL7556_ID))
     {
         if (ppdev->flCaps & CAPS_SW_POINTER) {
              bAssertModeHardware(ppdev, TRUE);
              vAssertModeText(ppdev, TRUE);
              vAssertModeBrushCache(ppdev,TRUE);
              // bEnablePointer(ppdev); // pat07
              ppdev->flCaps |= CAPS_SW_POINTER; // reset to HW. why???
         } else {
              // #pat07  start
              CP_OUT_BYTE(pjPorts, SR_INDEX,0x10);
              savex = CP_IN_BYTE(pjPorts, SR_DATA);
              CP_OUT_BYTE(pjPorts, SR_INDEX,0x11);
              savey = CP_IN_BYTE(pjPorts, SR_DATA);
              //pat07 end
              bAssertModeHardware(ppdev, TRUE);
//pat07       vAssertModePointer(ppdev,TRUE);
              vAssertModeText(ppdev, TRUE);
              vAssertModeBrushCache(ppdev,TRUE);
              bEnablePointer(ppdev);
              //pat07 begin
              CP_OUT_BYTE(pjPorts, SR_INDEX,0x10);
              CP_OUT_BYTE(pjPorts, SR_DATA, savex);
              CP_OUT_BYTE(pjPorts, SR_INDEX,0x11);
              CP_OUT_BYTE(pjPorts, SR_DATA, savey);
              CP_PTR_ENABLE(ppdev, pjPorts);
              // #pat07 end
         }


         palettecounter = 255;

         // Restore DAC values
         while (palettecounter-- ) {

           CP_OUT_BYTE(ppdev->pjPorts, DAC_PEL_WRITE_ADDR, palettecounter);
           CP_OUT_BYTE(ppdev->pjPorts, DAC_PEL_DATA, savePaletteR[palettecounter]);
           CP_OUT_BYTE(ppdev->pjPorts, DAC_PEL_DATA, savePaletteG[palettecounter]);
           CP_OUT_BYTE(ppdev->pjPorts, DAC_PEL_DATA, savePaletteB[palettecounter]);

          }// while
     }

  #endif
#else           //NT 4.0 code
//ppp begin
          palettecounter = 255;
          while (palettecounter--)
          {
              CP_OUT_BYTE(ppdev->pjPorts,DAC_PEL_READ_ADDR,palettecounter);
              savePaletteR[palettecounter] =
                  CP_IN_BYTE(ppdev->pjPorts,DAC_PEL_DATA);
              savePaletteG[palettecounter] =
                  CP_IN_BYTE(ppdev->pjPorts,DAC_PEL_DATA);
              savePaletteB[palettecounter] =
                  CP_IN_BYTE(ppdev->pjPorts,DAC_PEL_DATA);
          }

          bAssertModeHardware((PDEV *) dhpdev, TRUE);

          palettecounter = 255;
          while (palettecounter--)
          {
              CP_OUT_BYTE(ppdev->pjPorts,DAC_PEL_WRITE_ADDR,palettecounter);
              CP_OUT_BYTE(ppdev->pjPorts,DAC_PEL_DATA,
                          savePaletteR[palettecounter]);
              CP_OUT_BYTE(ppdev->pjPorts,DAC_PEL_DATA,
                          savePaletteG[palettecounter]);
              CP_OUT_BYTE(ppdev->pjPorts,DAC_PEL_DATA,
                          savePaletteB[palettecounter]);
          }
          bEnablePointer(ppdev);

//ppp end
#endif
//pat01, end
          return TRUE;

      }
   }

//
// chu01
//
#ifdef GAMMACORRECT
    else if (iEsc == CLESCAPE_GAMMA_CORRECT)                         // 9000
    {
        if (!(ppdev->flCaps & CAPS_GAMMA_CORRECT))
            return ;

        Signature      = *((ULONG *)pvIn+0) ;
        GammaFactor    = *((ULONG *)pvIn+1) ;
        ContrastFactor = *((ULONG *)pvIn+2) ;

        //
        // Is signature "CRUS" ?
        //
        if (Signature != 0x53555243)
            return TRUE ;

        // Fill in pScreenClut header info:

        pScreenClut             = (PVIDEO_CLUT) ajClutSpace;
        pScreenClut->NumEntries = 256;
        pScreenClut->FirstEntry = 0;

        ppalSrc  = ppdev->pCurrentPalette;
        ppalDest = (PALETTEENTRY*) pScreenClut->LookupTable;
        ppalEnd  = &ppalDest[256];

        for (; ppalDest < ppalEnd; ppalSrc++, ppalDest++)
        {
           ppalDest->peRed   = ppalSrc->peRed   ;
           ppalDest->peGreen = ppalSrc->peGreen ;
           ppalDest->peBlue  = ppalSrc->peBlue  ;
           ppalDest->peFlags = 0 ;
        }

//myf29 begin
        CP_OUT_BYTE(ppdev->pjPorts, CRTC_INDEX, 0x27) ;
        tempB = CP_IN_BYTE(ppdev->pjPorts, CRTC_DATA) ;
        if (tempB == 0xBC)
            status = bEnableGammaCorrect(ppdev) ;
        else if ((tempB == 0x40) || (tempB == 0x4C))
            status = bEnableGamma755x(ppdev);
//myf29 end

        CalculateGamma(ppdev, pScreenClut, 256) ;

        // Set palette registers:

        if (!IOCONTROL(ppdev->hDriver,
                       IOCTL_VIDEO_SET_COLOR_REGISTERS,
                       pScreenClut,
                       MAX_CLUT_SIZE,
                       NULL,
                       0,
                       &ulReturnedDataLength))
        {
            DISPDBG((2, "Failed bEnablePalette"));
            return FALSE ;
        }
        return TRUE ;
    }
    else if (iEsc == CLESCAPE_GET_CHIPID)                            // 9001
    {

        //
        // Return chip ID, graphics and video info
        //
        CP_OUT_BYTE(ppdev->pjPorts, CRTC_INDEX, 0x27) ;
        tempB = CP_IN_BYTE(ppdev->pjPorts, CRTC_DATA) ;
        if (tempB == 0xBC)                                  //myf29
            *(DWORD *)pvOut = ((DWORD)tempB) | 0x00000100 ; //for Graphic LUT
        else if ((tempB == 0x40) || (tempB == 0x4C))        //myf29
            *(DWORD *)pvOut = ((DWORD)tempB) | 0x00010100;  //myf29  Video LUT
        else                                                //myf29
            *(DWORD *)pvOut = ((DWORD)tempB);               //myf29 non gamma
        return TRUE ;
    }

//myf29 :02-12-97 add 7555 gamma correction begin
    else if (iEsc == CLESCAPE_WRITE_VIDEOLUT)                // 9010
    {
        if (!(ppdev->flCaps & CAPS_GAMMA_CORRECT))
            return ;

        pvLUT  = (ULONG *)pvIn+0;

        pScreenClut             = (PVIDEO_CLUT) ajClutSpace;
        pScreenClut->NumEntries = 256;
        pScreenClut->FirstEntry = 0;

        ppalDest = (PALETTEENTRY*) pScreenClut->LookupTable;
        ppalEnd  = &ppalDest[256];

        for (; ppalDest < ppalEnd; ppalDest++)
        {
           ppalDest->peRed   = *pvLUT++;
           ppalDest->peGreen = *pvLUT++;
           ppalDest->peBlue  = *pvLUT++;
           ppalDest->peFlags = 0 ;
        }

        CP_OUT_BYTE(ppdev->pjPorts, CRTC_INDEX, 0x27) ;
        tempB = CP_IN_BYTE(ppdev->pjPorts, CRTC_DATA) ;
        if ((tempB == 0x40) || (tempB == 0x4C))
            status = bEnableGammaVideo755x(ppdev);
//      if (!status)
//      {
//          DISPDBG((2, "Failed bEnableGAmmaVodeoCorrect"));
//          return FALSE ;
//      }

        // Set palette registers:

        if (!IOCONTROL(ppdev->hDriver,
                       IOCTL_VIDEO_SET_COLOR_REGISTERS,
                       pScreenClut,
                       MAX_CLUT_SIZE,
                       NULL,
                       0,
                       &ulReturnedDataLength))
        {
            //restore register

            CP_OUT_BYTE(ppdev->pjPorts, CRTC_INDEX, 0x3F) ;
            tempB = CP_IN_BYTE(ppdev->pjPorts, CRTC_DATA) ;
            CP_OUT_BYTE(ppdev->pjPorts, CRTC_DATA, (tempB & 0xEF)) ;

            DISPDBG((2, "Failed bEnablePalette"));
            return FALSE ;
        }

        //restore register

        CP_OUT_BYTE(ppdev->pjPorts, CRTC_INDEX, 0x3F) ;
        tempB = CP_IN_BYTE(ppdev->pjPorts, CRTC_DATA) ;
        CP_OUT_BYTE(ppdev->pjPorts, CRTC_DATA, (tempB & 0xEF)) ;

        return TRUE ;
    }
//myf29 :02-12-97 add 7555 gamma correction end
#endif // GAMMACORRECT

#if 1  // jl01 Implement Feature Connector's functions.
    else if (iEsc == CLESCAPE_FC_Cap)                                 // 9002
    {
        if ((ppdev->ulChipID == 0xAC)	|| (ppdev->ulChipID == 0xB8))
            return TRUE;
        return FALSE;
    }
    else if (iEsc == CLESCAPE_FC_Status)                              // 9003
    {
        if (ppdev->ulChipID == 0xAC)                                  // 5436
        {
            CP_OUT_BYTE(ppdev->pjPorts, SR_INDEX, 0x08);
            TempByte = CP_IN_BYTE(ppdev->pjPorts, SR_DATA);
            if ((TempByte & 0x20) == 0) 
                return TRUE;
            else 
                return FALSE;
        }
        else if (ppdev->ulChipID == 0xB8)                             // 5446
        {
            CP_OUT_BYTE(ppdev->pjPorts, INDEX_REG, 0x17);
            TempByte = CP_IN_BYTE(ppdev->pjPorts, DATA_REG);
            if ((TempByte & 0x08) == 0) 
                return TRUE;
            else
                return FALSE;
         }
         else    return FALSE;
    }
    else if (iEsc == CLESCAPE_FC_SetOrReset)                          // 9004
    {
        if (ppdev->ulChipID == 0xAC)                                  // 5436
        {
            CP_OUT_BYTE(ppdev->pjPorts, SR_INDEX, 0x08);
            TempByte = CP_IN_BYTE(ppdev->pjPorts, SR_DATA);
            if (*(UCHAR *)pvIn)
                TempByte &= ~0x20;
            else
                TempByte |= 0x20;
            CP_OUT_BYTE(ppdev->pjPorts, SR_DATA, TempByte);
        }
        else if (ppdev->ulChipID == 0xB8)                             // 5446
        {
            CP_OUT_BYTE(ppdev->pjPorts, INDEX_REG, 0x17);
            TempByte = CP_IN_BYTE(ppdev->pjPorts, DATA_REG);
            if (*(UCHAR *)pvIn)
                TempByte &= ~0x08;
            else
                TempByte |= 0x08;
            CP_OUT_BYTE(ppdev->pjPorts, DATA_REG, TempByte);
        }
        else return TRUE;
    }
#endif  // jl01 Implement Feature Connector's functions.

    else if (iEsc == CLESCAPE_IsItCLChips)                            // 9005
    {
        return TRUE;
    }
    else
        return 0xffffffff;

    /* we should never be here */
    return FALSE;
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\cirrus\disp\hw.h ===
/******************************************************************************\
*
* $Workfile:   hw.h  $
*
* All the hardware specific driver file stuff.  Parts are mirrored in
* 'hw.inc'.
*
* Copyright (c) 1992-1995 Microsoft Corporation
* Copyright (c) 1996 Cirrus Logic, Inc.
*
* $Log:   S:/projects/drivers/ntsrc/display/HW.H_V  $
 * 
 *    Rev 1.4   10 Jan 1997 15:40:14   PLCHU
 *  
 * 
 *    Rev 1.3   Nov 07 1996 16:48:02   unknown
 *  
 * 
 *    Rev 1.1   Oct 10 1996 15:37:46   unknown
 *  
* 
*    Rev 1.3   12 Aug 1996 16:48:16   frido
* Cleaned up source.
* 
*    Rev 1.2   29 Jul 1996 12:28:38   frido
* Added WriteMask register.
* 
*    Rev 1.1   03 Jul 1996 13:38:42   frido
* Added DirectDraw support.
*
*   sge01   10-23-96    Add second aperture flag
*
*   sge02   10-29-96    Merge port and register access for 
*                       VGA relocatable and MMIO registers.
*
\******************************************************************************/


#define CP_TRACK()                                                               \
(                                                                               \
    DISPDBG((100, "CP access - File(%s)  line(%d)", __FILE__, __LINE__))       \
)

////////////////////////////////////////////////////////////////////////////////
//                                      Ports                                      //
////////////////////////////////////////////////////////////////////////////////

#define SR_INDEX                0x3C4   // Sequencer Registers
#define SR_DATA                 0x3C5

#define DAC_PEL_READ_ADDR       0x3C7
#define DAC_PEL_WRITE_ADDR      0x3C8
#define DAC_PEL_DATA            0x3C9

#define INDEX_REG               0x3CE   // Graphics Controler Registers
#define DATA_REG                0x3CF

#if 1 // extra defines
#define CRTC_INDEX                0x3D4    // CRT Controller Registers
#define CRTC_DATA                0x3D5

#define STATUS_1                0x3DA    // Input Status Register 1
#define DISPLAY_MODE_INACTIVE    0x01
#define VBLANK_ACTIVE            0x08
#endif

////////////////////////////////////////////////////////////////////////////////
// Alpha and PowerPC considerations
//
// Both the Alpha and the PowerPC do not guarantee that I/O to separate
// addresses will be executed in order. The Alpha and PowerPC differ, however,
// in that the PowerPC guarantees that output to the same address will be
// executed in order, while the Alpha may cache and 'collapse' consecutive
// output to become only one output.
//
// Consequently, we use the following synchronization macros. They are
// relatively expensive in terms of performance, so we try to avoid them
// whereever possible.
//
// CP_EIEIO() 'Ensure In-order Execution of I/O'
//    - Used to flush any pending I/O in situations where we wish to avoid
//      out-of-order execution of I/O to separate addresses.
//
// CP_MEMORY_BARRIER()
//    - Used to flush any pending I/O in situations where we wish to avoid
//      out-of-order execution or 'collapsing' of I/O to the same address. On
//      the PowerPC, this will be defined as a null operation.

#if defined(_PPC_)

    // On PowerPC, CP_MEMORY_BARRIER doesn't do anything.

    #define CP_EIEIO()              MEMORY_BARRIER()
    #define CP_MEMORY_BARRIER()     0

#elseif defined(_ALPHA_)

    // On Alpha, CP_EIEIO() is the same thing as a CP_MEMORY_BARRIER().

    #define CP_EIEIO()              MEMORY_BARRIER()
    #define CP_MEMORY_BARRIER()     MEMORY_BARRIER()

#else

    // On i386 and MIPS, there is nu such thing as MEMORY_BARRIER.

    #define CP_EIEIO()                0
    #define CP_MEMORY_BARRIER()        0

#endif

//
// Merge port and register access for VGA relocatable and MMIO registers.
//

#define CL_READ_PORT_UCHAR(Port)           ppdev->pfnREAD_PORT_UCHAR(Port)
#define CL_READ_PORT_USHORT(Port)          ppdev->pfnREAD_PORT_USHORT(Port)
#define CL_READ_PORT_ULONG(Port)           ppdev->pfnREAD_PORT_ULONG(Port)
#define CL_WRITE_PORT_UCHAR(Port, Value)   ppdev->pfnWRITE_PORT_UCHAR(Port, Value)
#define CL_WRITE_PORT_USHORT(Port, Value)  ppdev->pfnWRITE_PORT_USHORT(Port, Value)
#define CL_WRITE_PORT_ULONG(Port, Value)   ppdev->pfnWRITE_PORT_ULONG(Port, Value)

////////////////////////////////////////////////////////////////////////////////
//                               Port access macros                              //
////////////////////////////////////////////////////////////////////////////////

#define CP_OUT_DWORD(pjBase, cjOffset, ul)                                       \
(                                                                               \
    CP_TRACK(),                                                                   \
    CL_WRITE_PORT_ULONG((BYTE*) (pjBase) + (cjOffset), (DWORD) (ul)),               \
    CP_EIEIO()                                                                   \
)

#define CP_OUT_WORD(pjBase, cjOffset, w)                                       \
(                                                                               \
    CP_TRACK(),                                                                   \
    CL_WRITE_PORT_USHORT((BYTE*) (pjBase) + (cjOffset), (WORD) (w)),               \
    CP_EIEIO()                                                                   \
)
                                                                            
#define CP_OUT_BYTE(pjBase, cjOffset, j)                                       \
(                                                                               \
    CP_TRACK(),                                                                   \
    CL_WRITE_PORT_UCHAR((BYTE*) (pjBase) + (cjOffset), (BYTE) (j)),               \
    CP_EIEIO()                                                                   \
)

#define CP_IN_DWORD(pjBase, cjOffset)                                           \
(                                                                               \
    CP_TRACK(),                                                                   \
    CL_READ_PORT_ULONG((BYTE*) (pjBase) + (cjOffset))                               \
)

#define CP_IN_WORD(pjBase, cjOffset)                                           \
(                                                                               \
    CP_TRACK(),                                                                   \
    CL_READ_PORT_USHORT((BYTE*) (pjBase) + (cjOffset))                               \
)

#define CP_IN_BYTE(pjBase, cjOffset)                                           \
(                                                                               \
    CP_TRACK(),                                                                   \
    CL_READ_PORT_UCHAR((BYTE*) (pjBase) + (cjOffset))                               \
)

////////////////////////////////////////////////////////////////////////////////
//                      Memory mapped register access macros                      //
////////////////////////////////////////////////////////////////////////////////

#define CP_WRITE_ULONG(pjBase, cjOffset, ul)                                   \
(                                                                               \
    CP_TRACK(),                                                                   \
    WRITE_REGISTER_ULONG((ULONG*)((BYTE*)(pjBase) + (cjOffset)), (DWORD)(ul))          \
)

#define CP_WRITE_USHORT(pjBase, cjOffset, w)                                   \
(                                                                               \
    CP_TRACK(),                                                                   \
    WRITE_REGISTER_USHORT((BYTE*) (pjBase) + (cjOffset), (WORD) (w))           \
)

#define CP_WRITE_UCHAR(pjBase, cjOffset, j)                                       \
(                                                                               \
    CP_TRACK(),                                                                   \
    WRITE_REGISTER_UCHAR((BYTE*) (pjBase) + (cjOffset), (BYTE) (j))               \
)

#define CP_READ_ULONG(pjBase, cjOffset)                                           \
(                                                                               \
    CP_TRACK(),                                                                   \
    READ_REGISTER_ULONG((BYTE*) (pjBase) + (cjOffset))                           \
)

#define CP_READ_USHORT(pjBase, cjOffset)                                       \
(                                                                               \
    CP_TRACK(),                                                                   \
    READ_REGISTER_USHORT((BYTE*) (pjBase) + (cjOffset))                           \
)

#define CP_READ_UCHAR(pjBase, cjOffset)                                           \
(                                                                               \
    CP_TRACK(),                                                                   \
    READ_REGISTER_UCHAR((BYTE*) (pjBase) + (cjOffset))                           \
)

////////////////////////////////////////////////////////////////////////////////
//                      Blt engine MM register access macros                      //
////////////////////////////////////////////////////////////////////////////////

#define CP_MM_ACL_STAT(ppdev, pjBase)                                           \
(                                                                               \
    CP_READ_UCHAR(pjBase, MM_BLT_START_STATUS_REG)                               \
)

#define CP_MM_ROP(ppdev, pjBase, val)                                           \
{                                                                               \
    CP_WRITE_UCHAR(pjBase, MM_BLT_ROP, val);                                   \
}                                                                               \

#define CP_MM_SRC_Y_OFFSET(ppdev, pjBase, val)                                   \
{                                                                               \
    CP_WRITE_USHORT(pjBase, MM_BLT_SRC_PITCH, val);                               \
}

#define CP_MM_DST_Y_OFFSET(ppdev, pjBase, val)                                   \
{                                                                               \
    CP_WRITE_USHORT(pjBase, MM_BLT_DST_PITCH, val);                               \
}

#define CP_MM_SRC_ADDR(ppdev, pjBase, val)                                       \
{                                                                               \
    CP_WRITE_ULONG(pjBase, MM_BLT_SRC_ADDR, val);                               \
}

#define CP_MM_DST_WRITE_MASK(ppdev, pjBase, val)                               \
{                                                                               \
    CP_WRITE_UCHAR(pjBase, MM_BLT_DST_WRITE_MASK, val);                           \
}

#define CP_MM_BLT_MODE(ppdev, pjBase, val)                                       \
{                                                                               \
    CP_WRITE_UCHAR(pjBase, MM_BLT_MODE, val);                                   \
    CP_WRITE_UCHAR(pjBase, MM_BLT_EXT, 0); \
}

#define CP_MM_START_REG(ppdev, pjBase, val)                                       \
{                                                                               \
    CP_WRITE_UCHAR(pjBase, MM_BLT_START_STATUS_REG, val);                       \
}

#define CP_MM_FG_COLOR(ppdev, pjBase, val)                                       \
{                                                                               \
    CP_WRITE_ULONG(pjBase, MM_BLT_FG_COLOR, val);                               \
}

#define CP_MM_BG_COLOR(ppdev, pjBase, val)                                       \
{                                                                               \
    CP_WRITE_ULONG(pjBase, MM_BLT_BG_COLOR, val);                               \
}

#define CP_MM_XCNT(ppdev, pjBase, val)                                           \
{                                                                               \
    CP_WRITE_USHORT(pjBase, MM_BLT_WIDTH, val);                                   \
}

#define CP_MM_YCNT(ppdev, pjBase, val)                                           \
{                                                                               \
    CP_WRITE_USHORT(pjBase, MM_BLT_HEIGHT, val);                               \
}

#define CP_MM_DST_ADDR(ppdev, pjBase, relval)                                   \
{                                                                               \
    CP_WRITE_ULONG(pjBase, MM_BLT_DST_ADDR, (relval) + ppdev->xyOffset);       \
}

#define CP_MM_DST_ADDR_ABS(ppdev, pjBase, val)                                   \
{                                                                               \
    CP_WRITE_ULONG(pjBase, MM_BLT_DST_ADDR, val);                               \
}

#define CP_MM_BLT_EXT_MODE(ppdev, pjBase, val)                                   \
{                                                                               \
    CP_WRITE_UCHAR(pjBase, MM_BLT_EXT, val);                                   \
}

#if 1 // D5480
#define CP_MM_BLT_MODE_PACKED(ppdev, pjBase, val)                              \
{                                                                              \
    CP_WRITE_ULONG(pjBase, MM_BLT_MODE, val);                                  \
}

// Note: The PACKXY_FAST macro is unsafe with negative coordinates
#define PACKXY(x, y)        (((y) << 16) | ((x) & 0xffff))
#define PACKXY_FAST(x, y)   (((y) << 16) | (x))

#define CP_MM_DST_XY_SAFE(ppdev, pjBase, x, y)                                 \
{                                                                              \
    CP_WRITE_ULONG(pjBase, MM_BLT_DST_X, PACKXY((x), (y)));                    \
}

#define CP_MM_DST_XY(ppdev, pjBase, x, y)                                      \
{                                                                              \
    CP_WRITE_ULONG(pjBase, MM_BLT_DST_X, PACKXY_FAST((x), (y)));               \
}

#define CP_MM_DST_X(ppdev, pjBase, x)                                          \
{                                                                              \
    CP_WRITE_USHORT(pjBase, MM_BLT_DST_X, (x));                                \
}

#define CP_MM_DST_Y(ppdev, pjBase, y)                                          \
{                                                                              \
    CP_WRITE_USHORT(pjBase, MM_BLT_DST_Y, (y));                                \
}

#define CP_MM_SRC_XY_SAFE(ppdev, pjBase, x, y)                                 \
{                                                                              \
    CP_WRITE_ULONG(pjBase, MM_BLT_SRC_X, PACKXY((x), (y)));                    \
}

#define CP_MM_SRC_XY(ppdev, pjBase, x, y)                                      \
{                                                                              \
    CP_WRITE_ULONG(pjBase, MM_BLT_SRC_X, PACKXY_FAST((x), (y)));               \
}

#define CP_MM_SRC_XY_PACKED(ppdev, pjBase, xy)                                 \
{                                                                              \
    CP_WRITE_ULONG(pjBase, MM_BLT_SRC_X, xy);                                  \
}

#define CP_MM_CLIP_ULXY_SAFE(ppdev, pjBase, x, y)                              \
{                                                                              \
    CP_WRITE_ULONG(pjBase, MM_BLT_CLIP_ULX, PACKXY((x), (y)));                 \
}

#define CP_MM_CLIP_ULXY(ppdev, pjBase, x, y)                                   \
{                                                                              \
    CP_WRITE_ULONG(pjBase, MM_BLT_CLIP_ULX, PACKXY_FAST((x), (y)));            \
}

#define CP_MM_CLIP_LRXY_SAFE(ppdev, pjBase, x, y)                              \
{                                                                              \
    CP_WRITE_ULONG(pjBase, MM_BLT_CLIP_LRX, PACKXY((x), (y)));                 \
}

#define CP_MM_CLIP_LRXY(ppdev, pjBase, x, y)                                   \
{                                                                              \
    CP_WRITE_ULONG(pjBase, MM_BLT_CLIP_LRX, PACKXY_FAST((x), (y)));            \
}
#endif // endif D5480
////////////////////////////////////////////////////////////////////////////////
//                      Blt engine IO register access macros                      //
////////////////////////////////////////////////////////////////////////////////

#define CP_IO_ACL_STAT(ppdev, pjPorts)                                           \
(                                                                               \
    CP_OUT_BYTE(pjPorts, INDEX_REG, IO_BLT_START_STATUS_REG),                   \
    CP_IN_BYTE(pjPorts, DATA_REG)                                               \
)

#define CP_IO_ROP(ppdev, pjPorts, val)                                           \
{                                                                               \
    CP_OUT_WORD(pjPorts, INDEX_REG, IO_BLT_ROP | ((val) << 8));                   \
}

#define CP_IO_SRC_Y_OFFSET(ppdev, pjPorts, val)                                   \
{                                                                               \
    CP_OUT_WORD(pjPorts, INDEX_REG,                                               \
                IO_BLT_SRC_PITCH_HIGH | ((val) & 0xff00));                       \
    CP_OUT_WORD(pjPorts, INDEX_REG,                                               \
                IO_BLT_SRC_PITCH_LOW  | (((val) & 0x00ff) << 8));               \
}

#define CP_IO_DST_Y_OFFSET(ppdev, pjPorts, val)                                   \
{                                                                               \
    CP_OUT_WORD(pjPorts, INDEX_REG,                                               \
                IO_BLT_DST_PITCH_HIGH | ((val) & 0xff00));                       \
    CP_OUT_WORD(pjPorts, INDEX_REG,                                               \
                IO_BLT_DST_PITCH_LOW  | (((val) & 0x00ff) << 8));               \
}

#define CP_IO_SRC_ADDR(ppdev, pjPorts, val)                                       \
{                                                                               \
    CP_OUT_WORD(pjPorts, INDEX_REG,                                               \
                IO_BLT_SRC_ADDR_HIGH | (((val) & 0xff0000) >> 8));               \
    CP_OUT_WORD(pjPorts, INDEX_REG,                                               \
                IO_BLT_SRC_ADDR_MID  | (((val) & 0x00ff00)));                   \
    CP_OUT_WORD(pjPorts, INDEX_REG,                                               \
                IO_BLT_SRC_ADDR_LOW  | (((val) & 0x0000ff) << 8));               \
}

#define CP_IO_BLT_MODE(ppdev, pjPorts, val)                                       \
{                                                                               \
    CP_OUT_WORD(pjPorts, INDEX_REG, IO_BLT_MODE | ((val) << 8));               \
}

#define CP_IO_START_REG(ppdev, pjPorts, val)                                   \
{                                                                               \
    CP_OUT_WORD(pjPorts, INDEX_REG,                                               \
                IO_BLT_START_STATUS_REG | ((val) << 8));                       \
}

#define CP_IO_FG_COLOR(ppdev, pjPorts, val)                                       \
{                                                                               \
    if (ppdev->flCaps & CAPS_TRUE_COLOR)                                       \
    {                                                                           \
        CP_OUT_WORD(pjPorts, INDEX_REG,                                           \
                    IO_BLT_FG_COLOR_BYTE_3 | (((val) & 0xff000000) >> 16));       \
        CP_OUT_WORD(pjPorts, INDEX_REG,                                           \
                    IO_BLT_FG_COLOR_BYTE_2 | (((val) & 0x00ff0000) >> 8));       \
    }                                                                           \
    CP_OUT_WORD(pjPorts, INDEX_REG,                                               \
                IO_BLT_FG_COLOR_BYTE_1 | ((val) & 0x0000ff00));                   \
    CP_OUT_WORD(pjPorts, INDEX_REG,                                               \
                IO_BLT_FG_COLOR_BYTE_0 | (((val) & 0x000000ff) << 8));           \
}

#define CP_IO_BG_COLOR(ppdev, pjPorts, val)                                       \
{                                                                               \
    if (ppdev->flCaps & CAPS_TRUE_COLOR)                                       \
    {                                                                           \
        CP_OUT_WORD(pjPorts, INDEX_REG,                                           \
                    IO_BLT_BG_COLOR_BYTE_3 | (((val) & 0xff000000) >> 16));       \
        CP_OUT_WORD(pjPorts, INDEX_REG,                                           \
                    IO_BLT_BG_COLOR_BYTE_2 | (((val) & 0x00ff0000) >> 8));       \
    }                                                                           \
    CP_OUT_WORD(pjPorts, INDEX_REG,                                               \
                IO_BLT_BG_COLOR_BYTE_1 | ((val) & 0x0000ff00));                   \
    CP_OUT_WORD(pjPorts, INDEX_REG,                                               \
                IO_BLT_BG_COLOR_BYTE_0 | (((val) & 0x000000ff) << 8));           \
}

#define CP_IO_XCNT(ppdev, pjPorts, val)                                           \
{                                                                               \
    CP_OUT_WORD(pjPorts, INDEX_REG,                                               \
                IO_BLT_WIDTH_HIGH | ((val) & 0xff00));                           \
    CP_OUT_WORD(pjPorts, INDEX_REG,                                               \
                IO_BLT_WIDTH_LOW  | (((val) & 0x00ff) << 8));                   \
}

#define CP_IO_YCNT(ppdev, pjPorts, val)                                           \
{                                                                               \
    CP_OUT_WORD(pjPorts, INDEX_REG,                                               \
                IO_BLT_HEIGHT_HIGH | ((val) & 0xff00));                           \
    CP_OUT_WORD(pjPorts, INDEX_REG,                                               \
                IO_BLT_HEIGHT_LOW  | (((val) & 0x00ff) << 8));                   \
}

#define CP_IO_DST_ADDR(ppdev, pjPorts, relval)                                   \
{                                                                               \
    LONG val = ((relval) + ppdev->xyOffset);                                   \
    CP_OUT_WORD(pjPorts, INDEX_REG,                                               \
                IO_BLT_DST_ADDR_HIGH | (((val) & 0xff0000) >> 8));               \
    CP_OUT_WORD(pjPorts, INDEX_REG,                                               \
                IO_BLT_DST_ADDR_MID  | ((val) & 0x00ff00));                       \
    CP_OUT_WORD(pjPorts, INDEX_REG,                                               \
                IO_BLT_DST_ADDR_LOW  | (((val) & 0x0000ff) << 8));               \
}

#define CP_IO_DST_ADDR_ABS(ppdev, pjPorts, val)                                   \
{                                                                               \
    CP_OUT_WORD(pjPorts, INDEX_REG,                                               \
                IO_BLT_DST_ADDR_HIGH | (((val) & 0xff0000) >> 8));               \
    CP_OUT_WORD(pjPorts, INDEX_REG,                                               \
                IO_BLT_DST_ADDR_MID  | ((val) & 0x00ff00));                       \
    CP_OUT_WORD(pjPorts, INDEX_REG,                                               \
                IO_BLT_DST_ADDR_LOW  | (((val) & 0x0000ff) << 8));               \
}

#if 1 // D5480
#define CP_IO_BLT_EXT_MODE(ppdev, pjPorts, val)                                \
{                                                                              \
    CP_OUT_WORD(pjPorts, INDEX_REG, (IO_BLT_EXT_MODE | ((val)<<8)));           \
}

#define CP_IO_DST_XY(ppdev, pjPorts, x, y)                                     \
{                                                                              \
    CP_OUT_WORD(pjPorts, INDEX_REG,                                            \
                IO_BLT_DST_X_HIGH | ((x) & 0x00ff00));                         \
    CP_OUT_WORD(pjPorts, INDEX_REG,                                            \
                IO_BLT_DST_X_LOW  | (((x) & 0x0000ff) << 8));                  \
    CP_OUT_WORD(pjPorts, INDEX_REG,                                            \
                IO_BLT_DST_Y_HIGH | ((y) & 0x00ff00));                         \
    CP_OUT_WORD(pjPorts, INDEX_REG,                                            \
                IO_BLT_DST_Y_LOW  | (((y) & 0x0000ff) << 8));                  \
}

#define CP_IO_DST_X(ppdev, pjPorts, x)                                         \
{                                                                              \
    CP_OUT_WORD(pjPorts, INDEX_REG,                                            \
                IO_BLT_DST_X_HIGH | ((x) & 0x00ff00));                         \
    CP_OUT_WORD(pjPorts, INDEX_REG,                                            \
                IO_BLT_DST_X_LOW  | (((x) & 0x0000ff) << 8));                  \
}

#define CP_IO_DST_Y(ppdev, pjPorts, y)                                         \
{                                                                              \
    CP_OUT_WORD(pjPorts, INDEX_REG,                                            \
                IO_BLT_DST_Y_HIGH | ((y) & 0x00ff00));                         \
    CP_OUT_WORD(pjPorts, INDEX_REG,                                            \
                IO_BLT_DST_Y_LOW  | (((y) & 0x0000ff) << 8));                  \
}

#define CP_IO_SRC_XY(ppdev, pjPorts, x, y)                                     \
{                                                                              \
    CP_OUT_WORD(pjPorts, INDEX_REG,                                            \
                IO_BLT_SRC_X_HIGH | ((x) & 0x00ff00));                         \
    CP_OUT_WORD(pjPorts, INDEX_REG,                                            \
                IO_BLT_SRC_X_LOW  | (((x) & 0x0000ff) << 8));                  \
    CP_OUT_WORD(pjPorts, INDEX_REG,                                            \
                IO_BLT_SRC_Y_HIGH | ((y) & 0x00ff00));                         \
    CP_OUT_WORD(pjPorts, INDEX_REG,                                            \
                IO_BLT_SRC_Y_LOW  | (((y) & 0x0000ff) << 8));                  \
}

#define CP_IO_CLIP_ULXY(ppdev, pjPorts, x, y)                                  \
{                                                                              \
    CP_OUT_WORD(pjPorts, INDEX_REG,                                            \
                IO_BLT_CLIP_ULX_HIGH | ((x) & 0x00ff00));                      \
    CP_OUT_WORD(pjPorts, INDEX_REG,                                            \
                IO_BLT_CLIP_ULX_LOW  | (((x) & 0x0000ff) << 8));               \
    CP_OUT_WORD(pjPorts, INDEX_REG,                                            \
                IO_BLT_CLIP_ULY_HIGH | ((y) & 0x00ff00));                      \
    CP_OUT_WORD(pjPorts, INDEX_REG,                                            \
                IO_BLT_CLIP_ULY_LOW  | (((y) & 0x0000ff) << 8));               \
}

#define CP_IO_CLIP_LRXY(ppdev, pjPorts, x, y)                                  \
{                                                                              \
    CP_OUT_WORD(pjPorts, INDEX_REG,                                            \
                IO_BLT_CLIP_LRX_HIGH | ((x) & 0x00ff00));                      \
    CP_OUT_WORD(pjPorts, INDEX_REG,                                            \
                IO_BLT_CLIP_LRX_LOW  | (((x) & 0x0000ff) << 8));               \
    CP_OUT_WORD(pjPorts, INDEX_REG,                                            \
                IO_BLT_CLIP_LRY_HIGH | ((y) & 0x00ff00));                      \
    CP_OUT_WORD(pjPorts, INDEX_REG,                                            \
                IO_BLT_CLIP_LRY_LOW  | (((y) & 0x0000ff) << 8));               \
}
#endif // endif D5480
////////////////////////////////////////////////////////////////////////////////
//                               Hardware registers                              //
////////////////////////////////////////////////////////////////////////////////

#if 1 // D5480
#define ENABLE_SOLID_FILL_PACKED        0x04000000
#define INVERT_SOURCE_PACKED            0x02000000
#define SOURCE_GRANULARITY_PACKED       0x01000000
#define ENABLE_COMMAND_LIST_PACKED      0x80000000
#define ENABLE_XY_POSITION_PACKED       0x40000000
#define ENABLE_CLIP_RECT_PACKED         0x20000000
#endif // endif D5480

#if 1 // D5480
#define ENABLE_COMMAND_LIST             0x80
#define ENABLE_XY_POSITION              0x40
#define ENABLE_CLIP_RECT                0x20
#endif // endif D5480

#define ENABLE_COLOR_EXPAND             0x80
#define ENABLE_8x8_PATTERN_COPY         0x40
#define SET_16BPP_COLOR                 0x10
#define SET_24BPP_COLOR                 0x20
#define SET_32BPP_COLOR                 0x30
#define ENABLE_TRANSPARENCY_COMPARE     0x08
#define SRC_CPU_DATA                    0x04
#define DST_CPU_DATA                    0x02
#define DECREMENT_BLT_ADDRESS           0x01

#define ENABLE_SOLID_FILL               0x04
#define INVERT_SOURCE                   0x02
#define SOURCE_GRANULARITY              0x01

#define IO_BLT_XPAR_COLOR_LOW           0x34
#define IO_BLT_XPAR_COLOR_HIGH          0x35
#define IO_BLT_XPAR_COLOR_MASK_LOW      0x38
#define IO_BLT_XPAR_COLOR_MASK_HIGH     0x39

#define IO_BLT_BG_COLOR_BYTE_0          0x00
#define IO_BLT_BG_COLOR_BYTE_1          0x10
#define IO_BLT_BG_COLOR_BYTE_2          0x12
#define IO_BLT_BG_COLOR_BYTE_3          0x14
#define IO_BLT_FG_COLOR_BYTE_0          0x01
#define IO_BLT_FG_COLOR_BYTE_1          0x11
#define IO_BLT_FG_COLOR_BYTE_2          0x13
#define IO_BLT_FG_COLOR_BYTE_3          0x15
#define IO_BLT_WIDTH_LOW                0x20
#define IO_BLT_WIDTH_HIGH               0x21
#define IO_BLT_HEIGHT_LOW               0x22
#define IO_BLT_HEIGHT_HIGH              0x23
#define IO_BLT_DST_PITCH_LOW            0x24
#define IO_BLT_DST_PITCH_HIGH           0x25
#define IO_BLT_SRC_PITCH_LOW            0x26
#define IO_BLT_SRC_PITCH_HIGH           0x27
#define IO_BLT_DST_ADDR_LOW             0x28
#define IO_BLT_DST_ADDR_MID             0x29
#define IO_BLT_DST_ADDR_HIGH            0x2A
#define IO_BLT_SRC_ADDR_LOW             0x2C
#define IO_BLT_SRC_ADDR_MID             0x2D
#define IO_BLT_SRC_ADDR_HIGH            0x2E
#define IO_BLT_MODE                     0x30
#define IO_BLT_ROP                      0x32
#define IO_BLT_START_STATUS_REG         0x31
#if 1 // D5480
#define IO_BLT_EXT_MODE                 0x33
#define IO_BLT_DST_X_LOW                0x40    
#define IO_BLT_DST_X_HIGH               0x41
#define IO_BLT_DST_Y_LOW                0x42
#define IO_BLT_DST_Y_HIGH               0x43
#define IO_BLT_SRC_X_LOW                0x44
#define IO_BLT_SRC_X_HIGH               0x45
#define IO_BLT_SRC_Y_LOW                0x46
#define IO_BLT_SRC_Y_HIGH               0x47
#define IO_BLT_CLIP_ULX_LOW             0x48
#define IO_BLT_CLIP_ULX_HIGH            0x49
#define IO_BLT_CLIP_ULY_LOW             0x4A
#define IO_BLT_CLIP_ULY_HIGH            0x4B
#define IO_BLT_CLIP_LRX_LOW             0x4C
#define IO_BLT_CLIP_LRX_HIGH            0x4D
#define IO_BLT_CLIP_LRY_LOW             0x4E
#define IO_BLT_CLIP_LRY_HIGH            0x4F
#endif // endif D5480

#define MM_BLT_BG_COLOR                 0x00
#define MM_BLT_FG_COLOR                 0x04
#define MM_BLT_WIDTH                    0x08
#define MM_BLT_HEIGHT                   0x0A
#define MM_BLT_DST_PITCH                0x0C
#define MM_BLT_SRC_PITCH                0x0E
#define MM_BLT_DST_ADDR                 0x10
#define MM_BLT_SRC_ADDR                 0x14
#define MM_BLT_DST_WRITE_MASK            0x17
#define MM_BLT_MODE                     0x18
#define MM_BLT_ROP                      0x1A
#define MM_BLT_EXT                      0x1B
#define MM_BLT_COLOR_KEY                0x1C
#define MM_BLT_START_STATUS_REG         0x40
#if 1 // D5480
#define MM_BLT_DST_X                    0x28
#define MM_BLT_DST_Y                    0x2A
#define MM_BLT_SRC_X                    0x2C
#define MM_BLT_SRC_Y                    0x2E
#define MM_BLT_CLIP_ULX                 0x30
#define MM_BLT_CLIP_LRX                 0x34
#endif // endif D5480

#define DIR_TBLR                        0x00    // Top-Bottom, Left-Right
#define DIR_BTRL                        0x01    // Bottom-Top, Right-Left

#define BLT_AUTO_START                  0x80
#define BLT_SECOND_APERTURE                0x40    // second aperture, sge01
#define BLT_PROGRESS_STATUS             0x08
#define BLT_RESET                       0x04
#define BLT_START                       0x02
#define BLT_SUSPEND                     0x02
#define BLT_STATUS                      0x01

////////////////////////////////////////////////////////////////////////////////
//                     Some handy clipping control structures                      //
////////////////////////////////////////////////////////////////////////////////

typedef struct {
    ULONG   c;
    RECTL   arcl[8];
} ENUMRECTS8, *PENUMRECTS8;

//
// The following two macros touch registers which are only available
// on the 5446 and 5480.  Only set these registers if we are on one
// of these chips.
//

#define CP_IO_XPAR_COLOR(ppdev, pjPorts, val)                                   \
{                                                                               \
    if (ppdev->flCaps & CAPS_TRANSPARENCY) {  \
        CP_OUT_WORD(pjPorts, INDEX_REG,                                               \
                    IO_BLT_XPAR_COLOR_HIGH | ((val) & 0xff00));                       \
        CP_OUT_WORD(pjPorts, INDEX_REG,                                               \
                    IO_BLT_XPAR_COLOR_LOW  | (((val) & 0x00ff) << 8));               \
    }  \
}

#define CP_IO_XPAR_COLOR_MASK(ppdev, pjPorts, val)                               \
{                                                                                \
    if (ppdev->flCaps & CAPS_TRANSPARENCY) {  \
        CP_OUT_WORD(pjPorts, INDEX_REG,                                               \
                    IO_BLT_XPAR_COLOR_MASK_HIGH | ((val) & 0xff00));               \
        CP_OUT_WORD(pjPorts, INDEX_REG,                                               \
                    IO_BLT_XPAR_COLOR_MASK_LOW  | (((val) & 0x00ff) << 8));           \
    }  \
}

////////////////////////////////////////////////////////////////////////////////
//                                 MM IO settings                                  //
////////////////////////////////////////////////////////////////////////////////

#define CP_SET_MM_IO_FLAGS(ppdev, pjPorts, val)                                   \
{                                                                               \
    CP_OUT_WORD(pjPorts, SR_INDEX, (0x17  | (val << 8)));                       \
}

#define CP_GET_MM_IO_FLAGS(ppdev, pjPorts)                                       \
(                                                                               \
    CP_OUT_BYTE(pjPorts, SR_INDEX, 0x17),                                       \
    CP_IN_BYTE(pjPorts, SR_DATA)                                               \
)

#define CP_ENABLE_MM_IO(ppdev, pjPorts)                                           \
{                                                                               \
    BYTE jAttr;                                                                   \
    ppdev->flCaps |= CAPS_MM_IO;                                               \
    jAttr = CP_GET_MM_IO_FLAGS(ppdev, pjPorts);                                   \
    jAttr |= 0x4;                                                               \
    jAttr &= ~0x40;                                                              \
    CP_SET_MM_IO_FLAGS(ppdev, pjPorts, jAttr);                                   \
}

#define CP_DISABLE_MM_IO(ppdev, pjPorts)                                       \
{                                                                               \
    BYTE jAttr;                                                                   \
    if (ppdev->flCaps & CAPS_MM_IO)                                               \
    {                                                                           \
        CP_MM_WAIT_FOR_BLT_COMPLETE(ppdev, ppdev->pjBase);                       \
    }                                                                           \
    else                                                                       \
    {                                                                           \
        CP_IO_WAIT_FOR_BLT_COMPLETE(ppdev, pjPorts);                           \
    }                                                                           \
    ppdev->flCaps &= ~CAPS_MM_IO;                                               \
    jAttr = CP_GET_MM_IO_FLAGS(ppdev, pjPorts);                                   \
    jAttr &= ~0x4;                                                               \
    CP_SET_MM_IO_FLAGS(ppdev, pjPorts, jAttr);                                   \
}

#define WAIT_COUNT 0x100000

// #if DBG //DBG
#if (DBG_STRESS_FAILURE || DBG)

    #define WAIT_BUSY_BLT(ppdev, pjBase)                                     \
    {                                                                        \
        ULONG ul = 0;                                                        \
        do                                                                   \
        {                                                                    \
            ul++;                                                            \
            if (ul >= WAIT_COUNT)                                            \
            {                                                                \
                DISPDBG((0, "WAIT_BUSY_BLT timeout"                          \
                            " file(%s) line(%d)", __FILE__, __LINE__));      \
                DISPDBG((0, "Last start blt was at file(%s) line(%d)",       \
                         glpszLastBltFile, gulLastBltLine));                 \
                DISPDBG((0, "press 'g' to continue...")); EngDebugBreak();   \
                ul = 0;                                                      \
            }                                                                \
        } while (CP_MM_ACL_STAT(ppdev, pjBase) & 0x10);                      \
    }
    
    extern ULONG   gulLastBltLine;
    extern CHAR *  glpszLastBltFile;
    extern BOOL    gbResetOnTimeout;

    ////////////////////////////////////////////////////////////////////////////
    //                 Wait for the Blt Operation to Complete                 //
    ////////////////////////////////////////////////////////////////////////////

    #define CP_IO_WAIT_FOR_BLT_COMPLETE(ppdev, pjPorts)                           \
    {                                                                           \
        ULONG ul = 0;                                                           \
        do                                                                       \
        {                                                                       \
            ul++;                                                               \
            if (ul >= WAIT_COUNT)                                               \
            {                                                                   \
                DISPDBG((0, "WAIT_FOR_BLT_COMPLETE timeout"                       \
                            " file(%s) line(%d)", __FILE__, __LINE__));           \
                DISPDBG((0,"Last start blt was at file(%s) line(%d)",           \
                           glpszLastBltFile, gulLastBltLine));                   \
                DISPDBG((0, "press 'g' to continue...")); EngDebugBreak(); \
                ul = 0;                                                           \
                if (gbResetOnTimeout)                                           \
                {                                                               \
                    CP_IO_START_REG(ppdev, pjPorts, BLT_RESET);                   \
                }                                                               \
            }                                                                  \
        } while (CP_IO_ACL_STAT(ppdev, pjPorts) & BLT_STATUS);                    \
    }

    #define CP_MM_WAIT_FOR_BLT_COMPLETE(ppdev, pjBase)                            \
    {                                                                          \
        ULONG ul = 0;                                                            \
        do                                                                     \
        {                                                                      \
            ul++;                                                              \
            if (ul >= WAIT_COUNT)                                              \
            {                                                                  \
                DISPDBG((0, "WAIT_FOR_BLT_COMPLETE timeout"                       \
                            " file(%s) line(%d)", __FILE__, __LINE__));           \
                DISPDBG((0, "Last start blt was at file(%s) line(%d)",           \
                         glpszLastBltFile, gulLastBltLine));                   \
                DISPDBG((0, "press 'g' to continue...")); EngDebugBreak(); \
                ul = 0;                                                           \
                if (gbResetOnTimeout)                                           \
                {                                                               \
                    CP_MM_START_REG(ppdev, pjBase, BLT_RESET);                    \
                }                                                               \
            }                                                                  \
        } while (CP_MM_ACL_STAT(ppdev, pjBase) & BLT_STATUS);                    \
    }

    ////////////////////////////////////////////////////////////////////////////
    //               Start the Blt Operation - save debug info                //
    ////////////////////////////////////////////////////////////////////////////

    #define CP_IO_START_BLT(ppdev, pjPorts)                                    \
    {                                                                          \
        DISPDBG((5, "START_BLT file(%s) line(%d)", __FILE__, __LINE__));       \
        gulLastBltLine = __LINE__;                                             \
        glpszLastBltFile = __FILE__;                                           \
        CP_IO_START_REG(ppdev, pjPorts, BLT_START);                            \
    }

    #define CP_MM_START_BLT(ppdev, pjBase)                                        \
    {                                                                          \
        DISPDBG((5, "START_BLT file(%s) line(%d)", __FILE__, __LINE__));       \
        gulLastBltLine = __LINE__;                                             \
        glpszLastBltFile = __FILE__;                                           \
        if (!(ppdev->flCaps & CAPS_AUTOSTART))                                   \
        {                                                                      \
            CP_MM_START_REG(ppdev, pjBase, BLT_START);                            \
        }                                                                      \
    }

#else

    #define WAIT_BUSY_BLT(ppdev, pjBase)                                     \
    while (CP_MM_ACL_STAT(ppdev, pjBase) & 0x10)


    ////////////////////////////////////////////////////////////////////////////
    //                 Wait for the Blt Operation to Complete                 //
    ////////////////////////////////////////////////////////////////////////////

    #define CP_IO_WAIT_FOR_BLT_COMPLETE(ppdev, pjPorts)                     \
    {                                                                       \
        while (CP_IO_ACL_STAT(ppdev, pjPorts) & BLT_STATUS);                \
    }

    #define CP_MM_WAIT_FOR_BLT_COMPLETE(ppdev, pjBase)                      \
    {                                                                       \
        while (CP_MM_ACL_STAT(ppdev, pjBase) & BLT_STATUS);                 \
    }

    ////////////////////////////////////////////////////////////////////////////
    //                        Start the Blt Operation                         //
    ////////////////////////////////////////////////////////////////////////////

    #define CP_IO_START_BLT(ppdev, pjPorts)                                    \
    {                                                                          \
        CP_IO_START_REG(ppdev, pjPorts, BLT_START);                            \
    }

    #define CP_MM_START_BLT(ppdev, pjBase)                                     \
    {                                                                           \
        if (!(ppdev->flCaps & CAPS_AUTOSTART))                                   \
        {                                                                      \
            CP_MM_START_REG(ppdev, pjBase, BLT_START);                         \
        }                                                                       \
    }

#endif


////////////////////////////////////////////////////////////////////////////////
//                                 TRANSFER_DWORD                                  //
//     32-bit transfers to host transfer buffer, the source has to be aligned      //
////////////////////////////////////////////////////////////////////////////////

#define TRANSFER_DWORD_ALIGNED(ppdev, pulXfer, p, c)                           \
{                                                                              \
    ULONG  mcd    = (ULONG)(c);                                                        \
    ULONG* mpdSrc = (ULONG*) (p);                                                \
    ASSERTDD((((ULONG_PTR) p) & 3) == 0, "Transfer not dword aligned");         \
    ASSERTDD((c) > 0, "Can't have a zero transfer count");                     \
                                                                               \
    CP_EIEIO();                                                                \
    do {                                                                       \
        CP_MEMORY_BARRIER();                                                   \
        /* *pulXfer = *mpdSrc++; */                                            \
        WRITE_REGISTER_ULONG((PULONG)(pulXfer), *mpdSrc);                      \
        mpdSrc++;                                                              \
    } while (--mcd);                                                           \
}

////////////////////////////////////////////////////////////////////////////////
//                                 TRANSFER_DWORD                                  //
// 32-bit transfers to host transfer buffer, the source has not to be aligned //
////////////////////////////////////////////////////////////////////////////////

#define TRANSFER_DWORD(ppdev, pulXfer, p, c)                                   \
{                                                                              \
    ULONG mcd               = (c);                                                \
    ULONG UNALIGNED* mpdSrc = (ULONG*) (p);                                       \
    ASSERTDD((c) > 0, "Can't have a zero transfer count");                     \
                                                                               \
    CP_EIEIO();                                                                \
    do {                                                                       \
        CP_MEMORY_BARRIER();                                                   \
        /* *pulXfer = *mpdSrc++; */                                            \
        WRITE_REGISTER_ULONG((PULONG)(pulXfer), *mpdSrc);                      \
        mpdSrc++;                                                              \
    } while (--mcd);                                                           \
}

#if 1 // D5480
////////////////////////////////////////////////////////////////////////////////
//                                  Command List stuff                                  //
////////////////////////////////////////////////////////////////////////////////

#define COMMAND_TOTAL_PACKETS        127             // We support 128 packets.
#define COMMAND_BUFFER_SIZE          4096
#define COMMAND_BUFFER_ALIGN          255

#define COMMAND_LAST_PACKET         0x80000000
#define COMMAND_DISCARD_SRC         0x40000000
#define COMMAND_FOURTH_NOTHING      0x30000000
#define COMMAND_FOURTH_BLT_ROP      0x10000000
#define COMMAND_FOURTH_DST_SRC      0x00000000
#define COMMAND_NOSRC_NOTHING       0x70000000


#define CP_MM_CL_SWITCH(ppdev)                                                 \
{                                                                              \
    if( ppdev->pCommandList == ppdev->pCLFirst )                               \
        ppdev->pCommandList = ppdev->pCLSecond;                                \
    else                                                                       \
        ppdev->pCommandList = ppdev->pCLFirst;                                 \
}
#endif // endif D5480

////////////////////////////////////////////////////////////////////////////////
//                                  Pointer stuff                                  //
////////////////////////////////////////////////////////////////////////////////

#define SPRITE_BUFFER_SIZE              256

#define POINTER_X_POSITION              0x10
#define POINTER_Y_POSITION              0x11
#define POINTER_ATTRIBUTES              0x12
#define POINTER_OFFSET                  0x13

#define ENABLE_POINTER                  0x01
#define ALLOW_DAC_ACCESS_TO_EXT_COLORS  0x02
#define POINTER_SIZE_64x64              0x04
#define OVERSCAN_COLOR_PROTECT          0x80

#define POINTER_X_SHIFT                 0x01
#define POINTER_Y_SHIFT                 0x02
#define POINTER_SHAPE_RESET             0x04
#define POINTER_DISABLED                0x08

#define CP_PTR_XY_POS(ppdev, pjPorts, x, y)                                       \
{                                                                               \
    DISPDBG((10, "\t CP_PTR_XY_POS (%d,%d)", x, y));                           \
    CP_OUT_WORD(pjPorts, SR_INDEX,                                               \
                (POINTER_Y_POSITION | ((y & 0x7) << 5)) | ((y & 0x7f8) << 5)); \
    CP_OUT_WORD(pjPorts, SR_INDEX,                                               \
                (POINTER_X_POSITION | ((x & 0x7) << 5)) | ((x & 0x7f8) << 5)); \
    /* [HWBUG] - must set position twice */                                       \
    CP_OUT_WORD(pjPorts, SR_INDEX,                                               \
                (POINTER_Y_POSITION | ((y & 0x7) << 5)) | ((y & 0x7f8) << 5)); \
    CP_OUT_WORD(pjPorts, SR_INDEX,                                               \
                (POINTER_X_POSITION | ((x & 0x7) << 5)) | ((x & 0x7f8) << 5)); \
}

#define CP_PTR_SET_FLAGS(ppdev, pjPorts, val)                                   \
{                                                                               \
    CP_OUT_WORD(pjPorts, SR_INDEX, POINTER_ATTRIBUTES | (val << 8));           \
}

#define CP_PTR_GET_FLAGS(ppdev, pjPorts)                                       \
(                                                                               \
    CP_OUT_BYTE(pjPorts, SR_INDEX, POINTER_ATTRIBUTES),                           \
    CP_IN_BYTE(pjPorts, SR_DATA)                                               \
)

#define CP_PTR_ADDR(ppdev, pjPorts, val)                                       \
{                                                                               \
    CP_OUT_WORD(pjPorts, SR_INDEX, POINTER_OFFSET | (val << 8));               \
}

#define CP_PTR_ENABLE(ppdev, pjPorts)                                           \
{                                                                               \
    BYTE jAttr;                                                                   \
    DISPDBG((10, "\t CP_PTR_ENABLE"));                                           \
    if (ppdev->flPointer & POINTER_DISABLED)                                   \
    {                                                                           \
        ppdev->flPointer &= ~POINTER_DISABLED;                                   \
        jAttr = CP_PTR_GET_FLAGS(ppdev, pjPorts);                               \
        jAttr |= ENABLE_POINTER;                                               \
        CP_PTR_SET_FLAGS(ppdev, pjPorts, jAttr);                               \
        DISPDBG((10, "\t CP_PTR_ENABLE - done"));                               \
    }                                                                           \
}

#define CP_PTR_DISABLE(ppdev, pjPorts)                                           \
{                                                                               \
    BYTE jAttr;                                                                   \
    DISPDBG((10, "\t CP_PTR_DISABLE"));                                           \
    if (!(ppdev->flPointer & POINTER_DISABLED))                                   \
    {                                                                           \
        ppdev->flPointer |= POINTER_DISABLED;                                   \
        jAttr = CP_PTR_GET_FLAGS(ppdev, pjPorts);                               \
        jAttr &= ~ENABLE_POINTER;                                               \
        CP_PTR_SET_FLAGS(ppdev, pjPorts, jAttr);                               \
        CP_PTR_XY_POS(ppdev, pjPorts, 2047, 2047);                               \
        DISPDBG((10, "\t CP_PTR_DISABLE - done"));                               \
    }                                                                           \
}

////////////////////////////////////////////////////////////////////////////////
//                        ROP definitions for the hardware                      //
////////////////////////////////////////////////////////////////////////////////

#define R3_BLACKNESS                0x00    // dest = BLACK
#define R3_NOTSRCERASE              0x11    // dest = (NOT src) AND (NOT dest)
#define R3_NOTSRCCOPY               0x33    // dest = (NOT source)
#define R3_SRCERASE                 0x44    // dest = source AND (NOT dest )
#define R3_DSTINVERT                0x55    // dest = (NOT dest)
#define R3_PATINVERT                0x5A    // dest = pattern XOR dest
#define R3_SRCINVERT                0x66    // dest = source XOR dest
#define R3_SRCAND                   0x88    // dest = source AND dest
#define R3_NOP                      0xAA    // dest = dest
#define R3_MERGEPAINT               0xBB    // dest = (NOT source) OR dest
#define R3_MERGECOPY                0xC0    // dest = (source AND pattern)
#define R3_SRCCOPY                  0xCC    // dest = source
#define R3_SRCPAINT                 0xEE    // dest = source OR dest
#define R3_PATCOPY                  0xF0    // dest = pattern
#define R3_PATPAINT                 0xFB    // dest = DPSnoo
#define R3_WHITENESS                0xFF    // dest = WHITE

#define R4_BLACKNESS                0x0000  // dest = BLACK
#define R4_NOTSRCERASE              0x1111  // dest = (NOT src) AND (NOT dest)
#define R4_NOTSRCCOPY               0x3333  // dest = (NOT source)
#define R4_SRCERASE                 0x4444  // dest = source AND (NOT dest )
#define R4_DSTINVERT                0x5555  // dest = (NOT dest)
#define R4_PATINVERT                0x5A5A  // dest = pattern XOR dest
#define R4_SRCINVERT                0x6666  // dest = source XOR dest
#define R4_SRCAND                   0x8888  // dest = source AND dest
#define R4_MERGEPAINT               0xBBBB  // dest = (NOT source) OR dest
#define R4_MERGECOPY                0xC0C0  // dest = (source AND pattern)
#define R4_SRCCOPY                  0xCCCC  // dest = source
#define R4_SRCPAINT                 0xEEEE  // dest = source OR dest
#define R4_PATCOPY                  0xF0F0  // dest = pattern
#define R4_PATPAINT                 0xFBFB  // dest = DPSnoo
#define R4_WHITENESS                0xFFFF  // dest = WHITE


#define HW_0                        0x00
#define HW_1                        0x0E
#define HW_P                        0x0D
#define HW_D                        0x06
#define HW_Pn                       0xD0
#define HW_Dn                       0x0B
#define HW_DPa                      0x05
#define HW_PDna                     0x09
#define HW_DPna                     0x50
#define HW_DPon                     0x90
#define HW_DPo                      0x6D
#define HW_PDno                     0xAD
#define HW_DPno                     0xD6
#define HW_DPan                     0xDA
#define HW_DPx                      0x59
#define HW_DPxn                     0x95

#define CL_BLACKNESS                HW_0
#define CL_WHITENESS                HW_1
#define CL_SRC_COPY                 HW_P
#define CL_DST                      HW_D
#define CL_NOT_SRC_COPY             HW_Pn
#define CL_DST_INVERT               HW_Dn
#define CL_SRC_AND                  HW_DPa
#define CL_SRC_ERASE                HW_PDna
#define CL_NOT_SRC_OR_DST           HW_DPna
#define CL_NOT_SRC_ERASE            HW_DPon
#define CL_SRC_PAINT                HW_DPo
#define CL_SRC_AND_NOT_DST          HW_PDno
#define CL_MERGE_PAINT              HW_DPno
#define CL_NOT_SRC_AND_NOT_DST      HW_DPan
#define CL_SRC_INVERT               HW_DPx
#define CL_NOT_SRC                  HW_PDxn

#if 1 // D5480
#define HW_PACKED_0                 0x000000    
#define HW_PACKED_1                 0x0E0000
#define HW_PACKED_P                 0x0D0000
#define HW_PACKED_D                 0x060000
#define HW_PACKED_Pn                0xD00000
#define HW_PACKED_Dn                0x0B0000
#define HW_PACKED_DPa               0x050000
#define HW_PACKED_PDna              0x090000
#define HW_PACKED_DPna              0x500000
#define HW_PACKED_DPon              0x900000
#define HW_PACKED_DPo               0x6D0000
#define HW_PACKED_PDno              0xAD0000
#define HW_PACKED_DPno              0xD60000
#define HW_PACKED_DPan              0xDA0000
#define HW_PACKED_DPx               0x590000
#define HW_PACKED_DPxn              0x950000

#define CL_PACKED_BLACKNESS             HW_PACKED_0
#define CL_PACKED_WHITENESS             HW_PACKED_1
#define CL_PACKED_SRC_COPY              HW_PACKED_P
#define CL_PACKED_DST                   HW_PACKED_D
#define CL_PACKED_NOT_SRC_COPY          HW_PACKED_Pn
#define CL_PACKED_DST_INVERT            HW_PACKED_Dn
#define CL_PACKED_SRC_AND               HW_PACKED_DPa
#define CL_PACKED_SRC_ERASE             HW_PACKED_PDna
#define CL_PACKED_NOT_SRC_OR_DST        HW_PACKED_DPna
#define CL_PACKED_NOT_SRC_ERASE         HW_PACKED_DPon
#define CL_PACKED_SRC_PAINT             HW_PACKED_DPo
#define CL_PACKED_SRC_AND_NOT_DST       HW_PACKED_PDno
#define CL_PACKED_MERGE_PAINT           HW_PACKED_DPno
#define CL_PACKED_NOT_SRC_AND_NOT_DST   HW_PACKED_DPan
#define CL_PACKED_SRC_INVERT            HW_PACKED_DPx
#define CL_PACKED_NOT_SRC               HW_PACKED_PDxn

#endif // endif D5480
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\cirrus\disp\lines.h ===
/******************************Module*Header*******************************\
* Module Name: lines.h
*
* Line drawing constants and structures.
*
* NOTE: This file mirrors LINES.INC.  Changes here must be reflected in
* the .inc file!
*
* Copyright (c) 1992-1995 Microsoft Corporation
\**************************************************************************/

typedef struct _PDEV PDEV;      // Handy forward declaration

// # of strip drawers in every group:

#define NUM_STRIP_DRAW_DIRECTIONS 4

// # of strip drawers for doing either solid lines or styled lines:

#define NUM_STRIP_DRAW_STYLES 8

typedef LONG STYLEPOS;

#define STYLE_MAX_COUNT     16
#define STYLE_MAX_VALUE     0x3fffL
#define RUN_MAX             20
#define STRIP_MAX           100
#define STYLE_DENSITY       3

// Flip and round flags:

#define FL_H_ROUND_DOWN         0x00000080L     // .... .... 1... ....
#define FL_V_ROUND_DOWN         0x00008000L     // 1... .... .... ....

#define FL_FLIP_D               0x00000005L     // .... .... .... .1.1
#define FL_FLIP_V               0x00000008L     // .... .... .... 1...
#define FL_FLIP_SLOPE_ONE       0x00000010L     // .... .... ...1 ....
#define FL_FLIP_HALF            0x00000002L     // .... .... .... ..1.
#define FL_FLIP_H               0x00000200L     // .... ..1. .... ....

#define FL_ROUND_MASK           0x0000001CL     // .... .... ...1 11..
#define FL_ROUND_SHIFT          2

#define FL_RECTLCLIP_MASK       0x0000000CL     // .... .... .... 11..
#define FL_RECTLCLIP_SHIFT      2

#define FL_STRIP_MASK           0x00000003L     // .... .... .... ..11
#define FL_STRIP_SHIFT          0

#define FL_SIMPLE_CLIP          0x00000020      // .... .... ..1. ....
#define FL_COMPLEX_CLIP         0x00000040      // .... .... .1.. ....
#define FL_CLIP                (FL_SIMPLE_CLIP | FL_COMPLEX_CLIP)

#define FL_STYLED               0x00000400L     // .... .1.. .... ....
#define FL_ALTERNATESTYLED      0x00001000L     // ...1 .... .... ....

#define FL_STYLE_MASK           0x00000400L
#define FL_STYLE_SHIFT          10

#define FL_LAST_PEL_INCLUSIVE   0x00002000L     // ..1. .... .... ....

// Miscellaneous DDA defines:

#define LROUND(x, flRoundDown) (((x) + F/2 - ((flRoundDown) > 0)) >> 4)
#define F                     16
#define FLOG2                 4
#define LFLOOR(x)             ((x) >> 4)
#define FXFRAC(x)             ((x) & (F - 1))

////////////////////////////////////////////////////////////////////////////
// NOTE: The following structures must exactly match those declared in
//       lines.inc!

typedef struct _STRIP {
    LONG   cStrips;               // # of strips in array
    LONG   flFlips;               // Indicates if line goes up or down
    POINTL ptlStart;             // first point
    LONG   alStrips[STRIP_MAX];   // Array of strips
} STRIP;

typedef struct _LINESTATE {
    STYLEPOS*       pspStart;       // Pointer to start of style array
    STYLEPOS*       pspEnd;         // Pointer to end of style array
    STYLEPOS*       psp;            // Pointer to current style entry

    STYLEPOS        spRemaining;    // To go in current style
    STYLEPOS        spTotal;        // Sum of style array
    STYLEPOS        spTotal2;       // Twice sum of style array
    STYLEPOS        spNext;         // Style state at start of next line
    STYLEPOS        spComplex;      // Style state at start of complex clip line

    STYLEPOS*       aspRtoL;        // Style array in right-to-left order
    STYLEPOS*       aspLtoR;        // Style array in left-to-right order

    ULONG           ulStyleMask;    // Are we working on a gap in the style?
                                    // 0xff if yes, 0x0 if not
    ULONG           xyDensity;      // Density of style
    ULONG           cStyle;         // Size of style array

    ULONG           ulStyleMaskLtoR;// Original style mask, left-to-right order
    ULONG           ulStyleMaskRtoL;// Original style mask, right-to-left order

    BOOL            ulStartMask;    // Determines if first element in style
                                    // array is for a gap or a dash

} LINESTATE;                        /* ls */

// Strip drawer prototype:

typedef VOID (*PFNSTRIP)(PDEV*, STRIP*, LINESTATE*);

// Strip drawers:

VOID vIoSolidHorizontal(PDEV* ppdev, STRIP *pStrip, LINESTATE *pLineState);
VOID vIoSolidVertical(PDEV* ppdev, STRIP *pStrip, LINESTATE *pLineState);
VOID vIoSolidDiagonalHorizontal(PDEV* ppdev, STRIP *pStrip, LINESTATE *pLineState);
VOID vIoSolidDiagonalVertical(PDEV* ppdev, STRIP *pStrip, LINESTATE *pLineState);
VOID vIoStyledHorizontal(PDEV* ppdev, STRIP *pStrip, LINESTATE *pLineState);
VOID vIoStyledVertical(PDEV* ppdev, STRIP *pStrip, LINESTATE *pLineState);

VOID vMmSolidHorizontal(PDEV* ppdev, STRIP *pStrip, LINESTATE *pLineState);
VOID vMmSolidVertical(PDEV* ppdev, STRIP *pStrip, LINESTATE *pLineState);
VOID vMmSolidDiagonalHorizontal(PDEV* ppdev, STRIP *pStrip, LINESTATE *pLineState);
VOID vMmSolidDiagonalVertical(PDEV* ppdev, STRIP *pStrip, LINESTATE *pLineState);
VOID vMmStyledHorizontal(PDEV* ppdev, STRIP *pStrip, LINESTATE *pLineState);
VOID vMmStyledVertical(PDEV* ppdev, STRIP *pStrip, LINESTATE *pLineState);

VOID vInvalidStrip(PDEV* ppdev, STRIP *pStrip, LINESTATE *pLineState);

#if 1 // D5480 chu01
VOID vMmSolidHorizontal80(PDEV* ppdev, STRIP *pStrip, LINESTATE *pLineState);
VOID vMmSolidVertical80(PDEV* ppdev, STRIP *pStrip, LINESTATE *pLineState);
#endif // D5480 chu01

// External calls:

BOOL bLines(PDEV*, POINTFIX*, POINTFIX*, RUN* prun, ULONG,
            LINESTATE*, RECTL*, PFNSTRIP apfn[], FLONG);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\cirrus\disp\overlay.c ===
/******************************************************************************\
*
* $Workfile:   OVERLAY.C  $
*
* Copyright (c) 1996-1997 Microsoft Corporation
* Copyright (c) 1996-1997 Cirrus Logic, Inc.
*
* $Log:   V:/CirrusLogic/CL54xx/NT40/Archive/Display/OVERLAY.C_v  $
*
\******************************************************************************/

#include "precomp.h"

#include "debug.h"
#include "panflags.h"
#include "dispint.h"

#if DIRECTDRAW
#include "overlay.h"


#ifdef DEBUG

#define DPF             Msg

extern void __cdecl Msg( LPSTR szFormat, ... );

#else

#define DPF             1 ? (void)0 : (void)

#endif // DEBUG


/* bandwidth matrix --------------------------------------*/



/* inline functions --------------------------------------*/

//static int __inline DrawEngineBusy(void)
//{
//    _outp(0x3ce,0x31);
//    return _inpw(0x3ce) & 0x100; /* Input a word -- test high byte. */
//}


/* defines -----------------------------------------------*/

#define MAX_STRETCH_SIZE     1024

#define IN_VBLANK            (_inp(0x3da) & 8)
#define CRTINDEX             0x3d4
#define DRAW_ENGINE_BUSY     (DrawEngineBusy())

#define PAKJR_GET_U(x) ((x & 0x00000FC0) >> 6)
#define PAKJR_GET_V(x) (x & 0x0000003F)

#define AVG_3_TO_1(u1, u2) ((u1 + ((u2 << 1) + u2)) >> 2) & 0x0000003F
#define AVG_2_TO_2(u1, u2) (((u1 << 1) + (u2 << 1)) >> 2) & 0x0000003F
#define AVG_1_2(u1,u2) u1
#define AVG_1_2_1(u1, u2, u3) ((u1 + (u2 << 1) + u3) >> 2) & 0x0000003F

#define MERGE_3_1(src, dst) (src & 0xFFFE0000) | (dst & 0x0001F000) | \
                            ((AVG_3_TO_1(PAKJR_GET_U(dst), PAKJR_GET_U(src))) << 6) | \
                            (AVG_3_TO_1(PAKJR_GET_V(dst), PAKJR_GET_V(src)))

#define MERGE_2_2(src, dst) (src & 0xFFC00000) | (dst & 0x003FF000) | \
                            ((AVG_2_TO_2(PAKJR_GET_U(dst), PAKJR_GET_U(src))) << 6) | \
                            (AVG_2_TO_2(PAKJR_GET_V(dst), PAKJR_GET_V(src)))

#define MERGE_1_3(src, dst) (src & 0xF8000000) | (dst & 0x07FFF000) | \
                            ((AVG_3_TO_1(PAKJR_GET_U(src), PAKJR_GET_U(dst))) << 6) | \
                            (AVG_3_TO_1(PAKJR_GET_V(src), PAKJR_GET_V(dst)))


#define MERGE_1_2_1(src1, src2, dst) ((src2 & 0x0001F000) << 15) | \
                                     ((src1 & 0x07FE0000) >> 5) | \
                                     ((dst &  0x0001F000)) | \
                                     ((AVG_1_2_1(PAKJR_GET_U(dst), PAKJR_GET_U(src1), PAKJR_GET_U(src2))) << 6) | \
                                     (AVG_1_2( PAKJR_GET_V(dst), PAKJR_GET_V(src1)))


#define MERGE_1_1_2(src1, src2, dst) ((src2 & 0x003FF000) << 10) | \
                                     ((src1 & 0xFE000000) >> 10) | \
                                     ((dst & 0xF8000000) >> 15) |  \
                                     ((AVG_1_2_1(PAKJR_GET_U(dst), PAKJR_GET_U(src2), PAKJR_GET_U(src1))) << 6) | \
                                     (AVG_1_2_1(PAKJR_GET_V(dst), PAKJR_GET_V(src2), PAKJR_GET_V(src1)))

#define MERGE_2_1_1(src1, src2, dst) ((src2 & 0x0001F000) << 15) | \
                                     ((src1 & 0xFE000000) >> 5) | \
                                     ((dst & 0x003FF000)) | \
                                     ((AVG_1_2_1(PAKJR_GET_U(src1), PAKJR_GET_U(dst), PAKJR_GET_U(src2))) << 6) | \
                                     (AVG_1_2_1(PAKJR_GET_V(src1), PAKJR_GET_V(dst), PAKJR_GET_V(src2)))

VOID NEAR PASCAL PackJRSpecialEnd_0_0 (LPDWORD dwSrcStart, LPDWORD dwDstStart, WORD wWidth);
VOID NEAR PASCAL PackJRSpecialEnd_0_1 (LPDWORD dwSrcStart, LPDWORD dwDstStart, WORD wWidth);
VOID NEAR PASCAL PackJRSpecialEnd_0_2 (LPDWORD dwSrcStart, LPDWORD dwDstStart, WORD wWidth);
VOID NEAR PASCAL PackJRSpecialEnd_0_3 (LPDWORD dwSrcStart, LPDWORD dwDstStart, WORD wWidth);
VOID NEAR PASCAL PackJRSpecialEnd_1_1 (LPDWORD dwSrcStart, LPDWORD dwDstStart, WORD wWidth);
VOID NEAR PASCAL PackJRSpecialEnd_1_2 (LPDWORD dwSrcStart, LPDWORD dwDstStart, WORD wWidth);
VOID NEAR PASCAL PackJRSpecialEnd_1_3 (LPDWORD dwSrcStart, LPDWORD dwDstStart, WORD wWidth);
VOID NEAR PASCAL PackJRSpecialEnd_2_1 (LPDWORD dwSrcStart, LPDWORD dwDstStart, WORD wWidth);
VOID NEAR PASCAL PackJRSpecialEnd_2_2 (LPDWORD dwSrcStart, LPDWORD dwDstStart, WORD wWidth);
VOID NEAR PASCAL PackJRSpecialEnd_2_3 (LPDWORD dwSrcStart, LPDWORD dwDstStart, WORD wWidth);
VOID NEAR PASCAL PackJRSpecialEnd_3_1 (LPDWORD dwSrcStart, LPDWORD dwDstStart, WORD wWidth);
VOID NEAR PASCAL PackJRSpecialEnd_3_2 (LPDWORD dwSrcStart, LPDWORD dwDstStart, WORD wWidth);
VOID NEAR PASCAL PackJRSpecialEnd_3_3 (LPDWORD dwSrcStart, LPDWORD dwDstStart, WORD wWidth);

/* global data -------------------------------------------*/

typedef void (NEAR PASCAL *NPALIGN)(LPDWORD, LPDWORD, DWORD, DWORD, WORD, WORD);
typedef void (NEAR PASCAL *NPEND)(LPDWORD , LPDWORD, WORD);
DWORD dwFOURCCs[5];

static NPEND npEnd[4][4] = {
                               (&PackJRSpecialEnd_0_0),
                               (&PackJRSpecialEnd_0_1),
                               (&PackJRSpecialEnd_0_2),
                               (&PackJRSpecialEnd_0_3),
                               (&PackJRSpecialEnd_0_0),
                               (&PackJRSpecialEnd_1_1),
                               (&PackJRSpecialEnd_1_2),
                               (&PackJRSpecialEnd_1_3),
                               (&PackJRSpecialEnd_0_0),
                               (&PackJRSpecialEnd_2_1),
                               (&PackJRSpecialEnd_2_2),
                               (&PackJRSpecialEnd_2_3),
                               (&PackJRSpecialEnd_0_0),
                               (&PackJRSpecialEnd_3_1),
                               (&PackJRSpecialEnd_3_2),
                               (&PackJRSpecialEnd_3_3),
                           };

/**********************************************************
*
*       Name:  PackJRBltAlignEnd
*
*       Module Abstract:
*       ----------------
*       Blts the last few PackJR pixels that are not properly
*       aligned (so it can't use the hardware BLTer).
*
*       Output Parameters:
*       ------------------
*       none
*
***********************************************************
*       Author:
*       Date:   10/06/96
*
*       Revision History:
*       -----------------
*       WHO             WHEN     WHAT/WHY/HOW
*       ---             ----     ------------
*
*********************************************************/

VOID PackJRBltAlignEnd (LPBYTE dwSrcStart, LPBYTE dwDstStart, DWORD dwWidth,
                     DWORD dwHeight, WORD wSrcPitch, WORD wDstPitch)
{
DWORD dwHeightLoop;

   switch (dwWidth)
   {
      case  1:
         for(dwHeightLoop = 0; dwHeightLoop < dwHeight; dwHeightLoop++)
         {
            *dwDstStart = MERGE_3_1(*dwDstStart, *dwSrcStart);
            (ULONG_PTR)dwSrcStart += wSrcPitch;
            (ULONG_PTR)dwDstStart += wDstPitch;
         }
         break;
      case 2:
         for(dwHeightLoop = 0; dwHeightLoop < dwHeight; dwHeightLoop++)
         {
            *dwDstStart = MERGE_2_2(*dwDstStart, *dwSrcStart);
            (ULONG_PTR)dwSrcStart += wSrcPitch;
            (ULONG_PTR)dwDstStart += wDstPitch;
         }
         break;
      case 3:
         for(dwHeightLoop = 0; dwHeightLoop < dwHeight; dwHeightLoop++)
         {
            *dwDstStart = MERGE_1_3(*dwDstStart, *dwSrcStart);
            (ULONG_PTR)dwSrcStart += wSrcPitch;
            (ULONG_PTR)dwDstStart += wDstPitch;
         }
         break;
   }
}


/**********************************************************
*
*       Name:  PackJRSpecialEnd functions
*
*       Module Abstract:
*       ----------------
*       Blts the last few PackJR pixels that are not properly
*       aligned (so it can't use the hardware BLTer).
*
*       There are 12 of these functions, based on alignment
*       and width
*
*       Output Parameters:
*       ------------------
*       none
*
***********************************************************
*       Author:
*       Date:   10/06/96
*
*       Revision History:
*       -----------------
*       WHO             WHEN     WHAT/WHY/HOW
*       ---             ----     ------------
*
*********************************************************/

VOID NEAR PASCAL PackJRSpecialEnd_0_0 (LPDWORD dwSrcStart, LPDWORD dwDstStart, WORD wWidth)
{
   //this should neverbe called
   return;
}


VOID NEAR PASCAL PackJRSpecialEnd_0_1(LPDWORD dwSrcStart, LPDWORD dwDstStart, WORD wWidth)
{
   *dwDstStart = MERGE_3_1(*dwDstStart, *dwSrcStart);
   return;
}

VOID NEAR PASCAL PackJRSpecialEnd_0_2(LPDWORD dwSrcStart, LPDWORD dwDstStart, WORD wWidth)
{
   *dwDstStart = MERGE_2_2(*dwDstStart, *dwSrcStart);
   return;
}

VOID NEAR PASCAL PackJRSpecialEnd_0_3(LPDWORD dwSrcStart, LPDWORD dwDstStart, WORD wWidth)
{
   *dwDstStart = MERGE_1_3(*dwDstStart, *dwSrcStart);
   return;
}

VOID NEAR PASCAL PackJRSpecialEnd_1_1(LPDWORD dwSrcStart, LPDWORD dwDstStart, WORD wWidth)
{
   *dwDstStart++ =   ((*dwSrcStart & 0x07C00000) >>10) |
                     ((*dwDstStart & 0xFFFE0000)) |
                     ((AVG_3_TO_1(PAKJR_GET_U(*dwSrcStart), PAKJR_GET_U(*dwDstStart))) << 6) | \
                     (AVG_3_TO_1(PAKJR_GET_V(*dwSrcStart), PAKJR_GET_V(*dwDstStart)));
   return;
}

VOID NEAR PASCAL PackJRSpecialEnd_1_2(LPDWORD dwSrcStart, LPDWORD dwDstStart, WORD wWidth)
{
   *dwDstStart++ =   ((*dwSrcStart & 0x07FFE000) >> 5) |
                     ((*dwDstStart & 0xFFC00000)) |
                     ((AVG_2_TO_2(PAKJR_GET_U(*dwSrcStart), PAKJR_GET_U(*dwDstStart))) << 6) | \
                     (AVG_2_TO_2(PAKJR_GET_V(*dwSrcStart), PAKJR_GET_V(*dwDstStart)));
   return;
}

VOID NEAR PASCAL PackJRSpecialEnd_1_3(LPDWORD dwSrcStart, LPDWORD dwDstStart, WORD wWidth)
{
   *dwDstStart++ =   ((*dwSrcStart & 0x07FFF000)) |
                     ((*dwDstStart & 0xF1000000)) |
                     ((AVG_3_TO_1(PAKJR_GET_U(*dwDstStart), PAKJR_GET_U(*dwSrcStart))) << 6) | \
                     (AVG_3_TO_1(PAKJR_GET_V(*dwDstStart), PAKJR_GET_V(*dwSrcStart)));
   return;
}

VOID NEAR PASCAL PackJRSpecialEnd_2_1(LPDWORD dwSrcStart, LPDWORD dwDstStart, WORD wWidth)
{
   *dwDstStart++ =   ((*dwSrcStart & 0x0003E000) >> 5) |
                     ((*dwDstStart & 0xFFFE0000)) |
                     ((AVG_3_TO_1(PAKJR_GET_U(*dwSrcStart), PAKJR_GET_U(*dwDstStart))) << 6) | \
                     (AVG_3_TO_1(PAKJR_GET_V(*dwSrcStart), PAKJR_GET_V(*dwDstStart)));

   return;
}

VOID NEAR PASCAL PackJRSpecialEnd_2_2(LPDWORD dwSrcStart, LPDWORD dwDstStart, WORD wWidth)
{
   *dwDstStart++ =   ((*dwSrcStart & 0xFFC00000) >> 10) |
                     ((*dwDstStart & 0xFFC00000)) |
                     ((AVG_2_TO_2(PAKJR_GET_U(*dwSrcStart), PAKJR_GET_U(*dwDstStart))) << 6) | \
                     (AVG_2_TO_2(PAKJR_GET_V(*dwSrcStart), PAKJR_GET_V(*dwDstStart)));
   return;
}

VOID NEAR PASCAL PackJRSpecialEnd_2_3(LPDWORD dwSrcStart, LPDWORD dwDstStart, WORD wWidth)
{
   *dwDstStart++ =   ((*dwSrcStart & 0xFFC00000) >> 10) |
                     ((*(dwSrcStart + 1) & 0x0001F000) << 10) |
                     ((*dwDstStart & 0xF1000000)) |
                     ((AVG_1_2_1(PAKJR_GET_U(*dwDstStart), PAKJR_GET_U(*dwSrcStart), PAKJR_GET_U(*(dwSrcStart+1)))) << 6) | \
                     (AVG_1_2_1(PAKJR_GET_V(*dwDstStart), PAKJR_GET_V(*dwSrcStart), PAKJR_GET_V(*(dwSrcStart+1))));
   return;
}

VOID NEAR PASCAL PackJRSpecialEnd_3_1(LPDWORD dwSrcStart, LPDWORD dwDstStart, WORD wWidth)
{
   *dwDstStart++ =   ((*dwSrcStart & 0xF1000000) >> 15) |
                     ((*dwDstStart & 0xFFFE0000)) |
                     ((AVG_3_TO_1(PAKJR_GET_U(*dwSrcStart), PAKJR_GET_U(*dwDstStart))) << 6) | \
                     (AVG_3_TO_1(PAKJR_GET_V(*dwSrcStart), PAKJR_GET_V(*dwDstStart)));
   return;
}

VOID NEAR PASCAL PackJRSpecialEnd_3_2(LPDWORD dwSrcStart, LPDWORD dwDstStart, WORD wWidth)
{
   *dwDstStart++ =   ((*dwSrcStart & 0xF1000000) >> 15) |
                     ((*(dwSrcStart + 1) & 0x0001F000) << 5) |
                     ((*dwDstStart & 0xFFC00000)) |
                     ((AVG_1_2_1(PAKJR_GET_U(*dwSrcStart), PAKJR_GET_U(*dwDstStart), PAKJR_GET_U(*(dwSrcStart+1)))) << 6) | \
                     (AVG_1_2_1(PAKJR_GET_V(*dwSrcStart), PAKJR_GET_V(*dwDstStart), PAKJR_GET_V(*(dwSrcStart+1))));
   return;
}

VOID NEAR PASCAL PackJRSpecialEnd_3_3(LPDWORD dwSrcStart, LPDWORD dwDstStart, WORD wWidth)
{
   *dwDstStart++ =   ((*dwSrcStart & 0xF1000000) >> 15) |
                     ((*(dwSrcStart + 1) & 0x003FF000) << 5) |
                     ((*dwDstStart & 0xF1000000)) |
                     ((AVG_1_2_1(PAKJR_GET_U(*dwDstStart), PAKJR_GET_U(*(dwSrcStart+1)), PAKJR_GET_U(*dwSrcStart))) << 6) | \
                     (AVG_1_2_1(PAKJR_GET_V(*dwDstStart), PAKJR_GET_V(*(dwSrcStart+1)), PAKJR_GET_V(*dwSrcStart)));
   return;
}

/**********************************************************
*
*       Name:  PackJRAlign functions
*
*       Module Abstract:
*       ----------------
*       These functions handle bliting unaligned PackJR
*       data
*
*       There are 12 of these functions, based on alignment
*       of source and destination
*
*       Output Parameters:
*       ------------------
*       none
*
***********************************************************
*       Author:
*       Date:   10/06/96
*
*       Revision History:
*       -----------------
*       WHO             WHEN     WHAT/WHY/HOW
*       ---             ----     ------------
*
*********************************************************/

VOID NEAR PASCAL PackJRAlign_1_1 (LPDWORD dwSrcStart, LPDWORD dwDstStart, DWORD dwWidth,
                     DWORD dwHeight, WORD wSrcPitch, WORD wDstPitch)
{
   DWORD dwHeightLoop, dwWidthLoop, i;


   for(dwHeightLoop = 0; dwHeightLoop < dwHeight; dwHeightLoop++)
   {
      dwWidthLoop = dwWidth;
      if (dwWidthLoop > 3)
      {
         *dwDstStart++ = MERGE_3_1(*dwSrcStart, *dwDstStart);
         dwWidthLoop-=3;
         dwSrcStart++;
      }
      if (dwWidthLoop > 3)
      {
         for (i=0; i < (dwWidthLoop >> 2); i++)
            *dwDstStart++ = *dwSrcStart++;
         dwWidthLoop&=3;
      }
      if (dwWidthLoop != 0)
         npEnd[LOWORD((ULONG_PTR)dwSrcStart & 3)][LOWORD(dwWidthLoop)]
            (dwSrcStart, dwDstStart, LOWORD(dwWidthLoop));

      (ULONG_PTR)dwSrcStart+= (wSrcPitch - dwWidth + dwWidthLoop);
      (ULONG_PTR)dwDstStart+= (wDstPitch - dwWidth + dwWidthLoop);
   }

}



VOID NEAR PASCAL PackJRAlign_1_2 (LPDWORD dwSrcStart, LPDWORD dwDstStart, DWORD dwWidth,
                     DWORD dwHeight, WORD wSrcPitch, WORD wDstPitch)
{


   DWORD dwHeightLoop, dwWidthLoop, i;


   for(dwHeightLoop = 0; dwHeightLoop < dwHeight; dwHeightLoop++)
   {
      dwWidthLoop = dwWidth;
      if (dwWidthLoop > 3)
      {
         *dwDstStart++ =   ((*dwSrcStart & 0x07FE0000) << 5) |
                           ((*dwDstStart & 0x003FF000)) |
                            ((AVG_2_TO_2(PAKJR_GET_U(*dwSrcStart), PAKJR_GET_U(*dwDstStart))) << 6) | \
                            (AVG_2_TO_2(PAKJR_GET_V(*dwSrcStart), PAKJR_GET_V(*dwDstStart)));
         dwWidthLoop-=2;
      }
      if (dwWidthLoop > 3)
      {
         for (i=0; i < (dwWidthLoop >> 2); i++)
         {
            *dwDstStart++ =   ((*dwSrcStart & 0xF8000000) >> 15) |
                              ((*(dwSrcStart + 1) & 0x07FFF000) << 5) |
                              ((AVG_3_TO_1(PAKJR_GET_U(*dwSrcStart), PAKJR_GET_U(*(dwSrcStart+1)))) << 6) | \
                              (AVG_3_TO_1(PAKJR_GET_V(*dwSrcStart), PAKJR_GET_V(*(dwSrcStart+1))));
            dwSrcStart++;
         }
         dwWidthLoop&=3;
      }
      (ULONG_PTR)dwSrcStart+=3;
      if (dwWidthLoop != 0)
         npEnd[LOWORD((ULONG_PTR)dwSrcStart & 3)][LOWORD(dwWidthLoop)]
            (dwSrcStart, dwDstStart, LOWORD(dwWidthLoop));

      (ULONG_PTR)dwSrcStart+= (wSrcPitch - dwWidth + dwWidthLoop);
      (ULONG_PTR)dwDstStart+= (wDstPitch - dwWidth + dwWidthLoop);
   }
}

VOID NEAR PASCAL PackJRAlign_1_3 (LPDWORD dwSrcStart, LPDWORD dwDstStart, DWORD dwWidth,
                     DWORD dwHeight, WORD wSrcPitch, WORD wDstPitch)
{
   DWORD dwHeightLoop, dwWidthLoop, i;


   for(dwHeightLoop = 0; dwHeightLoop < dwHeight; dwHeightLoop++)
   {
      dwWidthLoop = dwWidth;
      if (dwWidthLoop > 3)
      {
         *dwDstStart++ =   ((*dwSrcStart & 0x003E0000) << 10) |
                           ((*dwDstStart & 0x07FFF000)) |
                            ((AVG_3_TO_1(PAKJR_GET_U(*dwSrcStart), PAKJR_GET_U(*dwDstStart))) << 6) | \
                            (AVG_3_TO_1(PAKJR_GET_V(*dwSrcStart), PAKJR_GET_V(*dwDstStart)));
         dwWidthLoop--;
      }
      if (dwWidthLoop > 3)
      {
         for (i=0; i < (dwWidthLoop >> 2); i++)
         {
            *dwDstStart++ =   ((*dwSrcStart & 0xFFC0000) >> 10) |
                              ((*(dwSrcStart+1) & 0x003FF000) << 10) |
                              ((AVG_2_TO_2(PAKJR_GET_U(*(dwSrcStart+1)), PAKJR_GET_U(*dwSrcStart))) << 6) | \
                              (AVG_2_TO_2(PAKJR_GET_V(*(dwSrcStart+1)), PAKJR_GET_V(*dwSrcStart)));
            dwSrcStart++;
         }
         dwWidthLoop&=3;
      }
      (ULONG_PTR)dwSrcStart+=2;
      if (dwWidthLoop != 0)
         npEnd[LOWORD((ULONG_PTR)dwSrcStart & 3)][LOWORD(dwWidthLoop)]
            (dwSrcStart, dwDstStart, LOWORD(dwWidthLoop));

      (ULONG_PTR)dwSrcStart+= (wSrcPitch - dwWidth + dwWidthLoop);
      (ULONG_PTR)dwDstStart+= (wDstPitch - dwWidth + dwWidthLoop);
   }


}

VOID NEAR PASCAL PackJRAlign_1_0 (LPDWORD dwSrcStart, LPDWORD dwDstStart, DWORD dwWidth,
                     DWORD dwHeight, WORD wSrcPitch, WORD wDstPitch)
{

   DWORD dwHeightLoop, dwWidthLoop, i;


   for(dwHeightLoop = 0; dwHeightLoop < dwHeight; dwHeightLoop++)
   {
      dwWidthLoop = dwWidth;
      if (dwWidthLoop > 3)
      {
         for (i=0; i < (dwWidthLoop >> 2); i++)
         {
           *dwDstStart++ =   ((*dwSrcStart & 0xFFFE0000) >> 5) |
                             ((*(dwSrcStart+1) & 0x0001E000) << 15) |
                             ((AVG_3_TO_1(PAKJR_GET_U(*(dwSrcStart+1)), PAKJR_GET_U(*dwSrcStart))) << 6) | \
                             (AVG_3_TO_1(PAKJR_GET_V(*(dwSrcStart+1)), PAKJR_GET_V(*dwSrcStart)));
            dwSrcStart++;
         }
         dwWidthLoop&=3;
      }
      (ULONG_PTR)dwSrcStart+=1;
      if (dwWidthLoop != 0)
         npEnd[LOWORD((ULONG_PTR)dwSrcStart & 3)][LOWORD(dwWidthLoop)]
            (dwSrcStart, dwDstStart, LOWORD(dwWidthLoop));

      (ULONG_PTR)dwSrcStart+= (wSrcPitch - dwWidth + dwWidthLoop);
      (ULONG_PTR)dwDstStart+= (wDstPitch - dwWidth + dwWidthLoop);
   }
}

VOID NEAR PASCAL PackJRAlign_2_1 (LPDWORD dwSrcStart, LPDWORD dwDstStart, DWORD dwWidth,
                     DWORD dwHeight, WORD wSrcPitch, WORD wDstPitch)
{

   DWORD dwHeightLoop, dwWidthLoop, i;


   for(dwHeightLoop = 0; dwHeightLoop < dwHeight; dwHeightLoop++)
   {
      dwWidthLoop = dwWidth;
      if (dwWidthLoop > 3)
      {
         *dwDstStart++ = MERGE_1_2_1(*dwSrcStart, *(dwSrcStart+1), *dwDstStart);
         dwWidthLoop-=3;
         dwSrcStart++;
      }
      if (dwWidthLoop > 3)
      {
         for (i=0; i < (dwWidthLoop >> 2); i++)
         {
            *dwDstStart++ =   ((*dwSrcStart & 0xFFFE0000) >> 5) |
                              ((*(dwSrcStart+1) & 0x0001F000) << 15) |
                              ((AVG_3_TO_1(PAKJR_GET_U(*(dwSrcStart+1)), PAKJR_GET_U(*dwSrcStart))) << 6) | \
                              (AVG_3_TO_1(PAKJR_GET_V(*(dwSrcStart+1)), PAKJR_GET_V(*dwSrcStart)));
            dwSrcStart++;
         }
         dwWidthLoop&=3;
      }
      (ULONG_PTR)dwSrcStart+=1;
      if (dwWidthLoop != 0)
         npEnd[LOWORD((ULONG_PTR)dwSrcStart & 3)][LOWORD(dwWidthLoop)]
            (dwSrcStart, dwDstStart, LOWORD(dwWidthLoop));

      (ULONG_PTR)dwSrcStart+= (wSrcPitch - dwWidth + dwWidthLoop);
      (ULONG_PTR)dwDstStart+= (wDstPitch - dwWidth + dwWidthLoop);
   }

}

VOID NEAR PASCAL PackJRAlign_2_2 (LPDWORD dwSrcStart, LPDWORD dwDstStart, DWORD dwWidth,
                     DWORD dwHeight, WORD wSrcPitch, WORD wDstPitch)
{

   DWORD dwHeightLoop, dwWidthLoop, i;


   for(dwHeightLoop = 0; dwHeightLoop < dwHeight; dwHeightLoop++)
   {
      dwWidthLoop = dwWidth;
      if (dwWidthLoop > 3)
      {
         *dwDstStart++ = MERGE_2_2(*dwSrcStart, *dwDstStart);
         dwWidthLoop-=2;
         dwSrcStart++;
      }
      if (dwWidthLoop > 3)
      {
         for (i=0; i < (dwWidthLoop >> 2); i++)
            *dwDstStart++ = *dwSrcStart++;
         dwWidthLoop&=3;
      }
      if (dwWidthLoop != 0)
         npEnd[LOWORD((ULONG_PTR)dwSrcStart & 3)][LOWORD(dwWidthLoop)]
            (dwSrcStart, dwDstStart, LOWORD(dwWidthLoop));

      (ULONG_PTR)dwSrcStart+= (wSrcPitch - dwWidth + dwWidthLoop);
      (ULONG_PTR)dwDstStart+= (wDstPitch - dwWidth + dwWidthLoop);
   }

}

VOID NEAR PASCAL PackJRAlign_2_3 (LPDWORD dwSrcStart, LPDWORD dwDstStart, DWORD dwWidth,
                     DWORD dwHeight, WORD wSrcPitch, WORD wDstPitch)
{

   DWORD dwHeightLoop, dwWidthLoop, i;


   for(dwHeightLoop = 0; dwHeightLoop < dwHeight; dwHeightLoop++)
   {
      dwWidthLoop = dwWidth;
      if (dwWidthLoop > 3)
      {
         *dwDstStart++ =   ((*dwSrcStart & 0x003E0000) << 10) |
                           ((*dwDstStart & 0x07FFF000)) |
                           ((AVG_3_TO_1(PAKJR_GET_U(*dwSrcStart), PAKJR_GET_U(*dwDstStart))) << 6) | \
                           (AVG_3_TO_1(PAKJR_GET_V(*dwSrcStart), PAKJR_GET_V(*dwDstStart)));
         dwWidthLoop--;
      }
      if (dwWidthLoop > 3)
      {
         for (i=0; i < (dwWidthLoop >> 2); i++)
         {
            *dwDstStart++ =   ((*dwSrcStart & 0xF8000000) >> 15) |
                              ((*(dwSrcStart + 1) & 0x07FFF000) << 5) |
                              ((AVG_3_TO_1(PAKJR_GET_U(*dwSrcStart), PAKJR_GET_U(*(dwSrcStart+1)))) << 6) | \
                              (AVG_3_TO_1(PAKJR_GET_V(*dwSrcStart), PAKJR_GET_V(*(dwSrcStart+1))));
         }
         dwWidthLoop&=3;
      }
      (ULONG_PTR)dwSrcStart+=3;
      if (dwWidthLoop != 0)
         npEnd[LOWORD((ULONG_PTR)dwSrcStart & 3)][LOWORD(dwWidthLoop)]
            (dwSrcStart, dwDstStart, LOWORD(dwWidthLoop));

      (ULONG_PTR)dwSrcStart+= (wSrcPitch - dwWidth + dwWidthLoop);
      (ULONG_PTR)dwDstStart+= (wDstPitch - dwWidth + dwWidthLoop);
   }

}

VOID NEAR PASCAL PackJRAlign_2_0 (LPDWORD dwSrcStart, LPDWORD dwDstStart, DWORD dwWidth,
                     DWORD dwHeight, WORD wSrcPitch, WORD wDstPitch)
{
   DWORD dwHeightLoop, dwWidthLoop, i;


   for(dwHeightLoop = 0; dwHeightLoop < dwHeight; dwHeightLoop++)
   {
      dwWidthLoop = dwWidth;
      if (dwWidthLoop > 3)
      {
         for (i=0; i < (dwWidthLoop >> 2); i++)
         {
           *dwDstStart++ =   ((*dwSrcStart & 0xFFC00000) >> 10) |
                             ((*(dwSrcStart+1) & 0x003FF000) << 10) |
                             ((AVG_2_TO_2(PAKJR_GET_U(*(dwSrcStart+1)), PAKJR_GET_U(*dwSrcStart))) << 6) | \
                             (AVG_2_TO_2(PAKJR_GET_V(*(dwSrcStart+1)), PAKJR_GET_V(*dwSrcStart)));
            dwSrcStart++;
         }
         dwWidthLoop&=3;
      }
      (ULONG_PTR)dwSrcStart+=2;
      if (dwWidthLoop != 0)
         npEnd[LOWORD((ULONG_PTR)dwSrcStart & 3)][LOWORD(dwWidthLoop)]
            (dwSrcStart, dwDstStart, LOWORD(dwWidthLoop));

      (ULONG_PTR)dwSrcStart+= (wSrcPitch - dwWidth + dwWidthLoop);
      (ULONG_PTR)dwDstStart+= (wDstPitch - dwWidth + dwWidthLoop);
   }


}

VOID NEAR PASCAL PackJRAlign_3_1 (LPDWORD dwSrcStart, LPDWORD dwDstStart, DWORD dwWidth,
                     DWORD dwHeight, WORD wSrcPitch, WORD wDstPitch)
{
   DWORD dwHeightLoop, dwWidthLoop, i;


   for(dwHeightLoop = 0; dwHeightLoop < dwHeight; dwHeightLoop++)
   {
      dwWidthLoop = dwWidth;
      if (dwWidthLoop > 3)
      {
         *dwDstStart++ = MERGE_1_1_2(*dwSrcStart, *(dwSrcStart+1), *dwDstStart);
         dwWidthLoop-=3;
         dwSrcStart++;
      }
      if (dwWidthLoop > 3)
      {
         for (i=0; i < (dwWidthLoop >> 2); i++)
         {
           *dwDstStart++ =   ((*(dwSrcStart+1) & 0x003FF000) << 10) |
                             ((*dwSrcStart & 0xFFC00000) >> 10) |
                             ((AVG_2_TO_2(PAKJR_GET_U(*(dwSrcStart+1)), PAKJR_GET_U(*dwSrcStart))) << 6) | \
                             (AVG_2_TO_2(PAKJR_GET_V(*(dwSrcStart+1)), PAKJR_GET_V(*dwSrcStart)));
            dwSrcStart++;
         }
         dwWidthLoop&=3;
      }
      (ULONG_PTR)dwSrcStart+=2;
      if (dwWidthLoop != 0)
         npEnd[LOWORD((ULONG_PTR)dwSrcStart & 3)][LOWORD(dwWidthLoop)]
            (dwSrcStart, dwDstStart, LOWORD(dwWidthLoop));

      (ULONG_PTR)dwSrcStart+= (wSrcPitch - dwWidth + dwWidthLoop);
      (ULONG_PTR)dwDstStart+= (wDstPitch - dwWidth + dwWidthLoop);
   }


}

VOID NEAR PASCAL PackJRAlign_3_2 (LPDWORD dwSrcStart, LPDWORD dwDstStart, DWORD dwWidth,
                     DWORD dwHeight, WORD wSrcPitch, WORD wDstPitch)
{
   DWORD dwHeightLoop, dwWidthLoop, i;


   for(dwHeightLoop = 0; dwHeightLoop < dwHeight; dwHeightLoop++)
   {
      dwWidthLoop = dwWidth;
      if (dwWidthLoop > 3)
      {
         *dwDstStart++ = MERGE_2_1_1(*dwSrcStart, *(dwSrcStart+1), *dwDstStart);
         dwWidthLoop-=2;
         dwSrcStart++;
      }
      if (dwWidthLoop > 3)
      {
         for (i=0; i < (dwWidthLoop >> 2); i++)
         {
             *dwDstStart++ =   ((*dwSrcStart & 0xFFFE0000) >> 5) |
                               ((*(dwSrcStart+1) & 0x0001F000) << 15) |
                               ((AVG_3_TO_1(PAKJR_GET_U(*(dwSrcStart+1)), PAKJR_GET_U(*dwSrcStart))) << 6) | \
                               (AVG_3_TO_1(PAKJR_GET_V(*(dwSrcStart+1)), PAKJR_GET_V(*dwSrcStart)));
             dwSrcStart++;
         }
         dwWidthLoop&=3;
      }
      (ULONG_PTR)dwSrcStart+=1;
      if (dwWidthLoop != 0)
         npEnd[LOWORD((ULONG_PTR)dwSrcStart & 3)][LOWORD(dwWidthLoop)]
            (dwSrcStart, dwDstStart, LOWORD(dwWidthLoop));

      (ULONG_PTR)dwSrcStart+= (wSrcPitch - dwWidth + dwWidthLoop);
      (ULONG_PTR)dwDstStart+= (wDstPitch - dwWidth + dwWidthLoop);
   }


}

VOID NEAR PASCAL PackJRAlign_3_3 (LPDWORD dwSrcStart, LPDWORD dwDstStart, DWORD dwWidth,
                     DWORD dwHeight, WORD wSrcPitch, WORD wDstPitch)
{
   DWORD dwHeightLoop, dwWidthLoop, i;


   for(dwHeightLoop = 0; dwHeightLoop < dwHeight; dwHeightLoop++)
   {
      dwWidthLoop = dwWidth;
      if (dwWidthLoop > 3)
      {
         *dwDstStart++ = MERGE_1_3(*dwSrcStart, *dwDstStart);
         dwWidthLoop-=1;
         dwSrcStart++;
      }
      if (dwWidthLoop > 3)
      {
         for (i=0; i < (dwWidthLoop >> 2); i++)
            *dwDstStart++ = *dwSrcStart++;
         dwWidthLoop&=3;
      }
      if (dwWidthLoop != 0)
         npEnd[LOWORD((ULONG_PTR)dwSrcStart & 3)][LOWORD(dwWidthLoop)]
            (dwSrcStart, dwDstStart, LOWORD(dwWidthLoop));

      (ULONG_PTR)dwSrcStart+= (wSrcPitch - dwWidth + dwWidthLoop);
      (ULONG_PTR)dwDstStart+= (wDstPitch - dwWidth + dwWidthLoop);
   }


}

VOID NEAR PASCAL PackJRAlign_3_0 (LPDWORD dwSrcStart, LPDWORD dwDstStart, DWORD dwWidth,
                     DWORD dwHeight, WORD wSrcPitch, WORD wDstPitch)
{

   DWORD dwHeightLoop, dwWidthLoop, i;


   for(dwHeightLoop = 0; dwHeightLoop < dwHeight; dwHeightLoop++)
   {
      dwWidthLoop = dwWidth;
      if (dwWidthLoop > 3)
      {
         for (i=0; i < (dwWidthLoop >> 2); i++)
         {
            *dwDstStart++ =   ((*dwSrcStart & 0xF8000000) >> 15) |
                              ((*(dwSrcStart + 1) & 0x07FFF000) << 5) |
                              ((AVG_3_TO_1(PAKJR_GET_U(*dwSrcStart), PAKJR_GET_U(*(dwSrcStart+1)))) << 6) | \
                              (AVG_3_TO_1(PAKJR_GET_V(*dwSrcStart), PAKJR_GET_V(*(dwSrcStart+1))));
         }
         dwWidthLoop&=3;
      }
      (ULONG_PTR)dwSrcStart+=3;
      if (dwWidthLoop != 0)
         npEnd[LOWORD((ULONG_PTR)dwSrcStart & 3)][LOWORD(dwWidthLoop)]
            (dwSrcStart, dwDstStart, LOWORD(dwWidthLoop));

      (ULONG_PTR)dwSrcStart+= (wSrcPitch - dwWidth + dwWidthLoop);
      (ULONG_PTR)dwDstStart+= (wDstPitch - dwWidth + dwWidthLoop);
   }

}

VOID NEAR PASCAL PackJRAlign_0_1 (LPDWORD dwSrcStart, LPDWORD dwDstStart, DWORD dwWidth,
                     DWORD dwHeight, WORD wSrcPitch, WORD wDstPitch)
{

   DWORD dwHeightLoop, dwWidthLoop, i;


   for(dwHeightLoop = 0; dwHeightLoop < dwHeight; dwHeightLoop++)
   {
      dwWidthLoop = dwWidth;
      if (dwWidthLoop > 3)
      {
          *dwDstStart++ =   ((*dwDstStart & 0x0001F000) >> 15) |
                            ((*dwSrcStart & 0x07FFF000) << 5) |
                            ((AVG_3_TO_1(PAKJR_GET_U(*dwDstStart), PAKJR_GET_U(*dwSrcStart))) << 6) | \
                            (AVG_3_TO_1(PAKJR_GET_V(*dwDstStart), PAKJR_GET_V(*dwSrcStart)));
          dwWidthLoop-=3;
      }
      if (dwWidthLoop > 3)
      {
         for (i=0; i < (dwWidthLoop >> 2); i++)
         {
            *dwDstStart++ =   ((*dwSrcStart & 0xF8000000) >> 15) |
                              ((*(dwSrcStart + 1) & 0x07FFF000) << 5) |
                              ((AVG_3_TO_1(PAKJR_GET_U(*dwSrcStart), PAKJR_GET_U(*(dwSrcStart+1)))) << 6) | \
                              (AVG_3_TO_1(PAKJR_GET_V(*dwSrcStart), PAKJR_GET_V(*(dwSrcStart+1))));
            dwSrcStart++;
         }
         dwWidthLoop&=3;
      }
      (ULONG_PTR)dwSrcStart+=3;
      if (dwWidthLoop != 0)
         npEnd[LOWORD((ULONG_PTR)dwSrcStart & 3)][LOWORD(dwWidthLoop)]
            (dwSrcStart, dwDstStart, LOWORD(dwWidthLoop));

      (ULONG_PTR)dwSrcStart+= (wSrcPitch - dwWidth + dwWidthLoop);
      (ULONG_PTR)dwDstStart+= (wDstPitch - dwWidth + dwWidthLoop);
   }

}

VOID NEAR PASCAL PackJRAlign_0_2 (LPDWORD dwSrcStart, LPDWORD dwDstStart, DWORD dwWidth,
                     DWORD dwHeight, WORD wSrcPitch, WORD wDstPitch)
{

   DWORD dwHeightLoop, dwWidthLoop, i;


   for(dwHeightLoop = 0; dwHeightLoop < dwHeight; dwHeightLoop++)
   {
      dwWidthLoop = dwWidth;
      if (dwWidthLoop > 3)
      {
         *dwDstStart++ =   ((*dwDstStart & 0x003FF000)) |
                           ((*dwSrcStart & 0x003FF000) << 10) |
                           ((AVG_2_TO_2(PAKJR_GET_U(*dwDstStart), PAKJR_GET_U(*dwSrcStart))) << 6) | \
                           (AVG_2_TO_2(PAKJR_GET_V(*dwSrcStart), PAKJR_GET_V(*dwSrcStart)));
         dwWidthLoop-=2;
      }
      if (dwWidthLoop > 3)
      {
         for (i=0; i < (dwWidthLoop >> 2); i++)
         {
            *dwDstStart++ =   ((*(dwSrcStart+1) & 0x003FF000) << 10) |
                              ((*dwSrcStart & 0xFFC00000) >> 10) |
                              ((AVG_2_TO_2(PAKJR_GET_U(*(dwSrcStart+1)), PAKJR_GET_U(*dwSrcStart))) << 6) | \
                              (AVG_2_TO_2(PAKJR_GET_V(*(dwSrcStart+1)), PAKJR_GET_V(*dwSrcStart)));
            dwSrcStart++;
         }
         dwWidthLoop&=3;
      }
      (ULONG_PTR)dwSrcStart+=2;
      if (dwWidthLoop != 0)
         npEnd[LOWORD((ULONG_PTR)dwSrcStart & 3)][LOWORD(dwWidthLoop)]
            (dwSrcStart, dwDstStart, LOWORD(dwWidthLoop));

      (ULONG_PTR)dwSrcStart+= (wSrcPitch - dwWidth + dwWidthLoop);
      (ULONG_PTR)dwDstStart+= (wDstPitch - dwWidth + dwWidthLoop);
   }

}

VOID NEAR PASCAL PackJRAlign_0_3 (LPDWORD dwSrcStart, LPDWORD dwDstStart, DWORD dwWidth,
                     DWORD dwHeight, WORD wSrcPitch, WORD wDstPitch)
{

   DWORD dwHeightLoop, dwWidthLoop, i;

   for(dwHeightLoop = 0; dwHeightLoop < dwHeight; dwHeightLoop++)
   {
      dwWidthLoop = dwWidth;
      if (dwWidthLoop > 3)
      {
         *dwDstStart++ =   ((*dwDstStart & 0x07FFF000)) |
                           ((*dwSrcStart & 0x0001F000) << 15) |
                           ((AVG_3_TO_1(PAKJR_GET_U(*dwSrcStart), PAKJR_GET_U(*dwDstStart))) << 6) | \
                           (AVG_3_TO_1(PAKJR_GET_V(*dwSrcStart), PAKJR_GET_V(*dwDstStart)));
         dwWidthLoop--;
      }
      if (dwWidthLoop > 3)
      {
         for (i=0; i < (dwWidthLoop >> 2); i++)
         {
             *dwDstStart++ =   ((*dwSrcStart & 0xFFFE0000) >> 5) |
                               ((*(dwSrcStart+1) & 0x0001F000) << 15) |
                               ((AVG_3_TO_1(PAKJR_GET_U(*(dwSrcStart+1)), PAKJR_GET_U(*dwSrcStart))) << 6) | \
                               (AVG_3_TO_1(PAKJR_GET_V(*(dwSrcStart+1)), PAKJR_GET_V(*dwSrcStart)));
             dwSrcStart++;
         }
         dwWidthLoop&=3;
      }
      (ULONG_PTR)dwSrcStart+=1;
      if (dwWidthLoop != 0)
         npEnd[LOWORD((ULONG_PTR)dwSrcStart & 3)][LOWORD(dwWidthLoop)]
            (dwSrcStart, dwDstStart, LOWORD(dwWidthLoop));

      (ULONG_PTR)dwSrcStart+= (wSrcPitch - dwWidth + dwWidthLoop);
      (ULONG_PTR)dwDstStart+= (wDstPitch - dwWidth + dwWidthLoop);
   }

}


VOID NEAR PASCAL PackJRAlign_0_0 (LPDWORD dwSrcStart, LPDWORD dwDstStart, DWORD dwWidth,
                     DWORD dwHeight, WORD wSrcPitch, WORD wDstPitch)
{
   //This function should never be reached
   return;
}


/**********************************************************
*
*       Name:  PackJRBltAlign
*
*       Module Abstract:
*       ----------------
*       Blts PackJR data that is not DWORD aligned (so it
*       can't use the hardware BLTer).
*
*       Output Parameters:
*       ------------------
*       none
*
***********************************************************
*       Author:
*       Date:   10/06/96
*
*       Revision History:
*       -----------------
*       WHO             WHEN     WHAT/WHY/HOW
*       ---             ----     ------------
*
*********************************************************/

VOID PackJRBltAlign (LPBYTE dwSrcStart, LPBYTE dwDstStart, DWORD dwWidth,
                     DWORD dwHeight, WORD wSrcPitch, WORD wDstPitch)
{

static NPALIGN npAlign[4][4] = {
                                   (&PackJRAlign_0_0),
                                   (&PackJRAlign_0_1),
                                   (&PackJRAlign_0_2),
                                   (&PackJRAlign_0_3),
                                   (&PackJRAlign_1_0),
                                   (&PackJRAlign_1_1),
                                   (&PackJRAlign_1_2),
                                   (&PackJRAlign_1_3),
                                   (&PackJRAlign_2_0),
                                   (&PackJRAlign_2_1),
                                   (&PackJRAlign_2_2),
                                   (&PackJRAlign_2_3),
                                   (&PackJRAlign_3_0),
                                   (&PackJRAlign_3_1),
                                   (&PackJRAlign_3_2),
                                   (&PackJRAlign_3_3),
                               };

   npAlign[LOWORD((ULONG_PTR)dwSrcStart) & 3][LOWORD((ULONG_PTR)dwDstStart & 3)]
         ((LPDWORD)((ULONG_PTR)dwSrcStart & 0xFFFFFFFC),
          (LPDWORD)((ULONG_PTR)dwDstStart & 0xFFFFFFFC),
          dwWidth, dwHeight, wSrcPitch, wDstPitch);

   return;

}

/**********************************************************
*
*       Name:  PanOverlay1_7555
*
*       Module Abstract:
*       ----------------
*       Save data for panning overlay window one.
*       Clip lpVideoRect to panning viewport.
*
*       Output Parameters:
*       ------------------
*       lpVideoRect is clipped to panning viewport.
*
***********************************************************
*       Author: Rita Ma
*       Date:   04/01/97
*
*       Revision History:
*       -----------------
*       WHO             WHEN     WHAT/WHY/HOW
*       ---             ----     ------------
*
**********************************************************/
BOOL PanOverlay1_7555(
PDEV* ppdev,
LPRECTL lpVideoRect)
{
    BYTE*   pjPorts;

    pjPorts = ppdev->pjPorts;

    // Update panning viewport for the 32 bits DLL

    // return false if no overlay enable
//  if (ppdev->dwPanningFlag & OVERLAY_OLAY_SHOW)
//      return(FALSE);

    ppdev->rOverlaySrc.left = ppdev->sOverlay1.rSrc.left;
    ppdev->rOverlaySrc.top = ppdev->sOverlay1.rSrc.top;
    ppdev->rOverlaySrc.right = ppdev->sOverlay1.rSrc.right;
    ppdev->rOverlaySrc.bottom = ppdev->sOverlay1.rSrc.bottom;

    ppdev->rOverlayDest.left = ppdev->sOverlay1.rDest.left;
    ppdev->rOverlayDest.top = ppdev->sOverlay1.rDest.top;
    ppdev->rOverlayDest.right = ppdev->sOverlay1.rDest.right;
    ppdev->rOverlayDest.bottom = ppdev->sOverlay1.rDest.bottom;

    lpVideoRect->left = ppdev->sOverlay1.rDest.left;
    lpVideoRect->top = ppdev->sOverlay1.rDest.top;
    lpVideoRect->right = ppdev->sOverlay1.rDest.right;
    lpVideoRect->bottom = ppdev->sOverlay1.rDest.bottom;

    lpVideoRect->left -= ppdev->min_Xscreen;
    lpVideoRect->right -= ppdev->min_Xscreen;
    lpVideoRect->top -= ppdev->min_Yscreen;
    lpVideoRect->bottom -= ppdev->min_Yscreen;

    srcLeft_clip = ppdev->rOverlaySrc.left;
    srcTop_clip = ppdev->rOverlaySrc.top;

    bTop_clip = 0;

    //
    // clip lpVideoRect to panning viewport
    //
    if (lpVideoRect->left < 0)
    {
        srcLeft_clip = (LONG)ppdev->min_Xscreen - ppdev->rOverlayDest.left;
        bLeft_clip = 1;
        DISPDBG((0, "srcLeft_clip:%x", srcLeft_clip));
        lpVideoRect->left = 0;
    }
    if (lpVideoRect->top < 0)
    {
        srcTop_clip = (LONG)ppdev->min_Yscreen - ppdev->rOverlayDest.top;
        bTop_clip = 1;
        DISPDBG((0, "srcTop_clip:%x", srcTop_clip));
        lpVideoRect->top = 0;
    }
    if (lpVideoRect->right > (ppdev->max_Xscreen - ppdev->min_Xscreen)+1)
    {
        lpVideoRect->right = (ppdev->max_Xscreen - ppdev->min_Xscreen)+1;
    }
    if (lpVideoRect->bottom > (ppdev->max_Yscreen - ppdev->min_Yscreen)+1)
    {
        lpVideoRect->bottom =(ppdev->max_Yscreen - ppdev->min_Yscreen)+1;
    }

    return (TRUE);
} // VOID PanOverlay1_Init


/**********************************************************
*
*       Name:  PanOverlay1_Init
*
*       Module Abstract:
*       ----------------
*       Save data for panning overlay window one.
*       Clip lpVideoRect to panning viewport.
*
*       Output Parameters:
*       ------------------
*       lpVideoRect is clipped to panning viewport.
*
***********************************************************
*       Author: Rita Ma
*       Date:   04/01/97
*
*       Revision History:
*       -----------------
*       WHO             WHEN     WHAT/WHY/HOW
*       ---             ----     ------------
*
**********************************************************/
VOID PanOverlay1_Init(PDEV* ppdev,PDD_SURFACE_LOCAL lpSurface,
       LPRECTL lpVideoRect, LPRECTL lpOverlaySrc, LPRECTL lpOverlayDest,
       DWORD dwFourcc, WORD wBitCount)
{

    //
    // save these for panning code to use
    //
    ppdev->lPitch_gbls = lpSurface->lpGbl->lPitch;
    ppdev->fpVidMem_gbls = lpSurface->lpGbl->fpVidMem;
//    ppdev->dwReserved1_lcls = lpSurface->dwReserved1;
    ppdev->sOverlay1.dwFourcc = dwFourcc;
    ppdev->sOverlay1.wBitCount= wBitCount;
    ppdev->sOverlay1.lAdjustSource = 0L;
    ppdev->dwPanningFlag |= OVERLAY_OLAY_SHOW;

    ppdev->sOverlay1.rDest.left  = lpOverlayDest->left;
    ppdev->sOverlay1.rDest.right = lpOverlayDest->right;
    ppdev->sOverlay1.rDest.top   = lpOverlayDest->top;
    ppdev->sOverlay1.rDest.bottom= lpOverlayDest->bottom;

    ppdev->sOverlay1.rSrc.left   = lpOverlaySrc->left;
    ppdev->sOverlay1.rSrc.right  = lpOverlaySrc->right;
    ppdev->sOverlay1.rSrc.top    = lpOverlaySrc->top;
    ppdev->sOverlay1.rSrc.bottom = lpOverlaySrc->bottom;

    lpVideoRect->left   = lpOverlayDest->left;
    lpVideoRect->right  = lpOverlayDest->right;
    lpVideoRect->top    = lpOverlayDest->top;
    lpVideoRect->bottom = lpOverlayDest->bottom;

    //
    // adjust to panning viewport
    //
    lpVideoRect->left   -= (LONG)ppdev->min_Xscreen;
    lpVideoRect->right  -= (LONG)ppdev->min_Xscreen;
    lpVideoRect->top    -= (LONG)ppdev->min_Yscreen;
    lpVideoRect->bottom -= (LONG)ppdev->min_Yscreen;

    srcLeft_clip = lpOverlaySrc->left;
    srcTop_clip = lpOverlaySrc->top;
    bLeft_clip = 0;
    bTop_clip = 0;

    //
    // clip lpVideoRect to panning viewport
    //
    if (lpVideoRect->left < 0)
    {
        srcLeft_clip = (LONG)ppdev->min_Xscreen - lpOverlayDest->left;
        bLeft_clip = 1;
        DISPDBG((0, "srcLeft_clip:%x", srcLeft_clip));
        lpVideoRect->left = 0;
    }
    if (lpVideoRect->top < 0)
    {
        srcTop_clip = (LONG)ppdev->min_Yscreen - lpOverlayDest->top;
        bTop_clip = 1;
        DISPDBG((0, "srcTop_clip:%x", srcTop_clip));
        lpVideoRect->top = 0;
    }
    if (lpVideoRect->right > (ppdev->max_Xscreen - ppdev->min_Xscreen)+1)
    {
        lpVideoRect->right = (ppdev->max_Xscreen - ppdev->min_Xscreen)+1;
    }
    if (lpVideoRect->bottom > (ppdev->max_Yscreen - ppdev->min_Yscreen)+1)
    {
        lpVideoRect->bottom =(ppdev->max_Yscreen - ppdev->min_Yscreen)+1;
    }

} // VOID PanOverlay1_Init


#endif // endif DIRECTDRAW
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\cirrus\disp\lineto.c ===
/******************************************************************************\
*
* $Workfile:   LineTo.c  $
*
* Contents:
* This file contains the DrvLineTo function and simple line drawing code.
*
* Copyright (c) 1996 Cirrus Logic, Inc.
*
* $Log:   V:/CirrusLogic/CL54xx/NT40/Archive/Display/LineTo.c_v  $
*
*    Rev 1.4   12 Aug 1996 16:53:50   frido
* Added NT 3.5x/4.0 auto detection.
*
*    Rev 1.3   29 Jul 1996 12:23:04   frido
* Fixed bug in drawing horizontal lines from right to left.
*
*    Rev 1.2   15 Jul 1996 15:56:12   frido
* Changed DST_ADDR into DST_ADDR_ABS.
*
*    Rev 1.1   12 Jul 1996 16:02:06   frido
* Redefined some macros that caused irratic line drawing on device bitmaps.
*
*    Rev 1.0   10 Jul 1996 17:53:40   frido
* New code.
*
\******************************************************************************/

#include "PreComp.h"
#if LINETO

#define LEFT    0x01
#define TOP             0x02
#define RIGHT   0x04
#define BOTTOM  0x08

bIoLineTo(
PDEV* ppdev,
LONG  x1,
LONG  y1,
LONG  x2,
LONG  y2,
ULONG ulSolidColor,
MIX   mix,
ULONG ulDstAddr)
{
        BYTE* pjPorts = ppdev->pjPorts;
        LONG  lDelta = ppdev->lDelta;
        LONG  dx, dy;
        LONG  cx, cy;

        if (ulSolidColor != (ULONG) -1)
        {
                if (ppdev->cBpp == 1)
                {
                        ulSolidColor |= ulSolidColor << 8;
                        ulSolidColor |= ulSolidColor << 16;
                }
                else if (ppdev->cBpp == 2)
                {
                        ulSolidColor |= ulSolidColor << 16;
                }

                CP_IO_WAIT_FOR_BLT_COMPLETE(ppdev, pjPorts);
                CP_IO_ROP(ppdev, pjPorts, gajHwMixFromMix[mix & 0x0F]);
                CP_IO_SRC_ADDR(ppdev, pjPorts, ppdev->ulSolidColorOffset);
                CP_IO_BLT_MODE(ppdev, pjPorts, ENABLE_COLOR_EXPAND     |
                                                                           ENABLE_8x8_PATTERN_COPY |
                                                                           ppdev->jModeColor);
                CP_IO_FG_COLOR(ppdev, pjPorts, ulSolidColor);
        }

        // Calculate deltas.
        dx = x2 - x1;
        dy = y2 - y1;

        // Horizontal lines.
        if (dy == 0)
        {
                if (dx < 0)
                {
                        // From right to left.
                        ulDstAddr += PELS_TO_BYTES(x2 - 1) + (y2 * lDelta);
                        cx = PELS_TO_BYTES(-dx) - 1;
                }
                else if (dx > 0)
                {
                        // From left to right.
                        ulDstAddr += PELS_TO_BYTES(x1) + (y1 * lDelta);
                        cx = PELS_TO_BYTES(dx) - 1;
                }
                else
                {
                        // Nothing to do here!
                        return(TRUE);
                }

                CP_IO_WAIT_FOR_BLT_COMPLETE(ppdev, pjPorts);
                CP_IO_XCNT(ppdev, pjPorts, cx);
                CP_IO_YCNT(ppdev, pjPorts, 0);
                CP_IO_DST_ADDR_ABS(ppdev, pjPorts, ulDstAddr);
                CP_IO_START_BLT(ppdev, pjPorts);

                return(TRUE);
        }

        // Vertical lines.
        else if (dx == 0)
        {
                if (dy < 0)
                {
                        // From bottom to top.
                        ulDstAddr += PELS_TO_BYTES(x2) + ((y2 + 1) * lDelta);
                        cy = -dy - 1;
                }
                else
                {
                        // From top to bottom.
                        ulDstAddr += PELS_TO_BYTES(x1) + (y1 * lDelta);
                        cy = dy - 1;
                }

                cx = PELS_TO_BYTES(1) - 1;

                CP_IO_WAIT_FOR_BLT_COMPLETE(ppdev, pjPorts);
                CP_IO_XCNT(ppdev, pjPorts, cx);
                CP_IO_YCNT(ppdev, pjPorts, cy);
                CP_IO_DST_Y_OFFSET(ppdev, pjPorts, lDelta);
                CP_IO_DST_ADDR_ABS(ppdev, pjPorts, ulDstAddr);
                CP_IO_START_BLT(ppdev, pjPorts);

                return(TRUE);
        }

        // Diagonal lines.
        else if ((dx == dy) || (dx == -dy))
        {
                if (dy < 0)
                {
                        if (dx < 0)
                        {
                                // Diagonal line from bottom-right to upper-left.
                                ulDstAddr += PELS_TO_BYTES(x2 + 1);
                        }
                        else
                        {
                                // Diagonal line from bottom-left to upper-right.
                                ulDstAddr += PELS_TO_BYTES(x2 - 1);
                        }
                        ulDstAddr += (y2 + 1) * lDelta;
                        cy = -dy - 1;
                }
                else
                {
                        // Diagonal line from top to bottom, either from left to right or
                        // right to left.
                        ulDstAddr += PELS_TO_BYTES(x1) + (y1 * lDelta);
                        cy = dy - 1;
                }

                if (dx == dy)
                {
                        // Diagonal line from top-left to bottom-right or vice versa.
                        lDelta += PELS_TO_BYTES(1);
                }
                else
                {
                        // Diagonal line from top-right to bottom-left or vice versa.
                        lDelta -= PELS_TO_BYTES(1);
                }

                cx = PELS_TO_BYTES(1) - 1;

                CP_IO_WAIT_FOR_BLT_COMPLETE(ppdev, pjPorts);
                CP_IO_XCNT(ppdev, pjPorts, cx);
                CP_IO_YCNT(ppdev, pjPorts, cy);
                CP_IO_DST_Y_OFFSET(ppdev, pjPorts, lDelta);
                CP_IO_DST_ADDR_ABS(ppdev, pjPorts, ulDstAddr);
                CP_IO_START_BLT(ppdev, pjPorts);

                return(TRUE);
        }

        // All other lines.
        if (dx < 0)
        {
                dx = -dx;
        }
        if (dy < 0)
        {
                dy = -dy;
        }
        ulDstAddr += PELS_TO_BYTES(x1) + (y1 * lDelta);

        // Horizontal major.
        if (dx > dy)
        {
                LONG run = dy;

                cy = (y1 > y2) ? -lDelta : lDelta;

                CP_IO_WAIT_FOR_BLT_COMPLETE(ppdev, pjPorts);

                //
                // We would like to set the YCNT register once
                // here (outside the loops below).  However, on
                // the CL5428, this register does not hold its value
                // after one iteration through the loop.  So, I'll
                // have to set it inside the loop.
                //

                if (x1 < x2)
                {
                        while (x1 < x2)
                        {
                                cx = 1 + (dx - run) / dy;
                                if ((x1 + cx) < x2)
                                {
                                        run += cx * dy - dx;
                                }
                                else
                                {
                                        cx = x2 - x1;
                                }
                                x1 += cx;
                                cx = PELS_TO_BYTES(cx);

                                CP_IO_WAIT_FOR_BLT_COMPLETE(ppdev, pjPorts);
                                CP_IO_YCNT(ppdev, pjPorts, 0);
                                CP_IO_XCNT(ppdev, pjPorts, cx - 1);
                                CP_IO_DST_ADDR_ABS(ppdev, pjPorts, ulDstAddr);
                                CP_IO_START_BLT(ppdev, pjPorts);

                                ulDstAddr += cx + cy;
                        }
                }
                else
                {
                        cy -= PELS_TO_BYTES(1);

                        while (x1 > x2)
                        {
                                cx = 1 + (dx - run) / dy;
                                if ((x1 - cx) > x2)
                                {
                                        run += cx * dy - dx;
                                }
                                else
                                {
                                        cx = x1 - x2;
                                }
                                ulDstAddr -= PELS_TO_BYTES(cx - 1);
                                x1 -= cx;
                                cx = PELS_TO_BYTES(cx);

                                CP_IO_WAIT_FOR_BLT_COMPLETE(ppdev, pjPorts);
                                CP_IO_YCNT(ppdev, pjPorts, 0);
                                CP_IO_XCNT(ppdev, pjPorts, cx - 1);
                                CP_IO_DST_ADDR_ABS(ppdev, pjPorts, ulDstAddr);
                                CP_IO_START_BLT(ppdev, pjPorts);

                                ulDstAddr += cy;
                        }
                }
        }

        // Vertical major.
        else
        {
                LONG run = dx;

                cx = (x1 > x2) ? PELS_TO_BYTES(-1) : PELS_TO_BYTES(1);

                CP_IO_WAIT_FOR_BLT_COMPLETE(ppdev, pjPorts);
                CP_IO_XCNT(ppdev, pjPorts, PELS_TO_BYTES(1) - 1);
                CP_IO_DST_Y_OFFSET(ppdev, pjPorts, lDelta);

                if (y1 < y2)
                {
                        while (y1 < y2)
                        {
                                cy = 1 + (dy - run) / dx;
                                if ((y1 + cy) < y2)
                                {
                                        run += cy * dx - dy;
                                }
                                else
                                {
                                        cy = y2 - y1;
                                }
                                y1 += cy;

                                CP_IO_WAIT_FOR_BLT_COMPLETE(ppdev, pjPorts);
                                CP_IO_YCNT(ppdev, pjPorts, cy - 1);
                                CP_IO_DST_ADDR_ABS(ppdev, pjPorts, ulDstAddr);
                                CP_IO_START_BLT(ppdev, pjPorts);

                                ulDstAddr += cx + cy * lDelta;
                        }
                }
                else
                {
                        cx -= lDelta;

                        while (y1 > y2)
                        {
                                cy = 1 + (dy - run) / dx;
                                if ((y1 - cy) > y2)
                                {
                                        run += cy * dx - dy;
                                }
                                else
                                {
                                        cy = y1 - y2;
                                }
                                ulDstAddr -= (cy - 1) * lDelta;
                                y1 -= cy;

                                CP_IO_WAIT_FOR_BLT_COMPLETE(ppdev, pjPorts);
                                CP_IO_YCNT(ppdev, pjPorts, cy - 1);
                                CP_IO_DST_ADDR_ABS(ppdev, pjPorts, ulDstAddr);
                                CP_IO_START_BLT(ppdev, pjPorts);

                                ulDstAddr += cx;
                        }
                }
        }

        return(TRUE);
}

bMmLineTo(
PDEV* ppdev,
LONG  x1,
LONG  y1,
LONG  x2,
LONG  y2,
ULONG ulSolidColor,
MIX   mix,
ULONG ulDstAddr)
{
        BYTE* pjBase = ppdev->pjBase;
        LONG  lDelta = ppdev->lDelta;
        LONG  dx, dy;
        LONG  cx, cy;

        if (ulSolidColor != (ULONG) -1)
        {
                if (ppdev->cBpp == 1)
                {
                        ulSolidColor |= ulSolidColor << 8;
                        ulSolidColor |= ulSolidColor << 16;
                }
                else if (ppdev->cBpp == 2)
                {
                        ulSolidColor |= ulSolidColor << 16;
                }

                CP_MM_WAIT_FOR_BLT_COMPLETE(ppdev, pjBase);
                CP_MM_ROP(ppdev, pjBase, gajHwMixFromMix[mix & 0x0F]);
                CP_MM_SRC_ADDR(ppdev, pjBase, ppdev->ulSolidColorOffset);
                CP_MM_BLT_MODE(ppdev, pjBase, ENABLE_COLOR_EXPAND     |
                                                                          ENABLE_8x8_PATTERN_COPY |
                                                                          ppdev->jModeColor);
                CP_MM_FG_COLOR(ppdev, pjBase, ulSolidColor);

//              if (ppdev->flCaps & CAPS_IS_5436)
                if (ppdev->flCaps & CAPS_AUTOSTART)
                {
                        CP_MM_BLT_EXT_MODE(ppdev, pjBase, ENABLE_SOLID_FILL);
                }
        }

        // Calculate deltas.
        dx = x2 - x1;
        dy = y2 - y1;

        // Horizontal lines.
        if (dy == 0)
        {
                if (dx < 0)
                {
                        // From right to left.
                        ulDstAddr += PELS_TO_BYTES(x2 + 1) + (y2 * lDelta);
                        cx = PELS_TO_BYTES(-dx) - 1;
                }
                else if (dx > 0)
                {
                        // From left to right.
                        ulDstAddr += PELS_TO_BYTES(x1) + (y1 * lDelta);
                        cx = PELS_TO_BYTES(dx) - 1;
                }
                else
                {
                        // Nothing to do here!
                        return(TRUE);
                }

                CP_MM_WAIT_FOR_BLT_COMPLETE(ppdev, pjBase);
                CP_MM_XCNT(ppdev, pjBase, cx);
                CP_MM_YCNT(ppdev, pjBase, 0);
                CP_MM_DST_ADDR_ABS(ppdev, pjBase, ulDstAddr);
                CP_MM_START_BLT(ppdev, pjBase);

                return(TRUE);
        }

        // Vertical lines.
        else if (dx == 0)
        {
                if (dy < 0)
                {
                        // From bottom to top.
                        ulDstAddr += PELS_TO_BYTES(x2) + ((y2 + 1) * lDelta);
                        cy = -dy - 1;
                }
                else
                {
                        // From top to bottom.
                        ulDstAddr += PELS_TO_BYTES(x1) + (y1 * lDelta);
                        cy = dy - 1;
                }

                cx = PELS_TO_BYTES(1) - 1;

                CP_MM_WAIT_FOR_BLT_COMPLETE(ppdev, pjBase);
                CP_MM_XCNT(ppdev, pjBase, cx);
                CP_MM_YCNT(ppdev, pjBase, cy);
                CP_MM_DST_Y_OFFSET(ppdev, pjBase, lDelta);
                CP_MM_DST_ADDR_ABS(ppdev, pjBase, ulDstAddr);
                CP_MM_START_BLT(ppdev, pjBase);

                return(TRUE);
        }

        // Diagonal lines.
        else if ((dx == dy) || (dx == -dy))
        {
                if (dy < 0)
                {
                        if (dx < 0)
                        {
                                // Diagonal line from bottom-right to upper-left.
                                ulDstAddr += PELS_TO_BYTES(x2 + 1);
                        }
                        else
                        {
                                // Diagonal line from bottom-left to upper-right.
                                ulDstAddr += PELS_TO_BYTES(x2 - 1);
                        }
                        ulDstAddr += (y2 + 1) * lDelta;
                        cy = -dy - 1;
                }
                else
                {
                        // Diagonal line from top to bottom, either from left to right or
                        // right to left.
                        ulDstAddr += PELS_TO_BYTES(x1) + (y1 * lDelta);
                        cy = dy - 1;
                }

                if (dx == dy)
                {
                        // Diagonal line from top-left to bottom-right or vice versa.
                        lDelta += PELS_TO_BYTES(1);
                }
                else
                {
                        // Diagonal line from top-right to bottom-left or vice versa.
                        lDelta -= PELS_TO_BYTES(1);
                }

                cx = PELS_TO_BYTES(1) - 1;

                CP_MM_WAIT_FOR_BLT_COMPLETE(ppdev, pjBase);
                CP_MM_XCNT(ppdev, pjBase, cx);
                CP_MM_YCNT(ppdev, pjBase, cy);
                CP_MM_DST_Y_OFFSET(ppdev, pjBase, lDelta);
                CP_MM_DST_ADDR_ABS(ppdev, pjBase, ulDstAddr);
                CP_MM_START_BLT(ppdev, pjBase);

                return(TRUE);
        }

        // All other lines.
        if (dx < 0)
        {
                dx = -dx;
        }
        if (dy < 0)
        {
                dy = -dy;
        }
        ulDstAddr += PELS_TO_BYTES(x1) + (y1 * lDelta);

        // Horizontal major.
        if (dx > dy)
        {
                LONG run = dy;

                cy = (y1 > y2) ? -lDelta : lDelta;

                CP_MM_WAIT_FOR_BLT_COMPLETE(ppdev, pjBase);
                CP_MM_YCNT(ppdev, pjBase, 0);

                if (x1 < x2)
                {
                        while (x1 < x2)
                        {
                                cx = 1 + (dx - run) / dy;
                                if ((x1 + cx) < x2)
                                {
                                        run += cx * dy - dx;
                                }
                                else
                                {
                                        cx = x2 - x1;
                                }
                                x1 += cx;
                                cx = PELS_TO_BYTES(cx);

                                CP_MM_WAIT_FOR_BLT_COMPLETE(ppdev, pjBase);
                                CP_MM_XCNT(ppdev, pjBase, cx - 1);
                                CP_MM_DST_ADDR_ABS(ppdev, pjBase, ulDstAddr);
                                CP_MM_START_BLT(ppdev, pjBase);

                                ulDstAddr += cx + cy;
                        }
                }
                else
                {
                        cy -= PELS_TO_BYTES(1);

                        while (x1 > x2)
                        {
                                cx = 1 + (dx - run) / dy;
                                if ((x1 - cx) > x2)
                                {
                                        run += cx * dy - dx;
                                }
                                else
                                {
                                        cx = x1 - x2;
                                }
                                ulDstAddr -= PELS_TO_BYTES(cx - 1);
                                x1 -= cx;
                                cx = PELS_TO_BYTES(cx);

                                CP_MM_WAIT_FOR_BLT_COMPLETE(ppdev, pjBase);
                                CP_MM_XCNT(ppdev, pjBase, cx - 1);
                                CP_MM_DST_ADDR_ABS(ppdev, pjBase, ulDstAddr);
                                CP_MM_START_BLT(ppdev, pjBase);

                                ulDstAddr += cy;
                        }
                }
        }

        // Vertical major.
        else
        {
                LONG run = dx;

                cx = (x1 > x2) ? PELS_TO_BYTES(-1) : PELS_TO_BYTES(1);

                CP_MM_WAIT_FOR_BLT_COMPLETE(ppdev, pjBase);
                CP_MM_XCNT(ppdev, pjBase, PELS_TO_BYTES(1) - 1);
                CP_MM_DST_Y_OFFSET(ppdev, pjBase, lDelta);

                if (y1 < y2)
                {
                        while (y1 < y2)
                        {
                                cy = 1 + (dy - run) / dx;
                                if ((y1 + cy) < y2)
                                {
                                        run += cy * dx - dy;
                                }
                                else
                                {
                                        cy = y2 - y1;
                                }
                                y1 += cy;

                                CP_MM_WAIT_FOR_BLT_COMPLETE(ppdev, pjBase);
                                CP_MM_YCNT(ppdev, pjBase, cy - 1);
                                CP_MM_DST_ADDR_ABS(ppdev, pjBase, ulDstAddr);
                                CP_MM_START_BLT(ppdev, pjBase);

                                ulDstAddr += cx + cy * lDelta;
                        }
                }
                else
                {
                        cx -= lDelta;

                        while (y1 > y2)
                        {
                                cy = 1 + (dy - run) / dx;
                                if ((y1 - cy) > y2)
                                {
                                        run += cy * dx - dy;
                                }
                                else
                                {
                                        cy = y1 - y2;
                                }
                                ulDstAddr -= (cy - 1) * lDelta;
                                y1 -= cy;

                                CP_MM_WAIT_FOR_BLT_COMPLETE(ppdev, pjBase);
                                CP_MM_YCNT(ppdev, pjBase, cy - 1);
                                CP_MM_DST_ADDR_ABS(ppdev, pjBase, ulDstAddr);
                                CP_MM_START_BLT(ppdev, pjBase);

                                ulDstAddr += cx;
                        }
                }
        }

        return(TRUE);
}

BOOL bClipLine(LONG x1, LONG y1, LONG x2, LONG y2, RECTL* prcl)
{
        ULONG ulCode1, ulCode2;
        RECTL rclClip1, rclClip2;
        LONG  dx, dy;

        // Set clipping rectangles.
        rclClip1.left   = prcl->left;
        rclClip1.top    = prcl->top;
        rclClip1.right  = prcl->right - 1;
        rclClip1.bottom = prcl->bottom - 1;

        rclClip2.left   = prcl->left - 1;
        rclClip2.top    = prcl->top - 1;
        rclClip2.right  = prcl->right;
        rclClip2.bottom = prcl->bottom;

        // Set line deltas.
        dx = x2 - x1;
        dy = y2 - y1;

        // Set line flags.
        ulCode1 = 0;
        if (x1 < rclClip1.left)   ulCode1 |= LEFT;
        if (y1 < rclClip1.top)    ulCode1 |= TOP;
        if (x1 > rclClip1.right)  ulCode1 |= RIGHT;
        if (y1 > rclClip1.bottom) ulCode1 |= BOTTOM;

        ulCode2 = 0;
        if (x2 < rclClip2.left)   ulCode2 |= LEFT;
        if (y2 < rclClip2.top)    ulCode2 |= TOP;
        if (x2 > rclClip2.right)  ulCode2 |= RIGHT;
        if (y2 > rclClip2.bottom) ulCode2 |= BOTTOM;

        if ((ulCode1 & ulCode2) != 0)
        {
                // The line is completly clipped.
                return(FALSE);
        }

        // Vertical lines.
        if (dx == 0)
        {
                if (dy == 0)
                {
                        return(FALSE);
                }

                if (ulCode1 & TOP)
                {
                        y1 = rclClip1.top;
                }
                else if (ulCode1 & BOTTOM)
                {
                        y1 = rclClip1.bottom;
                }

                if (ulCode2 & TOP)
                {
                        y2 = rclClip2.top;
                }
                else if (ulCode2 & BOTTOM)
                {
                        y2 = rclClip2.bottom;
                }

                goto ReturnTrue;
        }

        // Horizontal lines.
        if (dy == 0)
        {
                if (ulCode1 & LEFT)
                {
                        x1 = rclClip1.left;
                }
                else if (ulCode1 & RIGHT)
                {
                        x1 = rclClip1.right;
                }

                if (ulCode2 & LEFT)
                {
                        x2 = rclClip2.left;
                }
                else if (ulCode2 & RIGHT)
                {
                        x2 = rclClip2.right;
                }

                goto ReturnTrue;
        }

        // Clip start point.
        if (x1 < rclClip1.left)
        {
                y1 += dy * (rclClip1.left - x1) / dx;
                x1  = rclClip1.left;
        }
        else if (x1 > rclClip1.right)
        {
                y1 += dy * (rclClip1.right - x1) / dx;
                x1  = rclClip1.right;
        }
        if (y1 < rclClip1.top)
        {
                x1 += dx * (rclClip1.top - y1) / dy;
                y1  = rclClip1.top;
        }
        else if (y1 > rclClip1.bottom)
        {
                x1 += dx * (rclClip1.bottom - y1) / dy;
                y1  = rclClip1.bottom;
        }
        if ((x1 < rclClip1.left) || (y1 < rclClip1.top) || (x1 > rclClip1.right) ||
            (y1 > rclClip1.bottom))
        {
                // Start point fully clipped.
                return(FALSE);
        }

        // Clip end point.
        if (x2 < rclClip2.left)
        {
                y2 += dy * (rclClip2.left - x2) / dx;
                x2  = rclClip2.left;
        }
        else if (x2 > rclClip2.right)
        {
                y2 += dy * (rclClip2.right - x2) / dx;
                x2  = rclClip2.right;
        }
        if (y2 < rclClip2.top)
        {
                x2 += dx * (rclClip2.top - y2) / dy;
                y2  = rclClip2.top;
        }
        else if (y2 > rclClip2.bottom)
        {
                x2 += dx * (rclClip2.bottom - y2) / dy;
                y2  = rclClip2.bottom;
        }
        if ((x2 < rclClip2.left) || (y2 < rclClip2.top) || (x2 > rclClip2.right) ||
            (y2 > rclClip2.bottom))
        {
                // End point fully clipped.
                return(FALSE);
        }

ReturnTrue:
        prcl->left       = x1;
        prcl->top        = y1;
        prcl->right      = x2;
        prcl->bottom = y2;
        return(TRUE);
}

/******************************************************************************\
*
* Function:     DrvLineTo
*
* This function draws a line between any two points. This function only draws
* lines in solod color and that are just 1 pixel wide. The end-point is not
* drawn.
*
* Parameters:   pso                     Pointer to surface.
*               pco                     Pointer to CLIPOBJ.
*               pbo                     Pointer to BRUSHOBJ.
*               x1                      Starting x-coordinate.
*               y1                      Starting y-coordinate.
*               x2                      Ending x-coordinate.
*               y2                      Ending y-coordinate.
*               prclBounds      Pointer to an unclipped bounding rectangle.
*               mix                     Mix to perform on the destination.
*
* Returns:      TRUE if the line has been drawn, FALSE oftherwise.
*
\******************************************************************************/
BOOL DrvLineTo(
SURFOBJ*  pso,
CLIPOBJ*  pco,
BRUSHOBJ* pbo,
LONG      x1,
LONG      y1,
LONG      x2,
LONG      y2,
RECTL*    prclBounds,
MIX       mix)
{
        PDEV*  ppdev = (PPDEV)pso->dhpdev;
        DSURF* pdsurf = (DSURF *)pso->dhsurf;
        OH*    poh;
        BOOL   bMore;

        // If the device bitmap is a DIB, let GDI handle it.
        if (pdsurf->dt == DT_DIB)
        {
                return(EngLineTo(pdsurf->pso, pco, pbo, x1, y1, x2, y2, prclBounds,
                                 mix));
        }

        // Get the off-screen node.
        poh = pdsurf->poh;

        if ((pco == NULL) || (pco->iDComplexity == DC_TRIVIAL))
        {
                // No clipping.
                return(ppdev->pfnLineTo(ppdev, x1, y1, x2, y2, pbo->iSolidColor, mix,
                                        poh->xy));
        }

        else if (pco->iDComplexity == DC_RECT)
        {
                // Clipped rectangle.
                RECTL rcl;

                rcl = pco->rclBounds;
                if (bClipLine(x1, y1, x2, y2, &rcl))
                {
                        return(ppdev->pfnLineTo(ppdev, rcl.left, rcl.top, rcl.right,
                                                                        rcl.bottom, pbo->iSolidColor, mix,
                                                                        poh->xy));
                }
                return(TRUE);
        }

        // Complex clipping.
        CLIPOBJ_cEnumStart(pco, FALSE, CT_RECTANGLES, CD_ANY, 0);

        do
        {
                CLIPENUM ce;
                RECTL* prcl;

                bMore = CLIPOBJ_bEnum(pco, sizeof(ce), &ce.c);

                prcl = ce.arcl;
                while (ce.c--)
                {
                        if (bClipLine(x1, y1, x2, y2, prcl))
                        {
                                if (!ppdev->pfnLineTo(ppdev, prcl->left, prcl->top, prcl->right,
                                                                          prcl->bottom, pbo->iSolidColor, mix,
                                                                          poh->xy))
                                {
                                        return(FALSE);
                                }
                        }
                        prcl++;
                }
        } while (bMore);

        return(TRUE);
}

#endif // LINETO
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\cirrus\disp\lines.c ===
/*************************************************************************\
* Module Name: Lines.c
*
* Contains the code for drawing short fractional endpoint lines and
* longer lines with strips.  There is also a separate x86 Asm version
* of this code.
*
* Copyright (c) 1990-1995 Microsoft Corporation
* Copyright (c) 1992      Digital Equipment Corporation
\**************************************************************************/

#include "precomp.h"

///////////////////////////////////////////////////////////////////////

// We have to be careful of arithmetic overflow in a number of places.
// Fortunately, the compiler is guaranteed to natively support 64-bit
// signed LONGLONGs and 64-bit unsigned DWORDLONGs.
//
// UUInt32x32To64(a, b) is a macro defined in 'winnt.h' that multiplies
//      two 32-bit ULONGs to produce a 64-bit DWORDLONG result.
//
// UInt64By32To32 is our own macro to divide a 64-bit DWORDLONG by
//      a 32-bit ULONG to produce a 32-bit ULONG result.
//
// UInt64Mod32To32 is our own macro to modulus a 64-bit DWORDLONG by
//      a 32-bit ULONG to produce a 32-bit ULONG result.
//
// 64 bit divides are usually very expensive.  Since it's very rare
// that we'll get lines where the upper 32 bits of the 64 bit result
// are used, we can almost always use 32-bit ULONG divides.  We still
// must correctly handle the larger cases:

#define UInt64Div32To32(a, b)                   \
    ((((DWORDLONG)(a)) > ULONG_MAX)          ?  \
        (ULONG)((DWORDLONG)(a) / (ULONG)(b)) :  \
        (ULONG)((ULONG)(a) / (ULONG)(b)))

#define UInt64Mod32To32(a, b)                   \
    ((((DWORDLONG)(a)) > ULONG_MAX)          ?  \
        (ULONG)((DWORDLONG)(a) % (ULONG)(b)) :  \
        (ULONG)((ULONG)(a) % (ULONG)(b)))

#define SWAPL(x,y,t)        {t = x; x = y; y = t;}

FLONG gaflRound[] = {
    FL_H_ROUND_DOWN | FL_V_ROUND_DOWN, // no flips
    FL_H_ROUND_DOWN | FL_V_ROUND_DOWN, // FL_FLIP_D
    FL_H_ROUND_DOWN,                   // FL_FLIP_V
    FL_V_ROUND_DOWN,                   // FL_FLIP_V | FL_FLIP_D
    FL_V_ROUND_DOWN,                   // FL_FLIP_SLOPE_ONE
    0xbaadf00d,                        // FL_FLIP_SLOPE_ONE | FL_FLIP_D
    FL_H_ROUND_DOWN,                   // FL_FLIP_SLOPE_ONE | FL_FLIP_V
    0xbaadf00d                         // FL_FLIP_SLOPE_ONE | FL_FLIP_V | FL_FLIP_D
};


/******************************Public*Routine******************************\
* BOOL bLines(ppdev, pptfxFirst, pptfxBuf, cptfx, pls,
*                   prclClip, apfn[], flStart)
*
* Computes the DDA for the line and gets ready to draw it.  Puts the
* pixel data into an array of strips, and calls a strip routine to
* do the actual drawing.
*
* Doing NT Lines Right
* --------------------
*
* In NT, all lines are given to the device driver in fractional
* coordinates, in a 28.4 fixed point format.  The lower 4 bits are
* fractional for sub-pixel positioning.
*
* Note that you CANNOT! just round the coordinates to integers
* and pass the results to your favorite integer Bresenham routine!!
* (Unless, of course, you have such a high resolution device that
* nobody will notice -- not likely for a display device.)  The
* fractions give a more accurate rendering of the line -- this is
* important for things like our Bezier curves, which would have 'kinks'
* if the points in its polyline approximation were rounded to integers.
*
* Unfortunately, for fractional lines there is more setup work to do
* a DDA than for integer lines.  However, the main loop is exactly
* the same (and can be done entirely with 32 bit math).
*
* If You've Got Hardware That Does Bresenham
* ------------------------------------------
*
* A lot of hardware limits DDA error terms to 'n' bits.  With fractional
* coordinates, 4 bits are given to the fractional part, letting
* you draw in hardware only those lines that lie entirely in a 2^(n-4)
* by 2^(n-4) pixel space.
*
* And you still have to correctly draw those lines with coordinates
* outside that space!  Remember that the screen is only a viewport
* onto a 28.4 by 28.4 space -- if any part of the line is visible
* you MUST render it precisely, regardless of where the end points lie.
* So even if you do it in software, somewhere you'll have to have a
* 32 bit DDA routine.
*
* Our Implementation
* ------------------
*
* We employ a run length slice algorithm: our DDA calculates the
* number of pixels that are in each row (or 'strip') of pixels.
*
* We've separated the running of the DDA and the drawing of pixels:
* we run the DDA for several iterations and store the results in
* a 'strip' buffer (which are the lengths of consecutive pixel rows of
* the line), then we crank up a 'strip drawer' that will draw all the
* strips in the buffer.
*
* We also employ a 'half-flip' to reduce the number of strip
* iterations we need to do in the DDA and strip drawing loops: when a
* (normalized) line's slope is more than 1/2, we do a final flip
* about the line y = (1/2)x.  So now, instead of each strip being
* consecutive horizontal or vertical pixel rows, each strip is composed
* of those pixels aligned in 45 degree rows.  So a line like (0, 0) to
* (128, 128) would generate only one strip.
*
* We also always draw only left-to-right.
*
* Styled lines may have arbitrary style patterns.  We specially
* optimize the default patterns (and call them 'masked' styles).
*
* The DDA Derivation
* ------------------
*
* Here is how I like to think of the DDA calculation.
*
* We employ Knuth's "diamond rule": rendering a one-pixel-wide line
* can be thought of as dragging a one-pixel-wide by one-pixel-high
* diamond along the true line.  Pixel centers lie on the integer
* coordinates, and so we light any pixel whose center gets covered
* by the "drag" region (John D. Hobby, Journal of the Association
* for Computing Machinery, Vol. 36, No. 2, April 1989, pp. 209-229).
*
* We must define which pixel gets lit when the true line falls
* exactly half-way between two pixels.  In this case, we follow
* the rule: when two pels are equidistant, the upper or left pel
* is illuminated, unless the slope is exactly one, in which case
* the upper or right pel is illuminated.  (So we make the edges
* of the diamond exclusive, except for the top and left vertices,
* which are inclusive, unless we have slope one.)
*
* This metric decides what pixels should be on any line BEFORE it is
* flipped around for our calculation.  Having a consistent metric
* this way will let our lines blend nicely with our curves.  The
* metric also dictates that we will never have one pixel turned on
* directly above another that's turned on.  We will also never have
* a gap; i.e., there will be exactly one pixel turned on for each
* column between the start and end points.  All that remains to be
* done is to decide how many pixels should be turned on for each row.
*
* So lines we draw will consist of varying numbers of pixels on
* successive rows, for example:
*
*       ******
*             *****
*                  ******
*                        *****
*
* We'll call each set of pixels on a row a "strip".
*
* (Please remember that our coordinate space has the origin as the
* upper left pixel on the screen; postive y is down and positive x
* is right.)
*
* Device coordinates are specified as fixed point 28.4 numbers,
* where the first 28 bits are the integer coordinate, and the last
* 4 bits are the fraction.  So coordinates may be thought of as
* having the form (x, y) = (M/F, N/F) where F is the constant scaling
* factor F = 2^4 = 16, and M and N are 32 bit integers.
*
* Consider the line from (M0/F, N0/F) to (M1/F, N1/F) which runs
* left-to-right and whose slope is in the first octant, and let
* dM = M1 - M0 and dN = N1 - N0.  Then dM >= 0, dN >= 0 and dM >= dN.
*
* Since the slope of the line is less than 1, the edges of the
* drag region are created by the top and bottom vertices of the
* diamond.  At any given pixel row y of the line, we light those
* pixels whose centers are between the left and right edges.
*
* Let mL(n) denote the line representing the left edge of the drag
* region.  On pixel row j, the column of the first pixel to be
* lit is
*
*       iL(j) = ceiling( mL(j * F) / F)
*
* Since the line's slope is less than one:
*
*       iL(j) = ceiling( mL([j + 1/2] F) / F )
*
* Recall the formula for our line:
*
*       n(m) = (dN / dM) (m - M0) + N0
*
*       m(n) = (dM / dN) (n - N0) + M0
*
* Since the line's slope is less than one, the line representing
* the left edge of the drag region is the original line offset
* by 1/2 pixel in the y direction:
*
*       mL(n) = (dM / dN) (n - F/2 - N0) + M0
*
* From this we can figure out the column of the first pixel that
* will be lit on row j, being careful of rounding (if the left
* edge lands exactly on an integer point, the pixel at that
* point is not lit because of our rounding convention):
*
*       iL(j) = floor( mL(j F) / F ) + 1
*
*             = floor( ((dM / dN) (j F - F/2 - N0) + M0) / F ) + 1
*
*             = floor( F dM j - F/2 dM - N0 dM + dN M0) / F dN ) + 1
*
*                      F dM j - [ dM (N0 + F/2) - dN M0 ]
*             = floor( ---------------------------------- ) + 1
*                                   F dN
*
*                      dM j - [ dM (N0 + F/2) - dN M0 ] / F
*             = floor( ------------------------------------ ) + 1       (1)
*                                     dN
*
*             = floor( (dM j + alpha) / dN ) + 1
*
* where
*
*       alpha = - [ dM (N0 + F/2) - dN M0 ] / F
*
* We use equation (1) to calculate the DDA: there are iL(j+1) - iL(j)
* pixels in row j.  Because we are always calculating iL(j) for
* integer quantities of j, we note that the only fractional term
* is constant, and so we can 'throw away' the fractional bits of
* alpha:
*
*       beta = floor( - [ dM (N0 + F/2) - dN M0 ] / F )                 (2)
*
* so
*
*       iL(j) = floor( (dM j + beta) / dN ) + 1                         (3)
*
* for integers j.
*
* Note if iR(j) is the line's rightmost pixel on row j, that
* iR(j) = iL(j + 1) - 1.
*
* Similarly, rewriting equation (1) as a function of column i,
* we can determine, given column i, on which pixel row j is the line
* lit:
*
*                       dN i + [ dM (N0 + F/2) - dN M0 ] / F
*       j(i) = ceiling( ------------------------------------ ) - 1
*                                       dM
*
* Floors are easier to compute, so we can rewrite this:
*
*                     dN i + [ dM (N0 + F/2) - dN M0 ] / F + dM - 1/F
*       j(i) = floor( ----------------------------------------------- ) - 1
*                                       dM
*
*                     dN i + [ dM (N0 + F/2) - dN M0 ] / F + dM - 1/F - dM
*            = floor( ---------------------------------------------------- )
*                                       dM
*
*                     dN i + [ dM (N0 + F/2) - dN M0 - 1 ] / F
*            = floor( ---------------------------------------- )
*                                       dM
*
* We can once again wave our hands and throw away the fractional bits
* of the remainder term:
*
*       j(i) = floor( (dN i + gamma) / dM )                             (4)
*
* where
*
*       gamma = floor( [ dM (N0 + F/2) - dN M0 - 1 ] / F )              (5)
*
* We now note that
*
*       beta = -gamma - 1 = ~gamma                                      (6)
*
* To draw the pixels of the line, we could evaluate (3) on every scan
* line to determine where the strip starts.  Of course, we don't want
* to do that because that would involve a multiply and divide for every
* scan.  So we do everything incrementally.
*
* We would like to easily compute c , the number of pixels on scan j:
*                                  j
*
*    c  = iL(j + 1) - iL(j)
*     j
*
*       = floor((dM (j + 1) + beta) / dN) - floor((dM j + beta) / dN)   (7)
*
* This may be rewritten as
*
*    c  = floor(i    + r    / dN) - floor(i  + r  / dN)                 (8)
*     j          j+1    j+1                j    j
*
* where i , i    are integers and r  < dN, r    < dN.
*        j   j+1                   j        j+1
*
* Rewriting (7) again:
*
*    c  = floor(i  + r  / dN + dM / dN) - floor(i  + r  / dN)
*     j          j    j                          j    j
*
*
*       = floor((r  + dM) / dN) - floor(r  / dN)
*                 j                      j
*
* This may be rewritten as
*
*    c  = dI + floor((r  + dR) / dN) - floor(r  / dN)
*     j                j                      j
*
* where dI + dR / dN = dM / dN, dI is an integer and dR < dN.
*
* r  is the remainder (or "error") term in the DDA loop: r  / dN
*  j                                                      j
* is the exact fraction of a pixel at which the strip ends.  To go
* on to the next scan and compute c    we need to know r   .
*                                  j+1                  j+1
*
* So in the main loop of the DDA:
*
*    c  = dI + floor((r  + dR) / dN) and r    = (r  + dR) % dN
*     j                j                  j+1     j
*
* and we know r  < dN, r    < dN, and dR < dN.
*              j        j+1
*
* We have derived the DDA only for lines in the first octant; to
* handle other octants we do the common trick of flipping the line
* to the first octant by first making the line left-to-right by
* exchanging the end-points, then flipping about the lines y = 0 and
* y = x, as necessary.  We must record the transformation so we can
* undo them later.
*
* We must also be careful of how the flips affect our rounding.  If
* to get the line to the first octant we flipped about x = 0, we now
* have to be careful to round a y value of 1/2 up instead of down as
* we would for a line originally in the first octant (recall that
* "In the case where two pels are equidistant, the upper or left
* pel is illuminated...").
*
* To account for this rounding when running the DDA, we shift the line
* (or not) in the y direction by the smallest amount possible.  That
* takes care of rounding for the DDA, but we still have to be careful
* about the rounding when determining the first and last pixels to be
* lit in the line.
*
* Determining The First And Last Pixels In The Line
* -------------------------------------------------
*
* Fractional coordinates also make it harder to determine which pixels
* will be the first and last ones in the line.  We've already taken
* the fractional coordinates into account in calculating the DDA, but
* the DDA cannot tell us which are the end pixels because it is quite
* happy to calculate pixels on the line from minus infinity to positive
* infinity.
*
* The diamond rule determines the start and end pixels.  (Recall that
* the sides are exclusive except for the left and top vertices.)
* This convention can be thought of in another way: there are diamonds
* around the pixels, and wherever the true line crosses a diamond,
* that pel is illuminated.
*
* Consider a line where we've done the flips to the first octant, and the
* floor of the start coordinates is the origin:
*
*        +-----------------------> +x
*        |
*        | 0                     1
*        |     0123456789abcdef
*        |
*        |   0 00000000?1111111
*        |   1 00000000 1111111
*        |   2 0000000   111111
*        |   3 000000     11111
*        |   4 00000    ** 1111
*        |   5 0000       ****1
*        |   6 000           1***
*        |   7 00             1  ****
*        |   8 ?                     ***
*        |   9 22             3         ****
*        |   a 222           33             ***
*        |   b 2222         333                ****
*        |   c 22222       3333                    **
*        |   d 222222     33333
*        |   e 2222222   333333
*        |   f 22222222 3333333
*        |
*        | 2                     3
*        v
*        +y
*
* If the start of the line lands on the diamond around pixel 0 (shown by
* the '0' region here), pixel 0 is the first pel in the line.  The same
* is true for the other pels.
*
* A little more work has to be done if the line starts in the
* 'nether-land' between the diamonds (as illustrated by the '*' line):
* the first pel lit is the first diamond crossed by the line (pixel 1 in
* our example).  This calculation is determined by the DDA or slope of
* the line.
*
* If the line starts exactly half way between two adjacent pixels
* (denoted here by the '?' spots), the first pixel is determined by our
* round-down convention (and is dependent on the flips done to
* normalize the line).
*
* Last Pel Exclusive
* ------------------
*
* To eliminate repeatedly lit pels between continuous connected lines,
* we employ a last-pel exclusive convention: if the line ends exactly on
* the diamond around a pel, that pel is not lit.  (This eliminates the
* checks we had in the old code to see if we were re-lighting pels.)
*
* The Half Flip
* -------------
*
* To make our run length algorithm more efficient, we employ a "half
* flip".  If after normalizing to the first octant, the slope is more
* than 1/2, we subtract the y coordinate from the x coordinate.  This
* has the effect of reflecting the coordinates through the line of slope
* 1/2.  Note that the diagonal gets mapped into the x-axis after a half
* flip.
*
* How Many Bits Do We Need, Anyway?
* ---------------------------------
*
* Note that if the line is visible on your screen, you must light up
* exactly the correct pixels, no matter where in the 28.4 x 28.4 device
* space the end points of the line lie (meaning you must handle 32 bit
* DDAs, you can certainly have optimized cases for lesser DDAs).
*
* We move the origin to (floor(M0 / F), floor(N0 / F)), so when we
* calculate gamma from (5), we know that 0 <= M0, N0 < F.  And we
* are in the first octant, so dM >= dN.  Then we know that gamma can
* be in the range [(-1/2)dM, (3/2)dM].  The DDI guarantees us that
* valid lines will have dM and dN values at most 31 bits (unsigned)
* of significance.  So gamma requires 33 bits of significance (we store
* this as a 64 bit number for convenience).
*
* When running through the DDA loop, r  + dR can have a value in the
*                                     j
* range 0 <= r  < 2 dN; thus the result must be a 32 bit unsigned value.
*             j
*
* Testing Lines
* -------------
*
* To be NT compliant, a display driver must exactly adhere to GIQ,
* which means that for any given line, the driver must light exactly
* the same pels as does GDI.  This can be tested using the Guiman tool
* provided elsewhere in the DDK, and 'ZTest', which draws random lines
* on the screen and to a bitmap, and compares the results.
*
* If You've Got Line Hardware
* ---------------------------
*
* If your hardware already adheres to GIQ, you're all set.  Otherwise
* you'll want to look at the sample code and read the following:
*
* 1) You'll want to special case integer-only lines, since they require
*    less processing time and are more common (CAD programs will probably
*    only ever give integer lines).  GDI does not provide a flag saying
*    that all lines in a path are integer lines; consequently, you will
*    have to explicitly check every line.
*
* 2) You are required to correctly draw any line in the 28.4 device
*    space that intersects the viewport.  If you have less than 32 bits
*    of significance in the hardware for the Bresenham terms, extremely
*    long lines would overflow the hardware.  For such (rare) cases, you
*    can fall back to strip-drawing code (or if your display is a frame
*    buffer, fall back to the engine).
*
* 3) If you can explicitly set the Bresenham terms in your hardware, you
*    can draw non-integer lines using the hardware.  If your hardware has
*    'n' bits of precision, you can draw GIQ lines that are up to 2^(n-5)
*    pels long (4 bits are required for the fractional part, and one bit is
*    used as a sign bit).  Note that integer lines don't require the 4
*    fractional bits, so if you special case them as in 1), you can do
*    integer lines that are up to 2^(n - 1) pels long.  See the
*    'bHardwareLine' routine for an example.
*
\**************************************************************************/

BOOL bLines(
PDEV*      ppdev,
POINTFIX*  pptfxFirst,  // Start of first line
POINTFIX*  pptfxBuf,    // Pointer to buffer of all remaining lines
RUN*       prun,        // Pointer to runs if doing complex clipping
ULONG      cptfx,       // Number of points in pptfxBuf or number of runs
                        // in prun
LINESTATE* pls,         // Colour and style info
RECTL*     prclClip,    // Pointer to clip rectangle if doing simple clipping
PFNSTRIP   apfn[],      // Array of strip functions
FLONG      flStart)     // Flags for each line, which is a combination of:
                        //      FL_SIMPLE_CLIP
                        //      FL_COMPLEX_CLIP
                        //      FL_STYLED
                        //      FL_LAST_PEL_INCLUSIVE
                        //        - Should be set only for all integer lines,
                        //          and can't be used with FL_COMPLEX_CLIP
{
    ULONG     M0;
    ULONG     dM;
    ULONG     N0;
    ULONG     dN;
    ULONG     dN_Original;
    FLONG     fl;
    LONG      x;
    LONG      y;

    LONGLONG  llBeta;
    LONGLONG  llGamma;
    LONGLONG  dl;
    LONGLONG  ll;

    ULONG     ulDelta;

    ULONG     x0;
    ULONG     y0;
    ULONG     x1;
    ULONG     cStylePels;    // Major length of line in pixels for styling
    ULONG     xStart;
    POINTL    ptlStart;
    STRIP     strip;
    PFNSTRIP  pfn;
    LONG      cPels;
    LONG*     plStrip;
    LONG*     plStripEnd;
    LONG      cStripsInNextRun;

    POINTFIX* pptfxBufEnd = pptfxBuf + cptfx; // Last point in path record
    STYLEPOS  spThis;                         // Style pos for this line

    do {

/***********************************************************************\
* Start the DDA calculations.                                           *
\***********************************************************************/

        M0 = (LONG) pptfxFirst->x;
        dM = (LONG) pptfxBuf->x;

        N0 = (LONG) pptfxFirst->y;
        dN = (LONG) pptfxBuf->y;

        fl = flStart;

        if ((LONG) M0 > (LONG) dM)
        {
        // Ensure that we run left-to-right:

            register ULONG ulTmp;
            SWAPL(M0, dM, ulTmp);
            SWAPL(N0, dN, ulTmp);
            fl |= FL_FLIP_H;
        }

    // Compute the delta dx.  The DDI says we can never have a valid delta
    // with a magnitued more than 2^31 - 1, but GDI never actually checks
    // its transforms.  So we have to check for this case to avoid overflow:

        dM -= M0;
        if ((LONG) dM < 0)
        {
            goto Next_Line;
        }

        if ((LONG) dN < (LONG) N0)
        {
        // Line runs from bottom to top, so flip across y = 0:

            N0 = -(LONG) N0;
            dN = -(LONG) dN;
            fl |= FL_FLIP_V;
        }

        dN -= N0;

        if ((LONG) dN < 0)
        {
            goto Next_Line;
        }

    // We now have a line running left-to-right, top-to-bottom from (M0, N0)
    // to (M0 + dM, N0 + dN):

        if (dN >= dM)
        {
            if (dN == dM)
            {
            // Have to special case slopes of one:

                fl |= FL_FLIP_SLOPE_ONE;
            }
            else
            {
            // Since line has slope greater than 1, flip across x = y:

                register ULONG ulTmp;
                SWAPL(dM, dN, ulTmp);
                SWAPL(M0, N0, ulTmp);
                fl |= FL_FLIP_D;
            }
        }

        fl |= gaflRound[(fl & FL_ROUND_MASK) >> FL_ROUND_SHIFT];

        x = LFLOOR((LONG) M0);
        y = LFLOOR((LONG) N0);

        M0 = FXFRAC(M0);
        N0 = FXFRAC(N0);

    // Calculate the remainder term [ dM * (N0 + F/2) - M0 * dN ]:

        llGamma = UInt32x32To64(dM, N0 + F/2) - UInt32x32To64(M0, dN);
        if (fl & FL_V_ROUND_DOWN)   // Adjust so y = 1/2 rounds down
        {
            llGamma--;
        }

        llGamma >>= FLOG2;
        llBeta = ~llGamma;

/***********************************************************************\
* Figure out which pixels are at the ends of the line.                  *
\***********************************************************************/

    // The toughest part of GIQ is determining the start and end pels.
    //
    // Our approach here is to calculate x0 and x1 (the inclusive start
    // and end columns of the line respectively, relative to our normalized
    // origin).  Then x1 - x0 + 1 is the number of pels in the line.  The
    // start point is easily calculated by plugging x0 into our line equation
    // (which takes care of whether y = 1/2 rounds up or down in value)
    // getting y0, and then undoing the normalizing flips to get back
    // into device space.
    //
    // We look at the fractional parts of the coordinates of the start and
    // end points, and call them (M0, N0) and (M1, N1) respectively, where
    // 0 <= M0, N0, M1, N1 < 16.  We plot (M0, N0) on the following grid
    // to determine x0:
    //
    //   +-----------------------> +x
    //   |
    //   | 0                     1
    //   |     0123456789abcdef
    //   |
    //   |   0 ........?xxxxxxx
    //   |   1 ..........xxxxxx
    //   |   2 ...........xxxxx
    //   |   3 ............xxxx
    //   |   4 .............xxx
    //   |   5 ..............xx
    //   |   6 ...............x
    //   |   7 ................
    //   |   8 ................
    //   |   9 ......**........
    //   |   a ........****...x
    //   |   b ............****
    //   |   c .............xxx****
    //   |   d ............xxxx    ****
    //   |   e ...........xxxxx        ****
    //   |   f ..........xxxxxx
    //   |
    //   | 2                     3
    //   v
    //
    //   +y
    //
    // This grid accounts for the appropriate rounding of GIQ and last-pel
    // exclusion.  If (M0, N0) lands on an 'x', x0 = 2.  If (M0, N0) lands
    // on a '.', x0 = 1.  If (M0, N0) lands on a '?', x0 rounds up or down,
    // depending on what flips have been done to normalize the line.
    //
    // For the end point, if (M1, N1) lands on an 'x', x1 =
    // floor((M0 + dM) / 16) + 1.  If (M1, N1) lands on a '.', x1 =
    // floor((M0 + dM)).  If (M1, N1) lands on a '?', x1 rounds up or down,
    // depending on what flips have been done to normalize the line.
    //
    // Lines of exactly slope one require a special case for both the start
    // and end.  For example, if the line ends such that (M1, N1) is (9, 1),
    // the line has gone exactly through (8, 0) -- which may be considered
    // to be part of 'x' because of rounding!  So slopes of exactly slope
    // one going through (8, 0) must also be considered as belonging in 'x'.
    //
    // For lines that go left-to-right, we have the following grid:
    //
    //   +-----------------------> +x
    //   |
    //   | 0                     1
    //   |     0123456789abcdef
    //   |
    //   |   0 xxxxxxxx?.......
    //   |   1 xxxxxxx.........
    //   |   2 xxxxxx..........
    //   |   3 xxxxx...........
    //   |   4 xxxx............
    //   |   5 xxx.............
    //   |   6 xx..............
    //   |   7 x...............
    //   |   8 x...............
    //   |   9 x.....**........
    //   |   a xx......****....
    //   |   b xxx.........****
    //   |   c xxxx............****
    //   |   d xxxxx...........    ****
    //   |   e xxxxxx..........        ****
    //   |   f xxxxxxx.........
    //   |
    //   | 2                     3
    //   v
    //
    //   +y
    //
    // This grid accounts for the appropriate rounding of GIQ and last-pel
    // exclusion.  If (M0, N0) lands on an 'x', x0 = 0.  If (M0, N0) lands
    // on a '.', x0 = 1.  If (M0, N0) lands on a '?', x0 rounds up or down,
    // depending on what flips have been done to normalize the line.
    //
    // For the end point, if (M1, N1) lands on an 'x', x1 =
    // floor((M0 + dM) / 16) - 1.  If (M1, N1) lands on a '.', x1 =
    // floor((M0 + dM)).  If (M1, N1) lands on a '?', x1 rounds up or down,
    // depending on what flips have been done to normalize the line.
    //
    // Lines of exactly slope one must be handled similarly to the right-to-
    // left case.

        {

        // Calculate x0, x1

            ULONG N1 = FXFRAC(N0 + dN);
            ULONG M1 = FXFRAC(M0 + dM);

            x1 = LFLOOR(M0 + dM);

            if (fl & FL_LAST_PEL_INCLUSIVE)
            {
            // It sure is easy to compute the first pel when lines have only
            // integer coordinates and are last-pel inclusive:

                x0 = 0;
                y0 = 0;

            // Last-pel inclusive lines that are exactly one pixel long
            // have a 'delta-x' and 'delta-y' equal to zero.  The problem is
            // that our clip code assumes that 'delta-x' is always non-zero
            // (since it never happens with last-pel exclusive lines).  As
            // an inelegant solution, we simply modify 'delta-x' in this
            // case -- because the line is exactly one pixel long, changing
            // the slope will obviously have no effect on rasterization.

                if (x1 == 0)
                {
                    dM      = 1;
                    llGamma = 0;
                    llBeta  = ~llGamma;
                }
            }
            else
            {
                if (fl & FL_FLIP_H)
                {
                // ---------------------------------------------------------------
                // Line runs right-to-left:  <----

                // Compute x1:

                    if (N1 == 0)
                    {
                        if (LROUND(M1, fl & FL_H_ROUND_DOWN))
                        {
                            x1++;
                        }
                    }
                    else if (abs((LONG) (N1 - F/2)) + M1 > F)
                    {
                        x1++;
                    }

                    if ((fl & (FL_FLIP_SLOPE_ONE | FL_H_ROUND_DOWN))
                           == (FL_FLIP_SLOPE_ONE))
                    {
                    // Have to special-case diagonal lines going through our
                    // the point exactly equidistant between two horizontal
                    // pixels, if we're supposed to round x=1/2 down:

                        if ((N1 > 0) && (M1 == N1 + 8))
                            x1++;

                    // Don't you love special cases?  Is this a rhetorical question?

                        if ((N0 > 0) && (M0 == N0 + 8))
                        {
                            x0      = 2;
                            ulDelta = dN;
                            goto right_to_left_compute_y0;
                        }
                    }

                // Compute x0:

                    x0      = 1;
                    ulDelta = 0;
                    if (N0 == 0)
                    {
                        if (LROUND(M0, fl & FL_H_ROUND_DOWN))
                        {
                            x0      = 2;
                            ulDelta = dN;
                        }
                    }
                    else if (abs((LONG) (N0 - F/2)) + M0 > F)
                    {
                        x0      = 2;
                        ulDelta = dN;
                    }


                // Compute y0:

                right_to_left_compute_y0:

                    y0 = 0;
                    ll = llGamma + (LONGLONG) ulDelta;

                    if (ll >= (LONGLONG) (2 * dM - dN))
                        y0 = 2;
                    else if (ll >= (LONGLONG) (dM - dN))
                        y0 = 1;
                }
                else
                {
                // ---------------------------------------------------------------
                // Line runs left-to-right:  ---->

                // Compute x1:

                    if (!(fl & FL_LAST_PEL_INCLUSIVE))
                        x1--;

                    if (M1 > 0)
                    {
                        if (N1 == 0)
                        {
                            if (LROUND(M1, fl & FL_H_ROUND_DOWN))
                                x1++;
                        }
                        else if (abs((LONG) (N1 - F/2)) <= (LONG) M1)
                        {
                            x1++;
                        }
                    }

                    if ((fl & (FL_FLIP_SLOPE_ONE | FL_H_ROUND_DOWN))
                           == (FL_FLIP_SLOPE_ONE | FL_H_ROUND_DOWN))
                    {
                    // Have to special-case diagonal lines going through our
                    // the point exactly equidistant between two horizontal
                    // pixels, if we're supposed to round x=1/2 down:

                        if ((M1 > 0) && (N1 == M1 + 8))
                            x1--;

                        if ((M0 > 0) && (N0 == M0 + 8))
                        {
                            x0 = 0;
                            goto left_to_right_compute_y0;
                        }
                    }

                // Compute x0:

                    x0 = 0;
                    if (M0 > 0)
                    {
                        if (N0 == 0)
                        {
                            if (LROUND(M0, fl & FL_H_ROUND_DOWN))
                                x0 = 1;
                        }
                        else if (abs((LONG) (N0 - F/2)) <= (LONG) M0)
                        {
                            x0 = 1;
                        }
                    }

                // Compute y0:

                left_to_right_compute_y0:

                    y0 = 0;
                    if (llGamma >= (LONGLONG) (dM - (dN & (-(LONG) x0))))
                    {
                        y0 = 1;
                    }
                }
            }
        }

        cStylePels = x1 - x0 + 1;
        if ((LONG) cStylePels <= 0)
            goto Next_Line;

        xStart = x0;

/***********************************************************************\
* Complex clipping.                                                     *
\***********************************************************************/

        if (fl & FL_COMPLEX_CLIP)
        {
            dN_Original = dN;

        Continue_Complex_Clipping:

            if (fl & FL_FLIP_H)
            {
            // Line runs right-to-left <-----

                x0 = xStart + cStylePels - prun->iStop - 1;
                x1 = xStart + cStylePels - prun->iStart - 1;
            }
            else
            {
            // Line runs left-to-right ----->

                x0 = xStart + prun->iStart;
                x1 = xStart + prun->iStop;
            }

            prun++;

        // Reset some variables we'll nuke a little later:

            dN          = dN_Original;
            pls->spNext = pls->spComplex;

        // No overflow since large integer math is used.  Both values
        // will be positive:

            dl = UInt32x32To64(x0, dN) + llGamma;

        // y0 = dl / dM:

            y0 = UInt64Div32To32(dl, dM);

            ASSERTDD((LONG) y0 >= 0, "y0 weird: Goofed up end pel calc?");
        }

/***********************************************************************\
* Simple rectangular clipping.                                          *
\***********************************************************************/

        if (fl & FL_SIMPLE_CLIP)
        {
            ULONG y1;
            LONG  xRight;
            LONG  xLeft;
            LONG  yBottom;
            LONG  yTop;

        // Note that y0 and y1 are actually the lower and upper bounds,
        // respectively, of the y coordinates of the line (the line may
        // have actually shrunk due to first/last pel clipping).
        //
        // Also note that x0, y0 are not necessarily zero.

            RECTL* prcl = &prclClip[(fl & FL_RECTLCLIP_MASK) >>
                                    FL_RECTLCLIP_SHIFT];

        // Normalize to the same point we've normalized for the DDA
        // calculations:

            xRight  = prcl->right  - x;
            xLeft   = prcl->left   - x;
            yBottom = prcl->bottom - y;
            yTop    = prcl->top    - y;

            if (yBottom <= (LONG) y0 ||
                xRight  <= (LONG) x0 ||
                xLeft   >  (LONG) x1)
            {
            Totally_Clipped:

                if (fl & FL_STYLED)
                {
                    pls->spNext += cStylePels;
                    if (pls->spNext >= pls->spTotal2)
                        pls->spNext %= pls->spTotal2;
                }

                goto Next_Line;
            }

            if ((LONG) x1 >= xRight)
                x1 = xRight - 1;

        // We have to know the correct y1, which we haven't bothered to
        // calculate up until now.  This multiply and divide is quite
        // expensive; we could replace it with code similar to that which
        // we used for computing y0.
        //
        // The reason why we need the actual value, and not an upper
        // bounds guess like y1 = LFLOOR(dM) + 2 is that we have to be
        // careful when calculating x(y) that y0 <= y <= y1, otherwise
        // we can overflow on the divide (which, needless to say, is very
        // bad).

            dl = UInt32x32To64(x1, dN) + llGamma;

        // y1 = dl / dM:

            y1 = UInt64Div32To32(dl, dM);

            if (yTop > (LONG) y1)
                goto Totally_Clipped;

            if (yBottom <= (LONG) y1)
            {
                y1 = yBottom;
                dl = UInt32x32To64(y1, dM) + llBeta;

            // x1 = dl / dN:

                x1 = UInt64Div32To32(dl, dN);
            }

        // At this point, we've taken care of calculating the intercepts
        // with the right and bottom edges.  Now we work on the left and
        // top edges:

            if (xLeft > (LONG) x0)
            {
                x0 = xLeft;
                dl = UInt32x32To64(x0, dN) + llGamma;

            // y0 = dl / dM;

                y0 = UInt64Div32To32(dl, dM);

                if (yBottom <= (LONG) y0)
                    goto Totally_Clipped;
            }

            if (yTop > (LONG) y0)
            {
                y0 = yTop;
                dl = UInt32x32To64(y0, dM) + llBeta;

            // x0 = dl / dN + 1;

                x0 = UInt64Div32To32(dl, dN) + 1;

                if (xRight <= (LONG) x0)
                    goto Totally_Clipped;
            }

            ASSERTDD(x0 <= x1, "Improper rectangle clip");
        }

/***********************************************************************\
* Done clipping.  Unflip if necessary.                                 *
\***********************************************************************/

        ptlStart.x = x + x0;
        ptlStart.y = y + y0;

        if (fl & FL_FLIP_D)
        {
            register LONG lTmp;
            SWAPL(ptlStart.x, ptlStart.y, lTmp);
        }


        if (fl & FL_FLIP_V)
        {
            ptlStart.y = -ptlStart.y;
        }

        cPels = x1 - x0 + 1;

/***********************************************************************\
* Style calculations.                                                   *
\***********************************************************************/

        if (fl & FL_STYLED)
        {
            STYLEPOS sp;

            spThis       = pls->spNext;
            pls->spNext += cStylePels;

            {
                if (pls->spNext >= pls->spTotal2)
                    pls->spNext %= pls->spTotal2;

                if (fl & FL_FLIP_H)
                    sp = pls->spNext - x0 + xStart;
                else
                    sp = spThis + x0 - xStart;

                ASSERTDD(fl & FL_STYLED, "Oops");

            // Normalize our target style position:

                if ((sp < 0) || (sp >= pls->spTotal2))
                {
                    sp %= pls->spTotal2;

                // The modulus of a negative number is not well-defined
                // in C -- if it's negative we'll adjust it so that it's
                // back in the range [0, spTotal2):

                    if (sp < 0)
                        sp += pls->spTotal2;
                }

            // Since we always draw the line left-to-right, but styling is
            // always done in the direction of the original line, we have
            // to figure out where we are in the style array for the left
            // edge of this line.

                if (fl & FL_FLIP_H)
                {
                // Line originally ran right-to-left:

                    sp = -sp;
                    if (sp < 0)
                        sp += pls->spTotal2;

                    pls->ulStyleMask = ~pls->ulStartMask;
                    pls->pspStart    = &pls->aspRtoL[0];
                    pls->pspEnd      = &pls->aspRtoL[pls->cStyle - 1];
                }
                else
                {
                // Line originally ran left-to-right:

                    pls->ulStyleMask = pls->ulStartMask;
                    pls->pspStart    = &pls->aspLtoR[0];
                    pls->pspEnd      = &pls->aspLtoR[pls->cStyle - 1];
                }

                if (sp >= pls->spTotal)
                {
                    sp -= pls->spTotal;
                    if (pls->cStyle & 1)
                        pls->ulStyleMask = ~pls->ulStyleMask;
                }

                pls->psp = pls->pspStart;
                while (sp >= *pls->psp)
                    sp -= *pls->psp++;

                ASSERTDD(pls->psp <= pls->pspEnd,
                        "Flew off into NeverNeverLand");

                pls->spRemaining = *pls->psp - sp;
                if ((pls->psp - pls->pspStart) & 1)
                    pls->ulStyleMask = ~pls->ulStyleMask;
            }
        }

        plStrip    = &strip.alStrips[0];
        plStripEnd = &strip.alStrips[STRIP_MAX];    // Is exclusive
        cStripsInNextRun   = 0x7fffffff;

        strip.ptlStart = ptlStart;

    // Now, run the DDA starting at (ptlStart.x, ptlStart.y)!

        strip.flFlips = fl;
        pfn           = apfn[(fl & FL_STRIP_MASK) >> FL_STRIP_SHIFT];

    // Now calculate the DDA variables needed to figure out how many pixels
    // go in the very first strip:

        {
            register LONG  i;
            register ULONG dI;
            register ULONG dR;
                     ULONG r;

            if (dN == 0)
                i = 0x7fffffff;
            else
            {
                dl = UInt32x32To64(y0 + 1, dM) + llBeta;

                ASSERTDD(dl >= 0, "Oops!");

            // i = (dl / dN) - x0 + 1;
            // r = (dl % dN);

                i = UInt64Div32To32(dl, dN);
                r = UInt64Mod32To32(dl, dN);
                i = i - x0 + 1;

                dI = dM / dN;
                dR = dM % dN;               // 0 <= dR < dN

                ASSERTDD(dI > 0, "Weird dI");
            }

            ASSERTDD(i > 0 && i <= 0x7fffffff, "Weird initial strip length");
            ASSERTDD(cPels > 0, "Zero pel line");

/***********************************************************************\
* Run the DDA!                                                          *
\***********************************************************************/

            while(TRUE)
            {
                cPels -= i;
                if (cPels <= 0)
                    break;

                *plStrip++ = i;

                if (plStrip == plStripEnd)
                {
                    strip.cStrips = (LONG)(plStrip - &strip.alStrips[0]);
                    (*pfn)(ppdev, &strip, pls);
                    plStrip = &strip.alStrips[0];
                }

                i = dI;
                r += dR;

                if (r >= dN)
                {
                    r -= dN;
                    i++;
                }
            }

            *plStrip++ = cPels + i;

            strip.cStrips = (LONG)(plStrip - &strip.alStrips[0]);
            (*pfn)(ppdev, &strip, pls);


        }

    Next_Line:

        if (fl & FL_COMPLEX_CLIP)
        {
            cptfx--;
            if (cptfx != 0)
                goto Continue_Complex_Clipping;

            break;
        }
        else
        {
            pptfxFirst = pptfxBuf;
            pptfxBuf++;
        }

    } while (pptfxBuf < pptfxBufEnd);

    return(TRUE);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\cirrus\disp\misc.c ===
/******************************Module*Header*******************************\
* Module Name: misc.c
*
* Miscellaneous common routines.
*
* Copyright (c) 1992-1995 Microsoft Corporation
*
\**************************************************************************/

#include "precomp.h"

/******************************Public*Table********************************\
* BYTE gaulHwMixFromRop2[]
*
* Table to convert from a Source and Destination Rop2 to the hardware's
* mix.
\**************************************************************************/

BYTE gajHwMixFromRop2[] = {
    HW_0,                           // 00 -- 0      BLACKNESS
    HW_DPon,                        // 11 -- DSon   NOTSRCERASE
    HW_DPna,                        // 22 -- DSna
    HW_Pn,                          // 33 -- Sn     NOSRCCOPY
    HW_PDna,                        // 44 -- SDna   SRCERASE
    HW_Dn,                          // 55 -- Dn     DSTINVERT
    HW_DPx,                         // 66 -- DSx    SRCINVERT
    HW_DPan,                        // 77 -- DSan
    HW_DPa,                         // 88 -- DSa    SRCAND
    HW_DPxn,                        // 99 -- DSxn
    HW_D,                           // AA -- D
    HW_DPno,                        // BB -- DSno   MERGEPAINT
    HW_P,                           // CC -- S      SRCCOPY
    HW_PDno,                        // DD -- SDno
    HW_DPo,                         // EE -- DSo    SRCPAINT
    HW_1                            // FF -- 1      WHITENESS
};


/******************************Public*Table********************************\
* BYTE gajHwMixFromMix[]
*
* Table to convert from a GDI mix value to the hardware's mix.
*
* Ordered so that the mix may be calculated from gajHwMixFromMix[mix & 0xf]
* or gajHwMixFromMix[mix & 0xff].
\**************************************************************************/

BYTE gajHwMixFromMix[] = {
    HW_1,                           // 0  -- 1
    HW_0,                           // 1  -- 0
    HW_DPon,                        // 2  -- DPon
    HW_DPna,                        // 3  -- DPna
    HW_Pn,                          // 4  -- Pn
    HW_PDna,                        // 5  -- PDna
    HW_Dn,                          // 6  -- Dn
    HW_DPx,                         // 7  -- DPx
    HW_DPan,                        // 8  -- DPan
    HW_DPa,                         // 9  -- DPa
    HW_DPxn,                        // 10 -- DPxn
    HW_D,                           // 11 -- D
    HW_DPno,                        // 12 -- DPno
    HW_P,                           // 13 -- P
    HW_PDno,                        // 14 -- PDno
    HW_DPo,                         // 15 -- DPo
    HW_1                            // 16 -- 1
};

#if 1 // D5480
/******************************Public*Table********************************\
* DWORD gaulHwPackedMixFromRop2_Packed[]
*
* Table to convert from a Source and Destination Rop2 to the hardware's
* mix in DWORD packed mode.
\**************************************************************************/

DWORD gajHwPackedMixFromRop2[] = {
    HW_PACKED_0,                           // 00 -- 0      BLACKNESS
    HW_PACKED_DPon,                        // 11 -- DSon   NOTSRCERASE
    HW_PACKED_DPna,                        // 22 -- DSna
    HW_PACKED_Pn,                          // 33 -- Sn     NOSRCCOPY
    HW_PACKED_PDna,                        // 44 -- SDna   SRCERASE
    HW_PACKED_Dn,                          // 55 -- Dn     DSTINVERT
    HW_PACKED_DPx,                         // 66 -- DSx    SRCINVERT
    HW_PACKED_DPan,                        // 77 -- DSan
    HW_PACKED_DPa,                         // 88 -- DSa    SRCAND
    HW_PACKED_DPxn,                        // 99 -- DSxn
    HW_PACKED_D,                           // AA -- D
    HW_PACKED_DPno,                        // BB -- DSno   MERGEPAINT
    HW_PACKED_P,                           // CC -- S      SRCCOPY
    HW_PACKED_PDno,                        // DD -- SDno
    HW_PACKED_DPo,                         // EE -- DSo    SRCPAINT
    HW_PACKED_1                            // FF -- 1      WHITENESS
};

/******************************Public*Table********************************\
* DWORD gajHwPackedMixFromMix[]
*
* Table to convert from a GDI mix value to the hardware's mix.
*
* Ordered so that the mix may be calculated from 
* gajHwPackedMixFromMix[mix & 0xf] or gajHwPackedMixFromMix[mix & 0xff].
\**************************************************************************/

DWORD gajHwPackedMixFromMix[] = {
    HW_PACKED_1,                           // 0  -- 1
    HW_PACKED_0,                           // 1  -- 0
    HW_PACKED_DPon,                        // 2  -- DPon
    HW_PACKED_DPna,                        // 3  -- DPna
    HW_PACKED_Pn,                          // 4  -- Pn
    HW_PACKED_PDna,                        // 5  -- PDna
    HW_PACKED_Dn,                          // 6  -- Dn
    HW_PACKED_DPx,                         // 7  -- DPx
    HW_PACKED_DPan,                        // 8  -- DPan
    HW_PACKED_DPa,                         // 9  -- DPa
    HW_PACKED_DPxn,                        // 10 -- DPxn
    HW_PACKED_D,                           // 11 -- D
    HW_PACKED_DPno,                        // 12 -- DPno
    HW_PACKED_P,                           // 13 -- P
    HW_PACKED_PDno,                        // 14 -- PDno
    HW_PACKED_DPo,                         // 15 -- DPo
    HW_PACKED_1                            // 16 -- 1
};

#endif // endif D5480

/******************************Public*Data*********************************\
* MIX translation table
*
* Translates a mix 1-16, into an old style Rop 0-255.
*
\**************************************************************************/

BYTE gaRop3FromMix[] =
{
    R3_WHITENESS,   // R2_WHITE       - Allow rop = gaRop3FromMix[mix & 0x0f]
    R3_BLACKNESS,   // R2_BLACK
    0x05,           // R2_NOTMERGEPEN
    0x0A,           // R2_MASKNOTPEN
    0x0F,           // R2_NOTCOPYPEN
    0x50,           // R2_MASKPENNOT
    R3_DSTINVERT,   // R2_NOT
    R3_PATINVERT,   // R2_XORPEN
    0x5F,           // R2_NOTMASKPEN
    0xA0,           // R2_MASKPEN
    0xA5,           // R2_NOTXORPEN
    R3_NOP,         // R2_NOP
    0xAF,           // R2_MERGENOTPEN
    R3_PATCOPY,     // R2_COPYPEN
    0xF5,           // R2_MERGEPENNOT
    0xFA,           // R2_MERGEPEN
    R3_WHITENESS    // R2_WHITE       - Allow rop = gaRop3FromMix[mix & 0xff]
};

/******************************Public*Data*********************************\
* Edge masks for clipping DWORDS
*
* Masks off unwanted bits.
*
\**************************************************************************/

ULONG   gaulLeftClipMask[] =
{
    0xFFFFFFFF, 0xFFFFFF7F, 0xFFFFFF3F, 0xFFFFFF1F,
    0xFFFFFF0F, 0xFFFFFF07, 0xFFFFFF03, 0xFFFFFF01,
    0xFFFFFF00, 0xFFFF7F00, 0xFFFF3F00, 0xFFFF1F00,
    0xFFFF0F00, 0xFFFF0700, 0xFFFF0300, 0xFFFF0100,
    0xFFFF0000, 0xFF7F0000, 0xFF3F0000, 0xFF1F0000,
    0xFF0F0000, 0xFF070000, 0xFF030000, 0xFF010000,
    0xFF000000, 0x7F000000, 0x3F000000, 0x1F000000,
    0x0F000000, 0x07000000, 0x03000000, 0x01000000
};

ULONG   gaulRightClipMask[] =
{
    0xFFFFFFFF, 0xFEFFFFFF, 0xFCFFFFFF, 0xF8FFFFFF,
    0xF0FFFFFF, 0xE0FFFFFF, 0xC0FFFFFF, 0x80FFFFFF,
    0x00FFFFFF, 0x00FEFFFF, 0x00FCFFFF, 0x00F8FFFF,
    0x00F0FFFF, 0x00E0FFFF, 0x00C0FFFF, 0x0080FFFF,
    0x0000FFFF, 0x0000FEFF, 0x0000FCFF, 0x0000F8FF,
    0x0000F0FF, 0x0000E0FF, 0x0000C0FF, 0x000080FF,
    0x000000FF, 0x000000FE, 0x000000FC, 0x000000F8,
    0x000000F0, 0x000000E0, 0x000000C0, 0x00000080
};

/******************************Public*Routine******************************\
* BOOL bIntersect
*
* If 'prcl1' and 'prcl2' intersect, has a return value of TRUE and returns
* the intersection in 'prclResult'.  If they don't intersect, has a return
* value of FALSE, and 'prclResult' is undefined.
*
\**************************************************************************/

BOOL bIntersect(
RECTL*  prcl1,
RECTL*  prcl2,
RECTL*  prclResult)
{
    prclResult->left  = max(prcl1->left,  prcl2->left);
    prclResult->right = min(prcl1->right, prcl2->right);

    if (prclResult->left < prclResult->right)
    {
        prclResult->top    = max(prcl1->top,    prcl2->top);
        prclResult->bottom = min(prcl1->bottom, prcl2->bottom);

        if (prclResult->top < prclResult->bottom)
        {
            return(TRUE);
        }
    }

    return(FALSE);
}

/******************************Public*Routine******************************\
* LONG cIntersect
*
* This routine takes a list of rectangles from 'prclIn' and clips them
* in-place to the rectangle 'prclClip'.  The input rectangles don't
* have to intersect 'prclClip'; the return value will reflect the
* number of input rectangles that did intersect, and the intersecting
* rectangles will be densely packed.
*
\**************************************************************************/

LONG cIntersect(
RECTL*  prclClip,
RECTL*  prclIn,         // List of rectangles
LONG    c)              // Can be zero
{
    LONG    cIntersections;
    RECTL*  prclOut;

    cIntersections = 0;
    prclOut        = prclIn;

    for (; c != 0; prclIn++, c--)
    {
        prclOut->left  = max(prclIn->left,  prclClip->left);
        prclOut->right = min(prclIn->right, prclClip->right);

        if (prclOut->left < prclOut->right)
        {
            prclOut->top    = max(prclIn->top,    prclClip->top);
            prclOut->bottom = min(prclIn->bottom, prclClip->bottom);

            if (prclOut->top < prclOut->bottom)
            {
                prclOut++;
                cIntersections++;
            }
        }
    }

    return(cIntersections);
}

/******************************Public*Routine******************************\
* VOID vImageTransfer
*
* This routine transfers a bitmap image via the data transfer
* area in video memory.
*
\**************************************************************************/

VOID vImageTransfer(        // Type FNIMAGETRANSFER
PDEV*   ppdev,
BYTE*   pjSrc,              // Source pointer
LONG    lDelta,             // Delta from start of scan to start of next
LONG    cjSrc,              // Number of bytes to be output on every scan
LONG    cScans)             // Number of scans
{
    ULONG*  pulXfer = ppdev->pulXfer;
    LONG    cdSrc;
    LONG    cjEnd;
    ULONG   d;

    ASSERTDD(cScans > 0, "Can't handle non-positive count of scans");

    cdSrc = cjSrc >> 2;
    cjEnd = cdSrc << 2;

    switch (cjSrc & 3)
    {
    case 3:
        do {
            if (cdSrc > 0)
            {
                TRANSFER_DWORD(ppdev, pulXfer, pjSrc, cdSrc);
            }

            d = (ULONG) (*(pjSrc + cjEnd))          |
                        (*(pjSrc + cjEnd + 1) << 8) |
                        (*(pjSrc + cjEnd + 2) << 16);
            TRANSFER_DWORD(ppdev, pulXfer, &d, 1);
            pjSrc += lDelta;

        } while (--cScans != 0);
        break;

    case 2:
        do {
            if (cdSrc > 0)
            {
                TRANSFER_DWORD(ppdev, pulXfer, pjSrc, cdSrc);
            }

            d = (ULONG) (*(pjSrc + cjEnd))          |
                        (*(pjSrc + cjEnd + 1) << 8);
            TRANSFER_DWORD(ppdev, pulXfer, &d, 1);
            pjSrc += lDelta;

        } while (--cScans != 0);
        break;

    case 1:
        do {
            if (cdSrc > 0)
            {
                TRANSFER_DWORD(ppdev, pulXfer, pjSrc, cdSrc);
            }

            d = (ULONG) (*(pjSrc + cjEnd));
            TRANSFER_DWORD(ppdev, pulXfer, &d, 1);
            pjSrc += lDelta;

        } while (--cScans != 0);
        break;

    case 0:
        do {
            TRANSFER_DWORD(ppdev, pulXfer, pjSrc, cdSrc);
            pjSrc += lDelta;

        } while (--cScans != 0);
        break;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\cirrus\disp\overlay.h ===
/******************************************************************************\
*
* Copyright (c) 1996-1997  Microsoft Corporation.
* Copyright (c) 1996-1997  Cirrus Logic, Inc.
*
* Module Name:
*
*    O    V    E    R    L    A    Y  .  H
*
* This module contains common function prototypes and defines needed for
* overlay support
*
* Revision History:
*
* tao1    10-22-96  Added direct draw support for CL-GD7555
* myf1    03-12-97  Change new bandwidth check for CL-GD755X
* myf2    03-31-97  Added direct draw support VPE
* chu01   03-26-97  Bandwidth equation for the CL-GD5480
* chu02   04-02-97  More overlay capabilities
*
\******************************************************************************/


/* FOURCC definitions ------------------------------------*/

#define FOURCC_YUY2         '2YUY'              // YUY2
#define FOURCC_YUV422       'YVYU'              // UYVY
#define FOURCC_PACKJR       'RJLC'              // CLJR
#define FOURCC_YUVPLANAR    'LPLC'              // CLPL
#define FOURCC_YUV420       'LPLC'              // CLPL


/* surface flags -----------------------------------------*/

#define OVERLAY_FLG_BEGIN_ACCESS      (DWORD)0x00000001
#define OVERLAY_FLG_ENABLED           (DWORD)0x00000002
#define OVERLAY_FLG_CONVERT_PACKJR    (DWORD)0x00000004
#define OVERLAY_FLG_MUST_RASTER       (DWORD)0x00000008
#define OVERLAY_FLG_TWO_MEG           (DWORD)0x00000010
#define OVERLAY_FLG_CHECK             (DWORD)0x00000020
#define OVERLAY_FLG_COLOR_KEY         (DWORD)0x00000040
#define OVERLAY_FLG_INTERPOLATE       (DWORD)0x00000080
#define OVERLAY_FLG_OVERLAY           (DWORD)0x00000100
#define OVERLAY_FLG_YUV422            (DWORD)0x00000200
#define OVERLAY_FLG_PACKJR            (DWORD)0x00000400
#define OVERLAY_FLG_USE_OFFSET        (DWORD)0x00000800
#define OVERLAY_FLG_YUVPLANAR         (DWORD)0x00001000
#define OVERLAY_FLG_SRC_COLOR_KEY     (DWORD)0x00002000
#define OVERLAY_FLG_DECIMATE          (DWORD)0x00004000
#define OVERLAY_FLG_CAPTURE           (DWORD)0x00008000           //myf2, VPE

// chu02
#define OVERLAY_FLG_DECIMATE4         (DWORD)0x00008000  
#define OVERLAY_FLG_YUY2              (DWORD)0x00010000
#define OVERLAY_FLG_VW_PRIMARY        (DWORD)0x00020000
#define OVERLAY_FLG_VW_SECONDARY      (DWORD)0x00040000  
#define OVERLAY_FLG_TWO_VIDEO         (DWORD)0x00200000  

/* display types (for portables) -------------------------*/

#define DTYPE_UNKNOWN                  (int)-1
#define DTYPE_640_COLOR_SINGLE_STN     0
#define DTYPE_640_MONO_DUAL_STN        1
#define DTYPE_640_COLOR_DUAL_STN       2
#define DTYPE_640_COLOR_SINGLE_TFT     3
#define DTYPE_640_COLOR_DUAL_STN_SHARP 4
#define DTYPE_800_COLOR_DUAL_STN       6
#define DTYPE_800_COLOR_SINGLE_TFT     7
#define DTYPE_CRT                      32767

//myf32 #define MIN_OLAY_WIDTH  4      //minium overlay window width

#define OVERLAY_OLAY_SHOW       0x100     //overlay is hidden iff bit not set
#define OVERLAY_OLAY_REENABLE   0x200     //overlay was fully clipped, need reenabling


VOID GetFormatInfo(PDEV* ppdev, LPDDPIXELFORMAT lpFormat, LPDWORD lpFourcc,
                   LPWORD lpBitCount);
VOID RegInitVideo(PDEV* ppdev, PDD_SURFACE_LOCAL lpSurface);
VOID DisableOverlay_544x(PDEV* ppdev);
VOID EnableOverlay_544x(PDEV* ppdev);
VOID RegMoveVideo(PDEV* ppdev, PDD_SURFACE_LOCAL lpSurface);
VOID CalculateStretchCode (LONG srcLength, LONG dstLength, LPBYTE code);
BYTE GetThresholdValue(VOID);
BOOL MustLineReplicate (PDEV* ppdev, PDD_SURFACE_LOCAL lpSurface, WORD wVideoDepth);
BOOL IsSufficientBandwidth(PDEV* ppdev, WORD wVideoDepth, LPRECTL lpSrc, LPRECTL lpDest, DWORD dwFlags);
LONG GetVCLK(PDEV* ppdev);
VOID EnableStartAddrDoubleBuffer(PDEV* ppdev);
DWORD GetCurrentVLine(PDEV* ppdev);
VOID ClearAltFIFOThreshold_544x(PDEV * ppdev);

// chu01
BOOL Is5480SufficientBandwidth(PDEV* ppdev, WORD wVideoDepth, LPRECTL lpSrc, LPRECTL lpDest, DWORD dwFlags);

// curs //tao1
typedef struct _BWREGS
{
     BYTE bSR2F;
     BYTE bSR32;
     BYTE bSR34;
     BYTE bCR42;

     BYTE bCR51;
     BYTE bCR5A;
     BYTE bCR5D;
     BYTE bCR5F;

}BWREGS, FAR *LPBWREGS;

BWREGS Regs;    //myf33

//myf33 for panning scrolling enable & DirectDraw overlay use
DWORD srcLeft_clip;
DWORD srcTop_clip;
BOOL  bLeft_clip;
BOOL  bTop_clip;
//myf33 end

VOID RegInit7555Video (PDEV *,PDD_SURFACE_LOCAL);
VOID RegMove7555Video (PDEV *,PDD_SURFACE_LOCAL);
VOID DisableVideoWindow    (PDEV * );
VOID EnableVideoWindow     (PDEV * );
VOID ClearAltFIFOThreshold (PDEV * );
BOOL Is7555SufficientBandwidth(PDEV* ppdev, WORD wVideoDepth, LPRECTL lpSrc, LPRECTL lpDest, DWORD dwFlags);
DWORD Get7555MCLK (PDEV *);
BOOL IsDSTN(PDEV * );
BOOL IsXGA (PDEV * );
VOID PanOverlay1_Init(PDEV *,PDD_SURFACE_LOCAL, LPRECTL, LPRECTL, LPRECTL,
        DWORD, WORD);           //myf33, DD init overlay data
VOID PanOverlay7555 (PDEV *,LONG ,LONG);        //myf33
BOOL PanOverlay1_7555(PDEV *,LPRECTL);          //myf33, PanOverlay7555 call

//      end curs         //tao1

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\cirrus\disp\panflags.h ===
//----------------------------Module-Header------------------------------
// Module Name: PANDEF.INC
//
// Panning flags definitions.
//
// Copyright (c) 1996  Cirrus Logic, Inc.
//
//-----------------------------------------------------------------------
// #ew1 02/22/96 created
//-----------------------------------------------------------------------

#ifdef _5446
#define MIN_OLAY_WIDTH  4     //minium overlay window width
#endif

#ifdef _5440
#define MIN_OLAY_WIDTH  12    //minium overlay window width
#endif

#define MAX_STRETCH_SIZE    1024  //in overlay.c


// wVDTflag's and sData.dwPanningFlag values

#define PAN_SUPPORTED   1         //panning is supported
#define PAN_ON          2         //enable panning, bit off = disable

#define OLAY_SHOW       0x100     //overlay is hidden iff bit not set
#define OLAY_REENABLE   0x200     //overlay was fully clipped, need reenabling
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\cirrus\disp\palette.c ===
/******************************************************************************\
*
* $Workfile:   palette.c  $
*
* Palette support.
*
* Copyright (c) 1992-1995 Microsoft Corporation
* Copyright (c) 1996 Cirrus Logic, Inc.
*
* $Log:   S:/projects/drivers/ntsrc/display/palette.c_v  $
 *
 *    Rev 1.2   18 Dec 1996 13:44:10   PLCHU
 *
*
*    Rev 1.1   Oct 10 1996 15:38:38   unknown
*
*
*    Rev 1.1   12 Aug 1996 16:54:26   frido
*
* Added NT 3.5x/4.0 auto detection.
*
*    chu01  12-16-96   Enable color correction
*    myf29  02-12-97   Support Gamma Correction for 755x
*
\******************************************************************************/

#include "precomp.h"

//
// chu01
//
#ifdef GAMMACORRECT

static BOOL bGammaInit = FALSE ;

BOOL bInitGlobalDefPaletteTable = FALSE ;

//
// gamma facter for All, Blue, Green, Red
// contrast facter for All, Blue, Green, Red
//
extern PGAMMA_VALUE    GammaFactor    ;
extern PCONTRAST_VALUE ContrastFactor ;

#endif // GAMMACORRECT

// Global Table defining the 20 Window default colours.  For 256 colour
// palettes the first 10 must be put at the beginning of the palette
// and the last 10 at the end of the palette.

PALETTEENTRY gapalBase[20] =
{
    { 0,   0,   0,   0 },       // 0
    { 0x80,0,   0,   0 },       // 1
    { 0,   0x80,0,   0 },       // 2
    { 0x80,0x80,0,   0 },       // 3
    { 0,   0,   0x80,0 },       // 4
    { 0x80,0,   0x80,0 },       // 5
    { 0,   0x80,0x80,0 },       // 6
    { 0xC0,0xC0,0xC0,0 },       // 7
    { 192, 220, 192, 0 },       // 8
    { 166, 202, 240, 0 },       // 9
    { 255, 251, 240, 0 },       // 10
    { 160, 160, 164, 0 },       // 11
    { 0x80,0x80,0x80,0 },       // 12
    { 0xFF,0,   0   ,0 },       // 13
    { 0,   0xFF,0   ,0 },       // 14
    { 0xFF,0xFF,0   ,0 },       // 15
    { 0   ,0,   0xFF,0 },       // 16
    { 0xFF,0,   0xFF,0 },       // 17
    { 0,   0xFF,0xFF,0 },       // 18
    { 0xFF,0xFF,0xFF,0 },       // 19
};

/******************************Public*Routine******************************\
* BOOL bInitializePalette
*
* Initializes default palette for PDEV.
*
\**************************************************************************/

BOOL bInitializePalette(
PDEV*    ppdev,
DEVINFO* pdi)
{
    PALETTEENTRY*   ppal;
    PALETTEENTRY*   ppalTmp;
    ULONG           ulLoop;
    BYTE            jRed;
    BYTE            jGre;
    BYTE            jBlu;
    HPALETTE        hpal;

//
// chu01
//
#ifdef GAMMACORRECT

    PALETTEENTRY*   pGpal;
    PALETTEENTRY*   ppalFrom;
    PALETTEENTRY*   ppalTo;
    PALETTEENTRY*   ppalEnd;
    int             i;

#endif // GAMMACORRECT

    DISPDBG((2, "bInitializePalette"));

//
// chu01 : Sorry VideoPort_xxxx functions do not work here.
//
#ifdef GAMMACORRECT
    if ((ppdev->iBitmapFormat == BMF_8BPP) ||
        (ppdev->ulChipID == 0x40) ||    //myf29
        (ppdev->ulChipID == 0x4C) ||    //myf29
        (ppdev->ulChipID == 0xBC))
#else
    if (ppdev->iBitmapFormat == BMF_8BPP)
#endif // GAMMACORRECT
    {
        // Allocate our palette:

        ppal = (PALETTEENTRY*) ALLOC(sizeof(PALETTEENTRY) * 256);
        if (ppal == NULL)
            goto ReturnFalse;

        ppdev->pPal = ppal;

//
// chu01
//
#ifdef GAMMACORRECT
        pGpal = (PALETTEENTRY*) ALLOC(sizeof(PALETTEENTRY) * 256) ;
        if (pGpal == NULL)
            goto ReturnFalse ;
        ppdev->pCurrentPalette = pGpal ;
#endif // GAMMACORRECT

        // Generate 256 (8*4*4) RGB combinations to fill the palette

        jRed = 0;
        jGre = 0;
        jBlu = 0;

        ppalTmp = ppal;

//
// chu01
//
#ifdef GAMMACORRECT
        if ((ppdev->ulChipID == 0xBC) ||
            (ppdev->ulChipID == 0x40) ||    //myf29
            (ppdev->ulChipID == 0x4C))      //myf29
        {
            if ((ppdev->iBitmapFormat == BMF_16BPP) ||
                (ppdev->iBitmapFormat == BMF_24BPP))
            {
                i = 0 ;
                for (ulLoop = 256; ulLoop != 0; ulLoop--)
                {
                    ppalTmp->peRed   = i ;
                    ppalTmp->peGreen = i ;
                    ppalTmp->peBlue  = i ;
                    ppalTmp->peFlags = 0 ;
                    ppalTmp++;
                    i++ ;
                }
                goto bInitPal ;
            }
        }
#endif // GAMMACORRECT


        for (ulLoop = 256; ulLoop != 0; ulLoop--)
        {
            ppalTmp->peRed   = jRed;
            ppalTmp->peGreen = jGre;
            ppalTmp->peBlue  = jBlu;
            ppalTmp->peFlags = 0;

            ppalTmp++;

            if (!(jRed += 32))
                if (!(jGre += 32))
                    jBlu += 64;
        }

        // Fill in Windows reserved colours from the WIN 3.0 DDK
        // The Window Manager reserved the first and last 10 colours for
        // painting windows borders and for non-palette managed applications.

        for (ulLoop = 0; ulLoop < 10; ulLoop++)
        {
            // First 10

            ppal[ulLoop]       = gapalBase[ulLoop];

            // Last 10

            ppal[246 + ulLoop] = gapalBase[ulLoop+10];
        }


//
// chu01
//
#ifdef GAMMACORRECT

bInitPal:

        if (!bInitGlobalDefPaletteTable)
        {
            ppalFrom = (PALETTEENTRY*) ppal   ;
            ppalTo   = ppdev->pCurrentPalette ;
            ppalEnd  = &ppalTo[256]           ;

            for (; ppalTo < ppalEnd; ppalFrom++, ppalTo++)
            {
                ppalTo->peRed   = ppalFrom->peRed   ;
                ppalTo->peGreen = ppalFrom->peGreen ;
                ppalTo->peBlue  = ppalFrom->peBlue  ;
                ppalTo->peFlags = 0                 ;
            }
            bInitGlobalDefPaletteTable = TRUE ;
        }

#endif // GAMMACORRECT


        // Create handle for palette.

#ifndef GAMMACORRECT
        hpal = EngCreatePalette(PAL_INDEXED, 256, (ULONG*) ppal, 0, 0, 0);
#else
        if (ppdev->iBitmapFormat == BMF_8BPP)
            hpal = EngCreatePalette(PAL_INDEXED, 256, (ULONG*) ppal, 0, 0, 0);
        else
            hpal = EngCreatePalette(PAL_BITFIELDS, 0, NULL,
                                    ppdev->flRed, ppdev->flGreen, ppdev->flBlue);
#endif // !GAMMACORRECT

    }
    else
    {
        ASSERTDD((ppdev->iBitmapFormat == BMF_16BPP) ||
                 (ppdev->iBitmapFormat == BMF_24BPP) ||
                 (ppdev->iBitmapFormat == BMF_32BPP),
                 "This case handles only 16, 24 or 32bpp");

        hpal = EngCreatePalette(PAL_BITFIELDS, 0, NULL,
                                ppdev->flRed, ppdev->flGreen, ppdev->flBlue);
    }

    ppdev->hpalDefault = hpal;
    pdi->hpalDefault   = hpal;

    if (hpal == 0)
        goto ReturnFalse;

    return(TRUE);

ReturnFalse:

    DISPDBG((0, "Failed bInitializePalette"));
    return(FALSE);
}

/******************************Public*Routine******************************\
* VOID vUninitializePalette
*
* Frees resources allocated by bInitializePalette.
*
* Note: In an error case, this may be called before bInitializePalette.
*
\**************************************************************************/

VOID vUninitializePalette(PDEV* ppdev)
{
    // Delete the default palette if we created one:

    if (ppdev->hpalDefault != 0)
        EngDeletePalette(ppdev->hpalDefault);

    if (ppdev->pPal != (PALETTEENTRY*) NULL)
        FREE(ppdev->pPal);
}

/******************************Public*Routine******************************\
* BOOL bEnablePalette
*
* Initialize the hardware's 8bpp palette registers.
*
\**************************************************************************/

BOOL bEnablePalette(PDEV* ppdev)
{
    BYTE        ajClutSpace[MAX_CLUT_SIZE];
    PVIDEO_CLUT pScreenClut;
    ULONG       ulReturnedDataLength;
    PALETTEENTRY* ppalFrom;
    PALETTEENTRY* ppalTo;
    PALETTEENTRY* ppalEnd;

//
// chu01
//
#ifdef GAMMACORRECT
    PALETTEENTRY* ppalSrc;
    PALETTEENTRY* ppalDest;
    PALETTEENTRY* ppalLength;
    BOOL status;        //myf29
#endif // GAMMACORRECT

    DISPDBG((2, "bEnablePalette"));
//
// chu01
//
#ifdef GAMMACORRECT
    if ((ppdev->iBitmapFormat == BMF_8BPP) ||
        (ppdev->ulChipID == 0x40) ||    //myf29
        (ppdev->ulChipID == 0x4C) ||    //myf29
        (ppdev->ulChipID == 0xBC))
#else
    if (ppdev->iBitmapFormat == BMF_8BPP)
#endif // GAMMACORRECT
    {
        // Fill in pScreenClut header info:

        pScreenClut             = (PVIDEO_CLUT) ajClutSpace;
        pScreenClut->NumEntries = 256;
        pScreenClut->FirstEntry = 0;

        // Copy Colors in.

        ppalFrom = ppdev->pPal;
        ppalTo   = (PALETTEENTRY*) pScreenClut->LookupTable;
        ppalEnd  = &ppalTo[256];

        for (; ppalTo < ppalEnd; ppalFrom++, ppalTo++)
        {
//
// chu01
//
#ifndef GAMMACORRECT
           ppalTo->peRed   = ppalFrom->peRed   >> 2 ;
           ppalTo->peGreen = ppalFrom->peGreen >> 2 ;
           ppalTo->peBlue  = ppalFrom->peBlue  >> 2 ;
           ppalTo->peFlags = 0 ;
#else
           ppalTo->peRed   = ppalFrom->peRed   ;
           ppalTo->peGreen = ppalFrom->peGreen ;
           ppalTo->peBlue  = ppalFrom->peBlue  ;
           ppalTo->peFlags = 0 ;
#endif // !GAMMACORRECT
        }

//
// chu01
//
#ifdef GAMMACORRECT
        if (!bGammaInit)
        {
            if (ppdev->flCaps & CAPS_GAMMA_CORRECT)
            {
                //
                // Get Gamma factor from registry
                //
                if (!IOCONTROL(ppdev->hDriver,
                               IOCTL_CIRRUS_GET_GAMMA_FACTOR,
                               NULL, ,
                               0,
                               &GammaFactor,
                               sizeof(GammaFactor),
                               &ulReturnedDataLength))
                {
                    DISPDBG((0, "Failed to access Gamma factor from registry"));
                }
                else
                {
                    DISPDBG((0, "G Gamma = %lx", GammaFactor)) ;
                }

                //
                // Get Contrast factor from registry
                //
                if (!IOCONTROL(ppdev->hDriver,
                               IOCTL_CIRRUS_GET_CONTRAST_FACTOR,
                               NULL, ,
                               0,
                               &ContrastFactor,
                               sizeof(ContrastFactor),
                               &ulReturnedDataLength))
                {
                    DISPDBG((0, "Failed to access Contrast factor from registry"));
                }
                else
                {
                    DISPDBG((0, "G Contrast = %lx", ContrastFactor)) ;
                }
            }
            else
            {
                GammaFactor    = 0x7f7f7f7f ;
                ContrastFactor = 0x80 ;
                DISPDBG((0, "G Gamma = %lx", GammaFactor)) ;
                DISPDBG((0, "G Contrast = %lx", ContrastFactor)) ;
            }

            bGammaInit = TRUE ;
        }

        //
        // Save the new palette values
        //
        ppalFrom = (PALETTEENTRY*) pScreenClut->LookupTable;

        ppalTo   = ppdev->pCurrentPalette;
        ppalEnd  = &ppalTo[256];
        for (; ppalTo < ppalEnd; ppalFrom++, ppalTo++)
        {
            ppalTo->peRed   = ppalFrom->peRed   ;
            ppalTo->peGreen = ppalFrom->peGreen ;
            ppalTo->peBlue  = ppalFrom->peBlue  ;
            ppalTo->peFlags = 0 ;
        }

//myf29 begin
        if (ppdev->ulChipID == 0xBC)
            status = bEnableGammaCorrect(ppdev) ;
        else if ((ppdev->ulChipID == 0x40) || (ppdev->ulChipID ==0x4C))
            status = bEnableGamma755x(ppdev) ;
//myf29 end

        CalculateGamma( ppdev, pScreenClut, 256 ) ;
#endif // GAMMACORRECT

        // Set palette registers:

        if (!IOCONTROL(ppdev->hDriver,
                       IOCTL_VIDEO_SET_COLOR_REGISTERS,
                       pScreenClut,
                       MAX_CLUT_SIZE,
                       NULL,
                       0,
                       &ulReturnedDataLength))
        {
            DISPDBG((0, "Failed bEnablePalette"));
            return(FALSE);
        }
    }

    DISPDBG((5, "Passed bEnablePalette"));

    return(TRUE);
}

/******************************Public*Routine******************************\
* VOID vDisablePalette
*
* Undoes anything done in bEnablePalette.
*
\**************************************************************************/

VOID vDisablePalette(
PDEV*   ppdev)
{
    // Nothin' to do
}

/******************************Public*Routine******************************\
* VOID vAssertModePalette
*
* Sets/resets the palette in preparation for full-screen/graphics mode.
*
\**************************************************************************/

VOID vAssertModePalette(
PDEV*   ppdev,
BOOL    bEnable)
{
    // USER immediately calls DrvSetPalette after switching out of
    // full-screen, so we don't have to worry about resetting the
    // palette here.
}

/******************************Public*Routine******************************\
* BOOL DrvSetPalette
*
* DDI entry point for manipulating the palette.
*
\**************************************************************************/

BOOL DrvSetPalette(
DHPDEV  dhpdev,
PALOBJ* ppalo,
FLONG   fl,
ULONG   iStart,
ULONG   cColors)
{
    BYTE          ajClutSpace[MAX_CLUT_SIZE];
    PVIDEO_CLUT   pScreenClut;
    PALETTEENTRY* ppal;
    PALETTEENTRY* ppalFrom;
    PALETTEENTRY* ppalTo;
    PALETTEENTRY* ppalEnd;
    BOOL status;                //myf29

    PDEV*         ppdev;

    UNREFERENCED_PARAMETER(fl);

    DISPDBG((2, "---- DrvSetPalette"));

    // Fill in pScreenClut header info:

    pScreenClut             = (PVIDEO_CLUT) ajClutSpace;
    pScreenClut->NumEntries = (USHORT) cColors;
    pScreenClut->FirstEntry = (USHORT) iStart;

    ppal = (PPALETTEENTRY) (pScreenClut->LookupTable);

    if (cColors != PALOBJ_cGetColors(ppalo, iStart, cColors, (ULONG*) ppal))
    {
        DISPDBG((0, "DrvSetPalette failed PALOBJ_cGetColors\n"));
        goto ReturnFalse;
    }

    // Set the high reserved byte in each palette entry to 0.

//
// chu01
//
#ifndef GAMMACORRECT
    for (ppalEnd = &ppal[cColors]; ppal < ppalEnd; ppal++)
    {
        ppal->peRed   >>= 2;
        ppal->peGreen >>= 2;
        ppal->peBlue  >>= 2;
        ppal->peFlags = 0;
    }
#endif // !GAMMACORRECT

    // Set palette registers

    ppdev = (PDEV*) dhpdev;

//
// chu01
//
#ifdef GAMMACORRECT
    //
    // Save the new palette values
    //

    ppalFrom = (PALETTEENTRY*) pScreenClut->LookupTable;
    ppalTo   = ppdev->pCurrentPalette;
    ppalEnd  = &ppalTo[256];
    for (; ppalTo < ppalEnd; ppalFrom++, ppalTo++)
    {
        ppalTo->peRed   = ppalFrom->peRed   ;
        ppalTo->peGreen = ppalFrom->peGreen ;
        ppalTo->peBlue  = ppalFrom->peBlue  ;
        ppalTo->peFlags = 0 ;
    }

//myf29 begin
    if (ppdev->ulChipID == 0xBC)
        status = bEnableGammaCorrect(ppdev) ;
    else if ((ppdev->ulChipID == 0x40) || (ppdev->ulChipID ==0x4C))
        status = bEnableGamma755x(ppdev) ;
//myf29 end

    CalculateGamma( ppdev, pScreenClut, 256 ) ;
#endif // GAMMACORRECT

    if (!IOCONTROL(ppdev->hDriver,
                   IOCTL_VIDEO_SET_COLOR_REGISTERS,
                   pScreenClut,
                   MAX_CLUT_SIZE,
                   NULL,
                   0,
                   &cColors))
    {
        DISPDBG((0, "DrvSetPalette failed EngDeviceIoControl\n"));
        goto ReturnFalse;
    }

    return(TRUE);

ReturnFalse:

    return(FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\cirrus\disp\pointer.c ===
/******************************************************************************\
*
* $Workfile:   pointer.c  $
*
* Contains the pointer management functions.
*
* Copyright (c) 1992-1995 Microsoft Corporation
* Copyright (c) 1996 Cirrus Logic, Inc.
*
* $Log:   S:/projects/drivers/ntsrc/display/pointer.c_v  $
 *
 *    Rev 1.5   07 Apr 1997 11:38:16   PLCHU
 *
 *
 *    Rev 1.4   Apr 03 1997 15:39:00   unknown
 *
 *
 *    Rev 1.3   28 Mar 1997 16:09:20   PLCHU
 *
*
*    Rev 1.2   12 Aug 1996 16:54:36   frido
* Added NT 3.5x/4.0 auto detection.
* Removed unaccessed local variables.
*
*    Rev 1.1   08 Aug 1996 12:54:54   frido
*       bank#1  Removed banking in memory mapped I/O which is always linear.
*    bank#1    Removed banking in memory mapped I/O which is always linear.
*
* myf0 : 08-19-96  added 85hz supported
* myf1 : 08-20-96  supported panning scrolling
* myf2 : 08-20-96 : fixed hardware save/restore state bug for matterhorn
* myf3 : 09-01-96 : Added IOCTL_CIRRUS_PRIVATE_BIOS_CALL for TV supported
* myf4 : 09-01-96 : patch Viking BIOS bug, PDR #4287, begin
* myf5 : 09-01-96 : Fixed PDR #4365 keep all default refresh rate
* myf6 : 09-17-96 : Merged Desktop SRC1001 & MINI102
* myf7 : 09-19-96 : Fixed exclude 60Hz refresh rate selected
* myf8 :*09-21-96*: May be need change CheckandUpdateDDC2BMonitor --keystring[]
* myf9 : 09-21-96 : 8x6 panel in 6x4x256 mode, cursor can't move to bottom scrn
* ms0809:09-25-96 : fixed dstn panel icon corrupted
* ms923 :09-25-96 : merge MS-923 Disp.zip code
* myf10 :09-26-96 : Fixed DSTN reserved half-frame buffer bug.
* myf11 :09-26-96 : Fixed 755x CE chip HW bug, access ramdac before disable HW
*                   icons and cursor
* myf12 :10-01-96 : Supported Hot Key switch display
* myf13 :10-02-96 : Fixed Panning scrolling (1280x1024x256) bug y < ppdev->miny
* myf14 :10-15-96 : Fixed PDR#6917, 6x4 panel can't panning scrolling for 754x
* myf15 :10-16-96 : Fixed disable memory mapped IO for 754x, 755x
* myf16 :10-22-96 : Fixed PDR #6933,panel type set different demo board setting
* tao1 : 10-21-96 : Added 7555 flag for Direct Draw support.
* smith :10-22-96 : Disable Timer event, because sometimes creat PAGE_FAULT or
*                   IRQ level can't handle
* myf17 :11-04-96 : Added special escape code must be use 11/5/96 later NTCTRL,
*                   and added Matterhorn LF Device ID==0x4C
* myf18 :11-04-96 : Fixed PDR #7075,
* myf19 :11-06-96 : Fixed Vinking can't work problem, because DEVICEID = 0x30
*                   is different from data book (CR27=0x2C)
* pat04: 12-20-96 : Supported NT3.51 software cursor with panning scrolling
* pat07:          : Take care of disappearing hardware cursor during modeset
* myf31 :02-24-97 : Fixed enable HW Video, panning scrolling enable,screen move
*                   video window have follow moving
* myf33 :03-06-97 : Fixed switch S/W cursor, have 2 cursor shape, PDR#8781,8804
* myf32 :03-13-97 : Fixed panning screen moving strength problem, PDR#8873
* pat08 :04-01-97 : Corrected SWcursor bugs due to code-merge. See also
*                   PDR #8949 & #8910
*
\******************************************************************************/

#include "precomp.h"
//crus begin
//myf17    #define PANNING_SCROLL           //myf1

#define LCD_type        1    //myf12
#define CRT_type        2    //myf12
#define SIM_type        3    //myf12

#if (_WIN32_WINNT >= 0x0400)

VOID PanOverlay7555 (PDEV *,LONG ,LONG);        //myf33
#endif
//crus end

ULONG SetMonoHwPointerShape(
    SURFOBJ    *pso,
    SURFOBJ    *psoMask,
    SURFOBJ    *psoColor,
    XLATEOBJ   *pxlo,
    LONG        xHot,
    LONG        yHot,
    LONG        x,
    LONG        y,
    RECTL      *prcl,
    FLONG       fl);


VOID vSetPointerBits(
PPDEV   ppdev,
LONG    xAdj,
LONG    yAdj)
{
    volatile PULONG  pulXfer;
    volatile PULONG  pul;

//ms923  LONG   lDelta = ppdev->lDeltaPointer;
    LONG    lDelta = 4;
    BYTE    ajAndMask[32][4];
    BYTE    ajXorMask[32][4];
    BYTE    ajHwPointer[256];
    PBYTE   pjAndMask;
    PBYTE   pjXorMask;

    LONG    cx;
    LONG    cy;
    LONG    cxInBytes;

    LONG    ix;
    LONG    iy;
    LONG    i;
    LONG    j;

#if BANKING //bank#1
    ppdev->pfnBankMap(ppdev, ppdev->lXferBank);
#endif

    // Clear the buffers that will hold the shifted masks.

    DISPDBG((2,"vSetPointerBits\n "));
    memset(ajAndMask, 0xff, 128);
    memset(ajXorMask, 0, 128);

    cx = ppdev->sizlPointer.cx;
    cy = ppdev->sizlPointer.cy - yAdj;

    cxInBytes = cx / 8;

    // Copy the AND Mask into the shifted bits AND buffer.
    // Copy the XOR Mask into the shifted bits XOR buffer.

    yAdj *= lDelta;

    pjAndMask  = (ppdev->pjPointerAndMask + yAdj);
    pjXorMask  = (ppdev->pjPointerXorMask + yAdj);

    for (iy = 0; iy < cy; iy++)
    {
        // Copy over a line of the masks.

        for (ix = 0; ix < cxInBytes; ix++)
        {
            ajAndMask[iy][ix] = pjAndMask[ix];
            ajXorMask[iy][ix] = pjXorMask[ix];
        }

        // point to the next line of the masks.

        pjAndMask += lDelta;
        pjXorMask += lDelta;
    }

    // At this point, the pointer is guaranteed to be a single
    // dword wide.

    if (xAdj != 0)
    {
        ULONG ulAndFillBits;
        ULONG ulXorFillBits;

        ulXorFillBits = 0xffffffff << xAdj;
        ulAndFillBits = ~ulXorFillBits;

        //
        // Shift the pattern to the left (in place)
        //

        DISPDBG((2, "xAdj(%d)", xAdj));

        for (iy = 0; iy < cy; iy++)
        {
            ULONG   ulTmpAnd = *((PULONG) (&ajAndMask[iy][0]));
            ULONG   ulTmpXor = *((PULONG) (&ajXorMask[iy][0]));

            BSWAP(ulTmpAnd);
            BSWAP(ulTmpXor);

            ulTmpAnd <<= xAdj;
            ulTmpXor <<= xAdj;

            ulTmpAnd |= ulAndFillBits;
            ulTmpXor &= ulXorFillBits;

            BSWAP(ulTmpAnd);
            BSWAP(ulTmpXor);

            *((PULONG) (&ajAndMask[iy][0])) = ulTmpAnd;
            *((PULONG) (&ajXorMask[iy][0])) = ulTmpXor;
        }
    }

    //
    // Convert the masks to the hardware pointer format
    //

    i = 0;      // AND mask
    j = 128;    // XOR mask

    for (iy = 0; iy < 32; iy++)
    {
        for (ix = 0; ix < 4; ix++)
        {
            ajHwPointer[j++] = ~ajAndMask[iy][ix];
            ajHwPointer[i++] =  ajXorMask[iy][ix];
        }
    }

    //
    // Download the pointer
    //

    if (ppdev->flCaps & CAPS_MM_IO)
    {
        BYTE * pjBase = ppdev->pjBase;

        CP_MM_WAIT_FOR_BLT_COMPLETE(ppdev, pjBase);
        CP_MM_DST_Y_OFFSET(ppdev, pjBase, 4);

//pat04, begin
//#if 0
#if (_WIN32_WINNT < 0x0400)
#ifdef PANNING_SCROLL
     if ((ppdev->ulChipID == CL7541_ID) || (ppdev->ulChipID == CL7543_ID) ||
         (ppdev->ulChipID == CL7542_ID) || (ppdev->ulChipID == CL7548_ID) ||
         (ppdev->ulChipID == CL7555_ID) || (ppdev->ulChipID == CL7556_ID))
        CP_MM_BLT_MODE(ppdev,pjBase, DIR_TBLR);
#endif
#endif
//#endif  //0
//pat04, end

        CP_MM_XCNT(ppdev, pjBase, (4 - 1));
        CP_MM_YCNT(ppdev, pjBase, (64 - 1));
        CP_MM_BLT_MODE(ppdev, pjBase, SRC_CPU_DATA);
        CP_MM_ROP(ppdev, pjBase, CL_SRC_COPY);
        CP_MM_DST_ADDR_ABS(ppdev, pjBase, ppdev->cjPointerOffset);
        CP_MM_START_BLT(ppdev, pjBase);
    }
    else
    {
        BYTE * pjPorts = ppdev->pjPorts;

#if BANKING //bank#1
                ppdev->pfnBankMap(ppdev, ppdev->lXferBank);
#endif
        CP_IO_WAIT_FOR_BLT_COMPLETE(ppdev, pjPorts);
        CP_IO_DST_Y_OFFSET(ppdev, pjPorts, 4);
        CP_IO_XCNT(ppdev, pjPorts, (4 - 1));
        CP_IO_YCNT(ppdev, pjPorts, (64 - 1));
        CP_IO_BLT_MODE(ppdev, pjPorts, SRC_CPU_DATA);
        CP_IO_ROP(ppdev, pjPorts, CL_SRC_COPY);
        CP_IO_DST_ADDR_ABS(ppdev, pjPorts, ppdev->cjPointerOffset);
        CP_IO_START_BLT(ppdev, pjPorts);
    }

    pulXfer = ppdev->pulXfer;
    pul = (PULONG) ajHwPointer;

    //
    // Disable the pointer (harmless if it already is)
    //

    for (i = 0; i < 64; i++)
    {
        CP_MEMORY_BARRIER();
        WRITE_REGISTER_ULONG(pulXfer, *pul);    // [ALPHA - sparse]
        pulXfer++;
        pul++;
        //*pulXfer++ = *pul++;
    }
    CP_EIEIO();
}

//crus begin
/***********************************************************\
* CirrusPanning
*
* caculate x, y
\************************************************************/
//myf1, begin
#ifdef PANNING_SCROLL
VOID CirrusPanning(
SURFOBJ*    pso,
LONG        x,
LONG        y,
RECTL*      prcl)
{
    PPDEV   ppdev = (PPDEV) pso->dhpdev;
    PBYTE   pjPorts = ppdev->pjPorts;

    UCHAR   CR13, CR1B, CR1D, CR17;
    UCHAR   Sflag = FALSE;      //myf31
    ULONG   Mem_addr;
    USHORT  h_pitch, X_shift;

    CP_OUT_BYTE(pjPorts, CRTC_INDEX, 0x13);
    CR13 = CP_IN_BYTE(pjPorts, CRTC_DATA);
    CP_OUT_BYTE(pjPorts, CRTC_INDEX, 0x1B);
    CR1B = CP_IN_BYTE(pjPorts, CRTC_DATA);

    //myf32 : fixed PDR #8873, panning enable, move mouse across max_Yscreen,
    // screen moving is strength
    CP_OUT_BYTE(pjPorts, CRTC_INDEX, 0x17);             //myf32
    CR17 = CP_IN_BYTE(pjPorts, CRTC_DATA) & 0x40;       //myf32
    h_pitch = (USHORT)((((CR1B & 0x10) << 4) + CR13));  //myf32
//  if (CR17 == 0)
        h_pitch <<= 1;

    if (ppdev->cBitsPerPixel == 8)
       X_shift = 2;             // (div 4)
    else if (ppdev->cBitsPerPixel == 16)
       X_shift = 1;             // (div 2)
    else if (ppdev->cBitsPerPixel == 24)
       X_shift = 4;             // (div 16)
    else if (ppdev->cBitsPerPixel == 32)
       X_shift = 0;             // (div 1)

    if ((y > ppdev->max_Yscreen))
    {
       Sflag = TRUE;            //myf31
       ppdev->min_Yscreen = y - (ppdev->Vres - 1);
       ppdev->max_Yscreen = y;
       if (x < ppdev->min_Xscreen)
       {
          ppdev->min_Xscreen = x;
          ppdev->max_Xscreen = x + (ppdev->Hres - 1);
       }
       if (x > ppdev->max_Xscreen)
       {
          ppdev->min_Xscreen = x - (ppdev->Hres - 1);
          ppdev->max_Xscreen = x;
       }
    DISPDBG((4,"CURSOR DOWN : (%x, %x),\t %x, %x, %x, %x\n",
         x, y,  ppdev->min_Xscreen, ppdev->max_Xscreen,
         ppdev->min_Yscreen, ppdev->max_Yscreen));
    }
    else if ((y < ppdev->min_Yscreen))
    {
       Sflag = TRUE;            //myf31
       ppdev->min_Yscreen = y;
//myf13   ppdev->max_Yscreen = (ppdev->Vres - 1) - y;
       ppdev->max_Yscreen = (ppdev->Vres - 1) + y;      //myf13
       if (x < ppdev->min_Xscreen)  //left
       {
          ppdev->min_Xscreen = x;
          ppdev->max_Xscreen = x + (ppdev->Hres - 1);
       }
       if (x > ppdev->max_Xscreen)
       {
          ppdev->min_Xscreen = x - (ppdev->Hres - 1);
          ppdev->max_Xscreen = x;
       }
    DISPDBG((4,"CURSOR DOWN : (%x, %x),\t %x, %x, %x, %x\n",
         x, y,  ppdev->min_Xscreen, ppdev->max_Xscreen,
         ppdev->min_Yscreen, ppdev->max_Yscreen));
    }
    else if ((y >= ppdev->min_Yscreen) && (y <= ppdev->max_Yscreen))
    {
       if (x < ppdev->min_Xscreen)
       {
          ppdev->min_Xscreen = x;
          ppdev->max_Xscreen = x + (ppdev->Hres - 1);
          Sflag = TRUE;            //myf31
       }
       if (x > ppdev->max_Xscreen)
       {
          ppdev->min_Xscreen = x - (ppdev->Hres - 1);
          ppdev->max_Xscreen = x;
          Sflag = TRUE;            //myf31
       }
    }
    DISPDBG((4,"CURSOR DOWN : (%x, %x),\t %x, %x, %x, %x\n",
         x, y,  ppdev->min_Xscreen, ppdev->max_Xscreen,
         ppdev->min_Yscreen, ppdev->max_Yscreen));

    if (ppdev->cBitsPerPixel == 24)
    {
        Mem_addr = ((ULONG)(h_pitch * ppdev->min_Yscreen)) +
                    (((ULONG)(ppdev->min_Xscreen >> X_shift)) * 12);
    }
    else
    {
        Mem_addr = ((ULONG)(h_pitch * ppdev->min_Yscreen)) +
                    (ULONG)(ppdev->min_Xscreen >> X_shift);
    }

    CR13 = (UCHAR)((Mem_addr >> 16) & 0x00FF);
    CP_OUT_BYTE(pjPorts, CRTC_INDEX, 0x1D);
    CR1D = CP_IN_BYTE(pjPorts, CRTC_DATA) & 0x7F;

    CR1D |= ((CR13 << 4) & 0x80);
    CR1B &= 0xF2;
    CR13 &= 0x07;
    CR1B |= (CR13 & 0x01);
    CR1B |= ((CR13 << 1) & 0x0C);

//myf32 for visibile bug, change the output reg sequence
    CP_OUT_BYTE(pjPorts, CRTC_INDEX, 0x1B);
    CP_OUT_BYTE(pjPorts, CRTC_DATA, (UCHAR)(CR1B));
    CP_OUT_BYTE(pjPorts, CRTC_INDEX, 0x1D);
    CP_OUT_BYTE(pjPorts, CRTC_DATA, (UCHAR)(CR1D));

    CP_OUT_BYTE(pjPorts, CRTC_INDEX, 0x0C);
    CP_OUT_BYTE(pjPorts, CRTC_DATA, (UCHAR)(Mem_addr >> 8));
    CP_OUT_BYTE(pjPorts, CRTC_INDEX, 0x0D);
    CP_OUT_BYTE(pjPorts, CRTC_DATA, (UCHAR)(Mem_addr & 0xFF));

    x -= ppdev->min_Xscreen;
    y -= ppdev->min_Yscreen;

#if (_WIN32_WINNT >= 0x0400)
    if (Sflag)                                  //myf31
        PanOverlay7555(ppdev,x,y);              //myf31
#endif

}
#endif          //ifdef PANNING_SCROLL
//myf1, end
//crus end

//pat04, begin

// Set Color Pointer Bits

//#if 0   //0, pat04
#if (_WIN32_WINNT < 0x0400)
#ifdef PANNING_SCROLL
// #if ((ppdev->ulChipID == CL7541_ID) || (ppdev->ulChipID == CL7543_ID) ||
//      (ppdev->ulChipID == CL7542_ID) || (ppdev->ulChipID == CL7548_ID) ||
//      (ppdev->ulChipID == CL7555_ID) || (ppdev->ulChipID == CL7556_ID)) )

VOID vSetCPointerBits(
PPDEV   ppdev,
LONG    xAdj,
LONG    yAdj)
{
    volatile PULONG  pulXfer;
    volatile PULONG  pul;

    LONG    lDelta = 4;
    BYTE    ajAndMask[32][4];
    BYTE    ajXorMask[32][4];
    BYTE    ajHwPointer[256];
    PBYTE   pjAndMask;
    PBYTE   pjXorMask;

    LONG    cx;
    LONG    cy;
    LONG    cxInBytes;

    LONG    ix;
    LONG    iy;
    LONG    i;
    LONG    j;
    BYTE * pjPorts = ppdev->pjPorts; //ppp

    // Clear the buffers that will hold the shifted masks.

    DISPDBG((2,"vSetCPointerBits\n "));
    memset(ajAndMask, 0xff, 128);

    cx = ppdev->sizlPointer.cx;
    cy = ppdev->sizlPointer.cy - yAdj;

    cxInBytes = cx / 8;

    // Copy the AND Mask into the shifted bits AND buffer.


    yAdj *= lDelta;

    pjAndMask  = (ppdev->pjPointerAndMask + yAdj);
    pjXorMask  = (ppdev->pjPointerXorMask + yAdj);

    for (iy = 0; iy < cy; iy++)
    {
        // Copy over a line of the masks.

        for (ix = 0; ix < cxInBytes; ix++)
            ajAndMask[iy][ix] = pjAndMask[ix];

        pjAndMask += lDelta;

    }

    // At this point, the pointer is guaranteed to be a single
    // dword wide.


    //
    // Convert the masks to the hardware pointer format
    //


    j = 0;

    for (iy = 0; iy < 32; iy++)
    {
        for (ix = 0; ix < 4; ix++)
           ajHwPointer[j++] = ~ajAndMask[iy][ix];

    }

    //
    // Download the pointer
    //



   if (ppdev->flCaps & CAPS_MM_IO) {

        BYTE * pjBase = ppdev->pjBase;

        // if !24bit. 24bit color expand requires 2 pass (for 7555)
        if (ppdev->cBpp != 3) {
          CP_MM_WAIT_FOR_BLT_COMPLETE(ppdev, pjBase);
          CP_MM_FG_COLOR(ppdev, pjBase, 0x00000000);
          CP_MM_BG_COLOR(ppdev, pjBase, 0xFFFFFFFF);
          CP_MM_DST_Y_OFFSET(ppdev, pjBase, ppdev->ppScanLine);
          CP_MM_XCNT(ppdev, pjBase, ppdev->xcount);
          CP_MM_YCNT(ppdev, pjBase, 31);
          CP_MM_BLT_MODE(ppdev, pjBase, SRC_CPU_DATA | DIR_TBLR | ENABLE_COLOR_EXPAND | ppdev->jModeColor);
          CP_MM_ROP(ppdev, pjBase, CL_SRC_COPY);
          CP_MM_DST_ADDR_ABS(ppdev, pjBase, ppdev->pjPointerAndCMask->xy);
          CP_MM_START_BLT(ppdev, pjBase);
        } // if (ppdev->cBpp != 3)

        else { // 24bit stuff

          // Save 1 pass, since we are generating monocrome masks.
          CP_MM_WAIT_FOR_BLT_COMPLETE(ppdev, pjBase);
          CP_MM_BLT_MODE(ppdev,pjBase, DIR_TBLR);
          CP_MM_ROP(ppdev,pjBase, CL_WHITENESS);
          CP_MM_SRC_Y_OFFSET(ppdev, pjBase, ppdev->ppScanLine );
          CP_MM_XCNT(ppdev, pjBase, ppdev->xcount);
          CP_MM_YCNT(ppdev, pjBase, 31);
          CP_MM_DST_ADDR_ABS(ppdev, pjBase, ppdev->pjPointerAndCMask->xy);
          CP_MM_START_BLT(ppdev, pjBase);

          CP_MM_WAIT_FOR_BLT_COMPLETE(ppdev, pjBase);
          CP_MM_FG_COLOR(ppdev, pjBase, 0x00000000);
          CP_MM_BG_COLOR(ppdev, pjBase, 0xFFFFFFFF);
          CP_MM_DST_Y_OFFSET(ppdev, pjBase, ppdev->ppScanLine);
          CP_MM_XCNT(ppdev, pjBase, ppdev->xcount);
          CP_MM_YCNT(ppdev, pjBase, 31);
          CP_MM_BLT_MODE(ppdev, pjBase, SRC_CPU_DATA | DIR_TBLR | ENABLE_COLOR_EXPAND | ppdev->jModeColor | ENABLE_TRANSPARENCY_COMPARE);
          CP_MM_ROP(ppdev, pjBase, CL_SRC_COPY);
          CP_MM_DST_ADDR_ABS(ppdev, pjBase, ppdev->pjPointerAndCMask->xy);
          CP_MM_START_BLT(ppdev, pjBase);
        } // else

       pulXfer = ppdev->pulXfer;
       pul = (PULONG) ajHwPointer;


       for (i = 0; i < 32; i++)
       {
         CP_MEMORY_BARRIER();
         WRITE_REGISTER_ULONG(pulXfer, *pul);
         pulXfer++;
         pul++;

       }

       CP_EIEIO();

    } // if MMIO

    else { // IO stuff (754x stuff)


       // 7548 HW BUG ?
       // system->screen with color expand will sometimes cause
       // the system to hang. Break it into 2 pass, and the problem
       // went away

       ppdev->pfnBankMap(ppdev, ppdev->lXferBank);
       CP_IO_WAIT_FOR_BLT_COMPLETE(ppdev, pjPorts);
       CP_IO_DST_Y_OFFSET(ppdev, pjPorts, 4);
       CP_IO_XCNT(ppdev, pjPorts, (4 - 1));
       CP_IO_YCNT(ppdev, pjPorts, (32 - 1));
       CP_IO_BLT_MODE(ppdev, pjPorts, SRC_CPU_DATA);
       CP_IO_ROP(ppdev, pjPorts, CL_SRC_COPY);
       CP_IO_DST_ADDR_ABS(ppdev, pjPorts, ppdev->cjPointerOffset);
       CP_IO_START_BLT(ppdev, pjPorts);

       pulXfer = ppdev->pulXfer;
       pul = (PULONG) ajHwPointer;

       for (i = 0; i < 32; i++) {

         CP_MEMORY_BARRIER();
         WRITE_REGISTER_ULONG(pulXfer, *pul);    // [ALPHA - sparse]
         pulXfer++;
         pul++;
      }

      CP_EIEIO();

      // Color Expand monocrome data into x-y DBB.

      CP_IO_WAIT_FOR_BLT_COMPLETE(ppdev, pjPorts);
      CP_IO_FG_COLOR(ppdev, pjPorts, 0x00000000);
      CP_IO_BG_COLOR(ppdev, pjPorts, 0xFFFFFFFF);
      CP_IO_SRC_Y_OFFSET(ppdev, pjPorts, 4); //
      CP_IO_DST_Y_OFFSET(ppdev, pjPorts, ppdev->ppScanLine);
      CP_IO_XCNT(ppdev, pjPorts, ppdev->xcount);
      CP_IO_YCNT(ppdev, pjPorts, 31);
      CP_IO_ROP(ppdev, pjPorts, CL_SRC_COPY);
      CP_IO_BLT_MODE(ppdev, pjPorts, DIR_TBLR | ENABLE_COLOR_EXPAND | ppdev->jModeColor);
      CP_IO_SRC_ADDR(ppdev, pjPorts, ppdev->cjPointerOffset);
      CP_IO_DST_ADDR_ABS(ppdev, pjPorts, ppdev->pjPointerAndCMask->xy);
      CP_IO_START_BLT(ppdev, pjPorts);
      CP_IO_WAIT_FOR_BLT_COMPLETE(ppdev, pjPorts);

  } // else

} // vSetCPointerBits( )


#endif
#endif
//#endif  //0

//pat04, end

/******************************Public*Routine******************************\
* DrvMovePointer
*
* Move the HW pointer to a new location on the screen.
\**************************************************************************/

VOID DrvMovePointer(
SURFOBJ*    pso,
LONG        x,
LONG        y,
RECTL*      prcl)
{
    PPDEV   ppdev = (PPDEV) pso->dhpdev;
    PBYTE   pjPorts = ppdev->pjPorts;

    FLONG   fl;
    LONG    xAdj = 0;
    LONG    yAdj = 0;

//crus
    LONG    deltaX;             //myf15
    LONG    deltaY;             //myf15

//pat04, begin
//#if 0
#if (_WIN32_WINNT < 0x0400)
#ifdef PANNING_SCROLL
    BYTE  * pjBase = ppdev->pjBase;
    static  specialcase = 0;
    LONG    tmpaddress;
    LONG    clipping  ;
    LONG    clippingy ;
    UCHAR   ChipID;
#endif
#endif
//#endif  //0
//pat04, end

    DISPDBG((4,"DrvMovePointer to (%d,%d)", x, y));

//crus
#if 0
    BYTE    SR0A, SR14, savSEQidx;      //myf12
    SHORT   Displaytype;                //myf12


    if (!(ppdev->bBlockSwitch))            //not block switch
    {
        savSEQidx = CP_IN_BYTE(pjPorts, SR_INDEX);
        CP_OUT_BYTE(pjPorts, SR_INDEX, 0x14);
        SR14 = CP_IN_BYTE(pjPorts, SR_DATA);
        CP_OUT_BYTE(pjPorts, SR_INDEX, (SR14 | 0x04));

        CP_OUT_BYTE(pjPorts, SR_INDEX, 0x09);
        SR0A = CP_IN_BYTE(pjPorts, SR_DATA);

        Displaytype = ((SR14 & 0x02) | (SR0A & 0x01));
        if (Displaytype == 0)
            Displaytype = LCD_type;
        else if (Displaytype == 1)
            Displaytype = CRT_type;
        else if (Displaytype == 3)
            Displaytype = SIM_type;

        if (ppdev->bDisplaytype != Displaytype)
        {
            ppdev->bDisplaytype = Displaytype;
//          SwitchDisplayDevice();
/*
            savCRTidx = CP_IN_BYTE(pjPorts, CRTC_INDEX);
            if (ppdev->ulChipID & CL754x)
            {
                CP_OUT_BYTE(pjPorts, CRTC_INDEX, 0x20);
                lcd = CP_IN_BYTE(pjPorts, CRTC_DATA);
            }
            else if (ppdev->ulChipID & CL755x)
            {
                CP_OUT_BYTE(pjPorts, CRTC_INDEX, 0x80);
                lcd = CP_IN_BYTE(pjPorts, CRTC_DATA);
            }
            CP_OUT_BYTE(pjPorts, CRTC_INDEX, savCRTidx);
*/
        }
        CP_OUT_BYTE(pjPorts, SR_INDEX, savSEQidx);
    }
#endif

//pat04, begin
//#if   0 //0
#if (_WIN32_WINNT < 0x0400)
#ifdef PANNING_SCROLL

//if ((ppdev->ulChipID == CL7541_ID) || (ppdev->ulChipID == CL7543_ID) ||
//    (ppdev->ulChipID == CL7542_ID) || (ppdev->ulChipID == CL7548_ID) ||
//    (ppdev->ulChipID == CL7555_ID) || (ppdev->ulChipID == CL7556_ID))

  if (ppdev->flCaps & CAPS_SW_POINTER) {

    y -= ppdev->yPointerHot;
    if (y < 0) y = 0;

    // Get Chip ID
    CP_OUT_BYTE(ppdev->pjPorts, CRTC_INDEX, 0x27);
    ChipID = (CP_IN_BYTE(ppdev->pjPorts, CRTC_DATA) & 0xFC) >> 2;


    // If x == -1 (invisible cursor)

    if (x < 0 )  {

      specialcase = 1;
      x = 0;
      y = 0;

      // if old coordinate is not negative ...
      if (ppdev->oldx >= 0) {
        if (ppdev->flCaps & CAPS_MM_IO) {
          CP_MM_WAIT_FOR_BLT_COMPLETE(ppdev, pjBase);
          CP_MM_BLT_MODE(ppdev,pjBase, DIR_TBLR);
          CP_MM_ROP(ppdev,pjBase, CL_SRC_COPY);
          CP_MM_SRC_Y_OFFSET(ppdev, pjBase, ppdev->ppScanLine );
          CP_MM_XCNT(ppdev, pjBase, ppdev->xcount );
          CP_MM_YCNT(ppdev, pjBase, 31);
          CP_MM_SRC_ADDR(ppdev, pjBase, ppdev->pjCBackground->xy);
          CP_MM_DST_ADDR_ABS(ppdev, pjBase, ((ppdev->oldy * ppdev->cxScreen * ppdev->cBpp) + (ppdev->oldx * ppdev->cBpp)) );
          CP_MM_START_BLT(ppdev, pjBase);
        } //  if (ppdev->flCaps & CAPS_MM_IO)

        else {
          CP_IO_WAIT_FOR_BLT_COMPLETE(ppdev, pjPorts);
          CP_IO_BLT_MODE(ppdev,pjPorts, DIR_TBLR);
          CP_IO_ROP(ppdev, pjPorts, CL_SRC_COPY);
          CP_IO_SRC_Y_OFFSET(ppdev, pjPorts, ppdev->ppScanLine );
          CP_IO_XCNT(ppdev, pjPorts, ppdev->xcount);
          CP_IO_YCNT(ppdev, pjPorts, 31);
          CP_IO_SRC_ADDR(ppdev, pjPorts, ppdev->pjCBackground->xy);
          CP_IO_DST_ADDR_ABS(ppdev, pjPorts, ((ppdev->oldy * ppdev->cxScreen * ppdev->cBpp) + (ppdev->oldx * ppdev->cBpp)) );
          CP_IO_START_BLT(ppdev, pjPorts);
        } // else
      }
      return;
    }


    x -= ppdev->xPointerHot;

    // cheap clipping ....
    if (x < 0) x = 0;

    clippingy = 31;

    if ((y + 32) > ppdev->cyScreen) {
       clippingy += (ppdev->cyScreen - y - 32);
    }


    clipping = 31;
    if ((x + 32) > ppdev->cxScreen)
    {
      clipping += (ppdev->cxScreen - x - 32); // negative value
    }

    clipping *= ppdev->cBpp;


    if (!specialcase) {

      if (ppdev->flCaps & CAPS_MM_IO) {
        CP_MM_WAIT_FOR_BLT_COMPLETE(ppdev, pjBase);
        CP_MM_BLT_MODE(ppdev,pjBase, DIR_TBLR);
        CP_MM_ROP(ppdev,pjBase, CL_SRC_COPY);
        CP_MM_SRC_Y_OFFSET(ppdev, pjBase, ppdev->ppScanLine );
        CP_MM_XCNT(ppdev, pjBase, ppdev->xcount);
        CP_MM_YCNT(ppdev, pjBase, 31);
        CP_MM_SRC_ADDR(ppdev, pjBase, ppdev->pjCBackground->xy);
        CP_MM_DST_ADDR_ABS(ppdev, pjBase, ((ppdev->oldy * ppdev->cxScreen * ppdev->cBpp) + (ppdev->oldx * ppdev->cBpp)) );
        CP_MM_START_BLT(ppdev, pjBase);
      }

      else {

        CP_IO_WAIT_FOR_BLT_COMPLETE(ppdev, pjPorts);
        CP_IO_BLT_MODE(ppdev, pjPorts, DIR_TBLR);
        CP_IO_ROP(ppdev, pjPorts, CL_SRC_COPY);
        CP_IO_SRC_Y_OFFSET(ppdev, pjPorts, ppdev->ppScanLine );
        CP_IO_XCNT(ppdev, pjPorts, ppdev->xcount);
        CP_IO_YCNT(ppdev, pjPorts, 31);
        CP_IO_SRC_ADDR(ppdev, pjPorts, ppdev->pjCBackground->xy);
        CP_IO_DST_ADDR_ABS(ppdev, pjPorts, ((ppdev->oldy * ppdev->cxScreen * ppdev->cBpp) + (ppdev->oldx * ppdev->cBpp)) );
        CP_IO_START_BLT(ppdev, pjPorts);
      } // else

     } // specialcase

     specialcase = 0; // no specialcase
     tmpaddress = (y * ppdev->cxScreen * ppdev->cBpp) + (x * ppdev->cBpp);
     ppdev->oldy = y;
     ppdev->oldx = x;

     if (ppdev->flCaps & CAPS_MM_IO) {
       CP_MM_WAIT_FOR_BLT_COMPLETE(ppdev, pjBase);
       CP_MM_BLT_MODE(ppdev,pjBase, DIR_TBLR);
       CP_MM_SRC_Y_OFFSET(ppdev, pjBase, ppdev->ppScanLine );
       CP_MM_ROP(ppdev,pjBase, CL_SRC_COPY);
       CP_MM_XCNT(ppdev, pjBase, ppdev->xcount);
       CP_MM_YCNT(ppdev, pjBase, 31);
       CP_MM_SRC_ADDR(ppdev, pjBase, tmpaddress);
       CP_MM_DST_ADDR_ABS(ppdev, pjBase, ppdev->pjCBackground->xy);
       CP_MM_START_BLT(ppdev, pjBase);
     } // MMIO

     else {
       CP_IO_WAIT_FOR_BLT_COMPLETE(ppdev, pjPorts);
       CP_IO_BLT_MODE(ppdev, pjPorts, DIR_TBLR);
       CP_IO_SRC_Y_OFFSET(ppdev, pjPorts, ppdev->ppScanLine );
       CP_IO_ROP(ppdev, pjPorts, CL_SRC_COPY);
       CP_IO_XCNT(ppdev, pjPorts, ppdev->xcount);
       CP_IO_YCNT(ppdev, pjPorts, 31);
       CP_IO_SRC_ADDR(ppdev, pjPorts, tmpaddress);
       CP_IO_DST_ADDR_ABS(ppdev, pjPorts, ppdev->pjCBackground->xy);
       CP_IO_START_BLT(ppdev, pjPorts);
     }


     if (clipping > 0) {

       if (ppdev->flCaps & CAPS_MM_IO)  {

         // And AND MASK
         CP_MM_WAIT_FOR_BLT_COMPLETE(ppdev, pjBase);
         CP_MM_SRC_Y_OFFSET(ppdev, pjBase, ppdev->ppScanLine );
         CP_MM_XCNT(ppdev, pjBase, clipping );
         CP_MM_YCNT(ppdev, pjBase, clippingy );
         //CP_MM_YCNT(ppdev, pjBase, 31);
         CP_MM_BLT_MODE(ppdev,pjBase, DIR_TBLR);
         CP_MM_ROP(ppdev, pjBase, CL_SRC_AND);
         CP_MM_SRC_ADDR(ppdev, pjBase, ppdev->pjPointerAndCMask->xy);
         CP_MM_DST_ADDR_ABS(ppdev, pjBase, tmpaddress );
         CP_MM_START_BLT(ppdev, pjBase);

         // OR COLOR MASK
         CP_MM_WAIT_FOR_BLT_COMPLETE(ppdev, pjBase);
         CP_MM_BLT_MODE(ppdev,pjBase, DIR_TBLR);
         CP_MM_ROP(ppdev,pjBase, CL_SRC_PAINT);
         CP_MM_SRC_Y_OFFSET(ppdev, pjBase, ppdev->ppScanLine);
         CP_MM_XCNT(ppdev, pjBase, clipping );
         CP_MM_YCNT(ppdev, pjBase, clippingy );
         //CP_MM_YCNT(ppdev, pjBase, 31);
         CP_MM_SRC_ADDR(ppdev, pjBase, ppdev->pjPointerCBitmap->xy);
         CP_MM_DST_ADDR_ABS(ppdev, pjBase, tmpaddress );
         CP_MM_START_BLT(ppdev, pjBase);
       }

       else {

         // AND AND MASK
         CP_IO_WAIT_FOR_BLT_COMPLETE(ppdev, pjPorts);
         CP_IO_SRC_Y_OFFSET(ppdev, pjPorts, ppdev->ppScanLine );
         CP_IO_XCNT(ppdev, pjPorts, clipping );
         CP_IO_YCNT(ppdev, pjPorts, clippingy);
         //CP_IO_YCNT(ppdev, pjPorts, 31);
         CP_IO_BLT_MODE(ppdev, pjPorts, DIR_TBLR);
         CP_IO_ROP(ppdev, pjPorts, CL_SRC_AND);
         CP_IO_SRC_ADDR(ppdev, pjPorts, ppdev->pjPointerAndCMask->xy);
         CP_IO_DST_ADDR_ABS(ppdev, pjPorts, tmpaddress );
         CP_IO_START_BLT(ppdev, pjPorts);

         // OR COLOR MASK
         CP_IO_WAIT_FOR_BLT_COMPLETE(ppdev, pjPorts);
         CP_IO_BLT_MODE(ppdev, pjPorts, DIR_TBLR);
         CP_IO_ROP(ppdev, pjPorts, CL_SRC_PAINT);
         CP_IO_SRC_Y_OFFSET(ppdev, pjPorts, ppdev->ppScanLine);
         CP_IO_XCNT(ppdev, pjPorts, clipping );
         CP_IO_YCNT(ppdev, pjPorts, clippingy);
         //CP_IO_YCNT(ppdev, pjPorts, 31);
         CP_IO_SRC_ADDR(ppdev, pjPorts, ppdev->pjPointerCBitmap->xy);
         CP_IO_DST_ADDR_ABS(ppdev, pjPorts, tmpaddress );
         CP_IO_START_BLT(ppdev, pjPorts);
         CP_IO_WAIT_FOR_BLT_COMPLETE(ppdev, pjPorts);

       } // else

    }  // if clipping

    // Bounding rectangle for software cursor
    prcl->left =  x;
    prcl->right = x + 32;
    prcl->top =  y;
    prcl->bottom = y + 32;



    if ((ppdev->ulChipID == 0x38) || (ppdev->ulChipID == 0x2C) ||
        (ppdev->ulChipID == 0x30) || (ppdev->ulChipID == 0x34) || //myf19
        (ppdev->ulChipID == 0x40) || (ppdev->ulChipID == 0x4C))   //myf17
    {
        CirrusPanning(pso, x, y, prcl);
        x -= ppdev->min_Xscreen;
        y -= ppdev->min_Yscreen;
    }

    return;
  }
//}     //if chipID == laptop chip
#endif          //PANNING_SCROLL
#endif          //_WIN32_WINNT < 0400
//#endif  //0
//pat04, end


    //
    // If x is -1 then take down the cursor.
    //

    if (x == -1)
    {
        // Move the hardware pointer off-screen so that when it gets
        // turned back on, it won't flash in the old position:

        CP_PTR_DISABLE(ppdev, pjPorts);
        return;
    }


//crus begin
//myf1, begin
#ifdef PANNING_SCROLL
//  if (ppdev->flCaps & CAPS_PANNING)
    if (y < 0)
        y = y + pso->sizlBitmap.cy;
//    DISPDBG((2,"DrvMovePointer to (%d,%d)", x, y));
//  else
//      y = -y;
    if ((ppdev->ulChipID == 0x38) || (ppdev->ulChipID == 0x2C) ||
        (ppdev->ulChipID == 0x30) || (ppdev->ulChipID == 0x34) || //myf19
        (ppdev->ulChipID == 0x40) || (ppdev->ulChipID == 0x4C))   //myf17
    {
        CirrusPanning(pso, x, y, prcl);
        x -= ppdev->min_Xscreen;
        y -= ppdev->min_Yscreen;
    }

#endif          //ifdef PANNING_SCROLL
//myf1, end
//crus end

    //myf33 begin
#if (_WIN32_WINNT >= 0x0400)
#ifdef PANNING_SCROLL
    // set CAPS_PANNING flag so must be check ppdev->flCaps flag,
    // disable display both shape(S/W & H/W)
    if (ppdev->flCaps & CAPS_SW_POINTER)
    {
        CP_PTR_DISABLE(ppdev, pjPorts);
        return;
    }
#endif
#endif
    //myf33 end


    // Adjust the actual pointer position depending upon
    // the hot spot.

    x -= ppdev->xPointerHot;
    y -= ppdev->yPointerHot;

    fl = 0;

    if (x < 0)
    {
        xAdj = -x;
        x = 0;
        fl |= POINTER_X_SHIFT;
    }

    if (y < 0)
    {
        yAdj = -y;
        y = 0;
        fl |= POINTER_Y_SHIFT;
    }

    if ((fl == 0) && (ppdev->flPointer & (POINTER_Y_SHIFT | POINTER_X_SHIFT)))
    {
        fl |= POINTER_SHAPE_RESET;
    }

    CP_PTR_XY_POS(ppdev, pjPorts, x, y);

    if (fl != 0)
    {
        vSetPointerBits(ppdev, xAdj, yAdj);
    }

    CP_PTR_ENABLE(ppdev, pjPorts);

    // record the flags.

    ppdev->flPointer = fl;
    return;
}

#if (_WIN32_WINNT < 0x0400)              //pat04
//if ((ppdev->ulChipID == CL7541_ID) || (ppdev->ulChipID == CL7543_ID) ||
//    (ppdev->ulChipID == CL7542_ID) || (ppdev->ulChipID == CL7548_ID) ||
//    (ppdev->ulChipID == CL7555_ID) || (ppdev->ulChipID == CL7556_ID))

/******************************Public*Routine******************************\
* DrvSetPointerShape
*
* Sets the new pointer shape.
\**************************************************************************/

ULONG DrvSetPointerShape(
SURFOBJ    *pso,
SURFOBJ    *psoMask,
SURFOBJ    *psoColor,
XLATEOBJ   *pxlo,
LONG        xHot,
LONG        yHot,
LONG        x,
LONG        y,
RECTL      *prcl,
FLONG       fl)
{
    PPDEV   ppdev = (PPDEV) pso->dhpdev;
    PBYTE   pjPorts = ppdev->pjPorts;
    ULONG   ulRet = SPS_DECLINE;
    LONG    cx;
    LONG    cy;

    BYTE  * pjBase = ppdev->pjBase;
    static  poh    = 0;
    volatile PULONG  pul;
    ULONG counter = 0;
    DSURF* pdsurfColor;         //myf32

    DISPDBG((2,"DrvSetPointerShape : (%x, %x)---%x\n", x, y,ppdev->flCaps));

    // Is the cursor a color cursor ?

#ifdef PANNING_SCROLL

    if (psoColor != NULL) {

      // Let GDI handle color cursor at these resolutions
      if ((ppdev->cxScreen == 640) ||
          ((ppdev->cxScreen == 800) & (ppdev->cBpp == 3)) ) {
//         CP_PTR_DISABLE(ppdev, pjPorts);
//         goto ReturnStatus;
           goto DisablePointer;         //myf33
      }

      // if the 3 permenent spaces cannot be allocated ...
      if ( (ppdev->pjPointerAndCMask == NULL) || (ppdev->pjCBackground == NULL)
          || (ppdev->pjPointerCBitmap == NULL) ) {
//        CP_PTR_DISABLE(ppdev, pjPorts);
//        goto ReturnStatus;
          goto DisablePointer;         //myf33
      }


      ppdev->xPointerHot = xHot;
      ppdev->yPointerHot = yHot;
      ppdev->ppScanLine = ppdev->cxScreen * ppdev->cBpp;
      ppdev->xcount     = 31 * ppdev->cBpp;


      if (!(ppdev->flCaps & CAPS_SW_POINTER)) {
        ppdev->flCaps |= CAPS_SW_POINTER;       //myfxx
        CP_PTR_DISABLE(ppdev, pjPorts);
      }


      // specialcase to init for first time
       if ((poh == 0) || (ppdev->globdat == 0)) {

   // if (poh == 0)  {

          if (x >= 0) {
            poh = 0;
            ppdev->oldx = x;
            ppdev->oldy = y;
            ppdev->globdat = 1;

           // Save background in xy DBB format
           if (ppdev->flCaps & CAPS_MM_IO) {
             CP_MM_WAIT_FOR_BLT_COMPLETE(ppdev, pjBase);
             CP_MM_BLT_MODE(ppdev,pjBase, DIR_TBLR);
             CP_MM_SRC_Y_OFFSET(ppdev, pjBase, ppdev->ppScanLine);
             CP_MM_DST_Y_OFFSET(ppdev, pjBase, ppdev->ppScanLine);
             CP_MM_ROP(ppdev,pjBase, CL_SRC_COPY);
             CP_MM_XCNT(ppdev, pjBase, ppdev->xcount);
             CP_MM_YCNT(ppdev, pjBase, 31);
             CP_MM_SRC_ADDR(ppdev, pjBase, ((y * ppdev->cxScreen * ppdev->cBpp) + (x * ppdev->cBpp)) );
             CP_MM_DST_ADDR_ABS(ppdev, pjBase, ppdev->pjCBackground->xy);
             CP_MM_START_BLT(ppdev, pjBase);
           } // if MMIO

           else {
             CP_IO_WAIT_FOR_BLT_COMPLETE(ppdev,  pjPorts);
             CP_IO_FG_COLOR(ppdev, pjPorts, 0);
             CP_IO_BLT_MODE(ppdev, pjPorts, DIR_TBLR);
             CP_IO_SRC_Y_OFFSET(ppdev,  pjPorts, ppdev->ppScanLine);
             CP_IO_DST_Y_OFFSET(ppdev,  pjPorts, ppdev->ppScanLine);
             CP_IO_ROP(ppdev,   pjPorts, CL_SRC_COPY);
             CP_IO_XCNT(ppdev,  pjPorts, ppdev->xcount);
             CP_IO_YCNT(ppdev,  pjPorts, 31);
             CP_IO_SRC_ADDR(ppdev,  pjPorts, ((y * ppdev->cxScreen * ppdev->cBpp) + (x * ppdev->cBpp)) );
             CP_IO_DST_ADDR_ABS(ppdev,  pjPorts, ppdev->pjCBackground->xy);
             CP_IO_START_BLT(ppdev,  pjPorts);

           } // ELSE
         }

      } // if poh == 0



      SetMonoHwPointerShape(pso, psoMask, psoColor, pxlo,
                           xHot, yHot, x, y, prcl, fl);

//myf32 added
      pdsurfColor = (DSURF*)psoColor->dhsurf;
      // if color bitmap resides in system memory, bring it into offscreen
      if ((pdsurfColor != NULL) && (pdsurfColor->poh->ofl == 0)) {
          bMoveDibToOffscreenDfbIfRoom(ppdev, pdsurfColor);
      }  // OH resides as DIB
//myf32 end


      // Get the color bitmap and save it, since it will be destroyed later
      if (ppdev->flCaps & CAPS_MM_IO) {

        CP_MM_WAIT_FOR_BLT_COMPLETE(ppdev, pjBase);
        CP_MM_BLT_MODE(ppdev,pjBase, DIR_TBLR);
        CP_MM_SRC_Y_OFFSET(ppdev, pjBase, ppdev->ppScanLine);
        CP_MM_ROP(ppdev,pjBase, CL_SRC_COPY);
        CP_MM_XCNT(ppdev, pjBase, ppdev->xcount);
        CP_MM_YCNT(ppdev, pjBase, 31);
        CP_MM_SRC_ADDR(ppdev, pjBase, ((DSURF *) (psoColor->dhsurf))->poh->xy);
        CP_MM_DST_ADDR_ABS(ppdev, pjBase, ppdev->pjPointerCBitmap->xy);
        CP_MM_START_BLT(ppdev, pjBase);

      }  // if MMIO


      else  {

       // if no space in offscreen, and color bitmap still resides in
       // system memory, then blt directly to the preallocated
       // permanent buffer

//myf32    if (  ((DSURF *) (psoColor->dhsurf))->poh->ofl != 0) {
           if ((pdsurfColor != NULL) && (pdsurfColor->poh->ofl != 0)) {
               CP_IO_WAIT_FOR_BLT_COMPLETE(ppdev,  pjPorts);
               CP_IO_BLT_MODE(ppdev,      pjPorts, DIR_TBLR);
               CP_IO_SRC_Y_OFFSET(ppdev,  pjPorts, ppdev->ppScanLine);
               CP_IO_ROP(ppdev,   pjPorts, CL_SRC_COPY);
               CP_IO_XCNT(ppdev,  pjPorts, ppdev->xcount);
               CP_IO_YCNT(ppdev,  pjPorts, 31);
               CP_IO_SRC_ADDR(ppdev,  pjPorts, ((DSURF *) (psoColor->dhsurf))->poh->xy);
               CP_IO_DST_ADDR_ABS(ppdev,  pjPorts, ppdev->pjPointerCBitmap->xy);
               CP_IO_START_BLT(ppdev,  pjPorts);
           }

           else { // not enough offscreen memory. so directly blt to video

               RECTL  rclDst;
               POINTL ptlSrc;
               rclDst.left   = ppdev->pjPointerCBitmap->x;
               rclDst.top    = ppdev->pjPointerCBitmap->y;
               rclDst.right  = rclDst.left +  ppdev->xcount;
               rclDst.bottom = rclDst.top +  32;
               ptlSrc.x = 0;
               ptlSrc.y = 0;
               ppdev->pfnPutBits(ppdev, ((DSURF *) (psoColor->dhsurf))->pso, &rclDst, &ptlSrc);

           }

     } // else

     prcl->left =  x;
     prcl->right = x + 32;
     prcl->top =  y;
     prcl->bottom = y + 32;

     DrvMovePointer(pso, x, y, NULL);

     if (poh == 0) {
       poh = 1;
       vAssertModeBrushCache(ppdev, TRUE);
     }

     ulRet = SPS_ACCEPT_EXCLUDE;


     // HW BUG ....
     //
     //    hardware (bootup) -> hardware -> software will mess the brush
     //  cache. Something to do with the BLTer. Marked off all the system
     //  -> video BLTS (in vSetCPointer()), but problem still exists.
     //  so I just restore them back. Only happens during bootup ...


     goto ReturnStatus;

   };


   if ((ppdev->flCaps & CAPS_SW_POINTER) && (ppdev->cxScreen == 640)) {
      goto ReturnStatus;
   }; //ppp  //if monocrome + software pointer

   if (ppdev->flCaps & CAPS_SW_POINTER)
   {
       ppdev->flCaps &=  ~CAPS_SW_POINTER;
       ppdev->globdat = 0;

     // repaint stuff back on screen !
       if (ppdev->flCaps & CAPS_MM_IO)
       {
           CP_MM_WAIT_FOR_BLT_COMPLETE(ppdev, pjBase);
           CP_MM_BLT_MODE(ppdev,pjBase, DIR_TBLR);
           CP_MM_ROP(ppdev,pjBase, CL_SRC_COPY);
           CP_MM_SRC_Y_OFFSET(ppdev, pjBase, ppdev->ppScanLine );
           CP_MM_XCNT(ppdev, pjBase, ppdev->xcount);
           CP_MM_YCNT(ppdev, pjBase, 31);
           CP_MM_SRC_ADDR(ppdev, pjBase, ppdev->pjCBackground->xy);
           CP_MM_DST_ADDR_ABS(ppdev, pjBase, ((ppdev->oldy * ppdev->cxScreen *
                     ppdev->cBpp) + (ppdev->oldx * ppdev->cBpp)) );
           CP_MM_START_BLT(ppdev, pjBase);
       }

       else {
           CP_IO_WAIT_FOR_BLT_COMPLETE(ppdev, pjPorts);
           CP_IO_BLT_MODE(ppdev, pjPorts, DIR_TBLR);
           CP_IO_ROP(ppdev, pjPorts, CL_SRC_COPY);
           CP_IO_SRC_Y_OFFSET(ppdev, pjPorts, ppdev->ppScanLine );
           CP_IO_XCNT(ppdev, pjPorts, ppdev->xcount);
           CP_IO_YCNT(ppdev, pjPorts, 31);
           CP_IO_SRC_ADDR(ppdev, pjPorts, ppdev->pjCBackground->xy);
           CP_IO_DST_ADDR_ABS(ppdev, pjPorts, ((ppdev->oldy * ppdev->cxScreen *
                     ppdev->cBpp) + (ppdev->oldx * ppdev->cBpp)) );
           CP_IO_START_BLT(ppdev, pjPorts);
       } // else

      // #pat07
      bEnablePointer(ppdev); // #pat07
      CP_PTR_ENABLE(ppdev, pjPorts); // #pat07
   }

#endif

    cx = psoMask->sizlBitmap.cx;
    cy = psoMask->sizlBitmap.cy / 2;

    DISPDBG((2,"DrvSetPtrShape %dx%d at (%d,%d), flags: %x, psoColor: %x",
                cx, cy, x, y, fl, psoColor));   //4

    if ((cx > 32) ||
        (cy > 32) ||
        (psoColor != NULL))
    {
        //
        // We only handle monochrome pointers that are 32x32 or less
        //

        goto DisablePointer;
    }

#if 0 //bank#1
    ppdev->pfnBankMap(ppdev, ppdev->lXferBank);
#endif

    //
    // Save the hot spot and dimensions of the cursor in the PDEV
    //

    ppdev->xPointerHot = xHot;
    ppdev->yPointerHot = yHot;

    ulRet = SetMonoHwPointerShape(pso, psoMask, psoColor, pxlo,
                                  xHot, yHot, x, y, prcl, fl);

    if (ulRet != SPS_DECLINE)
    {
        goto ReturnStatus;
    }

DisablePointer:
    CP_PTR_DISABLE(ppdev, pjPorts);

ReturnStatus:
    return (ulRet);
}

#else                   //pat04

/******************************Public*Routine******************************\
* DrvSetPointerShape
*
* Sets the new pointer shape.
\**************************************************************************/

ULONG DrvSetPointerShape(
SURFOBJ    *pso,
SURFOBJ    *psoMask,
SURFOBJ    *psoColor,
XLATEOBJ   *pxlo,
LONG        xHot,
LONG        yHot,
LONG        x,
LONG        y,
RECTL      *prcl,
FLONG       fl)
{
    PPDEV   ppdev = (PPDEV) pso->dhpdev;
    PBYTE   pjPorts = ppdev->pjPorts;
    ULONG   ulRet = SPS_DECLINE;
    LONG    cx;
    LONG    cy;

    DISPDBG((2,"DrvSetPointerShape : (%x, %x)\n", x, y));

    if (ppdev->flCaps & CAPS_SW_POINTER)
    {
        goto DisablePointer;    //myf33
//      goto ReturnStatus;
    }

    cx = psoMask->sizlBitmap.cx;
    cy = psoMask->sizlBitmap.cy / 2;

    DISPDBG((2,"DrvSetPtrShape %dx%d at (%d,%d), flags: %x, psoColor: %x",
                cx, cy, x, y, fl, psoColor));   //4

    if ((cx > 32) ||
        (cy > 32) ||
        (psoColor != NULL))
    {
        //
        // We only handle monochrome pointers that are 32x32 or less
        //
        ppdev->flCaps |= CAPS_SW_POINTER;       //myf33,
        DISPDBG((2, "It is a  64 x 64 cursor"));

        goto DisablePointer;
    }

#if BANKING //bank#1
    ppdev->pfnBankMap(ppdev, ppdev->lXferBank);
#endif

    //
    // Save the hot spot and dimensions of the cursor in the PDEV
    //

    ppdev->xPointerHot = xHot;
    ppdev->yPointerHot = yHot;

    ulRet = SetMonoHwPointerShape(pso, psoMask, psoColor, pxlo,
                                  xHot, yHot, x, y, prcl, fl);

    if (ulRet != SPS_DECLINE)
    {
        goto ReturnStatus;
    }

DisablePointer:
    CP_PTR_DISABLE(ppdev, pjPorts);

ReturnStatus:
    return (ulRet);
}
#endif          //pat04

/****************************************************************************\
* SetMonoHwPointerShape
*
*  Truth Table
*
*      MS                  Cirrus
*  ----|----               ----|----
*  AND | XOR               P0  |  P1
*   0  | 0     Black        0  |  1
*   0  | 1     White        1  |  1
*   1  | 0     Transparent  0  |  0
*   1  | 1     Inverse      1  |  0
*
*  So, in order to translate from the MS convention to the Cirrus convention
*  we had to invert the AND mask, then down load the XOR as plane 0 and the
*  the AND mask as plane 1.
\****************************************************************************/

ULONG SetMonoHwPointerShape(
SURFOBJ     *pso,
SURFOBJ     *psoMask,
SURFOBJ     *psoColor,
XLATEOBJ    *pxlo,
LONG        xHot,
LONG        yHot,
LONG        x,
LONG        y,
RECTL       *prcl,
FLONG       fl)
{

    INT     i,
            j,
            cxMask,
            cyMask,
            cy,
            cx;

    PBYTE   pjAND,
            pjXOR;

    INT     lDelta;

    PPDEV   ppdev   = (PPDEV) pso->dhpdev;
    PBYTE   pjPorts = ppdev->pjPorts;
    PBYTE   pjAndMask;
    PBYTE   pjXorMask;

    // Init the AND and XOR masks, for the cirrus chip
    DISPDBG((2,"SetMonoHWPointerShape\n "));

    pjAndMask = ppdev->pjPointerAndMask;
    pjXorMask = ppdev->pjPointerXorMask;

    memset (pjAndMask, 0, 128);
    memset (pjXorMask, 0, 128);

    // Get the bitmap dimensions.

    cxMask = psoMask->sizlBitmap.cx;
    cyMask = psoMask->sizlBitmap.cy;

    cy = cyMask / 2;
    cx = cxMask / 8;

    // Set up pointers to the AND and XOR masks.

    lDelta = psoMask->lDelta;
    pjAND  = psoMask->pvScan0;
    pjXOR  = pjAND + (cy * lDelta);

//ms923    ppdev->lDeltaPointer  = lDelta;
    ppdev->sizlPointer.cx = cxMask;
    ppdev->sizlPointer.cy = cyMask / 2;

    // Copy the masks

    for (i = 0; i < cy; i++)
    {
        for (j = 0; j < cx; j++)
        {
            pjAndMask[(i*4)+j] = pjAND[j];
            pjXorMask[(i*4)+j] = pjXOR[j];
        }

        // point to the next line of the AND mask.

        pjAND += lDelta;
        pjXOR += lDelta;
    }

//pat04, begin
//#if  0  //0
#if (_WIN32_WINNT < 0x0400)
#ifdef PANNING_SCROLL
    if (psoColor != NULL) {
        vSetCPointerBits(ppdev, 0, 0);
        return (SPS_ACCEPT_EXCLUDE); //ppp
    }
#endif
#endif
//#endif  //0
//pat04, end

    vSetPointerBits(ppdev, 0, 0);

    // The previous call left the pointer disabled (at our request).  If we
    // were told to disable the pointer, then set the flag and exit.
    // Otherwise, turn it back on.

    if (x != -1)
    {
        CP_PTR_ENABLE(ppdev, pjPorts);
        DrvMovePointer(pso, x, y, NULL);
    }
    else
    {
        CP_PTR_DISABLE(ppdev, pjPorts);
    }

    return (SPS_ACCEPT_NOEXCLUDE);
}

/******************************Public*Routine******************************\
* VOID vDisablePointer
*
\**************************************************************************/

VOID vDisablePointer(
    PDEV*   ppdev)
{
    DISPDBG((2,"vDisablePointer\n "));
    FREE(ppdev->pjPointerAndMask);
    FREE(ppdev->pjPointerXorMask);
}


//crus begin
//myf11, begin fixed M1 H/W bug
/******************************Public*Routine******************************\
* BOOL vAsserthwiconcurorsor
*
\**************************************************************************/

VOID vAssertHWiconcursor(
PDEV*   ppdev,
BOOL    Access_flag)
{
    PBYTE   pjPorts = ppdev->pjPorts;
    UCHAR   savSEQidx;

    savSEQidx = CP_IN_BYTE(pjPorts, SR_INDEX);
    if (Access_flag)            //enable HW cursor, icons
    {
        CP_OUT_BYTE(pjPorts, SR_INDEX, 0X12);
        CP_OUT_BYTE(pjPorts, SR_DATA, HWcur);

        CP_OUT_BYTE(pjPorts, SR_INDEX, 0X2A);
        CP_OUT_BYTE(pjPorts, SR_DATA, HWicon0);

        CP_OUT_BYTE(pjPorts, SR_INDEX, 0X2B);
        CP_OUT_BYTE(pjPorts, SR_DATA, HWicon1);

        CP_OUT_BYTE(pjPorts, SR_INDEX, 0X2C);
        CP_OUT_BYTE(pjPorts, SR_DATA, HWicon2);

        CP_OUT_BYTE(pjPorts, SR_INDEX, 0X2D);
        CP_OUT_BYTE(pjPorts, SR_DATA, HWicon3);

    }
    else                        //disable HW cursor, icons
    {
        CP_OUT_BYTE(pjPorts, SR_INDEX, 0X12);
        HWcur = CP_IN_BYTE(pjPorts, SR_DATA);
        CP_OUT_BYTE(pjPorts, SR_DATA, (HWcur & 0xFE));

        CP_OUT_BYTE(pjPorts, SR_INDEX, 0X2A);
        HWicon0 = CP_IN_BYTE(pjPorts, SR_DATA);
        CP_OUT_BYTE(pjPorts, SR_DATA, (HWicon0 & 0xFE));

        CP_OUT_BYTE(pjPorts, SR_INDEX, 0X2B);
        HWicon1 = CP_IN_BYTE(pjPorts, SR_DATA);
        CP_OUT_BYTE(pjPorts, SR_DATA, (HWicon1 & 0xFE));

        CP_OUT_BYTE(pjPorts, SR_INDEX, 0X2C);
        HWicon2 = CP_IN_BYTE(pjPorts, SR_DATA);
        CP_OUT_BYTE(pjPorts, SR_DATA, (HWicon2 & 0xFE));

        CP_OUT_BYTE(pjPorts, SR_INDEX, 0X2D);
        HWicon3 = CP_IN_BYTE(pjPorts, SR_DATA);
        CP_OUT_BYTE(pjPorts, SR_DATA, (HWicon3 & 0xFE));

    }
    CP_OUT_BYTE(pjPorts, SR_INDEX, savSEQidx);

}

//myf11, end
//crus end


/******************************Public*Routine******************************\
* VOID vAssertModePointer
*
\**************************************************************************/

VOID vAssertModePointer(
PDEV*   ppdev,
BOOL    bEnable)
{
    PBYTE   pjPorts = ppdev->pjPorts;
//crus
    UCHAR       savSEQidx;      //myf11

    DISPDBG((2,"vAssertModePointer\n"));
    if (DRIVER_PUNT_ALL ||
        DRIVER_PUNT_PTR ||
        (ppdev->pulXfer == NULL) ||
        (ppdev->pjPointerAndMask == NULL) ||
        (ppdev->pjPointerXorMask == NULL))
    {
        //
        // Force SW cursor
        //

        ppdev->flCaps |= CAPS_SW_POINTER;
    }

    if (ppdev->flCaps & CAPS_SW_POINTER)
    {
        goto Leave;
    }

    if (bEnable)
    {
        BYTE    jSavedDac_0_0;
        BYTE    jSavedDac_0_1;
        BYTE    jSavedDac_0_2;
        BYTE    jSavedDac_F_0;
        BYTE    jSavedDac_F_1;
        BYTE    jSavedDac_F_2;

        // Enable access to the extended DAC colors.

//crus
//      vAsserthwiconcursor(ppdev, 0);       //myf11
/*  {
    savSEQidx = CP_IN_BYTE(pjPorts, SR_INDEX);
        CP_OUT_BYTE(pjPorts, SR_INDEX, 0X12);
        HWcur = CP_IN_BYTE(pjPorts, SR_DATA);
        CP_OUT_BYTE(pjPorts, SR_DATA, (HWcur & 0xFE));

        CP_OUT_BYTE(pjPorts, SR_INDEX, 0X2A);
        HWicon0 = CP_IN_BYTE(pjPorts, SR_DATA);
        CP_OUT_BYTE(pjPorts, SR_DATA, (HWicon0 & 0xFE));

        CP_OUT_BYTE(pjPorts, SR_INDEX, 0X2B);
        HWicon1 = CP_IN_BYTE(pjPorts, SR_DATA);
        CP_OUT_BYTE(pjPorts, SR_DATA, (HWicon1 & 0xFE));

        CP_OUT_BYTE(pjPorts, SR_INDEX, 0X2C);
        HWicon2 = CP_IN_BYTE(pjPorts, SR_DATA);
        CP_OUT_BYTE(pjPorts, SR_DATA, (HWicon2 & 0xFE));

        CP_OUT_BYTE(pjPorts, SR_INDEX, 0X2D);
        HWicon3 = CP_IN_BYTE(pjPorts, SR_DATA);
        CP_OUT_BYTE(pjPorts, SR_DATA, (HWicon3 & 0xFE));

    CP_OUT_BYTE(pjPorts, SR_INDEX, savSEQidx);
    }
*/

        CP_PTR_SET_FLAGS(ppdev, pjPorts, 0);

        CP_OUT_BYTE(pjPorts, DAC_PEL_READ_ADDR, 0);
            jSavedDac_0_0 = CP_IN_BYTE(pjPorts, DAC_PEL_DATA);
            jSavedDac_0_1 = CP_IN_BYTE(pjPorts, DAC_PEL_DATA);
            jSavedDac_0_2 = CP_IN_BYTE(pjPorts, DAC_PEL_DATA);

        CP_OUT_BYTE(pjPorts, DAC_PEL_READ_ADDR, 0xf);
            jSavedDac_F_0 = CP_IN_BYTE(pjPorts, DAC_PEL_DATA);
            jSavedDac_F_1 = CP_IN_BYTE(pjPorts, DAC_PEL_DATA);
            jSavedDac_F_2 = CP_IN_BYTE(pjPorts, DAC_PEL_DATA);

        //
        // The following code maps DAC locations 256 and 257 to locations
        // 0 and 15 respectively, and then initializes them.  They are
        // used by the cursor.
        //

        CP_PTR_SET_FLAGS(ppdev, pjPorts, ALLOW_DAC_ACCESS_TO_EXT_COLORS);

        CP_OUT_BYTE(pjPorts, DAC_PEL_WRITE_ADDR, 0);
            CP_OUT_BYTE(pjPorts, DAC_PEL_DATA, 0);
            CP_OUT_BYTE(pjPorts, DAC_PEL_DATA, 0);
            CP_OUT_BYTE(pjPorts, DAC_PEL_DATA, 0);

        CP_OUT_BYTE(pjPorts, DAC_PEL_WRITE_ADDR, 0xf);
            CP_OUT_BYTE(pjPorts, DAC_PEL_DATA, 0xff);
            CP_OUT_BYTE(pjPorts, DAC_PEL_DATA, 0xff);
            CP_OUT_BYTE(pjPorts, DAC_PEL_DATA, 0xff);

        // Disable access to the extended DAC registers.
        // We are using a 32 X 32 pointer in last position in video memory.

        CP_PTR_SET_FLAGS(ppdev, pjPorts, 0);

        //
        // The following code restores the data at DAC locations 0 and 15
        // because it looks like the previous writes destroyed them.
        // That is a bug in the chip.
        //

        CP_OUT_BYTE(pjPorts, DAC_PEL_WRITE_ADDR, 0);
            CP_OUT_BYTE(pjPorts, DAC_PEL_DATA, jSavedDac_0_0);
            CP_OUT_BYTE(pjPorts, DAC_PEL_DATA, jSavedDac_0_1);
            CP_OUT_BYTE(pjPorts, DAC_PEL_DATA, jSavedDac_0_2);

        CP_OUT_BYTE(pjPorts, DAC_PEL_WRITE_ADDR, 0xf);
            CP_OUT_BYTE(pjPorts, DAC_PEL_DATA, jSavedDac_F_0);
            CP_OUT_BYTE(pjPorts, DAC_PEL_DATA, jSavedDac_F_1);
            CP_OUT_BYTE(pjPorts, DAC_PEL_DATA, jSavedDac_F_2);

        //
        // Set HW pointer to use last HW pattern location
        //

        CP_PTR_ADDR(ppdev, ppdev->pjPorts, 0x3f);
//crus
//      vAsserthwiconcursor(ppdev, 1);       //myf11
    }
    else
    {
        CP_PTR_DISABLE(ppdev, pjPorts);
    }

Leave:
    return;
}

/******************************Public*Routine******************************\
* BOOL bEnablePointer
*
\**************************************************************************/

BOOL bEnablePointer(
PDEV*   ppdev)
{
    PBYTE   pjPorts = ppdev->pjPorts;
    DISPDBG((2,"bEnablePointer\n "));

    ///////////////////////////////////////////////////////////////////////
    // Note: flCaps is overwritten during an vAsserModeHardware.  So, any
    // failures that disable the pointer need to be re-checked during
    // vAssertModePointer so that we can re-set the CAPS_SW_POINTER flag.

    if (DRIVER_PUNT_ALL || DRIVER_PUNT_PTR || (ppdev->pulXfer == NULL))
    {
        //
        // Force SW cursor
        //

        ppdev->flCaps |= CAPS_SW_POINTER;
    }

    if (ppdev->flCaps & CAPS_SW_POINTER)
    {
        goto ReturnSuccess;
    }

    ppdev->pjPointerAndMask = ALLOC(128);
    if (ppdev->pjPointerAndMask == NULL)
    {
        DISPDBG((0, "bEnablePointer: Failed - EngAllocMem (pjAndMask)"));
        ppdev->flCaps |= CAPS_SW_POINTER;
        goto ReturnSuccess;
    }

    ppdev->pjPointerXorMask = ALLOC(128);
    if (ppdev->pjPointerXorMask == NULL)
    {
        DISPDBG((0, "bEnablePointer: Failed - EngAllocMem (pjXorMask)"));
        ppdev->flCaps |= CAPS_SW_POINTER;
        goto ReturnSuccess;
    }

    ppdev->flPointer = POINTER_DISABLED;

    vAssertModePointer(ppdev, TRUE);

ReturnSuccess:

    if (ppdev->flCaps & CAPS_SW_POINTER)
    {
        DISPDBG((2, "Using software pointer"));
    }
    else
    {
        DISPDBG((2, "Using hardware pointer"));
    }

    return(TRUE);
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\cirrus\disp\stretch.c ===
/******************************************************************************\
*
* $Workfile:   stretch.c  $
*
* DrvStretchBlt function.
*
* Copyright (c) 1993-1995 Microsoft Corporation
* Copyright (c) 1996 Cirrus Logic, Inc.
*
* $Log:   S:/projects/drivers/ntsrc/display/STRETCH.C_V  $
 *
 *    Rev 1.3   10 Jan 1997 15:40:16   PLCHU
 *
 *
 *    Rev 1.2   Nov 07 1996 16:48:04   unknown
 *
 *
 *    Rev 1.1   Oct 10 1996 15:39:02   unknown
 *
*
*    Rev 1.1   12 Aug 1996 16:55:00   frido
* Removed unaccessed local variables.
*
*  chu01  : 01-02-97   5480 BitBLT enhancement
*
\******************************************************************************/

#include "precomp.h"

#define STRETCH_MAX_EXTENT 32767

typedef DWORDLONG ULONGLONG;

/******************************Public*Routine******************************\
*
* Routine Name
*
*   vDirectStretch8Narrow
*
* Routine Description:
*
*   Stretch blt 8->8 when the width is 7 or less
*
* Arguments:
*
*   pStrBlt - contains all params for blt
*
* Return Value:
*
*   VOID
*
\**************************************************************************/

VOID vDirectStretch8Narrow(
STR_BLT* pStrBlt)
{
    BYTE*   pjSrc;
    ULONG   xAccum;
    ULONG   xTmp;

    LONG    xDst        = pStrBlt->XDstStart;
    LONG    xSrc        = pStrBlt->XSrcStart;
    BYTE*   pjSrcScan   = pStrBlt->pjSrcScan + xSrc;
    BYTE*   pjDst       = pStrBlt->pjDstScan + xDst;
    LONG    yCount      = pStrBlt->YDstCount;
    LONG    WidthX      = pStrBlt->XDstEnd - xDst;
    ULONG   xInt        = pStrBlt->ulXDstToSrcIntCeil;
    ULONG   xFrac       = pStrBlt->ulXDstToSrcFracCeil;
    ULONG   yAccum      = pStrBlt->ulYFracAccumulator;
    ULONG   yFrac       = pStrBlt->ulYDstToSrcFracCeil;
    LONG    lDstStride  = pStrBlt->lDeltaDst - WidthX;
    ULONG   yInt        = 0;

    yInt = pStrBlt->lDeltaSrc * pStrBlt->ulYDstToSrcIntCeil;

    //
    // Narrow blt
    //

    do {

        ULONG  yTmp = yAccum + yFrac;
        BYTE   jSrc0;
        BYTE*  pjDstEndNarrow = pjDst + WidthX;

        pjSrc   = pjSrcScan;
        xAccum  = pStrBlt->ulXFracAccumulator;

        do {
            jSrc0    = *pjSrc;
            xTmp     = xAccum + xFrac;
            pjSrc    = pjSrc + xInt + (xTmp < xAccum);
            *pjDst++ = jSrc0;
            xAccum   = xTmp;
        } while (pjDst != pjDstEndNarrow);

        pjSrcScan += yInt;

        if (yTmp < yAccum)
        {
            pjSrcScan += pStrBlt->lDeltaSrc;
        }

        yAccum = yTmp;
        pjDst += lDstStride;

    } while (--yCount);

}

/******************************Public*Routine******************************\
*
* Routine Description:
*
*   StretchBlt using integer math. Must be from one surface to another
*   surface of the same format.
*
* Arguments:
*
*   ppdev           -   PDEV for device
*   pvDst           -   Pointer to start of dst bitmap
*   lDeltaDst       -   Bytes from start of dst scan line to start of next
*   DstCx           -   Width of Dst Bitmap in pixels
*   DstCy           -   Height of Dst Bitmap in pixels
*   prclDst         -   Pointer to rectangle of Dst extents
*   pvSrc           -   Pointer to start of Src bitmap
*   lDeltaSrc       -   Bytes from start of Src scan line to start of next
*   SrcCx           -   Width of Src Bitmap in pixels
*   SrcCy           -   Height of Src Bitmap in pixels
*   prclSrc         -   Pointer to rectangle of Src extents
*   prclSClip       -   Clip Dest to this rect
*
* Return Value:
*
*   Status
*
\**************************************************************************/

BOOL bStretchDIB(
PDEV*   ppdev,
VOID*   pvDst,
LONG    lDeltaDst,
RECTL*  prclDst,
VOID*   pvSrc,
LONG    lDeltaSrc,
RECTL*  prclSrc,
RECTL*  prclClip)
{
    STR_BLT StrBlt;
    ULONG   ulXDstToSrcIntCeil;
    ULONG   ulXDstToSrcFracCeil;
    ULONG   ulYDstToSrcIntCeil;
    ULONG   ulYDstToSrcFracCeil;
    ULONG   ulXFracAccumulator;
    ULONG   ulYFracAccumulator;
    LONG    LeftClipDistance;
    LONG    TopClipDistance;
    BOOL    bStretch;

    union {
        LARGE_INTEGER   large;
        ULONGLONG       li;
    } liInit;

    PFN_DIRSTRETCH      pfnStr;

    //
    // Calculate exclusive start and end points:
    //

    LONG    WidthDst  = prclDst->right  - prclDst->left;
    LONG    HeightDst = prclDst->bottom - prclDst->top;
    LONG    WidthSrc  = prclSrc->right  - prclSrc->left;
    LONG    HeightSrc = prclSrc->bottom - prclSrc->top;

    LONG    XSrcStart = prclSrc->left;
    LONG    XSrcEnd   = prclSrc->right;
    LONG    XDstStart = prclDst->left;
    LONG    XDstEnd   = prclDst->right;
    LONG    YSrcStart = prclSrc->top;
    LONG    YSrcEnd   = prclSrc->bottom;
    LONG    YDstStart = prclDst->top;
    LONG    YDstEnd   = prclDst->bottom;

    //
    // Validate parameters:
    //

    ASSERTDD(pvDst != (VOID*)NULL, "Bad destination bitmap pointer");
    ASSERTDD(pvSrc != (VOID*)NULL, "Bad source bitmap pointer");
    ASSERTDD(prclDst != (RECTL*)NULL, "Bad destination rectangle");
    ASSERTDD(prclSrc != (RECTL*)NULL, "Bad source rectangle");
    ASSERTDD((WidthDst > 0) && (HeightDst > 0) &&
             (WidthSrc > 0) && (HeightSrc > 0),
             "Can't do mirroring or empty rectangles here");
    ASSERTDD((WidthDst  <= STRETCH_MAX_EXTENT) &&
             (HeightDst <= STRETCH_MAX_EXTENT) &&
             (WidthSrc  <= STRETCH_MAX_EXTENT) &&
             (HeightSrc <= STRETCH_MAX_EXTENT), "Stretch exceeds limits");
    ASSERTDD(prclClip != NULL, "Bad clip rectangle");

    //
    // Calculate X Dst to Src mapping
    //
    //
    // dst->src =  ( CEIL( (2k*WidthSrc)/WidthDst) ) / 2k
    //
    //          =  ( FLOOR(  (2k*WidthSrc -1) / WidthDst) + 1) / 2k
    //
    // where 2k = 2 ^ 32
    //

    {
        ULONGLONG   liWidthSrc;
        ULONGLONG   liQuo;
        ULONG       ulTemp;

        //
        // Work around a compiler bug dealing with the assignment
        // 'liHeightSrc = (((LONGLONG)HeightSrc) << 32) - 1':
        //

        liInit.large.LowPart = (ULONG) -1;
        liInit.large.HighPart = WidthSrc - 1;
        liWidthSrc = liInit.li;

        liQuo = liWidthSrc / (ULONGLONG) WidthDst;

        ulXDstToSrcIntCeil  = (ULONG)(liQuo >> 32);
        ulXDstToSrcFracCeil = (ULONG)liQuo;

        //
        // Now add 1, use fake carry:
        //

        ulTemp = ulXDstToSrcFracCeil + 1;

        ulXDstToSrcIntCeil += (ulTemp < ulXDstToSrcFracCeil);
        ulXDstToSrcFracCeil = ulTemp;
    }

    //
    // Calculate Y Dst to Src mapping
    //
    //
    // dst->src =  ( CEIL( (2k*HeightSrc)/HeightDst) ) / 2k
    //
    //          =  ( FLOOR(  (2k*HeightSrc -1) / HeightDst) + 1) / 2k
    //
    // where 2k = 2 ^ 32
    //

    {
        ULONGLONG   liHeightSrc;
        ULONGLONG   liQuo;
        ULONG       ulTemp;

        //
        // Work around a compiler bug dealing with the assignment
        // 'liHeightSrc = (((LONGLONG)HeightSrc) << 32) - 1':
        //

        liInit.large.LowPart = (ULONG) -1;
        liInit.large.HighPart = HeightSrc - 1;
        liHeightSrc = liInit.li;

        liQuo = liHeightSrc / (ULONGLONG) HeightDst;

        ulYDstToSrcIntCeil  = (ULONG)(liQuo >> 32);
        ulYDstToSrcFracCeil = (ULONG)liQuo;

        //
        // Now add 1, use fake carry:
        //

        ulTemp = ulYDstToSrcFracCeil + 1;

        ulYDstToSrcIntCeil += (ulTemp < ulYDstToSrcFracCeil);
        ulYDstToSrcFracCeil = ulTemp;
    }

    //
    // Now clip Dst in X, and/or calc src clipping effect on dst
    //
    // adjust left and right edges if needed, record
    // distance adjusted for fixing the src
    //

    if (XDstStart < prclClip->left)
    {
        XDstStart = prclClip->left;
    }

    if (XDstEnd > prclClip->right)
    {
        XDstEnd = prclClip->right;
    }

    //
    // Check for totally clipped out destination:
    //

    if (XDstEnd <= XDstStart)
    {
        return(TRUE);
    }

    LeftClipDistance = XDstStart - prclDst->left;

    {
        ULONG   ulTempInt;
        ULONG   ulTempFrac;

        //
        // Calculate displacement for .5 in destination and add:
        //

        ulTempFrac = (ulXDstToSrcFracCeil >> 1) | (ulXDstToSrcIntCeil << 31);
        ulTempInt  = (ulXDstToSrcIntCeil >> 1);

        XSrcStart += ulTempInt;
        ulXFracAccumulator = ulTempFrac;

        if (LeftClipDistance != 0)
        {
            ULONGLONG ullFraction;
            ULONG     ulTmp;

            ullFraction = UInt32x32To64(ulXDstToSrcFracCeil, LeftClipDistance);

            ulTmp = ulXFracAccumulator;
            ulXFracAccumulator += (ULONG) (ullFraction);
            if (ulXFracAccumulator < ulTmp)
                XSrcStart++;

            XSrcStart += (ulXDstToSrcIntCeil * LeftClipDistance)
                       + (ULONG) (ullFraction >> 32);
        }
    }

    //
    // Now clip Dst in Y, and/or calc src clipping effect on dst
    //
    // adjust top and bottom edges if needed, record
    // distance adjusted for fixing the src
    //

    if (YDstStart < prclClip->top)
    {
        YDstStart = prclClip->top;
    }

    if (YDstEnd > prclClip->bottom)
    {
        YDstEnd = prclClip->bottom;
    }

    //
    // Check for totally clipped out destination:
    //

    if (YDstEnd <= YDstStart)
    {
        return(TRUE);
    }

    TopClipDistance = YDstStart - prclDst->top;

    {
        ULONG   ulTempInt;
        ULONG   ulTempFrac;

        //
        // Calculate displacement for .5 in destination and add:
        //

        ulTempFrac = (ulYDstToSrcFracCeil >> 1) | (ulYDstToSrcIntCeil << 31);
        ulTempInt  = ulYDstToSrcIntCeil >> 1;

        YSrcStart += (LONG)ulTempInt;
        ulYFracAccumulator = ulTempFrac;

        if (TopClipDistance != 0)
        {
            ULONGLONG ullFraction;
            ULONG     ulTmp;

            ullFraction = UInt32x32To64(ulYDstToSrcFracCeil, TopClipDistance);

            ulTmp = ulYFracAccumulator;
            ulYFracAccumulator += (ULONG) (ullFraction);
            if (ulYFracAccumulator < ulTmp)
                YSrcStart++;

            YSrcStart += (ulYDstToSrcIntCeil * TopClipDistance)
                       + (ULONG) (ullFraction >> 32);
        }
    }

    //
    // Warm up the hardware if doing an expanding stretch in 'y':
    //

    bStretch = (HeightDst > HeightSrc);
    if (bStretch)
    {
        //
        // Set up the info that is constant during the StretchBlt
        //

        ppdev->pfnBankSelectMode(ppdev, BANK_ON);

        //
        // BankSelectMode(BANK_ON) guarentees that the last
        // blt is completed.  We don't need to wait.
        //

        if (ppdev->flCaps & CAPS_MM_IO)
        {
            BYTE*   pjBase  = ppdev->pjBase;

            CP_MM_BLT_MODE(ppdev, pjBase, 0);                   // GR30
            CP_MM_ROP(ppdev, pjBase, CL_SRC_COPY);              // GR32
            CP_MM_SRC_Y_OFFSET(ppdev, pjBase, lDeltaDst);       // GR26, GR27
            CP_MM_DST_Y_OFFSET(ppdev, pjBase, lDeltaDst);       // GR24, GR25
        }
        else
        {
            BYTE*   pjPorts  = ppdev->pjPorts;

            CP_IO_BLT_MODE(ppdev, pjPorts, 0);
            CP_IO_ROP(ppdev, pjPorts, CL_SRC_COPY);
            CP_IO_SRC_Y_OFFSET(ppdev, pjPorts, lDeltaDst);
            CP_IO_DST_Y_OFFSET(ppdev, pjPorts, lDeltaDst);
        }
    }

    //
    // Fill out blt structure, then call format-specific stretch code
    //

    StrBlt.ppdev     = ppdev;
    StrBlt.XDstEnd   = XDstEnd;
    StrBlt.YDstStart = YDstStart;
    StrBlt.YDstCount = YDstEnd - YDstStart;

    if (StrBlt.YDstCount > 0)
    {
        //
        // Caclulate starting scan line address.  Since the inner loop
        // routines are format dependent, they must add XDstStart/XSrcStart
        // to pjDstScan/pjSrcScan to get the actual starting pixel address.
        //

        StrBlt.pjSrcScan           = (BYTE*) pvSrc + (YSrcStart * lDeltaSrc);
        StrBlt.pjDstScan           = (BYTE*) pvDst + (YDstStart * lDeltaDst);

        StrBlt.lDeltaSrc           = lDeltaSrc;
        StrBlt.XSrcStart           = XSrcStart;
        StrBlt.XDstStart           = XDstStart;
        StrBlt.lDeltaDst           = lDeltaDst;
        StrBlt.ulXDstToSrcIntCeil  = ulXDstToSrcIntCeil;
        StrBlt.ulXDstToSrcFracCeil = ulXDstToSrcFracCeil;
        StrBlt.ulYDstToSrcIntCeil  = ulYDstToSrcIntCeil;
        StrBlt.ulYDstToSrcFracCeil = ulYDstToSrcFracCeil;
        StrBlt.ulXFracAccumulator  = ulXFracAccumulator;
        StrBlt.ulYFracAccumulator  = ulYFracAccumulator;

// chu01
        if ((ppdev->flCaps & CAPS_COMMAND_LIST) && (ppdev->pCommandList != NULL))
        {
            if (ppdev->iBitmapFormat == BMF_8BPP)
            {
                if ((XDstEnd - XDstStart) < 7)
                    pfnStr = vDirectStretch8Narrow;
                else
                    pfnStr = vDirectStretch8_80;
            }
            else if (ppdev->iBitmapFormat == BMF_16BPP)
            {
                pfnStr = vDirectStretch16_80;
            }
            else
            {
                ASSERTDD(ppdev->iBitmapFormat == BMF_24BPP,
                         "Only handle stretches at 8/16/24bpp");
                pfnStr = vDirectStretch24_80;
            }
        }
        else
        {
            if (ppdev->iBitmapFormat == BMF_8BPP)
            {
                if ((XDstEnd - XDstStart) < 7)
                    pfnStr = vDirectStretch8Narrow;
                else
                    pfnStr = vDirectStretch8;
            }
            else if (ppdev->iBitmapFormat == BMF_16BPP)
            {
                pfnStr = vDirectStretch16;
            }
            else
            {
                ASSERTDD(ppdev->iBitmapFormat == BMF_24BPP,
                         "Only handle stretches at 8/16/24bpp");
                pfnStr = vDirectStretch24;
            }
        }

        (*pfnStr)(&StrBlt);
    }

    return(TRUE);
}

/******************************Public*Routine******************************\
* BOOL bBankedStretch
*
\**************************************************************************/

BOOL bBankedStretch(
PDEV*   ppdev,
VOID*   pvDst,
LONG    lDeltaDst,
RECTL*  prclDst,
VOID*   pvSrc,
LONG    lDeltaSrc,
RECTL*  prclSrc,
RECTL*  prclClip)
{
    BANK    bnk;
    BOOL    b;
    RECTL   rclDst;

    b = TRUE;
    if (bIntersect(prclDst, prclClip, &rclDst))
    {
        vBankStart(ppdev, &rclDst, NULL, &bnk);

        do {
            b &= bStretchDIB(ppdev,
                             bnk.pso->pvScan0,
                             lDeltaDst,
                             prclDst,
                             pvSrc,
                             lDeltaSrc,
                             prclSrc,
                             &bnk.pco->rclBounds);

        } while (bBankEnum(&bnk));
    }

    return(b);
}

/******************************Public*Routine******************************\
* BOOL DrvStretchBlt
*
\**************************************************************************/

BOOL DrvStretchBlt(
SURFOBJ*            psoDst,
SURFOBJ*            psoSrc,
SURFOBJ*            psoMsk,
CLIPOBJ*            pco,
XLATEOBJ*           pxlo,
COLORADJUSTMENT*    pca,
POINTL*             pptlHTOrg,
RECTL*              prclDst,
RECTL*              prclSrc,
POINTL*             pptlMsk,
ULONG               iMode)
{
    DSURF*  pdsurfSrc;
    DSURF*  pdsurfDst;
    PDEV*   ppdev;
    OH*     poh;

    // GDI guarantees us that for a StretchBlt the destination surface
    // will always be a device surface, and not a DIB:

    ppdev = (PDEV*) psoDst->dhpdev;

    if (!DIRECT_ACCESS(ppdev))
    {
        goto Punt_It;
    }

    // It's quicker for GDI to do a StretchBlt when the source surface
    // is not a device-managed surface, because then it can directly
    // read the source bits without having to allocate a temporary
    // buffer and call DrvCopyBits to get a copy that it can use.

    if (psoSrc->iType == STYPE_DEVBITMAP)
    {
        pdsurfSrc = (DSURF*) psoSrc->dhsurf;
        if (pdsurfSrc->dt == DT_SCREEN)
        {
            goto Punt_It;
        }

        ASSERTDD(pdsurfSrc->dt == DT_DIB, "Can only handle DIB DFBs here");

        psoSrc = pdsurfSrc->pso;
    }

    pdsurfDst = (DSURF*) psoDst->dhsurf;
    if (pdsurfDst->dt == DT_DIB)
    {
        // The destination was a device bitmap that we just converted
        // to a DIB:

        psoDst = pdsurfDst->pso;
        goto Punt_It;
    }

    poh             = pdsurfDst->poh;
    ppdev->xOffset  = poh->x;
    ppdev->yOffset  = poh->y;
    ppdev->xyOffset = poh->xy;

    {
        RECTL       rclClip;
        RECTL*      prclClip;
        ULONG       cxDst;
        ULONG       cyDst;
        ULONG       cxSrc;
        ULONG       cySrc;
        BOOL        bMore;
        CLIPENUM    ce;
        LONG        c;
        LONG        i;

        if ((psoSrc->iType == STYPE_BITMAP) &&
            (psoMsk == NULL) &&
            ((pxlo == NULL) || (pxlo->flXlate & XO_TRIVIAL)) &&
            ((psoSrc->iBitmapFormat == ppdev->iBitmapFormat)) &&
            (ppdev->iBitmapFormat <= BMF_24BPP))
        {
            cxDst = prclDst->right - prclDst->left;
            cyDst = prclDst->bottom - prclDst->top;
            cxSrc = prclSrc->right - prclSrc->left;
            cySrc = prclSrc->bottom - prclSrc->top;

            // Our 'bStretchDIB' routine requires that the stretch be
            // non-inverting, within a certain size, to have no source
            // clipping, and to have no empty rectangles (the latter is the
            // reason for the '- 1' on the unsigned compare here):

            if (((cxSrc - 1) < STRETCH_MAX_EXTENT)         &&
                ((cySrc - 1) < STRETCH_MAX_EXTENT)         &&
                ((cxDst - 1) < STRETCH_MAX_EXTENT)         &&
                ((cyDst - 1) < STRETCH_MAX_EXTENT)         &&
                (prclSrc->left   >= 0)                     &&
                (prclSrc->top    >= 0)                     &&
                (prclSrc->right  <= psoSrc->sizlBitmap.cx) &&
                (prclSrc->bottom <= psoSrc->sizlBitmap.cy))
            {
                // Our snazzy routine only does COLORONCOLOR.  But for
                // stretching blts, BLACKONWHITE and WHITEONBLACK are also
                // equivalent to COLORONCOLOR:

                if ((iMode == COLORONCOLOR) ||
                    ((iMode < COLORONCOLOR) && (cxSrc <= cxDst) && (cySrc <= cyDst)))
                {

                    if ((pco == NULL) || (pco->iDComplexity == DC_TRIVIAL))
                    {
                        rclClip.left   = LONG_MIN;
                        rclClip.top    = LONG_MIN;
                        rclClip.right  = LONG_MAX;
                        rclClip.bottom = LONG_MAX;
                        prclClip = &rclClip;

                    StretchSingleClipRect:

                        if (bBankedStretch(ppdev,
                                        NULL,
                                        ppdev->lDelta,
                                        prclDst,
                                        psoSrc->pvScan0,
                                        psoSrc->lDelta,
                                        prclSrc,
                                        prclClip))
                        {
                            return(TRUE);
                        }
                    }
                    else if (pco->iDComplexity == DC_RECT)
                    {
                        prclClip = &pco->rclBounds;
                        goto StretchSingleClipRect;
                    }
                    else
                    {
                        CLIPOBJ_cEnumStart(pco, FALSE, CT_RECTANGLES, CD_ANY, 0);

                        do {
                            bMore = CLIPOBJ_bEnum(pco, sizeof(ce), (ULONG*) &ce);

                            c = cIntersect(prclDst, ce.arcl, ce.c);

                            if (c != 0)
                            {
                                for (i = 0; i < c; i++)
                                {
                                    if (!bBankedStretch(ppdev,
                                                     NULL,
                                                     ppdev->lDelta,
                                                     prclDst,
                                                     psoSrc->pvScan0,
                                                     psoSrc->lDelta,
                                                     prclSrc,
                                                     &ce.arcl[i]))
                                    {
                                        goto Punt_It;
                                    }
                                }
                            }

                        } while (bMore);

                        return(TRUE);
                    }
                }
            }
        }
    }

Punt_It:

    // GDI is nice enough to handle the cases where 'psoDst' and/or 'psoSrc'
    // are device-managed surfaces, but it ain't gonna be fast...

    return(EngStretchBlt(psoDst, psoSrc, psoMsk, pco, pxlo, pca, pptlHTOrg,
                         prclDst, prclSrc, pptlMsk, iMode));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\cirrus\disp\str.c ===
/******************************************************************************\
*
* $Workfile:   str.c  $
*
* Copyright (c) 1993-1997 Microsoft Corporation
* Copyright (c) 1996-1997 Cirrus Logic, Inc.,
*
* $Log:   S:/projects/drivers/ntsrc/display/STR.C_V  $
 * 
 *    Rev 1.3   10 Jan 1997 15:40:16   PLCHU
 *  
 * 
 *    Rev 1.2   Nov 01 1996 16:52:02   unknown
 * 
 *    Rev 1.1   Oct 10 1996 15:38:58   unknown
* 
*    Rev 1.1   12 Aug 1996 16:54:52   frido
* Removed unaccessed local variables.
* 
*    sge01  : 11-01-96  Fix 24bpp stretch address calculation problem
*    chu01  : 01-02-97  5480 BitBLT enhacement
*  
\******************************************************************************/

#include "precomp.h"

/******************************Public*Routine******************************\
*
* Routine Name
*
*   vDirectStretch8
*
* Routine Description:
*
*   Stretch blt 8->8
*
* NOTE: This routine doesn't handle cases where the blt stretch starts
*       and ends in the same destination dword!  vDirectStretchNarrow
*       is expected to have been called for that case.
*
* Arguments:
*
*   pStrBlt - contains all params for blt
*
* Return Value:
*
*   VOID
*
\**************************************************************************/

VOID vDirectStretch8(
STR_BLT* pStrBlt)
{
    BYTE*   pjSrc;
    BYTE*   pjDstEnd;
    LONG    WidthXAln;
    ULONG   ulDst;
    ULONG   xAccum;
    ULONG   xTmp;
    BYTE*   pjOldScan;
    LONG    cyDuplicate;

    PDEV*   ppdev       = pStrBlt->ppdev;
    LONG    xDst        = pStrBlt->XDstStart;
    LONG    xSrc        = pStrBlt->XSrcStart;
    BYTE*   pjSrcScan   = pStrBlt->pjSrcScan + xSrc;
    BYTE*   pjDst       = pStrBlt->pjDstScan + xDst;
    LONG    yDst        = pStrBlt->YDstStart; // + ppdev->yOffset;
    LONG    yCount      = pStrBlt->YDstCount;
    ULONG   StartAln    = (ULONG)((ULONG_PTR)pjDst & 0x03);
    LONG    WidthX      = pStrBlt->XDstEnd - xDst;
    ULONG   EndAln      = (ULONG)((ULONG_PTR)(pjDst + WidthX) & 0x03);
    ULONG   xInt        = pStrBlt->ulXDstToSrcIntCeil;
    ULONG   xFrac       = pStrBlt->ulXDstToSrcFracCeil;
    ULONG   yAccum      = pStrBlt->ulYFracAccumulator;
    ULONG   yFrac       = pStrBlt->ulYDstToSrcFracCeil;
    ULONG   yInt        = 0;
    LONG    lDstStride  = pStrBlt->lDeltaDst - WidthX;

    BYTE*   pjPorts     = ppdev->pjPorts;
    BYTE*   pjBase      = ppdev->pjBase;
    LONG    lDelta      = ppdev->lDelta;
    LONG    xyOffset    = ppdev->xyOffset;
    LONG    xDstBytes   = xDst;
    LONG    WidthXBytes = WidthX;

    WidthXAln = WidthX - EndAln - ((- (LONG) StartAln) & 0x03);

    //
    // if this is a shrinking blt, calc src scan line stride
    //

    if (pStrBlt->ulYDstToSrcIntCeil != 0)
    {
        yInt = pStrBlt->lDeltaSrc * pStrBlt->ulYDstToSrcIntCeil;
    }

    //
    // loop drawing each scan line
    //
    //
    // at least 7 wide (DST) blt
    //

    do {
        BYTE    jSrc0,jSrc1,jSrc2,jSrc3;
        ULONG   yTmp;

        pjSrc   = pjSrcScan;
        xAccum  = pStrBlt->ulXFracAccumulator;

        //
        // a single src scan line is being written
        //

        if (ppdev->flCaps & CAPS_MM_IO)
        {
            CP_MM_WAIT_FOR_BLT_COMPLETE(ppdev, pjBase);
        }
        else
        {
            CP_IO_WAIT_FOR_BLT_COMPLETE(ppdev, pjPorts);
        }

        switch (StartAln) {
        case 1:
            jSrc0 = *pjSrc;
            xTmp = xAccum + xFrac;
            pjSrc = pjSrc + xInt + (xTmp < xAccum);
            *pjDst++ = jSrc0;
            xAccum = xTmp;
        case 2:
            jSrc0 = *pjSrc;
            xTmp = xAccum + xFrac;
            pjSrc = pjSrc + xInt + (xTmp < xAccum);
            *pjDst++ = jSrc0;
            xAccum = xTmp;
        case 3:
            jSrc0 = *pjSrc;
            xTmp = xAccum + xFrac;
            pjSrc = pjSrc + xInt + (xTmp < xAccum);
            *pjDst++ = jSrc0;
            xAccum = xTmp;
        }

        pjDstEnd  = pjDst + WidthXAln;

        while (pjDst != pjDstEnd)
        {
            jSrc0 = *pjSrc;
            xTmp = xAccum + xFrac;
            pjSrc = pjSrc + xInt + (xTmp < xAccum);

            jSrc1 = *pjSrc;
            xAccum = xTmp + xFrac;
            pjSrc = pjSrc + xInt + (xAccum < xTmp);

            jSrc2 = *pjSrc;
            xTmp = xAccum + xFrac;
            pjSrc = pjSrc + xInt + (xTmp < xAccum);

            jSrc3 = *pjSrc;
            xAccum = xTmp + xFrac;
            pjSrc = pjSrc + xInt + (xAccum < xTmp);

            ulDst = (jSrc3 << 24) | (jSrc2 << 16) | (jSrc1 << 8) | jSrc0;

            *(PULONG)pjDst = ulDst;
            pjDst += 4;
        }

        switch (EndAln) {
        case 3:
            jSrc0 = *pjSrc;
            xTmp = xAccum + xFrac;
            pjSrc = pjSrc + xInt + (xTmp < xAccum);
            *pjDst++ = jSrc0;
            xAccum = xTmp;
        case 2:
            jSrc0 = *pjSrc;
            xTmp = xAccum + xFrac;
            pjSrc = pjSrc + xInt + (xTmp < xAccum);
            *pjDst++ = jSrc0;
            xAccum = xTmp;
        case 1:
            jSrc0 = *pjSrc;
            xTmp = xAccum + xFrac;
            pjSrc = pjSrc + xInt + (xTmp < xAccum);
            *pjDst++ = jSrc0;
        }

        pjOldScan = pjSrcScan;
        pjSrcScan += yInt;

        yTmp = yAccum + yFrac;
        if (yTmp < yAccum)
        {
            pjSrcScan += pStrBlt->lDeltaSrc;
        }
        yAccum = yTmp;

        pjDst = (pjDst + lDstStride);
        yDst++;
        yCount--;

        if ((yCount != 0) && (pjSrcScan == pjOldScan))
        {
            // It's an expanding stretch in 'y'; the scan we just laid down
            // will be copied at least once using the hardware:

            cyDuplicate = 0;
            do {
                cyDuplicate++;
                pjSrcScan += yInt;

                yTmp = yAccum + yFrac;
                if (yTmp < yAccum)
                {
                    pjSrcScan += pStrBlt->lDeltaSrc;
                }
                yAccum = yTmp;

                pjDst = (pjDst + pStrBlt->lDeltaDst);
                yCount--;

            } while ((yCount != 0) && (pjSrcScan == pjOldScan));

            // The scan is to be copied 'cyDuplicate' times using the
            // hardware.

            //
            // We don't need to WAIT_FOR_BLT_COMPLETE since we did it above.
            //

            if (ppdev->flCaps & CAPS_MM_IO)
            {
                CP_MM_XCNT(ppdev, pjBase, (WidthXBytes - 1));
                CP_MM_YCNT(ppdev, pjBase, (cyDuplicate - 1));

                CP_MM_SRC_ADDR(ppdev, pjBase, (xyOffset + ((yDst - 1) * lDelta) + xDstBytes));
                CP_MM_DST_ADDR(ppdev, pjBase, ((yDst * lDelta) + xDstBytes));

                CP_MM_START_BLT(ppdev, pjBase);

            }
            else
            {
                CP_IO_XCNT(ppdev, pjPorts, (WidthXBytes - 1));
                CP_IO_YCNT(ppdev, pjPorts, (cyDuplicate - 1));

                CP_IO_SRC_ADDR(ppdev, pjPorts, (xyOffset + ((yDst - 1) * lDelta) + xDstBytes));
                CP_IO_DST_ADDR(ppdev, pjPorts, ((yDst * lDelta) + xDstBytes));
                CP_IO_START_BLT(ppdev, pjPorts);
            }

            yDst += cyDuplicate;
        }
    } while (yCount != 0);
}

/******************************Public*Routine******************************\
*
* Routine Name
*
*   vDirectStretch16
*
* Routine Description:
*
*   Stretch blt 16->16
*
* Arguments:
*
*   pStrBlt - contains all params for blt
*
* Return Value:
*
*   VOID
*
\**************************************************************************/

VOID vDirectStretch16(
STR_BLT* pStrBlt)
{
    BYTE*   pjOldScan;
    USHORT* pusSrc;
    USHORT* pusDstEnd;
    LONG    WidthXAln;
    ULONG   ulDst;
    ULONG   xAccum;
    ULONG   xTmp;
    LONG    cyDuplicate;

    PDEV*   ppdev       = pStrBlt->ppdev;
    LONG    xDst        = pStrBlt->XDstStart;
    LONG    xSrc        = pStrBlt->XSrcStart;
    BYTE*   pjSrcScan   = (pStrBlt->pjSrcScan) + xSrc * 2;
    USHORT* pusDst      = (USHORT*)(pStrBlt->pjDstScan) + xDst;
    LONG    yDst        = pStrBlt->YDstStart; // + ppdev->yOffset;
    LONG    yCount      = pStrBlt->YDstCount;
    ULONG   StartAln    = (ULONG)((ULONG_PTR)pusDst & 0x02) >> 1;
    LONG    WidthX      = pStrBlt->XDstEnd - xDst;
    ULONG   EndAln      = (ULONG)(((ULONG_PTR)(pusDst + WidthX) & 0x02) >> 1);
    ULONG   xInt        = pStrBlt->ulXDstToSrcIntCeil;
    ULONG   xFrac       = pStrBlt->ulXDstToSrcFracCeil;
    ULONG   yAccum      = pStrBlt->ulYFracAccumulator;
    ULONG   yFrac       = pStrBlt->ulYDstToSrcFracCeil;
    LONG    lDstStride  = pStrBlt->lDeltaDst - 2 * WidthX;
    ULONG   yInt        = 0;

    BYTE*   pjPorts     = ppdev->pjPorts;
    BYTE*   pjBase      = ppdev->pjBase;
    LONG    lDelta      = ppdev->lDelta;
    LONG    xyOffset    = ppdev->xyOffset;
    LONG    xDstBytes   = xDst * 2;
    LONG    WidthXBytes = WidthX * 2;

    WidthXAln = WidthX - EndAln - StartAln;

    //
    // if this is a shrinking blt, calc src scan line stride
    //

    if (pStrBlt->ulYDstToSrcIntCeil != 0)
    {
        yInt = pStrBlt->lDeltaSrc * pStrBlt->ulYDstToSrcIntCeil;
    }

    // Loop stretching each scan line

    do {
        USHORT  usSrc0,usSrc1;
        ULONG   yTmp;

        pusSrc  = (USHORT*) pjSrcScan;
        xAccum  = pStrBlt->ulXFracAccumulator;

        // A single source scan line is being written:

        if (ppdev->flCaps & CAPS_MM_IO)
        {
            CP_MM_WAIT_FOR_BLT_COMPLETE(ppdev, pjBase);
        }
        else
        {
            CP_IO_WAIT_FOR_BLT_COMPLETE(ppdev, pjPorts);
        }

        if (StartAln)
        {
            usSrc0    = *pusSrc;
            xTmp      = xAccum + xFrac;
            pusSrc    = pusSrc + xInt + (xTmp < xAccum);
            *pusDst++ = usSrc0;
            xAccum    = xTmp;
        }

        pusDstEnd  = pusDst + WidthXAln;

        while (pusDst != pusDstEnd)
        {

            usSrc0 = *pusSrc;
            xTmp   = xAccum + xFrac;
            pusSrc = pusSrc + xInt + (xTmp < xAccum);

            usSrc1 = *pusSrc;
            xAccum = xTmp + xFrac;
            pusSrc = pusSrc + xInt + (xAccum < xTmp);

            ulDst = (ULONG)((usSrc1 << 16) | usSrc0);

            *(ULONG*)pusDst = ulDst;
            pusDst+=2;
        }

        if (EndAln)
        {
            usSrc0    = *pusSrc;
            xTmp      = xAccum + xFrac;
            pusSrc    = pusSrc + xInt + (xTmp < xAccum);
            *pusDst++ = usSrc0;
        }

        pjOldScan = pjSrcScan;
        pjSrcScan += yInt;

        yTmp = yAccum + yFrac;
        if (yTmp < yAccum)
        {
            pjSrcScan += pStrBlt->lDeltaSrc;
        }
        yAccum = yTmp;

        pusDst = (USHORT*) ((BYTE*) pusDst + lDstStride);
        yDst++;
        yCount--;

        if ((yCount != 0) && (pjSrcScan == pjOldScan))
        {
            // It's an expanding stretch in 'y'; the scan we just laid down
            // will be copied at least once using the hardware:

            cyDuplicate = 0;
            do {
                cyDuplicate++;
                pjSrcScan += yInt;

                yTmp = yAccum + yFrac;
                if (yTmp < yAccum)
                {
                    pjSrcScan += pStrBlt->lDeltaSrc;
                }
                yAccum = yTmp;

                pusDst = (USHORT*) ((BYTE*) pusDst + pStrBlt->lDeltaDst);
                yCount--;

            } while ((yCount != 0) && (pjSrcScan == pjOldScan));

            // The scan is to be copied 'cyDuplicate' times using the
            // hardware.

            //
            // We don't need to WAIT_FOR_BLT_COMPLETE since we did it above.
            //

            if (ppdev->flCaps & CAPS_MM_IO)
            {
                CP_MM_XCNT(ppdev, pjBase, (WidthXBytes - 1)); 
                CP_MM_YCNT(ppdev, pjBase, (cyDuplicate - 1));

                CP_MM_SRC_ADDR(ppdev, pjBase, (xyOffset + ((yDst - 1) * lDelta) + xDstBytes));
                CP_MM_DST_ADDR(ppdev, pjBase, ((yDst * lDelta) + xDstBytes));

                CP_MM_START_BLT(ppdev, pjBase);

            }
            else
            {
                CP_IO_XCNT(ppdev, pjPorts, (WidthXBytes - 1));
                CP_IO_YCNT(ppdev, pjPorts, (cyDuplicate - 1));

                CP_IO_SRC_ADDR(ppdev, pjPorts, (xyOffset + ((yDst - 1) * lDelta) + xDstBytes));
                CP_IO_DST_ADDR(ppdev, pjPorts, ((yDst * lDelta) + xDstBytes));
                CP_IO_START_BLT(ppdev, pjPorts);
            }

            yDst += cyDuplicate;
        }
    } while (yCount != 0);
}

/******************************Public*Routine******************************\
*
* Routine Name
*
*   vDirectStretch24
*
* Routine Description:
*
*   Stretch blt 24->24
*
* Arguments:
*
*   pStrBlt - contains all params for blt
*
* Return Value:
*
*   VOID
*
\**************************************************************************/

VOID vDirectStretch24(
STR_BLT* pStrBlt)
{
    BYTE*   pbSrc;
    BYTE*   pbDstEnd; 
    LONG    WidthXAln;
    ULONG   xAccum;
    ULONG   xTmp;
    BYTE*   pjOldScan;
    LONG    cyDuplicate;
    ULONG   ulSrc0;
    BYTE    bDst0,bDst1,bDst2;
    ULONG   xBits;

    PDEV*   ppdev       = pStrBlt->ppdev;
    LONG    xDst        = pStrBlt->XDstStart;
    LONG    xSrc        = pStrBlt->XSrcStart;
    BYTE*   pjSrcScan   = (pStrBlt->pjSrcScan) + (xSrc << 1) + xSrc;                      // 3 bytes per pixel
    BYTE*   pbDST       = (pStrBlt->pjDstScan) + (xDst << 1) + xDst;                      
    LONG    yDst        = pStrBlt->YDstStart;                                                   // + ppdev->yOffset;
    LONG    yCount      = pStrBlt->YDstCount;
    LONG    WidthX      = pStrBlt->XDstEnd - xDst;
    ULONG   xInt        = pStrBlt->ulXDstToSrcIntCeil;
    ULONG   xFrac       = pStrBlt->ulXDstToSrcFracCeil;
    ULONG   yAccum      = pStrBlt->ulYFracAccumulator;
    ULONG   yFrac       = pStrBlt->ulYDstToSrcFracCeil;
    ULONG   yInt        = 0;
    LONG    lDstStride  = pStrBlt->lDeltaDst - (WidthX << 1) -  WidthX;

    BYTE*   pjPorts     = ppdev->pjPorts;
    BYTE*   pjBase      = ppdev->pjBase;
    LONG    lDelta      = ppdev->lDelta;
    LONG    xyOffset    = ppdev->xyOffset;
    LONG    xDstBytes   = (xDst << 1) +  xDst;

    LONG    WidthXBytes = (WidthX << 1) +  WidthX;

    //
    // if this is a shrinking blt, calc src scan line stride
    //

    if (pStrBlt->ulYDstToSrcIntCeil != 0)                       // enlargement ?
    {                                                                                                                   // yes.
        yInt = pStrBlt->lDeltaSrc * pStrBlt->ulYDstToSrcIntCeil;
    }

    // Loop stretching each scan line

    do {

        ULONG   yTmp;

        pbSrc  = pjSrcScan;
        xAccum  = pStrBlt->ulXFracAccumulator;

        // A single source scan line is being written:

        if (ppdev->flCaps & CAPS_MM_IO)                                         // Blt Engine Ready?
        {
            CP_MM_WAIT_FOR_BLT_COMPLETE(ppdev, pjBase);
        }
        else
        {
            CP_IO_WAIT_FOR_BLT_COMPLETE(ppdev, pjPorts);
        }

        pbDstEnd  = pbDST + WidthXBytes - 3;

        while (pbDST < pbDstEnd)
        {
            ulSrc0 = *((ULONG*)pbSrc);
            bDst0  = (BYTE) (ulSrc0 & 0xff);
            bDst1  = (BYTE) ((ulSrc0 >> 8) & 0xff);
            bDst2  = (BYTE) ((ulSrc0 >> 16) & 0xff);
            xTmp   = xAccum + xFrac;
            xBits  = xInt + (xTmp < xAccum); 
            xAccum = xTmp;
            pbSrc  += (xBits << 1) + xBits;

            *pbDST++ = bDst0;
            *pbDST++ = bDst1;
            *pbDST++ = bDst2;
        }
        
        //
        // do the last pixel using bye
        //
        *pbDST++  = *pbSrc++;
        *pbDST++  = *pbSrc++;
        *pbDST++  = *pbSrc++;


        pjOldScan = pjSrcScan;
        pjSrcScan += yInt;

        yTmp = yAccum + yFrac;
        if (yTmp < yAccum)
        {
            pjSrcScan += pStrBlt->lDeltaSrc;
        }
        yAccum = yTmp;

        pbDST += lDstStride;
        yDst++;
        yCount--;

        if ((yCount != 0) && (pjSrcScan == pjOldScan))
        {
            // It's an expanding stretch in 'y'; the scan we just laid down
            // will be copied at least once using the hardware:

            cyDuplicate = 0;
            do {
                cyDuplicate++;
                pjSrcScan += yInt;

                yTmp = yAccum + yFrac;
                if (yTmp < yAccum)
                {
                    pjSrcScan += pStrBlt->lDeltaSrc;
                }
                yAccum = yTmp;

                pbDST += pStrBlt->lDeltaDst;
                yCount--;

            } while ((yCount != 0) && (pjSrcScan == pjOldScan));

            // The scan is to be copied 'cyDuplicate' times using the
            // hardware.

            //
            // We don't need to WAIT_FOR_BLT_COMPLETE since we did it above.
            //

            if (ppdev->flCaps & CAPS_MM_IO)
            {
                CP_MM_XCNT(ppdev, pjBase, (WidthXBytes - 1));
                CP_MM_YCNT(ppdev, pjBase, (cyDuplicate - 1));

                CP_MM_SRC_ADDR(ppdev, pjBase, (xyOffset + ((yDst - 1) * lDelta) + xDstBytes));
                CP_MM_DST_ADDR(ppdev, pjBase, ((yDst * lDelta) + xDstBytes));

                CP_MM_START_BLT(ppdev, pjBase);

            }
            else
            {
                CP_IO_XCNT(ppdev, pjPorts, (WidthXBytes - 1));
                CP_IO_YCNT(ppdev, pjPorts, (cyDuplicate - 1));

                CP_IO_SRC_ADDR(ppdev, pjPorts, (xyOffset + ((yDst - 1) * lDelta) + xDstBytes));
                CP_IO_DST_ADDR(ppdev, pjPorts, ((yDst * lDelta) + xDstBytes));
                CP_IO_START_BLT(ppdev, pjPorts);
            }

            yDst += cyDuplicate;
        }
    } while (yCount != 0);
}

// chu01
/******************************Public*Routine******************************\
*
*     B i t B L T   E n h a n c e m e n t   F o r   C L - G D 5 4 8 0
*
\**************************************************************************/

/******************************Public*Routine******************************\
*
* Routine Name
*
*   vDirectStretch8_80
*
* Routine Description:
*
*   Stretch blt 8->8
*   This is for BLT enhancement only, such CL-GD5480.
*
* NOTE: This routine doesn't handle cases where the blt stretch starts
*       and ends in the same destination dword!  vDirectStretchNarrow
*       is expected to have been called for that case.
*
* Arguments:
*
*   pStrBlt - contains all params for blt
*
* Return Value:
*
*   VOID
*
\**************************************************************************/

VOID vDirectStretch8_80(
STR_BLT* pStrBlt)
{
    BYTE*   pjSrc;
    BYTE*   pjDstEnd;
    LONG    WidthXAln;
    ULONG   ulDst;
    ULONG   xAccum;
    ULONG   xTmp;
    BYTE*   pjOldScan;
    LONG    cyDuplicate;

    PDEV*   ppdev       = pStrBlt->ppdev;
    LONG    xDst        = pStrBlt->XDstStart;
    LONG    xSrc        = pStrBlt->XSrcStart;
    BYTE*   pjSrcScan   = pStrBlt->pjSrcScan + xSrc;
    BYTE*   pjDst       = pStrBlt->pjDstScan + xDst;
    LONG    yDst        = pStrBlt->YDstStart; // + ppdev->yOffset;
    LONG    yCount      = pStrBlt->YDstCount;
    ULONG   StartAln    = (ULONG)((ULONG_PTR)pjDst & 0x03);
    LONG    WidthX      = pStrBlt->XDstEnd - xDst;
    ULONG   EndAln      = (ULONG)((ULONG_PTR)(pjDst + WidthX) & 0x03);
    ULONG   xInt        = pStrBlt->ulXDstToSrcIntCeil;
    ULONG   xFrac       = pStrBlt->ulXDstToSrcFracCeil;
    ULONG   yAccum      = pStrBlt->ulYFracAccumulator;
    ULONG   yFrac       = pStrBlt->ulYDstToSrcFracCeil;
    ULONG   yInt        = 0;
    LONG    lDstStride  = pStrBlt->lDeltaDst - WidthX;

    BYTE*   pjPorts     = ppdev->pjPorts;
    BYTE*   pjBase      = ppdev->pjBase;
    LONG    lDelta      = ppdev->lDelta;
    LONG    xyOffset    = ppdev->xyOffset;
    LONG    xDstBytes   = xDst;
    LONG    WidthXBytes = WidthX;

    WidthXAln = WidthX - EndAln - ((- (LONG) StartAln) & 0x03);

    //
    // if this is a shrinking blt, calc src scan line stride
    //

    if (pStrBlt->ulYDstToSrcIntCeil != 0)
    {
        yInt = pStrBlt->lDeltaSrc * pStrBlt->ulYDstToSrcIntCeil;
    }

    //
    // loop drawing each scan line
    //
    //
    // at least 7 wide (DST) blt
    //

    do {
        BYTE    jSrc0,jSrc1,jSrc2,jSrc3;
        ULONG   yTmp;

        pjSrc   = pjSrcScan;
        xAccum  = pStrBlt->ulXFracAccumulator;

        //
        // a single src scan line is being written
        //

        if (ppdev->flCaps & CAPS_MM_IO)
        {
            CP_MM_WAIT_FOR_BLT_COMPLETE(ppdev, pjBase);
        }
        else
        {
            CP_IO_WAIT_FOR_BLT_COMPLETE(ppdev, pjPorts);
        }

        switch (StartAln) {
        case 1:
            jSrc0 = *pjSrc;
            xTmp = xAccum + xFrac;
            pjSrc = pjSrc + xInt + (xTmp < xAccum);
            *pjDst++ = jSrc0;
            xAccum = xTmp;
        case 2:
            jSrc0 = *pjSrc;
            xTmp = xAccum + xFrac;
            pjSrc = pjSrc + xInt + (xTmp < xAccum);
            *pjDst++ = jSrc0;
            xAccum = xTmp;
        case 3:
            jSrc0 = *pjSrc;
            xTmp = xAccum + xFrac;
            pjSrc = pjSrc + xInt + (xTmp < xAccum);
            *pjDst++ = jSrc0;
            xAccum = xTmp;
        }

        pjDstEnd  = pjDst + WidthXAln;

        while (pjDst != pjDstEnd)
        {
            jSrc0 = *pjSrc;
            xTmp = xAccum + xFrac;
            pjSrc = pjSrc + xInt + (xTmp < xAccum);

            jSrc1 = *pjSrc;
            xAccum = xTmp + xFrac;
            pjSrc = pjSrc + xInt + (xAccum < xTmp);

            jSrc2 = *pjSrc;
            xTmp = xAccum + xFrac;
            pjSrc = pjSrc + xInt + (xTmp < xAccum);

            jSrc3 = *pjSrc;
            xAccum = xTmp + xFrac;
            pjSrc = pjSrc + xInt + (xAccum < xTmp);

            ulDst = (jSrc3 << 24) | (jSrc2 << 16) | (jSrc1 << 8) | jSrc0;

            *(PULONG)pjDst = ulDst;
            pjDst += 4;
        }

        switch (EndAln) {
        case 3:
            jSrc0 = *pjSrc;
            xTmp = xAccum + xFrac;
            pjSrc = pjSrc + xInt + (xTmp < xAccum);
            *pjDst++ = jSrc0;
            xAccum = xTmp;
        case 2:
            jSrc0 = *pjSrc;
            xTmp = xAccum + xFrac;
            pjSrc = pjSrc + xInt + (xTmp < xAccum);
            *pjDst++ = jSrc0;
            xAccum = xTmp;
        case 1:
            jSrc0 = *pjSrc;
            xTmp = xAccum + xFrac;
            pjSrc = pjSrc + xInt + (xTmp < xAccum);
            *pjDst++ = jSrc0;
        }

        pjOldScan = pjSrcScan;
        pjSrcScan += yInt;

        yTmp = yAccum + yFrac;
        if (yTmp < yAccum)
        {
            pjSrcScan += pStrBlt->lDeltaSrc;
        }
        yAccum = yTmp;

        pjDst = (pjDst + lDstStride);
        yDst++;
        yCount--;

        if ((yCount != 0) && (pjSrcScan == pjOldScan))
        {
            // It's an expanding stretch in 'y'; the scan we just laid down
            // will be copied at least once using the hardware:

            cyDuplicate = 0;
            do {
                cyDuplicate++;
                pjSrcScan += yInt;

                yTmp = yAccum + yFrac;
                if (yTmp < yAccum)
                {
                    pjSrcScan += pStrBlt->lDeltaSrc;
                }
                yAccum = yTmp;

                pjDst = (pjDst + pStrBlt->lDeltaDst);
                yCount--;

            } while ((yCount != 0) && (pjSrcScan == pjOldScan));

            // The scan is to be copied 'cyDuplicate' times using the
            // hardware.

            //
            // We don't need to WAIT_FOR_BLT_COMPLETE since we did it above.
            //
            if (ppdev->flCaps & CAPS_MM_IO)
            {
                // GR33
                CP_MM_BLT_EXT_MODE(ppdev, pjBase, ENABLE_XY_POSITION) ;

                // GR20, GR21
                CP_MM_XCNT(ppdev, pjBase, (WidthX - 1)) ;

                // GR22, GR23
                CP_MM_YCNT(ppdev, pjBase, (cyDuplicate - 1)) ;

                // GR2C, GR2D, GR2E
                CP_MM_SRC_ADDR(ppdev, pjBase, xyOffset) ;

                // GR44, GR45, GR46, GR47
                CP_MM_SRC_XY(ppdev, pjBase, xDst, (yDst - 1)) ;

                // GR28, GR29, GR2A
                CP_MM_DST_ADDR(ppdev, pjBase, 0) ;

                // GR42, GR43
                CP_MM_DST_Y(ppdev, pjBase, yDst) ;

                // GR40, GR41
                CP_MM_DST_X(ppdev, pjBase, xDst) ;
            }
            else
            {
                CP_IO_XCNT(ppdev, pjPorts, (WidthXBytes - 1));
                CP_IO_YCNT(ppdev, pjPorts, (cyDuplicate - 1));

                CP_IO_SRC_ADDR(ppdev, pjPorts, (xyOffset + ((yDst - 1) * lDelta) + xDstBytes));
                CP_IO_DST_ADDR(ppdev, pjPorts, ((yDst * lDelta) + xDstBytes));
                CP_IO_START_BLT(ppdev, pjPorts);
            }

            yDst += cyDuplicate;
        }
    } while (yCount != 0);

    // GR33
    CP_MM_BLT_EXT_MODE(ppdev, pjBase, 0) ;

} // vDirectStretch8_80

/******************************Public*Routine******************************\
*
* Routine Name
*
*   vDirectStretch16_80
*
* Routine Description:
*
*   Stretch blt 16->16
*   This is for BLT enhancement only, such CL-GD5480.
*
* Arguments:
*
*   pStrBlt - contains all params for blt
*
* Return Value:
*
*   VOID
*
\**************************************************************************/

VOID vDirectStretch16_80(
STR_BLT* pStrBlt)
{
    BYTE*   pjOldScan;
    USHORT* pusSrc;
    USHORT* pusDstEnd;
    LONG    WidthXAln;
    ULONG   ulDst;
    ULONG   xAccum;
    ULONG   xTmp;
    LONG    cyDuplicate;

    PDEV*   ppdev       = pStrBlt->ppdev;
    LONG    xDst        = pStrBlt->XDstStart;
    LONG    xSrc        = pStrBlt->XSrcStart;
    BYTE*   pjSrcScan   = (pStrBlt->pjSrcScan) + xSrc * 2;
    USHORT* pusDst      = (USHORT*)(pStrBlt->pjDstScan) + xDst;
    LONG    yDst        = pStrBlt->YDstStart; // + ppdev->yOffset;
    LONG    yCount      = pStrBlt->YDstCount;
    ULONG   StartAln    = ((ULONG)((ULONG_PTR)pusDst & 0x02)) >> 1;
    LONG    WidthX      = pStrBlt->XDstEnd - xDst;
    ULONG   EndAln      = (ULONG)(((ULONG_PTR)(pusDst + WidthX) & 0x02) >> 1);
    ULONG   xInt        = pStrBlt->ulXDstToSrcIntCeil;
    ULONG   xFrac       = pStrBlt->ulXDstToSrcFracCeil;
    ULONG   yAccum      = pStrBlt->ulYFracAccumulator;
    ULONG   yFrac       = pStrBlt->ulYDstToSrcFracCeil;
    LONG    lDstStride  = pStrBlt->lDeltaDst - 2 * WidthX;
    ULONG   yInt        = 0;

    BYTE*   pjPorts     = ppdev->pjPorts;
    BYTE*   pjBase      = ppdev->pjBase;
    LONG    lDelta      = ppdev->lDelta;
    LONG    xyOffset    = ppdev->xyOffset;
    LONG    xDstBytes   = xDst * 2;
    LONG    WidthXBytes = WidthX * 2;

    WidthXAln = WidthX - EndAln - StartAln;

    //
    // if this is a shrinking blt, calc src scan line stride
    //

    if (pStrBlt->ulYDstToSrcIntCeil != 0)
    {
        yInt = pStrBlt->lDeltaSrc * pStrBlt->ulYDstToSrcIntCeil;
    }

    // Loop stretching each scan line

    do {
        USHORT  usSrc0,usSrc1;
        ULONG   yTmp;

        pusSrc  = (USHORT*) pjSrcScan;
        xAccum  = pStrBlt->ulXFracAccumulator;

        // A single source scan line is being written:

        if (ppdev->flCaps & CAPS_MM_IO)
        {
            CP_MM_WAIT_FOR_BLT_COMPLETE(ppdev, pjBase);
        }
        else
        {
            CP_IO_WAIT_FOR_BLT_COMPLETE(ppdev, pjPorts);
        }

        if (StartAln)
        {
            usSrc0    = *pusSrc;
            xTmp      = xAccum + xFrac;
            pusSrc    = pusSrc + xInt + (xTmp < xAccum);
            *pusDst++ = usSrc0;
            xAccum    = xTmp;
        }

        pusDstEnd  = pusDst + WidthXAln;

        while (pusDst != pusDstEnd)
        {

            usSrc0 = *pusSrc;
            xTmp   = xAccum + xFrac;
            pusSrc = pusSrc + xInt + (xTmp < xAccum);

            usSrc1 = *pusSrc;
            xAccum = xTmp + xFrac;
            pusSrc = pusSrc + xInt + (xAccum < xTmp);

            ulDst = (ULONG)((usSrc1 << 16) | usSrc0);

            *(ULONG*)pusDst = ulDst;
            pusDst+=2;
        }

        if (EndAln)
        {
            usSrc0    = *pusSrc;
            xTmp      = xAccum + xFrac;
            pusSrc    = pusSrc + xInt + (xTmp < xAccum);
            *pusDst++ = usSrc0;
        }

        pjOldScan = pjSrcScan;
        pjSrcScan += yInt;

        yTmp = yAccum + yFrac;
        if (yTmp < yAccum)
        {
            pjSrcScan += pStrBlt->lDeltaSrc;
        }
        yAccum = yTmp;

        pusDst = (USHORT*) ((BYTE*) pusDst + lDstStride);
        yDst++;
        yCount--;

        if ((yCount != 0) && (pjSrcScan == pjOldScan))
        {
            // It's an expanding stretch in 'y'; the scan we just laid down
            // will be copied at least once using the hardware:

            cyDuplicate = 0;
            do {
                cyDuplicate++;
                pjSrcScan += yInt;

                yTmp = yAccum + yFrac;
                if (yTmp < yAccum)
                {
                    pjSrcScan += pStrBlt->lDeltaSrc;
                }
                yAccum = yTmp;

                pusDst = (USHORT*) ((BYTE*) pusDst + pStrBlt->lDeltaDst);
                yCount--;

            } while ((yCount != 0) && (pjSrcScan == pjOldScan));

            // The scan is to be copied 'cyDuplicate' times using the
            // hardware.

            //
            // We don't need to WAIT_FOR_BLT_COMPLETE since we did it above.
            //
            if (ppdev->flCaps & CAPS_MM_IO)
            {
                // GR33
                CP_MM_BLT_EXT_MODE(ppdev, pjBase, ENABLE_XY_POSITION) ;

                // GR20, GR21
                CP_MM_XCNT(ppdev, pjBase, ((WidthX << 1) - 1)) ;

                // GR22, GR23
                CP_MM_YCNT(ppdev, pjBase, (cyDuplicate - 1)) ;

                // GR2C, GR2D, GR2E
                CP_MM_SRC_ADDR(ppdev, pjBase, xyOffset) ;

                // GR44, GR45, GR46, GR47
                CP_MM_SRC_XY(ppdev, pjBase, xDst << 1, (yDst - 1)) ;

                // GR28, GR29, GR2A
                CP_MM_DST_ADDR(ppdev, pjBase, 0) ;

                // GR42, GR43
                CP_MM_DST_Y(ppdev, pjBase, yDst) ;

                // GR40, GR41
                CP_MM_DST_X(ppdev, pjBase, xDst << 1) ;
            }
            else
            {
                CP_IO_XCNT(ppdev, pjPorts, (WidthXBytes - 1));
                CP_IO_YCNT(ppdev, pjPorts, (cyDuplicate - 1));

                CP_IO_SRC_ADDR(ppdev, pjPorts, (xyOffset + ((yDst - 1) * lDelta) + xDstBytes));
                CP_IO_DST_ADDR(ppdev, pjPorts, ((yDst * lDelta) + xDstBytes));
                CP_IO_START_BLT(ppdev, pjPorts);
            }

            yDst += cyDuplicate;
        }
    } while (yCount != 0);

    // GR33
    CP_MM_BLT_EXT_MODE(ppdev, pjBase, 0) ;

} // vDirectStretch16_80

/******************************Public*Routine******************************\
*
* Routine Name
*
*   vDirectStretch24_80
*
* Routine Description:
*
*   Stretch blt 24->24.
*   This is for BLT enhancement only, such CL-GD5480.
*
* Arguments:
*
*   pStrBlt - contains all params for blt
*
* Return Value:
*
*   VOID
*
\**************************************************************************/

VOID vDirectStretch24_80(
STR_BLT* pStrBlt)
{
    BYTE*   pbSrc;
    BYTE*   pbDstEnd; 
    LONG    WidthXAln;
    ULONG   xAccum;
    ULONG   xTmp;
    BYTE*   pjOldScan;
    LONG    cyDuplicate;
    ULONG   ulSrc0;
    BYTE    bDst0,bDst1,bDst2;
    ULONG   xBits;

    PDEV*   ppdev       = pStrBlt->ppdev;
    LONG    xDst        = pStrBlt->XDstStart;
    LONG    xSrc        = pStrBlt->XSrcStart;
    BYTE*   pjSrcScan   = (pStrBlt->pjSrcScan) + (xSrc << 1) + xSrc;                      // 3 bytes per pixel
    BYTE*   pbDST       = (pStrBlt->pjDstScan) + (xDst << 1) + xDst;                      
    LONG    yDst        = pStrBlt->YDstStart;                                                   // + ppdev->yOffset;
    LONG    yCount      = pStrBlt->YDstCount;
    LONG    WidthX      = pStrBlt->XDstEnd - xDst;
    ULONG   xInt        = pStrBlt->ulXDstToSrcIntCeil;
    ULONG   xFrac       = pStrBlt->ulXDstToSrcFracCeil;
    ULONG   yAccum      = pStrBlt->ulYFracAccumulator;
    ULONG   yFrac       = pStrBlt->ulYDstToSrcFracCeil;
    ULONG   yInt        = 0;
    LONG    lDstStride  = pStrBlt->lDeltaDst - (WidthX << 1) -  WidthX;

    BYTE*   pjPorts     = ppdev->pjPorts;
    BYTE*   pjBase      = ppdev->pjBase;
    LONG    lDelta      = ppdev->lDelta;
    LONG    xyOffset    = ppdev->xyOffset;
    LONG    xDstBytes   = (xDst << 1) +  xDst;

    LONG    WidthXBytes = (WidthX << 1) +  WidthX;

    //
    // if this is a shrinking blt, calc src scan line stride
    //

    if (pStrBlt->ulYDstToSrcIntCeil != 0)                       // enlargement ?
    {                                                                                                                   // yes.
        yInt = pStrBlt->lDeltaSrc * pStrBlt->ulYDstToSrcIntCeil;
    }

    // Loop stretching each scan line

    do {

        ULONG   yTmp;

        pbSrc  = pjSrcScan;
        xAccum  = pStrBlt->ulXFracAccumulator;

        // A single source scan line is being written:

        if (ppdev->flCaps & CAPS_MM_IO)                                         // Blt Engine Ready?
        {
            CP_MM_WAIT_FOR_BLT_COMPLETE(ppdev, pjBase);
        }
        else
        {
            CP_IO_WAIT_FOR_BLT_COMPLETE(ppdev, pjPorts);
        }

        pbDstEnd  = pbDST + WidthXBytes - 3;

        while (pbDST < pbDstEnd)
        {
            ulSrc0 = *((ULONG*)pbSrc);
            bDst0  = (BYTE) (ulSrc0 & 0xff);
            bDst1  = (BYTE) ((ulSrc0 >> 8) & 0xff);
            bDst2  = (BYTE) ((ulSrc0 >> 16) & 0xff);
            xTmp   = xAccum + xFrac;
            xBits  = xInt + (xTmp < xAccum); 
            xAccum = xTmp;
            pbSrc  += (xBits << 1) + xBits;

            *pbDST++ = bDst0;
            *pbDST++ = bDst1;
            *pbDST++ = bDst2;
        }
        
        //
        // do the last pixel using bye
        //
        *pbDST++  = *pbSrc++;
        *pbDST++  = *pbSrc++;
        *pbDST++  = *pbSrc++;


        pjOldScan = pjSrcScan;
        pjSrcScan += yInt;

        yTmp = yAccum + yFrac;
        if (yTmp < yAccum)
        {
            pjSrcScan += pStrBlt->lDeltaSrc;
        }
        yAccum = yTmp;

        pbDST += lDstStride;
        yDst++;
        yCount--;

        if ((yCount != 0) && (pjSrcScan == pjOldScan))
        {
            // It's an expanding stretch in 'y'; the scan we just laid down
            // will be copied at least once using the hardware:

            cyDuplicate = 0;
            do {
                cyDuplicate++;
                pjSrcScan += yInt;

                yTmp = yAccum + yFrac;
                if (yTmp < yAccum)
                {
                    pjSrcScan += pStrBlt->lDeltaSrc;
                }
                yAccum = yTmp;

                pbDST += pStrBlt->lDeltaDst;
                yCount--;

            } while ((yCount != 0) && (pjSrcScan == pjOldScan));

            // The scan is to be copied 'cyDuplicate' times using the
            // hardware.

            //
            // We don't need to WAIT_FOR_BLT_COMPLETE since we did it above.
            //

            if (ppdev->flCaps & CAPS_MM_IO)
            {
                // GR33
                CP_MM_BLT_EXT_MODE(ppdev, pjBase, ENABLE_XY_POSITION) ;

                // GR20, GR21
                CP_MM_XCNT(ppdev, pjBase, (WidthX * 3 - 1)) ;

                // GR22, GR23
                CP_MM_YCNT(ppdev, pjBase, (cyDuplicate - 1)) ;

                // GR2C, GR2D, GR2E
                CP_MM_SRC_ADDR(ppdev, pjBase, xyOffset) ;

                // GR44, GR45, GR46, GR47
                CP_MM_SRC_XY(ppdev, pjBase, xDst * 3, (yDst - 1)) ;

                // GR28, GR29, GR2A
                CP_MM_DST_ADDR(ppdev, pjBase, 0) ;

                // GR42, GR43
                CP_MM_DST_Y(ppdev, pjBase, yDst) ;

                // GR40, GR41
                CP_MM_DST_X(ppdev, pjBase, xDst * 3) ;
            }
            else
            {
                CP_IO_XCNT(ppdev, pjPorts, (WidthXBytes - 1));
                CP_IO_YCNT(ppdev, pjPorts, (cyDuplicate - 1));

                CP_IO_SRC_ADDR(ppdev, pjPorts, (xyOffset + ((yDst - 1) * lDelta) + xDstBytes));
                CP_IO_DST_ADDR(ppdev, pjPorts, ((yDst * lDelta) + xDstBytes));
                CP_IO_START_BLT(ppdev, pjPorts);
            }

            yDst += cyDuplicate;
        }
    } while (yCount != 0);

    // GR33
    CP_MM_BLT_EXT_MODE(ppdev, pjBase, ENABLE_XY_POSITION) ;

} // vDirectStretch24_80
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\cirrus\disp\precomp.h ===
/******************************************************************************\
*
* $Workfile:   precomp.h  $
*
* Common headers used throughout the display driver.  This entire include
* file will typically be pre-compiled.
*
* Copyright (c) 1993-1995 Microsoft Corporation
* Copyright (c) 1996 Cirrus Logic, Inc.
*
* $Log:   S:/projects/drivers/ntsrc/display/precomp.h_v  $
 * 
 *    Rev 1.2   18 Dec 1996 13:44:12   PLCHU
 *  
 * 
 *    Rev 1.1   Oct 10 1996 15:38:50   unknown
 *  
* 
*    Rev 1.2   12 Aug 1996 16:48:28   frido
* Added NT 3.5x/4.0 auto detection.
* 
*    Rev 1.1   03 Jul 1996 13:50:42   frido
* Added WINERROR.H include file.
*
*    chu01  12-16-96   Enable color correction
*
\******************************************************************************/

#include <stddef.h>
#include <stdarg.h>
#include <limits.h>
#if (_WIN32_WINNT >= 0x0400)
    #include <windef.h>
    #include <winerror.h>
    #include <wingdi.h>
#else
    #include <windows.h>
    #include <memory.h>
    #include <stdio.h>
    #include <stdlib.h>
#endif
#include <winddi.h>
#include <devioctl.h>
#include <ntddvdeo.h>
#include <ioaccess.h>

#include <math.h>

#define  ENABLE_BIOS_ARGUMENTS

//
// DBG_STRESS_FAILURE turns on debugging code related to the stress failure
//
#define  DBG_STRESS_FAILURE 0

//
// chu01 : GAMMACORRECT
//
#include "clioctl.h"         

#include "lines.h"
#include "hw.h"
#include "driver.h"
#include "debug.h"

//
// chu01 : GAMMACORRECT
//
//#define  GAMMACORRECT      1     // 1 : Enable; 0 : Disable
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\cirrus\disp\stripmm.c ===
/******************************************************************************\
*
* $Workfile:   stripmm.c  $
*
* Do what you can with no line support.
*
* I implemented the horizontal and vertical strip functions using
* solid fills, and removed the usage of diagonal strips.  With a little
* effort you could implement diagonal strips by doing solid fills while
* playing with lDelta.  This is probably not worth the trouble.
*
* Copyright (c) 1992-1997 Microsoft Corporation
* Copyright (c) 1996-1997 Cirrus Logic, Inc.,
*
* $Log:   S:/projects/drivers/ntsrc/display/STRIPMM.C_V  $
 * 
 *    Rev 1.2   10 Jan 1997 15:40:18   PLCHU
 *  
* 
*    Rev 1.1   Oct 10 1996 15:39:22   unknown
*  
* 
*    Rev 1.1   12 Aug 1996 16:55:04   frido
* Removed unaccessed local variables.
*
*    chu01  : 01-02-97  5480 BitBLT enhancement 
*    chu02  : 01-09-97  Macro redefinition
*
\******************************************************************************/

#include "precomp.h"

#define count COMMAND_TOTAL_PACKETS

#define MM_DRAW_HORZ_STRIP(xy, cx, lDelta, cBpp)\
{\
    ULONG   ulDstAddr;\
\
    ulDstAddr = xy;\
\
    CP_MM_WAIT_FOR_BLT_COMPLETE(ppdev, pjBase);\
    CP_MM_XCNT(ppdev, pjBase, (PELS_TO_BYTES(cx) - 1));\
    CP_MM_YCNT(ppdev, pjBase, 0);\
    CP_MM_DST_ADDR(ppdev, pjBase, ulDstAddr);\
    CP_MM_START_BLT(ppdev, pjBase);\
}

#define MM_DRAW_VERT_STRIP(xy, cy, lDelta, cBpp)\
{\
    ULONG   ulDstAddr;\
\
    ulDstAddr = xy;\
\
    CP_MM_WAIT_FOR_BLT_COMPLETE(ppdev, pjBase);\
    CP_MM_XCNT(ppdev, pjBase, (cBpp - 1));\
    CP_MM_YCNT(ppdev, pjBase, (cy - 1));\
    CP_MM_DST_ADDR(ppdev, pjBase, ulDstAddr);\
    CP_MM_START_BLT(ppdev, pjBase);\
}

#define MM_DRAW_VERT_STRIP_FLIPPED(xy, cy, lDelta, cBpp)\
{\
    ULONG   ulDstAddr;\
\
    ulDstAddr = xy - ((cy - 1) * lDelta);\
\
    CP_MM_WAIT_FOR_BLT_COMPLETE(ppdev, pjBase);\
    CP_MM_XCNT(ppdev, pjBase, (cBpp - 1));\
    CP_MM_YCNT(ppdev, pjBase, (cy - 1));\
    CP_MM_DST_ADDR(ppdev, pjBase, ulDstAddr);\
    CP_MM_START_BLT(ppdev, pjBase);\
}

// chu01, chu02
#define MM_DRAW_HORZ_STRIP80(x, y, cx)\
{\
    CP_MM_WAIT_FOR_BLT_COMPLETE(ppdev, pjBase);\
    CP_MM_BLT_EXT_MODE(ppdev, pjBase, ENABLE_XY_POSITION);\
    CP_MM_XCNT(ppdev, pjBase, (cx - 1));\
    CP_MM_YCNT(ppdev, pjBase, 0);\
    CP_MM_DST_ADDR(ppdev, pjBase, 0);\
    CP_MM_DST_Y(ppdev, pjBase, y);\
    CP_MM_DST_X(ppdev, pjBase, x);\
}

#define MM_DRAW_VERT_STRIP80(x, y, cy)\
{\
    CP_MM_WAIT_FOR_BLT_COMPLETE(ppdev, pjBase);\
    CP_MM_BLT_EXT_MODE(ppdev, pjBase, ENABLE_XY_POSITION);\
    CP_MM_XCNT(ppdev, pjBase, 0);\
    CP_MM_YCNT(ppdev, pjBase, (cy - 1));\
    CP_MM_DST_ADDR(ppdev, pjBase, 0);\
    CP_MM_DST_Y(ppdev, pjBase, y);\
    CP_MM_DST_X(ppdev, pjBase, x);\
}

#define MM_DRAW_VERT_STRIP_FLIPPED80(x, y, cy)\
{\
    CP_MM_WAIT_FOR_BLT_COMPLETE(ppdev, pjBase);\
    CP_MM_BLT_EXT_MODE(ppdev, pjBase, ENABLE_XY_POSITION);\
    CP_MM_XCNT(ppdev, pjBase, 0);\
    CP_MM_YCNT(ppdev, pjBase, (cy - 1));\
    CP_MM_DST_ADDR(ppdev, pjBase, 0);\
    CP_MM_DST_Y(ppdev, pjBase, ((y - cy) + 1));\
    CP_MM_DST_X(ppdev, pjBase, x);\
}

/******************************Public*Routine******************************\
* VOID vMmSolidHorizontal
*
* Draws left-to-right x-major near-horizontal lines using solid fills.
*
* Assumes fgRop, BgRop, and Color are already set correctly.
*
\**************************************************************************/

VOID vMmSolidHorizontal(
PDEV*       ppdev,
STRIP*      pStrip,
LINESTATE*  pLineState)
{
    BYTE*   pjBase   = ppdev->pjBase;
    LONG    cBpp     = ppdev->cBpp;
    LONG    lDelta   = ppdev->lDelta;
    LONG    cStrips  = pStrip->cStrips;
    PLONG   pStrips  = pStrip->alStrips;
    LONG    x        = pStrip->ptlStart.x;
    LONG    y        = pStrip->ptlStart.y;
    LONG    xy       = PELS_TO_BYTES(x) + (lDelta * y);
    LONG    yInc     = 1;
    LONG    i;

    DISPDBG((2, "vMmSolidHorizontal"));

    if (!(pStrip->flFlips & FL_FLIP_V))
    {
        //
        // Horizontal strips ->
        //                     ->
        //

        for (i = 0; i < cStrips; i++)
        {
            MM_DRAW_HORZ_STRIP(xy, *pStrips, lDelta, cBpp);
            x += *pStrips;
            xy += PELS_TO_BYTES(*pStrips);  // x+
            xy += lDelta;                   // y+
            pStrips++;
        }
        y += cStrips;
    }
    else
    {
        //
        //                     ->
        // Horizontal strips ->
        //

        for (i = 0; i < cStrips; i++)
        {
            MM_DRAW_HORZ_STRIP(xy, *pStrips, lDelta, cBpp);
            x += *pStrips;
            xy += PELS_TO_BYTES(*pStrips);  // x+
            xy -= lDelta;                   // y+
            pStrips++;
        }
        y -= cStrips;
    }

    pStrip->ptlStart.x = x;
    pStrip->ptlStart.y = y;
}

/******************************Public*Routine******************************\
* VOID vMmSolidVertical
*
* Draws left-to-right y-major near-vertical lines using solid fills.
*
\**************************************************************************/

VOID vMmSolidVertical(
PDEV*       ppdev,
STRIP*      pStrip,
LINESTATE*  pLineState)
{
    BYTE*   pjBase   = ppdev->pjBase;
    LONG    cBpp     = ppdev->cBpp;
    LONG    lDelta   = ppdev->lDelta;
    LONG    cStrips  = pStrip->cStrips;
    PLONG   pStrips  = pStrip->alStrips;
    LONG    x        = pStrip->ptlStart.x;
    LONG    y        = pStrip->ptlStart.y;
    LONG    xy       = PELS_TO_BYTES(x) + (lDelta * y);
    LONG    i;

    DISPDBG((2, "vMmSolidVertical"));

    if (!(pStrip->flFlips & FL_FLIP_V))
    {
        //
        //                  |
        // Vertical strips  v
        //                   |
        //                   v
        //

        for (i = 0; i < cStrips; i++)
        {
            MM_DRAW_VERT_STRIP(xy, *pStrips, lDelta, cBpp);
            y += *pStrips;
            xy += cBpp;                 // x+
            xy += (*pStrips * lDelta);  // y+
            pStrips++;
        }
    }
    else
    {
        //
        //                   ^
        // Vertical strips   |
        //                  ^
        //                  |
        //

        for (i = 0; i < cStrips; i++)
        {
            MM_DRAW_VERT_STRIP_FLIPPED(xy, *pStrips, lDelta, cBpp);
            y -= *pStrips;
            xy += cBpp;                 // x+
            xy -= (*pStrips * lDelta);  // y-
            pStrips++;
        }
    }
    x += cStrips;

    pStrip->ptlStart.x = x;
    pStrip->ptlStart.y = y;
}

/******************************Public*Routine******************************\
* VOID vMmStyledHorizontal
*
* Takes the list of strips that define the pixels that would be lit for
* a solid line, and breaks them into styling chunks according to the
* styling information that is passed in.
*
* This particular routine handles x-major lines that run left-to-right,
* and are comprised of horizontal strips.  It draws the dashes using
* short-stroke vectors.
*
* The performance of this routine could be improved significantly if
* anyone cared enough about styled lines improve it.
*
\**************************************************************************/

VOID vMmStyledHorizontal(
PDEV*       ppdev,
STRIP*      pstrip,
LINESTATE*  pls)
{
    BYTE*   pjBase   = ppdev->pjBase;
    LONG    cBpp     = ppdev->cBpp;
    LONG    lDelta   = ppdev->lDelta;
    LONG    x        = pstrip->ptlStart.x;   // x position of start of first strip
    LONG    y        = pstrip->ptlStart.y;   // y position of start of first strip
    LONG    xy       = PELS_TO_BYTES(x) + (lDelta * y);
    LONG*   plStrip  = pstrip->alStrips;     // Points to current strip
    LONG    cStrips  = pstrip->cStrips;      // Total number of strips we'll do
    LONG    dy;
    LONG    dylDelta;
    LONG    cStyle;
    LONG    cStrip;
    LONG    cThis;
    ULONG   bIsGap;

    DISPDBG((2, "vMmStyledHorizontal"));

    if (pstrip->flFlips & FL_FLIP_V)
    {
        // The minor direction of the line is 90 degrees, and the major
        // direction is 0 (it's a left-to-right x-major line going up):

        dy = -1;
        dylDelta = -lDelta;
    }
    else
    {
        // The minor direction of the line is 270 degrees, and the major
        // direction is 0 (it's a left-to-right x-major line going down):

        dy = 1;
        dylDelta = lDelta;
    }

    cStrip = *plStrip;              // Number of pels in first strip

    cStyle = pls->spRemaining;      // Number of pels in first 'gap' or 'dash'
    bIsGap = pls->ulStyleMask;      // Tells whether in a 'gap' or a 'dash'

    // ulStyleMask is non-zero if we're in the middle of a 'gap',
    // and zero if we're in the middle of a 'dash':

    if (bIsGap)
        goto SkipAGap;
    else
        goto OutputADash;

PrepareToSkipAGap:

    // Advance in the style-state array, so that we can find the next
    // 'dot' that we'll have to display:

    bIsGap = ~bIsGap;
    pls->psp++;
    if (pls->psp > pls->pspEnd)
        pls->psp = pls->pspStart;

    cStyle = *pls->psp;

    // If 'cStrip' is zero, we also need a new strip:

    if (cStrip != 0)
        goto SkipAGap;

    // Here, we're in the middle of a 'gap' where we don't have to
    // display anything.  We simply cycle through all the strips
    // we can, keeping track of the current position, until we run
    // out of 'gap':

    while (TRUE)
    {
        // Each time we loop, we move to a new scan and need a new strip:

        y += dy;
        xy += dylDelta;

        plStrip++;
        cStrips--;
        if (cStrips == 0)
            goto AllDone;

        cStrip = *plStrip;

    SkipAGap:

        cThis   = min(cStrip, cStyle);
        cStyle -= cThis;
        cStrip -= cThis;

        x += cThis;
        xy += PELS_TO_BYTES(cThis);

        if (cStyle == 0)
            goto PrepareToOutputADash;
    }

PrepareToOutputADash:

    // Advance in the style-state array, so that we can find the next
    // 'dot' that we'll have to display:

    bIsGap = ~bIsGap;
    pls->psp++;
    if (pls->psp > pls->pspEnd)
        pls->psp = pls->pspStart;

    cStyle = *pls->psp;

    // If 'cStrip' is zero, we also need a new strip.

    if (cStrip != 0)
    {
        // There's more to be done in the current strip:

        goto OutputADash;
    }

    // We've finished with the current strip:

    while (TRUE)
    {
        // Each time we loop, we move to a new scan and need a new strip:

        y += dy;
        xy += dylDelta;

        plStrip++;
        cStrips--;
        if (cStrips == 0)
            goto AllDone;

        cStrip = *plStrip;

    OutputADash:

        cThis   = min(cStrip, cStyle);
        cStyle -= cThis;
        cStrip -= cThis;

        MM_DRAW_HORZ_STRIP(xy, cThis, lDelta, cBpp);

        x += cThis;
        xy += PELS_TO_BYTES(cThis); // x+

        if (cStyle == 0)
            goto PrepareToSkipAGap;
    }

AllDone:

    // Update our state variables so that the next line can continue
    // where we left off:

    pls->spRemaining   = cStyle;
    pls->ulStyleMask   = bIsGap;
    pstrip->ptlStart.x = x;
    pstrip->ptlStart.y = y;
}

/******************************Public*Routine******************************\
* VOID vMmStyledVertical
*
* Takes the list of strips that define the pixels that would be lit for
* a solid line, and breaks them into styling chunks according to the
* styling information that is passed in.
*
* This particular routine handles y-major lines that run left-to-right,
* and are comprised of vertical strips.  It draws the dashes using
* short-stroke vectors.
*
* The performance of this routine could be improved significantly if
* anyone cared enough about styled lines improve it.
*
\**************************************************************************/

VOID vMmStyledVertical(
PDEV*       ppdev,
STRIP*      pstrip,
LINESTATE*  pls)
{
    BYTE*   pjBase   = ppdev->pjBase;
    LONG    cBpp     = ppdev->cBpp;
    LONG    lDelta   = ppdev->lDelta;
    LONG    x        = pstrip->ptlStart.x;   // x position of start of first strip
    LONG    y        = pstrip->ptlStart.y;   // y position of start of first strip
    LONG    xy       = PELS_TO_BYTES(x) + (lDelta * y);
    LONG*   plStrip  = pstrip->alStrips;     // Points to current strip
    LONG    cStrips  = pstrip->cStrips;      // Total number of strips we'll do
    LONG    dy;
    LONG    dylDelta;
    LONG    cStyle;
    LONG    cStrip;
    LONG    cThis;
    ULONG   bIsGap;

    DISPDBG((2, "vMmStyledVertical")) ;

    if (pstrip->flFlips & FL_FLIP_V)
    {
        // The minor direction of the line is 0 degrees, and the major
        // direction is 90 (it's a left-to-right y-major line going up):

        dy = -1;
        dylDelta = -lDelta;
    }
    else
    {
        // The minor direction of the line is 0 degrees, and the major
        // direction is 270 (it's a left-to-right y-major line going down):

        dy = 1;
        dylDelta = lDelta;
    }

    cStrip = *plStrip;              // Number of pels in first strip

    cStyle = pls->spRemaining;      // Number of pels in first 'gap' or 'dash'
    bIsGap = pls->ulStyleMask;      // Tells whether in a 'gap' or a 'dash'

    // ulStyleMask is non-zero if we're in the middle of a 'gap',
    // and zero if we're in the middle of a 'dash':

    if (bIsGap)
        goto SkipAGap;
    else
        goto OutputADash;

PrepareToSkipAGap:

    // Advance in the style-state array, so that we can find the next
    // 'dot' that we'll have to display:

    bIsGap = ~bIsGap;
    pls->psp++;
    if (pls->psp > pls->pspEnd)
        pls->psp = pls->pspStart;

    cStyle = *pls->psp;

    // If 'cStrip' is zero, we also need a new strip:

    if (cStrip != 0)
        goto SkipAGap;

    // Here, we're in the middle of a 'gap' where we don't have to
    // display anything.  We simply cycle through all the strips
    // we can, keeping track of the current position, until we run
    // out of 'gap':

    while (TRUE)
    {
        // Each time we loop, we move to a new column and need a new strip:

        xy += cBpp;
        x++;

        plStrip++;
        cStrips--;
        if (cStrips == 0)
            goto AllDone;

        cStrip = *plStrip;

    SkipAGap:

        cThis   = min(cStrip, cStyle);
        cStyle -= cThis;
        cStrip -= cThis;

        if (dy > 0)
        {
            y += cThis;
            xy += (cThis * lDelta);
        }
        else
        {
            y -= cThis;
            xy -= (cThis * lDelta);
        }

        if (cStyle == 0)
            goto PrepareToOutputADash;
    }

PrepareToOutputADash:

    // Advance in the style-state array, so that we can find the next
    // 'dot' that we'll have to display:

    bIsGap = ~bIsGap;
    pls->psp++;
    if (pls->psp > pls->pspEnd)
        pls->psp = pls->pspStart;

    cStyle = *pls->psp;

    // If 'cStrip' is zero, we also need a new strip.

    if (cStrip != 0)
    {
        // There's more to be done in the current strip:

        goto OutputADash;
    }

    // We've finished with the current strip:

    while (TRUE)
    {
        // Each time we loop, we move to a new column and need a new strip:

        xy += cBpp;
        x++;

        plStrip++;
        cStrips--;
        if (cStrips == 0)
            goto AllDone;

        cStrip = *plStrip;

    OutputADash:

        cThis   = min(cStrip, cStyle);
        cStyle -= cThis;
        cStrip -= cThis;

        if (dy <= 0)
        {
            MM_DRAW_VERT_STRIP_FLIPPED(xy, cThis, lDelta, cBpp);
            y -=  cThis;                // y-
            xy -=  (cThis * lDelta);    // y-
        }
        else
        {
            MM_DRAW_VERT_STRIP(xy, cThis, lDelta, cBpp);
            y +=  cThis;                // y+
            xy +=  (cThis * lDelta);    // y+
        }


        if (cStyle == 0)
            goto PrepareToSkipAGap;
    }

AllDone:

    // Update our state variables so that the next line can continue
    // where we left off:

    pls->spRemaining   = cStyle;
    pls->ulStyleMask   = bIsGap;
    pstrip->ptlStart.x = x;
    pstrip->ptlStart.y = y;
}

/******************************Public*Routine******************************\
* VOID vInvalidStrip
*
* Put this in the function table for entries that shouldn't get hit.
*
\**************************************************************************/

VOID vInvalidStrip(
PDEV*       ppdev,          // unused
STRIP*      pStrip,         // unused
LINESTATE*  pLineState)     // unused
{

    RIP("vInvalidStrip called");
    return;
}

// chu01
/******************************Public*Routine******************************\
*
*     B i t B L T   E n h a n c e m e n t   F o r   C L - G D 5 4 8 0
*
\**************************************************************************/

VOID vMmSolidHorizontal80(
PDEV*       ppdev,
STRIP*      pStrip,
LINESTATE*  pLineState)
{
    BYTE*   pjBase      = ppdev->pjBase ;
    LONG    cBpp        = ppdev->cBpp ;
    LONG    lDelta      = ppdev->lDelta ;
    LONG    cStrips     = pStrip->cStrips ;
    PLONG   pStrips     = pStrip->alStrips ;   // cx for each stroke
    LONG    x           = pStrip->ptlStart.x ; // X-position
    LONG    y           = pStrip->ptlStart.y ; // Y-position
    LONG    yOrg        = y ;
    LONG    yInc        = 1 ;
    LONG    x0, y0, cx ;

    ULONG   ulDstOffset = 0 ;
    ULONG_PTR* ulCLStart ;
    ULONG   ulWidthHeight ;

    LONG    i           = 0 ;
    BYTE    MM1B ;

    DISPDBG((2, "vMmSolidHorizontal80")) ;

    if (!(pStrip->flFlips & FL_FLIP_V))
    {
        //                          
        // Horizontal strips ->     1.
        //                     ->       2.
        //
        if (cStrips != 1)
        {
            MM1B = ENABLE_COMMAND_LIST | ENABLE_XY_POSITION | SRC_CPU_DATA ;
            CP_MM_BLT_EXT_MODE(ppdev, pjBase, MM1B) ;
Loop_H1:
            ulCLStart = ppdev->pCommandList ;
            ulDstOffset = (ULONG)(((ULONG_PTR)ulCLStart
                                 - (ULONG_PTR)ppdev->pjScreen) << 14) ;
            CP_MM_CL_SWITCH(ppdev) ;

            // First strip
            x0 = x ;
            y0 = y ;
            cx = *pStrips ;
            i++ ;

            // Next strip
            y++ ;
            x += cx ; 
            pStrips++ ;

            while (TRUE)
            {
                // GR20, GR21, GR22, GR23
                ulWidthHeight = PACKXY_FAST((*pStrips - 1), 0) ;
                ulWidthHeight |= COMMAND_NOSRC_NOTHING ;

                // GR40, GR41, GR42, GR43
                *(ulCLStart + 1) = PACKXY_FAST(x, y) ;

                // GR2C, GR2D, GR2E
                *(ulCLStart + 2) = 0 ;

                i++ ;

                if ((i == cStrips) || ((i % count) == 0))
                {
                    // Last Command
                    ulWidthHeight |= COMMAND_LAST_PACKET ;
                    *ulCLStart = ulWidthHeight ;
                    break ;
                }
                *ulCLStart = ulWidthHeight ;

                // Next strip
                y++ ;
                x += *pStrips ; 
                pStrips++ ;
                ulCLStart += 4 ;
            }

            CP_MM_WAIT_FOR_BLT_COMPLETE(ppdev, pjBase) ;
            CP_MM_XCNT(ppdev, pjBase, (cx - 1)) ;
            CP_MM_YCNT(ppdev, pjBase, 0) ;
            CP_MM_DST_ADDR(ppdev, pjBase, ulDstOffset) ;
            CP_MM_DST_Y(ppdev, pjBase, y0) ;
            CP_MM_DST_X(ppdev, pjBase, x0) ;

            if (i == cStrips)
                x += *pStrips ; 
            else if ((i % count) == 0)
            {
                // 
                // Resume a new command list
                //
                y++ ;
                cx = *pStrips ;
                x += cx ; 
                pStrips++ ; 
                if (i != (cStrips - 1))
                {
                    goto Loop_H1 ;
                }
                else
                {
                    MM_DRAW_HORZ_STRIP80(x, y, *pStrips) ;
                    x += *pStrips ;
                    pStrips++;
                }
            }
        }
        else
        {
            MM_DRAW_HORZ_STRIP80(x, y, *pStrips) ;
            x += *pStrips ;
            pStrips++;
        }
        yOrg += cStrips;
    }
    else
    {
        //
        //                     ->     2.
        // Horizontal strips ->     1.
        //
        if (cStrips != 1)
        {
            MM1B = ENABLE_COMMAND_LIST | ENABLE_XY_POSITION | SRC_CPU_DATA ;
            CP_MM_BLT_EXT_MODE(ppdev, pjBase, MM1B) ;
Loop_H2:
            ulCLStart = ppdev->pCommandList;
            ulDstOffset = (ULONG)(((ULONG_PTR)ulCLStart
                                 - (ULONG_PTR)ppdev->pjScreen) << 14) ;
            CP_MM_CL_SWITCH(ppdev) ;

            // First strip
            x0 = x ;
            y0 = y ;
            cx = *pStrips ;
            i++ ;

            // Next strip
            y-- ;
            x += cx ; 
            pStrips++ ;

            while (TRUE)
            {
                // GR20, GR21, GR22, GR23
                ulWidthHeight = PACKXY_FAST((*pStrips - 1), 0) ;
                ulWidthHeight |= COMMAND_NOSRC_NOTHING ;

                // GR40, GR41, GR42, GR43
                *(ulCLStart + 1) = PACKXY_FAST(x, y) ;

                // GR2C, GR2D, GR2E
                *(ulCLStart + 2) = 0 ;

                i++ ;

                if ((i == cStrips) || ((i % count) == 0))
                {
                    // Last Command
                    ulWidthHeight |= COMMAND_LAST_PACKET ;
                    *ulCLStart = ulWidthHeight ;
                    break ;
                }
                *ulCLStart = ulWidthHeight ;

                // Next strip
                y-- ;
                x += *pStrips ; 
                pStrips++ ;
                ulCLStart += 4 ;
            }

            CP_MM_WAIT_FOR_BLT_COMPLETE(ppdev, pjBase) ;
            CP_MM_XCNT(ppdev, pjBase, (cx - 1)) ;
            CP_MM_YCNT(ppdev, pjBase, 0) ;
            CP_MM_DST_ADDR(ppdev, pjBase, ulDstOffset) ;
            CP_MM_DST_Y(ppdev, pjBase, y0) ;
            CP_MM_DST_X(ppdev, pjBase, x0) ;

            if (i == cStrips)
                x += *pStrips ; 
            else if ((i % count) == 0) 
            {
                // 
                // Resume a new command list
                //
                y-- ;
                cx = *pStrips ;
                x += cx ; 
                pStrips++ ; 
                if (i != (cStrips - 1))
                {
                    goto Loop_H2 ;
                }
                else
                {
                    MM_DRAW_HORZ_STRIP80(x, y, *pStrips) ;
                    x += *pStrips ;
                    pStrips++;
                }
            }
        }
        else
        {
            MM_DRAW_HORZ_STRIP80(x, y, *pStrips) ;
            x += *pStrips ;
            pStrips++;
        }
        yOrg -= cStrips;
    }

    pStrip->ptlStart.x = x    ;
    pStrip->ptlStart.y = yOrg ;

}

/******************************Public*Routine******************************\
* VOID vMmSolidVertical80
*
* Draws left-to-right y-major near-vertical lines using solid fills.
*
\**************************************************************************/

VOID vMmSolidVertical80(
PDEV*       ppdev,
STRIP*      pStrip,
LINESTATE*  pLineState)
{
    BYTE*   pjBase      = ppdev->pjBase ;
    LONG    cBpp        = ppdev->cBpp ;
    LONG    lDelta      = ppdev->lDelta ;
    LONG    cStrips     = pStrip->cStrips ;
    PLONG   pStrips     = pStrip->alStrips ;
    LONG    x           = pStrip->ptlStart.x ;
    LONG    y           = pStrip->ptlStart.y ;
    LONG    xOrg        = x ;
    LONG    x0, y0, cy ;

    ULONG   ulDstOffset = 0 ;
    ULONG_PTR* ulCLStart ;
    ULONG   ulWidthHeight ;

    LONG    i           = 0 ;
    BYTE    MM1B ;

    DISPDBG((2, "vMmSolidVertical80")) ;

    if (!(pStrip->flFlips & FL_FLIP_V))
    {
        //
        //                  |     1.
        // Vertical strips  v
        //                   |     2.
        //                   v
        //
        if (cStrips != 1)
        {
            MM1B = ENABLE_COMMAND_LIST | ENABLE_XY_POSITION | SRC_CPU_DATA ;
            CP_MM_BLT_EXT_MODE(ppdev, pjBase, MM1B) ;
Loop_V1:
            ulCLStart = ppdev->pCommandList ;
            ulDstOffset = (ULONG)(((ULONG_PTR)ulCLStart
                                 - (ULONG_PTR)ppdev->pjScreen) << 14) ;
            CP_MM_CL_SWITCH(ppdev) ;

            // First strip
            x0 = x ; 
            y0 = y ;
            cy = *pStrips ;
            i++ ;

            // Next strip
            x++ ; 
            y += cy ; 
            pStrips++ ;

            while (TRUE)
            {
                // GR20, GR21, GR22, GR23
                ulWidthHeight = PACKXY_FAST(0, (*pStrips - 1)) ;
                ulWidthHeight |= COMMAND_NOSRC_NOTHING ;

                // GR40, GR41, GR42, GR43
                *(ulCLStart + 1) = PACKXY_FAST(x, y) ;

                // GR2C, GR2D, GR2E
                *(ulCLStart + 2) = 0 ;

                i++ ;

                if ((i == cStrips) || ((i % count) == 0))
                {
                    // Last Command
                    ulWidthHeight |= COMMAND_LAST_PACKET ;
                    *ulCLStart = ulWidthHeight ;
                    break ;
                }
                *ulCLStart = ulWidthHeight ;

                // Next strip
                x++ ;
                y += *pStrips ; 
                pStrips++ ;
                ulCLStart += 4 ;
            }
            CP_MM_WAIT_FOR_BLT_COMPLETE(ppdev, pjBase) ;
            CP_MM_XCNT(ppdev, pjBase, 0) ;
            CP_MM_YCNT(ppdev, pjBase, (cy - 1)) ;
            CP_MM_DST_ADDR(ppdev, pjBase, ulDstOffset) ;
            CP_MM_DST_Y(ppdev, pjBase, y0) ;
            CP_MM_DST_X(ppdev, pjBase, x0) ;

            if (i == cStrips)
                y += *pStrips ; 
            else if ((i % count) == 0) 
            {
                // 
                // Resume a new command list
                //
                x++ ;
                cy = *pStrips ;
                y += cy ; 
                pStrips++ ; 
                if (i != (cStrips - 1))
                {
                    goto Loop_V1 ;
                }
                else
                {
                    MM_DRAW_VERT_STRIP80(x, y, *pStrips) ;
                    y += *pStrips ;
                    pStrips++;
                }
            }
        }
        else
        {
            MM_DRAW_VERT_STRIP80(x, y, *pStrips) ;
            y += *pStrips ;
            pStrips++;
        }
    }
    else
    {
        //
        //                   ^
        // Vertical strips   |     2.
        //                  ^
        //                  |     1.
        //

        if (cStrips != 1)
        {
            MM1B = ENABLE_COMMAND_LIST | ENABLE_XY_POSITION | SRC_CPU_DATA ;
            CP_MM_BLT_EXT_MODE(ppdev, pjBase, MM1B) ;
Loop_V2:
            ulCLStart = ppdev->pCommandList ;
            ulDstOffset = (ULONG)(((ULONG_PTR)ulCLStart
                                 - (ULONG_PTR)ppdev->pjScreen) << 14) ;
            CP_MM_CL_SWITCH(ppdev) ;

            // First strip
            x0 = x ;
            cy = *pStrips ;
            y -= (cy - 1) ;
            y0 = y ;

            i++ ;
            pStrips++ ;

            // Next strip
            x++ ;
            y -= *pStrips ;

            while (TRUE)
            {
                // GR20, GR21, GR22, GR23
                ulWidthHeight = PACKXY_FAST(0, (*pStrips - 1)) ;
                ulWidthHeight |= COMMAND_NOSRC_NOTHING ;

                // GR40, GR41, GR42, GR43
                *(ulCLStart + 1) = PACKXY_FAST(x, y) ;

                // GR2C, GR2D, GR2E
                *(ulCLStart + 2) = 0 ;

                i++ ;

                if ((i == cStrips) || ((i % count) == 0))
                {
                    // Last Command
                    ulWidthHeight |= COMMAND_LAST_PACKET ;
                    *ulCLStart = ulWidthHeight ;
                    break ;
                }
                *ulCLStart = ulWidthHeight ;

                // Next strip
                x++ ;
                pStrips++ ;
                y -= *pStrips ; 

                ulCLStart += 4 ;
            }

            CP_MM_WAIT_FOR_BLT_COMPLETE(ppdev, pjBase) ;
            CP_MM_XCNT(ppdev, pjBase, 0) ;
            CP_MM_YCNT(ppdev, pjBase, (cy - 1)) ;
            CP_MM_DST_ADDR(ppdev, pjBase, ulDstOffset) ;
            CP_MM_DST_Y(ppdev, pjBase, y0) ;
            CP_MM_DST_X(ppdev, pjBase, x0);

            if (i == cStrips)
                y -= *pStrips ; 
            else if ((i % count) == 0)
            {
                // 
                // Resume a new command list
                //
                x++ ;
                y-- ; 
                pStrips++ ; 

                if (i != (cStrips - 1))
                {
                    goto Loop_V2 ;
                }
                else
                {
                    MM_DRAW_VERT_STRIP80(x, y, *pStrips) ;
                    y -= *pStrips ;
                    pStrips++;
                }
            }
        }
        else
        {
            MM_DRAW_VERT_STRIP_FLIPPED80(x, y, *pStrips) ;
            y -= *pStrips ;
            pStrips++;
        }
    }

    xOrg += cStrips ;
    pStrip->ptlStart.x = xOrg ;
    pStrip->ptlStart.y = y    ;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\cirrus\disp\stroke.c ===
/******************************************************************************\
*
* $Workfile:   stroke.c  $
*
* DrvStrokePath for the display driver.
*
* Copyright (c) 1992-1995 Microsoft Corporation
* Copyright (c) 1996 Cirrus Logic, Inc.
*
* $Log:   S:/projects/drivers/ntsrc/display/STROKE.C_V  $
 *
 *    Rev 1.3   10 Jan 1997 15:40:18   PLCHU
 *
 *
 *    Rev 1.2   Nov 07 1996 16:48:06   unknown
 *
 *
 *    Rev 1.1   Oct 10 1996 15:39:26   unknown
 *
*
*    Rev 1.1   12 Aug 1996 16:55:06   frido
* Removed unaccessed local variables.
*
*    chu01  : 01-02-97  5480 BitBLT enhancement
*
*
\******************************************************************************/

#include "precomp.h"

VOID (*gapfnStripMm[])(PDEV*, STRIP*, LINESTATE*) = {
    vMmSolidHorizontal,
    vMmSolidVertical,
    vInvalidStrip,              // Diagonal
    vInvalidStrip,              // Diagonal

// Should be NUM_STRIP_DRAW_DIRECTIONS = 4 strip drawers in every group

    vMmSolidHorizontal,
    vMmSolidVertical,
    vInvalidStrip,              // Diagonal
    vInvalidStrip,              // Diagonal

// Should be NUM_STRIP_DRAW_STYLES = 8 strip drawers in total for doing
// solid lines, and the same number for non-solid lines:

    vMmStyledHorizontal,
    vMmStyledVertical,
    vInvalidStrip,              // Diagonal
    vInvalidStrip,              // Diagonal

    vMmStyledHorizontal,
    vMmStyledVertical,
    vInvalidStrip,              // Diagonal
    vInvalidStrip,              // Diagonal
};

VOID (*gapfnStripIo[])(PDEV*, STRIP*, LINESTATE*) = {
    vIoSolidHorizontal,
    vIoSolidVertical,
    vInvalidStrip,              // Diagonal
    vInvalidStrip,              // Diagonal

// Should be NUM_STRIP_DRAW_DIRECTIONS = 4 strip drawers in every group

    vIoSolidHorizontal,
    vIoSolidVertical,
    vInvalidStrip,              // Diagonal
    vInvalidStrip,              // Diagonal

// Should be NUM_STRIP_DRAW_STYLES = 8 strip drawers in total for doing
// solid lines, and the same number for non-solid lines:

    vIoStyledHorizontal,
    vIoStyledVertical,
    vInvalidStrip,              // Diagonal
    vInvalidStrip,              // Diagonal

    vIoStyledHorizontal,
    vIoStyledVertical,
    vInvalidStrip,              // Diagonal
    vInvalidStrip,              // Diagonal
};

// chu01
VOID (*gapfnPackedStripMm[])(PDEV*, STRIP*, LINESTATE*) = {
    vMmSolidHorizontal80,
    vMmSolidVertical80,
    vInvalidStrip,              // Diagonal
    vInvalidStrip,              // Diagonal

// Should be NUM_STRIP_DRAW_DIRECTIONS = 4 strip drawers in every group

    vMmSolidHorizontal80,
    vMmSolidVertical80,
    vInvalidStrip,              // Diagonal
    vInvalidStrip,              // Diagonal

// Should be NUM_STRIP_DRAW_STYLES = 8 strip drawers in total for doing
// solid lines, and the same number for non-solid lines:

    vMmStyledHorizontal,
    vMmStyledVertical,
    vInvalidStrip,              // Diagonal
    vInvalidStrip,              // Diagonal

    vMmStyledHorizontal,
    vMmStyledVertical,
    vInvalidStrip,              // Diagonal
    vInvalidStrip,              // Diagonal
};

// Style array for alternate style (alternates one pixel on, one pixel off):

STYLEPOS gaspAlternateStyle[] = { 1 };

BOOL bPuntStrokePath(
SURFOBJ   *pso,
PATHOBJ   *ppo,
CLIPOBJ   *pco,
XFORMOBJ  *pxo,
BRUSHOBJ  *pbo,
POINTL    *pptlBrushOrg,
LINEATTRS *plineattrs,
MIX        mix);


/******************************Public*Routine******************************\
* BOOL DrvStrokePath(pso, ppo, pco, pxo, pbo, pptlBrush, pla, mix)
*
* Strokes the path.
*
\**************************************************************************/

BOOL DrvStrokePath(
    SURFOBJ*   pso,
    PATHOBJ*   ppo,
    CLIPOBJ*   pco,
    XFORMOBJ*  pxo,
    BRUSHOBJ*  pbo,
    POINTL*    pptlBrush,
    LINEATTRS* pla,
    MIX        mix)
{
    PDEV    *ppdev = (PDEV*) pso->dhpdev;
    DSURF   *pdsurf;
    OH*      poh;
    LONG     cBpp;
    BYTE     jHwRop;
    BYTE     jMode;
    ULONG    ulSolidColor;

    STYLEPOS  aspLtoR[STYLE_MAX_COUNT];
    STYLEPOS  aspRtoL[STYLE_MAX_COUNT];
    LINESTATE ls;
    PFNSTRIP* apfn;
    FLONG     fl;
    RECTL     arclClip[4];                  // For rectangular clipping

    if ((mix & 0xf) != 0x0d) DISPDBG((3,"Line with mix(%x)", mix));

    // Pass the surface off to GDI if it's a device bitmap that we've
    // converted to a DIB:

    pdsurf = (DSURF*) pso->dhsurf;
    if (pdsurf->dt == DT_DIB)
    {
        return(EngStrokePath(pdsurf->pso, ppo, pco, pxo, pbo, pptlBrush,
                             pla, mix));
    }

    // We'll be drawing to the screen or an off-screen DFB; copy the surface's
    // offset now so that we won't need to refer to the DSURF again:

    poh   = pdsurf->poh;
    cBpp  = ppdev->cBpp;

    ppdev->xOffset  = poh->x;
    ppdev->yOffset  = poh->y;
    ppdev->xyOffset = poh->xy;

    if ((DRIVER_PUNT_ALL) || (DRIVER_PUNT_LINES))
    {
        return bPuntStrokePath(pso,ppo,pco,pxo,pbo,pptlBrush,pla,mix);
    }

    //
    // Get the device ready:
    //

    jHwRop = gajHwMixFromMix[mix & 0xf];

    // Get the color expanded to a DWORD in the blt parameters.
    // replicate the color from a byte to a dword.
    // NOTE: this is pixel depth specific.

    jMode = ENABLE_COLOR_EXPAND |
            ENABLE_8x8_PATTERN_COPY |
            ppdev->jModeColor;

    ulSolidColor = pbo->iSolidColor;

    if (cBpp == 1)
    {
        ulSolidColor |= ulSolidColor << 8;
        ulSolidColor |= ulSolidColor << 16;
    }
    else if (cBpp == 2)
    {
        ulSolidColor |= ulSolidColor << 16;
    }

//
// chu01
//
    if ((ppdev->flCaps & CAPS_COMMAND_LIST) && (ppdev->pCommandList != NULL))
    {
        ULONG    jULHwRop                 ;
        DWORD    jExtMode = 0             ;
        BYTE*    pjBase   = ppdev->pjBase ;

        jULHwRop = gajHwPackedMixFromMix[mix & 0xf] ;
        jExtMode = (ENABLE_XY_POSITION_PACKED | ENABLE_COLOR_EXPAND |
                     ENABLE_8x8_PATTERN_COPY | ppdev->jModeColor) ;
        CP_MM_WAIT_FOR_BLT_COMPLETE(ppdev, pjBase) ;
        CP_MM_SRC_ADDR(ppdev, pjBase, ppdev->ulSolidColorOffset) ;
        CP_MM_DST_Y_OFFSET(ppdev, pjBase, ppdev->lDelta) ;
        CP_MM_BLT_MODE_PACKED(ppdev, pjBase, jExtMode | jULHwRop) ;
        CP_MM_FG_COLOR(ppdev, pjBase, ulSolidColor) ;
    }
    else
    {
        if (ppdev->flCaps & CAPS_MM_IO)
        {
            BYTE * pjBase = ppdev->pjBase;

            CP_MM_WAIT_FOR_BLT_COMPLETE(ppdev, pjBase);
            CP_MM_ROP(ppdev, pjBase, jHwRop);
            CP_MM_SRC_ADDR(ppdev, pjBase, ppdev->ulSolidColorOffset);
            CP_MM_DST_Y_OFFSET(ppdev, pjBase, ppdev->lDelta);
            CP_MM_BLT_MODE(ppdev, pjBase, jMode);
            CP_MM_FG_COLOR(ppdev, pjBase, ulSolidColor);
        }
        else
        {
            BYTE * pjPorts = ppdev->pjPorts;

            CP_IO_WAIT_FOR_BLT_COMPLETE(ppdev, pjPorts);
            CP_IO_ROP(ppdev, pjPorts, jHwRop);
            CP_IO_SRC_ADDR(ppdev, pjPorts, ppdev->ulSolidColorOffset);
            CP_IO_DST_Y_OFFSET(ppdev, pjPorts, ppdev->lDelta);
            CP_IO_BLT_MODE(ppdev, pjPorts, jMode);
            CP_IO_FG_COLOR(ppdev, pjPorts, ulSolidColor);
        }
     }

    fl = 0;

// Look after styling initialization:

    if (pla->fl & LA_ALTERNATE)
    {
        ls.cStyle      = 1;
        ls.spTotal     = 1;
        ls.spTotal2    = 2;
        ls.spRemaining = 1;
        ls.aspRtoL     = &gaspAlternateStyle[0];
        ls.aspLtoR     = &gaspAlternateStyle[0];
        ls.spNext      = HIWORD(pla->elStyleState.l);
        ls.xyDensity   = 1;
        fl            |= FL_STYLED;
        ls.ulStartMask = 0L;
    }
    else if (pla->pstyle != (FLOAT_LONG*) NULL)
    {
        PFLOAT_LONG pstyle;
        STYLEPOS*   pspDown;
        STYLEPOS*   pspUp;

        pstyle = &pla->pstyle[pla->cstyle];

        ls.xyDensity = STYLE_DENSITY;
        ls.spTotal   = 0;
        while (pstyle-- > pla->pstyle)
        {
            ls.spTotal += pstyle->l;
        }
        ls.spTotal *= STYLE_DENSITY;
        ls.spTotal2 = 2 * ls.spTotal;

    // Compute starting style position (this is guaranteed not to overflow):

        ls.spNext = HIWORD(pla->elStyleState.l) * STYLE_DENSITY +
                    LOWORD(pla->elStyleState.l);

        fl        |= FL_STYLED;
        ls.cStyle  = pla->cstyle;
        ls.aspRtoL = aspRtoL;
        ls.aspLtoR = aspLtoR;

        if (pla->fl & LA_STARTGAP)
            ls.ulStartMask = 0xffffffffL;
        else
            ls.ulStartMask = 0L;

        pstyle  = pla->pstyle;
        pspDown = &ls.aspRtoL[ls.cStyle - 1];
        pspUp   = &ls.aspLtoR[0];

        while (pspDown >= &ls.aspRtoL[0])
        {
            *pspDown = pstyle->l * STYLE_DENSITY;
            *pspUp   = *pspDown;

            pspUp++;
            pspDown--;
            pstyle++;
        }
    }

// chu01
    if ((ppdev->flCaps & CAPS_COMMAND_LIST) && (ppdev->pCommandList != NULL))
    {
        apfn = &gapfnPackedStripMm[NUM_STRIP_DRAW_STYLES *
                ((fl & FL_STYLE_MASK) >> FL_STYLE_SHIFT)];
    }
    else if (ppdev->flCaps & CAPS_MM_IO)
    {
        apfn = &gapfnStripMm[NUM_STRIP_DRAW_STYLES *
                ((fl & FL_STYLE_MASK) >> FL_STYLE_SHIFT)];
    }
    else
    {
        apfn = &gapfnStripIo[NUM_STRIP_DRAW_STYLES *
                ((fl & FL_STYLE_MASK) >> FL_STYLE_SHIFT)];
    }

// Set up to enumerate the path:

    if (pco->iDComplexity != DC_COMPLEX)
    {
        PATHDATA  pd;
        RECTL*    prclClip = (RECTL*) NULL;
        BOOL      bMore;
        ULONG     cptfx;
        POINTFIX  ptfxStartFigure;
        POINTFIX  ptfxLast;
        POINTFIX* pptfxFirst;
        POINTFIX* pptfxBuf;

        if (pco->iDComplexity == DC_RECT)
        {
            fl |= FL_SIMPLE_CLIP;

            arclClip[0]        =  pco->rclBounds;

        // FL_FLIP_D:

            arclClip[1].top    =  pco->rclBounds.left;
            arclClip[1].left   =  pco->rclBounds.top;
            arclClip[1].bottom =  pco->rclBounds.right;
            arclClip[1].right  =  pco->rclBounds.bottom;

        // FL_FLIP_V:

            arclClip[2].top    = -pco->rclBounds.bottom + 1;
            arclClip[2].left   =  pco->rclBounds.left;
            arclClip[2].bottom = -pco->rclBounds.top + 1;
            arclClip[2].right  =  pco->rclBounds.right;

        // FL_FLIP_V | FL_FLIP_D:

            arclClip[3].top    =  pco->rclBounds.left;
            arclClip[3].left   = -pco->rclBounds.bottom + 1;
            arclClip[3].bottom =  pco->rclBounds.right;
            arclClip[3].right  = -pco->rclBounds.top + 1;

            prclClip = arclClip;
        }

        pd.flags = 0;
        PATHOBJ_vEnumStart(ppo);
        do {
            bMore = PATHOBJ_bEnum(ppo, &pd);

            cptfx = pd.count;
            if (cptfx == 0)
            {
                break;
            }

            if (pd.flags & PD_BEGINSUBPATH)
            {
                ptfxStartFigure  = *pd.pptfx;
                pptfxFirst       = pd.pptfx;
                pptfxBuf         = pd.pptfx + 1;
                cptfx--;
            }
            else
            {
                pptfxFirst       = &ptfxLast;
                pptfxBuf         = pd.pptfx;
            }

            if (pd.flags & PD_RESETSTYLE)
                ls.spNext = 0;

            if (cptfx > 0)
            {
                if (!bLines(ppdev,
                            pptfxFirst,
                            pptfxBuf,
                            (RUN*) NULL,
                            cptfx,
                            &ls,
                            prclClip,
                            apfn,
                            fl))
                    goto ReturnFalse;
            }

            ptfxLast = pd.pptfx[pd.count - 1];

            if (pd.flags & PD_CLOSEFIGURE)
            {
                if (!bLines(ppdev,
                            &ptfxLast,
                            &ptfxStartFigure,
                            (RUN*) NULL,
                            1,
                            &ls,
                            prclClip,
                            apfn,
                            fl))
                    goto ReturnFalse;
            }
        } while (bMore);

        if (fl & FL_STYLED)
        {
        // Save the style state:

            ULONG ulHigh;
            ULONG ulLow;

        // Masked styles don't normalize the style state.  It's a good
        // thing to do, so let's do it now:

            if ((ULONG) ls.spNext >= (ULONG) ls.spTotal2)
                ls.spNext = (ULONG) ls.spNext % (ULONG) ls.spTotal2;

            ulHigh = ls.spNext / ls.xyDensity;
            ulLow  = ls.spNext % ls.xyDensity;

            pla->elStyleState.l = MAKELONG(ulLow, ulHigh);
        }
    }
    else
    {
    // Local state for path enumeration:

        BOOL bMore;
        union {
            BYTE     aj[offsetof(CLIPLINE, arun) + RUN_MAX * sizeof(RUN)];
            CLIPLINE cl;
        } cl;

        fl |= FL_COMPLEX_CLIP;

    // We use the clip object when non-simple clipping is involved:

        PATHOBJ_vEnumStartClipLines(ppo, pco, pso, pla);

        do {
            bMore = PATHOBJ_bEnumClipLines(ppo, sizeof(cl), &cl.cl);
            if (cl.cl.c != 0)
            {
                if (fl & FL_STYLED)
                {
                    ls.spComplex = HIWORD(cl.cl.lStyleState) * ls.xyDensity
                                 + LOWORD(cl.cl.lStyleState);
                }
                if (!bLines(ppdev,
                            &cl.cl.ptfxA,
                            &cl.cl.ptfxB,
                            &cl.cl.arun[0],
                            cl.cl.c,
                            &ls,
                            (RECTL*) NULL,
                            apfn,
                            fl))
                    goto ReturnFalse;
            }
        } while (bMore);
    }

    return(TRUE);

ReturnFalse:
    return(FALSE);
}


BOOL bPuntStrokePath(
    SURFOBJ*   pso,
    PATHOBJ*   ppo,
    CLIPOBJ*   pco,
    XFORMOBJ*  pxo,
    BRUSHOBJ*  pbo,
    POINTL*    pptlBrush,
    LINEATTRS* pla,
    MIX        mix)
{
    PDEV* ppdev = (PDEV*) pso->dhpdev;
    BOOL     b = TRUE;

    if (pso->iType == STYPE_BITMAP)
    {
        b = EngStrokePath(pso,ppo,pco,pxo,pbo,
                          pptlBrush,pla,mix);
        goto ReturnStatus;
    }

    if (DIRECT_ACCESS(ppdev))
    {
        //////////////////////////////////////////////////////////////////////
        // Banked Framebuffer bPuntBlt
        //
        // This section of code handles a PuntBlt when GDI can directly draw
        // on the framebuffer, but the drawing has to be done in banks:

        BANK     bnk;

        {
            ASSERTDD(pso->iType != STYPE_BITMAP,
                     "Dest should be the screen");

            // Do a memory-to-screen blt:

            if (ppdev->bLinearMode)
            {
                SURFOBJ* psoPunt = ppdev->psoPunt;
                OH*      poh     = ((DSURF*) pso->dhsurf)->poh;

                psoPunt->pvScan0 = poh->pvScan0;
                ppdev->pfnBankSelectMode(ppdev, BANK_ON);

                b = EngStrokePath(psoPunt,ppo,pco,pxo,pbo,
                                  pptlBrush,pla,mix);

                goto ReturnStatus;
            }

            {
                RECTL   rclDraw;
                RECTL  *prclDst = &pco->rclBounds;

                FLOAT_LONG  elSavedStyleState = pla->elStyleState;

                {
                    // The bank manager requires that the 'draw' rectangle be
                    // well-ordered:

                    rclDraw = *prclDst;
                    if (rclDraw.left > rclDraw.right)
                    {
                        rclDraw.left   = prclDst->right;
                        rclDraw.right  = prclDst->left;
                    }
                    if (rclDraw.top > rclDraw.bottom)
                    {
                        rclDraw.top    = prclDst->bottom;
                        rclDraw.bottom = prclDst->top;
                    }

                    vBankStart(ppdev, &rclDraw, pco, &bnk);

                    b = TRUE;
                    do {
                        pla->elStyleState = elSavedStyleState;

                        b &= EngStrokePath(bnk.pso,
                                           ppo,
                                           bnk.pco,
                                           pxo,
                                           pbo,
                                           pptlBrush,
                                           pla,
                                           mix);
                    } while (bBankEnum(&bnk));
                }
            }
        }

        goto ReturnStatus;
    }
    else
    {
        //////////////////////////////////////////////////////////////////////
        // Really Slow bPuntStrokePath
        //
        // Here we handle a bPuntStrokePath when GDI can't draw directly on the
        // framebuffer (as on the Alpha, which can't do it because of its
        // 32 bit bus).  If you thought the banked version was slow, just
        // look at this one.  Guaranteed, there will one bitmap
        // allocation and extra copy involved

        RECTL   rclDst;
        RECTFX  rcfxBounds;
        SIZEL   sizl;
        LONG    lDelta;
        BYTE*   pjBits;
        BYTE*   pjScan0;
        HSURF   hsurfDst;
        RECTL   rclScreen;

        PATHOBJ_vGetBounds(ppo, &rcfxBounds);

        rclDst.left   = (rcfxBounds.xLeft   >> 4);
        rclDst.top    = (rcfxBounds.yTop    >> 4);
        rclDst.right  = (rcfxBounds.xRight  >> 4) + 2;
        rclDst.bottom = (rcfxBounds.yBottom >> 4) + 2;

        //
        // This function is guarenteed to get a clip object.  Since the
        // rounding of the above calculation can give us a rectangle
        // outside the screen area, we must clip to the drawing area.
        //

        {
            ASSERTDD(pco != NULL, "clip object pointer is NULL");

            // We have to intersect the destination rectangle with
            // the clip bounds if there is one (consider the case
            // where the app asked to blt a really, really big
            // rectangle from the screen -- prclDst would be really,
            // really big but pco->rclBounds would be the actual
            // area of interest):

            rclDst.left   = max(rclDst.left,   pco->rclBounds.left);
            rclDst.top    = max(rclDst.top,    pco->rclBounds.top);
            rclDst.right  = min(rclDst.right,  pco->rclBounds.right);
            rclDst.bottom = min(rclDst.bottom, pco->rclBounds.bottom);
        }

        sizl.cx = rclDst.right  - rclDst.left;
        sizl.cy = rclDst.bottom - rclDst.top;

        // We need to create a temporary work buffer.  We have to do
        // some fudging with the offsets so that the upper-left corner
        // of the (relative coordinates) clip object bounds passed to
        // GDI will be transformed to the upper-left corner of our
        // temporary bitmap.

        // The alignment doesn't have to be as tight as this at 16bpp
        // and 32bpp, but it won't hurt:

        lDelta = PELS_TO_BYTES(((rclDst.right + 3) & ~3L) - (rclDst.left & ~3L));

        // We're actually only allocating a bitmap that is 'sizl.cx' x
        // 'sizl.cy' in size:

        pjBits = ALLOC(lDelta * sizl.cy);
        if (pjBits == NULL)
            goto ReturnStatus;

        // We now adjust the surface's 'pvScan0' so that when GDI thinks
        // it's writing to pixel (rclDst.top, rclDst.left), it will
        // actually be writing to the upper-left pixel of our temporary
        // bitmap:

        pjScan0 = pjBits - (rclDst.top * lDelta)
                         - PELS_TO_BYTES(rclDst.left & ~3L);

        ASSERTDD((((ULONG_PTR) pjScan0) & 3) == 0,
                "pvScan0 must be dword aligned!");

        // The checked build of GDI sometimes checks on blts that
        // prclDst->right <= pso->sizl.cx, so we lie to it about
        // the size of our bitmap:

        sizl.cx = rclDst.right;
        sizl.cy = rclDst.bottom;

        hsurfDst = (HSURF) EngCreateBitmap(
                    sizl,                   // Bitmap covers rectangle
                    lDelta,                 // Use this delta
                    ppdev->iBitmapFormat,   // Same colour depth
                    BMF_TOPDOWN,            // Must have a positive delta
                    NULL); //pjScan0);               // Where (0, 0) would be

        if ((hsurfDst == 0) ||
            (!EngAssociateSurface(hsurfDst, ppdev->hdevEng, 0)))
        {
            DISPDBG((0,"bPuntStrokePath - EngCreateBitmap or "
                       "EngAssociateSurface failed"));
            goto Error_3;
        }

        pso = EngLockSurface(hsurfDst);
        if (pso == NULL)
        {
            DISPDBG((0,"bPuntStrokePath - EngLockSurface failed"));
            goto Error_4;
        }

        // Make sure that the rectangle we Get/Put from/to the screen
        // is in absolute coordinates:

        rclScreen.left   = rclDst.left   + ppdev->xOffset;
        rclScreen.right  = rclDst.right  + ppdev->xOffset;
        rclScreen.top    = rclDst.top    + ppdev->yOffset;
        rclScreen.bottom = rclDst.bottom + ppdev->yOffset;

        // It would be nice to get a copy of the destination rectangle
        // only when the ROP involves the destination (or when the source
        // is an RLE), but we can't do that.  If the brush is truly NULL,
        // GDI will immediately return TRUE from EngBitBlt, without
        // modifying the temporary bitmap -- and we would proceed to
        // copy the uninitialized temporary bitmap back to the screen.

        ppdev->pfnGetBits(ppdev, pso, &rclDst, (POINTL*) &rclScreen);

        b = EngStrokePath(pso,ppo,pco,pxo,pbo,
                          pptlBrush,pla,mix);

        ppdev->pfnPutBits(ppdev, pso, &rclScreen, (POINTL*) &rclDst);

        EngUnlockSurface(pso);

    Error_4:

        EngDeleteSurface(hsurfDst);

    Error_3:

        FREE(pjBits);
    }

ReturnStatus:

    return(b);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\cirrus\disp\stripio.c ===
/******************************************************************************\
*
* $Workfile:   stripio.c  $
*
* Do what you can with no line support.
*
* I implemented the horizontal and vertical strip functions using
* solid fills, and removed the usage of diagonal strips.  With a little
* effort you could implement diagonal strips by doing solid fills while
* playing with lDelta.  This is probably not worth the trouble.
*
* Copyright (c) 1992-1995 Microsoft Corporation
* Copyright (c) 1996 Cirrus Logic, Inc.
*
* $Log:   S:/projects/drivers/ntsrc/display/stripio.c_v  $
 * 
 *    Rev 1.1   Oct 10 1996 15:39:12   unknown
 *  
* 
*    Rev 1.1   12 Aug 1996 16:55:04   frido
* Removed unaccessed local variables.
*
\******************************************************************************/

#include "precomp.h"

#define IO_DRAW_HORZ_STRIP(xy, cx, lDelta, cBpp)\
{\
    ULONG   ulDstAddr;\
\
    ulDstAddr = xy;\
\
    CP_IO_WAIT_FOR_BLT_COMPLETE(ppdev, pjPorts);\
    CP_IO_XCNT(ppdev, pjPorts, (PELS_TO_BYTES(cx) - 1));\
    CP_IO_YCNT(ppdev, pjPorts, 0);\
    CP_IO_DST_ADDR(ppdev, pjPorts, ulDstAddr);\
    CP_IO_START_BLT(ppdev, pjPorts);\
}

#define IO_DRAW_VERT_STRIP(xy, cy, lDelta, cBpp)\
{\
    ULONG   ulDstAddr;\
\
    ulDstAddr = xy;\
\
    CP_IO_WAIT_FOR_BLT_COMPLETE(ppdev, pjPorts);\
    CP_IO_XCNT(ppdev, pjPorts, (cBpp - 1));\
    CP_IO_YCNT(ppdev, pjPorts, (cy - 1));\
    CP_IO_DST_ADDR(ppdev, pjPorts, ulDstAddr);\
    CP_IO_START_BLT(ppdev, pjPorts);\
}

#define IO_DRAW_VERT_STRIP_FLIPPED(xy, cy, lDelta, cBpp)\
{\
    ULONG   ulDstAddr;\
\
    ulDstAddr = xy - ((cy - 1) * lDelta);\
\
    CP_IO_WAIT_FOR_BLT_COMPLETE(ppdev, pjPorts);\
    CP_IO_XCNT(ppdev, pjPorts, (cBpp - 1));\
    CP_IO_YCNT(ppdev, pjPorts, (cy - 1));\
    CP_IO_DST_ADDR(ppdev, pjPorts, ulDstAddr);\
    CP_IO_START_BLT(ppdev, pjPorts);\
}

/******************************Public*Routine******************************\
* VOID vIoSolidHorizontal
*
* Draws left-to-right x-major near-horizontal lines using solid fills.
*
* Assumes fgRop, BgRop, and Color are already set correctly.
*
\**************************************************************************/

VOID vIoSolidHorizontal(
PDEV*       ppdev,
STRIP*      pStrip,
LINESTATE*  pLineState)
{
    BYTE*   pjPorts  = ppdev->pjPorts;
    LONG    cBpp     = ppdev->cBpp;
    LONG    lDelta   = ppdev->lDelta;
    LONG    cStrips  = pStrip->cStrips;
    PLONG   pStrips  = pStrip->alStrips;
    LONG    x        = pStrip->ptlStart.x;
    LONG    y        = pStrip->ptlStart.y;
    LONG    xy       = PELS_TO_BYTES(x) + (lDelta * y);
    LONG    yInc     = 1;
    LONG    i;

    DISPDBG((2,"vIoSolidHorizontal"));

    if (!(pStrip->flFlips & FL_FLIP_V))
    {
        //
        // Horizontal strips ->
        //                     ->
        //

        for (i = 0; i < cStrips; i++)
        {
            IO_DRAW_HORZ_STRIP(xy, *pStrips, lDelta, cBpp);
            x += *pStrips;
            xy += PELS_TO_BYTES(*pStrips);  // x+
            xy += lDelta;                   // y+
            pStrips++;
        }
        y += cStrips;
    }
    else
    {
        //
        //                     ->
        // Horizontal strips ->
        //

        for (i = 0; i < cStrips; i++)
        {
            IO_DRAW_HORZ_STRIP(xy, *pStrips, lDelta, cBpp);
            x += *pStrips;
            xy += PELS_TO_BYTES(*pStrips);  // x+
            xy -= lDelta;                   // y+
            pStrips++;
        }
        y -= cStrips;
    }

    pStrip->ptlStart.x = x;
    pStrip->ptlStart.y = y;
}

/******************************Public*Routine******************************\
* VOID vIoSolidVertical
*
* Draws left-to-right y-major near-vertical lines using solid fills.
*
\**************************************************************************/

VOID vIoSolidVertical(
PDEV*       ppdev,
STRIP*      pStrip,
LINESTATE*  pLineState)
{
    BYTE*   pjPorts  = ppdev->pjPorts;
    LONG    cBpp     = ppdev->cBpp;
    LONG    lDelta   = ppdev->lDelta;
    LONG    cStrips  = pStrip->cStrips;
    PLONG   pStrips  = pStrip->alStrips;
    LONG    x        = pStrip->ptlStart.x;
    LONG    y        = pStrip->ptlStart.y;
    LONG    xy       = PELS_TO_BYTES(x) + (lDelta * y);
    LONG    i;

    DISPDBG((2,"vIoSolidVertical"));

    if (!(pStrip->flFlips & FL_FLIP_V))
    {
        //
        //                  |
        // Vertical strips  v
        //                   |
        //                   v
        //

        for (i = 0; i < cStrips; i++)
        {
            IO_DRAW_VERT_STRIP(xy, *pStrips, lDelta, cBpp);
            y += *pStrips;
            xy += cBpp;                 // x+
            xy += (*pStrips * lDelta);  // y+
            pStrips++;
        }
    }
    else
    {
        //
        //                   ^
        // Vertical strips   |
        //                  ^
        //                  |
        //

        for (i = 0; i < cStrips; i++)
        {
            IO_DRAW_VERT_STRIP_FLIPPED(xy, *pStrips, lDelta, cBpp);
            y -= *pStrips;
            xy += cBpp;                 // x+
            xy -= (*pStrips * lDelta);  // y-
            pStrips++;
        }
    }
    x += cStrips;

    pStrip->ptlStart.x = x;
    pStrip->ptlStart.y = y;
}

/******************************Public*Routine******************************\
* VOID vIoStyledHorizontal
*
* Takes the list of strips that define the pixels that would be lit for
* a solid line, and breaks them into styling chunks according to the
* styling information that is passed in.
*
* This particular routine handles x-major lines that run left-to-right,
* and are comprised of horizontal strips.  It draws the dashes using
* short-stroke vectors.
*
* The performance of this routine could be improved significantly if
* anyone cared enough about styled lines improve it.
*
\**************************************************************************/

VOID vIoStyledHorizontal(
PDEV*       ppdev,
STRIP*      pstrip,
LINESTATE*  pls)
{
    BYTE*   pjPorts  = ppdev->pjPorts;
    LONG    cBpp     = ppdev->cBpp;
    LONG    lDelta   = ppdev->lDelta;
    LONG    x        = pstrip->ptlStart.x;   // x position of start of first strip
    LONG    y        = pstrip->ptlStart.y;   // y position of start of first strip
    LONG    xy       = PELS_TO_BYTES(x) + (lDelta * y);
    LONG*   plStrip  = pstrip->alStrips;     // Points to current strip
    LONG    cStrips  = pstrip->cStrips;      // Total number of strips we'll do
    LONG    dy;
    LONG    dylDelta;
    LONG    cStyle;
    LONG    cStrip;
    LONG    cThis;
    ULONG   bIsGap;

    if (pstrip->flFlips & FL_FLIP_V)
    {
        // The minor direction of the line is 90 degrees, and the major
        // direction is 0 (it's a left-to-right x-major line going up):

        dy = -1;
        dylDelta = -lDelta;
    }
    else
    {
        // The minor direction of the line is 270 degrees, and the major
        // direction is 0 (it's a left-to-right x-major line going down):

        dy = 1;
        dylDelta = lDelta;
    }

    cStrip = *plStrip;              // Number of pels in first strip

    cStyle = pls->spRemaining;      // Number of pels in first 'gap' or 'dash'
    bIsGap = pls->ulStyleMask;      // Tells whether in a 'gap' or a 'dash'

    // ulStyleMask is non-zero if we're in the middle of a 'gap',
    // and zero if we're in the middle of a 'dash':

    if (bIsGap)
        goto SkipAGap;
    else
        goto OutputADash;

PrepareToSkipAGap:

    // Advance in the style-state array, so that we can find the next
    // 'dot' that we'll have to display:

    bIsGap = ~bIsGap;
    pls->psp++;
    if (pls->psp > pls->pspEnd)
        pls->psp = pls->pspStart;

    cStyle = *pls->psp;

    // If 'cStrip' is zero, we also need a new strip:

    if (cStrip != 0)
        goto SkipAGap;

    // Here, we're in the middle of a 'gap' where we don't have to
    // display anything.  We simply cycle through all the strips
    // we can, keeping track of the current position, until we run
    // out of 'gap':

    while (TRUE)
    {
        // Each time we loop, we move to a new scan and need a new strip:

        y += dy;
        xy += dylDelta;

        plStrip++;
        cStrips--;
        if (cStrips == 0)
            goto AllDone;

        cStrip = *plStrip;

    SkipAGap:

        cThis   = min(cStrip, cStyle);
        cStyle -= cThis;
        cStrip -= cThis;

        x += cThis;
        xy += PELS_TO_BYTES(cThis);

        if (cStyle == 0)
            goto PrepareToOutputADash;
    }

PrepareToOutputADash:

    // Advance in the style-state array, so that we can find the next
    // 'dot' that we'll have to display:

    bIsGap = ~bIsGap;
    pls->psp++;
    if (pls->psp > pls->pspEnd)
        pls->psp = pls->pspStart;

    cStyle = *pls->psp;

    // If 'cStrip' is zero, we also need a new strip.

    if (cStrip != 0)
    {
        // There's more to be done in the current strip:

        goto OutputADash;
    }

    // We've finished with the current strip:

    while (TRUE)
    {
        // Each time we loop, we move to a new scan and need a new strip:

        y += dy;
        xy += dylDelta;

        plStrip++;
        cStrips--;
        if (cStrips == 0)
            goto AllDone;

        cStrip = *plStrip;

    OutputADash:

        cThis   = min(cStrip, cStyle);
        cStyle -= cThis;
        cStrip -= cThis;

        IO_DRAW_HORZ_STRIP(xy, cThis, lDelta, cBpp);

        x += cThis;
        xy += PELS_TO_BYTES(cThis); // x+

        if (cStyle == 0)
            goto PrepareToSkipAGap;
    }

AllDone:

    // Update our state variables so that the next line can continue
    // where we left off:

    pls->spRemaining   = cStyle;
    pls->ulStyleMask   = bIsGap;
    pstrip->ptlStart.x = x;
    pstrip->ptlStart.y = y;
}

/******************************Public*Routine******************************\
* VOID vIoStyledVertical
*
* Takes the list of strips that define the pixels that would be lit for
* a solid line, and breaks them into styling chunks according to the
* styling information that is passed in.
*
* This particular routine handles y-major lines that run left-to-right,
* and are comprised of vertical strips.  It draws the dashes using
* short-stroke vectors.
*
* The performance of this routine could be improved significantly if
* anyone cared enough about styled lines improve it.
*
\**************************************************************************/

VOID vIoStyledVertical(
PDEV*       ppdev,
STRIP*      pstrip,
LINESTATE*  pls)
{
    BYTE*   pjPorts  = ppdev->pjPorts;
    LONG    cBpp     = ppdev->cBpp;
    LONG    lDelta   = ppdev->lDelta;
    LONG    x        = pstrip->ptlStart.x;   // x position of start of first strip
    LONG    y        = pstrip->ptlStart.y;   // y position of start of first strip
    LONG    xy       = PELS_TO_BYTES(x) + (lDelta * y);
    LONG*   plStrip  = pstrip->alStrips;     // Points to current strip
    LONG    cStrips  = pstrip->cStrips;      // Total number of strips we'll do
    LONG    dy;
    LONG    dylDelta;
    LONG    cStyle;
    LONG    cStrip;
    LONG    cThis;
    ULONG   bIsGap;

    if (pstrip->flFlips & FL_FLIP_V)
    {
        // The minor direction of the line is 0 degrees, and the major
        // direction is 90 (it's a left-to-right y-major line going up):

        dy = -1;
        dylDelta = -lDelta;
    }
    else
    {
        // The minor direction of the line is 0 degrees, and the major
        // direction is 270 (it's a left-to-right y-major line going down):

        dy = 1;
        dylDelta = lDelta;
    }

    cStrip = *plStrip;              // Number of pels in first strip

    cStyle = pls->spRemaining;      // Number of pels in first 'gap' or 'dash'
    bIsGap = pls->ulStyleMask;      // Tells whether in a 'gap' or a 'dash'

    // ulStyleMask is non-zero if we're in the middle of a 'gap',
    // and zero if we're in the middle of a 'dash':

    if (bIsGap)
        goto SkipAGap;
    else
        goto OutputADash;

PrepareToSkipAGap:

    // Advance in the style-state array, so that we can find the next
    // 'dot' that we'll have to display:

    bIsGap = ~bIsGap;
    pls->psp++;
    if (pls->psp > pls->pspEnd)
        pls->psp = pls->pspStart;

    cStyle = *pls->psp;

    // If 'cStrip' is zero, we also need a new strip:

    if (cStrip != 0)
        goto SkipAGap;

    // Here, we're in the middle of a 'gap' where we don't have to
    // display anything.  We simply cycle through all the strips
    // we can, keeping track of the current position, until we run
    // out of 'gap':

    while (TRUE)
    {
        // Each time we loop, we move to a new column and need a new strip:

        xy += cBpp;
        x++;

        plStrip++;
        cStrips--;
        if (cStrips == 0)
            goto AllDone;

        cStrip = *plStrip;

    SkipAGap:

        cThis   = min(cStrip, cStyle);
        cStyle -= cThis;
        cStrip -= cThis;

        if (dy > 0)
        {
            y += cThis;
            xy += (cThis * lDelta);
        }
        else
        {
            y -= cThis;
            xy -= (cThis * lDelta);
        }

        if (cStyle == 0)
            goto PrepareToOutputADash;
    }

PrepareToOutputADash:

    // Advance in the style-state array, so that we can find the next
    // 'dot' that we'll have to display:

    bIsGap = ~bIsGap;
    pls->psp++;
    if (pls->psp > pls->pspEnd)
        pls->psp = pls->pspStart;

    cStyle = *pls->psp;

    // If 'cStrip' is zero, we also need a new strip.

    if (cStrip != 0)
    {
        // There's more to be done in the current strip:

        goto OutputADash;
    }

    // We've finished with the current strip:

    while (TRUE)
    {
        // Each time we loop, we move to a new column and need a new strip:

        xy += cBpp;
        x++;

        plStrip++;
        cStrips--;
        if (cStrips == 0)
            goto AllDone;

        cStrip = *plStrip;

    OutputADash:

        cThis   = min(cStrip, cStyle);
        cStyle -= cThis;
        cStrip -= cThis;

        if (dy <= 0)
        {
            IO_DRAW_VERT_STRIP_FLIPPED(xy, cThis, lDelta, cBpp);
            y -=  cThis;                // y-
            xy -=  (cThis * lDelta);    // y-
        }
        else
        {
            IO_DRAW_VERT_STRIP(xy, cThis, lDelta, cBpp);
            y +=  cThis;                // y+
            xy +=  (cThis * lDelta);    // y+
        }


        if (cStyle == 0)
            goto PrepareToSkipAGap;
    }

AllDone:

    // Update our state variables so that the next line can continue
    // where we left off:

    pls->spRemaining   = cStyle;
    pls->ulStyleMask   = bIsGap;
    pstrip->ptlStart.x = x;
    pstrip->ptlStart.y = y;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\cirrus\disp\thunk.c ===
/******************************************************************************\
*
* $Workfile:   thunk.c  $
*
* This module exists solely for testing, to make it is easy to instrument
* all the driver's Drv calls.
*
* Note that most of this stuff will only be compiled in a checked (debug)
* build.
*
* Copyright (c) 1993-1995 Microsoft Corporation
* Copyright (c) 1996 Cirrus Logic, Inc.
*
* $Log:   S:/projects/drivers/ntsrc/display/thunk.c_v  $
 * 
 *    Rev 1.1   Oct 10 1996 15:39:32   unknown
 *  
* 
*    Rev 1.5   12 Aug 1996 16:55:12   frido
* Added NT 3.5x/4.0 auto detection.
* 
*    Rev 1.4   20 Jul 1996 13:47:40   frido
* Added DbgDestroyFont.
* 
*    Rev 1.3   19 Jul 1996 00:50:26   frido
* Fixed a typo.
* 
*    Rev 1.2   12 Jul 1996 19:49:24   frido
* Added DbgLineTo and fixed GWM 4 debugging.
* 
*    Rev 1.1   03 Jul 1996 13:36:44   frido
* Added debugging thunks for DirectDraw code.
*
\**************************************************************************/

#include "precomp.h"

////////////////////////////////////////////////////////////////////////////

#if DBG

// This entire module is only enabled for checked builds

#define SYNCH_ENTER()   0   // do nothing
#define SYNCH_LEAVE()   0   // do nothing


////////////////////////////////////////////////////////////////////////////

BOOL gbNull = FALSE;    // Set to TRUE with the debugger to test the speed
                        //   of NT with an inifinitely fast display driver
                        //   (actually, almost infinitely fast since we're
                        //   not hooking all the calls we could be)

VOID DbgDisableDriver(VOID)
{
    SYNCH_ENTER();
    DISPDBG((5, "DrvDisableDriver"));

    DrvDisableDriver();

    DISPDBG((6, "DrvDisableDriver done"));
    SYNCH_LEAVE();
}

DHPDEV DbgEnablePDEV(
DEVMODEW*   pDevmode,
PWSTR       pwszLogAddress,
ULONG       cPatterns,
HSURF*      ahsurfPatterns,
ULONG       cjGdiInfo,
ULONG*      pGdiInfo,
ULONG       cjDevInfo,
DEVINFO*    pDevInfo,
HDEV        hdev,
PWSTR       pwszDeviceName,
HANDLE      hDriver)
{
    DHPDEV bRet;

    SYNCH_ENTER();
    DISPDBG((5, "DrvEnablePDEV"));

    bRet = DrvEnablePDEV(
                pDevmode,
                pwszLogAddress,
                cPatterns,
                ahsurfPatterns,
                cjGdiInfo,
                pGdiInfo,
                cjDevInfo,
                pDevInfo,
                hdev,
                pwszDeviceName,
                hDriver);

    DISPDBG((6, "DrvEnablePDEV done"));
    SYNCH_LEAVE();

    return(bRet);
}

VOID DbgCompletePDEV(
DHPDEV dhpdev,
HDEV  hdev)
{
    SYNCH_ENTER();
    DISPDBG((5, "DrvCompletePDEV"));

    DrvCompletePDEV(
                dhpdev,
                hdev);

    DISPDBG((6, "DrvCompletePDEV done"));
    SYNCH_LEAVE();
}

VOID DbgDisablePDEV(DHPDEV dhpdev)
{
    SYNCH_ENTER();
    DISPDBG((5, "DrvDisable"));

    DrvDisablePDEV(dhpdev);

    DISPDBG((6, "DrvDisable done"));
    SYNCH_LEAVE();
}

HSURF DbgEnableSurface(DHPDEV dhpdev)
{
    HSURF h;

    SYNCH_ENTER();
    DISPDBG((5, "DrvEnableSurface"));

    h = DrvEnableSurface(dhpdev);

    DISPDBG((6, "DrvEnableSurface done"));
    SYNCH_LEAVE();

    return(h);
}

VOID DbgDisableSurface(DHPDEV dhpdev)
{
    SYNCH_ENTER();
    DISPDBG((5, "DrvDisableSurface"));

    DrvDisableSurface(dhpdev);

    DISPDBG((6, "DrvDisableSurface done"));
    SYNCH_LEAVE();
}

#if (NT_VERSION < 0x0400)
VOID DbgAssertMode(
DHPDEV dhpdev,
BOOL   bEnable)
{
    SYNCH_ENTER();
    DISPDBG((5, "DrvAssertMode"));
    DrvAssertMode(dhpdev,bEnable);
    DISPDBG((6, "DrvAssertMode done"));
    SYNCH_LEAVE();
}
#else
BOOL DbgAssertMode(
DHPDEV dhpdev,
BOOL   bEnable)
{
    BOOL b;

    SYNCH_ENTER();
    DISPDBG((5, "DrvAssertMode"));

    b = DrvAssertMode(dhpdev,bEnable);

    DISPDBG((6, "DrvAssertMode done"));
    SYNCH_LEAVE();

    return (b);
}
#endif

//
// We do not SYNCH_ENTER since we have not initalized the driver.
// We just want to get the list of modes from the miniport.
//

ULONG DbgGetModes(
HANDLE    hDriver,
ULONG     cjSize,
DEVMODEW* pdm)
{
    ULONG u;

    DISPDBG((5, "DrvGetModes"));

    u = DrvGetModes(
                hDriver,
                cjSize,
                pdm);

    DISPDBG((6, "DrvGetModes done"));

    return(u);
}

VOID DbgMovePointer(SURFOBJ *pso,LONG x,LONG y,RECTL *prcl)
{
    if (gbNull)
        return;

    // Note: Because we set GCAPS_ASYNCMOVE, we don't want to do a
    //       SYNCH_ENTER/LEAVE here.

    DISPDBG((5, "DrvMovePointer"));

    DrvMovePointer(pso,x,y,prcl);

    DISPDBG((6, "DrvMovePointer done"));
}

ULONG DbgSetPointerShape(
SURFOBJ*  pso,
SURFOBJ*  psoMask,
SURFOBJ*  psoColor,
XLATEOBJ* pxlo,
LONG      xHot,
LONG      yHot,
LONG      x,
LONG      y,
RECTL*    prcl,
FLONG     fl)
{
    ULONG u;

    if (gbNull)
        return(SPS_ACCEPT_NOEXCLUDE);

    SYNCH_ENTER();
    DISPDBG((5, "DrvSetPointerShape"));

    u = DrvSetPointerShape(
                pso,
                psoMask,
                psoColor,
                pxlo,
                xHot,
                yHot,
                x,
                y,
                prcl,
                fl);

    DISPDBG((6, "DrvSetPointerShape done"));
    SYNCH_LEAVE();

    return(u);
}

ULONG DbgDitherColor(
DHPDEV dhpdev,
ULONG  iMode,
ULONG  rgb,
ULONG* pul)
{
    ULONG u;

    if (gbNull)
        return(DCR_DRIVER);

    //
    // No need to Synchronize Dither color.
    //

    DISPDBG((5, "DrvDitherColor"));

    u = DrvDitherColor(
                dhpdev,
                iMode,
                rgb,
                pul);

    DISPDBG((6, "DrvDitherColor done"));

    return(u);
}

BOOL DbgSetPalette(
DHPDEV  dhpdev,
PALOBJ* ppalo,
FLONG   fl,
ULONG   iStart,
ULONG   cColors)
{
    BOOL u;

    if (gbNull)
        return(TRUE);

    SYNCH_ENTER();
    DISPDBG((5, "DrvSetPalette"));

    u = DrvSetPalette(
                dhpdev,
                ppalo,
                fl,
                iStart,
                cColors);

    DISPDBG((6, "DrvSetPalette done"));
    SYNCH_LEAVE();

    return(u);
}

BOOL DbgCopyBits(
SURFOBJ*  psoDst,
SURFOBJ*  psoSrc,
CLIPOBJ*  pco,
XLATEOBJ* pxlo,
RECTL*    prclDst,
POINTL*   pptlSrc)
{
    BOOL u;

    if (gbNull)
        return(TRUE);

    SYNCH_ENTER();
    DISPDBG((5, "DrvCopyBits"));

    u = DrvCopyBits(
                psoDst,
                psoSrc,
                pco,
                pxlo,
                prclDst,
                pptlSrc);

    DISPDBG((6, "DrvCopyBits done"));
    SYNCH_LEAVE();

    return(u);
}


BOOL DbgBitBlt(
SURFOBJ*  psoDst,
SURFOBJ*  psoSrc,
SURFOBJ*  psoMask,
CLIPOBJ*  pco,
XLATEOBJ* pxlo,
RECTL*    prclDst,
POINTL*   pptlSrc,
POINTL*   pptlMask,
BRUSHOBJ* pbo,
POINTL*   pptlBrush,
ROP4      rop4)
{
    BOOL u;

    if (gbNull)
        return(TRUE);

    SYNCH_ENTER();
    DISPDBG((5, "DrvBitBlt"));

    u = DrvBitBlt(
                psoDst,
                psoSrc,
                psoMask,
                pco,
                pxlo,
                prclDst,
                pptlSrc,
                pptlMask,
                pbo,
                pptlBrush,
                rop4);

    DISPDBG((6, "DrvBitBlt done"));
    SYNCH_LEAVE();

    return(u);
}

BOOL DbgTextOut(
SURFOBJ*  pso,
STROBJ*   pstro,
FONTOBJ*  pfo,
CLIPOBJ*  pco,
RECTL*    prclExtra,
RECTL*    prclOpaque,
BRUSHOBJ* pboFore,
BRUSHOBJ* pboOpaque,
POINTL*   pptlOrg,
MIX       mix)
{
    BOOL u;

    if (gbNull)
        return(TRUE);

    SYNCH_ENTER();
    DISPDBG((5, "DrvTextOut"));

    u = DrvTextOut(
                pso,
                pstro,
                pfo,
                pco,
                prclExtra,
                prclOpaque,
                pboFore,
                pboOpaque,
                pptlOrg,
                mix);

    DISPDBG((6, "DrvTextOut done"));
    SYNCH_LEAVE();

    return(u);
}

BOOL DbgStrokePath(
SURFOBJ*   pso,
PATHOBJ*   ppo,
CLIPOBJ*   pco,
XFORMOBJ*  pxo,
BRUSHOBJ*  pbo,
POINTL*    pptlBrushOrg,
LINEATTRS* plineattrs,
MIX        mix)
{
    BOOL u;

    if (gbNull)
        return(TRUE);

    SYNCH_ENTER();
    DISPDBG((5, "DrvStrokePath"));

    u = DrvStrokePath(
                pso,
                ppo,
                pco,
                pxo,
                pbo,
                pptlBrushOrg,
                plineattrs,
                mix);

    DISPDBG((6, "DrvStrokePath done"));
    SYNCH_LEAVE();

    return(u);
}

// crus
//#if RE_ENABLE_FILL
BOOL DbgFillPath(
SURFOBJ*  pso,
PATHOBJ*  ppo,
CLIPOBJ*  pco,
BRUSHOBJ* pbo,
POINTL*   pptlBrushOrg,
MIX       mix,
FLONG     flOptions)
{
    BOOL u;

    if (gbNull)
        return(TRUE);

    SYNCH_ENTER();
    DISPDBG((5, "DrvFillPath"));

    u = DrvFillPath(pso,
                ppo,
                pco,
                pbo,
                pptlBrushOrg,
                mix,
                flOptions);

    DISPDBG((6, "DrvFillPath done"));
    SYNCH_LEAVE();

    return(u);
}
//#endif

BOOL DbgRealizeBrush(
BRUSHOBJ* pbo,
SURFOBJ*  psoTarget,
SURFOBJ*  psoPattern,
SURFOBJ*  psoMask,
XLATEOBJ* pxlo,
ULONG     iHatch)
{
    BOOL u;

    // Note: The only time DrvRealizeBrush is called by GDI is when we've
    //       called BRUSHOBJ_pvGetRbrush in the middle of a DrvBitBlt
    //       call, and GDI had to call us back.  Since we're still in the
    //       middle of DrvBitBlt, synchronization has already taken care of.
    //       For the same reason, this will never be called when 'gbNull'
    //       is TRUE, so it doesn't even make sense to check gbNull...

    DISPDBG((5, "DrvRealizeBrush"));

    u = DrvRealizeBrush(
                pbo,
                psoTarget,
                psoPattern,
                psoMask,
                pxlo,
                iHatch);

    DISPDBG((6, "DrvRealizeBrush done"));

    return(u);
}

HBITMAP DbgCreateDeviceBitmap(DHPDEV dhpdev, SIZEL sizl, ULONG iFormat)
{
    HBITMAP hbm;

    if (gbNull)                     // I would pretend to have created a
        return(FALSE);              //   bitmap when gbNull is set, by we
                                    //   would need some code to back this
                                    //   up so that the system wouldn't
                                    //   crash...

    SYNCH_ENTER();
    DISPDBG((5, "DrvCreateDeviceBitmap"));

    hbm = DrvCreateDeviceBitmap(dhpdev, sizl, iFormat);

    DISPDBG((6, "DrvCreateDeviceBitmap done"));
    SYNCH_LEAVE();

    return(hbm);
}

VOID DbgDeleteDeviceBitmap(DHSURF dhsurf)
{
    SYNCH_ENTER();
    DISPDBG((5, "DrvDeleteDeviceBitmap"));

    DrvDeleteDeviceBitmap(dhsurf);

    DISPDBG((6, "DrvDeleteDeviceBitmap done"));
    SYNCH_LEAVE();
}

BOOL DbgStretchBlt(
SURFOBJ*            psoDst,
SURFOBJ*            psoSrc,
SURFOBJ*            psoMask,
CLIPOBJ*            pco,
XLATEOBJ*           pxlo,
COLORADJUSTMENT*    pca,
POINTL*             pptlHTOrg,
RECTL*              prclDst,
RECTL*              prclSrc,
POINTL*             pptlMask,
ULONG               iMode)
{
    BOOL u;

    if (gbNull)
        return(TRUE);

    SYNCH_ENTER();
    DISPDBG((5, "DrvStretchBlt"));

    u = DrvStretchBlt(psoDst, psoSrc, psoMask, pco, pxlo, pca, pptlHTOrg,
                      prclDst, prclSrc, pptlMask, iMode);

    DISPDBG((6, "DrvStretchBlt done"));
    SYNCH_LEAVE();

    return(u);
}

#if DIRECTDRAW
BOOL DbgGetDirectDrawInfo(
DHPDEV       dhpdev,
DD_HALINFO*  pHalInfo,
DWORD*       lpdwNumHeaps,
VIDEOMEMORY* pvmList,
DWORD*       lpdwNumFourCC,
DWORD*       lpdwFourCC)
{
    BOOL bRet;

    SYNCH_ENTER();
    DISPDBG((5, ">> DbgGetDirectDrawInfo"));

    bRet = DrvGetDirectDrawInfo(dhpdev, pHalInfo, lpdwNumHeaps, pvmList,
                                lpdwNumFourCC, lpdwFourCC);

    DISPDBG((6, "<< DbgGetDirectDrawInfo"));
    SYNCH_LEAVE();

    return(bRet);
}
#endif

#if DIRECTDRAW
BOOL DbgEnableDirectDraw(
DHPDEV               dhpdev,
DD_CALLBACKS*        pCallBacks,
DD_SURFACECALLBACKS* pSurfaceCallBacks,
DD_PALETTECALLBACKS* pPaletteCallBacks)
{
    BOOL bRet;

    SYNCH_ENTER();
    DISPDBG((5, ">> DbgEnableDirectDraw"));

    bRet = DrvEnableDirectDraw(dhpdev, pCallBacks, pSurfaceCallBacks,
                               pPaletteCallBacks);

    DISPDBG((6, "<< DbgEnableDirectDraw"));
    SYNCH_LEAVE();

    return(bRet);
}
#endif

#if DIRECTDRAW
VOID DbgDisableDirectDraw(
DHPDEV dhpdev)
{
    SYNCH_ENTER();
    DISPDBG((5, ">> DbgDisableDirectDraw"));

    DrvDisableDirectDraw(dhpdev);

    DISPDBG((6, "<< DbgDisableDirectDraw"));
    SYNCH_LEAVE();
}
#endif

#if LINETO
BOOL DbgLineTo(
SURFOBJ*  pso,
CLIPOBJ*  pco,
BRUSHOBJ* pbo,
LONG      x1,
LONG      y1,
LONG      x2,
LONG      y2,
RECTL*    prclBounds,
MIX       mix)
{
    BOOL bRet;

    SYNCH_ENTER();
    DISPDBG((5, ">> DbgLineTo"));

    bRet = DrvLineTo(pso, pco, pbo, x1, y1, x2, y2, prclBounds, mix);

    DISPDBG((6, "<< DbgLineTo"));
    SYNCH_LEAVE();

    return(bRet);
}
#endif

#if 1 // Font cache
VOID DbgDestroyFont(
FONTOBJ* pfo)
{
    SYNCH_ENTER();
    DISPDBG((5, ">> DbgDestroyFont"));

    DrvDestroyFont(pfo);

    DISPDBG((6, "<< DbgDestroyFont"));
    SYNCH_LEAVE();
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\cirrus\disp\i386\strucs.inc ===
;---------------------------- Include File Header ---------------------------;
; Module Name: strucs.inc
;
; Most of these definitions are pulled straight from winddi.h.  We have
; to copy these here because we don't have any good 'h2inc' C-include-to-
; Asm-include program for NT.
;
; Copyright (c) 1993-1994 Microsoft Corporation
;----------------------------------------------------------------------------;

BMF_1BPP        equ     1
BMF_4BPP        equ     2
BMF_8BPP        equ     3
BMF_16BPP       equ     4
BMF_24BPP       equ     5
BMF_32BPP       equ     6

;-----------------------------------------------------------------------;
; POINTL is used for points with a range of +/- 2G.
;-----------------------------------------------------------------------;

POINTL          STRUC
ptl_x           DD      0
ptl_y           DD      0
POINTL          ENDS

;-----------------------------------------------------------------------;
; SIZEL is used for extents with a range of +/- 2G
;-----------------------------------------------------------------------;

SIZEL           STRUC
sizl_cx         DD      0
sizl_cy         DD      0
SIZEL           ENDS

;-----------------------------------------------------------------------;
; Definition of a rectangle
;-----------------------------------------------------------------------;


RECTL               struc           ; /* rcl */
xLeft               dd      ?
yTop                dd      ?
xRight              dd      ?
yBottom             dd      ?
RECTL               ends

;-----------------------------------------------------------------------;
; Definition of the physical device data structure
;
; NOTE: Changes to this structure must be reflected in driver.h!
;-----------------------------------------------------------------------;

PDEV                struc           ; /* pdev, ppdev */
pdev_xOffset            dd  ?
pdev_yOffset            dd  ?
pdev_xyOffset           dd  ?
pdev_pjBase             dd  ?
pdev_pjPorts            dd  ?
pdev_pjScreen           dd  ?
pdev_iBitmapFormat      dd  ?
pdev_ulChipID           dd  ?
pdev_ulChipNum          dd  ?
PDEV                ends

;-----------------------------------------------------------------------;
; Definition of our realized brush structures.
;
; NOTE: Changes to these structure must be reflected in driver.h!
;-----------------------------------------------------------------------;

RBRUSH              struc           ; /* rb, prb */
rb_fl                   dd  ?
rb_bTransparent         dd  ?
rb_ulForeColor          dd  ?
rb_ulBackColor          dd  ?
rb_ptlBrushOrg          db  (size POINTL) dup(?)
rb_apbe                 dd  ?

; I haven't declared rb_aulPattern because we don't know the size of the
; rb_apbe array here.

RBRUSH              ends

BRUSHENTRY          struc           ; /* be, pbe */
be_prbVerify            dd  ?
be_x                    dd  ?
be_y                    dd  ?
be_xy                   dd  ?
BRUSHENTRY          ends

;-----------------------------------------------------------------------;
; Definitions for text output
;-----------------------------------------------------------------------;

GLYPHPOS    struc           ; /* gp */
gp_hg       dd      ?       ; hglyph (unused by vga)
gp_pgdf     dd      ?       ; glyphdef
gp_x        dd      ?       ; glyph x position
gp_y        dd      ?       ; glyph y position
GLYPHPOS    ends

GLYPHDEF struc              ; /* gdf */
gdf_pgb     dd      ?       ; points to GLYPHBITS
GLYPHDEF ends

GLYPHBITS struc             ; /* gb */
gb_x        dd      ?       ; glyph x offset
gb_y        dd      ?       ; glyph y offset
gb_cx       dd      ?       ; glyph width in pels
gb_cy       dd      ?       ; glyph height in pels
gb_aj       db      ?       ; glyph bit mask
GLYPHBITS ends

;-----------------------------------------------------------------------;
; Macro to do a simple RET, with no stack stuff, in a proc.
;-----------------------------------------------------------------------;

PLAIN_RET macro
        db      0c3h
        endm
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\cirrus\disp\textout.c ===
/******************************************************************************\
*
* $Workfile:   textout.c  $
*
* On every TextOut, GDI provides an array of 'GLYPHPOS' structures for every
* glyph to be drawn. Each GLYPHPOS structure contains a glyph handle and a
* pointer to a monochrome bitmap that describes the glyph. (Note that unlike
* Windows 3.1, which provides a column-major glyph bitmap, Windows NT always
* provides a row-major glyph bitmap.) As such, there are three basic methods
* for drawing text with hardware acceleration:
*
* 1) Glyph caching -- Glyph bitmaps are cached by the accelerator (probably in
*        off-screen memory), and text is drawn by referring the hardware to the
*        cached glyph locations.
*
* 2) Glyph expansion -- Each individual glyph is color-expanded directly to the
*        screen from the monochrome glyph bitmap supplied by GDI.
*
* 3) Buffer expansion -- The CPU is used to draw all the glyphs into a 1bpp
*         monochrome bitmap, and the hardware is then used to color-expand the
*        result.
*
* The fastest method depends on a number of variables, such as the color
* expansion speed, bus speed, CPU speed, average glyph size, and average string
* length.
*
* Glyph expansion is typically faster than buffer expansion for very large
* glyphs, even on the ISA bus, because less copying by the CPU needs to be
* done. Unfortunately, large glyphs are pretty rare.
*
* An advantange of the buffer expansion method is that opaque text will never
* flash -- the other two methods typically need to draw the opaquing rectangle
* before laying down the glyphs, which may cause a flash if the raster is
* caught at the wrong time.
*
* Copyright (c) 1992-1995 Microsoft Corporation
*
********************************************************************************
*
* On the CL-GD5436/46 chips we use glyph caching which is a major performance
* gain.
*
* Copyright (c) 1996 Cirrus Logic, Inc.
*
* $Log:   S:/projects/drivers/ntsrc/display/textout.c_v  $
 * 
 *    Rev 1.5   Jan 15 1997 09:43:28   unknown
 * Enable font cache for english.
 * 
 *    Rev 1.4   Jan 14 1997 15:16:58   unknown
 * take out GR33 clearing after 80 blt.
 * 
 *    Rev 1.2   Nov 07 1996 16:48:08   unknown
 *  
 * 
 *    Rev 1.1   Oct 10 1996 15:39:28   unknown
 *  
* 
*    Rev 1.9   12 Aug 1996 17:12:50   frido
* Changed some comments.
* 
*    Rev 1.8   12 Aug 1996 16:55:08   frido
* Removed unaccessed local variables.
* 
*    Rev 1.7   02 Aug 1996 14:50:42   frido
* Fixed reported GPF during mode switching.
* Used another way to bypass the hardware bug.
* 
*    Rev 1.6   31 Jul 1996 17:56:08   frido
* Fixed clipping.
* 
*    Rev 1.5   26 Jul 1996 12:56:48   frido
* Removed clipping for now.
* 
*    Rev 1.4   24 Jul 1996 20:19:26   frido
* Added a chain of FONTCACHE structures.
* Fixed bugs in vDrawGlyph and vClipGlyph.
* Changed vAssertModeText to remove all cached fonts.
* 
*    Rev 1.3   23 Jul 1996 17:41:52   frido
* Fixed a compile problem after commenting.
* 
*    Rev 1.2   23 Jul 1996 08:53:00   frido
* Documentation done.
* 
*    Rev 1.1   22 Jul 1996 20:45:38   frido
* Added font cache.
*
* jl01  10-08-96  Do Transparent BLT w/o Solid Fill.  Refer to PDRs#5511/6817.
\******************************************************************************/

#include "precomp.h"

// Handy macros.
#define BUSY_BLT(ppdev, pjBase)    (CP_MM_ACL_STAT(ppdev, pjBase) & 0x10)

#define FIFTEEN_BITS            ((1 << 15) - 1)

/******************************Public*Routine******************************\
* VOID vClipSolid
*
* Fills the specified rectangles with the specified color, honoring
* the requested clipping.  No more than four rectangles should be passed in.
*
* Intended for drawing the areas of the opaquing rectangle that extend
* beyond the text box.  The rectangles must be in left to right, top to
* bottom order.  Assumes there is at least one rectangle in the list.
*
* Also used as a simple way to do a rectangular solid fill while honoring
* clipping (as in extra rectangles).
*
\**************************************************************************/

VOID vClipSolid(
PDEV*       ppdev,
LONG        crcl,
RECTL*      prcl,
ULONG       iColor,
CLIPOBJ*    pco)
{
    BOOL            bMore;              // Flag for clip enumeration
    CLIPENUM        ce;                 // Clip enumeration object
    ULONG           i;
    ULONG           j;
    RECTL           arclTmp[4];
    ULONG           crclTmp;
    RECTL*          prclTmp;
    RECTL*          prclClipTmp;
    LONG            iLastBottom;
    RECTL*          prclClip;
    RBRUSH_COLOR    rbc;

    ASSERTDD((crcl > 0) && (crcl <= 4), "Expected 1 to 4 rectangles");

    rbc.iSolidColor = iColor;
    if ((!pco) || (pco->iDComplexity == DC_TRIVIAL))
    {
        (ppdev->pfnFillSolid)(ppdev, 1, prcl, R4_PATCOPY, rbc, NULL);
    }
    else if (pco->iDComplexity == DC_RECT)
    {
        crcl = cIntersect(&pco->rclBounds, prcl, crcl);
        if (crcl != 0)
        {
            (ppdev->pfnFillSolid)(ppdev, crcl, prcl, R4_PATCOPY,
                                  rbc, NULL);
        }
    }
    else // iDComplexity == DC_COMPLEX
    {
        // Bottom of last rectangle to fill

        iLastBottom = prcl[crcl - 1].bottom;

        // Initialize the clip rectangle enumeration to right-down so we can
        // take advantage of the rectangle list being right-down:

        CLIPOBJ_cEnumStart(pco, FALSE, CT_RECTANGLES, CD_RIGHTDOWN, 0);

        // Scan through all the clip rectangles, looking for intersects
        // of fill areas with region rectangles:

        do {
            // Get a batch of region rectangles:

            bMore = CLIPOBJ_bEnum(pco, sizeof(ce), (VOID*)&ce);

            // Clip the rect list to each region rect:

            for (j = ce.c, prclClip = ce.arcl; j-- > 0; prclClip++)
            {
                // Since the rectangles and the region enumeration are both
                // right-down, we can zip through the region until we reach
                // the first fill rect, and are done when we've passed the
                // last fill rect.

                if (prclClip->top >= iLastBottom)
                {
                    // Past last fill rectangle; nothing left to do:

                    return;
                }

                // Do intersection tests only if we've reached the top of
                // the first rectangle to fill:

                if (prclClip->bottom > prcl->top)
                {
                    // We've reached the top Y scan of the first rect, so
                    // it's worth bothering checking for intersection.

                    // Generate a list of the rects clipped to this region
                    // rect:

                    prclTmp     = prcl;
                    prclClipTmp = arclTmp;

                    for (i = crcl, crclTmp = 0; i-- != 0; prclTmp++)
                    {
                        // Intersect fill and clip rectangles

                        if (bIntersect(prclTmp, prclClip, prclClipTmp))
                        {
                            // Add to list if anything's left to draw:

                            crclTmp++;
                            prclClipTmp++;
                        }
                    }

                    // Draw the clipped rects

                    if (crclTmp != 0)
                    {
                        (ppdev->pfnFillSolid)(ppdev, crclTmp, &arclTmp[0],
                                             R4_PATCOPY, rbc, NULL);
                    }
                }
            }
        } while (bMore);
    }
}

#if 0 //removed
BOOL bVerifyStrObj(STROBJ* pstro)
{
    BOOL bMoreGlyphs;
    LONG cGlyph;
    GLYPHPOS * pgp;
    LONG iGlyph = 0;
    RECTL * prclDraw;
    GLYPHPOS * pgpTmp;
    POINTL ptlPlace;

    do
    {
        // Get the next batch of glyphs:

        if (pstro->pgp != NULL)
        {
            // There's only the one batch of glyphs, so save ourselves
            // a call:

            pgp         = pstro->pgp;
            cGlyph      = pstro->cGlyphs;
            bMoreGlyphs = FALSE;
        }
        else
        {
            bMoreGlyphs = STROBJ_bEnum(pstro, &cGlyph, &pgp);
        }

        prclDraw = &pstro->rclBkGround;
        pgpTmp = pgp;

        ptlPlace = pgpTmp->ptl;

        while (cGlyph)
        {
            if (((ptlPlace.x + pgpTmp->pgdf->pgb->ptlOrigin.x + pgpTmp->pgdf->pgb->sizlBitmap.cx) > (prclDraw->right)) ||
                ((ptlPlace.x + pgpTmp->pgdf->pgb->ptlOrigin.x) < (prclDraw->left)) ||
                ((ptlPlace.y + pgpTmp->pgdf->pgb->ptlOrigin.y + pgpTmp->pgdf->pgb->sizlBitmap.cy) > (prclDraw->bottom)) ||
                ((ptlPlace.y + pgpTmp->pgdf->pgb->ptlOrigin.y) < (prclDraw->top))
               )
            {
                DISPDBG((0,"------------------------------------------------------------"));
                DISPDBG((0,"Glyph %d extends beyond pstro->rclBkGround", iGlyph));
                DISPDBG((0,"\tpstro->rclBkGround (%d,%d,%d,%d)",
                            pstro->rclBkGround.left,
                            pstro->rclBkGround.top,
                            pstro->rclBkGround.right,
                            pstro->rclBkGround.bottom));
                DISPDBG((0,"\teffective glyph rect (%d,%d,%d,%d)",
                            (ptlPlace.x + pgpTmp->pgdf->pgb->ptlOrigin.x),
                            (ptlPlace.y + pgpTmp->pgdf->pgb->ptlOrigin.y),
                            (ptlPlace.x + pgpTmp->pgdf->pgb->ptlOrigin.x + pgpTmp->pgdf->pgb->sizlBitmap.cx),
                            (ptlPlace.y + pgpTmp->pgdf->pgb->ptlOrigin.y + pgpTmp->pgdf->pgb->sizlBitmap.cy)));
                DISPDBG((0,"\tglyph pos (%d,%d)",ptlPlace.x,ptlPlace.y));
                DISPDBG((0,"\tglyph origin (%d,%d)",
                            pgpTmp->pgdf->pgb->ptlOrigin.x,
                            pgpTmp->pgdf->pgb->ptlOrigin.y));
                DISPDBG((0,"\tglyph sizl (%d,%d)",
                            pgpTmp->pgdf->pgb->sizlBitmap.cx,
                            pgpTmp->pgdf->pgb->sizlBitmap.cy));
                DISPDBG((0,"------------------------------------------------------------"));
                RIP("time to call the font guys...");
                return(FALSE);
            }

            cGlyph--;
            iGlyph++;
            pgpTmp++;

            if (pstro->ulCharInc == 0)
            {
                ptlPlace = pgpTmp->ptl;
            }
            else
            {
                ptlPlace.x += pstro->ulCharInc;
            }
        }
    } while (bMoreGlyphs);

    return(TRUE);
}

VOID vIoTextOutUnclipped(
PPDEV     ppdev,
STROBJ*   pstro,
FONTOBJ*  pfo,
CLIPOBJ*  pco,
RECTL*    prclOpaque,
BRUSHOBJ* pboFore,
BRUSHOBJ* pboOpaque)
{
    BYTE*       pjPorts         = ppdev->pjPorts;
    LONG        lDelta          = ppdev->lDelta;
    LONG        cBpp            = ppdev->cBpp;

    ULONG      *pulXfer;
    ULONG       ulDstAddr;

    ULONG       ulFgColor;
    ULONG       ulBgColor;
    ULONG       ulSolidColor;

    BYTE        jMode = 0;
    BYTE        jModeColor = 0;

    BOOL        bTextPerfectFit;
    ULONG       cGlyph;
    BOOL        bMoreGlyphs;
    GLYPHPOS*   pgp;
    GLYPHBITS*  pgb;
    LONG        cxGlyph;
    LONG        cyGlyph;
    ULONG*      pdSrc;
    ULONG*      pdDst;
    LONG        cj;
    LONG        cd;
    POINTL      ptlOrigin;
    LONG        ulCharInc;

    ulFgColor       = pboFore->iSolidColor;

    if (pboOpaque)
    {
        ulBgColor       = pboOpaque->iSolidColor;
    }

    if (cBpp == 1)
    {
        ulFgColor |= ulFgColor << 8;
        ulFgColor |= ulFgColor << 16;
        ulBgColor |= ulBgColor << 8;
        ulBgColor |= ulBgColor << 16;
    }
    else if (cBpp == 2)
    {
        ulFgColor |= ulFgColor << 16;
        ulBgColor |= ulBgColor << 16;
    }

    pulXfer = ppdev->pulXfer;
    ppdev->pfnBankMap(ppdev, ppdev->lXferBank);

    CP_IO_WAIT_FOR_BLT_COMPLETE(ppdev, pjPorts);
    CP_IO_DST_Y_OFFSET(ppdev, pjPorts, lDelta);

    if (prclOpaque != NULL)
    {
      ////////////////////////////////////////////////////////////
      // Opaque Initialization
      ////////////////////////////////////////////////////////////

      // If we paint the glyphs in 'opaque' mode, we may not actually
      // have to draw the opaquing rectangle up-front -- the process
      // of laying down all the glyphs will automatically cover all
      // of the pixels in the opaquing rectangle.
      //
      // The condition that must be satisfied is that the text must
      // fit 'perfectly' such that the entire background rectangle is
      // covered, and none of the glyphs overlap (if the glyphs
      // overlap, such as for italics, they have to be drawn in
      // transparent mode after the opaquing rectangle is cleared).

      bTextPerfectFit = (pstro->flAccel & (SO_ZERO_BEARINGS |
              SO_FLAG_DEFAULT_PLACEMENT | SO_MAXEXT_EQUAL_BM_SIDE |
              SO_CHAR_INC_EQUAL_BM_BASE)) ==
              (SO_ZERO_BEARINGS | SO_FLAG_DEFAULT_PLACEMENT |
              SO_MAXEXT_EQUAL_BM_SIDE | SO_CHAR_INC_EQUAL_BM_BASE);

      if (!(bTextPerfectFit)                               ||
          (pstro->rclBkGround.top    > prclOpaque->top)    ||
          (pstro->rclBkGround.left   > prclOpaque->left)   ||
          (pstro->rclBkGround.right  < prclOpaque->right)  ||
          (pstro->rclBkGround.bottom < prclOpaque->bottom))
      {
        vClipSolid(ppdev, 1, prclOpaque, pboOpaque->iSolidColor, pco);
      }

      if (bTextPerfectFit)
      {
        // If we have already drawn the opaquing rectangle (because
        // is was larger than the text rectangle), we could lay down
        // the glyphs in 'transparent' mode.  But I've found the QVision
        // to be a bit faster drawing in opaque mode, so we'll stick
        // with that:

        jMode = jModeColor |
                ENABLE_COLOR_EXPAND |
                SRC_CPU_DATA;

        CP_IO_WAIT_FOR_BLT_COMPLETE(ppdev, pjPorts);

        CP_IO_FG_COLOR(ppdev, pjPorts, ulFgColor);
        CP_IO_BG_COLOR(ppdev, pjPorts, ulBgColor);
        CP_IO_ROP(ppdev, pjPorts, CL_SRC_COPY);
        CP_IO_BLT_MODE(ppdev, pjPorts, jMode);

        goto SkipTransparentInitialization;
      }
    }

    ////////////////////////////////////////////////////////////
    // Transparent Initialization
    ////////////////////////////////////////////////////////////

    // Initialize the hardware for transparent text:

    jMode = jModeColor |
            ENABLE_COLOR_EXPAND |
            ENABLE_TRANSPARENCY_COMPARE |
            SRC_CPU_DATA;

    CP_IO_WAIT_FOR_BLT_COMPLETE(ppdev, pjPorts);

    CP_IO_FG_COLOR(ppdev, pjPorts, ulFgColor);
    CP_IO_BG_COLOR(ppdev, pjPorts, ~ulFgColor);
    CP_IO_XPAR_COLOR(ppdev, pjPorts, ~ulFgColor);
    CP_IO_ROP(ppdev, pjPorts, CL_SRC_COPY);
    CP_IO_BLT_MODE(ppdev, pjPorts, jMode);
    CP_IO_BLT_EXT_MODE(ppdev, pjPorts, 0);                // jl01


  SkipTransparentInitialization:

    do {
        if (pstro->pgp != NULL)
        {
          // There's only the one batch of glyphs, so save ourselves
          // a call:

          pgp         = pstro->pgp;
          cGlyph      = pstro->cGlyphs;
          bMoreGlyphs = FALSE;
        }
        else
        {
          bMoreGlyphs = STROBJ_bEnum(pstro, &cGlyph, &pgp);
        }

        if (cGlyph > 0)
        {
          if (pstro->ulCharInc == 0)
          {
            ////////////////////////////////////////////////////////////
            // Proportional Spacing

            pdDst = pulXfer;

            CP_IO_WAIT_FOR_BLT_COMPLETE(ppdev, pjPorts);

            do {
              pgb = pgp->pgdf->pgb;

              ulDstAddr = ((pgp->ptl.y + pgb->ptlOrigin.y) * lDelta) +
                          PELS_TO_BYTES(pgp->ptl.x + pgb->ptlOrigin.x);

              cxGlyph = pgb->sizlBitmap.cx;
              cyGlyph = pgb->sizlBitmap.cy;

              CP_IO_WAIT_FOR_BLT_COMPLETE(ppdev, pjPorts);

              CP_IO_XCNT(ppdev, pjPorts, (PELS_TO_BYTES(cxGlyph) - 1));
              CP_IO_YCNT(ppdev, pjPorts, cyGlyph - 1);

              //
              // The 542x chips require a write to the Src Address Register when
              // doing a host transfer with color expansion.  The value is
              // irrelevant, but the write is crucial.  This is documented in
              // the manual, not the errata.  Go figure.
              //

              CP_IO_SRC_ADDR(ppdev, pjPorts, 0);
              CP_IO_DST_ADDR(ppdev, pjPorts, ulDstAddr);

              CP_IO_START_BLT(ppdev, pjPorts);

              pdSrc = (ULONG*) pgb->aj;

              cj = cyGlyph * ((cxGlyph + 7) >> 3);

              cd = (cj + 3) >> 2;

              {
                do {
                  WRITE_REGISTER_ULONG(pdDst, *pdSrc);
                  // *pdDst = *pdSrc;
                  CP_MEMORY_BARRIER();
                  pdSrc++;
                } while (--cd != 0);
              }
            } while (pgp++, --cGlyph != 0);
          }
          else
          {
            ////////////////////////////////////////////////////////////
            // Mono Spacing

            ulCharInc   = pstro->ulCharInc;
            pgb         = pgp->pgdf->pgb;

            ptlOrigin.x = pgb->ptlOrigin.x + pgp->ptl.x;
            ptlOrigin.y = pgb->ptlOrigin.y + pgp->ptl.y;

            pdDst       = pulXfer;

            do {
              pgb = pgp->pgdf->pgb;

              ulDstAddr = (ptlOrigin.y * lDelta) +
                          PELS_TO_BYTES(ptlOrigin.x);

              cxGlyph = pgb->sizlBitmap.cx;
              cyGlyph = pgb->sizlBitmap.cy;

              CP_IO_WAIT_FOR_BLT_COMPLETE(ppdev, pjPorts);

              CP_IO_XCNT(ppdev, pjPorts, (PELS_TO_BYTES(cxGlyph) - 1));
              CP_IO_YCNT(ppdev, pjPorts, cyGlyph - 1);

              //
              // The 542x chips require a write to the Src Address Register when
              // doing a host transfer with color expansion.  The value is
              // irrelevant, but the write is crucial.  This is documented in
              // the manual, not the errata.  Go figure.
              //

              CP_IO_SRC_ADDR(ppdev, pjPorts, 0);
              CP_IO_DST_ADDR(ppdev, pjPorts, ulDstAddr);

              ptlOrigin.x += ulCharInc;

              CP_IO_START_BLT(ppdev, pjPorts);

              pdSrc = (ULONG*) pgb->aj;

              cj = cyGlyph * ((cxGlyph + 7) >> 3);

              cd = (cj + 3) >> 2;

              {
                do {
                  WRITE_REGISTER_ULONG(pdDst, *pdSrc);
                  // *pdDst = *pdSrc;
                  MEMORY_BARRIER();
                  pdSrc++;
                } while (--cd != 0);
              }
            } while (pgp++, --cGlyph != 0);
          }
        }
    } while (bMoreGlyphs);

}
#endif

/******************************Public*Routine******************************\
* BOOL DrvTextOut
*
* If it's the fastest method, outputs text using the 'glyph expansion'
* method.  Each individual glyph is color-expanded directly to the
* screen from the monochrome glyph bitmap supplied by GDI.
*
* If it's not the fastest method, calls the routine that implements the
* 'buffer expansion' method.
*
\**************************************************************************/

BOOL DrvTextOut(
SURFOBJ*  pso,
STROBJ*   pstro,
FONTOBJ*  pfo,
CLIPOBJ*  pco,
RECTL*    prclExtra,    // If we had set GCAPS_HORIZSTRIKE, we would have
                        //   to fill these extra rectangles (it is used
                        //   largely for underlines).  It's not a big
                        //   performance win (GDI will call our DrvBitBlt
                        //   to draw the extra rectangles).
RECTL*    prclOpaque,
BRUSHOBJ* pboFore,
BRUSHOBJ* pboOpaque,
POINTL*   pptlBrush,
MIX       mix)
{
    PDEV*           ppdev;
    DSURF*          pdsurf;
    OH*             poh;
    BOOL            bTextPerfectFit;
    LONG            lDelta;

    BOOL            bTmpAlloc;
    VOID*           pvTmp;
    SURFOBJ*        psoTmpMono;
    BOOL            bOpaque;
    BRUSHOBJ        boFore;
    BRUSHOBJ        boOpaque;
    BOOL            bRet;
    XLATECOLORS     xlc;                // Temporary for keeping colours
    XLATEOBJ        xlo;                // Temporary for passing colours

    ULONG           ulBufferBytes;
    ULONG           ulBufferHeight;

    // The DDI spec says we'll only ever get foreground and background
    // mixes of R2_COPYPEN:

    ASSERTDD(mix == 0x0d0d, "GDI should only give us a copy mix");

    // Pass the surface off to GDI if it's a device bitmap that we've
    // converted to a DIB:

    pdsurf = (DSURF*) pso->dhsurf;

    if (pdsurf->dt != DT_DIB)
    {
        // We'll be drawing to the screen or an off-screen DFB; copy the
        // surface's offset now so that we won't need to refer to the DSURF
        // again:

        poh   = pdsurf->poh;
        ppdev = (PDEV*) pso->dhpdev;

        ppdev->xOffset  = poh->x;
        ppdev->yOffset  = poh->y;
        ppdev->xyOffset = poh->xy;

        if (HOST_XFERS_DISABLED(ppdev) && DIRECT_ACCESS(ppdev))
        {
            //
            // if HOST_XFERS_DISABLED(ppdev) is TRUE then the BitBlt used by
            // our text code will be VERY slow.  We should just let the engine
            // draw the text if it can.
            //

            if (ppdev->bLinearMode)
            {
                SURFOBJ *psoPunt = ppdev->psoPunt;

                psoPunt->pvScan0 = poh->pvScan0;
                ppdev->pfnBankSelectMode(ppdev, BANK_ON);

                return(EngTextOut(psoPunt, pstro, pfo, pco, prclExtra,
                                  prclOpaque, pboFore, pboOpaque,
                                  pptlBrush, mix));
            }
            else
            {
                BANK    bnk;
                BOOL    b;
                RECTL   rclDraw;
                RECTL  *prclDst = &pco->rclBounds;

                // The bank manager requires that the 'draw' rectangle be
                // well-ordered:

                rclDraw = *prclDst;
                if (rclDraw.left > rclDraw.right)
                {
                    rclDraw.left   = prclDst->right;
                    rclDraw.right  = prclDst->left;
                }
                if (rclDraw.top > rclDraw.bottom)
                {
                    rclDraw.top    = prclDst->bottom;
                    rclDraw.bottom = prclDst->top;
                }

                vBankStart(ppdev, &rclDraw, pco, &bnk);

                b = TRUE;
                do {
                    b &= EngTextOut(bnk.pso,
                                    pstro,
                                    pfo,
                                    bnk.pco,
                                    prclExtra,
                                    prclOpaque,
                                    pboFore,
                                    pboOpaque,
                                    pptlBrush,
                                    mix);
                } while (bBankEnum(&bnk));

                return(b);
            }
        }

        if ((pco != NULL) && (pco->iDComplexity != DC_TRIVIAL))
        {
            // I'm not entirely sure why, but GDI will occasionally send
            // us TextOut's where the opaquing rectangle does not intersect
            // with the clip object bounds -- meaning that the text out
            // should have already been trivially rejected.  We will do so
            // here because the blt code usually assumes that all trivial
            // rejections will have already been performed, and we will be
            // passing this call on to the blt code:

            if ((pco->rclBounds.top    >= pstro->rclBkGround.bottom) ||
                (pco->rclBounds.left   >= pstro->rclBkGround.right)  ||
                (pco->rclBounds.right  <= pstro->rclBkGround.left)   ||
                (pco->rclBounds.bottom <= pstro->rclBkGround.top))
            {
                // The entire operation was trivially rejected:

                if (prclOpaque)
                {
                    vClipSolid(ppdev, 1, prclOpaque, pboOpaque->iSolidColor, pco);
                }
                return(TRUE);
            }
        }

        // Font cache.
        if ((ppdev->flStatus & STAT_FONT_CACHE) &&
            bFontCache(ppdev, pstro, pfo, pco, prclOpaque, pboFore, pboOpaque))
        {
            return(TRUE);
        }

        // See if the temporary buffer is big enough for the text; if
        // not, try to allocate enough memory.  We round up to the
        // nearest dword multiple:

        lDelta = ((((pstro->rclBkGround.right + 31) & ~31) -
                    (pstro->rclBkGround.left & ~31)) >> 3);

        ulBufferHeight = pstro->rclBkGround.bottom - pstro->rclBkGround.top;
        ulBufferBytes  = lDelta * ulBufferHeight;

        if (((ULONG) lDelta > FIFTEEN_BITS) ||
            (ulBufferHeight > FIFTEEN_BITS))
        {
            // Fail if the math will have overflowed:

            return(FALSE);
        }

        // Use our temporary buffer if it's big enough, otherwise
        // allocate a buffer on the fly:

        if (ulBufferBytes >= TMP_BUFFER_SIZE)
        {
            // The textout is so big that I doubt this allocation will
            // cost a significant amount in performance:

            bTmpAlloc = TRUE;
            pvTmp     = ALLOC(ulBufferBytes);
            if (pvTmp == NULL)
                return(FALSE);
        }
        else
        {
            bTmpAlloc = FALSE;
            pvTmp     = ppdev->pvTmpBuffer;
        }

        psoTmpMono = ppdev->psoTmpMono;

        // Adjust 'lDelta' and 'pvScan0' of our temporary 1bpp surface object
        // so that when GDI starts drawing the text, it will begin in the
        // first dword

        psoTmpMono->pvScan0 = (BYTE*) pvTmp - (pstro->rclBkGround.top * lDelta)
                            - ((pstro->rclBkGround.left & ~31) >> 3);
        psoTmpMono->lDelta  = lDelta;

        ASSERTDD(((ULONG_PTR) psoTmpMono->pvScan0 & 3) == 0,
                 "pvScan0 must be dword aligned");
        ASSERTDD((lDelta & 3) == 0, "lDelta must be dword aligned");

        // We always want GDI to draw in opaque mode to temporary 1bpp
        // buffer:
        // We only want GDI to opaque within the rclBkGround.
        // We'll handle the rest ourselves.

        bOpaque = (prclOpaque != NULL);

        // Get GDI to draw the text for us:

        boFore.iSolidColor   = 1;
        boOpaque.iSolidColor = 0;

        bRet = EngTextOut(psoTmpMono,
                          pstro,
                          pfo,
                          pco,
                          prclExtra,
                          &pstro->rclBkGround,  //prclOpaque,
                          &boFore,
                          &boOpaque,
                          pptlBrush,
                          mix);

        if (bRet)
        {
            if (bOpaque)
            {
                bTextPerfectFit = (pstro->flAccel & (SO_ZERO_BEARINGS |
                      SO_FLAG_DEFAULT_PLACEMENT | SO_MAXEXT_EQUAL_BM_SIDE |
                      SO_CHAR_INC_EQUAL_BM_BASE)) ==
                      (SO_ZERO_BEARINGS | SO_FLAG_DEFAULT_PLACEMENT |
                      SO_MAXEXT_EQUAL_BM_SIDE | SO_CHAR_INC_EQUAL_BM_BASE);

                if (!(bTextPerfectFit)                               ||
                    (pstro->rclBkGround.top    > prclOpaque->top)    ||
                    (pstro->rclBkGround.left   > prclOpaque->left)   ||
                    (pstro->rclBkGround.right  < prclOpaque->right)  ||
                    (pstro->rclBkGround.bottom < prclOpaque->bottom))
                {
                    //
                    // Drawing the Opaque test will not completely cover the
                    // opaque rectangle, so we must do it.  Go to transparent
                    // blt so we don't do the work twice (since opaque text is
                    // done in two passes).
                    //

                    vClipSolid(ppdev, 1, prclOpaque, pboOpaque->iSolidColor, pco);
                    goto Transparent_Text;
                }

                xlc.iForeColor = pboFore->iSolidColor;
                xlc.iBackColor = pboOpaque->iSolidColor;
                xlo.pulXlate   = (ULONG*) &xlc;

                bRet = DrvBitBlt(pso,
                                 psoTmpMono,
                                 NULL,
                                 pco,
                                 &xlo,
                                 &pstro->rclBkGround,
                                 (POINTL*)&pstro->rclBkGround,
                                 NULL,
                                 NULL, //&boFore
                                 NULL,
                                 R4_SRCCOPY);
            }
            else
            {
Transparent_Text:
                // Foreground colour must be 0xff for 8bpp and 0xffff for 16bpp:

                xlc.iForeColor = (ULONG)((1<<PELS_TO_BYTES(8)) - 1);
                xlc.iBackColor = 0;
                xlo.pulXlate   = (ULONG*) &xlc;

                boFore.iSolidColor = pboFore->iSolidColor;

                //
                // Transparently blt the text bitmap
                //

                bRet = DrvBitBlt(pso,
                                 psoTmpMono,
                                 NULL,
                                 pco,
                                 &xlo,
                                 &pstro->rclBkGround,
                                 (POINTL*)&pstro->rclBkGround,
                                 NULL,
                                 &boFore,
                                 NULL,
                                 0xe2e2);
            }
        }

        // Free up any memory we allocated for the temp buffer:

        if (bTmpAlloc)
        {
            FREE(pvTmp);
        }

        return(bRet);
    }
    else
    {
        // We're drawing to a DFB we've converted to a DIB, so just call GDI
        // to handle it:

        return(EngTextOut(pdsurf->pso, pstro, pfo, pco, prclExtra, prclOpaque,
                          pboFore, pboOpaque, pptlBrush, mix));
    }

    return(TRUE);
}

/******************************Public*Routine******************************\
* VOID vDisableText
*
* Performs the necessary clean-up for the text drawing subcomponent.
*
\**************************************************************************/

VOID vDisableText(PDEV* ppdev)
{
    // Here we free any stuff allocated in 'bEnableText'.
}

////////////////////////////////////////////////////////////////////////////////
//                                                                              //
//                         F O N T   C A C H E   S T U F F                      //
//                                                                              //
////////////////////////////////////////////////////////////////////////////////

/*
    The font cache has quite an impact on the speed. First a little note on the
    necessaty of an off-screen font cache (it is an off-screen font cache). The
    original code calls the GDI to perform the character drawing on a temporary
    monochrome surface and then blits that surface to the screen. The problem
    is that GDI is realy too slow. So we need some sort of acceleration here.
    The best acceleration possible is to cache all glyphs off-screen so we can
    let the bitblt engine do its work while we calculate the stuff required for
    the next glyph to draw. Call it co-operate cacheing if you like.    

    Okay, so now we know why we need a font cache, how do we do it? Calling
    the heap manager for every glyph we are going to cache is quite disasterous
    since the off-screen heap gets fragmented with a lot (and I mean a lot) of
    small chunks of data. We can do it better. We will implement our own very
    sneaky (simple and fast) memory manager. We just call the off-screen heap
    manager to allocate a big chunk (4Kb or so) rectengular memory and perform
    our own allocation in that chunk.

    We will use a simple linear allocation technique. Whenever we are required
    to allocate a number of bytes we will test if we have enough room in the
    last line accessed in the chunk. If we have, we decrease the size left on
    that line and return a pointer to it. If we don't have enough memory in the
    last line we simply move to the next line which will be free. If there is
    not enough memory there either, the requested glyph is too big and so we
    return NULL. The only problem here is when we run out of lines in the
    chunk. In this case we link in another chunk we allocate in off-screen
    memory and mark the current chunk 'full'. Okay, this may not be the best
    memory manager since it might leave lines in the chunk very empty if a
    large glyph needs to be allocated. But it is small and fast. And that's our
    main goal.

    We could copy the entire glyph into off-screen memory, but this would use
    up valueable memory since most glyphs will have a lot of white space in
    them. So we calculate the actual visible part of the glyph and only copy
    that data to the off-screen memory. This requires some extra overhead when
    a glyph is being cached, but that will happen only once. And we can detect
    empty glyphs (like the space) to speed up drawing in the process. This does
    however add the necessaty of first drawing an opaque rectangle if required.
    This does not matter that much, since the bitblt engine will draw it while
    we setup some loop variables.

    Okay, now we know about the memory manager. But how do we attach this glyph
    cache to a font? And how do we free its recourses? Windows NT has this nice
    feature called OEM extension. In the FONT object there is a field
    (vConsumer) which is for the display driver only. We can use this field to
    hook up a pointer to our FONTCACHE structure. And when the font is no
    longer required, Windows NT calls DrvDestroyFont so we can remove any
    resources attached to the font. There is only one glitch to this scheme.
    Windows NT does not free up the fonts when the screen goes to full-screen
    DOS mode. This does not matter but when the screen is reset to graphics
    mode all off-screen fonts are smashed and invalid. So I have added a
    counter that gets incremented when the screen is reset to graphics mode.
    When this counter does not match the copy in the FONTCACHE structure we
    must destroy the font first before caching it again.

    There might be some TrueType fonts out there that have many glyphs in them
    (the Unicode fonts for example). This would cause an extremely large font
    cache indeed. So we set a maximum (defaults to 256) of glyphs to cache.
    Whenever we are asked to draw a glyph outside the range we do it by
    bypassing the font cache for that particular glyph.

    Some glyphs might be too large to cache even though the font is small
    enough to be validated for cacheing. In this case we mark the specific
    glyph as uncacheable and draw it directly to screen, bypassing the font
    cache. Other glyphs might have no visble pixels at all (spaces) and we mark
    them as empty so they never get drawn.

    This covers most of the basics for the font cache. See the comments in the
    source for more details.

    EXTRA: Today (24-Jul-96) I have added a chain of FONTCACHE structures that
    keeps track of which FONTOBJs are loaded and cached. This chain will we
    walked to throw all cached fonts out of memory when a mode change to full-
    screen occurs or when DirectDraw is being initialized to give more memory
    to DirectDraw.
*/

/******************************************************************************\
*
* Function:     bEnableText
*
* This routine is called from DrvEnableSurface and should perform any actions
* required to set up the font cache.
*
* Parameters:   ppdev        Pointer to physical device.
*
* Returns:      TRUE.
*
\******************************************************************************/
BOOL bEnableText(
PDEV* ppdev)
{
    // The font cache is only available on the CL-GD5436 like chips, direct
    // access to the frame buffer is enabled and we can do host transfers.
    if ((ppdev->flCaps & CAPS_AUTOSTART) &&
        DIRECT_ACCESS(ppdev)           &&
        !(ppdev->flCaps & CAPS_NO_HOST_XFER))
    {
        // Don't enable the font cache in low memory situations.
        LONG cWidth = BYTES_TO_PELS(FONT_ALLOC_X);
        if ((cWidth <= ppdev->heap.cxMax) &&
            (FONT_ALLOC_Y <= ppdev->heap.cyMax) && FALSE)
        {
            // The font cache will be used.
            ppdev->flStatus |= STAT_FONT_CACHE;
            ppdev->pfcChain  = NULL;
        }
    }
    return(TRUE);
}

/******************************************************************************\
*
* Function:     vAssertModeText
*
* This routine is called from DrvAssertMode. When we switch to full screen we
* destroy all cached fonts.
*
* Parameters:   ppdev        Pointer to physical device.
*                bEnable        TRUE if switching to graphics mode, FALSE if
*                            switching to full-screen MS-DOS mode.
*
* Returns:      Nothing.
*
\******************************************************************************/
VOID vAssertModeText(
PDEV* ppdev,
BOOL  bEnable)
{
    if (bEnable)
    {
        ppdev->ulFontCacheID++;
    }
    else
    {
        // Destroy all fonts in the chain.
        while (ppdev->pfcChain != NULL)
        {
            DrvDestroyFont(ppdev->pfcChain->pfo);
        }
    }
}

/******************************************************************************\
*
* Function:     DrvDestroyFont
*
* This functin is called by NT when a font is being removed from memory. We
* must free any resources we have attached to this font.
*
* Parameters:   pfo        Pointer to the font object being destroyed.
*
* Returns:      Nothing.
*
\******************************************************************************/
VOID DrvDestroyFont(
FONTOBJ *pfo)
{
    // Do we have any recourses allocated?
    if ((pfo->pvConsumer != NULL) && (pfo->pvConsumer != (VOID*) -1))
    {
        FONTCACHE*  pfc = pfo->pvConsumer;
        FONTMEMORY* pfm;
        PDEV*        ppdev;

        ppdev = pfc->ppdev;

        // Free all allocated memory blocks.
        pfm = pfc->pfm;
        while (pfm != NULL)
        {
            FONTMEMORY* pfmNext = pfm->pfmNext;

            if (pfm->poh != NULL)
            {
                pohFree(ppdev, pfm->poh);
            }

            FREE(pfm);
            pfm = pfmNext;
        }

        // Unhook the font cache from the chain.
        if (pfc->pfcPrev != NULL)
        {
            pfc->pfcPrev->pfcNext = pfc->pfcNext;
        }
        else
        {
            ppdev->pfcChain = pfc->pfcNext;
        }
        if (pfc->pfcNext != NULL)
        {
            pfc->pfcNext->pfcPrev = pfc->pfcPrev;
        }

        // Free the font cache.
        FREE(pfc);
    }

    // We don't have anything allocated anymore!
    pfo->pvConsumer = NULL;
}

/******************************************************************************\
*
* Function:     cGetGlyphSize
*
* Get the width and height of a glyph. The height is its visble height, without
* leading and trailing blank lines.
*
* Parameters:   pgb            Pointer to the glyph.
*                pptlOrigin    Pointer to a POINTL which receives the origin of
*                            the glyph.
*                psizlPixels    Pointer to a SIZEL which receives the size of the
*                            glyph in pixels.
*
* Returns:      The width of the glyph in bytes or 0 if the glyph is empty.
*
\******************************************************************************/
LONG cGetGlyphSize(
GLYPHBITS* pgb,
POINTL*    pptlOrigin,
SIZEL*       psizlPixels)
{
    LONG  x, y;
    BYTE* pByte = pgb->aj;
    INT   i;

    // Get width in bytes.
    x = (pgb->sizlBitmap.cx + 7) >> 3;
    if (x > 0)
    {
        // Find the first line in glyph that conatins data.
        for (y = 0; y < pgb->sizlBitmap.cy; y++, pByte += x)
        {
            // Walk through every byte on a line.
            for (i = 0; i < x; i++)
            {
                // If we have data here, we have found the first line.
                if (pByte[i]) 
                {
                    // Find the last line in the glyph that contains data.
                    LONG lHeight = pgb->sizlBitmap.cy - y;
                    for (pByte += (lHeight - 1) * x; lHeight > 0; lHeight--)
                    {
                        // Walk through every byte on a line.
                        for (i = 0; i < x; i++)
                        {
                            if (pByte[i])
                            {
                                // Fill return parameters.
                                pptlOrigin->y   = y;
                                psizlPixels->cx = pgb->sizlBitmap.cx;
                                psizlPixels->cy = lHeight;
                                return(x);
                            }
                        }
                        pByte -= x;
                    }

                    // Glyph is empty.
                    return(0);
                }
            }
        }
    }

    // Glyph is empty.
    return(0);
}

/******************************************************************************\
*
* Function:     pjAllocateFontCache
*
* Allocate a number of bytes in the off-screen font cache.
*
* Parameters:   pfc        Pointer to the font cache.
*                cBytes    Number of bytes to allocate.
*
* Returns:      Linear address of allocation or NULL if there was an error
*                allocating memory.
*
\******************************************************************************/
BYTE* pjAllocateFontCache(
FONTCACHE* pfc,
LONG       cBytes)
{
    FONTMEMORY* pfm;
    BYTE*        pjLinear;
    PDEV*        ppdev = pfc->ppdev;

    // Allocate first FONTMEMORY structure if not yet done.
    if (pfc->pfm == NULL)
    {
        pfc->pfm = ALLOC(sizeof(FONTMEMORY));
        if (pfc->pfm == NULL)
        {
            return(NULL);
        }
    }

    // Walk through all FONTMEMORY structures to find enough space.
    for (pfm = pfc->pfm; pfm != NULL; pfm = pfm->pfmNext)
    {
        // Allocate the off-screen node if not yet done so.
        if (pfm->poh == NULL)
        {
            OH* poh = pohAllocate(ppdev, pfc->cWidth, pfc->cHeight,
                                  FLOH_ONLY_IF_ROOM);
            if (poh == NULL)
            {
                DISPDBG((4, "Not enough room for font cache"));
                return(NULL);
            }

            // Make off-screen node PERMANENT.
            poh->ofl = OFL_PERMANENT;
            vCalculateMaximum(ppdev);

            // Initialize memory manager.
            pfm->poh = poh;
            pfm->cx  = PELS_TO_BYTES(poh->cx);
            pfm->cy  = poh->cy;
            pfm->xy  = poh->xy;
        }

        // Test if the font is too big to fit in any memory block.
        if (cBytes > pfm->cx)
        {
            return(NULL);
        }

        // If the block is not yet full...
        if (pfm->cy > 0)
        {
            // If the glyph fots on the current line...
            if ((pfm->x + cBytes) <= pfm->cx)
            {
                pjLinear = (BYTE*)(ULONG_PTR)(pfm->xy + pfm->x);
                pfm->x  += cBytes;
                return(pjLinear);
            }

            // Next line.
            pfm->cy--;

            // If this memory block is not yet full...
            if (pfm->cy > 0)
            {
                pfm->xy += ppdev->lDelta;
                pfm->x   = cBytes;
                return((BYTE*)(ULONG_PTR)pfm->xy);
            }
        }

        // Allocate the next FONTMEMORY structure if not yet done.
        if (pfm->pfmNext == NULL)
        {
            pfm->pfmNext = ALLOC(sizeof(FONTMEMORY));
        }
    }

    return(NULL);
}

/******************************************************************************\
*
* Function:     vAllocateGlyph
*
* Cache a glyph to the off-screen font cache.
*
* Parameters:   pfc        Pointer to the font cache.
*                pgb        Pointer to the glyph structure.
*                pgc        Pointer to the glyph cache.
*
* Returns:      pgc->sizlBytes.cy.
*
\******************************************************************************/
LONG lAllocateGlyph(
FONTCACHE*  pfc,
GLYPHBITS*  pgb,
GLYPHCACHE* pgc)
{
    PDEV* ppdev = pfc->ppdev;
    LONG  lDelta;
    BYTE* pjSrc;
    BYTE* pjDst;
    LONG  c;

    // Get the size of the glyph.
    lDelta = cGetGlyphSize(pgb, &pgc->ptlOrigin, &pgc->sizlPixels);
    if (lDelta == 0)
    {
        // Glyph is empty.
        pgc->pjGlyph      = (BYTE*) -1;
        pgc->sizlBytes.cy = GLYPH_EMPTY;
        return(GLYPH_EMPTY);
    }

    // Allocate the glyph in the off-screen font cache.
    pgc->lDelta  = lDelta;
    c             = lDelta * pgc->sizlPixels.cy;
    pgc->pjGlyph = pjAllocateFontCache(pfc, c);
    if (pgc->pjGlyph == NULL)
    {
        // Glyph is uncacheable.
        pgc->pjGlyph      = (BYTE*) -1;
        pgc->sizlBytes.cy = GLYPH_UNCACHEABLE;
        return(GLYPH_UNCACHEABLE);
    }

    // Calculate the glyph and off-screen pointers.
    pjSrc = &pgb->aj[pgc->ptlOrigin.y * lDelta];
    pjDst = ppdev->pjScreen + (ULONG_PTR) pgc->pjGlyph;

    // First, align the source to a DWORD boundary.
    while (((ULONG_PTR)pjSrc & 3) && (c > 0))
    {
        *pjDst++ = *pjSrc++;
        c--;
    }

    // Copy the data in DWORDs.
    while (c >= 4)
    {
        *((UNALIGNED DWORD*) pjDst)++ = *((DWORD*) pjSrc)++;
        c -= 4;
    }

    // Copy the remaining data.
    while (c >= 0)
    {
        *pjDst++ = *pjSrc++;
        c--;
    }

    // Calculate the glyph origin and size.
    pgc->ptlOrigin.x  = pgb->ptlOrigin.x;
    pgc->ptlOrigin.y += pgb->ptlOrigin.y;
    pgc->sizlBytes.cx = PELS_TO_BYTES(pgc->sizlPixels.cx) - 1;
    pgc->sizlBytes.cy = pgc->sizlPixels.cy - 1;

    return(pgc->sizlBytes.cy);
}

/******************************************************************************\
*
* Function:     bFontCache
*
* This is the font cache routine which is called from DrvTextOut if the font
* cache is turned on.
*
* Parameters:   ppdev        Pointer to physical device.
*                pstro        Pointer to array of glyphs to draw.
*                pfo            Pointer to the font.
*                pco            Pointer to a CLIPOBJ structure.
*                prclOpaque    Pointer to the opaque rectangle.
*                pboFore        Pointer to the foreground brush.
*                pboOpaque    Pointer to the opaque brush.
*
* Returns:      TRUE if the font has been drawn, FALSE if DrvTextOut should
*                handle it.
*
\******************************************************************************/
BOOL bFontCache(
PDEV*     ppdev,
STROBJ*   pstro,
FONTOBJ*  pfo,
CLIPOBJ*  pco,
RECTL*    prclOpaque,
BRUSHOBJ* pboFore,
BRUSHOBJ* pboOpaque)
{
    BYTE      iDComplexity;
    BOOL      bMoreGlyphs;
    LONG      cGlyphs;
    GLYPHPOS* pgp;
    BOOL       bFirstTime;
    POINTL    ptlOrigin;
    ULONG      ulCharInc;
    RECTL      rclBounds;
    ULONG      ulDstOffset;
    POINTL      ptlDst;
    SIZEL      sizlDst;

    FONTCACHE* pfc      = pfo->pvConsumer;
    BYTE*       pjBase   = ppdev->pjBase;
    LONG       lDelta   = ppdev->lDelta;
    BYTE       jBltMode = ppdev->jModeColor;

    // If the font is uncacheable, return FALSE.
    if (pfc == (VOID*) -1)
    {
        DISPDBG((5, "bFontCache: pfo=0x%08X uncachable", pfo));
        return(FALSE);
    }

    // We don't support complex clipping.
    iDComplexity = (pco == NULL) ? DC_TRIVIAL : pco->iDComplexity;
    if (iDComplexity == DC_COMPLEX)
    {
        return(FALSE);
    }

    // If the font was invalidated by a mode switch (or DirectDraw), destroy it
    // first.
    if ((pfc != NULL) && (pfc->ulFontCacheID != ppdev->ulFontCacheID))
    {
        DISPDBG((5, "bFontCache: pfo=0x%08X invalidated (%d)", pfo,
                 pfc->ulFontCacheID));
        DrvDestroyFont(pfo);
        pfc = NULL;
    }

    // If the font has not been cached, allocate a cache structure now.
    if (pfc == NULL)
    {
        // Mark the font uncacheable if it is too high. We could opt to cache
        // even the largest of fonts, but that will only reject them later on
        // if there is not enough font cache memory (remember we allocate off-
        // screen fonts in rectangular areas) so it will be rejected anyway.
        // This gives quite a bit of extra overhead we can better do without.
        if ((pstro->rclBkGround.bottom - pstro->rclBkGround.top) > FONT_ALLOC_Y)
        {
            DISPDBG((5, "bFontCache: pfo(0x%08X) too large (%d > %d)", pfo,
                     pstro->rclBkGround.bottom - pstro->rclBkGround.top,
                     FONT_ALLOC_Y));
            pfo->pvConsumer = (VOID*) -1;
            return(FALSE);
        }

        // Allocate the font cache structure.
        pfc = ALLOC(sizeof(FONTCACHE));
        if (pfc == NULL)
        {
            // Not enough memory.
            return(FALSE);
        }
        pfo->pvConsumer = pfc;

        // Initialize the font cache structure.
        pfc->ppdev         = ppdev;
        pfc->ulFontCacheID = ppdev->ulFontCacheID;
        pfc->cWidth        = BYTES_TO_PELS(FONT_ALLOC_X);
        pfc->cHeight       = FONT_ALLOC_Y;
        pfc->pfo           = pfo;

        // Allocate the first block of off-screen memory.
        if (pjAllocateFontCache(pfc, 0) == NULL)
        {
            // Not enough off-screen memory.
            DISPDBG((5, "bFontCache: pfo(0x%08X) not enough memory", pfo));

            if (pfc->pfm != NULL)
            {
                FREE(pfc->pfm);
            }
            FREE(pfc);
            pfo->pvConsumer = NULL;
            return(FALSE);
        }

        // Hook the font cache into the chain.
        pfc->pfcPrev    = NULL;
        pfc->pfcNext    = ppdev->pfcChain;
        ppdev->pfcChain = pfc;
        if (pfc->pfcNext != NULL)
        {
            pfc->pfcNext->pfcPrev = pfc;
        }
    }

    // If we need to draw an opaque rectangle...
    if (prclOpaque != NULL)
    {
        // Get opaque rectangle.
        if (iDComplexity == DC_TRIVIAL)
        {
            ptlDst.x   = prclOpaque->left;
            ptlDst.y   = prclOpaque->top;
            sizlDst.cx = prclOpaque->right  - ptlDst.x;
            sizlDst.cy = prclOpaque->bottom - ptlDst.y;
        }
        else
        {
            ptlDst.x   = max(prclOpaque->left,   pco->rclBounds.left);
            ptlDst.y   = max(prclOpaque->top,    pco->rclBounds.top);
            sizlDst.cx = min(prclOpaque->right,  pco->rclBounds.right)
                       - ptlDst.x;
            sizlDst.cy = min(prclOpaque->bottom, pco->rclBounds.bottom)
                       - ptlDst.y;
        }

        // If the clipped opaque rectangle is valid...
        if ((sizlDst.cx > 0) && (sizlDst.cy > 0))
        {
            ulDstOffset = (ptlDst.y * lDelta) + PELS_TO_BYTES(ptlDst.x);
            sizlDst.cx  = PELS_TO_BYTES(sizlDst.cx) - 1;
            sizlDst.cy    = sizlDst.cy - 1;

            // Wait for bitblt engine.
            while (BUSY_BLT(ppdev, pjBase));

            // Program bitblt engine.
            CP_MM_FG_COLOR(ppdev, pjBase, pboOpaque->iSolidColor);
            CP_MM_XCNT(ppdev, pjBase, sizlDst.cx);
            CP_MM_YCNT(ppdev, pjBase, sizlDst.cy);
            CP_MM_DST_Y_OFFSET(ppdev, pjBase, lDelta);
            CP_MM_SRC_ADDR(ppdev, pjBase, 0);
            CP_MM_BLT_MODE(ppdev, pjBase, jBltMode |
                                          ENABLE_COLOR_EXPAND |
                                          ENABLE_8x8_PATTERN_COPY);
            CP_MM_ROP(ppdev, pjBase, HW_P);
               CP_MM_BLT_EXT_MODE(ppdev, pjBase, ENABLE_SOLID_FILL);
            CP_MM_DST_ADDR(ppdev, pjBase, ulDstOffset);
        }
    }

    // Setup loop variables.
    bFirstTime = TRUE;
    ulCharInc  = pstro->ulCharInc;
    jBltMode  |= ENABLE_COLOR_EXPAND | ENABLE_TRANSPARENCY_COMPARE;

    // No clipping...
    if (iDComplexity == DC_TRIVIAL)
    {
#if 1 // D5480
        ppdev->pfnGlyphOut(ppdev, pfc, pstro, pboFore->iSolidColor);
#else
        do
        {
            // Get pointer to array of glyphs.
            if (pstro->pgp != NULL)
            {
                pgp         = pstro->pgp;
                cGlyphs        = pstro->cGlyphs;
                bMoreGlyphs = FALSE;
            }
            else
            {
                bMoreGlyphs = STROBJ_bEnum(pstro, &cGlyphs, &pgp);
            }

            // Setup the blitter if this is the first loop through.
            if (bFirstTime)
            {
                // Wait for the bitblt engine.
                while (BUSY_BLT(ppdev, pjBase));

                // Setup the common bitblt registers.
                CP_MM_FG_COLOR(ppdev, pjBase, pboFore->iSolidColor);
                CP_MM_DST_Y_OFFSET(ppdev, pjBase, lDelta);
                CP_MM_ROP(ppdev, pjBase, CL_SRC_COPY);
                CP_MM_BLT_EXT_MODE(ppdev, pjBase, 0);

                // Mark registers as setup.
                bFirstTime = FALSE;
            }

            // Get coordinates of first glyph.
            ptlOrigin.x = pgp->ptl.x;
            ptlOrigin.y = pgp->ptl.y;

            // Loop through all glyphs.
            while (cGlyphs-- > 0)
            {
                LONG        cy;
                GLYPHCACHE* pgc;

                if (pgp->hg < MAX_GLYPHS)
                {
                    // This is a cacheable glyph index.
                    pgc = &pfc->aGlyphs[pgp->hg];
                    cy  = (pgc->pjGlyph == NULL)
                        ? lAllocateGlyph(pfc, pgp->pgdf->pgb, pgc)
                        : pgc->sizlBytes.cy;
                }
                else
                {
                    // The glyph index is out of range.
                    cy = GLYPH_UNCACHEABLE;
                }

                if (cy >= 0) // The glyph is cached, expand it to the screen.
                {
                    // Setup the destination variables.
                    ptlDst.x = ptlOrigin.x + pgc->ptlOrigin.x;
                    ptlDst.y = ptlOrigin.y + pgc->ptlOrigin.y;
                    ulDstOffset = (ptlDst.y * lDelta) + PELS_TO_BYTES(ptlDst.x);

                    // Wait for the bitblt engine.
                    while (BUSY_BLT(ppdev, pjBase));

                    // Perform the blit expansion.
                    CP_MM_XCNT(ppdev, pjBase, pgc->sizlBytes.cx);
                    CP_MM_YCNT(ppdev, pjBase, cy);
                    CP_MM_SRC_Y_OFFSET(ppdev, pjBase, pgc->lDelta);
                    CP_MM_SRC_ADDR(ppdev, pjBase, pgc->pjGlyph);
                    CP_MM_BLT_MODE(ppdev, pjBase, jBltMode);
                    CP_MM_DST_ADDR(ppdev, pjBase, ulDstOffset);
                }
                else if (cy == GLYPH_UNCACHEABLE)
                {
                    // The glyph is uncacheable, draw it directly.
                    vDrawGlyph(ppdev, pgp->pgdf->pgb, ptlOrigin);
                }

                // Next glyph.
                pgp++;
                if (ulCharInc)
                {
                    ptlOrigin.x += ulCharInc;
                }
                else
                {
                    ptlOrigin.x = pgp->ptl.x;
                    ptlOrigin.y = pgp->ptl.y;
                }
            }
        } while (bMoreGlyphs);
#endif // endif D5480
        return(TRUE);
    }

    // Clipping...
    rclBounds = pco->rclBounds;

#if 1 // D5480
        ppdev->pfnGlyphOutClip(ppdev, pfc, pstro, &rclBounds, pboFore->iSolidColor);
#else
    do
    {
        // Get pointer to array of glyphs.
        if (pstro->pgp != NULL)
        {
            pgp         = pstro->pgp;
            cGlyphs        = pstro->cGlyphs;
            bMoreGlyphs = FALSE;
        }
        else
        {
            bMoreGlyphs = STROBJ_bEnum(pstro, &cGlyphs, &pgp);
        }

        // Setup the blitter if this is the first loop through.
        if (bFirstTime)
        {
            // Wait for the bitblt engine.
            while (BUSY_BLT(ppdev, pjBase));

            // Setup the common bitblt registers.
            CP_MM_FG_COLOR(ppdev, pjBase, pboFore->iSolidColor);
            CP_MM_DST_Y_OFFSET(ppdev, pjBase, lDelta);
            CP_MM_ROP(ppdev, pjBase, CL_SRC_COPY);
            CP_MM_BLT_EXT_MODE(ppdev, pjBase, 0);

            // Mark registers as setup.
            bFirstTime = FALSE;
        }

        // Get coordinates of first glyph.
        ptlOrigin.x = pgp->ptl.x;
        ptlOrigin.y = pgp->ptl.y;

        // Loop through all glyphs.
        while (cGlyphs-- > 0)
        {
            LONG        c, cy;
            GLYPHCACHE* pgc;

            if (pgp->hg < MAX_GLYPHS)
            {
                // This is a cacheable glyph index.
                pgc = &pfc->aGlyphs[pgp->hg];
                cy  = (pgc->pjGlyph == NULL)
                    ? lAllocateGlyph(pfc, pgp->pgdf->pgb, pgc)
                    : pgc->sizlBytes.cy;
            }
            else
            {
                // The glyph index is out of range.
                goto SoftwareClipping;
            }

            if (cy >= 0)
            {
                // The glyph is cached, expand it to the screen.
                ULONG ulSrcOffset;
                RECTL rcl;
                LONG  lSrcDelta;
                LONG  cSkipBits;

                // Calculate the glyph bounding box.
                rcl.left  = ptlOrigin.x + pgc->ptlOrigin.x;
                rcl.right = rcl.left + pgc->sizlPixels.cx;
                if ((rcl.left >= rclBounds.right) ||
                    (rcl.right <= rclBounds.left))
                {
                    goto NextGlyph;
                }
                rcl.top    = ptlOrigin.y + pgc->ptlOrigin.y;
                rcl.bottom = rcl.top + pgc->sizlPixels.cy;
                if ((rcl.top >= rclBounds.bottom) ||
                    (rcl.bottom <= rclBounds.top))
                {
                    goto NextGlyph;
                }

                // Setup source parameters.
                ulSrcOffset = (ULONG) pgc->pjGlyph;
                lSrcDelta   = pgc->lDelta;

                // Do the left side clipping.
                c = rclBounds.left - rcl.left;
                if (c > 0)
                {
                    ulSrcOffset += c >> 3;
                    cSkipBits    = c & 7;
                    rcl.left    += c & ~7;

                    if (ppdev->cBpp == 3)
                    {
                        cSkipBits *= 3;
                    }

                    ulSrcOffset |= cSkipBits << 24;
                }

                // Do the top side clipping.
                c = rclBounds.top - rcl.top;
                if (c > 0)
                {
                    rcl.top     += c;
                    ulSrcOffset += c * lSrcDelta;
                }

                // Calculate size of the blit.
                sizlDst.cx = min(rcl.right,  rclBounds.right)  - rcl.left;
                sizlDst.cy = min(rcl.bottom, rclBounds.bottom) - rcl.top;
                if ((sizlDst.cx <= 0) || (sizlDst.cy <= 0))
                {
                    goto NextGlyph;
                }

                // Setup destination variables.
                ulDstOffset = (rcl.top * lDelta) + PELS_TO_BYTES(rcl.left);

                // HARDWARE BUG:
                // ============
                // A monochrome screen-to-screen expansion with a source pitch
                // not equaling the width of the expansion (i.e. left- and/or
                // right-side clipping) is not done correctly by the hardware.
                // So we have to do the line increment by software.
                if (((sizlDst.cx + 7) >> 3) != lSrcDelta)
                {
                    // Wait for the bitblt engine.
                    while (BUSY_BLT(ppdev, pjBase));

                    // Setup the common bitblt registers.
                    CP_MM_XCNT(ppdev, pjBase, PELS_TO_BYTES(sizlDst.cx) - 1);
                    CP_MM_YCNT(ppdev, pjBase, 0);
                    CP_MM_BLT_MODE(ppdev, pjBase, jBltMode);

                    while (TRUE)
                    {
                        // Perform the expansion.
                        CP_MM_SRC_ADDR(ppdev, pjBase, ulSrcOffset);
                        CP_MM_DST_ADDR(ppdev, pjBase, ulDstOffset);

                        // Next line.
                        if (--sizlDst.cy == 0)
                        {
                            goto NextGlyph;
                        }
                        ulSrcOffset += lSrcDelta;
                        ulDstOffset += lDelta;

                        // Wait for the bitblt engine.
                        while (BUSY_BLT(ppdev, pjBase));
                    }
                }

                // Wait for the bitblt engine.
                while (BUSY_BLT(ppdev, pjBase));

                // Perform the expansion.
                CP_MM_XCNT(ppdev, pjBase, PELS_TO_BYTES(sizlDst.cx) - 1);
                CP_MM_YCNT(ppdev, pjBase, sizlDst.cy - 1);
                CP_MM_SRC_Y_OFFSET(ppdev, pjBase, lSrcDelta);
                CP_MM_SRC_ADDR(ppdev, pjBase, ulSrcOffset);
                CP_MM_BLT_MODE(ppdev, pjBase, jBltMode);
                CP_MM_DST_ADDR(ppdev, pjBase, ulDstOffset);
            }
            else if (cy == GLYPH_UNCACHEABLE)
            {
                SoftwareClipping:
                {
                    // The glyph is uncacheable, draw it directly.
                    vClipGlyph(ppdev, pgp->pgdf->pgb, ptlOrigin, rclBounds,
                               pboFore->iSolidColor);
                }
            }

            // Next glyph.
            NextGlyph:
            {
                pgp++;
                if (ulCharInc)
                {
                    ptlOrigin.x += ulCharInc;
                }
                else
                {
                    ptlOrigin.x = pgp->ptl.x;
                    ptlOrigin.y = pgp->ptl.y;
                }
            }
        }
    } while (bMoreGlyphs);
#endif // D5480
    return(TRUE);
}

/******************************************************************************\
*
* Function:     vDrawGlyph
*
* Draw an uncacheable glyph directly to screen.
*
* Parameters:   ppdev        Pointer to physical device.
*                pgb            Pointer to glyph to draw.
*                ptl            Coordinates of the glyph.
*
* Returns:      Nothing.
*
\******************************************************************************/
VOID vDrawGlyph(
PDEV*      ppdev,
GLYPHBITS* pgb,
POINTL     ptl)
{
    BYTE*  pjBase = ppdev->pjBase;
    BYTE   jBltMode;
    ULONG  dstOffset;
    DWORD* pulSrc;
    DWORD* pulDst;
    LONG   c, cx, cy;
    LONG   x, y;

    // BLT Mode Register value.
    jBltMode = ENABLE_COLOR_EXPAND
             | ENABLE_TRANSPARENCY_COMPARE
             | SRC_CPU_DATA
             | ppdev->jModeColor;

    // Calculate the destination offset.
    x = ptl.x + pgb->ptlOrigin.x;
    y = ptl.y + pgb->ptlOrigin.y;
    dstOffset = (y * ppdev->lDelta) + PELS_TO_BYTES(x);

    // Calculate the glyph variables.
    pulSrc = (DWORD*) pgb->aj;
    pulDst = (DWORD*) ppdev->pulXfer;
    cx     = pgb->sizlBitmap.cx;
    cy     = pgb->sizlBitmap.cy;
    c      = (((cx + 7) >> 3) * cy + 3) >> 2;    // Number of DWORDs to transfer.
    cx      *= ppdev->cBpp;

    // Wait for the blitter.
    CP_MM_WAIT_FOR_BLT_COMPLETE(ppdev, pjBase);

    // Setup the blitter registers.
    CP_MM_XCNT(ppdev, pjBase, cx - 1);
    CP_MM_YCNT(ppdev, pjBase, cy - 1);
    CP_MM_BLT_MODE(ppdev, pjBase, jBltMode);
    CP_MM_BLT_EXT_MODE(ppdev, pjBase, 0);
    CP_MM_DST_ADDR(ppdev, pjBase, dstOffset);

    // Copy the data from the glyph to the screen. Note that the glyph is
    // always DWORD aligned, so we don't have to do anything weird here.
    while (c-- > 0)
    {
        *pulDst = *pulSrc++;
    }
}

/******************************************************************************\
*
* Function:     vClipGlyph
*
* Draw an uncacheable glyph directly to screen using a clipping rectangle.
*
* Parameters:   ppdev        Pointer to physical device.
*                pgb            Pointer to glyph to draw.
*                ptl            Coordinates of the glyph.
*                rclBounds    Clipping rectangle.
*               ulColor     Foreground Color.
*
* Returns:      Nothing.
*
\******************************************************************************/
VOID vClipGlyph(
PDEV*      ppdev,
GLYPHBITS* pgb,
POINTL     ptl,
RECTL*       rclBounds,
ULONG       ulColor)
{
    BYTE   jBltMode;
    ULONG  ulDstOffset;
    BYTE*  pjSrc;
    LONG   cx, cy;
    RECTL  rcl;
    LONG   lSrcDelta;
    LONG   i, cBytes;

    BYTE*  pjBase    = ppdev->pjBase;
    LONG   lDelta    = ppdev->lDelta;
    ULONG* pulDst    = (ULONG*) ppdev->pulXfer;
    LONG   cSkipBits = 0;

    // Calculate glyph bounding box.
    rcl.left   = ptl.x + pgb->ptlOrigin.x;
    rcl.top    = ptl.y + pgb->ptlOrigin.y;
    rcl.right  = min(rcl.left + pgb->sizlBitmap.cx, rclBounds->right);
    rcl.bottom = min(rcl.top  + pgb->sizlBitmap.cy, rclBounds->bottom);

    // Setup source variables.
    pjSrc     = pgb->aj;
    lSrcDelta = (pgb->sizlBitmap.cx + 7) >> 3;

    // Setup BLT Mode Register value.
    jBltMode = ENABLE_COLOR_EXPAND
             | ENABLE_TRANSPARENCY_COMPARE
             | SRC_CPU_DATA
             | ppdev->jModeColor;

    // Do left side clipping.
    cx = rclBounds->left - rcl.left;
    if (cx > 0)
    {
        pjSrc    += cx >> 3;
        cSkipBits = cx & 7;
        rcl.left += cx & ~7;

        if (ppdev->cBpp == 3)
        {
            cSkipBits *= 3;
        }
    }

    // Calculate width in pixels.
    cx = rcl.right - rcl.left;
    if (cx <= 0)
    {
        // Glyph is completely clipped.
        return;
    }

    // Do top side clipping.
    cy = rclBounds->top - rcl.top;
    if (cy > 0)
    {
        pjSrc   += cy * lSrcDelta;
        rcl.top += cy;
    }

    // Calculate height in pixels.
    cy = rcl.bottom - rcl.top;
    if (cy <= 0)
    {
        // Glyph is completely clipped.
        return;
    }

    // Setup destination variables.
    ulDstOffset = (rcl.top * ppdev->lDelta) + PELS_TO_BYTES(rcl.left);
    cBytes        = (cx + 7) >> 3;

    // Wait for the bitblt engine.
    CP_MM_WAIT_FOR_BLT_COMPLETE(ppdev, pjBase);

    // Setup the bitblt registers.
    CP_MM_XCNT(ppdev, pjBase, PELS_TO_BYTES(cx) - 1);
    CP_MM_YCNT(ppdev, pjBase, cy - 1);
    CP_MM_DST_WRITE_MASK(ppdev, pjBase, cSkipBits);
    CP_MM_BLT_MODE(ppdev, pjBase, jBltMode);
    CP_MM_BLT_EXT_MODE(ppdev, pjBase, SOURCE_GRANULARITY);
    CP_MM_DST_ADDR(ppdev, pjBase, ulDstOffset);

    while (cy--)
    {
        BYTE* pjSrcTmp = pjSrc;

        // Copy one line of glyph data to the screen.
        for (i = cBytes; i >= sizeof(ULONG); i -= sizeof(ULONG))
        {
            *pulDst = *((ULONG*)pjSrcTmp)++;
        }

        if (i == 1)
        {
            *pulDst = *(BYTE*)pjSrcTmp;
        }
        else if (i == 2)
        {
            *pulDst = *(USHORT*)pjSrcTmp;
        }
        else if (i == 3)
        {
            *pulDst = pjSrcTmp[0] | (pjSrcTmp[1] << 8) | (pjSrcTmp[2] << 16);
        }

        pjSrc += lSrcDelta;
    }
    while (BUSY_BLT(ppdev, pjBase));
    CP_MM_BLT_EXT_MODE(ppdev, pjBase, 0);
}


#if 1 // D5480
/******************************************************************************\
*
* Function:     vGlyphOut
*
* Draw an uncacheable glyph directly to screen.
*
* Parameters:   ppdev            Pointer to physical device.
*               pfc             Pointer to FONTCACHE.
*                pstro            Pointer to array of glyphs to draw.
*               ulSolidColor    Foreground Color.
*
* Returns:      Nothing.
*
\******************************************************************************/
VOID vMmGlyphOut(
PDEV*       ppdev,
FONTCACHE*  pfc,
STROBJ*     pstro,
ULONG       ulSolidColor )
{
    BOOL      bMoreGlyphs;
    LONG      cGlyphs;
    GLYPHPOS* pgp;
    BOOL      bFirstTime;
    POINTL    ptlOrigin;
    ULONG     ulCharInc;
    ULONG     ulDstOffset;
    POINTL    ptlDst;
    BYTE*     pjBase   = ppdev->pjBase;
    BYTE      jBltMode = ppdev->jModeColor;
    LONG      lDelta   = ppdev->lDelta;

    bFirstTime = TRUE;
    ulCharInc  = pstro->ulCharInc;
    jBltMode  |= ENABLE_COLOR_EXPAND | ENABLE_TRANSPARENCY_COMPARE;

    do
    {
        // Get pointer to array of glyphs.
        if (pstro->pgp != NULL)
        {
            pgp         = pstro->pgp;
            cGlyphs        = pstro->cGlyphs;
            bMoreGlyphs = FALSE;
        }
        else
        {
            bMoreGlyphs = STROBJ_bEnum(pstro, &cGlyphs, &pgp);
        }

        // Setup the blitter if this is the first loop through.
        if (bFirstTime)
        {
            // Wait for the bitblt engine.
            while (BUSY_BLT(ppdev, pjBase));

            // Setup the common bitblt registers.
            CP_MM_FG_COLOR(ppdev, pjBase, ulSolidColor);
            CP_MM_DST_Y_OFFSET(ppdev, pjBase, lDelta);
            CP_MM_ROP(ppdev, pjBase, CL_SRC_COPY);
            CP_MM_BLT_EXT_MODE(ppdev, pjBase, 0);

            // Mark registers as setup.
            bFirstTime = FALSE;
        }

        // Get coordinates of first glyph.
        ptlOrigin.x = pgp->ptl.x;
        ptlOrigin.y = pgp->ptl.y;


        // Loop through all glyphs.
        while (cGlyphs-- > 0)
        {
            LONG        cy;
            GLYPHCACHE* pgc;

            if (pgp->hg < MAX_GLYPHS)
            {
                // This is a cacheable glyph index.
                pgc = &pfc->aGlyphs[pgp->hg];
                cy  = (pgc->pjGlyph == NULL)
                    ? lAllocateGlyph(pfc, pgp->pgdf->pgb, pgc)
                    : pgc->sizlBytes.cy;
            }
            else
            {
                // The glyph index is out of range.
                cy = GLYPH_UNCACHEABLE;
            }

            if (cy >= 0) // The glyph is cached, expand it to the screen.
            {
                // Setup the destination variables.
                ptlDst.x = ptlOrigin.x + pgc->ptlOrigin.x;
                ptlDst.y = ptlOrigin.y + pgc->ptlOrigin.y;
                ulDstOffset = (ptlDst.y * lDelta) + PELS_TO_BYTES(ptlDst.x);

                // Wait for the bitblt engine.
                while (BUSY_BLT(ppdev, pjBase));

                // Perform the blit expansion.
                CP_MM_XCNT(ppdev, pjBase, pgc->sizlBytes.cx);
                CP_MM_YCNT(ppdev, pjBase, cy);
                CP_MM_SRC_Y_OFFSET(ppdev, pjBase, pgc->lDelta);
                CP_MM_SRC_ADDR(ppdev, pjBase, (ULONG_PTR)pgc->pjGlyph);
                CP_MM_BLT_MODE(ppdev, pjBase, jBltMode);
                CP_MM_DST_ADDR(ppdev, pjBase, ulDstOffset);
            }
            else if (cy == GLYPH_UNCACHEABLE)
            {
                // The glyph is uncacheable, draw it directly.
                vDrawGlyph(ppdev, pgp->pgdf->pgb, ptlOrigin);
            }

            // Next glyph.
            pgp++;
            if (ulCharInc)
            {
                ptlOrigin.x += ulCharInc;
            }
            else
            {
                ptlOrigin.x = pgp->ptl.x;
                ptlOrigin.y = pgp->ptl.y;
            }
        }
    } while (bMoreGlyphs);
}

/******************************************************************************\
*
* Function:     vGlyphOutClip
*
* Draw an uncacheable glyph directly to screen.
*
* Parameters:   ppdev            Pointer to physical device.
*               pfc             Pointer to FONTCACHE.
*                pstro            Pointer to array of glyphs to draw.
*                rclBounds        Clipping rectangle.
*               ulSolidColor    Foreground Color.
*
* Returns:      Nothing.
*
\******************************************************************************/
VOID vMmGlyphOutClip(
PDEV*       ppdev,
FONTCACHE*  pfc,
STROBJ*     pstro,
RECTL*        rclBounds,
ULONG       ulSolidColor )
{
    BOOL      bMoreGlyphs;
    LONG      cGlyphs;
    GLYPHPOS* pgp;
    BOOL       bFirstTime;
    POINTL    ptlOrigin;
    ULONG      ulCharInc;
    ULONG     ulDstOffset;
    POINTL      ptlDst;
    BYTE*     pjBase   = ppdev->pjBase;
    BYTE      jBltMode = ppdev->jModeColor;
    LONG      lDelta   = ppdev->lDelta;

    bFirstTime = TRUE;
    ulCharInc  = pstro->ulCharInc;
    jBltMode  |= ENABLE_COLOR_EXPAND | ENABLE_TRANSPARENCY_COMPARE;

    do
    {
        // Get pointer to array of glyphs.
        if (pstro->pgp != NULL)
        {
            pgp         = pstro->pgp;
            cGlyphs        = pstro->cGlyphs;
            bMoreGlyphs = FALSE;
        }
        else
        {
            bMoreGlyphs = STROBJ_bEnum(pstro, &cGlyphs, &pgp);
        }

        // Setup the blitter if this is the first loop through.
        if (bFirstTime)
        {
            // Wait for the bitblt engine.
            while (BUSY_BLT(ppdev, pjBase));

            // Setup the common bitblt registers.
            CP_MM_FG_COLOR(ppdev, pjBase, ulSolidColor);
            CP_MM_DST_Y_OFFSET(ppdev, pjBase, lDelta);
            CP_MM_ROP(ppdev, pjBase, CL_SRC_COPY);
            CP_MM_BLT_EXT_MODE(ppdev, pjBase, 0);

            // Mark registers as setup.
            bFirstTime = FALSE;
        }

        // Get coordinates of first glyph.
        ptlOrigin.x = pgp->ptl.x;
        ptlOrigin.y = pgp->ptl.y;

        // Loop through all glyphs.
        while (cGlyphs-- > 0)
        {
            LONG        c, cy;
            GLYPHCACHE* pgc;

            if (pgp->hg < MAX_GLYPHS)
            {
                // This is a cacheable glyph index.
                pgc = &pfc->aGlyphs[pgp->hg];
                cy  = (pgc->pjGlyph == NULL)
                    ? lAllocateGlyph(pfc, pgp->pgdf->pgb, pgc)
                    : pgc->sizlBytes.cy;
            }
            else
            {
                // The glyph index is out of range.
                goto SoftwareClipping;
            }

            if (cy >= 0)
            {
                // The glyph is cached, expand it to the screen.
                ULONG ulSrcOffset;
                RECTL rcl;
                LONG  lSrcDelta;
                LONG  cSkipBits;
                SIZEL sizlDst;

                // Calculate the glyph bounding box.
                rcl.left  = ptlOrigin.x + pgc->ptlOrigin.x;
                rcl.right = rcl.left + pgc->sizlPixels.cx;
                if ((rcl.left >= rclBounds->right) ||
                    (rcl.right <= rclBounds->left))
                {
                    goto NextGlyph;
                }
                rcl.top    = ptlOrigin.y + pgc->ptlOrigin.y;
                rcl.bottom = rcl.top + pgc->sizlPixels.cy;
                if ((rcl.top >= rclBounds->bottom) ||
                    (rcl.bottom <= rclBounds->top))
                {
                    goto NextGlyph;
                }

                // Setup source parameters.
                ulSrcOffset = (ULONG)((ULONG_PTR)pgc->pjGlyph);
                lSrcDelta   = pgc->lDelta;

                // Do the left side clipping.
                c = rclBounds->left - rcl.left;
                if (c > 0)
                {
                    ulSrcOffset += c >> 3;
                    cSkipBits    = c & 7;
                    rcl.left    += c & ~7;

                    if (ppdev->cBpp == 3)
                    {
                        cSkipBits *= 3;
                    }

                    ulSrcOffset |= cSkipBits << 24;
                }

                // Do the top side clipping.
                c = rclBounds->top - rcl.top;
                if (c > 0)
                {
                    rcl.top     += c;
                    ulSrcOffset += c * lSrcDelta;
                }

                // Calculate size of the blit.
                sizlDst.cx = min(rcl.right,  rclBounds->right)  - rcl.left;
                sizlDst.cy = min(rcl.bottom, rclBounds->bottom) - rcl.top;
                if ((sizlDst.cx <= 0) || (sizlDst.cy <= 0))
                {
                    goto NextGlyph;
                }

                // Setup destination variables.
                ulDstOffset = (rcl.top * lDelta) + PELS_TO_BYTES(rcl.left);

                // HARDWARE BUG:
                // ============
                // A monochrome screen-to-screen expansion with a source pitch
                // not equaling the width of the expansion (i.e. left- and/or
                // right-side clipping) is not done correctly by the hardware.
                // So we have to do the line increment by software.
                if (((sizlDst.cx + 7) >> 3) != lSrcDelta)
                {
                    // Wait for the bitblt engine.
                    while (BUSY_BLT(ppdev, pjBase));

                    // Setup the common bitblt registers.
                    CP_MM_XCNT(ppdev, pjBase, PELS_TO_BYTES(sizlDst.cx) - 1);
                    CP_MM_YCNT(ppdev, pjBase, 0);
                    CP_MM_BLT_MODE(ppdev, pjBase, jBltMode);

                    while (TRUE)
                    {
                        // Perform the expansion.
                        CP_MM_SRC_ADDR(ppdev, pjBase, ulSrcOffset);
                        CP_MM_DST_ADDR(ppdev, pjBase, ulDstOffset);

                        // Next line.
                        if (--sizlDst.cy == 0)
                        {
                            goto NextGlyph;
                        }
                        ulSrcOffset += lSrcDelta;
                        ulDstOffset += lDelta;

                        // Wait for the bitblt engine.
                        while (BUSY_BLT(ppdev, pjBase));
                    }
                }

                // Wait for the bitblt engine.
                while (BUSY_BLT(ppdev, pjBase));

                // Perform the expansion.
                CP_MM_XCNT(ppdev, pjBase, PELS_TO_BYTES(sizlDst.cx) - 1);
                CP_MM_YCNT(ppdev, pjBase, sizlDst.cy - 1);
                CP_MM_SRC_Y_OFFSET(ppdev, pjBase, lSrcDelta);
                CP_MM_SRC_ADDR(ppdev, pjBase, ulSrcOffset);
                CP_MM_BLT_MODE(ppdev, pjBase, jBltMode);
                CP_MM_DST_ADDR(ppdev, pjBase, ulDstOffset);
            }
            else if (cy == GLYPH_UNCACHEABLE)
            {
                SoftwareClipping:
                {
                    // The glyph is uncacheable, draw it directly.
                    vClipGlyph(ppdev, pgp->pgdf->pgb, ptlOrigin, rclBounds,
                               ulSolidColor);
                }
            }

            // Next glyph.
            NextGlyph:
            {
                pgp++;
                if (ulCharInc)
                {
                    ptlOrigin.x += ulCharInc;
                }
                else
                {
                    ptlOrigin.x = pgp->ptl.x;
                    ptlOrigin.y = pgp->ptl.y;
                }
            }
        }
    } while (bMoreGlyphs);
}

/******************************************************************************\
*
* Function:     vGlyphOut80
*
* Draw an uncacheable glyph directly to screen.
*
* Parameters:   ppdev            Pointer to physical device.
*               pfc             Pointer to FONTCACHE.
*                pstro            Pointer to array of glyphs to draw.
*               ulSolidColor    Foreground Color.
*
* Returns:      Nothing.
*
\******************************************************************************/
VOID vMmGlyphOut80(
PDEV*       ppdev,
FONTCACHE*  pfc,
STROBJ*     pstro,
ULONG       ulSolidColor )
{
    ULONG_PTR*   ulCLStart;
    ULONG       ulWidthHeight;
    ULONG       xCLOffset;
    BOOL        bMoreGlyphs;
    LONG        cGlyphs;
    GLYPHPOS*   pgp;
    POINTL      ptlOrigin;
    ULONG       ulCharInc;
    POINTL      ptlDst;
    LONG        cy;
    GLYPHCACHE* pgc;
    DWORD       jSaveMode;
    ULONG       cCommandPacket = 0;
    ULONG       ulDstOffset = 0;
    BOOL        bCommandListOpen = FALSE;
    BYTE*       pjBase   = ppdev->pjBase;
    LONG        lDelta   = ppdev->lDelta;
    DWORD       jExtMode = ENABLE_XY_POSITION_PACKED
                           | CL_PACKED_SRC_COPY
                           | ppdev->jModeColor 
                           | ENABLE_COLOR_EXPAND
                           | ENABLE_TRANSPARENCY_COMPARE;

    ulCharInc  = pstro->ulCharInc;
    jSaveMode = jExtMode;

    //
    // Make sure we can write to the video registers.
    //
    // We need to change to wait for buffer ready
    CP_MM_WAIT_FOR_BLT_COMPLETE(ppdev, pjBase);
    
    // Setup the common bitblt registers.
    CP_MM_FG_COLOR(ppdev, pjBase, ulSolidColor);
    // Do we really need to set it every time?
    CP_MM_DST_Y_OFFSET(ppdev, pjBase, lDelta);
    CP_MM_SRC_XY_PACKED(ppdev, pjBase, 0);

    do
    {
        // Get pointer to array of glyphs.
        if (pstro->pgp != NULL)
        {
            pgp         = pstro->pgp;
            cGlyphs        = pstro->cGlyphs;
            bMoreGlyphs = FALSE;
        }
        else
        {
            bMoreGlyphs = STROBJ_bEnum(pstro, &cGlyphs, &pgp);
        }

        // Get coordinates of first glyph.
        ptlOrigin.x = pgp->ptl.x;
        ptlOrigin.y = pgp->ptl.y;


        // Loop through all glyphs.
        while (cGlyphs-- > 0)
        {
            if (pgp->hg < MAX_GLYPHS)
            {
                // This is a cacheable glyph index.
                pgc = &pfc->aGlyphs[pgp->hg];
                cy  = (pgc->pjGlyph == NULL)
                    ? lAllocateGlyph(pfc, pgp->pgdf->pgb, pgc)
                    : pgc->sizlBytes.cy;
            }
            else
            {
                // The glyph index is out of range.
                cy = GLYPH_UNCACHEABLE;
            }

            if (cy >= 0) // The glyph is cached, expand it to the screen.
            {
                if ( bCommandListOpen )
                {
                    // Command List
                    if( cCommandPacket == 0 )
                    {
                        jExtMode |= ENABLE_COMMAND_LIST_PACKED;
                        ulCLStart = ppdev->pCommandList;
                        ulDstOffset |= (ULONG)(((ULONG_PTR)ulCLStart
                                            - (ULONG_PTR)ppdev->pjScreen) << 14);
                        CP_MM_CL_SWITCH(ppdev);
                    }
    
                    // Calculate the destination address and size.
                    *ulCLStart = PACKXY_FAST(pgc->sizlPixels.cx - 1, cy);
                    // XY
                    *(ulCLStart + 1) = PACKXY_FAST(ptlOrigin.x + pgc->ptlOrigin.x,
                                                   ptlOrigin.y + pgc->ptlOrigin.y);
                    // Source Start address
                    *(ulCLStart + 2) = (ULONG)((ULONG_PTR)pgc->pjGlyph);
            
                    // Dst/SRC pitch
                    *(ulCLStart + 3) = PACKXY_FAST(lDelta, pgc->lDelta);

                    ulCLStart += 4;

                    if( ++cCommandPacket > COMMAND_TOTAL_PACKETS )
                    {
                        // Indicate last Packet
                        *(ulCLStart - 4) |= COMMAND_LAST_PACKET; 
                        CP_MM_BLT_MODE_PACKED(ppdev, pjBase, jExtMode);
                        CP_MM_DST_ADDR(ppdev, pjBase, ulDstOffset);
                        CP_MM_DST_X(ppdev, pjBase, xCLOffset);
                        bCommandListOpen = FALSE;
                        cCommandPacket   = 0;
                        jExtMode         = jSaveMode; 
                        ulDstOffset      = 0;
                    }
                }
                else
                {
                    bCommandListOpen = TRUE;
                    //
                    // Make sure we can write to the video registers.
                    //
                    // We need to change to wait for buffer ready
                    CP_MM_WAIT_FOR_BLT_COMPLETE(ppdev, pjBase);
                    // Setup the first set.
                    xCLOffset = ptlOrigin.x + pgc->ptlOrigin.x;
                    CP_MM_DST_Y(ppdev, pjBase, ptlOrigin.y + pgc->ptlOrigin.y);
                    CP_MM_SRC_Y_OFFSET(ppdev, pjBase, pgc->lDelta);
                    CP_MM_SRC_ADDR(ppdev,pjBase,(ULONG_PTR)pgc->pjGlyph);

                    // Perform the blit expansion.
                    CP_MM_XCNT(ppdev, pjBase, pgc->sizlPixels.cx - 1 );
                    CP_MM_YCNT(ppdev, pjBase, cy);
                }
            }
            else if (cy == GLYPH_UNCACHEABLE)
            {
                if ( bCommandListOpen )
                {
                    // Indicate last Packet
                    if ( cCommandPacket )
                        *(ulCLStart - 4) |= COMMAND_LAST_PACKET; 
                    CP_MM_BLT_MODE_PACKED(ppdev, pjBase, jExtMode);
                    CP_MM_DST_ADDR(ppdev, pjBase, ulDstOffset);
                    CP_MM_DST_X(ppdev, pjBase, xCLOffset);
                    bCommandListOpen    = FALSE;
                    jExtMode            = jSaveMode;
                    cCommandPacket      = 0;
                    ulDstOffset         = 0;
                }
                // The glyph is uncacheable, draw it directly.
                vDrawGlyph(ppdev, pgp->pgdf->pgb, ptlOrigin);
            }

            // Next glyph.
            pgp++;
            if (ulCharInc)
            {
                ptlOrigin.x += ulCharInc;
            }
            else
            {
                ptlOrigin.x = pgp->ptl.x;
                ptlOrigin.y = pgp->ptl.y;
            }
        }
    } while (bMoreGlyphs);

    if ( bCommandListOpen )
    {
        // Indicate last Packet
        if ( cCommandPacket )
            *(ulCLStart - 4) |= COMMAND_LAST_PACKET; 
        CP_MM_BLT_MODE_PACKED(ppdev, pjBase, jExtMode);
        CP_MM_DST_ADDR(ppdev, pjBase, ulDstOffset);
        CP_MM_DST_X(ppdev, pjBase, xCLOffset);
    }

}

/******************************************************************************\
*
* Function:     vGlyphOutClip80
*
* Draw an uncacheable glyph directly to screen.
*
* Parameters:   ppdev            Pointer to physical device.
*               pfc             Pointer to FONTCACHE.
*                pstro            Pointer to array of glyphs to draw.
*                rclBounds        Clipping rectangle.
*               ulSolidColor    Foreground Color.
*
* Returns:      Nothing.
*
\******************************************************************************/
VOID vMmGlyphOutClip80(
PDEV*       ppdev,
FONTCACHE*  pfc,
STROBJ*     pstro,
RECTL*      rclBounds,
ULONG       ulSolidColor )
{
    BOOL        bMoreGlyphs;
    LONG        cGlyphs;
    GLYPHPOS*   pgp;
    POINTL      ptlOrigin;
    ULONG       ulCharInc;
    POINTL      ptlDst;
    LONG        cy;
    GLYPHCACHE* pgc;
    RECTL       rclDst;
    RECTL       rclClip;
    ULONG       ulDstOffset;
    BYTE*       pjBase   = ppdev->pjBase;
    LONG        lDelta   = ppdev->lDelta;
    DWORD       jExtMode = ENABLE_XY_POSITION_PACKED
                           | ENABLE_CLIP_RECT_PACKED
                           | CL_PACKED_SRC_COPY
                           | ppdev->jModeColor 
                           | ENABLE_COLOR_EXPAND
                           | ENABLE_TRANSPARENCY_COMPARE;

    ulCharInc  = pstro->ulCharInc;

    //
    // Make sure we can write to the video registers.
    //
    // We need to change to wait for buffer ready
    CP_MM_WAIT_FOR_BLT_COMPLETE(ppdev, pjBase);
    
    // Setup the common bitblt registers.
    CP_MM_FG_COLOR(ppdev, pjBase, ulSolidColor);
    // Do we really need to set it every time?
    CP_MM_DST_Y_OFFSET(ppdev, pjBase, lDelta);
    CP_MM_SRC_XY_PACKED(ppdev, pjBase, 0);

    CP_MM_BLT_MODE_PACKED(ppdev, pjBase, jExtMode);

    do
    {
        // Get pointer to array of glyphs.
        if (pstro->pgp != NULL)
        {
            pgp         = pstro->pgp;
            cGlyphs     = pstro->cGlyphs;
            bMoreGlyphs = FALSE;
        }
        else
        {
            bMoreGlyphs = STROBJ_bEnum(pstro, &cGlyphs, &pgp);
        }

        // Get coordinates of first glyph.
        ptlOrigin.x = pgp->ptl.x;
        ptlOrigin.y = pgp->ptl.y;

        // Loop through all glyphs.
        while (cGlyphs-- > 0)
        {
            LONG        c;

            if (pgp->hg < MAX_GLYPHS)
            {
                // This is a cacheable glyph index.
                pgc = &pfc->aGlyphs[pgp->hg];
                cy  = (pgc->pjGlyph == NULL)
                    ? lAllocateGlyph(pfc, pgp->pgdf->pgb, pgc)
                    : pgc->sizlBytes.cy;
            }
            else
            {
                // The glyph index is out of range.
                pgc = NULL;
                cy  = GLYPH_UNCACHEABLE;
            }

            if (cy >= 0)
            {
                // Calculate the glyph bounding box.
                rclDst.left  = ptlOrigin.x + pgc->ptlOrigin.x;
                rclDst.right = rclDst.left + pgc->sizlPixels.cx;
                if ((rclDst.left >= rclBounds->right) ||
                    (rclDst.right <= rclBounds->left))
                {
                    goto NextGlyph;
                }
                rclDst.top    = ptlOrigin.y + pgc->ptlOrigin.y;
                rclDst.bottom = rclDst.top + pgc->sizlPixels.cy;
                if ((rclDst.top >= rclBounds->bottom) ||
                    (rclDst.bottom <= rclBounds->top))
                {
                    goto NextGlyph;
                }
                
                rclClip     = *rclBounds;
                ulDstOffset = 0;
                //
                // Handle X negtive
                //
                if (rclDst.left < 0)
                {
                    rclClip.left    -= rclDst.left;
                    rclClip.right   -= rclDst.left;
                    ulDstOffset     += PELS_TO_BYTES(rclDst.left);
                    rclDst.left      = 0;
                }
                //
                // Handle Y negtive
                //
                if (rclDst.top < 0)
                {
                    rclClip.top     -= rclDst.top;
                    rclClip.bottom  -= rclDst.top;
                    ulDstOffset     += (rclDst.top * lDelta);
                    rclDst.top       = 0;
                }

                CP_MM_CLIP_ULXY(ppdev, pjBase, rclClip.left, rclClip.top);
                CP_MM_CLIP_LRXY(ppdev, pjBase, rclClip.right - 1, rclClip.bottom - 1);

                //
                // Make sure we can write to the video registers.
                //
                // We need to change to wait for buffer ready
                CP_MM_WAIT_FOR_BLT_COMPLETE(ppdev, pjBase);
                CP_MM_DST_Y(ppdev, pjBase, rclDst.top);
                CP_MM_SRC_Y_OFFSET(ppdev, pjBase, pgc->lDelta);
                CP_MM_SRC_ADDR(ppdev, pjBase, (ULONG_PTR)pgc->pjGlyph);

                // Perform the blit expansion.
                CP_MM_XCNT(ppdev, pjBase, pgc->sizlPixels.cx - 1 );
                CP_MM_YCNT(ppdev, pjBase, cy);
                CP_MM_DST_ADDR(ppdev, pjBase, ulDstOffset);
                CP_MM_DST_X(ppdev, pjBase, rclDst.left);
            }
            else if (cy == GLYPH_UNCACHEABLE)
            {
                // The glyph is uncacheable, draw it directly.
                vClipGlyph(ppdev, pgp->pgdf->pgb, ptlOrigin, rclBounds,
                           ulSolidColor);
            }

            // Next glyph.
            NextGlyph:
            {
                pgp++;
                if (ulCharInc)
                {
                    ptlOrigin.x += ulCharInc;
                }
                else
                {
                    ptlOrigin.x = pgp->ptl.x;
                    ptlOrigin.y = pgp->ptl.y;
                }
            }
        }
    } while (bMoreGlyphs);

}
#endif // endif D5480
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\cirrus\disp\i386\strx86.asm ===
;---------------------------Module-Header------------------------------;
; Module Name: str.asm
;
; Contains the x86 'Asm' versions of some inner-loop routines for the
; partially hardware accelerated StretchBlt.
;
; Copyright (c) 1994-1995 Microsoft Corporation
;-----------------------------------------------------------------------;

        .386

        .model  small,c

        assume cs:FLAT,ds:FLAT,es:FLAT,ss:FLAT
        assume fs:nothing,gs:nothing

        .xlist
        include stdcall.inc             ;calling convention cmacros
        include i386\strucs.inc
        include i386\hw.inc
        .list

        .data

;
;  stack based params and local variables
;

STACK_STRUC             struc

; Feel free to add any local variables here:

sp_TempXFrac            dd      ?
sp_YCarry               dd      ?
sp_LeftCase             dd      ?
sp_RightCase            dd      ?
sp_pjSrcScan            dd      ?
sp_SrcIntStep           dd      ?
sp_DstStride            dd      ?
sp_XCntHW               dd      ?
sp_XCount               dd      ?
sp_xyOFfset             dd      ?
sp_yDst                 dd      ?
sp_pdev                 dd      ?

; Don't add any fields below here without modifying PROC_MEM_SIZE!

sp_ebp                  dd      ?
sp_esi                  dd      ?
sp_edi                  dd      ?
sp_ebx                  dd      ?
sp_RetAddr              dd      ?
sp_pSTR_BLT             dd      ?   ; If adding parameters, adjust 'ret' value!
STACK_STRUC             ends

PROC_MEM_SIZE           equ     6 * 4

;
; Make sure this STR_BLT matches that declared in driver.h!
;

STR_BLT                 struc
str_ppdev               dd      ?
str_pjSrcScan           dd      ?
str_lDeltaSrc           dd      ?
str_XSrcStart           dd      ?
str_pjDstScan           dd      ?
str_lDeltaDst           dd      ?
str_XDstStart           dd      ?
str_XDstEnd             dd      ?
str_YDstStart           dd      ?
str_YDstCount           dd      ?
str_ulXDstToSrcIntCeil  dd      ?
str_ulXDstToSrcFracCeil dd      ?
str_ulYDstToSrcIntCeil  dd      ?
str_ulYDstToSrcFracCeil dd      ?
str_ulXFracAccumulator  dd      ?
str_ulYFracAccumulator  dd      ?
STR_BLT                 ends

        .code

;---------------------------Public-Routine------------------------------;
; VOID vDirectStretch8(pStrBlt)
;
; NOTE: This routine doesn't handle cases where the blt stretch starts
;       and ends in the same destination dword!  vDirectStretchNarrow
;       is expected to have been called for that case.
;
; Stretch blt 8 -> 8
;-----------------------------------------------------------------------;

        public vDirectStretch8@4

vDirectStretch8@4 proc near

        ;
        ; use ebp as general register, use esp for parameter and local access
        ; save ebp,ebx,esi,edi
        ;

        push    ebx
        push    edi
        push    esi
        push    ebp

        sub     esp,(size STACK_STRUC) - PROC_MEM_SIZE  ; make room for local variables

        mov     ebp,[esp].sp_pSTR_BLT                   ; load pSTR_BLT into ebp

        ;
        ; load up some stack-based parameters to be used by our scan
        ; duplicator when doing vertical stretches
        ;

        mov     eax,[ebp].str_ppdev
        mov     ecx,[ebp].str_YDstStart                 ; get start y coordinate
        mov     [esp].sp_pdev,eax                       ; save ppdev pointer

        mov     ebx,[eax].pdev_xyOffset
        mov     [esp].sp_xyOffset,ebx                   ; save xyOffset

        mov     [esp].sp_yDst,ecx                       ; save current y coordinate

        ;
        ; calc starting addressing parameters
        ;

        mov     esi,[ebp].str_pjSrcScan                 ; load src DIB pointer
        add     esi,[ebp].str_XSrcStart                 ; add starting Src Pixel
        mov     edi,[ebp].str_pjDstScan                 ; load dst DIB pointer
        add     edi,[ebp].str_XDstStart                 ; add strarting Dst Pixel
        mov     [esp].sp_pjSrcScan,esi                  ; save scan line start pointer
        mov     eax,[ebp].str_ulYDstToSrcIntCeil        ; number of src scan lines to step
        mul     [ebp].str_lDeltaSrc                     ; calc scan line int lines to step
        mov     [esp].sp_SrcIntStep,eax                 ; save int portion of Y src step
        mov     edx,4                                   ; calc left bytes = (4 - LeftCase) & 0x03
        sub     edx,edi
        and     edx,3                                   ; left edge bytes
        mov     [esp].sp_LeftCase,edx                   ; save left edge case pixels (4-LeftCase)&0x03
        mov     eax,[ebp].str_pjDstScan                 ; make copy
        mov     ecx,[ebp].str_XDstEnd                   ; load x end
        add     eax,ecx                                 ; ending dst addr
        and     eax,3                                   ; calc right edge case
        mov     [esp].sp_RightCase,eax                  ; save right edge case
        sub     ecx,[ebp].str_XDstStart                 ; calc x count

        dec     ecx
        mov     [esp].sp_XCntHW,ecx                     ; x width for accelerator
        inc     ecx

        mov     ebx,[ebp].str_lDeltaDst                 ; dst scan line stride
        sub     ebx,ecx                                 ; distance from end of one line to start of next
        mov     [esp].sp_DstStride,ebx                  ; save dst scan line stride
        sub     ecx,eax                                 ; sub right edge from XCount
        sub     ecx,edx                                 ; sub left edge from XCount
        shr     ecx,2                                   ; convert from byte to DWORD count
        mov     [esp].sp_XCount,ecx                     ; save DWORD count
        mov     ebx,[ebp].str_ulXDstToSrcFracCeil       ; get x frac
        mov     [esp].sp_TempXFrac,ebx                  ; save x frac to a esp based location

NextScan:

        ;
        ; Wait until the accelerator is done with current blt
        ;

        mov     dx,3ceh     ;index register
        mov     al,31h      ;status reg
        out     dx,al
        mov     dx,3cfh     ;data register
@@:     in      al,dx
        test    al,1
        jnz     short @b

SingleLoop:

        ;
        ; esi and edi are assumed to be correctly loaded
        ;

        mov     eax,[ebp].str_ulXDstToSrcIntCeil        ; get src integer step for step in dst
        mov     ebx,[ebp].str_ulXDstToSrcFracCeil       ; get src frac step for step in dst
        mov     edx,[ebp].str_ulXFracAccumulator        ; put it in edx as tmp

        mov     ebp,edi                                 ; get dst pointer to ebp

        ;
        ; Can't directly access pSTR_BLT variables through ebp
        ;

        mov     edi,edx                                 ; get accumulator where we want it
        mov     ecx,[esp].sp_LeftCase

        ; eax = integer step in source
        ; ebx = fractional step in source
        ; ecx = left edge case
        ; edx = free for pixel data
        ; esi = pointer to source pixel
        ; edi = fractional accumulator
        ; ebp = pointer to dest pixel

        ;
        ; first do the left side to align dwords
        ;

        test    ecx,ecx
        jz      DwordAligned

@@:
        mov     dl,[esi]                                ; fetch pixel
        mov     [ebp],dl                                ; write it out
        add     edi,ebx                                 ; step fraction
        adc     esi,eax                                 ; add in integer and possible carry
        inc     ebp                                     ; step 1 in dest
        dec     ecx                                     ; dec left count
        jne     @B                                      ; repeat until done

DwordAligned:

        mov     ecx,[esp].sp_XCount                     ; get run length

@@:
        mov     dl,[esi]                                ; get a source pixel edx = ???0
        add     edi,ebx                                 ; step fraction
        adc     esi,eax                                 ; add integer and carry

        add     edi,ebx                                 ; step fraction
        mov     dh,[esi]                                ; get source pixel edx = ??10
        adc     esi,eax                                 ; add integer and carry

        shl     edx,16                                  ; edx = 10??

        add     edi,ebx                                 ; step fraction
        mov     dl,[esi]                                ; get a source pixel edx = 10?2
        adc     esi,eax                                 ; add integer and carry

        add     edi,ebx                                 ; step fraction
        mov     dh,[esi]                                ; get source pixel edx = 0132
        adc     esi,eax                                 ; add integer and carry

        ror     edx,16                                  ; edx = 3210

        mov     [ebp],edx                               ; write everything to dest

        add     ebp,4                                   ; increment dest pointer by 1 dword
        dec     ecx                                     ; decrement count
        jnz     @b                                      ; do more pixels

        ;
        ; now do the right side trailing bytes
        ;

        mov     ecx,[esp].sp_RightCase
        test    ecx,ecx
        jz      EndScanLine

@@:

        mov     dl,[esi]                                ; fetch pixel
        mov     [ebp],dl                                ; write it out
        add     edi,ebx                                 ; step fraction
        adc     esi,eax                                 ; add in integer and possible carry
        inc     ebp                                     ; step 1 in dest
        dec     ecx                                     ; dec right count
        jnz     @b                                      ; repeat until done

EndScanLine:

        mov     edi,ebp                                 ; get dst pointer back
        mov     ebp,[esp].sp_pSTR_BLT                   ; load pSTR_BLT into ebp

EndSkipScan:

        mov     esi,[esp].sp_pjSrcScan                  ; load src scan start addr
        mov     ebx,esi                                 ; save a copy
        mov     eax,[ebp].str_ulYFracAccumulator        ; get .32 part of Y pointer
        add     eax,[ebp].str_ulYDstToSrcFracCeil       ; add in fractional step
        jnc     @f
        add     esi,[ebp].str_lDeltaSrc                 ; step one extra in src
@@:     mov     [ebp].str_ulYFracAccumulator,eax        ; save Y accumulator

        add     esi,[esp].sp_SrcIntStep                 ; step int part
        mov     [esp].sp_pjSrcScan,esi                  ; save starting scan addr
        add     edi,[esp].sp_DstStride                  ; step to next scan in dst
        dec     [ebp].str_YDstCount                     ; decrement scan count
        jz      Done                                    ; no more scans

        inc     [esp].sp_yDst                           ; one scan further down in dst
        cmp     esi,ebx                                 ; is src scan same as before?
        jne     NextScan                                ; if so, fall through to dupe scan

        ;--------------------------------------------------------------------
        ; The source scan is the same one used for the previous destination
        ; scan, so we can simply use the hardware to copy the previous
        ; destination scan.
        ;
        ; Since on the S3 we can set up a 'rolling blt' to copy one scan
        ; line to several scans in a single command, we will count up how
        ; many times this scan should be duplicated.  If your hardware
        ; cannot do a rolling blt, simply issue a new blt command for
        ; every time the scan should be duplicated.
        ;
        ; eax = ulYFracAccumulator
        ; ebx = original pjSrcScan
        ; esi = current pjSrcScan
        ; ebp = pSTR_BLT
        ;

        mov     ecx,-1                                  ; number of times scan is to be
                                                        ;  duplicated, less one
AnotherDuplicate:

        inc     ecx                                     ; one scan further down
        dec     [ebp].str_YDstCount                     ; decrement scan count
        jz      OutputDuplicates                        ; no more scans
        add     eax,[ebp].str_ulYDstToSrcFracCeil       ; add in fractional step
        jnc     @f
        add     esi,[ebp].str_lDeltaSrc                 ; step one extra in src
@@:     add     esi,[esp].sp_SrcIntStep                 ; step int part
        add     edi,[ebp].str_lDeltaDst                 ; step entire dest scan
        cmp     esi,ebx                                 ; is src scan same as before?
        je      AnotherDuplicate

OutputDuplicates:

        mov     [esp].sp_pjSrcScan,esi                  ; save starting scan address
        mov     [ebp].str_ulYFracAccumulator,eax        ; save Y accumulator

        ;
        ; Now output the command to do the 'rolling blt'
        ;

        ;; mov     edx,[esp].sp_pjBase

        ;
        ; Wait until the accelerator is done with current blt
        ;

        mov     dx,3ceh     ;index register
        mov     al,31h      ;status reg
        out     dx,al
        mov     dx,3cfh     ;data register
@@:     in      al,dx
        test    al,1
        jnz     short @b

        mov     ebx,[esp].sp_XCntHW
        mov     eax,[esp].sp_yDst

        ; eax = yDst      -- Destination scan line (source scan line is yDst - 1)
        ; ebx = XCntHW    -- Number of bytes across (width) - 1
        ; ecx = cy        -- Number of times scan is to be duplicated - 1
        ; ebp = pSTR_BLT  -- Stretch blt info

DuplicateViaMmIo:

        ;
        ; Do the copy:
        ;

if 0
        CP_XCNT(ppdev, pjBase, (WidthXBytes - 1));
        CP_YCNT(ppdev, pjBase, (cyDuplicate - 1));
        CP_SRC_ADDR(ppdev, pjBase, (xyOffset + ((yDst - 1) * lDelta) + xDstBytes));
        SET_DEST_ADDR(ppdev, ((yDst * lDelta) + xDstBytes));
        START_ACL(ppdev);
endif

        .errnz  RECT_HEIGHT

        ;; mov     [edx+OFFSET_wXCnt],bx
        ;; mov     [edx+OFFSET_wYCnt],cx

        mov     dx,3ceh     ;index register

        ;
        ; set XCNT=bx and YCNT=cx
        ;

		push	eax

        mov     al,21h      ;BLT_WIDTH_HIGH
        mov     ah,bh       ;x count high byte
        out     dx,ax
        mov     al,20h      ;BLT_WIDTH_LOW
        mov     ah,bl       ;x count low byte
        out     dx,ax

        mov     al,23h      ;BLT_HEIGHT_HIGH
        mov     ah,ch       ;y count high byte
        out     dx,ax
        mov     al,22h      ;BLT_HEIGHT_LOW
        mov     ah,cl       ;y count low byte
        out     dx,ax

		pop		eax

        ;
        ; Calculate src address
        ;

        mov     ebx,eax                                 ; ebx <- yDst
        dec     ebx
        imul    ebx,[ebp].str_lDeltaDst
        add     ebx,[esp].sp_xyOffset
        add     ebx,[ebp].str_xDstStart

        ;; mov     [edx+OFFSET_ulSrcAddr],ebx

		push	eax

        mov     al,2ch      ;SRC_ADDR_LOW
        mov     ah,bl       ;src addr low byte
        out     dx,ax
        mov     al,2dh      ;SRC_ADDR_MID
        mov     ah,bh       ;src addr mid byte
        out     dx,ax

        shr     ebx,16

        mov     al,2eh      ;SRC_ADDR_HIGH
        mov     ah,bl       ;src addr high byte
        out     dx,ax

		pop		eax

        ;
        ; Calculate dst address
        ;

        inc     eax                                     ; account for 'ecx' being
                                                        ;  one less than scan count

        mov     ebx,eax                                 ; ebx <- yDst
        dec     ebx
        imul    ebx,[ebp].str_lDeltaDst
        add     ebx,[esp].sp_xyOffset
        add     ebx,[ebp].str_xDstStart

        ;; mov     [edx+OFFSET_ulDstAddr],ebx

        push	eax

        mov     al,28h      ;DST_ADDR_LOW
        mov     ah,bl       ;dst addr low byte
        out     dx,ax
        mov     al,29h      ;DST_ADDR_MID
        mov     ah,bh       ;dst addr mid byte
        out     dx,ax

        shr     ebx,16

        mov     al,2ah      ;DST_ADDR_HIGH
        mov     ah,bl       ;dst addr high byte
        out     dx,ax

        ;
        ; Start blt
        ;

        mov     al,31h      ;BLT_START_STATUS_REG
        mov     ah,2        ;BLT_START
        out     dx,ax

		pop		eax

DoneSetDestAddr:

        add     eax,ecx                                 ; add num scans just done
        mov     [esp].sp_yDst,eax

DoneDuplicate:

        cmp     [ebp].str_YDstCount,0                   ; we might be all done
        jne     NextScan

Done:

        add     esp,(size STACK_STRUC) - PROC_MEM_SIZE
        pop     ebp
        pop     esi
        pop     edi
        pop     ebx

        ret     4

vDirectStretch8@4 endp

;---------------------------Public-Routine------------------------------;
; VOID vDirectStretch16(pStrBlt)
;
; Stretch blt 16 -> 16
;-----------------------------------------------------------------------;

        public vDirectStretch16@4

vDirectStretch16@4 proc near

        ;
        ; use ebp as general register, use esp for parameter and local access
        ; save ebp,ebx,esi,edi
        ;

        push    ebx
        push    edi
        push    esi
        push    ebp

        sub     esp,(size STACK_STRUC) - PROC_MEM_SIZE  ; make room for local variables

        mov     ebp,[esp].sp_pSTR_BLT                   ; load pSTR_BLT into ebp

        ;
        ; load up some stack-based parameters to be used by our scan
        ; duplicator when doing vertical stretches
        ;

        mov     eax,[ebp].str_ppdev
        mov     ecx,[ebp].str_YDstStart                 ; get start y coordinate
        mov     [esp].sp_pdev,eax                       ; save ppdev pointer

        mov     ebx,[eax].pdev_xyOffset
        mov     [esp].sp_xyOffset,ebx                   ; save xyOffset

        mov     [esp].sp_yDst,ecx                       ; save current y coordinate

        ;
        ; calc starting addressing parameters
        ;

        mov     esi,[ebp].str_pjSrcScan                 ; load src DIB pointer
        mov     eax,[ebp].str_XSrcStart
        mov     edi,[ebp].str_pjDstScan                 ; load dst DIB pointer
        mov     ebx,[ebp].str_XDstStart
        add     esi,eax
        add     edi,ebx
        add     esi,eax                                 ; add starting Src Pixel
        add     edi,ebx                                 ; add starting Dst Pixel
        mov     [esp].sp_pjSrcScan,esi                  ; save scan line start pointer
        mov     eax,[ebp].str_ulYDstToSrcIntCeil        ; number of src scan lines to step
        mul     [ebp].str_lDeltaSrc                     ; calc scan line int lines to step
        mov     [esp].sp_SrcIntStep,eax                 ; save int portion of Y src step
        mov     edx,edi                                 ; make copy of pjDst
        and     edx,2                                   ; calc left edge case
        shr     edx,1                                   ; left edge pixels
        mov     [esp].sp_LeftCase,edx                   ; save left edge case pixels
        mov     eax,[ebp].str_pjDstScan                 ; make copy
        mov     ecx,[ebp].str_XDstEnd                   ; load x end
        add     eax,ecx
        add     eax,ecx                                 ; ending dst addr
        and     eax,2                                   ; calc right edge case
        shr     eax,1                                   ; right edge pixels
        mov     [esp].sp_RightCase,eax                  ; save right edge case
        sub     ecx,[ebp].str_XDstStart                 ; calc x count

        shl     ecx,1
        dec     ecx
        mov     [esp].sp_XCntHW,ecx                     ; x width for accelerator
        inc     ecx
        shr     ecx,1

        mov     ebx,[ebp].str_lDeltaDst                 ; dst scan line stride
        sub     ebx,ecx
        sub     ebx,ecx                                 ; distance from end of one line to start of next
        mov     [esp].sp_DstStride,ebx                  ; save dst scan line stride
        sub     ecx,eax                                 ; sub right edge from XCount
        sub     ecx,edx                                 ; sub left edge from XCount
        shr     ecx,1                                   ; convert from pixels to DWORD count
        mov     [esp].sp_XCount,ecx                     ; save DWORD count
        mov     ebx,[ebp].str_ulXDstToSrcFracCeil       ; get x frac
        mov     [esp].sp_TempXFrac,ebx                  ; save x frac to a esp based location

NextScan:

        ;
        ; Wait until the accelerator is done with current blt
        ;

        mov     dx,3ceh     ;index register
        mov     al,31h      ;status reg
        out     dx,al
        mov     dx,3cfh     ;data register
@@:     in      al,dx
        test    al,1
        jnz     short @b

SingleLoop:

        ;
        ; esi and edi are assumed to be correctly loaded
        ;

        mov     eax,[ebp].str_ulXDstToSrcIntCeil        ; get src integer step for step in dst
        mov     ebx,[ebp].str_ulXDstToSrcFracCeil       ; get src frac step for step in dst
        mov     edx,[ebp].str_ulXFracAccumulator        ; put it in edx as tmp

        mov     ebp,edi                                 ; get dst pointer to ebp

        ;
        ; Can't directly access pSTR_BLT variables through ebp
        ;

        mov     edi,edx                                 ; get accumulator where we want it
        mov     ecx,[esp].sp_LeftCase

        ; eax = integer step in source
        ; ebx = fractional step in source
        ; ecx = left edge case
        ; edx = free for pixel data
        ; esi = pointer to source pixel
        ; edi = fractional accumulator
        ; ebp = pointer to dest pixel

        ;
        ; divide 'esi' by 2 so that we can always dereference it by
        ; [2*esi] -- this allows us to still use an 'add with carry'
        ; to jump to the next pixel
        ;

        shr     esi,1

        ;
        ; first do the left side to align dwords
        ;

        test    ecx,ecx
        jz      DwordAligned

        mov     dx,[2*esi]                              ; fetch pixel
        mov     [ebp],dx                                ; write it out
        add     edi,ebx                                 ; step fraction
        adc     esi,eax                                 ; add in integer and possible carry
        add     ebp,2                                   ; step 1 in dest

DwordAligned:

        mov     ecx,[esp].sp_XCount                     ; get run length
        test    ecx,ecx
        jz      TrailingBytes                           ; watch for zero dword case

@@:
        mov     dx,[2*esi]                              ; get a source pixel
        add     edi,ebx                                 ; step fraction
        adc     esi,eax                                 ; add integer and carry

        shl     edx,16

        add     edi,ebx                                 ; step fraction
        mov     dx,[2*esi]                              ; get source pixel
        adc     esi,eax                                 ; add integer and carry

        ror     edx,16

        mov     [ebp],edx                               ; write everything to dest

        add     ebp,4                                   ; increment dest pointer by 1 dword
        dec     ecx                                     ; decrement count
        jnz     @b                                      ; do more pixels

TrailingBytes:

        ;
        ; now do the right side trailing bytes
        ;

        mov     ecx,[esp].sp_RightCase
        test    ecx,ecx
        jz      EndScanLine

        mov     dx,[2*esi]                              ; fetch pixel
        mov     [ebp],dx                                ; write it out
        add     edi,ebx                                 ; step fraction
        adc     esi,eax                                 ; add in integer and possible carry
        add     ebp,2                                   ; step 1 in dest

EndScanLine:

        mov     edi,ebp                                 ; get dst pointer back
        mov     ebp,[esp].sp_pSTR_BLT                   ; load pSTR_BLT into ebp

EndSkipScan:

        mov     esi,[esp].sp_pjSrcScan                  ; load src scan start addr
        mov     ebx,esi                                 ; save a copy
        mov     eax,[ebp].str_ulYFracAccumulator        ; get .32 part of Y pointer
        add     eax,[ebp].str_ulYDstToSrcFracCeil       ; add in fractional step
        jnc     @f
        add     esi,[ebp].str_lDeltaSrc                 ; step one extra in src
@@:     mov     [ebp].str_ulYFracAccumulator,eax        ; save Y accumulator

        add     esi,[esp].sp_SrcIntStep                 ; step int part
        mov     [esp].sp_pjSrcScan,esi                  ; save starting scan addr
        add     edi,[esp].sp_DstStride                  ; step to next scan in dst
        dec     [ebp].str_YDstCount                     ; decrement scan count
        jz      Done                                    ; no more scans

        inc     [esp].sp_yDst                           ; one scan further down in dst
        cmp     esi,ebx                                 ; is src scan same as before?
        jne     NextScan                                ; if so, fall through to dupe scan

        ;--------------------------------------------------------------------
        ; The source scan is the same one used for the previous destination
        ; scan, so we can simply use the hardware to copy the previous
        ; destination scan.
        ;
        ; Since on the S3 we can set up a 'rolling blt' to copy one scan
        ; line to several scans in a single command, we will count up how
        ; many times this scan should be duplicated.  If your hardware
        ; cannot do a rolling blt, simply issue a new blt command for
        ; every time the scan should be duplicated.
        ;
        ; eax = ulYFracAccumulator
        ; ebx = original pjSrcScan
        ; esi = current pjSrcScan
        ; ebp = pSTR_BLT
        ;

        mov     ecx,-1                                  ; number of times scan is to be
                                                        ;  duplicated, less one
AnotherDuplicate:

        inc     ecx                                     ; one scan further down
        dec     [ebp].str_YDstCount                     ; decrement scan count
        jz      OutputDuplicates                        ; no more scans
        add     eax,[ebp].str_ulYDstToSrcFracCeil       ; add in fractional step
        jnc     @f
        add     esi,[ebp].str_lDeltaSrc                 ; step one extra in src
@@:     add     esi,[esp].sp_SrcIntStep                 ; step int part
        add     edi,[ebp].str_lDeltaDst                 ; step entire dest scan
        cmp     esi,ebx                                 ; is src scan same as before?
        je      AnotherDuplicate

OutputDuplicates:

        mov     [esp].sp_pjSrcScan,esi                  ; save starting scan address
        mov     [ebp].str_ulYFracAccumulator,eax        ; save Y accumulator

        ;
        ; Now output the command to do the 'rolling blt'
        ;

        ;; mov     edx,[esp].sp_pjBase

        ;
        ; Wait until the accelerator is done with current blt
        ;

        mov     dx,3ceh     ;index register
        mov     al,31h      ;status reg
        out     dx,al
        mov     dx,3cfh     ;data register
@@:     in      al,dx
        test    al,1
        jnz     short @b

        mov     ebx,[esp].sp_XCntHW
        mov     eax,[esp].sp_yDst

        ; eax = yDst      -- Destination scan line (source scan line is yDst - 1)
        ; ebx = XCntHW    -- Number of bytes across (width) - 1
        ; ecx = cy        -- Number of times scan is to be duplicated - 1
        ; edx = pjBase    -- Pointer to memory mapped accelerator registers
        ; ebp = pSTR_BLT  -- Stretch blt info

DuplicateViaMmIo:

        ;
        ; Do the copy:
        ;

if 0
        CP_XCNT(ppdev, pjBase, (WidthXBytes - 1));
        CP_YCNT(ppdev, pjBase, (cyDuplicate - 1));
        CP_SRC_ADDR(ppdev, pjBase, (xyOffset + ((yDst - 1) * lDelta) + xDstBytes));
        SET_DEST_ADDR(ppdev, ((yDst * lDelta) + xDstBytes));
        START_ACL(ppdev);
endif

        .errnz  RECT_HEIGHT

        ;; mov     [edx+OFFSET_wXCnt],bx
        ;; mov     [edx+OFFSET_wYCnt],cx

        mov     dx,3ceh     ;index register

        ;
        ; set XCNT=bx and YCNT=cx
        ;

		push	eax

        mov     al,21h      ;BLT_WIDTH_HIGH
        mov     ah,bh       ;x count high byte
        out     dx,ax
        mov     al,20h      ;BLT_WIDTH_LOW
        mov     ah,bl       ;x count low byte
        out     dx,ax

        mov     al,23h      ;BLT_HEIGHT_HIGH
        mov     ah,ch       ;y count high byte
        out     dx,ax
        mov     al,22h      ;BLT_HEIGHT_LOW
        mov     ah,cl       ;y count low byte
        out     dx,ax

		pop		eax

        ;
        ; Calculate src address
        ;

        mov     ebx,eax                                 ; ebx <- yDst
        dec     ebx
        imul    ebx,[ebp].str_lDeltaDst
        add     ebx,[esp].sp_xyOffset
        add     ebx,[ebp].str_xDstStart
        add     ebx,[ebp].str_xDstStart

        ;; mov     [edx+OFFSET_ulSrcAddr],ebx

		push	eax

        mov     al,2ch      ;SRC_ADDR_LOW
        mov     ah,bl       ;src addr low byte
        out     dx,ax
        mov     al,2dh      ;SRC_ADDR_MID
        mov     ah,bh       ;src addr mid byte
        out     dx,ax

        shr     ebx,16

        mov     al,2eh      ;SRC_ADDR_HIGH
        mov     ah,bl       ;src addr high byte
        out     dx,ax

		pop		eax

        ;
        ; Calculate dst address
        ;

        inc     eax                                     ; account for 'ecx' being
                                                        ;  one less than scan count

        mov     ebx,eax                                 ; ebx <- yDst
        dec     ebx
        imul    ebx,[ebp].str_lDeltaDst
        add     ebx,[esp].sp_xyOffset
        add     ebx,[ebp].str_xDstStart
        add     ebx,[ebp].str_xDstStart

        ;; mov     [edx+OFFSET_ulDstAddr],ebx

        push	eax

        mov     al,28h      ;DST_ADDR_LOW
        mov     ah,bl       ;dst addr low byte
        out     dx,ax
        mov     al,29h      ;DST_ADDR_MID
        mov     ah,bh       ;dst addr mid byte
        out     dx,ax

        shr     ebx,16

        mov     al,2ah      ;DST_ADDR_HIGH
        mov     ah,bl       ;dst addr high byte
        out     dx,ax

        ;
        ; Start blt
        ;

        mov     al,31h      ;BLT_START_STATUS_REG
        mov     ah,2        ;BLT_START
        out     dx,ax

		pop		eax

DoneSetDestAddr:

        add     eax,ecx                                 ; add num scans just done
        mov     [esp].sp_yDst,eax

DoneDuplicate:

        cmp     [ebp].str_YDstCount,0                   ; we might be all done
        jne     NextScan

Done:

        add     esp,(size STACK_STRUC) - PROC_MEM_SIZE
        pop     ebp
        pop     esi
        pop     edi
        pop     ebx

        ret     4

vDirectStretch16@4 endp

end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\cirrus\disp\i386\hw.inc ===
;---------------------------- Include File Header ---------------------------;
; Module Name: hw.inc
;
; All the hardware specific driver file stuff.  Mirrors some of 'hw.h'.
;
; Copyright (c) 1993-1994 Microsoft Corporation
;----------------------------------------------------------------------------;

;--------------------------------------------------------------------------
; Chip equates

STATUS_1                        equ 03DAh
VSY_NOT                         equ 08h

CRTC_INDEX                      equ 03D4h
CRTC_DATA                       equ 03D5h

S3R8                            equ 038h
S3R9                            equ 039h
S3R1                            equ 031h
S3R5                            equ 035h

CR39                            equ 039h
CR4C                            equ 04Ch
CR4D                            equ 04Dh

HGC_MODE                        equ 045h
HGC_ENABLE                      equ 001h
HGC_DISABLE                     equ 000h

HGC_ORGX_LSB                    equ 047h
HGC_ORGX_MSB                    equ 046h
HGC_ORGY_LSB                    equ 049h
HGC_ORGY_MSB                    equ 048h

HGC_DX                          equ 04Eh
HGC_DY                          equ 04Fh

REG_UNLOCK_1                    equ 048h
CPUA_BASE                       equ 001h

SYSCTL_UNLOCK                   equ 0A0h
SYSCTL_LOCK                     equ 000h

SYS_CNFG                        equ 040h
LAW_CTL                         equ 058h
EX_SCTL_2                       equ 051h
EX_DAC_CT                       equ 055h

MISC_1                          equ 03Ah

; Command types:

DRAW_LINE                       equ 02000h
RECTANGLE_FILL                  equ 04000h
BITBLT                          equ 0C000h
PATTERN_FILL                    equ 0E000h

BYTE_SWAP                       equ 01000h
BUS_SIZE_16                     equ 00200h
BUS_SIZE_8                      equ 00000h
WAIT_CPU                        equ 00100h

; Drawing directions (radial):

DRAWING_DIRECTION_0             equ 0000h
DRAWING_DIRECTION_45            equ 0020h
DRAWING_DIRECTION_90            equ 0040h
DRAWING_DIRECTION_135           equ 0060h
DRAWING_DIRECTION_180           equ 0080h
DRAWING_DIRECTION_225           equ 00A0h
DRAWING_DIRECTION_270           equ 00C0h
DRAWING_DIRECTION_315           equ 00E0h

; Drawing directions (x/y):

DRAWING_DIR_BTRLXM              equ 0000h
DRAWING_DIR_BTLRXM              equ 0020h
DRAWING_DIR_BTRLYM              equ 0040h
DRAWING_DIR_BTLRYM              equ 0060h
DRAWING_DIR_TBRLXM              equ 0080h
DRAWING_DIR_TBLRXM              equ 00A0h
DRAWING_DIR_TBRLYM              equ 00C0h
DRAWING_DIR_TBLRYM              equ 00E0h

; Drawing direction bits:

PLUS_X                          equ 0020h
PLUS_Y                          equ 0080h
MAJOR_Y                         equ 0040h

; Draw:

DRAW                            equ 0010h

; Direction type:

DIR_TYPE_RADIAL                 equ 0008h
DIR_TYPE_XY                     equ 0000h

; Last pixel:

LAST_PIXEL_OFF                  equ 0004h
LAST_PIXEL_ON                   equ 0000h

; Pixel mode:

MULTIPLE_PIXELS                 equ 0002h
SINGLE_PIXEL                    equ 0000h

; Read/write:

READ                            equ 0000h
WRITE                           equ 0001h

; Graphics processor status:

HARDWARE_BUSY                   equ 0200h
READ_DATA_AVAILABLE             equ 0100h
GP_ALL_EMPTY                    equ 0400h

; Fifo status in terms of empty entries:

FIFO_1_EMPTY                    equ 0080h
FIFO_2_EMPTY                    equ 0040h
FIFO_3_EMPTY                    equ 0020h
FIFO_4_EMPTY                    equ 0010h
FIFO_5_EMPTY                    equ 0008h
FIFO_6_EMPTY                    equ 0004h
FIFO_7_EMPTY                    equ 0002h
FIFO_8_EMPTY                    equ 0001h

; These are the defines for the multifunction control register.
; The 4 MSBs define the function of the register.

RECT_HEIGHT                     equ 00000h

CLIP_TOP                        equ 01000h
CLIP_LEFT                       equ 02000h
CLIP_BOTTOM                     equ 03000h
CLIP_RIGHT                      equ 04000h

DATA_EXTENSION                  equ 0A000h
MULT_MISC_INDEX                 equ 0E000h
READ_SEL_INDEX                  equ 0F000h

ALL_ONES                        equ 00000h
CPU_DATA                        equ 00080h
DISPLAY_MEMORY                  equ 000C0h

; Color source:

BACKGROUND_COLOR                equ 000h
FOREGROUND_COLOR                equ 020h
SRC_CPU_DATA                    equ 040h
SRC_DISPLAY_MEMORY              equ 060h

; Mix modes:

NOT_SCREEN                      equ 00h
LOGICAL_0                       equ 01h
LOGICAL_1                       equ 02h
LEAVE_ALONE                     equ 03h
NOT_NEW                         equ 04h
SCREEN_XOR_NEW                  equ 05h
NOT_SCREEN_XOR_NEW              equ 06h
OVERPAINT                       equ 07h
NOT_SCREEN_OR_NOT_NEW           equ 08h
SCREEN_OR_NOT_NEW               equ 09h
NOT_SCREEN_OR_NEW               equ 0Ah
SCREEN_OR_NEW                   equ 0Bh
SCREEN_AND_NEW                  equ 0Ch
NOT_SCREEN_AND_NEW              equ 0Dh
SCREEN_AND_NOT_NEW              equ 0Eh
NOT_SCREEN_AND_NOT_NEW          equ 0Fh

; When one of the following bits is set in a hardware mix, it means
; that a pattern is needed (i.e., is none of NOT_SCREEN, LOGICAL_0,
; LOGICAL_1 or LEAVE_ALONE):

MIX_NEEDSPATTERN                equ 0Ch
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\cirrus\mini\cirrus.c ===
//---------------------------------------------------------------------------
/*++

Copyright (c) 1992-1997  Microsoft Corporation.
Copyright (c) 1996-1997  Cirrus Logic, Inc.,

Module Name:

    C   I   R   R   U   S  .  C

Abstract:

    This is the miniport driver for the Cirrus Logic
    6410/6420/542x/543x/544x/548x/754x/755x VGA's.

Environment:

    Kernel mode only

Notes:

Revision History:

* $Log:   S:/projects/drivers/ntsrc/miniport/cirrus.c_v  $
 *
 *    Rev 1.16   Apr 03 1997 15:44:40   unknown
 *
 *
 *    Rev 1.10   Jan 08 1997 14:25:40   unknown
 * Fix the 440FX and 5446AC coexist problem.
 *
 *    Rev 1.9   18 Dec 1996 14:03:48   PLCHU
 *
 *
 *    Rev 1.7   Dec 06 1996 11:14:16   unknown
 *
 *
 *    Rev 1.6   Nov 26 1996 16:29:02   unknown
 *
 *
 *    Rev 1.8   Nov 26 1996 16:02:20   unknown
 * Add conditional compile for P6Cache
 *
 *    Rev 1.7   Nov 26 1996 14:32:42   unknown
 * turn on PCI14 and second aperture for 5480
 *
 *    Rev 1.6   Nov 18 1996 16:23:32   unknown
 * Add P6 Cache flag and fix 5436BG hung bug for HCT
 *
 *    Rev 1.5   Nov 05 1996 14:49:56   unknown
 * turn off PCI14 for 5480 temporaryly
 *
 *    Rev 1.4   Nov 01 1996 16:44:54   unknown
*
*    Rev 1.3   Oct 14 1996 10:49:36   unknown
* Add 100Hz monitor support and Detailed timnig calculation
*
*    Rev 1.4   07 Aug 1996 14:43:02   frido
* Added better support for monochrome text modes.
*
*    Rev 1.3   06 Aug 1996 18:35:54   frido
* Changed the way the video memory is shared in linear mode.
*
*    Rev 1.2   06 Aug 1996 17:19:20   frido
* Removed banking in linear mode.
*
*   chu01  08-26-96   Distinguish CL-5480 and CL-5436/46 because the former
*                     has new fratures such as XY-clipping, XY-position and
*                     BLT command list that the others do not have.
*   jl01   09-24-96   Fix Alt+Tab switching between "Introducing Windows NT"
*                     and "Main".  Refer to PDR#5409.
*   jl02   10-21-96   Add CL-5446BE support.
*   sge01  10-14-96   VGA register and MMIO register can be relocatable.
*   sge02  10-22-96   VideoMemoryAddress use linear address instead of A0000.
*   sge03  10-23-96   Add second aperture maping
*   chu02  10-31-96   DDC2B enabling / disabling
*   sge04  11-04-96   Disable PCI14 for 5480 temporaryly
*   sge05  11-07-96   Add P6Cache support
*   sge06  11-26-96   Add conditional compile for P6Cache support
*   jl03   12-05-96   Set CL-5446BE flag "CL5446BE"
*   chu03  12-16-96   Enable color correction
*   sge07  12-16-96   Check mono or color mode before reading input status
*   sge08  01-08-97   Fix the 440FX and 5446AC coexist problem.
*   myf0   08-19-96   added 85hz supported
*   myf1   08-20-96   supported panning scrolling
*   myf2   08-20-96   fixed hardware save/restore state bug for matterhorn
*   myf3   09-01-96   Added IOCTL_CIRRUS_PRIVATE_BIOS_CALL for TV supported
*   myf4   09-01-96   patch Viking BIOS bug, PDR #4287, begin
*   myf5   09-01-96   Fixed PDR #4365 keep all default refresh rate
*   myf6   09-17-96   Merged Desktop SRC1001 & MINI102
*   myf7   09-19-96   Fixed exclude 60Hz refresh rate select
*   myf8  *09-21-96*  May be need change CheckandUpdateDDC2BMonitor --keystring[]
*   myf9   09-21-96   8x6 panel in 6x4x256 mode, cursor can't move to bottom scrn
*   ms0809 09-25-96   fixed dstn panel icon corrupted
*   ms923  09-25-96   merge MS-923 Disp.zip code
*   myf10  09-26-96   Fixed DSTN reserved half-frame buffer bug.
*   myf11  09-26-96   Fixed 755x CE chip HW bug, access ramdac before disable HW
*                     icons and cursor
*   myf12  10-01-96   Supported Hot Key switch display
*   myf13  10-05-96   Fixed /w panning scrolling, vertical expension on bug
*   myf14  10-15-96   Fixed PDR#6917, 6x4 panel can't panning scrolling for 754x
*   myf15  10-16-96   Fixed disable memory mapped IO for 754x, 755x
*   myf16  10-22-96   Fixed PDR #6933,panel type set different demo board setting
*   smith  10-22-96   Disable Timer event, because sometimes creat PAGE_FAULT or
*                     IRQ level can't handle
*   myf17  11-04-96   Added special escape code must be use 11/5/96 later NTCTRL,
*                     and added Matterhorn LF Device ID==0x4C
*   myf18  11-04-96   Fixed PDR #7075,
*   myf19  11-06-96   Fixed Vinking can't work problem, because DEVICEID = 0x30
*                     is different from data book (CR27=0x2C)
*   myf20  11-12-96   Fixed DSTN panel initial reserved 128K memoru
*   myf21  11-15-96   fixed #7495 during change resolution, screen appear garbage
*                     image, because not clear video memory.
*   myf22  11-19-96   Added 640x480x256/640x480x64K -85Hz refresh rate for 7548
*   myf23  11-21-96   Added fixed NT 3.51 S/W cursor panning problem
*   myf24  11-22-96   Added fixed NT 4.0 Japanese dos full screen problem
*   myf25  12-03-96   Fixed 8x6x16M 2560byte/line patch H/W bug PDR#7843, and
*                     fixed pre-install microsoft requested
*   myf26  12-11-96   Fixed Japanese NT 4.0 Dos-full screen bug for LCD enable
*   myf27  01-09-96   Fixed NT3.51 PDR#7986, horizontal lines appears at logon
*                     windows, set 8x6x64K mode boot up CRT, jumper set 8x6 DSTN
*                     Fixed NT3.51 PDR#7987, set 64K color modes, garbage on
*                     screen when boot up XGA panel.
*   myf28  02-03-97   Fixed NT3.51 PDR#8357, mode 3, 12, panning scrolling bug
*   myf29  02-12-97   Support Gamma correction graphic/video LUT for 755x
*   myf30  02-10-97   Fixed NT3.51, 6x4 LCD boot set 256 coloe, test 64K mode
*   jl04   02-11-97   Fix 542x VLB banking issue.
*   myf31  02-25-97   Fixed RadiSys system, set MCLK to 66MHz
*   myf32  03-02-97   Display each chip information
*   sge09  03-10-97   Add P6CACHE condition compile.
*   chu04  03-10-97   Chip type "5430/40", instead of "5430" requested by Intel.
*   chu05  03-13-97   For 5436 checked build NT, read 4-byte PCI
*                     configuration register to access index 0x53 instead of
*                     the whole 256 bytes.
*   chu06  03-26-97   Common routine to get Cirrus chip and revision IDs.
*   jl05   03-28-97   Fix for NT3.51
--*/
//---------------------------------------------------------------------------

#include <dderror.h>
#include <devioctl.h>
#include <miniport.h>

#include <ntddvdeo.h>
#include <video.h>
#include "cirrus.h"

#include "clioctl.h"

#include "sr754x.h"
#include "cmdcnst.h"

#define DDC2B  1

#define QUERY_MONITOR_ID            0x22446688
#define QUERY_NONDDC_MONITOR_ID     0x11223344


#define LCD_type        1
#define CRT_type        2
#define SIM_type        3

//---------------------------------------------------------------------------
//
// Function declarations
//
// Functions that start with 'VGA' are entry points for the OS port driver.
//

VP_STATUS
VgaFindAdapter(
    PVOID HwDeviceExtension,
    PVOID HwContext,
    PWSTR ArgumentString,
    PVIDEO_PORT_CONFIG_INFO ConfigInfo,
    PUCHAR Again
    );

BOOLEAN
VgaInitialize(
    PVOID HwDeviceExtension
    );

BOOLEAN
VgaStartIO(
    PVOID HwDeviceExtension,
    PVIDEO_REQUEST_PACKET RequestPacket
    );

//crus, smith
VOID
CirrusHwTimer(
    PVOID HwDeviceExtension
    );

//
// Private function prototypes.
//

VP_STATUS
VgaQueryAvailableModes(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PVIDEO_MODE_INFORMATION ModeInformation,
    ULONG ModeInformationSize,
    PULONG OutputSize
    );

VP_STATUS
VgaQueryNumberOfAvailableModes(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PVIDEO_NUM_MODES NumModes,
    ULONG NumModesSize,
    PULONG OutputSize
    );

VP_STATUS
VgaQueryCurrentMode(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PVIDEO_MODE_INFORMATION ModeInformation,
    ULONG ModeInformationSize,
    PULONG OutputSize
    );

VP_STATUS
VgaSetMode(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PVIDEO_MODE Mode,
    ULONG ModeSize
    );

VP_STATUS
VgaLoadAndSetFont(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PVIDEO_LOAD_FONT_INFORMATION FontInformation,
    ULONG FontInformationSize
    );

#ifdef PANNING_SCROLL
VP_STATUS
CirrusSetDisplayPitch (
   PHW_DEVICE_EXTENSION HwDeviceExtension,
   PANNMODE PanningMode
   );
#endif

VP_STATUS
VgaQueryCursorPosition(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PVIDEO_CURSOR_POSITION CursorPosition,
    ULONG CursorPositionSize,
    PULONG OutputSize
    );

VP_STATUS
VgaSetCursorPosition(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PVIDEO_CURSOR_POSITION CursorPosition,
    ULONG CursorPositionSize
    );

VP_STATUS
VgaQueryCursorAttributes(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PVIDEO_CURSOR_ATTRIBUTES CursorAttributes,
    ULONG CursorAttributesSize,
    PULONG OutputSize
    );

VP_STATUS
VgaSetCursorAttributes(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PVIDEO_CURSOR_ATTRIBUTES CursorAttributes,
    ULONG CursorAttributesSize
    );

BOOLEAN
VgaIsPresent(
    PHW_DEVICE_EXTENSION HwDeviceExtension
    );

BOOLEAN
CirrusLogicIsPresent(
    PHW_DEVICE_EXTENSION HwDeviceExtension
    );

ULONG
CirrusFindVmemSize(
    PHW_DEVICE_EXTENSION HwDeviceExtension
    );

VOID
CirrusValidateModes(
    PHW_DEVICE_EXTENSION HwDeviceExtension
    );

VOID
SetCirrusBanking(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    USHORT BankNumber
    );

VOID
vBankMap_CL64xx(
    ULONG iBankRead,
    ULONG iBankWrite,
    PVOID pvContext
    );

VOID
vBankMap_CL543x(
    ULONG iBankRead,
    ULONG iBankWrite,
    PVOID pvContext
    );

VOID
vBankMap_CL542x(
    ULONG iBankRead,
    ULONG iBankWrite,
    PVOID pvContext
    );

USHORT
CirrusFind6410DisplayType(
    PHW_DEVICE_EXTENSION HwDeviceExtension
    );

USHORT
CirrusFind6245DisplayType(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PUCHAR CRTCAddrPort,
    PUCHAR CRTCDataPort
    );

USHORT
CirrusFind754xDisplayType(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PUCHAR CRTCAddrPort,
    PUCHAR CRTCDataPort
    );

USHORT
CirrusFind755xDisplayType(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PUCHAR CRTCAddrPort,
    PUCHAR CRTCDataPort
    );

BOOLEAN
CirrusFind6340(
    PHW_DEVICE_EXTENSION HwDeviceExtension
    );

VOID
AccessHWiconcursor(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    SHORT Access_flag
    );


VOID
VgaInterpretCmdStream(
    PVOID HwDeviceExtension,
    PUSHORT pusCmdStream
    );

VP_STATUS
VgaSetPaletteReg(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PVIDEO_PALETTE_DATA PaletteBuffer,
    ULONG PaletteBufferSize
    );

VP_STATUS
VgaSetColorLookup(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PVIDEO_CLUT ClutBuffer,
    ULONG ClutBufferSize
    );

VP_STATUS
VgaRestoreHardwareState(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PVIDEO_HARDWARE_STATE HardwareState,
    ULONG HardwareStateSize
    );

VP_STATUS
VgaSaveHardwareState(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PVIDEO_HARDWARE_STATE HardwareState,
    ULONG HardwareStateSize,
    PULONG OutputSize
    );

VP_STATUS
VgaGetBankSelectCode(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PVIDEO_BANK_SELECT BankSelect,
    ULONG BankSelectSize,
    PULONG OutputSize
    );

BOOLEAN
CirrusConfigurePCI(
   PHW_DEVICE_EXTENSION HwDeviceExtension,
   PULONG NumPCIAccessRanges,
   PVIDEO_ACCESS_RANGE PCIAccessRanges
   );

VOID
WriteRegistryInfo(
   PHW_DEVICE_EXTENSION hwDeviceExtension
   );

VP_STATUS
CirrusGetDeviceDataCallback(
   PVOID HwDeviceExtension,
   PVOID Context,
   VIDEO_DEVICE_DATA_TYPE DeviceDataType,
   PVOID Identifier,
   ULONG IdentifierLength,
   PVOID ConfigurationData,
   ULONG ConfigurationDataLength,
   PVOID ComponentInformation,
   ULONG ComponentInformationLength
   );

VOID
IOWaitDisplEnableThenWrite(
    PHW_DEVICE_EXTENSION hwDeviceExtension,
    ULONG port,
    UCHAR value
    );

VOID
ReadVESATiming(
    PHW_DEVICE_EXTENSION hwDeviceExtension
    );

#if (_WIN32_WINNT <= 0x0400)
VOID
CheckAndUpdateDDC2BMonitor(
    PHW_DEVICE_EXTENSION HwDeviceExtension
    );
#endif // (_WIN32_WINNT <= 0x0400)

VOID
CirrusUpdate440FX(
    PHW_DEVICE_EXTENSION HwDeviceExtension
    );

//
// NOTE:
//
// This is a High Priority system callback.  DO NOT mark this
// routine as pageable!
//

BOOLEAN
IOCallback(
    PHW_DEVICE_EXTENSION HwDeviceExtension
    );

VP_STATUS
VgaGetGammaFactor(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PGAMMA_VALUE value,
    ULONG ValueLength,
    PULONG OutputSize
    );

VP_STATUS
VgaGetContrastFactor(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PCONTRAST_VALUE value,
    ULONG ValueLength,
    PULONG OutputSize
    );

UCHAR
GetCirrusChipId(
    PHW_DEVICE_EXTENSION HwDeviceExtension
    );

USHORT
GetCirrusChipRevisionId(
    PHW_DEVICE_EXTENSION HwDeviceExtension
    );

#if defined(ALLOC_PRAGMA)
#pragma alloc_text(PAGE,DriverEntry)
#pragma alloc_text(PAGE,VgaFindAdapter)
#pragma alloc_text(PAGE,VgaInitialize)
#pragma alloc_text(PAGE,VgaStartIO)
#pragma alloc_text(PAGE,CirrusHwTimer)
#pragma alloc_text(PAGE,VgaLoadAndSetFont)
#pragma alloc_text(PAGE,VgaQueryCursorPosition)
#pragma alloc_text(PAGE,VgaSetCursorPosition)
#pragma alloc_text(PAGE,VgaQueryCursorAttributes)
#pragma alloc_text(PAGE,VgaSetCursorAttributes)
#pragma alloc_text(PAGE,VgaIsPresent)
#pragma alloc_text(PAGE,CirrusLogicIsPresent)
#pragma alloc_text(PAGE,CirrusFindVmemSize)
#pragma alloc_text(PAGE,SetCirrusBanking)

#ifdef PANNING_SCROLL
#pragma alloc_text(PAGE,CirrusSetDisplayPitch)
#endif
#pragma alloc_text(PAGE,CirrusFind6245DisplayType)
#pragma alloc_text(PAGE,CirrusFind754xDisplayType)
#pragma alloc_text(PAGE,CirrusFind755xDisplayType)
#pragma alloc_text(PAGE,CirrusFind6410DisplayType)
#pragma alloc_text(PAGE,CirrusFind6340)
#pragma alloc_text(PAGE,AccessHWiconcursor)
#pragma alloc_text(PAGE,CirrusConfigurePCI)
#pragma alloc_text(PAGE,VgaSetPaletteReg)
#pragma alloc_text(PAGE,VgaSetColorLookup)
#pragma alloc_text(PAGE,VgaRestoreHardwareState)
#pragma alloc_text(PAGE,VgaSaveHardwareState)
#pragma alloc_text(PAGE,VgaGetBankSelectCode)

#pragma alloc_text(PAGE,VgaValidatorUcharEntry)
#pragma alloc_text(PAGE,VgaValidatorUshortEntry)
#pragma alloc_text(PAGE,VgaValidatorUlongEntry)

#pragma alloc_text(PAGE,WriteRegistryInfo)
#pragma alloc_text(PAGE,CirrusGetDeviceDataCallback)
#pragma alloc_text(PAGE,CirrusUpdate440FX)

#pragma alloc_text(PAGE,VgaGetGammaFactor)
#pragma alloc_text(PAGE,VgaGetContrastFactor)

#if (_WIN32_WINNT >= 0x0500)
#pragma alloc_text(PAGE,CirrusGetChildDescriptor)
#pragma alloc_text(PAGE,CirrusGetPowerState)
#pragma alloc_text(PAGE,CirrusSetPowerState)
#endif

#endif

BOOLEAN
GetDdcInformation(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PUCHAR QueryBuffer,
    ULONG BufferSize);

ULONG
CirrusGetChildDescriptor(
    PVOID pHwDeviceExtension,
    PVIDEO_CHILD_ENUM_INFO ChildEnumInfo,
    PVIDEO_CHILD_TYPE pChildType,
    PVOID pChildDescriptor,
    PULONG pHwId,
    PULONG pUnused
    )

/*++

Routine Description:

    Enumerate all devices controlled by the ATI graphics chip.
    This includes DDC monitors attached to the board, as well as other devices
    which may be connected to a proprietary bus.

Arguments:

    HwDeviceExtension - Pointer to our hardware device extension structure.

    ChildIndex        - Index of the child the system wants informaion for.

    pChildType        - Type of child we are enumerating - monitor, I2C ...

    pChildDescriptor  - Identification structure of the device (EDID, string)

    ppHwId            - Private unique 32 bit ID to passed back to the miniport

    pMoreChildren     - Should the miniport be called

Return Value:

    Status from VideoPortInitialize()

Note:

    In the event of a failure return, none of the fields are valid except for
    the return value and the pMoreChildren field.

--*/

{
    PHW_DEVICE_EXTENSION hwDeviceExtension = pHwDeviceExtension;
    ULONG Status;

    switch (ChildEnumInfo->ChildIndex) {
    case 0:

        //
        // Case 0 is used to enumerate devices found by the ACPI firmware.
        //
        // Since we do not support ACPI devices yet, we must return failure.
        //

        Status = ERROR_NO_MORE_DEVICES;
        break;

    case 1:

        //
        // This is the last device we enumerate.  Tell the system we don't
        // have any more.
        //

        *pChildType = Monitor;

        //
        // Obtain the EDID structure via DDC.
        //

        if (GetDdcInformation(hwDeviceExtension,
                              pChildDescriptor,
                              ChildEnumInfo->ChildDescriptorSize))
        {
            *pHwId = QUERY_MONITOR_ID;

            VideoDebugPrint((1, "CirrusGetChildDescriptor - successfully read EDID structure\n"));

        } else {

            //
            // Alway return TRUE, since we always have a monitor output
            // on the card and it just may not be a detectable device.
            //

            *pHwId = QUERY_NONDDC_MONITOR_ID;

            VideoDebugPrint((1, "CirrusGetChildDescriptor - DDC not supported\n"));

        }

        Status = ERROR_MORE_DATA;
        break;


    case DISPLAY_ADAPTER_HW_ID:

        //
        // Special ID to handle return legacy PnP IDs for root enumerated
        // devices.
        //

        *pChildType = VideoChip;
        *pHwId      = DISPLAY_ADAPTER_HW_ID;

        memcpy(pChildDescriptor, hwDeviceExtension->LegacyPnPId, 8*sizeof(WCHAR));

        Status = ERROR_MORE_DATA;
        break;


    default:

        Status = ERROR_NO_MORE_DEVICES;
        break;
    }

    return Status;
}

VP_STATUS
CirrusGetPowerState(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    ULONG HwDeviceId,
    PVIDEO_POWER_MANAGEMENT VideoPowerManagement
    )

/*++

Routine Description:

    Returns power state information.

Arguments:

    HwDeviceExtension - Pointer to our hardware device extension structure.

    HwDeviceId        - Private unique 32 bit ID identifing the device.

    VideoPowerManagement - Power state information.

Return Value:

    TRUE if power state can be set,
    FALSE otherwise.

--*/

{
    //
    // We only support power setting for the monitor.  Make sure the
    // HwDeviceId matches one the the monitors we could report.
    //

    if ((HwDeviceId == QUERY_NONDDC_MONITOR_ID) ||
        (HwDeviceId == QUERY_MONITOR_ID)) {

        //
        // We are querying the power support for the monitor.
        //

        if ((VideoPowerManagement->PowerState == VideoPowerOn) ||
            (VideoPowerManagement->PowerState == VideoPowerHibernate)) {
	
            return NO_ERROR;
        }

        switch (VideoPowerManagement->PowerState) {
	
        case VideoPowerStandBy:
            return (HwDeviceExtension->PMCapability & VESA_POWER_STANDBY) ?
                   NO_ERROR : ERROR_INVALID_FUNCTION;
	
        case VideoPowerSuspend:
            return (HwDeviceExtension->PMCapability & VESA_POWER_SUSPEND) ?
                   NO_ERROR : ERROR_INVALID_FUNCTION;
	
        case VideoPowerOff:
            return (HwDeviceExtension->PMCapability & VESA_POWER_OFF) ?
                   NO_ERROR : ERROR_INVALID_FUNCTION;
	
        default:
            break;
        }

        VideoDebugPrint((1, "This device does not support Power Management.\n"));
        return ERROR_INVALID_FUNCTION;

    } else if (HwDeviceId == DISPLAY_ADAPTER_HW_ID) {

        //
        // We are querying power support for the graphics card.
        //

        switch (VideoPowerManagement->PowerState) {

            case VideoPowerOn:
            case VideoPowerHibernate:
            case VideoPowerStandBy:

                return NO_ERROR;

            case VideoPowerOff:
            case VideoPowerSuspend:

                if ((HwDeviceExtension->ChipType & CL754x) ||
                    (HwDeviceExtension->ChipType & CL755x) ||
                    (HwDeviceExtension->ChipType & CL756x)) {

                    //
                    // We will allow the system to go into S3 sleep state
                    // for machines with laptop chipsets.  The system
                    // bios will be responsible for re-posting on wake up.
                    //

                    return NO_ERROR;

                } else {

                    //
                    // Indicate that we can't do VideoPowerOff, because
                    // we have no way of coming back when power is re-applied
                    // to the card.
                    //

                    return ERROR_INVALID_FUNCTION;
                }

            default:

                ASSERT(FALSE);
                return ERROR_INVALID_FUNCTION;
        }

    } else {

        VideoDebugPrint((1, "Unknown HwDeviceId"));
        ASSERT(FALSE);
        return ERROR_INVALID_PARAMETER;
    }
}

VP_STATUS
CirrusSetPowerState(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    ULONG HwDeviceId,
    PVIDEO_POWER_MANAGEMENT VideoPowerManagement
    )

/*++

Routine Description:

    Set the power state for a given device.

Arguments:

    HwDeviceExtension - Pointer to our hardware device extension structure.

    HwDeviceId        - Private unique 32 bit ID identifing the device.

    VideoPowerManagement - Power state information.

Return Value:

    TRUE if power state can be set,
    FALSE otherwise.

--*/

{
    //
    // Make sure we recognize the device.
    //

    if ((HwDeviceId == QUERY_NONDDC_MONITOR_ID) ||
        (HwDeviceId == QUERY_MONITOR_ID)) {

        VIDEO_X86_BIOS_ARGUMENTS biosArguments;

        VideoPortZeroMemory(&biosArguments, sizeof(VIDEO_X86_BIOS_ARGUMENTS));

        biosArguments.Eax = VESA_POWER_FUNCTION;
        biosArguments.Ebx = VESA_SET_POWER_FUNC;

        switch (VideoPowerManagement->PowerState) {
        case VideoPowerOn:
        case VideoPowerHibernate:
            biosArguments.Ebx |= VESA_POWER_ON;
            break;

        case VideoPowerStandBy:
            biosArguments.Ebx |= VESA_POWER_STANDBY;
            break;

        case VideoPowerSuspend:
            biosArguments.Ebx |= VESA_POWER_SUSPEND;
            break;

        case VideoPowerOff:
            biosArguments.Ebx |= VESA_POWER_OFF;
            break;

        default:
            VideoDebugPrint((1, "Unknown power state.\n"));
            ASSERT(FALSE);
            return ERROR_INVALID_PARAMETER;
        }

        VideoPortInt10(HwDeviceExtension, &biosArguments);

        //
        // I have no idea why, but on some machines after a while
        // the Pixel Mask Register gets set to zero.  Then when
        // we power back up, we can no longer see the screen.  It is
        // black.
        //
        // By setting the register here, we can prevent this
        // problem.  There should be no harmful side effects to
        // this.
        //

        if (VideoPowerManagement->PowerState == VideoPowerOn) {

            VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                    DAC_PIXEL_MASK_PORT, 0xff);
        }

        return NO_ERROR;

    } else if (HwDeviceId == DISPLAY_ADAPTER_HW_ID) {

        switch (VideoPowerManagement->PowerState) {

            case VideoPowerOn:
            case VideoPowerStandBy:
            case VideoPowerSuspend:
            case VideoPowerOff:
            case VideoPowerHibernate:

                return NO_ERROR;

            default:

                ASSERT(FALSE);
                return ERROR_INVALID_PARAMETER;
        }

    } else {

        VideoDebugPrint((1, "Unknown HwDeviceId"));
        ASSERT(FALSE);
        return ERROR_INVALID_PARAMETER;
    }
}


//---------------------------------------------------------------------------
ULONG
DriverEntry(
    PVOID Context1,
    PVOID Context2
    )

/*++

Routine Description:

    Installable driver initialization entry point.
    This entry point is called directly by the I/O system.

Arguments:

    Context1 - First context value passed by the operating system. This is
        the value with which the miniport driver calls VideoPortInitialize().

    Context2 - Second context value passed by the operating system. This is
        the value with which the miniport driver calls 3VideoPortInitialize().

Return Value:

    Status from VideoPortInitialize()

--*/

{

    VIDEO_HW_INITIALIZATION_DATA hwInitData;
    ULONG status;
    ULONG initializationStatus = (ULONG) -1;

    //
    // Zero out structure.
    //

    VideoPortZeroMemory(&hwInitData, sizeof(VIDEO_HW_INITIALIZATION_DATA));

    //
    // Specify sizes of structure and extension.
    //

    hwInitData.HwInitDataSize = sizeof(VIDEO_HW_INITIALIZATION_DATA);

    //
    // Set entry points.
    //

    hwInitData.HwFindAdapter = VgaFindAdapter;
    hwInitData.HwInitialize = VgaInitialize;
    hwInitData.HwInterrupt = NULL;
    hwInitData.HwStartIO = VgaStartIO;

#if (_WIN32_WINNT>= 0x0500)

    hwInitData.HwGetVideoChildDescriptor = CirrusGetChildDescriptor;
    hwInitData.HwGetPowerState = CirrusGetPowerState;
    hwInitData.HwSetPowerState = CirrusSetPowerState;

    hwInitData.HwLegacyResourceList = VgaAccessRange;
    hwInitData.HwLegacyResourceCount = 3;

#endif

    //
    // Determine the size we require for the device extension.
    //

    hwInitData.HwDeviceExtensionSize = sizeof(HW_DEVICE_EXTENSION);

    //
    // Always start with parameters for device0 in this case.
    // We can leave it like this since we know we will only ever find one
    // VGA type adapter in a machine.
    //

    // hwInitData.StartingDeviceNumber = 0;

    //
    // Once all the relevant information has been stored, call the video
    // port driver to do the initialization.
    // For this device we will repeat this call three times, for ISA, EISA
    // and PCI.
    // We will return the minimum of all return values.
    //

    //
    // We will try the PCI bus first so that our ISA detection does'nt claim
    // PCI cards (since it is impossible to differentiate between the two
    // by looking at the registers).
    //

    //
    // NOTE: since this driver only supports one adapter, we will return
    // as soon as we find a device, without going on to the following buses.
    // Normally one would call for each bus type and return the smallest
    // value.
    //

    hwInitData.AdapterInterfaceType = PCIBus;

    initializationStatus = VideoPortInitialize(Context1,
                                               Context2,
                                               &hwInitData,
                                               NULL);

    if (initializationStatus == NO_ERROR)
    {
        return initializationStatus;
    }

    hwInitData.AdapterInterfaceType = MicroChannel;

    initializationStatus = VideoPortInitialize(Context1,
                                               Context2,
                                               &hwInitData,
                                               NULL);

    //
    // Return immediately instead of checkin for smallest return code.
    //

    if (initializationStatus == NO_ERROR)
    {
        return initializationStatus;
    }


    hwInitData.AdapterInterfaceType = Isa;

    initializationStatus = VideoPortInitialize(Context1,
                                               Context2,
                                               &hwInitData,
                                               NULL);

    if (initializationStatus == NO_ERROR)
    {
        return initializationStatus;
    }


    hwInitData.AdapterInterfaceType = Eisa;

    initializationStatus = VideoPortInitialize(Context1,
                                               Context2,
                                               &hwInitData,
                                               NULL);

    if (initializationStatus == NO_ERROR)
    {
        return initializationStatus;
    }


    hwInitData.AdapterInterfaceType = Internal;

    status = VideoPortInitialize(Context1,
                                 Context2,
                                 &hwInitData,
                                 NULL);

    if (initializationStatus > status) {
        initializationStatus = status;
    }

    return initializationStatus;

} // end DriverEntry()


//---------------------------------------------------------------------------
VP_STATUS
VgaFindAdapter(
    PVOID HwDeviceExtension,
    PVOID HwContext,
    PWSTR ArgumentString,
    PVIDEO_PORT_CONFIG_INFO ConfigInfo,
    PUCHAR Again
    )

/*++

Routine Description:

    This routine is called to determine if the adapter for this driver
    is present in the system.
    If it is present, the function fills out some information describing
    the adapter.

Arguments:

    HwDeviceExtension - Supplies the miniport driver's adapter storage. This
        storage is initialized to zero before this call.

    HwContext - Supplies the context value which was passed to
        VideoPortInitialize(). Must be NULL for PnP drivers.

    ArgumentString - Supplies a NULL terminated ASCII string. This string
        originates from the user.

    ConfigInfo - Returns the configuration information structure which is
        filled by the miniport driver. This structure is initialized with
        any known configuration information (such as SystemIoBusNumber) by
        the port driver. Where possible, drivers should have one set of
        defaults which do not require any supplied configuration information.

    Again - Indicates if the miniport driver wants the port driver to call
        its VIDEO_HW_FIND_ADAPTER function again with a new device extension
        and the same config info. This is used by the miniport drivers which
        can search for several adapters on a bus.

Return Value:

    This routine must return:

    NO_ERROR - Indicates a host adapter was found and the
        configuration information was successfully determined.

    ERROR_INVALID_PARAMETER - Indicates an adapter was found but there was an
        error obtaining the configuration information. If possible an error
        should be logged.

    ERROR_DEV_NOT_EXIST - Indicates no host adapter was found for the
        supplied configuration information.

--*/

{

    PHW_DEVICE_EXTENSION hwDeviceExtension = HwDeviceExtension;
    VP_STATUS status;
    ULONG NumAccessRanges = NUM_VGA_ACCESS_RANGES;
    ULONG VESATimingBits ;

    VIDEO_ACCESS_RANGE AccessRangesTemp[5];

    //
    // if there are two cirrus cards and the one that is disabled is the second
    // one FindAdapter is called for, then we need to avoid writing to the global
    // VgaAccessRange. So make local copy of it
    //

    VideoPortMoveMemory((PUCHAR) AccessRangesTemp,
                        (PUCHAR) VgaAccessRange,
                        5*sizeof(VIDEO_ACCESS_RANGE));

    //
    // Make sure the size of the structure is at least as large as what we
    // are expecting (check version of the config info structure).
    //

    if (ConfigInfo->Length < sizeof(VIDEO_PORT_CONFIG_INFO)) {

        return ERROR_INVALID_PARAMETER;

    }

    //
    // Store the bus type
    //

    hwDeviceExtension->BusType = ConfigInfo->AdapterInterfaceType;

    //
    // Assign pfnVideoPortReadXxx and pfnVideoPortWriteXxx
    //

    hwDeviceExtension->gPortRWfn.pfnVideoPortReadPortUchar   = VideoPortReadPortUchar   ;
    hwDeviceExtension->gPortRWfn.pfnVideoPortReadPortUshort  = VideoPortReadPortUshort  ;
    hwDeviceExtension->gPortRWfn.pfnVideoPortReadPortUlong   = VideoPortReadPortUlong   ;
    hwDeviceExtension->gPortRWfn.pfnVideoPortWritePortUchar  = VideoPortWritePortUchar  ;
    hwDeviceExtension->gPortRWfn.pfnVideoPortWritePortUshort = VideoPortWritePortUshort ;
    hwDeviceExtension->gPortRWfn.pfnVideoPortWritePortUlong  = VideoPortWritePortUlong  ;

    //
    // Detect the PCI card.
    //

    if (ConfigInfo->AdapterInterfaceType == PCIBus)
    {
        VideoDebugPrint((1, "Cirrus!VgaFindAdapter: "
                            "ConfigInfo->AdapterInterfaceType == PCIBus\n"));//1

        if (!CirrusConfigurePCI(HwDeviceExtension,
                                &NumAccessRanges,
                                AccessRangesTemp))
        {
            VideoDebugPrint((1, "Failure Returned From CirrusConfigurePCI\n"));//1
            return ERROR_DEV_NOT_EXIST;
        }
    }
    else
    {
        VideoDebugPrint((1, "Cirrus!VgaFindAdapter: "
                            "ConfigInfo->AdapterInterfaceType != PCIBus\n"));//1
    }

    //
    // No interrupt information is necessary.
    //

    if (AccessRangesTemp[3].RangeLength == 0)
    {
        //
        // The last access range (range[3]) is the access range for
        // the linear frame buffer.  If this access range has a
        // range length of 0, then some HAL's will fail the request.
        // Therefore, if we are not using the last access range,
        // I'll not try to reserve it.
        //

        NumAccessRanges--;
    }

    //
    // Check to see if there is a hardware resource conflict.
    // (or if card is disabled)
    //

    status = VideoPortVerifyAccessRanges(HwDeviceExtension,
                                         NumAccessRanges,
                                         AccessRangesTemp);

    if (status != NO_ERROR) {

        VideoDebugPrint((1, "ERROR: VPVerifyAccessRanges failed!\n"));

        return status;

    }

    //
    // VideoPortVerifyAccessRanges will fail for a card that is disabled.
    // This card is not disabled.  We can write to the global VgaAccessRange
    //

    VideoPortMoveMemory((PUCHAR) VgaAccessRange,
                        (PUCHAR) AccessRangesTemp,
                        NumAccessRanges*sizeof(VIDEO_ACCESS_RANGE));

    //
    // Get logical IO port addresses.
    //

    if (hwDeviceExtension->bMMAddress)
    {
        if ((hwDeviceExtension->IOAddress =
             VideoPortGetDeviceBase(hwDeviceExtension,
             VgaAccessRange[4].RangeStart,
             VGA_MAX_IO_PORT - VGA_END_BREAK_PORT + 1,
             VgaAccessRange[4].RangeInIoSpace)) == NULL)
        {
            VideoDebugPrint((2, "VgaFindAdapter - Fail to get io address\n"));

            return ERROR_INVALID_PARAMETER;
        }

        hwDeviceExtension->IOAddress -= VGA_END_BREAK_PORT;
    }
    else
    {
        if ((hwDeviceExtension->IOAddress =
             VideoPortGetDeviceBase(hwDeviceExtension,
             VgaAccessRange->RangeStart,
             VGA_MAX_IO_PORT - VGA_BASE_IO_PORT + 1,
             VgaAccessRange->RangeInIoSpace)) == NULL)
        {
            VideoDebugPrint((2, "VgaFindAdapter - Fail to get io address\n"));

            return ERROR_INVALID_PARAMETER;
        }

        hwDeviceExtension->IOAddress -= VGA_BASE_IO_PORT;
    }

    //
    // Determine whether a VGA is present.
    //

    if (!VgaIsPresent(hwDeviceExtension)) {

        VideoDebugPrint((1, "CirrusFindAdapter - VGA Failed\n"));
        return ERROR_DEV_NOT_EXIST;
    }

    //
    // Minimum size of the buffer required to store the hardware state
    // information returned by IOCTL_VIDEO_SAVE_HARDWARE_STATE.
    //

    ConfigInfo->HardwareStateSize = VGA_TOTAL_STATE_SIZE;

    //
    // now that we have the video memory address in protected mode, lets do
    // the required video card initialization. We will try to detect a Cirrus
    // Logic chipset...
    //

    //
    // Determine whether an CL6410/6420/542x/543x is present.
    //

    //
    // CirrusLogicIsPresent may set up the
    // hwDeviceExtesion->AdapterMemorySize field.  Set it
    // to 0 now, so I can compare against this later to
    // see if CirrusLogicIsPresent assigned a value.
    //

    hwDeviceExtension->AdapterMemorySize = 0;

    if (!CirrusLogicIsPresent(hwDeviceExtension))
    {
        VideoDebugPrint((1, "CirrusFindAdapter - Failed\n"));
        return ERROR_DEV_NOT_EXIST;
    }

    //
    // Pass a pointer to the emulator range we are using.
    //

    ConfigInfo->NumEmulatorAccessEntries = VGA_NUM_EMULATOR_ACCESS_ENTRIES;
    ConfigInfo->EmulatorAccessEntries = VgaEmulatorAccessEntries;
    ConfigInfo->EmulatorAccessEntriesContext = (ULONG_PTR) hwDeviceExtension;

    //
    // There is really no reason to have the frame buffer mapped. On an
    // x86 we use if for save/restore (supposedly) but even then we
    // would only need to map a 64K window, not all 16 Meg!
    //

#ifdef _X86_

    //
    // Map the video memory into the system virtual address space so we can
    // clear it out and use it for save and restore.
    //

    if ( (hwDeviceExtension->VideoMemoryAddress =
              VideoPortGetDeviceBase(hwDeviceExtension,
                                     VgaAccessRange[2].RangeStart,
                                     VgaAccessRange[2].RangeLength,
                                     FALSE)) == NULL)
    {
        VideoDebugPrint((1, "VgaFindAdapter - Fail to get memory address\n"));

        return ERROR_INVALID_PARAMETER;
    }

#endif

    //
    // Size the memory
    //

    //
    // The size may have been set up in detection code, so
    // don't destroy if already set.
    //

    if( hwDeviceExtension->AdapterMemorySize == 0 )
    {
        hwDeviceExtension->AdapterMemorySize =
            CirrusFindVmemSize(hwDeviceExtension);
    }

    //
    // Write hardware info into registry
    //

    WriteRegistryInfo(hwDeviceExtension);

    ConfigInfo->VdmPhysicalVideoMemoryAddress.LowPart = MEM_VGA;
    ConfigInfo->VdmPhysicalVideoMemoryLength = MEM_VGA_SIZE;
    ConfigInfo->VdmPhysicalVideoMemoryAddress.HighPart = 0x00000000;


#if 0
// removed the following call. This fixes MS bug #163251
//#if DDC2B

    //
    // Check DDC2B monitor, get EDID table.
    // Turn on/off extended modes according the properties of the monitor.
    //

    // The miniport takes forever to load doing DDC on an
    // ISA 5434 in a DELL XPS P120c.
    // (IDEKIyama Vision Master 17 Monitor).
    //
    // Let only try to get DDC info on PCI cards for now.
    // CIRRUS - Can you fix this?

    if (ConfigInfo->AdapterInterfaceType == PCIBus) {
        ReadVESATiming ( hwDeviceExtension ) ;
    }

#endif

    //
    // Determines which modes are valid.
    //


#if DDC2B

    CirrusValidateModes(hwDeviceExtension);

#endif


#if (_WIN32_WINNT <= 0x0400)
    CheckAndUpdateDDC2BMonitor(hwDeviceExtension);
#endif (_WIN32_WINNT <= 0x0400)

    if (hwDeviceExtension->NumAvailableModes == 0)
    {
        VideoDebugPrint((1, "FindAdapter failed because there are no"
                            "available modes.\n"));

        return ERROR_INVALID_PARAMETER;
    }

    //
    // Fix the 5446Ac and 440FX core logic coexist bug.
    //

    if (hwDeviceExtension->ChipType == CL5446)
    {
        CirrusUpdate440FX(hwDeviceExtension);
    }

    //
    // Once modes are validated, all 543x's are the same (the number
    // of modes available is the only difference).
    //

#if 0
//myf31: for RadiSYS special driver, change MCLK to 66MHz
    if (hwDeviceExtension->ChipType == CL7555)
    {
        VideoPortWritePortUchar(hwDeviceExtension->IOAddress +
                        SEQ_ADDRESS_PORT, 0x1F);
        SR1F = VideoPortReadPortUchar(hwDeviceExtension->IOAddress +
                        SEQ_DATA_PORT) & 0xC0;
        VideoPortWritePortUchar(hwDeviceExtension->IOAddress +
                        SEQ_DATA_PORT, (SR1F | 0x25));
    }
//myf31 end
#endif


    if ((hwDeviceExtension->ChipType == CL5434) ||
        (hwDeviceExtension->ChipType == CL5434_6) ||
        (hwDeviceExtension->ChipType == CL5436) ||
        (hwDeviceExtension->ChipType == CL5446) ||
        (hwDeviceExtension->ChipType == CL5446BE) ||
        (hwDeviceExtension->ChipType == CL5480))

    {
        hwDeviceExtension->ChipType = CL543x;
    }

    //
    // Indicate we do not wish to be called again for another initialization.
    //

    *Again = 0;

    //
    // Indicate a successful completion status.
    //

    return NO_ERROR;

}


//---------------------------------------------------------------------------
BOOLEAN
VgaInitialize(
    PVOID HwDeviceExtension
    )

/*++

Routine Description:

    This routine does one time initialization of the device.

Arguments:

    HwDeviceExtension - Pointer to the miniport driver's adapter information.

Return Value:

    None.

--*/

{
    VP_STATUS status;
    VIDEO_X86_BIOS_ARGUMENTS biosArguments;

    PHW_DEVICE_EXTENSION hwDeviceExtension = HwDeviceExtension;

    //
    // Get the BIOS version number.
    //

    VideoPortZeroMemory(&biosArguments, sizeof(VIDEO_X86_BIOS_ARGUMENTS));

    biosArguments.Eax = 0x1200;
    biosArguments.Ebx = 0x81;

    status = VideoPortInt10(HwDeviceExtension, &biosArguments);

    if (status == NO_ERROR)
    {
        hwDeviceExtension->ulBIOSVersionNumber = biosArguments.Eax;
    }
    else
        hwDeviceExtension->ulBIOSVersionNumber = 0;

    hwDeviceExtension->bBlockSwitch = 0;

    biosArguments.Eax = 0x1200;
    biosArguments.Ebx = 0x9A;

    status = VideoPortInt10(HwDeviceExtension, &biosArguments);
    hwDeviceExtension->bDisplaytype = CRT_type;

    if (status == NO_ERROR)
    {
        if (!(biosArguments.Eax & 0x0100))
            hwDeviceExtension->bDisplaytype = LCD_type;
        else if (!(biosArguments.Ebx & 0x0200))
            hwDeviceExtension->bDisplaytype = SIM_type;
    }

    VideoPortZeroMemory(&biosArguments, sizeof(VIDEO_X86_BIOS_ARGUMENTS));

    biosArguments.Eax = VESA_POWER_FUNCTION;
    biosArguments.Ebx = VESA_GET_POWER_FUNC;

    status = VideoPortInt10(HwDeviceExtension, &biosArguments);

    if ((status == NO_ERROR) &&
       ((biosArguments.Eax & 0xffff) == VESA_STATUS_SUCCESS))
    {
       hwDeviceExtension->PMCapability = biosArguments.Ebx;
    }
    else
    {
       hwDeviceExtension->PMCapability = 0;
    }

    //
    // set up the default cursor position and type.
    //

    hwDeviceExtension->CursorPosition.Column = 0;
    hwDeviceExtension->CursorPosition.Row = 0;
    hwDeviceExtension->CursorTopScanLine = 0;
    hwDeviceExtension->CursorBottomScanLine = 31;
    hwDeviceExtension->CursorEnable = TRUE;

    return TRUE;

}


//---------------------------------------------------------------------------
BOOLEAN
VgaStartIO(
    PVOID pHwDeviceExtension,
    PVIDEO_REQUEST_PACKET RequestPacket
    )

/*++

Routine Description:

    This routine is the main execution routine for the miniport driver. It
    accepts a Video Request Packet, performs the request, and then returns
    with the appropriate status.

Arguments:

    HwDeviceExtension - Pointer to the miniport driver's adapter information.

    RequestPacket - Pointer to the video request packet. This structure
        contains all the parameters passed to the VideoIoControl function.

Return Value:

    This routine will return error codes from the various support routines
    and will also return ERROR_INSUFFICIENT_BUFFER for incorrectly sized
    buffers and ERROR_INVALID_FUNCTION for unsupported functions.

--*/

{
    PHW_DEVICE_EXTENSION hwDeviceExtension = pHwDeviceExtension;
    PHW_DEVICE_EXTENSION HwDeviceExtension = pHwDeviceExtension;
    VP_STATUS status;
    VIDEO_MODE videoMode;
    PVIDEO_MEMORY_INFORMATION memoryInformation;
    ULONG inIoSpace;
    ULONG physicalFrameLength;

    PVIDEO_SHARE_MEMORY pShareMemory;
    PVIDEO_SHARE_MEMORY_INFORMATION pShareMemoryInformation;
    PHYSICAL_ADDRESS shareAddress;
    PVOID virtualAddress;
    ULONG sharedViewSize;
    UCHAR SR0A;


    //
    // Switch on the IoContolCode in the RequestPacket. It indicates which
    // function must be performed by the driver.
    //

    switch (RequestPacket->IoControlCode)
    {
    case IOCTL_VIDEO_SHARE_VIDEO_MEMORY:

        VideoDebugPrint((2, "VgaStartIO - ShareVideoMemory\n"));

        if ((RequestPacket->OutputBufferLength < sizeof(VIDEO_SHARE_MEMORY_INFORMATION)) ||
            (RequestPacket->InputBufferLength < sizeof(VIDEO_MEMORY)) )
        {
            VideoDebugPrint((1, "VgaStartIO - ShareVideoMemory - ERROR_INSUFFICIENT_BUFFER\n"));
            status = ERROR_INSUFFICIENT_BUFFER;
            break;
        }

        pShareMemory = RequestPacket->InputBuffer;

        RequestPacket->StatusBlock->Information =
                            sizeof(VIDEO_SHARE_MEMORY_INFORMATION);

        //
        // Beware: the input buffer and the output buffer are the same
        // buffer, and therefore data should not be copied from one to the
        // other
        //

        virtualAddress = pShareMemory->ProcessHandle;
        sharedViewSize = pShareMemory->ViewSize;

        //
        // If you change to using a dense space frame buffer, make this
        // value a 4 for the ALPHA.
        //

        inIoSpace = 0;

        //
        // NOTE: we are ignoring ViewOffset
        //

        shareAddress.QuadPart =
            hwDeviceExtension->PhysicalFrameOffset.QuadPart +
            hwDeviceExtension->PhysicalVideoMemoryBase.QuadPart;

        if (hwDeviceExtension->LinearMode)
        {
            //
            // Add P6CACHE support
            //

#if P6CACHE
#if (_WIN32_WINNT >= 0x0400)
            inIoSpace |= VIDEO_MEMORY_SPACE_P6CACHE;
#endif
#endif

            status = VideoPortMapMemory(hwDeviceExtension,
                                        shareAddress,
                                        &sharedViewSize,
                                        &inIoSpace,
                                        &virtualAddress);
        }
        else
        {
            ULONG ulBankSize;
            VOID (*pfnBank)(ULONG,ULONG,PVOID);

            switch (hwDeviceExtension->ChipType) {

                case CL542x: pfnBank = vBankMap_CL542x;
                             break;

                case CL543x: pfnBank = vBankMap_CL543x;
                             break;

                default:     pfnBank = vBankMap_CL64xx;
                             break;

            };

            #if ONE_64K_BANK
            //
            // The Cirrus Logic VGA's support one 64K read/write bank.
            //

                ulBankSize = 0x10000; // 64K bank start adjustment
            #endif
            #if TWO_32K_BANKS
            //
            // The Cirrus Logic VGA's support two 32K read/write banks.
            //

                ulBankSize = 0x8000; // 32K bank start adjustment
            #endif

            status = VideoPortMapBankedMemory(hwDeviceExtension,
                                       shareAddress,
                                       &sharedViewSize,
                                       &inIoSpace,
                                       &virtualAddress,
                                       ulBankSize,
                                       FALSE,
                                       pfnBank,
                                       (PVOID)hwDeviceExtension);
        }

        pShareMemoryInformation = RequestPacket->OutputBuffer;

        pShareMemoryInformation->SharedViewOffset = pShareMemory->ViewOffset;
        pShareMemoryInformation->VirtualAddress = virtualAddress;
        pShareMemoryInformation->SharedViewSize = sharedViewSize;

        break;

    case IOCTL_VIDEO_UNSHARE_VIDEO_MEMORY:

        VideoDebugPrint((2, "VgaStartIO - UnshareVideoMemory\n"));

        if (RequestPacket->InputBufferLength < sizeof(VIDEO_SHARE_MEMORY)) {

            status = ERROR_INSUFFICIENT_BUFFER;
                    break;

        }

        pShareMemory = RequestPacket->InputBuffer;

        status = VideoPortUnmapMemory(hwDeviceExtension,
                                      pShareMemory->RequestedVirtualAddress,
                                      pShareMemory->ProcessHandle);

        break;


    case IOCTL_VIDEO_MAP_VIDEO_MEMORY:

        VideoDebugPrint((2, "VgaStartIO - MapVideoMemory\n"));

        if ((RequestPacket->OutputBufferLength <
             (RequestPacket->StatusBlock->Information =
                          sizeof(VIDEO_MEMORY_INFORMATION))) ||
             (RequestPacket->InputBufferLength < sizeof(VIDEO_MEMORY)) )
        {
            status = ERROR_INSUFFICIENT_BUFFER;
        }

        memoryInformation = RequestPacket->OutputBuffer;

        memoryInformation->VideoRamBase = ((PVIDEO_MEMORY)
              (RequestPacket->InputBuffer))->RequestedVirtualAddress;

        //
        // We reserved 16 meg for the frame buffer, however, it makes
        // no sense to map more memory than there is on the card.  So
        // only map the amount of memory we have on the card.
        //

        memoryInformation->VideoRamLength =
                hwDeviceExtension->AdapterMemorySize;

        //
        // If you change to using a dense space frame buffer, make this
        // value a 4 for the ALPHA.
        //

        inIoSpace = 0;

        //
        // Add P6CACHE support
        //

        physicalFrameLength = hwDeviceExtension->PhysicalVideoMemoryLength;

#if P6CACHE
#if (_WIN32_WINNT >= 0x0400)

        // 
        // We saw corrupted screen in 16 color mode on 54M40 if P6CAHCHE 
        // is enabled. We only turn on P6CACHE when we see two access 
        // ranges (so that we know this request is from cirrus.dll but
        // not from vga.dll)
        //

        if (RequestPacket->OutputBufferLength >=     // if we have room for
            sizeof(VIDEO_MEMORY_INFORMATION) * 2)    // another access range
        {


            inIoSpace |= VIDEO_MEMORY_SPACE_P6CACHE;

            if ( physicalFrameLength < 0x00400000)
            {
                 physicalFrameLength = 0x00400000;
            }
        }
#endif
#endif

        status = VideoPortMapMemory(hwDeviceExtension,
                                    hwDeviceExtension->PhysicalVideoMemoryBase,
                                    &physicalFrameLength,
                                    &inIoSpace,
                                    &(memoryInformation->VideoRamBase));

        if (status != NO_ERROR) {
            VideoDebugPrint((1, "VgaStartIO - IOCTL_VIDEO_MAP_VIDEO_MEMORY failed VideoPortMapMemory (%x)\n", status));
            break;
        }

        memoryInformation->FrameBufferBase =
            ((PUCHAR) (memoryInformation->VideoRamBase)) +
            hwDeviceExtension->PhysicalFrameOffset.LowPart;

        memoryInformation->FrameBufferLength =
            hwDeviceExtension->PhysicalFrameLength ?
            hwDeviceExtension->PhysicalFrameLength :
            memoryInformation->VideoRamLength;

        VideoDebugPrint((2, "physical VideoMemoryBase %08lx\n", hwDeviceExtension->PhysicalVideoMemoryBase));
        VideoDebugPrint((2, "physical VideoMemoryLength %08lx\n", hwDeviceExtension->PhysicalVideoMemoryLength));
        VideoDebugPrint((2, "VideoMemoryBase %08lx\n", memoryInformation->VideoRamBase));
        VideoDebugPrint((2, "VideoMemoryLength %08lx\n", memoryInformation->VideoRamLength));

        VideoDebugPrint((2, "physical framebuf offset %08lx\n", hwDeviceExtension->PhysicalFrameOffset.LowPart));
        VideoDebugPrint((2, "framebuf base %08lx\n", memoryInformation->FrameBufferBase));
        VideoDebugPrint((2, "physical framebuf len %08lx\n", hwDeviceExtension->PhysicalFrameLength));
        VideoDebugPrint((2, "framebuf length %08lx\n", memoryInformation->FrameBufferLength));

        //
        // add address mapping for system to screen blt
        //

        if (RequestPacket->OutputBufferLength >=     // if we have room for
            sizeof(VIDEO_MEMORY_INFORMATION) * 2)    // another access range
        {
            RequestPacket->StatusBlock->Information =
                sizeof(VIDEO_MEMORY_INFORMATION) * 2;

            memoryInformation++;
            memoryInformation->VideoRamBase = (PVOID)NULL;

            if (hwDeviceExtension->bSecondAperture)
            {
                //
                // We reserved 16 meg for the frame buffer, however, it makes
                // no sense to map more memory than there is on the card.  So
                // only map the amount of memory we have on the card.
                //

                memoryInformation->VideoRamLength =
                    hwDeviceExtension->AdapterMemorySize;

                //
                // If you change to using a dense space frame buffer, make this
                // value a 4 for the ALPHA.
                //

                inIoSpace = 0;

                //
                // Add P6CACHE support
                //

#if P6CACHE
#if (_WIN32_WINNT >= 0x0400)
                inIoSpace |= VIDEO_MEMORY_SPACE_P6CACHE;
#endif
#endif
                shareAddress.QuadPart =
                    hwDeviceExtension->PhysicalVideoMemoryBase.QuadPart +
                    0x1000000;      // add 16M offset

                status = VideoPortMapMemory(hwDeviceExtension,
                                            shareAddress,
                                            &physicalFrameLength,
                                            &inIoSpace,
                                            &(memoryInformation->VideoRamBase));

                if (status != NO_ERROR)
                {
                    VideoDebugPrint((1, "VgaStartIO - IOCTL_VIDEO_MAP_VIDEO_MEMORY failed for system to screen blt mapping (%x)\n", status));
                }

            }
        }

        break;

    case IOCTL_VIDEO_UNMAP_VIDEO_MEMORY:

        VideoDebugPrint((2, "VgaStartIO - UnMapVideoMemory\n"));

        if (RequestPacket->InputBufferLength < sizeof(VIDEO_MEMORY))
        {
            status = ERROR_INSUFFICIENT_BUFFER;
        }

        status = VideoPortUnmapMemory(hwDeviceExtension,
                                      ((PVIDEO_MEMORY)
                                       (RequestPacket->InputBuffer))->
                                           RequestedVirtualAddress,
                                      0);

        break;


    case IOCTL_VIDEO_QUERY_AVAIL_MODES:

        VideoDebugPrint((2, "VgaStartIO - QueryAvailableModes\n"));

        RequestPacket->StatusBlock->Information = 0;
        status = VgaQueryAvailableModes(HwDeviceExtension,
                                        (PVIDEO_MODE_INFORMATION)
                                            RequestPacket->OutputBuffer,
                                        RequestPacket->OutputBufferLength,
                                        (PULONG)&RequestPacket->StatusBlock->Information);

        break;


    case IOCTL_VIDEO_QUERY_NUM_AVAIL_MODES:

        VideoDebugPrint((2, "VgaStartIO - QueryNumAvailableModes\n"));

        RequestPacket->StatusBlock->Information = 0;
        status = VgaQueryNumberOfAvailableModes(HwDeviceExtension,
                                                (PVIDEO_NUM_MODES)
                                                    RequestPacket->OutputBuffer,
                                                RequestPacket->OutputBufferLength,
                                                (PULONG)&RequestPacket->StatusBlock->Information);

        break;


    case IOCTL_VIDEO_QUERY_CURRENT_MODE:

        VideoDebugPrint((2, "VgaStartIO - QueryCurrentMode\n"));

        RequestPacket->StatusBlock->Information = 0;
        status = VgaQueryCurrentMode(HwDeviceExtension,
                                     (PVIDEO_MODE_INFORMATION) RequestPacket->OutputBuffer,
                                     RequestPacket->OutputBufferLength,
                                     (PULONG)&RequestPacket->StatusBlock->Information);

        break;


    case IOCTL_VIDEO_SET_CURRENT_MODE:

        VideoDebugPrint((2, "VgaStartIO - SetCurrentModes\n"));

        status = VgaSetMode(HwDeviceExtension,
                              (PVIDEO_MODE) RequestPacket->InputBuffer,
                              RequestPacket->InputBufferLength);

        break;


    case IOCTL_VIDEO_RESET_DEVICE:

        VideoDebugPrint((2, "VgaStartIO - Reset Device\n"));

        videoMode.RequestedMode = DEFAULT_MODE;

        VgaSetMode(HwDeviceExtension,
                        (PVIDEO_MODE) &videoMode,
                        sizeof(videoMode));

        //
        // Always return succcess since settings the text mode will fail on
        // non-x86.
        //
        // Also, failiure to set the text mode is not fatal in any way, since
        // this operation must be followed by another set mode operation.
        //

        status = NO_ERROR;

        break;


    case IOCTL_VIDEO_LOAD_AND_SET_FONT:

        VideoDebugPrint((2, "VgaStartIO - LoadAndSetFont\n"));

        status = VgaLoadAndSetFont(HwDeviceExtension,
                                   (PVIDEO_LOAD_FONT_INFORMATION) RequestPacket->InputBuffer,
                                   RequestPacket->InputBufferLength);

        break;


    case IOCTL_VIDEO_QUERY_CURSOR_POSITION:

        VideoDebugPrint((2, "VgaStartIO - QueryCursorPosition\n"));

        RequestPacket->StatusBlock->Information = 0;
        status = VgaQueryCursorPosition(HwDeviceExtension,
                                        (PVIDEO_CURSOR_POSITION) RequestPacket->OutputBuffer,
                                        RequestPacket->OutputBufferLength,
                                        (PULONG)&RequestPacket->StatusBlock->Information);

        break;


    case IOCTL_VIDEO_SET_CURSOR_POSITION:

        VideoDebugPrint((2, "VgaStartIO - SetCursorPosition\n"));

        status = VgaSetCursorPosition(HwDeviceExtension,
                                      (PVIDEO_CURSOR_POSITION)
                                          RequestPacket->InputBuffer,
                                      RequestPacket->InputBufferLength);

        break;


    case IOCTL_VIDEO_QUERY_CURSOR_ATTR:

        VideoDebugPrint((2, "VgaStartIO - QueryCursorAttributes\n"));

        RequestPacket->StatusBlock->Information = 0;
        status = VgaQueryCursorAttributes(HwDeviceExtension,
                                          (PVIDEO_CURSOR_ATTRIBUTES) RequestPacket->OutputBuffer,
                                          RequestPacket->OutputBufferLength,
                                          (PULONG)&RequestPacket->StatusBlock->Information);

        break;


    case IOCTL_VIDEO_SET_CURSOR_ATTR:

        VideoDebugPrint((2, "VgaStartIO - SetCursorAttributes\n"));

        status = VgaSetCursorAttributes(HwDeviceExtension,
                                        (PVIDEO_CURSOR_ATTRIBUTES) RequestPacket->InputBuffer,
                                        RequestPacket->InputBufferLength);

        break;


    case IOCTL_VIDEO_SET_PALETTE_REGISTERS:

        VideoDebugPrint((2, "VgaStartIO - SetPaletteRegs\n"));

        status = VgaSetPaletteReg(HwDeviceExtension,
                                  (PVIDEO_PALETTE_DATA) RequestPacket->InputBuffer,
                                  RequestPacket->InputBufferLength);

        break;


    case IOCTL_VIDEO_SET_COLOR_REGISTERS:

        VideoDebugPrint((2, "VgaStartIO - SetColorRegs\n"));

        status = VgaSetColorLookup(HwDeviceExtension,
                                   (PVIDEO_CLUT) RequestPacket->InputBuffer,
                                   RequestPacket->InputBufferLength);

        break;


    case IOCTL_VIDEO_ENABLE_VDM:

        VideoDebugPrint((2, "VgaStartIO - EnableVDM\n"));

        hwDeviceExtension->TrappedValidatorCount = 0;
        hwDeviceExtension->SequencerAddressValue = 0;

        hwDeviceExtension->CurrentNumVdmAccessRanges =
            NUM_MINIMAL_VGA_VALIDATOR_ACCESS_RANGE;
        hwDeviceExtension->CurrentVdmAccessRange =
            MinimalVgaValidatorAccessRange;

        VideoPortSetTrappedEmulatorPorts(hwDeviceExtension,
                                         hwDeviceExtension->CurrentNumVdmAccessRanges,
                                         hwDeviceExtension->CurrentVdmAccessRange);

        status = NO_ERROR;

        break;


    case IOCTL_VIDEO_RESTORE_HARDWARE_STATE:

        VideoDebugPrint((2, "VgaStartIO - RestoreHardwareState\n"));

        try {

            status = VgaRestoreHardwareState(HwDeviceExtension,
                                             (PVIDEO_HARDWARE_STATE) RequestPacket->InputBuffer,
                                             RequestPacket->InputBufferLength);
        } except (1) {
	
            status = ERROR_INVALID_PARAMETER;
        }

        break;


    case IOCTL_VIDEO_SAVE_HARDWARE_STATE:

        VideoDebugPrint((2, "VgaStartIO - SaveHardwareState\n"));

        try {

            RequestPacket->StatusBlock->Information = 0;
            status = VgaSaveHardwareState(HwDeviceExtension,
                                          (PVIDEO_HARDWARE_STATE) RequestPacket->OutputBuffer,
                                          RequestPacket->OutputBufferLength,
                                          (PULONG)&RequestPacket->StatusBlock->Information);
        } except (1) {
	
            status = ERROR_INVALID_PARAMETER;
        }

        break;

    case IOCTL_VIDEO_GET_BANK_SELECT_CODE:

        VideoDebugPrint((2, "VgaStartIO - GetBankSelectCode\n"));

        RequestPacket->StatusBlock->Information = 0;
        status = VgaGetBankSelectCode(HwDeviceExtension,
                                        (PVIDEO_BANK_SELECT) RequestPacket->OutputBuffer,
                                        RequestPacket->OutputBufferLength,
                                        (PULONG)&RequestPacket->StatusBlock->Information);

        VideoDebugPrint((2, "VgaStartIO - END GetBankSelectCode\n"));
        break;

    case IOCTL_VIDEO_QUERY_PUBLIC_ACCESS_RANGES:

        {
            PVIDEO_PUBLIC_ACCESS_RANGES portAccess;
            PHYSICAL_ADDRESS physicalPortAddress;
            ULONG physicalPortLength;

            if (RequestPacket->OutputBufferLength <
                sizeof(VIDEO_PUBLIC_ACCESS_RANGES))
            {
                status = ERROR_INSUFFICIENT_BUFFER;
                break;
            }

            RequestPacket->StatusBlock->Information =
                sizeof(VIDEO_PUBLIC_ACCESS_RANGES);

            portAccess = RequestPacket->OutputBuffer;

            //
            // The first public access range is the IO ports.
            //

            //
            // On the alpha, VGA.DLL will call into the cirrus miniport
            // trying to get a pointer to the IO ports.  So, we can never
            // return MMIO to the VGA driver.  We'll assume that if the
            // size of the OutputBuffer is only big enough for one access
            // range then the VGA driver is asking for the ranges, and
            // thus we should map them as IO space.
            //

            if ((hwDeviceExtension->bMMAddress) &&
                (RequestPacket->OutputBufferLength >=
                 sizeof(VIDEO_PUBLIC_ACCESS_RANGES) * 2))
            {
                // PC97 Compliant
                portAccess->VirtualAddress  = (PVOID) NULL;
                portAccess->InIoSpace       = FALSE;
                portAccess->MappedInIoSpace = portAccess->InIoSpace;
                // for VGA register
                physicalPortLength = VGA_MAX_IO_PORT - VGA_END_BREAK_PORT + 1;

                status =  VideoPortMapMemory(hwDeviceExtension,
                                             VgaAccessRange[4].RangeStart,
                                             &physicalPortLength,
                                             &(portAccess->MappedInIoSpace),
                                             &(portAccess->VirtualAddress));

                (PUCHAR)portAccess->VirtualAddress -= VGA_END_BREAK_PORT;
                VideoDebugPrint((1, "VgaStartIO - memory mapping to (%x)\n", portAccess->VirtualAddress));

                if (status == NO_ERROR)
                {
                    RequestPacket->StatusBlock->Information =
                        sizeof(VIDEO_PUBLIC_ACCESS_RANGES) * 2;

                    portAccess++;

                    //
                    // map a region for memory mapped IO
                    //

                    portAccess->VirtualAddress  = (PVOID) NULL;    // Requested VA
                    portAccess->InIoSpace       = FALSE;
                    portAccess->MappedInIoSpace = portAccess->InIoSpace;
                    // MMIO register
                    physicalPortAddress = VgaAccessRange[4].RangeStart;
                    physicalPortAddress.QuadPart += RELOCATABLE_MEMORY_MAPPED_IO_OFFSET;
                    physicalPortLength = 0x100;

                    status = VideoPortMapMemory(hwDeviceExtension,
                                                physicalPortAddress,
                                                &physicalPortLength,
                                                &(portAccess->MappedInIoSpace),
                                                &(portAccess->VirtualAddress));

                    VideoDebugPrint((1, "The base MMIO address is: %x\n",
                                        portAccess->VirtualAddress));
                }
            }
            else
            {
                portAccess->VirtualAddress  = (PVOID) NULL;
                portAccess->InIoSpace       = TRUE;
                portAccess->MappedInIoSpace = portAccess->InIoSpace;
                physicalPortLength = VGA_MAX_IO_PORT - VGA_BASE_IO_PORT + 1;

                status =  VideoPortMapMemory(hwDeviceExtension,
                                             VgaAccessRange->RangeStart,
                                             &physicalPortLength,
                                             &(portAccess->MappedInIoSpace),
                                             &(portAccess->VirtualAddress));

                (PUCHAR)portAccess->VirtualAddress -= VGA_BASE_IO_PORT;
                VideoDebugPrint((1, "VgaStartIO - mapping ports to (%x)\n", portAccess->VirtualAddress));

                if ((status == NO_ERROR) &&
                    (RequestPacket->OutputBufferLength >=     // if we have room for
                     sizeof(VIDEO_PUBLIC_ACCESS_RANGES) * 2)) // another access range
                {
                    RequestPacket->StatusBlock->Information =
                        sizeof(VIDEO_PUBLIC_ACCESS_RANGES) * 2;

                    portAccess++;

                    //
                    // If we are running on a chip which supports Memory Mapped
                    // IO, then return a pointer to the MMIO Ports.  Otherwise,
                    // return zero to indicate we do not support memory mapped IO.
                    //

                    if (((hwDeviceExtension->ChipType == CL543x) ||
                        (hwDeviceExtension->ChipType &  CL755x)) &&  //myf15
                        (hwDeviceExtension->BusType != Isa) &&
                        (VideoPortGetDeviceData(hwDeviceExtension,
                                                VpMachineData,
                                                &CirrusGetDeviceDataCallback,
                                                NULL) != NO_ERROR))

                    {
                        //
                        // map a region for memory mapped IO
                        //
                        // memory mapped IO is located in physical addresses B8000
                        // to BFFFF, but we will only touch the first 256 bytes.
                        //

                        portAccess->VirtualAddress  = (PVOID) NULL;    // Requested VA
                        portAccess->InIoSpace       = FALSE;
                        portAccess->MappedInIoSpace = portAccess->InIoSpace;

                        physicalPortAddress = VgaAccessRange[2].RangeStart;
                        physicalPortAddress.QuadPart += MEMORY_MAPPED_IO_OFFSET;

                        physicalPortLength = 0x100;

                        status = VideoPortMapMemory(hwDeviceExtension,
                                                    physicalPortAddress,
                                                    &physicalPortLength,
                                                    &(portAccess->MappedInIoSpace),
                                                    &(portAccess->VirtualAddress));

                        VideoDebugPrint((1, "The base MMIO address is: %x\n",
                                            portAccess->VirtualAddress));
                    }
                    else
                    {
                        portAccess->VirtualAddress = 0;
                    }

                }
            }
        }

        break;

    case IOCTL_VIDEO_FREE_PUBLIC_ACCESS_RANGES:

        if (RequestPacket->InputBufferLength < sizeof(VIDEO_MEMORY))
        {
            status = ERROR_INSUFFICIENT_BUFFER;
            break;
        }

        //
        // We decrement VGA_BASE_IO_PORT before we hand this out,
        // so we should increment before we try to free it.
        //

        (PUCHAR)((PVIDEO_MEMORY)RequestPacket->InputBuffer)->
            RequestedVirtualAddress += VGA_BASE_IO_PORT;

        status = VideoPortUnmapMemory(hwDeviceExtension,
                                      ((PVIDEO_MEMORY)
                                      (RequestPacket->InputBuffer))->
                                          RequestedVirtualAddress,
                                      0);

        break;


    case IOCTL_CIRRUS_GET_GAMMA_FACTOR:

        VideoDebugPrint((2, "VgaStartIO - GetGammaFactor\n"));

        RequestPacket->StatusBlock->Information = 0;
        status = VgaGetGammaFactor(hwDeviceExtension,
                                   (PGAMMA_VALUE) RequestPacket->OutputBuffer,
                                   RequestPacket->OutputBufferLength,
                                   (PULONG)&RequestPacket->StatusBlock->Information);
        break ;

    case IOCTL_CIRRUS_GET_CONTRAST_FACTOR:

        VideoDebugPrint((2, "VgaStartIO - GetContrastFactor\n"));

        RequestPacket->StatusBlock->Information = 0;
        status = VgaGetContrastFactor(hwDeviceExtension,
                                   (PCONTRAST_VALUE) RequestPacket->OutputBuffer,
                                   RequestPacket->OutputBufferLength,
                                   (PULONG)&RequestPacket->StatusBlock->Information);
        break ;

     case IOCTL_CIRRUS_GET_CAPABILITIES:

        VideoDebugPrint((2, "VgaStartIO - CirrusGetCapabilities\n"));

        RequestPacket->StatusBlock->Information = 0;
        status = VgaQueryAvailableModes(HwDeviceExtension,
                                        (PVIDEO_MODE_INFORMATION)
                                            RequestPacket->OutputBuffer,
                                        RequestPacket->OutputBufferLength,
                                        (PULONG)&RequestPacket->StatusBlock->Information);

        break;

     case IOCTL_CIRRUS_SET_DISPLAY_PITCH:

        VideoDebugPrint((2, "VgaStartIO - CirrusSetDisplayPitch\n"));

        status = VgaSetMode(HwDeviceExtension,
                              (PVIDEO_MODE) RequestPacket->InputBuffer,
                              RequestPacket->InputBufferLength);
        break;


    //
    // if we get here, an invalid IoControlCode was specified.
    //

    default:

        VideoDebugPrint((1, "Fell through vga startIO routine - invalid command\n"));

        status = ERROR_INVALID_FUNCTION;

        break;

    }

    RequestPacket->StatusBlock->Status = status;

    return TRUE;

}


//---------------------------------------------------------------------------
VOID
CirrusHwTimer(
    PVOID pHwDeviceExtension
    )

/*++

Routine Description:

    This routine is the main execution routine for the miniport driver. It
    accepts a Video Request Packet, performs the request, and then returns
    with the appropriate status.

Arguments:

    HwDeviceExtension - Pointer to the miniport driver's HwVidTimer
    information.

Return Value:

    This routine will return error codes from the various support routines
    and will also return ERROR_INSUFFICIENT_BUFFER for incorrectly sized
    buffers and ERROR_INVALID_FUNCTION for unsupported functions.

--*/

{
    PHW_DEVICE_EXTENSION hwDeviceExtension = pHwDeviceExtension;
    PHW_DEVICE_EXTENSION HwDeviceExtension = pHwDeviceExtension;
    VIDEO_MODE videoMode;
    UCHAR   SR0A, SR14, savSEQidx, savCRTidx, lcd;
    SHORT   Displaytype;
    ULONG   ulCRTCAddress, ulCRTCData;



    if (VideoPortReadPortUchar(hwDeviceExtension->IOAddress +
                               MISC_OUTPUT_REG_READ_PORT) & 0x01)
    {
        ulCRTCAddress = CRTC_ADDRESS_PORT_COLOR;
        ulCRTCData    = CRTC_DATA_PORT_COLOR;
    }
    else
    {
        ulCRTCAddress = CRTC_ADDRESS_PORT_MONO;
        ulCRTCData    = CRTC_DATA_PORT_MONO;
    }

    if (!(hwDeviceExtension->bBlockSwitch))            //not block switch
    {
        savSEQidx = VideoPortReadPortUchar(hwDeviceExtension->IOAddress +
                             SEQ_ADDRESS_PORT);
        VideoPortWritePortUchar(hwDeviceExtension->IOAddress +
                             SEQ_ADDRESS_PORT, 0x14);
        SR14 = VideoPortReadPortUchar(hwDeviceExtension->IOAddress +
                             SEQ_DATA_PORT);
        VideoPortWritePortUchar(hwDeviceExtension->IOAddress +
                             SEQ_DATA_PORT, (UCHAR)(SR14 | 0x04));

        VideoPortWritePortUchar(hwDeviceExtension->IOAddress +
                             SEQ_ADDRESS_PORT, 0x0A);
        SR0A = VideoPortReadPortUchar(hwDeviceExtension->IOAddress +
                             SEQ_DATA_PORT);

        Displaytype = ((SR14 & 0x02) | (SR0A & 0x01));
        if (Displaytype == 0)
            Displaytype = LCD_type;
        else if (Displaytype == 1)
            Displaytype = CRT_type;
        else if (Displaytype == 3)
            Displaytype = SIM_type;

    VideoDebugPrint((1, "CirrusHwTimer :\n"
                        "\tPreDisplaytype: %d, Currenttype :%d\n",
                        hwDeviceExtension->bDisplaytype,
                        Displaytype));

    VideoDebugPrint((1, "CirrusHwTimer :\n"
                        "\tCurrentMode: %x\n",
                        hwDeviceExtension->bCurrentMode));

        if (hwDeviceExtension->bDisplaytype != Displaytype)
        {
            hwDeviceExtension->bDisplaytype = Displaytype;

            savCRTidx = VideoPortReadPortUchar(hwDeviceExtension->IOAddress +
                                 ulCRTCAddress);
            if (hwDeviceExtension->ChipType &  CL754x)
            {
                VideoPortWritePortUchar(hwDeviceExtension->IOAddress +
                                 ulCRTCAddress, 0x20);
                lcd = VideoPortReadPortUchar(hwDeviceExtension->IOAddress +
                                 ulCRTCData);
                if (Displaytype == LCD_type)
                {
                    VideoPortWritePortUchar(hwDeviceExtension->IOAddress +
                                 ulCRTCData, (UCHAR)((lcd & 0x9F) | 0x20));
                }
                else if (Displaytype == CRT_type)
                {
                    VideoPortWritePortUchar(hwDeviceExtension->IOAddress +
                                 ulCRTCData, (UCHAR)((lcd & 0x9F)| 0x40));
                }
                else if (Displaytype == SIM_type)
                {
                    VideoPortWritePortUchar(hwDeviceExtension->IOAddress +
                                 ulCRTCData, (UCHAR)((lcd & 0x9F)| 0x60));
                }
            }
            else if (hwDeviceExtension->ChipType &  CL755x)
            {
                VideoPortWritePortUchar(hwDeviceExtension->IOAddress +
                                 ulCRTCAddress, 0x80);
                lcd = VideoPortReadPortUchar(hwDeviceExtension->IOAddress +
                                 ulCRTCData);
                if (Displaytype == LCD_type)
                {
                    VideoPortWritePortUchar(hwDeviceExtension->IOAddress +
                                 ulCRTCData, (UCHAR)((lcd & 0xFC) | 0x01));
                }
                else if (Displaytype == CRT_type)
                {
                    VideoPortWritePortUchar(hwDeviceExtension->IOAddress +
                                 ulCRTCData, (UCHAR)((lcd & 0xFC)| 0x02));
                }
                else if (Displaytype == SIM_type)
                {
                    VideoPortWritePortUchar(hwDeviceExtension->IOAddress +
                                 ulCRTCData, (UCHAR)((lcd & 0xFC)| 0x03));
                }
            }
            VideoPortWritePortUchar(hwDeviceExtension->IOAddress +
                                 ulCRTCAddress, savCRTidx);
        }
        VideoPortWritePortUchar(hwDeviceExtension->IOAddress +
                            SEQ_ADDRESS_PORT, 0x14);
        VideoPortWritePortUchar(hwDeviceExtension->IOAddress +
                             SEQ_DATA_PORT, (UCHAR)(SR14 & 0xFB));
        VideoPortWritePortUchar(hwDeviceExtension->IOAddress +
                             SEQ_ADDRESS_PORT, savSEQidx);
    }

}


//---------------------------------------------------------------------------
//
// private routines
//

VP_STATUS
VgaLoadAndSetFont(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PVIDEO_LOAD_FONT_INFORMATION FontInformation,
    ULONG FontInformationSize
    )

/*++

Routine Description:

    Takes a buffer containing a user-defined font and loads it into the
    VGA soft font memory and programs the VGA to the appropriate character
    cell size.

Arguments:

    HwDeviceExtension - Pointer to the miniport driver's device extension.

    FontInformation - Pointer to the structure containing the information
        about the loadable ROM font to be set.

    FontInformationSize - Length of the input buffer supplied by the user.

Return Value:

    NO_ERROR - information returned successfully

    ERROR_INSUFFICIENT_BUFFER - input buffer not large enough for input data.

    ERROR_INVALID_PARAMETER - invalid video mode

--*/

{
    PUCHAR destination;
    PUCHAR source;
    USHORT width;
    ULONG  i;
    ULONG  ulCRTCAddress, ulCRTCData;

    //
    // check if a mode has been set
    //

    if (HwDeviceExtension->CurrentMode == NULL) {

        return ERROR_INVALID_FUNCTION;

    }

    //
    // Text mode only; If we are in a graphics mode, return an error
    //

    if (HwDeviceExtension->CurrentMode->fbType & VIDEO_MODE_GRAPHICS) {

        return ERROR_INVALID_PARAMETER;

    }

    //
    // Check if the size of the data in the input buffer is large enough
    // and that it contains all the data.
    //

    if ( (FontInformationSize < sizeof(VIDEO_LOAD_FONT_INFORMATION)) ||
         (FontInformationSize < sizeof(VIDEO_LOAD_FONT_INFORMATION) +
                   sizeof(UCHAR) * (FontInformation->FontSize - 1)) )
    {
        return ERROR_INSUFFICIENT_BUFFER;

    }

    //
    // Check for the width and height of the font
    //

    if ( ((FontInformation->WidthInPixels != 8) &&
          (FontInformation->WidthInPixels != 9)) ||
         (FontInformation->HeightInPixels > 32) ) {

        return ERROR_INVALID_PARAMETER;

    }

    //
    // Check the size of the font buffer is the right size for the size
    // font being passed down.
    //

    if (FontInformation->FontSize < FontInformation->HeightInPixels * 256 *
                                    sizeof(UCHAR) ) {

        return ERROR_INSUFFICIENT_BUFFER;

    }

    //
    // Since the font parameters are valid, store the parameters in the
    // device extension and load the font.
    //

    HwDeviceExtension->FontPelRows = FontInformation->HeightInPixels;
    HwDeviceExtension->FontPelColumns = FontInformation->WidthInPixels;

    HwDeviceExtension->CurrentMode->row =
        HwDeviceExtension->CurrentMode->vres / HwDeviceExtension->FontPelRows;

    width =
      HwDeviceExtension->CurrentMode->hres / HwDeviceExtension->FontPelColumns;

    if (width < (USHORT)HwDeviceExtension->CurrentMode->col) {

        HwDeviceExtension->CurrentMode->col = width;

    }

    source = &(FontInformation->Font[0]);

    //
    // Set up the destination and source pointers for the font
    //

    destination = (PUCHAR)HwDeviceExtension->VideoMemoryAddress;

    //
    // Map font buffer at A0000
    //

    VgaInterpretCmdStream(HwDeviceExtension, EnableA000Data);

    //
    // Move the font to its destination
    //

    for (i = 1; i <= 256; i++) {

        VideoPortWriteRegisterBufferUchar(destination,
                                          source,
                                          FontInformation->HeightInPixels);

        destination += 32;
        source += FontInformation->HeightInPixels;

    }

    VgaInterpretCmdStream(HwDeviceExtension, DisableA000Color);

    //
    // Restore to a text mode.
    //

    if (VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                               MISC_OUTPUT_REG_READ_PORT) & 0x01)
    {
        ulCRTCAddress = CRTC_ADDRESS_PORT_COLOR;
        ulCRTCData    = CRTC_DATA_PORT_COLOR;
    }
    else
    {
        ulCRTCAddress = CRTC_ADDRESS_PORT_MONO;
        ulCRTCData    = CRTC_DATA_PORT_MONO;
    }

    //
    // Set Height of font.
    //

    VideoPortWritePortUchar(HwDeviceExtension->IOAddress + ulCRTCAddress, 0x09);
    VideoPortWritePortUchar(HwDeviceExtension->IOAddress + ulCRTCData,
                       (UCHAR)(FontInformation->HeightInPixels - 1));

    //
    // Set Width of font.
    //

    VideoPortWritePortUchar(HwDeviceExtension->IOAddress + ulCRTCAddress, 0x12);
    VideoPortWritePortUchar(HwDeviceExtension->IOAddress + ulCRTCData,
                   (UCHAR)(((USHORT)FontInformation->HeightInPixels *
                   (USHORT)HwDeviceExtension->CurrentMode->row) - 1));

    i = HwDeviceExtension->CurrentMode->vres /
        HwDeviceExtension->CurrentMode->row;

    //
    // Set Cursor End
    //

    VideoPortWritePortUchar(HwDeviceExtension->IOAddress + ulCRTCAddress, 0x0B);
    VideoPortWritePortUchar(HwDeviceExtension->IOAddress + ulCRTCData,
                                                      (UCHAR)--i);

    //
    // Set Cursor Start
    //

    VideoPortWritePortUchar(HwDeviceExtension->IOAddress + ulCRTCAddress, 0x0A);
    VideoPortWritePortUchar(HwDeviceExtension->IOAddress + ulCRTCData,
                                                (UCHAR)--i);

    return NO_ERROR;

} //end VgaLoadAndSetFont()

//---------------------------------------------------------------------------
VP_STATUS
VgaQueryCursorPosition(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PVIDEO_CURSOR_POSITION CursorPosition,
    ULONG CursorPositionSize,
    PULONG OutputSize
    )

/*++

Routine Description:

    This routine returns the row and column of the cursor.

Arguments:

    HwDeviceExtension - Pointer to the miniport driver's device extension.

    CursorPosition - Pointer to the output buffer supplied by the user. This
        is where the cursor position is stored.

    CursorPositionSize - Length of the output buffer supplied by the user.

    OutputSize - Pointer to a buffer in which to return the actual size of
        the data in the buffer. If the buffer was not large enough, this
        contains the minimum required buffer size.

Return Value:

    NO_ERROR - information returned successfully

    ERROR_INSUFFICIENT_BUFFER - output buffer not large enough to return
        any useful data

    ERROR_INVALID_PARAMETER - invalid video mode

--*/

{
    //
    // check if a mode has been set
    //

    if (HwDeviceExtension->CurrentMode == NULL) {

        return ERROR_INVALID_FUNCTION;

    }

    //
    // Text mode only; If we are in a graphics mode, return an error
    //

    if (HwDeviceExtension->CurrentMode->fbType & VIDEO_MODE_GRAPHICS) {

        *OutputSize = 0;
        return ERROR_INVALID_PARAMETER;

    }

    //
    // If the buffer passed in is not large enough return an
    // appropriate error code.
    //

    if (CursorPositionSize < (*OutputSize = sizeof(VIDEO_CURSOR_POSITION)) ) {

        *OutputSize = 0;
        return ERROR_INSUFFICIENT_BUFFER;

    }

    //
    // Store the postition of the cursor into the buffer.
    //

    CursorPosition->Column = HwDeviceExtension->CursorPosition.Column;
    CursorPosition->Row = HwDeviceExtension->CursorPosition.Row;

    return NO_ERROR;

} // end VgaQueryCursorPosition()

//---------------------------------------------------------------------------
VP_STATUS
VgaSetCursorPosition(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PVIDEO_CURSOR_POSITION CursorPosition,
    ULONG CursorPositionSize
    )

/*++

Routine Description:

    This routine verifies that the requested cursor position is within
    the row and column bounds of the current mode and font. If valid, then
    it sets the row and column of the cursor.

Arguments:

    HwDeviceExtension - Pointer to the miniport driver's device extension.

    CursorPosition - Pointer to the structure containing the cursor position.

    CursorPositionSize - Length of the input buffer supplied by the user.

Return Value:

    NO_ERROR - information returned successfully

    ERROR_INSUFFICIENT_BUFFER - input buffer not large enough for input data

    ERROR_INVALID_PARAMETER - invalid video mode

--*/

{
    USHORT position;
    ULONG  ulCRTCAddress, ulCRTCData;

    //
    // check if a mode has been set
    //

    if (HwDeviceExtension->CurrentMode == NULL) {

        return ERROR_INVALID_FUNCTION;

    }

    //
    // Text mode only; If we are in a graphics mode, return an error
    //

    if (HwDeviceExtension->CurrentMode->fbType & VIDEO_MODE_GRAPHICS) {

        return ERROR_INVALID_PARAMETER;

    }

    //
    // Check if the size of the data in the input buffer is large enough.
    //

    if (CursorPositionSize < sizeof(VIDEO_CURSOR_POSITION)) {

        return ERROR_INSUFFICIENT_BUFFER;

    }

    //
    // Check if the new values for the cursor positions are in the valid
    // bounds for the screen.
    //

    if ((CursorPosition->Column >= HwDeviceExtension->CurrentMode->col) ||
        (CursorPosition->Row >= HwDeviceExtension->CurrentMode->row)) {

        return ERROR_INVALID_PARAMETER;

    }

    //
    // Store these new values in the device extension so we can use them in
    // a QUERY.
    //

    HwDeviceExtension->CursorPosition.Column = CursorPosition->Column;
    HwDeviceExtension->CursorPosition.Row = CursorPosition->Row;

    //
    // Calculate the position on the screen at which the cursor must be
    // be displayed
    //

    position = (USHORT) (HwDeviceExtension->CurrentMode->col *
                         CursorPosition->Row + CursorPosition->Column);

    if (VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                               MISC_OUTPUT_REG_READ_PORT) & 0x01)
    {
        ulCRTCAddress = CRTC_ADDRESS_PORT_COLOR;
        ulCRTCData    = CRTC_DATA_PORT_COLOR;
    }
    else
    {
        ulCRTCAddress = CRTC_ADDRESS_PORT_MONO;
        ulCRTCData    = CRTC_DATA_PORT_MONO;
    }

    //
    // Address Cursor Location Low Register in CRT Controller Registers
    //

    VideoPortWritePortUchar(HwDeviceExtension->IOAddress + ulCRTCAddress,
                            IND_CURSOR_LOW_LOC);

    //
    // Set Cursor Location Low Register
    //

    VideoPortWritePortUchar(HwDeviceExtension->IOAddress + ulCRTCData,
                            (UCHAR) (position & 0x00FF));

    //
    // Address Cursor Location High Register in CRT Controller Registers
    //

    VideoPortWritePortUchar(HwDeviceExtension->IOAddress + ulCRTCAddress,
                            IND_CURSOR_HIGH_LOC);

    //
    // Set Cursor Location High Register
    //

    VideoPortWritePortUchar(HwDeviceExtension->IOAddress + ulCRTCData,
                            (UCHAR) (position >> 8));

    return NO_ERROR;

} // end VgaSetCursorPosition()

//---------------------------------------------------------------------------
VP_STATUS
VgaQueryCursorAttributes(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PVIDEO_CURSOR_ATTRIBUTES CursorAttributes,
    ULONG CursorAttributesSize,
    PULONG OutputSize
    )

/*++

Routine Description:

    This routine returns information about the height and visibility of the
    cursor.

Arguments:

    HwDeviceExtension - Pointer to the miniport driver's device extension.

    CursorAttributes - Pointer to the output buffer supplied by the user.
        This is where the cursor type is stored.

    CursorAttributesSize - Length of the output buffer supplied by the user.

    OutputSize - Pointer to a buffer in which to return the actual size of
        the data in the buffer. If the buffer was not large enough, this
        contains the minimum required buffer size.

Return Value:

    NO_ERROR - information returned successfully

    ERROR_INSUFFICIENT_BUFFER - output buffer not large enough to return
        any useful data

    ERROR_INVALID_PARAMETER - invalid video mode

--*/

{
    //
    // check if a mode has been set
    //

    if (HwDeviceExtension->CurrentMode == NULL) {

        return ERROR_INVALID_FUNCTION;

    }

    //
    // Text mode only; If we are in a graphics mode, return an error
    //

    if (HwDeviceExtension->CurrentMode->fbType & VIDEO_MODE_GRAPHICS) {

        *OutputSize = 0;
        return ERROR_INVALID_PARAMETER;

    }

    //
    // Find out the size of the data to be put in the the buffer and return
    // that in the status information (whether or not the information is
    // there). If the buffer passed in is not large enough return an
    // appropriate error code.
    //

    if (CursorAttributesSize < (*OutputSize =
            sizeof(VIDEO_CURSOR_ATTRIBUTES)) ) {

        *OutputSize = 0;
        return ERROR_INSUFFICIENT_BUFFER;

    }

    //
    // Store the cursor information into the buffer.
    //

    CursorAttributes->Height = (USHORT) HwDeviceExtension->CursorTopScanLine;
    CursorAttributes->Width = (USHORT) HwDeviceExtension->CursorBottomScanLine;

    if (HwDeviceExtension->cursor_vert_exp_flag)
       CursorAttributes->Enable = FALSE;
    else
       CursorAttributes->Enable = TRUE;

    CursorAttributes->Enable = HwDeviceExtension->CursorEnable;

    return NO_ERROR;

} // end VgaQueryCursorAttributes()

//---------------------------------------------------------------------------
VP_STATUS
VgaSetCursorAttributes(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PVIDEO_CURSOR_ATTRIBUTES CursorAttributes,
    ULONG CursorAttributesSize
    )

/*++

Routine Description:

    This routine verifies that the requested cursor height is within the
    bounds of the character cell. If valid, then it sets the new
    visibility and height of the cursor.

Arguments:

    HwDeviceExtension - Pointer to the miniport driver's device extension.

    CursorType - Pointer to the structure containing the cursor information.

    CursorTypeSize - Length of the input buffer supplied by the user.

Return Value:

    NO_ERROR - information returned successfully

    ERROR_INSUFFICIENT_BUFFER - input buffer not large enough for input data

    ERROR_INVALID_PARAMETER - invalid video mode

--*/

{
    UCHAR cursorLine;
    ULONG ulCRTCAddress, ulCRTCData;

    //
    // check if a mode has been set
    //

    if (HwDeviceExtension->CurrentMode == NULL) {

        return ERROR_INVALID_FUNCTION;

    }

    //
    // Text mode only; If we are in a graphics mode, return an error
    //

    if (HwDeviceExtension->CurrentMode->fbType & VIDEO_MODE_GRAPHICS) {

        return ERROR_INVALID_PARAMETER;

    }

    //
    // Check if the size of the data in the input buffer is large enough.
    //

    if (CursorAttributesSize < sizeof(VIDEO_CURSOR_ATTRIBUTES)) {

        return ERROR_INSUFFICIENT_BUFFER;

    }

    //
    // Check if the new values for the cursor type are in the valid range.
    //

    if ((CursorAttributes->Height >= HwDeviceExtension->FontPelRows) ||
        (CursorAttributes->Width > 31)) {

        return ERROR_INVALID_PARAMETER;

    }

    //
    // Store the cursor information in the device extension so we can use
    // them in a QUERY.
    //

    HwDeviceExtension->CursorTopScanLine = (UCHAR) CursorAttributes->Height;
    HwDeviceExtension->CursorBottomScanLine = (UCHAR) CursorAttributes->Width;
    HwDeviceExtension->CursorEnable = CursorAttributes->Enable;

    if (VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                                  MISC_OUTPUT_REG_READ_PORT) & 0x01)
    {
        ulCRTCAddress = CRTC_ADDRESS_PORT_COLOR;
        ulCRTCData        = CRTC_DATA_PORT_COLOR;
    }
    else
    {
        ulCRTCAddress = CRTC_ADDRESS_PORT_MONO;
        ulCRTCData        = CRTC_DATA_PORT_MONO;
    }

    //
    // Address Cursor Start Register in CRT Controller Registers
    //

    VideoPortWritePortUchar(HwDeviceExtension->IOAddress + ulCRTCAddress,
                            IND_CURSOR_START);

    //
    // Set Cursor Start Register by writting to CRTCtl Data Register
    // Preserve the high three bits of this register.
    //
    // Only the Five low bits are used for the cursor height.
    // Bit 5 is cursor enable, bit 6 and 7 preserved.
    //

    cursorLine = (UCHAR) CursorAttributes->Height & 0x1F;

    cursorLine |= VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
        ulCRTCData) & 0xC0;

    if (!CursorAttributes->Enable) {

        cursorLine |= 0x20; // Flip cursor off bit

    }

    VideoPortWritePortUchar(HwDeviceExtension->IOAddress + ulCRTCData,
                            cursorLine);

    //
    // Address Cursor End Register in CRT Controller Registers
    //

    VideoPortWritePortUchar(HwDeviceExtension->IOAddress + ulCRTCAddress,
                            IND_CURSOR_END);

    //
    // Set Cursor End Register. Preserve the high three bits of this
    // register.
    //

    cursorLine =
        (CursorAttributes->Width < (USHORT)(HwDeviceExtension->FontPelRows - 1)) ?
        CursorAttributes->Width : (HwDeviceExtension->FontPelRows - 1);

    cursorLine &= 0x1f;

    cursorLine |= VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
            ulCRTCData) & 0xE0;

    VideoPortWritePortUchar(HwDeviceExtension->IOAddress + ulCRTCData,
                            cursorLine);

    return NO_ERROR;

} // end VgaSetCursorAttributes()

//---------------------------------------------------------------------------
BOOLEAN
VgaIsPresent(
    PHW_DEVICE_EXTENSION HwDeviceExtension
    )

/*++

Routine Description:

    This routine returns TRUE if a VGA is present. Determining whether a VGA
    is present is a two-step process. First, this routine walks bits through
    the Bit Mask register, to establish that there are readable indexed
    registers (EGAs normally don't have readable registers, and other adapters
    are unlikely to have indexed registers). This test is done first because
    it's a non-destructive EGA rejection test (correctly rejects EGAs, but
    doesn't potentially mess up the screen or the accessibility of display
    memory). Normally, this would be an adequate test, but some EGAs have
    readable registers, so next, we check for the existence of the Chain4 bit
    in the Memory Mode register; this bit doesn't exist in EGAs. It's
    conceivable that there are EGAs with readable registers and a register bit
    where Chain4 is stored, although I don't know of any; if a better test yet
    is needed, memory could be written to in Chain4 mode, and then examined
    plane by plane in non-Chain4 mode to make sure the Chain4 bit did what it's
    supposed to do. However, the current test should be adequate to eliminate
    just about all EGAs, and 100% of everything else.

    If this function fails to find a VGA, it attempts to undo any damage it
    may have inadvertently done while testing. The underlying assumption for
    the damage control is that if there's any non-VGA adapter at the tested
    ports, it's an EGA or an enhanced EGA, because: a) I don't know of any
    other adapters that use 3C4/5 or 3CE/F, and b), if there are other
    adapters, I certainly don't know how to restore their original states. So
    all error recovery is oriented toward putting an EGA back in a writable
    state, so that error messages are visible. The EGA's state on entry is
    assumed to be text mode, so the Memory Mode register is restored to the
    default state for text mode.

    If a VGA is found, the VGA is returned to its original state after
    testing is finished.

Arguments:

    None.

Return Value:

    TRUE if a VGA is present, FALSE if not.

--*/

{
    UCHAR originalGCAddr;
    UCHAR originalSCAddr;
    UCHAR originalBitMask;
    UCHAR originalReadMap;
    UCHAR originalMemoryMode;
    UCHAR testMask;
    BOOLEAN returnStatus;

    //
    // Remember the original state of the Graphics Controller Address register.
    //

    originalGCAddr = VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
            GRAPH_ADDRESS_PORT);

    //
    // Write the Read Map register with a known state so we can verify
    // that it isn't changed after we fool with the Bit Mask. This ensures
    // that we're dealing with indexed registers, since both the Read Map and
    // the Bit Mask are addressed at GRAPH_DATA_PORT.
    //

    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            GRAPH_ADDRESS_PORT, IND_READ_MAP);

    //
    // If we can't read back the Graphics Address register setting we just
    // performed, it's not readable and this isn't a VGA.
    //

    if ((VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
        GRAPH_ADDRESS_PORT) & GRAPH_ADDR_MASK) != IND_READ_MAP) {

        return FALSE;
    }

    //
    // Set the Read Map register to a known state.
    //

    originalReadMap = VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
            GRAPH_DATA_PORT);
    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            GRAPH_DATA_PORT, READ_MAP_TEST_SETTING);

    if (VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
            GRAPH_DATA_PORT) != READ_MAP_TEST_SETTING) {

        //
        // The Read Map setting we just performed can't be read back; not a
        // VGA. Restore the default Read Map state.
        //

        VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                GRAPH_DATA_PORT, READ_MAP_DEFAULT);

        return FALSE;
    }

    //
    // Remember the original setting of the Bit Mask register.
    //

    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            GRAPH_ADDRESS_PORT, IND_BIT_MASK);
    if ((VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                GRAPH_ADDRESS_PORT) & GRAPH_ADDR_MASK) != IND_BIT_MASK) {

        //
        // The Graphics Address register setting we just made can't be read
        // back; not a VGA. Restore the default Read Map state.
        //

        VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                GRAPH_ADDRESS_PORT, IND_READ_MAP);
        VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                GRAPH_DATA_PORT, READ_MAP_DEFAULT);

        return FALSE;
    }

    originalBitMask = VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
            GRAPH_DATA_PORT);

    //
    // Set up the initial test mask we'll write to and read from the Bit Mask.
    //

    testMask = 0xBB;

    do {

        //
        // Write the test mask to the Bit Mask.
        //

        VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                GRAPH_DATA_PORT, testMask);

        //
        // Make sure the Bit Mask remembered the value.
        //

        if (VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                    GRAPH_DATA_PORT) != testMask) {

            //
            // The Bit Mask is not properly writable and readable; not a VGA.
            // Restore the Bit Mask and Read Map to their default states.
            //

            VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                    GRAPH_DATA_PORT, BIT_MASK_DEFAULT);
            VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                    GRAPH_ADDRESS_PORT, IND_READ_MAP);
            VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                    GRAPH_DATA_PORT, READ_MAP_DEFAULT);

            return FALSE;
        }

        //
        // Cycle the mask for next time.
        //

        testMask >>= 1;

    } while (testMask != 0);

    //
    // There's something readable at GRAPH_DATA_PORT; now switch back and
    // make sure that the Read Map register hasn't changed, to verify that
    // we're dealing with indexed registers.
    //

    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            GRAPH_ADDRESS_PORT, IND_READ_MAP);
    if (VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                GRAPH_DATA_PORT) != READ_MAP_TEST_SETTING) {

        //
        // The Read Map is not properly writable and readable; not a VGA.
        // Restore the Bit Mask and Read Map to their default states, in case
        // this is an EGA, so subsequent writes to the screen aren't garbled.
        //

        VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                GRAPH_DATA_PORT, READ_MAP_DEFAULT);
        VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                GRAPH_ADDRESS_PORT, IND_BIT_MASK);
        VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                GRAPH_DATA_PORT, BIT_MASK_DEFAULT);

        return FALSE;
    }

    //
    // We've pretty surely verified the existence of the Bit Mask register.
    // Put the Graphics Controller back to the original state.
    //

    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            GRAPH_DATA_PORT, originalReadMap);
    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            GRAPH_ADDRESS_PORT, IND_BIT_MASK);
    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            GRAPH_DATA_PORT, originalBitMask);
    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            GRAPH_ADDRESS_PORT, originalGCAddr);

    //
    // Now, check for the existence of the Chain4 bit.
    //

    //
    // Remember the original states of the Sequencer Address and Memory Mode
    // registers.
    //

    originalSCAddr = VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
            SEQ_ADDRESS_PORT);
    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            SEQ_ADDRESS_PORT, IND_MEMORY_MODE);
    if ((VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
            SEQ_ADDRESS_PORT) & SEQ_ADDR_MASK) != IND_MEMORY_MODE) {

        //
        // Couldn't read back the Sequencer Address register setting we just
        // performed.
        //

        return FALSE;
    }
    originalMemoryMode = VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
            SEQ_DATA_PORT);

    //
    // Toggle the Chain4 bit and read back the result. This must be done during
    // sync reset, since we're changing the chaining state.
    //

    //
    // Begin sync reset.
    //

    VideoPortWritePortUshort((PUSHORT)(HwDeviceExtension->IOAddress +
             SEQ_ADDRESS_PORT),
             (IND_SYNC_RESET + (START_SYNC_RESET_VALUE << 8)));

    //
    // Toggle the Chain4 bit.
    //

    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            SEQ_ADDRESS_PORT, IND_MEMORY_MODE);
    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            SEQ_DATA_PORT, (UCHAR)(originalMemoryMode ^ CHAIN4_MASK));

    if (VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                SEQ_DATA_PORT) != (UCHAR) (originalMemoryMode ^ CHAIN4_MASK)) {

        //
        // Chain4 bit not there; not a VGA.
        // Set text mode default for Memory Mode register.
        //

        VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                SEQ_DATA_PORT, MEMORY_MODE_TEXT_DEFAULT);
        //
        // End sync reset.
        //

        VideoPortWritePortUshort((PUSHORT) (HwDeviceExtension->IOAddress +
                SEQ_ADDRESS_PORT),
                (IND_SYNC_RESET + (END_SYNC_RESET_VALUE << 8)));

        returnStatus = FALSE;

    } else {

        //
        // It's a VGA.
        //

        //
        // Restore the original Memory Mode setting.
        //

        VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                SEQ_DATA_PORT, originalMemoryMode);

        //
        // End sync reset.
        //

        VideoPortWritePortUshort((PUSHORT)(HwDeviceExtension->IOAddress +
                SEQ_ADDRESS_PORT),
                (USHORT)(IND_SYNC_RESET + (END_SYNC_RESET_VALUE << 8)));

        //
        // Restore the original Sequencer Address setting.
        //

        VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                SEQ_ADDRESS_PORT, originalSCAddr);

        returnStatus = TRUE;
    }

    return returnStatus;

} // VgaIsPresent()

//---------------------------------------------------------------------------
VP_STATUS
VgaSetPaletteReg(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PVIDEO_PALETTE_DATA PaletteBuffer,
    ULONG PaletteBufferSize
    )

/*++

Routine Description:

    This routine sets a specified portion of the EGA (not DAC) palette
    registers.

Arguments:

    HwDeviceExtension - Pointer to the miniport driver's device extension.

    PaletteBuffer - Pointer to the structure containing the palette data.

    PaletteBufferSize - Length of the input buffer supplied by the user.

Return Value:

    NO_ERROR - information returned successfully

    ERROR_INSUFFICIENT_BUFFER - input buffer not large enough for input data.

    ERROR_INVALID_PARAMETER - invalid palette size.

--*/

{
    USHORT i;

    //
    // Check if the size of the data in the input buffer is large enough.
    //

    if ((PaletteBufferSize) < (sizeof(VIDEO_PALETTE_DATA)) ||
        (PaletteBufferSize < (sizeof(VIDEO_PALETTE_DATA) +
                (sizeof(USHORT) * (PaletteBuffer->NumEntries -1)) ))) {

        return ERROR_INSUFFICIENT_BUFFER;

    }

    //
    // Check to see if the parameters are valid.
    //

    if ( (PaletteBuffer->FirstEntry > VIDEO_MAX_COLOR_REGISTER ) ||
         (PaletteBuffer->NumEntries == 0) ||
         (PaletteBuffer->FirstEntry + PaletteBuffer->NumEntries >
             VIDEO_MAX_PALETTE_REGISTER + 1 ) ) {

        return ERROR_INVALID_PARAMETER;

    }

    //
    // Reset ATC to index mode
    //

    //
    // check to see mono or color first
    //
    if (VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                               MISC_OUTPUT_REG_READ_PORT) & 0x01) {
        VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                               ATT_INITIALIZE_PORT_COLOR);
    } else {
        VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                               ATT_INITIALIZE_PORT_MONO);   //frido 07-Aug-96
    }

    //
    // Blast out our palette values.
    //

    for (i = 0; i < PaletteBuffer->NumEntries; i++) {

        VideoPortWritePortUchar(HwDeviceExtension->IOAddress + ATT_ADDRESS_PORT,
                                (UCHAR)(i+PaletteBuffer->FirstEntry));

        VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                                    ATT_DATA_WRITE_PORT,
                                (UCHAR)PaletteBuffer->Colors[i]);
    }

    VideoPortWritePortUchar(HwDeviceExtension->IOAddress + ATT_ADDRESS_PORT,
                            VIDEO_ENABLE);

    return NO_ERROR;

} // end VgaSetPaletteReg()


//---------------------------------------------------------------------------
VP_STATUS
VgaSetColorLookup(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PVIDEO_CLUT ClutBuffer,
    ULONG ClutBufferSize
    )

/*++

Routine Description:

    This routine sets a specified portion of the DAC color lookup table
    settings.

Arguments:

    HwDeviceExtension - Pointer to the miniport driver's device extension.

    ClutBufferSize - Length of the input buffer supplied by the user.

    ClutBuffer - Pointer to the structure containing the color lookup table.

Return Value:

    NO_ERROR - information returned successfully

    ERROR_INSUFFICIENT_BUFFER - input buffer not large enough for input data.

    ERROR_INVALID_PARAMETER - invalid clut size.

--*/

{
    ULONG i;

    //
    // Check if the size of the data in the input buffer is large enough.
    //

    if ( (ClutBufferSize < sizeof(VIDEO_CLUT) - sizeof(ULONG)) ||
         (ClutBufferSize < sizeof(VIDEO_CLUT) +
                     (sizeof(ULONG) * (ClutBuffer->NumEntries - 1)) ) ) {

        return ERROR_INSUFFICIENT_BUFFER;

    }

    //
    // Check to see if the parameters are valid.
    //

    if ( (ClutBuffer->NumEntries == 0) ||
         (ClutBuffer->FirstEntry > VIDEO_MAX_COLOR_REGISTER) ||
         (ClutBuffer->FirstEntry + ClutBuffer->NumEntries >
             VIDEO_MAX_COLOR_REGISTER + 1) ) {

        return ERROR_INVALID_PARAMETER;

    }

    //
    //  Set CLUT registers directly on the hardware
    //

    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            DAC_ADDRESS_WRITE_PORT, (UCHAR) ClutBuffer->FirstEntry);

    for (i = 0; i < ClutBuffer->NumEntries; i++) {
        VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                                DAC_ADDRESS_WRITE_PORT,
                                (UCHAR)(i + ClutBuffer->FirstEntry));

        VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                                DAC_DATA_REG_PORT,
                                ClutBuffer->LookupTable[i].RgbArray.Red);

        VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                                DAC_DATA_REG_PORT,
                                ClutBuffer->LookupTable[i].RgbArray.Green);

        VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                                DAC_DATA_REG_PORT,
                                ClutBuffer->LookupTable[i].RgbArray.Blue);
    }

    return NO_ERROR;

} // end VgaSetColorLookup()

//---------------------------------------------------------------------------
VP_STATUS
VgaRestoreHardwareState(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PVIDEO_HARDWARE_STATE HardwareState,
    ULONG HardwareStateSize
    )

/*++

Routine Description:

    Restores all registers and memory of the VGA.

    Note: HardwareState points to the actual buffer from which the state
    is to be restored. This buffer will always be big enough (we specified
    the required size at DriverEntry).

    Note: The offset in the hardware state header from which each general
    register is restored is the offset of the write address of that register
    from the base I/O address of the VGA.


Arguments:

    HwDeviceExtension - Pointer to the miniport driver's device extension.

    HardwareState - Pointer to a structure from which the saved state is to be
        restored (actually only info about and a pointer to the actual save
        buffer).

    HardwareStateSize - Length of the input buffer supplied by the user.
        (Actually only the size of the HardwareState structure, not the
        buffer it points to from which the state is actually restored. The
        pointed-to buffer is assumed to be big enough.)

Return Value:

    NO_ERROR - restore performed successfully

    ERROR_INSUFFICIENT_BUFFER - input buffer not large enough to provide data

--*/

{
    PVIDEO_HARDWARE_STATE_HEADER hardwareStateHeader;
    ULONG i;
    UCHAR dummy;
    PUCHAR pScreen;
    PUCHAR pucLatch;
    PULONG pulBuffer;
    PUCHAR port;
    PUCHAR portValue;
    PUCHAR portValueDAC;
    ULONG bIsColor;
    ULONG portIO ;
    UCHAR value ;

    //
    // Check if the size of the data in the input buffer is large enough.
    //

    if ((HardwareStateSize < sizeof(VIDEO_HARDWARE_STATE)) ||
            (HardwareState->StateLength < VGA_TOTAL_STATE_SIZE)) {

            return ERROR_INSUFFICIENT_BUFFER;

    }

    //
    // Point to the buffer where the restore data is actually stored.
    //

    hardwareStateHeader = HardwareState->StateHeader;

    //
    // Make sure the offset are in the structure ...
    //

    if ((hardwareStateHeader->BasicSequencerOffset + VGA_NUM_SEQUENCER_PORTS >
            HardwareState->StateLength) ||

        (hardwareStateHeader->BasicCrtContOffset + VGA_NUM_CRTC_PORTS >
            HardwareState->StateLength) ||

        (hardwareStateHeader->BasicGraphContOffset + VGA_NUM_GRAPH_CONT_PORTS >
            HardwareState->StateLength) ||

        (hardwareStateHeader->BasicAttribContOffset + VGA_NUM_ATTRIB_CONT_PORTS >
            HardwareState->StateLength) ||

        (hardwareStateHeader->BasicDacOffset + (3 * VGA_NUM_DAC_ENTRIES) >
            HardwareState->StateLength) ||

        (hardwareStateHeader->BasicLatchesOffset + 4 >
            HardwareState->StateLength) ||

        (hardwareStateHeader->ExtendedSequencerOffset + EXT_NUM_SEQUENCER_PORTS >
            HardwareState->StateLength) ||

        (hardwareStateHeader->ExtendedCrtContOffset + EXT_NUM_CRTC_PORTS >
            HardwareState->StateLength) ||

        (hardwareStateHeader->ExtendedGraphContOffset + EXT_NUM_GRAPH_CONT_PORTS >
            HardwareState->StateLength) ||

        (hardwareStateHeader->ExtendedAttribContOffset + EXT_NUM_ATTRIB_CONT_PORTS >
            HardwareState->StateLength) ||

        (hardwareStateHeader->ExtendedDacOffset + (4 * EXT_NUM_DAC_ENTRIES) >
            HardwareState->StateLength) ||

        //
        // Only check the validator state offset if there is unemulated data.
        //

        ((hardwareStateHeader->VGAStateFlags & VIDEO_STATE_UNEMULATED_VGA_STATE) &&
            (hardwareStateHeader->ExtendedValidatorStateOffset + VGA_VALIDATOR_AREA_SIZE >
            HardwareState->StateLength)) ||

        (hardwareStateHeader->ExtendedMiscDataOffset + VGA_MISC_DATA_AREA_OFFSET >
            HardwareState->StateLength) ||

        (hardwareStateHeader->Plane1Offset + hardwareStateHeader->PlaneLength >
            HardwareState->StateLength) ||

        (hardwareStateHeader->Plane2Offset + hardwareStateHeader->PlaneLength >
            HardwareState->StateLength) ||

        (hardwareStateHeader->Plane3Offset + hardwareStateHeader->PlaneLength >
            HardwareState->StateLength) ||

        (hardwareStateHeader->Plane4Offset + hardwareStateHeader->PlaneLength >
            HardwareState->StateLength) ||

        (hardwareStateHeader->DIBOffset +
            hardwareStateHeader->DIBBitsPerPixel / 8 *
            hardwareStateHeader->DIBXResolution *
            hardwareStateHeader->DIBYResolution  > HardwareState->StateLength) ||

        (hardwareStateHeader->DIBXlatOffset + hardwareStateHeader->DIBXlatLength >
            HardwareState->StateLength)) {

        return ERROR_INVALID_PARAMETER;

    }

    //
    // Turn off the screen to avoid flickering. The screen will turn back on
    // when we restore the DAC state at the end of this routine.
    //

    if (VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
            MISC_OUTPUT_REG_READ_PORT) & 0x01) {
        port = INPUT_STATUS_1_COLOR + HwDeviceExtension->IOAddress;
    } else {
        port = INPUT_STATUS_1_MONO + HwDeviceExtension->IOAddress;
    }

    //
    // Set DAC register 0 to display black.
    //

    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            DAC_ADDRESS_WRITE_PORT, 0);
    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            DAC_DATA_REG_PORT, 0);
    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            DAC_DATA_REG_PORT, 0);
    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            DAC_DATA_REG_PORT, 0);

    //
    // Set the DAC mask register to force DAC register 0 to display all the
    // time (this is the register we just set to display black). From now on,
    // nothing but black will show up on the screen.
    //

    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            DAC_PIXEL_MASK_PORT, 0);


    //
    // Restore the latches and the contents of display memory.
    //
    // Set up the VGA's hardware to allow us to copy to each plane in turn.
    //
    // Begin sync reset.
    //

    VideoPortWritePortUshort((PUSHORT) (HwDeviceExtension->IOAddress +
            SEQ_ADDRESS_PORT),
            (USHORT) (IND_SYNC_RESET + (START_SYNC_RESET_VALUE << 8)));

    //
    // Turn off Chain mode and map display memory at A0000 for 64K.
    //

    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            GRAPH_ADDRESS_PORT, IND_GRAPH_MISC);
    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            GRAPH_DATA_PORT, (UCHAR) ((VideoPortReadPortUchar(
            HwDeviceExtension->IOAddress + GRAPH_DATA_PORT) & 0xF1) | 0x04));

    //
    // Turn off Chain4 mode and odd/even.
    //

    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            SEQ_ADDRESS_PORT, IND_MEMORY_MODE);
    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            SEQ_DATA_PORT,
            (UCHAR) ((VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
            SEQ_DATA_PORT) & 0xF3) | 0x04));

    //
    // End sync reset.
    //

    VideoPortWritePortUshort((PUSHORT) (HwDeviceExtension->IOAddress +
            SEQ_ADDRESS_PORT), (USHORT) (IND_SYNC_RESET +
            (END_SYNC_RESET_VALUE << 8)));

    //
    // Set the write mode to 0, the read mode to 0, and turn off odd/even.
    //

    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            GRAPH_ADDRESS_PORT, IND_GRAPH_MODE);
    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            GRAPH_DATA_PORT,
            (UCHAR) ((VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
            GRAPH_DATA_PORT) & 0xE4) | 0x00));

    //
    // Set the Bit Mask to 0xFF to allow all CPU bits through.
    //

    VideoPortWritePortUshort((PUSHORT) (HwDeviceExtension->IOAddress +
            GRAPH_ADDRESS_PORT), (USHORT) (IND_BIT_MASK + (0xFF << 8)));

    //
    // Set the Data Rotation and Logical Function fields to 0 to allow CPU
    // data through unmodified.
    //

    VideoPortWritePortUshort((PUSHORT)(HwDeviceExtension->IOAddress +
            GRAPH_ADDRESS_PORT), (USHORT) (IND_DATA_ROTATE + (0 << 8)));

    //
    // Set Set/Reset Enable to 0 to select CPU data for all planes.
    //

    VideoPortWritePortUshort((PUSHORT) (HwDeviceExtension->IOAddress +
            GRAPH_ADDRESS_PORT), (USHORT) (IND_SET_RESET_ENABLE + (0 << 8)));

    //
    // Point the Sequencer Index to the Map Mask register.
    //

    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
             SEQ_ADDRESS_PORT, IND_MAP_MASK);

    //
    // Restore the latches.
    //
    // Point to the saved data for the first latch.
    //

    pucLatch = ((PUCHAR) (hardwareStateHeader)) +
            hardwareStateHeader->BasicLatchesOffset;

    //
    // Point to first byte of display memory.
    //

    pScreen = (PUCHAR) HwDeviceExtension->VideoMemoryAddress;

    //
    // Write the contents to be restored to each of the four latches in turn.
    //

    for (i = 0; i < 4; i++) {

        //
        // Set the Map Mask to select the plane we want to restore next.
        //

        VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                SEQ_DATA_PORT, (UCHAR)(1<<i));

        //
        // Write this plane's latch.
        //

        VideoPortWriteRegisterUchar(pScreen, *pucLatch++);

    }

    //
    // Read the latched data into the latches, and the latches are set.
    //

    dummy = VideoPortReadRegisterUchar(pScreen);

    //
    // Point to the offset of the saved data for the first plane.
    //

    pulBuffer = &(hardwareStateHeader->Plane1Offset);

    //
    // Restore each of the four planes in turn.
    //

    for (i = 0; i < 4; i++) {

        //
        // Set the Map Mask to select the plane we want to restore next.
        //

        VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                SEQ_DATA_PORT, (UCHAR)(1<<i));

        //
        // Restore this plane from the buffer.
        //

        VideoPortMoveMemory((PUCHAR) HwDeviceExtension->VideoMemoryAddress,
                           ((PUCHAR) (hardwareStateHeader)) + *pulBuffer,
                           hardwareStateHeader->PlaneLength);

        pulBuffer++;

    }

    //
    // If we have some unemulated data, put it back into the buffer
    //

    if (hardwareStateHeader->VGAStateFlags & VIDEO_STATE_UNEMULATED_VGA_STATE) {

        if (!hardwareStateHeader->ExtendedValidatorStateOffset) {

            return ERROR_INVALID_PARAMETER;

        }

        //
        // Get the right offset in the struct and save all the data associated
        // with the trapped validator data.
        //

        VideoPortMoveMemory(&(HwDeviceExtension->TrappedValidatorCount),
                            ((PUCHAR) (hardwareStateHeader)) +
                                hardwareStateHeader->ExtendedValidatorStateOffset,
                            VGA_VALIDATOR_AREA_SIZE);

        //
        // Check to see if this is an appropriate access range.
        // We are trapping - so we must have the trapping access range enabled.
        //

        if (((HwDeviceExtension->CurrentVdmAccessRange != FullVgaValidatorAccessRange) ||
             (HwDeviceExtension->CurrentNumVdmAccessRanges != NUM_FULL_VGA_VALIDATOR_ACCESS_RANGE)) &&
            ((HwDeviceExtension->CurrentVdmAccessRange != MinimalVgaValidatorAccessRange) ||
             (HwDeviceExtension->CurrentNumVdmAccessRanges != NUM_MINIMAL_VGA_VALIDATOR_ACCESS_RANGE))) {

            return ERROR_INVALID_PARAMETER;

        }

        VideoPortSetTrappedEmulatorPorts(HwDeviceExtension,
                                         HwDeviceExtension->CurrentNumVdmAccessRanges,
                                         HwDeviceExtension->CurrentVdmAccessRange);

    }

    //
    // Set the critical registers (clock and timing states) during sync reset.
    //
    // Begin sync reset.
    //

    VideoPortWritePortUshort((PUSHORT) (HwDeviceExtension->IOAddress +
            SEQ_ADDRESS_PORT), (USHORT) (IND_SYNC_RESET +
            (START_SYNC_RESET_VALUE << 8)));

    //
    // Restore the Miscellaneous Output register.
    //

    portIO = MISC_OUTPUT_REG_WRITE_PORT ;
    value = (UCHAR) (hardwareStateHeader->PortValue[MISC_OUTPUT_REG_WRITE_PORT-VGA_BASE_IO_PORT] & 0xF7) ;
    IOWaitDisplEnableThenWrite ( HwDeviceExtension,
                                 portIO,
                                 value ) ;

    //
    // Restore all Sequencer registers except the Sync Reset register, which
    // is always not in reset (except when we send out a batched sync reset
    // register set, but that can't be interrupted, so we know we're never in
    // sync reset at save/restore time).
    //

    portValue = ((PUCHAR) hardwareStateHeader) +
            hardwareStateHeader->BasicSequencerOffset + 1;

    for (i = 1; i < VGA_NUM_SEQUENCER_PORTS; i++) {

        VideoPortWritePortUshort((PUSHORT) (HwDeviceExtension->IOAddress +
                SEQ_ADDRESS_PORT), (USHORT) (i + ((*portValue++) << 8)) );

    }

    //
    // Restore extended sequencer registers
    //

#ifdef EXTENDED_REGISTER_SAVE_RESTORE

    if (hardwareStateHeader->ExtendedSequencerOffset) {

        portValue = ((PUCHAR) hardwareStateHeader) +
                          hardwareStateHeader->ExtendedSequencerOffset;

        if ((HwDeviceExtension->ChipType != CL6410) &&
            (HwDeviceExtension->ChipType != CL6420))
        {

            //
            // No extended sequencer registers for the CL64xx
            //

            //
            // The first section in restore must open the extension registers
            //

            VideoPortWritePortUshort((PUSHORT) (HwDeviceExtension->IOAddress +
                                         SEQ_ADDRESS_PORT),
                                     IND_CL_EXTS_ENB + (0x0012 << 8) );

            for (i = CL542x_SEQUENCER_EXT_START;
                 i <= CL542x_SEQUENCER_EXT_END;
                 i++) {

                VideoPortWritePortUshort((PUSHORT) (HwDeviceExtension->IOAddress +
                                             SEQ_ADDRESS_PORT),
                                         (USHORT) (i + ((*portValue++) << 8)) );

            }
        }
    }

#endif

    //
    // Restore the Graphics Controller Miscellaneous register, which contains
    // the Chain bit.
    //

    portValue = ((PUCHAR) hardwareStateHeader) +
                hardwareStateHeader->BasicGraphContOffset + IND_GRAPH_MISC;

    VideoPortWritePortUshort((PUSHORT) (HwDeviceExtension->IOAddress +
            GRAPH_ADDRESS_PORT), (USHORT)(IND_GRAPH_MISC + (*portValue << 8)));

    //
    // End sync reset.
    //

    VideoPortWritePortUshort((PUSHORT) (HwDeviceExtension->IOAddress +
            SEQ_ADDRESS_PORT), (USHORT) (IND_SYNC_RESET +
            (END_SYNC_RESET_VALUE << 8)));

    //
    // Figure out if color/mono switchable registers are at 3BX or 3DX.
    // At the same time, save the state of the Miscellaneous Output register
    // which is read from 3CC but written at 3C2.
    //

    if (hardwareStateHeader->PortValue[MISC_OUTPUT_REG_WRITE_PORT-VGA_BASE_IO_PORT] & 0x01) {
        bIsColor = TRUE;
    } else {
        bIsColor = FALSE;
    }

    //
    // Restore the CRT Controller indexed registers.
    //
    // Unlock CRTC registers 0-7.
    //

    portValue = (PUCHAR) hardwareStateHeader +
            hardwareStateHeader->BasicCrtContOffset;

    if (bIsColor) {

        VideoPortWritePortUshort((PUSHORT) (HwDeviceExtension->IOAddress +
                CRTC_ADDRESS_PORT_COLOR), (USHORT) (IND_CRTC_PROTECT +
                (((*(portValue + IND_CRTC_PROTECT)) & 0x7F) << 8)));

    } else {

        VideoPortWritePortUshort((PUSHORT) (HwDeviceExtension->IOAddress +
                CRTC_ADDRESS_PORT_MONO), (USHORT) (IND_CRTC_PROTECT +
                (((*(portValue + IND_CRTC_PROTECT)) & 0x7F) << 8)));

    }

    //
    // Restore extended crtc registers.
    //

#ifdef EXTENDED_REGISTER_SAVE_RESTORE

    if (hardwareStateHeader->ExtendedCrtContOffset) {

        portValue = (PUCHAR) hardwareStateHeader +
                         hardwareStateHeader->ExtendedCrtContOffset;

        if ((HwDeviceExtension->ChipType != CL6410) &&
            (HwDeviceExtension->ChipType != CL6420))
        {
            //
            // No CRTC Extensions in CL64xx chipset
            //

            for (i = CL542x_CRTC_EXT_START; i <= CL542x_CRTC_EXT_END; i++) {

                if (bIsColor) {

                    VideoPortWritePortUshort((PUSHORT) (HwDeviceExtension->IOAddress +
                                                 CRTC_ADDRESS_PORT_COLOR),
                                             (USHORT) (i + ((*portValue++) << 8)));

                } else {

                    VideoPortWritePortUshort((PUSHORT) (HwDeviceExtension->IOAddress +
                                                 CRTC_ADDRESS_PORT_MONO),
                                             (USHORT) (i + ((*portValue++) << 8)));

                }
            }
        }

/* myf2, crus
        if (HwDeviceExtension->ChipType &  CL755x)
        {
            for (i = 0x81; i <= 0x91; i++)
            {
                if (bIsColor)
                {
                    VideoPortWritePortUshort((PUSHORT) (HwDeviceExtension->IOAddress +
                                                 CRTC_ADDRESS_PORT_COLOR),
                                             (USHORT) (i + ((*portValue++) << 8)));

                } else {

                    VideoPortWritePortUshort((PUSHORT) (HwDeviceExtension->IOAddress +
                                                 CRTC_ADDRESS_PORT_MONO),
                                             (USHORT) (i + ((*portValue++) << 8)));

                }
            }
        }
crus, myf2 */
    }

#endif

    //
    // Now restore the CRTC registers.
    //

    portValue = (PUCHAR) hardwareStateHeader +
            hardwareStateHeader->BasicCrtContOffset;

    for (i = 0; i < VGA_NUM_CRTC_PORTS; i++) {

        if (bIsColor) {

            VideoPortWritePortUshort((PUSHORT) (HwDeviceExtension->IOAddress +
                    CRTC_ADDRESS_PORT_COLOR),
                    (USHORT) (i + ((*portValue++) << 8)));

        } else {

            VideoPortWritePortUshort((PUSHORT) (HwDeviceExtension->IOAddress +
                    CRTC_ADDRESS_PORT_MONO),
                    (USHORT) (i + ((*portValue++) << 8)));

        }

    }

    //
    // Restore the Graphics Controller indexed registers.
    //

    portValue = (PUCHAR) hardwareStateHeader +
            hardwareStateHeader->BasicGraphContOffset;

    for (i = 0; i < VGA_NUM_GRAPH_CONT_PORTS; i++) {

        VideoPortWritePortUshort((PUSHORT) (HwDeviceExtension->IOAddress +
                GRAPH_ADDRESS_PORT), (USHORT) (i + ((*portValue++) << 8)));

    }

    //
    // Restore extended graphics controller registers.
    //

#ifdef EXTENDED_REGISTER_SAVE_RESTORE

    if (hardwareStateHeader->ExtendedGraphContOffset) {

    portValue = (PUCHAR) hardwareStateHeader +
                         hardwareStateHeader->ExtendedGraphContOffset;

        if ((HwDeviceExtension->ChipType != CL6410) &&
            (HwDeviceExtension->ChipType != CL6420))
        {
            for (i = CL542x_GRAPH_EXT_START; i <= CL542x_GRAPH_EXT_END; i++) {

                VideoPortWritePortUshort((PUSHORT) (HwDeviceExtension->IOAddress +
                                             GRAPH_ADDRESS_PORT),
                                         (USHORT) (i + ((*portValue++) << 8)));
            }

        } else {         // must be a CL64xx

            VideoPortWritePortUshort((PUSHORT)(HwDeviceExtension->IOAddress +
                                         GRAPH_ADDRESS_PORT),
                                     CL64xx_EXTENSION_ENABLE_INDEX +
                                         (CL64xx_EXTENSION_ENABLE_VALUE << 8));

            for (i = CL64xx_GRAPH_EXT_START; i <= CL64xx_GRAPH_EXT_END; i++) {

                VideoPortWritePortUshort((PUSHORT) (HwDeviceExtension->IOAddress +
                                             GRAPH_ADDRESS_PORT),
                                         (USHORT) (i + ((*portValue++) << 8)));

            }
        }
    }

#endif

    //
    // Restore the Attribute Controller indexed registers.
    //

    portValue = (PUCHAR) hardwareStateHeader +
            hardwareStateHeader->BasicAttribContOffset;

    //
    // Reset the AC index/data toggle, then blast out all the register
    // settings.
    //

    if (bIsColor) {
        dummy = VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                INPUT_STATUS_1_COLOR);
    } else {
        dummy = VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                INPUT_STATUS_1_MONO);
    }

    for (i = 0; i < VGA_NUM_ATTRIB_CONT_PORTS; i++) {

        VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                ATT_ADDRESS_PORT, (UCHAR)i);
        VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                ATT_DATA_WRITE_PORT, *portValue++);

    }

    //
    // Restore DAC registers 1 through 255. We'll do register 0, the DAC Mask,
    // and the index registers later.
    // Set the DAC address port Index, then write out the DAC Data registers.
    // Each three reads get Red, Green, and Blue components for that register.
    //
    // Write them one at a time due to problems on local bus machines.
    //

    portValueDAC = (PUCHAR) hardwareStateHeader +
                   hardwareStateHeader->BasicDacOffset + 3;

    for (i = 1; i < VGA_NUM_DAC_ENTRIES; i++) {

        VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                                DAC_ADDRESS_WRITE_PORT, (UCHAR)i);

        VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                                DAC_DATA_REG_PORT, *portValueDAC++);

        VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                                DAC_DATA_REG_PORT, *portValueDAC++);

        VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                                DAC_DATA_REG_PORT, *portValueDAC++);

    }

    //
    // Is this color or mono ?
    //

    if (bIsColor) {
        port = HwDeviceExtension->IOAddress + INPUT_STATUS_1_COLOR;
    } else {
        port = HwDeviceExtension->IOAddress + INPUT_STATUS_1_MONO;
    }

    //
    // Restore the Feature Control register.
    //

    if (bIsColor) {

        VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                FEAT_CTRL_WRITE_PORT_COLOR,
                hardwareStateHeader->PortValue[FEAT_CTRL_WRITE_PORT_COLOR-VGA_BASE_IO_PORT]);

    } else {

        VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                FEAT_CTRL_WRITE_PORT_MONO,
                hardwareStateHeader->PortValue[FEAT_CTRL_WRITE_PORT_MONO-VGA_BASE_IO_PORT]);

    }


    //
    // Restore the Sequencer Index.
    //

    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            SEQ_ADDRESS_PORT,
            hardwareStateHeader->PortValue[SEQ_ADDRESS_PORT-VGA_BASE_IO_PORT]);

    //
    // Restore the CRT Controller Index.
    //

    if (bIsColor) {

        VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                CRTC_ADDRESS_PORT_COLOR,
                hardwareStateHeader->PortValue[CRTC_ADDRESS_PORT_COLOR-VGA_BASE_IO_PORT]);

    } else {

        VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                CRTC_ADDRESS_PORT_MONO,
                hardwareStateHeader->PortValue[CRTC_ADDRESS_PORT_MONO-VGA_BASE_IO_PORT]);

    }


    //
    // Restore the Graphics Controller Index.
    //

    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            GRAPH_ADDRESS_PORT,
            hardwareStateHeader->PortValue[GRAPH_ADDRESS_PORT-VGA_BASE_IO_PORT]);


    //
    // Restore the Attribute Controller Index and index/data toggle state.
    //

    if (bIsColor) {
        port = HwDeviceExtension->IOAddress + INPUT_STATUS_1_COLOR;
    } else {
        port = HwDeviceExtension->IOAddress + INPUT_STATUS_1_MONO;
    }

    VideoPortReadPortUchar(port);  // reset the toggle to Index state

    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            ATT_ADDRESS_PORT,  // restore the AC Index
            hardwareStateHeader->PortValue[ATT_ADDRESS_PORT-VGA_BASE_IO_PORT]);

    //
    // If the toggle should be in Data state, we're all set. If it should be in
    // Index state, reset it to that condition.
    //

    if (hardwareStateHeader->AttribIndexDataState == 0) {

        //
        // Reset the toggle to Index state.
        //

        VideoPortReadPortUchar(port);

    }


    //
    // Restore DAC register 0 and the DAC Mask, to unblank the screen.
    //

    portValueDAC = (PUCHAR) hardwareStateHeader +
            hardwareStateHeader->BasicDacOffset;

    //
    // Restore the DAC Mask register.
    //

    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            DAC_PIXEL_MASK_PORT,
            hardwareStateHeader->PortValue[DAC_PIXEL_MASK_PORT-VGA_BASE_IO_PORT]);

    //
    // Restore DAC register 0.
    //

    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            DAC_ADDRESS_WRITE_PORT, 0);
    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            DAC_DATA_REG_PORT, *portValueDAC++);
    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            DAC_DATA_REG_PORT, *portValueDAC++);
    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            DAC_DATA_REG_PORT, *portValueDAC++);


    //
    // Restore the read/write state and the current index of the DAC.
    //
    // See whether the Read or Write Index was written to most recently.
    // (The upper nibble stored at DAC_STATE_PORT is the # of reads/writes
    // for the current index.)
    //

    if ((hardwareStateHeader->PortValue[DAC_STATE_PORT-VGA_BASE_IO_PORT] & 0x0F) == 3) {

        //
        // The DAC Read Index was written to last. Restore the DAC by setting
        // up to read from the saved index - 1, because the way the Read
        // Index works is that it autoincrements after reading, so you actually
        // end up reading the data for the index you read at the DAC Write
        // Mask register - 1.
        //
        // Set the Read Index to the index we read, minus 1, accounting for
        // wrap from 255 back to 0. The DAC hardware immediately reads this
        // register into a temporary buffer, then adds 1 to the index.
        //

        if (hardwareStateHeader->PortValue[DAC_ADDRESS_WRITE_PORT-VGA_BASE_IO_PORT] == 0) {

            VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                    DAC_ADDRESS_READ_PORT, 255);

        } else {

            VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                    DAC_ADDRESS_READ_PORT, (UCHAR)
                    (hardwareStateHeader->PortValue[DAC_ADDRESS_WRITE_PORT-VGA_BASE_IO_PORT] -
                    1));

        }

        //
        // Now read the hardware however many times are required to get to
        // the partial read state we saved.
        //

        for (i = hardwareStateHeader->PortValue[DAC_STATE_PORT-VGA_BASE_IO_PORT] >> 4;
                i > 0; i--) {

            dummy = VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                    DAC_DATA_REG_PORT);

        }

    } else {

        //
        // The DAC Write Index was written to last. Set the Write Index to the
        // index value we read out of the DAC. Then, if a partial write
        // (partway through an RGB triplet) was in place, write the partial
        // values, which we obtained by writing them to the current DAC
        // register. This DAC register will be wrong until the write is
        // completed, but at least the values will be right once the write is
        // finished, and most importantly we won't have messed up the sequence
        // of RGB writes (which can be as long as 768 in a row).
        //

        VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                DAC_ADDRESS_WRITE_PORT,
                hardwareStateHeader->PortValue[DAC_ADDRESS_WRITE_PORT-VGA_BASE_IO_PORT]);

        //
        // Now write to the hardware however many times are required to get to
        // the partial write state we saved (if any).
        //
        // Point to the saved value for the DAC register that was in the
        // process of being written to; we wrote the partial value out, so now
        // we can restore it.
        //

        portValueDAC = (PUCHAR) hardwareStateHeader +
                hardwareStateHeader->BasicDacOffset +
                (hardwareStateHeader->PortValue[DAC_ADDRESS_WRITE_PORT-VGA_BASE_IO_PORT] * 3);

        for (i = hardwareStateHeader->PortValue[DAC_STATE_PORT-VGA_BASE_IO_PORT] >> 4;
                i > 0; i--) {

            VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                    DAC_DATA_REG_PORT, *portValueDAC++);

        }

    }

    return NO_ERROR;

} // end VgaRestoreHardwareState()

//---------------------------------------------------------------------------
VP_STATUS
VgaSaveHardwareState(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PVIDEO_HARDWARE_STATE HardwareState,
    ULONG HardwareStateSize,
    PULONG OutputSize
    )

/*++

Routine Description:

    Saves all registers and memory of the VGA.

    Note: HardwareState points to the actual buffer in which the state
    is saved. This buffer will always be big enough (we specified
    the required size at DriverEntry).

    Note: This routine leaves registers in any state it cares to, except
    that it will not mess with any of the CRT or Sequencer parameters that
    might make the monitor unhappy. It leaves the screen blanked by setting
    the DAC Mask and DAC register 0 to all zero values. The next video
    operation we expect after this is a mode set to take us back to Win32.

    Note: The offset in the hardware state header in which each general
    register is saved is the offset of the write address of that register from
    the base I/O address of the VGA.

Arguments:

    HwDeviceExtension - Pointer to the miniport driver's device extension.

    HardwareState - Pointer to a structure in which the saved state will be
        returned (actually only info about and a pointer to the actual save
        buffer).

    HardwareStateSize - Length of the output buffer supplied by the user.
        (Actually only the size of the HardwareState structure, not the
        buffer it points to where the state is actually saved. The pointed-
        to buffer is assumed to be big enough.)

    OutputSize - Pointer to a buffer in which to return the actual size of
        the data returned in the buffer.

Return Value:

    NO_ERROR - information returned successfully

    ERROR_INSUFFICIENT_BUFFER - output buffer not large enough to return
        any useful data

--*/

{
    PVIDEO_HARDWARE_STATE_HEADER hardwareStateHeader;
    PUCHAR port;
    PUCHAR pScreen;
    PUCHAR portValue;
    PUCHAR portValueDAC;
    PUCHAR bufferPointer;
    ULONG i;
    UCHAR dummy, originalACIndex, originalACData;
    UCHAR ucCRTC03;
    ULONG bIsColor;

    ULONG portIO ;
    UCHAR value ;

    //
    // See if the buffer is big enough to hold the hardware state structure.
    // (This is only the HardwareState structure itself, not the buffer it
    // points to.)
    //

    if (HardwareStateSize < sizeof(VIDEO_HARDWARE_STATE) ) {

        *OutputSize = 0;  // nothing returned
        return ERROR_INSUFFICIENT_BUFFER;

    }

    //
    // Amount of data we're going to return in the output buffer.
    // (The VIDEO_HARDWARE_STATE in the output buffer points to the actual
    // buffer in which the state is stored, which is assumed to be large
    // enough.)
    //

    *OutputSize = sizeof(VIDEO_HARDWARE_STATE);

    //
    // Indicate the size of the full state save info.
    //

    HardwareState->StateLength = VGA_TOTAL_STATE_SIZE;

    //
    // hardwareStateHeader is a structure of offsets at the start of the
    // actual save area that indicates the locations in which various VGA
    // register and memory components are saved.
    //

    hardwareStateHeader = HardwareState->StateHeader;

    //
    // Zero out the structure.
    //

    VideoPortZeroMemory(hardwareStateHeader, sizeof(VIDEO_HARDWARE_STATE_HEADER));

    //
    // Set the Length field, which is basically a version ID.
    //

    hardwareStateHeader->Length = sizeof(VIDEO_HARDWARE_STATE_HEADER);

    //
    // Set the basic register offsets properly.
    //

    hardwareStateHeader->BasicSequencerOffset = VGA_BASIC_SEQUENCER_OFFSET;
    hardwareStateHeader->BasicCrtContOffset = VGA_BASIC_CRTC_OFFSET;
    hardwareStateHeader->BasicGraphContOffset = VGA_BASIC_GRAPH_CONT_OFFSET;
    hardwareStateHeader->BasicAttribContOffset = VGA_BASIC_ATTRIB_CONT_OFFSET;
    hardwareStateHeader->BasicDacOffset = VGA_BASIC_DAC_OFFSET;
    hardwareStateHeader->BasicLatchesOffset = VGA_BASIC_LATCHES_OFFSET;

    //
    // Set the entended register offsets properly.
    //

    hardwareStateHeader->ExtendedSequencerOffset = VGA_EXT_SEQUENCER_OFFSET;
    hardwareStateHeader->ExtendedCrtContOffset = VGA_EXT_CRTC_OFFSET;
    hardwareStateHeader->ExtendedGraphContOffset = VGA_EXT_GRAPH_CONT_OFFSET;
    hardwareStateHeader->ExtendedAttribContOffset = VGA_EXT_ATTRIB_CONT_OFFSET;
    hardwareStateHeader->ExtendedDacOffset = VGA_EXT_DAC_OFFSET;

    //
    // Figure out if color/mono switchable registers are at 3BX or 3DX.
    // At the same time, save the state of the Miscellaneous Output register
    // which is read from 3CC but written at 3C2.
    //

    if ((hardwareStateHeader->PortValue[MISC_OUTPUT_REG_WRITE_PORT-VGA_BASE_IO_PORT] =
            VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                    MISC_OUTPUT_REG_READ_PORT))
            & 0x01) {
        bIsColor = TRUE;
    } else {
        bIsColor = FALSE;
    }

    //
    // Force the video subsystem enable state to enabled.
    //

    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            VIDEO_SUBSYSTEM_ENABLE_PORT, 1);

    //
    // Save the DAC state first, so we can set the DAC to blank the screen
    // so nothing after this shows up at all.
    //
    // Save the DAC Mask register.
    //

    hardwareStateHeader->PortValue[DAC_PIXEL_MASK_PORT-VGA_BASE_IO_PORT] =
            VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                    DAC_PIXEL_MASK_PORT);

    //
    // Save the DAC Index register. Note that there is actually only one DAC
    // Index register, which functions as either the Read Index or the Write
    // Index as needed.
    //

    hardwareStateHeader->PortValue[DAC_ADDRESS_WRITE_PORT-VGA_BASE_IO_PORT] =
            VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                    DAC_ADDRESS_WRITE_PORT);

    //
    // Save the DAC read/write state. We determine if the DAC has been written
    // to or read from at the current index 0, 1, or 2 times (the application
    // is in the middle of reading or writing a DAC register triplet if the
    // count is 1 or 2), and save enough info so we can restore things
    // properly. The only hole is if the application writes to the Write Index,
    // then reads from instead of writes to the Data register, or vice-versa,
    // or if they do a partial read write, then never finish it.
    // This is fairly ridiculous behavior, however, and anyway there's nothing
    // we can do about it.
    //

    hardwareStateHeader->PortValue[DAC_STATE_PORT-VGA_BASE_IO_PORT] =
             VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                    DAC_STATE_PORT);

    if (hardwareStateHeader->PortValue[DAC_STATE_PORT-VGA_BASE_IO_PORT] == 3) {

        //
        // The DAC Read Index was written to last. Figure out how many reads
        // have been done from the current index. We'll restart this on restore
        // by setting the Read Index to the current index - 1 (the read index
        // is one greater than the index being read), then doing the proper
        // number of reads.
        //
        // Read the Data register once, and see if the index changes.
        //

        dummy = VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                DAC_DATA_REG_PORT);

        if (VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                    DAC_ADDRESS_WRITE_PORT) !=
                hardwareStateHeader->PortValue[DAC_ADDRESS_WRITE_PORT-VGA_BASE_IO_PORT]) {

            //
            // The DAC Index changed, so two reads had already been done from
            // the current index. Store the count "2" in the upper nibble of
            // the read/write state field.
            //

            hardwareStateHeader->PortValue[DAC_STATE_PORT-VGA_BASE_IO_PORT] |= 0x20;

        } else {

            //
            // Read the Data register again, and see if the index changes.
            //

            dummy = VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                    DAC_DATA_REG_PORT);

            if (VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                        DAC_ADDRESS_WRITE_PORT) !=
                    hardwareStateHeader->PortValue[DAC_ADDRESS_WRITE_PORT-VGA_BASE_IO_PORT]) {

                //
                // The DAC Index changed, so one read had already been done
                // from the current index. Store the count "1" in the upper
                // nibble of the read/write state field.
                //

                hardwareStateHeader->PortValue[DAC_STATE_PORT-VGA_BASE_IO_PORT] |= 0x10;
            }

            //
            // If neither 2 nor 1 reads had been done from the current index,
            // then 0 reads were done, and we're all set, since the upper
            // nibble of the read/write state field is already 0.
            //

        }

    } else {

        //
        // The DAC Write Index was written to last. Figure out how many writes
        // have been done to the current index. We'll restart this on restore
        // by setting the Write Index to the proper index, then doing the
        // proper number of writes. When we do the DAC register save, we'll
        // read out the value that gets written (if there was a partial write
        // in progress), so we can restore the proper data later. This will
        // cause this current DAC location to be briefly wrong in the 1- and
        // 2-bytes-written case (until the app finishes the write), but that's
        // better than having the wrong DAC values written for good.
        //
        // Write the Data register once, and see if the index changes.
        //

        VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                DAC_DATA_REG_PORT, 0);

        if (VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                    DAC_ADDRESS_WRITE_PORT) !=
                hardwareStateHeader->PortValue[DAC_ADDRESS_WRITE_PORT-VGA_BASE_IO_PORT]) {

            //
            // The DAC Index changed, so two writes had already been done to
            // the current index. Store the count "2" in the upper nibble of
            // the read/write state field.
            //

            hardwareStateHeader->PortValue[DAC_STATE_PORT-VGA_BASE_IO_PORT] |= 0x20;

        } else {

            //
            // Write the Data register again, and see if the index changes.
            //

            VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                    DAC_DATA_REG_PORT, 0);

            if (VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                        DAC_ADDRESS_WRITE_PORT) !=
                    hardwareStateHeader->PortValue[DAC_ADDRESS_WRITE_PORT-VGA_BASE_IO_PORT]) {

                //
                // The DAC Index changed, so one write had already been done
                // to the current index. Store the count "1" in the upper
                // nibble of the read/write state field.
                //

                hardwareStateHeader->PortValue[DAC_STATE_PORT-VGA_BASE_IO_PORT] |= 0x10;
            }

            //
            // If neither 2 nor 1 writes had been done to the current index,
            // then 0 writes were done, and we're all set.
            //

        }

    }

    //
    // Now, read out the 256 18-bit DAC palette registers (256 RGB triplets),
    // and blank the screen.
    //

    portValueDAC = (PUCHAR) hardwareStateHeader + VGA_BASIC_DAC_OFFSET;

    //
    // Read out DAC register 0, so we can set it to black.
    //

    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                DAC_ADDRESS_READ_PORT, 0);
    *portValueDAC++ = VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
            DAC_DATA_REG_PORT);
    *portValueDAC++ = VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
            DAC_DATA_REG_PORT);
    *portValueDAC++ = VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
            DAC_DATA_REG_PORT);

    //
    // Set DAC register 0 to display black.
    //

    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            DAC_ADDRESS_WRITE_PORT, 0);
    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            DAC_DATA_REG_PORT, 0);
    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            DAC_DATA_REG_PORT, 0);
    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            DAC_DATA_REG_PORT, 0);

    //
    // Set the DAC mask register to force DAC register 0 to display all the
    // time (this is the register we just set to display black). From now on,
    // nothing but black will show up on the screen.
    //

    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            DAC_PIXEL_MASK_PORT, 0);

    //
    // Read out the Attribute Controller Index state, and deduce the Index/Data
    // toggle state at the same time.
    //
    // Save the state of the Attribute Con