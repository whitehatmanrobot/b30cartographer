ETURN();

        BEGINCOPYOUT()
            try {
                if (lpdwW != NULL)
                    *lpdwW = ProbeAndReadUlong((LPDWORD)pcbs->pOutput);
                if (lpdwL != NULL)
                    *lpdwL = ProbeAndReadUlong((LPDWORD)pcbs->pOutput + 1);
            } except (W32ExceptionHandler(TRUE, RIP_WARNING)) {
                MSGERROR();
            }
        ENDCOPYOUT()

    TRACECALLBACKMSG("SfnOPTOUTLPDWORDOPTOUTLPDWORD");
    ENDSEND(LRESULT,0);
}
#endif // SENDSIDE

#ifdef RECVSIDE
RECVCALL(fnOPTOUTLPDWORDOPTOUTLPDWORD, FNOPTOUTLPDWORDOPTOUTLPDWORDMSG)
{
    DWORD adwOut[2];
    BEGINRECV(0, adwOut, sizeof(adwOut));

    retval = (ULONG_PTR)CALLPROC(CALLDATA(xpfnProc))(
            CALLDATA(pwnd),
            CALLDATA(msg),
            &adwOut[0],
            &adwOut[1],
            CALLDATA(xParam));

    ENDRECV();
}
#endif // RECVSIDE

/**************************************************************************\
* fnDWORDOPTINLPMSG
*
* 03-30-92 scottlu      Created
\**************************************************************************/

typedef struct _FNDWORDOPTINLPMSGMSG {
    PWND pwnd;
    UINT msg;
    WPARAM wParam;
    LPMSG pmsgstruct;
    ULONG_PTR xParam;
    PROC xpfnProc;
    MSG msgstruct;
} FNDWORDOPTINLPMSGMSG;

#ifdef SENDSIDE
SMESSAGECALL(DWORDOPTINLPMSG)
{
    SETUPPWND(FNDWORDOPTINLPMSG)

    UNREFERENCED_PARAMETER(dwSCMSFlags);
    UNREFERENCED_PARAMETER(psms);

    BEGINSEND(FNDWORDOPTINLPMSG)

        LPMSG pmsgstruct = (LPMSG)lParam;

        MSGDATA()->pwnd = pwndClient;
        MSGDATA()->msg = msg;
        MSGDATA()->wParam = wParam;
        COPYSTRUCTOPT(msgstruct);
        MSGDATA()->xParam = xParam;
        MSGDATA()->xpfnProc = xpfnProc;

        LOCKPWND();
        MAKECALL(FNDWORDOPTINLPMSG);
        UNLOCKPWND();
        CHECKRETURN();

    TRACECALLBACKMSG("SfnDWORDOPTINLPMSG");
    ENDSEND(LRESULT,0);
}
#endif // SENDSIDE

#ifdef RECVSIDE
RECVCALL(fnDWORDOPTINLPMSG, FNDWORDOPTINLPMSGMSG)
{
    BEGINRECV(0, NULL, 0);

    retval = (ULONG_PTR)CALLPROC(CALLDATA(xpfnProc))(
            CALLDATA(pwnd),
            CALLDATA(msg),
            CALLDATA(wParam),
            PCALLDATAOPT(msgstruct),
            CALLDATA(xParam));

    ENDRECV();
}
#endif // RECVSIDE

/**************************************************************************\
* fnCOPYGLOBALDATA
*
* 6-20-92 Sanfords created
\**************************************************************************/

typedef struct _FNCOPYGLOBALDATAMSG {
    CAPTUREBUF CaptureBuf;
    DWORD cbSize;
    PBYTE pData;
} FNCOPYGLOBALDATAMSG;

#ifdef SENDSIDE
SMESSAGECALL(COPYGLOBALDATA)
{
    PBYTE pData = (PBYTE)lParam;

    SETUPPWND(FNCOPYGLOBALDATA)

    UNREFERENCED_PARAMETER(msg);
    UNREFERENCED_PARAMETER(xParam);
    UNREFERENCED_PARAMETER(xpfnProc);
    UNREFERENCED_PARAMETER(dwSCMSFlags);
    UNREFERENCED_PARAMETER(psms);

    BEGINSENDCAPTURE(FNCOPYGLOBALDATA, 1, wParam, TRUE)

        if (pData == 0) {
            MSGERROR();
        }

        MSGDATA()->cbSize = (DWORD)wParam;
        LARGECOPYBYTES(pData, (DWORD)wParam);

        LOCKPWND();
        MAKECALLCAPTURE(FNCOPYGLOBALDATA);
        UNLOCKPWND();
        CHECKRETURN();

    TRACECALLBACKMSG("SfnCOPYGLOBALDATA");
    ENDSENDCAPTURE(LRESULT,0);
}
#endif // SENDSIDE

#ifdef RECVSIDE
RECVCALL(fnCOPYGLOBALDATA, FNCOPYGLOBALDATAMSG)
{
    PBYTE p;

    BEGINRECV(0, NULL, 0);
    FIXUPPOINTERS();

    retval = (ULONG_PTR)GlobalAlloc(GMEM_MOVEABLE, CALLDATA(cbSize));
    if (p = GlobalLock((HANDLE)retval)) {

        memcpy(p, (PVOID)CALLDATA(pData), CALLDATA(cbSize));
        USERGLOBALUNLOCK((HANDLE)retval);

    }

    ENDRECV();
}
#endif // RECVSIDE

/**************************************************************************\
* fnCOPYDATA
*
* 7-14-92 Sanfords created
\**************************************************************************/

typedef struct _FNCOPYDATAMSG {
    CAPTUREBUF CaptureBuf;
    PWND pwnd;
    UINT msg;
    HWND hwndFrom;
    BOOL fDataPresent;
    COPYDATASTRUCT cds;
    ULONG_PTR xParam;
    PROC xpfnProc;
} FNCOPYDATAMSG;

#ifdef SENDSIDE
SMESSAGECALL(COPYDATA)
{
    HWND hwndFrom = (HWND)wParam;
    PCOPYDATASTRUCT pcds = (PCOPYDATASTRUCT)lParam;
    DWORD cCapture, cbCapture;

    SETUPPWND(FNCOPYDATA)

    UNREFERENCED_PARAMETER(dwSCMSFlags);
    UNREFERENCED_PARAMETER(psms);

    if (pcds == NULL) {
        cCapture = cbCapture = 0;
    } else {
        cCapture = 1;
        cbCapture = pcds->cbData;
    }
    BEGINSENDCAPTURE(FNCOPYDATA, cCapture, cbCapture, TRUE);

        MSGDATA()->pwnd = pwndClient;
        MSGDATA()->msg = msg;
        MSGDATA()->hwndFrom = hwndFrom;
        if (pcds != NULL) {
            MSGDATA()->fDataPresent = TRUE;
            MSGDATA()->cds = *pcds;
            LARGECOPYBYTES2(pcds->lpData, cbCapture, cds.lpData);
        } else {
            MSGDATA()->fDataPresent = FALSE;
        }
        MSGDATA()->xParam = xParam;
        MSGDATA()->xpfnProc = xpfnProc;

        LOCKPWND();
        MAKECALLCAPTURE(FNCOPYDATA);
        UNLOCKPWND();
        CHECKRETURN();

    TRACECALLBACKMSG("SfnCOPYDATA");
    ENDSENDCAPTURE(LRESULT,0);
}
#endif // SENDSIDE

#ifdef RECVSIDE
RECVCALL(fnCOPYDATA, FNCOPYDATAMSG)
{
    BEGINRECV(0, NULL, 0);
    FIXUPPOINTERS();

    retval = CALLPROC(CALLDATA(xpfnProc))(
        CALLDATA(pwnd),
        CALLDATA(msg),
        CALLDATA(hwndFrom),
        CALLDATA(fDataPresent) ? PCALLDATA(cds) : NULL,
        CALLDATA(xParam));

    ENDRECV();
}
#endif // RECVSIDE


/**************************************************************************\
* fnSENTDDEMSG
*
* 11-5-92 Sanfords created
*
*   This thunks DDE messages that SHOULD be posted.  It will only work for
*   WOW apps.  This thunking is strictly for WOW compatability.  No 32 bit
*   app should be allowed to get away with this practice because it opens
*   the DDE protocol up to deadlocks.
\**************************************************************************/

typedef struct _FNSENTDDEMSGMSG {
    PWND pwnd;
    UINT msg;
    WPARAM wParam;
    LPARAM lParam;
    ULONG_PTR xParam;
    PROC xpfnProc;
    BOOL fIsUnicodeProc;
} FNSENTDDEMSGMSG;

#ifdef SENDSIDE
SMESSAGECALL(SENTDDEMSG)
{
    MSG msgs;

    SETUPPWND(FNSENTDDEMSG)

    UNREFERENCED_PARAMETER(psms);

    BEGINSEND(FNSENTDDEMSG)

        msg &= ~MSGFLAG_DDE_SPECIAL_SEND;
        if (msg & MSGFLAG_DDE_MID_THUNK) {
            /*
             * complete the thunking here.
             */
            msgs.hwnd = HW(pwnd);
            msgs.message = msg & ~MSGFLAG_DDE_MID_THUNK;
            msgs.wParam = wParam;
            msgs.lParam = lParam;
            xxxDDETrackGetMessageHook((PMSG)&msgs);

            MSGDATA()->pwnd = (PWND)((PBYTE)PW(msgs.hwnd) -
                    pti->ulClientDelta);
            MSGDATA()->msg = msgs.message;
            MSGDATA()->wParam = msgs.wParam;
            MSGDATA()->lParam = msgs.lParam;
        } else {
            MSGDATA()->pwnd = pwndClient;
            MSGDATA()->msg = msg;
            MSGDATA()->wParam = wParam;
            MSGDATA()->lParam = lParam;
        }
        MSGDATA()->xParam = xParam;
        MSGDATA()->xpfnProc = xpfnProc;
        MSGDATA()->fIsUnicodeProc = !(dwSCMSFlags & SCMS_FLAGS_ANSI);

        LOCKPWND();
        MAKECALL(FNSENTDDEMSG);
        UNLOCKPWND();
        CHECKRETURN();

    TRACECALLBACKMSG("SfnSENTDDEMSG");
    ENDSEND(LRESULT,0);
}
#endif // SENDSIDE

#ifdef RECVSIDE
RECVCALL(fnSENTDDEMSG, FNSENTDDEMSGMSG)
{
    BEGINRECV(0, NULL, 0);

    /*
     * A DDE message may have been sent via CallWindowProc due to subclassing.
     * Since IsWindowUnicode() cannot properly tell what proc a message will
     * ultimately reach, we make sure that the Ansi/Unicode form of any
     * WM_DDE_EXECUTE data is correct for the documented convention and
     * translate it as necessary.
     */
    if (CALLDATA(msg) == WM_DDE_EXECUTE) {
        BOOL fHandleChanged;

        fHandleChanged = FixupDdeExecuteIfNecessary((HGLOBAL *)PCALLDATA(lParam),
                CALLDATA(fIsUnicodeProc) &&
                IsWindowUnicode((HWND)CALLDATA(wParam)));
        /*
         * NOTE:
         * If the app didn't allocate this DDE memory GMEM_MOVEABLE,
         * the fixup may require the handle value to change.
         * If this happens things will fall appart when the other side
         * or the tracking layer tries to free the old handle value.
         */
        UserAssert(!fHandleChanged);
    }
    retval = (ULONG_PTR)CALLPROC(CALLDATA(xpfnProc))(
            CALLDATA(pwnd),
            CALLDATA(msg),
            CALLDATA(wParam),
            CALLDATA(lParam),
            CALLDATA(xParam));

    ENDRECV();
}
#endif // RECVSIDE

/**************************************************************************\
* fnDWORD
*
* 22-Jul-1991 mikeke    Created
\**************************************************************************/

typedef struct _FNDWORDMSG {
    PWND pwnd;
    UINT msg;
    WPARAM wParam;
    LPARAM lParam;
    ULONG_PTR xParam;
    PROC xpfnProc;
} FNDWORDMSG;

#ifdef SENDSIDE
SMESSAGECALL(DWORD)
{
    SETUPPWND(FNDWORD)

    UNREFERENCED_PARAMETER(dwSCMSFlags);
    UNREFERENCED_PARAMETER(psms);

    BEGINSEND(FNDWORD)

        MSGDATA()->pwnd = pwndClient;
        MSGDATA()->msg = msg;
        MSGDATA()->wParam = wParam;
        MSGDATA()->lParam = lParam;
        MSGDATA()->xParam = xParam;
        MSGDATA()->xpfnProc = xpfnProc;

        LOCKPWND();
        MAKECALL(FNDWORD);
        UNLOCKPWND();
        CHECKRETURN();

    TRACECALLBACKMSG("SfnDWORD");
    ENDSEND(LRESULT,0);
}
#endif // SENDSIDE

#ifdef RECVSIDE
RECVCALL(fnDWORD, FNDWORDMSG)
{
    BEGINRECV(0, NULL, 0);

    retval = (ULONG_PTR)CALLPROC(CALLDATA(xpfnProc))(
            CALLDATA(pwnd),
            CALLDATA(msg),
            CALLDATA(wParam),
            CALLDATA(lParam),
            CALLDATA(xParam));

    ENDRECV();
}
#endif // RECVSIDE

/**************************************************************************\
* fnNCDESTROY
*
* 07-24-00 MHamid    Created
\**************************************************************************/

typedef struct _FNNCDESTROYMSG {
    PWND pwnd;
    UINT msg;
    WPARAM wParam;
    LPARAM lParam;
    ULONG_PTR xParam;
    PROC xpfnProc;
} FNNCDESTROYMSG;

#ifdef SENDSIDE
SMESSAGECALL(NCDESTROY)
{
    SETUPPWND(FNNCDESTROY)

    UNREFERENCED_PARAMETER(dwSCMSFlags);
    UNREFERENCED_PARAMETER(psms);

    BEGINSEND(FNNCDESTROY)

        MSGDATA()->pwnd = pwndClient;
        MSGDATA()->msg = msg;
        MSGDATA()->wParam = wParam;
        MSGDATA()->lParam = lParam;
        MSGDATA()->xParam = xParam;
        MSGDATA()->xpfnProc = xpfnProc;

        LOCKPWND();
        MAKECALL(FNNCDESTROY);
        pwnd->pActCtx = NULL;
        UNLOCKPWND();
        CHECKRETURN();

    TRACECALLBACKMSG("SfnNCDESTROY");
    ENDSEND(LRESULT, 0);
}
#endif // SENDSIDE

#ifdef RECVSIDE
RECVCALL(fnNCDESTROY, FNNCDESTROYMSG)
{
    BEGINRECV(0, NULL, 0);

    retval = (ULONG_PTR)CALLPROC(CALLDATA(xpfnProc))(
            CALLDATA(pwnd),
            CALLDATA(msg),
            CALLDATA(wParam),
            CALLDATA(lParam),
            CALLDATA(xParam));

    if (CALLDATA(pwnd)->pActCtx) {
        RtlReleaseActivationContext(CALLDATA(pwnd)->pActCtx);
    }

#ifdef LAME_BUTTON
    if (GetProp(HW(CALLDATA(pwnd)), MAKEINTATOM(gatomLameButton)) != NULL) {
        UserLocalFree(GetProp(HW(CALLDATA(pwnd)), MAKEINTATOM(gatomLameButton)));
        SetProp(HW(CALLDATA(pwnd)), MAKEINTATOM(gatomLameButton), NULL);
    }
#endif // LAME_BUTTON

    ENDRECV();
}
#endif // RECVSIDE

/**************************************************************************\
* fnINWPARAMCHAR
*
* 22-Jul-1991 mikeke    Created
\**************************************************************************/

typedef struct _FNINWPARAMCHARMSG {
    PWND pwnd;
    UINT msg;
    WPARAM wParam;
    LPARAM lParam;
    ULONG_PTR xParam;
    PROC xpfnProc;
} FNINWPARAMCHARMSG;

#ifdef SENDSIDE
SMESSAGECALL(INWPARAMCHAR)
{
    SETUPPWND(FNINWPARAMCHAR)

    UNREFERENCED_PARAMETER(psms);

    BEGINSEND(FNINWPARAMCHAR)

        MSGDATA()->pwnd = pwndClient;
        MSGDATA()->msg = msg;

        /*
         * WM_CHARTOITEM has an index in the hi-word of wParam
         */
        if (dwSCMSFlags & SCMS_FLAGS_ANSI) {
            if (msg == WM_CHARTOITEM || msg == WM_MENUCHAR) {
                WPARAM dwT = wParam & 0xFFFF;                // mask of caret pos
                RtlWCSMessageWParamCharToMB(msg, &dwT);     // convert key portion
                UserAssert(HIWORD(dwT) == 0);
                wParam = MAKELONG(LOWORD(dwT),HIWORD(wParam));  // rebuild pos & key wParam
            } else {
                RtlWCSMessageWParamCharToMB(msg, &wParam);
            }
        }

        MSGDATA()->wParam = wParam;

        MSGDATA()->lParam = lParam;
        MSGDATA()->xParam = xParam;
        MSGDATA()->xpfnProc = xpfnProc;

        LOCKPWND();
        MAKECALL(FNDWORD);
        UNLOCKPWND();
        CHECKRETURN();

    TRACECALLBACKMSG("SfnINWPARAMCHAR");
    ENDSEND(LRESULT,0);
}
#endif // SENDSIDE

#ifdef RECVSIDE
/*
 * The fnDWORD routine is used for this message
 */
#endif // RECVSIDE

/**************************************************************************\
* fnINWPARAMDBCSCHAR
*
* 12-Feb-1996 hideyukn   Created
\**************************************************************************/

typedef struct _FNINWPARAMDBCSCHARMSG {
    PWND pwnd;
    UINT msg;
    WPARAM wParam;
    LPARAM lParam;
    ULONG_PTR xParam;
    PROC xpfnProc;
    BOOL  bAnsi;
} FNINWPARAMDBCSCHARMSG;

#ifdef SENDSIDE
SMESSAGECALL(INWPARAMDBCSCHAR)
{
    SETUPPWND(FNINWPARAMDBCSCHAR)

    UNREFERENCED_PARAMETER(psms);

    BEGINSEND(FNINWPARAMDBCSCHAR)

        MSGDATA()->pwnd  = pwndClient;
        MSGDATA()->msg   = msg;
        MSGDATA()->bAnsi = dwSCMSFlags & SCMS_FLAGS_ANSI;

        /*
         * wParam in WM_CHAR/EM_SETPASSWORDCHAR should be converted to ANSI
         * ,if target is ANSI.
         */
        if (dwSCMSFlags & SCMS_FLAGS_ANSI) {
            RtlWCSMessageWParamCharToMB(msg, &wParam);
        }

        MSGDATA()->wParam = wParam;
        MSGDATA()->lParam = lParam;
        MSGDATA()->xParam = xParam;
        MSGDATA()->xpfnProc = xpfnProc;

        LOCKPWND();
        MAKECALL(FNINWPARAMDBCSCHAR);
        UNLOCKPWND();
        CHECKRETURN();

    TRACECALLBACKMSG("SfnINWPARAMDBCSCHAR");
    ENDSEND(LRESULT,0);
}
#endif // SENDSIDE

#ifdef RECVSIDE
RECVCALL(fnINWPARAMDBCSCHAR, FNINWPARAMDBCSCHARMSG)
{
    BOOL bAnsiWndProc;

    BEGINRECV(0,NULL,0);

        bAnsiWndProc = CALLDATA(bAnsi);

        if (bAnsiWndProc) {

            PKERNEL_MSG  pmsgDbcsCB = GetCallBackDbcsInfo();
            WPARAM wParam         = pmsg->wParam;
            BOOL  bDbcsMessaging = FALSE;

            //
            // Check wParam has Dbcs character or not..
            //
            if (IS_DBCS_MESSAGE(pmsg->wParam)) {

                if (pmsg->wParam & WMCR_IR_DBCSCHAR) {

                    //
                    // This is reply for WM_IME_REPORT:IR_DBCSCHAR, then
                    // We send DBCS chararcter at one time...
                    // (Do not need to send twice for DBCS LeadByte and TrailByte).
                    //
                    // Validation for wParam.. (mask off the secret bit).
                    //
                    wParam = (pmsg->wParam & 0x0000FFFF);

                } else {

                    //
                    // Mark the wParam keeps Dbcs character..
                    //
                    bDbcsMessaging = TRUE;

                    //
                    // Backup current message. this backupped message will be used
                    // when Apps peek (or get) message from thier WndProc.
                    // (see GetMessageA(), PeekMessageA()...)
                    //
                    // pmsgDbcsCB->hwnd    = HW(pmsg->pwnd);
                    // pmsgDbcsCB->message = pmsg->msg;
                    // pmsgDbcsCB->wParam  = pmsg->wParam;
                    // pmsgDbcsCB->lParam  = pmsg->lParam;
                    // pmsgDbcsCB->time    = pmsg->time;
                    // pmsgDbcsCB->pt      = pmsg->pt;
                    //
                    COPY_MSG_TO_KERNELMSG(pmsgDbcsCB,(PMSG)pmsg);

                    //
                    // pwnd should be converted to hwnd.
                    //
                    pmsgDbcsCB->hwnd = HW(pmsg->pwnd);

                    //
                    // DbcsLeadByte will be sent below soon, we just need DbcsTrailByte
                    // for further usage..
                    //
                    pmsgDbcsCB->wParam = (pmsg->wParam & 0x000000FF);

                    //
                    // Pass the LeadingByte of the DBCS character to an ANSI WndProc.
                    //
                    wParam = (pmsg->wParam & 0x0000FF00) >> 8;
                }
            }

            //
            // Forward Dbcs LeadingByte or Sbcs character to Apps WndProc.
            //
            retval = CALLPROC(CALLDATA(xpfnProc))(
                    CALLDATA(pwnd),
                    CALLDATA(msg),
                    wParam,
                    CALLDATA(lParam),
                    CALLDATA(xParam) );

            //
            // Check we need to send trailing byte or not, if the wParam has Dbcs character.
            //
            if (bDbcsMessaging && pmsgDbcsCB->wParam) {

                //
                // If an app didn't peek (or get) the trailing byte from within
                // WndProc, and then pass the DBCS TrailingByte to the ANSI WndProc here
                // pmsgDbcsCB->wParam has DBCS TrailingByte here.. see above..
                //
                wParam = KERNEL_WPARAM_TO_WPARAM(pmsgDbcsCB->wParam);

                //
                // Invalidate cached message.
                //
                pmsgDbcsCB->wParam = 0;

                retval = CALLPROC(CALLDATA(xpfnProc))(
                        CALLDATA(pwnd),
                        CALLDATA(msg),
                        wParam,
                        CALLDATA(lParam),
                        CALLDATA(xParam) );
            } else {

                //
                // If an app called Get/PeekMessageA from its
                // WndProc, do not do anything.
                //
            }

        } else {

            //
            // Only LOWORD of WPARAM is valid for WM_CHAR....
            //  (Mask off DBCS messaging information.)
            //
            pmsg->wParam &= 0x0000FFFF;

            retval = (ULONG_PTR)CALLPROC(pmsg->xpfnProc)(
                    pmsg->pwnd,
                    pmsg->msg,
                    pmsg->wParam,
                    pmsg->lParam,
                    pmsg->xParam);
        }

    ENDRECV();
}
#endif // RECVSIDE

/**************************************************************************\
* yyy
*
* 22-Jul-1991 mikeke    Created
\**************************************************************************/

typedef struct _FNINOUTDRAGMSG {
    PWND pwnd;
    UINT msg;
    WPARAM wParam;
    ULONG_PTR xParam;
    PROC xpfnProc;
    DROPSTRUCT ds;
} FNINOUTDRAGMSG;

#ifdef SENDSIDE
SMESSAGECALL(INOUTDRAG)
{
    SETUPPWND(FNINOUTDRAG)

    UNREFERENCED_PARAMETER(dwSCMSFlags);

    BEGINSEND(FNINOUTDRAG)

        LPDROPSTRUCT pds = (LPDROPSTRUCT)lParam;

        MSGDATA()->pwnd = pwndClient;
        MSGDATA()->msg = msg;
        MSGDATA()->wParam = wParam;
        MSGDATA()->ds = *pds;
        MSGDATA()->xParam = xParam;
        MSGDATA()->xpfnProc = xpfnProc;

        LOCKPWND();
        MAKECALL(FNINOUTDRAG);
        UNLOCKPWND();
        CHECKRETURN();

        BEGINCOPYOUT()
            OUTSTRUCT(pds, DROPSTRUCT);
        ENDCOPYOUT()

    TRACECALLBACKMSG("SfnINOUTDRAG");
    ENDSEND(LRESULT,0);
}
#endif // SENDSIDE

#ifdef RECVSIDE
RECVCALL(fnINOUTDRAG, FNINOUTDRAGMSG)
{
    BEGINRECV(0, &pmsg->ds, sizeof(pmsg->ds));

    retval = (ULONG_PTR)CALLPROC(pmsg->xpfnProc)(
            pmsg->pwnd,
            pmsg->msg,
            pmsg->wParam,
            &pmsg->ds,
            pmsg->xParam);

    ENDRECV();
}
#endif // RECVSIDE

/**************************************************************************\
* fnGETTEXTLENGTHS
*
* Gets the Unicode & ANSI lengths
* Internally, lParam pints to the ANSI length in bytes and the return value
* is the Unicode length in bytes.  However, the public definition is maintained
* on the  client side, where lParam is not used and either ANSI or Unicode is
* returned.
*
* 10-Feb-1992 IanJa    Created
\**************************************************************************/

typedef struct _FNGETTEXTLENGTHSMSG {
    PWND pwnd;
    UINT msg;
    WPARAM wParam;
    ULONG_PTR xParam;
    PROC xpfnProc;
} FNGETTEXTLENGTHSMSG;

#ifdef SENDSIDE
SMESSAGECALL(GETTEXTLENGTHS)
{
    SETUPPWND(FNGETTEXTLENGTHS)

    UNREFERENCED_PARAMETER(lParam);
    UNREFERENCED_PARAMETER(dwSCMSFlags);
    UNREFERENCED_PARAMETER(psms);

    BEGINSEND(FNGETTEXTLENGTHS)

        MSGDATA()->pwnd = pwndClient;
        MSGDATA()->msg = msg;
        MSGDATA()->wParam = wParam;
        MSGDATA()->xParam = xParam;
        MSGDATA()->xpfnProc = xpfnProc;

        LOCKPWND();
        MAKECALL(FNGETTEXTLENGTHS);
        UNLOCKPWND();
        CHECKRETURN();

        /*
         * ANSI client wndproc returns us cbANSI.  We want cchUnicode,
         * so we guess cchUnicode = cbANSI. (It may be less if
         * multi-byte characters are involved, but it will never be more).
         * Save cbANSI in *lParam in case the server ultimately returns
         * the length to an ANSI caller.
         *
         * Unicode client wndproc returns us cchUnicode.  If we want to know
         * cbANSI, we must guess how many 'ANSI' chars we would need.
         * We guess cbANSI = cchUnicode * 2. (It may be this much if all
         * 'ANSI' characters are multi-byte, but it will never be more).
         *
         * Return cchUnicode (server code is all Unicode internally).
         * Put cbANSI in *lParam to be passed along within the server in case
         * we ultimately need to return it to the client.
         *
         * NOTE: this will sometimes cause text lengths to be misreported
         * up to twice the real length, but that is expected to be harmless.
         * This will only * happen if an app sends WM_GETcode TEXTLENGTH to a
         * window with an ANSI client-side wndproc, or a ANSI WM_GETTEXTLENGTH
         * is sent to a Unicode client-side wndproc.
         */

    TRACECALLBACKMSG("SfnGETTEXTLENGTHS");
    ENDSEND(LRESULT,0);
}
#endif // SENDSIDE

#ifdef RECVSIDE
RECVCALL(fnGETTEXTLENGTHS, FNGETTEXTLENGTHSMSG)
{
    BEGINRECV(0, NULL, 0);

    retval = (ULONG_PTR)CALLPROC(pmsg->xpfnProc)(
            pmsg->pwnd,
            pmsg->msg,
            pmsg->wParam,
            0,                      // so we don't pass &cbAnsi to apps
            pmsg->xParam);

    ENDRECV();
}
#endif // RECVSIDE

/**************************************************************************\
* yyy
*
* 22-Jul-1991 mikeke    Created
\**************************************************************************/

typedef struct _FNINLPCREATESTRUCTMSG {
    CAPTUREBUF CaptureBuf;
    PWND pwnd;
    UINT msg;
    WPARAM wParam;
    LPARAM lParam;
    CREATESTRUCT cs;
    ULONG_PTR xParam;
    PROC xpfnProc;
} FNINLPCREATESTRUCTMSG;

#ifdef SENDSIDE
SMESSAGECALL(INLPCREATESTRUCT)
{
    PCREATESTRUCTEX pcreatestruct = (PCREATESTRUCTEX)lParam;
    DWORD cbName = 0, cbClass = 0;
    DWORD cCapture = 0;
    BOOL fAnsiReceiver = (dwSCMSFlags & SCMS_FLAGS_ANSI);

    SETUPPWND(FNINLPCREATESTRUCT)

    UNREFERENCED_PARAMETER(psms);

    /*
     * Compute ANSI capture lengths.  Don't capture if
     * the strings are in the client's address space.
     */
    if (pcreatestruct) {
        if (pcreatestruct->cs.lpszName &&
                ((BOOL)pcreatestruct->strName.bAnsi != fAnsiReceiver ||
                IS_SYSTEM_ADDRESS((PVOID)pcreatestruct->cs.lpszName))) {
            CALC_SIZE_IN(cbName, &pcreatestruct->strName);
            cCapture++;
        }
        if (IS_PTR(pcreatestruct->cs.lpszClass) &&
                ((BOOL)pcreatestruct->strClass.bAnsi != fAnsiReceiver ||
                IS_SYSTEM_ADDRESS((PVOID)pcreatestruct->cs.lpszClass))) {
            CALC_SIZE_IN(cbClass, &pcreatestruct->strClass);
            cCapture++;
        }
    }

    BEGINSENDCAPTURE(FNINLPCREATESTRUCT, cCapture, cbName + cbClass, TRUE)

        MSGDATA()->pwnd = pwndClient;
        MSGDATA()->msg = msg;
        MSGDATA()->wParam = wParam;
        MSGDATA()->lParam = lParam;  // this could be NULL in WOW apps!

        if (pcreatestruct != NULL) {
            MSGDATA()->cs = pcreatestruct->cs;

            // Make it a "Large" copy because it could be an Edit control
            if (cbName) {
                if (!pcreatestruct->strName.bAnsi) {
                    WORD wOrdinal;

                    try {
                        wOrdinal = *(PWORD)pcreatestruct->cs.lpszName;
                    } except (W32ExceptionHandler(TRUE, RIP_WARNING)) {
                        goto errorexit;
                    }
                    if (wOrdinal == 0xffff) {

                        /*
                         * Copy out an ordinal of the form 0xffff, ID.
                         * If the receiver is ANSI, skip the first 0xff.
                         */
                        if (fAnsiReceiver) {
                            if (!NT_SUCCESS(CaptureCallbackData(&mp->CaptureBuf,
                                    (PBYTE)pcreatestruct->cs.lpszName + 1,
                                    3, (PVOID *)&mp->cs.lpszName)))
                                goto errorexit;
                        } else {
                            if (!NT_SUCCESS(CaptureCallbackData(&mp->CaptureBuf,
                                    (PBYTE)pcreatestruct->cs.lpszName,
                                    4, (PVOID *)&mp->cs.lpszName)))
                                goto errorexit;
                        }
                    } else if (fAnsiReceiver) {
                        LARGECOPYSTRINGLPWSTRA(&pcreatestruct->strName, cs.lpszName);
                    } else {
                        LARGECOPYSTRINGLPWSTR(&pcreatestruct->strName, cs.lpszName);
                    }
                } else {
                    BYTE bOrdinal;

                    try {
                        bOrdinal = *(PBYTE)pcreatestruct->cs.lpszName;
                    } except (W32ExceptionHandler(TRUE, RIP_WARNING)) {
                        goto errorexit;
                    }
                    if (bOrdinal == 0xff) {

                        /*
                         * Copy out an ordinal of the form 0xff, ID.
                         * If the receiver is UNICODE, expand the 0xff to 0xffff.
                         */
                        if (fAnsiReceiver) {
                            if (!NT_SUCCESS(CaptureCallbackData(&mp->CaptureBuf,
                                    (PBYTE)pcreatestruct->cs.lpszName,
                                    3, (PVOID *)&mp->cs.lpszName)))
                                goto errorexit;
                        } else {
                            DWORD dwOrdinal;

                            try {
                                dwOrdinal = MAKELONG(0xffff,
                                        (*(DWORD UNALIGNED *)pcreatestruct->cs.lpszName >> 8));
                            } except (W32ExceptionHandler(TRUE, RIP_WARNING)) {
                                goto errorexit;
                            }
                            if (!NT_SUCCESS(CaptureCallbackData(&mp->CaptureBuf,
                                    &dwOrdinal,
                                    4, (PVOID *)&mp->cs.lpszName)))
                                goto errorexit;
                        }
                    } else if (fAnsiReceiver) {
                        LARGECOPYSTRINGLPSTR(&pcreatestruct->strName, cs.lpszName);
                    } else {
                        LARGECOPYSTRINGLPSTRW(&pcreatestruct->strName, cs.lpszName);
                    }
                }
            }
            if (cbClass) {
                if (!pcreatestruct->strClass.bAnsi) {
                    if (fAnsiReceiver) {
                        LARGECOPYSTRINGLPWSTRA(&pcreatestruct->strClass, cs.lpszClass);
                    } else {
                        LARGECOPYSTRINGLPWSTR(&pcreatestruct->strClass, cs.lpszClass);
                    }
                } else {
                    if (fAnsiReceiver) {
                        LARGECOPYSTRINGLPSTR(&pcreatestruct->strClass, cs.lpszClass);
                    } else {
                        LARGECOPYSTRINGLPSTRW(&pcreatestruct->strClass, cs.lpszClass);
                    }
                }
            }
        }

        MSGDATA()->xParam = xParam;
        MSGDATA()->xpfnProc = xpfnProc;

        LOCKPWND();
        MAKECALLCAPTURE(FNINLPCREATESTRUCT);
        UNLOCKPWND();
        CHECKRETURN();

    TRACECALLBACKMSG("SfnINLPCREATESTRUCT");
    ENDSENDCAPTURE(LRESULT,0);
}
#endif // SENDSIDE

#ifdef RECVSIDE
RECVCALL(fnINLPCREATESTRUCT, FNINLPCREATESTRUCTMSG)
{
    LPARAM lParam;

    BEGINRECV(0, NULL, 0);
    FIXUPPOINTERS();

    if (pmsg->lParam != 0) {
        if ((ULONG_PTR)pmsg->cs.lpszName > gHighestUserAddress)
            pmsg->cs.lpszName = REBASEPTR(pmsg->pwnd, pmsg->cs.lpszName);
        if ((ULONG_PTR)pmsg->cs.lpszClass > gHighestUserAddress)
            pmsg->cs.lpszClass = REBASEPTR(pmsg->pwnd, pmsg->cs.lpszClass);
        lParam = (LPARAM)&pmsg->cs;

        if ((pmsg->cs.lpCreateParams != NULL) &&
            (TestWF(pmsg->pwnd, WEFMDICHILD))) {
               // Note -- do not test the flag in cs.dwExStyle -- it gets zapped for Old UI apps, like Quicken
            ((LPMDICREATESTRUCT)(pmsg->cs.lpCreateParams))->szClass = pmsg->cs.lpszClass;
            ((LPMDICREATESTRUCT)(pmsg->cs.lpCreateParams))->szTitle = pmsg->cs.lpszName;
        }
    } else
        lParam = 0;


    retval = (ULONG_PTR)CALLPROC(pmsg->xpfnProc)(
            pmsg->pwnd,
            pmsg->msg,
            pmsg->wParam,
            lParam,
            pmsg->xParam);

    ENDRECV();
}
#endif // RECVSIDE

/**************************************************************************\
* fnINLPMDICREATESTRUCT
*
* 22-Jul-1991 mikeke    Created
\**************************************************************************/

typedef struct _FNINLPMDICREATESTRUCTMSG {
    CAPTUREBUF CaptureBuf;
    PWND pwnd;
    UINT msg;
    WPARAM wParam;
    MDICREATESTRUCT mdics;
    ULONG_PTR xParam;
    PROC xpfnProc;
    int szClass;
    int szTitle;
} FNINLPMDICREATESTRUCTMSG;

#ifdef SENDSIDE
SMESSAGECALL(INLPMDICREATESTRUCT)
{
    PMDICREATESTRUCTEX pmdicreatestruct = (PMDICREATESTRUCTEX)lParam;
    DWORD cbTitle = 0, cbClass = 0;
    DWORD cCapture = 0;
    BOOL fAnsiReceiver = (dwSCMSFlags & SCMS_FLAGS_ANSI);

    SETUPPWND(FNINLPMDICREATESTRUCT)

    UNREFERENCED_PARAMETER(psms);

    /*
     * Compute ANSI capture lengths.  Don't capture if
     * the strings are in the client's address space and
     * are Unicode.
     */
    if (pmdicreatestruct->mdics.szTitle &&
            (IS_SYSTEM_ADDRESS((PVOID)pmdicreatestruct->mdics.szTitle) ||
            ((BOOL)pmdicreatestruct->strTitle.bAnsi != fAnsiReceiver))) {
        CALC_SIZE_IN(cbTitle, &pmdicreatestruct->strTitle);
        cCapture = 1;
    }
    if (IS_PTR(pmdicreatestruct->mdics.szClass) &&
            (IS_SYSTEM_ADDRESS((PVOID)pmdicreatestruct->mdics.szClass) ||
            ((BOOL)pmdicreatestruct->strClass.bAnsi != fAnsiReceiver))) {
        CALC_SIZE_IN(cbClass, &pmdicreatestruct->strClass);
        cCapture++;
    }

    BEGINSENDCAPTURE(FNINLPMDICREATESTRUCT, cCapture, cbTitle + cbClass, TRUE)

        MSGDATA()->pwnd = pwndClient;
        MSGDATA()->msg = msg;
        MSGDATA()->wParam = wParam;
        MSGDATA()->mdics = pmdicreatestruct->mdics;

        if (cbTitle) {
            if (!pmdicreatestruct->strTitle.bAnsi) {
                if (fAnsiReceiver) {
                    LARGECOPYSTRINGLPWSTRA(&pmdicreatestruct->strTitle, mdics.szTitle);
                } else {
                    LARGECOPYSTRINGLPWSTR(&pmdicreatestruct->strTitle, mdics.szTitle);
                }
            } else {
                if (fAnsiReceiver) {
                    LARGECOPYSTRINGLPSTR(&pmdicreatestruct->strTitle, mdics.szTitle);
                } else {
                    LARGECOPYSTRINGLPSTRW(&pmdicreatestruct->strTitle, mdics.szTitle);
                }
            }
        }
        if (cbClass) {
            if (!pmdicreatestruct->strClass.bAnsi) {
                if (fAnsiReceiver) {
                    LARGECOPYSTRINGLPWSTRA(&pmdicreatestruct->strClass, mdics.szClass);
                } else {
                    LARGECOPYSTRINGLPWSTR(&pmdicreatestruct->strClass, mdics.szClass);
                }
            } else {
                if (fAnsiReceiver) {
                    LARGECOPYSTRINGLPSTR(&pmdicreatestruct->strClass, mdics.szClass);
                } else {
                    LARGECOPYSTRINGLPSTRW(&pmdicreatestruct->strClass, mdics.szClass);
                }
            }
        }
        MSGDATA()->xParam = xParam;
        MSGDATA()->xpfnProc = xpfnProc;

        LOCKPWND();
        MAKECALLCAPTURE(FNINLPMDICREATESTRUCT);
        UNLOCKPWND();
        CHECKRETURN();

    TRACECALLBACKMSG("SfnINLPMDICREATESTRUCT");
    ENDSENDCAPTURE(LRESULT,0);
    DBG_UNREFERENCED_PARAMETER(wParam);
}
#endif // SENDSIDE

#ifdef RECVSIDE
RECVCALL(fnINLPMDICREATESTRUCT, FNINLPMDICREATESTRUCTMSG)
{
    BEGINRECV(0, NULL, 0);
    FIXUPPOINTERS();

    retval = (ULONG_PTR)CALLPROC(pmsg->xpfnProc)(
            pmsg->pwnd,
            pmsg->msg,
            pmsg->wParam,
            &pmsg->mdics,
            pmsg->xParam);

    ENDRECV();
}
#endif // RECVSIDE

/**************************************************************************\
* fnINPAINTCLIPBRD
*
* lParam is a supposed to be a Global Handle to DDESHARE memory.
*
* 22-Jul-1991 johnc     Created
\**************************************************************************/

typedef struct _FNINPAINTCLIPBRDMSG {
    PWND pwnd;
    UINT msg;
    WPARAM wParam;
    PAINTSTRUCT ps;
    ULONG_PTR xParam;
    PROC xpfnProc;
} FNINPAINTCLIPBRDMSG;

#ifdef SENDSIDE
SMESSAGECALL(INPAINTCLIPBRD)
{
    PWND pwndDCOwner;

    /*
     * We need to check clipboard access rights because the app could
     * get the clipboard owner's window handle by enumeration etc and
     * send this message
     */

    SETUPPWND(FNINPAINTCLIPBRD)

    UNREFERENCED_PARAMETER(dwSCMSFlags);
    UNREFERENCED_PARAMETER(psms);

    BEGINSEND(FNINPAINTCLIPBRD)

        LPPAINTSTRUCT pps = (LPPAINTSTRUCT)lParam;

        if (RtlAreAllAccessesGranted(PpiCurrent()->amwinsta,
                WINSTA_ACCESSCLIPBOARD)) {

            MSGDATA()->pwnd = pwndClient;
            MSGDATA()->msg = msg;
            MSGDATA()->wParam = wParam;
            MSGDATA()->ps = *pps;
            MSGDATA()->xParam = xParam;
            MSGDATA()->xpfnProc = xpfnProc;

            /*
             * We can't just set the owner of the DC and pass the original DC
             * because currently GDI won't let you query the current owner
             * and we don't know if it is a public or privately owned DC
             */
            pwndDCOwner = _WindowFromDC(pps->hdc);
            MSGDATA()->ps.hdc = _GetDC(pwndDCOwner);

            LOCKPWND();
            MAKECALL(FNINPAINTCLIPBRD);
            UNLOCKPWND();
            CHECKRETURN();

            _ReleaseDC(MSGDATA()->ps.hdc);
        }

    TRACECALLBACKMSG("SfnINPAINTCLIPBRD");
    ENDSEND(LRESULT,0);
}
#endif // SENDSIDE

#ifdef RECVSIDE
RECVCALL(fnINPAINTCLIPBRD, FNINPAINTCLIPBRDMSG)
{
    LPPAINTSTRUCT lpps;

    BEGINRECV(0, NULL, 0);

    lpps = (LPPAINTSTRUCT)GlobalAlloc(GMEM_FIXED | GMEM_DDESHARE, sizeof(PAINTSTRUCT));
    UserAssert(lpps);

    if (lpps) {
        *lpps = pmsg->ps;

        UserAssert(lpps->hdc);

        retval = (ULONG_PTR)CALLPROC(pmsg->xpfnProc)(
                pmsg->pwnd,
                pmsg->msg,
                pmsg->wParam,
                lpps,
                pmsg->xParam);

        GlobalFree((HGLOBAL)lpps);
    }

    ENDRECV();
}
#endif // RECVSIDE

/**************************************************************************\
* fnINSIZECLIPBRD
*
* lParam is a supposed to be a Global Handle to DDESHARE memory.
*
* 11-Jun-1992 sanfords  Created
\**************************************************************************/

typedef struct _FNINSIZECLIPBRDMSG {
    PWND pwnd;
    UINT msg;
    WPARAM wParam;
    RECT rc;
    ULONG_PTR xParam;
    PROC xpfnProc;
} FNINSIZECLIPBRDMSG;

#ifdef SENDSIDE
SMESSAGECALL(INSIZECLIPBRD)
{
    /*
     * We need to check clipboard access rights because the app could
     * get the clipboard owner's window handle by enumeration etc and
     * send this message
     */

    SETUPPWND(FNINSIZECLIPBRD)

    UNREFERENCED_PARAMETER(dwSCMSFlags);
    UNREFERENCED_PARAMETER(psms);

    BEGINSEND(FNINSIZECLIPBRD)

        LPRECT prc = (LPRECT)lParam;

        if (RtlAreAllAccessesGranted(PpiCurrent()->amwinsta,
                WINSTA_ACCESSCLIPBOARD)) {

            MSGDATA()->pwnd = pwndClient;
            MSGDATA()->msg = msg;
            MSGDATA()->wParam = wParam;
            MSGDATA()->rc = *prc;
            MSGDATA()->xParam = xParam;
            MSGDATA()->xpfnProc = xpfnProc;

            LOCKPWND();
            MAKECALL(FNINSIZECLIPBRD);
            UNLOCKPWND();
            CHECKRETURN();
        }

    TRACECALLBACKMSG("SfnINSIZECLIPBRD");
    ENDSEND(LRESULT,0);
}
#endif // SENDSIDE

#ifdef RECVSIDE
RECVCALL(fnINSIZECLIPBRD, FNINSIZECLIPBRDMSG)
{
    LPRECT lprc;

    BEGINRECV(0, NULL, 0);

    lprc = (LPRECT)GlobalAlloc(GMEM_FIXED | GMEM_DDESHARE, sizeof(RECT));
    UserAssert(lprc);

    if (lprc) {
        *lprc = pmsg->rc;

        retval = (ULONG_PTR)CALLPROC(pmsg->xpfnProc)(
                pmsg->pwnd,
                pmsg->msg,
                pmsg->wParam,
                lprc,
                pmsg->xParam);

        GlobalFree((HGLOBAL)lprc);
    }

    ENDRECV();
}
#endif // RECVSIDE


/**************************************************************************\
* fnINDESTROYCLIPBRD
*
* Special handler so we can call ClientEmptyClipboard on client
*
* 01-16-93 scottlu  Created
\**************************************************************************/

typedef struct _FNINDESTROYCLIPBRDMSG {
    PWND pwnd;
    UINT msg;
    WPARAM wParam;
    LPARAM lParam;
    ULONG_PTR xParam;
    PROC xpfnProc;
} FNINDESTROYCLIPBRDMSG;

#ifdef SENDSIDE
SMESSAGECALL(INDESTROYCLIPBRD)
{
    SETUPPWND(FNINDESTROYCLIPBRD)

    UNREFERENCED_PARAMETER(dwSCMSFlags);
    UNREFERENCED_PARAMETER(psms);

    BEGINSEND(FNINDESTROYCLIPBRD)

        MSGDATA()->pwnd = pwndClient;
        MSGDATA()->msg = msg;
        MSGDATA()->wParam = wParam;
        MSGDATA()->lParam = lParam;
        MSGDATA()->xParam = xParam;
        MSGDATA()->xpfnProc = xpfnProc;

        LOCKPWND();
        MAKECALL(FNINDESTROYCLIPBRD);
        UNLOCKPWND();
        CHECKRETURN();

    TRACECALLBACKMSG("SfnINDESTROYCLIPBRD");
    ENDSEND(LRESULT,0);
}
#endif // SENDSIDE

#ifdef RECVSIDE
RECVCALL(fnINDESTROYCLIPBRD, FNINDESTROYCLIPBRDMSG)
{
    void ClientEmptyClipboard(void);

    BEGINRECV(0, NULL, 0);

    retval = (ULONG_PTR)CALLPROC(pmsg->xpfnProc)(
            pmsg->pwnd,
            pmsg->msg,
            pmsg->wParam,
            pmsg->lParam,
            pmsg->xParam);

    /*
     * Now empty the client side clipboard cache.
     * Don't do this if this is a 16bit app.  We don't want to clear out the
     * clipboard just because one app is going away.  All of the 16bit apps
     * share one clipboard.
     */
    if ((GetClientInfo()->CI_flags & CI_16BIT) == 0) {
        ClientEmptyClipboard();
    }

    ENDRECV();
}
#endif // RECVSIDE

/**************************************************************************\
* yyy
*
* 22-Jul-1991 mikeke    Created
\**************************************************************************/

typedef struct _FNINOUTLPSCROLLINFOMSG {
    PWND pwnd;
    UINT msg;
    WPARAM wParam;
    SCROLLINFO info;
    ULONG_PTR xParam;
    PROC xpfnProc;
} FNINOUTLPSCROLLINFOMSG;

#ifdef SENDSIDE
SMESSAGECALL(INOUTLPSCROLLINFO)
{
    SETUPPWND(FNINOUTLPSCROLLINFO)

    UNREFERENCED_PARAMETER(dwSCMSFlags);

    BEGINSEND(FNINOUTLPSCROLLINFO)

        LPSCROLLINFO pinfo = (LPSCROLLINFO)lParam;

        MSGDATA()->pwnd = pwndClient;
        MSGDATA()->msg = msg;
        MSGDATA()->wParam = wParam;
        MSGDATA()->info = *pinfo;
        MSGDATA()->xParam = xParam;
        MSGDATA()->xpfnProc = xpfnProc;

        LOCKPWND();
        MAKECALL(FNINOUTLPSCROLLINFO);
        UNLOCKPWND();
        CHECKRETURN();

        BEGINCOPYOUT()
            OUTSTRUCT(pinfo, SCROLLINFO);
        ENDCOPYOUT()

    TRACECALLBACKMSG("SfnINOUTLPSCROLLINFO");
    ENDSEND(LRESULT,0);
}
#endif // SENDSIDE

#ifdef RECVSIDE
RECVCALL(fnINOUTLPSCROLLINFO, FNINOUTLPSCROLLINFOMSG)
{
    BEGINRECV(0, &pmsg->info, sizeof(pmsg->info));

    retval = (ULONG_PTR)CALLPROC(pmsg->xpfnProc)(
            pmsg->pwnd,
            pmsg->msg,
            pmsg->wParam,
            &pmsg->info,
            pmsg->xParam);

    ENDRECV();
}
#endif // RECVSIDE

/**************************************************************************\
* yyy
*
* 22-Jul-1991 mikeke    Created
\**************************************************************************/

typedef struct _FNINOUTLPPOINT5MSG {
    PWND pwnd;
    UINT msg;
    WPARAM wParam;
    POINT5 point5;
    ULONG_PTR xParam;
    PROC xpfnProc;
} FNINOUTLPPOINT5MSG;

#ifdef SENDSIDE
SMESSAGECALL(INOUTLPPOINT5)
{
    SETUPPWND(FNINOUTLPPOINT5)

    UNREFERENCED_PARAMETER(dwSCMSFlags);

    BEGINSEND(FNINOUTLPPOINT5)

        LPPOINT5 ppoint5 = (LPPOINT5)lParam;

        MSGDATA()->pwnd = pwndClient;
        MSGDATA()->msg = msg;
        MSGDATA()->wParam = wParam;
        MSGDATA()->point5 = *ppoint5;
        MSGDATA()->xParam = xParam;
        MSGDATA()->xpfnProc = xpfnProc;

        LOCKPWND();
        MAKECALL(FNINOUTLPPOINT5);
        UNLOCKPWND();
        CHECKRETURN();

        BEGINCOPYOUT()
             OUTSTRUCT(ppoint5, POINT5);
        ENDCOPYOUT()

    TRACECALLBACKMSG("SfnINOUTLPPOINT5");
    ENDSEND(LRESULT,0);
}
#endif // SENDSIDE

#ifdef RECVSIDE
RECVCALL(fnINOUTLPPOINT5, FNINOUTLPPOINT5MSG)
{
    BEGINRECV(0, &pmsg->point5, sizeof(POINT5));

    retval = (ULONG_PTR)CALLPROC(pmsg->xpfnProc)(
            pmsg->pwnd,
            pmsg->msg,
            pmsg->wParam,
            &pmsg->point5,
            pmsg->xParam);

    ENDRECV();
}
#endif // RECVSIDE

/**************************************************************************\
* yyy
*
* 22-Jul-1991 mikeke    Created
\**************************************************************************/

typedef struct _FNINOUTLPRECTMSG {
    PWND pwnd;
    UINT msg;
    WPARAM wParam;
    RECT rect;
    ULONG_PTR xParam;
    PROC xpfnProc;
} FNINOUTLPRECTMSG;

#ifdef SENDSIDE
SMESSAGECALL(INOUTLPRECT)
{
    SETUPPWND(FNINOUTLPRECT)

    UNREFERENCED_PARAMETER(dwSCMSFlags);

    BEGINSEND(FNINOUTLPRECT)

        LPRECT prect = (LPRECT)lParam;

        MSGDATA()->pwnd = pwndClient;
        MSGDATA()->msg = msg;
        MSGDATA()->wParam = wParam;
        MSGDATA()->rect = *prect;
        MSGDATA()->xParam = xParam;
        MSGDATA()->xpfnProc = xpfnProc;

        LOCKPWND();
        MAKECALL(FNINOUTLPRECT);
        UNLOCKPWND();
        CHECKRETURN();

        BEGINCOPYOUT()
            OUTSTRUCT(prect, RECT);
        ENDCOPYOUT()

    TRACECALLBACKMSG("SfnINOUTLPRECT");
    ENDSEND(LRESULT,0);
}
#endif // SENDSIDE

#ifdef RECVSIDE
RECVCALL(fnINOUTLPRECT, FNINOUTLPRECTMSG)
{
    BEGINRECV(0, &pmsg->rect, sizeof(pmsg->rect));

    retval = (ULONG_PTR)CALLPROC(pmsg->xpfnProc)(
            pmsg->pwnd,
            pmsg->msg,
            pmsg->wParam,
            &pmsg->rect,
            pmsg->xParam);

    ENDRECV();
}
#endif // RECVSIDE

/**************************************************************************\
* yyy
*
* 11-25-92 ScottLu      Created.
\**************************************************************************/

typedef struct _FNINOUTNCCALCSIZEMSG {
    PWND pwnd;
    UINT msg;
    WPARAM wParam;
    ULONG_PTR xParam;
    PROC xpfnProc;
    union {
        RECT rc;
        struct {
            NCCALCSIZE_PARAMS params;
            WINDOWPOS pos;
        } p;
    } u;
} FNINOUTNCCALCSIZEMSG;

typedef struct _OUTNCCALCSIZE {
    NCCALCSIZE_PARAMS params;
    WINDOWPOS pos;
} OUTNCCALCSIZE, *POUTNCCALCSIZE;

#ifdef SENDSIDE
SMESSAGECALL(INOUTNCCALCSIZE)
{
    SETUPPWND(FNINOUTNCCALCSIZE)

    UNREFERENCED_PARAMETER(dwSCMSFlags);

    BEGINSEND(FNINOUTNCCALCSIZE)

        LPWINDOWPOS lppos;
        UINT cbCallback;

        MSGDATA()->pwnd = pwndClient;
        MSGDATA()->msg = msg;
        MSGDATA()->wParam = wParam;
        MSGDATA()->xParam = xParam;
        MSGDATA()->xpfnProc = xpfnProc;

        /*
         * If wParam != 0, lParam points to a NCCALCSIZE_PARAMS structure,
         * otherwise it points to a rectangle.
         */
        if (wParam != 0) {
            MSGDATA()->u.p.params = *((LPNCCALCSIZE_PARAMS)lParam);
            MSGDATA()->u.p.pos = *(MSGDATA()->u.p.params.lppos);
            cbCallback = sizeof(FNINOUTNCCALCSIZEMSG);
        } else {
            MSGDATA()->u.rc = *((LPRECT)lParam);
            cbCallback = FIELD_OFFSET(FNINOUTNCCALCSIZEMSG, u) +
                    sizeof(RECT);
        }

        /*
         * Don't use the MAKECALL macro so we can
         * select the callback data size
         */
        LOCKPWND();
        LeaveCrit();
        Status = (DWORD)KeUserModeCallback(
            FI_FNINOUTNCCALCSIZE,
            mp,
            cbCallback,
            &pcbs,
            &cbCBStatus);
        EnterCrit();
        UNLOCKPWND();
        CHECKRETURN();

        BEGINCOPYOUT()
            try {
                ProbeForRead(pcbs->pOutput, pcbs->cbOutput, sizeof(DWORD));
                if (wParam != 0) {
                    lppos = ((LPNCCALCSIZE_PARAMS)lParam)->lppos;
                    *((LPNCCALCSIZE_PARAMS)lParam) =
                            ((POUTNCCALCSIZE)pcbs->pOutput)->params;
                    *lppos = ((POUTNCCALCSIZE)pcbs->pOutput)->pos;
                    ((LPNCCALCSIZE_PARAMS)lParam)->lppos = lppos;
                } else {
                    *((LPRECT)lParam) = *(PRECT)pcbs->pOutput;
                }
            } except (W32ExceptionHandler(TRUE, RIP_WARNING)) {
                MSGERROR();
            }
        ENDCOPYOUT()

    TRACECALLBACKMSG("SfnINOUTNCCALCSIZE");
    ENDSEND(LRESULT,0);
}
#endif // SENDSIDE

#ifdef RECVSIDE
RECVCALL(fnINOUTNCCALCSIZE, FNINOUTNCCALCSIZEMSG)
{
    BEGINRECV(0, &pmsg->u, sizeof(pmsg->u));

    if (CALLDATA(wParam) != 0)
        CALLDATA(u.p.params).lppos = PCALLDATA(u.p.pos);

    retval = (ULONG_PTR)CALLPROC(pmsg->xpfnProc)(
            pmsg->pwnd,
            pmsg->msg,
            pmsg->wParam,
            (LPARAM)&pmsg->u,
            pmsg->xParam);

    ENDRECV();
}
#endif // RECVSIDE

/**************************************************************************\
* yyy
*
* 9/30/94 Sanfords created
\**************************************************************************/

typedef struct _FNINOUTSTYLECHANGEMSG {
    PWND pwnd;
    UINT msg;
    WPARAM wParam;
    STYLESTRUCT ss;
    ULONG_PTR xParam;
    PROC xpfnProc;
} FNINOUTSTYLECHANGEMSG;

#ifdef SENDSIDE
SMESSAGECALL(INOUTSTYLECHANGE)
{
    SETUPPWND(FNINOUTSTYLECHANGE)

    UNREFERENCED_PARAMETER(dwSCMSFlags);
    UNREFERENCED_PARAMETER(psms);

    BEGINSEND(FNINOUTSTYLECHANGE)

        MSGDATA()->pwnd = pwndClient;
        MSGDATA()->msg = msg;
        MSGDATA()->wParam = wParam;
        MSGDATA()->xParam = xParam;
        MSGDATA()->xpfnProc = xpfnProc;
        MSGDATA()->ss = *((LPSTYLESTRUCT)lParam);

        LOCKPWND();
        MAKECALL(FNINOUTSTYLECHANGE);
        UNLOCKPWND();
        CHECKRETURN();

        if (msg == WM_STYLECHANGING)
            OUTSTRUCT(((LPSTYLESTRUCT)lParam), STYLESTRUCT);

    TRACECALLBACKMSG("SfnINOUTSTYLECHANGE");
    ENDSEND(LRESULT,0);
}
#endif // SENDSIDE

#ifdef RECVSIDE
RECVCALL(fnINOUTSTYLECHANGE, FNINOUTSTYLECHANGEMSG)
{
    BEGINRECV(0, &pmsg->ss, sizeof(pmsg->ss));

    retval = (ULONG_PTR)CALLPROC(CALLDATA(xpfnProc))(
            CALLDATA(pwnd),
            CALLDATA(msg),
            CALLDATA(wParam),
            (LPARAM)&pmsg->ss,
            pmsg->xParam);

    ENDRECV();
}
#endif // RECVSIDE

/**************************************************************************\
* yyy
*
* 22-Jul-1991 mikeke    Created
\**************************************************************************/

typedef struct _FNOUTLPRECTMSG {
    PWND pwnd;
    UINT msg;
    WPARAM wParam;
    ULONG_PTR xParam;
    PROC xpfnProc;
} FNOUTLPRECTMSG;

#ifdef SENDSIDE
SMESSAGECALL(OUTLPRECT)
{
    SETUPPWND(FNOUTLPRECT)

    UNREFERENCED_PARAMETER(dwSCMSFlags);

    BEGINSEND(FNOUTLPRECT)

        LPRECT prect = (LPRECT)lParam;

        MSGDATA()->pwnd = pwndClient;
        MSGDATA()->msg = msg;
        MSGDATA()->wParam = wParam;
        MSGDATA()->xParam = xParam;
        MSGDATA()->xpfnProc = xpfnProc;

        LOCKPWND();
        MAKECALL(FNOUTLPRECT);
        UNLOCKPWND();
        CHECKRETURN();

        BEGINCOPYOUT()
            OUTSTRUCT(prect, RECT);
        ENDCOPYOUT()

    TRACECALLBACKMSG("SfnOUTLPRECT");
    ENDSEND(LRESULT,0);
}
#endif // SENDSIDE

#ifdef RECVSIDE
RECVCALL(fnOUTLPRECT, FNOUTLPRECTMSG)
{
    RECT rc;

    BEGINRECV(0, &rc, sizeof(rc));

    retval = (ULONG_PTR)CALLPROC(pmsg->xpfnProc)(
            pmsg->pwnd,
            pmsg->msg,
            pmsg->wParam,
            &rc,
            pmsg->xParam);

    ENDRECV();
}
#endif // RECVSIDE

/**************************************************************************\
* yyy
*
* 22-Jul-1991 mikeke    Created
\**************************************************************************/

typedef struct _FNINLPCOMPAREITEMSTRUCTMSG {
    PWND pwnd;
    UINT msg;
    WPARAM wParam;
    COMPAREITEMSTRUCT compareitemstruct;
    ULONG_PTR xParam;
    PROC xpfnProc;
} FNINLPCOMPAREITEMSTRUCTMSG;

#ifdef SENDSIDE
SMESSAGECALL(INLPCOMPAREITEMSTRUCT)
{
    SETUPPWND(FNINLPCOMPAREITEMSTRUCT)

    UNREFERENCED_PARAMETER(dwSCMSFlags);
    UNREFERENCED_PARAMETER(psms);

    BEGINSEND(FNINLPCOMPAREITEMSTRUCT)

        LPCOMPAREITEMSTRUCT pcompareitemstruct = (LPCOMPAREITEMSTRUCT)lParam;

        MSGDATA()->pwnd = pwndClient;
        MSGDATA()->msg = msg;
        MSGDATA()->wParam = wParam;
        MSGDATA()->compareitemstruct = *pcompareitemstruct;
        MSGDATA()->xParam = xParam;
        MSGDATA()->xpfnProc = xpfnProc;

        LOCKPWND();
        MAKECALL(FNINLPCOMPAREITEMSTRUCT);
        UNLOCKPWND();
        CHECKRETURN();

    TRACECALLBACKMSG("SfnINLPCOMPAREITEMSTRUCT");
    ENDSEND(LRESULT,0);
}
#endif // SENDSIDE

#ifdef RECVSIDE
RECVCALL(fnINLPCOMPAREITEMSTRUCT, FNINLPCOMPAREITEMSTRUCTMSG)
{
    BEGINRECV(0, NULL, 0);

    retval = (ULONG_PTR)CALLPROC(pmsg->xpfnProc)(
            pmsg->pwnd,
            pmsg->msg,
            pmsg->wParam,
            &(pmsg->compareitemstruct),
            pmsg->xParam);

    ENDRECV();
}
#endif // RECVSIDE

/**************************************************************************\
* yyy
*
* 22-Jul-1991 mikeke    Created
\**************************************************************************/

typedef struct _FNINLPDELETEITEMSTRUCTMSG {
    PWND pwnd;
    UINT msg;
    WPARAM wParam;
    DELETEITEMSTRUCT deleteitemstruct;
    ULONG_PTR xParam;
    PROC xpfnProc;
} FNINLPDELETEITEMSTRUCTMSG;

#ifdef SENDSIDE
SMESSAGECALL(INLPDELETEITEMSTRUCT)
{
    SETUPPWND(FNINLPDELETEITEMSTRUCT)

    UNREFERENCED_PARAMETER(dwSCMSFlags);
    UNREFERENCED_PARAMETER(psms);

    BEGINSEND(FNINLPDELETEITEMSTRUCT)

        LPDELETEITEMSTRUCT pdeleteitemstruct = (LPDELETEITEMSTRUCT)lParam;

        MSGDATA()->pwnd = pwndClient;
        MSGDATA()->msg = msg;
        MSGDATA()->wParam = wParam;
        MSGDATA()->deleteitemstruct = *pdeleteitemstruct;
        MSGDATA()->xParam = xParam;
        MSGDATA()->xpfnProc = xpfnProc;

        LOCKPWND();
        MAKECALL(FNINLPDELETEITEMSTRUCT);
        UNLOCKPWND();
        CHECKRETURN();

    TRACECALLBACKMSG("SfnINLPDELETEITEMSTRUCT");
    ENDSEND(LRESULT,0);
}
#endif // SENDSIDE

#ifdef RECVSIDE
RECVCALL(fnINLPDELETEITEMSTRUCT, FNINLPDELETEITEMSTRUCTMSG)
{
    BEGINRECV(0, NULL, 0);

    retval = (ULONG_PTR)CALLPROC(pmsg->xpfnProc)(
            pmsg->pwnd,
            pmsg->msg,
            pmsg->wParam,
            &(pmsg->deleteitemstruct),
            pmsg->xParam);

    ENDRECV();
}
#endif // RECVSIDE

/**************************************************************************\
* FNINHLPSTRUCT
*
* 06-08-92 SanfordS Created
\**************************************************************************/

typedef struct _FNINLPHLPSTRUCTMSG {
    CAPTUREBUF CaptureBuf;
    PWND pwnd;
    UINT msg;
    WPARAM wParam;
    LPHLP lphlp;
    ULONG_PTR xParam;
    PROC xpfnProc;
} FNINLPHLPSTRUCTMSG;

#ifdef SENDSIDE
SMESSAGECALL(INLPHLPSTRUCT)
{
    LPHLP lphlp = (LPHLP)lParam;

    SETUPPWND(FNINLPHLPSTRUCT)

    UNREFERENCED_PARAMETER(dwSCMSFlags);
    UNREFERENCED_PARAMETER(psms);

    BEGINSENDCAPTURE(FNINLPHLPSTRUCT, 1, lphlp->cbData, TRUE)

        MSGDATA()->pwnd = pwndClient;
        MSGDATA()->msg = msg;
        MSGDATA()->wParam = wParam;
        COPYBYTES(lphlp, lphlp->cbData);
        MSGDATA()->xParam = xParam;
        MSGDATA()->xpfnProc = xpfnProc;

        LOCKPWND();
        MAKECALLCAPTURE(FNINLPHLPSTRUCT);
        UNLOCKPWND();
        CHECKRETURN();

    TRACECALLBACKMSG("SfnINLPHLPSTRUCT");
    ENDSENDCAPTURE(LRESULT,0);
}
#endif // SENDSIDE

#ifdef RECVSIDE
RECVCALL(fnINLPHLPSTRUCT, FNINLPHLPSTRUCTMSG)
{
    BEGINRECV(0, NULL, 0);
    FIXUPPOINTERS();

    retval = (ULONG_PTR)CALLPROC(pmsg->xpfnProc)(
            pmsg->pwnd,
            pmsg->msg,
            pmsg->wParam,
            FIXUP(lphlp),
            pmsg->xParam);

    ENDRECV();
}
#endif // RECVSIDE

#ifndef WINHELP4

/**************************************************************************\
* FNINHELPINFOSTRUCT
*
* 06-08-92 SanfordS Created
\**************************************************************************/

typedef struct _FNINLPHELPFINFOSTRUCTMSG {
    CAPTUREBUF CaptureBuf;
    PWND pwnd;
    UINT msg;
    WPARAM wParam;
    LPHELPINFO lphlp;
    ULONG_PTR xParam;
    PROC xpfnProc;
} FNINLPHELPINFOSTRUCTMSG;

#ifdef SENDSIDE
SMESSAGECALL(INLPHELPINFOSTRUCT)
{
    LPHELPINFO lphlp = (LPHELPINFO)lParam;

    SETUPPWND(FNINLPHELPINFOSTRUCT)

    UNREFERENCED_PARAMETER(dwSCMSFlags);
    UNREFERENCED_PARAMETER(psms);

    BEGINSENDCAPTURE(FNINLPHELPINFOSTRUCT, 1, lphlp->cbSize, TRUE)

        MSGDATA()->pwnd = pwndClient;
        MSGDATA()->msg = msg;
        MSGDATA()->wParam = wParam;
        COPYBYTES(lphlp, lphlp->cbSize);
        MSGDATA()->xParam = xParam;
        MSGDATA()->xpfnProc = xpfnProc;

        LOCKPWND();
        MAKECALLCAPTURE(FNINLPHELPINFOSTRUCT);
        UNLOCKPWND();
        CHECKRETURN();

    TRACECALLBACKMSG("SfnINLPHELPINFOSTRUCT");
    ENDSENDCAPTURE(LRESULT,0);
}
#endif // SENDSIDE

#ifdef RECVSIDE
RECVCALL(fnINLPHELPINFOSTRUCT, FNINLPHELPINFOSTRUCTMSG)
{
    BEGINRECV(0, NULL, 0);
    FIXUPPOINTERS();

    retval = (ULONG_PTR)CALLPROC(pmsg->xpfnProc)(
            pmsg->pwnd,
            pmsg->msg,
            pmsg->wParam,
            FIXUP(lphlp),
            pmsg->xParam);

    ENDRECV();
}
#endif // RECVSIDE
#endif // WINHELP4

/**************************************************************************\
* yyy
*
* 22-Jul-1991 mikeke    Created
\**************************************************************************/

typedef struct _FNINLPDRAWITEMSTRUCTMSG {
    PWND pwnd;
    UINT msg;
    WPARAM wParam;
    DRAWITEMSTRUCT drawitemstruct;
    ULONG_PTR xParam;
    PROC xpfnProc;
} FNINLPDRAWITEMSTRUCTMSG;

#ifdef SENDSIDE
SMESSAGECALL(INLPDRAWITEMSTRUCT)
{
    SETUPPWND(FNINLPDRAWITEMSTRUCT)

    UNREFERENCED_PARAMETER(dwSCMSFlags);
    UNREFERENCED_PARAMETER(psms);

    BEGINSEND(FNINLPDRAWITEMSTRUCT)

        LPDRAWITEMSTRUCT pdrawitemstruct = (LPDRAWITEMSTRUCT)lParam;
        HDC hdcOriginal = (HDC)NULL;

        /*
         * Make sure that this is not an OLE inter-process DrawItem
         */
        if (GreGetObjectOwner((HOBJ)pdrawitemstruct->hDC, DC_TYPE) !=
                W32GetCurrentPID()) {
            if (pdrawitemstruct->hDC) {
                PWND pwndItem;

                pwndItem = _WindowFromDC(pdrawitemstruct->hDC);

                if (pwndItem) {
                    hdcOriginal = pdrawitemstruct->hDC;
                    pdrawitemstruct->hDC = _GetDC(pwndItem);
                }
            }
        }


        MSGDATA()->pwnd = pwndClient;
        MSGDATA()->msg = msg;
        MSGDATA()->wParam = wParam;
        MSGDATA()->drawitemstruct = *pdrawitemstruct;
        MSGDATA()->xParam = xParam;
        MSGDATA()->xpfnProc = xpfnProc;

        LOCKPWND();
        MAKECALL(FNINLPDRAWITEMSTRUCT);
        UNLOCKPWND();
        CHECKRETURN();

        if (hdcOriginal) {
            _ReleaseDC(pdrawitemstruct->hDC);
            pdrawitemstruct->hDC = hdcOriginal;
        }
    TRACECALLBACKMSG("SfnINLPDRAWITEMSTRUCT");
    ENDSEND(LRESULT,0);
}
#endif // SENDSIDE

#ifdef RECVSIDE
RECVCALL(fnINLPDRAWITEMSTRUCT, FNINLPDRAWITEMSTRUCTMSG)
{
    BEGINRECV(0, NULL, 0);

    if (pmsg->drawitemstruct.hDC == NULL)
        MSGERRORCODE(ERROR_INVALID_HANDLE);

    retval = (ULONG_PTR)CALLPROC(pmsg->xpfnProc)(
            pmsg->pwnd,
            pmsg->msg,
            pmsg->wParam,
            &(pmsg->drawitemstruct),
            pmsg->xParam);

    ENDRECV();
}
#endif // RECVSIDE

/**************************************************************************\
* fnINOUTLPMEASUREITEMSTRUCT
*
* 22-Jul-1991 mikeke    Created
\**************************************************************************/

typedef struct _FNINOUTLPMEASUREITEMSTRUCTMSG {
    PWND pwnd;
    UINT msg;
    WPARAM wParam;
    MEASUREITEMSTRUCT measureitemstruct;
    ULONG_PTR xParam;
    PROC xpfnProc;
} FNINOUTLPMEASUREITEMSTRUCTMSG;

#ifdef SENDSIDE
SMESSAGECALL(INOUTLPMEASUREITEMSTRUCT)
{
    SETUPPWND(FNINOUTLPMEASUREITEMSTRUCT)

    BEGINSEND(FNINOUTLPMEASUREITEMSTRUCT)

        PMEASUREITEMSTRUCT pmeasureitemstruct = (PMEASUREITEMSTRUCT)lParam;

        MSGDATA()->pwnd = pwndClient;
        MSGDATA()->msg = msg & ~MSGFLAG_MASK;
        MSGDATA()->wParam = wParam;
        MSGDATA()->measureitemstruct = *pmeasureitemstruct;
        MSGDATA()->xParam = xParam;
        MSGDATA()->xpfnProc = xpfnProc;

        LOCKPWND();
        MAKECALL(FNINOUTLPMEASUREITEMSTRUCT);
        UNLOCKPWND();
        CHECKRETURN();

        BEGINCOPYOUT()
            OUTSTRUCT(pmeasureitemstruct, MEASUREITEMSTRUCT);
        ENDCOPYOUT()

    TRACECALLBACKMSG("SfnINOUTLPMEASUREITEMSTRUCT");
    ENDSEND(LRESULT,0);
}
#endif // SENDSIDE

#ifdef RECVSIDE
RECVCALL(fnINOUTLPMEASUREITEMSTRUCT, FNINOUTLPMEASUREITEMSTRUCTMSG)
{
    BEGINRECV(0, &pmsg->measureitemstruct, sizeof(pmsg->measureitemstruct));

    retval = (ULONG_PTR)CALLPROC(pmsg->xpfnProc)(
            pmsg->pwnd,
            pmsg->msg,
            pmsg->wParam,
            &pmsg->measureitemstruct,
            pmsg->xParam);

    ENDRECV();
}
#endif // RECVSIDE

/**************************************************************************\
* fnINSTRING
*
* 22-Jul-1991 mikeke    Created
* 27-Jan-1992 IanJa     Unicode/ANSI
\**************************************************************************/

typedef struct _FNINSTRINGMSG {
    CAPTUREBUF CaptureBuf;
    PWND       pwnd;
    UINT       msg;
    WPARAM     wParam;
    ULONG_PTR   xParam;
    PROC       xpfnProc;
    LPTSTR     pwsz;
} FNINSTRINGMSG;

#ifdef SENDSIDE
SMESSAGECALL(INSTRING)
{
    PLARGE_STRING pstr = (PLARGE_STRING)lParam;
    DWORD         cbCapture;
    DWORD         cCapture;
    BOOL          fAnsiReceiver = (dwSCMSFlags & SCMS_FLAGS_ANSI);

    SETUPPWND(FNINSTRING)

    UNREFERENCED_PARAMETER(psms);

    /*
     * Compute ANSI capture lengths.  Don't capture if
     * the strings are in the client's address space and
     * of the correct type.
     */
    if (pstr &&
        (IS_SYSTEM_ADDRESS((PVOID)pstr->Buffer) ||
        ((BOOL)pstr->bAnsi != fAnsiReceiver))) {

        cCapture = 1;
        CALC_SIZE_IN(cbCapture, pstr);

    } else {

        cbCapture = 0;
        cCapture  = 0;
    }

    BEGINSENDCAPTURE(FNINSTRING, cCapture, cbCapture, TRUE)

        MSGDATA()->pwnd   = pwndClient;
        MSGDATA()->msg    = msg;
        MSGDATA()->wParam = wParam;

        if (cCapture) {

            if (!pstr->bAnsi) {

                if (fAnsiReceiver) {
                    LARGECOPYSTRINGLPWSTRA(pstr, pwsz);
                } else {
                    LARGECOPYSTRINGLPWSTR(pstr, pwsz);
                }

            } else {

                if (fAnsiReceiver) {
                    LARGECOPYSTRINGLPSTR(pstr, pwsz);
                } else {
                    LARGECOPYSTRINGLPSTRW(pstr, pwsz);
                }
            }

        } else {

            MSGDATA()->pwsz = (pstr ? pstr->Buffer : NULL);
        }

        MSGDATA()->xParam   = xParam;
        MSGDATA()->xpfnProc = xpfnProc;

        LOCKPWND();
        MAKECALLCAPTURE(FNINSTRING);
        UNLOCKPWND();
        CHECKRETURN();

    TRACECALLBACKMSG("SfnINSTRING");
    ENDSENDCAPTURE(LRESULT,0);
}
#endif // SENDSIDE

#ifdef RECVSIDE
RECVCALL(fnINSTRING, FNINSTRINGMSG)
{
    BEGINRECV(0, NULL, 0);
    FIXUPPOINTERS();

    retval = (ULONG_PTR)CALLPROC(pmsg->xpfnProc)(
            pmsg->pwnd,
            pmsg->msg,
            pmsg->wParam,
            pmsg->pwsz,
            pmsg->xParam);

    ENDRECV();
}
#endif // RECVSIDE

/**************************************************************************\
* fnINSTRINGNULL
*
* Server-side stub translates Unicode to ANSI if required.
*
* 22-Jul-1991 mikeke    Created
* 28-Jan-1992 IanJa     Unicode/ANSI  (Server translate to ANSI if rquired)
\**************************************************************************/

typedef struct _FNINSTRINGNULLMSG {
    CAPTUREBUF CaptureBuf;
    PWND pwnd;
    UINT msg;
    WPARAM wParam;
    ULONG_PTR xParam;
    PROC xpfnProc;
    LPTSTR pwsz;
} FNINSTRINGNULLMSG;

#ifdef SENDSIDE
SMESSAGECALL(INSTRINGNULL)
{
    PLARGE_STRING pstr = (PLARGE_STRING)lParam;
    DWORD cbCapture;
    DWORD cCapture;
    BOOL fAnsiReceiver = (dwSCMSFlags & SCMS_FLAGS_ANSI);

    SETUPPWND(FNINSTRINGNULL)

    UNREFERENCED_PARAMETER(psms);

    cCapture = 0;
    cbCapture = 0;
    if (pstr) {

        /*
         * Compute ANSI capture lengths.  Don't capture if
         * the strings are in the client's address space and
         * of the correct type.
         */
        if (IS_SYSTEM_ADDRESS((PVOID)pstr->Buffer) ||
                (BOOL)pstr->bAnsi != fAnsiReceiver) {
            cCapture = 1;
            CALC_SIZE_IN(cbCapture, pstr);
        }
    }

    BEGINSENDCAPTURE(FNINSTRINGNULL, cCapture, cbCapture, TRUE)


        MSGDATA()->pwnd = pwndClient;
        MSGDATA()->msg = msg;
        MSGDATA()->wParam = wParam;
        if (cCapture) {
            if (!pstr->bAnsi) {
                if (fAnsiReceiver) {
                    LARGECOPYSTRINGLPWSTRA(pstr, pwsz);
                } else {
                    LARGECOPYSTRINGLPWSTR(pstr, pwsz);
                }
            } else {
                if (fAnsiReceiver) {
                    LARGECOPYSTRINGLPSTR(pstr, pwsz);
                } else {
                    LARGECOPYSTRINGLPSTRW(pstr, pwsz);
                }
            }
        } else
            MSGDATA()->pwsz = pstr ? pstr->Buffer : NULL;
        MSGDATA()->xParam = xParam;
        MSGDATA()->xpfnProc = xpfnProc;

        LOCKPWND();
        MAKECALLCAPTURE(FNINSTRINGNULL);
        UNLOCKPWND();
        CHECKRETURN();

    TRACECALLBACKMSG("SfnINSTRINGNULL");
    ENDSENDCAPTURE(LRESULT,0);
}
#endif // SENDSIDE

#ifdef RECVSIDE
RECVCALL(fnINSTRINGNULL, FNINSTRINGNULLMSG)
{
    BEGINRECV(0, NULL, 0);
    FIXUPPOINTERS();

    retval = (ULONG_PTR)CALLPROC(pmsg->xpfnProc)(
            pmsg->pwnd,
            pmsg->msg,
            pmsg->wParam,
            pmsg->pwsz,
            pmsg->xParam);

    ENDRECV();
}
#endif // RECVSIDE

/**************************************************************************\
* yyy
*
* 27-May-1997 GregoryW  Created
\**************************************************************************/

typedef struct _FNINLPKDRAWSWITCHWNDMSG {
    CAPTUREBUF CaptureBuf;
    PWND pwnd;
    UINT msg;
    WPARAM wParam;
    ULONG_PTR xParam;
    PROC xpfnProc;
    LPWSTR pwsz;
    RECT rcRect;
} FNINLPKDRAWSWITCHWNDMSG;

#ifdef SENDSIDE
SMESSAGECALL(INLPKDRAWSWITCHWND)
{
    PLARGE_UNICODE_STRING pstr = &((LPKDRAWSWITCHWND *)lParam)->strName;
    DWORD cbCapture;
    DWORD cCapture = 1;  // Always capture the string
    PWND pwndDCOwner;
    HDC hdcSwitch;
    COLORREF clrOldText, clrOldBk;
    HFONT hOldFont;
    BOOL fAnsiReceiver = FALSE;  // The string is always Unicode

    SETUPPWND(FNINLPKDRAWSWITCHWND)

    UNREFERENCED_PARAMETER(psms);
    UNREFERENCED_PARAMETER(dwSCMSFlags);

    CALC_SIZE_IN(cbCapture, pstr);

    BEGINSENDCAPTURE(FNINLPKDRAWSWITCHWND, cCapture, cbCapture, TRUE)

        LARGECOPYSTRINGLPWSTR(pstr, pwsz);

        pwndDCOwner = _WindowFromDC((HDC)wParam);
        hdcSwitch = _GetDC(pwndDCOwner);
        clrOldText = GreSetTextColor(hdcSwitch, SYSRGB(BTNTEXT));
        clrOldBk   = GreSetBkColor(hdcSwitch, SYSRGB(3DFACE));
        hOldFont = GreSelectFont(hdcSwitch, gpsi->hCaptionFont);

        MSGDATA()->pwnd = pwndClient;
        MSGDATA()->msg = msg;
        MSGDATA()->wParam = (WPARAM)hdcSwitch;
        MSGDATA()->rcRect = ((LPKDRAWSWITCHWND *)lParam)->rcRect;
        MSGDATA()->xParam = xParam;
        MSGDATA()->xpfnProc = xpfnProc;

        LOCKPWND();
        MAKECALLCAPTURE(FNINLPKDRAWSWITCHWND);
        UNLOCKPWND();

        GreSelectFont(hdcSwitch, hOldFont);
        GreSetBkColor(hdcSwitch, clrOldBk);
        GreSetTextColor(hdcSwitch, clrOldText);
        _ReleaseDC(hdcSwitch);

        CHECKRETURN();

    TRACECALLBACKMSG("SfnINLPKDRAWSWITCHWND");
    ENDSENDCAPTURE(LRESULT,0);
}
#endif // SENDSIDE

#ifdef RECVSIDE
RECVCALL(fnINLPKDRAWSWITCHWND, FNINLPKDRAWSWITCHWNDMSG)
{
    DRAWTEXTPARAMS  dtp;

    BEGINRECV(0, NULL, 0);
    FIXUPPOINTERS();

    dtp.cbSize = sizeof(dtp);
    dtp.iLeftMargin = 0;
    dtp.iRightMargin = 0;
    retval = DrawTextExW(
                 (HDC)pmsg->wParam,
                 pmsg->pwsz,
                 -1,
                 &(pmsg->rcRect),
                 DT_NOPREFIX | DT_END_ELLIPSIS | DT_SINGLELINE,
                 &dtp
                 );
    ENDRECV();
}
#endif // RECVSIDE

typedef struct _FNINDEVICECHANGEMSG {
    CAPTUREBUF CaptureBuf;
    PWND pwnd;
    UINT msg;
    WPARAM wParam;
    ULONG_PTR xParam;
    PROC xpfnProc;
    LPTSTR pwsz;
    BOOL fAnsi;
} FNINDEVICECHANGEMSG;

#ifdef SENDSIDE
SMESSAGECALL(INDEVICECHANGE)
{
    PVOID pstr = (PVOID)lParam;
    DWORD cbCapture;
    BOOL fAnsiReceiver = (dwSCMSFlags & SCMS_FLAGS_ANSI);
    BOOL fPtr    = (BOOL)((wParam & 0x8000) == 0x8000);

    SETUPPWND(FNINDEVICECHANGE)

    UNREFERENCED_PARAMETER(psms);

    cbCapture = 0;
    if (fPtr && (pstr != NULL)) {

        /*
         * Compute ANSI capture lengths.  Don't capture if
         * the strings are in the client's address space and
         * of the correct type.
         */
        if (IS_SYSTEM_ADDRESS((PVOID)pstr)) {
            cbCapture = *((DWORD *)pstr);
        }
    }

    BEGINSENDCAPTURE(FNINDEVICECHANGE, 1, cbCapture, TRUE)

        MSGDATA()->pwnd = pwndClient;
        MSGDATA()->msg = msg;
        MSGDATA()->wParam = wParam;
        if (cbCapture) {
           LARGECOPYBYTES2(pstr, *((DWORD *)pstr), pwsz);
        } else {
           MSGDATA()->pwsz = (LPTSTR)pstr;
        }

        MSGDATA()->fAnsi = fAnsiReceiver;
        MSGDATA()->xParam = xParam;
        MSGDATA()->xpfnProc = xpfnProc;

        LOCKPWND();
        MAKECALLCAPTURE(FNINDEVICECHANGE);
        UNLOCKPWND();
        CHECKRETURN();

    TRACECALLBACKMSG("SfnINDEVICECHANGE");
    ENDSENDCAPTURE(LRESULT,0);
}
#endif // SENDSIDE

#ifdef RECVSIDE
RECVCALL(fnINDEVICECHANGE, FNINDEVICECHANGEMSG)
{

    struct _DEV_BROADCAST_HEADER *pHdr;
    PDEV_BROADCAST_PORT_A pPortA = NULL;
    PDEV_BROADCAST_PORT_W pPortW;
    PDEV_BROADCAST_DEVICEINTERFACE_A pInterfaceA = NULL;
    PDEV_BROADCAST_DEVICEINTERFACE_W pInterfaceW;
    PDEV_BROADCAST_HANDLE pHandleA = NULL;
    PDEV_BROADCAST_HANDLE pHandleW;
    PDEV_BROADCAST_VOLUME pVolume;


    int iStr, iSize;
    LPSTR lpStr;
    LPARAM lParam;

    BEGINRECV(0, NULL, 0);
    FIXUPPOINTERS();

    lParam = (LPARAM)pmsg->pwsz;

    pHdr = (struct _DEV_BROADCAST_HEADER *)lParam;

    if (!lParam || !(pmsg->wParam & 0x8000) ||
        (!pmsg->fAnsi &&
        ((pHdr->dbcd_devicetype != DBT_DEVTYP_VOLUME) || (pmsg->msg != WM_DEVICECHANGE))
        )) {
        goto shipit;
    }

    switch (pHdr->dbcd_devicetype) {
    case DBT_DEVTYP_PORT:
        pPortW = (PDEV_BROADCAST_PORT_W)lParam;
        iStr = wcslen(pPortW->dbcp_name);
        iSize = FIELD_OFFSET(DEV_BROADCAST_PORT_A, dbcp_name) + DBCS_CHARSIZE*(iStr+1);
        pPortA = UserLocalAlloc(0, iSize);
        if (pPortA == NULL)
            MSGERROR();
        RtlCopyMemory(pPortA, pPortW, FIELD_OFFSET(DEV_BROADCAST_PORT_A, dbcp_name));
        lpStr = pPortA->dbcp_name;
        if (iStr) {
            WCSToMB(pPortW->dbcp_name, -1, &lpStr, iStr, FALSE);
        }
        lpStr[iStr] = 0;
        pPortA->dbcp_size = iSize;
        lParam = (LPARAM)pPortA;
        break;
    case DBT_DEVTYP_DEVICEINTERFACE:
        pInterfaceW = (PDEV_BROADCAST_DEVICEINTERFACE_W)lParam;
        iStr = wcslen(pInterfaceW->dbcc_name);
        iSize = FIELD_OFFSET(DEV_BROADCAST_DEVICEINTERFACE_A, dbcc_name) + DBCS_CHARSIZE*(iStr+1);
        pInterfaceA = UserLocalAlloc(0, iSize);
        if (pInterfaceA == NULL)
            MSGERROR();
        RtlCopyMemory(pInterfaceA, pInterfaceW, FIELD_OFFSET(DEV_BROADCAST_DEVICEINTERFACE_A, dbcc_name));
        lpStr = pInterfaceA->dbcc_name;
        if (iStr) {
            WCSToMB(pInterfaceW->dbcc_name, -1, &lpStr, iStr, FALSE);
        }
        lpStr[iStr] = 0;
        pInterfaceA->dbcc_size = iSize;
        lParam = (LPARAM)pInterfaceA;
        break;
    case DBT_DEVTYP_HANDLE:
        pHandleW = (PDEV_BROADCAST_HANDLE)lParam;
        if ((pmsg->wParam != DBT_CUSTOMEVENT) || (pHandleW->dbch_nameoffset < 0)) break;
        iStr = wcslen((LPWSTR)(pHandleW->dbch_data+pHandleW->dbch_nameoffset));
        iSize = pHandleW->dbch_size;
        /*
         * MB size can't be bigger than UNICODE size
         */
        pHandleA = UserLocalAlloc(0, iSize);
        if (pHandleA == NULL)
            MSGERROR();
        RtlCopyMemory(pHandleA, pHandleW, FIELD_OFFSET(DEV_BROADCAST_HANDLE, dbch_data)+ pHandleW->dbch_nameoffset);
        lpStr = pHandleA->dbch_data+pHandleA->dbch_nameoffset;
        if (iStr) {
            WCSToMB((LPWSTR)(pHandleW->dbch_data+pHandleW->dbch_nameoffset), -1, &lpStr, iStr, FALSE);
        }
        lpStr[iStr] = 0;
        pHandleA->dbch_size = iSize;
        lParam = (LPARAM)pHandleA;
        break;
    case DBT_DEVTYP_VOLUME:
        pVolume = (PDEV_BROADCAST_VOLUME)lParam;
        if (((pmsg->wParam == DBT_DEVICEREMOVECOMPLETE) ||
             (pmsg->wParam == DBT_DEVICEARRIVAL)) &&
            (pVolume->dbcv_unitmask & DBV_FILTER_MSG)) {
            DWORD LUIDDriveMask, ResultDriveMask;

            LUIDDriveMask = GetLUIDDosDrivesOnly();

            /*
             * Filter out the common drive letter bits & DBV_FILTER_MSG
             */
            ResultDriveMask = (((LUIDDriveMask & pVolume->dbcv_unitmask) ^
                                pVolume->dbcv_unitmask) ^
                               DBV_FILTER_MSG);

            if (ResultDriveMask == 0) {
                goto cleanup;
            }
            pVolume->dbcv_unitmask = ResultDriveMask;
            lParam = (LPARAM)pVolume;
        }
        break;
    }
shipit:
    retval = (ULONG_PTR)CALLPROC(pmsg->xpfnProc)(
            pmsg->pwnd,
            pmsg->msg,
            pmsg->wParam,
            lParam,
            pmsg->xParam);

cleanup:
    if (pInterfaceA) UserLocalFree(pInterfaceA);
    if (pPortA) UserLocalFree(pPortA);
    if (pHandleA) UserLocalFree(pHandleA);

    ENDRECV();
}
#endif // RECVSIDE


/**************************************************************************\
* fnOUTSTRING
*
* Warning this message copies but does not count the NULL in retval
* as in WM_GETTEXT
*
* 22-Jul-1991 mikeke    Created
\**************************************************************************/

typedef struct _FNOUTSTRINGMSG {
    CAPTUREBUF CaptureBuf;
    PWND pwnd;
    UINT msg;
    WPARAM wParam;
    ULONG_PTR xParam;
    PROC xpfnProc;
    PBYTE pOutput;
    DWORD cbOutput;
} FNOUTSTRINGMSG;

#ifdef SENDSIDE
SMESSAGECALL(OUTSTRING)
{
    PLARGE_STRING pstr = (PLARGE_STRING)lParam;
    DWORD cbCapture;
    BOOL fAnsiReceiver = (dwSCMSFlags & SCMS_FLAGS_ANSI);
    BOOL bInflateWParam = FALSE;

    SETUPPWND(FNOUTSTRING)

    CALC_SIZE_OUT_STRING(cbCapture, pstr);

    BEGINSENDCAPTURE(FNOUTSTRING, 1, cbCapture, FALSE)

        MSGDATA()->pwnd = pwndClient;
        MSGDATA()->msg = msg;

        /*
         * Need to wParam MBCS bytes may be required to form wParam Unicode bytes
         */
        if (fAnsiReceiver && !(pstr->bAnsi)) {
            /*
             * Unicode -> Ansi
             */
            MSGDATA()->wParam = (wParam * sizeof(WCHAR));
            PtiCurrent()->TIF_flags |= TIF_ANSILENGTH;
            bInflateWParam = TRUE;
        } else {
            /*
             * if wParam is already adjusted for ANSI, we need to re-adjust for Unicode...
             *
             * This logic is for following cases...
             *
             * +========+===============+=============+================+=============+
             * |WndProc |Unicode WndProc->Ansi WndProc->Unicode WndProc->Ansi WndProc|
             * +--------+---------------+-------------+----------------+-------------+
             * |Length  |      X        ->  (X * 2)   ->       X       ->  (X * 2)   |
             * +--------+---------------+-------------+----------------+-------------+
             */
            if (!fAnsiReceiver && (PtiCurrent()->TIF_flags & TIF_ANSILENGTH)) {
                /* adjust limit also... */
                MSGDATA()->wParam = wParam / sizeof(WCHAR);
                PtiCurrent()->TIF_flags &= ~TIF_ANSILENGTH;
            } else {
                MSGDATA()->wParam = wParam;
            }
        }
        MSGDATA()->xParam = xParam;
        MSGDATA()->xpfnProc = xpfnProc;

        RESERVEBYTES(cbCapture, pOutput, cbOutput);

        LOCKPWND();
        MAKECALLCAPTURE(FNOUTSTRING);
        UNLOCKPWND();
        CHECKRETURN();

        BEGINCOPYOUT()
            if (retval) {
                /*
                 * Non-zero retval means some text to copy out.  Do not copy out
                 * more than the requested byte count 'wParam'.
                 */
                COPYOUTLPWSTRLIMIT(pstr, (int)wParam);
            } else {
                /*
                 * A dialog function returning FALSE means no text to copy out,
                 * but an empty string also has retval == 0: put a null char in
                 * pstr for the latter case.
                 */
                if (wParam != 0) {
                    if (pstr->bAnsi) {
                         *(PCHAR)pstr->Buffer = 0;
                    } else {
                         *(PWCHAR)pstr->Buffer = 0;
                    }
                }
            }
        ENDCOPYOUT()

    TRACECALLBACKMSG("SfnOUTSTRING");
    ENDSENDCAPTUREOUTSTRING(LRESULT,0);
}
#endif // SENDSIDE

#ifdef RECVSIDE
RECVCALL(fnOUTSTRING, FNOUTSTRINGMSG)
{
    BYTE abOutput[CALLBACKSTACKLIMIT];

    BEGINRECV(0, NULL, pmsg->cbOutput);
    FIXUPPOINTERS();
    if (pmsg->cbOutput <= CALLBACKSTACKLIMIT)
        CallbackStatus.pOutput = abOutput;
    else
        CallbackStatus.pOutput = pmsg->pOutput;

    retval = (ULONG_PTR)CALLPROC(CALLDATA(xpfnProc))(
            CALLDATA(pwnd),
            CALLDATA(msg),
            CALLDATA(wParam),
            (LPARAM)KPVOID_TO_PVOID(CallbackStatus.pOutput),
            CALLDATA(xParam));

    ENDRECV();
}
#endif // RECVSIDE

/**************************************************************************\
* fnINCNTOUTSTRING
*
* Does NOT NULL terminate string
*
* 22-Jul-1991 mikeke    Created
\**************************************************************************/

typedef struct _FNINCNTOUTSTRING {
    CAPTUREBUF CaptureBuf;
    PWND pwnd;
    UINT msg;
    WPARAM wParam;
    ULONG_PTR xParam;
    PROC xpfnProc;
    WORD cchMax;
    PBYTE pOutput;
    DWORD cbOutput;
} FNINCNTOUTSTRINGMSG;

#ifdef SENDSIDE
SMESSAGECALL(INCNTOUTSTRING)
{
    PLARGE_STRING pstr = (PLARGE_STRING)lParam;
    DWORD cbCapture;
    WORD cchOriginal;
    BOOL fAnsiReceiver = (dwSCMSFlags & SCMS_FLAGS_ANSI);

    SETUPPWND(FNINCNTOUTSTRING)

    CALC_SIZE_OUT(cbCapture, pstr);

    BEGINSENDCAPTURE(FNINCNTOUTSTRING, 1, cbCapture, FALSE)

        MSGDATA()->pwnd = pwndClient;
        MSGDATA()->msg = msg;
        MSGDATA()->wParam = wParam;
        cchOriginal = (WORD)pstr->MaximumLength;
        if (!pstr->bAnsi)
            cchOriginal /= sizeof(WCHAR);

        MSGDATA()->cchMax = (WORD)min(cchOriginal, 0xffff);
        MSGDATA()->xParam = xParam;
        MSGDATA()->xpfnProc = xpfnProc;

        RESERVEBYTES(cbCapture, pOutput, cbOutput);

        LOCKPWND();
        MAKECALLCAPTURE(FNINCNTOUTSTRING)
        UNLOCKPWND();
        CHECKRETURN();

        /*
         * We don't want to do the copy out of the sender died or if
         * this message was just sent as part of a CALLWNDPROC hook processing
         */
        BEGINCOPYOUT()
            if (retval) {
                /*
                 * Non-zero retval means some text to copy out.  Do not copy out
                 * more than the requested char count 'wParam'.
                 */
                COPYOUTLPWSTRLIMIT(pstr, (int)cchOriginal);
            } else {
                /*
                 * A dialog function returning FALSE means no text to copy out,
                 * but an empty string also has retval == 0: put a null char in
                 * pstr for the latter case.
                 */
                if (pstr->bAnsi) {
                    *(PCHAR)pstr->Buffer = 0;
                } else {
                    *(PWCHAR)pstr->Buffer = 0;
                }
            }
        ENDCOPYOUT()

    TRACECALLBACKMSG("SfnINCNTOUTSTRING");
    ENDSENDCAPTURE(LRESULT,0);
}
#endif // SENDSIDE

#ifdef RECVSIDE
RECVCALL(fnINCNTOUTSTRING, FNINCNTOUTSTRINGMSG)
{
    BYTE abOutput[CALLBACKSTACKLIMIT];

    BEGINRECV(0, NULL, pmsg->cbOutput);
    FIXUPPOINTERS();
    if (pmsg->cbOutput <= CALLBACKSTACKLIMIT)
        CallbackStatus.pOutput = abOutput;
    else
        CallbackStatus.pOutput = pmsg->pOutput;

    *(KPWORD)CallbackStatus.pOutput = CALLDATA(cchMax);

    retval = (ULONG_PTR)CALLPROC(CALLDATA(xpfnProc))(
            CALLDATA(pwnd),
            CALLDATA(msg),
            CALLDATA(wParam),
            (LPARAM)KPVOID_TO_PVOID(CallbackStatus.pOutput),
            CALLDATA(xParam));

    ENDRECV();
}
#endif // RECVSIDE

/**************************************************************************\
* fnINCNTOUTSTRINGNULL
*
* wParam specifies the maximum number of bytes to copy
* the string is NULL terminated
*
* 22-Jul-1991 mikeke    Created
\**************************************************************************/

typedef struct _FNINCNTOUTSTRINGNULL {
    CAPTUREBUF CaptureBuf;
    PWND pwnd;
    UINT msg;
    WPARAM wParam;
    ULONG_PTR xParam;
    PROC xpfnProc;
    PBYTE pOutput;
    DWORD cbOutput;
} FNINCNTOUTSTRINGNULLMSG;

#ifdef SENDSIDE
SMESSAGECALL(INCNTOUTSTRINGNULL)
{
    PLARGE_STRING pstr = (PLARGE_STRING)lParam;
    DWORD cbCapture;
    BOOL fAnsiReceiver = (dwSCMSFlags & SCMS_FLAGS_ANSI);

    SETUPPWND(FNINCNTOUTSTRINGNULL)

    CALC_SIZE_OUT(cbCapture, pstr);

    BEGINSENDCAPTURE(FNINCNTOUTSTRINGNULL, 1, cbCapture, FALSE)

        if (wParam < 2) {   // However unlikely, this prevents a possible GP
            MSGERROR();     // on the server side.
        }

        MSGDATA()->pwnd = pwndClient;
        MSGDATA()->msg = msg;
        MSGDATA()->wParam = wParam;
        MSGDATA()->xParam = xParam;
        MSGDATA()->xpfnProc = xpfnProc;

        RESERVEBYTES(cbCapture, pOutput, cbOutput);

        LOCKPWND();
        MAKECALLCAPTURE(FNINCNTOUTSTRINGNULL)
        UNLOCKPWND();
        CHECKRETURN();

        /*
         * We don't want to do the copy out of the sender died or if
         * this message was just sent as part of a CALLWNDPROC hook processing
         */
        BEGINCOPYOUT()
            if (pcbs->cbOutput != 0) {

                /*
                 * Buffer changed means some text to copy out.  Do not copy out
                 * more than the requested byte count 'wParam'.
                 */
                COPYOUTLPWSTRLIMIT(pstr, (int)wParam);
            }
        ENDCOPYOUT()

    TRACECALLBACKMSG("SfnINCNTOUTSTRINGNULL");
    ENDSENDCAPTURE(LRESULT,0);
}
#endif // SENDSIDE

#ifdef RECVSIDE
RECVCALL(fnINCNTOUTSTRINGNULL, FNINCNTOUTSTRINGNULLMSG)
{
    BYTE abOutput[CALLBACKSTACKLIMIT];

    BEGINRECV(0, NULL, pmsg->cbOutput);
    FIXUPPOINTERS();
    if (pmsg->cbOutput <= CALLBACKSTACKLIMIT)
        CallbackStatus.pOutput = abOutput;
    else
        CallbackStatus.pOutput = pmsg->pOutput;

    retval = (ULONG_PTR)CALLPROC(CALLDATA(xpfnProc))(
            CALLDATA(pwnd),
            CALLDATA(msg),
            CALLDATA(wParam),
            (LPARAM)KPVOID_TO_PVOID(CallbackStatus.pOutput),
            CALLDATA(xParam));

    ENDRECV();
}
#endif // RECVSIDE

/**************************************************************************\
* fnPOUTLPINT
*
* 22-Jul-1991 mikeke    Created
\**************************************************************************/

typedef struct _FNPOUTLPINTMSG {
    CAPTUREBUF CaptureBuf;
    PWND pwnd;
    UINT msg;
    WPARAM wParam;
    ULONG_PTR xParam;
    PROC xpfnProc;
    PBYTE pOutput;
    DWORD cbOutput;
} FNPOUTLPINTMSG;

#ifdef SENDSIDE
SMESSAGECALL(POUTLPINT)
{
    DWORD cbCapture;
    LPINT pint = (LPINT)lParam;

    SETUPPWND(FNPOUTLPINT)

    cbCapture = (UINT)wParam * sizeof(INT);

    BEGINSENDCAPTURE(FNPOUTLPINT, 1, cbCapture, FALSE)

        MSGDATA()->pwnd = pwndClient;
        MSGDATA()->msg = msg;
        MSGDATA()->wParam = wParam;
        MSGDATA()->xParam = xParam;
        MSGDATA()->xpfnProc = xpfnProc;

        /*
         * Hooks should see the buffer content
         */
        if (dwSCMSFlags & SCMS_FLAGS_INONLY) {
            MSGDATA()->cbOutput = cbCapture;
            LARGECOPYBYTES2(pint, cbCapture, pOutput);
        } else {
            RESERVEBYTES(cbCapture, pOutput, cbOutput);
        }

        LOCKPWND();
        MAKECALLCAPTURE(FNPOUTLPINT);
        UNLOCKPWND();
        CHECKRETURN();

        BEGINCOPYOUT()
            try {
                ProbeForRead(pcbs->pOutput, pcbs->cbOutput, sizeof(DWORD));
                memcpy(pint, pcbs->pOutput, cbCapture);
            } except (W32ExceptionHandler(TRUE, RIP_WARNING)) {
                MSGERROR();
            }
        ENDCOPYOUT()

    TRACECALLBACKMSG("SfnPOUTLPINT");
    ENDSENDCAPTURE(LRESULT,0);
}
#endif // SENDSIDE

#ifdef RECVSIDE
RECVCALL(fnPOUTLPINT, FNPOUTLPINTMSG)
{
    BYTE abOutput[CALLBACKSTACKLIMIT];

    BEGINRECV(0, NULL, pmsg->cbOutput);
    FIXUPPOINTERS();
    if (pmsg->cbOutput <= CALLBACKSTACKLIMIT)
        CallbackStatus.pOutput = abOutput;
    else
        CallbackStatus.pOutput = pmsg->pOutput;

    retval = (ULONG_PTR)CALLPROC(CALLDATA(xpfnProc))(
            CALLDATA(pwnd),
            CALLDATA(msg),
            CALLDATA(wParam),
            (LPARAM)KPVOID_TO_PVOID(CallbackStatus.pOutput),
            CALLDATA(xParam));

    ENDRECV();
}
#endif // RECVSIDE

/**************************************************************************\
* fnPOPTINLPUINT
*
* NOTE!!! -- This function actually thunks arrays of INTs (32bit) and not
* WORDs (16bit).  The name was left the same to prevent a global rebuild
* of client and server.  The name should be changed to fnPOPTINLPINT as
* soon as we ship the beta!  The corresponding callforward function in
* cf2.h should also have its name changed.
*
* 22-Jul-1991 mikeke    Created
* 07-Jan-1993 JonPa     Changed to pass INTs instead of WORDs
\**************************************************************************/

typedef struct _FNPOPTINLPUINTMSG {
    CAPTUREBUF CaptureBuf;
    PWND pwnd;
    UINT msg;
    WPARAM wParam;
    LPWORD pw;
    ULONG_PTR xParam;
    PROC xpfnProc;
} FNPOPTINLPUINTMSG;

#ifdef SENDSIDE
SMESSAGECALL(POPTINLPUINT)
{
    LPWORD pw = (LPWORD)lParam;
    DWORD cCapture, cbCapture;

    SETUPPWND(FNPOPTINLPUINT);

    UNREFERENCED_PARAMETER(dwSCMSFlags);
    UNREFERENCED_PARAMETER(psms);

    if (lParam) {
        cCapture = 1;
        cbCapture = (UINT)wParam * sizeof(UINT);
    } else {
        cCapture = cbCapture = 0;
    }

    BEGINSENDCAPTURE(FNPOPTINLPUINT, cCapture, cbCapture, TRUE)

        MSGDATA()->pwnd = pwndClient;
        MSGDATA()->msg = msg;
        MSGDATA()->wParam = wParam;
        COPYBYTESOPT(pw, cbCapture);
        MSGDATA()->xParam = xParam;
        MSGDATA()->xpfnProc = xpfnProc;

        LOCKPWND();
        MAKECALLCAPTURE(FNPOPTINLPUINT);
        UNLOCKPWND();
        CHECKRETURN();

    TRACECALLBACKMSG("SfnPOPTINLPUINT");
    ENDSENDCAPTURE(LRESULT,0);
}
#endif // SENDSIDE

#ifdef RECVSIDE
RECVCALL(fnPOPTINLPUINT, FNPOPTINLPUINTMSG)
{
    BEGINRECV(0, NULL, 0);
    FIXUPPOINTERS();

    retval = (ULONG_PTR)CALLPROC(CALLDATA(xpfnProc))(
            CALLDATA(pwnd),
            CALLDATA(msg),
            CALLDATA(wParam),
            (LPDWORD)FIRSTFIXUPOPT(pw),
            CALLDATA(xParam));

    ENDRECV();
}
#endif // RECVSIDE

/**************************************************************************\
* fnINOUTLPWINDOWPOS (for WM_WINDOWPOSCHANGING message)
*
* 08-11-91 darrinm      Created.
\**************************************************************************/

typedef struct _FNINOUTLPWINDOWPOSMSG {
    PWND pwnd;
    UINT msg;
    WPARAM wParam;
    WINDOWPOS wp;
    ULONG_PTR xParam;
    PROC xpfnProc;
} FNINOUTLPWINDOWPOSMSG;

#ifdef SENDSIDE
SMESSAGECALL(INOUTLPWINDOWPOS)
{
    SETUPPWND(FNINOUTLPWINDOWPOS)

    UNREFERENCED_PARAMETER(dwSCMSFlags);

    BEGINSEND(FNINOUTLPWINDOWPOS)

        LPWINDOWPOS pwp = (LPWINDOWPOS)lParam;

        MSGDATA()->pwnd = pwndClient;
        MSGDATA()->msg = msg;
        MSGDATA()->wParam = wParam;
        MSGDATA()->wp = *pwp;
        MSGDATA()->xParam = xParam;
        MSGDATA()->xpfnProc = xpfnProc;

        LOCKPWND();
        MAKECALL(FNINOUTLPWINDOWPOS);
        UNLOCKPWND();
        CHECKRETURN();

        BEGINCOPYOUT()
            OUTSTRUCT(pwp, WINDOWPOS);
        ENDCOPYOUT()

    TRACECALLBACKMSG("SfnINOUTLPWINDOWPOS");
    ENDSEND(LRESULT,0);
}
#endif // SENDSIDE

#ifdef RECVSIDE
RECVCALL(fnINOUTLPWINDOWPOS, FNINOUTLPWINDOWPOSMSG)
{
    BEGINRECV(0, &pmsg->wp, sizeof(pmsg->wp));

    retval = (ULONG_PTR)CALLPROC(CALLDATA(xpfnProc))(
            pmsg->pwnd,
            pmsg->msg,
            pmsg->wParam,
            PCALLDATA(wp),
            pmsg->xParam);

    ENDRECV();
}
#endif // RECVSIDE


/**************************************************************************\
* fnINLPWINDOWPOS (for WM_WINDOWPOSCHANGED message)
*
* 08-11-91 darrinm      Created.
\**************************************************************************/

typedef struct _FNINLPWINDOWPOSMSG {
    PWND pwnd;
    UINT msg;
    WPARAM wParam;
    WINDOWPOS wp;
    ULONG_PTR xParam;
    PROC xpfnProc;
} FNINLPWINDOWPOSMSG;

#ifdef SENDSIDE
SMESSAGECALL(INLPWINDOWPOS)
{
    SETUPPWND(FNINLPWINDOWPOS)

    UNREFERENCED_PARAMETER(dwSCMSFlags);
    UNREFERENCED_PARAMETER(psms);

    BEGINSEND(FNINLPWINDOWPOS)

        LPWINDOWPOS pwp = (LPWINDOWPOS)lParam;

        MSGDATA()->pwnd = pwndClient;
        MSGDATA()->msg = msg;
        MSGDATA()->wParam = wParam;
        MSGDATA()->wp = *pwp;
        MSGDATA()->xParam = xParam;
        MSGDATA()->xpfnProc = xpfnProc;

        LOCKPWND();
        MAKECALL(FNINLPWINDOWPOS);
        UNLOCKPWND();
        CHECKRETURN();

    TRACECALLBACKMSG("SfnINLPWINDOWPOS");
    ENDSEND(LRESULT,0);
}
#endif // SENDSIDE

#ifdef RECVSIDE
RECVCALL(fnINLPWINDOWPOS, FNINLPWINDOWPOSMSG)
{
    BEGINRECV(0, NULL, 0);

    retval = (ULONG_PTR)CALLPROC(CALLDATA(xpfnProc))(
            CALLDATA(pwnd),
            CALLDATA(msg),
            CALLDATA(wParam),
            PCALLDATA(wp),
            CALLDATA(xParam));

    ENDRECV();
}
#endif // RECVSIDE




/**************************************************************************\
* fnINOUTNEXTMENU
*
* 22-Jul-1991 mikeke    Created
\**************************************************************************/

typedef struct _FNINOUTNEXTMENUMSG {
    PWND pwnd;
    UINT msg;
    WPARAM wParam;
    MDINEXTMENU mnm;
    ULONG_PTR xParam;
    PROC xpfnProc;
} FNINOUTNEXTMENUMSG;

#ifdef SENDSIDE
SMESSAGECALL(INOUTNEXTMENU)
{
    SETUPPWND(FNINOUTNEXTMENU)

    UNREFERENCED_PARAMETER(dwSCMSFlags);

    BEGINSEND(FNINOUTNEXTMENU)

        MSGDATA()->pwnd = pwndClient;
        MSGDATA()->msg = msg;
        MSGDATA()->wParam = wParam;
        MSGDATA()->xParam = xParam;
        MSGDATA()->xpfnProc = xpfnProc;
        MSGDATA()->mnm = *((PMDINEXTMENU)lParam);

        LOCKPWND();
        MAKECALL(FNINOUTNEXTMENU);
        UNLOCKPWND();
        CHECKRETURN();

        BEGINCOPYOUT()
            OUTSTRUCT(((PMDINEXTMENU)lParam), MDINEXTMENU);
        ENDCOPYOUT()

    TRACECALLBACKMSG("SfnINOUTNEXTMENU");
    ENDSEND(LRESULT,0);
}
#endif // SENDSIDE

#ifdef RECVSIDE
RECVCALL(fnINOUTNEXTMENU, FNINOUTNEXTMENUMSG)
{
    BEGINRECV(0, &pmsg->mnm, sizeof(pmsg->mnm));

    retval = (ULONG_PTR)CALLPROC(CALLDATA(xpfnProc))(
            CALLDATA(pwnd),
            CALLDATA(msg),
            CALLDATA(wParam),
            &CALLDATA(mnm),
            CALLDATA(xParam));

    ENDRECV();
}
#endif // RECVSIDE

/**************************************************************************\
* fnHkINLPCBTCREATESTRUCT
*
* 22-Jul-1991 mikeke    Created
\**************************************************************************/

typedef struct _CREATESTRUCTDATA {
    CREATESTRUCT cs;
    HWND hwndInsertAfter;
} CREATESTRUCTDATA;

typedef struct _FNHKINLPCBTCREATESTRUCTMSG {
    CAPTUREBUF CaptureBuf;
    PWND pwnd;
    UINT msg;
    WPARAM wParam;
    CREATESTRUCTDATA d;
    PROC xpfnProc;
    BOOL bAnsi;
} FNHKINLPCBTCREATESTRUCTMSG;

#ifdef SENDSIDE
LRESULT fnHkINLPCBTCREATESTRUCT(
    UINT msg,
    WPARAM wParam,
    LPCBT_CREATEWND pcbt,
    PROC xpfnProc,
    BOOL fAnsiReceiver)
{
    DWORD cbTitle = 0, cbClass = 0;
    DWORD cCapture = 0;
    CREATESTRUCTDATA csdOut;
    PCREATESTRUCTEX pcreatestruct;
    PWND pwnd = _GetDesktopWindow();

    SETUPPWND(FNHKINLPCBTCREATESTRUCT)

    /*
     * Compute ANSI capture lengths.  Don't capture if
     * the strings are in the client's address space.
     */
    pcreatestruct = (PCREATESTRUCTEX)pcbt->lpcs;
    if (pcreatestruct->cs.lpszName &&
            ((BOOL)pcreatestruct->strName.bAnsi != fAnsiReceiver ||
            IS_SYSTEM_ADDRESS((PVOID)pcreatestruct->cs.lpszName))) {
        CALC_SIZE_IN(cbTitle, &pcreatestruct->strName);
        cCapture++;
    }
    if (IS_PTR(pcreatestruct->cs.lpszClass) &&
            ((BOOL)pcreatestruct->strClass.bAnsi != fAnsiReceiver ||
            IS_SYSTEM_ADDRESS((PVOID)pcreatestruct->cs.lpszClass))) {
        CALC_SIZE_IN(cbClass, &pcreatestruct->strClass);
        cCapture++;
    }

    BEGINSENDCAPTURE(FNHKINLPCBTCREATESTRUCT, cCapture, cbTitle + cbClass, TRUE)

        MSGDATA()->pwnd = pwndClient;
        MSGDATA()->msg = msg;
        MSGDATA()->wParam = wParam;

        MSGDATA()->d.cs = *(pcbt->lpcs);

        if (cbTitle) {
            if (!pcreatestruct->strName.bAnsi) {
                WORD wOrdinal;

                try {
                    wOrdinal = *(PWORD)pcreatestruct->cs.lpszName;
                } except (W32ExceptionHandler(TRUE, RIP_WARNING)) {
                    goto errorexit;
                }
                if (wOrdinal == 0xffff) {

                    /*
                     * Copy out an ordinal of the form 0xffff, ID.
                     * If the receiver is ANSI, skip the first 0xff.
                     */
                    if (fAnsiReceiver) {
                        if (!NT_SUCCESS(CaptureCallbackData(&mp->CaptureBuf,
                                (PBYTE)pcreatestruct->cs.lpszName + 1,
                                3, (PVOID *)&mp->d.cs.lpszName)))
                            goto errorexit;
                    } else {
                        if (!NT_SUCCESS(CaptureCallbackData(&mp->CaptureBuf,
                                (PBYTE)pcreatestruct->cs.lpszName,
                                4, (PVOID *)&mp->d.cs.lpszName)))
                            goto errorexit;
                    }
                } else if (fAnsiReceiver) {
                    LARGECOPYSTRINGLPWSTRA(&pcreatestruct->strName, d.cs.lpszName);
                } else {
                    LARGECOPYSTRINGLPWSTR(&pcreatestruct->strName, d.cs.lpszName);
                }
            } else {
                BYTE bOrdinal;

                try {
                    bOrdinal = *(PBYTE)pcreatestruct->cs.lpszName;
                } except (W32ExceptionHandler(TRUE, RIP_WARNING)) {
                    goto errorexit;
                }
                if (bOrdinal == 0xff) {

                    /*
                     * Copy out an ordinal of the form 0xff, ID.
                     * If the receiver is UNICODE, expand the 0xff to 0xffff.
                     */
                    if (fAnsiReceiver) {
                        if (!NT_SUCCESS(CaptureCallbackData(&mp->CaptureBuf,
                                (PBYTE)pcreatestruct->cs.lpszName,
                                3, (PVOID *)&mp->d.cs.lpszName)))
                            goto errorexit;
                    } else {
                        DWORD dwOrdinal;

                        try {
                            dwOrdinal = MAKELONG(0xffff,
                                    (*(DWORD UNALIGNED *)pcreatestruct->cs.lpszName >> 8));
                        } except (W32ExceptionHandler(TRUE, RIP_WARNING)) {
                            goto errorexit;
                        }
                        if (!NT_SUCCESS(CaptureCallbackData(&mp->CaptureBuf,
                                &dwOrdinal,
                                4, (PVOID *)&mp->d.cs.lpszName)))
                            goto errorexit;
                    }
                } else if (fAnsiReceiver) {
                    LARGECOPYSTRINGLPSTR(&pcreatestruct->strName, d.cs.lpszName);
                } else {
                    LARGECOPYSTRINGLPSTRW(&pcreatestruct->strName, d.cs.lpszName);
                }
            }
        }
        if (cbClass) {
            if (!pcreatestruct->strClass.bAnsi) {
                if (fAnsiReceiver) {
                    LARGECOPYSTRINGLPWSTRA(&pcreatestruct->strClass, d.cs.lpszClass);
                } else {
                    LARGECOPYSTRINGLPWSTR(&pcreatestruct->strClass, d.cs.lpszClass);
                }
            } else {
                if (fAnsiReceiver) {
                    LARGECOPYSTRINGLPSTR(&pcreatestruct->strClass, d.cs.lpszClass);
                } else {
                    LARGECOPYSTRINGLPSTRW(&pcreatestruct->strClass, d.cs.lpszClass);
                }
            }
        }

        MSGDATA()->d.hwndInsertAfter = pcbt->hwndInsertAfter;
        MSGDATA()->xpfnProc = xpfnProc;
        MSGDATA()->bAnsi = fAnsiReceiver;

        LOCKPWND();
        MAKECALLCAPTURE(FNHKINLPCBTCREATESTRUCT);
        UNLOCKPWND();
        CHECKRETURN();

        /*
         * Probe output data
         */
        OUTSTRUCT(&csdOut, CREATESTRUCTDATA);

        // MS Visual C centers its dialogs with the CBT_CREATEHOOK
        pcbt->hwndInsertAfter = csdOut.hwndInsertAfter;
        pcbt->lpcs->x  = csdOut.cs.x;
        pcbt->lpcs->y  = csdOut.cs.y;
        pcbt->lpcs->cx = csdOut.cs.cx;
        pcbt->lpcs->cy = csdOut.cs.cy;

    TRACECALLBACK("SfnHkINLPCBTCREATESTRUCT");
    ENDSENDCAPTURE(DWORD,0);
}
#endif // SENDSIDE

#ifdef RECVSIDE
RECVCALL(fnHkINLPCBTCREATESTRUCT, FNHKINLPCBTCREATESTRUCTMSG)
{
    CBT_CREATEWND cbt;

    BEGINRECV(0, &pmsg->d, sizeof(pmsg->d));
    FIXUPPOINTERS();

    cbt.lpcs = &pmsg->d.cs;
    cbt.hwndInsertAfter = pmsg->d.hwndInsertAfter;
    if ((ULONG_PTR)pmsg->d.cs.lpszName > gHighestUserAddress)
        pmsg->d.cs.lpszName = REBASEPTR(pmsg->pwnd, pmsg->d.cs.lpszName);
    if ((ULONG_PTR)pmsg->d.cs.lpszClass > gHighestUserAddress)
        pmsg->d.cs.lpszClass = REBASEPTR(pmsg->pwnd, pmsg->d.cs.lpszClass);

    if (pmsg->bAnsi) {
        retval = DispatchHookA(
                pmsg->msg,
                pmsg->wParam,
                (LPARAM)&cbt,
                (HOOKPROC)pmsg->xpfnProc);
    } else {
        retval = DispatchHookW(
                pmsg->msg,
                pmsg->wParam,
                (LPARAM)&cbt,
                (HOOKPROC)pmsg->xpfnProc);
    }

    pmsg->d.hwndInsertAfter = cbt.hwndInsertAfter;
    pmsg->d.cs.x  = cbt.lpcs->x;
    pmsg->d.cs.y  = cbt.lpcs->y;
    pmsg->d.cs.cx = cbt.lpcs->cx;
    pmsg->d.cs.cy = cbt.lpcs->cy;

    ENDRECV();
}
#endif // RECVSIDE

#ifdef REDIRECTION

/**************************************************************************\
* fnHkINLPPOINT
*
* 29-Jan-1999 clupu    Created
\**************************************************************************/

typedef struct _FNHKINLPPOINTMSG {
    DWORD nCode;
    WPARAM wParam;
    POINT pt;
    ULONG_PTR xParam;
    PROC xpfnProc;
} FNHKINLPPOINTMSG;

#ifdef SENDSIDE
LRESULT fnHkINLPPOINT(
    IN DWORD nCode,
    IN WPARAM wParam,
    IN OUT LPPOINT ppt,
    IN ULONG_PTR xParam,
    IN PROC xpfnProc)
{
    SETUP(FNHKINLPPOINT)

    BEGINSEND(FNHKINLPPOINT)

        MSGDATA()->nCode = nCode;
        MSGDATA()->wParam = wParam;
        MSGDATA()->pt = *ppt;
        MSGDATA()->xParam = xParam;
        MSGDATA()->xpfnProc = xpfnProc;

        MAKECALL(FNHKINLPPOINT);
        CHECKRETURN();

        /*
         * Probe output data
         */
        OUTSTRUCT(ppt, POINT);

    TRACECALLBACK("SfnHkINLPPOINT");
    ENDSEND(DWORD,0);
}
#endif // SENDSIDE

#ifdef RECVSIDE
RECVCALL(fnHkINLPPOINT, FNHKINLPPOINTMSG)
{
    BEGINRECV(0, &pmsg->pt, sizeof(POINT));

    retval = (DWORD)CALLPROC(pmsg->xpfnProc)(
            pmsg->nCode,
            pmsg->wParam,
            PCALLDATA(pt),
            pmsg->xParam);

    ENDRECV();
}
#endif // RECVSIDE

#endif // REDIRECTION


/**************************************************************************\
* fnHkINLPRECT
*
* 22-Jul-1991 mikeke    Created
\**************************************************************************/

typedef struct _FNHKINLPRECTMSG {
    DWORD nCode;
    WPARAM wParam;
    RECT rect;
    ULONG_PTR xParam;
    PROC xpfnProc;
} FNHKINLPRECTMSG;

#ifdef SENDSIDE
LRESULT fnHkINLPRECT(
    IN DWORD nCode,
    IN WPARAM wParam,
    IN OUT LPRECT prect,
    IN ULONG_PTR xParam,
    IN PROC xpfnProc)
{
    SETUP(FNHKINLPRECT)

    BEGINSEND(FNHKINLPRECT)

        MSGDATA()->nCode = nCode;
        MSGDATA()->wParam = wParam;
        MSGDATA()->rect = *prect;
        MSGDATA()->xParam = xParam;
        MSGDATA()->xpfnProc = xpfnProc;

        MAKECALL(FNHKINLPRECT);
        CHECKRETURN();

        /*
         * Probe output data
         */
        OUTSTRUCT(prect, RECT);

    TRACECALLBACK("SfnHkINLPRECT");
    ENDSEND(DWORD,0);
}
#endif // SENDSIDE

#ifdef RECVSIDE
RECVCALL(fnHkINLPRECT, FNHKINLPRECTMSG)
{
    BEGINRECV(0, &pmsg->rect, sizeof(RECT));

    retval = (DWORD)CALLPROC(pmsg->xpfnProc)(
            pmsg->nCode,
            pmsg->wParam,
            PCALLDATA(rect),
            pmsg->xParam);

    ENDRECV();
}
#endif // RECVSIDE

/**************************************************************************\
* yyy
*
* 22-Jul-1991 mikeke    Created
\**************************************************************************/

typedef struct _FNHKINDWORDMSG {
    GENERICHOOKHEADER ghh;
    DWORD flags;
    LPARAM lParam;
} FNHKINDWORDMSG;

#ifdef SENDSIDE
LRESULT fnHkINDWORD(
    IN DWORD nCode,
    IN WPARAM wParam,
    IN LPARAM lParam,
    IN ULONG_PTR xParam,
    IN PROC xpfnProc,
    IN OUT LPDWORD lpFlags)
{
    SETUP(FNHKINDWORD)

    BEGINSEND(FNHKINDWORD)

        MSGDATA()->ghh.nCode = nCode;
        MSGDATA()->ghh.wParam = wParam;
        MSGDATA()->lParam = lParam;
        MSGDATA()->ghh.xParam = xParam;
        MSGDATA()->ghh.xpfnProc = xpfnProc;
        MSGDATA()->flags = *lpFlags;

        MAKECALL(FNHKINDWORD);
        CHECKRETURN();

        /*
         * Probe output data
         */
        OUTBITMASK(lpFlags, DWORD, HF_HOOKFAULTED);

    TRACECALLBACK("SfnHkINDWORD");
    ENDSEND(DWORD,0);
}
#endif // SENDSIDE

#ifdef RECVSIDE
RECVCALL(fnHkINDWORD, FNHKINDWORDMSG)
{
    BEGINRECV(0, &pmsg->flags, sizeof(pmsg->flags));

    retval = CallHookWithSEH((LPGENERICHOOKHEADER)pmsg, (LPVOID)pmsg->lParam, &pmsg->flags, retval);

    ENDRECV();
}
#endif // RECVSIDE

/**************************************************************************\
* yyy
*
* 22-Jul-1991 mikeke    Created
\**************************************************************************/

typedef struct _FNHKINLPMSGDATA {
    MSG msg;
    DWORD flags;
} FNHKINLPMSGDATA;

typedef struct _FNHKINLPMSGMSG {
    GENERICHOOKHEADER ghh;
    FNHKINLPMSGDATA d;
} FNHKINLPMSGMSG;

#ifdef SENDSIDE
LRESULT fnHkINLPMSG(
    DWORD nCode,
    WPARAM wParam,
    LPMSG pmsg,
    ULONG_PTR xParam,
    PROC xpfnProc,
    BOOL bAnsi,
    LPDWORD lpFlags)
{
    SETUP(FNHKINLPMSG)
    WPARAM wParamOriginal;

    BEGINSEND(FNHKINLPMSG)

        MSGDATA()->ghh.nCode = nCode;
        MSGDATA()->ghh.wParam = wParam;

        MSGDATA()->d.msg = *pmsg;
        if (((WM_CHAR == pmsg->message) || (WM_SYSCHAR == pmsg->message)) && bAnsi) {
            wParamOriginal = pmsg->wParam;
            RtlWCSMessageWParamCharToMB(pmsg->message, &(MSGDATA()->d.msg.wParam));
        }

        MSGDATA()->ghh.xParam = xParam;
        MSGDATA()->ghh.xpfnProc = xpfnProc;
        MSGDATA()->d.flags = *lpFlags;

        MAKECALL(FNHKINLPMSG);
        CHECKRETURN();

        /*
         * Probe output data
         */
        try {
            ProbeForRead(pcbs->pOutput, sizeof(FNHKINLPMSGDATA), sizeof(DWORD));
            *pmsg = ((FNHKINLPMSGDATA *)pcbs->pOutput)->msg;
            COPY_FLAG(*lpFlags, ((FNHKINLPMSGDATA *)pcbs->pOutput)->flags, HF_HOOKFAULTED);
        } except (W32ExceptionHandler(TRUE, RIP_WARNING)) {
            MSGERROR();
        }

        if (((WM_CHAR == pmsg->message) || (WM_SYSCHAR == pmsg->message)) && bAnsi) {
            /*
             * LATER, DBCS should be handled correctly.
             */
            /*
             * If the ANSI hook didn't change the wParam we sent it, restore
             * the Unicode value we started with, otherwise we just collapse
             * Unicode chars to an ANSI codepage (best visual fit or ?)
             * The rotten "Intellitype" point32.exe does this.
             */
            if (MSGDATA()->d.msg.wParam == pmsg->wParam) {
                pmsg->wParam = wParamOriginal;
            } else {
                RtlMBMessageWParamCharToWCS(pmsg->message, &pmsg->wParam);
            }
        }

    TRACECALLBACK("SfnHkINLPMSG");
    ENDSEND(DWORD,0);
}
#endif // SENDSIDE

#ifdef RECVSIDE
RECVCALL(fnHkINLPMSG, FNHKINLPMSGMSG)
{
    BEGINRECV(0, &pmsg->d, sizeof(pmsg->d));

    /*
     * LATER, DBCS should be handled correctly.
     */

    retval = CallHookWithSEH((LPGENERICHOOKHEADER)pmsg, &pmsg->d.msg, &pmsg->d.flags, retval);

    ENDRECV();
}
#endif // RECVSIDE

/**************************************************************************\
* yyy
*
* 22-Jul-1991 mikeke    Created
\**************************************************************************/

typedef struct _FNHKINLPMOUSEHOOKSTRUCTEXMSG {
    GENERICHOOKHEADER ghh;
    DWORD flags;
    MOUSEHOOKSTRUCTEX mousehookstructex;
} FNHKINLPMOUSEHOOKSTRUCTEXMSG;

#ifdef SENDSIDE
LRESULT fnHkINLPMOUSEHOOKSTRUCTEX(
    IN DWORD nCode,
    IN WPARAM wParam,
    IN LPMOUSEHOOKSTRUCTEX pmousehookstructex,
    IN ULONG_PTR xParam,
    IN PROC xpfnProc,
    IN OUT LPDWORD lpFlags)
{
    SETUP(FNHKINLPMOUSEHOOKSTRUCTEX)

    BEGINSEND(FNHKINLPMOUSEHOOKSTRUCTEX)

        MSGDATA()->ghh.nCode = nCode;
        MSGDATA()->ghh.wParam = wParam;
        MSGDATA()->mousehookstructex = *pmousehookstructex;
        MSGDATA()->ghh.xParam = xParam;
        MSGDATA()->ghh.xpfnProc = xpfnProc;
        MSGDATA()->flags = *lpFlags;

        MAKECALL(FNHKINLPMOUSEHOOKSTRUCTEX);
        CHECKRETURN();

        /*
         * Probe output data
         */
        OUTBITMASK(lpFlags, DWORD, HF_HOOKFAULTED);

    TRACECALLBACK("SfnHkINLPMOUSEHOOKSTRUCTEX");
    ENDSEND(DWORD,0);
}
#endif // SENDSIDE

#ifdef RECVSIDE
RECVCALL(fnHkINLPMOUSEHOOKSTRUCTEX, FNHKINLPMOUSEHOOKSTRUCTEXMSG)
{
    BEGINRECV(0, &pmsg->flags, sizeof(pmsg->flags));

    retval = CallHookWithSEH((LPGENERICHOOKHEADER)pmsg, &pmsg->mousehookstructex, &pmsg->flags, retval);

    ENDRECV();
}
#endif // RECVSIDE

/**************************************************************************\
* kbdll
*
* 06-Jun-1996 clupu    Created
\**************************************************************************/

typedef struct _FNHKINLPKBDLLHOOKSTRUCTMSG {
    GENERICHOOKHEADER ghh;
    KBDLLHOOKSTRUCT   kbdllhookstruct;
} FNHKINLPKBDLLHOOKSTRUCTMSG;

#ifdef SENDSIDE
LRESULT fnHkINLPKBDLLHOOKSTRUCT(
    IN DWORD nCode,
    IN WPARAM wParam,
    IN LPKBDLLHOOKSTRUCT pkbdllhookstruct,
    IN ULONG_PTR xParam,
    IN PROC xpfnProc)
{
    SETUP(FNHKINLPKBDLLHOOKSTRUCT)

    BEGINSEND(FNHKINLPKBDLLHOOKSTRUCT)

        MSGDATA()->ghh.nCode       = nCode;
        MSGDATA()->ghh.wParam      = wParam;
        MSGDATA()->kbdllhookstruct = *pkbdllhookstruct;
        MSGDATA()->ghh.xParam      = xParam;
        MSGDATA()->ghh.xpfnProc    = xpfnProc;

        MAKECALL(FNHKINLPKBDLLHOOKSTRUCT);
        CHECKRETURN();

    TRACECALLBACK("SfnHkINLPKBDLLHOOKSTRUCT");
    ENDSEND(DWORD,0);
}
#endif // SENDSIDE

#ifdef RECVSIDE
RECVCALL(fnHkINLPKBDLLHOOKSTRUCT, FNHKINLPKBDLLHOOKSTRUCTMSG)
{
    BEGINRECV(0, &pmsg->kbdllhookstruct, sizeof(pmsg->kbdllhookstruct));

    retval = (DWORD)CALLPROC(pmsg->ghh.xpfnProc)(
            pmsg->ghh.nCode,
            pmsg->ghh.wParam,
            &pmsg->kbdllhookstruct,
            pmsg->ghh.xParam);

    ENDRECV();
}
#endif // RECVSIDE


/**************************************************************************\
* msll
*
* 06-Jun-1996 clupu    Created
\**************************************************************************/

typedef struct _FNHKINLPMSLLHOOKSTRUCTMSG {
    GENERICHOOKHEADER ghh;
    MSLLHOOKSTRUCT    msllhookstruct;
} FNHKINLPMSLLHOOKSTRUCTMSG;

#ifdef SENDSIDE
LRESULT fnHkINLPMSLLHOOKSTRUCT(
    IN DWORD nCode,
    IN WPARAM wParam,
    IN LPMSLLHOOKSTRUCT pmsllhookstruct,
    IN ULONG_PTR xParam,
    IN PROC xpfnProc)
{
    SETUP(FNHKINLPMSLLHOOKSTRUCT)

    BEGINSEND(FNHKINLPMSLLHOOKSTRUCT)

        MSGDATA()->ghh.nCode      = nCode;
        MSGDATA()->ghh.wParam     = wParam;
        MSGDATA()->msllhookstruct = *pmsllhookstruct;
        MSGDATA()->ghh.xParam     = xParam;
        MSGDATA()->ghh.xpfnProc   = xpfnProc;

        MAKECALL(FNHKINLPMSLLHOOKSTRUCT);
        CHECKRETURN();

    TRACECALLBACK("SfnHkINLPMSLLHOOKSTRUCT");
    ENDSEND(DWORD,0);
}
#endif // SENDSIDE

#ifdef RECVSIDE
RECVCALL(fnHkINLPMSLLHOOKSTRUCT, FNHKINLPMSLLHOOKSTRUCTMSG)
{
    BEGINRECV(0, &pmsg->msllhookstruct, sizeof(pmsg->msllhookstruct));

    retval = (DWORD)CALLPROC(pmsg->ghh.xpfnProc)(
            pmsg->ghh.nCode,
            pmsg->ghh.wParam,
            &pmsg->msllhookstruct,
            pmsg->ghh.xParam);

    ENDRECV();
}
#endif // RECVSIDE

#ifdef REDIRECTION
/**************************************************************************\
* ht
*
* 21-Jan-1999 clupu    Created
\**************************************************************************/

typedef struct _FNHKINLPHTHOOKSTRUCTMSG {
    GENERICHOOKHEADER ghh;
    HTHOOKSTRUCT      hthookstruct;
} FNHKINLPHTHOOKSTRUCTMSG;

#ifdef SENDSIDE
LRESULT fnHkINLPHTHOOKSTRUCT(
    IN DWORD nCode,
    IN WPARAM wParam,
    IN OUT LPHTHOOKSTRUCT phthookstruct,
    IN ULONG_PTR xParam,
    IN PROC xpfnProc)
{
    SETUP(FNHKINLPHTHOOKSTRUCT)

    BEGINSEND(FNHKINLPHTHOOKSTRUCT)

        MSGDATA()->ghh.nCode      = nCode;
        MSGDATA()->ghh.wParam     = wParam;
        MSGDATA()->hthookstruct   = *phthookstruct;
        MSGDATA()->ghh.xParam     = xParam;
        MSGDATA()->ghh.xpfnProc   = xpfnProc;

        MAKECALL(FNHKINLPHTHOOKSTRUCT);
        CHECKRETURN();

        /*
         * Probe output data
         */
        if (phthookstruct != NULL)
            OUTSTRUCT(phthookstruct, HTHOOKSTRUCT);

    TRACECALLBACK("SfnHkINLPHTHOOKSTRUCT");
    ENDSEND(DWORD,0);
}
#endif // SENDSIDE

#ifdef RECVSIDE
RECVCALL(fnHkINLPHTHOOKSTRUCT, FNHKINLPHTHOOKSTRUCTMSG)
{
    BEGINRECV(0, &pmsg->hthookstruct, sizeof(pmsg->hthookstruct));

    retval = (DWORD)CALLPROC(pmsg->ghh.xpfnProc)(
            pmsg->ghh.nCode,
            pmsg->ghh.wParam,
            &pmsg->hthookstruct,
            pmsg->ghh.xParam);

    ENDRECV();
}
#endif // RECVSIDE

#endif // REDIRECTION

/**************************************************************************\
* yyy
*
* 22-Jul-1991 mikeke    Created
\**************************************************************************/

typedef struct _FNHKOPTINLPEVENTMSGMSG {
    DWORD nCode;
    WPARAM wParam;
    LPEVENTMSGMSG peventmsgmsg;
    ULONG_PTR xParam;
    PROC xpfnProc;
    EVENTMSG eventmsgmsg;
} FNHKOPTINLPEVENTMSGMSG;

#ifdef SENDSIDE
LRESULT fnHkOPTINLPEVENTMSG(
    IN DWORD nCode,
    IN WPARAM wParam,
    IN OUT LPEVENTMSGMSG peventmsgmsg,
    IN ULONG_PTR xParam,
    IN PROC xpfnProc)
{
    SETUP(FNHKOPTINLPEVENTMSG)

    BEGINSEND(FNHKOPTINLPEVENTMSG)

        MSGDATA()->nCode = nCode;
        MSGDATA()->wParam = wParam;
        COPYSTRUCTOPT(eventmsgmsg);
        MSGDATA()->xParam = xParam;
        MSGDATA()->xpfnProc = xpfnProc;

        MAKECALL(FNHKOPTINLPEVENTMSG);
        CHECKRETURN();

        /*
         * Probe output data
         */
        if (peventmsgmsg != NULL)
            OUTSTRUCT(peventmsgmsg, EVENTMSG);

    TRACECALLBACK("SfnHkOPTINLPEVENTMSG");
    ENDSEND(DWORD,-1);
}
#endif // SENDSIDE

#ifdef RECVSIDE
RECVCALL(fnHkOPTINLPEVENTMSG, FNHKOPTINLPEVENTMSGMSG)
{
    PHOOK phk;

    BEGINRECV(-1, &pmsg->eventmsgmsg, sizeof(pmsg->eventmsgmsg));

    if (pmsg->wParam) {
        phk = (PHOOK)HMValidateHandle((HANDLE)pmsg->wParam, TYPE_HOOK);

        if (phk != NULL) {
            /*
             * The HF_NEEDHC_SKIP bit is passed on from the pti when we need to
             * pass on a HC_SKIP
             */
            if ((phk->flags & HF_NEEDHC_SKIP) &&
                    (HIWORD(pmsg->nCode) == WH_JOURNALPLAYBACK)) {
                UserAssert(LOWORD(pmsg->nCode) == HC_GETNEXT);
                CALLPROC(pmsg->xpfnProc)(
                    MAKELONG(HC_SKIP, HIWORD(pmsg->nCode)),
                    0,
                    0,
                    pmsg->xParam);
            }

            /*
             * Make sure the hook wasn't free'd during the last call to the app
             */
            if (HMIsMarkDestroy(phk)) {
                retval = (DWORD)-1;
                goto AllDoneHere;
            }
        }
    }

    pmsg->wParam = 0;

    retval = (DWORD)CALLPROC(pmsg->xpfnProc)(
            pmsg->nCode,
            pmsg->wParam,
            PCALLDATAOPT(eventmsgmsg),
            pmsg->xParam);

AllDoneHere:
    ENDRECV();
}
#endif // RECVSIDE

/**************************************************************************\
* yyy
*
* 22-Jul-1991 mikeke    Created
\**************************************************************************/

/*
 * Create a structure big enough to hold the larges item LPARAM points to.
 */
typedef union _DEBUGLPARAM {
    MSG msg;                // WH_GETMESSAGE, WH_MSGFILTER, WH_SYSMSGFILTER
    CWPSTRUCT cwp;          // WH_CALLWNDPROC
    CWPRETSTRUCT cwpret;    // WH_CALLWNDPROCRET
    MOUSEHOOKSTRUCTEX mhs;  // WH_MOUSE, HCBT_CLICKSKIPPED
    EVENTMSG em;            // WH_JOURNALRECORD, WH_JOURNALPLAYBACK
    CBTACTIVATESTRUCT as;   // HCBT_ACTIVATE
    CBT_CREATEWND cw;       // HCBT_CREATEWND
    RECT rc;                // HCBT_MOVESIZE
} DEBUGLPARAM;


typedef struct _FNHKINLPDEBUGHOOKSTRUCTMSG {
    DWORD nCode;
    WPARAM wParam;
    DEBUGHOOKINFO debughookstruct;
    DEBUGLPARAM dbgLParam;
    DWORD cbDbgLParam;
    ULONG_PTR xParam;
    PROC xpfnProc;
} FNHKINLPDEBUGHOOKSTRUCTMSG;

#ifdef SENDSIDE
LRESULT fnHkINLPDEBUGHOOKSTRUCT(
    IN DWORD nCode,
    IN WPARAM wParam,
    IN LPDEBUGHOOKINFO pdebughookstruct,
    IN ULONG_PTR xParam,
    IN PROC xpfnProc)
{
    SETUP(FNHKINLPDEBUGHOOKSTRUCT)

    BEGINSEND(FNHKINLPDEBUGHOOKSTRUCT)

        MSGDATA()->nCode = nCode;
        MSGDATA()->wParam = wParam;
        MSGDATA()->debughookstruct = *pdebughookstruct;
        MSGDATA()->xParam = xParam;
        MSGDATA()->xpfnProc = xpfnProc;
        MSGDATA()->cbDbgLParam = GetDebugHookLParamSize(wParam, pdebughookstruct);

        switch(wParam) {
        case WH_MOUSE_LL:
        case WH_KEYBOARD_LL:
            return 0;
         }

        /*
         * if LPARAM in the debug hook points to struct then copy it over
         */
        if (MSGDATA()->cbDbgLParam) {
            try {
                RtlCopyMemory(&MSGDATA()->dbgLParam, (BYTE *)pdebughookstruct->lParam,
                        MSGDATA()->cbDbgLParam);
            } except (W32ExceptionHandler(FALSE, RIP_WARNING)) {
                MSGERROR();
            }
        }

        MAKECALL(FNHKINLPDEBUGHOOKSTRUCT);
        CHECKRETURN();

    TRACECALLBACK("SfnHkINLPDEBUGHOOKSTRUCT");
    ENDSEND(DWORD,0);
}
#endif // SENDSIDE

#ifdef RECVSIDE
RECVCALL(fnHkINLPDEBUGHOOKSTRUCT, FNHKINLPDEBUGHOOKSTRUCTMSG)
{
    BEGINRECV(0, NULL, 0);

    if (pmsg->cbDbgLParam) {
        pmsg->debughookstruct.lParam = (LPARAM)&(pmsg->dbgLParam);
    }

    retval = (DWORD)CALLPROC(pmsg->xpfnProc)(
            pmsg->nCode,
            pmsg->wParam,
            &(pmsg->debughookstruct),
            pmsg->xParam);

    ENDRECV();
}
#endif // RECVSIDE

DWORD GetDebugHookLParamSize(
    IN WPARAM wParam,
    IN PDEBUGHOOKINFO pdebughookstruct)
{
    DWORD cbDbgLParam = 0;

    switch(wParam) {
    case WH_MSGFILTER:
    case WH_SYSMSGFILTER:
    case WH_GETMESSAGE:
        cbDbgLParam = sizeof(MSG);
        break;

    case WH_CALLWNDPROC:
        cbDbgLParam = sizeof(CWPSTRUCT);
        break;

    case WH_CALLWNDPROCRET:
        cbDbgLParam = sizeof(CWPRETSTRUCT);
        break;

    case WH_MOUSE:
        cbDbgLParam = sizeof(MOUSEHOOKSTRUCTEX);
        break;

    case WH_JOURNALRECORD:
    case WH_JOURNALPLAYBACK:
        cbDbgLParam = sizeof(EVENTMSG);
        break;

    case WH_CBT:
        switch (pdebughookstruct->code) {
        case HCBT_ACTIVATE:
            cbDbgLParam = sizeof(CBTACTIVATESTRUCT);
            break;
        case HCBT_CLICKSKIPPED:
            cbDbgLParam = sizeof(MOUSEHOOKSTRUCTEX);
            break;
        case HCBT_CREATEWND:
            cbDbgLParam = sizeof(CBT_CREATEWND);
            break;
        case HCBT_MOVESIZE:
            cbDbgLParam = sizeof(RECT);
            break;
        }
        break;

    case WH_SHELL:
        if (pdebughookstruct->code == HSHELL_GETMINRECT) {
            cbDbgLParam = sizeof(RECT);
        }
        break;
    }
    return cbDbgLParam;
}

/**************************************************************************\
* fnHkINLPCBTACTIVATESTRUCT
*
* 17-Mar-1992 jonpa    Created
\**************************************************************************/

typedef struct _FNHKINLPCBTACTIVATESTRUCTMSG {
    DWORD nCode;
    WPARAM wParam;
    CBTACTIVATESTRUCT cbtactivatestruct;
    ULONG_PTR xParam;
    PROC xpfnProc;
} FNHKINLPCBTACTIVATESTRUCTMSG;

#ifdef SENDSIDE
LRESULT fnHkINLPCBTACTIVATESTRUCT(
    IN DWORD nCode,
    IN WPARAM wParam,
    IN LPCBTACTIVATESTRUCT pcbtactivatestruct,
    IN ULONG_PTR xParam,
    IN PROC xpfnProc)
{
    SETUP(FNHKINLPCBTACTIVATESTRUCT)

    BEGINSEND(FNHKINLPCBTACTIVATESTRUCT)

        MSGDATA()->nCode = nCode;
        MSGDATA()->wParam = wParam;
        MSGDATA()->cbtactivatestruct = *pcbtactivatestruct;
        MSGDATA()->xParam = xParam;
        MSGDATA()->xpfnProc = xpfnProc;

        MAKECALL(FNHKINLPCBTACTIVATESTRUCT);
        CHECKRETURN();

    TRACECALLBACK("SfnHkINLPCBTACTIVATESTRUCT");
    ENDSEND(DWORD,0);
}
#endif // SENDSIDE

#ifdef RECVSIDE
RECVCALL(fnHkINLPCBTACTIVATESTRUCT, FNHKINLPCBTACTIVATESTRUCTMSG)
{
    BEGINRECV(0, NULL, 0);

    retval = (DWORD)CALLPROC(pmsg->xpfnProc)(
            pmsg->nCode,
            pmsg->wParam,
            &(pmsg->cbtactivatestruct),
            pmsg->xParam);

    ENDRECV();
}
#endif // RECVSIDE


/**************************************************************************\
* ClientLoadMenu
*
* 22-Jul-1991 mikeke    Created
\**************************************************************************/

typedef struct _CLIENTLOADMENUMSG {
    CAPTUREBUF CaptureBuf;
    HANDLE hmod;
    UNICODE_STRING strName;
} CLIENTLOADMENUMSG;

#ifdef SENDSIDE
PMENU xxxClientLoadMenu(
    IN HANDLE hmod,
    IN PUNICODE_STRING pstrName)
{
    DWORD cCapture, cbCapture;

    SETUP(CLIENTLOADMENU)

    if (pstrName->MaximumLength) {
        cCapture = 1;
        cbCapture = pstrName->MaximumLength;
    } else
        cCapture = cbCapture = 0;

    BEGINSENDCAPTURE(CLIENTLOADMENU, cCapture, cbCapture, TRUE)

        MSGDATA()->hmod = hmod;
        COPYSTRINGID(strName);

        MAKECALLCAPTURE(CLIENTLOADMENU);
        CHECKRETURN();

        retval = (ULONG_PTR)HtoP((HMENU)retval);

    TRACECALLBACK("ClientLoadMenu");
    ENDSENDCAPTURE(PMENU,0);
}
#endif // SENDSIDE

#ifdef RECVSIDE
RECVCALL(ClientLoadMenu, CLIENTLOADMENUMSG)
{
    BEGINRECV(0, NULL, 0);
    FIXUPPOINTERS();

    retval = (ULONG_PTR)LoadMenu(
            CALLDATA(hmod) ? CALLDATA(hmod) : hmodUser,
            (LPTSTR)FIXUPSTRINGID(strName));

    ENDRECV();
}
#endif // RECVSIDE

/**************************************************************************\
* xxxClientLoadImage
*
* 28-Aug-1995 ChrisWil    Created
\**************************************************************************/

typedef struct _CLIENTLOADIMAGEMSG {
    CAPTUREBUF     CaptureBuf;
    UNICODE_STRING strModName;
    UNICODE_STRING strName;
    UINT           uImageType;
    int            cxDesired;
    int            cyDesired;
    UINT           LR_flags;
    BOOL           fWallpaper;
} CLIENTLOADIMAGEMSG;

#ifdef SENDSIDE
HANDLE xxxClientLoadImage(
    IN PUNICODE_STRING pstrName,
    IN ATOM            atomModName,
    IN WORD            wImageType,
    IN int             cxDesired,
    IN int             cyDesired,
    IN UINT            LR_flags,
    IN BOOL            fWallpaper)
{
    DWORD           cCapture;
    DWORD           cbCapture;
    WCHAR           awszModName[MAX_PATH];
    UNICODE_STRING  strModName;
    PUNICODE_STRING pstrModName = &strModName;

    SETUP(CLIENTLOADIMAGE)

    if (pstrName->MaximumLength) {
        cCapture  = 1;
        cbCapture = pstrName->MaximumLength;
    } else {
        cCapture  =
        cbCapture = 0;
    }
    if (atomModName && atomModName != atomUSER32) {
        UserGetAtomName(atomModName, awszModName, MAX_PATH);
        RtlInitUnicodeString(&strModName, awszModName);
    } else {
        strModName.Length = strModName.MaximumLength = 0;
        strModName.Buffer = NULL;
    }
    if (pstrModName->MaximumLength) {
        cCapture++;
        cbCapture += pstrModName->MaximumLength;
    }

    BEGINSENDCAPTURE(CLIENTLOADIMAGE, cCapture, cbCapture, TRUE)

        COPYSTRINGOPT(strModName);
        COPYSTRINGID(strName);
        MSGDATA()->uImageType = (UINT)wImageType;
        MSGDATA()->cxDesired  = cxDesired;
        MSGDATA()->cyDesired  = cyDesired;
        MSGDATA()->LR_flags   = LR_flags;
        MSGDATA()->fWallpaper = fWallpaper;

        MAKECALLCAPTURE(CLIENTLOADIMAGE);
        CHECKRETURN();

        if (retval && (wImageType != IMAGE_BITMAP)) {
            retval = (ULONG_PTR)HMRevalidateHandle((HANDLE)retval);
        }

    TRACECALLBACK("ClientLoadImage");
    ENDSENDCAPTURE(PCURSOR,0);
}
#endif // SENDSIDE

#ifdef RECVSIDE
RECVCALL(ClientLoadImage, CLIENTLOADIMAGEMSG)
{
    HMODULE hmod;
    LPTSTR  filepart;
    LPTSTR  lpszName;
    TCHAR   szFullPath[MAX_PATH];
    TCHAR   szExpandedPath[MAX_PATH];
    DWORD   dwRet;

    BEGINRECV(0, NULL, 0);
    FIXUPPOINTERS();

    if (hmod = (HMODULE)FIXUPSTRINGIDOPT(strModName)) {

        if ((hmod = GetModuleHandle((LPTSTR)hmod)) == NULL) {
            MSGERROR();
        }
    }

    /*
     * Find the file.  This normalizes the filename.
     */
    lpszName = (LPTSTR)FIXUPSTRINGID(strName);

    if (CALLDATA(fWallpaper)) {

        /*
         * Expand any environment strings in the path. This is beneficial
         * for people using roaming profiles. See bug #89188.
         */
        dwRet = ExpandEnvironmentStrings(lpszName, szExpandedPath, MAX_PATH);

        /*
         * dwRet > MAX_PATH means that the buffer we supplied was too small. If
         * this happens, there's no way the LoadImage can succeed - even if the
         * buffer were big enough, as the filename can't possibly refer to a
         * valid file - so fail the call.
         */
        if (dwRet == 0 || dwRet > MAX_PATH) {
            MSGERROR();
        }

        if (!SearchPath(NULL,
                       szExpandedPath,
                       TEXT(".bmp"),
                       ARRAY_SIZE(szFullPath),
                       szFullPath,
                       &filepart)) {

            MSGERROR();
        }

        lpszName = szFullPath;
    }

    retval = (ULONG_PTR)LoadImage(hmod,
                              lpszName,
                              CALLDATA(uImageType),
                              CALLDATA(cxDesired),
                              CALLDATA(cyDesired),
                              CALLDATA(LR_flags));

    ENDRECV();
}
#endif // RECVSIDE

/***********************************************************************\
* xxxClientCopyImage
*
* Returns: hIconCopy - note LR_flags could cause this to be the same as
*       what came in.
*
* 11/3/1995 Created SanfordS
\***********************************************************************/

typedef struct _CLIENTCOPYIMAGEMSG {
    HANDLE         hImage;
    UINT           uImageType;
    int            cxDesired;
    int            cyDesired;
    UINT           LR_flags;
} CLIENTCOPYIMAGEMSG;

#ifdef SENDSIDE
HANDLE xxxClientCopyImage(
    IN HANDLE          hImage,
    IN UINT            uImageType,
    IN int             cxDesired,
    IN int             cyDesired,
    IN UINT            LR_flags)
{
    SETUP(CLIENTCOPYIMAGE)

    BEGINSEND(CLIENTCOPYIMAGE)

        MSGDATA()->hImage     = hImage;
        MSGDATA()->uImageType = uImageType;
        MSGDATA()->cxDesired  = cxDesired;
        MSGDATA()->cyDesired  = cyDesired;
        MSGDATA()->LR_flags   = LR_flags;

        MAKECALL(CLIENTCOPYIMAGE);
        CHECKRETURN();

        if (retval && (uImageType != IMAGE_BITMAP)) {
            retval = (ULONG_PTR)HMRevalidateHandle((HANDLE)retval);
        }

    TRACECALLBACK("ClientCopyImage");
    ENDSEND(HANDLE,0);
}
#endif // SENDSIDE

#ifdef RECVSIDE
RECVCALL(ClientCopyImage, CLIENTCOPYIMAGEMSG)
{
    BEGINRECV(0, NULL, 0);

    retval = (ULONG_PTR)InternalCopyImage(CALLDATA(hImage),
                                      CALLDATA(uImageType),
                                      CALLDATA(cxDesired),
                                      CALLDATA(cyDesired),
                                      CALLDATA(LR_flags));

    ENDRECV();
}
#endif // RECVSIDE

/**************************************************************************\
* yyy
*
* 22-Jul-1991 mikeke    Created
\**************************************************************************/

typedef struct _CLIENTGETLISTBOXSTRINGMSG {
    CAPTUREBUF CaptureBuf;
    PWND pwnd;
    UINT msg;
    WPARAM wParam;
    ULONG_PTR xParam;
    PROC xpfn;
    PBYTE pOutput;
    DWORD cbOutput;
} CLIENTGETLISTBOXSTRINGMSG;

#ifdef SENDSIDE
DWORD ClientGetListboxString(
    IN PWND pwnd,
    IN UINT msg,
    IN WPARAM wParam,
    OUT PVOID pdata,
    IN ULONG_PTR xParam,
    IN PROC xpfn,
    IN DWORD dwSCMSFlags,
    IN BOOL bNotString,
    IN PSMS psms)
{
    DWORD cbCapture;
    DWORD cchRet;
    PLARGE_STRING pstr;
    BOOL fAnsiReceiver = (dwSCMSFlags & SCMS_FLAGS_ANSI);

    SETUPPWND(CLIENTGETLISTBOXSTRING)

    CheckLock(pwnd);

    pstr = (PLARGE_STRING)pdata;
    cbCapture = pstr->MaximumLength;

    BEGINSENDCAPTURE(CLIENTGETLISTBOXSTRING, 1, cbCapture, FALSE)

        MSGDATA()->pwnd = pwndClient;
        MSGDATA()->msg = msg;
        MSGDATA()->wParam = wParam;
        MSGDATA()->xParam = xParam;
        MSGDATA()->xpfn = xpfn;

        RESERVEBYTES(cbCapture, pOutput, cbOutput);

        LOCKPWND();
        MAKECALLCAPTURE(CLIENTGETLISTBOXSTRING);
        UNLOCKPWND();
        CHECKRETURN();

        BEGINCOPYOUT()
            if (bNotString) {
                /*
                 * This is a 4-byte "object" for ownerdraw listboxes without
                 * the LBS_HASSTRINGS style.
                 */
                OUTSTRUCT((PULONG_PTR)pstr->Buffer, ULONG_PTR);
            } else {
                COPYOUTLPWSTRLIMIT(pstr,
                        pstr->bAnsi ? (int)pstr->MaximumLength :
                        (int)pstr->MaximumLength / sizeof(WCHAR));
            }

            cchRet = pstr->Length;
            if (!pstr->bAnsi)
                cchRet *= sizeof(WCHAR);
            if (!bNotString && retval != LB_ERR && retval > cchRet) {
                RIPMSG2(RIP_WARNING, "GetListBoxString: limit %lX chars to %lX\n",
                        retval, cchRet);
                retval = cchRet;
            }
        ENDCOPYOUT()

    TRACECALLBACK("ClientGetListboxString");
    ENDSENDCAPTURE(DWORD,0);
}
#endif // SENDSIDE

#ifdef RECVSIDE
RECVCALL(ClientGetListboxString, CLIENTGETLISTBOXSTRINGMSG)
{
    BYTE abOutput[CALLBACKSTACKLIMIT];

    BEGINRECV(0, NULL, pmsg->cbOutput);
    FIXUPPOINTERS();
    if (pmsg->cbOutput <= CALLBACKSTACKLIMIT)
        CallbackStatus.pOutput = abOutput;
    else
        CallbackStatus.pOutput = pmsg->pOutput;

    retval = (DWORD)_ClientGetListboxString(
            CALLDATA(pwnd),
            CALLDATA(msg),
            CALLDATA(wParam),
            (LPSTR)KPVOID_TO_PVOID(CallbackStatus.pOutput),
            CALLDATA(xParam),
            CALLDATA(xpfn));

    ENDRECV();
}
#endif // RECVSIDE

/**************************************************************************\
* yyy
*
* 22-Jul-1991 mikeke    Created
\**************************************************************************/

typedef struct _CLIENTLOADLIBRARYMSG {
    CAPTUREBUF CaptureBuf;
    UNICODE_STRING strLib;
    ULONG_PTR      offPfnInitUserApiHook;
} CLIENTLOADLIBRARYMSG;

#ifdef SENDSIDE
HANDLE ClientLoadLibrary(
    IN PUNICODE_STRING pstrLib,
    IN ULONG_PTR offPfnInitUserApiHook)
{
    SETUP(CLIENTLOADLIBRARY)

    BEGINSENDCAPTURE(CLIENTLOADLIBRARY, 1, pstrLib->MaximumLength, TRUE)

        MSGDATA()->offPfnInitUserApiHook = offPfnInitUserApiHook;
        COPYSTRING(strLib);

        MAKECALLCAPTURE(CLIENTLOADLIBRARY);
        CHECKRETURN();

    TRACECALLBACK("ClientLoadLibrary");
    ENDSENDCAPTURE(HANDLE,0);
}
#endif // SENDSIDE

#ifdef RECVSIDE
RECVCALL(ClientLoadLibrary, CLIENTLOADLIBRARYMSG)
{
    BEGINRECV(0, NULL, 0);
    FIXUPPOINTERS();

    retval = (ULONG_PTR)LoadLibraryEx((LPTSTR)FIXUPSTRING(strLib), NULL, LOAD_WITH_ALTERED_SEARCH_PATH);

    /*
     * If we're loading the module containing the UserApiHook's,
     * make sure it's correctly initialized.
     */
    if ((retval != 0) && CALLDATA(offPfnInitUserApiHook)) {
        if (!InitUserApiHook((HMODULE)retval, CALLDATA(offPfnInitUserApiHook))) {
            FreeLibrary((HMODULE)retval);
            retval = 0;
            MSGERROR();
        }
    }

    ENDRECV();
}
#endif // RECVSIDE

/**************************************************************************\
* yyy
*
* 22-Jul-1991 mikeke    Created
\**************************************************************************/

typedef struct _CLIENTFREELIBRARYMSG {
    HANDLE hmod;
} CLIENTFREELIBRARYMSG;

#ifdef SENDSIDE
BOOL ClientFreeLibrary(
    IN HANDLE hmod)
{
    SETUP(CLIENTFREELIBRARY)

    BEGINSEND(CLIENTFREELIBRARY)

        MSGDATA()->hmod = hmod;

        MAKECALL(CLIENTFREELIBRARY);
        CHECKRETURN();

    TRACECALLBACK("ClientFreeLibrary");
    ENDSEND(BOOL,0);
}
#endif // SENDSIDE

#ifdef RECVSIDE
RECVCALL(ClientFreeLibrary, CLIENTFREELIBRARYMSG)
{
    BEGINRECV(0, NULL, 0);

    /*
     * Make sure we don't free a UserApiHook module that's in use.
     */
    if (!ClearUserApiHook(CALLDATA(hmod))) {
        MSGERROR();
    }

    retval = (DWORD)FreeLibrary(CALLDATA(hmod));

    ENDRECV();
}
#endif // RECVSIDE


#ifdef MESSAGE_PUMP_HOOK

/**************************************************************************\
* GetMessageMPH()
*
* 06-Dec-2000   JStall      Created
\**************************************************************************/

typedef struct _CLIENTGETMESSAGEMPHMSG {
    HWND        hwndFilter;
    UINT        msgMin;
    UINT        msgMax;
    UINT        flags;
    BOOL        fGetMessage;
} CLIENTGETMESSAGEMPHMSG;

#ifdef SENDSIDE
BOOL ClientGetMessageMPH(
    IN MSG * pmsg,
    IN HWND hwndFilter,
    IN UINT msgMin,
    IN UINT msgMax,
    IN UINT flags,
    IN BOOL fGetMessage)
{
    SETUP(CLIENTGETMESSAGEMPH)

    BEGINSEND(CLIENTGETMESSAGEMPH)

        MSGDATA()->hwndFilter = hwndFilter;
        MSGDATA()->msgMin = msgMin;
        MSGDATA()->msgMax = msgMax;
        MSGDATA()->flags = flags;
        MSGDATA()->fGetMessage = fGetMessage;

        MAKECALL(CLIENTGETMESSAGEMPH);
        CHECKRETURN();

        OUTSTRUCT(pmsg, MSG);

    TRACECALLBACK("ClientGetMessageMPH");
    ENDSEND(BOOL,0);
}
#endif // SENDSIDE

#ifdef RECVSIDE
RECVCALL(ClientGetMessageMPH, CLIENTGETMESSAGEMPHMSG)
{
    MSG msg;

    BEGINRECV(0, &msg, sizeof(msg));

    retval = (ULONG_PTR)(gmph.pfnInternalGetMessage)(&msg, CALLDATA(hwndFilter),
            CALLDATA(msgMin), CALLDATA(msgMax), CALLDATA(flags), CALLDATA(fGetMessage));

    ENDRECV();
}
#endif // RECVSIDE


/**************************************************************************\
* WaitMessageMPH()
*
* 06-Dec-2000   JStall      Created
\**************************************************************************/

typedef struct _CLIENTWAITMESSAGEEXMPHMSG {
    UINT        fsWakeMask;
    DWORD       Timeout;
} CLIENTWAITMESSAGEEXMPHMSG;

#ifdef SENDSIDE
BOOL ClientWaitMessageExMPH(
    IN UINT fsWakeMask,
    IN DWORD Timeout)
{
    SETUP(CLIENTWAITMESSAGEEXMPH)

    BEGINSEND(CLIENTWAITMESSAGEEXMPH)

        MSGDATA()->fsWakeMask = fsWakeMask;
        MSGDATA()->Timeout = Timeout;

        MAKECALL(CLIENTWAITMESSAGEEXMPH);
        CHECKRETURN();

    TRACECALLBACK("ClientWaitMessageExMPH");
    ENDSEND(BOOL,0);
}
#endif // SENDSIDE

#ifdef RECVSIDE
RECVCALL(ClientWaitMessageExMPH, CLIENTWAITMESSAGEEXMPHMSG)
{
    BEGINRECV(0, NULL, 0);

    retval = (ULONG_PTR)(gmph.pfnWaitMessageEx)(CALLDATA(fsWakeMask), CALLDATA(Timeout));

    ENDRECV();
}
#endif // RECVSIDE

#endif // MESSAGE_PUMP_HOOK


/**************************************************************************\
* xxxClientGetCharsetInfo
*
* 96-06-11  IanJa     Created
\**************************************************************************/

typedef struct _CLIENTGETCHARSETINFOMSG {
    LCID lcid;
    CHARSETINFO cs;
} CLIENTGETCHARSETINFOMSG;

#ifdef SENDSIDE
BOOL xxxClientGetCharsetInfo(
    IN LCID lcid,
    OUT PCHARSETINFO pcs)
{
    SETUP(CLIENTGETCHARSETINFO)

    BEGINSEND(CLIENTGETSCHARSETINFO)

        MSGDATA()->lcid = lcid;

        MAKECALL(CLIENTGETCHARSETINFO);
        CHECKRETURN();

        OUTSTRUCT(pcs, CHARSETINFO);

    TRACECALLBACK("ClientGetCharsetInfo");
    ENDSEND(BOOL,0);
}
#endif // SENDSIDE

#ifdef RECVSIDE
RECVCALL(ClientGetCharsetInfo, CLIENTGETCHARSETINFOMSG)
{
    BEGINRECV(0, &pmsg->cs, sizeof(CHARSETINFO));

    // TCI_SRCLOCALE = 0x1000
    // Sundown: lcid value should be zero-extended in the TCI_SRCLOCALE case.
    retval = (DWORD)TranslateCharsetInfo((DWORD *)ULongToPtr( pmsg->lcid ), &pmsg->cs, TCI_SRCLOCALE);

    ENDRECV();
}
#endif // RECVSIDE

/**************************************************************************\
* ClientFreeDDEHandle
*
* 9-29-91 sanfords     Created.
\**************************************************************************/

typedef struct _CLIENTFREEDDEHANDLEMSG {
    HANDLE hClient;
    DWORD flags;
} CLIENTFREEDDEHANDLEMSG;

#ifdef SENDSIDE
DWORD ClientFreeDDEHandle(
    IN HANDLE hClient,
    IN DWORD flags)
{
    SETUP(CLIENTFREEDDEHANDLE)

    BEGINSEND(CLIENTFREEDDEHANDLE)

        MSGDATA()->hClient = hClient;
        MSGDATA()->flags = flags;

        MAKECALL(CLIENTFREEDDEHANDLE);
        CHECKRETURN();

    TRACECALLBACK("ClientFreeDDEHandle");
    ENDSEND(DWORD, 0);
}
#endif // SENDSIDE



#ifdef RECVSIDE
RECVCALL(ClientFreeDDEHandle, CLIENTFREEDDEHANDLEMSG)
{
    BEGINRECV(0, NULL, 0);
    _ClientFreeDDEHandle(CALLDATA(hClient), CALLDATA(flags));
    ENDRECV();
}
#endif // RECVSIDE




/**************************************************************************\
* ClientGetDDEFlags
*
* This function is used to get a peek at the wStatus flags packed within
* DDE handles - this could either be within the DdePack structure directly
* or within the direct data handle given or referenced via the DdePack
* structure.  flags is used to figure out the right thing to do.
*
* 9-29-91 sanfords     Created.
\**************************************************************************/

typedef struct _CLIENTGETDDEFLAGSMSG {
    HANDLE hClient;
    DWORD flags;
} CLIENTGETDDEFLAGSMSG;

#ifdef SENDSIDE
DWORD ClientGetDDEFlags(
    IN HANDLE hClient,
    IN DWORD flags)
{
    SETUP(CLIENTGETDDEFLAGS)

    BEGINSEND(CLIENTGETDDEFLAGS)

        MSGDATA()->hClient = hClient;
        MSGDATA()->flags = flags;

        MAKECALL(CLIENTGETDDEFLAGS);
        CHECKRETURN();

    TRACECALLBACK("ClientGetDDEFlags");
    ENDSEND(DWORD, 0);
}
#endif // SENDSIDE



#ifdef RECVSIDE
RECVCALL(ClientGetDDEFlags, CLIENTGETDDEFLAGSMSG)
{
    BEGINRECV(0, NULL, 0);
    retval = _ClientGetDDEFlags(CALLDATA(hClient), CALLDATA(flags));
    ENDRECV();
}
#endif // RECVSIDE



/************************************************************************
* ClientCopyDDEIn1
*
* History:
* 10-22-91    sanfords    Created
\***********************************************************************/

typedef struct _CLIENTCOPYDDEIN1MSG {
    HANDLE hClient;      // client side DDE handle - non-0 on initial call
    DWORD flags;
} CLIENTCOPYDDEIN1MSG;

#ifdef SENDSIDE
DWORD xxxClientCopyDDEIn1(
    HANDLE hClient,
    DWORD flags,
    PINTDDEINFO *ppi)
{
    PINTDDEINFO pi;
    INTDDEINFO IntDdeInfo;

    SETUP(CLIENTCOPYDDEIN1)

    BEGINSEND(CLIENTCOPYDDEIN1)

        retval = FAIL_POST;
        *ppi = NULL;
        MSGDATA()->hClient = hClient;
        MSGDATA()->flags = flags;

        MAKECALL(CLIENTCOPYDDEIN1);
        CHECKRETURN();

        if (retval != DO_POST) {
            MSGERROR();
        }

        try {
            OUTSTRUCT(&IntDdeInfo, INTDDEINFO);

            pi = (PINTDDEINFO)UserAllocPool(
                    sizeof(INTDDEINFO) + IntDdeInfo.cbDirect +
                    IntDdeInfo.cbIndirect, TAG_DDE);

            if (pi != NULL) {
                *ppi = pi;
                *pi = IntDdeInfo;

                if (IntDdeInfo.cbDirect) {
                    RtlCopyMemory((PBYTE)pi + sizeof(INTDDEINFO),
                            IntDdeInfo.pDirect,
                            IntDdeInfo.cbDirect);
                }

                if (IntDdeInfo.cbIndirect) {
                    RtlCopyMemory((PBYTE)pi + sizeof(INTDDEINFO) +
                                IntDdeInfo.cbDirect,
                            IntDdeInfo.pIndirect,
                            IntDdeInfo.cbIndirect);
                }

                xxxClientCopyDDEIn2(pi);

            } else {
                retval = FAILNOFREE_POST;
            }
        } except (W32ExceptionHandler(TRUE, RIP_WARNING)) {
            if (pi != NULL)
                UserFreePool(pi);
            retval = FAILNOFREE_POST;
            MSGERROR();
        }

    TRACECALLBACK("ClientCopyDDEIn1");
    ENDSEND(DWORD, retval);
}
#endif // SENDSIDE

#ifdef RECVSIDE
RECVCALL(ClientCopyDDEIn1, CLIENTCOPYDDEIN1MSG)
{
    INTDDEINFO IntDdeInfo;

    BEGINRECV(0, &IntDdeInfo, sizeof(INTDDEINFO));

    IntDdeInfo.flags = CALLDATA(flags);
    retval = _ClientCopyDDEIn1(CALLDATA(hClient), &IntDdeInfo);

    ENDRECV();
}
#endif // RECVSIDE


/************************************************************************
* ClientCopyDDEIn2
*
* History:
* 9-3-91    sanfords    Created
\***********************************************************************/

typedef struct _CLIENTCOPYDDEIN2MSG {
    INTDDEINFO IntDdeInfo;
} CLIENTCOPYDDEIN2MSG;

#ifdef SENDSIDE
BOOL xxxClientCopyDDEIn2(
    PINTDDEINFO pi)
{
    SETUP(CLIENTCOPYDDEIN2)

    BEGINSEND(CLIENTCOPYDDEIN2)

        MSGDATA()->IntDdeInfo = *pi;

        MAKECALL(CLIENTCOPYDDEIN2);
        CHECKRETURN();

    TRACECALLBACK("ClientCopyDDEIn2");
    ENDSEND(BOOL, 0);
}
#endif // SENDSIDE

#ifdef RECVSIDE
RECVCALL(ClientCopyDDEIn2, CLIENTCOPYDDEIN2MSG)
{
    BEGINRECV(0, NULL, 0);

    _ClientCopyDDEIn2(PCALLDATA(IntDdeInfo));

    ENDRECV();
}
#endif // RECVSIDE



/************************************************************************
* ClientCopyDDEOut2
*
* History:
* 10-22-91    sanfords    Created
\***********************************************************************/

typedef struct _CLIENTCOPYDDEOUT2MSG {
    INTDDEINFO IntDdeInfo;
} CLIENTCOPYDDEOUT2MSG;

#ifdef SENDSIDE
DWORD xxxClientCopyDDEOut2(
    PINTDDEINFO pi)
{
    SETUP(CLIENTCOPYDDEOUT2)

    BEGINSEND(CLIENTCOPYDDEOUT2)

        MSGDATA()->IntDdeInfo = *pi;

        MAKECALL(CLIENTCOPYDDEOUT2);
        /*
         * This read is covered by a try/except in ClientCopyDDEOut1.
         */
        pi->hDirect = MSGDATA()->IntDdeInfo.hDirect;
        CHECKRETURN();

    TRACECALLBACK("ClientCopyDDEOut2");
    ENDSEND(DWORD, 0);
}
#endif // SENDSIDE

#ifdef RECVSIDE
RECVCALL(ClientCopyDDEOut2, CLIENTCOPYDDEOUT2MSG)
{
    BEGINRECV(0, NULL, 0);

    retval = _ClientCopyDDEOut2(PCALLDATA(IntDdeInfo));

    ENDRECV();
}
#endif // RECVSIDE

/************************************************************************
* ClientCopyDDEOut1
*
* History:
* 10-22-91    sanfords    Created
\***********************************************************************/

typedef struct _CLIENTCOPYDDEOUT1MSG {
    INTDDEINFO IntDdeInfo;
} CLIENTCOPYDDEOUT1MSG;

#ifdef SENDSIDE
HANDLE xxxClientCopyDDEOut1(
    PINTDDEINFO pi)
{
    INTDDEINFO IntDdeInfo;

    SETUP(CLIENTCOPYDDEOUT1)

    BEGINSEND(CLIENTCOPYDDEOUT1)

        MSGDATA()->IntDdeInfo = *pi;

        MAKECALL(CLIENTCOPYDDEOUT1);
        CHECKRETURN();

        if (retval) {
            try {
                OUTSTRUCT(&IntDdeInfo, INTDDEINFO);

                if (pi->cbDirect) {
                    ProbeForWrite(IntDdeInfo.pDirect,
                            pi->cbDirect,
                            sizeof(BYTE));
                    RtlCopyMemory(IntDdeInfo.pDirect,
                            (PBYTE)pi + sizeof(INTDDEINFO),
                            pi->cbDirect);
                }

                if (pi->cbIndirect) {
                    ProbeForWrite(IntDdeInfo.pIndirect,
                            pi->cbIndirect,
                            sizeof(BYTE));
                    RtlCopyMemory(IntDdeInfo.pIndirect,
                            (PBYTE)pi + sizeof(INTDDEINFO) + pi->cbDirect,
                            pi->cbIndirect);
                }

                if (IntDdeInfo.hDirect != NULL) {
                    BOOL fSuccess = xxxClientCopyDDEOut2(&IntDdeInfo);
                    if (fSuccess && IntDdeInfo.flags & XS_EXECUTE) {
                        /*
                         * In case value was changed by Execute Fixup.
                         */
                        retval = (ULONG_PTR)IntDdeInfo.hDirect;
                    }
                }
                *pi = IntDdeInfo;
            } except (W32ExceptionHandler(TRUE, RIP_WARNING)) {
                retval = 0;
                MSGERROR();
            }
        }

    TRACECALLBACK("ClientCopyDDEOut1");
    ENDSEND(HANDLE, 0);
}
#endif // SENDSIDE



#ifdef RECVSIDE
RECVCALL(ClientCopyDDEOut1, CLIENTCOPYDDEOUT1MSG)
{
    BEGINRECV(0, &pmsg->IntDdeInfo, sizeof(INTDDEINFO));

    retval = (ULONG_PTR)_ClientCopyDDEOut1(&pmsg->IntDdeInfo);

    ENDRECV();
}
#endif // RECVSIDE



/**************************************************************************\
* ClientEventCallback
*
* 11-11-91  sanfords    Created
\**************************************************************************/

typedef struct _CLIENTEVENTCALLBACKMSG {
    CAPTUREBUF CaptureBuf;
    PVOID pcii;
    PVOID pep;
} CLIENTEVENTCALLBACKMSG;

#ifdef SENDSIDE
DWORD ClientEventCallback(
    IN PVOID pcii,
    IN PEVENT_PACKET pep)
{
    DWORD cbCapture = pep->cbEventData +
            sizeof(EVENT_PACKET) - sizeof(DWORD);

    SETUP(CLIENTEVENTCALLBACK)

    BEGINSENDCAPTURE(CLIENTEVENTCALLBACK, 1, cbCapture, TRUE)

        MSGDATA()->pcii = pcii;
        COPYBYTES(pep, cbCapture);

        MAKECALLCAPTURE(CLIENTEVENTCALLBACK);
        CHECKRETURN();

    TRACECALLBACK("ClientEventCallback");
    ENDSENDCAPTURE(DWORD,0);
}
#endif // SENDSIDE

#ifdef RECVSIDE
RECVCALL(ClientEventCallback, CLIENTEVENTCALLBACKMSG)
{
    BEGINRECV(0, NULL, 0);
    FIXUPPOINTERS();

    _ClientEventCallback(CALLDATA(pcii), (PEVENT_PACKET)FIXUP(pep));

    ENDRECV();
}
#endif // RECVSIDE

/**************************************************************************\
* ClientGetDDEHookData
*
* 11-11-91  sanfords    Created
\**************************************************************************/

typedef struct _CLIENTGETDDEHOOKDATAMSG {
    UINT message;
    LPARAM lParam;
    DDEML_MSG_HOOK_DATA dmhd;
} CLIENTGETDDEHOOKDATAMSG;

#ifdef SENDSIDE
DWORD ClientGetDDEHookData(
    IN UINT message,
    IN LPARAM lParam,
    OUT PDDEML_MSG_HOOK_DATA pdmhd)
{
    SETUP(CLIENTGETDDEHOOKDATA)

    BEGINSEND(CLIENTGETDDEHOOKDATA)

        MSGDATA()->lParam = lParam;
        MSGDATA()->message = message;

        MAKECALL(CLIENTGETDDEHOOKDATA);
        CHECKRETURN();

        OUTSTRUCT(pdmhd, DDEML_MSG_HOOK_DATA);

    TRACECALLBACK("ClientGetDDEHookData");
    ENDSEND(DWORD,0);
}
#endif // SENDSIDE

#ifdef RECVSIDE
RECVCALL(ClientGetDDEHookData, CLIENTGETDDEHOOKDATAMSG)
{
    BEGINRECV(0, &pmsg->dmhd, sizeof(DDEML_MSG_HOOK_DATA));

    _ClientGetDDEHookData(CALLDATA(message), CALLDATA(lParam),
            (PDDEML_MSG_HOOK_DATA)&pmsg->dmhd);

    ENDRECV();
}
#endif // RECVSIDE

/**************************************************************************\
*
*
* 22-Jul-1991 mikeke    Created
\**************************************************************************/

typedef struct _CLIENTCHARTOWCHARMSG {
    WORD CodePage;
    WORD wch;
} CLIENTCHARTOWCHARMSG;

#ifdef SENDSIDE
WCHAR xxxClientCharToWchar(
    IN WORD CodePage,
    IN WORD wch)
{
    SETUP(CLIENTCHARTOWCHAR)

    BEGINSEND(CLIENTCHARTOWCHAR)

        MSGDATA()->CodePage = CodePage;
        MSGDATA()->wch = wch;

        MAKECALL(CLIENTCHARTOWCHAR);
        CHECKRETURN();

    TRACECALLBACK("ClientCharToWchar");
    ENDSEND(WCHAR, L'_');
}
#endif // SENDSIDE

#ifdef RECVSIDE
RECVCALL(ClientCharToWchar, CLIENTCHARTOWCHARMSG)
{
    char ach[2];
    WCHAR wch = L'_';

    BEGINRECV(0, NULL, 0);

    ach[0] = LOBYTE(CALLDATA(wch));
    ach[1] = HIBYTE(CALLDATA(wch));

    MultiByteToWideChar(
            CALLDATA(CodePage),                // CP_THREAD_ACP, 437, 850 etc.
            MB_PRECOMPOSED | MB_USEGLYPHCHARS, // visual map to precomposed
            ach, ach[1] ? 2 : 1,               // source & length
            &wch,                              // destination
            1);                                // max poss. precomposed length

    retval = (DWORD)wch;

    ENDRECV();
}
#endif // RECVSIDE

/**************************************************************************\
*
*
* 22-Jul-1991 mikeke    Created
\**************************************************************************/

typedef struct _CLIENTFINDMNEMCHARMSG {
    CAPTUREBUF CaptureBuf;
    UNICODE_STRING strSrc;
    WCHAR ch;
    BOOL fFirst;
    BOOL fPrefix;
} CLIENTFINDMNEMCHARMSG;

#ifdef SENDSIDE
int xxxClientFindMnemChar(
    IN PUNICODE_STRING pstrSrc,
    IN WCHAR ch,
    IN BOOL fFirst,
    IN BOOL fPrefix)
{
    SETUP(CLIENTFINDMNEMCHAR)

    BEGINSENDCAPTURE(CLIENTFINDMNEMCHAR, 1, pstrSrc->MaximumLength, TRUE)

        MSGDATA()->ch = ch;
        MSGDATA()->fFirst = fFirst;
        MSGDATA()->fPrefix = fPrefix;
        COPYSTRING(strSrc);

        MAKECALLCAPTURE(CLIENTFINDMNEMCHAR);
        CHECKRETURN();

    TRACECALLBACK("ClientFindMnemChar");
    ENDSENDCAPTURE(BOOL,0);
}
#endif // SENDSIDE

#ifdef RECVSIDE
RECVCALL(ClientFindMnemChar, CLIENTFINDMNEMCHARMSG)
{
    BEGINRECV(0, NULL, 0);
    FIXUPPOINTERS();

    retval = (DWORD)FindMnemChar((LPWSTR)FIXUPSTRING(strSrc),
            CALLDATA(ch), CALLDATA(fFirst), CALLDATA(fPrefix));

    ENDRECV();
}
#endif // RECVSIDE

/**************************************************************************\
* xxxClientPSMTextOut
*
* Called when a client-side LanguagePack (LPK) is installed
*
* 18-Sep-1996 GregoryW  Created
* 11-Dec-1997 SamerA    Calling LPK with user-mode accessible DC
\**************************************************************************/

typedef struct _CLIENTPSMTEXTOUTMSG {
    CAPTUREBUF CaptureBuf;
    UNICODE_STRING strSrc;
    HDC hdc;
    int xLeft;
    int yTop;
    int cch;
    DWORD dwFlags;
} CLIENTPSMTEXTOUTMSG;

#ifdef SENDSIDE
void xxxClientPSMTextOut(
    IN HDC hdc,
    IN int xLeft,
    IN int yTop,
    IN PUNICODE_STRING pstrSrc,
    IN int cch,
    IN DWORD dwFlags)
{
    SETUPDC(CLIENTPSMTEXTOUT)

    /*
     * Make sure this routine is called when a client LanguagePack (LPK)
     * is installed.
     */
    UserAssert(CALL_LPK(PtiCurrentShared()));

    BEGINSENDCAPTUREVOIDDC(CLIENTPSMTEXTOUT, 1, pstrSrc->MaximumLength, TRUE)

    CheckPublicDC ("xxxClientPSMTextOut: Public DC passed to LPK. hdcUse=%lX", hdcUse);

        MSGDATA()->hdc = hdcUse;
        MSGDATA()->xLeft = xLeft;
        MSGDATA()->yTop = yTop;
        MSGDATA()->cch = cch;
        MSGDATA()->dwFlags = dwFlags;
        COPYSTRING(strSrc);

        MAKECALLCAPTUREDC(CLIENTPSMTEXTOUT);

        CHECKRETURN();

    TRACECALLBACK("ClientPSMTextOut");
    ENDSENDCAPTUREVOIDDC();
}
#endif // SENDSIDE

#ifdef RECVSIDE
RECVCALL(ClientPSMTextOut, CLIENTPSMTEXTOUTMSG)
{
    BEGINRECV(0, NULL, 0);
    FIXUPPOINTERS();

    PSMTextOut(CALLDATA(hdc), CALLDATA(xLeft), CALLDATA(yTop),
        (LPWSTR)FIXUPSTRING(strSrc), CALLDATA(cch), CALLDATA(dwFlags));

    retval = 0;
    ENDRECV();
}
#endif // RECVSIDE

/**************************************************************************\
* xxxClientLpkDrawTextEx
*
* Called when a client-side LanguagePack (LPK) is installed
*
* 18-Sep-1996 GregoryW  Created
* 11-Dec-1997 SamerA    Calling LPK with user-mode accessible DC
\**************************************************************************/

typedef struct _CLIENTLPKDRAWTEXTEXMSG {
    CAPTUREBUF CaptureBuf;
    UNICODE_STRING strSrc;
    HDC hdc;
    int xLeft;
    int yTop;
    int nCount;
    BOOL fDraw;
    UINT wFormat;
    DRAWTEXTDATA DrawInfo;
    UINT bAction;
    int iCharSet;
} CLIENTLPKDRAWTEXTEXMSG;

#ifdef SENDSIDE
int xxxClientLpkDrawTextEx(
    IN HDC hdc,
    IN int xLeft,
    IN int yTop,
    IN LPCWSTR lpsz,
    IN int nCount,
    IN BOOL fDraw,
    IN UINT wFormat,
    IN LPDRAWTEXTDATA lpDrawInfo,
    IN UINT bAction,
    IN int iCharSet)
{
    SETUPDC(CLIENTLPKDRAWTEXTEX)
    UNICODE_STRING strSrc;
    UNICODE_STRING *pstrSrc   = &strSrc;

    /*
     * Make sure this routine is called when a client LanguagePack (LPK)
     * is installed.
     */
    UserAssert(CALL_LPK(PtiCurrentShared()));


    RtlInitUnicodeString(pstrSrc, lpsz);

    BEGINSENDCAPTUREDC(CLIENTLPKDRAWTEXTEX, 1, nCount, TRUE)

    CheckPublicDC ("xxxClientLpkDrawTextEx: Public DC passed to LPK. hdcUse=%lX", hdcUse);

        MSGDATA()->hdc = hdcUse;
        MSGDATA()->xLeft = xLeft;
        MSGDATA()->yTop = yTop;
        MSGDATA()->nCount = nCount;
        MSGDATA()->fDraw = fDraw;
        MSGDATA()->wFormat = wFormat;
        MSGDATA()->DrawInfo = *lpDrawInfo;
        MSGDATA()->bAction = bAction;
        MSGDATA()->iCharSet = iCharSet;
        COPYSTRING(strSrc);

        MAKECALLCAPTUREDC(CLIENTLPKDRAWTEXTEX);

        CHECKRETURN();

    TRACECALLBACK("ClientLpkDrawTextEx");
    ENDSENDCAPTUREDC(int, 0);
}
#endif // SENDSIDE

#ifdef RECVSIDE
RECVCALL(ClientLpkDrawTextEx, CLIENTLPKDRAWTEXTEXMSG)
{
    BEGINRECV(0, NULL, 0);
    FIXUPPOINTERS();

    retval = (*fpLpkDrawTextEx)(CALLDATA(hdc), CALLDATA(xLeft), CALLDATA(yTop),
        (LPWSTR)FIXUPSTRING(strSrc), CALLDATA(nCount), CALLDATA(fDraw),
        CALLDATA(wFormat), PCALLDATA(DrawInfo), CALLDATA(bAction), CALLDATA(iCharSet));

    ENDRECV();
}
#endif // RECVSIDE

/**************************************************************************\
* xxxClientExtTextOutW
*
* Called when a client-side LanguagePack (LPK) is installed
*
* 26-Jan-1997 GregoryW  Created
* 11-Dec-1997 SamerA    Calling LPK with user-mode accessible DC
\**************************************************************************/

typedef struct _CLIENTEXTTEXTOUTW {
    CAPTUREBUF CaptureBuf;
    UNICODE_STRING strSrc;
    HDC hdc;
    int x;
    int y;
    int flOpts;
    RECT rcl;
    UINT cwc;
    BOOL fNullRect;
} CLIENTEXTTEXTOUTWMSG;

#ifdef SENDSIDE
BOOL xxxClientExtTextOutW(
    IN HDC hdc,
    IN int x,
    IN int y,
    IN int flOpts,
    IN RECT *prcl,
    IN LPCWSTR pwsz,
    IN UINT cwc,
    IN INT *pdx)
{
    SETUPDC(CLIENTEXTTEXTOUTW)
    UNICODE_STRING strSrc;
    UNICODE_STRING *pstrSrc = &strSrc;

    /*
     * Make sure this routine is called when a client LanguagePack (LPK)
     * is installed.
     */
    UserAssert(CALL_LPK(PtiCurrentShared()));


    RtlInitUnicodeString(pstrSrc, pwsz);

    BEGINSENDCAPTUREDC(CLIENTEXTTEXTOUTW, 1, cwc, TRUE)

    CheckPublicDC ("xxxClientExtTextOutW: Public DC passed to LPK. hdcUse=%lX", hdcUse);

        MSGDATA()->hdc = hdcUse;
        MSGDATA()->x = x;
        MSGDATA()->y = y;
        MSGDATA()->flOpts = flOpts;
        /* In order not to pass a NULL ptr */
        if( prcl ){
            MSGDATA()->rcl = *prcl;
            MSGDATA()->fNullRect=TRUE;
        }
        else {
            MSGDATA()->fNullRect=FALSE;
        }
        MSGDATA()->cwc = cwc;
        COPYSTRING(strSrc);

        MAKECALLCAPTUREDC(CLIENTEXTTEXTOUTW);

        CHECKRETURN();

    TRACECALLBACK("ClientExtTextOutW");
    ENDSENDCAPTUREDC(BOOL, 0);

    UNREFERENCED_PARAMETER(pdx);
}
#endif // SENDSIDE

#ifdef RECVSIDE
RECVCALL(ClientExtTextOutW, CLIENTEXTTEXTOUTWMSG)
{
    BEGINRECV(0, NULL, 0);
    FIXUPPOINTERS();

    retval = ExtTextOutW(CALLDATA(hdc), CALLDATA(x), CALLDATA(y),
        CALLDATA(flOpts), (CALLDATA(fNullRect)) ? PCALLDATA(rcl) : NULL , (LPWSTR)FIXUPSTRING(strSrc),
        CALLDATA(cwc), NULL);

    ENDRECV();
}
#endif // RECVSIDE

/**************************************************************************\
* xxxClientGetTextExtentPointW
*
* Called when a client-side LanguagePack (LPK) is installed
*
* 06-Feb-1997 GregoryW  Created
* 19-Jan-1998 SamerA    EIP_ERROR if a public DC is passed other than hdcGray
\**************************************************************************/

typedef struct _CLIENTGETTEXTEXTENTPOINTW {
    CAPTUREBUF CaptureBuf;
    UNICODE_STRING strSrc;
    HDC hdc;
    int cch;
    SIZE size;
} CLIENTGETTEXTEXTENTPOINTWMSG;

#ifdef SENDSIDE
BOOL xxxClientGetTextExtentPointW(
    IN HDC hdc,
    IN LPCWSTR lpstr,
    IN int cch,
    OUT PSIZE psize)
{
    SETUPDC(CLIENTGETTEXTEXTENTPOINTW)
    UNICODE_STRING strSrc;
    UNICODE_STRING *pstrSrc = &strSrc;

    /*
     * Make sure this routine is called when a client LanguagePack (LPK)
     * is installed.
     */
    UserAssert(CALL_LPK(PtiCurrentShared()));

    RtlInitUnicodeString(pstrSrc, lpstr);

    BEGINSENDCAPTUREDC(CLIENTGETTEXTEXTENTPOINTW, 1, cch, TRUE)

    CheckPublicDC ("xxxGetTextExtentPointW: Public DC passed to LPK. hdcUse=%lX", hdcUse);

        MSGDATA()->hdc = hdcUse;
        MSGDATA()->cch = cch;
        COPYSTRING(strSrc);

        MAKECALLCAPTUREDC(CLIENTGETTEXTEXTENTPOINTW);

        CHECKRETURN();

        OUTSTRUCT(psize, SIZE);

    TRACECALLBACK("ClientGetTextExtentPointW");
    ENDSENDCAPTUREDC(BOOL, 0);

}
#endif // SENDSIDE

#ifdef RECVSIDE
RECVCALL(ClientGetTextExtentPointW, CLIENTGETTEXTEXTENTPOINTWMSG)
{
    BEGINRECV(0, &pmsg->size, sizeof(SIZE));
    FIXUPPOINTERS();

    retval = GetTextExtentPointW(CALLDATA(hdc), (LPWSTR)FIXUPSTRING(strSrc),
        CALLDATA(cch), PCALLDATA(size));

    ENDRECV();
}
#endif // RECVSIDE

/**************************************************************************\
*
*
* 22-Jul-1991 mikeke    Created
\**************************************************************************/

typedef struct _CLIENTADDFONTRESOURCEWMSG {
    CAPTUREBUF CaptureBuf;
    UNICODE_STRING strSrc;
    DWORD dwFlags;
    DESIGNVECTOR   dv;
} CLIENTADDFONTRESOURCEWMSG;

#ifdef SENDSIDE
int xxxClientAddFontResourceW(
    IN PUNICODE_STRING pstrSrc,
    IN DWORD dwFlags,
    IN DESIGNVECTOR *pdv)
{
    SETUP(CLIENTADDFONTRESOURCEW)

    BEGINSENDCAPTURE(CLIENTADDFONTRESOURCEW, 1, pstrSrc->MaximumLength, TRUE)

        COPYSTRING(strSrc);
        MSGDATA()->dwFlags = dwFlags;

        if (pdv && pdv->dvNumAxes) {
            MSGDATA()->dv = *pdv;
        } else {
            MSGDATA()->dv.dvNumAxes = 0;
        }

        MAKECALLCAPTURE(CLIENTADDFONTRESOURCEW);
        CHECKRETURN();

    TRACECALLBACK("ClientAddFontResourceW");
    ENDSENDCAPTURE(int,0);
}
#endif // SENDSIDE

#ifdef RECVSIDE


RECVCALL(ClientAddFontResourceW, CLIENTADDFONTRESOURCEWMSG)
{
    DWORD AddFont(LPWSTR, DWORD, DESIGNVECTOR*);

    BEGINRECV(0, NULL, 0);
    FIXUPPOINTERS();

    retval = GdiAddFontResourceW((LPWSTR)FIXUPSTRING(strSrc),
                                  CALLDATA(dwFlags), CALLDATA(dv).dvNumAxes ? &CALLDATA(dv) : NULL);

    ENDRECV();
}
#endif // RECVSIDE



/******************************Public*Routine******************************\
*
* FontSweep()
*
* History:
*  23-Oct-1995 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/



#ifdef SENDSIDE
VOID ClientFontSweep(VOID)
{
    PVOID p;
    ULONG cb;

    LeaveCrit();
    KeUserModeCallback(
        FI_CLIENTFONTSWEEP,
        NULL,
        0,
        &p,
        &cb);
    EnterCrit();
    return;
}
#endif // SENDSIDE

#ifdef RECVSIDE

DWORD __ClientFontSweep(
    PVOID p)
{
    UNREFERENCED_PARAMETER(p);
    vFontSweep();
    return NtCallbackReturn(NULL, 0, STATUS_SUCCESS);
}
#endif // RECVSIDE


/******************************Public*Routine******************************\
*
* VOID ClientLoadLocalT1Fonts(VOID)
* very similar to above, only done for t1 fonts
*
* History:
*  25-Apr-1996 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/



#ifdef SENDSIDE
VOID ClientLoadLocalT1Fonts(VOID)
{
    PVOID p;
    ULONG cb;

    LeaveCrit();
    KeUserModeCallback(
        FI_CLIENTLOADLOCALT1FONTS,
        NULL,
        0,
        &p,
        &cb);
    EnterCrit();
    return;
}
#endif // SENDSIDE

#ifdef RECVSIDE



DWORD __ClientLoadLocalT1Fonts(
    PVOID p)
{
    UNREFERENCED_PARAMETER(p);
    vLoadLocalT1Fonts();
    return NtCallbackReturn(NULL, 0, STATUS_SUCCESS);
}
#endif // RECVSIDE



/******************************Public*Routine******************************\
*
* VOID ClientLoadRemoteT1Fonts(VOID)
* very similar to above, only done for t1 fonts
*
* History:
*  25-Apr-1996 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/



#ifdef SENDSIDE
VOID ClientLoadRemoteT1Fonts(VOID)
{
    PVOID p;
    ULONG cb;

    LeaveCrit();
    KeUserModeCallback(
        FI_CLIENTLOADREMOTET1FONTS,
        NULL,
        0,
        &p,
        &cb);
    EnterCrit();
    return;
}
#endif // SENDSIDE

#ifdef RECVSIDE



DWORD __ClientLoadRemoteT1Fonts(
    PVOID p)
{
    UNREFERENCED_PARAMETER(p);
    vLoadRemoteT1Fonts();
    return NtCallbackReturn(NULL, 0, STATUS_SUCCESS);
}
#endif // RECVSIDE

/**************************************************************************\
* pppUserModeCallback
*
* Same as xxxUserModeCallback except not leaving/re-entering critical section
*
* 12/9/97 LingyunW     Copied from xxxUserModeCallback
\**************************************************************************/
#ifdef SENDSIDE
NTSTATUS pppUserModeCallback (ULONG uApi, PVOID pIn, ULONG cbIn, PVOID pOut, ULONG cbOut)
{
    NTSTATUS Status;
    PVOID pLocalOut;
    ULONG cbLocalOut;

    /*
     * Call the client
     */
    Status = KeUserModeCallback(uApi, pIn, cbIn, &pLocalOut, &cbLocalOut);

    /*
     * If it failed, bail
     */
    if (!NT_SUCCESS(Status)) {
        return Status;
    }

    /*
     * If we didn't get the right amount of data, fail.
     */
    if (cbLocalOut != cbOut) {
        RIPMSG3(RIP_WARNING, "pppUserModeCallback: uAPi: %#lx cbOut: %#lx cbLocalOut: %#lx",
                uApi, cbOut, cbLocalOut);
        return STATUS_UNSUCCESSFUL;
    }

    /*
     * If we were expecting some data, copy it.
     */
    if (cbOut != 0) {
        try {
            ProbeForRead(pLocalOut, cbLocalOut, sizeof(DWORD));
            RtlCopyMemory(pOut, pLocalOut, cbLocalOut);
        } except (W32ExceptionHandler(FALSE, RIP_WARNING)) {
            RIPMSG2(RIP_WARNING, "pppUserModeCallback: uAPi: %#lx Exception: %#lx", uApi, GetExceptionCode());
            Status = STATUS_UNSUCCESSFUL;
        }
    }

    return Status;
}
#endif // SENDSIDE

/******************************Public*Routine******************************\
* ClientPrinterThunk
*
* Callback used as the kernel-to-user transport layer.
*
* Note: User critical section is not held by the caller.
*
* History:
*  22-Jun-1997 -by- Gilman Wong [gilmanw]
*  11/13/97 -by- Lingyun Wang [lingyunw] clean up
*
* Wrote it.
\**************************************************************************/

#define CLIENTPRINTERTHUNKMSG UMTHDR

#ifdef SENDSIDE
DWORD ClientPrinterThunk(PVOID pvIn, ULONG cjIn, PVOID pvOut, ULONG cjOut)
{
    NTSTATUS Status;

    /*
     * (Temporarly..) we return failure if we are holding USERK's crit section
     */
    if (ExIsResourceAcquiredExclusiveLite(gpresUser)
            || (ExIsResourceAcquiredSharedLite(gpresUser) != 0)) {
        RIPMSG0(RIP_ERROR, "ClientPrinterThunk: Holding USERK critical section!");
        return 0xffffffff;
    }

    /*
     * The pvIn buffer must have at least a CLIENTPRINTERTHUNK header.
     */
    UserAssertMsg1(cjIn >= sizeof(CLIENTPRINTERTHUNKMSG), "ClientPrinterThunk: incorrect cjIn:%#lx", cjIn);

    /*
     * Set the private cjOut.  The receive-side uses this to allocate
     *  a return buffer.
     */
    ((CLIENTPRINTERTHUNKMSG *) pvIn)->ulReserved1      = cjOut;
    ((CLIENTPRINTERTHUNKMSG *) pvIn)->ulReserved2 = 0;


    /*
     * Do the callback.
     */
    Status = pppUserModeCallback(FI_CLIENTPRINTERTHUNK, pvIn, cjIn, pvOut, cjOut);

    return (NT_SUCCESS(Status) ? 0 : 0xFFFFFFFF);
}
#endif // SENDSIDE

#ifdef RECVSIDE
DWORD __ClientPrinterThunk(CLIENTPRINTERTHUNKMSG *pMsg)
{
    PVOID pv;
    ULONG aul[526];
    NTSTATUS Status;

    /*
     * Check that the local buffer is big enough.
     */
    if (pMsg->ulReserved1 <= sizeof(aul)) {
        pv = (PVOID) aul;
        /*
         * Call GDI to process command.
         */
        if (GdiPrinterThunk((UMTHDR *) pMsg, pv, pMsg->ulReserved1) != GPT_ERROR) {
            Status = STATUS_SUCCESS;
        } else {
            RIPMSG0(RIP_WARNING, "ClientPrinterThunk failed");
            Status = STATUS_UNSUCCESSFUL;
        }
    } else {
        RIPMSG0(RIP_WARNING, "ClientPrinterThunk: buffer too big!");
        Status = STATUS_NO_MEMORY;
    }


    /*
     * Return to kernel.
     */
    if (NT_SUCCESS(Status)) {
        return UserCallbackReturn(pv, pMsg->ulReserved1, Status);
    } else {
        return UserCallbackReturn(NULL, 0, Status);
    }
}
#endif // RECVSIDE

/**************************************************************************\
*
*
* 22-Jul-1991 mikeke    Created
\**************************************************************************/

#ifdef SENDSIDE
VOID ClientNoMemoryPopup(VOID)
{
    PVOID p;
    ULONG cb;

    LeaveCrit();
    KeUserModeCallback(
        FI_CLIENTNOMEMORYPOPUP,
        NULL,
        0,
        &p,
        &cb);
    EnterCrit();
    return;
}
#endif // SENDSIDE

#ifdef RECVSIDE

DWORD __ClientNoMemoryPopup(
    PVOID p)
{
    WCHAR szNoMem[200];

    UNREFERENCED_PARAMETER(p);

    if (LoadStringW(hmodUser, STR_NOMEMBITMAP, szNoMem,
            sizeof(szNoMem) / sizeof(WCHAR))) {
        MessageBoxW(GetActiveWindow(), szNoMem, NULL, MB_OK);
    }

    return NtCallbackReturn(NULL, 0, STATUS_SUCCESS);
}
#endif // RECVSIDE

/**************************************************************************\
* ClientThreadSetup
*
* Callback to the client to perform thread initialization.
*
* 04-07-95 JimA         Created.
\**************************************************************************/

#ifdef SENDSIDE
NTSTATUS xxxClientThreadSetup(VOID)
{
    PVOID p;
    ULONG cb;
    NTSTATUS Status;

    LeaveCrit();
    Status = KeUserModeCallback(
        FI_CLIENTTHREADSETUP,
        NULL,
        0,
        &p,
        &cb);
    EnterCrit();
    return Status;
}
#endif // SENDSIDE

#ifdef RECVSIDE
DWORD __ClientThreadSetup(
    PVOID p)
{
    BOOL fSuccess;
    BOOL ClientThreadSetup(VOID);

    UNREFERENCED_PARAMETER(p);

    fSuccess = ClientThreadSetup();
    return NtCallbackReturn(NULL, 0,
            fSuccess ? STATUS_SUCCESS : STATUS_UNSUCCESSFUL);
}
#endif // RECVSIDE

/**************************************************************************\
* ClientDeliverUserApc
*
* Callback to the client to handle a user APC.  This is needed to
* ensure that a thread will exit promptly when terminated.
*
* 08-12-95 JimA         Created.
\**************************************************************************/

#ifdef SENDSIDE
VOID ClientDeliverUserApc(VOID)
{
    PVOID p;
    ULONG cb;

    LeaveCrit();
    KeUserModeCallback(
        FI_CLIENTDELIVERUSERAPC,
        NULL,
        0,
        &p,
        &cb);
    EnterCrit();
}
#endif // SENDSIDE

#ifdef RECVSIDE
DWORD __ClientDeliverUserApc(
    PVOID p)
{
    UNREFERENCED_PARAMETER(p);
    return NtCallbackReturn(NULL, 0, STATUS_SUCCESS);
}
#endif // RECVSIDE


/**************************************************************************\
* ClientImmLoadLayout
*
* 29-Jan-1996 wkwok   Created
\**************************************************************************/

typedef struct _CLIENTIMMLOADLAYOUTMSG {
    HKL hKL;
} CLIENTIMMLOADLAYOUTMSG;

#ifdef SENDSIDE
BOOL ClientImmLoadLayout(
    IN HKL hKL,
    OUT PIMEINFOEX piiex)
{
    SETUP(CLIENTIMMLOADLAYOUT)

    BEGINSEND(CLIENTIMMLOADLAYOUT)

        MSGDATA()->hKL = hKL;

        MAKECALL(CLIENTIMMLOADLAYOUT);
        CHECKRETURN();

        if (retval)
            OUTSTRUCT(piiex, IMEINFOEX);

    TRACECALLBACK("ClientImmLoadLayout");
    ENDSEND(BOOL, 0);
}
#endif // SENDSIDE

#ifdef RECVSIDE
RECVCALL(ClientImmLoadLayout, CLIENTIMMLOADLAYOUTMSG)
{
    IMEINFOEX iiex;

    BEGINRECV(0, &iiex, sizeof(iiex));

    retval = fpImmLoadLayout(CALLDATA(hKL), &iiex);

    ENDRECV();
}
#endif // RECVSIDE

/**************************************************************************\
* ClientImmProcessKey
*
* 03-Mar-1996 TakaoK   Created
\**************************************************************************/

typedef struct _CLIENTIMMPROCESSKEYMSG {
    HWND hWnd;
    HKL  hkl;
    UINT uVKey;
    LPARAM lParam;
    DWORD dwHotKeyID;
} CLIENTIMMPROCESSKEYMSG;

#ifdef SENDSIDE
DWORD ClientImmProcessKey(
    IN HWND hWnd,
    IN HKL  hkl,
    IN UINT uVKey,
    IN LPARAM lParam,
    IN DWORD dwHotKeyID)
{
    SETUP(CLIENTIMMPROCESSKEY)

    UserAssert(IS_IME_ENABLED());

    BEGINSEND(CLIENTIMMPROCESSKEY)

        MSGDATA()->hWnd = hWnd,
        MSGDATA()->hkl = hkl;
        MSGDATA()->uVKey = uVKey;
        MSGDATA()->lParam = lParam;
        MSGDATA()->dwHotKeyID = dwHotKeyID;

        MAKECALL(CLIENTIMMPROCESSKEY);
        CHECKRETURN();

    TRACECALLBACK("ClientImmProcessKey");
    ENDSEND(DWORD, 0);
}
#endif // SENDSIDE

#ifdef RECVSIDE
RECVCALL(ClientImmProcessKey, CLIENTIMMPROCESSKEYMSG)
{
    BEGINRECV(0, NULL, 0);

    retval = fpImmProcessKey(CALLDATA(hWnd),
                CALLDATA(hkl),
                CALLDATA(uVKey),
                CALLDATA(lParam),
                CALLDATA(dwHotKeyID));

    ENDRECV();
}
#endif // RECVSIDE

/**************************************************************************\
* fnIMECONTROL
*
* 22-Apr-1996 wkwok    Created
\**************************************************************************/

typedef struct _FNIMECONTROL {
    CAPTUREBUF CaptureBuf;
    PWND pwnd;
    UINT msg;
    WPARAM wParam;
    union {
        PCANDIDATEFORM pCandForm;
        PCOMPOSITIONFORM pCompForm;
        PLOGFONTA pLogFontA;
        PLOGFONTW pLogFontW;
        PSOFTKBDDATA pSoftKbdData;
        LPARAM lParam;
    } u;
    ULONG_PTR xParam;
    PROC xpfnProc;
    PBYTE pOutput;
    DWORD cbOutput;
} FNIMECONTROLMSG;

#ifdef SENDSIDE
void CopyLogFontAtoW(
    PLOGFONTW pdest,
    PLOGFONTA psrc)
{
    LPSTR lpstrFont = (LPSTR)(&psrc->lfFaceName);
    LPWSTR lpstrFontW = (LPWSTR)(&pdest->lfFaceName);

    memcpy((LPBYTE)pdest, psrc, sizeof(LOGFONTA) - LF_FACESIZE);
    memset(pdest->lfFaceName, 0, LF_FACESIZE * sizeof(WCHAR));
    MBToWCS(lpstrFont, -1, &lpstrFontW, LF_FACESIZE, FALSE);
}

SMESSAGECALL(IMECONTROL)
{
    DWORD cCapture, cbCapture;

    SETUPPWND(FNIMECONTROL)

    switch (wParam) {
        case IMC_GETCANDIDATEPOS:
        case IMC_SETCANDIDATEPOS:
            cCapture  = 1;
            cbCapture = sizeof(CANDIDATEFORM);
            break;

        case IMC_GETCOMPOSITIONWINDOW:
        case IMC_SETCOMPOSITIONWINDOW:
            cCapture  = 1;
            cbCapture = sizeof(COMPOSITIONFORM);
            break;

        case IMC_GETCOMPOSITIONFONT:
        case IMC_SETCOMPOSITIONFONT:
        case IMC_GETSOFTKBDFONT:
            cCapture  = 1;
            cbCapture = (dwSCMSFlags & SCMS_FLAGS_ANSI)
                      ? sizeof(LOGFONTA) : sizeof(LOGFONTW) ;
            break;

        case IMC_SETSOFTKBDDATA:
            cCapture  = 1;
            cbCapture = FIELD_OFFSET(SOFTKBDDATA, wCode[0])
                      + ((PSOFTKBDDATA)lParam)->uCount * sizeof(WORD) * 256;

            break;

        default:
            cCapture  = 0;
            cbCapture = 0;
            break;
    }

    BEGINSENDCAPTURE(FNIMECONTROL, cCapture, cbCapture, TRUE);

        MSGDATA()->pwnd     = pwndClient;
        MSGDATA()->msg      = msg;
        MSGDATA()->wParam   = wParam;
        MSGDATA()->u.lParam = lParam;
        MSGDATA()->xParam   = xParam;
        MSGDATA()->xpfnProc = xpfnProc;

        LOCKPWND();

        switch (wParam) {

        case IMC_GETCANDIDATEPOS:
        case IMC_GETCOMPOSITIONWINDOW:
        case IMC_GETCOMPOSITIONFONT:
        case IMC_GETSOFTKBDFONT:

            RESERVEBYTES(cbCapture, pOutput, cbOutput);
            MAKECALLCAPTURE(FNIMECONTROL);
            UNLOCKPWND();
            CHECKRETURN();

            BEGINCOPYOUT()
                try {
                    ProbeForRead(pcbs->pOutput, pcbs->cbOutput, sizeof(DWORD));
                    switch (wParam) {
                    case IMC_GETCANDIDATEPOS:
                    case IMC_GETCOMPOSITIONWINDOW:
                        memcpy((LPBYTE)lParam, pcbs->pOutput, cbCapture);
                        break;

                    case IMC_GETCOMPOSITIONFONT:
                    case IMC_GETSOFTKBDFONT:
                        if (dwSCMSFlags & SCMS_FLAGS_ANSI) {
                            CopyLogFontAtoW((PLOGFONTW)lParam, (PLOGFONTA)pcbs->pOutput);
                        }
                        else {
                            memcpy((LPBYTE)lParam, pcbs->pOutput, cbCapture);
                        }
                        break;
                    }
                } except (W32ExceptionHandler(TRUE, RIP_WARNING)) {
                    MSGERROR();
                }
            ENDCOPYOUT()

            break;

        case IMC_SETCANDIDATEPOS:
        case IMC_SETCOMPOSITIONWINDOW:
        case IMC_SETCOMPOSITIONFONT:
        case IMC_SETSOFTKBDDATA:
            if (wParam == IMC_SETCANDIDATEPOS) {
                PCANDIDATEFORM pCandForm = (PCANDIDATEFORM)lParam;
                LARGECOPYBYTES2(pCandForm, sizeof(CANDIDATEFORM), u.pCandForm);
            }
            else if (wParam == IMC_SETCOMPOSITIONWINDOW) {
                PCOMPOSITIONFORM pCompForm = (PCOMPOSITIONFORM)lParam;
                LARGECOPYBYTES2(pCompForm, sizeof(COMPOSITIONFORM), u.pCompForm);
            }
            else if (wParam == IMC_SETCOMPOSITIONFONT) {
                if (dwSCMSFlags & SCMS_FLAGS_ANSI) {
                    LOGFONTA LogFontA;
                    LPSTR  lpstrFontA = LogFontA.lfFaceName;
                    LPWSTR lpstrFontW = ((PLOGFONTW)lParam)->lfFaceName;

                    memcpy(&LogFontA, (PBYTE)lParam, sizeof(LOGFONTA)-LF_FACESIZE);
                    memset(lpstrFontA, 0, LF_FACESIZE * sizeof(CHAR));
                    WCSToMB(lpstrFontW, -1, &lpstrFontA, LF_FACESIZE, FALSE);
                    LARGECOPYBYTES2(&LogFontA, sizeof(LOGFONTA), u.pLogFontA);
                }
                else {
                    PLOGFONTW pLogFontW = (PLOGFONTW)lParam;
                    LARGECOPYBYTES2(pLogFontW, sizeof(LOGFONTW), u.pLogFontW);
                }
            }
            else if (wParam == IMC_SETSOFTKBDDATA) {
                PSOFTKBDDATA pSoftKbdData;

                if (dwSCMSFlags & SCMS_FLAGS_ANSI) {
                    PWORD pCodeA;
                    PWSTR pCodeW;
                    CHAR  ch[2];
                    PSTR  pch = (PSTR)&ch;
                    UINT  i;

                    pSoftKbdData = (PSOFTKBDDATA)UserAllocPool(cbCapture, TAG_IME);
                    if (pSoftKbdData == NULL)
                        MSGERROR();

                    pCodeA = &pSoftKbdData->wCode[0][0];
                    pCodeW = (PWSTR)&((PSOFTKBDDATA)lParam)->wCode[0][0];

                    pSoftKbdData->uCount = ((PSOFTKBDDATA)lParam)->uCount;

                    i = pSoftKbdData->uCount * 256;

                    while (i--) {
                        pch[1] = '\0';
                        WCSToMBEx(THREAD_CODEPAGE(), pCodeW, 1, &pch, 2, FALSE);
                        if (pch[1]) {
                            *pCodeA = MAKEWORD(pch[1], pch[0]);
                        } else {
                            *pCodeA = MAKEWORD(pch[0], 0);
                        }
                        pCodeA++; pCodeW++;
                    }

                    LARGECOPYBYTES2(pSoftKbdData, cbCapture, u.pSoftKbdData);

                    UserFreePool(pSoftKbdData);
                }
                else {
                    pSoftKbdData = (PSOFTKBDDATA)lParam;
                    LARGECOPYBYTES2(pSoftKbdData, cbCapture, u.pSoftKbdData);
                }
            }

            /*
             * Fall thur.
             */

        default:
            MAKECALLCAPTURE(FNIMECONTROL);
            UNLOCKPWND();
            CHECKRETURN();
            break;
        }


    TRACECALLBACKMSG("SfnINSTRINGNULL");
    ENDSENDCAPTURE(LRESULT,0);
}
#endif // SENDSIDE

#ifdef RECVSIDE
RECVCALL(fnIMECONTROL, FNIMECONTROLMSG)
{
    BYTE abOutput[CALLBACKSTACKLIMIT];
    LPARAM lParam;

    BEGINRECV(0, NULL, pmsg->cbOutput);
    FIXUPPOINTERS();
    if (pmsg->cbOutput <= CALLBACKSTACKLIMIT)
        CallbackStatus.pOutput = abOutput;
    else
        CallbackStatus.pOutput = pmsg->pOutput;

    switch (CALLDATA(wParam)) {
        case IMC_GETCANDIDATEPOS:
        case IMC_GETCOMPOSITIONWINDOW:
        case IMC_GETCOMPOSITIONFONT:
        case IMC_GETSOFTKBDFONT:
            lParam = (LPARAM)CallbackStatus.pOutput;
            break;

        case IMC_SETCANDIDATEPOS:
        case IMC_SETCOMPOSITIONWINDOW:
        case IMC_SETCOMPOSITIONFONT:
        case IMC_SETSOFTKBDDATA:
            lParam = FIRSTFIXUP(u.lParam);
            break;

       default:
            lParam = CALLDATA(u.lParam);
            break;
    }

    retval = (ULONG_PTR)CALLPROC(CALLDATA(xpfnProc))(
            CALLDATA(pwnd),
            CALLDATA(msg),
            CALLDATA(wParam),
            lParam,
            CALLDATA(xParam));


    ENDRECV();
}
#endif // RECVSIDE

/**************************************************************************\
* fnIMEREQUEST
*
* 22-Apr-1996     Created
\**************************************************************************/

#ifdef LATER
typedef struct _FNIMEREQUEST {
    CAPTUREBUF CaptureBuf;
    PWND pwnd;
    UINT msg;
    WPARAM wParam;
    union {
        LPCANDIDATEFORM         pCandidateForm;
        LPLOGFONTA              pLogFontA;
        LPLOGFONTW              pLogFontW;
        LPCOMPOSITIONFORM       pCompositionForm;
        LPRECONVERTSTRING       pReconvertString;
        LPPrivateIMECHARPOSITION pImeCharPosition;
        LPARAM                  lParam;
    } u;
    ULONG_PTR xParam;
    PROC xpfnProc;
    PBYTE pOutput;
    DWORD cbOutput;
    BOOL fAnsi;
} FNIMEREQUESTMSG;

#ifdef SENDSIDE

SMESSAGECALL(IMEREQUEST)
{
    DWORD cCapture, cbCapture;

    SETUPPWND(FNIMEREQUEST)

    //
    // IMEREQUEST assumes the callback is within the thread
    // (see MESSAGECALL(IMEREQUEST) in kernel/ntstubs.c.)
    //
    // All the data pointed by lParam should point the valid
    // client side address. Thus all the validation and copy
    // (if needed) will be done in the receiver side.
    //
    UserAssert(psms == NULL || psms->ptiSender == psms->ptiReceiver);

    switch (wParam) {
    case IMR_CANDIDATEWINDOW:
        cCapture  = 1;
        cbCapture = sizeof(CANDIDATEFORM);
        break;

    case IMR_COMPOSITIONWINDOW:
        cCapture = 1;
        cbCapture = sizeof(COMPOSITIONFORM);
        break;

    case IMR_CONFIRMRECONVERTSTRING:
    case IMR_RECONVERTSTRING:
    case IMR_DOCUMENTFEED:
    case IMR_QUERYCHARPOSITION:
        cCapture = 0;
        cbCapture = 0;
        break;

    case IMR_COMPOSITIONFONT:   // only the exception to the rule above.
        cCapture = 1;
        cbCapture = (dwSCMSFlags & SCMS_FLAGS_ANSI) ? sizeof(LOGFONTA) : sizeof(LOGFONTW);
        break;

    default:
        UserAssert(FALSE);
        cCapture  = 0;
        cbCapture = 0;
        break;
    }

    BEGINSENDCAPTURE(FNIMEREQUEST, cCapture, cbCapture, TRUE);

        MSGDATA()->pwnd     = pwndClient;
        MSGDATA()->msg      = msg;
        MSGDATA()->wParam   = wParam;
        MSGDATA()->u.lParam = lParam;
        MSGDATA()->xParam   = xParam;
        MSGDATA()->xpfnProc = xpfnProc;
        MSGDATA()->fAnsi    = (dwSCMSFlags & SCMS_FLAGS_ANSI);

        LOCKPWND();

        //
        // Preparation
        //

        switch (wParam) {
        case IMR_COMPOSITIONFONT:
            RESERVEBYTES(cbCapture, pOutput, cbOutput);
            break;
        }

        MAKECALLCAPTURE(FNIMEREQUEST);
        UNLOCKPWND();
        CHECKRETURN();

        BEGINCOPYOUT()
            try {
                switch (wParam) {
                case IMR_COMPOSITIONFONT:
                    ProbeForRead(pcbs->pOutput, pcbs->cbOutput, sizeof(DWORD));
                    if (dwSCMSFlags & SCMS_FLAGS_ANSI) {
                        CopyLogFontAtoW((PLOGFONTW)lParam, (PLOGFONTA)pcbs->pOutput);
                    }
                    else {
                        memcpy((LPBYTE)lParam, pcbs->pOutput, cbCapture);
                    }
                    break;
                }
            } except (EXCEPTION_EXECUTE_HANDLER) {
                MSGERROR();
            }
        ENDCOPYOUT()

    TRACECALLBACKMSG("SfnIMEREQUEST");
    ENDSENDCAPTURE(LRESULT,0);
}
#endif // SENDSIDE

#ifdef RECVSIDE
RECVCALL(fnIMEREQUEST, FNIMEREQUESTMSG)
{
    BYTE abOutput[CALLBACKSTACKLIMIT];
    LPVOID pvNew = NULL;
    LPARAM lParam;

    BEGINRECV(0, NULL, pmsg->cbOutput);
    FIXUPPOINTERS();
    if (pmsg->cbOutput <= CALLBACKSTACKLIMIT)
        CallbackStatus.pOutput = abOutput;
    else
        CallbackStatus.pOutput = pmsg->pOutput;

    lParam = CALLDATA(u.lParam);

    switch (CALLDATA(wParam)) {
    case IMR_COMPOSITIONWINDOW:
    case IMR_CANDIDATEWINDOW:
//        lParam = CALLDATA(lParam);
        break;

    case IMR_COMPOSITIONFONT:
        lParam = (LPARAM)CallbackStatus.pOutput;
        break;

    case IMR_QUERYCHARPOSITION:
        if (CALLDATA(fAnsi)) {
            LPPrivateIMECHARPOSITION lpCharPos;

            pvNew = UserLocalAlloc(0, sizeof(PrivateIMECHARPOSITION));
            if (pvNew == NULL) {
                goto error_return;
            }
            lpCharPos = pvNew;
            *lpCharPos = *CALLDATA(u.pImeCharPosition);
            lpCharPos->dwCharPos = lpCharPos->dwCharPositionA;
        }
        break;

    case IMR_RECONVERTSTRING:
    case IMR_CONFIRMRECONVERTSTRING:
    case IMR_DOCUMENTFEED:
        // Real W/A conversion may be needed.
        if (CALLDATA(fAnsi) && lParam) {
            PRECONVERTSTRING Source = (LPRECONVERTSTRING)lParam;
            // Do conversion.
            DWORD dwNewSize = ImmGetReconvertTotalSize(((LPRECONVERTSTRING)lParam)->dwSize, FROM_IME, TRUE);
            if (dwNewSize == 0) {
                goto error_return;
            }

            pvNew = UserLocalAlloc(0, dwNewSize);
            if (pvNew == NULL) {
                goto error_return;
            }
            lParam = (LPARAM)pvNew;

            #define lpReconv ((LPRECONVERTSTRING)lParam)
            // setup the information in the allocated structure
            lpReconv->dwVersion = 0;
            lpReconv->dwSize = dwNewSize;
            if (CALLDATA(wParam) == IMR_CONFIRMRECONVERTSTRING) {
                ImmReconversionWorker(lpReconv, (LPRECONVERTSTRING)lParam, TRUE, CP_ACP);
            }
        }
        break;

   default:
        lParam = CALLDATA(u.lParam);
        break;
    }

    retval = (ULONG_PTR)CALLPROC(CALLDATA(xpfnProc))(
            CALLDATA(pwnd),
            CALLDATA(msg),
            CALLDATA(wParam),
            lParam,
            CALLDATA(xParam));

    switch (CALLDATA(wParam)) {
    case IMR_RECONVERTSTRING:
    case IMR_DOCUMENTFEED:
        if (CALLDATA(fAnsi)) {
            retval = ImmGetReconvertTotalSize((DWORD)retval, FROM_APP, TRUE);
            if (lParam) {
                retval = ImmReconversionWorker((LPRECONVERTSTRING)CALLDATA(u.lParam), (LPRECONVERTSTRING)pvNew, FALSE, CP_ACP);
            }
        }
        break;
    }

    if (pvNew) {
        UserLocalFree(pvNew);
    }
error_return:
    ENDRECV();
}

#undef lpReconv

#endif // RECVSIDE

#endif

/**************************************************************************\
* fnGETDBCSTEXTLENGTHS (DBCS-aware Version)
*
* Gets the Unicode & ANSI lengths
* Internally, lParam pints to the ANSI length in bytes and the return value
* is the Unicode length in bytes.  However, the public definition is maintained
* on the  client side, where lParam is not used and either ANSI or Unicode is
* returned.
*
* 14-Mar-1996 HideyukN  Created
\**************************************************************************/

#if (WM_GETTEXTLENGTH - WM_GETTEXT) != 1
#error "WM_GETTEXT Messages no longer 1 apart. Error in code."
#endif
#if (LB_GETTEXTLEN - LB_GETTEXT) != 1
#error "LB_GETTEXT Messages no longer 1 apart. Error in code."
#endif
#if (CB_GETLBTEXTLEN - CB_GETLBTEXT) != 1
#error "CB_GETLBTEXT Messages no longer 1 apart. Error in code."
#endif

typedef struct _FNGETDBCSTEXTLENGTHSMSG {
    PWND pwnd;
    UINT msg;
    WPARAM wParam;
    ULONG_PTR xParam;
    PROC xpfnProc;
} FNGETDBCSTEXTLENGTHSMSG;

#ifdef SENDSIDE
SMESSAGECALL(GETDBCSTEXTLENGTHS)
{
    BOOL fAnsiSender   = !!(BOOL)lParam;
    BOOL fAnsiReceiver = ((dwSCMSFlags & SCMS_FLAGS_ANSI) != 0);
    LPVOID pfnSavedWndProc = pwnd->lpfnWndProc;

    SETUPPWND(FNGETDBCSTEXTLENGTHS)

    BEGINSEND(FNGETDBCSTEXTLENGTHS)

    UserAssert((fAnsiReceiver & 1) == fAnsiReceiver && (fAnsiSender & 1) == fAnsiSender);

    MSGDATA()->pwnd = pwndClient;
    MSGDATA()->msg = msg;
    MSGDATA()->wParam = wParam;
    MSGDATA()->xParam = xParam;
    MSGDATA()->xpfnProc = xpfnProc;

    LOCKPWND();
    MAKECALL(FNGETTEXTLENGTHS);
    UNLOCKPWND();
    CHECKRETURN1();

    /*
     * ANSI client wndproc returns us cbANSI.  We want cchUnicode,
     * so we guess cchUnicode = cbANSI. (It may be less if
     * multi-byte characters are involved, but it will never be more).
     * Save cbANSI in *lParam in case the server ultimately returns
     * the length to an ANSI caller.
     *
     * Unicode client wndproc returns us cchUnicode.  If we want to know
     * cbANSI, we must guess how many 'ANSI' chars we would need.
     * We guess cbANSI = cchUnicode * 2. (It may be this much if all
     * 'ANSI' characters are multi-byte, but it will never be more).
     *
     * Return cchUnicode (server code is all Unicode internally).
     * Put cbANSI in *lParam to be passed along within the server in case
     * we ultimately need to return it to the client.
     *
     * NOTE: this will sometimes cause text lengths to be misreported
     * up to twice the real length, but that is expected to be harmless.
     * This will only * happen if an app sends WM_GETcode TEXTLENGTH to a
     * window with an ANSI client-side wndproc, or a ANSI WM_GETTEXTLENGTH
     * is sent to a Unicode client-side wndproc.
     */

    BEGINCOPYOUT()

        //
        // retval can be [CB|LB]_ERR (-1) or [CB|LB]_ERRSPACE (-2)
        // then, it should be grater then zero. otherwise we can handle
        // it as error, or zero length string.
        //
        if ((LONG)retval > 0) {

            //
            // Check we need to Ansi <-> Unicode conversion.
            //
            if (fAnsiSender != fAnsiReceiver) {
                if (pwnd->lpfnWndProc != pfnSavedWndProc) {
                    // The window procedure is changed during the first callback.
                    // Let's take a guess for the worst case.
                    RIPMSG1(RIP_WARNING, "GETTEXTLENGTHS(pwnd=%x): The subclass status of winproc changed during 1st callback.",
                            pwnd);
                    retval *= 2;
                }
                else {
                    BOOL bNotString = FALSE; // default is string....

                    if (msg != WM_GETTEXTLENGTH) {
                        DWORD dw;

                        if (!RevalidateHwnd(HW(pwnd))) {
                            MSGERROR1();
                        }

                        //
                        // Get window style.
                        //
                        dw = pwnd->style;

                        if (msg == LB_GETTEXTLEN) {
                            //
                            // See if the control is ownerdraw and does not have the LBS_HASSTRINGS
                            // style.
                            //
                            bNotString =  (!(dw & LBS_HASSTRINGS) &&
                                            (dw & (LBS_OWNERDRAWFIXED | LBS_OWNERDRAWVARIABLE)));
                        } else if (msg == CB_GETLBTEXTLEN) {
                            //
                            // See if the control is ownerdraw and does not have the CBS_HASSTRINGS
                            // style.
                            //
                            bNotString = (!(dw & CBS_HASSTRINGS) &&
                                           (dw & (CBS_OWNERDRAWFIXED | CBS_OWNERDRAWVARIABLE)));
                        } else {
                            MSGERROR1();
                        }

                        //
                        // if so, the length should be ULONG_PTR.
                        //
                        if (bNotString) {
                            retval = sizeof(ULONG_PTR);
                        }
                    }

                    //
                    // if the target data is "string", get it, and compute the length
                    //
                    if (!bNotString) {
                        if (PtiCurrent()->TIF_flags & TIF_INGETTEXTLENGTH) {
                            if (fAnsiSender) {
                                UserAssert(!fAnsiReceiver);
                                //
                                // retval has Unicode character count, guessed DBCS length.
                                //
                                retval *= 2;
                            }
                        } else {
                            //
                            // fAnsiReceiver == 1, retval has MBCS character count.
                            // fAnsiReceiver == 0, retval has Unicode character count.
                            //
                            // Add 1 to make room for zero-terminator.
                            //
                            DWORD cchText   = (DWORD)retval + 1;
                            DWORD cbCapture = cchText;

                            SETUPPWND(FNOUTSTRING)

                            PtiCurrent()->TIF_flags |= TIF_INGETTEXTLENGTH;

                            //
                            // if reciver is Unicode, The buffder should be reserved as musg as
                            // (TextLength * sizeof(WCHAR).
                            //
                            if (!fAnsiReceiver) {
                                cbCapture *= sizeof(WCHAR);
                            }

                            BEGINSENDCAPTURE(FNOUTSTRING, 1, cbCapture, FALSE)

                                MSGDATA()->pwnd = pwndClient;

                                //
                                // Use (msg-1) for sending the WM_GETTEXT, LB_GETTEXT or CB_GETLBTEXT
                                // since the above precompiler checks passed.
                                //
                                MSGDATA()->msg = msg-1;

                                if (msg == WM_GETTEXTLENGTH) {
                                    //
                                    // WM_GETTEXT:
                                    //    wParam = cchTextMax; // number of character to copy.
                                    //    lParam = lpszText;   // address of buffer for text.
                                    //
                                    MSGDATA()->wParam = cchText;
                                } else {
                                    //
                                    // LB_GETTEXT:
                                    // CB_GETLBTEXT:
                                    //    wParam = index;      // item index
                                    //    lParam = lpszText;   // address of buffer for text.
                                    //
                                    MSGDATA()->wParam = wParam;
                                }

                                MSGDATA()->xParam = xParam;
                                MSGDATA()->xpfnProc = xpfnProc;

                                RESERVEBYTES(cbCapture, pOutput, cbOutput);

                                LOCKPWND();
                                MAKECALLCAPTURE(FNOUTSTRING);
                                UNLOCKPWND();
                                CHECKRETURN();

                                BEGINCOPYOUT()
                                        //
                                        // retval can be [CB|LB]_ERR (-1) or [CB|LB]_ERRSPACE (-2)
                                        // then, it should be grater then zero.
                                        //
                                        if ((LONG)retval > 0) {
                                        /*
                                         * Non-zero retval means some text to copy out.
                                         */
                                        CALC_SIZE_STRING_OUT((LONG)retval);
                                    }
                                ENDCOPYOUT()

                                PtiCurrent()->TIF_flags &= ~TIF_INGETTEXTLENGTH;

                            TRACECALLBACKMSG("SfnOUTSTRING");
                            ENDSENDCAPTURE(LRESULT,0);
                        }
                    }
                }
            }
        }
    ENDCOPYOUT()

    TRACECALLBACKMSG("SfnGETDBCSTEXTLENGTHS");
    ENDSEND1(LRESULT,0);
}
#endif // SENDSIDE

#ifdef RECVSIDE
/*
 * The fnGETTEXTLENGTHS routine is used for this message (see... client\dispcb.tpl)
 */
#endif // RECVSIDE

/***************************************************************************\
* xxxClientMonitorEnumProc
*
* Calls the client callback given to EnumDisplayMonitors.
*
* History:
* 05-Sep-1996 adams     Created.
\***************************************************************************/

typedef struct _CLIENTMONITORENUMPROCMSG {
    HMONITOR        hMonitor;
    HDC             hdcMonitor;
    RECT            rc;
    LPARAM          dwData;
    MONITORENUMPROC xpfnProc;
} CLIENTMONITORENUMPROCMSG;

#ifdef SENDSIDE
BOOL xxxClientMonitorEnumProc(
    HMONITOR        hMonitor,
    HDC             hdcMonitor,
    LPRECT          lprc,
    LPARAM          dwData,
    MONITORENUMPROC xpfnProc)
{
    SETUP(CLIENTMONITORENUMPROC)

    BEGINSEND(CLIENTMONITORENUMPROCMSG)

        MSGDATA()->hMonitor = hMonitor;
        MSGDATA()->hdcMonitor = hdcMonitor;
        MSGDATA()->rc = *lprc;
        MSGDATA()->dwData = dwData;
        MSGDATA()->xpfnProc = xpfnProc;

        MAKECALL(CLIENTMONITORENUMPROC);
        CHECKRETURN();

    TRACECALLBACK("SxxxClientMonitorEnumProc");
    ENDSEND(BOOL,FALSE);
}
#endif // SENDSIDE

#ifdef RECVSIDE
RECVCALL(ClientMonitorEnumProc, CLIENTMONITORENUMPROCMSG)
{
    BEGINRECV(FALSE, NULL, 0);

    retval = (DWORD)CALLPROC(pmsg->xpfnProc)(
            CALLDATA(hMonitor),
            CALLDATA(hdcMonitor),
            PCALLDATA(rc),
            CALLDATA(dwData));

    ENDRECV();
}
#endif // RECVSIDE

/**************************************************************************\
* xxxUserModeCallback
*
* Generic kernel callback stub
*
* 10/28/96 GerardoB     Created
\**************************************************************************/
#ifdef SENDSIDE
NTSTATUS xxxUserModeCallback (ULONG uApi, PVOID pIn, ULONG cbIn, PVOID pOut, ULONG cbOut)
{
    NTSTATUS Status;
    PVOID pLocalOut;
    ULONG cbLocalOut;

    /*
     * Call the client
     */
    LeaveCrit();
    Status = KeUserModeCallback(uApi, pIn, cbIn, &pLocalOut, &cbLocalOut);
    EnterCrit();

    /*
     * If it failed, bail
     */
    if (!NT_SUCCESS(Status)) {
        return Status;
    }

    /*
     * If we didn't get the right amount of data, fail.
     */
    if (cbLocalOut != cbOut) {
        RIPMSG3(RIP_WARNING, "xxxUserModeCallback: uAPi: %#lx cbOut: %#lx cbLocalOut: %#lx",
                uApi, cbOut, cbLocalOut);
        return STATUS_UNSUCCESSFUL;
    }

    /*
     * If we were expecting some data, copy it.
     */
    if (cbOut != 0) {
        try {
            ProbeForRead(pLocalOut, cbLocalOut, sizeof(DWORD));
            RtlCopyMemory(pOut, pLocalOut, cbLocalOut);
        } except (W32ExceptionHandler(FALSE, RIP_WARNING)) {
            RIPMSG2(RIP_WARNING, "xxxUserModeCallback: uAPi: %#lx Exception: %#lx", uApi, GetExceptionCode());
            Status = STATUS_UNSUCCESSFUL;
        }
    }

    return Status;
}
#endif // SENDSIDE

/**************************************************************************\
* fnINOUTMENUGETOBJECT
*
* 11/12/96 GerardoB     Created
\**************************************************************************/
typedef struct _FNINOUTMENUGETOBJECTMSG {
    PWND pwnd;
    UINT msg;
    WPARAM wParam;
    MENUGETOBJECTINFO mngoi;
    ULONG_PTR xParam;
    PROC xpfnProc;
} FNINOUTMENUGETOBJECTMSG;

#ifdef SENDSIDE
SMESSAGECALL(INOUTMENUGETOBJECT)
{
    SETUPPWND(FNINOUTMENUGETOBJECT)

    UNREFERENCED_PARAMETER(dwSCMSFlags);

    BEGINSEND(FNOUTDWORDINDWORD)

    PMENUGETOBJECTINFO pmngoi = (PMENUGETOBJECTINFO)lParam;

        MSGDATA()->pwnd = pwndClient;
        MSGDATA()->msg = msg;
        MSGDATA()->wParam = wParam;
        MSGDATA()->mngoi = *pmngoi;
        MSGDATA()->xParam = xParam;
        MSGDATA()->xpfnProc = xpfnProc;

        LOCKPWND();
        MAKECALL(FNINOUTMENUGETOBJECT);
        UNLOCKPWND();
        CHECKRETURN();

        BEGINCOPYOUT()
            try {
                UserAssert(pcbs->cbOutput == sizeof(pmngoi->pvObj));
                ProbeForRead(pcbs->pOutput, sizeof(pmngoi->pvObj), sizeof(DWORD));
                pmngoi->pvObj = *((PVOID *)(pcbs->pOutput));
            } except (W32ExceptionHandler(TRUE, RIP_WARNING)) {
                MSGERROR();
            }
        ENDCOPYOUT()

    TRACECALLBACKMSG("SfnINOUTMENUGETOBJECT");
    ENDSEND(LRESULT, 0);
}
#endif // SENDSIDE

#ifdef RECVSIDE
RECVCALL(fnINOUTMENUGETOBJECT, FNINOUTMENUGETOBJECTMSG)
{
    BEGINRECV(0, &(pmsg->mngoi.pvObj), sizeof(pmsg->mngoi.pvObj));

    retval = (ULONG_PTR)CALLPROC(CALLDATA(xpfnProc))(
            CALLDATA(pwnd),
            CALLDATA(msg),
            CALLDATA(wParam),
            PCALLDATA(mngoi),
            CALLDATA(xParam));

    ENDRECV();
}
#endif // RECVSIDE

/**************************************************************************\
* fnLOGONNOTIFY
*
* 2/1/97   JerrySh      Created
\**************************************************************************/
typedef struct _FNLOGONNOTIFYMSG {
    PWND pwnd;
    UINT msg;
    WPARAM wParam;
    LPARAM lParam;
    POWERSTATEPARAMS psParams;
    ULONG_PTR xParam;
    PROC xpfnProc;
} FNLOGONNOTIFYMSG;

#ifdef SENDSIDE
SMESSAGECALL(LOGONNOTIFY)
{
    SETUPPWND(FNLOGONNOTIFY)

    UNREFERENCED_PARAMETER(dwSCMSFlags);
    UNREFERENCED_PARAMETER(psms);

    BEGINSEND(FNLOGONNOTIFY)

        PPOWERSTATEPARAMS ppsParams = (PPOWERSTATEPARAMS)lParam;

        if (wParam == LOGON_POWERSTATE ||
            wParam == LOGON_REMOVE_POWER_MESSAGE ||
            wParam == LOGON_SHOW_POWER_MESSAGE) {
            MSGDATA()->psParams = *((PPOWERSTATEPARAMS)lParam);
        }

        MSGDATA()->pwnd = pwndClient;
        MSGDATA()->msg = msg;
        MSGDATA()->wParam = wParam;
        MSGDATA()->lParam = lParam;
        MSGDATA()->xParam = xParam;
        MSGDATA()->xpfnProc = xpfnProc;

        LOCKPWND();
        MAKECALL(FNLOGONNOTIFY);
        UNLOCKPWND();
        CHECKRETURN();

        if (wParam == LOGON_POWERSTATE) {
            BEGINCOPYOUT()
                OUTSTRUCT(ppsParams, POWERSTATEPARAMS);
            ENDCOPYOUT()
        }

    TRACECALLBACKMSG("SfnLOGONNOTIFY");
    ENDSEND(LRESULT, 0);
}
#endif // SENDSIDE

#ifdef RECVSIDE
RECVCALL(fnLOGONNOTIFY, FNLOGONNOTIFYMSG)
{
    BEGINRECV(0, &pmsg->psParams, sizeof(pmsg->psParams));

    if (CALLDATA(wParam) == LOGON_POWERSTATE ||
       CALLDATA(wParam) == LOGON_REMOVE_POWER_MESSAGE ||
       CALLDATA(wParam) == LOGON_SHOW_POWER_MESSAGE) {
       CALLDATA(lParam) = (LPARAM)&CALLDATA(psParams);
    }

    retval = (ULONG_PTR)CALLPROC(CALLDATA(xpfnProc))(
            CALLDATA(pwnd),
            CALLDATA(msg),
            CALLDATA(wParam),
            CALLDATA(lParam),
            CALLDATA(xParam));

    ENDRECV();
}
#endif // RECVSIDE

/**************************************************************************\
* xxxClientCallWinEventProc
*
* cf. Win'97 Call32BitEventProc() in user_40\user32\user.c
*
* 1996-10-18 IanJa     Created
\**************************************************************************/

typedef struct _CLIENTCALLWINEVENTPROCMSG {
    WINEVENTPROC  pfn;
    HWINEVENTHOOK hWinEventHook;
    DWORD         event;
    HWND          hwnd;
    LONG          idObject;
    LONG          idChild;
    DWORD         idEventThread;
    DWORD         dwmsEventTime;
} CLIENTCALLWINEVENTPROCMSG;

#ifdef SENDSIDE
BOOL xxxClientCallWinEventProc(
    WINEVENTPROC pfn,
    PEVENTHOOK pEventHook,
    PNOTIFY pNotify)
{
    SETUP(CLIENTCALLWINEVENTPROC)

    BEGINSEND(CLIENTCALLWINEVENTPROC)

        MSGDATA()->pfn = pfn;
        MSGDATA()->hWinEventHook = (HWINEVENTHOOK)PtoH(pEventHook);
        MSGDATA()->hwnd = pNotify->hwnd;
        MSGDATA()->event = pNotify->event;
        MSGDATA()->idObject = pNotify->idObject;
        MSGDATA()->idChild = pNotify->idChild;
        MSGDATA()->idEventThread = pNotify->idSenderThread;
        MSGDATA()->dwmsEventTime = pNotify->dwEventTime;

        MAKECALL(CLIENTCALLWINEVENTPROC);
        CHECKRETURN();

    TRACECALLBACK("xxxClientCallWinEventProc");
    ENDSEND(BOOL, FALSE);
}
#endif // SENDSIDE

#ifdef RECVSIDE
RECVCALL(ClientCallWinEventProc, CLIENTCALLWINEVENTPROCMSG)
{
    BEGINRECV(FALSE, NULL, 0);

    retval = (DWORD)CALLPROC(pmsg->pfn)(
            CALLDATA(hWinEventHook),
            CALLDATA(event),
            CALLDATA(hwnd),
            CALLDATA(idObject),
            CALLDATA(idChild),
            CALLDATA(idEventThread),
            CALLDATA(dwmsEventTime));

    ENDRECV();

}
#endif // RECVSIDE



/**************************************************************************\
* WOWGetProcModule
*
* 3/25/97 FritzS created
\**************************************************************************/

typedef struct _CLIENTWOWGETPROCMODULEMSG {
    WNDPROC_PWND pfn;
} CLIENTWOWGETPROCMODULEMSG;



#ifdef SENDSIDE
WORD xxxClientWOWGetProcModule(
    WNDPROC_PWND pfn)
{
    SETUP(CLIENTWOWGETPROCMODULE)

    BEGINSEND(CLIENTWOWGETPROCMODULE)

        MSGDATA()->pfn = pfn;

        MAKECALL(CLIENTWOWGETPROCMODULE);
        CHECKRETURN();

    TRACECALLBACK("xxxWOWGetProcModule");
    ENDSEND(WORD, FALSE);
}
#endif // SENDSIDE

#ifdef RECVSIDE
RECVCALL(ClientWOWGetProcModule, CLIENTWOWGETPROCMODULEMSG)
{
    ULONG ulReal;
    BEGINRECV(0, NULL, 0);

    if ((pfnWowGetProcModule == NULL) || !IsWOWProc(CALLDATA(pfn))) {
        retval = 0;
    } else {
        UnMarkWOWProc(CALLDATA(pfn),ulReal);
        retval = (pfnWowGetProcModule)(ulReal);
    }

    ENDRECV();

}
#endif // RECVSIDE

/**************************************************************************\
* WOWTask16SchedNotify
*
* 12/20/00 ARR created
\**************************************************************************/

typedef struct _CLIENTWOWTASK16SCHEDNOTIFYMSG {
    DWORD NotifyParm;
    DWORD dwParam;
} CLIENTWOWTASK16SCHEDNOTIFYMSG;

#ifdef SENDSIDE
DWORD xxxClientWOWTask16SchedNotify(
    DWORD NotifyParm,
    DWORD dwParam)
{
    SETUP(CLIENTWOWTASK16SCHEDNOTIFY)

    BEGINSEND(CLIENTWOWTASK16SCHEDNOTIFY)

    MSGDATA()->NotifyParm = NotifyParm;
    MSGDATA()->dwParam = dwParam;

    MAKECALL(CLIENTWOWTASK16SCHEDNOTIFY);
        CHECKRETURN();

    TRACECALLBACK("xxxWOWTask16SchedNotify");
    ENDSEND(DWORD, FALSE);
}
#endif // SENDSIDE

#ifdef RECVSIDE
RECVCALL(ClientWOWTask16SchedNotify, CLIENTWOWTASK16SCHEDNOTIFYMSG)
{
    BEGINRECV(0, NULL, 0);

    if (pfnWowTask16SchedNotify == NULL) {
    retval = 1;
    } else {
    retval = (pfnWowTask16SchedNotify)(CALLDATA(NotifyParm),CALLDATA(dwParam));
    }

    ENDRECV();

}
#endif // RECVSIDE

/**************************************************************************\
* xxxClientLoadStringW
*
* Called to load per user ToolTip strings
*
* 24-Feb-2000 Mhamid    Created
\**************************************************************************/

typedef struct _CLIENTLOADSTRINGWMSG {
    CAPTUREBUF CaptureBuf;
    UINT StrID;
    int cch;
    PBYTE pOutput;
    DWORD cbOutput;
} CLIENTLOADSTRINGWMSG;

#ifdef SENDSIDE
int xxxClientLoadStringW(
    IN UINT StrID,
    OUT LPWSTR szText,
    IN int cch)
{
    DWORD cbCapture;
    PLARGE_STRING pstr;
    BOOL fAnsiReceiver = FALSE;
    LARGE_UNICODE_STRING strName;

    SETUP(CLIENTLOADSTRINGW)

    cbCapture = cch * sizeof(WCHAR);
    RtlInitLargeUnicodeString(&strName, szText, cbCapture);
    pstr = (PLARGE_STRING)&strName;

    BEGINSENDCAPTURE(CLIENTLOADSTRINGW, 1, cbCapture, FALSE)


        MSGDATA()->StrID = StrID;
        MSGDATA()->cch = cch;

        RESERVEBYTES(cbCapture, pOutput, cbOutput);

        MAKECALLCAPTURE(CLIENTLOADSTRINGW);

        CHECKRETURN();

        COPYOUTLPWSTRLIMIT(pstr,cch);

    TRACECALLBACK("ClientLoadStringW");
    ENDSENDCAPTURE(int, 0);

}
#endif // SENDSIDE

#ifdef RECVSIDE
VOID CheckMsgFontDimensions();
RECVCALL(ClientLoadStringW, CLIENTLOADSTRINGWMSG)
{
    BYTE abOutput[CALLBACKSTACKLIMIT];

    BEGINRECV(0, NULL, pmsg->cbOutput);
    FIXUPPOINTERS();

    if (pmsg->cbOutput <= CALLBACKSTACKLIMIT)
        CallbackStatus.pOutput = abOutput;
    else
        CallbackStatus.pOutput = pmsg->pOutput;

    retval = (DWORD)LoadStringOrError(
            hmodUser,
            CALLDATA(StrID),
            (LPWSTR)KPVOID_TO_PVOID(CallbackStatus.pOutput),
            CALLDATA(cch),
            0);

    ENDRECV();
}
#endif // RECVSIDE



/**************************************************************************\
* fnOUTLPCOMBOBOXINFO       (for CB_GETCOMBOBOXINFO message)
*
* 05/12/00   MHamid         Created
\**************************************************************************/
typedef struct _FNOUTLPCOMBOBOXINFOMSG {
    PWND pwnd;
    UINT msg;
    WPARAM wParam;
    COMBOBOXINFO cbinfo;
    ULONG_PTR xParam;
    PROC xpfnProc;
} FNOUTLPCOMBOBOXINFOMSG;


#ifdef SENDSIDE
SMESSAGECALL(OUTLPCOMBOBOXINFO)
{
    SETUPPWND(FNOUTLPCOMBOBOXINFO)

    UNREFERENCED_PARAMETER(dwSCMSFlags);

    BEGINSEND(FNOUTLPCOMBOBOXINFO)

        PCOMBOBOXINFO pcbinfo = (PCOMBOBOXINFO)lParam;

        MSGDATA()->pwnd = pwndClient;
        MSGDATA()->msg = msg;
        MSGDATA()->wParam = wParam;
        MSGDATA()->cbinfo = *pcbinfo;
        MSGDATA()->xParam = xParam;
        MSGDATA()->xpfnProc = xpfnProc;

        LOCKPWND();
        MAKECALL(FNOUTLPCOMBOBOXINFO);
        UNLOCKPWND();
        CHECKRETURN();

        BEGINCOPYOUT()
            OUTSTRUCT(pcbinfo, COMBOBOXINFO);
        ENDCOPYOUT()

    TRACECALLBACKMSG("SfnOUTLPCOMBOBOXINFO");
    ENDSEND(LRESULT,0);
}
#endif // SENDSIDE

#ifdef RECVSIDE
RECVCALL(fnOUTLPCOMBOBOXINFO, FNOUTLPCOMBOBOXINFOMSG)
{
    BEGINRECV(0, &pmsg->cbinfo, sizeof(pmsg->cbinfo));

    retval = (ULONG_PTR)CALLPROC(CALLDATA(xpfnProc))(
            pmsg->pwnd,
            pmsg->msg,
            pmsg->wParam,
            PCALLDATA(cbinfo),
            pmsg->xParam);

    ENDRECV();
}
#endif // RECVSIDE


/**************************************************************************\
* fnOUTLPSCROLLBARINFO      (for SBM_GETSCROLLBARINFO message)
*
* 05/12/00   MHamid         Created
\**************************************************************************/
typedef struct _FNOUTLPSCROLLBARINFOMSG {
    PWND pwnd;
    UINT msg;
    WPARAM wParam;
    SCROLLBARINFO sbinfo;
    ULONG_PTR xParam;
    PROC xpfnProc;
} FNOUTLPSCROLLBARINFOMSG;


#ifdef SENDSIDE
SMESSAGECALL(OUTLPSCROLLBARINFO)
{
    SETUPPWND(FNOUTLPSCROLLBARINFO)

    UNREFERENCED_PARAMETER(dwSCMSFlags);

    BEGINSEND(FNOUTLPSCROLLBARINFO)

        PSCROLLBARINFO psbinfo = (PSCROLLBARINFO)lParam;

        MSGDATA()->pwnd = pwndClient;
        MSGDATA()->msg = msg;
        MSGDATA()->wParam = wParam;
        MSGDATA()->sbinfo = *psbinfo;
        MSGDATA()->xParam = xParam;
        MSGDATA()->xpfnProc = xpfnProc;

        LOCKPWND();
        MAKECALL(FNOUTLPSCROLLBARINFO);
        UNLOCKPWND();
        CHECKRETURN();

        BEGINCOPYOUT()
            OUTSTRUCT(psbinfo, SCROLLBARINFO);
        ENDCOPYOUT()

    TRACECALLBACKMSG("SfnOUTLPSCROLLBARINFO");
    ENDSEND(LRESULT,0);
}
#endif // SENDSIDE

#ifdef RECVSIDE
RECVCALL(fnOUTLPSCROLLBARINFO, FNOUTLPSCROLLBARINFOMSG)
{
    BEGINRECV(0, &pmsg->sbinfo, sizeof(pmsg->sbinfo));

    retval = (ULONG_PTR)CALLPROC(CALLDATA(xpfnProc))(
            pmsg->pwnd,
            pmsg->msg,
            pmsg->wParam,
            PCALLDATA(sbinfo),
            pmsg->xParam);

    ENDRECV();
}
#endif // RECVSIDE

/**************************************************************************\
* GetLUIDDosDrivesOnly
*
* Called to check the drive letters used in the LUID DosDevice
* map.  Does not check if the drive letters are used in the Global
* DosDevices
*
* 08/18/00   ELi         Created
\**************************************************************************/
#ifdef RECVSIDE
__inline DWORD  GetLUIDDosDrivesOnly()
{
    NTSTATUS Status;
    PROCESS_DEVICEMAP_INFORMATION_EX ProcessDeviceMapInfoEx;

    ProcessDeviceMapInfoEx.Flags = PROCESS_LUID_DOSDEVICES_ONLY;

    Status = NtQueryInformationProcess( NtCurrentProcess(),
                                        ProcessDeviceMap,
                                        &ProcessDeviceMapInfoEx,
                                        sizeof( ProcessDeviceMapInfoEx ),
                                        NULL
                                      );
    if (NT_SUCCESS( Status )) {
        return ProcessDeviceMapInfoEx.Query.DriveMap;
    }
    else {
        return 0;
    }
}
#endif // RECVSIDE
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\inc\messages.h ===
/****************************** Module Header ******************************\
* Module Name: messages.h
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* Contains the message indirection table. This is included in both the client
* and server code.
*
* 04-11-91 ScottLu      Created.
\***************************************************************************/

#include "msgdef.h"

#define IMSG_EMPTY      IMSG_DWORD
#define IMSG_RESERVED   IMSG_DWORD

/*
 * Allow posting of LB_DIR and CB_DIR because DlgDirList allows a DDL_POSTMSGS
 * flag that makes the API post the messages.  This should be as long as we
 * don't handle these messages in the kernel.  NT 3.51 allowed posting these.
 */

CONST MSG_TABLE_ENTRY MessageTable[] = {
    //iFunction,
    //           bThunkMessage,
    //                  bSyncOnlyMessage
    {IMSG_DWORD, FALSE, FALSE},                   // WM_NULL                  0x0000
    {IMSG_INLPCREATESTRUCT,  TRUE,  TRUE},        // WM_CREATE                0x0001
    {IMSG_DWORD, FALSE, FALSE},                   // WM_DESTROY               0x0002
    {IMSG_DWORD, FALSE, FALSE},                   // WM_MOVE                  0x0003
    {IMSG_DWORD, FALSE, FALSE},                   // WM_SIZEWAIT              0x0004
    {IMSG_DWORD, FALSE, FALSE},                   // WM_SIZE                  0x0005
    {IMSG_DWORD, FALSE, FALSE},                   // WM_ACTIVATE              0x0006
    {IMSG_DWORD, FALSE, FALSE},                   // WM_SETFOCUS              0x0007
    {IMSG_DWORD, FALSE, FALSE},                   // WM_KILLFOCUS             0x0008
    {IMSG_DWORD, FALSE, FALSE},                   // WM_SETVISIBLE            0x0009
    {IMSG_DWORD, FALSE, FALSE},                   // WM_ENABLE                0x000A
    {IMSG_DWORD, FALSE, FALSE},                   // WM_SETREDRAW             0x000B
    {IMSG_INSTRINGNULL,  TRUE,  TRUE},            // WM_SETTEXT               0x000C
    {IMSG_OUTSTRING,  TRUE,  TRUE},               // WM_GETTEXT               0x000D
    {IMSG_GETDBCSTEXTLENGTHS,  TRUE,  TRUE},      // WM_GETTEXTLENGTH         0x000E
    {IMSG_DWORD, FALSE, FALSE},                   // WM_PAINT                 0x000F

    {IMSG_DWORD, FALSE, FALSE},                   // WM_CLOSE                 0x0010
    {IMSG_DWORD, FALSE, FALSE},                   // WM_QUERYENDSESSION       0x0011
    {IMSG_DWORD, FALSE, FALSE},                   // WM_QUIT                  0x0012
    {IMSG_DWORD, FALSE, FALSE},                   // WM_QUERYOPEN             0x0013
    {IMSG_DWORD, FALSE,  TRUE},                   // WM_ERASEBKGND            0x0014
    {IMSG_DWORD, FALSE, FALSE},                   // WM_SYSCOLORCHANGE        0x0015
    {IMSG_DWORD, FALSE, FALSE},                   // WM_ENDSESSION            0x0016
    {IMSG_DWORD, FALSE, FALSE},                   // WM_SYSTEMERROR           0x0017
    {IMSG_DWORD, FALSE, FALSE},                   // WM_SHOWWINDOW            0x0018
    {IMSG_RESERVED, FALSE, FALSE},                // WM_CTLCOLOR              0x0019
    {IMSG_INSTRINGNULL,  TRUE,  TRUE},            // WM_WININICHANGE          0x001A
    {IMSG_INSTRING,  TRUE,  TRUE},                // WM_DEVMODECHANGE         0x001B
    {IMSG_DWORD, FALSE, FALSE},                   // WM_ACTIVATEAPP           0x001C
    {IMSG_DWORD, FALSE, FALSE},                   // WM_FONTCHANGE            0x001D
    {IMSG_DWORD, FALSE, FALSE},                   // WM_TIMECHANGE            0x001E
    {IMSG_DWORD, FALSE, FALSE},                   // WM_CANCELMODE            0x001F

    {IMSG_DWORD, FALSE, FALSE},                   // WM_SETCURSOR             0x0020
    {IMSG_DWORD, FALSE, FALSE},                   // WM_MOUSEACTIVATE         0x0021
    {IMSG_DWORD, FALSE, FALSE},                   // WM_CHILDACTIVATE         0x0022
    {IMSG_DWORD, FALSE, FALSE},                   // WM_QUEUESYNC             0x0023
    {IMSG_INOUTLPPOINT5, FALSE,  TRUE},           // WM_GETMINMAXINFO         0x0024
    {IMSG_EMPTY, FALSE, FALSE},                   // empty                    0x0025
    {IMSG_DWORD, FALSE, FALSE},                   // WM_PAINTICON             0x0026
    {IMSG_DWORD, FALSE,  TRUE},                   // WM_ICONERASEBKGND        0x0027
    {IMSG_DWORD, FALSE, FALSE},                   // WM_NEXTDLGCTL            0x0028
    {IMSG_DWORD, FALSE, FALSE},                   // WM_ALTTABACTIVE          0x0029
    {IMSG_DWORD, FALSE, FALSE},                   // WM_SPOOLERSTATUS         0x002A
    {IMSG_INLPDRAWITEMSTRUCT, FALSE,  TRUE},      // WM_DRAWITEM              0x002B
    {IMSG_INOUTLPMEASUREITEMSTRUCT, FALSE,  TRUE},// WM_MEASUREITEM           0x002C
    {IMSG_INLPDELETEITEMSTRUCT, FALSE,  TRUE},    // WM_DELETEITEM            0x002D
    {IMSG_DWORD, FALSE, FALSE},                   // WM_VKEYTOITEM            0x002E
    {IMSG_INWPARAMCHAR,  TRUE, FALSE},            // WM_CHARTOITEM            0x002F

    {IMSG_DWORD, FALSE, FALSE},                   // WM_SETFONT               0x0030
    {IMSG_DWORD, FALSE,  TRUE},                   // WM_GETFONT               0x0031
    {IMSG_DWORD, FALSE, FALSE},                   // WM_SETHOTKEY             0x0032
    {IMSG_DWORD, FALSE, FALSE},                   // WM_GETHOTKEY             0x0033
    {IMSG_DWORD, FALSE, FALSE},                   // WM_FILESYSCHANGE         0x0034
    {IMSG_DWORD, FALSE, FALSE},                   // WM_ISACTIVEICON          0x0035
    {IMSG_DWORD, FALSE, FALSE},                   // WM_QUERYPARKICON         0x0036
    {IMSG_DWORD, FALSE, FALSE},                   // WM_QUERYDRAGICON         0x0037
    {IMSG_INLPHLPSTRUCT, FALSE,  TRUE},           // WM_WINHELP               0x0038
    {IMSG_INLPCOMPAREITEMSTRUCT, FALSE,  TRUE},   // WM_COMPAREITEM           0x0039
    {IMSG_KERNELONLY, FALSE, FALSE},              // WM_FULLSCREEN            0x003A
    {IMSG_DWORD, FALSE, FALSE},                   // WM_CLIENTSHUTDOWN        0x003B
    {IMSG_KERNELONLY, FALSE, TRUE},               // WM_DDEMLEVENT            0x003C
    {IMSG_EMPTY, FALSE, FALSE},                   // empty                    0x003D
    {IMSG_EMPTY, FALSE, FALSE},                   // empty                    0x003E
    {IMSG_DWORD, FALSE, FALSE},                   // MM_CALCSCROLL            0x003F

    {IMSG_RESERVED, FALSE, FALSE},                // WM_TESTING               0x0040
    {IMSG_DWORD, FALSE, FALSE},                   // WM_COMPACTING            0x0041

    {IMSG_RESERVED, FALSE, FALSE},                // WM_OTHERWINDOWCREATED    0x0042
    {IMSG_RESERVED, FALSE, FALSE},                // WM_OTHERWINDOWDESTROYED  0x0043
    {IMSG_RESERVED, FALSE, FALSE},                // WM_COMMNOTIFY            0x0044
    {IMSG_RESERVED, FALSE, FALSE},                // WM_MEDIASTATUSCHANGE     0x0045
    {IMSG_INOUTLPWINDOWPOS, FALSE,  TRUE},        // WM_WINDOWPOSCHANGING     0x0046
    {IMSG_INLPWINDOWPOS, FALSE,  TRUE},           // WM_WINDOWPOSCHANGED      0x0047

    {IMSG_RESERVED, FALSE, FALSE},                // WM_POWER                 0x0048
    {IMSG_COPYGLOBALDATA,  TRUE,  TRUE},          // WM_COPYGLOBALDATA        0x0049
    {IMSG_COPYDATA, FALSE,  TRUE},                // WM_COPYDATA              0x004A
    {IMSG_RESERVED, FALSE, FALSE},                // WM_CANCELJOURNAL         0x004B
    {IMSG_LOGONNOTIFY, FALSE, FALSE},             // WM_LOGONNOTIFY           0x004C
    {IMSG_DWORD, FALSE, FALSE},                   // WM_KEYF1                 0x004D
    {IMSG_DWORD, FALSE, FALSE},                   // WM_NOTIFY                0x004E
    {IMSG_RESERVED, FALSE, FALSE},                // WM_ACCESS_WINDOW         0x004f

    {IMSG_DWORD, FALSE, FALSE},                   // WM_INPUTLANGCHANGEREQUEST 0x0050
    {IMSG_DWORD, FALSE, FALSE},                   // WM_INPUTLANGCHANGE       0x0051
    {IMSG_EMPTY, FALSE, FALSE},                   // WM_TCARD                 0x0052
    {IMSG_INLPHELPINFOSTRUCT, FALSE,  TRUE},      // WM_HELP                  0x0053 WINHELP4
    {IMSG_EMPTY, FALSE, FALSE},                   // WM_USERCHANGED           0x0054
    {IMSG_DWORD, FALSE, FALSE},                   // WM_NOTIFYFORMAT          0x0055
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},

    {IMSG_EMPTY, FALSE, FALSE},                   // 0x0059-0x005F
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},

    {IMSG_EMPTY, FALSE, FALSE},                   // 0x0060-0x0067
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},

    {IMSG_EMPTY, FALSE, FALSE},                   // 0x0068-0x006F
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},

    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},

    {IMSG_KERNELONLY, FALSE, TRUE},               // WM_FINALDESTROY          0x0070
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_DWORD, FALSE, FALSE},                   // WM_TASKACTIVATED         0x0072
    {IMSG_DWORD, FALSE, FALSE},                   // WM_TASKDEACTIVATED       0x0073
    {IMSG_DWORD, FALSE, FALSE},                   // WM_TASKCREATED           0x0074
    {IMSG_DWORD, FALSE, FALSE},                   // WM_TASKDESTROYED         0x0075
    {IMSG_DWORD, FALSE, FALSE},                   // WM_TASKUICHANGED         0x0076
    {IMSG_DWORD, FALSE, FALSE},                   // WM_TASKVISIBLE           0x0077
    {IMSG_DWORD, FALSE, FALSE},                   // WM_TASKNOTVISIBLE        0x0078
    {IMSG_DWORD, FALSE, FALSE},                   // WM_SETCURSORINFO         0x0079
    {IMSG_EMPTY, FALSE, FALSE},                   //                          0x007A
    {IMSG_DWORD, FALSE, FALSE},                   // WM_CONTEXTMENU           0x007B
    {IMSG_INOUTSTYLECHANGE, FALSE,  TRUE},        // WM_STYLECHANGING         0x007C
    {IMSG_INOUTSTYLECHANGE, FALSE,  TRUE},        // WM_STYLECHANGED          0x007D
    {IMSG_EMPTY, FALSE, FALSE},                   //                          0x007E
    {IMSG_DWORD, FALSE, FALSE},                   // WM_GETICON               0x007f

    {IMSG_DWORD, FALSE, FALSE},                   // WM_SETICON               0x0080
    {IMSG_INLPCREATESTRUCT,  TRUE,  TRUE},        // WM_NCCREATE              0x0081
    {IMSG_NCDESTROY, FALSE, FALSE},               // WM_NCDESTROY             0x0082
    {IMSG_INOUTNCCALCSIZE, FALSE,  TRUE},         // WM_NCCALCSIZE            0x0083

    {IMSG_DWORD, FALSE, FALSE},                   // WM_NCHITTEST             0x0084
    {IMSG_DWORD, FALSE,  TRUE},                   // WM_NCPAINT               0x0085
    {IMSG_DWORD, FALSE, FALSE},                   // WM_NCACTIVATE            0x0086
    {IMSG_DWORDOPTINLPMSG, FALSE,  TRUE},         // WM_GETDLGCODE            0x0087

    {IMSG_DWORD, FALSE, FALSE},                   // WM_SYNCPAINT             0x0088
    {IMSG_DWORD, FALSE, FALSE},                   // WM_SYNCTASK              0x0089

    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_INOUTLPRECT, FALSE,  TRUE},             // WM_KLUDGEMINRECT         0x008B
    {IMSG_INLPKDRAWSWITCHWND, FALSE, TRUE},       // WM_LPKDRAWSWITCHWND      0x008C
    {IMSG_EMPTY, FALSE, FALSE},                   // 0x008D-0x008F
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},

    {IMSG_EMPTY, FALSE, FALSE},                   // 0x0090-0x0097
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},

    {IMSG_EMPTY, FALSE, FALSE},                   // 0x0098-0x009F
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},

    {IMSG_DWORD, FALSE, FALSE},                   // WM_NCMOUSEMOVE           0x00A0
    {IMSG_DWORD, FALSE, FALSE},                   // WM_NCLBUTTONDOWN         0x00A1
    {IMSG_DWORD, FALSE, FALSE},                   // WM_NCLBUTTONUP           0x00A2
    {IMSG_DWORD, FALSE, FALSE},                   // WM_NCLBUTTONDBLCLK       0x00A3
    {IMSG_DWORD, FALSE, FALSE},                   // WM_NCRBUTTONDOWN         0x00A4
    {IMSG_DWORD, FALSE, FALSE},                   // WM_NCRBUTTONUP           0x00A5
    {IMSG_DWORD, FALSE, FALSE},                   // WM_NCRBUTTONDBLCLK       0x00A6
    {IMSG_DWORD, FALSE, FALSE},                   // WM_NCMBUTTONDOWN         0x00A7
    {IMSG_DWORD, FALSE, FALSE},                   // WM_NCMBUTTONUP           0x00A8
    {IMSG_DWORD, FALSE, FALSE},                   // WM_NCMBUTTONDBLCLK       0x00A9
    {IMSG_EMPTY, FALSE, FALSE},                   // empty                    0x00AA
    {IMSG_DWORD, FALSE, FALSE},                   // WM_NCXBUTTONDOWN         0x00AB
    {IMSG_DWORD, FALSE, FALSE},                   // WM_NCXBUTTONUP           0x00AC
    {IMSG_DWORD, FALSE, FALSE},                   // WM_NCXBUTTONDBLCLK       0x00AD
    {IMSG_DWORD, FALSE, FALSE},                   // WM_NCUAHDRAWCAPTION      0x00AE
    {IMSG_DWORD, FALSE, FALSE},                   // WM_NCUAHDRAWFRAME        0x00AF

    {IMSG_EMGETSEL, FALSE,  TRUE},                // EM_GETSEL                0x00B0
    {IMSG_EMSETSEL, FALSE, FALSE},                // EM_SETSEL                0x00B1
    {IMSG_OUTLPRECT, FALSE,  TRUE},               // EM_GETRECT               0x00B2
    {IMSG_INOUTLPRECT, FALSE,  TRUE},             // EM_SETRECT               0x00B3
    {IMSG_INOUTLPRECT, FALSE,  TRUE},             // EM_SETRECTNP             0x00B4
    {IMSG_DWORD, FALSE, FALSE},                   // EM_SCROLL                0x00B5
    {IMSG_DWORD, FALSE, FALSE},                   // EM_LINESCROLL            0x00B6
    {IMSG_EMPTY, FALSE, FALSE},                   // empty                    0x00B7
    {IMSG_DWORD, FALSE, FALSE},                   // EM_GETMODIFY             0x00B8
    {IMSG_DWORD, FALSE, FALSE},                   // EM_SETMODIFY             0x00B9
    {IMSG_DWORD, FALSE, FALSE},                   // EM_GETLINECOUNT          0x00BA
    {IMSG_DWORD, FALSE, FALSE},                   // EM_LINEINDEX             0x00BB
    {IMSG_DWORD, FALSE, FALSE},                   // EM_SETHANDLE             0x00BC
    {IMSG_DWORD, FALSE, FALSE},                   // EM_GETHANDLE             0x00BD
    {IMSG_DWORD, FALSE, FALSE},                   // EM_GETTHUMB              0x00BE
    {IMSG_EMPTY, FALSE, FALSE},                   // empty                    0x00BF

    {IMSG_EMPTY, FALSE, FALSE},                   // empty                    0x00C0
    {IMSG_DWORD, FALSE, FALSE},                   // EM_LINELENGTH            0x00C1
    {IMSG_INSTRINGNULL,  TRUE,  TRUE},            // EM_REPLACESEL            0x00C2
    {IMSG_DWORD, FALSE, FALSE},                   // EM_SETFONT               0x00C3
    {IMSG_INCNTOUTSTRING,  TRUE,  TRUE},          // EM_GETLINE               0x00C4
    {IMSG_DWORD, FALSE, FALSE},                   // EM_LIMITTEXT             0x00C5
    {IMSG_DWORD, FALSE, FALSE},                   // EM_CANUNDO               0x00C6
    {IMSG_DWORD, FALSE, FALSE},                   // EM_UNDO                  0x00C7
    {IMSG_DWORD, FALSE, FALSE},                   // EM_FMTLINES              0x00C8
    {IMSG_DWORD, FALSE, FALSE},                   // EM_LINEFROMCHAR          0x00C9
    {IMSG_DWORD, FALSE, FALSE},                   // EM_SETWORDBREAK          0x00CA
    {IMSG_POPTINLPUINT, FALSE,  TRUE},            // EM_SETTABSTOPS           0x00CB
    {IMSG_INWPARAMDBCSCHAR,  TRUE, FALSE},        // EM_SETPASSWORDCHAR       0x00CC
    {IMSG_DWORD, FALSE, FALSE},                   // EM_EMPTYUNDOBUFFER       0x00CD
    {IMSG_DWORD, FALSE, FALSE},                   // EM_GETFIRSTVISIBLELINE   0x00CE
    {IMSG_DWORD, FALSE, FALSE},                   // EM_SETREADONLY           0x00CF

    {IMSG_DWORD, FALSE, FALSE},                   // EM_SETWORDBREAKPROC      0x00D0
    {IMSG_DWORD, FALSE, FALSE},                   // EM_GETWORDBREAKPROC      0x00D1
    {IMSG_DWORD, FALSE, FALSE},                   // EM_GETPASSWORDCHAR       0x00D2
    {IMSG_DWORD, FALSE, FALSE},                   // EM_SETMARGINS            0x00D3
    {IMSG_DWORD, FALSE, FALSE},                   // EM_GETMARGINS            0x00D4
    {IMSG_DWORD, FALSE, FALSE},                   // EM_GETLIMITTEXT          0x00D5
    {IMSG_DWORD, FALSE, FALSE},                   // EM_POSFROMCHAR           0x00D6
    {IMSG_DWORD, FALSE, FALSE},                   // EM_CHARFROMPOS           0x00D7
    {IMSG_DWORD, FALSE, FALSE},                   // EM_SETIMESTATUS          0x00D8

    {IMSG_DWORD, FALSE, FALSE},                   // EM_GETIMESTATUS          0x00D9
    {IMSG_RESERVED, FALSE, FALSE},                // EM_MSGMAX                0x00DA
    {IMSG_EMPTY, FALSE, FALSE},                   // 0x00DB-0x00DF
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},

    {IMSG_DWORD, FALSE, FALSE},                   // SBM_SETPOS               0x00E0
    {IMSG_DWORD, FALSE, FALSE},                   // SBM_GETPOS               0x00E1
    {IMSG_DWORD, FALSE, FALSE},                   // SBM_SETRANGE             0x00E2
    {IMSG_OPTOUTLPDWORDOPTOUTLPDWORD, FALSE,  TRUE}, // SBM_GETRANGE          0x00E3
    {IMSG_DWORD, FALSE, FALSE},                   // SBM_ENABLE_ARROWS        0x00E4
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_DWORD, FALSE, FALSE},                   // SBM_SETRANGEREDRAW       0x00E6
    {IMSG_EMPTY, FALSE, FALSE},

    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_INOUTLPSCROLLINFO, FALSE,  TRUE},       // SBM_SETSCROLLINFO        0x00E9
    {IMSG_INOUTLPSCROLLINFO, FALSE,  TRUE},       // SBM_GETSCROLLINFO        0x00EA
    {IMSG_OUTLPSCROLLBARINFO, FALSE, TRUE},       // CB_GETSCROLLBARINFO      0x00EB
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},

    {IMSG_DWORD, FALSE, FALSE},                   // BM_GETCHECK              0x00F0
    {IMSG_DWORD, FALSE, FALSE},                   // BM_SETCHECK              0x00F1
    {IMSG_DWORD, FALSE, FALSE},                   // BM_GETSTATE              0x00F2
    {IMSG_DWORD, FALSE, FALSE},                   // BM_SETSTATE              0x00F3
    {IMSG_DWORD, FALSE, FALSE},                   // BM_SETSTYLE              0x00F4
    {IMSG_DWORD, FALSE, FALSE},                   // BM_CLICK                 0x00F5
    {IMSG_DWORD, FALSE, FALSE},                   // BM_GETIMAGE              0x00F6
    {IMSG_DWORD, FALSE, FALSE},                   // BM_SETIMAGE              0x00F7

    {IMSG_EMPTY, FALSE, FALSE},                   // 0x00F8-0x00FE
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},

    {IMSG_DWORD, FALSE, FALSE},                   // WM_INPUT                 0x00FF
    {IMSG_DWORD, FALSE, FALSE},                   // WM_KEYDOWN               0x0100
    {IMSG_DWORD, FALSE, FALSE},                   // WM_KEYUP                 0x0101
    {IMSG_INWPARAMDBCSCHAR,  TRUE, FALSE},        // WM_CHAR                  0x0102
    {IMSG_INWPARAMCHAR,  TRUE, FALSE},            // WM_DEADCHAR              0x0103
    {IMSG_DWORD, FALSE, FALSE},                   // WM_SYSKEYDOWN            0x0104
    {IMSG_DWORD, FALSE, FALSE},                   // WM_SYSKEYUP              0x0105
    {IMSG_INWPARAMCHAR,  TRUE, FALSE},            // WM_SYSCHAR               0x0106
    {IMSG_INWPARAMCHAR,  TRUE, FALSE},            // WM_SYSDEADCHAR           0x0107
    {IMSG_DWORD, FALSE,  TRUE},                   // WM_YOMICHAR              0x0108
    {IMSG_DWORD, FALSE, FALSE},                   // WM_UNICHAR               0x0109
    {IMSG_RESERVED, FALSE,  TRUE},                // WM_CONVERTREQUEST        0x010A
    {IMSG_RESERVED, FALSE, FALSE},                // WM_CONVERTRESULT         0x010B
    {IMSG_EMPTY, FALSE, FALSE},                   // empty                    0x010C
    {IMSG_EMPTY, FALSE, FALSE},                   // empty                    0x010D
    {IMSG_EMPTY, FALSE, FALSE},                   // empty                    0x010E
    {IMSG_INWPARAMCHAR,  TRUE, FALSE},            // WM_IME_COMPOSITION       0x010F

    {IMSG_DWORD, FALSE, TRUE},                    // WM_INITDIALOG            0x0110
    {IMSG_DWORD, FALSE, FALSE},                   // WM_COMMAND               0x0111
    {IMSG_DWORD, FALSE, FALSE},                   // WM_SYSCOMMAND            0x0112
    {IMSG_DWORD, FALSE, FALSE},                   // WM_TIMER                 0x0113
    {IMSG_DWORD, FALSE, FALSE},                   // WM_HSCROLL               0x0114
    {IMSG_DWORD, FALSE, FALSE},                   // WM_VSCROLL               0x0115
    {IMSG_DWORD, FALSE, FALSE},                   // WM_INITMENU              0x0116
    {IMSG_DWORD, FALSE, FALSE},                   // WM_INITMENUPOPUP         0x0117
    {IMSG_DWORD, FALSE, FALSE},                   // WM_SYSTIMER              0x0118
    {IMSG_EMPTY, FALSE, FALSE},                   // empty                    0x0119
    {IMSG_EMPTY, FALSE, FALSE},                   // empty                    0x011A
    {IMSG_EMPTY, FALSE, FALSE},                   // empty                    0x011B
    {IMSG_EMPTY, FALSE, FALSE},                   // empty                    0x011C
    {IMSG_EMPTY, FALSE, FALSE},                   // empty                    0x011D
    {IMSG_EMPTY, FALSE, FALSE},                   // empty                    0x011E
    {IMSG_DWORD, FALSE, FALSE},                   // WM_MENUSELECT            0x011F

    {IMSG_INWPARAMCHAR,  TRUE, FALSE},            // WM_MENUCHAR              0x0120
    {IMSG_DWORD, FALSE, FALSE},                   // WM_ENTERIDLE             0x0121
    {IMSG_DWORD, FALSE, FALSE},                   // WM_MENURBUTTONUP         0x0122
    {IMSG_DWORD, FALSE, FALSE},                   // WM_MENUDRAG              0x0123
    {IMSG_INOUTMENUGETOBJECT, TRUE, TRUE},        // WM_MENUGETOBJECT         0x0124
    {IMSG_DWORD, FALSE, FALSE},                   // WM_UNINITMENUPOPUP       0x0125
    {IMSG_DWORD, FALSE, FALSE},                   // WM_MENUCOMMAND           0x0126
    {IMSG_DWORD, FALSE, FALSE},                   // WM_CHANGEUISTATE         0x0127
    {IMSG_DWORD, FALSE, FALSE},                   // WM_UPDATEUISTATE         0x0128
    {IMSG_DWORD, FALSE, FALSE},                   // WM_QUERYUISTATE          0x0129

    {IMSG_EMPTY, FALSE, FALSE},                   // 0x012A-0x012F
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},

    {IMSG_EMPTY, FALSE, FALSE},                   // empty                    0x0130
    {IMSG_DWORD, FALSE, FALSE},                   // WM_LBTRACKPOINT          0x0131
    {IMSG_DWORD, FALSE,  TRUE},                   // WM_CTLCOLORMSGBOX        0x0132
    {IMSG_DWORD, FALSE,  TRUE},                   // WM_CTLCOLOREDIT          0x0133
    {IMSG_DWORD, FALSE,  TRUE},                   // WM_CTLCOLORLISTBOX       0x0134
    {IMSG_DWORD, FALSE,  TRUE},                   // WM_CTLCOLORBTN           0x0135
    {IMSG_DWORD, FALSE,  TRUE},                   // WM_CTLCOLORDLG           0x0136
    {IMSG_DWORD, FALSE,  TRUE},                   // WM_CTLCOLORSCROLLBAR     0x0137
    {IMSG_DWORD, FALSE,  TRUE},                   // WM_CTLCOLORSTATIC        0x0138
    {IMSG_EMPTY, FALSE, FALSE},                   //                          0x0139

    {IMSG_EMPTY, FALSE, FALSE},                   // 0x013A-0x013F
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},

    {IMSG_CBGETEDITSEL, FALSE,  TRUE},            // CB_GETEDITSEL            0x0140
    {IMSG_DWORD, FALSE, FALSE},                   // CB_LIMITTEXT             0x0141
    {IMSG_DWORD, FALSE, FALSE},                   // CB_SETEDITSEL            0x0142
    {IMSG_INCBOXSTRING,  TRUE,  TRUE},            // CB_ADDSTRING             0x0143
    {IMSG_DWORD, FALSE, FALSE},                   // CB_DELETESTRING          0x0144
    {IMSG_INSTRING,  TRUE,  FALSE},               // CB_DIR                   0x0145
    {IMSG_DWORD, FALSE, FALSE},                   // CB_GETCOUNT              0x0146
    {IMSG_DWORD, FALSE, FALSE},                   // CB_GETCURSEL             0x0147
    {IMSG_OUTCBOXSTRING,  TRUE,  TRUE},           // CB_GETLBTEXT             0x0148
    {IMSG_GETDBCSTEXTLENGTHS,  TRUE,  TRUE},      // CB_GETLBTEXTLEN          0x0149
    {IMSG_INCBOXSTRING,  TRUE,  TRUE},            // CB_INSERTSTRING          0x014A
    {IMSG_DWORD, FALSE, FALSE},                   // CB_RESETCONTENT          0x014B
    {IMSG_INCBOXSTRING,  TRUE,  TRUE},            // CB_FINDSTRING            0x014C
    {IMSG_INCBOXSTRING,  TRUE,  TRUE},            // CB_SELECTSTRING          0x014D
    {IMSG_DWORD, FALSE, FALSE},                   // CB_SETCURSEL             0x014E
    {IMSG_DWORD, FALSE, FALSE},                   // CB_SHOWDROPDOWN          0x014F

    {IMSG_DWORD, FALSE, FALSE},                   // CB_GETITEMDATA           0x0150
    {IMSG_DWORD, FALSE, FALSE},                   // CB_SETITEMDATA           0x0151
    {IMSG_OUTLPRECT, FALSE,  TRUE},               // CB_GETDROPPEDCONTROLRECT 0x0152
    {IMSG_DWORD, FALSE, FALSE},                   // CB_SETITEMHEIGHT         0x0153
    {IMSG_DWORD, FALSE, FALSE},                   // CB_GETITEMHEIGHT         0x0154
    {IMSG_DWORD, FALSE, FALSE},                   // CB_SETEXTENDEDUI         0x0155
    {IMSG_DWORD, FALSE, FALSE},                   // CB_GETEXTENDEDUI         0x0156
    {IMSG_DWORD, FALSE, FALSE},                   // CB_GETDROPPEDSTATE       0x0157
    {IMSG_INCBOXSTRING,  TRUE,  TRUE},            // CB_FINDSTRINGEXACT       0x0158
    {IMSG_DWORD, FALSE, FALSE},                   // CB_SETLOCALE             0x0159
    {IMSG_DWORD, FALSE, FALSE},                   // CB_GETLOCALE             0x015A
    {IMSG_DWORD, FALSE, FALSE},                   // CB_GETTOPINDEX           0x015b

    {IMSG_DWORD, FALSE, FALSE},                   // CB_SETTOPINDEX           0x015c
    {IMSG_DWORD, FALSE, FALSE},                   // CB_GETHORIZONTALEXTENT   0x015d
    {IMSG_DWORD, FALSE, FALSE},                   // CB_SETHORIZONTALEXTENT   0x015e
    {IMSG_DWORD, FALSE, FALSE},                   // CB_GETDROPPEDWIDTH       0x015F

    {IMSG_DWORD, FALSE, FALSE},                   // CB_SETDROPPEDWIDTH       0x0160
    {IMSG_DWORD, FALSE, FALSE},                   // CB_INITSTORAGE           0x0161
    {IMSG_EMPTY, FALSE, FALSE},                   // 0x0162
    {IMSG_EMPTY, FALSE, FALSE},                   // CB_MULTIPLEADDSTRING     0x0163
    {IMSG_OUTLPCOMBOBOXINFO,  FALSE, TRUE},       // CB_GETCOMBOBOXINFO       0x0164
    {IMSG_RESERVED, FALSE, FALSE},                // CB_MSGMAX                0x0165
    {IMSG_EMPTY, FALSE, FALSE},                   // 0x0166-0x0167
    {IMSG_EMPTY, FALSE, FALSE},

    {IMSG_EMPTY, FALSE, FALSE},                   // 0x0168-0x016F
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},

    {IMSG_DWORD, FALSE, FALSE},                   // STM_SETICON              0x0170
    {IMSG_DWORD, FALSE, FALSE},                   // STM_GETICON              0x0171
    {IMSG_DWORD, FALSE, FALSE},                   // STM_SETIMAGE             0x0172
    {IMSG_DWORD, FALSE, FALSE},                   // STM_GETIMAGE             0x0173
    {IMSG_DWORD, FALSE, FALSE},                   // STM_MSGMAX               0x0174
    {IMSG_EMPTY, FALSE, FALSE},                   // 0x0175-0x0177
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},

    {IMSG_EMPTY, FALSE, FALSE},                   // 0x0178-0x017F
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},

    {IMSG_INLBOXSTRING,  TRUE,  TRUE},            // LB_ADDSTRING             0x0180
    {IMSG_INLBOXSTRING,  TRUE,  TRUE},            // LB_INSERTSTRING          0x0181
    {IMSG_DWORD, FALSE, FALSE},                   // LB_DELETESTRING          0x0182
    {IMSG_EMPTY, FALSE, FALSE},                   // empty                    0x0183
    {IMSG_DWORD, FALSE, FALSE},                   // LB_RESETCONTENT          0x0184
    {IMSG_DWORD, FALSE, FALSE},                   // LB_SETSEL                0x0185
    {IMSG_DWORD, FALSE, FALSE},                   // LB_SETCURSEL             0x0186
    {IMSG_DWORD, FALSE, FALSE},                   // LB_GETSEL                0x0187
    {IMSG_DWORD, FALSE, FALSE},                   // LB_GETCURSEL             0x0188
    {IMSG_OUTLBOXSTRING,  TRUE,  TRUE},           // LB_GETTEXT               0x0189
    {IMSG_GETDBCSTEXTLENGTHS,  TRUE,  TRUE},      // LB_GETTEXTLEN            0x018A
    {IMSG_DWORD, FALSE, FALSE},                   // LB_GETCOUNT              0x018B
    {IMSG_INLBOXSTRING,  TRUE,  TRUE},            // LB_SELECTSTRING          0x018C
    {IMSG_INSTRING,  TRUE,  FALSE},               // LB_DIR                   0x018D
    {IMSG_DWORD, FALSE, FALSE},                   // LB_GETTOPINDEX           0x018E
    {IMSG_INLBOXSTRING,  TRUE,  TRUE},            // LB_FINDSTRING            0x018F

    {IMSG_DWORD, FALSE, FALSE},                   // LB_GETSELCOUNT           0x0190
    {IMSG_POUTLPINT, FALSE,  TRUE},               // LB_GETSELITEMS           0x0191
    {IMSG_POPTINLPUINT, FALSE,  TRUE},            // LB_SETTABSTOPS           0x0192
    {IMSG_DWORD, FALSE, FALSE},                   // LB_GETHORIZONTALEXTENT   0x0193
    {IMSG_DWORD, FALSE, FALSE},                   // LB_SETHORIZONTALEXTENT   0x0194
    {IMSG_DWORD, FALSE, FALSE},                   // LB_SETCOLUMNWIDTH        0x0195
    {IMSG_INSTRING,  TRUE,  TRUE},                // LB_ADDFILE               0x0196
    {IMSG_DWORD, FALSE, FALSE},                   // LB_SETTOPINDEX           0x0197
    {IMSG_INOUTLPRECT, FALSE,  TRUE},             // LB_GETITEMRECT           0x0198
    {IMSG_DWORD, FALSE, FALSE},                   // LB_GETITEMDATA           0x0199
    {IMSG_DWORD, FALSE, FALSE},                   // LB_SETITEMDATA           0x019A
    {IMSG_DWORD, FALSE, FALSE},                   // LB_SELITEMRANGE          0x019B
    {IMSG_DWORD, FALSE, FALSE},                   // LB_SETANCHORINDEX        0x019C
    {IMSG_DWORD, FALSE, FALSE},                   // LB_GETANCHORINDEX        0x019D
    {IMSG_DWORD, FALSE, FALSE},                   // LB_SETCARETINDEX         0x019E
    {IMSG_DWORD, FALSE, FALSE},                   // LB_GETCARETINDEX         0x019F

    {IMSG_DWORD, FALSE, FALSE},                   // LB_SETITEMHEIGHT         0x01A0
    {IMSG_DWORD, FALSE, FALSE},                   // LB_GETITEMHEIGHT         0x01A1
    {IMSG_INLBOXSTRING,  TRUE,  TRUE},            // LB_FINDSTRINGEXACT       0x01A2
    {IMSG_DWORD, FALSE, FALSE},                   // LBCB_CARETON             0x01A3
    {IMSG_DWORD, FALSE, FALSE},                   // LBCB_CARETOFF            0x01A4
    {IMSG_DWORD, FALSE, FALSE},                   // LB_SETLOCALE             0x01A5
    {IMSG_DWORD, FALSE, FALSE},                   // LB_GETLOCALE             0x01A6
    {IMSG_DWORD, FALSE, FALSE},                   // LB_SETCOUNT              0x01A7

    {IMSG_DWORD, FALSE, FALSE},                   // LB_INITSTORAGE           0x01A8

    {IMSG_DWORD, FALSE, FALSE},                   // LB_ITEMFROMPOINT         0x01A9
    {IMSG_INLBOXSTRING,  TRUE,  TRUE},            // LB_INSERTSTRINGUPPER     0x01AA
    {IMSG_INLBOXSTRING,  TRUE,  TRUE},            // LB_INSERTSTRINGLOWER     0x01AB
    {IMSG_INLBOXSTRING,  TRUE,  TRUE},            // LB_ADDSTRINGUPPER        0x01AC
    {IMSG_INLBOXSTRING,  TRUE,  TRUE},            // LB_ADDSTRINGLOWER        0x01AD
    {IMSG_DWORD, FALSE, FALSE},                   // LBCB_STARTTRACK          0x01AE
    {IMSG_DWORD, FALSE, FALSE},                   // LBCB_ENDTRACK            0x01AF

    {IMSG_EMPTY, FALSE, FALSE},                   // 0x01B0
    {IMSG_EMPTY, FALSE, FALSE},                   // LB_MULTIPLEADDSTRING     0x01B1
    {IMSG_DWORD, FALSE,  TRUE},                   // LB_GETLISTBOXINFO        0x01B2
    {IMSG_RESERVED, FALSE, FALSE},                // LB_MSGMAX                0x01B3
    {IMSG_EMPTY, FALSE, FALSE},                   // 0x01B4-0x01B7
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},

    {IMSG_EMPTY, FALSE, FALSE},                   // 0x01B8-0x01BF
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},

    {IMSG_EMPTY, FALSE, FALSE},                   // 0x01C0-0x01C7
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},

    {IMSG_EMPTY, FALSE, FALSE},                   // 0x01C8-0x01CF
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},

    {IMSG_EMPTY, FALSE, FALSE},                   // 0x01D0-0x01D7
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},

    {IMSG_EMPTY, FALSE, FALSE},                   // 0x01D8-0x01DF
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},

    {IMSG_DWORD, FALSE, FALSE},                   // MN_SETHMENU              0x01E0
    {IMSG_DWORD, FALSE, FALSE},                   // MN_GETHMENU              0x01E1
    {IMSG_DWORD, FALSE, FALSE},                   // MN_SIZEWINDOW            0x01E2
    {IMSG_DWORD, FALSE, FALSE},                   // MN_OPENHIERARCHY         0x01E3
    {IMSG_DWORD, FALSE, FALSE},                   // MN_CLOSEHIERARCHY        0x01E4
    {IMSG_DWORD, FALSE, FALSE},                   // MN_SELECTITEM            0x01E5
    {IMSG_DWORD, FALSE, FALSE},                   // MN_CANCELMENUS           0x01E6
    {IMSG_DWORD, FALSE, FALSE},                   // MN_SELECTFIRSTVALIDITEM  0x01E7

    {IMSG_EMPTY, FALSE, FALSE},                   // 0x1E8 - 0x1E9
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},                   // MN_GETPPOPUPMENU(obsolete) 0x01EA
    {IMSG_OUTDWORDINDWORD, FALSE,  TRUE},         // MN_FINDMENUWINDOWFROMPOINT 0x01EB
    {IMSG_DWORD, FALSE, FALSE},                   // MN_SHOWPOPUPWINDOW         0x01EC
    {IMSG_DWORD, FALSE, FALSE},                   // MN_BUTTONDOWN              0x01ED
    {IMSG_DWORD, FALSE, FALSE},                   // MN_MOUSEMOVE               0x01EE
    {IMSG_DWORD, FALSE, FALSE},                   // MN_BUTTONUP                0x01EF
    {IMSG_DWORD, FALSE, FALSE},                   // MN_SETTIMERTOOPENHIERARCHY 0x01F0

    {IMSG_DWORD, FALSE, FALSE},                   // MN_DBLCLK                  0x01F1
    {IMSG_DWORD, FALSE, FALSE},                   // MN_ENDMENU                 0x01F2
    {IMSG_DWORD, FALSE, FALSE},                   // MN_DODRAGDROP              0x01F3
    {IMSG_DWORD, FALSE, FALSE},                   // MN_ENDMENU                 0x01F4

    {IMSG_EMPTY, FALSE, FALSE},                   // 0x01F5-0x01F7
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},

    {IMSG_EMPTY, FALSE, FALSE},                   // 0x01F8-0x01FF
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},

    {IMSG_DWORD, FALSE, FALSE},                   // WM_MOUSEMOVE             0x0200
    {IMSG_DWORD, FALSE, FALSE},                   // WM_LBUTTONDOWN           0x0201
    {IMSG_DWORD, FALSE, FALSE},                   // WM_LBUTTONUP             0x0202
    {IMSG_DWORD, FALSE, FALSE},                   // WM_LBUTTONDBLCLK         0x0203
    {IMSG_DWORD, FALSE, FALSE},                   // WM_RBUTTONDOWN           0x0204
    {IMSG_DWORD, FALSE, FALSE},                   // WM_RBUTTONUP             0x0205
    {IMSG_DWORD, FALSE, FALSE},                   // WM_RBUTTONDBLCLK         0x0206
    {IMSG_DWORD, FALSE, FALSE},                   // WM_MBUTTONDOWN           0x0207
    {IMSG_DWORD, FALSE, FALSE},                   // WM_MBUTTONUP             0x0208
    {IMSG_DWORD, FALSE, FALSE},                   // WM_MBUTTONDBLCLK         0x0209
    {IMSG_DWORD, FALSE, FALSE},                   // WM_MOUSEWHEEL            0x020A
    {IMSG_DWORD, FALSE, FALSE},                   // WM_XBUTTONDOWN           0x020B
    {IMSG_DWORD, FALSE, FALSE},                   // WM_XBUTTONUP             0x020C
    {IMSG_DWORD, FALSE, FALSE},                   // WM_XBUTTONDBLCLK         0x020D
    {IMSG_EMPTY, FALSE, FALSE},                   // empty                    0x020E
    {IMSG_EMPTY, FALSE, FALSE},                   // empty                    0x020F

    {IMSG_DWORD, FALSE,  TRUE},                   // WM_PARENTNOTIFY          0x0210
    {IMSG_DWORD, FALSE, FALSE},                   // WM_ENTERMENULOOP         0x0211
    {IMSG_DWORD, FALSE, FALSE},                   // WM_EXITMENULOOP          0x0212
    {IMSG_INOUTNEXTMENU, FALSE,  TRUE},           // WM_NEXTMENU              0x0213

    {IMSG_INOUTLPRECT, FALSE,  TRUE},             // WM_SIZING                0x0214
    {IMSG_DWORD, FALSE, FALSE},                   // WM_CAPTURECHANGED        0x0215
    {IMSG_INOUTLPRECT, FALSE,  TRUE},             // WM_MOVING                0x0216
    {IMSG_EMPTY, FALSE, FALSE},

    {IMSG_POWERBROADCAST, FALSE, FALSE},          // WM_POWERBROADCAST        0x0218
    {IMSG_INDEVICECHANGE, FALSE, FALSE},          // WM_DEVICECHANGE          0x0219
    {IMSG_EMPTY, FALSE, FALSE},                   // 0x021A-0x021F
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},

    {IMSG_INLPMDICREATESTRUCT,  TRUE,  TRUE},     // WM_MDICREATE             0x0220
    {IMSG_DWORD, FALSE, FALSE},                   // WM_MDIDESTROY            0x0221
    {IMSG_DWORD, FALSE, FALSE},                   // WM_MDIACTIVATE           0x0222
    {IMSG_DWORD, FALSE, FALSE},                   // WM_MDIRESTORE            0x0223
    {IMSG_DWORD, FALSE, FALSE},                   // WM_MDINEXT               0x0224
    {IMSG_DWORD, FALSE, FALSE},                   // WM_MDIMAXIMIZE           0x0225
    {IMSG_RESERVED, FALSE, FALSE},                // WM_MDITILE               0x0226
    {IMSG_DWORD, FALSE, FALSE},                   // WM_MDICASCADE            0x0227
    {IMSG_DWORD, FALSE, FALSE},                   // WM_MDIICONARRANGE        0x0228
    {IMSG_OPTOUTLPDWORDOPTOUTLPDWORD, FALSE,  TRUE}, // WM_MDIGETACTIVE       0x0229
    {IMSG_INOUTDRAG, FALSE,  TRUE},               // WM_DROPOBJECT            0x022A
    {IMSG_INOUTDRAG, FALSE,  TRUE},               // WM_QUERYDROPOBJECT       0x022B
    {IMSG_DWORD, FALSE, FALSE},                   // WM_BEGINDRAG             0x022C
    {IMSG_INOUTDRAG, FALSE,  TRUE},               // WM_DRAGLOOP              0x022D
    {IMSG_INOUTDRAG, FALSE,  TRUE},               // WM_DRAGSELECT            0x022E
    {IMSG_INOUTDRAG, FALSE,  TRUE},               // WM_DRAGMOVE              0x022F

    {IMSG_DWORD, FALSE, FALSE},                   // WM_MDISETMENU            0x0230
    {IMSG_DWORD, FALSE, FALSE},                   // WM_ENTERSIZEMOVE         0x0231
    {IMSG_DWORD, FALSE, FALSE},                   // WM_EXITSIZEMOVE          0x0232

    {IMSG_EMPTY, FALSE, FALSE},                   // WM_DROPFILES             0x0233
    {IMSG_DWORD, FALSE, FALSE},                   // WM_MDIREFRESHMENU        0x0234
    {IMSG_EMPTY, FALSE, FALSE},                   // 0x0235-0x0237
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},

    {IMSG_EMPTY, FALSE, FALSE},                   // 0x0238-0x023F
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},

    {IMSG_EMPTY, FALSE, FALSE},                   // 0x0240-0x0247
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},

    {IMSG_EMPTY, FALSE, FALSE},                   // 0x0248-0x024F
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},

    {IMSG_EMPTY, FALSE, FALSE},                   // 0x0250-0x0257
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},

    {IMSG_EMPTY, FALSE, FALSE},                   // 0x0258-0x025F
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},

    {IMSG_EMPTY, FALSE, FALSE},                   // 0x0260-0x0267
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},

    {IMSG_EMPTY, FALSE, FALSE},                   // 0x0268-0x026F
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},

    {IMSG_EMPTY, FALSE, FALSE},                   // 0x0270-0x0277
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},

    {IMSG_EMPTY, FALSE, FALSE},                   // 0x0278-0x027F
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},

    {IMSG_DWORD, FALSE, FALSE},                   // WM_IME_REPORT            0x0280
    {IMSG_DWORD, FALSE,  TRUE},                   // WM_IME_SETCONTEXT        0x0281
    {IMSG_DWORD, FALSE, FALSE},                   // WM_IME_NOTIFY            0x0282
    {IMSG_IMECONTROL,  TRUE,  TRUE},              // WM_IME_CONTROL           0x0283
    {IMSG_DWORD, FALSE, FALSE},                   // WM_IME_COMPOSITIONFULL   0x0284
    {IMSG_DWORD, FALSE, FALSE},                   // WM_IME_SELECT            0x0285
    {IMSG_INWPARAMCHAR,  TRUE, FALSE},            // WM_IME_CHAR              0x0286
    {IMSG_RESERVED, FALSE, FALSE},

    {IMSG_RESERVED, FALSE, FALSE},                // 0x0288
    {IMSG_RESERVED, FALSE, FALSE},
    {IMSG_RESERVED, FALSE, FALSE},
    {IMSG_RESERVED, FALSE, FALSE},
    {IMSG_RESERVED, FALSE, FALSE},
    {IMSG_RESERVED, FALSE, FALSE},
    {IMSG_RESERVED, FALSE, FALSE},
    {IMSG_RESERVED, FALSE, FALSE},

    {IMSG_RESERVED, FALSE, FALSE},                // 0x0290
    {IMSG_RESERVED, FALSE, FALSE},
    {IMSG_RESERVED, FALSE, FALSE},
    {IMSG_RESERVED, FALSE, FALSE},
    {IMSG_RESERVED, FALSE, FALSE},
    {IMSG_RESERVED, FALSE, FALSE},
    {IMSG_RESERVED, FALSE, FALSE},
    {IMSG_RESERVED, FALSE, FALSE},

    {IMSG_RESERVED, FALSE, FALSE},                // 0x0298
    {IMSG_RESERVED, FALSE, FALSE},
    {IMSG_RESERVED, FALSE, FALSE},
    {IMSG_RESERVED, FALSE, FALSE},
    {IMSG_RESERVED, FALSE, FALSE},
    {IMSG_RESERVED, FALSE, FALSE},
    {IMSG_RESERVED, FALSE, FALSE},
    {IMSG_RESERVED, FALSE, FALSE},                // WM_KANJILAST             0x029F

    {IMSG_DWORD, FALSE, FALSE},                   // WM_NCMOUSEHOVER          0x02Ao
    {IMSG_DWORD, FALSE, FALSE},                   // WM_MOUSEHOVER            0x02A1
    {IMSG_DWORD, FALSE, FALSE},                   // WM_NCMOUSELEAVE          0x02A2
    {IMSG_DWORD, FALSE, FALSE},                   // WM_MOUSELEAVE            0x02A3

    {IMSG_EMPTY, FALSE, FALSE},                   // 0x02A4-0x02A7
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},

    {IMSG_EMPTY, FALSE, FALSE},                   // 0x02A8-0x02AF
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},

    {IMSG_EMPTY, FALSE, FALSE},                   // 0x02B0-0x02B7
    {IMSG_DWORD, FALSE, FALSE},                   // WM_WTSSESSION_CHANGE
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},

    {IMSG_EMPTY, FALSE, FALSE},                   // 0x02B8-0x02BF
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},

    {IMSG_DWORD, FALSE, FALSE},                   // 0x02C0-0x02DF
    {IMSG_DWORD, FALSE, FALSE},                   // reserved for WM_TABLET_xxx
    {IMSG_DWORD, FALSE, FALSE},
    {IMSG_DWORD, FALSE, FALSE},
    {IMSG_DWORD, FALSE, FALSE},
    {IMSG_DWORD, FALSE, FALSE},
    {IMSG_DWORD, FALSE, FALSE},
    {IMSG_DWORD, FALSE, FALSE},

    {IMSG_DWORD, FALSE, FALSE},                   // 0x02C8-0x02CF
    {IMSG_DWORD, FALSE, FALSE},
    {IMSG_DWORD, FALSE, FALSE},
    {IMSG_DWORD, FALSE, FALSE},
    {IMSG_DWORD, FALSE, FALSE},
    {IMSG_DWORD, FALSE, FALSE},
    {IMSG_DWORD, FALSE, FALSE},
    {IMSG_DWORD, FALSE, FALSE},

    {IMSG_DWORD, FALSE, FALSE},                   // 0x02D0-0x02D7
    {IMSG_DWORD, FALSE, FALSE},
    {IMSG_DWORD, FALSE, FALSE},
    {IMSG_DWORD, FALSE, FALSE},
    {IMSG_DWORD, FALSE, FALSE},
    {IMSG_DWORD, FALSE, FALSE},
    {IMSG_DWORD, FALSE, FALSE},
    {IMSG_DWORD, FALSE, FALSE},

    {IMSG_DWORD, FALSE, FALSE},                   // 0x02D8-0x02DF
    {IMSG_DWORD, FALSE, FALSE},
    {IMSG_DWORD, FALSE, FALSE},
    {IMSG_DWORD, FALSE, FALSE},
    {IMSG_DWORD, FALSE, FALSE},
    {IMSG_DWORD, FALSE, FALSE},
    {IMSG_DWORD, FALSE, FALSE},
    {IMSG_DWORD, FALSE, FALSE},                   // 0x02DF

    {IMSG_EMPTY, FALSE, FALSE},                   // 0x02E0-0x02E7
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},

    {IMSG_EMPTY, FALSE, FALSE},                   // 0x02E8-0x02EF
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},

    {IMSG_EMPTY, FALSE, FALSE},                   // 0x02F0-0x02F7
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},

    {IMSG_EMPTY, FALSE, FALSE},                   // 0x02F8-0x02FF
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},

    {IMSG_DWORD, FALSE, FALSE},                   // WM_CUT                   0x0300
    {IMSG_DWORD, FALSE, FALSE},                   // WM_COPY                  0x0301
    {IMSG_DWORD, FALSE, FALSE},                   // WM_PASTE                 0x0302
    {IMSG_DWORD, FALSE, FALSE},                   // WM_CLEAR                 0x0303
    {IMSG_DWORD, FALSE, FALSE},                   // WM_UNDO                  0x0304
    {IMSG_DWORD, FALSE, FALSE},                   // WM_RENDERFORMAT          0x0305
    {IMSG_INDESTROYCLIPBRD,  TRUE, FALSE},        // WM_RENDERALLFORMATS      0x0306
    {IMSG_INDESTROYCLIPBRD,  TRUE, FALSE},        // WM_DESTROYCLIPBOARD      0x0307
    {IMSG_DWORD, FALSE, FALSE},                   // WM_DRAWCLIPBOARD         0x0308
    {IMSG_INPAINTCLIPBRD,  TRUE,  TRUE},          // WM_PAINTCLIPBOARD        0x0309
    {IMSG_DWORD, FALSE, FALSE},                   // WM_VSCROLLCLIPBOARD      0x030A
    {IMSG_INSIZECLIPBRD,  TRUE,  TRUE},           // WM_SIZECLIPBOARD         0x030B
    {IMSG_INCNTOUTSTRINGNULL,  TRUE,  TRUE},      // WM_ASKCBFORMATNAME       0x030C
    {IMSG_DWORD, FALSE, FALSE},                   // WM_CHANGECBCHAIN         0x030D
    {IMSG_DWORD, FALSE, FALSE},                   // WM_HSCROLLCLIPBOARD      0x030E
    {IMSG_DWORD, FALSE, FALSE},                   // WM_QUERYNEWPALETTE       0x030F

    {IMSG_DWORD, FALSE, FALSE},                   // WM_PALETTEISCHANGING     0x0310
    {IMSG_DWORD, FALSE, FALSE},                   // WM_PALETTECHANGED        0x0311
    {IMSG_DWORD, FALSE, FALSE},                   // WM_HOTKEY                0x0312

    {IMSG_EMPTY, FALSE, FALSE},                   // 0x0313-0x0316
    {IMSG_KERNELONLY, FALSE,  TRUE},              // WM_HOOKMSG               0x0314
    {IMSG_EMPTY, FALSE, FALSE},                   // WM_EXITPROCESS           0x0315
    {IMSG_EMPTY, FALSE, FALSE},                   // WM_WAKETHREAD            0x0316
    {IMSG_DWORD, FALSE, FALSE},                   // WM_PRINT                 0x0317

    {IMSG_DWORD, FALSE, FALSE},                   // WM_PRINTCLIENT           0x0318
    {IMSG_DWORD, FALSE, FALSE},                   // WM_APPCOMMAND            0x0319
    {IMSG_DWORD, FALSE, FALSE},                   // WM_THEMECHANGED          0x031A
    {IMSG_DWORD, FALSE, FALSE},                   // WM_UAHINIT               0x031B
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},

    {IMSG_EMPTY, FALSE, FALSE},                   // 0x0320-0x0327
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},

    {IMSG_EMPTY, FALSE, FALSE},                   // 0x0328-0x032F
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},

    {IMSG_EMPTY, FALSE, FALSE},                   // 0x0330-0x0337
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},

    {IMSG_EMPTY, FALSE, FALSE},                   // 0x0338-0x033F
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},

    {IMSG_EMPTY, FALSE, FALSE},                   // 0x0340-0x0347
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},

    {IMSG_EMPTY, FALSE, FALSE},                   // 0x0348-0x034F
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},

    {IMSG_EMPTY, FALSE, FALSE},                   // 0x0350-0x0357
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},

    {IMSG_EMPTY, FALSE, FALSE},                   // reserved pen windows      0x0358-0x035F
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},

    {IMSG_EMPTY, FALSE, FALSE},                   // 0x0360-0x0367
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},

    {IMSG_EMPTY, FALSE, FALSE},                   // 0x0368-0x036F
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},

    {IMSG_EMPTY, FALSE, FALSE},                   // 0x0370-0x0377
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},

    {IMSG_EMPTY, FALSE, FALSE},                   // 0x0378-0x037F
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},

    {IMSG_EMPTY, FALSE, FALSE},                   // 0x0380-0x0387
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},

    {IMSG_EMPTY, FALSE, FALSE},                   // 0x0388-0x038F
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},

    {IMSG_EMPTY, FALSE, FALSE},                   // 0x0390-0x0397
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},

    {IMSG_EMPTY, FALSE, FALSE},                   // 0x0398-0x039F
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},

    {IMSG_RESERVED, FALSE, FALSE},                // WM_MM_RESERVED_FIRST      0x03A0
    {IMSG_RESERVED, FALSE, FALSE},
    {IMSG_RESERVED, FALSE, FALSE},
    {IMSG_RESERVED, FALSE, FALSE},
    {IMSG_RESERVED, FALSE, FALSE},
    {IMSG_RESERVED, FALSE, FALSE},
    {IMSG_RESERVED, FALSE, FALSE},
    {IMSG_RESERVED, FALSE, FALSE},

    {IMSG_RESERVED, FALSE, FALSE},                // 0x03A8
    {IMSG_RESERVED, FALSE, FALSE},
    {IMSG_RESERVED, FALSE, FALSE},
    {IMSG_RESERVED, FALSE, FALSE},
    {IMSG_RESERVED, FALSE, FALSE},
    {IMSG_RESERVED, FALSE, FALSE},
    {IMSG_RESERVED, FALSE, FALSE},
    {IMSG_RESERVED, FALSE, FALSE},

    {IMSG_RESERVED, FALSE, FALSE},                // 0x03B0
    {IMSG_RESERVED, FALSE, FALSE},
    {IMSG_RESERVED, FALSE, FALSE},
    {IMSG_RESERVED, FALSE, FALSE},
    {IMSG_RESERVED, FALSE, FALSE},
    {IMSG_RESERVED, FALSE, FALSE},
    {IMSG_RESERVED, FALSE, FALSE},
    {IMSG_RESERVED, FALSE, FALSE},

    {IMSG_RESERVED, FALSE, FALSE},                // 0x03B7
    {IMSG_RESERVED, FALSE, FALSE},
    {IMSG_RESERVED, FALSE, FALSE},
    {IMSG_RESERVED, FALSE, FALSE},
    {IMSG_RESERVED, FALSE, FALSE},
    {IMSG_RESERVED, FALSE, FALSE},
    {IMSG_RESERVED, FALSE, FALSE},
    {IMSG_RESERVED, FALSE, FALSE},

    {IMSG_RESERVED, FALSE, FALSE},                // 0x03C0
    {IMSG_RESERVED, FALSE, FALSE},
    {IMSG_RESERVED, FALSE, FALSE},
    {IMSG_RESERVED, FALSE, FALSE},
    {IMSG_RESERVED, FALSE, FALSE},
    {IMSG_RESERVED, FALSE, FALSE},
    {IMSG_RESERVED, FALSE, FALSE},
    {IMSG_RESERVED, FALSE, FALSE},

    {IMSG_RESERVED, FALSE, FALSE},                // 0x03C7
    {IMSG_RESERVED, FALSE, FALSE},
    {IMSG_RESERVED, FALSE, FALSE},
    {IMSG_RESERVED, FALSE, FALSE},
    {IMSG_RESERVED, FALSE, FALSE},
    {IMSG_RESERVED, FALSE, FALSE},
    {IMSG_RESERVED, FALSE, FALSE},
    {IMSG_RESERVED, FALSE, FALSE},

    {IMSG_RESERVED, FALSE, FALSE},                // 0x03D0
    {IMSG_RESERVED, FALSE, FALSE},
    {IMSG_RESERVED, FALSE, FALSE},
    {IMSG_RESERVED, FALSE, FALSE},
    {IMSG_RESERVED, FALSE, FALSE},
    {IMSG_RESERVED, FALSE, FALSE},
    {IMSG_RESERVED, FALSE, FALSE},
    {IMSG_RESERVED, FALSE, FALSE},

    {IMSG_RESERVED, FALSE, FALSE},                // 0x03D7
    {IMSG_RESERVED, FALSE, FALSE},
    {IMSG_RESERVED, FALSE, FALSE},
    {IMSG_RESERVED, FALSE, FALSE},
    {IMSG_RESERVED, FALSE, FALSE},
    {IMSG_RESERVED, FALSE, FALSE},
    {IMSG_RESERVED, FALSE, FALSE},
    {IMSG_RESERVED, FALSE, FALSE},                // WM_MM_RESERVED_LAST      0x03DF

    {IMSG_DDEINIT,  TRUE, FALSE},                 // WM_DDE_INITIATE          0x03E0
    {IMSG_DWORD,  TRUE, FALSE},                   // WM_DDE_TERMINATE         0x03E1
    {IMSG_SENTDDEMSG,  TRUE, FALSE},              // WM_DDE_ADVISE            0x03E2
    {IMSG_SENTDDEMSG,  TRUE, FALSE},              // WM_DDE_UNADVISE          0x03E3
    {IMSG_DWORD,  TRUE, FALSE},                   // WM_DDE_ACK               0x03E4
    {IMSG_SENTDDEMSG,  TRUE, FALSE},              // WM_DDE_DATA              0x03E5
    {IMSG_SENTDDEMSG,  TRUE, FALSE},              // WM_DDE_REQUEST           0x03E6
    {IMSG_SENTDDEMSG,  TRUE, FALSE},              // WM_DDE_POKE              0x03E7
    {IMSG_SENTDDEMSG,  TRUE, FALSE},              // WM_DDE_EXECUTE           0x03E8

    {IMSG_EMPTY, FALSE, FALSE},                   // 0x03E9-0x03EF
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},

    {IMSG_RESERVED, FALSE, FALSE},                // WM_CBT_RESERVED_FIRST     0x03F0
    {IMSG_RESERVED, FALSE, FALSE},
    {IMSG_RESERVED, FALSE, FALSE},
    {IMSG_RESERVED, FALSE, FALSE},
    {IMSG_RESERVED, FALSE, FALSE},
    {IMSG_RESERVED, FALSE, FALSE},
    {IMSG_RESERVED, FALSE, FALSE},
    {IMSG_RESERVED, FALSE, FALSE},

    {IMSG_RESERVED, FALSE, FALSE},                // 0x03F8
    {IMSG_RESERVED, FALSE, FALSE},
    {IMSG_RESERVED, FALSE, FALSE},
    {IMSG_RESERVED, FALSE, FALSE},
    {IMSG_RESERVED, FALSE, FALSE},
    {IMSG_RESERVED, FALSE, FALSE},
    {IMSG_RESERVED, FALSE, FALSE},
    {IMSG_RESERVED, FALSE, FALSE},                // WM_CBT_RESERVED_LAST      0x03FF
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\inc\ntsend.h ===
/**************************************************************************\
* Module Name: ntsend.h
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* client-side macros for kernel-mode
*
* 03-21-95 JimA             Created.
\**************************************************************************/

/*
 * The BEGINCALLCONNECT macro ensures that the thread is set up correctly.
 */
#define BEGINCALLCONNECT()                              \
    {                                                   \
    ULONG_PTR retval;                                    \
    {                                                   \
        if (NtCurrentTeb()->Win32ThreadInfo == NULL) {  \
            if (!USERTHREADCONNECT()) { \
                MSGERROR();                             \
            }                                           \
        }

/*
 * Use this macro if you don't need to access shared memory.
 */
#define BEGINCALL()       \
    {                     \
    ULONG_PTR retval;      \
    {

#define BEGINCALL_CLASSV()                                                              \
    {                                                                                   \
    ULONG_PTR retval;                                                                   \
    TCHAR ClassNameVer[MAX_ATOM_LEN];                                                   \
    LPTSTR lpClassNameVer;                                                              \
    BOOL   bRegistered = FALSE;                                                         \
    PACTIVATION_CONTEXT lpActivationContext = NULL;                                     \
    LPWSTR lpDllName = NULL;                                                            \
    {                                                                                   \
        lpClassNameVer = (LPTSTR)ClassNameToVersion((LPCWSTR)pszClassName,              \
                                     (LPWSTR)ClassNameVer, &lpDllName, &lpActivationContext, IS_ANSI); \
        if (lpClassNameVer == NULL) {                                                   \
            RIPMSG0(RIP_WARNING, "Couldn't resolve class name");                        \
            MSGERROR();                                                                 \
        }

#define BEGINCALLVOID()   \
    {

#define ERRORTRAP(error) \
       goto cleanup;        \
    }                       \
    goto errorexit;         \
errorexit:                  \
    retval = (ULONG_PTR)error; \
cleanup:

#define ERRORTRAPVOID()     \
    goto errorexit;         \
errorexit:

#define ENDCALL(type)     \
    return (type)retval;  \
    }

#define ENDCALLVOID() \
    return;           \
    }

#define MSGERROR() goto errorexit

#define MSGERRORCODE(code) { \
    RIPERR0(code, RIP_WARNING, "Unspecified error"); \
    goto errorexit; }

#define MSGNTERRORCODE(code) { \
    RIPNTERR0(code, RIP_WARNING, "Unspecified error"); \
    goto errorexit; }

#define MESSAGECALL(api) \
LRESULT api(             \
    HWND hwnd,           \
    UINT msg,            \
    WPARAM wParam,       \
    LPARAM lParam,       \
    ULONG_PTR xParam,     \
    DWORD xpfnProc,      \
    BOOL bAnsi)

/*
 * Copy optional string/Ordinal where if hiword is FF/FFFF then new WORD is a
 * resource oridinal ID
 * Sources is Unicode
 */
#define OrdinalLPSTR(src)   (MAKELONG(0xFFFF,((*(DWORD UNALIGNED *)src) >> 8)))
#define OrdinalLPSTRW(src)  (MAKELONG(0xFFFF,((*(DWORD UNALIGNED *)src) >> 8)))
#define OrdinalLPWSTR(src)  (*(DWORD UNALIGNED *)src)
#define OrdinalLPWSTRA(src) (*(DWORD UNALIGNED *)((PBYTE)src + 1))

/*
 * Ansi->Unicode macros
 */
#define COPYLPSTRW(pinstr, psz) \
    if (!RtlCaptureAnsiString((pinstr), (LPCSTR)(psz), TRUE))     \
        MSGERROR();

#define COPYLPSTRIDW(pinstr, psz) \
    if (IS_PTR(psz)) {                                      \
        if (!RtlCaptureAnsiString((pinstr), (LPCSTR)(psz), TRUE))   \
            MSGERROR();                                     \
    }                                                       \
    else {                                                  \
        (pinstr)->fAllocated = FALSE;                       \
        (pinstr)->pstr = &(pinstr)->strCapture;             \
        (pinstr)->strCapture.Length =                       \
                (pinstr)->strCapture.MaximumLength = 0;     \
        (pinstr)->strCapture.Buffer = (LPWSTR)(psz);        \
    }

#define COPYLPSTRIDOPTW     COPYLPSTRIDW
#define COPYLPSTROPTW       COPYLPSTRW

#define LARGECOPYLPSTRW(pinstr, psz) \
    if(!RtlCaptureLargeAnsiString((pinstr), (LPCSTR)(psz), TRUE)) \
        MSGERROR();

#define LARGECOPYLPSTROPTW  LARGECOPYLPSTRW

#define LARGECOPYLPSTRORDINALOPTW(pinstr, psz) \
    (pinstr)->pstr = &(pinstr)->strCapture;                                         \
    (pinstr)->fAllocated = FALSE;                                                   \
    if (psz) {                                                                      \
        if (*(LPBYTE)(psz) != 0xff) {                                               \
            if (!RtlCaptureLargeAnsiString((pinstr), (LPCSTR)(psz), TRUE))          \
                MSGERROR();                                                         \
        } else {                                                                    \
            (pinstr)->strCapture.Length =                                           \
                    (pinstr)->strCapture.MaximumLength = sizeof(DWORD);             \
            dwOrdinal = OrdinalLPSTRW(psz);                                         \
            (pinstr)->strCapture.Buffer = (LPWSTR)&dwOrdinal;                       \
        }                                                                           \
    } else {                                                                        \
        (pinstr)->strCapture.Length =                                               \
                (pinstr)->strCapture.MaximumLength = 0;                             \
        (pinstr)->strCapture.Buffer = NULL;                                         \
    }

#define FIRSTCOPYLPSTRW(pinstr, psz) \
    if (!RtlCaptureAnsiString((pinstr), (LPCSTR)(psz), FALSE))    \
        MSGERROR();

#define FIRSTCOPYLPSTRIDW(pinstr, psz) \
    if (IS_PTR(psz)) {                                      \
        if (!RtlCaptureAnsiString((pinstr), (LPCSTR)(psz), FALSE))  \
            MSGERROR();                                     \
    } else {                                                \
        (pinstr)->fAllocated = FALSE;                       \
        (pinstr)->pstr = &(pinstr)->strCapture;             \
        (pinstr)->strCapture.Length =                       \
                (pinstr)->strCapture.MaximumLength = 0;     \
        (pinstr)->strCapture.Buffer = (LPWSTR)(psz);        \
    }

#define FIRSTCOPYLPSTRIDOPTW     FIRSTCOPYLPSTRIDW
#define FIRSTCOPYLPSTROPTW       FIRSTCOPYLPSTRW

#define FIRSTLARGECOPYLPSTRW(pinstr, psz) \
    if (!RtlCaptureLargeAnsiString((pinstr), (LPCSTR)(psz), FALSE))   \
        MSGERROR();

#define FIRSTLARGECOPYLPSTROPTW  FIRSTLARGECOPYLPSTRW

#define FIRSTLARGECOPYLPSTRORDINALOPTW(pinstr, psz) \
    (pinstr)->pstr = &(pinstr)->strCapture;                                             \
    (pinstr)->fAllocated = FALSE;                                                       \
    if (psz) {                                                                          \
        if (*(LPBYTE)(psz) != 0xff) {                                                   \
            if (!RtlCaptureLargeAnsiString((pinstr), (LPCSTR)(psz), FALSE))             \
                MSGERROR();                                                             \
        } else {                                                                        \
            (pinstr)->strCapture.Length =                                               \
                    (pinstr)->strCapture.MaximumLength = sizeof(DWORD);                 \
            dwOrdinal = OrdinalLPSTRW(psz);                                             \
            (pinstr)->strCapture.Buffer = (LPWSTR)&dwOrdinal;                           \
        }                                                                               \
    } else {                                                                            \
        (pinstr)->strCapture.Length =                                                   \
                (pinstr)->strCapture.MaximumLength = 0;                                 \
        (pinstr)->strCapture.Buffer = NULL;                                             \
    }

#define CLEANUPLPSTRW(instr) \
    if (instr.fAllocated)                     \
        UserLocalFree(KPVOID_TO_PVOID(instr.strCapture.Buffer));

/*
 * Unicode->Unicode macros
 */
#define COPYLPWSTR(pinstr, psz) \
    (pinstr)->fAllocated = FALSE;                           \
    (pinstr)->pstr = &(pinstr)->strCapture;                 \
    RtlInitUnicodeString(&(pinstr)->strCapture, (psz));

#define COPYLPWSTRID(pinstr, psz) \
    (pinstr)->fAllocated = FALSE;                           \
    (pinstr)->pstr = &(pinstr)->strCapture;                 \
    if (IS_PTR(psz))                                        \
        RtlInitUnicodeString(&(pinstr)->strCapture, (psz)); \
    else {                                                  \
        (pinstr)->strCapture.Length =                       \
                (pinstr)->strCapture.MaximumLength = 0;     \
        (pinstr)->strCapture.Buffer = (LPWSTR)(psz);        \
    }

#define COPYLPWSTRIDOPT     COPYLPWSTRID
#define COPYLPWSTROPT       COPYLPWSTR

#define LARGECOPYLPWSTR(pinstr, psz) \
    (pinstr)->fAllocated = FALSE;                           \
    (pinstr)->pstr = &(pinstr)->strCapture;                         \
    RtlInitLargeUnicodeString(&(pinstr)->strCapture, (psz), (UINT)-1);

#define LARGECOPYLPWSTROPT  LARGECOPYLPWSTR

#define LARGECOPYLPWSTRORDINALOPT(pinstr, psz) \
    (pinstr)->fAllocated = FALSE;                           \
    (pinstr)->pstr = &(pinstr)->strCapture;                                     \
    if (psz) {                                                                  \
        if (*(LPWORD)(psz) != 0xffff)                                           \
            RtlInitLargeUnicodeString(&(pinstr)->strCapture, (psz), (UINT)-1);  \
        else {                                                                  \
            (pinstr)->strCapture.Length =                                       \
                    (pinstr)->strCapture.MaximumLength = sizeof(DWORD);         \
            dwOrdinal = OrdinalLPWSTR(psz);                                     \
            (pinstr)->strCapture.Buffer = (LPWSTR)&dwOrdinal;                   \
        }                                                                       \
    } else {                                                                    \
        (pinstr)->strCapture.Length =                                           \
                (pinstr)->strCapture.MaximumLength = 0;                         \
        (pinstr)->strCapture.Buffer = NULL;                                     \
    }

#define FIRSTCOPYLPWSTR                 COPYLPWSTR
#define FIRSTCOPYLPWSTRID               COPYLPWSTRID
#define FIRSTCOPYLPWSTRIDOPT            COPYLPWSTRIDOPT
#define FIRSTCOPYLPWSTROPT              COPYLPWSTROPT
#define FIRSTLARGECOPYLPWSTR            LARGECOPYLPWSTR
#define FIRSTLARGECOPYLPWSTROPT         LARGECOPYLPWSTROPT
#define FIRSTLARGECOPYLPWSTRORDINALOPT  LARGECOPYLPWSTRORDINALOPT

#define CLEANUPLPWSTR(instr)

/*
 * Type-neutral macros
 */
#ifdef UNICODE

#define COPYLPTSTR                  COPYLPWSTR
#define COPYLPTSTRID                COPYLPWSTRID
#define COPYLPTSTRIDOPT             COPYLPWSTRIDOPT
#define COPYLPTSTROPT               COPYLPWSTROPT
#define FIRSTCOPYLPTSTR             COPYLPWSTR
#define FIRSTCOPYLPTSTRID           COPYLPWSTRID
#define FIRSTCOPYLPTSTRIDOPT        COPYLPWSTRIDOPT
#define LARGECOPYLPTSTR             LARGECOPYLPWSTR
#define LARGECOPYLPTSTROPT          LARGECOPYLPWSTROPT
#define FIRSTLARGECOPYLPTSTROPT     LARGECOPYLPWSTROPT
#define CLEANUPLPTSTR               CLEANUPLPWSTR

#else

#define COPYLPTSTR                  COPYLPSTRW
#define COPYLPTSTRID                COPYLPSTRIDW
#define COPYLPTSTRIDOPT             COPYLPSTRIDOPTW
#define COPYLPTSTROPT               COPYLPSTROPTW
#define FIRSTCOPYLPTSTR             COPYLPSTRW
#define FIRSTCOPYLPTSTRID           COPYLPSTRIDW
#define FIRSTCOPYLPTSTRIDOPT        COPYLPSTRIDOPTW
#define LARGECOPYLPTSTR             LARGECOPYLPSTRW
#define LARGECOPYLPTSTROPT          LARGECOPYLPSTROPTW
#define FIRSTLARGECOPYLPTSTROPT     LARGECOPYLPSTROPTW
#define CLEANUPLPTSTR               CLEANUPLPSTRW

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\inc\daytona\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\inc\sources.inc ===
#****************************** File Header ******************************\
# File Name: Sources.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# This file is used to build generated header files (specifed in NTTARGETFILE0).
#  Building rules are specified in MAKEFILE.INC.
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/
!include $(WINCORE_PATH)\core.inc

PASS0ONLY=1
NOPASS0=1

TARGETTYPE=NOTARGET
SOURCES=
TARGETPATH=

NTTARGETFILE0=$(O)\cscall.h $(O)\scf.lst $(O)\callback.h $(O)\cb.lst $(O)\msgdef.h $(O)\msgdef.lst

SYNCHRONIZE_BLOCK=1

SOURCES_USED=..\sources.inc $(WINCORE_PATH)\core.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\inc\wow6432\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\inc\ntuser.h ===
/****************************** Module Header ******************************\
* Module Name: ntuser.h
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* This header file contains all kernel mode entry points
*
* History:
* 03-22-95 JimA         Created.
\***************************************************************************/

#ifndef _NTUSER_
#define _NTUSER_

#include "w32wow64.h"

#ifndef W32KAPI
#define W32KAPI  DECLSPEC_ADDRSAFE
#endif

#include "usercall.h"

#ifdef GENERIC_INPUT

W32KAPI
UINT
NtUserGetRawInputData(
    IN HRAWINPUT hRawInput,
    IN UINT uiCommand,
    OUT LPVOID pData OPTIONAL,
    IN OUT PUINT pcbSize,
    IN UINT cbSizeHeader);

W32KAPI
UINT
NtUserGetRawInputDeviceInfo(
    IN HANDLE hDevice,
    IN UINT uiCommand,
    OUT LPVOID pData OPTIONAL,
    IN OUT PUINT pcbSize);

W32KAPI
UINT
NtUserGetRawInputBuffer(
    OUT PRAWINPUT pData OPTIONAL,
    IN PUINT pcbSize,
#ifdef LATER
    IN DWORD dwFlags,
#endif
    IN UINT cbSizeHeader);

W32KAPI
UINT
NtUserGetRegisteredRawInputDevices(
    PRAWINPUTDEVICE pRawInputDevices,
    PUINT puiNumDevices,
    UINT cbSize);

W32KAPI
BOOL
NtUserRegisterRawInputDevices(
    PRAWINPUTDEVICE pRawInputDevices,
    UINT uiNumDevices,
    UINT cbSize);

W32KAPI
UINT NtUserGetRawInputDeviceList(
    PRAWINPUTDEVICELIST pRawInputDeviceList,
    PUINT puiNumDevices,
    UINT cbSize);

#endif // GENERIC_INPUT

W32KAPI
UINT
NtUserHardErrorControl(
    IN HARDERRORCONTROL dwCmd,
    IN HANDLE handle OPTIONAL,
    OUT PDESKRESTOREDATA pdrdRestore OPTIONAL);

W32KAPI
BOOL
NtUserGetObjectInformation(
    IN HANDLE hObject,
    IN int nIndex,
    OUT PVOID pvInfo,
    IN DWORD nLength,
    OUT LPDWORD pnLengthNeeded);

W32KAPI
BOOL
NtUserSetObjectInformation(
    IN HANDLE hObject,
    IN int nIndex,
    IN LPCVOID pvInfo,
    IN DWORD nLength);

W32KAPI
BOOL
NtUserWin32PoolAllocationStats(
    IN  LPDWORD parrTags,
    IN  SIZE_T  tagsCount,
    OUT SIZE_T* lpdwMaxMem,
    OUT SIZE_T* lpdwCrtMem,
    OUT LPDWORD lpdwMaxAlloc,
    OUT LPDWORD lpdwCrtAlloc);

#if DBG

W32KAPI
VOID
NtUserDbgWin32HeapFail(
    IN DWORD dwFlags,
    IN BOOL  bFail);

W32KAPI
DWORD
NtUserDbgWin32HeapStat(
    PDBGHEAPSTAT phs,
    DWORD   dwLen);

#endif // DBG

W32KAPI
NTSTATUS
NtUserConsoleControl(
    IN CONSOLECONTROL ConsoleCommand,
    IN PVOID ConsoleInformation,
    IN DWORD ConsoleInformationLength);

W32KAPI
HWINSTA
NtUserCreateWindowStation(
    IN POBJECT_ATTRIBUTES   pObja,
    IN ACCESS_MASK          amRequest,
    IN HANDLE               hKbdLayoutFile,
    IN DWORD                offTable,
    PKBDTABLE_MULTI_INTERNAL pKbdTableMulti,
    IN PUNICODE_STRING      pstrKLID,
    IN UINT                 uKbdInputLocale);

W32KAPI
HWINSTA
NtUserOpenWindowStation(
    IN POBJECT_ATTRIBUTES pObja,
    IN ACCESS_MASK amRequest);

W32KAPI
BOOL
NtUserCloseWindowStation(
    IN HWINSTA hwinsta);

W32KAPI
BOOL
NtUserSetProcessWindowStation(
    IN HWINSTA hwinsta);

W32KAPI
HWINSTA
NtUserGetProcessWindowStation(
    VOID);

W32KAPI
BOOL
NtUserLockWorkStation(
    VOID);

W32KAPI
HDESK
NtUserCreateDesktop(
    IN POBJECT_ATTRIBUTES pObja,
    IN PUNICODE_STRING pstrDevice,
    IN LPDEVMODEW pDevmode,
    IN DWORD dwFlags,
    IN ACCESS_MASK amRequest);

W32KAPI
HDESK
NtUserOpenDesktop(
    IN POBJECT_ATTRIBUTES pObja,
    IN DWORD dwFlags,
    IN ACCESS_MASK amRequest);

W32KAPI
HDESK
NtUserOpenInputDesktop(
    IN DWORD dwFlags,
    IN BOOL fInherit,
    IN DWORD amRequest);

W32KAPI
NTSTATUS
NtUserResolveDesktopForWOW (
    IN OUT PUNICODE_STRING pstrDesktop);

W32KAPI
HDESK
NtUserResolveDesktop(
    IN HANDLE hProcess,
    IN PUNICODE_STRING pstrDesktop,
    IN BOOL fInherit,
    OUT HWINSTA *phwinsta);

W32KAPI
BOOL
NtUserCloseDesktop(
    IN HDESK hdesk);

W32KAPI
BOOL
NtUserSetThreadDesktop(
    IN HDESK hdesk);

W32KAPI
HDESK
NtUserGetThreadDesktop(
    IN DWORD dwThreadId,
    IN HDESK hdeskConsole);

W32KAPI
BOOL
NtUserSwitchDesktop(
    IN HDESK hdesk);

W32KAPI
NTSTATUS
NtUserInitializeClientPfnArrays(
    IN CONST PFNCLIENT *ppfnClientA OPTIONAL,
    IN CONST PFNCLIENT *ppfnClientW OPTIONAL,
    IN CONST PFNCLIENTWORKER *ppfnClientWorker OPTIONAL,
    IN HANDLE hModUser);

W32KAPI
BOOL
NtUserWaitForMsgAndEvent(
    IN HANDLE hevent);

W32KAPI
DWORD
NtUserDragObject(
    IN HWND hwndParent,
    IN HWND hwndFrom,
    IN UINT wFmt,
    IN ULONG_PTR dwData,
    IN HCURSOR hcur);

W32KAPI
BOOL
NtUserGetIconInfo(
    IN  HICON hicon,
    OUT PICONINFO piconinfo,
    IN  OUT OPTIONAL PUNICODE_STRING pstrInstanceName,
    IN  OUT OPTIONAL PUNICODE_STRING pstrResName,
    OUT OPTIONAL LPDWORD pbpp,
    IN  BOOL fInternal);

W32KAPI
BOOL
NtUserGetIconSize(
    IN HICON hIcon,
    IN UINT istepIfAniCur,
    OUT int *pcx,
    OUT int *pcy);

W32KAPI
BOOL
NtUserDrawIconEx(
    IN HDC hdc,
    IN int x,
    IN int y,
    IN HICON hicon,
    IN int cx,
    IN int cy,
    IN UINT istepIfAniCur,
    IN HBRUSH hbrush,
    IN UINT diFlags,
    IN BOOL fMeta,
    OUT DRAWICONEXDATA *pdid);

W32KAPI
HANDLE
NtUserDeferWindowPos(
    IN HDWP hWinPosInfo,
    IN HWND hwnd,
    IN HWND hwndInsertAfter,
    IN int x,
    IN int y,
    IN int cx,
    IN int cy,
    IN UINT wFlags);

W32KAPI
BOOL
NtUserEndDeferWindowPosEx(
    IN HDWP hWinPosInfo,
    IN BOOL fAsync);

W32KAPI
BOOL
NtUserGetMessage(
    OUT LPMSG pmsg,
    IN HWND hwnd,
    IN UINT wMsgFilterMin,
    IN UINT wMsgFilterMax);

#ifdef MESSAGE_PUMP_HOOK

W32KAPI
BOOL
NtUserRealInternalGetMessage(
    OUT LPMSG pmsg,
    IN HWND hwnd,
    IN UINT wMsgFilterMin,
    IN UINT wMsgFilterMax,
    IN UINT flags,
    BOOL fGetMessage);

#endif

W32KAPI
BOOL
NtUserMoveWindow(
    IN HWND hwnd,
    IN int x,
    IN int y,
    IN int cx,
    IN int cy,
    IN BOOL fRepaint);

W32KAPI
int
NtUserTranslateAccelerator(
    IN HWND hwnd,
    IN HACCEL hAccTable,
    IN LPMSG lpMsg);

W32KAPI
LONG
NtUserSetClassLong(
    IN HWND hwnd,
    IN int nIndex,
    IN LONG dwNewLong,
    IN BOOL bAnsi);

#ifdef _WIN64
W32KAPI
LONG_PTR
NtUserSetClassLongPtr(
    IN HWND hwnd,
    IN int nIndex,
    IN LONG_PTR dwNewLong,
    IN BOOL bAnsi);
#else
#define NtUserSetClassLongPtr   NtUserSetClassLong
#endif

W32KAPI
BOOL
NtUserSetKeyboardState(
    IN CONST BYTE *lpKeyState);

W32KAPI
BOOL
NtUserSetWindowPos(
    IN HWND hwnd,
    IN HWND hwndInsertAfter,
    IN int x,
    IN int y,
    IN int cx,
    IN int cy,
    IN UINT dwFlags);

W32KAPI
BOOL
NtUserSetShellWindowEx(
    IN HWND hwnd,
    IN HWND hwndBkGnd);

W32KAPI
BOOL
NtUserSystemParametersInfo(
    IN UINT wFlag,
    IN DWORD wParam,
    IN OUT LPVOID lpData,
    IN UINT flags);

W32KAPI
BOOL
NtUserUpdatePerUserSystemParameters(
    IN HANDLE hToken,
    IN DWORD  dwFlags);

W32KAPI
DWORD
NtUserDdeInitialize(
    OUT PHANDLE phInst,
    OUT HWND *phwnd,
    OUT LPDWORD pMonFlags,
    IN DWORD afCmd,
    IN PVOID pcii);

W32KAPI
DWORD
NtUserUpdateInstance(
    IN HANDLE hInst,
    OUT LPDWORD pMonFlags,
    IN DWORD afCmd);

W32KAPI
DWORD
NtUserEvent(
    IN PEVENT_PACKET pep);

W32KAPI
BOOL
NtUserFillWindow(
    IN HWND hwndBrush,
    IN HWND hwndPaint,
    IN HDC hdc,
    IN HBRUSH hbr);

W32KAPI
PCLS
NtUserGetWOWClass(
    IN HINSTANCE hInstance,
    IN PUNICODE_STRING pString);

W32KAPI
UINT
NtUserGetInternalWindowPos(
    IN HWND hwnd,
    OUT LPRECT lpRect OPTIONAL,
    OUT LPPOINT lpPoint OPTIONAL);

W32KAPI
NTSTATUS
NtUserInitTask(
    IN UINT dwExpWinVer,
    IN DWORD dwAppCompatFlags,
    IN DWORD dwUserWOWCompatFlags,
    IN PUNICODE_STRING pstrModName,
    IN PUNICODE_STRING pstrBaseFileName,
    IN DWORD hTaskWow,
    IN DWORD dwHotkey,
    IN DWORD idTask,
    IN DWORD dwX,
    IN DWORD dwY,
    IN DWORD dwXSize,
    IN DWORD dwYSize);

W32KAPI
BOOL
NtUserPostThreadMessage(
    IN DWORD id,
    IN UINT msg,
    IN WPARAM wParam,
    IN LPARAM lParam);

W32KAPI
BOOL
NtUserRegisterTasklist(
    IN HWND hwndTasklist);

W32KAPI
BOOL
NtUserSetClipboardData(
    IN UINT wFmt,
    IN HANDLE hMem,
    IN PSETCLIPBDATA scd);

W32KAPI
BOOL
NtUserCloseClipboard(
    VOID);

W32KAPI
BOOL
NtUserEmptyClipboard(
    VOID);

W32KAPI
HANDLE
NtUserConvertMemHandle(
    IN LPBYTE lpData,
    IN UINT cbNULL);

W32KAPI
NTSTATUS
NtUserCreateLocalMemHandle(
    IN HANDLE hMem,
    OUT LPBYTE lpData OPTIONAL,
    IN UINT cbData,
    OUT PUINT lpcbNeeded OPTIONAL);

W32KAPI
HHOOK
NtUserSetWindowsHookEx(
    IN HANDLE hmod,
    IN PUNICODE_STRING pstrLib OPTIONAL,
    IN DWORD idThread,
    IN int nFilterType,
    IN PROC pfnFilterProc,
    IN DWORD dwFlags);

W32KAPI
BOOL
NtUserSetInternalWindowPos(
    IN HWND hwnd,
    IN UINT cmdShow,
    IN CONST RECT *lpRect,
    IN CONST POINT *lpPoint);

W32KAPI
BOOL
NtUserChangeClipboardChain(
    IN HWND hwndRemove,
    IN HWND hwndNewNext);

W32KAPI
DWORD
NtUserCheckMenuItem(
    IN HMENU hmenu,
    IN UINT wIDCheckItem,
    IN UINT wCheck);

W32KAPI
HWND
NtUserChildWindowFromPointEx(
    IN HWND hwndParent,
    IN POINT point,
    IN UINT flags);

W32KAPI
BOOL
NtUserClipCursor(
    IN CONST RECT *lpRect OPTIONAL);

W32KAPI
HACCEL
NtUserCreateAcceleratorTable(
    IN LPACCEL lpAccel,
    IN INT cAccel);

W32KAPI
BOOL
NtUserDeleteMenu(
    IN HMENU hmenu,
    IN UINT nPosition,
    IN UINT dwFlags);

W32KAPI
BOOL
NtUserDestroyAcceleratorTable(
    IN HACCEL hAccel);

W32KAPI
BOOL
NtUserDestroyCursor(
    IN HCURSOR hcurs,
    IN DWORD cmd);

W32KAPI
HANDLE
NtUserGetClipboardData(
    IN UINT fmt,
    OUT PGETCLIPBDATA pgcd);

W32KAPI
BOOL
NtUserDestroyMenu(
    IN HMENU hmenu);

W32KAPI
UINT
NtUserPaintMenuBar(
    IN HWND hwnd,
    IN HDC hdc,
    IN int iLeftOffset,
    IN int iRightOffset,
    IN int iTopOffset,
    IN DWORD dwFlags);

W32KAPI
UINT
NtUserCalcMenuBar(
    IN HWND hwnd,
    IN int iLeftOffset,
    IN int iRightOffset,
    IN int iTopOffset,
    IN LPCRECT prcWnd);

W32KAPI
BOOL
NtUserDestroyWindow(
    IN HWND hwnd);

W32KAPI
LRESULT
NtUserDispatchMessage(
    IN CONST MSG *pmsg);

W32KAPI
BOOL
NtUserEnableMenuItem(
    IN HMENU hMenu,
    IN UINT wIDEnableItem,
    IN UINT wEnable);

W32KAPI
BOOL
NtUserAttachThreadInput(
    IN DWORD idAttach,
    IN DWORD idAttachTo,
    IN BOOL fAttach);

W32KAPI
BOOL
NtUserGetWindowPlacement(
    IN HWND hwnd,
    OUT PWINDOWPLACEMENT pwp);

W32KAPI
BOOL
NtUserSetWindowPlacement(
    IN HWND hwnd,
    IN CONST WINDOWPLACEMENT *lpwndpl);

W32KAPI
BOOL
NtUserLockWindowUpdate(
    IN HWND hwnd);

W32KAPI
BOOL
NtUserGetClipCursor(
    OUT LPRECT lpRect);

W32KAPI
BOOL
NtUserEnableScrollBar(
    IN HWND hwnd,
    IN UINT wSBflags,
    IN UINT wArrows);

W32KAPI
BOOL
NtUserDdeSetQualityOfService(
    IN HWND hwndClient,
    IN CONST SECURITY_QUALITY_OF_SERVICE *pqosNew,
    OUT PSECURITY_QUALITY_OF_SERVICE pqosPrev OPTIONAL);

W32KAPI
BOOL
NtUserDdeGetQualityOfService(
    IN HWND hwndClient,
    IN HWND hwndServer,
    OUT PSECURITY_QUALITY_OF_SERVICE pqos);

W32KAPI
DWORD
NtUserGetMenuIndex(
    IN HMENU hMenu,
    IN HMENU hSubMenu);

W32KAPI
VOID
NtUserSetRipFlags(
    IN DWORD dwRipFlags);

W32KAPI
VOID
NtUserSetDbgTag(
    IN int     tag,
    IN DWORD   dwBitFlags);

W32KAPI
VOID
NtUserSetDbgTagCount(
    IN DWORD dwTagCount);

W32KAPI
BOOL
NtUserThunkedMenuItemInfo(
    IN HMENU hMenu,
    IN UINT nPosition,
    IN BOOL fByPosition,
    IN BOOL fInsert,
    IN LPMENUITEMINFOW lpmii,
    IN PUNICODE_STRING pstrItem OPTIONAL);

W32KAPI
BOOL
NtUserThunkedMenuInfo(
    IN HMENU hMenu,
    IN LPCMENUINFO lpmi);

W32KAPI
BOOL
NtUserSetMenuDefaultItem(
    IN HMENU hMenu,
    IN UINT wID,
    IN UINT fByPosition
    );

W32KAPI
BOOL
NtUserDrawAnimatedRects(
    IN HWND hwnd,
    IN int idAni,
    IN CONST RECT * lprcFrom,
    IN CONST RECT * lprcTo);

W32KAPI
BOOL
NtUserDrawCaption(
    IN HWND hwnd,
    IN HDC hdc,
    IN CONST RECT *lprc,
    IN UINT flags);

W32KAPI
BOOL
NtUserFlashWindowEx(
    IN PFLASHWINFO pfwi);

W32KAPI
BOOL
NtUserPaintDesktop(
    IN HDC hdc);

W32KAPI
SHORT
NtUserGetAsyncKeyState(
    IN int vKey);

W32KAPI
HBRUSH
NtUserGetControlBrush(
    IN HWND hwnd,
    IN HDC hdc,
    IN UINT msg);

W32KAPI
HBRUSH
NtUserGetControlColor(
    IN HWND hwndParent,
    IN HWND hwndCtl,
    IN HDC hdc,
    IN UINT msg);

W32KAPI
BOOL
NtUserEndMenu(
    VOID);

W32KAPI
int
NtUserCountClipboardFormats(
    VOID);

W32KAPI
DWORD
NtUserGetClipboardSequenceNumber(
    VOID);

W32KAPI
UINT
NtUserGetCaretBlinkTime(
    VOID);

W32KAPI
HWND
NtUserGetClipboardOwner(
    VOID);

W32KAPI
HWND
NtUserGetClipboardViewer(
    VOID);

W32KAPI
UINT
NtUserGetDoubleClickTime(
    VOID);

W32KAPI
HWND
NtUserGetForegroundWindow(
    VOID);

W32KAPI
HWND
NtUserGetOpenClipboardWindow(
    VOID);

W32KAPI
int
NtUserGetPriorityClipboardFormat(
    OUT UINT *paFormatPriorityList,
    IN int cFormats);

W32KAPI
HMENU
NtUserGetSystemMenu(
    IN HWND hwnd,
    IN BOOL bRevert);

W32KAPI
BOOL
NtUserGetUpdateRect(
    IN HWND hwnd,
    IN LPRECT prect OPTIONAL,
    IN BOOL bErase);

W32KAPI
BOOL
NtUserHideCaret(
    IN HWND hwnd);

W32KAPI
BOOL
NtUserHiliteMenuItem(
    IN HWND hwnd,
    IN HMENU hMenu,
    IN UINT uIDHiliteItem,
    IN UINT uHilite);

W32KAPI
BOOL
NtUserInvalidateRect(
    IN HWND hwnd,
    IN CONST RECT *prect OPTIONAL,
    IN BOOL bErase);

W32KAPI
BOOL
NtUserIsClipboardFormatAvailable(
    IN UINT nFormat);

W32KAPI
BOOL
NtUserKillTimer(
    IN HWND hwnd,
    IN UINT_PTR nIDEvent);

W32KAPI
HWND
NtUserMinMaximize(
    IN HWND hwnd,
    IN UINT nCmdShow,
    IN BOOL fKeepHidden);

W32KAPI
BOOL
NtUserMNDragOver(
    IN POINT * ppt,
    OUT PMNDRAGOVERINFO pmndoi);

W32KAPI
BOOL
NtUserMNDragLeave(
    VOID);

W32KAPI
BOOL
NtUserOpenClipboard(
    IN HWND hwnd,
    OUT PBOOL pfEmptyClient);

W32KAPI
BOOL
NtUserPeekMessage(
    OUT LPMSG pmsg,
    IN HWND hwnd,
    IN UINT wMsgFilterMin,
    IN UINT wMsgFilterMax,
    IN UINT wRemoveMsg);

W32KAPI
BOOL
NtUserPostMessage(
    IN HWND hwnd,
    IN UINT msg,
    IN WPARAM wParam,
    IN LPARAM lParam);

W32KAPI
BOOL
NtUserRegisterHotKey(
    IN HWND hwnd,
    IN int id,
    IN UINT fsModifiers,
    IN UINT vk);

W32KAPI
BOOL
NtUserRemoveMenu(
    IN HMENU hmenu,
    IN UINT nPosition,
    IN UINT dwFlags);

W32KAPI
BOOL
NtUserScrollWindowEx(
    IN HWND hwnd,
    IN int XAmount,
    IN int YAmount,
    IN CONST RECT *pRect OPTIONAL,
    IN CONST RECT *pClipRect OPTIONAL,
    IN HRGN hrgnUpdate,
    OUT LPRECT prcUpdate OPTIONAL,
    IN UINT flags);

W32KAPI
HWND
NtUserSetActiveWindow(
    IN HWND hwnd);

W32KAPI
HWND
NtUserSetCapture(
    IN HWND hwnd);

W32KAPI
WORD
NtUserSetClassWord(
    IN HWND hwnd,
    IN int nIndex,
    IN WORD wNewWord);

W32KAPI
HWND
NtUserSetClipboardViewer(
    IN HWND hwndNewViewer);

W32KAPI
HCURSOR
NtUserSetCursor(
    IN HCURSOR hCursor);

W32KAPI
HWND
NtUserSetFocus(
    IN HWND hwnd);

W32KAPI
BOOL
NtUserSetMenu(
    IN HWND  hwnd,
    IN HMENU hmenu,
    IN BOOL  fRedraw);

W32KAPI
BOOL
NtUserSetMenuContextHelpId(
    IN HMENU hMenu,
    IN DWORD dwContextHelpId);

W32KAPI
BOOL
NtUserSetMenuFlagRtoL(
    IN HMENU hMenu);

W32KAPI
HWND
NtUserSetParent(
    IN HWND hwndChild,
    IN HWND hwndNewParent);

W32KAPI
int
NtUserSetScrollInfo(
    IN HWND hwnd,
    IN int nBar,
    IN LPCSCROLLINFO pInfo,
    IN BOOL fRedraw);

W32KAPI
BOOL
NtUserSetSysColors(
    IN int cElements,
    IN CONST INT * lpaElements,
    IN CONST COLORREF * lpaRgbValues,
    IN UINT  uOptions);

W32KAPI
UINT_PTR
NtUserSetTimer(
    IN HWND hwnd,
    IN UINT_PTR nIDEvent,
    IN UINT wElapse,
    IN TIMERPROC pTimerFunc);

W32KAPI
LONG
NtUserSetWindowLong(
    IN HWND hwnd,
    IN int nIndex,
    IN LONG dwNewLong,
    IN BOOL bAnsi);

#ifdef _WIN64
W32KAPI
LONG_PTR
NtUserSetWindowLongPtr(
    IN HWND hwnd,
    IN int nIndex,
    IN LONG_PTR dwNewLong,
    IN BOOL bAnsi);
#else
#define NtUserSetWindowLongPtr  NtUserSetWindowLong
#endif

W32KAPI
WORD
NtUserSetWindowWord(
    IN HWND hwnd,
    IN int nIndex,
    IN WORD wNewWord);

W32KAPI
HHOOK
NtUserSetWindowsHookAW(
    IN int nFilterType,
    IN HOOKPROC pfnFilterProc,
    IN DWORD dwFlags);

W32KAPI
BOOL
NtUserShowCaret(
    IN HWND hwnd);

W32KAPI
BOOL
NtUserShowScrollBar(
    IN HWND hwnd,
    IN int iBar,
    IN BOOL fShow);

W32KAPI
BOOL
NtUserShowWindowAsync(
    IN HWND hwnd,
    IN int nCmdShow);

W32KAPI
BOOL
NtUserShowWindow(
    IN HWND hwnd,
    IN int nCmdShow);

W32KAPI
BOOL
NtUserTrackMouseEvent(
    IN OUT LPTRACKMOUSEEVENT lpTME
    );

W32KAPI
BOOL
NtUserTrackPopupMenuEx(
    IN HMENU hMenu,
    IN UINT uFlags,
    IN int x,
    IN int y,
    IN HWND hwnd,
    IN CONST TPMPARAMS *pparamst OPTIONAL);

W32KAPI
BOOL
NtUserTranslateMessage(
    IN CONST MSG *lpMsg,
    IN UINT flags);

W32KAPI
BOOL
NtUserUnhookWindowsHookEx(
    IN HHOOK hhk);

W32KAPI
BOOL
NtUserUnregisterHotKey(
    IN HWND hwnd,
    IN int id);

W32KAPI
BOOL
NtUserValidateRect(
    IN HWND hwnd,
    IN CONST RECT *lpRect OPTIONAL);

W32KAPI
DWORD
NtUserWaitForInputIdle(
    IN ULONG_PTR idProcess,
    IN DWORD dwMilliseconds,
    IN BOOL fSharedWow);

W32KAPI
HWND
NtUserWindowFromPoint(
    IN POINT Point);

W32KAPI
HDC
NtUserBeginPaint(
    IN HWND hwnd,
    OUT LPPAINTSTRUCT lpPaint);

W32KAPI
BOOL
NtUserCreateCaret(
    IN HWND hwnd,
    IN HBITMAP hBitmap,
    IN int nWidth,
    IN int nHeight);

W32KAPI
BOOL
NtUserEndPaint(
    IN HWND hwnd,
    IN CONST PAINTSTRUCT *lpPaint);

W32KAPI
int
NtUserExcludeUpdateRgn(
    IN HDC hDC,
    IN HWND hwnd);

W32KAPI
HDC
NtUserGetDC(
    IN HWND hwnd);

W32KAPI
HDC
NtUserGetDCEx(
    IN HWND hwnd,
    IN HRGN hrgnClip,
    IN DWORD flags);

W32KAPI
HDC
NtUserGetWindowDC(
    IN HWND hwnd);

W32KAPI
int
NtUserGetUpdateRgn(
    IN HWND hwnd,
    IN HRGN hRgn,
    IN BOOL bErase);

W32KAPI
BOOL
NtUserRedrawWindow(
    IN HWND hwnd,
    IN CONST RECT *lprcUpdate OPTIONAL,
    IN HRGN hrgnUpdate,
    IN UINT flags);

W32KAPI
BOOL
NtUserInvalidateRgn(
    IN HWND hwnd,
    IN HRGN hRgn,
    IN BOOL bErase);

W32KAPI
int
NtUserSetWindowRgn(
    IN HWND hwnd,
    IN HRGN hRgn,
    IN BOOL bRedraw);

W32KAPI
BOOL
NtUserScrollDC(
    IN HDC hDC,
    IN int dx,
    IN int dy,
    IN CONST RECT *lprcScroll OPTIONAL,
    IN CONST RECT *lprcClip OPTIONAL,
    IN HRGN hrgnUpdate,
    OUT LPRECT lprcUpdate OPTIONAL);

W32KAPI
int
NtUserInternalGetWindowText(
    IN HWND hwnd,
    OUT LPWSTR lpString,
    IN int nMaxCount);

W32KAPI
int
NtUserGetMouseMovePointsEx(
    IN UINT             cbSize,
    IN CONST MOUSEMOVEPOINT *lppt,
    OUT MOUSEMOVEPOINT *lpptBuf,
    IN UINT             nBufPoints,
    IN DWORD            resolution);

W32KAPI
int
NtUserToUnicodeEx(
    IN UINT wVirtKey,
    IN UINT wScanCode,
    IN CONST BYTE *lpKeyState,
    OUT LPWSTR lpszBuff,
    IN int cchBuff,
    IN UINT wFlags,
    IN HKL hKeyboardLayout);

W32KAPI
BOOL
NtUserYieldTask(
    VOID);

W32KAPI
BOOL
NtUserWaitMessage(
    VOID);

#ifdef MESSAGE_PUMP_HOOK

W32KAPI
BOOL
NtUserRealWaitMessageEx(
    IN UINT fsWakeMask,
    IN DWORD Timeout);

#endif

W32KAPI
UINT
NtUserLockWindowStation(
    IN HWINSTA hWindowStation);

W32KAPI
BOOL
NtUserUnlockWindowStation(
    IN HWINSTA hWindowStation);

W32KAPI
UINT
NtUserSetWindowStationUser(
    IN HWINSTA hWindowStation,
    IN PLUID pLuidUser,
    IN PSID pSidUser OPTIONAL,
    IN DWORD cbSidUser);

W32KAPI
BOOL
NtUserSetLogonNotifyWindow(
    IN HWND hwndNotify);

W32KAPI
BOOL
NtUserSetSystemCursor(
    IN HCURSOR hcur,
    IN DWORD id);

W32KAPI
HCURSOR
NtUserGetCursorFrameInfo(
    IN HCURSOR hcur,
    IN int iFrame,
    OUT LPDWORD pjifRate,
    OUT LPINT pccur);

W32KAPI
BOOL
NtUserSetCursorContents(
    IN HCURSOR hCursor,
    IN HCURSOR hCursorNew);

W32KAPI
HCURSOR
NtUserFindExistingCursorIcon(
    IN PUNICODE_STRING pstrModName,
    IN PUNICODE_STRING pstrResName,
    IN PCURSORFIND     pcfSearch);

W32KAPI
BOOL
NtUserSetCursorIconData(
    IN HCURSOR         hCursor,
    IN PUNICODE_STRING pstrModName,
    IN PUNICODE_STRING pstrResName,
    IN PCURSORDATA     pData);

W32KAPI
BOOL
NtUserGetMenuItemRect(
    IN HWND hwnd,
    IN HMENU hMenu,
    IN UINT uItem,
    OUT LPRECT lprcItem);

W32KAPI
int
NtUserMenuItemFromPoint(
    IN HWND hwnd,
    IN HMENU hMenu,
    IN POINT ptScreen);

W32KAPI
BOOL
NtUserGetCaretPos(
    OUT LPPOINT lpPoint);

W32KAPI
BOOL
NtUserDefSetText(
    IN HWND hwnd,
    IN PLARGE_STRING Text OPTIONAL);

W32KAPI
NTSTATUS
NtUserQueryInformationThread(
    IN HANDLE hThread,
    IN USERTHREADINFOCLASS ThreadInfoClass,
    OUT PVOID ThreadInformation,
    IN ULONG ThreadInformationLength,
    IN OUT PULONG ReturnLength OPTIONAL);

W32KAPI
NTSTATUS
NtUserSetInformationThread(
    IN HANDLE hThread,
    IN USERTHREADINFOCLASS ThreadInfoClass,
    IN PVOID ThreadInformation,
    IN ULONG ThreadInformationLength);

W32KAPI
NTSTATUS
NtUserSetInformationProcess(
    IN HANDLE hProcess,
    IN USERPROCESSINFOCLASS ProcessInfoClass,
    IN PVOID ProcessInformation,
    IN ULONG ProcessInformationLength);

W32KAPI
BOOL
NtUserNotifyProcessCreate(
    IN DWORD dwProcessId,
    IN DWORD dwParentThreadId,
    IN ULONG_PTR dwData,
    IN DWORD dwFlags);

W32KAPI
NTSTATUS
NtUserTestForInteractiveUser(
    IN PLUID pluidCaller);

W32KAPI
BOOL
NtUserSetConsoleReserveKeys(
    IN HWND hwnd,
    IN DWORD fsReserveKeys);

W32KAPI
VOID
NtUserModifyUserStartupInfoFlags(
    IN DWORD dwMask,
    IN DWORD dwFlags);

W32KAPI
BOOL
NtUserSetWindowFNID(
    IN HWND hwnd,
    IN WORD fnid);

W32KAPI
VOID
NtUserAlterWindowStyle(
    IN HWND hwnd,
    IN DWORD mask,
    IN DWORD flags);

W32KAPI
VOID
NtUserSetThreadState(
    IN DWORD dwFlags,
    IN DWORD dwMask);

W32KAPI
ULONG_PTR
NtUserGetThreadState(
    IN USERTHREADSTATECLASS ThreadState);

W32KAPI
BOOL
NtUserValidateHandleSecure(
    IN HANDLE h);

W32KAPI
BOOL
NtUserUserHandleGrantAccess(
    IN HANDLE hUserHandle,
    IN HANDLE hJob,
    IN BOOL   bGrant);

W32KAPI
HWND
NtUserCreateWindowEx(
    IN DWORD dwExStyle,
    IN PLARGE_STRING pstrNVClassName,
    IN PLARGE_STRING pstrClassName,
    IN PLARGE_STRING pstrWindowName OPTIONAL,
    IN DWORD dwStyle,
    IN int x,
    IN int y,
    IN int nWidth,
    IN int nHeight,
    IN HWND hwndParent,
    IN HMENU hmenu,
    IN HANDLE hModule,
    IN LPVOID pParam,
    IN DWORD dwFlags,
    IN PACTIVATION_CONTEXT pActCtx);

W32KAPI
NTSTATUS
NtUserBuildHwndList(
    IN HDESK hdesk,
    IN HWND hwndNext,
    IN BOOL fEnumChildren,
    IN DWORD idThread,
    IN UINT cHwndMax,
    OUT HWND *phwndFirst,
    OUT PUINT pcHwndNeeded);

W32KAPI
NTSTATUS
NtUserBuildPropList(
    IN HWND hwnd,
    IN UINT cPropMax,
    OUT PPROPSET pPropSet,
    OUT PUINT pcPropNeeded);

W32KAPI
NTSTATUS
NtUserBuildNameList(
    IN HWINSTA hwinsta,
    IN UINT cbNameList,
    OUT PNAMELIST pNameList,
    OUT PUINT pcbNeeded);

W32KAPI
HKL
NtUserActivateKeyboardLayout(
    IN HKL hkl,
    IN UINT Flags);

W32KAPI
HKL
NtUserLoadKeyboardLayoutEx(
    IN HANDLE hFile,
    IN DWORD offTable,
    IN PKBDTABLE_MULTI_INTERNAL pKbdTableMulti,
    IN HKL hkl,
    IN PUNICODE_STRING pstrKLID,
    IN UINT KbdInputLocale,
    IN UINT Flags);

W32KAPI
BOOL
NtUserUnloadKeyboardLayout(
    IN HKL hkl);

W32KAPI
BOOL
NtUserSetSystemMenu(
    IN HWND hwnd,
    IN HMENU hmenu);

W32KAPI
BOOL
NtUserDragDetect(
    IN HWND hwnd,
    IN POINT pt);

W32KAPI
UINT_PTR
NtUserSetSystemTimer(
    IN HWND hwnd,
    IN UINT_PTR nIDEvent,
    IN DWORD dwElapse,
    IN WNDPROC pTimerFunc);

W32KAPI
BOOL
NtUserQuerySendMessage(
    OUT PMSG pmsg);

W32KAPI
UINT
NtUserSendInput(
    IN UINT    cInputs,
    IN CONST INPUT *pInputs,
    IN int     cbSize);

W32KAPI
BOOL
NtUserImpersonateDdeClientWindow(
    IN HWND hwndClient,
    IN HWND hwndServer);

W32KAPI
ULONG_PTR
NtUserGetCPD(
    IN HWND hwnd,
    IN DWORD options,
    IN ULONG_PTR dwData);

W32KAPI
int
NtUserCopyAcceleratorTable(
    IN HACCEL hAccelSrc,
    IN OUT LPACCEL lpAccelDst OPTIONAL,
    IN int cAccelEntries);

W32KAPI
HWND
NtUserFindWindowEx(
    IN HWND hwndParent,
    IN HWND hwndChild,
    IN PUNICODE_STRING pstrClassName OPTIONAL,
    IN PUNICODE_STRING pstrWindowName OPTIONAL,
    IN DWORD dwType);

W32KAPI
BOOL
NtUserGetClassInfoEx(
    IN HINSTANCE hInstance OPTIONAL,
    IN PUNICODE_STRING pstrClassName,
    IN OUT LPWNDCLASSEXW lpWndClass,
    OUT LPWSTR *ppszMenuName,
    IN BOOL bAnsi);

W32KAPI
int
NtUserGetClassName(
    IN HWND hwnd,
    IN BOOL bReal,
    IN OUT PUNICODE_STRING pstrClassName);

W32KAPI
UINT
NtUserGetAtomName(
    IN ATOM atom,
    IN OUT PUNICODE_STRING pstrAtomName);

W32KAPI
int
NtUserGetClipboardFormatName(
    IN UINT format,
    OUT LPWSTR lpszFormatName,
    IN UINT chMax);

W32KAPI
int
NtUserGetKeyNameText(
    IN LONG lParam,
    OUT LPWSTR lpszKeyName,
    IN UINT chMax);

W32KAPI
BOOL
NtUserGetKeyboardLayoutName(
    IN OUT PUNICODE_STRING pstrKLID);

W32KAPI
UINT
NtUserGetKeyboardLayoutList(
    IN UINT nItems,
    OUT HKL *lpBuff);

W32KAPI
DWORD
NtUserGetGuiResources(
    IN HANDLE hProcess,
    IN DWORD dwFlags);

W32KAPI
UINT
NtUserMapVirtualKeyEx(
    IN UINT uCode,
    IN UINT uMapType,
    IN ULONG_PTR dwHKLorPKL,
    IN BOOL bHKL);

W32KAPI
ATOM
NtUserRegisterClassExWOW(
    IN WNDCLASSEX *lpWndClass,
    IN PUNICODE_STRING pstrClassName,
    IN PUNICODE_STRING pstrClassNameVer,
    IN PCLSMENUNAME pcmn,
    IN WORD fnid,
    IN DWORD dwFlags,
    IN LPDWORD pdwWOWstuff OPTIONAL);

W32KAPI
UINT
NtUserRegisterWindowMessage(
    IN PUNICODE_STRING pstrMessage);

W32KAPI
HANDLE
NtUserRemoveProp(
    IN HWND hwnd,
    IN DWORD dwProp);

W32KAPI
BOOL
NtUserSetProp(
    IN HWND hwnd,
    IN DWORD dwProp,
    IN HANDLE hData);

W32KAPI
BOOL
NtUserUnregisterClass(
    IN PUNICODE_STRING pstrClassName,
    IN HINSTANCE hInstance,
    OUT PCLSMENUNAME pcmn);

W32KAPI
SHORT
NtUserVkKeyScanEx(
    IN WCHAR ch,
    IN ULONG_PTR dwHKLorPKL,
    IN BOOL bHKL);

W32KAPI
NTSTATUS
NtUserEnumDisplayDevices(
    IN PUNICODE_STRING pstrDeviceName,
    IN DWORD iDevNum,
    IN OUT LPDISPLAY_DEVICEW lpDisplayDevice,
    IN DWORD dwFlags);

W32KAPI
HWINEVENTHOOK
NtUserSetWinEventHook(
    IN DWORD           eventMin,
    IN DWORD           eventMax,
    IN HMODULE         hmodWinEventProc,
    IN PUNICODE_STRING pstrLib OPTIONAL,
    IN WINEVENTPROC    pfnWinEventProc,
    IN DWORD           idEventProcess,
    IN DWORD           idEventThread,
    IN DWORD           dwFlags);

W32KAPI
BOOL
NtUserUnhookWinEvent(
    IN HWINEVENTHOOK hWinEventHook);

W32KAPI
VOID
NtUserNotifyWinEvent(
    IN DWORD event,
    IN HWND  hwnd,
    IN LONG  idObject,
    IN LONG  idChild);

W32KAPI
BOOL
NtUserRegisterUserApiHook(
    IN PUNICODE_STRING pstrLib,
    IN ULONG_PTR offPfnInitUserApiHook);

W32KAPI
BOOL
NtUserUnregisterUserApiHook(VOID);

W32KAPI
BOOL
NtUserGetGUIThreadInfo(
    IN DWORD idThread,
    IN OUT PGUITHREADINFO pgui);

W32KAPI
BOOL
NtUserGetTitleBarInfo(
    IN HWND hwnd,
    IN OUT PTITLEBARINFO ptbi);

W32KAPI
BOOL
NtUserGetScrollBarInfo(
    IN HWND hwnd,
    IN LONG idObject,
    IN OUT PSCROLLBARINFO ptbi);

W32KAPI
BOOL
NtUserGetComboBoxInfo(
    IN HWND hwnd,
    IN OUT PCOMBOBOXINFO pcbi
    );

W32KAPI
DWORD
NtUserGetListBoxInfo(
    IN HWND hwnd
    );

W32KAPI
HWND
NtUserGetAncestor(
    IN HWND hwnd,
    IN UINT gaFlags);

W32KAPI
BOOL
NtUserGetCursorInfo(
    IN OUT PCURSORINFO pci);

W32KAPI
HWND
NtUserRealChildWindowFromPoint(
    IN HWND hwndParent,
    IN POINT pt
    );

W32KAPI
BOOL
NtUserGetAltTabInfo(
    IN HWND hwnd,
    IN int iItem,
    IN OUT PALTTABINFO pati,
    OUT LPWSTR lpszItemText,
    IN UINT cchItemText,
    IN BOOL bAnsi);

W32KAPI
BOOL
NtUserGetMenuBarInfo(
    IN HWND hwnd,
    IN long idObject,
    IN long idItem,
    IN OUT PMENUBARINFO pmbi);

W32KAPI
BOOL
NtUserCallMsgFilter(
    IN OUT LPMSG lpMsg,
    IN int nCode);

W32KAPI
int
NtUserDrawMenuBarTemp(
    IN HWND hwnd,
    IN HDC hdc,
    IN LPCRECT lprc,
    IN HMENU hMenu,
    IN HFONT hFont);

W32KAPI
BOOL
NtUserDrawCaptionTemp(
    IN HWND hwnd,
    IN HDC hdc,
    IN LPCRECT lprc,
    IN HFONT hFont,
    IN HICON hicon,
    IN PUNICODE_STRING pstrText,
    IN UINT flags);

W32KAPI
SHORT
NtUserGetKeyState(
    IN int vk);

W32KAPI
BOOL
NtUserGetKeyboardState(
    OUT PBYTE pb);

W32KAPI
HANDLE
NtUserQueryWindow(
    IN HWND hwnd,
    IN WINDOWINFOCLASS WindowInfo);

W32KAPI
BOOL
NtUserSBGetParms(
    IN HWND hwnd,
    IN int code,
    IN PSBDATA pw,
    IN OUT LPSCROLLINFO lpsi);

W32KAPI
BOOL
NtUserBitBltSysBmp(
    IN HDC hdc,
    IN int xDest,
    IN int yDest,
    IN int cxDest,
    IN int cyDest,
    IN int xSrc,
    IN int ySrc,
    IN DWORD dwRop);

W32KAPI
LRESULT
NtUserMessageCall(
    IN HWND hwnd,
    IN UINT msg,
    IN WPARAM wParam,
    IN LPARAM lParam,
    IN ULONG_PTR xParam,
    IN DWORD xpfnProc,
    IN BOOL bAnsi);

W32KAPI
LRESULT
NtUserCallNextHookEx(
    IN int nCode,
    IN WPARAM wParam,
    IN LPARAM lParam,
    IN BOOL bAnsi);

W32KAPI
BOOL
NtUserEnumDisplayMonitors(
    IN HDC             hdc,
    IN LPCRECT         lprcClip,
    IN MONITORENUMPROC lpfnEnum,
    IN LPARAM          dwData);

W32KAPI
NTSTATUS
NtUserEnumDisplaySettings(
    IN PUNICODE_STRING pstrDeviceName,
    IN DWORD           iModeNum,
    OUT LPDEVMODEW     lpDevMode,
    IN  DWORD          dwFlags);

W32KAPI
LONG
NtUserChangeDisplaySettings(
    IN PUNICODE_STRING pstrDeviceName,
    IN LPDEVMODEW lpDevMode,
    IN DWORD dwFlags,
    IN PVOID lParam);

#ifdef PRERELEASE
W32KAPI
BOOL
NtUserQueryUserCounters(
    IN  DWORD       dwQueryType,
    IN  LPVOID      pvIn,
    IN  DWORD       dwInSize,
    OUT LPVOID      pvResult,
    IN  DWORD       dwOutSize);
#endif

W32KAPI
BOOL
NtUserUpdateLayeredWindow(
    IN HWND hwnd,
    IN HDC hdcDst,
    IN POINT *pptDst,
    IN SIZE *psize,
    IN HDC hdcSrc,
    IN POINT *pptSrc,
    IN COLORREF crKey,
    IN BLENDFUNCTION *pblend,
    IN DWORD dwFlags);

W32KAPI
BOOL
NtUserGetLayeredWindowAttributes(
    IN HWND hwnd,
    OUT COLORREF *pcrKey OPTIONAL,
    OUT BYTE *pbAlpha OPTIONAL,
    OUT DWORD * pdwFlags OPTIONAL);

W32KAPI
BOOL
NtUserSetLayeredWindowAttributes(
    IN HWND hwnd,
    IN COLORREF crKey,
    IN BYTE bAlpha,
    IN DWORD dwFlags);

W32KAPI
BOOL
NtUserPrintWindow(
    IN HWND hwnd,
    IN HDC hdcBlt,
    IN UINT nFlags);

W32KAPI
NTSTATUS
NtUserRemoteConnect(
    IN PDOCONNECTDATA pDoConnectData,
    IN ULONG DisplayDriverNameLength,
    IN PWCHAR DisplayDriverName );

W32KAPI
NTSTATUS
NtUserRemoteRedrawRectangle(
    IN WORD Left,
    IN WORD Top,
    IN WORD Right,
    IN WORD Bottom );

W32KAPI
NTSTATUS
NtUserRemoteRedrawScreen( VOID );

W32KAPI
NTSTATUS
NtUserRemoteStopScreenUpdates( VOID );

W32KAPI
NTSTATUS
NtUserCtxDisplayIOCtl(
    IN ULONG  DisplayIOCtlFlags,
    IN PUCHAR pDisplayIOCtlData,
    IN ULONG  cbDisplayIOCtlData);

W32KAPI
HPALETTE
NtUserSelectPalette(
    IN HDC hdc,
    IN HPALETTE hpalette,
    IN BOOL fForceBackground);

W32KAPI
NTSTATUS
NtUserProcessConnect(
    IN HANDLE    hProcess,
    IN OUT PVOID pConnectInfo,
    IN ULONG     cbConnectInfo);

W32KAPI
NTSTATUS
NtUserSoundSentry(VOID);

W32KAPI
NTSTATUS
NtUserInitialize(
    IN DWORD   dwVersion,
    IN HANDLE  hPowerRequestEvent,
    IN HANDLE  hMediaRequestEvent);


W32KAPI
BOOL
NtUserSetProcessRedirectionMode(
    IN HANDLE hProcess,
    IN BOOL bRedirectionMode);

W32KAPI
BOOL
NtUserGetProcessRedirectionMode(
    IN HANDLE hProcess,
    OUT PBOOL pbRedirectionMode);

W32KAPI
BOOL
NtUserSetDesktopRedirectionMode(
    IN HANDLE hProcess,
    IN BOOL bRedirectionMode);

W32KAPI
BOOL
NtUserGetDesktopRedirectionMode(
    IN HANDLE hProcess,
    OUT PBOOL pbRedirectionMode);

W32KAPI
BOOL
NtUserValidateTimerCallback(
    IN ULONG_PTR pfnCallback);

#endif  // _NTUSER_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\inc\usercall.h ===
/****************************** Module Header ******************************\
* Module Name: usercall.h
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* This header file contains all kernel mode entry points
*
* History:
* 12-98 Hiroyama    Created
\***************************************************************************/

#ifndef _USERCALL_
#define _USERCALL_

#include "w32wow64.h"

#ifndef W32KAPI
#define W32KAPI  DECLSPEC_ADDRSAFE
#endif

W32KAPI
ULONG_PTR
NtUserCallNoParam(
    IN DWORD xpfnProc);

W32KAPI
ULONG_PTR
NtUserCallOneParam(
    IN ULONG_PTR dwParam,
    IN DWORD xpfnProc);

W32KAPI
KERNEL_ULONG_PTR
NtUserCallHwnd(
    IN HWND hwnd,
    IN DWORD xpfnProc);

W32KAPI
KERNEL_ULONG_PTR
NtUserCallHwndLock(
    IN HWND hwnd,
    IN DWORD xpfnProc);

W32KAPI
ULONG_PTR
NtUserCallHwndOpt(
    IN HWND hwnd,
    IN DWORD xpfnProc);

W32KAPI
ULONG_PTR
NtUserCallTwoParam(
    ULONG_PTR dwParam1,
    ULONG_PTR dwParam2,
    IN DWORD xpfnProc);

W32KAPI
ULONG_PTR
NtUserCallHwndParam(
    IN HWND hwnd,
    IN ULONG_PTR dwParam,
    IN DWORD xpfnProc);

W32KAPI
ULONG_PTR
NtUserCallHwndParamLock(
    IN HWND hwnd,
    IN ULONG_PTR dwParam,
    IN DWORD xpfnProc);

#endif  /* _USERCALL_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\inc\user.h ===
/****************************** Module Header ******************************\
* Module Name: user.h
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* This header file contains stuff shared by all the modules of the USER.DLL.
*
* History:
* 09-18-90 DarrinM      Created.
* 04-27-91 DarrinM      Merged in USERCALL.H, removed some dead wood.
\***************************************************************************/

#ifndef _USER_
#define _USER_

/******************************WOW64***NOTE********************************\
* Note: Win32k Memory shared with User-Mode and Wow64
*
* For Wow64 (Win32 apps on Win64) we build a 32-bit version
* of user32.dll & gdi32.dll which can run against the 64-bit kernel
* with no changes to the 64-bit kernel code.
*
* For the 32 on 64 bit dlls all data structures which are shared with
* win32k must be 64-bit. These data structures include the shared
* sections, as well as members of the TEB.
* These shared data structures are now declared so that they can be
* built as 32 bit in a 32 bit dll, 64 bit in a 64 bit dll, and now
* 64 bit in a 32 bit dll.
*
* The following rules should be followed when declaring
* shared data structures:
*
*     Pointers in shared data structures use the KPTR_MODIFIER in their
*     declaration.
*
*     Handles in shared data structures are declared KHxxx.
*
*     xxx_PTR changes to KERNEL_xxx_PTR.
*
*     Pointers to basic types are declared as KPxxx;
*
* Also on Wow64 every thread has both a 32-bit TEB and a 64-bit TEB.
* GetCurrentTeb() returns the current 32-bit TEB while the kernel
* will allways reference the 64-bit TEB.
*
* All client side references to shared data in the TEB should use
* the new GetCurrentTebShared() macro which returns the 64-bit TEB
* for Wow64 builds and returns GetCurrentTeb() for regular builds.
* The exception to this rule is LastErrorValue, which should allways
* be referenced through GetCurrentTeb().
*
* Ex:
*
* DECLARE_HANDLE(HFOO);
*
* typedef struct _MY_STRUCT *PMPTR;
*
* struct _SHARED_STRUCT
* {
*     struct _SHARED_STRUCT *   pNext;
*     PMPTR                     pmptr;
*     HFOO                      hFoo;
*     UINT_PTR                  cb;
*     PBYTE                     pb;
*     PVOID                     pv;
*
*     DWORD                     dw;
*     USHORT                    us;
* } SHARED_STRUCT;
*
*
* Changes to:
*
*
* DECLARE_HANDLE(HFOO);
* DECLARE_KHANDLE(HFOO);
*
* typedef struct _MY_STRUCT * KPTR_MODIFIER   PMPTR;
*
* struct _SHARED_STRUCT
* {
*     struct _SHARED_STRUCT * KPTR_MODIFIER   pNext;
*     PMPTR                     pmptr;
*     KHFOO                     hFoo;
*     KERNEL_UINT_PTR           cb;
*     KPBYTE                    pb;
*     KERNEL_PVOID              pv;
*
*     DWORD                     dw;
*     USHORT                    us;
* } SHARED_STRUCT;
*
\***************************************************************************/
#include "w32wow64.h"

DECLARE_KHANDLE(HIMC);

/*
 * Enable warnings that are turned off default for NT but we want on
 */
#ifndef RC_INVOKED       // RC can't handle #pragmas
    #pragma warning(error:4100)   // Unreferenced formal parameter
    #pragma warning(error:4101)   // Unreferenced local variable
    // #pragma warning(error:4702)   // Unreachable code
    #pragma warning(error:4705)   // Statement has no effect
#endif // RC_INVOKED

#if !defined(FASTCALL)
    #if defined(_X86_)
        #define FASTCALL    _fastcall
    #else // defined(_X86_)
        #define FASTCALL
    #endif // defined(_X86_)
#endif // !defined(FASTCALL)

#ifdef UNICODE
    #define UTCHAR WCHAR
#else // UINCODE
    #define UTCHAR UCHAR
#endif // UINCODE


/*
 * These types are needed before they are fully defined.
 */
typedef struct tagWINDOWSTATION     * KPTR_MODIFIER PWINDOWSTATION;
typedef struct _LOCKRECORD          * KPTR_MODIFIER PLR;
typedef struct _TL                  * KPTR_MODIFIER PTL;
typedef struct tagDESKTOP           * KPTR_MODIFIER PDESKTOP;
typedef struct tagTDB               * KPTR_MODIFIER PTDB;
typedef struct tagSVR_INSTANCE_INFO * PSVR_INSTANCE_INFO;
typedef struct _MOVESIZEDATA        * PMOVESIZEDATA;
typedef struct tagCURSOR            * KPTR_MODIFIER PCURSOR;
typedef struct tagPOPUPMENU         * KPTR_MODIFIER PPOPUPMENU;
typedef struct tagQMSG              * KPTR_MODIFIER PQMSG;
typedef struct tagWND               * KPTR_MODIFIER PWND;
typedef struct _ETHREAD             * PETHREAD;
typedef struct tagDESKTOPINFO       * KPTR_MODIFIER PDESKTOPINFO;
typedef struct tagDISPLAYINFO       * KPTR_MODIFIER PDISPLAYINFO;
typedef struct tagCLIENTTHREADINFO  * KPTR_MODIFIER PCLIENTTHREADINFO;
typedef struct tagDCE               * KPTR_MODIFIER PDCE;
typedef struct tagSPB               * KPTR_MODIFIER PSPB;
typedef struct tagQ                 * KPTR_MODIFIER PQ;
typedef struct tagTHREADINFO        * KPTR_MODIFIER PTHREADINFO;
typedef struct tagPROCESSINFO       * KPTR_MODIFIER PPROCESSINFO;
typedef struct tagWOWTHREADINFO     * PWOWTHREADINFO;
typedef struct tagPERUSERDATA       * PPERUSERDATA;
typedef struct tagTERMINAL          * PTERMINAL;
typedef struct tagCLIENTINFO          * PCLIENTINFO;
typedef struct tagMENU              * KPTR_MODIFIER PMENU;
typedef struct tagHOOK              * KPTR_MODIFIER PHOOK;
typedef struct _HANDLEENTRY         * KPTR_MODIFIER PHE;
typedef struct tagSERVERINFO        * KPTR_MODIFIER PSERVERINFO;
typedef struct _CALLPROCDATA        * KPTR_MODIFIER PCALLPROCDATA;
typedef struct tagCLS               * KPTR_MODIFIER PCLS;
typedef struct tagMONITOR           * KPTR_MODIFIER PMONITOR;

/*
 * MessageBox button strings.
 * They should be in the same order as IDOK... and SEB_OK... are
 */
#define STR_OK                      800
#define STR_CANCEL                  801
#define STR_ABORT                   802
#define STR_RETRY                   803
#define STR_IGNORE                  804
#define STR_YES                     805
#define STR_NO                      806
#define STR_CLOSE                   807
#define STR_HELP                    808
#define STR_TRYAGAIN                809
#define STR_CONTINUE                810

/*
 * ToolTip strings.
 */
#define STR_TT_MIN                  900
#define STR_TT_MAX                  901
#define STR_TT_RESUP                902
#define STR_TT_RESDOWN              903
#define STR_TT_HELP                 904
#define STR_TT_SCLOSE               905

/*
 * This name is used both in kernel\server.c and ntuser\server\exitwin.c
 */
#define ICON_PROP_NAME  L"SysIC"

/*
 * Define DbgPrint to be something bogus on free builds so we won't
 * include it accidentally.
 */
#if !DBG
#define DbgPrint UserDbgPrint
#endif

typedef struct tagMBSTRING
{
    WCHAR szName[15];
    UINT  uID;
    UINT  uStr;
} MBSTRING, * KPTR_MODIFIER PMBSTRING;

/*
 * SIZERECT is a rectangle represented by a top-left coordinate, width,
 * and height.
 *
 * Hungarian is "src".
 */
typedef struct tagSIZERECT {
    int x;
    int y;
    int cx;
    int cy;
} SIZERECT, *PSIZERECT, *LPSIZERECT;

typedef const SIZERECT * PCSIZERECT;
typedef const SIZERECT * LPCSIZERECT;


void RECTFromSIZERECT(PRECT prc, PCSIZERECT psrc);
void SIZERECTFromRECT(PSIZERECT psrc, LPCRECT prc);

/*
 * Use these macros to unpack things packed by MAKELPARAM.
 */

#define LOSHORT(l)          ((short)LOWORD(l))
#define HISHORT(l)          ((short)HIWORD(l))

#ifndef GET_X_LPARAM
#define GET_X_LPARAM(lp)    ((int)(short)LOWORD(lp))
#endif

#ifndef GET_Y_LPARAM
#define GET_Y_LPARAM(lp)    ((int)(short)HIWORD(lp))
#endif

#ifdef _USERK_
    #define GetClientInfo() (((PTHREADINFO)(W32GetCurrentThread()))->pClientInfo)
#else
    // We don't grab it this way in the kernel in case it is a kernel only thread
    #define GetClientInfo() ((PCLIENTINFO)((NtCurrentTebShared())->Win32ClientInfo))
#endif

/* Used by xxxSleepTask */
#define HEVENT_REMOVEME ((HANDLE)IntToPtr(0xFFFFFFFF))


/*
 * Access to system metrics, colors, and brushes.
 */
#define SYSMETBOOL(i)         ((gpsi->aiSysMet[SM_BOOLEANS] & (1 << (SM_##i - SM_STARTBOOLRANGE))) != 0)
#define SYSMETBOOL2(index)    ((gpsi->aiSysMet[SM_BOOLEANS] & (1 << (index - SM_STARTBOOLRANGE))) != 0)
#define SETSYSMETBOOL(i, val) SET_OR_CLEAR_FLAG(gpsi->aiSysMet[SM_BOOLEANS], 1 << (SM_##i - SM_STARTBOOLRANGE), val)
#define SYSMET(i)             (gpsi->aiSysMet[SM_##i])
#define SYSMETRTL(i)          (gpsi->aiSysMet[SM_##i])
#define SYSRGB(i)             (gpsi->argbSystem[COLOR_##i])
#define SYSRGBRTL(i)          (gpsi->argbSystem[COLOR_##i])
#define SYSHBR(i)             KHBRUSH_TO_HBRUSH(gpsi->ahbrSystem[COLOR_##i])
#define SYSHBRUSH(i)          KHBRUSH_TO_HBRUSH(gpsi->ahbrSystem[i])

#ifdef _USERK_
    #define SYSMETFROMPROCESS(i)  gpsi->aiSysMet[SM_##i]
#endif

/*
 * These cool constants can be used to specify rops.
 */
#define DESTINATION (DWORD)0x00AA0000
#define SOURCE      (DWORD)0x00CC0000
#define PATTERN     (DWORD)0x00F00000

/*
 *  Chicago equates.
 */
#define BI_CHECKBOX       0
#define BI_RADIOBUTTON    1
#define BI_3STATE         2

#define NUM_BUTTON_TYPES  3
#define NUM_BUTTON_STATES 4

/*
 * Total number of strings used as button strings in MessageBoxes.
 */
#define  MAX_MB_STRINGS    11


/*
 * Rectangle macros.  Inlining these is both faster and smaller.
 */
#define CopyRect        CopyRectInl
#define EqualRect       EqualRectInl
#define SetRectEmpty    SetRectEmptyInl

__inline void
CopyRectInl(LPRECT prcDest, LPCRECT prcSrc)
{
    *prcDest = *prcSrc;
}

__inline DWORD
EqualRectInl(LPCRECT prc1, LPCRECT prc2)
{
    return RtlEqualMemory(prc1, prc2, sizeof(*prc1));
}

__inline void
SetRectEmptyInl(LPRECT prc)
{
    RtlZeroMemory(prc, sizeof(*prc));
}

/***************************************************************************\
* ANSI/Unicode function names
*
* For non-API Client/Server stubs, an "A" or "W" suffix must be added.
* (API function names are generated by running wcshdr.exe over winuser.x)
*
\***************************************************************************/
#ifdef UNICODE
    #define TEXT_FN(fn) fn##W
#else // UNICODE
    #define TEXT_FN(fn) fn##A
#endif // UNICODE

#ifdef UNICODE
    #define BYTESTOCHARS(cb) ((cb) / sizeof(TCHAR))
    #define CHARSTOBYTES(cch) ((cch) * sizeof(TCHAR))
#else // UNICODE
    #define BYTESTOCHARS(cb) (cb)
    #define CHARSTOBYTES(cch) (cch)
#endif // UNICODE

/*
 * Internal window class names
 */
#define DESKTOPCLASS    MAKEINTATOM(0x8001)
#define DIALOGCLASS     MAKEINTATOM(0x8002)
#define SWITCHWNDCLASS  MAKEINTATOM(0x8003)
#define ICONTITLECLASS  MAKEINTATOM(0x8004)
#define INFOCLASS       MAKEINTATOM(0x8005)
#define TOOLTIPCLASS    MAKEINTATOM(0x8006)
#define GHOSTCLASS      MAKEINTATOM(0x8007)
#define MENUCLASS       MAKEINTATOM(0x8000)     /* Public Knowledge */

//
// System timer IDs
//
#define IDSYS_LAYER         0x0000FFF5L
#define IDSYS_FADE          0x0000FFF6L
#define IDSYS_WNDTRACKING   0x0000FFF7L
#define IDSYS_FLASHWND      0x0000FFF8L
#define IDSYS_MNAUTODISMISS 0x0000FFF9L
#define IDSYS_MOUSEHOVER    0x0000FFFAL
#define IDSYS_MNANIMATE     0x0000FFFBL
#define IDSYS_MNDOWN        MFMWFP_DOWNARROW /* 0xFFFFFFFC */
#define IDSYS_LBSEARCH      0x0000FFFCL
#define IDSYS_MNUP          MFMWFP_UPARROW   /* 0xFFFFFFFD */
#define IDSYS_STANIMATE     0x0000FFFDL
#define IDSYS_MNSHOW        0x0000FFFEL
#define IDSYS_SCROLL        0x0000FFFEL
#define IDSYS_MNHIDE        0x0000FFFFL
#define IDSYS_CARET         0x0000FFFFL


/*
 * Special case string token codes.  These must be the same as in the resource
 * compiler's RC.H file.
 */
/*
 * NOTE: Order is assumed and much be this way for applications to be
 * compatable with windows 2.0
 */
#define CODEBIT             0x80
#define BUTTONCODE          0x80
#define EDITCODE            0x81
#define STATICCODE          0x82
#define LISTBOXCODE         0x83
#define SCROLLBARCODE       0x84
#define COMBOBOXCODE        0x85
#define MDICLIENTCODE       0x86
#define COMBOLISTBOXCODE    0x87

/*
 * Internal window classes. These numbers serve as indices into the
 * atomSysClass table so that we can get the atoms for the various classes.
 * The order of the control classes (through COMBOLISTBOXCLASS) is assumed
 * to be the same as the class codes above.
 */
#define ICLS_BUTTON         0
#define ICLS_EDIT           1
#define ICLS_STATIC         2
#define ICLS_LISTBOX        3
#define ICLS_SCROLLBAR      4
#define ICLS_COMBOBOX       5       // End of special dlgmgr indices

#define ICLS_MDICLIENT      6
#define ICLS_COMBOLISTBOX   7
#define ICLS_DDEMLEVENT     8
#define ICLS_DDEMLMOTHER    9
#define ICLS_DDEML16BIT     10
#define ICLS_DDEMLCLIENTA   11
#define ICLS_DDEMLCLIENTW   12
#define ICLS_DDEMLSERVERA   13
#define ICLS_DDEMLSERVERW   14
#define ICLS_IME            15

#define ICLS_CTL_MAX        16       // Number of public control classes


#define ICLS_DESKTOP        16
#define ICLS_DIALOG         17
#define ICLS_MENU           18
#define ICLS_SWITCH         19
#define ICLS_ICONTITLE      20
#define ICLS_TOOLTIP        21
#define ICLS_GHOST          22
#define ICLS_MAX            23  // Number of system classes

/*
 * Directory name for windowstations and desktops
 */
#define WINSTA_DIR  L"\\Windows\\WindowStations"
#define WINSTA_SESSION_DIR  L"\\Sessions\\xxxxxxxxxxx\\Windows\\WindowStations"
#define WINSTA_NAME L"Service-0x0000-0000$"
#define MAX_SESSION_PATH   256
#define SESSION_ROOT L"\\Sessions"

/***************************************************************************\
* Normal Stuff
*
* Nice normal typedefs, defines, prototypes, etc that everyone wants to share.
*
\***************************************************************************/

/*
 * Define size limit of callback data. Below or equal to this limit, put data
 * on the client-side stack. Above this limit allocate virtual memory
 * for the data.
 */
#define CALLBACKSTACKLIMIT  (KERNEL_PAGE_SIZE / 2)

/*
 * Capture buffer definition for callbacks.
 */
typedef struct _CAPTUREBUF {
    DWORD cbCallback;
    DWORD cbCapture;
    DWORD cCapturedPointers;
    PBYTE pbFree;
    DWORD offPointers;
    PVOID pvVirtualAddress;
} CAPTUREBUF, *PCAPTUREBUF;

/*
 * Callback return status
 */
typedef struct _CALLBACKSTATUS {
    KERNEL_ULONG_PTR retval;
    DWORD cbOutput;
    KERNEL_PVOID pOutput;
} CALLBACKSTATUS, *PCALLBACKSTATUS;

#define IS_PTR(p)       ((((ULONG_PTR)(p)) & ~MAXUSHORT) != 0)
#define PTR_TO_ID(p)    ((USHORT)(((ULONG_PTR)(p)) & MAXUSHORT))

//
// Strings are counted 16-bit character strings. If they are
// NULL terminated, Length does not include trailing NULL.
//
typedef struct _LARGE_STRING {
    ULONG Length;
    ULONG MaximumLength : 31;
    ULONG bAnsi : 1;
    KERNEL_PVOID Buffer;
} LARGE_STRING, *PLARGE_STRING;

typedef struct _LARGE_ANSI_STRING {
    ULONG Length;
    ULONG MaximumLength : 31;
    ULONG bAnsi : 1;
    KPSTR Buffer;
} LARGE_ANSI_STRING, *PLARGE_ANSI_STRING;

typedef struct _LARGE_UNICODE_STRING {
    ULONG Length;
    ULONG MaximumLength : 31;
    ULONG bAnsi : 1;
    KPWSTR Buffer;
} LARGE_UNICODE_STRING, *PLARGE_UNICODE_STRING;

/*
 * String macros
 */
__inline BOOL IsEmptyString(PVOID p, ULONG bAnsi)
{
    return (BOOL)!(bAnsi ? *(LPSTR)p : *(LPWSTR)p);
}
__inline void NullTerminateString(PVOID p, ULONG bAnsi)
{
    if (bAnsi) *(LPSTR)p = (CHAR)0; else *(LPWSTR)p = (WCHAR)0;
}
__inline UINT StringLength(PVOID p, ULONG bAnsi)
{
    return (bAnsi ? strlen((LPSTR)p) : wcslen((LPWSTR)p));
}

typedef struct _CTLCOLOR {
    COLORREF crText;
    COLORREF crBack;
    int iBkMode;
} CTLCOLOR, *PCTLCOLOR;


/*
 * This is used by the cool client side DrawIcon code
 */
typedef struct _DRAWICONEXDATA {
    HBITMAP hbmMask;
    HBITMAP hbmColor;
    int cx;
    int cy;
    HBITMAP hbmUserAlpha;
} DRAWICONEXDATA;

/*
 * Static items stored in the TEB
 */
typedef struct _CALLBACKWND {
    KHWND               hwnd;
    PWND                pwnd;
    PACTIVATION_CONTEXT pActCtx;
} CALLBACKWND, *PCALLBACKWND;

#define CVKKEYCACHE                 32
#define CBKEYCACHE                  (CVKKEYCACHE >> 2)

#define CVKASYNCKEYCACHE            32
#define CBASYNCKEYCACHE             (CVKASYNCKEYCACHE >> 2)

/*
 * The offset to cSpins must match WIN32_CLIENT_INFO_SPIN_COUNT defined
 * in ntpsapi.h. GDI uses this offset to reset the spin count. WARNING!
 * This struct must fit in the TEB::Win32ClientInfo field.
 */
typedef struct tagCLIENTINFO {
    KERNEL_ULONG_PTR    CI_flags;           // Needs to be first because CSR sets this
    KERNEL_ULONG_PTR    cSpins;             // GDI resets this
    DWORD               dwExpWinVer;
    DWORD               dwCompatFlags;
    DWORD               dwCompatFlags2;
    DWORD               dwTIFlags;
    PDESKTOPINFO        pDeskInfo;
    KERNEL_ULONG_PTR    ulClientDelta;
    PHOOK               phkCurrent;
    DWORD               fsHooks;
    CALLBACKWND         CallbackWnd;
    DWORD               dwHookCurrent;
    int                 cInDDEMLCallback;
    PCLIENTTHREADINFO   pClientThreadInfo;
    KERNEL_ULONG_PTR    dwHookData;
    DWORD               dwKeyCache;
    BYTE                afKeyState[CBKEYCACHE];
    DWORD               dwAsyncKeyCache;
    BYTE                afAsyncKeyState[CBASYNCKEYCACHE];
    BYTE                afAsyncKeyStateRecentDown[CBASYNCKEYCACHE];
    KHKL                hKL;
    WORD                CodePage;

    BYTE                achDbcsCF[2]; // Save ANSI DBCS LeadByte character code
                                      // in this field for ANSI to Unicode.
                                      // Uses SendMessageA/PostMessageA from CLIENT
                                      // to SERVER (index 0)
                                      //  And...
                                      // Uses SendMessageA/DispatchMessageA
                                      // for CLIENT to CLIENT (index 1)
    KERNEL_MSG          msgDbcsCB;    // Save ANSI DBCS character message in
                                      // this field for convert Unicode to ANSI.
                                      // Uses GetMessageA/PeekMessageA from
                                      // SERVER to CLIENT
    LPBOOL              lpClassesRegistered;
} CLIENTINFO, *PCLIENTINFO;


#define CI_IN_SYNC_TRANSACTION 0x00000001
#define CI_PROCESSING_QUEUE    0x00000002
#define CI_16BIT               0x00000004
#define CI_INITIALIZED         0x00000008
#define CI_INTERTHREAD_HOOK    0x00000010
#define CI_REGISTERCLASSES     0x00000020
#define CI_INPUTCONTEXT_REINIT 0x00000040

#ifdef CUAS_ENABLE
#define CI_CUAS_COINIT_CALLED  0x00000080 /* CoInit is called for CUAS */
#define CI_CUAS_TIM_ACTIVATED  0x00000100 /* Tim activate for CUAS */
#define CI_CUAS_MSCTF_RUNNING  0x00000200 /* Msctf (hooks) is running in the thread */
#define CI_CUAS_DISABLE        0x00000400 /* Disable CUAS on thread */
#define CI_CUAS_AIMM12ACTIVATED  0x00000800
#endif // CUAS_ENABLE

/*
 * THREAD_CODEPAGE()
 *
 * Returns the CodePage based on the current keyboard layout.
 */
#ifndef _USERK_
#define THREAD_CODEPAGE() (GetClientInfo()->CodePage)
#endif // _USERK_

// WMCR_IR_DBCSCHAR and DBCS Macros
/*
 * Flags used for the WM_CHAR  HIWORD of wParam for DBCS messaging.
 *  (LOWORD of wParam will have character codepoint)
 */
#define WMCR_IR_DBCSCHAR       0x80000000
/*
 * Macros to determine this is DBCS message or not.
 */
#define IS_DBCS_MESSAGE(DbcsChar) (((DWORD)(DbcsChar)) & 0x0000FF00)

/*
 * Macros for IR_DBCSCHAR format to/from regular format.
 */
#define MAKE_IR_DBCSCHAR(DbcsChar) \
        (IS_DBCS_MESSAGE((DbcsChar)) ?                                     \
            (MAKEWPARAM(MAKEWORD(HIBYTE((DbcsChar)),LOBYTE((DbcsChar))),0)) : \
            ((WPARAM)((DbcsChar) & 0x00FF))                                   \
        )

#define MAKE_WPARAM_DBCSCHAR(DbcsChar) \
        (IS_DBCS_MESSAGE((DbcsChar)) ?                                     \
            (MAKEWPARAM(MAKEWORD(HIBYTE((DbcsChar)),LOBYTE((DbcsChar))),0)) : \
            ((WPARAM)((DbcsChar) & 0x00FF))                                   \
        )

#define DBCS_CHARSIZE   (2)

#define IS_DBCS_ENABLED()  (TEST_SRVIF(SRVIF_DBCS))
#define _IS_IME_ENABLED()  (TEST_SRVIF(SRVIF_IME))
#ifdef _IMMCLI_
    #define IS_IME_ENABLED()   (gpsi && _IS_IME_ENABLED())
#else   // _IMMCLI_
    #define IS_IME_ENABLED()   _IS_IME_ENABLED()
#endif  // _IMMCLI_

#ifdef CUAS_ENABLE

#define _IS_CICERO_ENABLED()   (TEST_SRVIF(SRVIF_CTFIME_ENABLED))
#ifdef _IMMCLI_
    #define IS_CICERO_ENABLED() (gpsi && _IS_CICERO_ENABLED())
    #define IS_CICERO_ENABLED_AND_NOT16BIT() \
                                (IS_CICERO_ENABLED() && !(GetClientInfo()->dwTIFlags & TIF_16BIT))
#else  // _IMMCLI_
    #define IS_CICERO_ENABLED() _IS_CICERO_ENABLED()
    #define IS_CICERO_ENABLED_AND_NOT16BIT() \
                                (IS_CICERO_ENABLED() && !(PtiCurrent()->TIF_flags & TIF_16BIT))
#endif // _IMMCLI_

#endif // CUAS_ENABLE

#ifndef IS_IME_KBDLAYOUT
#define IS_IME_KBDLAYOUT(hkl) ((HIWORD((ULONG_PTR)(hkl)) & 0xf000) == 0xe000)
#endif


#define CP_JAPANESE     (932)
#define CP_KOREAN       (949)
#define CP_CHINESE_SIMP (936)
#define CP_CHINESE_TRAD (950)

#define IS_DBCS_CODEPAGE(wCodePage) \
            ((wCodePage) == CP_JAPANESE || \
             (wCodePage) == CP_KOREAN || \
             (wCodePage) == CP_CHINESE_TRAD || \
             (wCodePage) == CP_CHINESE_SIMP)

#define IS_DBCS_CHARSET(charset) \
            ((charset) == SHIFTJIS_CHARSET || \
             (charset) == HANGEUL_CHARSET || \
             (charset) == CHINESEBIG5_CHARSET || \
             (charset) == GB2312_CHARSET)

#define IS_JPN_1BYTE_KATAKANA(c)   ((c) >= 0xa1 && (c) <= 0xdf)

/*
 * Dynamic layout switching
 */

typedef struct tagKBDTABLE_MULT_INTERNAL {
    KBDTABLE_MULTI multi;
    WCHAR wszDllName[32];   // main dll name
    struct {
        KHANDLE hFile;
        WORD wTable;
        WORD wNls;
    } files[KBDTABLE_MULTI_MAX];
} KBDTABLE_MULTI_INTERNAL, *PKBDTABLE_MULTI_INTERNAL;

// IMM dynamic loading support
#define IMM_MAGIC_CALLER_ID     (0x19650412)

BOOL User32InitializeImmEntryTable(DWORD dwMagic);

#define IS_MIDEAST_ENABLED()   (TEST_SRVIF(SRVIF_MIDEAST))

/*
 * Flags used for the WM_CLIENTSHUTDOWN wParam.
 */
#define WMCS_EXIT             0x0001
#define WMCS_QUERYEND         0x0002
#define WMCS_SHUTDOWN         0x0004
#define WMCS_CONTEXTLOGOFF    0x0008
#define WMCS_ENDTASK          0x0010
#define WMCS_CONSOLE          0x0020
#define WMCS_NODLGIFHUNG      0x0040
#define WMCS_NORETRY          0x0080
#define WMCS_LOGOFF           ENDSESSION_LOGOFF  /* from winuser.w */

/*
 * WM_CLIENTSHUTDOWN return value
 */
#define WMCSR_ALLOWSHUTDOWN     1
#define WMCSR_DONE              2
#define WMCSR_CANCEL            3

/*
 * We don't need 64-bit intermediate precision so we use this macro
 * instead of calling MulDiv.
 */
#define MultDiv(x, y, z)        (((INT)(x) * (INT)(y) + (INT)(z) / 2) / (INT)(z))

typedef DWORD ICH, *LPICH;

typedef struct _PROPSET {
    KHANDLE hData;
    ATOM atom;
} PROPSET, *PPROPSET;

/*
 * Internal menu flags stored in pMenu->fFlags.
 * High order bits are used for public MNS_ flags defined in winuser.w
 */
#define MFISPOPUP               0x00000001
#define MFMULTIROW              0x00000002
#define MFUNDERLINE             0x00000004
#define MFWINDOWDC              0x00000008  /* Window DC vs Client area DC when drawing*/
#define MFINACTIVE              0x00000010
#define MFRTL                   0x00000020
#define MFDESKTOP               0x00000040 /* Set on the desktop menu AND its submenus */
#define MFSYSMENU               0x00000080 /* Set on desktop menu but NOT on its submenus */
#define MFAPPSYSMENU            0x00000100 /* Set on (sub)menu we return to the app via GetSystemMenu */
#define MFREADONLY              0x00000200 /* Menu cannot be modified */
#define MFLAST                  0x00000200

#if (MNS_LAST <= MFLAST)
    #error MNS_ AND MF defines conflict
#endif // (MNS_LAST <= MFLAST)

// Event stuff --------------------------------------------

typedef struct tagEVENT_PACKET {
    DWORD EventType;    // == apropriate afCmd filter flag
    WORD  fSense;       // TRUE means flag on is passed.
    WORD  cbEventData;  // size of data starting at Data field.
    DWORD Data;         // event specific data - must be last
} EVENT_PACKET, *PEVENT_PACKET;

// Window long offsets in mother window     (szDDEMLMOTHERCLASS)

#define GWLP_INSTANCE_INFO  0       // PCL_INSTANCE_INFO


// Window long offsets in client window     (szDDEMLCLIENTCLASS)

#define GWLP_PCI            0
#define GWL_CONVCONTEXT     GWLP_PCI + sizeof(PVOID)
#define GWL_CONVSTATE       GWL_CONVCONTEXT + sizeof(CONVCONTEXT)   // See CLST_ flags
#define GWLP_SHINST         GWL_CONVSTATE + sizeof(LONG)
#define GWLP_CHINST         GWLP_SHINST + sizeof(HANDLE)

#define CLST_CONNECTED              0
#define CLST_SINGLE_INITIALIZING    1
#define CLST_MULT_INITIALIZING      2

// Window long offsets in server window     (szDDEMLSERVERCLASS)

#define GWLP_PSI            0

// Window long offsets in event window      (szDDEMLEVENTCLASS)

#define GWLP_PSII           0


/*
 * DrawFrame defines
 */
#define DF_SHIFT0           0x0000
#define DF_SHIFT1           0x0001
#define DF_SHIFT2           0x0002
#define DF_SHIFT3           0x0003
#define DF_PATCOPY          0x0000
#define DF_PATINVERT        0x0004
#define DF_SHIFTMASK (DF_SHIFT0 | DF_SHIFT1 | DF_SHIFT2 | DF_SHIFT3)
#define DF_ROPMASK   (DF_PATCOPY | DF_PATINVERT)
#define DF_HBRMASK   ~(DF_SHIFTMASK | DF_ROPMASK)

#define DF_SCROLLBAR        (COLOR_SCROLLBAR << 3)
#define DF_BACKGROUND       (COLOR_BACKGROUND << 3)
#define DF_ACTIVECAPTION    (COLOR_ACTIVECAPTION << 3)
#define DF_INACTIVECAPTION  (COLOR_INACTIVECAPTION << 3)
#define DF_MENU             (COLOR_MENU << 3)
#define DF_WINDOW           (COLOR_WINDOW << 3)
#define DF_WINDOWFRAME      (COLOR_WINDOWFRAME << 3)
#define DF_MENUTEXT         (COLOR_MENUTEXT << 3)
#define DF_WINDOWTEXT       (COLOR_WINDOWTEXT << 3)
#define DF_CAPTIONTEXT      (COLOR_CAPTIONTEXT << 3)
#define DF_ACTIVEBORDER     (COLOR_ACTIVEBORDER << 3)
#define DF_INACTIVEBORDER   (COLOR_INACTIVEBORDER << 3)
#define DF_APPWORKSPACE     (COLOR_APPWORKSPACE << 3)
#define DF_3DSHADOW         (COLOR_3DSHADOW << 3)
#define DF_3DFACE           (COLOR_3DFACE << 3)
#define DF_GRAY             (COLOR_MAX << 3)


/*
 * CreateWindowEx internal flags for dwExStyle
 */

#define WS_EX_MDICHILD      0x00000040L         // Internal
#define WS_EX_ANSICREATOR   0x80000000L         // Internal

/*
 * These flags are used in the internal version of NtUserFindWindowEx
 */
#define FW_BOTH 0
#define FW_16BIT 1
#define FW_32BIT 2

/*
 * Calculate the size of a field in a structure of type type.
 */
#define FIELD_SIZE(type, field)     (sizeof(((type *)0)->field))

#define FLASTKEY 0x80

/*
 * Special types we've fabricated for special thunks.
 */
typedef struct {
    POINT point1;
    POINT point2;
    POINT point3;
    POINT point4;
    POINT point5;
} POINT5, *LPPOINT5;

typedef struct {
    DWORD dwRecipients;
    DWORD dwFlags;
    BSMINFO;
} BROADCASTSYSTEMMSGPARAMS, *LPBROADCASTSYSTEMMSGPARAMS;
/*
 * Server side address constants. When we want to call a server side proc,
 * we pass an index indentifying the function, rather than the server side
 * address itself. More robust.  The functions between WNDPROCSTART/END
 * have client side stubs which map to this routines.
 *
 * Adding a new FNID (This is just what I figured out...so fix it if wrong or incomplete)
 * -Decide what range it should be in:
 *      FNID_WNDPROCSTART to FNID_WNDPROCEND: Server side proc with client
 *          stub
 *      FIND_CONTROLSTART to FNID_CONTROLEND: Client side controls with no
 *          server side proc
 *      After FNID_CONTROLEND: other, like server side only procs or client
 *          side only....
 * -Make sure to adjust FNID_*START and FNID_*END appropriately here and in wowuserp.w.
 * -If the ID is to be associated with a window class, and it is for all
 *      windows of that class, make sure that the InternalRegisterClassEx call
 *      receives the id as a parameter.
 * -If in FNID_WNDPROCSTART-END range, make the proper STOCID call in InitFunctionTables.
 * -Add proper FNID call in InitFunctionTables.
 * -If the class has a client side worker function (pcls->lpfnWorker) or you expect
 *   apps to send messages to it or call its window proc directly, define
 *   a message table in kernel\server.c and initialize it in InitMessageTables.
 * -Add a new entry to the PFNCLIENT and matching entries in clinet\clinet.c pfnClientA and
 *   pfnClientW arrays.
 * -Add the debug-only text description of this FNID to in gapszFNID in globals.c
 * -Modify aiClassWow in client\client.c
 * -Modify the gaFNIDtoICLS table in kernel\ntstubs.c
 */
#define FNID_START                  0x0000029A
#define FNID_WNDPROCSTART           0x0000029A

#define FNID_SCROLLBAR              0x0000029A      // xxxSBWndProc;
#define FNID_ICONTITLE              0x0000029B      // xxxDefWindowProc;
#define FNID_MENU                   0x0000029C      // xxxMenuWindowProc;
#define FNID_DESKTOP                0x0000029D      // xxxDesktopWndProc;
#define FNID_DEFWINDOWPROC          0x0000029E      // xxxDefWindowProc;
#define FNID_MESSAGEWND             0x0000029F      // xxxDefWindowProc;
#define FNID_SWITCH                 0x000002A0      // xxxSwitchWndProc

#define FNID_WNDPROCEND             0x000002A0      // see PatchThreadWindows
#define FNID_CONTROLSTART           0x000002A1

#define FNID_BUTTON                 0x000002A1      // No server side proc
#define FNID_COMBOBOX               0x000002A2      // No server side proc
#define FNID_COMBOLISTBOX           0x000002A3      // No server side proc
#define FNID_DIALOG                 0x000002A4      // No server side proc
#define FNID_EDIT                   0x000002A5      // No server side proc
#define FNID_LISTBOX                0x000002A6      // No server side proc
#define FNID_MDICLIENT              0x000002A7      // No server side proc
#define FNID_STATIC                 0x000002A8      // No server side proc

#define FNID_IME                    0x000002A9      // No server side proc
#define FNID_CONTROLEND             0x000002A9

#define FNID_HKINLPCWPEXSTRUCT      0x000002AA
#define FNID_HKINLPCWPRETEXSTRUCT   0x000002AB
#define FNID_DEFFRAMEPROC           0x000002AC      // No server side proc
#define FNID_DEFMDICHILDPROC        0x000002AD      // No server side proc
#define FNID_MB_DLGPROC             0x000002AE      // No server side proc
#define FNID_MDIACTIVATEDLGPROC     0x000002AF      // No server side proc
#define FNID_SENDMESSAGE            0x000002B0

#define FNID_SENDMESSAGEFF          0x000002B1
#define FNID_SENDMESSAGEEX          0x000002B2
#define FNID_CALLWINDOWPROC         0x000002B3
#define FNID_SENDMESSAGEBSM         0x000002B4
#define FNID_TOOLTIP                0x000002B5
#define FNID_GHOST                  0x000002B6

#define FNID_SENDNOTIFYMESSAGE      0x000002B7
#define FNID_SENDMESSAGECALLBACK    0x000002B8

#define FNID_END                    0x000002B8

/*
 * The size of the server side function table is defined as a power of two
 * so a simple "and" operation can be used to determine if a function index
 * is legal or not. Unused entries in the table are fill with a routine that
 * catches invalid functions that have indices within range, but are not
 * implemented.
 */

#define FNID_ARRAY_SIZE             32

#if (FNID_END - FNID_START + 1) > FNID_ARRAY_SIZE
    #error"The size of the function array is greater than the allocated storage"
#endif // (FNID_END - FNID_START + 1) > FNID_ARRAY_SIZE

#define FNID_DDE_BIT                0x00002000    // Used by RegisterClassExWOW
#define FNID_CLEANEDUP_BIT          0x00004000
#define FNID_DELETED_BIT            0x00008000
#define FNID_STATUS_BITS            (FNID_CLEANEDUP_BIT | FNID_DELETED_BIT)

#define FNID(s)     (gpsi->mpFnidPfn[((DWORD)(s) - FNID_START) & (FNID_ARRAY_SIZE - 1)])
#define STOCID(s)   (gpsi->aStoCidPfn[(DWORD)((s) & ~FNID_STATUS_BITS) - FNID_START])
#define CBFNID(s)   (gpsi->mpFnid_serverCBWndProc[(DWORD)((s) & ~FNID_STATUS_BITS) - FNID_START])
#define GETFNID(pwnd)       ((pwnd)->fnid & ~FNID_STATUS_BITS)

#ifndef BUILD_WOW6432
typedef LRESULT (APIENTRY * WNDPROC_PWND)(PWND, UINT, WPARAM, LPARAM);
typedef LRESULT (APIENTRY * WNDPROC_PWNDEX)(PWND, UINT, WPARAM, LPARAM, ULONG_PTR);
#else
typedef KERNEL_PVOID WNDPROC_PWND;
typedef KERNEL_PVOID WNDPROC_PWNDEX;
#endif
typedef BOOL (APIENTRY * WNDENUMPROC_PWND)(PWND, LPARAM);
typedef VOID (APIENTRY * TIMERPROC_PWND)(PWND, UINT, UINT_PTR, LPARAM);

/*
 * Structure passed by client during process initialization that holds some
 * client-side callback addresses.
 */
typedef struct _PFNCLIENT {
    KPROC pfnScrollBarWndProc;       // and must be paired Unicode then ANSI
    KPROC pfnTitleWndProc;
    KPROC pfnMenuWndProc;
    KPROC pfnDesktopWndProc;
    KPROC pfnDefWindowProc;
    KPROC pfnMessageWindowProc;
    KPROC pfnSwitchWindowProc;

// Below not in FNID_WNDPROCSTART FNID_WNDPROCEND range

    KPROC pfnButtonWndProc;
    KPROC pfnComboBoxWndProc;
    KPROC pfnComboListBoxProc;
    KPROC pfnDialogWndProc;
    KPROC pfnEditWndProc;
    KPROC pfnListBoxWndProc;
    KPROC pfnMDIClientWndProc;
    KPROC pfnStaticWndProc;
    KPROC pfnImeWndProc;

// Below not in FNID_CONTROLSTART FNID_CONTROLEND range

    KPROC pfnHkINLPCWPSTRUCT;    // client-side callback for hook thunks
    KPROC pfnHkINLPCWPRETSTRUCT; // client-side callback for hook thunks
    KPROC pfnDispatchHook;
    KPROC pfnDispatchDefWindowProc;
    KPROC pfnDispatchMessage;
    KPROC pfnMDIActivateDlgProc;
} PFNCLIENT, *PPFNCLIENT;

typedef struct _PFNCLIENTWORKER {
    KPROC pfnButtonWndProc;
    KPROC pfnComboBoxWndProc;
    KPROC pfnComboListBoxProc;
    KPROC pfnDialogWndProc;
    KPROC pfnEditWndProc;
    KPROC pfnListBoxWndProc;
    KPROC pfnMDIClientWndProc;
    KPROC pfnStaticWndProc;
    KPROC pfnImeWndProc;
} PFNCLIENTWORKER, *PPFNCLIENTWORKER;

#ifdef BUILD_WOW6432

extern const PFNCLIENT   pfnClientA;
extern const PFNCLIENT   pfnClientW;
extern const PFNCLIENTWORKER   pfnClientWorker;

#define FNID_TO_CLIENT_PFNA_CLIENT(s) ((ULONG_PTR)(*(((KERNEL_ULONG_PTR *)&pfnClientA) + (s - FNID_START))))
#define FNID_TO_CLIENT_PFNW_CLIENT(s) ((ULONG_PTR)(*(((KERNEL_ULONG_PTR *)&pfnClientW) + (s - FNID_START))))
#define FNID_TO_CLIENT_PFNWORKER(s)   ((ULONG_PTR)(*(((KERNEL_ULONG_PTR *)&pfnClientWorker) + (s - FNID_CONTROLSTART))))

WNDPROC_PWND MapKernelClientFnToClientFn(WNDPROC_PWND lpfnWndProc);

#else

#define FNID_TO_CLIENT_PFNA_CLIENT FNID_TO_CLIENT_PFNA_KERNEL
#define FNID_TO_CLIENT_PFNW_CLIENT FNID_TO_CLIENT_PFNW_KERNEL
#define FNID_TO_CLIENT_PFNWORKER(s) (*(((KERNEL_ULONG_PTR *)&gpsi->apfnClientWorker) + (s - FNID_CONTROLSTART)))

#define MapKernelClientFnToClientFn(lpfnWndProc) (lpfnWndProc)

#endif

#define FNID_TO_CLIENT_PFNA_KERNEL(s) (*(((KERNEL_ULONG_PTR * KPTR_MODIFIER)&gpsi->apfnClientA) + (s - FNID_START)))
#define FNID_TO_CLIENT_PFNW_KERNEL(s) (*(((KERNEL_ULONG_PTR * KPTR_MODIFIER)&gpsi->apfnClientW) + (s - FNID_START)))

#define FNID_TO_CLIENT_PFNA FNID_TO_CLIENT_PFNA_KERNEL
#define FNID_TO_CLIENT_PFNW FNID_TO_CLIENT_PFNW_KERNEL

/*
 * Object types
 *
 * NOTE: Changing this table means changing hard-coded arrays that depend
 * on the index number (in security.c and in debug.c)
 */
#define TYPE_FREE           0           // must be zero!
#define TYPE_WINDOW         1           // in order of use for C code lookups
#define TYPE_MENU           2
#define TYPE_CURSOR         3
#define TYPE_SETWINDOWPOS   4
#define TYPE_HOOK           5
#define TYPE_CLIPDATA       6           // clipboard data
#define TYPE_CALLPROC       7
#define TYPE_ACCELTABLE     8
#define TYPE_DDEACCESS      9
#define TYPE_DDECONV        10
#define TYPE_DDEXACT        11          // DDE transaction tracking info.
#define TYPE_MONITOR        12
#define TYPE_KBDLAYOUT      13          // Keyboard Layout handle (HKL) object.
#define TYPE_KBDFILE        14          // Keyboard Layout file object.
#define TYPE_WINEVENTHOOK   15          // WinEvent hook (EVENTHOOK)
#define TYPE_TIMER          16
#define TYPE_INPUTCONTEXT   17          // Input Context info structure
#define TYPE_HIDDATA        18
#define TYPE_DEVICEINFO     19

#define TYPE_CTYPES         20          // Count of TYPEs; Must be LAST + 1

#define TYPE_GENERIC        255         // used for generic handle validation

/* OEM Bitmap Information Structure */
typedef struct tagOEMBITMAPINFO
{
    int     x;
    int     y;
    int     cx;
    int     cy;
} OEMBITMAPINFO, * KPTR_MODIFIER POEMBITMAPINFO;

// For the following OBI_ defines :
//
// a  pushed   state bitmap should be at +1 from it's normal state bitmap
// an inactive state bitmap should be at +2 from it's normal state bitmap
// A small caption bitmap should be +2 from the normal bitmap

#define DOBI_NORMAL         0
#define DOBI_PUSHED         1
#define DOBI_HOT            2
#define DOBI_INACTIVE       3

#define DOBI_CHECK      1   // checkbox/radio/3state button states
#define DOBI_DOWN       2
#define DOBI_CHECKDOWN  3

#define DOBI_CAPON      0   // caption states
#define DOBI_CAPOFF     1

// shared bitmap mappings
#define DOBI_3STATE         8   // offset from checkbox to 3state
#define DOBI_MBAR OBI_CLOSE_MBAR    // offset to menu bar equivalent

#define OBI_CLOSE            0      // caption close button
#define OBI_CLOSE_D          1
#define OBI_CLOSE_H          2
#define OBI_CLOSE_I          3
#define OBI_REDUCE           4      // caption minimize button
#define OBI_REDUCE_D         5
#define OBI_REDUCE_H         6
#define OBI_REDUCE_I         7
#define OBI_RESTORE          8      // caption restore button
#define OBI_RESTORE_D        9
#define OBI_RESTORE_H       10
#define OBI_HELP            11
#define OBI_HELP_D          12
#define OBI_HELP_H          13
#define OBI_ZOOM            14      // caption maximize button
#define OBI_ZOOM_D          15
#define OBI_ZOOM_H          16
#define OBI_ZOOM_I          17
#define OBI_CLOSE_MBAR      18      // menu bar close button
#define OBI_CLOSE_MBAR_D    19
#define OBI_CLOSE_MBAR_H    20
#define OBI_CLOSE_MBAR_I    21
#define OBI_REDUCE_MBAR     22      // menu bar minimize button
#define OBI_REDUCE_MBAR_D   23
#define OBI_REDUCE_MBAR_H   24
#define OBI_REDUCE_MBAR_I   25
#define OBI_RESTORE_MBAR    26      // menu bar restore button
#define OBI_RESTORE_MBAR_D  27
#define OBI_RESTORE_MBAR_H  28
#define OBI_CAPCACHE1       29      // caption icon cache entry #1
#define OBI_CAPCACHE1_I     30
#define OBI_CAPCACHE2       31      // caption icon cache entry #2
#define OBI_CAPCACHE2_I     32
#define OBI_CAPCACHE3       33      // caption icon cache entry #3
#define OBI_CAPCACHE3_I     34
#define OBI_CAPCACHE4       35      // caption icon cache entry #4
#define OBI_CAPCACHE4_I     36
#define OBI_CAPCACHE5       37      // caption icon cache entry #5
#define OBI_CAPCACHE5_I     38
#define OBI_CAPBTNS         39      // caption buttons cache
#define OBI_CAPBTNS_I       40
#define OBI_CLOSE_PAL       41      // small caption close button
#define OBI_CLOSE_PAL_D     42
#define OBI_CLOSE_PAL_H     43
#define OBI_CLOSE_PAL_I     44
#define OBI_NCGRIP          45      // bottom/right size grip
#define OBI_UPARROW         46      // up scroll arrow
#define OBI_UPARROW_D       47
#define OBI_UPARROW_H       48
#define OBI_UPARROW_I       49
#define OBI_DNARROW         50      // down scroll arrow
#define OBI_DNARROW_D       51
#define OBI_DNARROW_H       52
#define OBI_DNARROW_I       53
#define OBI_RGARROW         54      // right scroll arrow
#define OBI_RGARROW_D       55
#define OBI_RGARROW_H       56
#define OBI_RGARROW_I       57
#define OBI_LFARROW         58      // left scroll arrow
#define OBI_LFARROW_D       59
#define OBI_LFARROW_H       60
#define OBI_LFARROW_I       61
#define OBI_MENUARROW       62      // menu hierarchy arrow
#define OBI_MENUCHECK       63      // menu check mark
#define OBI_MENUBULLET      64      // menu bullet mark
#define OBI_MENUARROWUP     65
#define OBI_MENUARROWUP_H   66
#define OBI_MENUARROWUP_I   67
#define OBI_MENUARROWDOWN   68
#define OBI_MENUARROWDOWN_H 69
#define OBI_MENUARROWDOWN_I 70
#define OBI_RADIOMASK       71      // radio button mask
#define OBI_CHECK           72      // check box
#define OBI_CHECK_C         73
#define OBI_CHECK_D         74
#define OBI_CHECK_CD        75
#define OBI_CHECK_CDI       76
#define OBI_RADIO           77      // radio button
#define OBI_RADIO_C         78
#define OBI_RADIO_D         79
#define OBI_RADIO_CD        80
#define OBI_RADIO_CDI       81
#define OBI_3STATE          82      // 3-state button
#define OBI_3STATE_C        83
#define OBI_3STATE_D        84
#define OBI_3STATE_CD       85
#define OBI_3STATE_CDI      86
#define OBI_POPUPFIRST      87      // System popupmenu bitmaps.
#define OBI_CLOSE_POPUP     87
#define OBI_RESTORE_POPUP   88
#define OBI_ZOOM_POPUP      89
#define OBI_REDUCE_POPUP    90
#define OBI_NCGRIP_L        91
#define OBI_MENUARROW_L     92
#define OBI_COUNT           93      // bitmap count

/*
 * One global instance of this structure is allocated into memory that is
 * mapped into all clients' address space.  Client-side functions will
 * read this data to avoid calling the server.
 */

#define NCHARS   256
#define NCTRLS   0x20

#define PUSIF_PALETTEDISPLAY            0x00000001  /* Is the display palettized? */
#define PUSIF_SNAPTO                    0x00000002  /* Is SnapTo enabled? */
#define PUSIF_COMBOBOXANIMATION         0x00000004  /* Must match UPBOOLMask(SPI_GETCOMBOBOXANIMATION) */
#define PUSIF_LISTBOXSMOOTHSCROLLING    0x00000008  /* Must match UPBOOLMask(SPI_GETLISTBOXSMOOTHSCROLLING) */
#define PUSIF_KEYBOARDCUES              0x00000020  /* Must match UPBOOLMask(SPI_GETKEYBOARDCUES) */

#define PUSIF_UIEFFECTS                 0x80000000  /* Must match UPBOOLMask(SPI_GETUIEFFECTS) */

#define TEST_PUSIF(f)               TEST_FLAG(gpsi->PUSIFlags, f)
#define TEST_BOOL_PUSIF(f)          TEST_BOOL_FLAG(gpsi->PUSIFlags, f)
#define SET_PUSIF(f)                SET_FLAG(gpsi->PUSIFlags, f)
#define CLEAR_PUSIF(f)              CLEAR_FLAG(gpsi->PUSIFlags, f)
#define SET_OR_CLEAR_PUSIF(f, fSet) SET_OR_CLEAR_FLAG(gpsi->PUSIFlags, f, fSet)
#define TOGGLE_PUSIF(f)             TOGGLE_FLAG(gpsi->PUSIFlags, f)

#define TEST_EffectPUSIF(f)  \
    ((gpsi->PUSIFlags & (f | PUSIF_UIEFFECTS)) == (f | PUSIF_UIEFFECTS))

/*
 * Some UI effects have an "inverted" disabled value (ie, disabled is TRUE)
 */
#define TEST_EffectInvertPUSIF(f) (TEST_PUSIF(f) || !TEST_PUSIF(PUSIF_UIEFFECTS))


/*
 * System-wide last user input info on shared system page is updated
 * by a session only if this many tick counts have elapsed since
 * the last time the session updated it.
 */

#define SYSTEM_RIT_EVENT_UPDATE_PERIOD  (60 * 1000)

#define SRVIF_CHECKED                   0x0001
#define SRVIF_DBCS                      0x0002
#define SRVIF_IME                       0x0004
#define SRVIF_MIDEAST                   0x0008
#define SRVIF_HOOKED                    0x0010
#ifdef CUAS_ENABLE
#define SRVIF_CTFIME_ENABLED            0x0020
#endif // CUAS_ENABLE
#define SRVIF_LASTRITWASKEYBOARD        0x0040
#define SRVIF_KEYBOARDPREF              0x0080
#define SRVIF_LOGDESKTOPHEAPFAILURE     0x0100

#define TEST_SRVIF(f)                   TEST_BOOL_FLAG(gpsi->dwSRVIFlags, f)
#define SET_SRVIF(f)                    SET_FLAG(gpsi->dwSRVIFlags, f)
#define CLEAR_SRVIF(f)                  CLEAR_FLAG(gpsi->dwSRVIFlags, f)
#define SET_OR_CLEAR_SRVIF(f, fSet)     SET_OR_CLEAR_FLAG(gpsi->dwSRVIFlags, f, fSet)
#define TOGGLE_SRVIF(f)                 TOGGLE_FLAG(gpsi->dwSRVIFlags, f)

#define TEST_KbdCuesPUSIF (!TEST_SRVIF(SRVIF_KEYBOARDPREF) &&               \
                           !TEST_EffectInvertPUSIF(PUSIF_KEYBOARDCUES) &&   \
                           !(GetAppCompatFlags2(VER40) & GACF2_KCOFF))


typedef struct tagSERVERINFO {
    DWORD dwSRVIFlags;           // SRVIF_ flags
    KERNEL_ULONG_PTR cHandleEntries;    // count of handle entries in array

    /*
     * Array of server-side function pointers.
     * Client passes servers function ID so they can be easily validated;
     * this array maps function ID into server-side function address.
     * The order of these are enforced by the FNID_ constants, and must match
     * the client-side mpFnidClientPfn[] order as well.
     */
    WNDPROC_PWNDEX mpFnidPfn[FNID_ARRAY_SIZE]; // function mapping table
    WNDPROC_PWND aStoCidPfn[(FNID_WNDPROCEND - FNID_START) + 1];

    // mapping of fnid to min bytes need by public windproc user
    WORD mpFnid_serverCBWndProc[(FNID_END - FNID_START) + 1];

    /*
     * Client side functions pointer structure.
     */
    struct _PFNCLIENT apfnClientA;
    struct _PFNCLIENT apfnClientW;
    struct _PFNCLIENTWORKER apfnClientWorker;

    DWORD cbHandleTable;

    /*
     * Class atoms to allow fast checks on the client.
     */
    ATOM atomSysClass[ICLS_MAX];   // Atoms for control classes

    DWORD dwDefaultHeapBase;            // so WOW can do handle validation
    DWORD dwDefaultHeapSize;

    UINT uiShellMsg;         // message for shell hooks

    UINT wMaxBtnSize;   /* Size of the longest button string in any MessageBox */

    MBSTRING MBStrings[MAX_MB_STRINGS];

    /*
     * values to allow HasCaptionIcon to be in user32
     */
    ATOM atomIconSmProp;
    ATOM atomIconProp;

    ATOM atomContextHelpIdProp;

    char acOemToAnsi[NCHARS];
    char acAnsiToOem[NCHARS];

#ifdef LAME_BUTTON
    /*
     * button size
     */
    int ncxLame;
    WCHAR gwszLame[50];
#endif // LAME_BUTTON

    /*
     * We track the WinEvent hooks that are installed for events by their
     * event category. This is strictly an implementation detail, and is
     * not exposed to the user. The user API is IsWinEventHookInstalled.
     */
    DWORD dwInstalledEventHooks;

    int         aiSysMet[SM_CMETRICS];
    COLORREF    argbSystemUnmatched[COLOR_MAX];
    COLORREF    argbSystem[COLOR_MAX];
    KHBRUSH     ahbrSystem[COLOR_MAX];
    KHBRUSH     hbrGray;
    POINT       ptCursor;
    DWORD       dwLastRITEventTickCount;
    int         nEvents;

    int         gclBorder;              /* # of logical units in window frame */

    UINT        dtScroll;
    UINT        dtLBSearch;
    UINT        dtCaretBlink;
    UINT        ucWheelScrollLines;

    int         wMaxLeftOverlapChars;
    int         wMaxRightOverlapChars;

    /*
     * these are here to lose a thunk for GetDialogBaseUnits
     */
    int         cxSysFontChar;
    int         cySysFontChar;
    int         cxMsgFontChar;
    int         cyMsgFontChar;
    TEXTMETRICW tmSysFont;

    /*
     * values to allow HasCaptionIcon to be in user32
     */
    KHICON      hIconSmWindows;
    KHICON      hIcoWindows;

    KHFONT      hCaptionFont;
    KHFONT      hMsgFont;

    /*
     * These are needed for various user-mode performance hacks.
     */
    DWORD       dwKeyCache;
    DWORD       dwAsyncKeyCache;
    DWORD       cCaptures;

    /*
     * Information about the current state of the display which needs to
     * be shared with the client side. The information here corresponds
     * to the display in gpDispInfo. Note that much of this information
     * is only for the primary monitor.
     */
    OEMBITMAPINFO oembmi[OBI_COUNT];  /* OEM bitmap information */
    RECT          rcScreen;           /* rectangle of the virtual screen */
    WORD          BitCount;           /* Planes * Depth */
    WORD          dmLogPixels;        /* logical pixels per inch, both X and Y */
    BYTE          Planes;             /* Planes */
    BYTE          BitsPixel;          /* Depth */

    DWORD         PUSIFlags;          // PUSIF_ flags
    UINT          uCaretWidth;        /* caret width in edits */
    LANGID        UILangID;           // Default UI language

    /*
     * TickCount when our session updated LastSystemRITEventTickCount on
     * the shared system page that stands for the last RIT event time across
     * all terminal sessions. For MP performance, it is not updated all
     * the time.
     */
    DWORD       dwLastSystemRITEventTickCountUpdate;

#if DBG
    DWORD adwDBGTAGFlags[DBGTAG_Max + 1];
    DWORD dwTagCount;
    DWORD dwRIPFlags;
#endif
} SERVERINFO;


/*
 * IS_BUTTON checks if the button is either our system button control or
 * a fusionized one.
 *
 * To check for system button controls only, then use
 * (GETFNID(pwnd) == FNID_BUTTON).
 *
 * IS_EDIT works similarly for edit controls and the system edit control
 * can also be checked by (GETFNID(pwnd) == FNID_EDIT).
 */
#ifdef _USERK_
#define REBASEALWAYS(p, elem) ((p)->elem)
#endif
#define IS_BUTTON(pwnd)  (gpsi->atomSysClass[ICLS_BUTTON] == ((PCLS)REBASEALWAYS(pwnd, pcls))->atomNVClassName)
#define IS_EDIT(pwnd)    (gpsi->atomSysClass[ICLS_EDIT] == ((PCLS)REBASEALWAYS(pwnd, pcls))->atomNVClassName)

/*
 * Event Categories
 * If you make any changes here, you must update the global variable geci,
 * and the define EVENTCATEGORY_ALL!
 */
#define EVENTCATEGORY_SYSTEM_MENU           0x0001
#define EVENTCATEGORY_CONSOLE               0x0002
#define EVENTCATEGORY_FOCUS                 0x0004
#define EVENTCATEGORY_NAMECHANGE            0x0008
#define EVENTCATEGORY_VALUECHANGE           0x0010
#define EVENTCATEGORY_STATECHANGE           0x0020
#define EVENTCATEGORY_LOCATIONCHANGE        0x0040
#define EVENTCATEGORY_OTHER                 0x8000
#define EVENTCATEGORY_ALL                   0x807F
DWORD CategoryMaskFromEvent(DWORD event);
DWORD CategoryMaskFromEventRange(DWORD eventMin, DWORD eventMax);

/*
 * Quick test for any Window Event Hooks.
 */
#define FEVENTCATEGORYHOOKED(CategoryMask) (TEST_FLAG(gpsi->dwInstalledEventHooks, (CategoryMask)) ? TRUE : FALSE)
#define FEVENTHOOKED(Event) FEVENTCATEGORYHOOKED(CategoryMaskFromEvent(Event))

/* MessageBox String pointers from offset in the gpsi struct */
#define GETGPSIMBPSTR(u) KPWSTR_TO_PWSTR(gpsi->MBStrings[(u)].szName)

typedef struct _WNDMSG {
    UINT maxMsgs;
    KPBYTE abMsgs;
} WNDMSG, *PWNDMSG;

typedef struct tagSHAREDINFO {
    PSERVERINFO     psi;
    PHE             aheList;         /* handle table pointer                */
    PDISPLAYINFO    pDispInfo;       /* global displayinfo                  */
    KERNEL_UINT_PTR ulSharedDelta;   /* delta between client and kernel mapping of ...*/
                                     /* shared memory section. Only valid/used in client.*/

    WNDMSG          awmControl[FNID_END - FNID_START + 1];

    WNDMSG          DefWindowMsgs;
    WNDMSG          DefWindowSpecMsgs;
} SHAREDINFO, *PSHAREDINFO;

typedef struct _USERCONNECT {
    IN  ULONG ulVersion;
    OUT ULONG ulCurrentVersion;
    IN  DWORD dwDispatchCount;
    OUT SHAREDINFO siClient;
} USERCONNECT, *PUSERCONNECT;

#define USER_MAJOR_VERSION  0x0005
#define USER_MINOR_VERSION  0x0000

#define USERCURRENTVERSION   MAKELONG(USER_MINOR_VERSION, USER_MAJOR_VERSION)

/*
 * Options used for NtUserSetSysColors
 */
#define SSCF_NOTIFY             0x00000001
#define SSCF_FORCESOLIDCOLOR    0x00000002
#define SSCF_SETMAGICCOLORS     0x00000004
#define SSCF_16COLORS           0x00000008

/*
 * Structure used for GetClipboardData, where we can have
 * extra information returned from the kernel.
 */
typedef struct tagGETCLIPBDATA {

    UINT   uFmtRet;          // Identifies returned format.
    BOOL   fGlobalHandle;    // Indicates if handle is global.
    union {
        HANDLE hLocale;      // Locale (text-type formats only).
        HANDLE hPalette;     // Palette (bitmap-type formats only).
    };

} GETCLIPBDATA, *PGETCLIPBDATA;

/*
 * Structure used for SetClipboardData, where we can have
 * extra information passed to the kernel.
 */
typedef struct tagSETCLIPBDATA {

    BOOL fGlobalHandle;      // Indicates if handle is global.
    BOOL fIncSerialNumber;   // Indicates if we should increment serial#

} SETCLIPBDATA, *PSETCLIPBDATA;

/*
 * HM Object definition control flags
 */
#define OCF_THREADOWNED         0x01
#define OCF_PROCESSOWNED        0x02
#define OCF_MARKPROCESS         0x04
#define OCF_USEPOOLQUOTA        0x08
#define OCF_DESKTOPHEAP         0x10
#define OCF_USEPOOLIFNODESKTOP  0x20
#define OCF_SHAREDHEAP          0x40
#if DBG
#define OCF_VARIABLESIZE        0x80
#else
#define OCF_VARIABLESIZE        0
#endif

/*
 * From HANDTABL.C
 */
/*
 * Static information about each handle type.
 */
typedef void (*FnDestroyUserObject)(void *);

typedef struct tagHANDLETYPEINFO {
#if DBG
    LPCSTR              szObjectType;
    UINT                uSize;
#endif
    FnDestroyUserObject fnDestroy;
    DWORD               dwAllocTag;
    BYTE                bObjectCreateFlags;
} HANDLETYPEINFO, *PHANDLETYPEINFO;

/*
 * The following is the header of all objects managed in the handle list.
 * (allocated as part of the object for easy access).  All object
 * headers must start with the members of a HEAD structure.
 */
typedef struct _HEAD {
    KHANDLE h;
    DWORD   cLockObj;
} HEAD, * KPTR_MODIFIER PHEAD;

/*
 * sizeof(THROBJHEAD) must be equal to sizeof(PROCOBJHEAD)
 * This is to make sure that DESKHEAD fields are always at the same offset.
 */
typedef struct _THROBJHEAD {
    HEAD;
    PTHREADINFO pti;
} THROBJHEAD, * KPTR_MODIFIER PTHROBJHEAD;

typedef struct _PROCOBJHEAD {
    HEAD;
    DWORD hTaskWow;
} PROCOBJHEAD, *PPROCOBJHEAD;

typedef struct _PROCMARKHEAD {
    PROCOBJHEAD;
    PPROCESSINFO ppi;
} PROCMARKHEAD, *PPROCMARKHEAD;

typedef struct _DESKHEAD {
    PDESKTOP rpdesk;
    KPBYTE   pSelf;
} DESKHEAD, *PDESKHEAD;

/*
 * This type is for HM casting only. Use THRDESKHEAD or PROCDESKHEAD instead.
 */
typedef struct _DESKOBJHEAD {
    HEAD;
    KERNEL_PVOID pOwner;
    DESKHEAD;
} DESKOBJHEAD, *PDESKOBJHEAD;

typedef struct _THRDESKHEAD {
    THROBJHEAD;
    DESKHEAD;
} THRDESKHEAD, *PTHRDESKHEAD;

typedef struct _PROCDESKHEAD {
    PROCOBJHEAD;
    DESKHEAD;
} PROCDESKHEAD, *PPROCDESKHEAD;



#define HANDLEF_DESTROY        0x01
#define HANDLEF_INDESTROY      0x02
#define HANDLEF_MARKED_OK      0x10
#define HANDLEF_GRANTED        0x20
#define HANDLEF_POOL           0x40     // for the mother desktop window
#define HANDLEF_VALID          0x7F

/*
 * The following is a handle table entry.
 *
 * Note that by keeping a pointer to the owning entity (process or
 * thread), cleanup will touch only those objects that belong to
 * the entity being destroyed.  This helps keep the working set
 * size down.  Look at DestroyProcessesObjects() for an example.
 */
typedef struct _HANDLEENTRY {
    PHEAD       phead;                  /* pointer to the real object */
    KERNEL_PVOID pOwner;                 /* pointer to owning entity (pti or ppi) */
    BYTE        bType;                  /* type of object */
    BYTE        bFlags;                 /* flags - like destroy flag */
    WORD        wUniq;                  /* uniqueness count */

#if DBG || FRE_LOCK_RECORD
    PLR         plr;                    /* lock record pointer */
#endif // DBG

} HANDLEENTRY;

/*
 * Change HMINDEXBITS for bits that make up table index in handle
 * Change HMUNIQSHIFT for count of bits to shift uniqueness left.
 * Change HMUNIQBITS for bits that make up uniqueness.
 *
 * Currently 64K handles can be created, w/16 bits of uniqueness.
 */
#define HMINDEXBITS             0x0000FFFF      // bits where index is stored
#define HMUNIQSHIFT             16              // bits to shift uniqueness
#define HMUNIQBITS              0xFFFF          // valid uniqueness bits

#ifdef _USERK_
#define HMHandleFromIndex(i)    LongToHandle((LONG)(i) | ((LONG)gSharedInfo.aheList[i].wUniq << HMUNIQSHIFT))
#define HMObjectFlags(p)        (gahti[HMObjectType(p)].bObjectCreateFlags)
#endif

#define HMIndexFromHandle(h)    ((ULONG)(((ULONG_PTR)(h)) & HMINDEXBITS))
#define _HMPheFromObject(p)      (&gSharedInfo.aheList[HMIndexFromHandle((((PHEAD)p)->h))])
#define _HMObjectFromHandle(h)  ((KERNEL_PVOID)(gSharedInfo.aheList[HMIndexFromHandle(h)].phead))
#define HMUniqFromHandle(h)     ((WORD)((((ULONG_PTR)h) >> HMUNIQSHIFT) & HMUNIQBITS))
#define HMObjectType(p)         (HMPheFromObject(p)->bType)

#define HMIsMarkDestroy(p)      (HMPheFromObject(p)->bFlags & HANDLEF_DESTROY)

/*
 * Validation, handle mapping, etc.
 */
#define HMRevalidateHandle(h)       HMValidateHandleNoSecure(h, TYPE_GENERIC)
#define HMRevalidateCatHandle(h)    HMValidateCatHandleNoSecure(h, TYPE_GENERIC)

#define HMRevalidateHandleNoRip(h)  HMValidateHandleNoRip(h, TYPE_GENERIC)
#define RevalidateHmenu(hmenuX)     HMValidateHandleNoRip(hmenuX, TYPE_MENU)

#define _PtoHq(p)       (KHANDLE_TO_HANDLE(((PHEAD)p)->h))
#define _PtoH(p)        ((HANDLE)((p) == NULL ? NULL : _PtoHq(p)))
#define _HW(pwnd)       ((HWND)_PtoH(pwnd))
#define _HWCCX(ccxPwnd) ((HWND)_PtoH(ccxPwnd))
#define _HWq(pwnd)      ((HWND)_PtoHq(pwnd))

#if DBG && defined(_USERK_)

PHE DBGHMPheFromObject (PVOID p);
PVOID DBGHMObjectFromHandle (HANDLE h);
PVOID DBGHMCatObjectFromHandle (HANDLE h);
HANDLE DBGPtoH (PVOID p);
HANDLE DBGPtoHq (PVOID p);
HWND DBGHW (PWND pwnd);
HWND DBGHWCCX (PWND pwnd);
HWND DBGHWq (PWND pwnd);

#define HMPheFromObject(p)      DBGHMPheFromObject((p))
#define HMObjectFromHandle(h)   DBGHMObjectFromHandle((HANDLE)(h))
#define HMCatObjectFromHandle(h) DBGHMCatObjectFromHandle((HANDLE)(h))
#define PtoH(p)                 DBGPtoH((PVOID)(p))
#define PtoHq(p)                DBGPtoHq((PVOID)(p))
#define HW(pwnd)                DBGHW((PWND)(pwnd))
#define HWCCX(ccxPwnd)          DBGHWCCX((PWND)(ccxPwnd))
#define HWq(pwnd)               DBGHWq((PWND)(pwnd))

#else

#define HMPheFromObject(p)      _HMPheFromObject(p)
#define HMObjectFromHandle(h)   _HMObjectFromHandle(h)
#define HMCatObjectFromHandle(h) _HMObjectFromHandle(h)
#define PtoH(p)                 _PtoH(p)
#define PtoHq(p)                _PtoHq(p)
#define HW(pwnd)                _HW(pwnd)
#define HWCCX(ccxPwnd)          _HW(ccxPwnd)
#define HWq(pwnd)               _HWq(pwnd)

#endif // DBG && defined(_USERK_)

/*
 * Inline functions / macros to access HM object head fields
 */
#define _GETPTI(p)      (((PTHROBJHEAD)p)->pti)
#define _GETPDESK(p)    (((PDESKOBJHEAD)p)->rpdesk)
#define _GETPPI(p)      (((PPROCMARKHEAD)p)->ppi)

#if DBG && defined(_USERK_)
extern CONST HANDLETYPEINFO gahti[];
extern SHAREDINFO gSharedInfo;
__inline PTHREADINFO GETPTI (PVOID p)
{
    UserAssert(HMObjectFlags(p) & OCF_THREADOWNED);
    return _GETPTI(p);
}
__inline PDESKTOP GETPDESK (PVOID p)
{
    UserAssert(HMObjectFlags(p) & OCF_DESKTOPHEAP);
    return _GETPDESK(p);
}
__inline PPROCESSINFO GETPPI (PVOID p)
{
    UserAssert(HMObjectFlags(p) & OCF_MARKPROCESS);
    return _GETPPI(p);
}

#else

#define GETPTI(p)       _GETPTI(p)
#define GETPDESK(p)     _GETPDESK(p)
#define GETPPI(p)       _GETPPI(p)

#endif /* #else #if DBG && defined(_USERK_) */

#define GETPWNDPPI(p) (GETPTI(p)->ppi)
#define GETPTIID(p)   (PsGetThreadId((p)->pEThread))


/*
 * NOTE!: there is code in exitwin.c that assumes HMIsMarkDestroy is defined as
 *      (HMPheFromObject(p)->bFlags & HANDLEF_DESTROY)
 */

#define CPD_ANSI_TO_UNICODE     0x0001      /* CPD represents ansi to U transition */
#define CPD_UNICODE_TO_ANSI     0x0002
#define CPD_TRANSITION_TYPES    (CPD_ANSI_TO_UNICODE|CPD_UNICODE_TO_ANSI)

#define CPD_CLASS               0x0010      /* Get CPD for a class */
#define CPD_WND                 0x0020
#define CPD_DIALOG              0x0040
#define CPD_WNDTOCLS            0x0080

#define CPDHANDLE_HI            ((ULONG_PTR)~HMINDEXBITS)
#define MAKE_CPDHANDLE(h)       (HMIndexFromHandle(h) | CPDHANDLE_HI)
#define ISCPDTAG(x)             (((ULONG_PTR)(x) & CPDHANDLE_HI) == CPDHANDLE_HI)

/*
 * Call Proc Handle Info
 */
typedef struct _CALLPROCDATA {
    PROCDESKHEAD                 head;
    PCALLPROCDATA                spcpdNext;
    KERNEL_ULONG_PTR             pfnClientPrevious;
    WORD                         wType;
} CALLPROCDATA;

/*
 * Class styles
 */
#define CFVREDRAW         0x0001
#define CFHREDRAW         0x0002
#define CFKANJIWINDOW     0x0004
#define CFDBLCLKS         0x0008
#define CFSERVERSIDEPROC  0x0010    // documented as reserved in winuser.h
#define CFOWNDC           0x0020
#define CFCLASSDC         0x0040
#define CFPARENTDC        0x0080
#define CFNOKEYCVT        0x0101
#define CFNOCLOSE         0x0102
#define CFLVB             0x0104
#define CFSAVEBITS        0x0108
#define CFOEMCHARS        0x0140
#define CFIME             0x0201
#define CFDROPSHADOW      0x0202

/*
 * Offset from the beginning of the CLS structure to the WNDCLASS section.
 */
#define CFOFFSET             (FIELD_OFFSET(CLS, style))

#define TestCF(hwnd, flag)   (*((KPBYTE)((PWND)(hwnd))->pcls + CFOFFSET + HIBYTE(flag)) & LOBYTE(flag))
#define SetCF(hwnd, flag)    (*((KPBYTE)((PWND)(hwnd))->pcls + CFOFFSET + HIBYTE(flag)) |= LOBYTE(flag))
#define ClrCF(pcls, flag)    (*((KPBYTE)((PWND)(hwnd))->pcls + CFOFFSET + HIBYTE(flag)) &= ~LOBYTE(flag))

#define TestCF2(pcls, flag)  (*((KPBYTE)(pcls) + CFOFFSET + (int)HIBYTE(flag)) & LOBYTE(flag))
#define SetCF2(pcls, flag)   (*((KPBYTE)(pcls) + CFOFFSET + (int)HIBYTE(flag)) |= LOBYTE(flag))
#define ClrCF2(pcls, flag)   (*((KPBYTE)(pcls) + CFOFFSET + (int)HIBYTE(flag)) &= ~LOBYTE(flag))

#define PWCFromPCLS(pcls)  ((PWC)KPBYTE_TO_PBYTE((KPBYTE)(pcls) + sizeof(CLS) + (pcls)->cbclsExtra))

/* Window class structure */
typedef struct tagCOMMON_WNDCLASS
{
    /*
     * We'll add cWndReferenceCount here so COMMON_WNDCLASS and WNDCLASSEX have
     * the same layout. Otherwise padding will mess us up on 64-bit platforms.
     */
    int           cWndReferenceCount; /* The number of windows registered
                                         with this class */
    UINT          style;
    WNDPROC_PWND  lpfnWndProc;       // HI BIT on means WOW PROC
    int           cbclsExtra;
    int           cbwndExtra;
    KHANDLE       hModule;
    PCURSOR       spicn;
    PCURSOR       spcur;
    KHBRUSH       hbrBackground;
    KLPWSTR       lpszMenuName;
    KLPSTR        lpszAnsiClassName;
    PCURSOR       spicnSm;
} COMMON_WNDCLASS;

/*
 * Class Menu names structure. For performance reasons (GetClassInfo) we
 * keep two client side copies of wndcls.lpszMenu and another kernel side
 * copy. This structure is used to pass menu names info between client and
 * kernel.
 */
typedef struct tagCLSMENUNAME
{
    KLPSTR              pszClientAnsiMenuName;
    KLPWSTR             pwszClientUnicodeMenuName;
    PUNICODE_STRING     pusMenuName;
} CLSMENUNAME, *PCLSMENUNAME;

/*
 * This is the window class structure.  All window classes are linked
 * together in a master list pointed to by gpclsList.
 *
 * RED ALERT! Do not add any fields after the COMMON_WNDCLASS structure;
 *            CFOFFSET depends on this.
 */

typedef struct tagCLS {
    /* NOTE: The order of the following fields is assumed. */
    PCLS                        pclsNext;
    ATOM                        atomClassName;      //Version aware class name.
    ATOM                        atomNVClassName;    //None-version aware class name.
    WORD                        fnid;               // record window proc used by this hwnd
                                                    // access through GETFNID
    PDESKTOP                    rpdeskParent;/* Parent desktop */
    PDCE                        pdce;            /* PDCE to DC associated with class */
    WORD                        hTaskWow;
    WORD                        CSF_flags;           /* internal class flags */
    KLPSTR                      lpszClientAnsiMenuName;     /* string or resource ID */
    KLPWSTR                     lpszClientUnicodeMenuName;  /* string or resource ID */

    PCALLPROCDATA               spcpdFirst;       /* Pointer to first CallProcData element (or 0) */
    PCLS                        pclsBase;        /* Pointer to base class */
    PCLS                        pclsClone;       /* Pointer to clone class list */

    COMMON_WNDCLASS;
    /*
     * WARNING:
     * CFOFFSET expects COMMON_WNDCLASS to be last fields in CLS
     */
} CLS, **PPCLS;

/*
 * This class flag is used to distinguish classes that were registered
 * by the server (most system classes) from those registered by the client.
 * Note -- flags are a WORD in the class structure now.
 */
#define CSF_SERVERSIDEPROC      0x0001
#define CSF_ANSIPROC            0x0002
#define CSF_WOWDEFERDESTROY     0x0004
#define CSF_SYSTEMCLASS         0x0008
#define CSF_WOWCLASS            0x0010  // extra words at end for wow info
#define CSF_WOWEXTRA            0x0020
#define CSF_CACHEDSMICON        0x0040
#define CSF_WIN40COMPAT         0x0080
#define CSF_VERSIONCLASS        0x0100
#define CSF_VALID               (CSF_ANSIPROC | CSF_WIN40COMPAT | CSF_VERSIONCLASS)

/*
 * SBDATA are the values for one scrollbar
 */

typedef struct tagSBDATA {
    int    posMin;
    int    posMax;
    int    page;
    int    pos;
} SBDATA, *PSBDATA;

/*
 * SBINFO is the set of values that hang off of a window structure, if the
 * window has scrollbars.
 */
typedef struct tagSBINFO {
    int WSBflags;
    SBDATA Horz;
    SBDATA Vert;
} SBINFO, * KPTR_MODIFIER PSBINFO;

/*
 * Window Property structure
 */
typedef struct tagPROP {
    KHANDLE hData;
    ATOM atomKey;
    WORD fs;
} PROP, * KPTR_MODIFIER PPROP;

#define PROPF_INTERNAL   0x0001
#define PROPF_STRING     0x0002
#define PROPF_NOPOOL     0x0004


/*
 * Window Property List structure
 */
typedef struct tagPROPLIST {
    UINT cEntries;
    UINT iFirstFree;
    PROP aprop[1];
} PROPLIST, * KPTR_MODIFIER PPROPLIST;

/*
 * NOTE -- this structure has been sorted (roughly) in order of use
 * of the fields. The x86 code set allows cheaper access to fields
 * that are in the first 0x80 bytes of a structure. Please attempt
 * to ensure that frequently-used fields are below this boundary.
 */

typedef struct tagWND {
    THRDESKHEAD   head;

    WW;         // WOW-USER common fields. Defined in wowuserp.h
                // The presence of "state" at the start of this structure is
                // assumed by the STATEOFFSET macro.

    PWND                 spwndNext;    // Handle to the next window
    PWND                 spwndPrev;    // Handle to the previous window
    PWND                 spwndParent;  // Backpointer to the parent window.
    PWND                 spwndChild;   // Handle to child
    PWND                 spwndOwner;   // Popup window owner field

    RECT                 rcWindow;     // Window outer rectangle
    RECT                 rcClient;     // Client rectangle

    WNDPROC_PWND         lpfnWndProc;  // Can be WOW address or standard address

    PCLS                 pcls;         // Pointer to window class

    KHRGN                hrgnUpdate;   // Accumulated paint region

    PPROPLIST            ppropList;    // Pointer to property list
    PSBINFO              pSBInfo;      // Words used for scrolling

    PMENU                spmenuSys;    // Handle to system menu
    PMENU                spmenu;       // Menu handle or ID

    KHRGN                hrgnClip;     // Clipping region for this window

    LARGE_UNICODE_STRING strName;
    int                  cbwndExtra;   // Extra bytes in window
    PWND                 spwndLastActive; // Last active in owner/ownee list
    KHIMC                hImc;         // Associated input context handle
    KERNEL_ULONG_PTR     dwUserData;   // Reserved for random application data
    struct _ACTIVATION_CONTEXT  * KPTR_MODIFIER pActCtx;
} WND;

#define NEEDSPAINT(pwnd)    (pwnd->hrgnUpdate != NULL || TestWF(pwnd, WFINTERNALPAINT))

/*
 * Combo Box stuff
 */
typedef struct tagCBox {
    PWND    spwnd;      /* Window for the combo box */
    PWND    spwndParent;/* Parent of the combo box */
    RECT    editrc;            /* Rectangle for the edit control/static text
                                  area */
    RECT    buttonrc;          /* Rectangle where the dropdown button is */

    int     cxCombo;            // Width of sunken area
    int     cyCombo;            // Height of sunken area
    int     cxDrop;             // 0x24 Width of dropdown
    int     cyDrop;             // Height of dropdown or shebang if simple

    PWND    spwndEdit;  /* Edit control window handle */
    PWND    spwndList;  /* List box control window handle */

    UINT    CBoxStyle:2;         /* Combo box style */
    UINT    fFocus:1;          /* Combo box has focus? */
    UINT    fNoRedraw:1;       /* Stop drawing? */
    UINT    fMouseDown:1;      /* Was the popdown button just clicked and
                                   mouse still down? */
    UINT    fButtonPressed:1; /* Is the dropdown button in an inverted state?
                                */
    UINT    fLBoxVisible:1;    /* Is list box visible? (dropped down?) */
    UINT    OwnerDraw:2;       /* Owner draw combo box if nonzero. value
                                * specifies either fixed or varheight
                                */
    UINT    fKeyboardSelInListBox:1; /* Is the user keyboarding through the
                                      * listbox. So that we don't hide the
                                      * listbox on selchanges caused by the
                                      * user keyboard through it but we do
                                      * hide it if the mouse causes the
                                      * selchange.
                                      */
    UINT    fExtendedUI:1;     /* Are we doing TandyT's UI changes on this
                                * combo box?
                                */
    UINT    fCase:2;

    UINT    f3DCombo:1;         // 3D or flat border?
    UINT    fNoEdit:1;         /* True if editing is not allowed in the edit
                                * window.
                                */
#ifdef COLOR_HOTTRACKING
    UINT    fButtonHotTracked:1; /* Is the dropdown hot-tracked? */
#endif // COLOR_HOTTRACKING
    UINT    fRightAlign:1;     /* used primarily for MidEast right align */
    UINT    fRtoLReading:1;    /* used only for MidEast, text rtol reading order */
    UINT    fInDestroy:1;      /* Is combobox destruction started already? */
    HANDLE  hFont;             /* Font for the combo box */
    LONG    styleSave;         /* Temp to save the style bits when creating
                                * window.  Needed because we strip off some
                                * bits and pass them on to the listbox or
                                * edit box.
                                */
} CBOX, * KPTR_MODIFIER PCBOX;

typedef struct tagCOMBOWND {
    WND wnd;
    PCBOX pcbox;
} COMBOWND, * KPTR_MODIFIER PCOMBOWND;

/*
 * List Box
 */
typedef struct _SCROLLPOS {
    INT cItems;
    UINT iPage;
    INT iPos;
    UINT fMask;
    INT iReturn;
} SCROLLPOS, *PSCROLLPOS;

typedef struct tagLBIV {
    PWND    spwndParent;    /* parent window */
    PWND    spwnd;          /* lbox ctl window */
    INT     iTop;           /* index of top item displayed          */
    INT     iSel;           /* index of current item selected       */
    INT     iSelBase;       /* base sel for multiple selections     */
    INT     cItemFullMax;   /* cnt of Fully Visible items. Always contains
                               result of CItemInWindow(plb, FALSE) for fixed
                               height listboxes. Contains 1 for var height
                               listboxes. */
    INT     cMac;           /* cnt of items in listbox              */
    INT     cMax;           /* cnt of total # items allocated for rgpch.
                               Not all are necessarly in use    */
    KPBYTE  rgpch;          /* pointer to array of string offsets    */
    KLPWSTR hStrings;       /* string storage handle                */
    INT     cchStrings;     /* Size in bytes of hStrings            */
    INT     ichAlloc;       /* Pointer to end of hStrings (end of last valid
                               string) */
    INT     cxChar;         /* Width of a character                 */
    INT     cyChar;         /* height of line                       */
    INT     cxColumn;       /* width of a column in multicolumn listboxes */
    INT     itemsPerColumn; /* for multicolumn listboxes */
    INT     numberOfColumns; /* for multicolumn listboxes */
    POINT   ptPrev;         /* coord of last tracked mouse pt. used for auto
                               scrolling the listbox during timer's */

    UINT    OwnerDraw:2;    /* Owner draw styles. Non-zero if ownerdraw. */
    UINT    fRedraw:1;      /* if TRUE then do repaints             */
    UINT    fDeferUpdate:1; /* */
    UINT    wMultiple:2;    /* SINGLESEL allows a single item to be selected.
                             * MULTIPLESEL allows simple toggle multi-selection
                             * EXTENDEDSEL allows extended multi selection;
                             */

    UINT     fSort:1;        /* if TRUE the sort list                */
    UINT     fNotify:1;      /* if TRUE then Notify parent           */
    UINT     fMouseDown:1;   /* if TRUE then process mouse moves/mouseup */
    UINT     fCaptured:1;    /* if TRUE then process mouse messages  */
    UINT     fCaret:1;       /* flashing caret allowed               */
    UINT     fDoubleClick:1; /* mouse down in double click           */
    UINT     fCaretOn:1;     /* if TRUE then caret is on             */
    UINT     fAddSelMode:1;  /* if TRUE, then it is in ADD selection mode */
    UINT     fHasStrings:1;  /* True if the listbox has a string associated
                              * with each item else it has an app suppled LONG
                              * value and is ownerdraw
                              */
    UINT     fHasData:1;    /* if FALSE, then lb doesn't keep any line data
                             * beyond selection state, but instead calls back
                             * to the client for each line's definition.
                             * Forces OwnerDraw==OWNERDRAWFIXED, !fSort,
                             * and !fHasStrings.
                             */
    UINT     fNewItemState:1; /* select/deselect mode? for multiselection lb
                              */
    UINT     fUseTabStops:1; /* True if the non-ownerdraw listbox should handle
                             * tabstops
                             */
    UINT     fMultiColumn:1; /* True if this is a multicolumn listbox */
    UINT     fNoIntegralHeight:1; /* True if we don't want to size the listbox
                                  * an integral lineheight
                                  */
    UINT     fWantKeyboardInput:1; /* True if we should pass on WM_KEY & CHAR
                                   * so that the app can go to special items
                                   * with them.
                                   */
    UINT     fDisableNoScroll:1;   /* True if the listbox should
                                    * automatically Enable/disable
                                    * it's scroll bars. If false, the scroll
                                    * bars will be hidden/Shown automatically
                                    * if they are present.
                                    */
    UINT    fHorzBar:1; // TRUE if WS_HSCROLL specified at create time

    UINT    fVertBar:1; // TRUE if WS_VSCROLL specified at create time
    UINT    fFromInsert:1;  // TRUE if client drawing should be deferred during delete/insert ops
    UINT    fNoSel:1;

    UINT    fHorzInitialized : 1;   // Horz scroll cache initialized
    UINT    fVertInitialized : 1;   // Vert scroll cache initialized

    UINT    fSized : 1;             // Listbox was resized.
    UINT    fIgnoreSizeMsg : 1;     // If TRUE, ignore WM_SIZE message

    UINT    fInitialized : 1;

    UINT    fRightAlign:1;     // used primarily for MidEast right align
    UINT    fRtoLReading:1;    // used only for MidEast, text rtol reading order
    UINT    fSmoothScroll:1;   // allow just one smooth-scroll per scroll cycle

    int     xRightOrigin;      // For horizontal scrolling. The current x origin

    INT     iLastSelection; /* Used for cancelable selection. Last selection
                             * in listbox for combo box support
                             */
    INT     iMouseDown;     /* For multiselection mouse click & drag extended
                             * selection. It is the ANCHOR point for range
                             * selections
                             */
    INT     iLastMouseMove; /* selection of listbox items */
    KPINT   iTabPixelPositions; /* List of positions for tabs */
    KHANDLE hFont;          /* User settable font for listboxes */
    int     xOrigin;        /* For horizontal scrolling. The current x origin */
    int     maxWidth;       /* Maximum width of listbox in pixels for
                               horizontal scrolling purposes */
    PCBOX   pcbox;          /* Combo box pointer */
    HDC     hdc;            /* hdc currently in use */
    DWORD   dwLocaleId;     /* Locale used for sorting strings in list box */
    int     iTypeSearch;
    KLPWSTR pszTypeSearch;
    SCROLLPOS HPos;
    SCROLLPOS VPos;
} LBIV, *PLBIV;

typedef struct tagLBWND {
    WND wnd;
    PLBIV pLBIV;
} LBWND, * KPTR_MODIFIER PLBWND;

/*
 * Kernel side input context structure.
 */
typedef struct tagIMC {    /* hImc */
    THRDESKHEAD                     head;
    struct tagIMC* KPTR_MODIFIER    pImcNext;
    KERNEL_ULONG_PTR                dwClientImcData;    // Client side data
    KHWND                           hImeWnd;            // in use Ime Window
} IMC, * KPTR_MODIFIER PIMC;


/*
 * Hook structure.
 */
#undef HOOKBATCH
typedef struct tagHOOK {   /* hk */
    THRDESKHEAD     head;
    PHOOK           phkNext;
    int             iHook;              // WH_xxx hook type
    KERNEL_ULONG_PTR offPfn;
    UINT            flags;              // HF_xxx flags
    int             ihmod;
    PTHREADINFO     ptiHooked;          // Thread hooked.
    PDESKTOP        rpdesk;             // Global hook pdesk. Only used when
                                        //  hook is locked and owner is destroyed

    BOOL            fLastHookHung : 1;  // for LL hook only

#ifdef HOOKBATCH
    DWORD           cEventMessages;     // Number of events in the cache
    DWORD           iCurrentEvent;      // Current cache event
    DWORD           CacheTimeOut;       // Timeout between keys
    PEVENTMSG       aEventCache;        // The array of Events
#endif // HOOKBATCH
} HOOK;

/*
 * Hook defines.
 */
#define HF_GLOBAL          0x0001
#define HF_ANSI            0x0002
#define HF_NEEDHC_SKIP     0x0004
#define HF_HUNG            0x0008      // Hook Proc hung don't call if system
#define HF_HOOKFAULTED     0x0010      // Hook Proc faulted
#define HF_NOPLAYBACKDELAY 0x0020      // Ignore requested delay
#define HF_DESTROYED       0x0080      // Set by FreeHook
#if DBG
#define HF_INCHECKWHF      0x0100      // fsHooks is being updated
#define HF_FREED           0x0200      // Object has been freed.
#define HF_DBGUSED         0x03FF      // Update if adding a flag
#endif

/*
 * Macro to convert the WH_* index into a bit position for
 * the fsHooks fields of SERVERINFO and THREADINFO.
 */
#define WHF_FROM_WH(n)     (1 << (n + 1))

/*
 * Flags for IsHooked().
 */
#define WHF_MSGFILTER       WHF_FROM_WH(WH_MSGFILTER)
#define WHF_JOURNALRECORD   WHF_FROM_WH(WH_JOURNALRECORD)
#define WHF_JOURNALPLAYBACK WHF_FROM_WH(WH_JOURNALPLAYBACK)
#define WHF_KEYBOARD        WHF_FROM_WH(WH_KEYBOARD)
#define WHF_GETMESSAGE      WHF_FROM_WH(WH_GETMESSAGE)
#define WHF_CALLWNDPROC     WHF_FROM_WH(WH_CALLWNDPROC)
#define WHF_CALLWNDPROCRET  WHF_FROM_WH(WH_CALLWNDPROCRET)
#define WHF_CBT             WHF_FROM_WH(WH_CBT)
#define WHF_SYSMSGFILTER    WHF_FROM_WH(WH_SYSMSGFILTER)
#define WHF_MOUSE           WHF_FROM_WH(WH_MOUSE)
#define WHF_HARDWARE        WHF_FROM_WH(WH_HARDWARE)
#define WHF_DEBUG           WHF_FROM_WH(WH_DEBUG)
#define WHF_SHELL           WHF_FROM_WH(WH_SHELL)
#define WHF_FOREGROUNDIDLE  WHF_FROM_WH(WH_FOREGROUNDIDLE)

/*
 * Windowstation and desktop enum list structure.
 */
typedef struct tagNAMELIST {
    DWORD cb;
    DWORD cNames;
    WCHAR awchNames[1];
} NAMELIST, *PNAMELIST;

#define MONF_VISIBLE         0x01   // monitor is visible on desktop
#define MONF_PALETTEDISPLAY  0x02   // monitor has palette

#ifndef _USERSRV_

#ifdef SUBPIXEL_MOUSE
typedef LONG64 FIXPOINT;

/*
 * Number of points in the arrays describing the acceleration curves.
 */
#define SM_POINT_CNT 5

#endif // SUBPIXEL_MOUSE

/*
 * Monitor information structure.
 *
 *     This structure defines the attributes of a single monitor
 *     in a virtual display.
 */
typedef struct tagMONITOR {
    HEAD                        head;            // object handle stuff

    PMONITOR                    pMonitorNext;    // next monitor in free or used list
    DWORD                       dwMONFlags;      // flags
    RECT                        rcMonitor;       // location of monitor in virtual screen coordinates
    RECT                        rcWork;          // work area of monitor in virtual screen coordinates
    KHRGN                       hrgnMonitor;     // monitor region in virtual screen coordinates
    short                       cFullScreen;     // number of fullscreen apps on this monitor
    short                       cWndStack;       // number of tiled top-level windows
    KHANDLE                     hDev;            // hdev associated with this monitor

#ifdef SUBPIXEL_MOUSE
    FIXPOINT                    xTxf[SM_POINT_CNT], yTxf[SM_POINT_CNT];
    /*
     * SM_POINT_CNT - 1 because you need two points for one slope/yint value.
     */
    FIXPOINT                    slope[SM_POINT_CNT - 1], yint[SM_POINT_CNT - 1];
#endif // SUBPIXEL_MOUSE
} MONITOR;
#endif

/*
 * Display Information Structure.
 *
 *   This structure defines the display attributes for the
 *   desktop.  This is usually maintained in the DESKTOP
 *   structure. The current display in use is pointed to
 *   by gpDispInfo.
 *
 *   CONSIDER: How many of these fields need to be actually kept
 *   in a DISPLAYINFO that is not in use, rather than just be put
 *   in gpsi or a kernel-side global?
 */
#ifndef _USERSRV_

typedef struct tagDISPLAYINFO {
    // device stuff
    KHANDLE       hDev;
    KERNEL_PVOID  pmdev;
    KHANDLE       hDevInfo;

    // useful dcs
    KHDC          hdcScreen;        // Device-Context for screen
    KHDC          hdcBits;          // Holds system-bitmap resource

    // Graystring resources
    KHDC          hdcGray;          // GrayString DC.
    KHBITMAP      hbmGray;          // GrayString Bitmap Surface.
    int           cxGray;           // width of gray bitmap
    int           cyGray;           // height of gray bitmap

    // random stuff
    PDCE          pdceFirst;       // list of dcs
    PSPB          pspbFirst;       // list of spbs

    // Monitors on this device
    ULONG         cMonitors;        // number of MONF_VISIBLE monitors attached to desktop
    PMONITOR      pMonitorPrimary;  // the primary monitor (display)
    PMONITOR      pMonitorFirst;    // monitor in use list

    // device characteristics
    RECT          rcScreen;         // Rectangle of entire desktop surface
    KHRGN         hrgnScreen;       // region describing virtual screen
    WORD          dmLogPixels;      // pixels per inch
    WORD          BitCountMax;      // Maximum bitcount across all monitors

    BOOL          fDesktopIsRect:1;   // Is the desktop a simple rectangle?
    BOOL          fAnyPalette:1;      // Are any of the monitors paletized?

    // NOTE: if you need more flags, make fDesktopIsRect a flags field instead.

} DISPLAYINFO;

/*
 * Multimonitor function in rtl\mmrtl.c
 */
PMONITOR _MonitorFromPoint(POINT pt, DWORD dwFlags);
PMONITOR _MonitorFromRect(LPCRECT lprc, DWORD dwFlags);
PMONITOR _MonitorFromWindow(PWND pwnd, DWORD dwFlags);
#endif

#define HDCBITS() gpDispInfo->hdcBits

#define DTF_NEEDSPALETTECHANGED      0x00000001
#define DTF_NEEDSREDRAW              0x00000002

#define CWINHOOKS       (WH_MAX - WH_MIN + 1)

/*
 * VWPL - Volatile Window Pointer List (see rare.c)
 * VPWLs are manipulate with the functions:
 *    VWPLAdd(), VWPLRemove() and VWPLNext()
 */
typedef struct {
    DWORD       cPwnd;       // number of pwnds in apwnd[]
    DWORD       cElem;       // number of elements in apwnd[]
    DWORD       cThreshhold; // (re)allocation increment/decrement
    PWND        aPwnd[0];    // array of pwnds
} VWPL, * KPTR_MODIFIER PVWPL;

/*
 * Desktop Information Structure.
 *
 *   This structure contains information regading the
 *   desktop.  This is viewable from both the client and
 *   kernel processes.
 */
typedef struct tagDESKTOPINFO {

    KERNEL_PVOID  pvDesktopBase;          // For handle validation
    KERNEL_PVOID  pvDesktopLimit;         // ???
    PWND          spwnd;                 // Desktop window
    DWORD         fsHooks;                // Deskop global hooks
    PHOOK         aphkStart[CWINHOOKS];  // List of hooks
    PWND          spwndShell;            // Shell window
    PPROCESSINFO  ppiShellProcess;        // Shell Process
    PWND          spwndBkGnd;            // Shell background window
    PWND          spwndTaskman;          // Task-Manager window
    PWND          spwndProgman;          // Program-Manager window
    PVWPL         pvwplShellHook;         // see (De)RegisterShellHookWindow
    int           cntMBox;                // ???
} DESKTOPINFO;


#define CURSOR_ALWAYSDESTROY    0
#define CURSOR_CALLFROMCLIENT   1
#define CURSOR_THREADCLEANUP    2

typedef struct tagCURSOR_ACON {
    PROCMARKHEAD    head;
    PCURSOR         pcurNext;
    UNICODE_STRING   strName;
    ATOM             atomModName;
    WORD             rt;
} CURSOR_ACON;

typedef struct CURSOR_COMMON {
    CURSINFO;                          // CURSINFO includes the flags

    DWORD            bpp;
    DWORD            cx;
    DWORD            cy;
} CURSOR_COMMON;

typedef struct ACON_COMMON {
    int            cpcur;              // Count of image frames
    int            cicur;              // Count of steps in animation sequence
    PCURSOR * KPTR_MODIFIER aspcur;    // Array of image frame pointers
    DWORD * KPTR_MODIFIER aicur;       // Array of frame indices (seq-table)
    JIF * KPTR_MODIFIER ajifRate;      // Array of time offsets
    int            iicur;              // Current step in animation
} ACON_COMMON;

typedef struct tagCURSOR {
    CURSOR_ACON;                       // common cursor/acon elements -
                                       // See SetSystemImage()
    CURSOR_COMMON;
} CURSOR;

typedef struct tagACON {               // acon
    CURSOR_ACON;                       // common cursor/acon elements -
                                       // See SetSystemImage()
    /*
     * CURSORF_flags must be the first element to follow CURSOR_ACON. This
     * way all members up to and including CURSORF_flags are the same in
     * tagCURSOR and tagACON which is needed for SetSystemImage. See more
     * comments for CI_FIRST in wingdi.w.
     */
    DWORD CURSORF_flags;               // same as CI_FIRST in CURSINFO

    ACON_COMMON;
} ACON, *PACON;

#define PICON PCURSOR

typedef struct tagCURSORDATA {
    KLPWSTR  lpName;
    KLPWSTR  lpModName;
    WORD    rt;
    WORD    dummy;

    CURSOR_COMMON;

    ACON_COMMON;
} CURSORDATA, *PCURSORDATA;


typedef struct tagCURSORFIND {

    KHCURSOR hcur;
    DWORD   rt;
    DWORD   cx;
    DWORD   cy;
    DWORD   bpp;

} CURSORFIND, *PCURSORFIND;

#define MSGFLAG_MASK                0xFFFE0000
#define MSGFLAG_WOW_RESERVED        0x00010000      // Used by WOW
#define MSGFLAG_DDE_MID_THUNK       0x80000000      // DDE tracking thunk
#define MSGFLAG_DDE_SPECIAL_SEND    0x40000000      // WOW bad DDE app hack
#define MSGFLAG_SPECIAL_THUNK       0x10000000      // server->client thunk needs special handling

#define WIDTHBYTES(i) \
    ((((i) + 31) & ~31) >> 3)

#define BITMAPWIDTHSIZE(cx, cy, planes, bpp) \
    (WIDTHBYTES((cx * bpp)) * (cy) * (planes))

/*
 * Window Style and State Masks -
 *
 * High byte of word is byte index from the start of the state field
 * in the WND structure, low byte is the mask to use on the byte.
 * These masks assume the order of the state and style fields of a
 * window instance structure.
 *
 * This is how the Test/Set/Clr/MaskWF value ranges map to the corresponding
 * fields in the window structure.
 *
 *   offset                 WND field
 *   0 - 3                  state        - private
 *   4 - 7                  state2       - private
 *   8 - B                  ExStyle      - public, exposed in SetWindowLong(GWL_EXSTYLE)
 *   C - F                  style        - public, exposed in SetWindowLong(GWL_STYLE)
 *                                         C-D are reserved for window class designer.
 *                                         E-F are reserved for WS_ styles.
 *
 * NOTE: Be sure to add the flag to the wFlags array in kd\userexts.c!!!
 */

/*
 * State flags, from 0x0000 to 0x0780.
 */

/*
 * DON'T MOVE ANY ONE OF THE FOLLOWING WFXPRESENT FLAGS,
 * BECAUSE WFFRAMEPRESENTMASK DEPENDS ON THEIR VALUES
 */
#define WFMPRESENT              0x0001
#define WFVPRESENT              0x0002
#define WFHPRESENT              0x0004
#define WFCPRESENT              0x0008
#define WFFRAMEPRESENTMASK      0x000F

#define WFSENDSIZEMOVE          0x0010
#define WFMSGBOX                0x0020  // used to maintain count of msg boxes on screen
#define WFFRAMEON               0x0040
#define WFHASSPB                0x0080
#define WFNONCPAINT             0x0101
#define WFSENDERASEBKGND        0x0102
#define WFERASEBKGND            0x0104
#define WFSENDNCPAINT           0x0108
#define WFINTERNALPAINT         0x0110
#define WFUPDATEDIRTY           0x0120
#define WFHIDDENPOPUP           0x0140
#define WFMENUDRAW              0x0180

/*
 * NOTE -- WFDIALOGWINDOW is used in WOW.  DO NOT CHANGE without
 *   changing WD_DIALOG_WINDOW in winuser.w
 */
#define WFDIALOGWINDOW          0x0201

#define WFTITLESET              0x0202
#define WFSERVERSIDEPROC        0x0204
#define WFANSIPROC              0x0208
#define WFBEINGACTIVATED        0x0210  // prevent recursion in xxxActivateThis Window
#define WFHASPALETTE            0x0220
#define WFPAINTNOTPROCESSED     0x0240  // WM_PAINT message not processed
#define WFSYNCPAINTPENDING      0x0280
#define WFGOTQUERYSUSPENDMSG    0x0301
#define WFGOTSUSPENDMSG         0x0302
#define WFTOGGLETOPMOST         0x0304  // Toggle the WS_EX_TOPMOST bit ChangeStates

/*
 * DON'T MOVE REDRAWIFHUNGFLAGS WITHOUT ADJUSTING WFANYHUNGREDRAW
 */
#define WFREDRAWIFHUNG          0x0308
#define WFREDRAWFRAMEIFHUNG     0x0310
#define WFANYHUNGREDRAW         0x0318

#define WFANSICREATOR           0x0320
#define WFREALLYMAXIMIZABLE     0x0340  // The window fills the work area or monitor when maximized
#define WFDESTROYED             0x0380
#define WFWMPAINTSENT           0x0401
#define WFDONTVALIDATE          0x0402
#define WFSTARTPAINT            0x0404
#define WFOLDUI                 0x0408
#define WFCEPRESENT             0x0410  // Client edge present
#define WFBOTTOMMOST            0x0420  // Bottommost window
#define WFFULLSCREEN            0x0440
#define WFINDESTROY             0x0480

/*
 * DON'T MOVE ANY ONE OF THE FOLLOWING WFWINXXCOMPAT FLAGS,
 * BECAUSE WFWINCOMPATMASK DEPENDS ON THEIR VALUES
 */
#define WFWIN31COMPAT           0x0501  // Win 3.1 compatible window
#define WFWIN40COMPAT           0x0502  // Win 4.0 compatible window
#define WFWIN50COMPAT           0x0504  // Win 5.0 compatibile window
#define WFWINCOMPATMASK         0x0507  // Compatibility flag mask

#define WFMAXFAKEREGIONAL       0x0508  // Window has a fake region for maxing on 1 monitor

// Active Accessibility (Window Event) state
#define WFCLOSEBUTTONDOWN       0x0510
#define WFZOOMBUTTONDOWN        0x0520
#define WFREDUCEBUTTONDOWN      0x0540
#define WFHELPBUTTONDOWN        0x0580
#define WFLINEUPBUTTONDOWN      0x0601  // Line up/left scroll button down
#define WFPAGEUPBUTTONDOWN      0x0602  // Page up/left scroll area down
#define WFPAGEDNBUTTONDOWN      0x0604  // Page down/right scroll area down
#define WFLINEDNBUTTONDOWN      0x0608  // Line down/right scroll area down
#define WFSCROLLBUTTONDOWN      0x0610  // Any scroll button down?
#define WFVERTSCROLLTRACK       0x0620  // Vertical or horizontal scroll track...

#define WFALWAYSSENDNCPAINT     0x0640  // Always send WM_NCPAINT to children
#define WFPIXIEHACK             0x0680  // Send (HRGN)1 to WM_NCPAINT (see PixieHack)

/*
 * WFFULLSCREENBASE MUST HAVE LOWORD OF 0. See SetFullScreen macro.
 */
#define WFFULLSCREENBASE        0x0700  // Fullscreen flags take up 0x0701
#define WFFULLSCREENMASK        0x0707  // and 0x0702 and 0x0704
#define WEFTRUNCATEDCAPTION     0x0708  // The caption text was truncated -> caption tootip

#define WFNOANIMATE             0x0710  // ???
#define WFSMQUERYDRAGICON       0x0720  // ??? Small icon comes from WM_QUERYDRAGICON
#define WFSHELLHOOKWND          0x0740  // ???
#define WFISINITIALIZED         0x0780  // Window is initialized -- checked by WoW32

/*
 * Add more state flags here, up to 0x0780.
 * Look for empty slots above before adding to the end.
 * Be sure to add the flag to the wFlags array in kd\userexts.c
 */

/*
 * Window Extended Style, from 0x0800 to 0x0B80.
 */
#define WEFDLGMODALFRAME        0x0801  // WS_EX_DLGMODALFRAME
#define WEFDRAGOBJECT           0x0802  // ???
#define WEFNOPARENTNOTIFY       0x0804  // WS_EX_NOPARENTNOTIFY
#define WEFTOPMOST              0x0808  // WS_EX_TOPMOST
#define WEFACCEPTFILES          0x0810  // WS_EX_ACCEPTFILES
#define WEFTRANSPARENT          0x0820  // WS_EX_TRANSPARENT
#define WEFMDICHILD             0x0840  // WS_EX_MDICHILD
#define WEFTOOLWINDOW           0x0880  // WS_EX_TOOLWINDOW
#define WEFWINDOWEDGE           0x0901  // WS_EX_WINDOWEDGE
#define WEFCLIENTEDGE           0x0902  // WS_EX_CLIENTEDGE
#define WEFEDGEMASK             0x0903  // WS_EX_WINDOWEDGE | WS_EX_CLIENTEDGE
#define WEFCONTEXTHELP          0x0904  // WS_EX_CONTEXTHELP
#define WEFGHOSTMAKEVISIBLE     0x0908  // WS_EXP_GHOSTMAKEVISIBLE


// intl styles
#define WEFRIGHT                0x0910  // WS_EX_RIGHT
#define WEFRTLREADING           0x0920  // WS_EX_RTLREADING
#define WEFLEFTSCROLL           0x0940  // WS_EX_LEFTSCROLLBAR


#define WEFCONTROLPARENT        0x0A01  // WS_EX_CONTROLPARENT
#define WEFSTATICEDGE           0x0A02  // WS_EX_STATICEDGE
#define WEFAPPWINDOW            0x0A04  // WS_EX_APPWINDOW
#define WEFLAYERED              0x0A08  // WS_EX_LAYERED

#define WEFNOINHERITLAYOUT      0x0A10  // WS_EX_NOINHERITLAYOUT
#define WEFLAYOUTVBHRESERVED    0x0A20  // WS_EX_LAYOUTVBHRESERVED
#define WEFLAYOUTRTL            0x0A40  // WS_EX_LAYOUTRTL
#define WEFLAYOUTBTTRESERVED    0x0A80  // WS_EX_LAYOUTBTTRESERVED

/*
 * To delay adding a new state3 DWORD in the WW structure, we're using
 * the extended style bits for now.  If we'll need more of these, we'll
 * add the new DWORD and move these ones around
 */
#define WEFPUIFOCUSHIDDEN         0x0B80  // focus indicators hidden
#define WEFPUIACCELHIDDEN         0x0B40  // keyboard acceleraors hidden
#define WEFPREDIRECTED            0x0B20  // redirection bit
#define WEFPCOMPOSITING           0x0B10  // compositing


/*
 * Add more Window Extended Style flags here, up to 0x0B80.
 * Be sure to add the flag to the wFlags array in kd\userexts.c
 */
#ifdef REDIRECTION
#define WEFEXTREDIRECTED        0x0B01   // WS_EX_EXTREDIRECTED
#endif // REDIRECTION

#define WEFCOMPOSITED           0x0B02   // WS_EX_COMPOSITED
#define WEFPUIACTIVE            0x0B04   // WS_EXP_UIACTIVE
#define WEFNOACTIVATE           0x0B08   // WS_EX_NOACTIVATE

#ifdef LAME_BUTTON
#define WEFLAMEBUTTON           0x0980   // the window should display a lame button
#endif // LAME_BUTTON

/*
 * Window styles, from 0x0E00 to 0x0F80.
 */
#define WFMAXBOX                0x0E01  // WS_MAXIMIZEBOX
#define WFTABSTOP               0x0E01  // WS_TABSTOP
#define WFMINBOX                0x0E02  // WS_MAXIMIZEBOX
#define WFGROUP                 0x0E02  // WS_GROUP
#define WFSIZEBOX               0x0E04  // WS_THICKFRAME, WS_SIZEBOX
#define WFSYSMENU               0x0E08  // WS_SYSMENU
#define WFHSCROLL               0x0E10  // WS_HSCROLL
#define WFVSCROLL               0x0E20  // WS_VSCROLL
#define WFDLGFRAME              0x0E40  // WS_DLGFRAME
#define WFTOPLEVEL              0x0E40  // ???
#define WFBORDER                0x0E80  // WS_BORDER
#define WFBORDERMASK            0x0EC0  // WS_BORDER | WS_DLGFRAME
#define WFCAPTION               0x0EC0  // WS_CAPTION

#define WFTILED                 0x0F00  // WS_OVERLAPPED, WS_TILED
#define WFMAXIMIZED             0x0F01  // WS_MAXIMIZE
#define WFCLIPCHILDREN          0x0F02  // WS_CLIPCHILDREN
#define WFCLIPSIBLINGS          0x0F04  // WS_CLIPSIBLINGS
#define WFDISABLED              0x0F08  // WS_DISABLED
#define WFVISIBLE               0x0F10  // WS_VISIBLE
#define WFMINIMIZED             0x0F20  // WS_MINIMIZE
#define WFCHILD                 0x0F40  // WS_CHILD
#define WFPOPUP                 0x0F80  // WS_POPUP
#define WFTYPEMASK              0x0FC0  // WS_CHILD | WS_POPUP
#define WFICONICPOPUP           0x0FC0  // WS_CHILD | WS_POPUP
#define WFICONIC                WFMINIMIZED
/*
 * No more Window style flags are available, use Extended window styles.
 */

/*
 * Window Styles for built-in classes, from 0x0C00 to 0x0D80.
 */

// Buttons
#define BFTYPEMASK              0x0C0F

#define BFRIGHTBUTTON           0x0C20
#define BFICON                  0x0C40
#define BFBITMAP                0x0C80
#define BFIMAGEMASK             0x0CC0

#define BFLEFT                  0x0D01
#define BFRIGHT                 0x0D02
#define BFCENTER                0x0D03
#define BFHORZMASK              0x0D03
#define BFTOP                   0x0D04
#define BFBOTTOM                0x0D08
#define BFVCENTER               0x0D0C
#define BFVERTMASK              0x0D0C
#define BFALIGNMASK             0x0D0F

#define BFPUSHLIKE              0x0D10
#define BFMULTILINE             0x0D20
#define BFNOTIFY                0x0D40
#define BFFLAT                  0x0D80

#define ISBSTEXTOROD(pwnd) (!TestWF(pwnd, BFBITMAP) && !TestWF(pwnd, BFICON))

// Combos
#define CBFSIMPLE               0x0C01
#define CBFDROPDOWN             0x0C02
#define CBFDROPDOWNLIST         0x0C03

#define CBFEDITABLE             0x0C01
#define CBFDROPPABLE            0x0C02
#define CBFDROPTYPE             0x0C03

#define CBFOWNERDRAWFIXED       0x0C10
#define CBFOWNERDRAWVAR         0x0C20
#define CBFOWNERDRAW            0x0C30

#define CBFAUTOHSCROLL          0x0C40
#define CBFOEMCONVERT           0x0C80
#define CBFSORT                 0x0D01
#define CBFHASSTRINGS           0x0D02
#define CBFNOINTEGRALHEIGHT     0x0D04
#define CBFDISABLENOSCROLL      0x0D08
#define CBFBUTTONUPTRACK        0x0D10

#define CBFUPPERCASE            0x0D20
#define CBFLOWERCASE            0x0D40

// Dialogs
#define DFSYSMODAL              0x0C02
#define DF3DLOOK                0x0C04
#define DFNOFAILCREATE          0x0C10
#define DFLOCALEDIT             0x0C20
#define WFNOIDLEMSG             0x0D01
#define DFCONTROL               0x0D04

// Edits
#define EFMULTILINE             0x0C04
#define EFUPPERCASE             0x0C08
#define EFLOWERCASE             0x0C10
#define EFPASSWORD              0x0C20
#define EFAUTOVSCROLL           0x0C40
#define EFAUTOHSCROLL           0x0C80
#define EFNOHIDESEL             0x0D01
#define EFCOMBOBOX              0x0D02
#define EFOEMCONVERT            0x0D04
#define EFREADONLY              0x0D08
#define EFWANTRETURN            0x0D10
#define EFNUMBER                0x0D20

// Scrollbars
#define SBFSIZEBOXTOPLEFT       0x0C02
#define SBFSIZEBOXBOTTOMRIGHT   0x0C04
#define SBFSIZEBOX              0x0C08
#define SBFSIZEGRIP             0x0C10

// Statics
#define SFTYPEMASK              0x0C1F
#define SFREALSIZECONTROL       0x0C40
#define SFNOPREFIX              0x0C80
#define SFNOTIFY                0x0D01
#define SFCENTERIMAGE           0x0D02
#define SFRIGHTJUST             0x0D04
#define SFREALSIZEIMAGE         0x0D08
#define SFSUNKEN                0x0D10
#define SFEDITCONTROL           0x0D20
#define SFELLIPSISMASK          0x0DC0
#define SFWIDELINESPACING       0x0C20


/*
 *
 */
#define SYS_ALTERNATE           0x2000
#define SYS_PREVKEYSTATE        0x4000

/*** AWESOME HACK ALERT!!!
 *
 * The low byte of the WF?PRESENT state flags must NOT be the
 * same as the low byte of the WFBORDER and WFCAPTION flags,
 * since these are used as paint hint masks.  The masks are calculated
 * with the MaskWF macro below.
 *
 * The magnitude of this hack compares favorably with that of the national debt.
 *
 * STATEOFFSET is the offset into the WND structure of the state field.
 * The state field is actually part of the WW structure defined in wowuserp.h
 * which is embedded in the WND structure.
 */
#define STATEOFFSET (FIELD_OFFSET(WND, state))

#define TestWF(hwnd, flag)   (*(((KPBYTE)(hwnd)) + STATEOFFSET + (int)HIBYTE(flag)) & LOBYTE(flag))
#define SetWF(hwnd, flag)    (*(((KPBYTE)(hwnd)) + STATEOFFSET + (int)HIBYTE(flag)) |= LOBYTE(flag))
#define ClrWF(hwnd, flag)    (*(((KPBYTE)(hwnd)) + STATEOFFSET + (int)HIBYTE(flag)) &= ~LOBYTE(flag))
#define MaskWF(flag)         ((WORD)( (HIBYTE(flag) & 1) ? LOBYTE(flag) << 8 : LOBYTE(flag)))


#define TestwndChild(hwnd)   (TestWF(hwnd, WFTYPEMASK) == LOBYTE(WFCHILD))
#define TestwndIPopup(hwnd)  (TestWF(hwnd, WFTYPEMASK) == LOBYTE(WFICONICPOPUP))
#define TestwndTiled(hwnd)   (TestWF(hwnd, WFTYPEMASK) == LOBYTE(WFTILED))
#define TestwndNIPopup(hwnd) (TestWF(hwnd, WFTYPEMASK) == LOBYTE(WFPOPUP))
#define TestwndPopup(hwnd)   (TestwndNIPopup(hwnd) || TestwndIPopup(hwnd))
#define TestwndHI(hwnd)      (TestwndTiled(hwnd) || TestwndIPopup(hwnd))

#define GetChildParent(pwnd) (TestwndChild(pwnd) ? pwnd->spwndParent : (PWND)NULL)
#define GetWindowCreator(pwnd) (TestwndChild(pwnd) ? pwnd->spwndParent : pwnd->spwndOwner)

#define TestwndFrameOn(pwnd) (TestWF(pwnd, WFFRAMEON) && (GETPTI(pwnd)->pq == gpqForeground))

#define GetFullScreen(pwnd)        (TestWF(pwnd, WFFULLSCREENMASK))
#define SetFullScreen(pwnd, state) (ClrWF(pwnd, WFFULLSCREENMASK), \
                                    SetWF(pwnd, WFFULLSCREENBASE | (state & WFFULLSCREENMASK)))

#define FTrueVis(pwnd)       (_IsWindowVisible(pwnd))
#define _IsWindowEnabled(pwnd) (TestWF(pwnd, WFDISABLED)  == 0)
#define _IsIconic(pwnd)        (TestWF(pwnd, WFMINIMIZED) != 0)
#define _IsZoomed(pwnd)        (TestWF(pwnd, WFMAXIMIZED) != 0)

#define SV_UNSET        0x0000
#define SV_SET          0x0001
#define SV_CLRFTRUEVIS  0x0002

/*
 * System menu IDs
 */
#define ID_SYSMENU              0x10
#define ID_CLOSEMENU            0x20
#define CHILDSYSMENU            ID_CLOSEMENU
#define ID_DIALOGSYSMENU        0x30
#define ID_HSCROLLMENU          0x40
#define ID_VSCROLLMENU          0x50

/*
 * Menu Item Structure
 */
typedef struct tagITEM {
    UINT                fType;          // Item Type  Flags
    UINT                fState;         // Item State Flags
    UINT                wID;
    PMENU               spSubMenu;      /* Handle to a popup */
    KHANDLE             hbmpChecked;    /* Bitmap for an on  check */
    KHANDLE             hbmpUnchecked;  /* Bitmap for an off check */
    KLPWSTR             lpstr;          //item's text
    DWORD               cch;            /* String: WCHAR count */
    KERNEL_ULONG_PTR    dwItemData;
    DWORD               xItem;
    DWORD               yItem;
    DWORD               cxItem;
    DWORD               cyItem;
    DWORD               dxTab;
    DWORD               ulX;            /* String: Underline start */
    DWORD               ulWidth;        /* String: underline width */
    KHBITMAP            hbmp;           // item's bitmap
    int                 cxBmp;          // bitmap width
    int                 cyBmp;          // bitmap height
} ITEM, * KPTR_MODIFIER PITEM, * KPTR_MODIFIER LPITEM;

/*
 * MENULIST structure, holds the PMENUs that contain a submenu
 * We store a list of menus in MENU.pParentMenus as a menu
 * can be submenu in more items
 */
typedef struct tagMENULIST {
    struct tagMENULIST   *pNext;
    PMENU       pMenu;
} MENULIST, * KPTR_MODIFIER PMENULIST;

/*
 * Scroll menu arrow flags
 */
#define MSA_OFF         0
#define MSA_ON          1
#define MSA_ATTOP       2
#define MSA_ATBOTTOM    3

/*
 * Menu Structure
 */
typedef struct tagMENU {
    PROCDESKHEAD    head;
    DWORD           fFlags;         /* Menu Flags */
    int             iItem;          /* Contains the position of the selected
                                       item in the menu. -1 if no selection */
    UINT            cAlloced;       // Number of items that can fit in rgItems
    UINT            cItems;         /* Number of items in rgItems */

    DWORD           cxMenu;
    DWORD           cyMenu;
    DWORD           cxTextAlign;    /* Text align offset for popups*/
    PWND            spwndNotify;     /* The owner hwnd of this menu */
    PITEM           rgItems;        /* The list of items in this menu */
    PMENULIST       pParentMenus;   // The list of parents (menus that have this as submenu)
    DWORD           dwContextHelpId;// Context help Id for the whole menu
    DWORD           cyMax;          /* max menu height after which menu scrolls */
    KERNEL_ULONG_PTR dwMenuData;     /* app-supplied menu data */

    KHBRUSH         hbrBack;        // background brush for menu
    int             iTop;           // Scroll top
    int             iMaxTop;        // Scroll MaxTop
    DWORD           dwArrowsOn:2;   // Scroll flags
} MENU, * KPTR_MODIFIER PMENU;


/*
 *  Items used for WinHelp and Context Sensitive help support
 */

#define ID_HELPMENU            4

// WINHELP4 invoked type
enum {
        TYPE_NORMAL,
        TYPE_POPUP,
        TYPE_TCARD
};

typedef struct tagDLGENUMDATA {
    PWND    pwndDialog;
    PWND    pwndControl;
    POINT   ptCurHelp;
} DLGENUMDATA, *PDLGENUMDATA;

BOOL CALLBACK EnumPwndDlgChildProc(PWND pwnd, LPARAM lParam);
BOOL FIsParentDude(PWND pwnd);


#define MNF_DONTSKIPSEPARATORS      0x0001

/*
 * The following masks can be used along with the wDisableFlags field of SB
 * to find if the Up/Left or Down/Right arrow or Both are disabled;
 * Now it is possible to selectively Enable/Disable just one or both the
 * arrows in a scroll bar control;
 */
#define LTUPFLAG    0x0001  // Left/Up arrow disable flag.
#define RTDNFLAG    0x0002  // Right/Down arrow disable flag.

typedef struct tagSBCALC {
    SBDATA;               /* this must be first -- we cast structure pointers */
    int    pxTop;
    int    pxBottom;
    int    pxLeft;
    int    pxRight;
    int    cpxThumb;
    int    pxUpArrow;
    int    pxDownArrow;
    int    pxStart;         /* Initial position of thumb */
    int    pxThumbBottom;
    int    pxThumbTop;
    int    cpx;
    int    pxMin;
} SBCALC, *PSBCALC;

typedef struct tagSBTRACK {
    DWORD  fHitOld : 1;
    DWORD  fTrackVert : 1;
    DWORD  fCtlSB : 1;
    DWORD  fTrackRecalc: 1;
    PWND   spwndTrack;
    PWND   spwndSB;
    PWND   spwndSBNotify;
    RECT   rcTrack;
    VOID   (*xxxpfnSB)(PWND, UINT, WPARAM, LPARAM, PSBCALC);
    UINT   cmdSB;
    UINT_PTR hTimerSB;
    int    dpxThumb;        /* Offset from mouse point to start of thumb box */
    int    pxOld;           /* Previous position of thumb */
    int    posOld;
    int    posNew;
    int    nBar;
    PSBCALC pSBCalc;
} SBTRACK, *PSBTRACK;

/*
 * How many times a thread can spin through get/peek message without idling
 * before the system puts the app in the background.
 */
#define CSPINBACKGROUND 100

#define CCHTITLEMAX     256

#define SW_MDIRESTORE   0xCC    /* special xxxMinMaximize() command for MDI */

/*
 * This is used by CreateWindow() - the 16 bit version of CW_USEDEFAULT,
 * that we still need to support.
 */
#define CW2_USEDEFAULT          0x8000
#define CW_FLAGS_DIFFHMOD       0x80000000
#define CW_FLAGS_VERSIONCLASS   0x40000000


/*
 * Menu commands
 */
//#define MENUBIT             (0x8000)
//#define MENUUP              (0x8000 | VK_UP)
//#define MENUDOWN            (0x8000 | VK_DOWN)
//#define MENULEFT            (0x8000 | VK_LEFT)
//#define MENURIGHT           (0x8000 | VK_RIGHT)
//#define MENUEXECUTE         TEXT('\r')      /* Return character */
#define MENUSYSMENU         TEXT(' ')       /* Space character */
#define MENUCHILDSYSMENU    TEXT('-')       /* Hyphen */
#define LAMEBUTTONHOTKEY    TEXT('/')       /* Forward slash */

#define MF_ALLSTATE         0x00FF
#define MF_MAINMENU         0xFFFF
#define MFMWFP_OFFMENU      0
#define MFMWFP_MAINMENU     0x0000FFFF
#define MFMWFP_NOITEM       0xFFFFFFFF
#define MFMWFP_UPARROW      0xFFFFFFFD  /* Warning: Also used to define IDSYS_MNUP */
#define MFMWFP_DOWNARROW    0xFFFFFFFC  /* Warning: Also used to define IDSYS_MNDOWN */
#define MFMWFP_MINVALID     0xFFFFFFFC
#define MFMWFP_ALTMENU      0xFFFFFFFB
#define MFMWFP_FIRSTITEM    0


/*
 * NOTE: SetMF() can only be used on single bit flags.
 */
#define SetMF(pmenu, flag)    ((pmenu)->fFlags |=  (flag))
#define ClearMF(pmenu, flag)  ((pmenu)->fFlags &= ~(flag))
#define TestMF(pmenu, flag)   ((pmenu)->fFlags &   (flag))

#define SetMFS(pitem, flag)   ((pitem)->fState |=  (flag))
#define TestMFS(pitem, flag)  ((pitem)->fState &   (flag))
#define ClearMFS(pitem, flag) ((pitem)->fState &= ~(flag))

#define SetMFT(pitem, flag)   ((pitem)->fType |=  (flag))
#define TestMFT(pitem, flag)  ((pitem)->fType &   (flag))
#define ClearMFT(pitem, flag) ((pitem)->fType &= ~(flag))

/*
 * Dialog structure (dlg). The window-words for the dialog structure must
 * be EXACTLY 30 bytes long! This is because Windows 3.0 exported a constant
 * called DLGWINDOWEXTRA that resolved to 30. Although we could redefine this
 * for 32-bit windows apps, we cannot redefine it for 16 bit apps (it is
 * a difficult problem). So instead we peg the window-words at 30 bytes
 * exactly, and allocate storage for the other information.
 */
typedef struct _DLG {
    DLGPROC lpfnDlg;
    DWORD   flags;          /* Various useful flags -- see definitions below */
    int     cxChar;
    int     cyChar;
    KHWND   hwndFocusSave;
    UINT    fEnd      : 1;
    UINT    fDisabled : 1;
    KERNEL_INT_PTR result;         /* DialogBox result */
    KHANDLE  hData;          /* Global handle for edit ctl storage. */
    KHFONT   hUserFont;      /* Handle of the font mentioned by the user in template*/
#ifdef SYSMODALWINDOWS
    KHWND    hwndSysModalSave;  /* Previous sysmodal window saved here */
#endif
} DLG, * KPTR_MODIFIER PDLG;

typedef struct _DIALOG {
    WND             wnd;
    KERNEL_LRESULT  resultWP;       /* window proc result -- DWL_MSGRESULT (+0) */
    PDLG            pdlg;
    KERNEL_LONG_PTR unused;        /* DWL_USER (+8) */
    BYTE            reserved[DLGWINDOWEXTRA - sizeof(KERNEL_LRESULT) - sizeof(PDLG) - sizeof(KERNEL_LONG_PTR)];
} DIALOG, * KPTR_MODIFIER PDIALOG;

#define PDLG(pwnd) (((PDIALOG)pwnd)->pdlg)

/*
 * Flags definitions for DLG.flags
 */
#define DLGF_ANSI           0x01    /* lpfnDlg is an ANSI proc */

/*
 * MDI typedefs
 */
typedef struct tagMDI {
    UINT    cKids;
    HWND    hwndMaxedChild;
    HWND    hwndActiveChild;
    HMENU   hmenuWindow;
    UINT    idFirstChild;
    UINT    wScroll;
    LPWSTR  pTitle;
    UINT    iChildTileLevel;
} MDI, * PMDI;

typedef struct tagMDIWND {
    WND             wnd;
    KERNEL_UINT_PTR dwReserved; // quattro pro 1.0 stores stuff here!!
    PMDI            pmdi;
} MDIWND, * KPTR_MODIFIER PMDIWND;

#define CST_DESKTOP                 (UINT)0x00000001
#define CST_RIT                     (UINT)0x00000002
#define CST_GHOST                   (UINT)0x00000003
#define CST_POWER                   (UINT)0x00000004
#define CST_LAST                    (UINT)0x00000004

#define GWLP_MDIDATA        (FIELD_OFFSET(MDIWND, pmdi) - sizeof(WND))

#define TIF_INCLEANUP               (UINT)0x00000001
#define TIF_16BIT                   (UINT)0x00000002
#define TIF_SYSTEMTHREAD            (UINT)0x00000004
#define TIF_CSRSSTHREAD             (UINT)0x00000008
#define TIF_TRACKRECTVISIBLE        (UINT)0x00000010
#define TIF_ALLOWFOREGROUNDACTIVATE (UINT)0x00000020
#define TIF_DONTATTACHQUEUE         (UINT)0x00000040
#define TIF_DONTJOURNALATTACH       (UINT)0x00000080
#define TIF_WOW64                   (UINT)0x00000100 /* Thread is in a emulated 32bit process */
#define TIF_INACTIVATEAPPMSG        (UINT)0x00000200
#define TIF_SPINNING                (UINT)0x00000400
#define TIF_PALETTEAWARE            (UINT)0x00000800
#define TIF_SHAREDWOW               (UINT)0x00001000
#define TIF_FIRSTIDLE               (UINT)0x00002000
#define TIF_WAITFORINPUTIDLE        (UINT)0x00004000
#define TIF_MOVESIZETRACKING        (UINT)0x00008000
#define TIF_VDMAPP                  (UINT)0x00010000
#define TIF_DOSEMULATOR             (UINT)0x00020000
#define TIF_GLOBALHOOKER            (UINT)0x00040000
#define TIF_DELAYEDEVENT            (UINT)0x00080000
#define TIF_MSGPOSCHANGED           (UINT)0x00100000
#define TIF_IGNOREPLAYBACKDELAY     (UINT)0x00200000
#define TIF_ALLOWOTHERACCOUNTHOOK   (UINT)0x00400000
#define TIF_MEOW                    (UINT)0x00800000 /* Thread is associated with the MEOW VM */
#define TIF_GUITHREADINITIALIZED    (UINT)0x01000000
#define TIF_DISABLEIME              (UINT)0x02000000
#define TIF_INGETTEXTLENGTH         (UINT)0x04000000
#define TIF_ANSILENGTH              (UINT)0x08000000
#define TIF_DISABLEHOOKS            (UINT)0x10000000
#define TIF_RESTRICTED              (UINT)0x20000000
#define TIF_QUITPOSTED              (UINT)0x40000000


/*
 * Client Thread Information Structure.
 *
 *   This structure contains information regarding the
 *   thread.  This is viewable from both the client and
 *   kernel processes.
 */
typedef struct tagCLIENTTHREADINFO {
    UINT        CTIF_flags;
    WORD        fsChangeBits;           // Bits changes since last compared
    WORD        fsWakeBits;             // Bits currently available
    WORD        fsWakeBitsJournal;      // Bits saved while journalling
    WORD        fsWakeMask;             // Bits looking for when asleep
    LONG        timeLastRead;           // Time of last input read
#ifdef MESSAGE_PUMP_HOOK
    LONG        cMessagePumpHooks;      // Count of installed MPH's on this thread
#endif
} CLIENTTHREADINFO;

#define CTIF_SYSQUEUELOCKED         (UINT)0x00000001
#define CTIF_INSENDMESSAGE          (UINT)0x00000002
#define CTIF_INCALLBACKMESSAGE      (UINT)0x00000004

/*
 * First check for a 0, 0 filter which means we want all input.
 * If inverted message range, filter is exclusive.
 */
#define CheckMsgFilter(wMsg, wMsgFilterMin, wMsgFilterMax)                 \
    (   ((wMsgFilterMin) == 0 && (wMsgFilterMax) == 0xFFFFFFFF)            \
     || (  ((wMsgFilterMin) > (wMsgFilterMax))                             \
         ? (((wMsg) <  (wMsgFilterMax)) || ((wMsg) >  (wMsgFilterMin)))    \
         : (((wMsg) >= (wMsgFilterMin)) && ((wMsg) <= (wMsgFilterMax)))))

UINT    CalcWakeMask(UINT wMsgFilterMin, UINT wMsgFilterMax, UINT fsWakeMaskFilter);

/*
 * GetInputBits
 *
 * This function checks if the specified input (fsWakeMask) has arrived
 * (fsChangeBits) or it's available (fsWakeBits).
 */
__inline WORD GetInputBits(
    CLIENTTHREADINFO *pcti,
    WORD fsWakeMask,
    BOOL fAvailable)
{
    return (pcti->fsChangeBits  | (fAvailable ? pcti->fsWakeBits : 0)) & fsWakeMask;
}


typedef struct tagCARET {
    struct tagWND *spwnd;
    UINT    fVisible : 1;
    UINT    fOn      : 1;
    int     iHideLevel;
    int     x;
    int     y;
    int     cy;
    int     cx;
    HBITMAP hBitmap;
    UINT_PTR hTimer;
    DWORD   tid;

    /*
     * The following values are used to track the equivelent client coordinates
     * for caret positions in a window with a private DC.
     * See Also: zzzSetCaretPos, _GetGUIThreadInfo
     */
    int     xOwnDc;
    int     yOwnDc;
    int     cxOwnDc;
    int     cyOwnDc;
} CARET, *PCARET;

#define XPixFromXDU(x, cxChar)       MultDiv(x, cxChar, 4)
#define YPixFromYDU(y, cyChar)       MultDiv(y, cyChar, 8)
#define XDUFromXPix(x, cxChar)       MultDiv(x, 4, cxChar)
#define YDUFromYPix(y, cyChar)       MultDiv(y, 8, cyChar)


/*
 * Flags for the Q structure.
 */
#define QF_UPDATEKEYSTATE         (UINT)0x00001 // Set as key events are received. See PostUpdateKeyStateEvent.

#define QF_FMENUSTATUSBREAK       (UINT)0x00004 // Mouse button went up/down while ALT key was down == ignore ALT up.
#define QF_FMENUSTATUS            (UINT)0x00008 // ALT key down - toggle menu status mode (enter or exit).
#define QF_FF10STATUS             (UINT)0x00010 // Context menu key down. Treat us ALT if set on key up.
#define QF_MOUSEMOVED             (UINT)0x00020 // Mouse has moved but no move posted yet. Coalescing & performance
#define QF_ACTIVATIONCHANGE       (UINT)0x00040 // This flag is examined in the
                                                // menu loop code so that we
                                                // exit from menu mode if
                                                // another window was activated
                                                // while we were tracking
                                                // menus. This flag is set
                                                // whenever we activate a new
                                                // window.

#define QF_TABSWITCHING           (UINT)0x00080 // This bit is used as a
                                                // safety check when alt-
                                                // tabbing between apps.  It
                                                // tells us when to expect
                                                // a tab-switch in dwp.c.

#define QF_KEYSTATERESET          (UINT)0x00100 // Used by xxxSwitchDesktop to overwrite the key state upon desktop activation
#define QF_INDESTROY              (UINT)0x00200 // Debug only. To make sure we don't use a queue to be destroyed.
#define QF_LOCKNOREMOVE           (UINT)0x00400 // An input message has been peeked but not removed. Must be removed next.
#define QF_FOCUSNULLSINCEACTIVE   (UINT)0x00800 // Application set focus to NULL. Don't send focus messages on activation
#define QF_DIALOGACTIVE           (UINT)0x04000 // To pass this info in key/char messages lparam's. Undocumented.
#define QF_EVENTDEACTIVATEREMOVED (UINT)0x08000 //

#define QF_CAPTURELOCKED             0x00100000 // Set by menu mode. Prevent capture changes.
#define QF_ACTIVEWNDTRACKING         0x00200000 // Mouse has moved over a new window while in active wnd tracking mode

/*
 * Constants for Round Frame balloons
 */
#define RNDFRM_CORNER 10
#define RNDFRM_BORDER 3

/*
 * Constants for GetRealClientRect
 */
#define GRC_SCROLLS     0x0001
#define GRC_MINWNDS     0x0002
#define GRC_FULLSCREEN  0x0004

/*
 * Scroll bar info structure
 */
typedef struct tagSBWND {
    WND    wnd;
    BOOL   fVert;
#ifdef COLOR_HOTTRACKING
    int    ht;
#endif // COLOR_HOTTRACKING
    UINT   wDisableFlags;       /* Indicates which arrow is disabled; */
    SBCALC SBCalc;
} SBWND, * KPTR_MODIFIER PSBWND;

//
// Special regions
//
#define HRGN_NONE           ((HRGN)-1)
#define HRGN_EMPTY          ((HRGN)0)
#define HRGN_FULL           ((HRGN)1)
#define HRGN_MONITOR        ((HRGN)2)
#define HRGN_SPECIAL_LAST   HRGN_MONITOR

/*
 * SendMsgTimeout client/server transition struct
 */
typedef struct tagSNDMSGTIMEOUT {   /* smto */
    UINT fuFlags;                       // how to send the message, SMTO_BLOCK, SMTO_ABORTIFHUNG
    UINT uTimeout;                      // time-out duration
    ULONG_PTR lSMTOReturn;              // return value TRUE or FALSE
    ULONG_PTR lSMTOResult;              // result value for lpdwResult
} SNDMSGTIMEOUT, *PSNDMSGTIMEOUT;

typedef struct tagSNDMSGCALLBACK {
    SENDASYNCPROC lpResultCallBack;
    ULONG_PTR dwData;
} SNDMSGCALLBACK, *PSNDMSGCALLBACK;


#ifndef _USERK_
#if DBG
ULONG_PTR USERTHREADCONNECT();
__inline ULONG_PTR USERTHREADCONNECT()
{
    ULONG_PTR ulReturn;

    ulReturn = NtUserGetThreadState(UserThreadConnect);
    UserAssert(ulReturn == 0 || ulReturn == 1);
    return ulReturn;
}
#else
#define USERTHREADCONNECT() (NtUserGetThreadState(UserThreadConnect))
#endif // DBG

#define ConnectIfNecessary(retval) \
{ \
    if ((NtCurrentTebShared()->Win32ThreadInfo == NULL) \
            && !USERTHREADCONNECT()) { \
        return retval; \
    } \
}
#endif // !_USERK_

/*
 *  Button data structures (use to be in usercli.h)
 */
typedef struct tagBUTN {
    PWND spwnd;
    UINT buttonState;
    KHANDLE hFont;
    KHANDLE hImage;
    UINT fPaintKbdCuesOnly : 1;
} BUTN, * KPTR_MODIFIER PBUTN;

typedef struct tagBUTNWND {
    WND wnd;
    PBUTN pbutn;
} BUTNWND, * KPTR_MODIFIER PBUTNWND;

/*
 * IME control data structures
 */
typedef struct tagIMEUI {
    PWND  spwnd;
    KHIMC hIMC;
    KHWND hwndIMC;
    KHKL  hKL;
    KHWND hwndUI;               // To keep handle for UI window.
    int   nCntInIMEProc;        // Non-zero if hwnd has called into ImeWndProc.
    BOOL  fShowStatus:1;        // TRUE if don't want to show IME's window.
    BOOL  fActivate:1;          // TRUE if hwnd has called into ImeWndProc.
    BOOL  fDestroy:1;           // TRUE if hwnd has called into ImeWndProc.
    BOOL  fDefault:1;           // TRUE if this is the default IME.
    BOOL  fChildThreadDef:1;    // TRUE if this is the default IME which
                                // thread has only child window.
    BOOL  fCtrlShowStatus:1;    // Control status of show status bar.
    BOOL  fFreeActiveEvent:1;   // Control status of show status bar.

#ifdef CUAS_ENABLE
    // Cicero
    DWORD dwPrevToolbarStatus;  // Cicero for Hide or RestoreToolbar
#endif // CUAS_ENABLE
} IMEUI, *PIMEUI;

typedef struct tagIMEWND {
    WND wnd;
    PIMEUI pimeui;
} IMEWND, * KPTR_MODIFIER PIMEWND;


/*
 * SysErrorBox is a 3.1 API that has no 32-bit equivalent.  It's
 * implemented for WOW in harderr.c.
 */
#define MAX_SEB_STYLES  11  /* number of SEB_* values */

/*
 * The next values should be in the same order
 * with the ones in IDOK and STR_OK lists
 */
#define  SEB_OK         0  /* Button with "OK".     */
#define  SEB_CANCEL     1  /* Button with "Cancel"  */
#define  SEB_ABORT      2  /* Button with "&Abort"   */
#define  SEB_RETRY      3  /* Button with "&Retry"   */
#define  SEB_IGNORE     4  /* Button with "&Ignore"  */
#define  SEB_YES        5  /* Button with "&Yes"     */
#define  SEB_NO         6  /* Button with "&No"      */
#define  SEB_CLOSE      7  /* Button with "&Close"   */
#define  SEB_HELP       8  /* Button with "&Help"    */
#define  SEB_TRYAGAIN   9  /* Button with "&Try Again"  */
#define  SEB_CONTINUE   10 /* Button with "&Continue"   */

#define  SEB_DEFBUTTON  0x8000  /* Mask to make this button default */

typedef struct _MSGBOXDATA {            // mbd
    MSGBOXPARAMS;                       // Must be 1st item in structure
    PWND     pwndOwner;                 // Converted hwndOwner
    WORD     wLanguageId;
    INT    * pidButton;                 // Array of button IDs
    LPWSTR * ppszButtonText;            // Array of button text strings
    UINT     cButtons;                  // Number of buttons
    UINT     DefButton;
    UINT     CancelId;
    DWORD    dwTimeout;
    HWND     *phwndList;
} MSGBOXDATA, *PMSGBOXDATA, *LPMSGBOXDATA;

LPWSTR MB_GetString(UINT wBtn);
int    SoftModalMessageBox(LPMSGBOXDATA lpmb);

DWORD GetContextHelpId(PWND pwnd);

PITEM  MNLookUpItem(PMENU pMenu, UINT wCmd, BOOL fByPosition, PMENU *ppMenuItemIsOn);
BOOL xxxMNCanClose(PWND pwnd);
PMENU xxxGetSysMenuHandle(PWND pwnd);
PWND    GetPrevPwnd(PWND pwndList, PWND pwndFind);
BOOL   _RegisterServicesProcess(DWORD dwProcessId);

#ifdef _USERK_
#define RTLMENU PMENU
#define RtlGetSubMenu(rtlMenu, nPos) _GetSubMenu(rtlMenu, nPos)
#define xxxRtlSetMenuInfo xxxSetMenuInfo
#define xxxRtlInsertMenuItem(rtlMenu, wIndex, fByPos, lpmii, pstrItem) \
            xxxInsertMenuItem(rtlMenu, wIndex, fByPos, lpmii, pstrItem)
#define xxxRtlSetMenuItemInfo(rtlMenu, uId, pmii) \
            xxxSetMenuItemInfo(rtlMenu, uId, FALSE, pmii, NULL)
#else
#define RTLMENU HMENU
#define RtlGetSubMenu(rtlMenu, nPos) GetSubMenu(rtlMenu, nPos)
#define xxxRtlSetMenuInfo NtUserThunkedMenuInfo
#define xxxRtlInsertMenuItem(rtlMenu, wIndex, fByPos, lpmii, pstrItem) \
            InternalInsertMenuItem(rtlMenu, wIndex, fByPos, lpmii)
#define xxxRtlSetMenuItemInfo(rtlMenu, uId, pmii) \
            NtUserThunkedMenuItemInfo(rtlMenu, uId, FALSE, FALSE, pmii, NULL)
#endif
#ifdef LAME_BUTTON
RTLMENU xxxLoadSysMenu(UINT uMenuId, PWND pwnd);
#else
RTLMENU xxxLoadSysMenu(UINT uMenuId);
#endif // LAME_BUTTON


BOOL _FChildVisible(PWND pwnd);

#define CH_PREFIX TEXT('&')
//
// Japan support both Kanji and English mnemonic characters,
// toggled from control panel.  Both mnemonics are embedded in menu
// resource templates.  The following prefixes guide their parsing.
//
#define CH_ENGLISHPREFIX 0x1E
#define CH_KANJIPREFIX   0x1F


BOOL RtlWCSMessageWParamCharToMB(DWORD msg, WPARAM *pWParam);
BOOL RtlMBMessageWParamCharToWCS(DWORD msg, WPARAM *pWParam);

VOID RtlInitLargeAnsiString(PLARGE_ANSI_STRING plstr, LPCSTR psz,
        UINT cchLimit);
VOID RtlInitLargeUnicodeString(PLARGE_UNICODE_STRING plstr, LPCWSTR psz,
        UINT cchLimit);

DWORD RtlGetExpWinVer(HANDLE hmod);

/***************************************************************************\
*
* International multi-keyboard layout/font support
*
\***************************************************************************/

#define DT_CHARSETDRAW  1
#define DT_GETNEXTWORD  2

typedef void (FAR *LPFNTEXTDRAW)(HDC, int, int, LPWSTR, int, DWORD);

typedef  struct   {
    RECT     rcFormat;          // Format rectangle.
    int      cxTabLength;       // Tab length in pixels.
    int      iXSign;
    int      iYSign;
    int      cyLineHeight;      // Height of a line based on DT_EXTERNALLEADING
    int      cxMaxWidth;        // Width of the format rectangle.
    int      cxMaxExtent;       // Width of the longest line drawn.
    int      cxRightMargin;     // Right margin in pixels (with proper sign)
    LPFNTEXTDRAW  lpfnTextDraw; // pointer to PSTextOut or PSMTextOut based
                                // on DT_NOPREFIX flag.
    int      cxOverhang;        // Character overhang.
    BOOL     bCharsetDll;       // redirect to intl DLL, not textout
    int      iCharset;          // ANSI charset value
} DRAWTEXTDATA, *LPDRAWTEXTDATA;

typedef LONG (*FPLPKTABBEDTEXTOUT)
               (HDC, int, int, LPCWSTR, int, int, CONST INT *, int, BOOL, int, int, int);

typedef void (*FPLPKPSMTEXTOUT)
               (HDC, int, int, LPWSTR, int, DWORD);

typedef int  (*FPLPKDRAWTEXTEX)
               (HDC, int, int, LPCWSTR, int, BOOL, UINT, LPDRAWTEXTDATA, UINT, int);

extern FPLPKTABBEDTEXTOUT fpLpkTabbedTextOut;
extern FPLPKPSMTEXTOUT    fpLpkPSMTextOut;
extern FPLPKDRAWTEXTEX    fpLpkDrawTextEx;


// The number of characters in the ellipsis string (string defined in rtl\drawtext.c).
#define CCHELLIPSIS  3

int DrawTextExWorker(HDC hdc, LPWSTR lpchText, int cchText, LPRECT lprc,
                     UINT dwDTformat, LPDRAWTEXTPARAMS lpDTparams, int iCharset);


/***************************************************************************\
*
* Language pack edit control callouts.
*
* Functions are accessed through the pLpkEditCallout pointer in the ED
* structure. pLpkEditCallout points to a structure containing a pointer
* to each callout routine. These are typedef'd here.
*
* (In Windows95 this was achieved through a single function pointer
* - lpfnCharset - which was written in assembler and called from over 30
* places with different parameters. Since for NT the Lpk is written in C,
* the ED structure now points to a list of function pointers, each properly
* typedef'd, improving performance, enabling typechecking and avoiding
* varargs discrepancies between architectures.)
*
\***************************************************************************/

typedef struct tagED *PED;

typedef BOOL LpkEditCreate        (PED ped, HWND hWnd);

typedef int  LpkEditIchToXY       (PED ped, HDC hDC, PSTR pText, ICH cch, ICH ichPos);

typedef ICH  LpkEditMouseToIch    (PED ped, HDC hDC, PSTR pText, ICH cch, INT iX);

typedef ICH  LpkEditCchInWidth    (PED ped, HDC hdc, PSTR pText, ICH cch, int width);

typedef INT  LpkEditGetLineWidth  (PED ped, HDC hdc, PSTR pText, ICH cch);

typedef void LpkEditDrawText      (PED ped, HDC hdc, PSTR pText, INT cch, INT iMinSel, INT iMaxSel, INT iY);

typedef BOOL LpkEditHScroll       (PED ped, HDC hdc, PSTR pText);

typedef ICH  LpkEditMoveSelection (PED ped, HDC hdc, PSTR pText, ICH ich, BOOL fLeft);

typedef int  LpkEditVerifyText    (PED ped, HDC hdc, PSTR pText, ICH ichInsert, PSTR pInsertText, ICH cchInsert);

typedef void LpkEditNextWord      (PED ped, HDC hdc, PSTR pText, ICH ichStart, BOOL fLeft, ICH *pichMin, ICH *pichMax);

typedef void LpkEditSetMenu       (PED ped, HMENU hMenu);

typedef int  LpkEditProcessMenu   (PED ped, UINT idMenuItem);

typedef int  LpkEditCreateCaret   (PED ped, HDC hdc, INT nWidth, INT nHeight, UINT hkl);

typedef ICH  LpkEditAdjustCaret   (PED ped, HDC hdc, PSTR pText, ICH ich);


typedef struct tagLPKEDITCALLOUT {
    LpkEditCreate        *EditCreate;
    LpkEditIchToXY       *EditIchToXY;
    LpkEditMouseToIch    *EditMouseToIch;
    LpkEditCchInWidth    *EditCchInWidth;
    LpkEditGetLineWidth  *EditGetLineWidth;
    LpkEditDrawText      *EditDrawText;
    LpkEditHScroll       *EditHScroll;
    LpkEditMoveSelection *EditMoveSelection;
    LpkEditVerifyText    *EditVerifyText;
    LpkEditNextWord      *EditNextWord;
    LpkEditSetMenu       *EditSetMenu;
    LpkEditProcessMenu   *EditProcessMenu;
    LpkEditCreateCaret   *EditCreateCaret;
    LpkEditAdjustCaret   *EditAdjustCaret;
} LPKEDITCALLOUT, *PLPKEDITCALLOUT;

extern PLPKEDITCALLOUT    fpLpkEditControl;

/***************************************************************************\
*
*  Structure for client-side thread-info.
*   dwHookCurrent HIWORD is current hook filter type (eg: WH_GETMESSAGE)
*                 LOWORD is TRUE if current hook is ANSI, FALSE if Unicode
*
\***************************************************************************/


/*
 * Hook thunks.
 */
#ifdef REDIRECTION
LRESULT CALLBACK fnHkINLPPOINT(DWORD nCode,
        WPARAM wParam, LPPOINT lParam,
        ULONG_PTR xParam, PROC xpfnProc);
#endif // REDIRECTION

LRESULT CALLBACK fnHkINLPRECT(DWORD nCode,
        WPARAM wParam, LPRECT lParam,
        ULONG_PTR xParam, PROC xpfnProc);
LRESULT CALLBACK fnHkINDWORD(DWORD nCode,
        WPARAM wParam, LPARAM lParam,
        ULONG_PTR xParam, PROC xpfnProc, LPDWORD lpFlags);
LRESULT CALLBACK fnHkINLPMSG(DWORD nCode,
        WPARAM wParam, LPMSG lParam,
        ULONG_PTR xParam, PROC xpfnProc, BOOL bAnsi, LPDWORD lpFlags);
LRESULT CALLBACK fnHkOPTINLPEVENTMSG(DWORD nCode,
        WPARAM wParam, LPEVENTMSGMSG lParam,
        ULONG_PTR xParam, PROC xpfnProc);
LRESULT CALLBACK fnHkINLPDEBUGHOOKSTRUCT(DWORD nCode,
        WPARAM wParam, LPDEBUGHOOKINFO lParam,
        ULONG_PTR xParam, PROC xpfnProc);
LRESULT CALLBACK fnHkINLPMOUSEHOOKSTRUCTEX(DWORD nCode,
        WPARAM wParam, LPMOUSEHOOKSTRUCTEX lParam,
        ULONG_PTR xParam, PROC xpfnProc, LPDWORD lpFlags);
LRESULT CALLBACK fnHkINLPKBDLLHOOKSTRUCT(DWORD nCode,
        WPARAM wParam, LPKBDLLHOOKSTRUCT lParam,
        ULONG_PTR xParam, PROC xpfnProc);
LRESULT CALLBACK fnHkINLPMSLLHOOKSTRUCT(DWORD nCode,
        WPARAM wParam, LPMSLLHOOKSTRUCT lParam,
        ULONG_PTR xParam, PROC xpfnProc);
LRESULT CALLBACK fnHkINLPCBTACTIVATESTRUCT(DWORD nCode,
        WPARAM wParam, LPCBTACTIVATESTRUCT lParam,
        ULONG_PTR xParam, PROC xpfnProc);
LRESULT CALLBACK fnHkINLPCBTCSTRUCT(UINT msg,
        WPARAM wParam, LPCBT_CREATEWND pcbt,
        PROC xpfnProc, BOOL bAnsi);
LRESULT CALLBACK fnHkINLPCBTMDICCSTRUCT(UINT msg,
        WPARAM wParam, LPCBT_CREATEWND pcbt,
        PROC xpfnProc, BOOL bAnsi);

#ifdef REDIRECTION
LRESULT CALLBACK fnHkINLPHTHOOKSTRUCT(DWORD nCode,
        WPARAM wParam, LPHTHOOKSTRUCT lParam,
        ULONG_PTR xParam, PROC xpfnProc);
#endif // REDIRECTION

/***************************************************************************\
*
* Definitions for client/server-specific data referenced by rtl routines.
*
\***************************************************************************/

extern HBRUSH   ghbrWhite;
extern HBRUSH   ghbrBlack;


ULONG_PTR GetCPD(KERNEL_PVOID pWndOrCls, DWORD options, ULONG_PTR dwData);

BOOL TestWindowProcess(PWND pwnd);
DWORD GetAppCompatFlags(PTHREADINFO pti);
DWORD GetAppCompatFlags2(WORD wVer);
DWORD GetAppImeCompatFlags(PTHREADINFO pti);
PWND _GetDesktopWindow(VOID);
PWND _GetMessageWindow(VOID);

/***************************************************************************\
*
* Shared function prototypes
*
\***************************************************************************/


PVOID FASTCALL HMValidateHandle(HANDLE h, BYTE btype);
PVOID FASTCALL HMValidateCatHandleNoRip(HANDLE h, BYTE btype);
PVOID FASTCALL HMValidateHandleNoRip(HANDLE h, BYTE btype);
KERNEL_PVOID FASTCALL HMValidateHandleNoDesktop(HANDLE h, BYTE btype);
PVOID FASTCALL HMValidateSharedHandle(HANDLE h, BYTE bType);

PVOID FASTCALL HMValidateCatHandleNoSecure(HANDLE h, BYTE bType);
PVOID FASTCALL HMValidateCatHandleNoSecureCCX(HANDLE h, BYTE bType, PTHREADINFO pti);
PVOID FASTCALL HMValidateHandleNoSecure(HANDLE h, BYTE bType);

ULONG_PTR MapClientNeuterToClientPfn(PCLS pcls, KERNEL_ULONG_PTR dw, BOOL bAnsi);
ULONG_PTR MapServerToClientPfn(KERNEL_ULONG_PTR dw, BOOL bAnsi);

BOOL IsSysFontAndDefaultMode(HDC hdc);

int GetCharDimensions(HDC hDC, TEXTMETRICW *lpTextMetrics, LPINT lpcy);

int   GetWindowBorders(LONG lStyle, DWORD dwExStyle, BOOL fWindow, BOOL fClient);
PWND  SizeBoxHwnd(PWND pwnd);
VOID  _GetClientRect(PWND pwnd, LPRECT prc);

#ifndef _USERSRV_
void GetRealClientRect(PWND pwnd, LPRECT prc, UINT uFlags, PMONITOR pMonitor);
#endif

VOID  _GetWindowRect(PWND pwnd, LPRECT prc);
PWND  _GetLastActivePopup(PWND pwnd);
BOOL  _IsChild(PWND pwndParent, PWND pwnd);
BOOL  _AdjustWindowRectEx(LPRECT lprc, DWORD style, BOOL fMenu, DWORD dwExStyle);
BOOL  NeedsWindowEdge(DWORD dwStyle, DWORD dwExStyle, BOOL fNewApp);
VOID  _ClientToScreen(PWND pwnd, PPOINT ppt);
VOID  _ScreenToClient(PWND pwnd, PPOINT ppt);
int   _MapWindowPoints(PWND pwndFrom, PWND pwndTo, LPPOINT lppt, DWORD cpt);
BOOL  _IsWindowVisible(PWND pwnd);
BOOL  _IsDescendant(PWND pwndParent, PWND pwndChild);
BOOL  IsVisible(PWND pwnd);
PWND  _GetWindow(PWND pwnd, UINT cmd);
PWND  _GetParent(PWND pwnd);
int   FindNCHit(PWND pwnd, LONG lPt);
SHORT _GetKeyState(int vk);
PHOOK PhkNextValid(PHOOK phk);

#define GRECT_CLIENT        0x0001
#define GRECT_WINDOW        0x0002
#define GRECT_RECTMASK      0x0003

#define GRECT_CLIENTCOORDS  0x0010
#define GRECT_WINDOWCOORDS  0x0020
#define GRECT_PARENTCOORDS  0x0040
#define GRECT_COORDMASK     0x0070

void GetRect(PWND pwnd, LPRECT lprc, UINT uCoords);

PPROP _FindProp(PWND pwnd, PCWSTR pszKey, BOOL fInternal);
HANDLE _GetProp(PWND pwnd, PCWSTR pszKey, BOOL fInternal);
BOOL _HasCaptionIcon(PWND pwnd);
PWND GetTopLevelWindow(PWND pwnd);

BOOL _SBGetParms(PWND pwnd, int code, PSBDATA pw, LPSCROLLINFO lpsi);
BOOL PSMGetTextExtent(HDC hdc, LPCWSTR lpstr, int cch, PSIZE psize);

LONG   GetPrefixCount(LPCWSTR lpstr, int cb, LPWSTR lpstrCopy, int cbCopy);
PMENU _GetSubMenu(PMENU pMenu, int nPos);
DWORD _GetMenuDefaultItem(PMENU pMenu, BOOL fByPosition, UINT uFlags);
UINT _GetMenuState(PMENU pMenu, UINT wID, UINT dwFlags);

BOOL APIENTRY CopyInflateRect(LPRECT prcDst, CONST RECT *prcSrc, int cx, int cy);
BOOL APIENTRY CopyOffsetRect(LPRECT prcDst, CONST RECT *prcSrc, int cx, int cy);

DWORD FindCharPosition(LPWSTR lpString, WCHAR ch);
LPWSTR  TextAlloc(LPCWSTR lpsz);
UINT  TextCopy(PLARGE_UNICODE_STRING pstr, LPWSTR lpstr, UINT size);
DWORD wcsncpycch(LPWSTR pwsDest, LPCWSTR pwszSrc, DWORD cch);
DWORD strncpycch(LPSTR pszDest, LPCSTR pszSrc, DWORD cch);


#define TextPointer(h) ((LPWSTR)h)

BOOL DrawFrame(HDC hdc, LPRECT prect, int clFrame, int cmd);
VOID DrawPushButton(HDC hdc, LPRECT lprc, UINT state, UINT flags);
BOOL ClientFrame(HDC hDC, CONST RECT *pRect, HBRUSH hBrush, DWORD patOp, int cxBorder, int cyBorder);

VOID MirrorClientRect(PWND pwnd, LPRECT lprc);
VOID MirrorWindowRect(PWND pwnd, LPRECT lprc);

#define ISTS() (!!(USER_SHARED_DATA->SuiteMask & (1 << TerminalServer)))

/*
 * Structure for DoConnect system call.
 */
typedef struct _DOCONNECTDATA {
    BOOL   fConsoleShadowFlag;
    BOOL   fMouse;
    BOOL   fINetClient;
    BOOL   fInitialProgram;
    BOOL   fHideTitleBar;
    HANDLE IcaVideoChannel;
    HANDLE IcaBeepChannel;
    HANDLE IcaMouseChannel;
    HANDLE IcaKeyboardChannel;
    HANDLE IcaThinwireChannel;
    HANDLE DisplayChangeEvent;
    WCHAR  WinStationName[32];
    WCHAR  ProtocolName[10];
    WCHAR  AudioDriverName[10];
    BOOL   fClientDoubleClickSupport;
    BOOL   fEnableWindowsKey;
    DWORD  drBitsPerPel;
    DWORD  drPelsWidth;
    DWORD  drPelsHeight;
    DWORD  drDisplayFrequency;
    USHORT drProtocolType;
    CLIENTKEYBOARDTYPE  ClientKeyboardType;
} DOCONNECTDATA, *PDOCONNECTDATA;

/*
 * Structure for DoReconnect system call.
 */

#define DR_DISPLAY_DRIVER_NAME_LENGTH 9
#define DR_PROTOCOL_NAME_LENGTH 9

typedef struct _DORECONNECTDATA {
    BOOL   fMouse;
    BOOL   fINetClient;
    WCHAR  WinStationName[32];
    WCHAR   DisplayDriverName[DR_DISPLAY_DRIVER_NAME_LENGTH];
    WCHAR   ProtocolName[DR_PROTOCOL_NAME_LENGTH];
    WCHAR  AudioDriverName[9];
    BOOL   fClientDoubleClickSupport;
    BOOL   fEnableWindowsKey;
    DWORD  drBitsPerPel;
    DWORD  drPelsWidth;
    DWORD  drPelsHeight;
    DWORD  drDisplayFrequency;
    USHORT drProtocolType;
    BOOL   fChangeDisplaySettings;
    CLIENTKEYBOARDTYPE  ClientKeyboardType;
} DORECONNECTDATA, *PDORECONNECTDATA;

typedef enum _NOTIFYEVENT {
    Notify_Disconnect,
    Notify_Reconnect,
    Notify_PreReconnect,
    Notify_SyncDisconnect,
    Notify_DisableScrnSaver,
    Notify_EnableScrnSaver,
    Notify_StopReadInput,
    Notify_PreReconnectDesktopSwitch,
    Notify_HelpAssistantShadowStart,
    Notify_HelpAssistantShadowFinish,
    Notify_DisconnectPipe
} NOTIFYEVENT, *PNOTIFYEVENT;

typedef struct _DONOTIFYDATA {
    NOTIFYEVENT NotifyEvent;
} DONOTIFYDATA, *PDONOTIFYDATA;

/*
 * EndTask, ExitWindows, hung app, etc time outs
 */
#define CMSSLEEP                250
#define CMSHUNGAPPTIMEOUT       (5 * 1000)
#define CMSHUNGTOKILLCOUNT       4
#define CMSWAITTOKILLTIMEOUT    (CMSHUNGTOKILLCOUNT * CMSHUNGAPPTIMEOUT)
#define CMSAPPSTARTINGTIMEOUT   (6 * CMSHUNGAPPTIMEOUT) /* Some setup apps are pretty slow. bug 195832 */
#define CMS_QANIMATION          165
#define CMS_FLASHWND            500
#define CMS_MENUFADE            175
#define CMS_SELECTIONFADE       350
#define CMS_TOOLTIP             135
#ifdef MOUSE_IP
#define CMS_SONARTIMEOUT        1000    /* if it takes more than this, sonar will just bail out */
#endif
#define PROCESSTERMINATETIMEOUT (90 * 1000)
#define CB_DELAYRENDER_TIMEOUT  (30 *1000)

/*
 * Message table definitions
 */
typedef struct tagMSG_TABLE_ENTRY {
    BYTE iFunction:6;
    BYTE bThunkMessage:1;
    BYTE bSyncOnlyMessage:1;
} MSG_TABLE_ENTRY;

extern CONST MSG_TABLE_ENTRY MessageTable[];

#define TESTSYNCONLYMESSAGE(msg, wParam) (((msg) < WM_USER) ?       \
        (   (MessageTable[msg].bSyncOnlyMessage) ||                 \
            (((msg) == WM_DEVICECHANGE) && ((wParam) & 0x8000))) :  \
        0)

#define BLOCKMESSAGECROSSLUID(msg, ppiSender, ppiReceiver)                    \
    ((msg == EM_SETWORDBREAKPROC) ?                                           \
     !RtlEqualLuid(&(ppiSender->luidSession), &(ppiReceiver->luidSession)) : FALSE)


/*
 * Drag and Drop menus.
 * MNDragOver output info
 */
typedef struct tagMNDRAGOVERINFO
{
    DWORD dwFlags;
    HMENU hmenu;
    UINT uItemIndex;
    HWND hwndNotify;
} MNDRAGOVERINFO, * PMNDRAGOVERINFO;

#ifdef _USERK_
typedef struct tagMOUSECURSOR {
    BYTE bAccelTableLen;
    BYTE bAccelTable[128];
    BYTE bConstantTableLen;
    BYTE bConstantTable[128];
} MOUSECURSOR;
#endif

typedef struct tagINTERNALSETHIGHCONTRAST {
    UINT    cbSize;
    DWORD   dwFlags;
    UNICODE_STRING usDefaultScheme;
} INTERNALSETHIGHCONTRAST, *LPINTERNALSETHIGHCONTRAST;

#define InMsgRange(msg, start, end) (((msg) >= (start)) && ((msg) <= (end)))


/*
 * Enforce 64bit/32bit natural alignment
 * N.b. does not work for byte aligned objects.
 */

#define NATURAL_ALIGNED_PTR(type, x)  ((type*)(((ULONG_PTR)(x) + PROBE_ALIGNMENT(type) - 1) & ~(PROBE_ALIGNMENT(type) - 1)))

#define ARABIC_UI_LANGID()    (gpsi->UILangID == MAKELANGID(LANG_ARABIC, SUBLANG_DEFAULT))
#define HEBREW_UI_LANGID()    (gpsi->UILangID == MAKELANGID(LANG_HEBREW, SUBLANG_DEFAULT))
#define RTL_UI()              (ARABIC_UI_LANGID() || HEBREW_UI_LANGID())

#endif // _USER_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kbd\makefile.inc ===
$(O)\$(TARGETNAME).c $(O)\$(TARGETNAME).h $(O)\$(TARGETNAME).rc $(O)\$(TARGETNAME).def: $(NTUSER_PATH)\kbd\txt\$(TARGETNAME).txt
    cd $(O)
    kbdtool $**
    cd $(MAKEDIR)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\inc\wow.h ===
/****************************** Module Header ******************************\
* Module Name: wow.h
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* This header file contains macros to be used in rtl\wow.c client\ and kernel\
*
* History:
* 22-AUG-97 CLupu      created
\***************************************************************************/


#if !defined(_WIN64)

/*
 * WIN32 and WOW6432 version of StartValidateHandleMacro
 */
#define StartValidateHandleMacro(h)                                         \
{                                                                           \
    PHE phe;                                                                \
    DWORD dw;                                                               \
    WORD uniq;                                                              \
                                                                            \
    /*                                                                      \
     * This is a macro that does an AND with HMINDEXBITS,                   \
     * so it is fast.                                                       \
     */                                                                     \
    dw = HMIndexFromHandle(h);                                              \
                                                                            \
    /*                                                                      \
     * Make sure it is part of our handle table.                            \
     */                                                                     \
    if (dw < gpsi->cHandleEntries) {                                        \
        /*                                                                  \
         * Make sure it is the handle                                       \
         * the app thought it was, by                                       \
         * checking the uniq bits in                                        \
         * the handle against the uniq                                      \
         * bits in the handle entry.                                        \
         */                                                                 \
        phe = &gSharedInfo.aheList[dw];                                     \
        uniq = HMUniqFromHandle(h);                                         \
        if (   uniq == phe->wUniq                                           \
            || uniq == 0                                                    \
            || uniq == HMUNIQBITS                                           \
            ) {                                                             \

#else  /* _WIN64 */
#if defined(_USERK_)
/*
 * Allow 32bit process running on 64bit OS to mask the uniq bits (WOW64).
 */
#define ALLOWZEROFORWOW64  ((uniq == 0) && (PsGetProcessWow64Process(PsGetCurrentProcess()) != NULL))
#else
#define ALLOWZEROFORWOW64   0
#endif

/*
 * WIN64 version of StartValidateHandleMacro
 */
#define StartValidateHandleMacro(h)                                         \
{                                                                           \
    PHE phe;                                                                \
    DWORD dw;                                                               \
    WORD uniq;                                                              \
                                                                            \
    /*                                                                      \
     * This is a macro that does an AND with HMINDEXBITS,                   \
     * so it is fast.                                                       \
     */                                                                     \
    dw = HMIndexFromHandle(h);                                              \
                                                                            \
    /*                                                                      \
     * Make sure it is part of our handle table.                            \
     */                                                                     \
    if (dw < gpsi->cHandleEntries) {                                        \
        /*                                                                  \
         * Make sure it is the handle                                       \
         * the app thought it was, by                                       \
         * checking the uniq bits in                                        \
         * the handle against the uniq                                      \
         * bits in the handle entry.                                        \
         * For Win64 uniq can't be zero!                                    \
         */                                                                 \
        phe = &gSharedInfo.aheList[dw];                                     \
        uniq = HMUniqFromHandle(h);                                         \
        if (   uniq == phe->wUniq                                           \
            || uniq == HMUNIQBITS                                           \
            || ALLOWZEROFORWOW64                                            \
            ) {                                                             \

#endif /* _WIN64 */

#define BeginAliveValidateHandleMacro() \
          /*                                                                   \
           * Now make sure that the handle is not destroyed.  On free          \
           * builds the RIP disappears and the main line is straightthrough.   \
           */                                                                  \
            if (!(phe->bFlags & HANDLEF_DESTROY)) {  \


#define EndAliveValidateHandleMacro() \
            } else {                                \
                RIPMSG2(RIP_WARNING, "ValidateAliveHandle: Object phe %#p is destroyed. Handle: %#p", \
                    phe, h);   \
            }   \


#define BeginTypeValidateHandleMacro(pobj, bTypeTest)                       \
            /*                                                              \
             * Now make sure the app is passing the right handle            \
             * type for this api. If the handle is TYPE_FREE, this'll       \
             * catch it.  Also let Generic requests through.                \
             */                                                             \
            if ((phe->bType == bTypeTest) ||                                \
                (bTypeTest == TYPE_GENERIC && phe->bType != TYPE_FREE)) {   \
                                                                            \
                /*                                                          \
                 * Instead of try/except we use the heap range check        \
                 * mechanism to verify that the given 'pwnd' belongs to     \
                 * the default desktop. We also have to do a Win 3.1 like   \
                 * check to make sure the window is not deleted             \
                 * See NT bug 12242 Kitchen app.  Also 6479                 \
                 *                                                          \
                 * TESTDESKOP returns the handle if the handle is valid     \
                 * in the current desktop                                   \
                 */                                                         \
                pobj = phe->phead;                                          \
                {                                                           \

#define EndTypeValidateHandleMacro                                          \
                }                                                           \
            }                                                               \

#define EndValidateHandleMacro                                              \
        }                                                                   \
    }                                                                       \
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kbd\all_kbds\kbda1\daytona\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kbd\all_kbds\kbda2\wow6432\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kbd\all_kbds\kbda3\daytona\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kbd\sources.inc ===
INCLUDES=..\..\..\inc

C_DEFINES=
UMTYPE=nt
UMTEST=
UMAPPL=
UMBASE=0x1000000
UMLIBS=
TARGETLIBS=
DLLDEF=$(O)\$(TARGETNAME).def

!if $(IA64)
SECTION_ALIGNMENT=0x4000
!endif
# The layout mapping code in kernel depends on the strings that match the key codes residing
# in the same data section as the scan code.  Don't pool.
NO_STRING_POOLING=1
LINKER_FLAGS = -merge:.edata=.data -merge:.rdata=.data -merge:.text=.data -merge:.bss=.data -section:.data,re

TARGETPATH=$(_OBJ_DIR)
TARGETTYPE=DYNLINK

SOURCES=$(O)\$(TARGETNAME).c $(O)\$(TARGETNAME).rc

!if "$(SOURCES_USED)" != "..\..\..\fekbds.inc"
NTTARGETFILE0=$(O)\$(TARGETNAME).h $(O)\$(TARGETNAME).rc $(O)\$(TARGETNAME).def
!endif

# No overflow checking for keyboard maps
BUFFER_OVERFLOW_CHECKS=0
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kbd\all_kbds\kbda3\wow6432\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kbd\all_kbds\kbdal\wow6432\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kbd\all_kbds\kbdal\daytona\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kbd\all_kbds\kbdarme\daytona\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kbd\all_kbds\kbdarme\wow6432\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kbd\all_kbds\makefile.inc ===
#############################################################################
#
# This is the first phase of building keyboard layouts
#
# For each *.txt layout definition (eg: kbdbe.txt kbdbtr.txt etc.):
#  - make the ..\tmp\* directory
#  - generate "sources", "makefile" and "makefile.inc" files in ..\tmp\*
#
# Also generate the ..\tmp\dirs files
#
# THIS FILE IS INCLUDED BY ..\us_kbd\makefile.inc
#
#############################################################################

#
# Layout names (eg: kbdbe)
#
TARGETNAMES=$(SOURCES:.c=)

#
# Directories in which layout will be built (eg: ..\tmp\kbdbe)
#
TARGETDIRS=$(TARGETNAMES:kbd=..\tmp\kbd)

#
# "sources" files used by BUILD to compile layouts (eg: kbdbe\sources)
#
TARGETSOURCEFILES=$(SOURCES:.c=\sources)

#############################################################################
#
# Build all
# builds the "dirs" file that steers the compile and link phase
#
#############################################################################
all: always_build_dirs $(TARGETSOURCEFILES:kbd=..\tmp\kbd)

#
# build -clean does this
#
clean:
    delnode /q ..\tmp\*

#
# Build the DIRS file in ..\tmp
# do this always
#
always_build_dirs: ..\tmp\dirs
    type << > ..\tmp\dirs
DIRS=\
$(TARGETNAMES)
<<


#
# If the "sources" or (this) "makefile.inc" file in this directory have
# changed, make the TARGETDIRS out of date (by deleting)
#
..\tmp\dirs: ..\all_kbds\sources ..\us_kbd\sources makefile.inc
    -md ..\tmp
    type << > ..\tmp\dirs
DIRS=\
$(TARGETNAMES)
<<
    delnode /q ..\tmp\kbd*

#
# Dependencies to make sure the "sources" files are built
# (eg: ..\tmp\kbdbe\sources: ..\tmp\kbdbe)
#
$(TARGETSOURCEFILES:kbd=..\tmp\kbd): $$(@D)


#
# build the SOURCES, MAKEFILE and MAKEFILE.INC in each ..\tmp\kbd*
#   The target of this rule is a directory, which is a problem, since the
#   timestamp of these can only change if the directory is deleted and
#   recreated: hence the delnode /q ..\tmp\kbd* line is the ..\tmp\dirs
#   rule (above).  This deletes the _objects.mac files so you have to run
#   build twice is either the sources or makefile.inc files are updated.
#   To get around this by changing the
#
$(TARGETDIRS): sources ..\all_kbds\makefile.inc
    -md $@
    copy ..\all_kbds\makefile.tpl $@\makefile
    type << > $@\makefile.inc
$(@B).c $(@B).h $(@B).rc $(@B).def: ..\..\all_kbds\$(@B).txt
    kbdtool ..\..\all_kbds\$(@B).txt
<<
    type << > $@\sources._xx
^!IF 0
Copyright (c) 1995  Microsoft Corporation
^!ENDIF

NOLINK=
MAJORCOMP=user
MINORCOMP=$(@B)
TARGETNAME=$(@B)
TARGETPATH=$(O)
TARGETTYPE=DYNLINK
TARGETLIBS=
INCLUDES=..\..\..\inc
SOURCES=$(@B).c $(@B).rc
C_DEFINES=
UMTYPE=nt
UMTEST=
UMAPPL=
UMBASE=0x1000000
UMLIBS=
^!if $$(IA64)
SECTION_ALIGNMENT=0x4000
LINKER_FLAGS = -merge:.edata=.data -merge:.srdata=.data -merge:.text=.data -merge:.bss=.data -section:.data,re
^!else
LINKER_FLAGS = -merge:.edata=.data -merge:.rdata=.data -merge:.text=.data -merge:.bss=.data -section:.data,re
^!endif

NTTARGETFILE0=$(@B).h $(@B).rc $(@B).def
<< 
    sed "s/^\^//" $@\sources._xx > $@\sources
    del /f $@\sources._xx
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kbd\all_kbds\kbdarmw\daytona\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kbd\all_kbds\kbdaze\daytona\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kbd\all_kbds\kbdarmw\wow6432\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kbd\all_kbds\kbdaze\wow6432\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kbd\all_kbds\kbdazel\wow6432\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kbd\all_kbds\kbdbe\daytona\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kbd\all_kbds\kbdazel\daytona\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kbd\all_kbds\kbdbe\wow6432\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kbd\all_kbds\kbdbene\daytona\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kbd\all_kbds\kbdbene\wow6432\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kbd\all_kbds\kbda2\daytona\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kbd\all_kbds\kbda1\wow6432\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kbd\all_kbds\kbdblr\wow6432\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kbd\all_kbds\kbdbr\daytona\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kbd\all_kbds\kbdbr\wow6432\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kbd\all_kbds\kbdblr\daytona\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kbd\all_kbds\kbdbu\daytona\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kbd\all_kbds\kbdbu\wow6432\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kbd\all_kbds\kbdca\wow6432\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kbd\all_kbds\kbdca\daytona\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kbd\all_kbds\kbdcan\daytona\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kbd\all_kbds\kbdcr\daytona\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kbd\all_kbds\kbdcan\wow6432\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kbd\all_kbds\kbdcr\wow6432\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kbd\all_kbds\kbdcz\daytona\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kbd\all_kbds\kbdcz\wow6432\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kbd\all_kbds\kbdcz1\daytona\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kbd\all_kbds\kbdcz1\wow6432\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kbd\all_kbds\kbdcz2\daytona\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kbd\all_kbds\kbdda\daytona\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kbd\all_kbds\kbdda\wow6432\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kbd\all_kbds\kbdcz2\wow6432\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kbd\all_kbds\kbddiv1\daytona\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kbd\all_kbds\kbddiv2\daytona\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kbd\all_kbds\kbddiv1\wow6432\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kbd\all_kbds\kbddv\wow6432\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kbd\all_kbds\kbddiv2\wow6432\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kbd\all_kbds\kbddv\daytona\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kbd\all_kbds\kbdes\daytona\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kbd\all_kbds\kbdes\wow6432\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kbd\all_kbds\kbdest\wow6432\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kbd\all_kbds\kbdest\daytona\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kbd\all_kbds\kbdfa\daytona\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kbd\all_kbds\kbdfa\wow6432\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kbd\all_kbds\kbdfc\daytona\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kbd\all_kbds\kbdfi\wow6432\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kbd\all_kbds\kbdfo\wow6432\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kbd\all_kbds\kbdfi\daytona\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kbd\all_kbds\kbdfo\daytona\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kbd\all_kbds\kbdfc\wow6432\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kbd\all_kbds\kbdfr\daytona\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kbd\all_kbds\kbdfr\wow6432\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kbd\all_kbds\kbdgae\daytona\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kbd\all_kbds\kbdgae\wow6432\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kbd\all_kbds\kbdgeo\daytona\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kbd\all_kbds\kbdgkl\daytona\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kbd\all_kbds\kbdgeo\wow6432\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kbd\all_kbds\kbdgr\daytona\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kbd\all_kbds\kbdgkl\wow6432\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kbd\all_kbds\kbdgr1\daytona\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kbd\all_kbds\kbdgr\wow6432\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kbd\all_kbds\kbdhe\daytona\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kbd\all_kbds\kbdgr1\wow6432\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kbd\all_kbds\kbdhe220\daytona\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kbd\all_kbds\kbdhe220\wow6432\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kbd\all_kbds\kbdhe\wow6432\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kbd\all_kbds\kbdhe319\wow6432\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kbd\all_kbds\kbdhe319\daytona\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kbd\all_kbds\kbdheb\daytona\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kbd\all_kbds\kbdhela2\daytona\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kbd\all_kbds\kbdhebx\wow6432\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kbd\all_kbds\kbdheb\wow6432\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kbd\all_kbds\kbdhebx\daytona\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kbd\all_kbds\kbdhela3\daytona\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kbd\all_kbds\kbdhela2\wow6432\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kbd\all_kbds\kbdhept\daytona\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kbd\all_kbds\kbdhela3\wow6432\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kbd\all_kbds\kbdhu\wow6432\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kbd\all_kbds\kbdhept\wow6432\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kbd\all_kbds\kbdhu\daytona\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kbd\all_kbds\kbdhu1\daytona\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kbd\all_kbds\kbdhu1\wow6432\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kbd\all_kbds\kbdic\wow6432\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kbd\all_kbds\kbdinasa\daytona\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kbd\all_kbds\kbdinasa\wow6432\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kbd\all_kbds\kbdinben\daytona\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kbd\all_kbds\kbdic\daytona\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kbd\all_kbds\kbdinben\wow6432\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kbd\all_kbds\kbdindev\daytona\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kbd\all_kbds\kbdindev\wow6432\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kbd\all_kbds\kbdinguj\daytona\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kbd\all_kbds\kbdinguj\wow6432\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kbd\all_kbds\kbdinhin\daytona\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kbd\all_kbds\kbdinhin\wow6432\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kbd\all_kbds\kbdinmal\daytona\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kbd\all_kbds\kbdinkan\daytona\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kbd\all_kbds\kbdinkan\wow6432\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kbd\all_kbds\kbdinmal\wow6432\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kbd\all_kbds\kbdinmar\daytona\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kbd\all_kbds\kbdinmar\wow6432\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kbd\all_kbds\kbdinori\daytona\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kbd\all_kbds\kbdinori\wow6432\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kbd\all_kbds\kbdinpun\daytona\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kbd\all_kbds\kbdinpun\wow6432\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kbd\all_kbds\kbdintam\wow6432\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kbd\all_kbds\kbdintel\wow6432\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kbd\all_kbds\kbdintel\daytona\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kbd\all_kbds\kbdit\daytona\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kbd\all_kbds\kbdintam\daytona\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kbd\all_kbds\kbdir\daytona\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kbd\all_kbds\kbdir\wow6432\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kbd\all_kbds\kbdit\wow6432\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kbd\all_kbds\kbdit142\daytona\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kbd\all_kbds\kbdit142\wow6432\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kbd\all_kbds\kbdkyr\wow6432\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kbd\all_kbds\kbdkaz\wow6432\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kbd\all_kbds\kbdkaz\daytona\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kbd\all_kbds\kbdkyr\daytona\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kbd\all_kbds\kbdla\wow6432\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kbd\all_kbds\kbdla\daytona\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kbd\all_kbds\kbdlt\daytona\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kbd\all_kbds\kbdlt\wow6432\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kbd\all_kbds\kbdlt1\daytona\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kbd\all_kbds\kbdlv\daytona\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kbd\all_kbds\kbdlv1\daytona\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kbd\all_kbds\kbdlt1\wow6432\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kbd\all_kbds\kbdlv\wow6432\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kbd\all_kbds\kbdlv1\wow6432\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kbd\all_kbds\kbdmac\wow6432\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kbd\all_kbds\kbdmon\daytona\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kbd\all_kbds\kbdmac\daytona\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kbd\all_kbds\kbdmon\wow6432\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kbd\all_kbds\kbdne\daytona\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kbd\all_kbds\kbdno\daytona\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kbd\all_kbds\kbdne\wow6432\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kbd\all_kbds\kbdpl\daytona\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kbd\all_kbds\kbdno\wow6432\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kbd\all_kbds\kbdpl1\daytona\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kbd\all_kbds\kbdpl\wow6432\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kbd\all_kbds\kbdpl1\wow6432\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kbd\all_kbds\kbdpo\daytona\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kbd\all_kbds\kbdru\daytona\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kbd\all_kbds\kbdpo\wow6432\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kbd\all_kbds\kbdro\daytona\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kbd\all_kbds\kbdru1\daytona\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kbd\all_kbds\kbdru\wow6432\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kbd\all_kbds\kbdro\wow6432\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kbd\all_kbds\kbdru1\wow6432\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kbd\all_kbds\kbdsf\daytona\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kbd\all_kbds\kbdsg\daytona\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kbd\all_kbds\kbdsf\wow6432\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kbd\all_kbds\kbdsg\wow6432\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kbd\all_kbds\kbdsl\daytona\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kbd\all_kbds\kbdsl\wow6432\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kbd\all_kbds\kbdsl1\daytona\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kbd\all_kbds\kbdsl1\wow6432\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kbd\all_kbds\kbdsp\daytona\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kbd\all_kbds\kbdsp\wow6432\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kbd\all_kbds\kbdsw\daytona\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kbd\all_kbds\kbdsyr1\daytona\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kbd\all_kbds\kbdsyr1\wow6432\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kbd\all_kbds\kbdsw\wow6432\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kbd\all_kbds\kbdsyr2\daytona\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kbd\all_kbds\kbdsyr2\wow6432\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kbd\all_kbds\kbdtat\daytona\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kbd\all_kbds\kbdth0\daytona\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kbd\all_kbds\kbdtat\wow6432\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kbd\all_kbds\kbdth0\wow6432\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kbd\all_kbds\kbdth1\daytona\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kbd\all_kbds\kbdth1\wow6432\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kbd\all_kbds\kbdth2\wow6432\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kbd\all_kbds\kbdth2\daytona\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kbd\all_kbds\kbdth3\daytona\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kbd\all_kbds\kbdth3\wow6432\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kbd\all_kbds\kbdtuf\daytona\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kbd\all_kbds\kbduk\wow6432\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kbd\all_kbds\kbdtuf\wow6432\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kbd\all_kbds\kbdtuq\wow6432\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kbd\all_kbds\kbduk\daytona\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kbd\all_kbds\kbdur\daytona\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kbd\all_kbds\kbdur\wow6432\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kbd\all_kbds\kbdtuq\daytona\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kbd\all_kbds\kbdurdu\wow6432\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kbd\all_kbds\kbdurdu\daytona\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kbd\all_kbds\kbdurs\wow6432\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kbd\all_kbds\kbdurs\daytona\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kbd\all_kbds\kbdusa\daytona\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kbd\all_kbds\kbdusa\wow6432\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kbd\all_kbds\kbdusl\daytona\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kbd\all_kbds\kbdusl\wow6432\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kbd\all_kbds\kbdusr\wow6432\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kbd\all_kbds\kbdusr\daytona\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kbd\all_kbds\kbdusx\daytona\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kbd\all_kbds\kbduzb\daytona\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kbd\all_kbds\kbdusx\wow6432\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kbd\all_kbds\kbduzb\wow6432\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kbd\all_kbds\kbdvntc\daytona\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kbd\all_kbds\kbdvntc\wow6432\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kbd\all_kbds\kbdycc\daytona\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kbd\all_kbds\kbdycl\daytona\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kbd\all_kbds\kbdycc\wow6432\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kbd\all_kbds\kbdycl\wow6432\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kbd\fe_kbds\jpn\japan.inc ===
#****************************** File Header ******************************\
# File Name: Sources.inc for JPN KBDs
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific SOURCES file.
#
# History:
# May-14-1999 HiroYama Created
#***************************************************************************/

!include ..\..\..\fekbds.inc

C_DEFINES=$(C_DEFINES) -DJAPAN -DNEWKBDMAP

SOURCES_USED=..\..\japan.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kbd\fe_kbds\fekbds.inc ===
#****************************** File Header ******************************\
# File Name: Sources.inc for FE KBDs
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific SOURCES file.
#
# History:
# May-14-1999 HiroYama Created
#***************************************************************************/


TARGETNAME=$(MINORCOMP)
NOLINK=
MAJORCOMP=user

SOURCES_USED=..\..\..\fekbds.inc

!include ..\..\..\..\sources.inc


# Override some of the values set by sources.inc
SOURCES=..\$(MINORCOMP).c ..\$(MINORCOMP).rc

INCLUDES= \
    ..\..\inc; \
    $(NTUSER_PATH)\inc; \
    $(NTUSER_PATH)\inc\$(ALT_PROJECT)\$(O); \
    $(PROJECT_ROOT)\core\w32inc; \
    $(BASE_INC_PATH);

#    $(SHELL_INC_PATH)
C_DEFINES=$(C_DEFINES) -DFE_SB -DFE_IME
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kbd\fe_kbds\common\sources.inc ===
!IF 0

Copyright (c) 1989  Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


Author:

    Steve Wood (stevewo) 12-Apr-1990

NOTE:   Commented description of this file is in \nt\bak\bin\sources.tpl

!ENDIF

MAJORCOMP=user
MINORCOMP=kbdfe_common
TARGETPATH=$(ALT_PROJECT_TARGET)\$(_OBJ_DIR)

C_DEFINES=$(C_DEFINES) $(USER_C_DEFINES)

TARGETNAME=fekbdcom
TARGETTYPE=LIBRARY

#INCLUDES=..\inc;..\..\..\inc;..\..\..\..\inc;..\$(BASE_KEYBOARD_LAYOUT)


SOURCES=..\fekbdcom.c

SYNCHRONIZE_BLOCK=1

# No overflow checking for keyboard maps
BUFFER_OVERFLOW_CHECKS=0
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kbd\fe_kbds\jpn\101\sources.inc ===
!IF 0

Copyright (c) 1989  Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


Author:

    Steve Wood (stevewo) 12-Apr-1990

NOTE:   Commented description of this file is in \nt\bak\bin\sources.tpl

!ENDIF

MINORCOMP=kbd101

!include ..\..\japan.inc

SOURCES_USED=..\sources.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kbd\fe_kbds\jpn\101\kbd101.h ===
/****************************** Module Header ******************************\
* Module Name: kbd101.h
*
* Copyright (c) 1985-2000, Microsoft Corporation
*
* Various defines for use by keyboard input code.
*
* History:
\***************************************************************************/

/*
 * kbd type should be controlled by cl command-line argument
 */
#define KBD_TYPE 4

/*
 * Include the basis of all keyboard table values
 */
#include "kbd.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kbd\fe_kbds\jpn\106\kbd106.c ===
/***************************************************************************\
* Module Name: kbd106.c
*
* Copyright (c) 1985-2000, Microsoft Corporation
*
* History:
\***************************************************************************/

//@@BEGIN_DDKSPLIT
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
//@@END_DDKSPLIT
#include <windows.h>
#include "kbdjpn.h"
#include "kbd106.h"

#if defined(_M_IA64)
#pragma section(".data")
#define ALLOC_SECTION_LDATA __declspec(allocate(".data"))
#else
#pragma data_seg(".data")
#define ALLOC_SECTION_LDATA
#endif

/***************************************************************************\
* ausVK[] - Virtual Scan Code to Virtual Key conversion table for 106
\***************************************************************************/

static ALLOC_SECTION_LDATA USHORT ausVK[] = {
    T00, T01, T02, T03, T04, T05, T06, T07,
    T08, T09, T0A, T0B, T0C, T0D, T0E, T0F,
    T10, T11, T12, T13, T14, T15, T16, T17,
    T18, T19, T1A, T1B, T1C, T1D, T1E, T1F,
    T20, T21, T22, T23, T24, T25, T26, T27,
    T28,

    /*
     * Hankaku/Zenkaku/Kanji key must have KBDSPECIAL bit set (NLS key)
     */
    T29 | KBDSPECIAL,

              T2A, T2B, T2C, T2D, T2E, T2F,
    T30, T31, T32, T33, T34, T35,

    /*
     * Right-hand Shift key must have KBDEXT bit set.
     */
    T36 | KBDEXT,

    /*
     * numpad_* + Shift/Alt -> SnapShot
     */
    T37 | KBDMULTIVK,

    T38, T39,

    /*
     * Alphanumeric/CapsLock key must have KBDSPECIAL bit set (NLS key)
     */
    T3A | KBDSPECIAL,

                   T3B, T3C, T3D, T3E, T3F,
    T40, T41, T42, T43, T44,

    /*
     * NumLock Key:
     *     KBDEXT     - VK_NUMLOCK is an Extended key
     *     KBDMULTIVK - VK_NUMLOCK or VK_PAUSE (without or with CTRL)
     */
    T45 | KBDEXT | KBDMULTIVK,

    T46 | KBDMULTIVK,

    /*
     * Number Pad keys:
     *     KBDNUMPAD  - digits 0-9 and decimal point.
     *     KBDSPECIAL - require special processing by Windows
     */
    T47 | KBDNUMPAD | KBDSPECIAL,   // Numpad 7 (Home)
    T48 | KBDNUMPAD | KBDSPECIAL,   // Numpad 8 (Up),
    T49 | KBDNUMPAD | KBDSPECIAL,   // Numpad 9 (PgUp),
    T4A,
    T4B | KBDNUMPAD | KBDSPECIAL,   // Numpad 4 (Left),
    T4C | KBDNUMPAD | KBDSPECIAL,   // Numpad 5 (Clear),
    T4D | KBDNUMPAD | KBDSPECIAL,   // Numpad 6 (Right),
    T4E,
    T4F | KBDNUMPAD | KBDSPECIAL,   // Numpad 1 (End),
    T50 | KBDNUMPAD | KBDSPECIAL,   // Numpad 2 (Down),
    T51 | KBDNUMPAD | KBDSPECIAL,   // Numpad 3 (PgDn),
    T52 | KBDNUMPAD | KBDSPECIAL,   // Numpad 0 (Ins),
    T53 | KBDNUMPAD | KBDSPECIAL,   // Numpad . (Del),

    T54, T55, T56, T57, T58, T59, T5A, T5B,
    T5C, T5D, T5E, T5F, T60, T61, T62, T63,
    T64, T65, T66, T67, T68, T69, T6A, T6B,
    T6C, T6D, T6E, T6F,

    /*
     * Hiragana/Katakana/Roman key must have KBDSPECIAL bit set (NLS key)
     */
    T70 | KBDSPECIAL,

                             T71, T72, T73,
    T74, T75, T76, T77, T78,

    /*
     * Conversion key must have KBDSPECIAL bit set (NLS key)
     */
    T79 | KBDSPECIAL,

                                  T7A,

    /*
     * Non-Conversion key must have KBDSPECIAL bit set (NLS key)
     */
    T7B | KBDSPECIAL,

    T7C, T7D, T7E, T7F

};

static ALLOC_SECTION_LDATA VSC_VK aE0VscToVk[] = {
        { 0x10, X10 | KBDEXT              },  // Speedracer: Previous Track
        { 0x19, X19 | KBDEXT              },  // Speedracer: Next Track
        { 0x1C, X1C | KBDEXT              },  // Numpad Enter
        { 0x1D, X1D | KBDEXT              },  // RControl
        { 0x20, X20 | KBDEXT              },  // Speedracer: Volume Mute
        { 0x21, X21 | KBDEXT              },  // Speedracer: Launch App 2
        { 0x22, X22 | KBDEXT              },  // Speedracer: Media Play/Pause
        { 0x24, X24 | KBDEXT              },  // Speedracer: Media Stop
        { 0x2E, X2E | KBDEXT              },  // Speedracer: Volume Down
        { 0x30, X30 | KBDEXT              },  // Speedracer: Volume Up
        { 0x32, X32 | KBDEXT              },  // Speedracer: Browser Home
        { 0x35, X35 | KBDEXT              },  // Numpad Divide
        { 0x37, X37 | KBDEXT              },  // Snapshot
        { 0x38, X38 | KBDEXT              },  // RMenu
        { 0x46, X46 | KBDEXT              },  // Break (Ctrl + Pause)
        { 0x47, X47 | KBDEXT              },  // Home
        { 0x48, X48 | KBDEXT              },  // Up
        { 0x49, X49 | KBDEXT              },  // Prior
        { 0x4B, X4B | KBDEXT              },  // Left
        { 0x4D, X4D | KBDEXT              },  // Right
        { 0x4F, X4F | KBDEXT              },  // End
        { 0x50, X50 | KBDEXT              },  // Down
        { 0x51, X51 | KBDEXT              },  // Next
        { 0x52, X52 | KBDEXT              },  // Insert
        { 0x53, X53 | KBDEXT              },  // Delete
        { 0x5B, X5B | KBDEXT              },  // Left Win
        { 0x5C, X5C | KBDEXT              },  // Right Win
        { 0x5D, X5D | KBDEXT              },  // Application
        { 0x5F, X5F | KBDEXT              },  // Speedracer: Sleep
        { 0x65, X65 | KBDEXT              },  // Speedracer: Browser Search
        { 0x66, X66 | KBDEXT              },  // Speedracer: Browser Favorites
        { 0x67, X67 | KBDEXT              },  // Speedracer: Browser Refresh
        { 0x68, X68 | KBDEXT              },  // Speedracer: Browser Stop
        { 0x69, X69 | KBDEXT              },  // Speedracer: Browser Forward
        { 0x6A, X6A | KBDEXT              },  // Speedracer: Browser Back
        { 0x6B, X6B | KBDEXT              },  // Speedracer: Launch App 1
        { 0x6C, X6C | KBDEXT              },  // Speedracer: Launch Mail
        { 0x6D, X6D | KBDEXT              },  // Speedracer: Launch Media Selector
        { 0,      0                       }
};

static ALLOC_SECTION_LDATA VSC_VK aE1VscToVk[] = {
        { 0x1D, Y1D                       },  // Pause
        { 0   ,   0                       }
};

/***************************************************************************\
* aVkToBits[]  - map Virtual Keys to Modifier Bits
*
* See kbd.h for a full description.
*
* US Keyboard has only three shifter keys:
*     SHIFT (L & R) affects alphabnumeric keys,
*     CTRL  (L & R) is used to generate control characters
*     ALT   (L & R) used for generating characters by number with numpad
\***************************************************************************/

static ALLOC_SECTION_LDATA VK_TO_BIT aVkToBits[] = {
    { VK_SHIFT,   KBDSHIFT },
    { VK_CONTROL, KBDCTRL  },
    { VK_MENU,    KBDALT   },
    { VK_KANA,    KBDKANA  },
    { 0,          0        }
};

/***************************************************************************\
* aModification[]  - map character modifier bits to modification number
*
* See kbd.h for a full description.
*
\***************************************************************************/

static ALLOC_SECTION_LDATA MODIFIERS CharModifiers = {
    &aVkToBits[0],
    11,
    {
    //  Modification# //  Keys Pressed  : Explanation
    //  ============= // ============== : =============================
        0,            //                : unshifted characters
        1,            //          SHIFT : capitals, ~!@#$%^&*()_+{}:"<>? etc.
        4,            //     CTRL       : control characters
        6,            //     CTRL SHIFT :
        SHFT_INVALID, // ALT            : invalid
        SHFT_INVALID, // ALT      SHIFT : invalid
        SHFT_INVALID, // ALT CTRL       : invalid
        SHFT_INVALID, // ALT CTRL SHIFT : invalid
        2,            //KANA
        3,            //KANA      SHIFT
        5,            //KANA CTRL
        7             //KANA CTRL SHIFT
    }
};

/***************************************************************************\
*
* aVkToWch2[]  - Virtual Key to WCHAR translation for 2 shift states
* aVkToWch3[]  - Virtual Key to WCHAR translation for 3 shift states
* aVkToWch4[]  - Virtual Key to WCHAR translation for 4 shift states
*
* Table attributes: Unordered Scan, null-terminated
*
* Search this table for an entry with a matching Virtual Key to find the
* corresponding unshifted and shifted WCHAR characters.
*
* Reserved VirtualKey values (first column)
*     -1            - this line contains dead characters (diacritic)
*     0             - terminator
*
* Reserved Attribute values (second column)
*     CAPLOK        - CapsLock affects this key like Shift
*     KANALOK       - The KANA-LOCK key affects this key like KANA
*
* Reserved character values (third through last column)
*     WCH_NONE      - No character
*     WCH_DEAD      - Dead character (diacritic) value is in next line
*
\***************************************************************************/

static ALLOC_SECTION_LDATA VK_TO_WCHARS4 aVkToWch4[] = {
    //                               |          |   SHIFT  |  KANA  | K+SHFT |
    //                               |          |==========|========|========|
    {'0'          ,          KANALOK ,'0'       ,WCH_NONE  ,WCH_WA  ,WCH_WO  },
    {'1'          ,          KANALOK ,'1'       ,'!'       ,WCH_NU  ,WCH_NU  },
    {'3'          ,          KANALOK ,'3'       ,'#'       ,WCH_A   ,WCH_AA  },
    {'4'          ,          KANALOK ,'4'       ,'$'       ,WCH_U   ,WCH_UU  },
    {'5'          ,          KANALOK ,'5'       ,'%'       ,WCH_E   ,WCH_EE  },
    {'7'          ,          KANALOK ,'7'       ,0x27      ,WCH_YA  ,WCH_YAA },
    {'8'          ,          KANALOK ,'8'       ,'('       ,WCH_YU  ,WCH_YUU },
    {'9'          ,          KANALOK ,'9'       ,')'       ,WCH_YO  ,WCH_YOO },
    {'A'          , CAPLOK | KANALOK ,'a'       ,'A'       ,WCH_TI  ,WCH_TI  },
    {'B'          , CAPLOK | KANALOK ,'b'       ,'B'       ,WCH_KO  ,WCH_KO  },
    {'C'          , CAPLOK | KANALOK ,'c'       ,'C'       ,WCH_SO  ,WCH_SO  },
    {'D'          , CAPLOK | KANALOK ,'d'       ,'D'       ,WCH_SI  ,WCH_SI  },
    {'E'          , CAPLOK | KANALOK ,'e'       ,'E'       ,WCH_I   ,WCH_II  },
    {'F'          , CAPLOK | KANALOK ,'f'       ,'F'       ,WCH_HA  ,WCH_HA  },
    {'G'          , CAPLOK | KANALOK ,'g'       ,'G'       ,WCH_KI  ,WCH_KI  },
    {'H'          , CAPLOK | KANALOK ,'h'       ,'H'       ,WCH_KU  ,WCH_KU  },
    {'I'          , CAPLOK | KANALOK ,'i'       ,'I'       ,WCH_NI  ,WCH_NI  },
    {'J'          , CAPLOK | KANALOK ,'j'       ,'J'       ,WCH_MA  ,WCH_MA  },
    {'K'          , CAPLOK | KANALOK ,'k'       ,'K'       ,WCH_NO  ,WCH_NO  },
    {'L'          , CAPLOK | KANALOK ,'l'       ,'L'       ,WCH_RI  ,WCH_RI  },
    {'M'          , CAPLOK | KANALOK ,'m'       ,'M'       ,WCH_MO  ,WCH_MO  },
    {'N'          , CAPLOK | KANALOK ,'n'       ,'N'       ,WCH_MI  ,WCH_MI  },
    {'O'          , CAPLOK | KANALOK ,'o'       ,'O'       ,WCH_RA  ,WCH_RA  },
    {'P'          , CAPLOK | KANALOK ,'p'       ,'P'       ,WCH_SE  ,WCH_SE  },
    {'Q'          , CAPLOK | KANALOK ,'q'       ,'Q'       ,WCH_TA  ,WCH_TA  },
    {'R'          , CAPLOK | KANALOK ,'r'       ,'R'       ,WCH_SU  ,WCH_SU  },
    {'S'          , CAPLOK | KANALOK ,'s'       ,'S'       ,WCH_TO  ,WCH_TO  },
    {'T'          , CAPLOK | KANALOK ,'t'       ,'T'       ,WCH_KA  ,WCH_KA  },
    {'U'          , CAPLOK | KANALOK ,'u'       ,'U'       ,WCH_NA  ,WCH_NA  },
    {'V'          , CAPLOK | KANALOK ,'v'       ,'V'       ,WCH_HI  ,WCH_HI  },
    {'W'          , CAPLOK | KANALOK ,'w'       ,'W'       ,WCH_TE  ,WCH_TE  },
    {'X'          , CAPLOK | KANALOK ,'x'       ,'X'       ,WCH_SA  ,WCH_SA  },
    {'Y'          , CAPLOK | KANALOK ,'y'       ,'Y'       ,WCH_NN  ,WCH_NN  },
    {'Z'          , CAPLOK | KANALOK ,'z'       ,'Z'       ,WCH_TU  ,WCH_TUU },
    {VK_OEM_1     ,          KANALOK ,':'       ,'*'       ,WCH_KE  ,WCH_KE  },
    {VK_OEM_2     ,          KANALOK ,'/'       ,'?'       ,WCH_ME  ,WCH_MD  },
    {VK_OEM_3     ,          KANALOK ,'@'       ,'`'       ,WCH_VS  ,WCH_VS  },
    {VK_OEM_7     ,          KANALOK ,'^'       ,'~'       ,WCH_HE  ,WCH_HE  },
    {VK_OEM_8     , 0                ,WCH_NONE  ,WCH_NONE  ,WCH_NONE,WCH_NONE},
    {VK_OEM_COMMA ,          KANALOK ,','       ,'<'       ,WCH_NE  ,WCH_IC  },
    {VK_OEM_PERIOD,          KANALOK ,'.'       ,'>'       ,WCH_RU  ,WCH_IP  },
    {VK_OEM_PLUS  ,          KANALOK ,';'       ,'+'       ,WCH_RE  ,WCH_RE  },
    {VK_TAB       , 0                ,'\t'      ,'\t'      ,'\t'    ,'\t'    },
    {VK_ADD       , 0                ,'+'       ,'+'       ,'+'     ,'+'     },
    {VK_DECIMAL   , 0                ,'.'       ,'.'       ,'.'     ,'.'     },
    {VK_DIVIDE    , 0                ,'/'       ,'/'       ,'/'     ,'/'     },
    {VK_MULTIPLY  , 0                ,'*'       ,'*'       ,'*'     ,'*'     },
    {VK_SUBTRACT  , 0                ,'-'       ,'-'       ,'-'     ,'-'     },
    {0            , 0                ,0         ,0         ,0       ,0       }
};

static ALLOC_SECTION_LDATA VK_TO_WCHARS6 aVkToWch6[] = {
    //                      |          |   SHIFT  |  KANA  | K+SHFT |  CONTROL  |  K+CTRL   |
    //                      |          |==========|========|========|===========|===========|
    {VK_BACK      , 0       ,'\b'      ,'\b'      ,'\b'    ,'\b'    , 0x7f      , 0x7f      },
    {VK_CANCEL    , 0       ,0x03      ,0x03      ,0x03    ,0x03    , 0x03      , 0x03      },
    {VK_ESCAPE    , 0       ,0x1b      ,0x1b      ,0x1b    ,0x1b    , 0x1b      , 0x1b      },
    {VK_OEM_4     , KANALOK ,'['       ,'{'       ,WCH_SVS ,WCH_OB  , 0x1b      , 0x1b      },
    {VK_OEM_5     , KANALOK ,'\\'      ,'|'       ,WCH_PS  ,WCH_PS  , 0x1c      , 0x1c      },
    {VK_OEM_102   , KANALOK ,'\\'      ,'_'       ,WCH_RO  ,WCH_RO  , 0x1c      , 0x1c      },
    {VK_OEM_6     , KANALOK ,']'       ,'}'       ,WCH_MU  ,WCH_CB  , 0x1d      , 0x1d      },
    {VK_RETURN    , 0       ,'\r'      ,'\r'      ,'\r'    ,'\r'    , '\n'      , '\n'      },
    {VK_SPACE     , 0       ,' '       ,' '       ,' '     ,' '     , 0x20      , 0x20      },
    {0            , 0       ,0         ,0         ,0       ,0       , 0         , 0         }
};

static ALLOC_SECTION_LDATA VK_TO_WCHARS8 aVkToWch8[] = {
    //                      |          |   SHIFT  |  KANA  | K+SHFT |  CONTROL  |  K+CTRL   | SHFT+CTRL |K+SHFT+CTRL|
    //                      |          |==========|========|========|===========|===========|===========|===========|
    {'2'          , KANALOK ,'2'       ,'"'       ,WCH_HU  ,WCH_HU  , WCH_NONE  , WCH_NONE  , 0x00      , 0x00      },
    {'6'          , KANALOK ,'6'       ,'&'       ,WCH_O   ,WCH_OO  , WCH_NONE  , WCH_NONE  , 0x1e      , 0x1e      },
    {VK_OEM_MINUS , KANALOK ,'-'       ,'='       ,WCH_HO  ,WCH_HO  , WCH_NONE  , WCH_NONE  , 0x1f      , 0x1f      },
    {0            , 0       ,0         ,0         ,0       ,0       , 0         , 0         , 0         , 0         }
};

// Put this last so that VkKeyScan interprets number characters
// as coming from the main section of the kbd (aVkToWch2 and
// aVkToWch4) before considering the numpad (aVkToWch1).

static ALLOC_SECTION_LDATA VK_TO_WCHARS4 aVkToWch1[] = {
    //                     |          |   SHIFT  |  KANA  | K+SHFT |
    //                     |          |==========|========|========|
    { VK_NUMPAD0   , 0      ,  '0'    , WCH_NONE ,   '0'  ,WCH_NONE},
    { VK_NUMPAD1   , 0      ,  '1'    , WCH_NONE ,   '1'  ,WCH_NONE},
    { VK_NUMPAD2   , 0      ,  '2'    , WCH_NONE ,   '2'  ,WCH_NONE},
    { VK_NUMPAD3   , 0      ,  '3'    , WCH_NONE ,   '3'  ,WCH_NONE},
    { VK_NUMPAD4   , 0      ,  '4'    , WCH_NONE ,   '4'  ,WCH_NONE},
    { VK_NUMPAD5   , 0      ,  '5'    , WCH_NONE ,   '5'  ,WCH_NONE},
    { VK_NUMPAD6   , 0      ,  '6'    , WCH_NONE ,   '6'  ,WCH_NONE},
    { VK_NUMPAD7   , 0      ,  '7'    , WCH_NONE ,   '7'  ,WCH_NONE},
    { VK_NUMPAD8   , 0      ,  '8'    , WCH_NONE ,   '8'  ,WCH_NONE},
    { VK_NUMPAD9   , 0      ,  '9'    , WCH_NONE ,   '9'  ,WCH_NONE},
    { 0            , 0      ,  '\0'   , 0        ,   0    ,0       }   //null terminator
};

/***************************************************************************\
* aVkToWcharTable: table of pointers to Character Tables
*
* Describes the character tables and the order they should be searched.
*
* Note: the order determines the behavior of VkKeyScan() : this function
*       takes a character and attempts to find a Virtual Key and character-
*       modifier key combination that produces that character.  The table
*       containing the numeric keypad (aVkToWch1) must appear last so that
*       VkKeyScan('0') will be interpreted as one of keys from the main
*       section, not the numpad.  etc.
\***************************************************************************/

static ALLOC_SECTION_LDATA VK_TO_WCHAR_TABLE aVkToWcharTable[] = {
    {  (PVK_TO_WCHARS1)aVkToWch6, 6, sizeof(aVkToWch6[0]) },
    {  (PVK_TO_WCHARS1)aVkToWch8, 8, sizeof(aVkToWch8[0]) },
    {  (PVK_TO_WCHARS1)aVkToWch4, 4, sizeof(aVkToWch4[0]) },
    {  (PVK_TO_WCHARS1)aVkToWch1, 4, sizeof(aVkToWch1[0]) },  // must come last
    {                       NULL, 0, 0                    }
};

/***************************************************************************\
* aKeyNames[], aKeyNamesExt[]  - Scan Code -> Key Name tables
*
* For the GetKeyNameText() API function
*
* Tables for non-extended and extended (KBDEXT) keys.
* (Keys producing printable characters are named by the character itself)
\***************************************************************************/

static ALLOC_SECTION_LDATA VSC_LPWSTR aKeyNames[] = {
    0x01,    L"Esc",
    0x0e,    L"Backspace",
    0x0f,    L"Tab",
    0x1c,    L"Enter",
    0x1d,    L"Ctrl",
    0x29,    (LPWSTR)SZ_KEY_NAME_HANKAKU_ZENKAKU,  // NLS Key
    0x2a,    L"Shift",
    0x36,    L"Right Shift",
    0x37,    L"Num *",
    0x38,    L"Alt",
    0x39,    L"Space",
    0x3a,    L"Caps Lock",
    0x3b,    L"F1",
    0x3c,    L"F2",
    0x3d,    L"F3",
    0x3e,    L"F4",
    0x3f,    L"F5",
    0x40,    L"F6",
    0x41,    L"F7",
    0x42,    L"F8",
    0x43,    L"F9",
    0x44,    L"F10",
    0x45,    L"Pause",
    0x46,    L"Scroll Lock",
    0x47,    L"Num 7",
    0x48,    L"Num 8",
    0x49,    L"Num 9",
    0x4a,    L"Num -",
    0x4b,    L"Num 4",
    0x4c,    L"Num 5",
    0x4d,    L"Num 6",
    0x4e,    L"Num +",
    0x4f,    L"Num 1",
    0x50,    L"Num 2",
    0x51,    L"Num 3",
    0x52,    L"Num 0",
    0x53,    L"Num Del",
    0x54,    L"Sys Req",
    0x57,    L"F11",
    0x58,    L"F12",
    0x70,    (LPWSTR)SZ_KEY_NAME_HIRAGANA,
    0x79,    (LPWSTR)SZ_KEY_NAME_HENKAN,
    0x7b,    (LPWSTR)SZ_KEY_NAME_MUHENKAN,
    0x7C,    L"F13",
    0   ,    NULL
};

static ALLOC_SECTION_LDATA VSC_LPWSTR aKeyNamesExt[] = {
    0x1c,    L"Num Enter",
    0x1d,    L"Right Control",
    0x35,    L"Num /",
    0x37,    L"Prnt Scrn",
    0x38,    L"Right Alt",
    0x45,    L"Num Lock",
    0x46,    L"Break",
    0x47,    L"Home",
    0x48,    L"Up",
    0x49,    L"Page Up",
    0x4b,    L"Left",
    0x4d,    L"Right",
    0x4f,    L"End",
    0x50,    L"Down",
    0x51,    L"Page Down",
    0x52,    L"Insert",
    0x53,    L"Delete",
    0x5B,    L"Left Windows",
    0x5C,    L"Right Windows",
    0x5D,    L"Application",
    0   ,    NULL
};

ALLOC_SECTION_LDATA KBDTABLES KbdTables106 = {
    /*
     * Modifier keys
     */
    &CharModifiers,

    /*
     * Characters tables
     */
    aVkToWcharTable,

    /*
     * Diacritics  (none for US English)
     */
    NULL,

    /*
     * Names of Keys  (no dead keys)
     */
    aKeyNames,
    aKeyNamesExt,
    NULL,

    /*
     * Scan codes to Virtual Keys
     */
    ausVK,
    sizeof(ausVK) / sizeof(ausVK[0]),
    aE0VscToVk,
    aE1VscToVk,

    /*
     * No Locale-specific special processing
     */
    0,

    /*
     * No Ligatures
     */
    0, 0, NULL,

    /*
     * Type and subtype.
     */
    KEYBOARD_TYPE_JAPAN,    // Japanese Keyboard Layout
    MAKEWORD(MICROSOFT_KBD_106_TYPE, NLSKBD_OEM_MICROSOFT),
};

PKBDTABLES KbdLayerDescriptor(VOID)
{
    return &KbdTables106;
}

/***********************************************************************\
* VkToFuncTable_106[]
*
\***********************************************************************/

static ALLOC_SECTION_LDATA VK_F VkToFuncTable_106[] = {
    {
        VK_DBE_ALPHANUMERIC,  // Base Vk
        KBDNLS_TYPE_TOGGLE,   // NLSFEProcType
        KBDNLS_INDEX_NORMAL,  // NLSFEProcCurrent
        0x02, /* 00000010 */  // NLSFEProcSwitch
        {                     // NLSFEProc
            {KBDNLS_ALPHANUM,0},               // Base
            {KBDNLS_SEND_PARAM_VK,VK_CAPITAL}, // Shift
            {KBDNLS_ALPHANUM,0},               // Control
            {KBDNLS_ALPHANUM,0},               // Shift+Control
            {KBDNLS_ALPHANUM,0},               // Alt
            {KBDNLS_ALPHANUM,0},               // Shift+Alt
            {KBDNLS_CODEINPUT,0},              // Control+Alt
            {KBDNLS_CODEINPUT,0}               // Shift+Control+Alt
        },
        {                     // NLSFEProcAlt
            {KBDNLS_SEND_PARAM_VK,VK_CAPITAL}, // Base
            {KBDNLS_SEND_PARAM_VK,VK_CAPITAL}, // Shift
            {KBDNLS_NOEVENT,0},                // Control
            {KBDNLS_NOEVENT,0},                // Shift+Control
            {KBDNLS_NOEVENT,0},                // Alt
            {KBDNLS_NOEVENT,0},                // Shift+Alt
            {KBDNLS_NOEVENT,0},                // Control+Alt
            {KBDNLS_NOEVENT,0}                 // Shift+Control+Alt
        }
    },
    {
        VK_DBE_HIRAGANA,     // Base Vk
        KBDNLS_TYPE_TOGGLE,  // NLSFEProcType
        KBDNLS_INDEX_NORMAL, // NLSFEProcCurrent
        0x08, /* 00001000 */ // NLSFEProcSwitch
        {                    // NLSFEProc
            {KBDNLS_HIRAGANA,0},             // Base
            {KBDNLS_KATAKANA,0},             // Shift
            {KBDNLS_HIRAGANA,0},             // Control
            {KBDNLS_SEND_PARAM_VK,VK_KANA},  // Shift+Control
            {KBDNLS_ROMAN,0},                // Alt
            {KBDNLS_ROMAN,0},                // Shift+Alt
            {KBDNLS_ROMAN,0},                // Control+Alt
            {KBDNLS_NOEVENT,0}               // Shift+Control+Alt
        },
        {                    // NLSFEProcIndexAlt
            {KBDNLS_SEND_PARAM_VK,VK_KANA},  // Base
            {KBDNLS_SEND_PARAM_VK,VK_KANA},  // Shift
            {KBDNLS_SEND_PARAM_VK,VK_KANA},  // Control
            {KBDNLS_SEND_PARAM_VK,VK_KANA},  // Shift+Control
            {KBDNLS_NOEVENT,0},              // Alt
            {KBDNLS_NOEVENT,0},              // Shift+Alt
            {KBDNLS_NOEVENT,0},              // Control+Alt
            {KBDNLS_NOEVENT,0}               // Shift+Control+Alt
        }
    },
    {
        VK_DBE_SBCSCHAR,     // Base Vk
        KBDNLS_TYPE_NORMAL,  // NLSFEProcType
        KBDNLS_INDEX_NORMAL, // NLSFEProcCurrent
        0x0,                 // NLSFEProcSwitch
        {                    // NLSFEProc
            {KBDNLS_SBCSDBCS,0},             // Base
            {KBDNLS_SBCSDBCS,0},             // Shift
            {KBDNLS_SBCSDBCS,0},             // Control
            {KBDNLS_SBCSDBCS,0},             // Shift+Control
            {KBDNLS_SEND_PARAM_VK,VK_KANJI}, // Alt
            {KBDNLS_SBCSDBCS,0},             // Shift+Alt
            {KBDNLS_SEND_PARAM_VK,VK_DBE_ENTERIMECONFIGMODE}, // Control+Alt
            {KBDNLS_SEND_PARAM_VK,VK_DBE_ENTERIMECONFIGMODE}  // Shift+Control+Alt
        },
        {                    // NLSFEProcIndexAlt
            {KBDNLS_NULL,0},  // Base
            {KBDNLS_NULL,0},  // Shift
            {KBDNLS_NULL,0},  // Control
            {KBDNLS_NULL,0},  // Shift+Control
            {KBDNLS_NULL,0},  // Alt
            {KBDNLS_NULL,0},  // Shift+Alt
            {KBDNLS_NULL,0},  // Control+Alt
            {KBDNLS_NULL,0}   // Shift+Control+Alt
        }
    },
    {
        VK_NONCONVERT,       // Base Vk
        KBDNLS_TYPE_NORMAL,  // NLSFEProcType
        KBDNLS_INDEX_NORMAL, // NLSFEProcCurrent
        0x0,                 // NLSFEProcSwitch
        {                    // NLSFEProc
            {KBDNLS_SEND_BASE_VK,0},         // Base
            {KBDNLS_SEND_BASE_VK,0},         // Shift
            {KBDNLS_SEND_BASE_VK,0},         // Control
            {KBDNLS_SEND_BASE_VK,0},         // Shift+Control
            {KBDNLS_SEND_BASE_VK,0},         // Alt
            {KBDNLS_SEND_BASE_VK,0},         // Shift+Alt
            {KBDNLS_SEND_PARAM_VK,VK_DBE_ENTERWORDREGISTERMODE}, // Control+Alt
            {KBDNLS_SEND_PARAM_VK,VK_DBE_ENTERWORDREGISTERMODE}  // Shift+Control+Alt
        },
        {                         // NLSFEProcIndexAlt
            {KBDNLS_NULL,0},  // Base
            {KBDNLS_NULL,0},  // Shift
            {KBDNLS_NULL,0},  // Control
            {KBDNLS_NULL,0},  // Shift+Control
            {KBDNLS_NULL,0},  // Alt
            {KBDNLS_NULL,0},  // Shift+Alt
            {KBDNLS_NULL,0},  // Control+Alt
            {KBDNLS_NULL,0}   // Shift+Control+Alt
        }
    }
};

/***********************************************************************\
* KbdNlsTables
*
\***********************************************************************/

ALLOC_SECTION_LDATA KBDNLSTABLES KbdNlsTables106 = {
    0,                      // OEM ID (0 = Microsoft)
    0,                      // Information
    4,                      // Number of VK_F entry
    VkToFuncTable_106,      // Pointer to VK_F array
    0,                      // Number of MouseVk entry
    NULL                    // Pointer to MouseVk array
};

//@@BEGIN_DDKSPLIT
static ALLOC_SECTION_LDATA KBDNLSTABLES KbdNlsTablesNEC98 = {
    0x0d,                   // OEM ID (0x0d = NEC)
    0,                      // Information
    4,                      // Number of VK_F entry
    VkToFuncTable_106,      // Pointer to VK_F array
    0,                      // Number of MouseVk entry
    NULL                    // Pointer to MouseVk array
};
//@@END_DDKSPLIT

PKBDNLSTABLES KbdNlsLayerDescriptor(VOID)
{
//@@BEGIN_DDKSPLIT
    if (!IsNEC_98) {
//@@END_DDKSPLIT
        return &KbdNlsTables106;
//@@BEGIN_DDKSPLIT
    } else {
        return &KbdNlsTablesNEC98;
    }
//@@END_DDKSPLIT
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kbd\fe_kbds\jpn\101\kbd101.c ===
/***************************************************************************\
* Module Name: kbd101.c
*
* Copyright (c) 1985-2000, Microsoft Corporation
*
* History:
\***************************************************************************/

#include <windows.h>
#include "kbdjpn.h"
#include "kbd101.h"

#if defined(_M_IA64)
#pragma section(".data")
#define ALLOC_SECTION_LDATA __declspec(allocate(".data"))
#else
#pragma data_seg(".data")
#define ALLOC_SECTION_LDATA
#endif

/***************************************************************************\
* ausVK[] - Virtual Scan Code to Virtual Key conversion table for 101
\***************************************************************************/

static ALLOC_SECTION_LDATA USHORT ausVK[] = {
    T00, T01, T02, T03, T04, T05, T06, T07,
    T08, T09, T0A, T0B, T0C, T0D, T0E, T0F,
    T10, T11, T12, T13, T14, T15, T16, T17,
    T18, T19, T1A, T1B, T1C, T1D, T1E, T1F,
    T20, T21, T22, T23, T24, T25, T26, T27,
    T28,

    /*
     * '~' key must have KBDSPECIAL bit set. (NLS key)
     */
    T29 | KBDSPECIAL,

              T2A, T2B, T2C, T2D, T2E, T2F,
    T30, T31, T32, T33, T34, T35,

    /*
     * Right-hand Shift key must have KBDEXT bit set.
     */
    T36 | KBDEXT,

    /*
     * numpad_* + Shift/Alt -> SnapShot
     */
    T37 | KBDMULTIVK,

    T38, T39,

    /*
     * CapsLock key must have KBDSPECIAL bit set. (NLS key)
     */
    T3A | KBDSPECIAL,

                   T3B, T3C, T3D, T3E, T3F,
    T40, T41, T42, T43, T44,

    /*
     * NumLock Key:
     *     KBDEXT     - VK_NUMLOCK is an Extended key
     *     KBDMULTIVK - VK_NUMLOCK or VK_PAUSE (without or with CTRL)
     */
    T45 | KBDEXT | KBDMULTIVK,

    T46 | KBDMULTIVK,

    /*
     * Number Pad keys:
     *     KBDNUMPAD  - digits 0-9 and decimal point.
     *     KBDSPECIAL - require special processing by Windows
     */
    T47 | KBDNUMPAD | KBDSPECIAL,   // Numpad 7 (Home)
    T48 | KBDNUMPAD | KBDSPECIAL,   // Numpad 8 (Up),
    T49 | KBDNUMPAD | KBDSPECIAL,   // Numpad 9 (PgUp),
    T4A,
    T4B | KBDNUMPAD | KBDSPECIAL,   // Numpad 4 (Left),
    T4C | KBDNUMPAD | KBDSPECIAL,   // Numpad 5 (Clear),
    T4D | KBDNUMPAD | KBDSPECIAL,   // Numpad 6 (Right),
    T4E,
    T4F | KBDNUMPAD | KBDSPECIAL,   // Numpad 1 (End),
    T50 | KBDNUMPAD | KBDSPECIAL,   // Numpad 2 (Down),
    T51 | KBDNUMPAD | KBDSPECIAL,   // Numpad 3 (PgDn),
    T52 | KBDNUMPAD | KBDSPECIAL,   // Numpad 0 (Ins),
    T53 | KBDNUMPAD | KBDSPECIAL,   // Numpad . (Del),

    T54, T55, T56, T57, T58, T59, T5A, T5B,
    T5C, T5D, T5E, T5F, T60, T61, T62, T63,
    T64, T65, T66, T67, T68, T69, T6A, T6B,
    T6C, T6D, T6E, T6F, T70, T71, T72, T73,
    T74, T75, T76, T77, T78, T79, T7A, T7B,
    T7C, T7D, T7E, T7F

};

static ALLOC_SECTION_LDATA VSC_VK aE0VscToVk[] = {
        { 0x10, X10 | KBDEXT              },  // Speedracer: Previous Track
        { 0x19, X19 | KBDEXT              },  // Speedracer: Next Track
        { 0x1C, X1C | KBDEXT              },  // Numpad Enter
        { 0x1D, X1D | KBDEXT              },  // RControl
        { 0x20, X20 | KBDEXT              },  // Speedracer: Volume Mute
        { 0x21, X21 | KBDEXT              },  // Speedracer: Launch App 2
        { 0x22, X22 | KBDEXT              },  // Speedracer: Media Play/Pause
        { 0x24, X24 | KBDEXT              },  // Speedracer: Media Stop
        { 0x2E, X2E | KBDEXT              },  // Speedracer: Volume Down
        { 0x30, X30 | KBDEXT              },  // Speedracer: Volume Up
        { 0x32, X32 | KBDEXT              },  // Speedracer: Browser Home
        { 0x35, X35 | KBDEXT              },  // Numpad Divide
        { 0x37, X37 | KBDEXT              },  // Snapshot
        { 0x38, X38 | KBDEXT              },  // RMenu
        { 0x46, X46 | KBDEXT              },  // Break (Ctrl + Pause)
        { 0x47, X47 | KBDEXT              },  // Home
        { 0x48, X48 | KBDEXT              },  // Up
        { 0x49, X49 | KBDEXT              },  // Prior
        { 0x4B, X4B | KBDEXT              },  // Left
        { 0x4D, X4D | KBDEXT              },  // Right
        { 0x4F, X4F | KBDEXT              },  // End
        { 0x50, X50 | KBDEXT              },  // Down
        { 0x51, X51 | KBDEXT              },  // Next
        { 0x52, X52 | KBDEXT              },  // Insert
        { 0x53, X53 | KBDEXT              },  // Delete
        { 0x5B, X5B | KBDEXT              },  // Left Win
        { 0x5C, X5C | KBDEXT              },  // Right Win
        { 0x5D, X5D | KBDEXT              },  // Application
        { 0x5F, X5F | KBDEXT              },  // Speedracer: Sleep
        { 0x65, X65 | KBDEXT              },  // Speedracer: Browser Search
        { 0x66, X66 | KBDEXT              },  // Speedracer: Browser Favorites
        { 0x67, X67 | KBDEXT              },  // Speedracer: Browser Refresh
        { 0x68, X68 | KBDEXT              },  // Speedracer: Browser Stop
        { 0x69, X69 | KBDEXT              },  // Speedracer: Browser Forward
        { 0x6A, X6A | KBDEXT              },  // Speedracer: Browser Back
        { 0x6B, X6B | KBDEXT              },  // Speedracer: Launch App 1
        { 0x6C, X6C | KBDEXT              },  // Speedracer: Launch Mail
        { 0x6D, X6D | KBDEXT              },  // Speedracer: Launch Media Selector
        { 0,      0                       }
};

static ALLOC_SECTION_LDATA VSC_VK aE1VscToVk[] = {
        { 0x1D, Y1D                       },  // Pause
        { 0   ,   0                       }
};

/***************************************************************************\
* aVkToBits[]  - map Virtual Keys to Modifier Bits
*
* See kbd.h for a full description.
*
* US Keyboard has only three shifter keys:
*     SHIFT (L & R) affects alphabnumeric keys,
*     CTRL  (L & R) is used to generate control characters
*     ALT   (L & R) used for generating characters by number with numpad
\***************************************************************************/

static ALLOC_SECTION_LDATA VK_TO_BIT aVkToBits[] = {
    { VK_SHIFT,   KBDSHIFT },
    { VK_CONTROL, KBDCTRL  },
    { VK_MENU,    KBDALT   },
    { VK_KANA,    KBDKANA  },
    { 0,          0        }
};

/***************************************************************************\
* aModification[]  - map character modifier bits to modification number
*
* See kbd.h for a full description.
*
\***************************************************************************/

static ALLOC_SECTION_LDATA MODIFIERS CharModifiers = {
    &aVkToBits[0],
    11,
    {
    //  Modification# //  Keys Pressed  : Explanation
    //  ============= // ============== : =============================
        0,            //                : unshifted characters
        1,            //          SHIFT : capitals, ~!@#$%^&*()_+{}:"<>? etc.
        4,            //     CTRL       : control characters
        6,            //     CTRL SHIFT :
        SHFT_INVALID, // ALT            : invalid
        SHFT_INVALID, // ALT      SHIFT : invalid
        SHFT_INVALID, // ALT CTRL       : invalid
        SHFT_INVALID, // ALT CTRL SHIFT : invalid
        2,            //KANA
        3,            //KANA      SHIFT
        5,            //KANA CTRL
        7             //KANA CTRL SHIFT
    }
};

/***************************************************************************\
*
* aVkToWch2[]  - Virtual Key to WCHAR translation for 2 shift states
* aVkToWch3[]  - Virtual Key to WCHAR translation for 3 shift states
* aVkToWch4[]  - Virtual Key to WCHAR translation for 4 shift states
*
* Table attributes: Unordered Scan, null-terminated
*
* Search this table for an entry with a matching Virtual Key to find the
* corresponding unshifted and shifted WCHAR characters.
*
* Reserved VirtualKey values (first column)
*     -1            - this line contains dead characters (diacritic)
*     0             - terminator
*
* Reserved Attribute values (second column)
*     CAPLOK        - CapsLock affects this key like Shift
*     KANALOK       - The KANA-LOCK key affects this key like KANA
*
* Reserved character values (third through last column)
*     WCH_NONE      - No character
*     WCH_DEAD      - Dead character (diacritic) value is in next line
*
\***************************************************************************/

static ALLOC_SECTION_LDATA VK_TO_WCHARS4 aVkToWch4[] = {
    //                               |          |   SHIFT  |  KANA  | K+SHFT |
    //                               |          |==========|========|========|
    {'0'          ,          KANALOK ,'0'       ,')'       ,WCH_WA  ,WCH_WO  },
    {'1'          ,          KANALOK ,'1'       ,'!'       ,WCH_NU  ,WCH_NU  },
    {'3'          ,          KANALOK ,'3'       ,'#'       ,WCH_A   ,WCH_AA  },
    {'4'          ,          KANALOK ,'4'       ,'$'       ,WCH_U   ,WCH_UU  },
    {'5'          ,          KANALOK ,'5'       ,'%'       ,WCH_E   ,WCH_EE  },
    {'7'          ,          KANALOK ,'7'       ,'&'       ,WCH_YA  ,WCH_YAA },
    {'8'          ,          KANALOK ,'8'       ,'*'       ,WCH_YU  ,WCH_YUU },
    {'9'          ,          KANALOK ,'9'       ,'('       ,WCH_YO  ,WCH_YOO },
    {'A'          , CAPLOK | KANALOK ,'a'       ,'A'       ,WCH_TI  ,WCH_TI  },
    {'B'          , CAPLOK | KANALOK ,'b'       ,'B'       ,WCH_KO  ,WCH_KO  },
    {'C'          , CAPLOK | KANALOK ,'c'       ,'C'       ,WCH_SO  ,WCH_SO  },
    {'D'          , CAPLOK | KANALOK ,'d'       ,'D'       ,WCH_SI  ,WCH_SI  },
    {'E'          , CAPLOK | KANALOK ,'e'       ,'E'       ,WCH_I   ,WCH_II  },
    {'F'          , CAPLOK | KANALOK ,'f'       ,'F'       ,WCH_HA  ,WCH_HA  },
    {'G'          , CAPLOK | KANALOK ,'g'       ,'G'       ,WCH_KI  ,WCH_KI  },
    {'H'          , CAPLOK | KANALOK ,'h'       ,'H'       ,WCH_KU  ,WCH_KU  },
    {'I'          , CAPLOK | KANALOK ,'i'       ,'I'       ,WCH_NI  ,WCH_NI  },
    {'J'          , CAPLOK | KANALOK ,'j'       ,'J'       ,WCH_MA  ,WCH_MA  },
    {'K'          , CAPLOK | KANALOK ,'k'       ,'K'       ,WCH_NO  ,WCH_NO  },
    {'L'          , CAPLOK | KANALOK ,'l'       ,'L'       ,WCH_RI  ,WCH_RI  },
    {'M'          , CAPLOK | KANALOK ,'m'       ,'M'       ,WCH_MO  ,WCH_MO  },
    {'N'          , CAPLOK | KANALOK ,'n'       ,'N'       ,WCH_MI  ,WCH_MI  },
    {'O'          , CAPLOK | KANALOK ,'o'       ,'O'       ,WCH_RA  ,WCH_RA  },
    {'P'          , CAPLOK | KANALOK ,'p'       ,'P'       ,WCH_SE  ,WCH_SE  },
    {'Q'          , CAPLOK | KANALOK ,'q'       ,'Q'       ,WCH_TA  ,WCH_TA  },
    {'R'          , CAPLOK | KANALOK ,'r'       ,'R'       ,WCH_SU  ,WCH_SU  },
    {'S'          , CAPLOK | KANALOK ,'s'       ,'S'       ,WCH_TO  ,WCH_TO  },
    {'T'          , CAPLOK | KANALOK ,'t'       ,'T'       ,WCH_KA  ,WCH_KA  },
    {'U'          , CAPLOK | KANALOK ,'u'       ,'U'       ,WCH_NA  ,WCH_NA  },
    {'V'          , CAPLOK | KANALOK ,'v'       ,'V'       ,WCH_HI  ,WCH_HI  },
    {'W'          , CAPLOK | KANALOK ,'w'       ,'W'       ,WCH_TE  ,WCH_TE  },
    {'X'          , CAPLOK | KANALOK ,'x'       ,'X'       ,WCH_SA  ,WCH_SA  },
    {'Y'          , CAPLOK | KANALOK ,'y'       ,'Y'       ,WCH_NN  ,WCH_NN  },
    {'Z'          , CAPLOK | KANALOK ,'z'       ,'Z'       ,WCH_TU  ,WCH_TUU },
    {VK_OEM_1     ,          KANALOK ,';'       ,':'       ,WCH_RE  ,WCH_RE  },
    {VK_OEM_2     ,          KANALOK ,'/'       ,'?'       ,WCH_ME  ,WCH_MD  },
    {VK_OEM_3     ,          KANALOK ,'`'       ,'~'       ,WCH_RO  ,WCH_RO  },
    {VK_OEM_7     ,          KANALOK ,0x27      ,'"'       ,WCH_KE  ,WCH_KE  },
    {VK_OEM_8     , 0                ,WCH_NONE  ,WCH_NONE  ,WCH_NONE,WCH_NONE},
    {VK_OEM_COMMA ,          KANALOK ,','       ,'<'       ,WCH_NE  ,WCH_IC  },
    {VK_OEM_PERIOD,          KANALOK ,'.'       ,'>'       ,WCH_RU  ,WCH_IP  },
    {VK_OEM_PLUS  ,          KANALOK ,'='       ,'+'       ,WCH_HE  ,WCH_HE  },
    {VK_TAB       , 0                ,'\t'      ,'\t'      ,'\t'    ,'\t'    },
    {VK_ADD       , 0                ,'+'       ,'+'       ,'+'     ,'+'     },
    {VK_DECIMAL   , 0                ,'.'       ,'.'       ,'.'     ,'.'     },
    {VK_DIVIDE    , 0                ,'/'       ,'/'       ,'/'     ,'/'     },
    {VK_MULTIPLY  , 0                ,'*'       ,'*'       ,'*'     ,'*'     },
    {VK_SUBTRACT  , 0                ,'-'       ,'-'       ,'-'     ,'-'     },
    {0            , 0                ,0         ,0         ,0       ,0       }
};

static ALLOC_SECTION_LDATA VK_TO_WCHARS6 aVkToWch6[] = {
    //                      |          |   SHIFT  |  KANA  | K+SHFT |  CONTROL  |  K+CTRL   |
    //                      |          |==========|========|========|===========|===========|
    {VK_BACK      , 0       ,'\b'      ,'\b'      ,'\b'    ,'\b'    , 0x7f      , 0x7f      },
    {VK_CANCEL    , 0       ,0x03      ,0x03      ,0x03    ,0x03    , 0x03      , 0x03      },
    {VK_ESCAPE    , 0       ,0x1b      ,0x1b      ,0x1b    ,0x1b    , 0x1b      , 0x1b      },
    {VK_OEM_4     , KANALOK ,'['       ,'{'       ,WCH_VS  ,WCH_OB  , 0x1b      , 0x1b      },
    {VK_OEM_5     , KANALOK ,'\\'      ,'|'       ,WCH_MU  ,WCH_MU  , 0x1c      , 0x1c      },
    {VK_OEM_102   , KANALOK ,'\\'      ,'|'       ,WCH_MU  ,WCH_MU  , 0x1c      , 0x1c      },
    {VK_OEM_6     , KANALOK ,']'       ,'}'       ,WCH_SVS ,WCH_CB  , 0x1d      , 0x1d      },
    {VK_RETURN    , 0       ,'\r'      ,'\r'      ,'\r'    ,'\r'    , '\n'      , '\n'      },
    {VK_SPACE     , 0       ,' '       ,' '       ,' '     ,' '     , 0x20      , 0x20      },
    {0            , 0       ,0         ,0         ,0       ,0       , 0         , 0         }
};

static ALLOC_SECTION_LDATA VK_TO_WCHARS8 aVkToWch8[] = {
    //                      |          |   SHIFT  |  KANA  | K+SHFT |  CONTROL  |  K+CTRL   | SHFT+CTRL |K+SHFT+CTRL|
    //                      |          |==========|========|========|===========|===========|===========|===========|
    {'2'          , KANALOK ,'2'       ,'@'       ,WCH_HU  ,WCH_HU  , WCH_NONE  , WCH_NONE  , 0x00      , 0x00      },
    {'6'          , KANALOK ,'6'       ,'^'       ,WCH_O   ,WCH_OO  , WCH_NONE  , WCH_NONE  , 0x1e      , 0x1e      },
    {VK_OEM_MINUS , KANALOK ,'-'       ,'_'       ,WCH_HO  ,WCH_PS  , WCH_NONE  , WCH_NONE  , 0x1f      , 0x1f      },
    {0            , 0       ,0         ,0         ,0       ,0       , 0         , 0         , 0         , 0         }
};

// Put this last so that VkKeyScan interprets number characters
// as coming from the main section of the kbd (aVkToWch2 and
// aVkToWch4) before considering the numpad (aVkToWch1).

static ALLOC_SECTION_LDATA VK_TO_WCHARS4 aVkToWch1[] = {
    //                     |          |   SHIFT  |  KANA  | K+SHFT |
    //                     |          |==========|========|========|
    { VK_NUMPAD0   , 0      ,  '0'    , WCH_NONE ,   '0'  ,WCH_NONE},
    { VK_NUMPAD1   , 0      ,  '1'    , WCH_NONE ,   '1'  ,WCH_NONE},
    { VK_NUMPAD2   , 0      ,  '2'    , WCH_NONE ,   '2'  ,WCH_NONE},
    { VK_NUMPAD3   , 0      ,  '3'    , WCH_NONE ,   '3'  ,WCH_NONE},
    { VK_NUMPAD4   , 0      ,  '4'    , WCH_NONE ,   '4'  ,WCH_NONE},
    { VK_NUMPAD5   , 0      ,  '5'    , WCH_NONE ,   '5'  ,WCH_NONE},
    { VK_NUMPAD6   , 0      ,  '6'    , WCH_NONE ,   '6'  ,WCH_NONE},
    { VK_NUMPAD7   , 0      ,  '7'    , WCH_NONE ,   '7'  ,WCH_NONE},
    { VK_NUMPAD8   , 0      ,  '8'    , WCH_NONE ,   '8'  ,WCH_NONE},
    { VK_NUMPAD9   , 0      ,  '9'    , WCH_NONE ,   '9'  ,WCH_NONE},
    { 0            , 0      ,  '\0'   , 0        ,   0    ,0       }   //null terminator
};

/***************************************************************************\
* aVkToWcharTable: table of pointers to Character Tables
*
* Describes the character tables and the order they should be searched.
*
* Note: the order determines the behavior of VkKeyScan() : this function
*       takes a character and attempts to find a Virtual Key and character-
*       modifier key combination that produces that character.  The table
*       containing the numeric keypad (aVkToWch1) must appear last so that
*       VkKeyScan('0') will be interpreted as one of keys from the main
*       section, not the numpad.  etc.
\***************************************************************************/

static ALLOC_SECTION_LDATA VK_TO_WCHAR_TABLE aVkToWcharTable[] = {
    {  (PVK_TO_WCHARS1)aVkToWch6, 6, sizeof(aVkToWch6[0]) },
    {  (PVK_TO_WCHARS1)aVkToWch8, 8, sizeof(aVkToWch8[0]) },
    {  (PVK_TO_WCHARS1)aVkToWch4, 4, sizeof(aVkToWch4[0]) },
    {  (PVK_TO_WCHARS1)aVkToWch1, 4, sizeof(aVkToWch1[0]) },  // must come last
    {                       NULL, 0, 0                    }
};

/***************************************************************************\
* aKeyNames[], aKeyNamesExt[]  - Scan Code -> Key Name tables
*
* For the GetKeyNameText() API function
*
* Tables for non-extended and extended (KBDEXT) keys.
* (Keys producing printable characters are named by the character itself)
\***************************************************************************/

static ALLOC_SECTION_LDATA VSC_LPWSTR aKeyNames[] = {
    0x01,    L"Esc",
    0x0e,    L"Backspace",
    0x0f,    L"Tab",
    0x1c,    L"Enter",
    0x1d,    L"Ctrl",
    0x2a,    L"Shift",
    0x36,    L"Right Shift",
    0x37,    L"Num *",
    0x38,    L"Alt",
    0x39,    L"Space",
    0x3a,    L"Caps Lock",
    0x3b,    L"F1",
    0x3c,    L"F2",
    0x3d,    L"F3",
    0x3e,    L"F4",
    0x3f,    L"F5",
    0x40,    L"F6",
    0x41,    L"F7",
    0x42,    L"F8",
    0x43,    L"F9",
    0x44,    L"F10",
    0x45,    L"Pause",
    0x46,    L"Scroll Lock",
    0x47,    L"Num 7",
    0x48,    L"Num 8",
    0x49,    L"Num 9",
    0x4a,    L"Num -",
    0x4b,    L"Num 4",
    0x4c,    L"Num 5",
    0x4d,    L"Num 6",
    0x4e,    L"Num +",
    0x4f,    L"Num 1",
    0x50,    L"Num 2",
    0x51,    L"Num 3",
    0x52,    L"Num 0",
    0x53,    L"Num Del",
    0x54,    L"Sys Req",
    0x57,    L"F11",
    0x58,    L"F12",
    0x7C,    L"F13",
    0x7D,    L"F14",
    0x7E,    L"F15",
    0x7F,    L"F16",
    0x80,    L"F17",
    0x81,    L"F18",
    0x82,    L"F19",
    0x83,    L"F20",
    0x84,    L"F21",
    0x85,    L"F22",
    0x86,    L"F23",
    0x87,    L"F24",
    0   ,    NULL
};

static ALLOC_SECTION_LDATA VSC_LPWSTR aKeyNamesExt[] = {
    0x1c,    L"Num Enter",
    0x1d,    L"Right Control",
    0x35,    L"Num /",
    0x37,    L"Prnt Scrn",
    0x38,    L"Right Alt",
    0x45,    L"Num Lock",
    0x46,    L"Break",
    0x47,    L"Home",
    0x48,    L"Up",
    0x49,    L"Page Up",
    0x4b,    L"Left",
    0x4d,    L"Right",
    0x4f,    L"End",
    0x50,    L"Down",
    0x51,    L"Page Down",
    0x52,    L"Insert",
    0x53,    L"Delete",
    0x5B,    L"Left Windows",
    0x5C,    L"Right Windows",
    0x5D,    L"Application",
    0   ,    NULL
};

ALLOC_SECTION_LDATA KBDTABLES KbdTables101 = {
    /*
     * Modifier keys
     */
    &CharModifiers,

    /*
     * Characters tables
     */
    aVkToWcharTable,

    /*
     * Diacritics  (none for US English)
     */
    NULL,

    /*
     * Names of Keys  (no dead keys)
     */
    aKeyNames,
    aKeyNamesExt,
    NULL,

    /*
     * Scan codes to Virtual Keys
     */
    ausVK,
    sizeof(ausVK) / sizeof(ausVK[0]),
    aE0VscToVk,
    aE1VscToVk,

    /*
     * No Locale-specific special processing
     */
    0,


    /*
     * No Ligatures
     */
    0, 0, NULL,

    /*
     * Type and subtype.
     */
    KEYBOARD_TYPE_GENERIC_101,  // Generic 101
    MAKEWORD(MICROSOFT_KBD_101_TYPE, NLSKBD_OEM_MICROSOFT),
};

PKBDTABLES KbdLayerDescriptor(VOID)
{
    return &KbdTables101;
}

/***********************************************************************\
* VkToFuncTable_101[]
*
\***********************************************************************/

static ALLOC_SECTION_LDATA VK_F VkToFuncTable_101[] = {
    {
        VK_CAPITAL,                 // Base Vk
        KBDNLS_TYPE_TOGGLE,         // NLSFEProcType
        KBDNLS_INDEX_NORMAL,        // NLSFEProcCurrent
        0x08, /* 00001000 */        // NLSFEProcSwitch
        {                           // NLSFEProc
            {KBDNLS_SEND_BASE_VK,0},        // Base
            {KBDNLS_ALPHANUM,0},            // Shift
            {KBDNLS_HIRAGANA,0},            // Control
            {KBDNLS_SEND_PARAM_VK,VK_KANA}, // Shift+Control
            {KBDNLS_KATAKANA,0},            // Alt
            {KBDNLS_SEND_BASE_VK,0},        // Shift+Alt
            {KBDNLS_SEND_BASE_VK,0},        // Control+Alt
            {KBDNLS_SEND_BASE_VK,0}         // Shift+Control+Alt
        },
        {                           // NLSFEProcAlt
            {KBDNLS_SEND_PARAM_VK,VK_KANA}, // Base
            {KBDNLS_SEND_PARAM_VK,VK_KANA}, // Shift
            {KBDNLS_SEND_PARAM_VK,VK_KANA}, // Control
            {KBDNLS_SEND_PARAM_VK,VK_KANA}, // Shift+Control
            {KBDNLS_SEND_BASE_VK,0},        // Alt
            {KBDNLS_SEND_BASE_VK,0},        // Shift+Alt
            {KBDNLS_SEND_BASE_VK,0},        // Control+Alt
            {KBDNLS_SEND_BASE_VK,0}         // Shift+Control+Alt
        }
    },
    {
        VK_OEM_3,            // Base Vk
        KBDNLS_TYPE_NORMAL,  // NLSFEProcType
        KBDNLS_INDEX_NORMAL, // NLSFEProcCurrent
        0,                   // NLSFEProcSwitch
        {                    // NLSFEProc
            {KBDNLS_SEND_BASE_VK,0},         // Base
            {KBDNLS_SEND_BASE_VK,0},         // Shift
            {KBDNLS_SBCSDBCS,0},             // Control
            {KBDNLS_SEND_BASE_VK,0},         // Shift+Control
            {KBDNLS_SEND_PARAM_VK,VK_KANJI}, // Alt
            {KBDNLS_SEND_BASE_VK,0},         // Shift+Alt
            {KBDNLS_SEND_BASE_VK,0},         // Control+Alt
            {KBDNLS_SEND_BASE_VK,0}          // Shift+Control+Alt
        },
        {                    // NLSFEProcIndexAlt
            {KBDNLS_NULL,0},                 // Base
            {KBDNLS_NULL,0},                 // Shift
            {KBDNLS_NULL,0},                 // Control
            {KBDNLS_NULL,0},                 // Shift+Control
            {KBDNLS_NULL,0},                 // Alt
            {KBDNLS_NULL,0},                 // Shift+Alt
            {KBDNLS_NULL,0},                 // Control+Alt
            {KBDNLS_NULL,0}                  // Shift+Control+Alt
        }
    }
};

/***********************************************************************\
* KbdNlsTables
*
\***********************************************************************/

ALLOC_SECTION_LDATA KBDNLSTABLES KbdNlsTables101 = {
    0,                      // OEM ID (0 = Microsoft)
    0,                      // Information
    2,                      // Number of VK_F entry
    VkToFuncTable_101,      // Pointer to VK_F array
    0,                      // Number of MouseVk entry
    NULL                    // Pointer to MouseVk array
};

PKBDNLSTABLES KbdNlsLayerDescriptor(VOID)
{
    return &KbdNlsTables101;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kbd\fe_kbds\common\fekbdcom.c ===
/***************************************************************************\
* Module Name: fekbdcom.c
* Common FE routines for stub keyboard layout DLLs
*
* Copyright (c) 1985-92, Microsoft Corporation
*
* History: Created Aug 1997 by Hiro Yamamoto
\***************************************************************************/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <kbd.h>

/***************************************************************************\
 * KbdLayerRealDllFile() returns the name of the real keyboard Dll
 *
 * Get Dll name from the registry
 * PATH:"\Registry\Machine\System\CurrentControlSet\Services\i8042prt\Parameters"
 * VALUE:"LayerDriver" (REG_SZ)
 *
 * kbdjpn.dll for Japanese and kbdkor.dll for Korean
\***************************************************************************/

#if 0   // FYI: old explanation
/***************************************************************************\
 * KbdLayerRealDriverFile() returns the name of the real keyboard driver
 *
 * 1) Get Path to the name of safe real driver
 * KEY: "\Registry\Machine\Hardware\DeviceMap\KeyboardPort"
 * VALUE: "\Device\KeyboardPort0" (REG_SZ) keeps path in the registry
 *   e.g. "\REGISTRY\Machine\System\ControlSet001\Services\i8042prt"
 *                                               ~~~~~~~~~~~~~~~~~~
 * 2) Create path from the results
 * "\Registry\Machine\System\CurrentControlSet" + "\Services\i8042prt"  + "\Parameters"
 *
 * 3) Get value
 * PATH: "\Registry\Machine\System\CurrentControlSet\Services\i8042prt\Parameters"
 * VALUE: "Parameters" (REG_SZ)
 *
 * NOTE: default value:
 *      "KBD101.DLL" for Japanese
 *      "KBD101A.DLL" for Korean
 *
 * kbdjpn.dll and kbdkor.dll
\***************************************************************************/
#endif


#if defined(HIRO_DBG)
#define TRACE(x)    DbgPrint x
#else
#define TRACE(x)
#endif

#ifndef ARRAY_SIZE
#define ARRAY_SIZE(x)   (sizeof((x)) / sizeof((x)[0]))
#endif

/*
 * Maximum character count
 */
#define MAXBUF_CSIZE    (256)

/*
 * Null-terminates the wchar string in pKey.
 * returns pointer to WCHAR string.
 *
 * limit: maximum BYTE SIZE
 */
__inline LPWSTR MakeString(PKEY_VALUE_FULL_INFORMATION pKey, size_t limit)
{
    LPWSTR pwszHead = (LPWSTR)((LPBYTE)pKey + pKey->DataOffset);
    LPWSTR pwszTail = (LPWSTR)((LPBYTE)pwszHead + pKey->DataLength);

    ASSERT((LPBYTE)pwszTail - (LPBYTE)pKey < (int)limit );
    *pwszTail = L'\0';

    UNREFERENCED_PARAMETER(limit);  // just in case

    return pwszHead;
}

#ifdef OBSOLETE // not needed any more
/*
 * Find L"\services" in the given str.
 * Case insensitive search.
 * To avoid the binary size increase,
 * and since we know the string we're searching only contains
 * alphabet and backslash,
 * it's safe here not to use ideal functions (tolower/toupper).
 */
WCHAR* FindServices(WCHAR* str)
{
    CONST WCHAR wszServices[] = L"\\services";

    while (*str) {
        CONST WCHAR* p1;
        CONST WCHAR* p2;
        for (p1 = str, p2 = wszServices; *p1 && *p2; ++p1, ++p2) {
            // we know p2 only contains alphabet and backslash
            if (*p2 != L'\\') {
                if ((*p1 != *p2) && (*p1 + (L'a' - L'A') != *p2)) {
                    break;
                }
            }
            else if (*p1 != L'\\') {
                break;
            }
        }
        if (*p2 == 0) {
            // we found a match !
            return str;
        }
        ++str;
    }
    return NULL;
}
#endif

BOOL GetRealDllFileNameWorker(CONST WCHAR* pwszKeyName, WCHAR* RealDllName)
{
    NTSTATUS            Status;
    HANDLE              handleService;
    BOOL                fRet = FALSE;
    UNICODE_STRING      servicePath;
    OBJECT_ATTRIBUTES   servicePathObjectAttributes;
    WCHAR               serviceRegistryPath[MAXBUF_CSIZE];

    servicePath.Buffer = serviceRegistryPath;
    servicePath.Length = 0;
    servicePath.MaximumLength = sizeof serviceRegistryPath; // byte count !

    RtlAppendUnicodeToString(&servicePath,
                             L"\\Registry\\Machine\\System\\CurrentControlSet\\Services\\i8042prt\\Parameters");

    InitializeObjectAttributes(&servicePathObjectAttributes,
                               &servicePath,
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               NULL);

    TRACE(("Open -> '%ws'\n",servicePath.Buffer));

    Status = NtOpenKey(&handleService, KEY_READ, &servicePathObjectAttributes);

    if (NT_SUCCESS(Status)) {

        UNICODE_STRING layerName;
        WCHAR LayerDllName[MAXBUF_CSIZE];
        ULONG cbStringSize;

        RtlInitUnicodeString(&layerName, pwszKeyName);
        TRACE(("Entry name -> '%ws'\n", layerName.Buffer));

        /*
         * Get the name of the DLL based on the device name.
         */
        Status = NtQueryValueKey(handleService,
                                 &layerName,
                                 KeyValueFullInformation,
                                 LayerDllName,
                                 sizeof LayerDllName - sizeof(WCHAR),    // reserves room for L'\0'
                                 &cbStringSize);

        if (NT_SUCCESS(Status)) {
            LPWSTR pwszStr = MakeString((PKEY_VALUE_FULL_INFORMATION)LayerDllName,
                                        sizeof LayerDllName);

            wcscpy(RealDllName, pwszStr);

            TRACE(("Real Dll name -> '%ws'\n", RealDllName));

            //
            // everything went fine.
            //
            fRet = TRUE;
        }
        NtClose(handleService);
    }

    return fRet;
}

///////////////////////////////////////////////////////////////////////
// This entry is used for backward compatibility.
// Exported as ordinal 3.
///////////////////////////////////////////////////////////////////////

BOOL KbdLayerRealDllFileNT4(WCHAR *RealDllName)
{
    TRACE(("KbdLayerRealDllFile():\n"));
    return GetRealDllFileNameWorker(L"LayerDriver", RealDllName);
}

///////////////////////////////////////////////////////////////////////
// This entry is used for remote client of Hydra server.
//
// Created: 1988 kazum
///////////////////////////////////////////////////////////////////////

BOOL KbdLayerRealDllFileForWBT(HKL hkl, WCHAR *realDllName, PCLIENTKEYBOARDTYPE pClientKbdType, LPVOID reserve)
{
    HANDLE hkRegistry = NULL;
    UNICODE_STRING    deviceMapPath;
    OBJECT_ATTRIBUTES deviceMapObjectAttributes;
    NTSTATUS          Status;
    HANDLE            handleMap;
    HANDLE            handleService;
    ULONG             cbStringSize;
    PWCHAR            pwszReg;

    UNREFERENCED_PARAMETER(reserve);

    ASSERT(pClientKbdType != NULL);
    /*
     * Set default keyboard layout for error cases.
     */
    if (PRIMARYLANGID(LOWORD(hkl)) == LANG_JAPANESE) {
        wcscpy(realDllName, L"kbd101.dll");
        pwszReg = L"\\Registry\\Machine\\System\\CurrentControlSet\\Control\\Terminal Server\\KeyboardType Mapping\\JPN";
    }
    else if (PRIMARYLANGID(LOWORD(hkl)) == LANG_KOREAN) {
        wcscpy(realDllName, L"kbd101a.dll");
        pwszReg = L"\\Registry\\Machine\\System\\CurrentControlSet\\Control\\Terminal Server\\KeyboardType Mapping\\KOR";
    }
    else {
        ASSERT(FALSE);
    }


    /*
     * Start by opening the registry for keyboard type mapping table.
     */
    RtlInitUnicodeString(&deviceMapPath, pwszReg);

    InitializeObjectAttributes(&deviceMapObjectAttributes,
                               &deviceMapPath,
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               NULL);

    TRACE(("Open -> %ws\n",deviceMapPath.Buffer));

    Status = NtOpenKey(&handleMap, KEY_READ, &deviceMapObjectAttributes);

    if (NT_SUCCESS(Status)) {
        WCHAR SubKbdBuffer[16];
        WCHAR FuncKeyBuffer[16];
        WCHAR SubKbdAndFuncKeyBuffer[32];
        UNICODE_STRING SubKbd = {
            0, sizeof SubKbdBuffer, SubKbdBuffer,
        };
        UNICODE_STRING FuncKbd = {
            0, sizeof FuncKeyBuffer, FuncKeyBuffer,
        };
        UNICODE_STRING SubKbdAndFuncKey = {
            0, sizeof SubKbdAndFuncKeyBuffer, SubKbdAndFuncKeyBuffer,
        };
        UCHAR AnsiBuffer[16];
        ANSI_STRING AnsiString;
        WCHAR LayerDriverName[256];

        /*
         * Convert the sub keyboard type to the Ansi string buffer.
         */
        RtlZeroMemory(AnsiBuffer, sizeof(AnsiBuffer));
        Status = RtlIntegerToChar(pClientKbdType->SubType, 16L,
                                  -8, // length of buffer, but negative means 0 padding
                                  AnsiBuffer);
        if (NT_SUCCESS(Status)) {
            /*
             * Convert the Ansi string buffer to Unicode string buffer.
             */
            AnsiString.Buffer = AnsiBuffer;
            AnsiString.MaximumLength = sizeof AnsiBuffer;
            AnsiString.Length = (USHORT)strlen(AnsiBuffer);
            Status = RtlAnsiStringToUnicodeString(&SubKbd, &AnsiString, FALSE);
        }
        ASSERT(NT_SUCCESS(Status));     // Make sure the number is not bad

        /*
         * Convert the number of function key to the Ansi string buffer.
         */
        RtlZeroMemory(AnsiBuffer, sizeof(AnsiBuffer));
        Status = RtlIntegerToChar(pClientKbdType->FunctionKey, 10L,
                                  -4, // length of buffer, but negative means 0 padding
                                  AnsiBuffer);
        if (NT_SUCCESS(Status)) {
            /*
             * Convert the Ansi string buffer to Unicode string buffer.
             */
            AnsiString.Buffer = AnsiBuffer;
            AnsiString.MaximumLength = sizeof AnsiBuffer;
            AnsiString.Length = (USHORT)strlen(AnsiBuffer);
            Status = RtlAnsiStringToUnicodeString(&FuncKbd, &AnsiString, FALSE);
        }
        ASSERT(NT_SUCCESS(Status));  // Make sure the number is not bad


        /*
         * Get the sub kbd + function key layout name
         */
        RtlCopyUnicodeString(&SubKbdAndFuncKey, &SubKbd);
        RtlAppendUnicodeStringToString(&SubKbdAndFuncKey, &FuncKbd);
        Status = NtQueryValueKey(handleMap,
                                 &SubKbdAndFuncKey,
                                 KeyValueFullInformation,
                                 LayerDriverName,
                                 sizeof(LayerDriverName),
                                 &cbStringSize);

        if (NT_SUCCESS(Status)) {

            LayerDriverName[cbStringSize / sizeof(WCHAR)] = L'\0';

            wcscpy(realDllName,
                   (LPWSTR)((PUCHAR)LayerDriverName +
                            ((PKEY_VALUE_FULL_INFORMATION)LayerDriverName)->DataOffset));

            TRACE(("Real driver name -> %ws\n",realDllName));
        }
        else {
            /*
             * Get the sub kbd layout name
             */
            Status = NtQueryValueKey(handleMap,
                                     &SubKbd,
                                     KeyValueFullInformation,
                                     LayerDriverName,
                                     sizeof(LayerDriverName),
                                     &cbStringSize);

            if (NT_SUCCESS(Status)) {

                LayerDriverName[cbStringSize / sizeof(WCHAR)] = L'\0';

                wcscpy(realDllName,
                       (LPWSTR)((PUCHAR)LayerDriverName +
                                ((PKEY_VALUE_FULL_INFORMATION)LayerDriverName)->DataOffset));

                TRACE(("Real driver name -> %ws\n",realDllName));
            }
        }

        NtClose(handleMap);
    }

    return TRUE;
}


__inline WCHAR* wszcpy(WCHAR* target, CONST WCHAR* src)
{
    while (*target++ = *src++);
    return target - 1;
}


///////////////////////////////////////////////////////////////////////
// KbdLayerRealDllFile
//
// Enhanced version of KbdLayerRealDllFile:
// Distinguishes KOR and JPN.
///////////////////////////////////////////////////////////////////////

BOOL KbdLayerRealDllFile(HKL hkl, WCHAR *realDllName, PCLIENTKEYBOARDTYPE pClientKbdType, LPVOID reserve)
{
    WCHAR pwszBuff[32];
    WCHAR* pwszTail;
    LPCWSTR pwsz;

    ASSERT(PRIMARYLANGID(LOWORD(hkl)) == LANG_JAPANESE ||
           PRIMARYLANGID(LOWORD(hkl)) == LANG_KOREAN);

    if (pClientKbdType != NULL) {
        //
        // HYDRA case
        //
        return KbdLayerRealDllFileForWBT(hkl, realDllName, pClientKbdType, reserve);
    }

    if (PRIMARYLANGID(LOWORD(hkl)) == LANG_JAPANESE) {
        pwsz = L" JPN";
    }
    else if (PRIMARYLANGID(LOWORD(hkl)) == LANG_KOREAN) {
        pwsz = L" KOR";
    }
    else {
        pwsz = L"";
    }

    pwszTail = wszcpy(pwszBuff, L"LayerDriver");
    if (*pwsz) {
        wszcpy(pwszTail, pwsz);
    }

    TRACE(("KbdLayerRealDllFileEx: fetching '%S'\n", pwszBuff));

    return GetRealDllFileNameWorker(pwszBuff, realDllName);
}

///////////////////////////////////////////////////////////////////////
// EnumDyanmicLayoutSwitchingLayouts
//
//
// The form of each entry is:
// name: filename of DLL without the directory path
//   to reserve a room for the future expansion, dll name can have
//   qualifier after the ",".  A string after the comma will be ignored.
//   as of Whistler, qualifier is not really effective yet.
// value: KBD_TYPE_INFO.
//   version, XXXXXXXX,YYYYYYYY
//      version is 0, in DWORD
//      XX.. is the keyboard type, in DWORD
//      YY.. is the keyboard subtype, in DWORD
///////////////////////////////////////////////////////////////////////

#define DIGITS_PER_BYTE (2)

BOOL UnpackDynamicLayoutInformation(PKBDTABLE_MULTI pKbdTableMulti, PKEY_VALUE_FULL_INFORMATION pKeyValueFullInformation)
{
    PKBDTABLE_DESC pKbdTableDesc = &pKbdTableMulti->aKbdTables[pKbdTableMulti->nTables];
    PKBD_TYPE_INFO pKbdTypeInfo;
    LPWSTR pwstrStop;

    /*
     * Validate the registry entry name, i.e. DLL name.
     */
    if (pKeyValueFullInformation->NameLength >= sizeof(pKbdTableDesc->wszDllName)) {
        TRACE(("UnpackDynamicLayoutInformation: too long DLL name %d\n", pKeyValueFullInformation->NameLength / sizeof(WCHAR)));
        return FALSE;
    }

    /*
     * Validate the data field.
     */
    if (pKeyValueFullInformation->DataLength != sizeof(KBD_TYPE_INFO)) {
        TRACE(("UnpackDynamicLayoutInformation: invalid data length %d for %.*ws\n",
               pKeyValueFullInformation->DataLength, pKeyValueFullInformation->NameLength / sizeof(WCHAR), pKeyValueFullInformation->Name));
        return FALSE;
    }

    /*
     * Retrieve the DLL name.
     */
    wcsncpy(pKbdTableDesc->wszDllName, pKeyValueFullInformation->Name, pKeyValueFullInformation->NameLength / sizeof(WCHAR));
    /*
     * Make sure it's NULL terminated.
     */
    pKbdTableDesc->wszDllName[ARRAY_SIZE(pKbdTableDesc->wszDllName) - 1] = L'\0';

    /*
     * Cut out the qualifier.
     */
    if ((pwstrStop = wcschr(pKbdTableDesc->wszDllName, L',')) != NULL) {
        /*
         * Allow additional information after ','
         */
        *pwstrStop = L'\0';
    }

    /*
     * Retrieve the type and the subtype (combined with OEMID)
     */
    pKbdTypeInfo = (PKBD_TYPE_INFO)((LPBYTE)pKeyValueFullInformation + pKeyValueFullInformation->DataOffset);
    if (pKbdTypeInfo->dwVersion != 0) {
        TRACE(("UnpackDynamicLayoutInformation: unrecognized version %d\n", pKbdTypeInfo->dwVersion));
        return FALSE;
    }

    pKbdTableDesc->dwType = pKbdTypeInfo->dwType;
    pKbdTableDesc->dwSubType = pKbdTypeInfo->dwSubType;

    TRACE((" - UnpackDynamicLayoutInformation: \"%ws\" = (%x,%x)\n", pKbdTableDesc->wszDllName,
           pKbdTableDesc->dwType, pKbdTableDesc->dwSubType));

    return TRUE;
}

BOOL EnumDynamicSwitchingLayouts(LPCWSTR lpwszBaseDll, PKBDTABLE_MULTI pKbdTableMulti)
{
    WCHAR wszKeyName[MAX_PATH];
    UNICODE_STRING strKeyName = {
        0, sizeof wszKeyName, wszKeyName,
    };
    UNICODE_STRING strBaseDll, strTmp;
    HANDLE hKey;
    OBJECT_ATTRIBUTES oaKey;
    NTSTATUS Status;

#if DBG
    /*
     * Validate the arguments
     */
    if (lpwszBaseDll == NULL || *lpwszBaseDll == L'\0' || pKbdTableMulti == NULL) {
        TRACE(("EnumDynamicSwitchingLayouts: invalid argument!\n"));
        return FALSE;
    }
#endif

    /*
     * Make full key name.
     */
    RtlInitUnicodeString(&strTmp, L"\\Registry\\Machine\\System\\CurrentControlSet\\Control\\Keyboard Layout\\Dynamic Tables\\");
    RtlCopyUnicodeString(&strKeyName, &strTmp);
    RtlInitUnicodeString(&strBaseDll, lpwszBaseDll);
    RtlAppendUnicodeStringToString(&strKeyName, &strBaseDll);

    TRACE(("EnumDynamicSwitchingLayouts: key name=\"%.*ws\"\n", strKeyName.Length, strKeyName.Buffer));

    /*
     * Open the key to read the setting from.
     */
    InitializeObjectAttributes(&oaKey,
                               &strKeyName,
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               NULL);
    Status = NtOpenKey(&hKey, KEY_READ, &oaKey);
    if (!NT_SUCCESS(Status)) {
        TRACE(("EnumDynamicSwitchingLayouts: failed to open the top key.\n"));
        return FALSE;
    }

    for (pKbdTableMulti->nTables = 0; pKbdTableMulti->nTables < ARRAY_SIZE(pKbdTableMulti->aKbdTables); ++pKbdTableMulti->nTables) {
        ULONG uResultLength;
        WCHAR buffer[512];
        PKEY_VALUE_FULL_INFORMATION pKeyValueFullInformation = (PKEY_VALUE_FULL_INFORMATION)buffer;

        Status = NtEnumerateValueKey(hKey, pKbdTableMulti->nTables, KeyValueFullInformation, pKeyValueFullInformation, sizeof buffer, &uResultLength);
        if (!NT_SUCCESS(Status)) {
            break;
        }

        if (!UnpackDynamicLayoutInformation(pKbdTableMulti, pKeyValueFullInformation)) {
            /*
             * If unpacking fails, we'll abort the whole registry stuff and will use
             * the default layout table.
             */
            pKbdTableMulti->nTables = 0;
            break;
        }
    }

    NtClose(hKey);

    if (pKbdTableMulti->nTables == 0) {
        /*
         * If there wasn't any entry, tell the caller so.
         */
        TRACE(("EnumDynamicSwitchingLayouts: there was no entry.\n"));
        return FALSE;
    }

    TRACE(("EnumDynamicSwitchingLayouts: %d entries found.\n", pKbdTableMulti->nTables));

#if DBG
    {
        UINT i;

        for (i = 0; i < pKbdTableMulti->nTables; ++i) {
            TRACE(("EnumDynamicSwitchingLayouts: [%d] \"%ws\"\n", i, pKbdTableMulti->aKbdTables[i].wszDllName));
        }
    }
#endif

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kbd\fe_kbds\jpn\106n\sources.inc ===
!IF 0

Copyright (c) 1989-2000  Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


!ENDIF

MINORCOMP=kbd106n

!include ..\..\japan.inc

SOURCES_USED=..\sources.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kbd\fe_kbds\jpn\106n\kbd106n.h ===
/****************************** Module Header ******************************\
* Module Name: kbd106n.h
*
* Copyright (c) 1985-91, Microsoft Corporation
*
* Various defines for use by keyboard input code.
*
* History:
\***************************************************************************/

/*
 * kbd type should be controlled by cl command-line argument
 */
#define KBD_TYPE 8

/*
 * Include the basis of all keyboard table values
 */
#include "kbd.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kbd\fe_kbds\jpn\106\kbd106.h ===
/****************************** Module Header ******************************\
* Module Name: kbd106.h
*
* Copyright (c) 1985-2000, Microsoft Corporation
*
* Various defines for use by keyboard input code.
*
* History:
\***************************************************************************/

/*
 * kbd type should be controlled by cl command-line argument
 */
#define KBD_TYPE 8

/*
 * Include the basis of all keyboard table values
 */
#include "kbd.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kbd\fe_kbds\jpn\106\sources.inc ===
!IF 0

Copyright (c) 1989-2000  Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


!ENDIF

MINORCOMP=kbd106

!include ..\..\japan.inc

SOURCES_USED=..\sources.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kbd\fe_kbds\jpn\106n\kbd106n.c ===
/***************************************************************************\
* Module Name: kbd106.c
*
* Copyright (c) 1985-92, Microsoft Corporation
*
* History:
\***************************************************************************/

#include <windows.h>
#include <ime.h>
#include "vkoem.h"
#include "kbdjpn.h"
#include "kbd106n.h"

#if defined(_M_IA64)
#pragma section(".data")
#define ALLOC_SECTION_LDATA __declspec(allocate(".data"))
#else
#pragma data_seg(".data")
#define ALLOC_SECTION_LDATA
#endif

/***************************************************************************\
* ausVK[] - Virtual Scan Code to Virtual Key conversion table for 106
\***************************************************************************/

static ALLOC_SECTION_LDATA USHORT ausVK[] = {
    T00, T01, T02, T03, T04, T05, T06, T07,
    T08, T09, T0A, T0B, T0C, T0D, T0E, T0F,
    T10, T11, T12, T13, T14, T15, T16, T17,
    T18, T19, T1A, T1B, T1C, T1D, T1E, T1F,
    T20, T21, T22, T23, T24, T25, T26, T27,
    T28,

    /*
     * Hankaku/Zenkaku/Kanji key must have KBDSPECIAL bit set (NLS key)
     */
    T29 | KBDSPECIAL,

              T2A, T2B, T2C, T2D, T2E, T2F,
    T30, T31, T32, T33, T34, T35,

    /*
     * Right-hand Shift key must have KBDEXT bit set.
     */
    T36 | KBDEXT,

    /*
     * numpad_* + Shift/Alt -> SnapShot
     */
    T37 | KBDMULTIVK,

    T38, T39,

    /*
     * Alphanumeric/CapsLock key must have KBDSPECIAL bit set (NLS key)
     */
    T3A | KBDSPECIAL,

                   T3B, T3C, T3D, T3E, T3F,
    T40, T41, T42, T43, T44,

    /*
     * NumLock Key:
     *     KBDEXT     - VK_NUMLOCK is an Extended key
     *     KBDMULTIVK - VK_NUMLOCK or VK_PAUSE (without or with CTRL)
     */
    T45 | KBDEXT | KBDMULTIVK,

    T46 | KBDMULTIVK,

    /*
     * Number Pad keys:
     *     KBDNUMPAD  - digits 0-9 and decimal point.
     *     KBDSPECIAL - require special processing by Windows
     */
    T47 | KBDNUMPAD | KBDSPECIAL,   // Numpad 7 (Home)
    T48 | KBDNUMPAD | KBDSPECIAL,   // Numpad 8 (Up),
    T49 | KBDNUMPAD | KBDSPECIAL,   // Numpad 9 (PgUp),
    T4A,
    T4B | KBDNUMPAD | KBDSPECIAL,   // Numpad 4 (Left),
    T4C | KBDNUMPAD | KBDSPECIAL,   // Numpad 5 (Clear),
    T4D | KBDNUMPAD | KBDSPECIAL,   // Numpad 6 (Right),
    T4E,
    T4F | KBDNUMPAD | KBDSPECIAL,   // Numpad 1 (End),
    T50 | KBDNUMPAD | KBDSPECIAL,   // Numpad 2 (Down),
    T51 | KBDNUMPAD | KBDSPECIAL,   // Numpad 3 (PgDn),
    T52 | KBDNUMPAD | KBDSPECIAL,   // Numpad 0 (Ins),
    T53 | KBDNUMPAD | KBDSPECIAL,   // Numpad . (Del),

    T54, T55, T56, T57, T58, T59, T5A, T5B,
    T5C, T5D, T5E, T5F, T60, T61, T62, T63,
    T64, T65, T66, T67, T68, T69, T6A, T6B,
    T6C, T6D, T6E, T6F,

    /*
     * Hiragana/Katakana/Roman key must have KBDSPECIAL bit set (NLS key)
     */
    T70 | KBDSPECIAL,

                             T71, T72, T73,
    T74, T75, T76, T77, T78,

    /*
     * Conversion key must have KBDSPECIAL bit set (NLS key)
     */
    T79 | KBDSPECIAL,

                                  T7A,

    /*
     * Non-Conversion key must have KBDSPECIAL bit set (NLS key)
     */
    T7B | KBDSPECIAL,

    T7C, T7D, T7E, T7F

};

static ALLOC_SECTION_LDATA VSC_VK aE0VscToVk[] = {
        { 0x10, X10 | KBDEXT              },  // Speedracer: Previous Track
        { 0x19, X19 | KBDEXT              },  // Speedracer: Next Track
        { 0x1C, X1C | KBDEXT              },  // Numpad Enter
        { 0x1D, X1D | KBDEXT              },  // RControl
        { 0x20, X20 | KBDEXT              },  // Speedracer: Volume Mute
        { 0x21, X21 | KBDEXT              },  // Speedracer: Launch App 2
        { 0x22, X22 | KBDEXT              },  // Speedracer: Media Play/Pause
        { 0x24, X24 | KBDEXT              },  // Speedracer: Media Stop
        { 0x2E, X2E | KBDEXT              },  // Speedracer: Volume Down
        { 0x30, X30 | KBDEXT              },  // Speedracer: Volume Up
        { 0x32, X32 | KBDEXT              },  // Speedracer: Browser Home
        { 0x35, X35 | KBDEXT              },  // Numpad Divide
        { 0x37, X37 | KBDEXT              },  // Snapshot
        { 0x38, X38 | KBDEXT              },  // RMenu
        { 0x46, X46 | KBDEXT              },  // Break (Ctrl + Pause)
        { 0x47, X47 | KBDEXT              },  // Home
        { 0x48, X48 | KBDEXT              },  // Up
        { 0x49, X49 | KBDEXT              },  // Prior
        { 0x4B, X4B | KBDEXT              },  // Left
        { 0x4D, X4D | KBDEXT              },  // Right
        { 0x4F, X4F | KBDEXT              },  // End
        { 0x50, X50 | KBDEXT              },  // Down
        { 0x51, X51 | KBDEXT              },  // Next
        { 0x52, X52 | KBDEXT              },  // Insert
        { 0x53, X53 | KBDEXT              },  // Delete
        { 0x5B, X5B | KBDEXT              },  // Left Win
        { 0x5C, X5C | KBDEXT              },  // Right Win
        { 0x5D, X5D | KBDEXT              },  // Application
        { 0x5F, X5F | KBDEXT              },  // Speedracer: Sleep
        { 0x65, X65 | KBDEXT              },  // Speedracer: Browser Search
        { 0x66, X66 | KBDEXT              },  // Speedracer: Browser Favorites
        { 0x67, X67 | KBDEXT              },  // Speedracer: Browser Refresh
        { 0x68, X68 | KBDEXT              },  // Speedracer: Browser Stop
        { 0x69, X69 | KBDEXT              },  // Speedracer: Browser Forward
        { 0x6A, X6A | KBDEXT              },  // Speedracer: Browser Back
        { 0x6B, X6B | KBDEXT              },  // Speedracer: Launch App 1
        { 0x6C, X6C | KBDEXT              },  // Speedracer: Launch Mail
        { 0x6D, X6D | KBDEXT              },  // Speedracer: Launch Media Selector
        { 0,      0                       }
};

static ALLOC_SECTION_LDATA VSC_VK aE1VscToVk[] = {
        { 0x1D, Y1D                       },  // Pause
        { 0   ,   0                       }
};

/***************************************************************************\
* aVkToBits[]  - map Virtual Keys to Modifier Bits
*
* See kbd.h for a full description.
*
* US Keyboard has only three shifter keys:
*     SHIFT (L & R) affects alphabnumeric keys,
*     CTRL  (L & R) is used to generate control characters
*     ALT   (L & R) used for generating characters by number with numpad
\***************************************************************************/

static ALLOC_SECTION_LDATA VK_TO_BIT aVkToBits[] = {
    { VK_SHIFT,   KBDSHIFT },
    { VK_CONTROL, KBDCTRL  },
    { VK_MENU,    KBDALT   },
    { VK_KANA,    KBDKANA  },
    { 0,          0        }
};

/***************************************************************************\
* aModification[]  - map character modifier bits to modification number
*
* See kbd.h for a full description.
*
\***************************************************************************/

static ALLOC_SECTION_LDATA MODIFIERS CharModifiers = {
    &aVkToBits[0],
    11,
    {
    //  Modification# //  Keys Pressed  : Explanation
    //  ============= // ============== : =============================
        0,            //                : unshifted characters
        1,            //          SHIFT : capitals, ~!@#$%^&*()_+{}:"<>? etc.
        4,            //     CTRL       : control characters
        6,            //     CTRL SHIFT :
        SHFT_INVALID, // ALT            : invalid
        SHFT_INVALID, // ALT      SHIFT : invalid
        SHFT_INVALID, // ALT CTRL       : invalid
        SHFT_INVALID, // ALT CTRL SHIFT : invalid
        2,            //KANA
        3,            //KANA      SHIFT
        5,            //KANA CTRL
        7             //KANA CTRL SHIFT
    }
};

/***************************************************************************\
*
* aVkToWch2[]  - Virtual Key to WCHAR translation for 2 shift states
* aVkToWch3[]  - Virtual Key to WCHAR translation for 3 shift states
* aVkToWch4[]  - Virtual Key to WCHAR translation for 4 shift states
*
* Table attributes: Unordered Scan, null-terminated
*
* Search this table for an entry with a matching Virtual Key to find the
* corresponding unshifted and shifted WCHAR characters.
*
* Reserved VirtualKey values (first column)
*     -1            - this line contains dead characters (diacritic)
*     0             - terminator
*
* Reserved Attribute values (second column)
*     CAPLOK        - CapsLock affects this key like Shift
*     KANALOK       - The KANA-LOCK key affects this key like KANA
*
* Reserved character values (third through last column)
*     WCH_NONE      - No character
*     WCH_DEAD      - Dead character (diacritic) value is in next line
*
\***************************************************************************/

static ALLOC_SECTION_LDATA VK_TO_WCHARS4 aVkToWch4[] = {
    //                               |          |   SHIFT  |  KANA  | K+SHFT |
    //                               |          |==========|========|========|
    {'0'          ,          KANALOK ,'0'       ,WCH_NONE  ,WCH_WA  ,WCH_WO  },
    {'1'          ,          KANALOK ,'1'       ,'!'       ,WCH_NU  ,WCH_NU  },
    {'3'          ,          KANALOK ,'3'       ,'#'       ,WCH_A   ,WCH_AA  },
    {'4'          ,          KANALOK ,'4'       ,'$'       ,WCH_U   ,WCH_UU  },
    {'5'          ,          KANALOK ,'5'       ,'%'       ,WCH_E   ,WCH_EE  },
    {'7'          ,          KANALOK ,'7'       ,0x27      ,WCH_YA  ,WCH_YAA },
    {'8'          ,          KANALOK ,'8'       ,'('       ,WCH_YU  ,WCH_YUU },
    {'9'          ,          KANALOK ,'9'       ,')'       ,WCH_YO  ,WCH_YOO },
    {'A'          , CAPLOK | KANALOK ,'a'       ,'A'       ,WCH_TI  ,WCH_TI  },
    {'B'          , CAPLOK | KANALOK ,'b'       ,'B'       ,WCH_KO  ,WCH_KO  },
    {'C'          , CAPLOK | KANALOK ,'c'       ,'C'       ,WCH_SO  ,WCH_SO  },
    {'D'          , CAPLOK | KANALOK ,'d'       ,'D'       ,WCH_SI  ,WCH_SI  },
    {'E'          , CAPLOK | KANALOK ,'e'       ,'E'       ,WCH_I   ,WCH_II  },
    {'F'          , CAPLOK | KANALOK ,'f'       ,'F'       ,WCH_HA  ,WCH_HA  },
    {'G'          , CAPLOK | KANALOK ,'g'       ,'G'       ,WCH_KI  ,WCH_KI  },
    {'H'          , CAPLOK | KANALOK ,'h'       ,'H'       ,WCH_KU  ,WCH_KU  },
    {'I'          , CAPLOK | KANALOK ,'i'       ,'I'       ,WCH_NI  ,WCH_NI  },
    {'J'          , CAPLOK | KANALOK ,'j'       ,'J'       ,WCH_MA  ,WCH_MA  },
    {'K'          , CAPLOK | KANALOK ,'k'       ,'K'       ,WCH_NO  ,WCH_NO  },
    {'L'          , CAPLOK | KANALOK ,'l'       ,'L'       ,WCH_RI  ,WCH_RI  },
    {'M'          , CAPLOK | KANALOK ,'m'       ,'M'       ,WCH_MO  ,WCH_MO  },
    {'N'          , CAPLOK | KANALOK ,'n'       ,'N'       ,WCH_MI  ,WCH_MI  },
    {'O'          , CAPLOK | KANALOK ,'o'       ,'O'       ,WCH_RA  ,WCH_RA  },
    {'P'          , CAPLOK | KANALOK ,'p'       ,'P'       ,WCH_SE  ,WCH_SE  },
    {'Q'          , CAPLOK | KANALOK ,'q'       ,'Q'       ,WCH_TA  ,WCH_TA  },
    {'R'          , CAPLOK | KANALOK ,'r'       ,'R'       ,WCH_SU  ,WCH_SU  },
    {'S'          , CAPLOK | KANALOK ,'s'       ,'S'       ,WCH_TO  ,WCH_TO  },
    {'T'          , CAPLOK | KANALOK ,'t'       ,'T'       ,WCH_KA  ,WCH_KA  },
    {'U'          , CAPLOK | KANALOK ,'u'       ,'U'       ,WCH_NA  ,WCH_NA  },
    {'V'          , CAPLOK | KANALOK ,'v'       ,'V'       ,WCH_HI  ,WCH_HI  },
    {'W'          , CAPLOK | KANALOK ,'w'       ,'W'       ,WCH_TE  ,WCH_TE  },
    {'X'          , CAPLOK | KANALOK ,'x'       ,'X'       ,WCH_SA  ,WCH_SA  },
    {'Y'          , CAPLOK | KANALOK ,'y'       ,'Y'       ,WCH_NN  ,WCH_NN  },
    {'Z'          , CAPLOK | KANALOK ,'z'       ,'Z'       ,WCH_TU  ,WCH_TUU },
    {VK_OEM_1     ,          KANALOK ,':'       ,'*'       ,WCH_KE  ,WCH_KE  },
    {VK_OEM_2     ,          KANALOK ,'/'       ,'?'       ,WCH_ME  ,WCH_MD  },
    {VK_OEM_3     ,          KANALOK ,'@'       ,'`'       ,WCH_VS  ,WCH_VS  },
    {VK_OEM_7     ,          KANALOK ,'^'       ,'~'       ,WCH_HE  ,WCH_HE  },
    {VK_OEM_8     , 0                ,','       ,','       ,','     ,','     },
    {VK_OEM_COMMA ,          KANALOK ,','       ,'<'       ,WCH_NE  ,WCH_IC  },
    {VK_OEM_PERIOD,          KANALOK ,'.'       ,'>'       ,WCH_RU  ,WCH_IP  },
    {VK_OEM_PLUS  ,          KANALOK ,';'       ,'+'       ,WCH_RE  ,WCH_RE  },
    {VK_TAB       , 0                ,'\t'      ,'\t'      ,'\t'    ,'\t'    },
    {VK_ADD       , 0                ,'+'       ,'+'       ,'+'     ,'+'     },
    {VK_DECIMAL   , 0                ,'.'       ,'.'       ,'.'     ,'.'     },
    {VK_DIVIDE    , 0                ,'/'       ,'/'       ,'/'     ,'/'     },
    {VK_MULTIPLY  , 0                ,'*'       ,'*'       ,'*'     ,'*'     },
    {VK_SUBTRACT  , 0                ,'-'       ,'-'       ,'-'     ,'-'     },
    {0            , 0                ,0         ,0         ,0       ,0       }
};

static ALLOC_SECTION_LDATA VK_TO_WCHARS6 aVkToWch6[] = {
    //                      |          |   SHIFT  |  KANA  | K+SHFT |  CONTROL  |  K+CTRL   |
    //                      |          |==========|========|========|===========|===========|
    {VK_BACK      , 0       ,'\b'      ,'\b'      ,'\b'    ,'\b'    , 0x7f      , 0x7f      },
    {VK_CANCEL    , 0       ,0x03      ,0x03      ,0x03    ,0x03    , 0x03      , 0x03      },
    {VK_ESCAPE    , 0       ,0x1b      ,0x1b      ,0x1b    ,0x1b    , 0x1b      , 0x1b      },
    {VK_OEM_4     , KANALOK ,'['       ,'{'       ,WCH_SVS ,WCH_OB  , 0x1b      , 0x1b      },
    {VK_OEM_5     , KANALOK ,'\\'      ,'|'       ,WCH_PS  ,WCH_PS  , 0x1c      , 0x1c      },
    {VK_OEM_102   , KANALOK ,'\\'      ,'_'       ,WCH_RO  ,WCH_RO  , 0x1c      , 0x1c      },
    {VK_OEM_6     , KANALOK ,']'       ,'}'       ,WCH_MU  ,WCH_CB  , 0x1d      , 0x1d      },
    {VK_RETURN    , 0       ,'\r'      ,'\r'      ,'\r'    ,'\r'    , '\n'      , '\n'      },
    {VK_SPACE     , 0       ,' '       ,' '       ,' '     ,' '     , 0x20      , 0x20      },
    {0            , 0       ,0         ,0         ,0       ,0       , 0         , 0         }
};

static ALLOC_SECTION_LDATA VK_TO_WCHARS8 aVkToWch8[] = {
    //                      |          |   SHIFT  |  KANA  | K+SHFT |  CONTROL  |  K+CTRL   | SHFT+CTRL |K+SHFT+CTRL|
    //                      |          |==========|========|========|===========|===========|===========|===========|
    {'2'          , KANALOK ,'2'       ,'"'       ,WCH_HU  ,WCH_HU  , WCH_NONE  , WCH_NONE  , 0x00      , 0x00      },
    {'6'          , KANALOK ,'6'       ,'&'       ,WCH_O   ,WCH_OO  , WCH_NONE  , WCH_NONE  , 0x1e      , 0x1e      },
    {VK_OEM_MINUS , KANALOK ,'-'       ,'='       ,WCH_HO  ,WCH_HO  , WCH_NONE  , WCH_NONE  , 0x1f      , 0x1f      },
    {0            , 0       ,0         ,0         ,0       ,0       , 0         , 0         , 0         , 0         }
};

// Put this last so that VkKeyScan interprets number characters
// as coming from the main section of the kbd (aVkToWch2 and
// aVkToWch4) before considering the numpad (aVkToWch1).

static ALLOC_SECTION_LDATA VK_TO_WCHARS4 aVkToWch1[] = {
    //                     |          |   SHIFT  |  KANA  | K+SHFT |
    //                     |          |==========|========|========|
    { VK_NUMPAD0   , 0      ,  '0'    , WCH_NONE ,   '0'  ,WCH_NONE},
    { VK_NUMPAD1   , 0      ,  '1'    , WCH_NONE ,   '1'  ,WCH_NONE},
    { VK_NUMPAD2   , 0      ,  '2'    , WCH_NONE ,   '2'  ,WCH_NONE},
    { VK_NUMPAD3   , 0      ,  '3'    , WCH_NONE ,   '3'  ,WCH_NONE},
    { VK_NUMPAD4   , 0      ,  '4'    , WCH_NONE ,   '4'  ,WCH_NONE},
    { VK_NUMPAD5   , 0      ,  '5'    , WCH_NONE ,   '5'  ,WCH_NONE},
    { VK_NUMPAD6   , 0      ,  '6'    , WCH_NONE ,   '6'  ,WCH_NONE},
    { VK_NUMPAD7   , 0      ,  '7'    , WCH_NONE ,   '7'  ,WCH_NONE},
    { VK_NUMPAD8   , 0      ,  '8'    , WCH_NONE ,   '8'  ,WCH_NONE},
    { VK_NUMPAD9   , 0      ,  '9'    , WCH_NONE ,   '9'  ,WCH_NONE},
    { 0            , 0      ,  '\0'   , 0        ,   0    ,0       }   //null terminator
};

/***************************************************************************\
* aVkToWcharTable: table of pointers to Character Tables
*
* Describes the character tables and the order they should be searched.
*
* Note: the order determines the behavior of VkKeyScan() : this function
*       takes a character and attempts to find a Virtual Key and character-
*       modifier key combination that produces that character.  The table
*       containing the numeric keypad (aVkToWch1) must appear last so that
*       VkKeyScan('0') will be interpreted as one of keys from the main
*       section, not the numpad.  etc.
\***************************************************************************/

static ALLOC_SECTION_LDATA VK_TO_WCHAR_TABLE aVkToWcharTable[] = {
    {  (PVK_TO_WCHARS1)aVkToWch6, 6, sizeof(aVkToWch6[0]) },
    {  (PVK_TO_WCHARS1)aVkToWch8, 8, sizeof(aVkToWch8[0]) },
    {  (PVK_TO_WCHARS1)aVkToWch4, 4, sizeof(aVkToWch4[0]) },
    {  (PVK_TO_WCHARS1)aVkToWch1, 4, sizeof(aVkToWch1[0]) },  // must come last
    {                       NULL, 0, 0                    }
};

/***************************************************************************\
* aKeyNames[], aKeyNamesExt[]  - Scan Code -> Key Name tables
*
* For the GetKeyNameText() API function
*
* Tables for non-extended and extended (KBDEXT) keys.
* (Keys producing printable characters are named by the character itself)
\***************************************************************************/

static ALLOC_SECTION_LDATA VSC_LPWSTR aKeyNames[] = {
    0x01,    L"Esc",
    0x0e,    L"Backspace",
    0x0f,    L"Tab",
    0x1c,    L"Enter",
    0x1d,    L"Ctrl",
    0x29,    (LPWSTR)SZ_KEY_NAME_HANKAKU_ZENKAKU,  // NLS Key
    0x2a,    L"Shift",
    0x36,    L"Right Shift",
    0x37,    L"Num *",
    0x38,    L"Alt",
    0x39,    L"Space",
    0x3a,    L"Caps Lock",
    0x3b,    L"F1",
    0x3c,    L"F2",
    0x3d,    L"F3",
    0x3e,    L"F4",
    0x3f,    L"F5",
    0x40,    L"F6",
    0x41,    L"F7",
    0x42,    L"F8",
    0x43,    L"F9",
    0x44,    L"F10",
    0x45,    L"Pause",
    0x46,    L"Scroll Lock",
    0x47,    L"Num 7",
    0x48,    L"Num 8",
    0x49,    L"Num 9",
    0x4a,    L"Num -",
    0x4b,    L"Num 4",
    0x4c,    L"Num 5",
    0x4d,    L"Num 6",
    0x4e,    L"Num +",
    0x4f,    L"Num 1",
    0x50,    L"Num 2",
    0x51,    L"Num 3",
    0x52,    L"Num 0",
    0x53,    L"Num Del",
    0x54,    L"Sys Req",
    0x57,    L"F11",
    0x58,    L"F12",
    0x70,    (LPWSTR)SZ_KEY_NAME_HIRAGANA,
    0x79,    (LPWSTR)SZ_KEY_NAME_HENKAN,
    0x7b,    (LPWSTR)SZ_KEY_NAME_MUHENKAN,
    0x7C,    L"F13",
    0   ,    NULL
};

static ALLOC_SECTION_LDATA VSC_LPWSTR aKeyNamesExt[] = {
    0x1c,    L"Num Enter",
    0x1d,    L"Right Control",
    0x35,    L"Num /",
    0x37,    L"Prnt Scrn",
    0x38,    L"Right Alt",
    0x45,    L"Num Lock",
    0x46,    L"Break",
    0x47,    L"Home",
    0x48,    L"Up",
    0x49,    L"Page Up",
    0x4b,    L"Left",
    0x4d,    L"Right",
    0x4f,    L"End",
    0x50,    L"Down",
    0x51,    L"Page Down",
    0x52,    L"Insert",
    0x53,    L"Delete",
    0x5B,    L"Left Windows",
    0x5C,    L"Right Windows",
    0x5D,    L"Application",
    0   ,    NULL
};

static ALLOC_SECTION_LDATA KBDTABLES KbdTables = {
    /*
     * Modifier keys
     */
    &CharModifiers,

    /*
     * Characters tables
     */
    aVkToWcharTable,

    /*
     * Diacritics  (none for US English)
     */
    NULL,

    /*
     * Names of Keys  (no dead keys)
     */
    aKeyNames,
    aKeyNamesExt,
    NULL,

    /*
     * Scan codes to Virtual Keys
     */
    ausVK,
    sizeof(ausVK) / sizeof(ausVK[0]),
    aE0VscToVk,
    aE1VscToVk,

    /*
     * No Locale-specific special processing
     */
    0,

    /*
     * No Ligatures
     */
    0, 0, NULL,

    /*
     * Type and subtype
     */
    KEYBOARD_TYPE_JAPAN,
    MAKEWORD(MICROSOFT_KBD_106_TYPE, NLSKBD_OEM_MICROSOFT),
};

PKBDTABLES KbdLayerDescriptor(VOID)
{
    return &KbdTables;
}

/***********************************************************************\
* VkToFuncTable_106[]
*
\***********************************************************************/

static ALLOC_SECTION_LDATA VK_F VkToFuncTable_106[] = {
    {
        VK_DBE_ALPHANUMERIC,  // Base Vk
        KBDNLS_TYPE_TOGGLE,   // NLSFEProcType
        KBDNLS_INDEX_NORMAL,  // NLSFEProcCurrent
        0x02, /* 00000010 */  // NLSFEProcSwitch
        {                     // NLSFEProc
            {KBDNLS_ALPHANUM,0},               // Base
            {KBDNLS_SEND_PARAM_VK,VK_CAPITAL}, // Shift
            {KBDNLS_SEND_PARAM_VK,VK_KANA},    // Control
            {KBDNLS_ALPHANUM,0},               // Shift+Control
            {KBDNLS_ALPHANUM,0},               // Alt
            {KBDNLS_ALPHANUM,0},               // Shift+Alt
            {KBDNLS_CODEINPUT,0},              // Control+Alt
            {KBDNLS_CODEINPUT,0}               // Shift+Control+Alt
        },
        {                     // NLSFEProcAlt
            {KBDNLS_SEND_PARAM_VK,VK_CAPITAL}, // Base
            {KBDNLS_SEND_PARAM_VK,VK_CAPITAL}, // Shift
            {KBDNLS_NOEVENT,0},                // Control
            {KBDNLS_NOEVENT,0},                // Shift+Control
            {KBDNLS_NOEVENT,0},                // Alt
            {KBDNLS_NOEVENT,0},                // Shift+Alt
            {KBDNLS_NOEVENT,0},                // Control+Alt
            {KBDNLS_NOEVENT,0}                 // Shift+Control+Alt
        }
    },
    {
        VK_DBE_HIRAGANA,     // Base Vk
        KBDNLS_TYPE_NORMAL,  // NLSFEProcType
        KBDNLS_INDEX_NORMAL, // NLSFEProcCurrent
        0x0,                 // NLSFEProcSwitch
        {                    // NLSFEProc
            {KBDNLS_HIRAGANA,0},             // Base
            {KBDNLS_KATAKANA,0},             // Shift
            {KBDNLS_HIRAGANA,0},             // Control
            {KBDNLS_KATAKANA,0},             // Shift+Control
            {KBDNLS_ROMAN,0},                // Alt
            {KBDNLS_ROMAN,0},                // Shift+Alt
            {KBDNLS_ROMAN,0},                // Control+Alt
            {KBDNLS_NOEVENT,0}               // Shift+Control+Alt
        },
        {                    // NLSFEProcIndexAlt
            {KBDNLS_NULL,0},                 // Base
            {KBDNLS_NULL,0},                 // Shift
            {KBDNLS_NULL,0},                 // Control
            {KBDNLS_NULL,0},                 // Shift+Control
            {KBDNLS_NULL,0},                 // Alt
            {KBDNLS_NULL,0},                 // Shift+Alt
            {KBDNLS_NULL,0},                 // Control+Alt
            {KBDNLS_NULL,0}                  // Shift+Control+Alt
        }
    },
    {
        VK_DBE_SBCSCHAR,     // Base Vk
        KBDNLS_TYPE_NORMAL,  // NLSFEProcType
        KBDNLS_INDEX_NORMAL, // NLSFEProcCurrent
        0x0,                 // NLSFEProcSwitch
        {                    // NLSFEProc
            {KBDNLS_SBCSDBCS,0},             // Base
            {KBDNLS_SBCSDBCS,0},             // Shift
            {KBDNLS_SBCSDBCS,0},             // Control
            {KBDNLS_SBCSDBCS,0},             // Shift+Control
            {KBDNLS_SEND_PARAM_VK,VK_KANJI}, // Alt
            {KBDNLS_SBCSDBCS,0},             // Shift+Alt
            {KBDNLS_SEND_PARAM_VK,VK_DBE_ENTERIMECONFIGMODE}, // Control+Alt
            {KBDNLS_SEND_PARAM_VK,VK_DBE_ENTERIMECONFIGMODE}  // Shift+Control+Alt
        },
        {                    // NLSFEProcIndexAlt
            {KBDNLS_NULL,0},  // Base
            {KBDNLS_NULL,0},  // Shift
            {KBDNLS_NULL,0},  // Control
            {KBDNLS_NULL,0},  // Shift+Control
            {KBDNLS_NULL,0},  // Alt
            {KBDNLS_NULL,0},  // Shift+Alt
            {KBDNLS_NULL,0},  // Control+Alt
            {KBDNLS_NULL,0}   // Shift+Control+Alt
        }
    },
    {
        VK_NONCONVERT,       // Base Vk
        KBDNLS_TYPE_NORMAL,  // NLSFEProcType
        KBDNLS_INDEX_NORMAL, // NLSFEProcCurrent
        0x0,                 // NLSFEProcSwitch
        {                    // NLSFEProc
            {KBDNLS_SEND_BASE_VK,0},         // Base
            {KBDNLS_SEND_BASE_VK,0},         // Shift
            {KBDNLS_SEND_BASE_VK,0},         // Control
            {KBDNLS_SEND_BASE_VK,0},         // Shift+Control
            {KBDNLS_SEND_BASE_VK,0},         // Alt
            {KBDNLS_SEND_BASE_VK,0},         // Shift+Alt
            {KBDNLS_SEND_PARAM_VK,VK_DBE_ENTERWORDREGISTERMODE}, // Control+Alt
            {KBDNLS_SEND_PARAM_VK,VK_DBE_ENTERWORDREGISTERMODE}  // Shift+Control+Alt
        },
        {                         // NLSFEProcIndexAlt
            {KBDNLS_NULL,0},  // Base
            {KBDNLS_NULL,0},  // Shift
            {KBDNLS_NULL,0},  // Control
            {KBDNLS_NULL,0},  // Shift+Control
            {KBDNLS_NULL,0},  // Alt
            {KBDNLS_NULL,0},  // Shift+Alt
            {KBDNLS_NULL,0},  // Control+Alt
            {KBDNLS_NULL,0}   // Shift+Control+Alt
        }
    }
};

/***********************************************************************\
* KbdNlsTables
*
\***********************************************************************/

static ALLOC_SECTION_LDATA KBDNLSTABLES KbdNlsTables = {
    0,                      // OEM ID (0 = Microsoft)
    0,                      // Information
    4,                      // Number of VK_F entry
    VkToFuncTable_106,      // Pointer to VK_F array
    0,                      // Number of MouseVk entry
    NULL                    // Pointer to MouseVk array
};

PKBDNLSTABLES KbdNlsLayerDescriptor(VOID)
{
    return &KbdNlsTables;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kbd\fe_kbds\jpn\ax2\kbdax2.h ===
/****************************** Module Header ******************************\
* Module Name: kbdax2.h
*
* Copyright (c) 1985-91, Microsoft Corporation
*
* Various defines for use by keyboard input code.
*
* History:
\***************************************************************************/

/*
 * kbd type should be controlled by cl command-line argument
 */
#define KBD_TYPE 16

/*
 * Include the basis of all keyboard table values
 */
#include "kbd.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kbd\fe_kbds\jpn\ax2\kbdax2.c ===
/***************************************************************************\
* Module Name: kbdax2.c
*
* Copyright (c) 1985-92, Microsoft Corporation
*
* History:
\***************************************************************************/

#include <windows.h>
#include <ime.h>
#include "vkoem.h"
#include "kbdjpn.h"
#include "kbdax2.h"

#if defined(_M_IA64)
#pragma section(".data")
#define ALLOC_SECTION_LDATA __declspec(allocate(".data"))
#else
#pragma data_seg(".data")
#define ALLOC_SECTION_LDATA
#endif

/***************************************************************************\
* ausVK[] - Virtual Scan Code to Virtual Key conversion table for AX2
\***************************************************************************/

static ALLOC_SECTION_LDATA USHORT ausVK[] = {
    T00, T01, T02, T03, T04, T05, T06, T07,
    T08, T09, T0A, T0B, T0C, T0D, T0E, T0F,
    T10, T11, T12, T13, T14, T15, T16, T17,
    T18, T19, T1A, T1B, T1C, T1D, T1E, T1F,
    T20, T21, T22, T23, T24, T25, T26, T27,
    T28, T29, T2A, T2B, T2C, T2D, T2E, T2F,
    T30, T31, T32, T33, T34, T35,

    /*
     * Right-hand Shift key must have KBDEXT bit set.
     */
    T36 | KBDEXT,

    /*
     * numpad_* + Shift/Alt -> SnapShot
     */
    T37 | KBDMULTIVK,

    T38, T39, T3A, T3B, T3C, T3D, T3E, T3F,
    T40, T41, T42, T43, T44,

    /*
     * NumLock Key:
     *     KBDEXT     - VK_NUMLOCK is an Extended key
     *     KBDMULTIVK - VK_NUMLOCK or VK_PAUSE (without or with CTRL)
     */
    T45 | KBDEXT | KBDMULTIVK,

    T46 | KBDMULTIVK,

    /*
     * Number Pad keys:
     *     KBDNUMPAD  - digits 0-9 and decimal point.
     *     KBDSPECIAL - require special processing by Windows
     */
    T47 | KBDNUMPAD | KBDSPECIAL,   // Numpad 7 (Home)
    T48 | KBDNUMPAD | KBDSPECIAL,   // Numpad 8 (Up),
    T49 | KBDNUMPAD | KBDSPECIAL,   // Numpad 9 (PgUp),
    T4A,
    T4B | KBDNUMPAD | KBDSPECIAL,   // Numpad 4 (Left),
    T4C | KBDNUMPAD | KBDSPECIAL,   // Numpad 5 (Clear),
    T4D | KBDNUMPAD | KBDSPECIAL,   // Numpad 6 (Right),
    T4E,
    T4F | KBDNUMPAD | KBDSPECIAL,   // Numpad 1 (End),
    T50 | KBDNUMPAD | KBDSPECIAL,   // Numpad 2 (Down),
    T51 | KBDNUMPAD | KBDSPECIAL,   // Numpad 3 (PgDn),
    T52 | KBDNUMPAD | KBDSPECIAL,   // Numpad 0 (Ins),
    T53 | KBDNUMPAD | KBDSPECIAL,   // Numpad . (Del),

    T54, T55, T56, T57, T58, T59,

    /*
     * Non-Conversion key must have KBDSPECIAL bit set (NLS key)
     */
    T5A | KBDSPECIAL,

    /*
     * Conversion key must have KBDSPECIAL bit set (NLS key)
     */
    T5B | KBDSPECIAL,

    /*
     * AX key
     */
    T5C,

                             T5D, T5E, T5F,
    T60, T61, T62, T63, T64, T65, T66, T67,
    T68, T69, T6A, T6B, T6C, T6D, T6E, T6F,
    T70, T71, T72, T73, T74, T75, T76, T77,
    T78, T79, T7A, T7B, T7C, T7D, T7E, T7F
};

static ALLOC_SECTION_LDATA VSC_VK aE0VscToVk[] = {
    { 0x1C, X1C | KBDEXT              },  // Numpad Enter
    { 0x1D, X1D | KBDEXT | KBDSPECIAL },  // Alphanumeric/Katakana key
    { 0x35, X35 | KBDEXT              },  // Numpad Divide
    { 0x37, X37 | KBDEXT              },  // Snapshot
    { 0x38, X38 | KBDEXT | KBDSPECIAL },  // Kanji key
    { 0x46, X46 | KBDEXT              },  // Break (Ctrl + Pause)
    { 0x47, X47 | KBDEXT              },  // Home
    { 0x48, X48 | KBDEXT              },  // Up
    { 0x49, X49 | KBDEXT              },  // Prior
    { 0x4B, X4B | KBDEXT              },  // Left
    { 0x4D, X4D | KBDEXT              },  // Right
    { 0x4F, X4F | KBDEXT              },  // End
    { 0x50, X50 | KBDEXT              },  // Down
    { 0x51, X51 | KBDEXT              },  // Next
    { 0x52, X52 | KBDEXT              },  // Insert
    { 0x53, X53 | KBDEXT              },  // Delete
    { 0x5B, X5B | KBDEXT              },  // Left Win
    { 0x5C, X5C | KBDEXT              },  // Right Win
    { 0x5D, X5D | KBDEXT              },  // Application
    { 0,      0                       }
};

static ALLOC_SECTION_LDATA VSC_VK aE1VscToVk[] = {
    { 0x1D, Y1D                       },  // Pause
    { 0   ,   0                       }
};

/***************************************************************************\
* aVkToBits[]  - map Virtual Keys to Modifier Bits
*
* See kbd.h for a full description.
*
* US Keyboard has only three shifter keys:
*     SHIFT (L & R) affects alphabnumeric keys,
*     CTRL  (L & R) is used to generate control characters
*     ALT   (L & R) used for generating characters by number with numpad
\***************************************************************************/

static ALLOC_SECTION_LDATA VK_TO_BIT aVkToBits[] = {
    { VK_SHIFT,   KBDSHIFT },
    { VK_CONTROL, KBDCTRL  },
    { VK_MENU,    KBDALT   },
    { VK_KANA,    KBDKANA  },
    { 0,          0        }
};

/***************************************************************************\
* aModification[]  - map character modifier bits to modification number
*
* See kbd.h for a full description.
*
\***************************************************************************/

static ALLOC_SECTION_LDATA MODIFIERS CharModifiers = {
    &aVkToBits[0],
    11,
    {
    //  Modification# //  Keys Pressed  : Explanation
    //  ============= // ============== : =============================
        0,            //                : unshifted characters
        1,            //          SHIFT : capitals, ~!@#$%^&*()_+{}:"<>? etc.
        4,            //     CTRL       : control characters
        6,            //     CTRL SHIFT :
        SHFT_INVALID, // ALT            : invalid
        SHFT_INVALID, // ALT      SHIFT : invalid
        SHFT_INVALID, // ALT CTRL       : invalid
        SHFT_INVALID, // ALT CTRL SHIFT : invalid
        2,            //KANA
        3,            //KANA      SHIFT
        5,            //KANA CTRL
        7             //KANA CTRL SHIFT
    }
};

/***************************************************************************\
*
* aVkToWch2[]  - Virtual Key to WCHAR translation for 2 shift states
* aVkToWch3[]  - Virtual Key to WCHAR translation for 3 shift states
* aVkToWch4[]  - Virtual Key to WCHAR translation for 4 shift states
*
* Table attributes: Unordered Scan, null-terminated
*
* Search this table for an entry with a matching Virtual Key to find the
* corresponding unshifted and shifted WCHAR characters.
*
* Reserved VirtualKey values (first column)
*     -1            - this line contains dead characters (diacritic)
*     0             - terminator
*
* Reserved Attribute values (second column)
*     CAPLOK        - CapsLock affects this key like Shift
*     KANALOK       - The KANA-LOCK key affects this key like KANA
*
* Reserved character values (third through last column)
*     WCH_NONE      - No character
*     WCH_DEAD      - Dead character (diacritic) value is in next line
*
\***************************************************************************/

static ALLOC_SECTION_LDATA VK_TO_WCHARS4 aVkToWch4[] = {
    //                               |          |   SHIFT  |  KANA  | K+SHFT |
    //                               |          |==========|========|========|
    {'0'          ,          KANALOK ,'0'       ,')'       ,WCH_WA  ,WCH_WO  },
    {'1'          ,          KANALOK ,'1'       ,'!'       ,WCH_NU  ,WCH_NU  },
    {'3'          ,          KANALOK ,'3'       ,'#'       ,WCH_A   ,WCH_AA  },
    {'4'          ,          KANALOK ,'4'       ,'$'       ,WCH_U   ,WCH_UU  },
    {'5'          ,          KANALOK ,'5'       ,'%'       ,WCH_E   ,WCH_EE  },
    {'7'          ,          KANALOK ,'7'       ,'&'       ,WCH_YA  ,WCH_YAA },
    {'8'          ,          KANALOK ,'8'       ,'*'       ,WCH_YU  ,WCH_YUU },
    {'9'          ,          KANALOK ,'9'       ,'('       ,WCH_YO  ,WCH_YOO },
    {'A'          , CAPLOK | KANALOK ,'a'       ,'A'       ,WCH_TI  ,WCH_TI  },
    {'B'          , CAPLOK | KANALOK ,'b'       ,'B'       ,WCH_KO  ,WCH_KO  },
    {'C'          , CAPLOK | KANALOK ,'c'       ,'C'       ,WCH_SO  ,WCH_SO  },
    {'D'          , CAPLOK | KANALOK ,'d'       ,'D'       ,WCH_SI  ,WCH_SI  },
    {'E'          , CAPLOK | KANALOK ,'e'       ,'E'       ,WCH_I   ,WCH_II  },
    {'F'          , CAPLOK | KANALOK ,'f'       ,'F'       ,WCH_HA  ,WCH_HA  },
    {'G'          , CAPLOK | KANALOK ,'g'       ,'G'       ,WCH_KI  ,WCH_KI  },
    {'H'          , CAPLOK | KANALOK ,'h'       ,'H'       ,WCH_KU  ,WCH_KU  },
    {'I'          , CAPLOK | KANALOK ,'i'       ,'I'       ,WCH_NI  ,WCH_NI  },
    {'J'          , CAPLOK | KANALOK ,'j'       ,'J'       ,WCH_MA  ,WCH_MA  },
    {'K'          , CAPLOK | KANALOK ,'k'       ,'K'       ,WCH_NO  ,WCH_NO  },
    {'L'          , CAPLOK | KANALOK ,'l'       ,'L'       ,WCH_RI  ,WCH_RI  },
    {'M'          , CAPLOK | KANALOK ,'m'       ,'M'       ,WCH_MO  ,WCH_MO  },
    {'N'          , CAPLOK | KANALOK ,'n'       ,'N'       ,WCH_MI  ,WCH_MI  },
    {'O'          , CAPLOK | KANALOK ,'o'       ,'O'       ,WCH_RA  ,WCH_RA  },
    {'P'          , CAPLOK | KANALOK ,'p'       ,'P'       ,WCH_SE  ,WCH_SE  },
    {'Q'          , CAPLOK | KANALOK ,'q'       ,'Q'       ,WCH_TA  ,WCH_TA  },
    {'R'          , CAPLOK | KANALOK ,'r'       ,'R'       ,WCH_SU  ,WCH_SU  },
    {'S'          , CAPLOK | KANALOK ,'s'       ,'S'       ,WCH_TO  ,WCH_TO  },
    {'T'          , CAPLOK | KANALOK ,'t'       ,'T'       ,WCH_KA  ,WCH_KA  },
    {'U'          , CAPLOK | KANALOK ,'u'       ,'U'       ,WCH_NA  ,WCH_NA  },
    {'V'          , CAPLOK | KANALOK ,'v'       ,'V'       ,WCH_HI  ,WCH_HI  },
    {'W'          , CAPLOK | KANALOK ,'w'       ,'W'       ,WCH_TE  ,WCH_TE  },
    {'X'          , CAPLOK | KANALOK ,'x'       ,'X'       ,WCH_SA  ,WCH_SA  },
    {'Y'          , CAPLOK | KANALOK ,'y'       ,'Y'       ,WCH_NN  ,WCH_NN  },
    {'Z'          , CAPLOK | KANALOK ,'z'       ,'Z'       ,WCH_TU  ,WCH_TUU },
    {VK_OEM_1     ,          KANALOK ,';'       ,':'       ,WCH_RE  ,WCH_RE  },
    {VK_OEM_2     ,          KANALOK ,'/'       ,'?'       ,WCH_ME  ,WCH_MD  },
    {VK_OEM_3     ,          KANALOK ,'`'       ,'~'       ,WCH_MU  ,WCH_CB  },
    {VK_OEM_7     ,          KANALOK ,0x27      ,'"'       ,WCH_KE  ,WCH_KE  },
    {VK_OEM_8     , 0                ,WCH_NONE  ,WCH_NONE  ,WCH_NONE,WCH_NONE},
    {VK_OEM_COMMA ,          KANALOK ,','       ,'<'       ,WCH_NE  ,WCH_IC  },
    {VK_OEM_PERIOD,          KANALOK ,'.'       ,'>'       ,WCH_RU  ,WCH_IP  },
    {VK_OEM_PLUS  ,          KANALOK ,'='       ,'+'       ,WCH_HE  ,WCH_HE  },
    {VK_TAB       , 0                ,'\t'      ,'\t'      ,'\t'    ,'\t'    },
    {VK_ADD       , 0                ,'+'       ,'+'       ,'+'     ,'+'     },
    {VK_DECIMAL   , 0                ,'.'       ,'.'       ,'.'     ,'.'     },
    {VK_DIVIDE    , 0                ,'/'       ,'/'       ,'/'     ,'/'     },
    {VK_MULTIPLY  , 0                ,'*'       ,'*'       ,'*'     ,'*'     },
    {VK_SUBTRACT  , 0                ,'-'       ,'-'       ,'-'     ,'-'     },
    {0            , 0                ,0         ,0         ,0       ,0       }
};

static ALLOC_SECTION_LDATA VK_TO_WCHARS6 aVkToWch6[] = {
    //                      |          |   SHIFT  |  KANA  | K+SHFT |  CONTROL  |  K+CTRL   |
    //                      |          |==========|========|========|===========|===========|
    {VK_BACK      , 0       ,'\b'      ,'\b'      ,'\b'    ,'\b'    , 0x7f      , 0x7f      },
    {VK_CANCEL    , 0       ,0x03      ,0x03      ,0x03    ,0x03    , 0x03      , 0x03      },
    {VK_ESCAPE    , 0       ,0x1b      ,0x1b      ,0x1b    ,0x1b    , 0x1b      , 0x1b      },
    {VK_OEM_4     , KANALOK ,'['       ,'{'       ,WCH_VS  ,WCH_VS  , 0x1b      , 0x1b      },
    {VK_OEM_5     , KANALOK ,'\\'      ,'|'       ,WCH_PS  ,WCH_PS  , 0x1c      , 0x1c      },
    {VK_OEM_102   , KANALOK ,'\\'      ,'|'       ,WCH_RO  ,WCH_RO  , 0x1c      , 0x1c      },
    {VK_OEM_6     , KANALOK ,']'       ,'}'       ,WCH_SVS ,WCH_OB  , 0x1d      , 0x1d      },
    {VK_RETURN    , 0       ,'\r'      ,'\r'      ,'\r'    ,'\r'    , '\n'      , '\n'      },
    {VK_SPACE     , 0       ,' '       ,' '       ,' '     ,' '     , 0x20      , 0x20      },
    {0            , 0       ,0         ,0         ,0       ,0       , 0         , 0         }
};

static ALLOC_SECTION_LDATA VK_TO_WCHARS8 aVkToWch8[] = {
    //                      |          |   SHIFT  |  KANA  | K+SHFT |  CONTROL  |  K+CTRL   | SHFT+CTRL |K+SHFT+CTRL|
    //                      |          |==========|========|========|===========|===========|===========|===========|
    {'2'          , KANALOK ,'2'       ,'@'       ,WCH_HU  ,WCH_HU  , WCH_NONE  , WCH_NONE  , 0x00      , 0x00      },
    {'6'          , KANALOK ,'6'       ,'^'       ,WCH_O   ,WCH_OO  , WCH_NONE  , WCH_NONE  , 0x1e      , 0x1e      },
    {VK_OEM_MINUS , KANALOK ,'-'       ,'_'       ,WCH_HO  ,WCH_HO  , WCH_NONE  , WCH_NONE  , 0x1f      , 0x1f      },
    {0            , 0       ,0         ,0         ,0       ,0       , 0         , 0         , 0         , 0         }
};

// Put this last so that VkKeyScan interprets number characters
// as coming from the main section of the kbd (aVkToWch2 and
// aVkToWch4) before considering the numpad (aVkToWch1).

static ALLOC_SECTION_LDATA VK_TO_WCHARS4 aVkToWch1[] = {
    //                     |          |   SHIFT  |  KANA  | K+SHFT |
    //                     |          |==========|========|========|
    { VK_NUMPAD0   , 0      ,  '0'    , WCH_NONE ,   '0'  ,WCH_NONE},
    { VK_NUMPAD1   , 0      ,  '1'    , WCH_NONE ,   '1'  ,WCH_NONE},
    { VK_NUMPAD2   , 0      ,  '2'    , WCH_NONE ,   '2'  ,WCH_NONE},
    { VK_NUMPAD3   , 0      ,  '3'    , WCH_NONE ,   '3'  ,WCH_NONE},
    { VK_NUMPAD4   , 0      ,  '4'    , WCH_NONE ,   '4'  ,WCH_NONE},
    { VK_NUMPAD5   , 0      ,  '5'    , WCH_NONE ,   '5'  ,WCH_NONE},
    { VK_NUMPAD6   , 0      ,  '6'    , WCH_NONE ,   '6'  ,WCH_NONE},
    { VK_NUMPAD7   , 0      ,  '7'    , WCH_NONE ,   '7'  ,WCH_NONE},
    { VK_NUMPAD8   , 0      ,  '8'    , WCH_NONE ,   '8'  ,WCH_NONE},
    { VK_NUMPAD9   , 0      ,  '9'    , WCH_NONE ,   '9'  ,WCH_NONE},
    { 0            , 0      ,  '\0'   , 0        ,   0    ,0       }   //null terminator
};

/***************************************************************************\
* aVkToWcharTable: table of pointers to Character Tables
*
* Describes the character tables and the order they should be searched.
*
* Note: the order determines the behavior of VkKeyScan() : this function
*       takes a character and attempts to find a Virtual Key and character-
*       modifier key combination that produces that character.  The table
*       containing the numeric keypad (aVkToWch1) must appear last so that
*       VkKeyScan('0') will be interpreted as one of keys from the main
*       section, not the numpad.  etc.
\***************************************************************************/

static ALLOC_SECTION_LDATA VK_TO_WCHAR_TABLE aVkToWcharTable[] = {
    {  (PVK_TO_WCHARS1)aVkToWch6, 6, sizeof(aVkToWch6[0]) },
    {  (PVK_TO_WCHARS1)aVkToWch8, 8, sizeof(aVkToWch8[0]) },
    {  (PVK_TO_WCHARS1)aVkToWch4, 4, sizeof(aVkToWch4[0]) },
    {  (PVK_TO_WCHARS1)aVkToWch1, 4, sizeof(aVkToWch1[0]) },  // must come last
    {                       NULL, 0, 0                    }
};

/***************************************************************************\
* aKeyNames[], aKeyNamesExt[]  - Scan Code -> Key Name tables
*
* For the GetKeyNameText() API function
*
* Tables for non-extended and extended (KBDEXT) keys.
* (Keys producing printable characters are named by the character itself)
\***************************************************************************/

static ALLOC_SECTION_LDATA VSC_LPWSTR aKeyNames[] = {
    0x01,    L"Esc",
    0x0e,    L"Backspace",
    0x0f,    L"Tab",
    0x1c,    L"Enter",
    0x1d,    L"Ctrl",
    0x2a,    L"Shift",
    0x36,    L"Right Shift",
    0x37,    L"Num *",
    0x38,    L"Alt",
    0x39,    L"Space",
    0x3a,    L"Caps Lock",
    0x3b,    L"F1",
    0x3c,    L"F2",
    0x3d,    L"F3",
    0x3e,    L"F4",
    0x3f,    L"F5",
    0x40,    L"F6",
    0x41,    L"F7",
    0x42,    L"F8",
    0x43,    L"F9",
    0x44,    L"F10",
    0x45,    L"Pause",
    0x46,    L"Scroll Lock",
    0x47,    L"Num 7",
    0x48,    L"Num 8",
    0x49,    L"Num 9",
    0x4a,    L"Num -",
    0x4b,    L"Num 4",
    0x4c,    L"Num 5",
    0x4d,    L"Num 6",
    0x4e,    L"Num +",
    0x4f,    L"Num 1",
    0x50,    L"Num 2",
    0x51,    L"Num 3",
    0x52,    L"Num 0",
    0x53,    L"Num Del",
    0x54,    L"Sys Req",
    0x57,    L"F11",
    0x58,    L"F12",
    0x5a,    (LPWSTR)SZ_KEY_NAME_MUHENKAN,  // NLS Key
    0x5b,    (LPWSTR)SZ_KEY_NAME_HENKAN,    // NLS Key
    0x5c,    L"AX",                 // NLS Key
    0x7C,    L"F13",
    0x7D,    L"F14",
    0x7E,    L"F15",
    0x7F,    L"F16",
    0x80,    L"F17",
    0x81,    L"F18",
    0x82,    L"F19",
    0x83,    L"F20",
    0x84,    L"F21",
    0x85,    L"F22",
    0x86,    L"F23",
    0x87,    L"F24",
    0   ,    NULL
};

static ALLOC_SECTION_LDATA VSC_LPWSTR aKeyNamesExt[] = {
    0x1c,    L"Num Enter",
    0x1d,    (LPWSTR)SZ_KEY_NAME_EISU_KANA, // NLS Key
    0x35,    L"Num /",
    0x37,    L"Prnt Scrn",
    0x38,    (LPWSTR)SZ_KEY_NAME_KANJI,     // NLS Key
    0x45,    L"Num Lock",
    0x46,    L"Break",
    0x47,    L"Home",
    0x48,    L"Up",
    0x49,    L"Page Up",
    0x4b,    L"Left",
    0x4d,    L"Right",
    0x4f,    L"End",
    0x50,    L"Down",
    0x51,    L"Page Down",
    0x52,    L"Insert",
    0x53,    L"Delete",
    0x54,    L"<00>",
    0x56,    L"Help",
    0x5B,    L"Left Windows",
    0x5C,    L"Right Windows",
    0x5D,    L"Application",
    0   ,    NULL
};

static ALLOC_SECTION_LDATA KBDTABLES KbdTables = {
    /*
     * Modifier keys
     */
    &CharModifiers,

    /*
     * Characters tables
     */
    aVkToWcharTable,

    /*
     * Diacritics  (none for US English)
     */
    NULL,

    /*
     * Names of Keys  (no dead keys)
     */
    aKeyNames,
    aKeyNamesExt,
    NULL,

    /*
     * Scan codes to Virtual Keys
     */
    ausVK,
    sizeof(ausVK) / sizeof(ausVK[0]),
    aE0VscToVk,
    aE1VscToVk,

    /*
     * No Locale-specific special processing
     */
    0,

    /*
     * No Ligatures
     */
    0, 0, NULL,

    /*
     * Type and subtype
     */
    KEYBOARD_TYPE_JAPAN,
    MAKEWORD(MICROSOFT_KBD_AX_TYPE, NLSKBD_OEM_MICROSOFT),
};

PKBDTABLES KbdLayerDescriptor(VOID)
{
    return &KbdTables;
}

/***********************************************************************\
* VkToFuncTable_ax2[]
*
\***********************************************************************/

static ALLOC_SECTION_LDATA VK_F VkToFuncTable_ax2[] = {
    {
        VK_DBE_KATAKANA,      // Base Vk
        KBDNLS_TYPE_TOGGLE,   // NLSFEProcType
        KBDNLS_INDEX_NORMAL,  // NLSFEProcCurrent
        0x8, /* 00001000 */   // NLSFEProcSwitch
        {                     // NLSFEProc
            {KBDNLS_KATAKANA,0},               // Base
            {KBDNLS_HIRAGANA,0},               // Shift
            {KBDNLS_ROMAN,0},                  // Control
            {KBDNLS_SEND_PARAM_VK,VK_KANA},    // Shift+Control
            {KBDNLS_ALPHANUM,0},               // Alt
            {KBDNLS_ALPHANUM,0},               // Shift+Alt
            {KBDNLS_ALPHANUM,0},               // Control+Alt
            {KBDNLS_ALPHANUM,0}                // Shift+Control+Alt
        },
        {                     // NLSFEProcAlt
            {KBDNLS_SEND_PARAM_VK,VK_KANA},    // Base
            {KBDNLS_SEND_PARAM_VK,VK_KANA},    // Shift
            {KBDNLS_SEND_PARAM_VK,VK_KANA},    // Control
            {KBDNLS_SEND_PARAM_VK,VK_KANA},    // Shift+Control
            {KBDNLS_NOEVENT,0},                // Alt
            {KBDNLS_NOEVENT,0},                // Shift+Alt
            {KBDNLS_NOEVENT,0},                // Control+Alt
            {KBDNLS_NOEVENT,0}                 // Shift+Control+Alt
        }
    },
    {
        VK_NONCONVERT,       // Base Vk
        KBDNLS_TYPE_NORMAL,  // NLSFEProcType
        KBDNLS_INDEX_NORMAL, // NLSFEProcCurrent
        0x0,                 // NLSFEProcSwitch
        {                    // NLSFEProc
            {KBDNLS_SEND_BASE_VK,0},                             // Base
            {KBDNLS_SEND_PARAM_VK,VK_DBE_ENTERWORDREGISTERMODE}, // Shift
            {KBDNLS_CODEINPUT,0},                                // Control
            {KBDNLS_SEND_PARAM_VK,VK_DBE_ENTERWORDREGISTERMODE}, // Shift+Control
            {KBDNLS_SEND_BASE_VK,0},                             // Alt
            {KBDNLS_SEND_PARAM_VK,VK_DBE_ENTERWORDREGISTERMODE}, // Shift+Alt
            {KBDNLS_CODEINPUT,0},                                // Control+Alt
            {KBDNLS_SEND_PARAM_VK,VK_DBE_ENTERWORDREGISTERMODE}  // Shift+Control+Alt
        },
        {                    // NLSFEProcIndexAlt
            {KBDNLS_NULL,0},              // Base
            {KBDNLS_NULL,0},              // Shift
            {KBDNLS_NULL,0},              // Control
            {KBDNLS_NULL,0},              // Shift+Control
            {KBDNLS_NULL,0},              // Alt
            {KBDNLS_NULL,0},              // Shift+Alt
            {KBDNLS_NULL,0},              // Control+Alt
            {KBDNLS_NULL,0}               // Shift+Control+Alt
        }
    },
    {
        VK_KANJI,            // Base Vk
        KBDNLS_TYPE_NORMAL,  // NLSFEProcType
        KBDNLS_INDEX_NORMAL, // NLSFEProcCurrent
        0x0,                 // NLSFEProcSwitch
        {                    // NLSFEProc
            {KBDNLS_SEND_BASE_VK,0},                          // Base
            {KBDNLS_SBCSDBCS,0},                              // Shift
            {KBDNLS_SEND_BASE_VK,0},                          // Control
            {KBDNLS_SEND_PARAM_VK,VK_DBE_ENTERIMECONFIGMODE}, // Shift+Control
            {KBDNLS_SEND_BASE_VK,0},                          // Alt
            {KBDNLS_SBCSDBCS,0},                              // Shift+Alt
            {KBDNLS_SEND_BASE_VK,0},                          // Control+Alt
            {KBDNLS_SEND_PARAM_VK,VK_DBE_ENTERIMECONFIGMODE}  // Shift+Control+Alt
        },
        {                    // NLSFEProcIndexAlt
            {KBDNLS_NULL,0},  // Base
            {KBDNLS_NULL,0},  // Shift
            {KBDNLS_NULL,0},  // Control
            {KBDNLS_NULL,0},  // Shift+Control
            {KBDNLS_NULL,0},  // Alt
            {KBDNLS_NULL,0},  // Shift+Alt
            {KBDNLS_NULL,0},  // Control+Alt
            {KBDNLS_NULL,0}   // Shift+Control+Alt
        }
    }
};

/***********************************************************************\
* KbdNlsTables
*
\***********************************************************************/

static ALLOC_SECTION_LDATA KBDNLSTABLES KbdNlsTables = {
    0,                      // OEM ID (0 = Microsoft)
    0,                      // Information
    3,                      // Number of VK_F entry
    VkToFuncTable_ax2,      // Pointer to VK_F array
    0,                      // Number of MouseVk entry
    NULL                    // Pointer to MouseVk array
};

PKBDNLSTABLES KbdNlsLayerDescriptor(VOID)
{
    return &KbdNlsTables;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kbd\fe_kbds\jpn\ax2\sources.inc ===
!IF 0

Copyright (c) 1989-2000  Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


!ENDIF

MINORCOMP=kbdax2

!include ..\..\japan.inc

SOURCES_USED=..\sources.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kbd\fe_kbds\jpn\ibm02\sources.inc ===
!IF 0

Copyright (c) 1989-2000  Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


!ENDIF

MINORCOMP=kbdibm02

!include ..\..\japan.inc

SOURCES_USED=..\sources.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kbd\fe_kbds\jpn\ibm02\kbdibm02.h ===
/****************************** Module Header ******************************\
* Module Name: kbdibm02.h
*
* Copyright (c) 1985-91, Microsoft Corporation
*
* Various defines for use by keyboard input code.
*
* History:
\***************************************************************************/

/*
 * kbd type should be controlled by cl command-line argument
 */
#define KBD_TYPE 7

/*
 * Include the basis of all keyboard table values
 */
#include "kbd.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kbd\fe_kbds\jpn\f3ahvoas\f3ahvoas.c ===
/***************************************************************************\
* Module Name: f3ahvoas.
*
* Copyright (c) 1985-92, Microsoft Corporation
*
* History:
\***************************************************************************/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <ime.h>
#include "vkoem.h"
#include "kbdjpn.h"
#include "f3ahvoas.h"

#include "cscall.h"
#include "usercall.h"

#if defined(_M_IA64)
#pragma section(".data")
#define ALLOC_SECTION_LDATA __declspec(allocate(".data"))
#else
#pragma data_seg(".data")
#define ALLOC_SECTION_LDATA
#endif

/***************************************************************************\
* ausVK[] - Virtual Scan Code to Virtual Key conversion table for F3AHVOAS
\***************************************************************************/

static ALLOC_SECTION_LDATA USHORT ausVK[] = {
    T00, T01, T02, T03, T04, T05, T06, T07,
    T08, T09, T0A, T0B, T0C, T0D, T0E, T0F,
    T10, T11, T12, T13, T14, T15, T16, T17,
    T18, T19, T1A, T1B, T1C, T1D, T1E, T1F,
    T20, T21, T22, T23, T24, T25, T26, T27,
    T28,

    /*
     * Hankaku/Zenkaku/Kanji key must have KBDSPECIAL bit set (NLS key)
     */
    T29 | KBDSPECIAL,

              T2A, T2B, T2C, T2D, T2E, T2F,
    T30, T31, T32, T33, T34, T35,

    /*
     * Right-hand Shift key must have KBDEXT bit set.
     */
    T36 | KBDEXT,

    /*
     * numpad_* + Shift/Alt -> SnapShot
     */
    T37 | KBDMULTIVK,

    T38, T39,

    /*
     * Alphanumeric/CapsLock key must have KBDSPECIAL bit set (NLS key)
     */
    T3A | KBDSPECIAL,

                   T3B, T3C, T3D, T3E, T3F,
    T40, T41, T42, T43, T44,

    /*
     * NumLock Key:
     *     KBDEXT     - VK_NUMLOCK is an Extended key
     *     KBDMULTIVK - VK_NUMLOCK or VK_PAUSE (without or with CTRL)
     */
    T45 | KBDEXT | KBDMULTIVK,

    T46 | KBDMULTIVK,

    /*
     * Number Pad keys:
     *     KBDNUMPAD  - digits 0-9 and decimal point.
     *     KBDSPECIAL - require special processing by Windows
     */
    T47 | KBDNUMPAD | KBDSPECIAL,   // Numpad 7 (Home)
    T48 | KBDNUMPAD | KBDSPECIAL,   // Numpad 8 (Up),
    T49 | KBDNUMPAD | KBDSPECIAL,   // Numpad 9 (PgUp),
    T4A,
    T4B | KBDNUMPAD | KBDSPECIAL,   // Numpad 4 (Left),
    T4C | KBDNUMPAD | KBDSPECIAL,   // Numpad 5 (Clear),
    T4D | KBDNUMPAD | KBDSPECIAL,   // Numpad 6 (Right),
    T4E,
    T4F | KBDNUMPAD | KBDSPECIAL,   // Numpad 1 (End),
    T50 | KBDNUMPAD | KBDSPECIAL,   // Numpad 2 (Down),
    T51 | KBDNUMPAD | KBDSPECIAL,   // Numpad 3 (PgDn),
    T52 | KBDNUMPAD | KBDSPECIAL,   // Numpad 0 (Ins),
    T53 | KBDNUMPAD | KBDSPECIAL,   // Numpad . (Del),

    T54, T55, T56, T57, T58, T59, T5A, T5B,
    T5C, T5D, T5E, T5F, T60, T61, T62, T63,
    T64, T65, T66, T67, T68, T69, T6A, T6B,
    T6C, T6D, T6E, T6F,

    /*
     * Hiragana/Katakana/Roman key must have KBDSPECIAL bit set (NLS key)
     */
    T70 | KBDSPECIAL,

                             T71, T72, T73,
    T74, T75, T76, T77, T78,

    /*
     * Conversion key must have KBDSPECIAL bit set (NLS key)
     */
    T79 | KBDSPECIAL,

                                  T7A,

    /*
     * Non-Conversion key must have KBDSPECIAL bit set (NLS key)
     */
    T7B | KBDSPECIAL,

    T7C, T7D, T7E, T7F

};

static ALLOC_SECTION_LDATA VSC_VK aE0VscToVk[] = {
        { 0x1C, X1C | KBDEXT              },  // Numpad Enter
        { 0x1D, X1D | KBDEXT              },  // RControl
        { 0x35, X35 | KBDEXT              },  // Numpad Divide
        { 0x37, X37 | KBDEXT              },  // Snapshot
        { 0x38, X38 | KBDEXT              },  // RMenu
        { 0x46, X46 | KBDEXT              },  // Break (Ctrl + Pause)
        { 0x47, X47 | KBDEXT              },  // Home
        { 0x48, X48 | KBDEXT              },  // Up
        { 0x49, X49 | KBDEXT              },  // Prior
        { 0x4B, X4B | KBDEXT              },  // Left
        { 0x4D, X4D | KBDEXT              },  // Right
        { 0x4F, X4F | KBDEXT              },  // End
        { 0x50, X50 | KBDEXT              },  // Down
        { 0x51, X51 | KBDEXT              },  // Next
        { 0x52, X52 | KBDEXT              },  // Insert
        { 0x53, X53 | KBDEXT              },  // Delete
        { 0x5B, X5B | KBDEXT              },  // Left Win
        { 0x5C, X5C | KBDEXT              },  // Right Win
        { 0x5D, X5D | KBDEXT              },  // Application
        { 0,      0                       }
};

static ALLOC_SECTION_LDATA VSC_VK aE1VscToVk[] = {
        { 0x1D, Y1D                       },  // Pause
        { 0   ,   0                       }
};

/***************************************************************************\
* aVkToBits[]  - map Virtual Keys to Modifier Bits
*
* See kbd.h for a full description.
*
* US Keyboard has only three shifter keys:
*     SHIFT (L & R) affects alphabnumeric keys,
*     CTRL  (L & R) is used to generate control characters
*     ALT   (L & R) used for generating characters by number with numpad
\***************************************************************************/

static ALLOC_SECTION_LDATA VK_TO_BIT aVkToBits[] = {
    { VK_SHIFT,   KBDSHIFT },
    { VK_CONTROL, KBDCTRL  },
    { VK_MENU,    KBDALT   },
    { VK_KANA,    KBDKANA  },
    { 0,          0        }
};

/***************************************************************************\
* aModification[]  - map character modifier bits to modification number
*
* See kbd.h for a full description.
*
\***************************************************************************/

static ALLOC_SECTION_LDATA MODIFIERS CharModifiers = {
    &aVkToBits[0],
    11,
    {
    //  Modification# //  Keys Pressed  : Explanation
    //  ============= // ============== : =============================
        0,            //                : unshifted characters
        1,            //          SHIFT : capitals, ~!@#$%^&*()_+{}:"<>? etc.
        4,            //     CTRL       : control characters
        6,            //     CTRL SHIFT :
        SHFT_INVALID, // ALT            : invalid
        SHFT_INVALID, // ALT      SHIFT : invalid
        SHFT_INVALID, // ALT CTRL       : invalid
        SHFT_INVALID, // ALT CTRL SHIFT : invalid
        2,            //KANA
        3,            //KANA      SHIFT
        5,            //KANA CTRL
        7             //KANA CTRL SHIFT
    }
};

/***************************************************************************\
*
* aVkToWch2[]  - Virtual Key to WCHAR translation for 2 shift states
* aVkToWch3[]  - Virtual Key to WCHAR translation for 3 shift states
* aVkToWch4[]  - Virtual Key to WCHAR translation for 4 shift states
*
* Table attributes: Unordered Scan, null-terminated
*
* Search this table for an entry with a matching Virtual Key to find the
* corresponding unshifted and shifted WCHAR characters.
*
* Reserved VirtualKey values (first column)
*     -1            - this line contains dead characters (diacritic)
*     0             - terminator
*
* Reserved Attribute values (second column)
*     CAPLOK        - CapsLock affects this key like Shift
*     KANALOK       - The KANA-LOCK key affects this key like KANA
*
* Reserved character values (third through last column)
*     WCH_NONE      - No character
*     WCH_DEAD      - Dead character (diacritic) value is in next line
*
\***************************************************************************/

static ALLOC_SECTION_LDATA VK_TO_WCHARS4 aVkToWch4[] = {
    //                               |          |   SHIFT  |  KANA  | K+SHFT |
    //                               |          |==========|========|========|
    {'0'          ,          KANALOK ,'0'       ,WCH_NONE  ,WCH_WA  ,WCH_WO  },
    {'1'          ,          KANALOK ,'1'       ,'!'       ,WCH_NU  ,WCH_NU  },
    {'3'          ,          KANALOK ,'3'       ,'#'       ,WCH_A   ,WCH_AA  },
    {'4'          ,          KANALOK ,'4'       ,'$'       ,WCH_U   ,WCH_UU  },
    {'5'          ,          KANALOK ,'5'       ,'%'       ,WCH_E   ,WCH_EE  },
    {'7'          ,          KANALOK ,'7'       ,0x27      ,WCH_YA  ,WCH_YAA },
    {'8'          ,          KANALOK ,'8'       ,'('       ,WCH_YU  ,WCH_YUU },
    {'9'          ,          KANALOK ,'9'       ,')'       ,WCH_YO  ,WCH_YOO },
    {'A'          , CAPLOK | KANALOK ,'a'       ,'A'       ,WCH_TI  ,WCH_TI  },
    {'B'          , CAPLOK | KANALOK ,'b'       ,'B'       ,WCH_KO  ,WCH_KO  },
    {'C'          , CAPLOK | KANALOK ,'c'       ,'C'       ,WCH_SO  ,WCH_SO  },
    {'D'          , CAPLOK | KANALOK ,'d'       ,'D'       ,WCH_SI  ,WCH_SI  },
    {'E'          , CAPLOK | KANALOK ,'e'       ,'E'       ,WCH_I   ,WCH_II  },
    {'F'          , CAPLOK | KANALOK ,'f'       ,'F'       ,WCH_HA  ,WCH_HA  },
    {'G'          , CAPLOK | KANALOK ,'g'       ,'G'       ,WCH_KI  ,WCH_KI  },
    {'H'          , CAPLOK | KANALOK ,'h'       ,'H'       ,WCH_KU  ,WCH_KU  },
    {'I'          , CAPLOK | KANALOK ,'i'       ,'I'       ,WCH_NI  ,WCH_NI  },
    {'J'          , CAPLOK | KANALOK ,'j'       ,'J'       ,WCH_MA  ,WCH_MA  },
    {'K'          , CAPLOK | KANALOK ,'k'       ,'K'       ,WCH_NO  ,WCH_NO  },
    {'L'          , CAPLOK | KANALOK ,'l'       ,'L'       ,WCH_RI  ,WCH_RI  },
    {'M'          , CAPLOK | KANALOK ,'m'       ,'M'       ,WCH_MO  ,WCH_MO  },
    {'N'          , CAPLOK | KANALOK ,'n'       ,'N'       ,WCH_MI  ,WCH_MI  },
    {'O'          , CAPLOK | KANALOK ,'o'       ,'O'       ,WCH_RA  ,WCH_RA  },
    {'P'          , CAPLOK | KANALOK ,'p'       ,'P'       ,WCH_SE  ,WCH_SE  },
    {'Q'          , CAPLOK | KANALOK ,'q'       ,'Q'       ,WCH_TA  ,WCH_TA  },
    {'R'          , CAPLOK | KANALOK ,'r'       ,'R'       ,WCH_SU  ,WCH_SU  },
    {'S'          , CAPLOK | KANALOK ,'s'       ,'S'       ,WCH_TO  ,WCH_TO  },
    {'T'          , CAPLOK | KANALOK ,'t'       ,'T'       ,WCH_KA  ,WCH_KA  },
    {'U'          , CAPLOK | KANALOK ,'u'       ,'U'       ,WCH_NA  ,WCH_NA  },
    {'V'          , CAPLOK | KANALOK ,'v'       ,'V'       ,WCH_HI  ,WCH_HI  },
    {'W'          , CAPLOK | KANALOK ,'w'       ,'W'       ,WCH_TE  ,WCH_TE  },
    {'X'          , CAPLOK | KANALOK ,'x'       ,'X'       ,WCH_SA  ,WCH_SA  },
    {'Y'          , CAPLOK | KANALOK ,'y'       ,'Y'       ,WCH_NN  ,WCH_NN  },
    {'Z'          , CAPLOK | KANALOK ,'z'       ,'Z'       ,WCH_TU  ,WCH_TUU },
    {VK_OEM_1     ,          KANALOK ,':'       ,'*'       ,WCH_KE  ,WCH_KE  },
    {VK_OEM_2     ,          KANALOK ,'/'       ,'?'       ,WCH_ME  ,WCH_MD  },
    {VK_OEM_3     ,          KANALOK ,'@'       ,'`'       ,WCH_VS  ,WCH_VS  },
    {VK_OEM_7     ,          KANALOK ,'^'       ,'~'       ,WCH_HE  ,WCH_HE  },
    {VK_OEM_8     , 0                ,WCH_NONE  ,WCH_NONE  ,WCH_NONE,WCH_NONE},
    {VK_OEM_COMMA ,          KANALOK ,','       ,'<'       ,WCH_NE  ,WCH_IC  },
    {VK_OEM_PERIOD,          KANALOK ,'.'       ,'>'       ,WCH_RU  ,WCH_IP  },
    {VK_OEM_PLUS  ,          KANALOK ,';'       ,'+'       ,WCH_RE  ,WCH_RE  },
    {VK_TAB       , 0                ,'\t'      ,'\t'      ,'\t'    ,'\t'    },
    {VK_ADD       , 0                ,'+'       ,'+'       ,'+'     ,'+'     },
    {VK_DECIMAL   , 0                ,'.'       ,'.'       ,'.'     ,'.'     },
    {VK_DIVIDE    , 0                ,'/'       ,'/'       ,'/'     ,'/'     },
    {VK_MULTIPLY  , 0                ,'*'       ,'*'       ,'*'     ,'*'     },
    {VK_SUBTRACT  , 0                ,'-'       ,'-'       ,'-'     ,'-'     },
    {0            , 0                ,0         ,0         ,0       ,0       }
};

static ALLOC_SECTION_LDATA VK_TO_WCHARS6 aVkToWch6[] = {
    //                      |          |   SHIFT  |  KANA  | K+SHFT |  CONTROL  |  K+CTRL   |
    //                      |          |==========|========|========|===========|===========|
    {VK_BACK      , 0       ,'\b'      ,'\b'      ,'\b'    ,'\b'    , 0x7f      , 0x7f      },
    {VK_CANCEL    , 0       ,0x03      ,0x03      ,0x03    ,0x03    , 0x03      , 0x03      },
    {VK_ESCAPE    , 0       ,0x1b      ,0x1b      ,0x1b    ,0x1b    , 0x1b      , 0x1b      },
    {VK_OEM_4     , KANALOK ,'['       ,'{'       ,WCH_SVS ,WCH_OB  , 0x1b      , 0x1b      },
    {VK_OEM_5     , KANALOK ,'\\'      ,'|'       ,WCH_PS  ,WCH_PS  , 0x1c      , 0x1c      },
    {VK_OEM_102   , KANALOK ,'\\'      ,'_'       ,WCH_RO  ,WCH_RO  , 0x1c      , 0x1c      },
    {VK_OEM_6     , KANALOK ,']'       ,'}'       ,WCH_MU  ,WCH_CB  , 0x1d      , 0x1d      },
    {VK_RETURN    , 0       ,'\r'      ,'\r'      ,'\r'    ,'\r'    , '\n'      , '\n'      },
    {VK_SPACE     , 0       ,' '       ,' '       ,' '     ,' '     , 0x20      , 0x20      },
    {0            , 0       ,0         ,0         ,0       ,0       , 0         , 0         }
};

static ALLOC_SECTION_LDATA VK_TO_WCHARS8 aVkToWch8[] = {
    //                      |          |   SHIFT  |  KANA  | K+SHFT |  CONTROL  |  K+CTRL   | SHFT+CTRL |K+SHFT+CTRL|
    //                      |          |==========|========|========|===========|===========|===========|===========|
    {'2'          , KANALOK ,'2'       ,'"'       ,WCH_HU  ,WCH_HU  , WCH_NONE  , WCH_NONE  , 0x00      , 0x00      },
    {'6'          , KANALOK ,'6'       ,'&'       ,WCH_O   ,WCH_OO  , WCH_NONE  , WCH_NONE  , 0x1e      , 0x1e      },
    {VK_OEM_MINUS , KANALOK ,'-'       ,'='       ,WCH_HO  ,WCH_HO  , WCH_NONE  , WCH_NONE  , 0x1f      , 0x1f      },
    {0            , 0       ,0         ,0         ,0       ,0       , 0         , 0         , 0         , 0         }
};

// Put this last so that VkKeyScan interprets number characters
// as coming from the main section of the kbd (aVkToWch2 and
// aVkToWch4) before considering the numpad (aVkToWch1).

static ALLOC_SECTION_LDATA VK_TO_WCHARS4 aVkToWch1[] = {
    //                     |          |   SHIFT  |  KANA  | K+SHFT |
    //                     |          |==========|========|========|
    { VK_NUMPAD0   , 0      ,  '0'    , WCH_NONE ,   '0'  ,WCH_NONE},
    { VK_NUMPAD1   , 0      ,  '1'    , WCH_NONE ,   '1'  ,WCH_NONE},
    { VK_NUMPAD2   , 0      ,  '2'    , WCH_NONE ,   '2'  ,WCH_NONE},
    { VK_NUMPAD3   , 0      ,  '3'    , WCH_NONE ,   '3'  ,WCH_NONE},
    { VK_NUMPAD4   , 0      ,  '4'    , WCH_NONE ,   '4'  ,WCH_NONE},
    { VK_NUMPAD5   , 0      ,  '5'    , WCH_NONE ,   '5'  ,WCH_NONE},
    { VK_NUMPAD6   , 0      ,  '6'    , WCH_NONE ,   '6'  ,WCH_NONE},
    { VK_NUMPAD7   , 0      ,  '7'    , WCH_NONE ,   '7'  ,WCH_NONE},
    { VK_NUMPAD8   , 0      ,  '8'    , WCH_NONE ,   '8'  ,WCH_NONE},
    { VK_NUMPAD9   , 0      ,  '9'    , WCH_NONE ,   '9'  ,WCH_NONE},
    { 0            , 0      ,  '\0'   , 0        ,   0    ,0       }   //null terminator
};

/***************************************************************************\
* aVkToWcharTable: table of pointers to Character Tables
*
* Describes the character tables and the order they should be searched.
*
* Note: the order determines the behavior of VkKeyScan() : this function
*       takes a character and attempts to find a Virtual Key and character-
*       modifier key combination that produces that character.  The table
*       containing the numeric keypad (aVkToWch1) must appear last so that
*       VkKeyScan('0') will be interpreted as one of keys from the main
*       section, not the numpad.  etc.
\***************************************************************************/

static ALLOC_SECTION_LDATA VK_TO_WCHAR_TABLE aVkToWcharTable[] = {
    {  (PVK_TO_WCHARS1)aVkToWch6, 6, sizeof(aVkToWch6[0]) },
    {  (PVK_TO_WCHARS1)aVkToWch8, 8, sizeof(aVkToWch8[0]) },
    {  (PVK_TO_WCHARS1)aVkToWch4, 4, sizeof(aVkToWch4[0]) },
    {  (PVK_TO_WCHARS1)aVkToWch1, 4, sizeof(aVkToWch1[0]) },  // must come last
    {                       NULL, 0, 0                    }
};

/***************************************************************************\
* aKeyNames[], aKeyNamesExt[]  - Scan Code -> Key Name tables
*
* For the GetKeyNameText() API function
*
* Tables for non-extended and extended (KBDEXT) keys.
* (Keys producing printable characters are named by the character itself)
\***************************************************************************/

static ALLOC_SECTION_LDATA VSC_LPWSTR aKeyNames[] = {
    0x01,    L"Esc",
    0x0e,    L"Backspace",
    0x0f,    L"Tab",
    0x1c,    L"Enter",
    0x1d,    L"Ctrl",
    0x29,    (LPWSTR)SZ_KEY_NAME_HANKAKU_ZENKAKU,  // NLS Key
    0x2a,    L"Shift",
    0x36,    L"Right Shift",
    0x37,    L"Num *",
    0x38,    L"Alt",
    0x39,    L"Space",
    0x3a,    L"Caps Lock",
    0x3b,    L"F1",
    0x3c,    L"F2",
    0x3d,    L"F3",
    0x3e,    L"F4",
    0x3f,    L"F5",
    0x40,    L"F6",
    0x41,    L"F7",
    0x42,    L"F8",
    0x43,    L"F9",
    0x44,    L"F10",
    0x45,    L"Pause",
    0x46,    L"Scroll Lock",
    0x47,    L"Num 7",
    0x48,    L"Num 8",
    0x49,    L"Num 9",
    0x4a,    L"Num -",
    0x4b,    L"Num 4",
    0x4c,    L"Num 5",
    0x4d,    L"Num 6",
    0x4e,    L"Num +",
    0x4f,    L"Num 1",
    0x50,    L"Num 2",
    0x51,    L"Num 3",
    0x52,    L"Num 0",
    0x53,    L"Num Del",
    0x54,    L"Sys Req",
    0x57,    L"F11",
    0x58,    L"F12",
    0x70,    (LPWSTR)SZ_KEY_NAME_HIRAGANA,
    0x79,    (LPWSTR)SZ_KEY_NAME_HENKAN,
    0x7b,    (LPWSTR)SZ_KEY_NAME_MUHENKAN,
    0x7C,    L"F13",
    0   ,    NULL
};

static ALLOC_SECTION_LDATA VSC_LPWSTR aKeyNamesExt[] = {
    0x1c,    L"Num Enter",
    0x1d,    L"Right Control",
    0x35,    L"Num /",
    0x37,    L"Prnt Scrn",
    0x38,    L"Right Alt",
    0x45,    L"Num Lock",
    0x46,    L"Break",
    0x47,    L"Home",
    0x48,    L"Up",
    0x49,    L"Page Up",
    0x4b,    L"Left",
    0x4d,    L"Right",
    0x4f,    L"End",
    0x50,    L"Down",
    0x51,    L"Page Down",
    0x52,    L"Insert",
    0x53,    L"Delete",
    0x5B,    L"Left Windows",
    0x5C,    L"Right Windows",
    0x5D,    L"Application",
    0   ,    NULL
};

static ALLOC_SECTION_LDATA KBDTABLES KbdTables = {
    /*
     * Modifier keys
     */
    &CharModifiers,

    /*
     * Characters tables
     */
    aVkToWcharTable,

    /*
     * Diacritics  (none for US English)
     */
    NULL,

    /*
     * Names of Keys  (no dead keys)
     */
    aKeyNames,
    aKeyNamesExt,
    NULL,

    /*
     * Scan codes to Virtual Keys
     */
    ausVK,
    sizeof(ausVK) / sizeof(ausVK[0]),
    aE0VscToVk,
    aE1VscToVk,

    /*
     * No Locale-specific special processing
     */
    0,

    /*
     * No Ligatures
     */
    0, 0, NULL,

    /*
     * Type and subtype
     */
    KEYBOARD_TYPE_JAPAN,
    MAKEWORD(FMV_KBD_OASYS_TYPE, NLSKBD_OEM_FUJITSU),
};

PKBDTABLES KbdLayerDescriptor(VOID)
{
    return &KbdTables;
}

/***********************************************************************\
* VkToFuncTable_F3AHVOAS[]
*
\***********************************************************************/

static ALLOC_SECTION_LDATA VK_F VkToFuncTable_F3AHVOAS[] = {
    {
        VK_DBE_ALPHANUMERIC,  // Base Vk
        KBDNLS_TYPE_TOGGLE,   // NLSFEProcType
        KBDNLS_INDEX_NORMAL,  // NLSFEProcCurrent
        0x02, /* 00000010 */  // NLSFEProcSwitch
        {                     // NLSFEProc
            {KBDNLS_ALPHANUM,0},               // Base
            {KBDNLS_SEND_PARAM_VK,VK_CAPITAL}, // Shift
            {KBDNLS_ALPHANUM,0},               // Control
            {KBDNLS_ALPHANUM,0},               // Shift+Control
            {KBDNLS_ALPHANUM,0},               // Alt
            {KBDNLS_ALPHANUM,0},               // Shift+Alt
            {KBDNLS_CODEINPUT,0},              // Control+Alt
            {KBDNLS_CODEINPUT,0}               // Shift+Control+Alt
        },
        {                     // NLSFEProcAlt
            {KBDNLS_SEND_PARAM_VK,VK_CAPITAL}, // Base
            {KBDNLS_SEND_PARAM_VK,VK_CAPITAL}, // Shift
            {KBDNLS_NOEVENT,0},                // Control
            {KBDNLS_NOEVENT,0},                // Shift+Control
            {KBDNLS_NOEVENT,0},                // Alt
            {KBDNLS_NOEVENT,0},                // Shift+Alt
            {KBDNLS_NOEVENT,0},                // Control+Alt
            {KBDNLS_NOEVENT,0}                 // Shift+Control+Alt
        }
    },
    {
        VK_DBE_HIRAGANA,     // Base Vk
        KBDNLS_TYPE_TOGGLE,  // NLSFEProcType
        KBDNLS_INDEX_NORMAL, // NLSFEProcCurrent
        0x08, /* 00001000 */ // NLSFEProcSwitch
        {                    // NLSFEProc
            {KBDNLS_HIRAGANA,0},             // Base
            {KBDNLS_KATAKANA,0},             // Shift
            {KBDNLS_HIRAGANA,0},             // Control
            {KBDNLS_KANAEVENT,VK_KANA},      // Shift+Control
            {KBDNLS_ROMAN,0},                // Alt
            {KBDNLS_ROMAN,0},                // Shift+Alt
            {KBDNLS_ROMAN,0},                // Control+Alt
            {KBDNLS_NOEVENT,0}               // Shift+Control+Alt
        },
        {                    // NLSFEProcIndexAlt
            {KBDNLS_KANAEVENT,VK_KANA},      // Base
            {KBDNLS_KANAEVENT,VK_KANA},      // Shift
            {KBDNLS_KANAEVENT,VK_KANA},      // Control
            {KBDNLS_KANAEVENT,VK_KANA},      // Shift+Control
            {KBDNLS_NOEVENT,0},              // Alt
            {KBDNLS_NOEVENT,0},              // Shift+Alt
            {KBDNLS_NOEVENT,0},              // Control+Alt
            {KBDNLS_NOEVENT,0}               // Shift+Control+Alt
        }
    },
    {
        VK_DBE_SBCSCHAR,     // Base Vk
        KBDNLS_TYPE_NORMAL,  // NLSFEProcType
        KBDNLS_INDEX_NORMAL, // NLSFEProcCurrent
        0x0,                 // NLSFEProcSwitch
        {                    // NLSFEProc
            {KBDNLS_SBCSDBCS,0},             // Base
            {KBDNLS_SBCSDBCS,0},             // Shift
            {KBDNLS_SBCSDBCS,0},             // Control
            {KBDNLS_SBCSDBCS,0},             // Shift+Control
            {KBDNLS_SEND_PARAM_VK,VK_KANJI}, // Alt
            {KBDNLS_SBCSDBCS,0},             // Shift+Alt
            {KBDNLS_SEND_PARAM_VK,VK_DBE_ENTERIMECONFIGMODE}, // Control+Alt
            {KBDNLS_SEND_PARAM_VK,VK_DBE_ENTERIMECONFIGMODE}  // Shift+Control+Alt
        },
        {                    // NLSFEProcIndexAlt
            {KBDNLS_NULL,0},  // Base
            {KBDNLS_NULL,0},  // Shift
            {KBDNLS_NULL,0},  // Control
            {KBDNLS_NULL,0},  // Shift+Control
            {KBDNLS_NULL,0},  // Alt
            {KBDNLS_NULL,0},  // Shift+Alt
            {KBDNLS_NULL,0},  // Control+Alt
            {KBDNLS_NULL,0}   // Shift+Control+Alt
        }
    },
    {
        VK_CONVERT,          // Base Vk
        KBDNLS_TYPE_NORMAL,  // NLSFEProcType
        KBDNLS_INDEX_NORMAL, // NLSFEProcCurrent
        0x0,                 // NLSFEProcSwitch
        {                    // NLSFEProc
            {KBDNLS_CONV_OR_NONCONV,0},      // Base
            {KBDNLS_CONV_OR_NONCONV,0},      // Shift
            {KBDNLS_CONV_OR_NONCONV,0},      // Control
            {KBDNLS_CONV_OR_NONCONV,0},      // Shift+Control
            {KBDNLS_CONV_OR_NONCONV,0},      // Alt
            {KBDNLS_CONV_OR_NONCONV,0},      // Shift+Alt
            {KBDNLS_CONV_OR_NONCONV,0},      // Control+Alt
            {KBDNLS_CONV_OR_NONCONV,0},      // Shift+Control+Alt
        },
        {                         // NLSFEProcIndexAlt
            {KBDNLS_NULL,0},  // Base
            {KBDNLS_NULL,0},  // Shift
            {KBDNLS_NULL,0},  // Control
            {KBDNLS_NULL,0},  // Shift+Control
            {KBDNLS_NULL,0},  // Alt
            {KBDNLS_NULL,0},  // Shift+Alt
            {KBDNLS_NULL,0},  // Control+Alt
            {KBDNLS_NULL,0}   // Shift+Control+Alt
        }
    },
    {
        VK_NONCONVERT,       // Base Vk
        KBDNLS_TYPE_NORMAL,  // NLSFEProcType
        KBDNLS_INDEX_NORMAL, // NLSFEProcCurrent
        0x0,                 // NLSFEProcSwitch
        {                    // NLSFEProc
            {KBDNLS_CONV_OR_NONCONV,0},      // Base
            {KBDNLS_CONV_OR_NONCONV,0},      // Shift
            {KBDNLS_CONV_OR_NONCONV,0},      // Control
            {KBDNLS_CONV_OR_NONCONV,0},      // Shift+Control
            {KBDNLS_CONV_OR_NONCONV,0},      // Alt
            {KBDNLS_CONV_OR_NONCONV,0},      // Shift+Alt
            {KBDNLS_SEND_PARAM_VK,VK_DBE_ENTERWORDREGISTERMODE}, // Control+Alt
            {KBDNLS_SEND_PARAM_VK,VK_DBE_ENTERWORDREGISTERMODE}  // Shift+Control+Alt
        },
        {                         // NLSFEProcIndexAlt
            {KBDNLS_NULL,0},  // Base
            {KBDNLS_NULL,0},  // Shift
            {KBDNLS_NULL,0},  // Control
            {KBDNLS_NULL,0},  // Shift+Control
            {KBDNLS_NULL,0},  // Alt
            {KBDNLS_NULL,0},  // Shift+Alt
            {KBDNLS_NULL,0},  // Control+Alt
            {KBDNLS_NULL,0}   // Shift+Control+Alt
        }
    }
};

/***********************************************************************\
* KbdNlsTables
*
\***********************************************************************/

static ALLOC_SECTION_LDATA KBDNLSTABLES KbdNlsTables = {
    NLSKBD_OEM_FUJITSU,                    // OEM ID (0 = Microsoft)
    NLSKBD_INFO_SEND_IME_NOTIFICATION |
    NLSKBD_INFO_EMURATE_106_KEYBOARD,      // Information
    5,                                     // Number of VK_F entry
    VkToFuncTable_F3AHVOAS,                // Pointer to VK_F array
    0,                                     // Pointer to MouseVk entry
    NULL                                   // Pointer to MouseVk array
};

PKBDNLSTABLES KbdNlsLayerDescriptor(VOID)
{
    return &KbdNlsTables;
}

VOID FujitsuOyayubiControl(DWORD dwOpen, DWORD dwConversion)
{
    NtUserCallTwoParam(dwOpen, dwConversion, SFI_NLSKBDSENDIMENOTIFICATION);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kbd\fe_kbds\jpn\ibm02\kbdibm02.c ===
/***************************************************************************\
* Module Name: kbdibm02.c
*
* Copyright (c) 1985-92, Microsoft Corporation
*
* History:
\***************************************************************************/

#include <windows.h>
#include <ime.h>
#include "vkoem.h"
#include "kbdjpn.h"
#include "kbdibm02.h"

#if defined(_M_IA64)
#pragma section(".data")
#define ALLOC_SECTION_LDATA __declspec(allocate(".data"))
#else
#pragma data_seg(".data")
#define ALLOC_SECTION_LDATA
#endif

/***************************************************************************\
* ausVK[] - Virtual Scan Code to Virtual Key conversion table for IBM-J 5576-002
\***************************************************************************/

static ALLOC_SECTION_LDATA USHORT ausVK[] = {
    T00, T01, T02, T03, T04, T05, T06, T07,
    T08, T09, T0A, T0B, T0C, T0D, T0E, T0F,
    T10, T11, T12, T13, T14, T15, T16, T17,
    T18, T19, T1A, T1B, T1C, T1D, T1E, T1F,
    T20, T21, T22, T23, T24, T25, T26, T27,
    T28, T29, T2A, T2B, T2C, T2D, T2E, T2F,
    T30, T31, T32, T33, T34, T35,

    /*
     * Right-hand Shift key must have KBDEXT bit set.
     */
    T36 | KBDEXT,

    T37 | KBDMULTIVK,               // numpad_* + Shift/Alt -> SnapShot

    T38, T39,

    T3A | KBDSPECIAL,              // Alphanumeric/Caps key // NLS key

    T3B, T3C, T3D, T3E, T3F, T40, T41, T42,
    T43, T44,

    /*
     * NumLock Key:
     *     KBDEXT     - VK_NUMLOCK is an Extended key
     *     KBDMULTIVK - VK_NUMLOCK or VK_PAUSE (without or with CTRL)
     */
    T45 | KBDEXT | KBDMULTIVK,

    T46 | KBDMULTIVK,

    /*
     * Number Pad keys:
     *     KBDNUMPAD  - digits 0-9 and decimal point.
     *     KBDSPECIAL - require special processing by Windows
     */
    T47 | KBDNUMPAD | KBDSPECIAL,   // Numpad 7 (Home)
    T48 | KBDNUMPAD | KBDSPECIAL,   // Numpad 8 (Up),
    T49 | KBDNUMPAD | KBDSPECIAL,   // Numpad 9 (PgUp),
    T4A,
    T4B | KBDNUMPAD | KBDSPECIAL,   // Numpad 4 (Left),
    T4C | KBDNUMPAD | KBDSPECIAL,   // Numpad 5 (Clear),
    T4D | KBDNUMPAD | KBDSPECIAL,   // Numpad 6 (Right),
    T4E,
    T4F | KBDNUMPAD | KBDSPECIAL,   // Numpad 1 (End),
    T50 | KBDNUMPAD | KBDSPECIAL,   // Numpad 2 (Down),
    T51 | KBDNUMPAD | KBDSPECIAL,   // Numpad 3 (PgDn),
    T52 | KBDNUMPAD | KBDSPECIAL,   // Numpad 0 (Ins),
    T53 | KBDNUMPAD | KBDSPECIAL,   // Numpad . (Del),

    T54, T55, T56, T57, T58, T59, T5A, T5B,
    T5C, T5D, T5E, T5F, T60, T61, T62, T63,
    T64, T65, T66, T67, T68, T69, T6A, T6B,
    T6C, T6D, T6E, T6F,

    T70 | KBDSPECIAL,              // Katakana/Kanji key

    T71, T72,

    T73,                           // | \ Katakana RO key   // NLS key

    T74, T75, T76,

    T77 | KBDSPECIAL,              // SBCS/DBCS key         // NLS key

    T78,

    T79 | KBDSPECIAL,              // Conversion key        // NLS key

    T7A,

    T7B | KBDSPECIAL               // Non-Conversion key    // NLS key
};

static ALLOC_SECTION_LDATA VSC_VK aE0VscToVk[] = {
        { 0x1C, X1C | KBDEXT              },  // Numpad Enter
        { 0x1D, X1D | KBDEXT              },  // RControl
        { 0x33, X33 | KBDEXT              },  // Comma key by 5576-002 special
        { 0x35, X35 | KBDEXT              },  // Numpad Divide
        { 0x37, X37 | KBDEXT              },  // Snapshot
        { 0x38, X38 | KBDEXT | KBDSPECIAL },  // Hiragana key   // NLS key
        { 0x46, X46 | KBDEXT              },  // Break (Ctrl + Pause)
        { 0x47, X47 | KBDEXT              },  // Home
        { 0x48, X48 | KBDEXT              },  // Up
        { 0x49, X49 | KBDEXT              },  // Prior
        { 0x4B, X4B | KBDEXT              },  // Left
        { 0x4D, X4D | KBDEXT              },  // Right
        { 0x4F, X4F | KBDEXT              },  // End
        { 0x50, X50 | KBDEXT              },  // Down
        { 0x51, X51 | KBDEXT              },  // Next
        { 0x52, X52 | KBDEXT              },  // Insert
        { 0x53, X53 | KBDEXT              },  // Delete
        { 0x5B, X5B | KBDEXT              },  // Left Win
        { 0x5C, X5C | KBDEXT              },  // Right Win
        { 0x5D, X5D | KBDEXT              },  // Application
        { 0,      0                       }
};

static ALLOC_SECTION_LDATA VSC_VK aE1VscToVk[] = {
        { 0x1D, Y1D                       },  // Pause
        { 0   ,   0                       }
};

/***************************************************************************\
* aVkToBits[]  - map Virtual Keys to Modifier Bits
*
* See kbd.h for a full description.
*
* US Keyboard has only three shifter keys:
*     SHIFT (L & R) affects alphabnumeric keys,
*     CTRL  (L & R) is used to generate control characters
*     ALT   (L & R) used for generating characters by number with numpad
\***************************************************************************/

static ALLOC_SECTION_LDATA VK_TO_BIT aVkToBits[] = {
    { VK_SHIFT,   KBDSHIFT },
    { VK_CONTROL, KBDCTRL  },
    { VK_MENU,    KBDALT   },
    { VK_KANA,    KBDKANA  },
    { 0,          0        }
};

/***************************************************************************\
* aModification[]  - map character modifier bits to modification number
*
* See kbd.h for a full description.
*
\***************************************************************************/

static ALLOC_SECTION_LDATA MODIFIERS CharModifiers = {
    &aVkToBits[0],
    11,
    {
    //  Modification# //  Keys Pressed  : Explanation
    //  ============= // ============== : =============================
        0,            //                : unshifted characters
        1,            //          SHIFT : capitals, ~!@#$%^&*()_+{}:"<>? etc.
        4,            //     CTRL       : control characters
        6,            //     CTRL SHIFT :
        SHFT_INVALID, // ALT            : invalid
        SHFT_INVALID, // ALT      SHIFT : invalid
        SHFT_INVALID, // ALT CTRL       : invalid
        SHFT_INVALID, // ALT CTRL SHIFT : invalid
        2,            //KANA
        3,            //KANA      SHIFT
        5,            //KANA CTRL
        7             //KANA CTRL SHIFT
    }
};

/***************************************************************************\
*
* aVkToWch2[]  - Virtual Key to WCHAR translation for 2 shift states
* aVkToWch3[]  - Virtual Key to WCHAR translation for 3 shift states
* aVkToWch4[]  - Virtual Key to WCHAR translation for 4 shift states
*
* Table attributes: Unordered Scan, null-terminated
*
* Search this table for an entry with a matching Virtual Key to find the
* corresponding unshifted and shifted WCHAR characters.
*
* Reserved VirtualKey values (first column)
*     -1            - this line contains dead characters (diacritic)
*     0             - terminator
*
* Reserved Attribute values (second column)
*     CAPLOK        - CapsLock affects this key like Shift
*     KANALOK       - The KANA-LOCK key affects this key like KANA
*
* Reserved character values (third through last column)
*     WCH_NONE      - No character
*     WCH_DEAD      - Dead character (diacritic) value is in next line
*
\***************************************************************************/

static ALLOC_SECTION_LDATA VK_TO_WCHARS4 aVkToWch4[] = {
    //                               |          |   SHIFT  |  KANA  | K+SHFT |
    //                               |          |==========|========|========|
    {'0'          ,          KANALOK ,'0'       ,WCH_NONE  ,WCH_WA  ,WCH_WO  },
    {'1'          ,          KANALOK ,'1'       ,'!'       ,WCH_NU  ,WCH_NU  },
    {'3'          ,          KANALOK ,'3'       ,'#'       ,WCH_A   ,WCH_AA  },
    {'4'          ,          KANALOK ,'4'       ,'$'       ,WCH_U   ,WCH_UU  },
    {'5'          ,          KANALOK ,'5'       ,'%'       ,WCH_E   ,WCH_EE  },
    {'7'          ,          KANALOK ,'7'       ,0x27      ,WCH_YA  ,WCH_YAA },
    {'8'          ,          KANALOK ,'8'       ,'('       ,WCH_YU  ,WCH_YUU },
    {'9'          ,          KANALOK ,'9'       ,')'       ,WCH_YO  ,WCH_YOO },
    {'A'          , CAPLOK | KANALOK ,'a'       ,'A'       ,WCH_TI  ,WCH_TI  },
    {'B'          , CAPLOK | KANALOK ,'b'       ,'B'       ,WCH_KO  ,WCH_KO  },
    {'C'          , CAPLOK | KANALOK ,'c'       ,'C'       ,WCH_SO  ,WCH_SO  },
    {'D'          , CAPLOK | KANALOK ,'d'       ,'D'       ,WCH_SI  ,WCH_SI  },
    {'E'          , CAPLOK | KANALOK ,'e'       ,'E'       ,WCH_I   ,WCH_II  },
    {'F'          , CAPLOK | KANALOK ,'f'       ,'F'       ,WCH_HA  ,WCH_HA  },
    {'G'          , CAPLOK | KANALOK ,'g'       ,'G'       ,WCH_KI  ,WCH_KI  },
    {'H'          , CAPLOK | KANALOK ,'h'       ,'H'       ,WCH_KU  ,WCH_KU  },
    {'I'          , CAPLOK | KANALOK ,'i'       ,'I'       ,WCH_NI  ,WCH_NI  },
    {'J'          , CAPLOK | KANALOK ,'j'       ,'J'       ,WCH_MA  ,WCH_MA  },
    {'K'          , CAPLOK | KANALOK ,'k'       ,'K'       ,WCH_NO  ,WCH_NO  },
    {'L'          , CAPLOK | KANALOK ,'l'       ,'L'       ,WCH_RI  ,WCH_RI  },
    {'M'          , CAPLOK | KANALOK ,'m'       ,'M'       ,WCH_MO  ,WCH_MO  },
    {'N'          , CAPLOK | KANALOK ,'n'       ,'N'       ,WCH_MI  ,WCH_MI  },
    {'O'          , CAPLOK | KANALOK ,'o'       ,'O'       ,WCH_RA  ,WCH_RA  },
    {'P'          , CAPLOK | KANALOK ,'p'       ,'P'       ,WCH_SE  ,WCH_SE  },
    {'Q'          , CAPLOK | KANALOK ,'q'       ,'Q'       ,WCH_TA  ,WCH_TA  },
    {'R'          , CAPLOK | KANALOK ,'r'       ,'R'       ,WCH_SU  ,WCH_SU  },
    {'S'          , CAPLOK | KANALOK ,'s'       ,'S'       ,WCH_TO  ,WCH_TO  },
    {'T'          , CAPLOK | KANALOK ,'t'       ,'T'       ,WCH_KA  ,WCH_KA  },
    {'U'          , CAPLOK | KANALOK ,'u'       ,'U'       ,WCH_NA  ,WCH_NA  },
    {'V'          , CAPLOK | KANALOK ,'v'       ,'V'       ,WCH_HI  ,WCH_HI  },
    {'W'          , CAPLOK | KANALOK ,'w'       ,'W'       ,WCH_TE  ,WCH_TE  },
    {'X'          , CAPLOK | KANALOK ,'x'       ,'X'       ,WCH_SA  ,WCH_SA  },
    {'Y'          , CAPLOK | KANALOK ,'y'       ,'Y'       ,WCH_NN  ,WCH_NN  },
    {'Z'          , CAPLOK | KANALOK ,'z'       ,'Z'       ,WCH_TU  ,WCH_TUU },
    {VK_OEM_1     ,          KANALOK ,':'       ,'*'       ,WCH_KE  ,WCH_KE  },
    {VK_OEM_2     ,          KANALOK ,'/'       ,'?'       ,WCH_ME  ,WCH_MD  },
    {VK_OEM_3     ,          KANALOK ,'@'       ,'`'       ,WCH_VS  ,WCH_VS  },
    {VK_OEM_7     ,          KANALOK ,'^'       ,'~'       ,WCH_HE  ,WCH_HE  },
    {VK_OEM_8     , 0                ,','       ,','       ,','     ,','     },
    {VK_OEM_COMMA ,          KANALOK ,','       ,'<'       ,WCH_NE  ,WCH_IC  },
    {VK_OEM_PERIOD,          KANALOK ,'.'       ,'>'       ,WCH_RU  ,WCH_IP  },
    {VK_OEM_PLUS  ,          KANALOK ,';'       ,'+'       ,WCH_RE  ,WCH_RE  },
    {VK_TAB       , 0                ,'\t'      ,'\t'      ,'\t'    ,'\t'    },
    {VK_ADD       , 0                ,'+'       ,'+'       ,'+'     ,'+'     },
    {VK_DECIMAL   , 0                ,'.'       ,'.'       ,'.'     ,'.'     },
    {VK_DIVIDE    , 0                ,'/'       ,'/'       ,'/'     ,'/'     },
    {VK_MULTIPLY  , 0                ,'*'       ,'*'       ,'*'     ,'*'     },
    {VK_SUBTRACT  , 0                ,'-'       ,'-'       ,'-'     ,'-'     },
    {0            , 0                ,0         ,0         ,0       ,0       }
};

static ALLOC_SECTION_LDATA VK_TO_WCHARS6 aVkToWch6[] = {
    //                      |          |   SHIFT  |  KANA  | K+SHFT |  CONTROL  |  K+CTRL   |
    //                      |          |==========|========|========|===========|===========|
    {VK_BACK      , 0       ,'\b'      ,'\b'      ,'\b'    ,'\b'    , 0x7f      , 0x7f      },
    {VK_CANCEL    , 0       ,0x03      ,0x03      ,0x03    ,0x03    , 0x03      , 0x03      },
    {VK_ESCAPE    , 0       ,0x1b      ,0x1b      ,0x1b    ,0x1b    , 0x1b      , 0x1b      },
    {VK_OEM_4     , KANALOK ,'['       ,'{'       ,WCH_SVS ,WCH_OB  , 0x1b      , 0x1b      },
    {VK_OEM_5     , KANALOK ,'\\'      ,'|'       ,WCH_PS  ,WCH_PS  , 0x1c      , 0x1c      },
    {VK_OEM_102   , KANALOK ,'\\'      ,'_'       ,WCH_RO  ,WCH_RO  , 0x1c      , 0x1c      },
    {VK_OEM_6     , KANALOK ,']'       ,'}'       ,WCH_MU  ,WCH_CB  , 0x1d      , 0x1d      },
    {VK_RETURN    , 0       ,'\r'      ,'\r'      ,'\r'    ,'\r'    , '\n'      , '\n'      },
    {VK_SPACE     , 0       ,' '       ,' '       ,' '     ,' '     , 0x20      , 0x20      },
    {0            , 0       ,0         ,0         ,0       ,0       , 0         , 0         }
};

static ALLOC_SECTION_LDATA VK_TO_WCHARS8 aVkToWch8[] = {
    //                      |          |   SHIFT  |  KANA  | K+SHFT |  CONTROL  |  K+CTRL   | SHFT+CTRL |K+SHFT+CTRL|
    //                      |          |==========|========|========|===========|===========|===========|===========|
    {'2'          , KANALOK ,'2'       ,'"'       ,WCH_HU  ,WCH_HU  , WCH_NONE  , WCH_NONE  , 0x00      , 0x00      },
    {'6'          , KANALOK ,'6'       ,'&'       ,WCH_O   ,WCH_OO  , WCH_NONE  , WCH_NONE  , 0x1e      , 0x1e      },
    {VK_OEM_MINUS , KANALOK ,'-'       ,'='       ,WCH_HO  ,WCH_HO  , WCH_NONE  , WCH_NONE  , 0x1f      , 0x1f      },
    {0            , 0       ,0         ,0         ,0       ,0       , 0         , 0         , 0         , 0         }
};

// Put this last so that VkKeyScan interprets number characters
// as coming from the main section of the kbd (aVkToWch2 and
// aVkToWch4) before considering the numpad (aVkToWch1).

static ALLOC_SECTION_LDATA VK_TO_WCHARS4 aVkToWch1[] = {
    //                     |          |   SHIFT  |  KANA  | K+SHFT |
    //                     |          |==========|========|========|
    { VK_NUMPAD0   , 0      ,  '0'    , WCH_NONE ,   '0'  ,WCH_NONE},
    { VK_NUMPAD1   , 0      ,  '1'    , WCH_NONE ,   '1'  ,WCH_NONE},
    { VK_NUMPAD2   , 0      ,  '2'    , WCH_NONE ,   '2'  ,WCH_NONE},
    { VK_NUMPAD3   , 0      ,  '3'    , WCH_NONE ,   '3'  ,WCH_NONE},
    { VK_NUMPAD4   , 0      ,  '4'    , WCH_NONE ,   '4'  ,WCH_NONE},
    { VK_NUMPAD5   , 0      ,  '5'    , WCH_NONE ,   '5'  ,WCH_NONE},
    { VK_NUMPAD6   , 0      ,  '6'    , WCH_NONE ,   '6'  ,WCH_NONE},
    { VK_NUMPAD7   , 0      ,  '7'    , WCH_NONE ,   '7'  ,WCH_NONE},
    { VK_NUMPAD8   , 0      ,  '8'    , WCH_NONE ,   '8'  ,WCH_NONE},
    { VK_NUMPAD9   , 0      ,  '9'    , WCH_NONE ,   '9'  ,WCH_NONE},
    { 0            , 0      ,  '\0'   , 0        ,   0    ,0       }   //null terminator
};

/***************************************************************************\
* aVkToWcharTable: table of pointers to Character Tables
*
* Describes the character tables and the order they should be searched.
*
* Note: the order determines the behavior of VkKeyScan() : this function
*       takes a character and attempts to find a Virtual Key and character-
*       modifier key combination that produces that character.  The table
*       containing the numeric keypad (aVkToWch1) must appear last so that
*       VkKeyScan('0') will be interpreted as one of keys from the main
*       section, not the numpad.  etc.
\***************************************************************************/

static ALLOC_SECTION_LDATA VK_TO_WCHAR_TABLE aVkToWcharTable[] = {
    {  (PVK_TO_WCHARS1)aVkToWch6, 6, sizeof(aVkToWch6[0]) },
    {  (PVK_TO_WCHARS1)aVkToWch8, 8, sizeof(aVkToWch8[0]) },
    {  (PVK_TO_WCHARS1)aVkToWch4, 4, sizeof(aVkToWch4[0]) },
    {  (PVK_TO_WCHARS1)aVkToWch1, 4, sizeof(aVkToWch1[0]) },  // must come last
    {                       NULL, 0, 0                    }
};

/***************************************************************************\
* aKeyNames[], aKeyNamesExt[]  - Scan Code -> Key Name tables
*
* For the GetKeyNameText() API function
*
* Tables for non-extended and extended (KBDEXT) keys.
* (Keys producing printable characters are named by the character itself)
\***************************************************************************/

static ALLOC_SECTION_LDATA VSC_LPWSTR aKeyNames[] = {
    0x01,    L"Esc",
    0x0e,    L"Backspace",
    0x0f,    L"Tab",
    0x1c,    L"Enter",
    0x1d,    L"Ctrl",
    0x2a,    L"Shift",
    0x36,    L"Right Shift",
    0x37,    L"Num *",
    0x38,    L"Alt",
    0x39,    L"Space",
    0x3a,    L"Caps Lock",
    0x3b,    L"F1",
    0x3c,    L"F2",
    0x3d,    L"F3",
    0x3e,    L"F4",
    0x3f,    L"F5",
    0x40,    L"F6",
    0x41,    L"F7",
    0x42,    L"F8",
    0x43,    L"F9",
    0x44,    L"F10",
    0x45,    L"Pause",
    0x46,    L"Scroll Lock",
    0x47,    L"Num 7",
    0x48,    L"Num 8",
    0x49,    L"Num 9",
    0x4a,    L"Num -",
    0x4b,    L"Num 4",
    0x4c,    L"Num 5",
    0x4d,    L"Num 6",
    0x4e,    L"Num +",
    0x4f,    L"Num 1",
    0x50,    L"Num 2",
    0x51,    L"Num 3",
    0x52,    L"Num 0",
    0x53,    L"Num Del",
    0x54,    L"Sys Req",
    0x57,    L"F11",
    0x58,    L"F12",
    0x70,    (LPWSTR)SZ_KEY_NAME_KATAKANA,        // NLS Key
    0x77,    (LPWSTR)SZ_KEY_NAME_HANKAKU_ZENKAKU, // NLS Key
    0x79,    (LPWSTR)SZ_KEY_NAME_HENKAN,          // NLS Key
    0x7b,    (LPWSTR)SZ_KEY_NAME_MUHENKAN,        // NLS Key
    0   ,    NULL
};

static ALLOC_SECTION_LDATA VSC_LPWSTR aKeyNamesExt[] = {
    0x1c,    L"Num Enter",
    0x1d,    L"Right Control",
    0x35,    L"Num /",
    0x37,    L"Prnt Scrn",
    0x38,    (LPWSTR)SZ_KEY_NAME_HIRAGANA,        // NLS Key
    0x45,    L"Num Lock",
    0x46,    L"Break",
    0x47,    L"Home",
    0x48,    L"Up",
    0x49,    L"Page Up",
    0x4b,    L"Left",
    0x4d,    L"Right",
    0x4f,    L"End",
    0x50,    L"Down",
    0x51,    L"Page Down",
    0x52,    L"Insert",
    0x53,    L"Delete",
    0x54,    L"<00>",
    0x56,    L"Help",
    0x5B,    L"Left Windows",
    0x5C,    L"Right Windows",
    0x5D,    L"Application",
    0   ,    NULL
};

static ALLOC_SECTION_LDATA KBDTABLES KbdTables = {
    /*
     * Modifier keys
     */
    &CharModifiers,

    /*
     * Characters tables
     */
    aVkToWcharTable,

    /*
     * Diacritics  (none for US English)
     */
    NULL,

    /*
     * Names of Keys  (no dead keys)
     */
    aKeyNames,
    aKeyNamesExt,
    NULL,

    /*
     * Scan codes to Virtual Keys
     */
    ausVK,
    sizeof(ausVK) / sizeof(ausVK[0]),
    aE0VscToVk,
    aE1VscToVk,

    /*
     * No Locale-specific special processing
     */
    0,

    /*
     * No Ligatures
     */
    0, 0, NULL,

    /*
     * Type and subtype
     */
    KEYBOARD_TYPE_JAPAN,
    MAKEWORD(MICROSOFT_KBD_001_TYPE, NLSKBD_OEM_MICROSOFT),
};

PKBDTABLES KbdLayerDescriptor(VOID)
{
    return &KbdTables;
}

/***********************************************************************\
* VkToFuncTable_101[]
*
\***********************************************************************/

static ALLOC_SECTION_LDATA VK_F VkToFuncTable_IBM002[] = {
    {
        VK_DBE_KATAKANA,            // Base Vk
        KBDNLS_TYPE_TOGGLE,         // NLSFEProcType
        KBDNLS_INDEX_NORMAL,        // NLSFEProcCurrent
        0x04, /* 00000100 */        // NLSFEProcSwitch
        {                           // NLSFEProc
            {KBDNLS_KATAKANA,0},             // Base
            {KBDNLS_SEND_PARAM_VK,VK_KANJI}, // Shift
            {KBDNLS_SEND_PARAM_VK,VK_KANA},  // Control
            {KBDNLS_NOEVENT,0},              // Shift+Control
            {KBDNLS_CODEINPUT,0},            // Alt
            {KBDNLS_CODEINPUT,0},            // Shift+Alt
            {KBDNLS_CODEINPUT,0},            // Control+Alt
            {KBDNLS_CODEINPUT,0}             // Shift+Control+Alt
        },
        {                           // NLSFEProcAlt
            {KBDNLS_SEND_PARAM_VK,VK_KANA},  // Base
            {KBDNLS_NOEVENT,0},              // Shift
            {KBDNLS_SEND_PARAM_VK,VK_KANA},  // Control
            {KBDNLS_NOEVENT,0},              // Shift+Control
            {KBDNLS_NOEVENT,0},              // Alt
            {KBDNLS_NOEVENT,0},              // Shift+Alt
            {KBDNLS_NOEVENT,0},              // Control+Alt
            {KBDNLS_NOEVENT,0}               // Shift+Control+Alt
        }
    },
    {
        VK_DBE_ALPHANUMERIC,     // Base Vk
        KBDNLS_TYPE_TOGGLE,      // NLSFEProcType
        KBDNLS_INDEX_NORMAL,     // NLSFEProcCurrent
        0xFE, /* 11111110 */     // NLSFEProcSwitch
        {                        // NLSFEProc
            {KBDNLS_ALPHANUM,0},               // Base
            {KBDNLS_SEND_PARAM_VK,VK_CAPITAL}, // Shift
            {KBDNLS_SEND_PARAM_VK,VK_CAPITAL}, // Control
            {KBDNLS_SEND_PARAM_VK,VK_CAPITAL}, // Shift+Control
            {KBDNLS_SEND_PARAM_VK,VK_CAPITAL}, // Alt
            {KBDNLS_SEND_PARAM_VK,VK_CAPITAL}, // Shift+Alt
            {KBDNLS_SEND_PARAM_VK,VK_CAPITAL}, // Control+Alt
            {KBDNLS_SEND_PARAM_VK,VK_CAPITAL}  // Shift+Control+Alt
        },
        {                    // NLSFEProcIndexAlt
            {KBDNLS_SEND_PARAM_VK,VK_CAPITAL}, // Base
            {KBDNLS_SEND_PARAM_VK,VK_CAPITAL}, // Shift
            {KBDNLS_SEND_PARAM_VK,VK_CAPITAL}, // Control
            {KBDNLS_SEND_PARAM_VK,VK_CAPITAL}, // Shift+Control
            {KBDNLS_SEND_PARAM_VK,VK_CAPITAL}, // Alt
            {KBDNLS_SEND_PARAM_VK,VK_CAPITAL}, // Shift+Alt
            {KBDNLS_SEND_PARAM_VK,VK_CAPITAL}, // Control+Alt
            {KBDNLS_SEND_PARAM_VK,VK_CAPITAL}  // Shift+Control+Alt
        }
    },
    {
        VK_DBE_HIRAGANA,         // Base Vk
        KBDNLS_TYPE_NORMAL,      // NLSFEProcType
        KBDNLS_INDEX_NORMAL,     // NLSFEProcCurrent
        0,                       // NLSFEProcSwitch
        {                        // NLSFEProc
            {KBDNLS_HIRAGANA,0}, // Base
            {KBDNLS_HIRAGANA,0}, // Shift
            {KBDNLS_HIRAGANA,0}, // Control
            {KBDNLS_HIRAGANA,0}, // Shift+Control
            {KBDNLS_ROMAN,0},    // Alt
            {KBDNLS_ROMAN,0},    // Shift+Alt
            {KBDNLS_ROMAN,0},    // Control+Alt
            {KBDNLS_ROMAN,0}     // Shift+Control+Alt
        },
        {                    // NLSFEProcIndexAlt
            {KBDNLS_NULL,0},     // Base
            {KBDNLS_NULL,0},     // Shift
            {KBDNLS_NULL,0},     // Control
            {KBDNLS_NULL,0},     // Shift+Control
            {KBDNLS_NULL,0},     // Alt
            {KBDNLS_NULL,0},     // Shift+Alt
            {KBDNLS_NULL,0},     // Control+Alt
            {KBDNLS_NULL,0}      // Shift+Control+Alt
        }
    },
    {
        VK_DBE_SBCSCHAR,         // Base Vk
        KBDNLS_TYPE_NORMAL,      // NLSFEProcType
        KBDNLS_INDEX_NORMAL,     // NLSFEProcCurrent
        0,                       // NLSFEProcSwitch
        {                        // NLSFEProc
            {KBDNLS_SBCSDBCS,0}, // Base
            {KBDNLS_SBCSDBCS,0}, // Shift
            {KBDNLS_SBCSDBCS,0}, // Control
            {KBDNLS_SBCSDBCS,0}, // Shift+Control
            {KBDNLS_NOEVENT,0},    // Alt
            {KBDNLS_NOEVENT,0},    // Shift+Alt
            {KBDNLS_SEND_PARAM_VK,VK_DBE_ENTERIMECONFIGMODE}, // Control+Alt
            {KBDNLS_SEND_PARAM_VK,VK_DBE_ENTERIMECONFIGMODE}  // Shift+Control+Alt
        },
        {                    // NLSFEProcIndexAlt
            {KBDNLS_NULL,0},     // Base
            {KBDNLS_NULL,0},     // Shift
            {KBDNLS_NULL,0},     // Control
            {KBDNLS_NULL,0},     // Shift+Control
            {KBDNLS_NULL,0},     // Alt
            {KBDNLS_NULL,0},     // Shift+Alt
            {KBDNLS_NULL,0},     // Control+Alt
            {KBDNLS_NULL,0}      // Shift+Control+Alt
        }
    },
    {
        VK_NONCONVERT,           // Base Vk
        KBDNLS_TYPE_NORMAL,      // NLSFEProcType
        KBDNLS_INDEX_NORMAL,     // NLSFEProcCurrent
        0,                       // NLSFEProcSwitch
        {                        // NLSFEProc
            {KBDNLS_SEND_BASE_VK,0}, // Base
            {KBDNLS_NOEVENT,0},      // Shift
            {KBDNLS_NOEVENT,0},      // Control
            {KBDNLS_NOEVENT,0},      // Shift+Control
            {KBDNLS_NOEVENT,0},      // Alt
            {KBDNLS_NOEVENT,0},      // Shift+Alt
            {KBDNLS_SEND_PARAM_VK,VK_DBE_ENTERWORDREGISTERMODE}, // Control+Alt
            {KBDNLS_SEND_PARAM_VK,VK_DBE_ENTERWORDREGISTERMODE}  // Shift+Control+Alt
        },
        {                    // NLSFEProcIndexAlt
            {KBDNLS_NULL,0},     // Base
            {KBDNLS_NULL,0},     // Shift
            {KBDNLS_NULL,0},     // Control
            {KBDNLS_NULL,0},     // Shift+Control
            {KBDNLS_NULL,0},     // Alt
            {KBDNLS_NULL,0},     // Shift+Alt
            {KBDNLS_NULL,0},     // Control+Alt
            {KBDNLS_NULL,0}      // Shift+Control+Alt
        }
    }
};

/***********************************************************************\
* KbdNlsTables
*
\***********************************************************************/

static ALLOC_SECTION_LDATA KBDNLSTABLES KbdNlsTables = {
    0,                      // OEM ID (0 = Microsoft)
    0,                      // Information
    5,                      // Number of VK_F entry
    VkToFuncTable_IBM002,   // Pointer to VK_F array
    0,                      // Pointer to MouseVk entry
    NULL                    // Pointer to MouseVk array
};

PKBDNLSTABLES KbdNlsLayerDescriptor(VOID)
{
    return &KbdNlsTables;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kbd\fe_kbds\jpn\f3ahvoas\f3ahvoas.h ===
/****************************** Module Header ******************************\
* Module Name: f3ahvoas.h
*
* Copyright (c) 1985-91, Microsoft Corporation
*
* Various defines for use by keyboard input code.
*
* History:
\***************************************************************************/

/*
 * kbd type should be controlled by cl command-line argument
 */
#define KBD_TYPE 22

/*
 * Include the basis of all keyboard table values
 */
#include "kbd.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kbd\fe_kbds\jpn\f3ahvoas\sources.inc ===
!IF 0

Copyright (c) 1989-2000  Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


!ENDIF

MINORCOMP=f3ahvoas

!include ..\..\japan.inc

SOURCES_USED=..\sources.inc

LINKLIBS=$(WUMODE_PATH)\daytona\$(O)\w32umode.lib
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kbd\fe_kbds\jpn\jpn\kbdjpn.c ===
/***************************************************************************\
* Module Name: kbdjpn.c
*
* Copyright (c) 1985-92, Microsoft Corporation
*
* History:
\***************************************************************************/


#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#if ((BASE_KEYBOARD_LAYOUT) == 101)
/*
 * include kbd101.c (PC/AT 101 English keyboard layout driver)
 */
#include "..\101\kbd101.c"
#elif ((BASE_KEYBOARD_LAYOUT) == 106)
/*
 * include kbd106.c (PC/AT 106 Japanese keyboard layout driver)
 */
#include "..\106\kbd106.c"
#else
#error "BASE_KEYBOARD_LAYOUT should be 101 or 106."
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kbd\fe_kbds\jpn\inc\kbdjpn.h ===
/****************************** Module Header ******************************\
* Module Name: kbdjpn.h
*
* Copyright (c) 1985-91, Microsoft Corporation
*
* Various defines for use by keyboard input code.
*
* History:
\***************************************************************************/
/*
 * Katakana Unicode
 */
enum _KATAKANA_UNICODE {
    WCH_IP=0xff61, // Ideographic Period
    WCH_OB,        // Opening Corner Bracket
    WCH_CB,        // Closing Corner Bracket
    WCH_IC,        // Ideographic Comma
    WCH_MD,        // Katakana Middle Dot
    WCH_WO,        // Katakana Letter WO
    WCH_AA,        // Katakana Letter Small A
    WCH_II,        // Katakana Letter Small I
    WCH_UU,        // Katakana Letter Small U
    WCH_EE,        // Katakana Letter Small E
    WCH_OO,        // Katakana Letter Small O
    WCH_YAA,       // Katakana Letter Small YA
    WCH_YUU,       // Katakana Letter Small YU
    WCH_YOO,       // Katakana Letter Small YO
    WCH_TUU,       // Katakana Letter Small TU
    WCH_PS,        // Katakana Prolonged Sound Mark
    WCH_A,         // Katakana Letter A
    WCH_I,         // Katakana Letter I
    WCH_U,         // Katakana Letter U
    WCH_E,         // Katakana Letter E
    WCH_O,         // Katakana Letter O
    WCH_KA,        // Katakana Letter KA
    WCH_KI,        // Katakana Letter KI
    WCH_KU,        // Katakana Letter KU
    WCH_KE,        // Katakana Letter KE
    WCH_KO,        // Katakana Letter KO
    WCH_SA,        // Katakana Letter SA
    WCH_SI,        // Katakana Letter SI
    WCH_SU,        // Katakana Letter SU
    WCH_SE,        // Katakana Letter SE
    WCH_SO,        // Katakana Letter SO
    WCH_TA,        // Katakana Letter TA
    WCH_TI,        // Katakana Letter TI
    WCH_TU,        // Katakana Letter TU
    WCH_TE,        // Katakana Letter TE
    WCH_TO,        // Katakana Letter TO
    WCH_NA,        // Katakana Letter NA
    WCH_NI,        // Kanakana Letter NI
    WCH_NU,        // Katakana Letter NU
    WCH_NE,        // Katakana Letter NE
    WCH_NO,        // Katakana Letter NO
    WCH_HA,        // Katakana Letter HA
    WCH_HI,        // Katakana Letter HI
    WCH_HU,        // Katakana Letter HU
    WCH_HE,        // Katakana Letter HE
    WCH_HO,        // Katakana Letter HO
    WCH_MA,        // Katakana Letter MA
    WCH_MI,        // Katakana Letter MI
    WCH_MU,        // Katakana Letter MU
    WCH_ME,        // Katakana Letter ME
    WCH_MO,        // Katakana Letter MO
    WCH_YA,        // Katakana Letter YA
    WCH_YU,        // Katakana Letter YU
    WCH_YO,        // Katakana Letter YO
    WCH_RA,        // Katakana Letter RA
    WCH_RI,        // Katakana Letter RI
    WCH_RU,        // Katakana Letter RU
    WCH_RE,        // Katakana Letter RE
    WCH_RO,        // Katakana Letter RO
    WCH_WA,        // Katakana Letter WA
    WCH_NN,        // Katakana Letter N
    WCH_VS,        // Katakana Voiced Sound Mark
    WCH_SVS        // Katakana Semi-Voiced Sound Mark
};

/***************************************************************************\
* OEM Key Name -
\***************************************************************************/

                                    // lo  hi  lo  hi
#define SZ_KEY_NAME_HENKAN          "\x09\x59\xdb\x63\000\000"
#define SZ_KEY_NAME_MUHENKAN        "\x21\x71\x09\x59\xdb\x63\000\000"
#define SZ_KEY_NAME_KANJI           "\x22\x6f\x57\x5b\000\000"
#define SZ_KEY_NAME_EISU_KANA       "\xf1\x82\x70\x65\x20\000\xab\x30\xca\x30\000\000"
#define SZ_KEY_NAME_HANKAKU_ZENKAKU "\x4a\x53\xd2\x89\x2f\000\x68\x51\xd2\x89\000\000"
#define SZ_KEY_NAME_KATAKANA        "\xab\x30\xbf\x30\xab\x30\xca\x30\000\000"
#define SZ_KEY_NAME_HIRAGANA        "\x72\x30\x89\x30\x4c\x30\x6a\x30\000\000"
// FMR Jul.13.1994 KA
// For the GetKeyNameText() API function.
#define SZ_KEY_NAME_BACKSPACE       "\x8C\x5F\x00\x90\000\000"
#define SZ_KEY_NAME_ENTER           "\x39\x65\x4C\x88\000\000"
#define SZ_KEY_NAME_NUMPADENTER     "\x4E\x00\x75\x00\x6d\x00\x20\x00\x39\x65\x4C\x88\000\000"
#define SZ_KEY_NAME_SPACE           "\x7A\x7A\x7D\x76\000\000"
#define SZ_KEY_NAME_INSERT          "\x3F\x63\x65\x51\000\000"
#define SZ_KEY_NAME_DELETE          "\x4A\x52\x64\x96\000\000"
#define SZ_KEY_NAME_KANAKANJI       "\x4b\x30\x6a\x30\x22\x6f\x57\x5b\000\000"
#define SZ_KEY_NAME_SHIFTLEFT       "\xB7\x30\xD5\x30\xC8\x30\xE6\x5D\000\000"
#define SZ_KEY_NAME_SHIFTRIGHT      "\xB7\x30\xD5\x30\xC8\x30\xF3\x53\000\000"
#define SZ_KEY_NAME_EIJI            "\xF1\x82\x57\x5B\000\000"
#define SZ_KEY_NAME_JISHO           "\x58\x53\x9E\x8A\x9E\x8F\xF8\x66\000\000"
#define SZ_KEY_NAME_MASSHOU         "\x58\x53\x9E\x8A\xB9\x62\x88\x6D\000\000"
#define SZ_KEY_NAME_TOUROKU         "\x58\x53\x9E\x8A\x7B\x76\x32\x93\000\000"
#define SZ_KEY_NAME_PRIOR           "\x4D\x52\x4C\x88\000\000"
#define SZ_KEY_NAME_NEXT            "\x21\x6B\x4C\x88\000\000"
#define SZ_KEY_NAME_CANCEL          "\xD6\x53\x88\x6D\000\000"
#define SZ_KEY_NAME_EXECUTE         "\x9F\x5B\x4C\x88\000\000"
#define SZ_KEY_NAME_TAB             "\xBF\x30\xD6\x30\000\000"


//----------------------[ NEC Code Original Start ]-----------------
                    // ff76(ka) ff85(na) for Unicode
#define SZ_KEY_NAME_KANA        "\x76\xff\x85\xff"
#define SZ_KEY_NAME_F1          "\x66\x00\x65\xff\x31\x00"
#define SZ_KEY_NAME_F2          "\x66\x00\x65\xff\x32\x00"
#define SZ_KEY_NAME_F3          "\x66\x00\x65\xff\x33\x00"
#define SZ_KEY_NAME_F4          "\x66\x00\x65\xff\x34\x00"
#define SZ_KEY_NAME_F5          "\x66\x00\x65\xff\x35\x00"
#define SZ_KEY_NAME_F6          "\x66\x00\x65\xff\x36\x00"
#define SZ_KEY_NAME_F7          "\x66\x00\x65\xff\x37\x00"
#define SZ_KEY_NAME_F8          "\x66\x00\x65\xff\x38\x00"
#define SZ_KEY_NAME_F9          "\x66\x00\x65\xff\x39\x00"
#define SZ_KEY_NAME_F10         "\x66\x00\x65\xff\x31\x00\x30\x00"
#define SZ_KEY_NAME_F11         "\x66\x00\x65\xff\x31\x00\x31\x00"
#define SZ_KEY_NAME_F12         "\x66\x00\x65\xff\x31\x00\x32\x00"
#define SZ_KEY_NAME_F13         "\x66\x00\x65\xff\x31\x00\x33\x00"
#define SZ_KEY_NAME_F14         "\x66\x00\x65\xff\x31\x00\x34\x00"
#define SZ_KEY_NAME_F15         "\x66\x00\x65\xff\x31\x00\x35\x00"

//----------------------[ NEC Code Original Start ]-----------------
//This is NEC Document Processer define
//
#define SZ_KEY_NAME_DP_ZENKAKU_HANKAKU "\x68\x51\xd2\x89\x2f\000\x4a\x53\xd2\x89\000\000"
#define SZ_KEY_NAME_DP_KANA            "\x4b\x30\x6a\x30\000\000"
#define SZ_KEY_NAME_DP_KATAKANA        "\xab\x30\xbf\x30\xab\x30\xca\x30\000\000"
#define SZ_KEY_NAME_DP_EISU            "\xf1\x82\x70\x65\000\000"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kbd\fe_kbds\jpn\jpn\sources.inc ===
!IF 0

Copyright (c) 1989-2000  Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


!ENDIF

MINORCOMP=kbdjpn

!include ..\..\japan.inc

SOURCES_USED=..\sources.inc

TARGETLIBS=$(SDK_LIB_PATH)\ntdll.lib
LINKLIBS=..\..\..\common\$(ALT_PROJECT)\$(O)\fekbdcom.lib

INCLUDES=$(INCLUDES);..\;..\inc;$(NTUSER_PATH)\inc;..\$(BASE_KEYBOARD_LAYOUT)

C_DEFINES=$(C_DEFINES) -DBASE_KEYBOARD_LAYOUT=$(BASE_KEYBOARD_LAYOUT)

BASE_KEYBOARD_LAYOUT=101

SOURCES=    kbdjpn.rc \
            kbdjpn.c \
            multi.c
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kbd\fe_kbds\jpn\jpn\multi.c ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windef.h>
#include <kbd.h>

BOOL EnumDynamicSwitchingLayouts(LPCWSTR lpwszBaseDll, PKBDTABLE_MULTI pKbdTableMulti);

BOOL KbdLayerMultiDescriptor(PKBDTABLE_MULTI pKbdTableMulti)
{
    /*
     * Firstly, try to get the setting from the registry.
     */
    if (EnumDynamicSwitchingLayouts(L"kbdjpn", pKbdTableMulti)) {
        return TRUE;
    }

    /*
     * If we failed to get the registry, set the default ones.
     */
    pKbdTableMulti->nTables = 3;

    wcscpy(pKbdTableMulti->aKbdTables[0].wszDllName, L"kbd101.dll");
    pKbdTableMulti->aKbdTables[0].dwType = 4;
    pKbdTableMulti->aKbdTables[0].dwSubType = MAKEWORD(MICROSOFT_KBD_101_TYPE, NLSKBD_OEM_MICROSOFT);

    wcscpy(pKbdTableMulti->aKbdTables[1].wszDllName, L"kbd106.dll");
    pKbdTableMulti->aKbdTables[1].dwType = 7;
    pKbdTableMulti->aKbdTables[1].dwSubType = MAKEWORD(MICROSOFT_KBD_106_TYPE, NLSKBD_OEM_MICROSOFT);

    wcscpy(pKbdTableMulti->aKbdTables[2].wszDllName, L"kbdnec.dll");
    pKbdTableMulti->aKbdTables[2].dwType = 7;
    pKbdTableMulti->aKbdTables[2].dwSubType = MAKEWORD(NEC_KBD_N_MODE_TYPE, NLSKBD_OEM_NEC);

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kbd\fe_kbds\jpn\kbdnec\sources.inc ===
!IF 0

Copyright (c) 1989-2000  Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


!ENDIF

MINORCOMP=kbdnec

!include ..\..\japan.inc

SOURCES_USED=..\sources.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kbd\fe_kbds\jpn\kbdnec\kbdnec.c ===
/***************************************************************************\
* Module Name: kbdnec.c
*
* Copyright (c) 1985-98, Microsoft Corporation
*
* History:
\***************************************************************************/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <ime.h>
#include "vkoem.h"
#include "kbdjpn.h"
#include "kbdnec.h"

#if defined(_M_IA64)
#pragma section(".data")
#define ALLOC_SECTION_LDATA __declspec(allocate(".data"))
#else
#pragma data_seg(".data")
#define ALLOC_SECTION_LDATA
#endif

/***************************************************************************\
* ausVK[] - Virtual Scan Code to Virtual Key conversion table for NEC KBD
\***************************************************************************/

static ALLOC_SECTION_LDATA USHORT ausVK[] = {
    T00, T01, T02, T03, T04, T05, T06, T07,
    T08, T09, T0A, T0B, T0C, T0D, T0E, T0F,
    T10, T11, T12, T13, T14, T15, T16, T17,
    T18, T19, T1A, T1B, T1C, T1D, T1E, T1F,
    T20, T21, T22, T23, T24, T25, T26, T27,
    T28,

    /*
     * Hankaku/Zenkaku/Kanji key must have KBDSPECIAL bit set (NLS key)
     */
    T29 | KBDSPECIAL,

              T2A, T2B, T2C, T2D, T2E, T2F,
    T30, T31, T32, T33, T34, T35,

    /*
     * Right-hand Shift key must have KBDEXT bit set.
     */
    T36 | KBDEXT,

    T37,

    T38, T39,

    T3A,

                   T3B, T3C, T3D, T3E, T3F,
    T40, T41, T42, T43, T44,

    /*
     * NumLock Key:
     *     KBDEXT     - VK_NUMLOCK is an Extended key
     *     KBDMULTIVK - VK_NUMLOCK or VK_PAUSE (without or with CTRL)
     */
    T45 | KBDEXT | KBDMULTIVK,

    T46,

    /*
     * Number Pad keys:
     *     KBDNUMPAD  - digits 0-9 and decimal point.
     *     KBDSPECIAL - require special processing by Windows
     */
    T47 | KBDNUMPAD | KBDSPECIAL,   // Numpad 7 (Home)
    T48 | KBDNUMPAD | KBDSPECIAL,   // Numpad 8 (Up),
    T49 | KBDNUMPAD | KBDSPECIAL,   // Numpad 9 (PgUp),
    T4A,
    T4B | KBDNUMPAD | KBDSPECIAL,   // Numpad 4 (Left),
    T4C | KBDNUMPAD | KBDSPECIAL,   // Numpad 5 (Clear),
    T4D | KBDNUMPAD | KBDSPECIAL,   // Numpad 6 (Right),
    T4E,
    T4F | KBDNUMPAD | KBDSPECIAL,   // Numpad 1 (End),
    T50 | KBDNUMPAD | KBDSPECIAL,   // Numpad 2 (Down),
    T51 | KBDNUMPAD | KBDSPECIAL,   // Numpad 3 (PgDn),
    T52 | KBDNUMPAD | KBDSPECIAL,   // Numpad 0 (Ins),
    T53 | KBDNUMPAD | KBDSPECIAL,   // Numpad . (Del),

    T54, T55, T56, T57, T58,
    T59 | KBDSPECIAL,               // TenKey EQU (VK_SCROLL)
                                  T5A, T5B,

    T5C, T5D, T5E, T5F, T60, T61, T62, T63,
    T64, T65, T66, T67, T68, T69, T6A, T6B,
    T6C, T6D, T6E, T6F,

    /*
     * Hiragana/Katakana/Roman key must have KBDSPECIAL bit set (NLS key)
     */
    T70,

                             T71, T72, T73,
    T74, T75, T76, T77, T78,

    /*
     * Conversion key must have KBDSPECIAL bit set (NLS key)
     */
    T79 | KBDSPECIAL,

                                  T7A,

    /*
     * Non-Conversion key must have KBDSPECIAL bit set (NLS key)
     */
    T7B | KBDSPECIAL,

    T7C, T7D, T7E, T7F
};

static ALLOC_SECTION_LDATA VSC_VK aE0VscToVk[] = {
        { 0x1C, X1C | KBDEXT              },  // Numpad Enter
        { 0x1D, X1D | KBDEXT              },  // RControl
        { 0x35, X35 | KBDEXT              },  // Numpad Divide
        { 0x37, X37 | KBDEXT              },  // Snapshot
        { 0x38, X38 | KBDEXT              },  // RMenu
        { 0x46, X46 | KBDEXT              },  // Break (Ctrl + Pause)
        { 0x47, X47 | KBDEXT | KBDSPECIAL },  // CLR HOME
        { 0x48, X48 | KBDEXT              },  // Up
        { 0x49, X49 | KBDEXT              },  // Prior
        { 0x4B, X4B | KBDEXT              },  // Left
        { 0x4D, X4D | KBDEXT              },  // Right
        { 0x4F, X4F | KBDEXT | KBDSPECIAL },  // HELP
        { 0x50, X50 | KBDEXT              },  // Down
        { 0x51, X51 | KBDEXT              },  // Next
        { 0x52, X52 | KBDEXT              },  // Insert
        { 0x53, X53 | KBDEXT              },  // Delete
        { 0x5B, X5B | KBDEXT              },  // Left Win
        { 0x5C, X5C | KBDEXT              },  // Right Win
        { 0x5D, X5D | KBDEXT              },  // Application
        { 0,      0                       }
};

static ALLOC_SECTION_LDATA VSC_VK aE1VscToVk[] = {
        { 0x1D, Y1D                       },  // Pause
        { 0   ,   0                       }
};

/***************************************************************************\
* aVkToBits[]  - map Virtual Keys to Modifier Bits
*
* See kbd.h for a full description.
*
* US Keyboard has only three shifter keys:
*     SHIFT (L & R) affects alphabnumeric keys,
*     CTRL  (L & R) is used to generate control characters
*     ALT   (L & R) used for generating characters by number with numpad
\***************************************************************************/

static ALLOC_SECTION_LDATA VK_TO_BIT aVkToBits[] = {
    { VK_SHIFT,   KBDSHIFT },
    { VK_CONTROL, KBDCTRL  },
    { VK_MENU,    KBDALT   },
    { VK_KANA,    KBDKANA  },
    { 0,          0        }
};

/***************************************************************************\
* aModification[]  - map character modifier bits to modification number
*
* See kbd.h for a full description.
*
\***************************************************************************/

static ALLOC_SECTION_LDATA MODIFIERS CharModifiers = {
    &aVkToBits[0],
    11,
    {
    //  Modification# //  Keys Pressed  : Explanation
    //  ============= // ============== : =============================
        0,            //                : unshifted characters
        1,            //          SHIFT : capitals, ~!@#$%^&*()_+{}:"<>? etc.
        4,            //     CTRL       : control characters
        6,            //     CTRL SHIFT :
        SHFT_INVALID, // ALT            : invalid
        SHFT_INVALID, // ALT      SHIFT : invalid
        SHFT_INVALID, // ALT CTRL       : invalid
        SHFT_INVALID, // ALT CTRL SHIFT : invalid
        2,            //KANA
        3,            //KANA      SHIFT
        5,            //KANA CTRL
        7             //KANA CTRL SHIFT
    }
};

/***************************************************************************\
*
* aVkToWch2[]  - Virtual Key to WCHAR translation for 2 shift states
* aVkToWch3[]  - Virtual Key to WCHAR translation for 3 shift states
* aVkToWch4[]  - Virtual Key to WCHAR translation for 4 shift states
*
* Table attributes: Unordered Scan, null-terminated
*
* Search this table for an entry with a matching Virtual Key to find the
* corresponding unshifted and shifted WCHAR characters.
*
* Reserved VirtualKey values (first column)
*     -1            - this line contains dead characters (diacritic)
*     0             - terminator
*
* Reserved Attribute values (second column)
*     CAPLOK        - CapsLock affects this key like Shift
*     KANALOK       - The KANA-LOCK key affects this key like KANA
*
* Reserved character values (third through last column)
*     WCH_NONE      - No character
*     WCH_DEAD      - Dead character (diacritic) value is in next line
*
\***************************************************************************/

static ALLOC_SECTION_LDATA VK_TO_WCHARS4 aVkToWch4[] = {
    //                               |          |   SHIFT  |  KANA  | K+SHFT |
    //                               |          |==========|========|========|
    {'0'          ,          KANALOK ,'0'       ,'0'       ,WCH_WA  ,WCH_WO  },
    {'1'          ,          KANALOK ,'1'       ,'!'       ,WCH_NU  ,WCH_NU  },
    {'3'          ,          KANALOK ,'3'       ,'#'       ,WCH_A   ,WCH_AA  },
    {'4'          ,          KANALOK ,'4'       ,'$'       ,WCH_U   ,WCH_UU  },
    {'5'          ,          KANALOK ,'5'       ,'%'       ,WCH_E   ,WCH_EE  },
    {'7'          ,          KANALOK ,'7'       ,0x27      ,WCH_YA  ,WCH_YAA },
    {'8'          ,          KANALOK ,'8'       ,'('       ,WCH_YU  ,WCH_YUU },
    {'9'          ,          KANALOK ,'9'       ,')'       ,WCH_YO  ,WCH_YOO },
    {'A'          , CAPLOK | KANALOK ,'a'       ,'A'       ,WCH_TI  ,WCH_TI  },
    {'B'          , CAPLOK | KANALOK ,'b'       ,'B'       ,WCH_KO  ,WCH_KO  },
    {'C'          , CAPLOK | KANALOK ,'c'       ,'C'       ,WCH_SO  ,WCH_SO  },
    {'D'          , CAPLOK | KANALOK ,'d'       ,'D'       ,WCH_SI  ,WCH_SI  },
    {'E'          , CAPLOK | KANALOK ,'e'       ,'E'       ,WCH_I   ,WCH_II  },
    {'F'          , CAPLOK | KANALOK ,'f'       ,'F'       ,WCH_HA  ,WCH_HA  },
    {'G'          , CAPLOK | KANALOK ,'g'       ,'G'       ,WCH_KI  ,WCH_KI  },
    {'H'          , CAPLOK | KANALOK ,'h'       ,'H'       ,WCH_KU  ,WCH_KU  },
    {'I'          , CAPLOK | KANALOK ,'i'       ,'I'       ,WCH_NI  ,WCH_NI  },
    {'J'          , CAPLOK | KANALOK ,'j'       ,'J'       ,WCH_MA  ,WCH_MA  },
    {'K'          , CAPLOK | KANALOK ,'k'       ,'K'       ,WCH_NO  ,WCH_NO  },
    {'L'          , CAPLOK | KANALOK ,'l'       ,'L'       ,WCH_RI  ,WCH_RI  },
    {'M'          , CAPLOK | KANALOK ,'m'       ,'M'       ,WCH_MO  ,WCH_MO  },
    {'N'          , CAPLOK | KANALOK ,'n'       ,'N'       ,WCH_MI  ,WCH_MI  },
    {'O'          , CAPLOK | KANALOK ,'o'       ,'O'       ,WCH_RA  ,WCH_RA  },
    {'P'          , CAPLOK | KANALOK ,'p'       ,'P'       ,WCH_SE  ,WCH_SE  },
    {'Q'          , CAPLOK | KANALOK ,'q'       ,'Q'       ,WCH_TA  ,WCH_TA  },
    {'R'          , CAPLOK | KANALOK ,'r'       ,'R'       ,WCH_SU  ,WCH_SU  },
    {'S'          , CAPLOK | KANALOK ,'s'       ,'S'       ,WCH_TO  ,WCH_TO  },
    {'T'          , CAPLOK | KANALOK ,'t'       ,'T'       ,WCH_KA  ,WCH_KA  },
    {'U'          , CAPLOK | KANALOK ,'u'       ,'U'       ,WCH_NA  ,WCH_NA  },
    {'V'          , CAPLOK | KANALOK ,'v'       ,'V'       ,WCH_HI  ,WCH_HI  },
    {'W'          , CAPLOK | KANALOK ,'w'       ,'W'       ,WCH_TE  ,WCH_TE  },
    {'X'          , CAPLOK | KANALOK ,'x'       ,'X'       ,WCH_SA  ,WCH_SA  },
    {'Y'          , CAPLOK | KANALOK ,'y'       ,'Y'       ,WCH_NN  ,WCH_NN  },
    {'Z'          , CAPLOK | KANALOK ,'z'       ,'Z'       ,WCH_TU  ,WCH_TUU },
    {VK_OEM_1     ,          KANALOK ,':'       ,'*'       ,WCH_KE  ,WCH_KE  },
    {VK_OEM_2     ,          KANALOK ,'/'       ,'?'       ,WCH_ME  ,WCH_MD  },
    {VK_OEM_COMMA ,          KANALOK ,','       ,'<'       ,WCH_NE  ,WCH_IC  },
    {VK_OEM_PERIOD,          KANALOK ,'.'       ,'>'       ,WCH_RU  ,WCH_IP  },
    {VK_OEM_PLUS  ,          KANALOK ,';'       ,'+'       ,WCH_RE  ,WCH_RE  },
    {VK_TAB       , 0                ,'\t'      ,'\t'      ,'\t'    ,'\t'    },
    {VK_ADD       , 0                ,'+'       ,'+'       ,'+'     ,'+'     },
    {VK_DECIMAL   , 0                ,'.'       ,'.'       ,'.'     ,'.'     },
    {VK_DIVIDE    , 0                ,'/'       ,'/'       ,'/'     ,'/'     },
    {VK_MULTIPLY  , 0                ,'*'       ,'*'       ,'*'     ,'*'     },
    {VK_SUBTRACT  , 0                ,'-'       ,'-'       ,'-'     ,'-'     },
    {VK_SEPARATOR , 0                ,','       ,','       ,','     ,','     },
    {VK_OEM_NEC_EQUAL,    0          ,'='       ,'='       ,'='     ,'='     },
    {0            , 0                ,0         ,0         ,0       ,0       }
};

static ALLOC_SECTION_LDATA VK_TO_WCHARS6 aVkToWch6[] = {
    //                      |          |   SHIFT  |  KANA  | K+SHFT |  CONTROL  |  K+CTRL   |
    //                      |          |==========|========|========|===========|===========|
    {VK_BACK      , 0       ,'\b'      ,'\b'      ,'\b'    ,'\b'    , 0x7f      , 0x7f      },
    {VK_CANCEL    , 0       ,0x03      ,0x03      ,0x03    ,0x03    , 0x03      , 0x03      },
    {VK_ESCAPE    , 0       ,0x1b      ,0x1b      ,0x1b    ,0x1b    , 0x1b      , 0x1b      },
    {VK_OEM_3     , KANALOK ,'@'       ,'~'       ,WCH_VS  ,WCH_VS  , 0x00      , 0x00      },
    {VK_OEM_4     , KANALOK ,'['       ,'{'       ,WCH_SVS ,WCH_OB  , 0x1b      , 0x1b      },
    {VK_OEM_5     , KANALOK ,'\\'      ,'|'       ,WCH_PS  ,WCH_PS  , 0x1c      , 0x1c      },
    {VK_OEM_6     , KANALOK ,']'       ,'}'       ,WCH_MU  ,WCH_CB  , 0x1d      , 0x1d      },
    {VK_OEM_7     , KANALOK ,'^'       ,'`'       ,WCH_HE  ,WCH_HE  , 0x1e      , 0x1e      },
    {VK_OEM_8     , KANALOK ,WCH_NONE  ,'_'       ,WCH_RO  ,WCH_RO  , 0x1f      , 0x1f      },
    {VK_RETURN    , 0       ,'\r'      ,'\r'      ,'\r'    ,'\r'    , '\n'      , '\n'      },
    {VK_SPACE     , 0       ,' '       ,' '       ,' '     ,' '     , 0x20      , 0x20      },
    {0            , 0       ,0         ,0         ,0       ,0       , 0         , 0         }
};

static ALLOC_SECTION_LDATA VK_TO_WCHARS8 aVkToWch8[] = {
    //                      |          |   SHIFT  |  KANA  | K+SHFT |  CONTROL  |  K+CTRL   | SHFT+CTRL |K+SHFT+CTRL|
    //                      |          |==========|========|========|===========|===========|===========|===========|
    {'2'          , KANALOK ,'2'       ,'"'       ,WCH_HU  ,WCH_HU  , WCH_NONE  , WCH_NONE  , 0x00      , 0x00      },
    {'6'          , KANALOK ,'6'       ,'&'       ,WCH_O   ,WCH_OO  , WCH_NONE  , WCH_NONE  , 0x1e      , 0x1e      },
    {VK_OEM_MINUS , KANALOK ,'-'       ,'='       ,WCH_HO  ,WCH_HO  , WCH_NONE  , WCH_NONE  , 0x1f      , 0x1f      },
    {0            , 0       ,0         ,0         ,0       ,0       , 0         , 0         , 0         , 0         }
};

// Put this last so that VkKeyScan interprets number characters
// as coming from the main section of the kbd (aVkToWch2 and
// aVkToWch4) before considering the numpad (aVkToWch1).

static ALLOC_SECTION_LDATA VK_TO_WCHARS4 aVkToWch1[] = {
    //                     |          |   SHIFT  |  KANA  | K+SHFT |
    //                     |          |==========|========|========|
    { VK_NUMPAD0   , 0      ,  '0'    , WCH_NONE ,   '0'  ,WCH_NONE},
    { VK_NUMPAD1   , 0      ,  '1'    , WCH_NONE ,   '1'  ,WCH_NONE},
    { VK_NUMPAD2   , 0      ,  '2'    , WCH_NONE ,   '2'  ,WCH_NONE},
    { VK_NUMPAD3   , 0      ,  '3'    , WCH_NONE ,   '3'  ,WCH_NONE},
    { VK_NUMPAD4   , 0      ,  '4'    , WCH_NONE ,   '4'  ,WCH_NONE},
    { VK_NUMPAD5   , 0      ,  '5'    , WCH_NONE ,   '5'  ,WCH_NONE},
    { VK_NUMPAD6   , 0      ,  '6'    , WCH_NONE ,   '6'  ,WCH_NONE},
    { VK_NUMPAD7   , 0      ,  '7'    , WCH_NONE ,   '7'  ,WCH_NONE},
    { VK_NUMPAD8   , 0      ,  '8'    , WCH_NONE ,   '8'  ,WCH_NONE},
    { VK_NUMPAD9   , 0      ,  '9'    , WCH_NONE ,   '9'  ,WCH_NONE},
    { 0            , 0      ,  '\0'   , 0        ,   0    ,0       }   //null terminator
};

/***************************************************************************\
* aVkToWcharTable: table of pointers to Character Tables
*
* Describes the character tables and the order they should be searched.
*
* Note: the order determines the behavior of VkKeyScan() : this function
*       takes a character and attempts to find a Virtual Key and character-
*       modifier key combination that produces that character.  The table
*       containing the numeric keypad (aVkToWch1) must appear last so that
*       VkKeyScan('0') will be interpreted as one of keys from the main
*       section, not the numpad.  etc.
\***************************************************************************/

static ALLOC_SECTION_LDATA VK_TO_WCHAR_TABLE aVkToWcharTable[] = {
    {  (PVK_TO_WCHARS1)aVkToWch6, 6, sizeof(aVkToWch6[0]) },
    {  (PVK_TO_WCHARS1)aVkToWch8, 8, sizeof(aVkToWch8[0]) },
    {  (PVK_TO_WCHARS1)aVkToWch4, 4, sizeof(aVkToWch4[0]) },
    {  (PVK_TO_WCHARS1)aVkToWch1, 4, sizeof(aVkToWch1[0]) },  // must come last
    {                       NULL, 0, 0                    }
};

/***************************************************************************\
* aKeyNames[], aKeyNamesExt[]  - Scan Code -> Key Name tables
*
* For the GetKeyNameText() API function
*
* Tables for non-extended and extended (KBDEXT) keys.
* (Keys producing printable characters are named by the character itself)
\***************************************************************************/

static ALLOC_SECTION_LDATA VSC_LPWSTR aKeyNames[] = {
    0x01,    L"Esc",
    0x0e,    L"Backspace",
    0x0f,    L"Tab",
    0x1c,    L"Enter",
    0x1d,    L"Ctrl",
    0x29,    (LPWSTR)SZ_KEY_NAME_HANKAKU_ZENKAKU,  // NLS Key
    0x2a,    L"Shift",
    0x36,    L"Right Shift",
    0x37,    L"Num *",
    0x38,    L"Alt",
    0x39,    L"Space",
    0x3a,    L"Caps Lock",
    0x3b,    L"F1",
    0x3c,    L"F2",
    0x3d,    L"F3",
    0x3e,    L"F4",
    0x3f,    L"F5",
    0x40,    L"F6",
    0x41,    L"F7",
    0x42,    L"F8",
    0x43,    L"F9",
    0x44,    L"F10",
    0x45,    L"Pause",
    0x46,    L"Scroll Lock",
    0x47,    L"Num 7",
    0x48,    L"Num 8",
    0x49,    L"Num 9",
    0x4a,    L"Num -",
    0x4b,    L"Num 4",
    0x4c,    L"Num 5",
    0x4d,    L"Num 6",
    0x4e,    L"Num +",
    0x4f,    L"Num 1",
    0x50,    L"Num 2",
    0x51,    L"Num 3",
    0x52,    L"Num 0",
    0x53,    L"Num Del",
    0x54,    L"Sys Req",
    0x57,    L"F11",
    0x58,    L"F12",
    0x59,    L"Num =",
    0x5C,    L"Num ,",
    0x5D,    L"F13",    // vf3
    0x5E,    L"F14",    // vf4
    0x5F,    L"F15",    // vf5
    0x70,    (LPWSTR)SZ_KEY_NAME_KANA,    // NLS Key Kana
    0x79,    L"XFER",
    0x7b,    L"NFER",
    0   ,    NULL
};

static ALLOC_SECTION_LDATA VSC_LPWSTR aKeyNamesExt[] = {
    0x1c,    L"Num Enter",
    0x1d,    L"Right Control",
    0x35,    L"Num /",
    0x37,    L"Prnt Scrn",
    0x38,    L"Right Alt",
    0x45,    L"Num Lock",
    0x46,    L"Break",
    0x47,    L"Home",
    0x48,    L"Up",
    0x49,    L"Page Up",
    0x4b,    L"Left",
    0x4d,    L"Right",
    0x4f,    L"End",
    0x50,    L"Down",
    0x51,    L"Page Down",
    0x52,    L"Insert",
    0x53,    L"Delete",
    0x5B,    L"Left Windows",
    0x5C,    L"Right Windows",
    0x5D,    L"Application",
    0   ,    NULL
};

ALLOC_SECTION_LDATA KBDTABLES KbdTablesNec = {
    /*
     * Modifier keys
     */
    &CharModifiers,

    /*
     * Characters tables
     */
    aVkToWcharTable,

    /*
     * Diacritics  (none for US English)
     */
    NULL,

    /*
     * Names of Keys  (no dead keys)
     */
    aKeyNames,
    aKeyNamesExt,
    NULL,

    /*
     * Scan codes to Virtual Keys
     */
    ausVK,
    sizeof(ausVK) / sizeof(ausVK[0]),
    aE0VscToVk,
    aE1VscToVk,

    /*
     * No Locale-specific special processing
     */
    0,

    /*
     * No Ligatures
     */
    0, 0, NULL,

    /*
     * Type and subtype.
     */
    KEYBOARD_TYPE_JAPAN,    // Japanese Keyboard Layout
    MAKEWORD(NEC_KBD_N_MODE_TYPE, NLSKBD_OEM_NEC),
};

PKBDTABLES KbdLayerDescriptor(VOID)
{
    return &KbdTablesNec;
}

/***********************************************************************\
* VkToFuncTable_NEC[]
*
\***********************************************************************/

static ALLOC_SECTION_LDATA VK_F VkToFuncTable_NEC[] = {
    {
        VK_DBE_SBCSCHAR,     // Base Vk
        KBDNLS_TYPE_NORMAL,  // NLSFEProcType
        KBDNLS_INDEX_NORMAL, // NLSFEProcCurrent
        0x0,                 // NLSFEProcSwitch
        {                    // NLSFEProc
            {KBDNLS_SBCSDBCS,0},             // Base
            {KBDNLS_SBCSDBCS,0},             // Shift
            {KBDNLS_SBCSDBCS,0},             // Control
            {KBDNLS_SBCSDBCS,0},             // Shift+Control
            {KBDNLS_SBCSDBCS,0},             // Alt
            {KBDNLS_SBCSDBCS,0},             // Shift+Alt
            {KBDNLS_SEND_PARAM_VK,VK_DBE_ENTERIMECONFIGMODE}, // Control+Alt
            {KBDNLS_SEND_PARAM_VK,VK_DBE_ENTERIMECONFIGMODE}  // Shift+Control+Alt
        },
        {                    // NLSFEProcIndexAlt
            {KBDNLS_NULL,0},  // Base
            {KBDNLS_NULL,0},  // Shift
            {KBDNLS_NULL,0},  // Control
            {KBDNLS_NULL,0},  // Shift+Control
            {KBDNLS_NULL,0},  // Alt
            {KBDNLS_NULL,0},  // Shift+Alt
            {KBDNLS_NULL,0},  // Control+Alt
            {KBDNLS_NULL,0}   // Shift+Control+Alt
        }
    },
    {
        VK_NONCONVERT,       // Base Vk  PC98_NFER key
        KBDNLS_TYPE_NORMAL,  // NLSFEProcType
        KBDNLS_INDEX_NORMAL, // NLSFEProcCurrent
        0x0,                 // NLSFEProcSwitch
        {                    // NLSFEProc
            {KBDNLS_SEND_BASE_VK,0},                             // Base
            {KBDNLS_SEND_BASE_VK,0},                             // Shift
            {KBDNLS_SEND_PARAM_VK,VK_DBE_ALPHANUMERIC},          // Control
            {KBDNLS_SBCSDBCS,0},                                 // Shift+Control
            {KBDNLS_SEND_PARAM_VK,VK_DBE_KATAKANA},              // Alt
            {KBDNLS_SEND_PARAM_VK,VK_DBE_ENTERWORDREGISTERMODE}, // Shift+Alt
            {KBDNLS_SEND_PARAM_VK,VK_DBE_NOCODEINPUT},           // Control+Alt
            {KBDNLS_SEND_PARAM_VK,VK_DBE_FLUSHSTRING}            // Shift+Control+Alt
        },
        {                     // NLSFEProcIndexAlt
            {KBDNLS_NULL,0},  // Base
            {KBDNLS_NULL,0},  // Shift
            {KBDNLS_NULL,0},  // Control
            {KBDNLS_NULL,0},  // Shift+Control
            {KBDNLS_NULL,0},  // Alt
            {KBDNLS_NULL,0},  // Shift+Alt
            {KBDNLS_NULL,0},  // Control+Alt
            {KBDNLS_NULL,0}   // Shift+Control+Alt
        }
    },
    {
        VK_CONVERT,            // Base Vk  PC98_XFER key
        KBDNLS_TYPE_NORMAL,  // NLSFEProcType
        KBDNLS_INDEX_NORMAL, // NLSFEProcCurrent
        0x0,                 // NLSFEProcSwitch
        {                    // NLSFEProc
            {KBDNLS_SEND_BASE_VK,0},                          // Base
            {KBDNLS_SEND_BASE_VK,0},                          // Shift
            {KBDNLS_SEND_PARAM_VK,VK_KANJI},                  // Control
            {KBDNLS_SEND_BASE_VK,0},                          // Shift+Control
            {KBDNLS_ROMAN,0},                                 // Alt
            {KBDNLS_SEND_PARAM_VK,VK_DBE_ENTERIMECONFIGMODE}, // Shift+Alt
            {KBDNLS_SEND_PARAM_VK,VK_DBE_CODEINPUT},          // Control+Alt
            {KBDNLS_SEND_PARAM_VK,VK_DBE_HIRAGANA}            // Shift+Control+Alt
        },
        {                     // NLSFEProcIndexAlt
            {KBDNLS_NULL,0},  // Base
            {KBDNLS_NULL,0},  // Shift
            {KBDNLS_NULL,0},  // Control
            {KBDNLS_NULL,0},  // Shift+Control
            {KBDNLS_NULL,0},  // Alt
            {KBDNLS_NULL,0},  // Shift+Alt
            {KBDNLS_NULL,0},  // Control+Alt
            {KBDNLS_NULL,0}   // Shift+Control+Alt
        }
    },
    {
        VK_OEM_NEC_EQUAL,    // Base Vk NEC98_"="  key
        KBDNLS_TYPE_NORMAL,  // NLSFEProcType
        KBDNLS_INDEX_NORMAL, // NLSFEProcCurrent
        0x0,                 // NLSFEProcSwitch
        {                    // NLSFEProc
            {KBDNLS_SEND_BASE_VK,0},                  // Base
            {KBDNLS_SEND_BASE_VK,0},                  // Shift
            {KBDNLS_SEND_PARAM_VK,VK_SCROLL},         // Control
            {KBDNLS_SEND_BASE_VK,0},                  // Shift+Control
            {KBDNLS_SEND_BASE_VK,0},                  // Alt
            {KBDNLS_SEND_BASE_VK,0},                  // Shift+Alt
            {KBDNLS_SEND_BASE_VK,0},                  // Control+Alt
            {KBDNLS_SEND_BASE_VK,0}                   // Shift+Control+Alt
        },
        {                     // NLSFEProcIndexAlt
            {KBDNLS_NULL,0},  // Base
            {KBDNLS_NULL,0},  // Shift
            {KBDNLS_NULL,0},  // Control
            {KBDNLS_NULL,0},  // Shift+Control
            {KBDNLS_NULL,0},  // Alt
            {KBDNLS_NULL,0},  // Shift+Alt
            {KBDNLS_NULL,0},  // Control+Alt
            {KBDNLS_NULL,0}   // Shift+Control+Alt
        }
    },
    {
        VK_HOME,             // Base Vk  PC98_HOME  key
        KBDNLS_TYPE_NORMAL,  // NLSFEProcType
        KBDNLS_INDEX_NORMAL, // NLSFEProcCurrent
        0x0,                 // NLSFEProcSwitch
        {                    // NLSFEProc
            {KBDNLS_HOME_OR_CLEAR,0},         // Base
            {KBDNLS_SEND_BASE_VK,0},          // Shift
            {KBDNLS_HOME_OR_CLEAR,0},         // Control
            {KBDNLS_HOME_OR_CLEAR,0},         // Shift+Control
            {KBDNLS_HOME_OR_CLEAR,0},         // Alt
            {KBDNLS_HOME_OR_CLEAR,0},         // Shift+Alt
            {KBDNLS_HOME_OR_CLEAR,0},         // Control+Alt
            {KBDNLS_HOME_OR_CLEAR,0}          // Shift+Control+Alt
        },
        {                     // NLSFEProcIndexAlt
            {KBDNLS_NULL,0},  // Base
            {KBDNLS_NULL,0},  // Shift
            {KBDNLS_NULL,0},  // Control
            {KBDNLS_NULL,0},  // Shift+Control
            {KBDNLS_NULL,0},  // Alt
            {KBDNLS_NULL,0},  // Shift+Alt
            {KBDNLS_NULL,0},  // Control+Alt
            {KBDNLS_NULL,0}   // Shift+Control+Alt
        }
    },
    {
        VK_END,              // Base Vk  PC98_HELP  key
        KBDNLS_TYPE_NORMAL,  // NLSFEProcType
        KBDNLS_INDEX_NORMAL, // NLSFEProcCurrent
        0x0,                 // NLSFEProcSwitch
        {                    // NLSFEProc
            {KBDNLS_HELP_OR_END,0},         // Base
            {KBDNLS_HELP_OR_END,0},         // Shift
            {KBDNLS_HELP_OR_END,0},         // Control
            {KBDNLS_HELP_OR_END,0},         // Shift+Control
            {KBDNLS_HELP_OR_END,0},         // Alt
            {KBDNLS_HELP_OR_END,0},         // Shift+Alt
            {KBDNLS_HELP_OR_END,0},         // Control+Alt
            {KBDNLS_HELP_OR_END,0}          // Shift+Control+Alt
        },
        {                     // NLSFEProcIndexAlt
            {KBDNLS_NULL,0},  // Base
            {KBDNLS_NULL,0},  // Shift
            {KBDNLS_NULL,0},  // Control
            {KBDNLS_NULL,0},  // Shift+Control
            {KBDNLS_NULL,0},  // Alt
            {KBDNLS_NULL,0},  // Shift+Alt
            {KBDNLS_NULL,0},  // Control+Alt
            {KBDNLS_NULL,0}   // Shift+Control+Alt
        }
    }
};

USHORT ausMouseVKey98[] = {
                       VK_CLEAR,           // Numpad 5: Click active button
                       VK_PRIOR,           // Numpad 9: Up & Right
                       VK_NEXT,            // Numpad 3: Down & Right
                       VK_END,             // Numpad 1: Down & Left
                       VK_HOME,            // Numpad 7: Up & Left
                       VK_LEFT,            // Numpad 4: Left
                       VK_UP,              // Numpad 8: Up
                       VK_RIGHT,           // Numpad 6: Right
                       VK_DOWN,            // Numpad 2: Down
                       VK_INSERT,          // Numpad 0: Active button down
                       VK_DELETE,          // Numpad .: Active button up
                       VK_MULTIPLY,
                       VK_ADD,
                       VK_SUBTRACT,
                       VK_DIVIDE | KBDEXT,
                       VK_HOME | KBDEXT
                      };

/***********************************************************************\
* KbdNlsTables
*
\***********************************************************************/

static ALLOC_SECTION_LDATA KBDNLSTABLES KbdNlsTables = {
    0,                      // OEM ID (0 = Microsoft)
    NLSKBD_INFO_ACCESSIBILITY_KEYMAP,// Information
    6,                      // Number of VK_F entry
    VkToFuncTable_NEC,      // Pointer to VK_F array
    16,                     // Number of MouseVk entry
    ausMouseVKey98          // Pointer to MouseVk array
};

ALLOC_SECTION_LDATA KBDNLSTABLES KbdNlsTablesNEC98 = {
    0x0d,                   // OEM ID (0x0d = NEC)
    NLSKBD_INFO_ACCESSIBILITY_KEYMAP,// Information
    6,                      // Number of VK_F entry
    VkToFuncTable_NEC,      // Pointer to VK_F array
    16,                     // Number of MouseVk entry
    ausMouseVKey98          // Pointer to MouseVk array
};

PKBDNLSTABLES KbdNlsLayerDescriptor(VOID)
{
#ifdef W2K_BEHAVIOR
    if (!IsNEC_98) {
        return &KbdNlsTables;
    } else {
        return &KbdNlsTablesNEC98;
    }
#else
    // From Whistler, we don't support NEC 9800 series: no need to
    // have NEC's OEMID in the NLSTABLE.
    return &KbdNlsTables;
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kbd\fe_kbds\jpn\kbdnec95\kbdnec95.c ===
#if defined(JAPAN) && defined(_PC98_)
/***************************************************************************\
* Module Name: kbdnec95.c
*
* Copyright (c) 1985-97, NEC Corporation
*
* History:
\***************************************************************************/
#else  // _PC98_
/***************************************************************************\
* Module Name: kbd106.c
*
* Copyright (c) 1985-92, Microsoft Corporation
*
* History:
\***************************************************************************/
#endif // _PC98_

#include <windows.h>
#include <ime.h>
#include "vkoem.h"
#include "kbdjpn.h"
#if defined(JAPAN) && defined(_PC98_)
#include "kbdnec95.h"
#else  // _PC98_
#include "kbd106.h"
#endif // _PC98_

#if defined(_M_IA64)
#pragma section(".data")
#define ALLOC_SECTION_LDATA __declspec(allocate(".data"))
#else
#pragma data_seg(".data")
#define ALLOC_SECTION_LDATA
#endif

#if defined(JAPAN) && defined(_PC98_)
/***************************************************************************\
* ausVK[] - Virtual Scan Code to Virtual Key conversion table for NEC 106
\***************************************************************************/
#else // _PC98_
/***************************************************************************\
* ausVK[] - Virtual Scan Code to Virtual Key conversion table for 106
\***************************************************************************/
#endif // _PC98_

static ALLOC_SECTION_LDATA USHORT ausVK[] = {
    T00, T01, T02, T03, T04, T05, T06, T07,
    T08, T09, T0A, T0B, T0C, T0D, T0E, T0F,
    T10, T11, T12, T13, T14, T15, T16, T17,
    T18, T19, T1A, T1B, T1C, T1D, T1E, T1F,
    T20, T21, T22, T23, T24, T25, T26, T27,
#if defined(JAPAN) && defined(_PC98_)
    T28, T29, T2A, T2B, T2C, T2D, T2E, T2F,
    T30, T31, T32, T33, T34,

    /*
     * Conversion key must have KBDSPECIAL bit set (NLS key)
     */
    T35 | KBDSPECIAL,
#else // _PC98_
    T28,

    /*
     * Hankaku/Zenkaku/Kanji key must have KBDSPECIAL bit set (NLS key)
     */
    T29 | KBDSPECIAL,

              T2A, T2B, T2C, T2D, T2E, T2F,
    T30, T31, T32, T33, T34, T35,
#endif // _PC98_

#if defined(JAPAN) && defined(_PC98_)
    T36, T37,
#else //_PC98_
    /*
     * Right-hand Shift key must have KBDEXT bit set.
     */
    T36 | KBDEXT,

    /*
     * numpad_* + Shift/Alt -> SnapShot
     */
    T37 | KBDMULTIVK,
#endif // _PC98_

    T38, T39,

#if defined(JAPAN) && defined(_PC98_)
    T3A,
#else //_PC98_
    /*
     * Alphanumeric/CapsLock key must have KBDSPECIAL bit set (NLS key)
     */
    T3A | KBDSPECIAL,
#endif // _PC98_

                   T3B, T3C, T3D, T3E, T3F,

#if defined(JAPAN) && defined(_PC98_)
    /*
     * Number Pad keys:
     *     KBDNUMPAD  - digits 0-9 and decimal point.
     *     KBDSPECIAL - require special processing by Windows
     */

    T40,                            // Numpad -
    T41,                            // Numpad /
    T42 | KBDNUMPAD | KBDSPECIAL,   // Numpad 7 (Home)
    T43 | KBDNUMPAD | KBDSPECIAL,   // Numpad 8 (Up)
    T44 | KBDNUMPAD | KBDSPECIAL,   // Numpad 9 (PgUp)
    T45,                            // Numpad *
    T46 | KBDNUMPAD | KBDSPECIAL,   // Numpad 4 (Left)
    T47 | KBDNUMPAD | KBDSPECIAL,   // Numpad 5 (Clear)
    T48 | KBDNUMPAD | KBDSPECIAL,   // Numpad 6 (Right)
    T49,                            // Numpad +
    T4A | KBDNUMPAD | KBDSPECIAL,   // Numpad 1 (End)
    T4B | KBDNUMPAD | KBDSPECIAL,   // Numpad 2 (Down)
    T4C | KBDNUMPAD | KBDSPECIAL,   // Numpad 3 (PgDn)
    T4D | KBDNUMPAD | KBDSPECIAL,   // Numpad =
    T4E | KBDNUMPAD | KBDSPECIAL,   // Numpad 0 (Ins)
    T4F,                            // Numpad ,
    T50 | KBDNUMPAD | KBDSPECIAL,   // Numpad . (Del)

    /*
     * Non-Conversion key must have KBDSPECIAL bit set (NLS key)
     */
    T51 | KBDSPECIAL,

    T52, T53,
#else //_PC98_
    T40, T41, T42, T43, T44,

    /*
     * NumLock Key:
     *     KBDEXT     - VK_NUMLOCK is an Extended key
     *     KBDMULTIVK - VK_NUMLOCK or VK_PAUSE (without or with CTRL)
     */
    T45 | KBDEXT | KBDMULTIVK,

    T46 | KBDMULTIVK,

    /*
     * Number Pad keys:
     *     KBDNUMPAD  - digits 0-9 and decimal point.
     *     KBDSPECIAL - require special processing by Windows
     */
    T47 | KBDNUMPAD | KBDSPECIAL,   // Numpad 7 (Home)
    T48 | KBDNUMPAD | KBDSPECIAL,   // Numpad 8 (Up),
    T49 | KBDNUMPAD | KBDSPECIAL,   // Numpad 9 (PgUp),
    T4A,
    T4B | KBDNUMPAD | KBDSPECIAL,   // Numpad 4 (Left),
    T4C | KBDNUMPAD | KBDSPECIAL,   // Numpad 5 (Clear),
    T4D | KBDNUMPAD | KBDSPECIAL,   // Numpad 6 (Right),
    T4E,
    T4F | KBDNUMPAD | KBDSPECIAL,   // Numpad 1 (End),
    T50 | KBDNUMPAD | KBDSPECIAL,   // Numpad 2 (Down),
    T51 | KBDNUMPAD | KBDSPECIAL,   // Numpad 3 (PgDn),
    T52 | KBDNUMPAD | KBDSPECIAL,   // Numpad 0 (Ins),
    T53 | KBDNUMPAD | KBDSPECIAL,   // Numpad . (Del),
#endif // _PC98_

    T54, T55, T56, T57, T58, T59, T5A, T5B,
    T5C, T5D, T5E, T5F, T60, T61, T62, T63,
    T64, T65, T66, T67, T68, T69, T6A, T6B,
    T6C, T6D, T6E, T6F,

#if defined(JAPAN) && defined(_PC98_)
    T70,
#else //_PC98_
    /*
     * Hiragana/Katakana/Roman key must have KBDSPECIAL bit set (NLS key)
     */
    T70 | KBDSPECIAL,
#endif // _PC98_

                             T71, T72, T73,
    T74, T75, T76, T77, T78,

#if defined(JAPAN) && defined(_PC98_)
    T79,
#else //_PC98_
    /*
     * Conversion key must have KBDSPECIAL bit set (NLS key)
     */
    T79 | KBDSPECIAL,
#endif // _PC98_

                                  T7A,

#if defined(JAPAN) && defined(_PC98_)
    T7B,
#else //_PC98_
    /*
     * Non-Conversion key must have KBDSPECIAL bit set (NLS key)
     */
    T7B | KBDSPECIAL,
#endif // _PC98_

    T7C, T7D, T7E, T7F

};

static ALLOC_SECTION_LDATA VSC_VK aE0VscToVk[] = {
#if defined(JAPAN) && defined(_PC98_)
#else //_PC98_
        { 0x1C, X1C | KBDEXT              },  // Numpad Enter
        { 0x1D, X1D | KBDEXT              },  // RControl
        { 0x35, X35 | KBDEXT              },  // Numpad Divide
        { 0x37, X37 | KBDEXT              },  // Snapshot
        { 0x38, X38 | KBDEXT              },  // RMenu
        { 0x46, X46 | KBDEXT              },  // Break (Ctrl + Pause)
        { 0x47, X47 | KBDEXT              },  // Home
        { 0x48, X48 | KBDEXT              },  // Up
        { 0x49, X49 | KBDEXT              },  // Prior
        { 0x4B, X4B | KBDEXT              },  // Left
        { 0x4D, X4D | KBDEXT              },  // Right
        { 0x4F, X4F | KBDEXT              },  // End
        { 0x50, X50 | KBDEXT              },  // Down
        { 0x51, X51 | KBDEXT              },  // Next
        { 0x52, X52 | KBDEXT              },  // Insert
        { 0x53, X53 | KBDEXT              },  // Delete
        { 0x5B, X5B | KBDEXT              },  // Left Win
        { 0x5C, X5C | KBDEXT              },  // Right Win
        { 0x5D, X5D | KBDEXT              },  // Application
#endif // _PC98_
        { 0,      0                       }
};

static ALLOC_SECTION_LDATA VSC_VK aE1VscToVk[] = {
#if defined(JAPAN) && defined(_PC98_)
#else //_PC98_
        { 0x1D, Y1D                       },  // Pause
#endif // _PC98_
        { 0   ,   0                       }
};

/***************************************************************************\
* aVkToBits[]  - map Virtual Keys to Modifier Bits
*
* See kbd.h for a full description.
*
* US Keyboard has only three shifter keys:
*     SHIFT (L & R) affects alphabnumeric keys,
*     CTRL  (L & R) is used to generate control characters
*     ALT   (L & R) used for generating characters by number with numpad
\***************************************************************************/

static ALLOC_SECTION_LDATA VK_TO_BIT aVkToBits[] = {
    { VK_SHIFT,   KBDSHIFT },
    { VK_CONTROL, KBDCTRL  },
    { VK_MENU,    KBDALT   },
    { VK_KANA,    KBDKANA  },
    { 0,          0        }
};

/***************************************************************************\
* aModification[]  - map character modifier bits to modification number
*
* See kbd.h for a full description.
*
\***************************************************************************/

static ALLOC_SECTION_LDATA MODIFIERS CharModifiers = {
    &aVkToBits[0],
    11,
    {
    //  Modification# //  Keys Pressed  : Explanation
    //  ============= // ============== : =============================
        0,            //                : unshifted characters
        1,            //          SHIFT : capitals, ~!@#$%^&*()_+{}:"<>? etc.
        4,            //     CTRL       : control characters
        6,            //     CTRL SHIFT :
        SHFT_INVALID, // ALT            : invalid
        SHFT_INVALID, // ALT      SHIFT : invalid
        SHFT_INVALID, // ALT CTRL       : invalid
        SHFT_INVALID, // ALT CTRL SHIFT : invalid
        2,            //KANA
        3,            //KANA      SHIFT
        5,            //KANA CTRL
        7             //KANA CTRL SHIFT
    }
};

/***************************************************************************\
*
* aVkToWch2[]  - Virtual Key to WCHAR translation for 2 shift states
* aVkToWch3[]  - Virtual Key to WCHAR translation for 3 shift states
* aVkToWch4[]  - Virtual Key to WCHAR translation for 4 shift states
*
* Table attributes: Unordered Scan, null-terminated
*
* Search this table for an entry with a matching Virtual Key to find the
* corresponding unshifted and shifted WCHAR characters.
*
* Reserved VirtualKey values (first column)
*     -1            - this line contains dead characters (diacritic)
*     0             - terminator
*
* Reserved Attribute values (second column)
*     CAPLOK        - CapsLock affects this key like Shift
*     KANALOK       - The KANA-LOCK key affects this key like KANA
*
* Reserved character values (third through last column)
*     WCH_NONE      - No character
*     WCH_DEAD      - Dead character (diacritic) value is in next line
*
\***************************************************************************/

static ALLOC_SECTION_LDATA VK_TO_WCHARS4 aVkToWch4[] = {
    //                               |          |   SHIFT  |  KANA  | K+SHFT |
    //                               |          |==========|========|========|
#if defined(JAPAN) && defined(_PC98_)
    {'0'          ,          KANALOK ,'0'       ,'0'       ,WCH_WA  ,WCH_WO  }, //_PC98_
#else //_PC98_
    {'0'          ,          KANALOK ,'0'       ,WCH_NONE  ,WCH_WA  ,WCH_WO  },
#endif // _PC98_
    {'1'          ,          KANALOK ,'1'       ,'!'       ,WCH_NU  ,WCH_NU  },
    {'3'          ,          KANALOK ,'3'       ,'#'       ,WCH_A   ,WCH_AA  },
    {'4'          ,          KANALOK ,'4'       ,'$'       ,WCH_U   ,WCH_UU  },
    {'5'          ,          KANALOK ,'5'       ,'%'       ,WCH_E   ,WCH_EE  },
    {'7'          ,          KANALOK ,'7'       ,0x27      ,WCH_YA  ,WCH_YAA },
    {'8'          ,          KANALOK ,'8'       ,'('       ,WCH_YU  ,WCH_YUU },
    {'9'          ,          KANALOK ,'9'       ,')'       ,WCH_YO  ,WCH_YOO },
    {'A'          , CAPLOK | KANALOK ,'a'       ,'A'       ,WCH_TI  ,WCH_TI  },
    {'B'          , CAPLOK | KANALOK ,'b'       ,'B'       ,WCH_KO  ,WCH_KO  },
    {'C'          , CAPLOK | KANALOK ,'c'       ,'C'       ,WCH_SO  ,WCH_SO  },
    {'D'          , CAPLOK | KANALOK ,'d'       ,'D'       ,WCH_SI  ,WCH_SI  },
    {'E'          , CAPLOK | KANALOK ,'e'       ,'E'       ,WCH_I   ,WCH_II  },
    {'F'          , CAPLOK | KANALOK ,'f'       ,'F'       ,WCH_HA  ,WCH_HA  },
    {'G'          , CAPLOK | KANALOK ,'g'       ,'G'       ,WCH_KI  ,WCH_KI  },
    {'H'          , CAPLOK | KANALOK ,'h'       ,'H'       ,WCH_KU  ,WCH_KU  },
    {'I'          , CAPLOK | KANALOK ,'i'       ,'I'       ,WCH_NI  ,WCH_NI  },
    {'J'          , CAPLOK | KANALOK ,'j'       ,'J'       ,WCH_MA  ,WCH_MA  },
    {'K'          , CAPLOK | KANALOK ,'k'       ,'K'       ,WCH_NO  ,WCH_NO  },
    {'L'          , CAPLOK | KANALOK ,'l'       ,'L'       ,WCH_RI  ,WCH_RI  },
    {'M'          , CAPLOK | KANALOK ,'m'       ,'M'       ,WCH_MO  ,WCH_MO  },
    {'N'          , CAPLOK | KANALOK ,'n'       ,'N'       ,WCH_MI  ,WCH_MI  },
    {'O'          , CAPLOK | KANALOK ,'o'       ,'O'       ,WCH_RA  ,WCH_RA  },
    {'P'          , CAPLOK | KANALOK ,'p'       ,'P'       ,WCH_SE  ,WCH_SE  },
    {'Q'          , CAPLOK | KANALOK ,'q'       ,'Q'       ,WCH_TA  ,WCH_TA  },
    {'R'          , CAPLOK | KANALOK ,'r'       ,'R'       ,WCH_SU  ,WCH_SU  },
    {'S'          , CAPLOK | KANALOK ,'s'       ,'S'       ,WCH_TO  ,WCH_TO  },
    {'T'          , CAPLOK | KANALOK ,'t'       ,'T'       ,WCH_KA  ,WCH_KA  },
    {'U'          , CAPLOK | KANALOK ,'u'       ,'U'       ,WCH_NA  ,WCH_NA  },
    {'V'          , CAPLOK | KANALOK ,'v'       ,'V'       ,WCH_HI  ,WCH_HI  },
    {'W'          , CAPLOK | KANALOK ,'w'       ,'W'       ,WCH_TE  ,WCH_TE  },
    {'X'          , CAPLOK | KANALOK ,'x'       ,'X'       ,WCH_SA  ,WCH_SA  },
    {'Y'          , CAPLOK | KANALOK ,'y'       ,'Y'       ,WCH_NN  ,WCH_NN  },
    {'Z'          , CAPLOK | KANALOK ,'z'       ,'Z'       ,WCH_TU  ,WCH_TUU },
    {VK_OEM_1     ,          KANALOK ,':'       ,'*'       ,WCH_KE  ,WCH_KE  },
    {VK_OEM_2     ,          KANALOK ,'/'       ,'?'       ,WCH_ME  ,WCH_MD  },
#if defined(JAPAN) && defined(_PC98_)
#else //_PC98_
    {VK_OEM_3     ,          KANALOK ,'@'       ,'`'       ,WCH_VS  ,WCH_VS  },
    {VK_OEM_7     ,          KANALOK ,'^'       ,'~'       ,WCH_HE  ,WCH_HE  },
    {VK_OEM_8     , 0                ,WCH_NONE  ,WCH_NONE  ,WCH_NONE,WCH_NONE},
#endif // _PC98_
    {VK_OEM_COMMA ,          KANALOK ,','       ,'<'       ,WCH_NE  ,WCH_IC  },
    {VK_OEM_PERIOD,          KANALOK ,'.'       ,'>'       ,WCH_RU  ,WCH_IP  },
    {VK_OEM_PLUS  ,          KANALOK ,';'       ,'+'       ,WCH_RE  ,WCH_RE  },
    {VK_TAB       , 0                ,'\t'      ,'\t'      ,'\t'    ,'\t'    },
    {VK_ADD       , 0                ,'+'       ,'+'       ,'+'     ,'+'     },
    {VK_DECIMAL   , 0                ,'.'       ,'.'       ,'.'     ,'.'     },
    {VK_DIVIDE    , 0                ,'/'       ,'/'       ,'/'     ,'/'     },
    {VK_MULTIPLY  , 0                ,'*'       ,'*'       ,'*'     ,'*'     },
    {VK_SUBTRACT  , 0                ,'-'       ,'-'       ,'-'     ,'-'     },
#if defined(JAPAN) && defined(_PC98_)
    {VK_SEPARATOR , 0                ,','       ,','       ,','     ,','     }, //<NEC_OCDE OEM
    {VK_OEM_NEC_EQUAL,    0          ,'='       ,'='       ,'='     ,'='     }, //<_PC98_ OEM
#endif // _PC98_
    {0            , 0                ,0         ,0         ,0       ,0       }
};

static ALLOC_SECTION_LDATA VK_TO_WCHARS6 aVkToWch6[] = {
    //                      |          |   SHIFT  |  KANA  | K+SHFT |  CONTROL  |  K+CTRL   |
    //                      |          |==========|========|========|===========|===========|
    {VK_BACK      , 0       ,'\b'      ,'\b'      ,'\b'    ,'\b'    , 0x7f      , 0x7f      },
    {VK_CANCEL    , 0       ,0x03      ,0x03      ,0x03    ,0x03    , 0x03      , 0x03      },
    {VK_ESCAPE    , 0       ,0x1b      ,0x1b      ,0x1b    ,0x1b    , 0x1b      , 0x1b      },
#if defined(JAPAN) && defined(_PC98_)
    {VK_OEM_3     , KANALOK ,'@'       ,'~'       ,WCH_VS  ,WCH_VS  , 0x00      , 0x00      },//_PC98_ #931208
    {VK_OEM_4     , KANALOK ,'['       ,'{'       ,WCH_SVS ,WCH_OB  , 0x1b      , 0x1b      },//_PC98_
    {VK_OEM_5     , KANALOK ,'\\'      ,'|'       ,WCH_PS  ,WCH_PS  , 0x1c      , 0x1c      },//_PC98_
    {VK_OEM_6     , KANALOK ,']'       ,'}'       ,WCH_MU  ,WCH_CB  , 0x1d      , 0x1d      },//_PC98_
    {VK_OEM_7     , KANALOK ,'^'       ,'`'       ,WCH_HE  ,WCH_HE  , 0x1e      , 0x1e      },//_PC98_ #931208
    {VK_OEM_8     , KANALOK ,WCH_NONE  ,'_'       ,WCH_RO  ,WCH_RO  , 0x1f      , 0x1f      },//_PC98_ #931208
#else //_PC98_
    {VK_OEM_4     , KANALOK ,'['       ,'{'       ,WCH_SVS ,WCH_OB  , 0x1b      , 0x1b      },
    {VK_OEM_5     , KANALOK ,'\\'      ,'|'       ,WCH_PS  ,WCH_PS  , 0x1c      , 0x1c      },
    {VK_OEM_102   , KANALOK ,'\\'      ,'_'       ,WCH_RO  ,WCH_RO  , 0x1c      , 0x1c      },
    {VK_OEM_6     , KANALOK ,']'       ,'}'       ,WCH_MU  ,WCH_CB  , 0x1d      , 0x1d      },
#endif // _PC98_
    {VK_RETURN    , 0       ,'\r'      ,'\r'      ,'\r'    ,'\r'    , '\n'      , '\n'      },
    {VK_SPACE     , 0       ,' '       ,' '       ,' '     ,' '     , 0x20      , 0x20      },
    {0            , 0       ,0         ,0         ,0       ,0       , 0         , 0         }
};

static ALLOC_SECTION_LDATA VK_TO_WCHARS8 aVkToWch8[] = {
    //                      |          |   SHIFT  |  KANA  | K+SHFT |  CONTROL  |  K+CTRL   | SHFT+CTRL |K+SHFT+CTRL|
    //                      |          |==========|========|========|===========|===========|===========|===========|
    {'2'          , KANALOK ,'2'       ,'"'       ,WCH_HU  ,WCH_HU  , WCH_NONE  , WCH_NONE  , 0x00      , 0x00      },
    {'6'          , KANALOK ,'6'       ,'&'       ,WCH_O   ,WCH_OO  , WCH_NONE  , WCH_NONE  , 0x1e      , 0x1e      },
    {VK_OEM_MINUS , KANALOK ,'-'       ,'='       ,WCH_HO  ,WCH_HO  , WCH_NONE  , WCH_NONE  , 0x1f      , 0x1f      },
    {0            , 0       ,0         ,0         ,0       ,0       , 0         , 0         , 0         , 0         }
};

// Put this last so that VkKeyScan interprets number characters
// as coming from the main section of the kbd (aVkToWch2 and
// aVkToWch4) before considering the numpad (aVkToWch1).

static ALLOC_SECTION_LDATA VK_TO_WCHARS4 aVkToWch1[] = {
    //                     |          |   SHIFT  |  KANA  | K+SHFT |
    //                     |          |==========|========|========|
    { VK_NUMPAD0   , 0      ,  '0'    , WCH_NONE ,   '0'  ,WCH_NONE},
    { VK_NUMPAD1   , 0      ,  '1'    , WCH_NONE ,   '1'  ,WCH_NONE},
    { VK_NUMPAD2   , 0      ,  '2'    , WCH_NONE ,   '2'  ,WCH_NONE},
    { VK_NUMPAD3   , 0      ,  '3'    , WCH_NONE ,   '3'  ,WCH_NONE},
    { VK_NUMPAD4   , 0      ,  '4'    , WCH_NONE ,   '4'  ,WCH_NONE},
    { VK_NUMPAD5   , 0      ,  '5'    , WCH_NONE ,   '5'  ,WCH_NONE},
    { VK_NUMPAD6   , 0      ,  '6'    , WCH_NONE ,   '6'  ,WCH_NONE},
    { VK_NUMPAD7   , 0      ,  '7'    , WCH_NONE ,   '7'  ,WCH_NONE},
    { VK_NUMPAD8   , 0      ,  '8'    , WCH_NONE ,   '8'  ,WCH_NONE},
    { VK_NUMPAD9   , 0      ,  '9'    , WCH_NONE ,   '9'  ,WCH_NONE},
    { 0            , 0      ,  '\0'   , 0        ,   0    ,0       }   //null terminator
};

/***************************************************************************\
* aVkToWcharTable: table of pointers to Character Tables
*
* Describes the character tables and the order they should be searched.
*
* Note: the order determines the behavior of VkKeyScan() : this function
*       takes a character and attempts to find a Virtual Key and character-
*       modifier key combination that produces that character.  The table
*       containing the numeric keypad (aVkToWch1) must appear last so that
*       VkKeyScan('0') will be interpreted as one of keys from the main
*       section, not the numpad.  etc.
\***************************************************************************/

static ALLOC_SECTION_LDATA VK_TO_WCHAR_TABLE aVkToWcharTable[] = {
    {  (PVK_TO_WCHARS1)aVkToWch6, 6, sizeof(aVkToWch6[0]) },
    {  (PVK_TO_WCHARS1)aVkToWch8, 8, sizeof(aVkToWch8[0]) },
    {  (PVK_TO_WCHARS1)aVkToWch4, 4, sizeof(aVkToWch4[0]) },
    {  (PVK_TO_WCHARS1)aVkToWch1, 4, sizeof(aVkToWch1[0]) },  // must come last
    {                       NULL, 0, 0                    }
};

/***************************************************************************\
* aKeyNames[], aKeyNamesExt[]  - Scan Code -> Key Name tables
*
* For the GetKeyNameText() API function
*
* Tables for non-extended and extended (KBDEXT) keys.
* (Keys producing printable characters are named by the character itself)
\***************************************************************************/

static ALLOC_SECTION_LDATA VSC_LPWSTR aKeyNames[] = {
#if defined(JAPAN) && defined(_PC98_)
//    0x00,    L"ESC",            // Esc
    0x0e,    L"BS",             // Backspace
    0x0f,    L"TAB",            // Tab
    0x1c,    L"RETURN",         // Enter
    0x34,    L"SPACE",          // Space
    0x35,    L"XFER",           // NLS Key SZ_KEY_NAME_HIRAGANA
    0x36,    L"ROLL UP",        // Page Down
    0x37,    L"ROLL DOWN",      // Page Up
    0x38,    L"INS",            // Insert
    0x39,    L"DEL",            // Delete
    0x3A,    L"UP",             // Up
    0x3B,    L"LEFT",           // Left
    0x3C,    L"RIGHT",          // Right
    0x3D,    L"DOWN",           // Down
    0x3E,    L"CLR",            // Home
    0x3F,    L"HELP",           // End
    0x40,    L"Num -",
    0x41,    L"Num /",
    0x42,    L"Num 7",
    0x43,    L"Num 8",
    0x44,    L"Num 9",
    0x45,    L"Num *",
    0x46,    L"Num 4",
    0x47,    L"Num 5",
    0x48,    L"Num 6",
    0x49,    L"Num +",
    0x4a,    L"Num 1",
    0x4b,    L"Num 2",
    0x4c,    L"Num 3",
    0x4d,    L"Num =",
    0x4e,    L"Num 0",
    0x4f,    L"Num ,",
    0x50,    L"Num .",
    0x51,    L"NFER",                   //
    0x52,    (LPWSTR)SZ_KEY_NAME_F11,   // vf1
    0x53,    (LPWSTR)SZ_KEY_NAME_F12,   // vf2
    0x54,    (LPWSTR)SZ_KEY_NAME_F13,   // vf3
    0x55,    (LPWSTR)SZ_KEY_NAME_F14,   // vf4
    0x56,    (LPWSTR)SZ_KEY_NAME_F15,   // vf5
    0x60,    L"STOP",                   // Break
    0x61,    L"COPY",                   // Prnt Scr
    0x62,    (LPWSTR)SZ_KEY_NAME_F1,    // F1
    0x63,    (LPWSTR)SZ_KEY_NAME_F2,    // F2
    0x64,    (LPWSTR)SZ_KEY_NAME_F3,    // F3
    0x65,    (LPWSTR)SZ_KEY_NAME_F4,    // F4
    0x66,    (LPWSTR)SZ_KEY_NAME_F5,    // F5
    0x67,    (LPWSTR)SZ_KEY_NAME_F6,    // F6
    0x68,    (LPWSTR)SZ_KEY_NAME_F7,    // F7
    0x69,    (LPWSTR)SZ_KEY_NAME_F8,    // F8
    0x6A,    (LPWSTR)SZ_KEY_NAME_F9,    // F9
    0x6B,    (LPWSTR)SZ_KEY_NAME_F10,   // F10
    0x70,    L"SHIFT",                  // Shift
    0x71,    L"CAPS",                   // Caps Lock
    0x72,    (LPWSTR)SZ_KEY_NAME_KANA,  // NLS Key Katakana
    0x73,    L"GRPH",                   // Alt
    0x74,    L"CTRL",                   // Ctrl
    0x77,    L"Left Windows",
    0x78,    L"Right Windows",
    0x79,    L"Application",
    0x7d,    L"SHIFT",                  // Right Shift
#else //_PC98_
    0x01,    L"Esc",
    0x0e,    L"Backspace",
    0x0f,    L"Tab",
    0x1c,    L"Enter",
    0x1d,    L"Ctrl",
    0x29,    (LPWSTR)SZ_KEY_NAME_HANKAKU_ZENKAKU,  // NLS Key
    0x2a,    L"Shift",
    0x36,    L"Right Shift",
    0x37,    L"Num *",
    0x38,    L"Alt",
    0x39,    L"Space",
    0x3a,    L"Caps Lock",
    0x3b,    L"F1",
    0x3c,    L"F2",
    0x3d,    L"F3",
    0x3e,    L"F4",
    0x3f,    L"F5",
    0x40,    L"F6",
    0x41,    L"F7",
    0x42,    L"F8",
    0x43,    L"F9",
    0x44,    L"F10",
    0x45,    L"Pause",
    0x46,    L"Scroll Lock",
    0x47,    L"Num 7",
    0x48,    L"Num 8",
    0x49,    L"Num 9",
    0x4a,    L"Num -",
    0x4b,    L"Num 4",
    0x4c,    L"Num 5",
    0x4d,    L"Num 6",
    0x4e,    L"Num +",
    0x4f,    L"Num 1",
    0x50,    L"Num 2",
    0x51,    L"Num 3",
    0x52,    L"Num 0",
    0x53,    L"Num Del",
    0x54,    L"Sys Req",
    0x57,    L"F11",
    0x58,    L"F12",
    0x70,    (LPWSTR)SZ_KEY_NAME_HIRAGANA,
    0x79,    (LPWSTR)SZ_KEY_NAME_HENKAN,
    0x7b,    (LPWSTR)SZ_KEY_NAME_MUHENKAN,
    0x7C,    L"F13",
#endif // _PC98_
    0   ,    NULL
};

static ALLOC_SECTION_LDATA VSC_LPWSTR aKeyNamesExt[] = {
#if defined(JAPAN) && defined(_PC98_)
#else //_PC98_
    0x1c,    L"Num Enter",
    0x1d,    L"Right Control",
    0x35,    L"Num /",
    0x37,    L"Prnt Scrn",
    0x38,    L"Right Alt",
    0x45,    L"Num Lock",
    0x46,    L"Break",
    0x47,    L"Home",
    0x48,    L"Up",
    0x49,    L"Page Up",
    0x4b,    L"Left",
    0x4d,    L"Right",
    0x4f,    L"End",
    0x50,    L"Down",
    0x51,    L"Page Down",
    0x52,    L"Insert",
    0x53,    L"Delete",
    0x5B,    L"Left Windows",
    0x5C,    L"Right Windows",
    0x5D,    L"Application",
#endif // _PC98_
    0   ,    NULL
};

static ALLOC_SECTION_LDATA KBDTABLES KbdTables = {
    /*
     * Modifier keys
     */
    &CharModifiers,

    /*
     * Characters tables
     */
    aVkToWcharTable,

    /*
     * Diacritics  (none for US English)
     */
    NULL,

    /*
     * Names of Keys  (no dead keys)
     */
    aKeyNames,
    aKeyNamesExt,
    NULL,

    /*
     * Scan codes to Virtual Keys
     */
    ausVK,
    sizeof(ausVK) / sizeof(ausVK[0]),
    aE0VscToVk,
    aE1VscToVk,

    /*
     * No Locale-specific special processing
     */
    0,

    /*
     * No Ligatures
     */
    0, 0, NULL,

    /*
     * Type and subtype.
     */
    KEYBOARD_TYPE_JAPAN,    // Japanese Keyboard Layout
    MAKEWORD(NEC_KBD_N_MODE_TYPE, NLSKBD_OEM_NEC),
};

PKBDTABLES KbdLayerDescriptor(VOID)
{
    return &KbdTables;
}

/***********************************************************************\
* VkToFuncTable_106[]
*
\***********************************************************************/

static ALLOC_SECTION_LDATA VK_F VkToFuncTable_106[] = {
    {
        VK_DBE_ALPHANUMERIC,  // Base Vk
        KBDNLS_TYPE_TOGGLE,   // NLSFEProcType
        KBDNLS_INDEX_NORMAL,  // NLSFEProcCurrent
        0x02, /* 00000010 */  // NLSFEProcSwitch
        {                     // NLSFEProc
            {KBDNLS_ALPHANUM,0},               // Base
            {KBDNLS_SEND_PARAM_VK,VK_CAPITAL}, // Shift
            {KBDNLS_ALPHANUM,0},               // Control
            {KBDNLS_ALPHANUM,0},               // Shift+Control
            {KBDNLS_ALPHANUM,0},               // Alt
            {KBDNLS_ALPHANUM,0},               // Shift+Alt
            {KBDNLS_CODEINPUT,0},              // Control+Alt
            {KBDNLS_CODEINPUT,0}               // Shift+Control+Alt
        },
        {                     // NLSFEProcAlt
            {KBDNLS_SEND_PARAM_VK,VK_CAPITAL}, // Base
            {KBDNLS_SEND_PARAM_VK,VK_CAPITAL}, // Shift
            {KBDNLS_NOEVENT,0},                // Control
            {KBDNLS_NOEVENT,0},                // Shift+Control
            {KBDNLS_NOEVENT,0},                // Alt
            {KBDNLS_NOEVENT,0},                // Shift+Alt
            {KBDNLS_NOEVENT,0},                // Control+Alt
            {KBDNLS_NOEVENT,0}                 // Shift+Control+Alt
        }
    },
    {
        VK_DBE_HIRAGANA,     // Base Vk
        KBDNLS_TYPE_TOGGLE,  // NLSFEProcType
        KBDNLS_INDEX_NORMAL, // NLSFEProcCurrent
        0x08, /* 00001000 */ // NLSFEProcSwitch
        {                    // NLSFEProc
            {KBDNLS_HIRAGANA,0},             // Base
            {KBDNLS_KATAKANA,0},             // Shift
            {KBDNLS_HIRAGANA,0},             // Control
            {KBDNLS_SEND_PARAM_VK,VK_KANA},  // Shift+Control
            {KBDNLS_ROMAN,0},                // Alt
            {KBDNLS_ROMAN,0},                // Shift+Alt
            {KBDNLS_ROMAN,0},                // Control+Alt
            {KBDNLS_NOEVENT,0}               // Shift+Control+Alt
        },
        {                    // NLSFEProcIndexAlt
            {KBDNLS_SEND_PARAM_VK,VK_KANA},  // Base
            {KBDNLS_SEND_PARAM_VK,VK_KANA},  // Shift
            {KBDNLS_SEND_PARAM_VK,VK_KANA},  // Control
            {KBDNLS_SEND_PARAM_VK,VK_KANA},  // Shift+Control
            {KBDNLS_NOEVENT,0},              // Alt
            {KBDNLS_NOEVENT,0},              // Shift+Alt
            {KBDNLS_NOEVENT,0},              // Control+Alt
            {KBDNLS_NOEVENT,0}               // Shift+Control+Alt
        }
    },
    {
        VK_DBE_SBCSCHAR,     // Base Vk
        KBDNLS_TYPE_NORMAL,  // NLSFEProcType
        KBDNLS_INDEX_NORMAL, // NLSFEProcCurrent
        0x0,                 // NLSFEProcSwitch
        {                    // NLSFEProc
            {KBDNLS_SBCSDBCS,0},             // Base
            {KBDNLS_SBCSDBCS,0},             // Shift
            {KBDNLS_SBCSDBCS,0},             // Control
            {KBDNLS_SBCSDBCS,0},             // Shift+Control
            {KBDNLS_SEND_PARAM_VK,VK_KANJI}, // Alt
            {KBDNLS_SBCSDBCS,0},             // Shift+Alt
            {KBDNLS_SEND_PARAM_VK,VK_DBE_ENTERIMECONFIGMODE}, // Control+Alt
            {KBDNLS_SEND_PARAM_VK,VK_DBE_ENTERIMECONFIGMODE}  // Shift+Control+Alt
        },
        {                    // NLSFEProcIndexAlt
            {KBDNLS_NULL,0},  // Base
            {KBDNLS_NULL,0},  // Shift
            {KBDNLS_NULL,0},  // Control
            {KBDNLS_NULL,0},  // Shift+Control
            {KBDNLS_NULL,0},  // Alt
            {KBDNLS_NULL,0},  // Shift+Alt
            {KBDNLS_NULL,0},  // Control+Alt
            {KBDNLS_NULL,0}   // Shift+Control+Alt
        }
    },
    {
        VK_NONCONVERT,       // Base Vk
        KBDNLS_TYPE_NORMAL,  // NLSFEProcType
        KBDNLS_INDEX_NORMAL, // NLSFEProcCurrent
        0x0,                 // NLSFEProcSwitch
        {                    // NLSFEProc
            {KBDNLS_SEND_BASE_VK,0},         // Base
            {KBDNLS_SEND_BASE_VK,0},         // Shift
            {KBDNLS_SEND_BASE_VK,0},         // Control
            {KBDNLS_SEND_BASE_VK,0},         // Shift+Control
            {KBDNLS_SEND_BASE_VK,0},         // Alt
            {KBDNLS_SEND_BASE_VK,0},         // Shift+Alt
            {KBDNLS_SEND_PARAM_VK,VK_DBE_ENTERWORDREGISTERMODE}, // Control+Alt
            {KBDNLS_SEND_PARAM_VK,VK_DBE_ENTERWORDREGISTERMODE}  // Shift+Control+Alt
        },
        {                         // NLSFEProcIndexAlt
            {KBDNLS_NULL,0},  // Base
            {KBDNLS_NULL,0},  // Shift
            {KBDNLS_NULL,0},  // Control
            {KBDNLS_NULL,0},  // Shift+Control
            {KBDNLS_NULL,0},  // Alt
            {KBDNLS_NULL,0},  // Shift+Alt
            {KBDNLS_NULL,0},  // Control+Alt
            {KBDNLS_NULL,0}   // Shift+Control+Alt
        }
    }
};

#if defined(JAPAN) && defined(_PC98_)
static ALLOC_SECTION_LDATA VK_F VkToFuncTable_NEC[] = {
    {
        VK_DBE_SBCSCHAR,     // Base Vk
        KBDNLS_TYPE_NORMAL,  // NLSFEProcType
        KBDNLS_INDEX_NORMAL, // NLSFEProcCurrent
        0x0,                 // NLSFEProcSwitch
        {                    // NLSFEProc
            {KBDNLS_SBCSDBCS,0},             // Base
            {KBDNLS_SBCSDBCS,0},             // Shift
            {KBDNLS_SBCSDBCS,0},             // Control
            {KBDNLS_SBCSDBCS,0},             // Shift+Control
            {KBDNLS_SBCSDBCS,0},             // Alt
//            {KBDNLS_SEND_PARAM_VK,VK_KANJI}, // Alt
            {KBDNLS_SBCSDBCS,0},             // Shift+Alt
            {KBDNLS_SEND_PARAM_VK,VK_DBE_ENTERIMECONFIGMODE}, // Control+Alt
            {KBDNLS_SEND_PARAM_VK,VK_DBE_ENTERIMECONFIGMODE}  // Shift+Control+Alt
        },
        {                     // NLSFEProcIndexAlt
            {KBDNLS_NULL,0},  // Base
            {KBDNLS_NULL,0},  // Shift
            {KBDNLS_NULL,0},  // Control
            {KBDNLS_NULL,0},  // Shift+Control
            {KBDNLS_NULL,0},  // Alt
            {KBDNLS_NULL,0},  // Shift+Alt
            {KBDNLS_NULL,0},  // Control+Alt
            {KBDNLS_NULL,0}   // Shift+Control+Alt
        }
    },
    {
        VK_NONCONVERT,       // Base Vk  PC98_NFER key
        KBDNLS_TYPE_NORMAL,  // NLSFEProcType
        KBDNLS_INDEX_NORMAL, // NLSFEProcCurrent
        0x0,                 // NLSFEProcSwitch
        {                    // NLSFEProc
            {KBDNLS_SEND_BASE_VK,0},                             // Base
            {KBDNLS_SEND_BASE_VK,0},                             // Shift
            {KBDNLS_SEND_PARAM_VK,VK_DBE_ALPHANUMERIC},          // Control
            {KBDNLS_SBCSDBCS,0},                                 // Shift+Control
            {KBDNLS_SEND_PARAM_VK,VK_DBE_KATAKANA},              // Alt
            {KBDNLS_SEND_PARAM_VK,VK_DBE_ENTERWORDREGISTERMODE}, // Shift+Alt
            {KBDNLS_SEND_PARAM_VK,VK_DBE_NOCODEINPUT},           // Control+Alt
            {KBDNLS_SEND_PARAM_VK,VK_DBE_FLUSHSTRING}            // Shift+Control+Alt
        },
        {                     // NLSFEProcIndexAlt
            {KBDNLS_NULL,0},  // Base
            {KBDNLS_NULL,0},  // Shift
            {KBDNLS_NULL,0},  // Control
            {KBDNLS_NULL,0},  // Shift+Control
            {KBDNLS_NULL,0},  // Alt
            {KBDNLS_NULL,0},  // Shift+Alt
            {KBDNLS_NULL,0},  // Control+Alt
            {KBDNLS_NULL,0}   // Shift+Control+Alt
        }
    },
    {
        VK_CONVERT,            // Base Vk  PC98_XFER key
        KBDNLS_TYPE_NORMAL,  // NLSFEProcType
        KBDNLS_INDEX_NORMAL, // NLSFEProcCurrent
        0x0,                 // NLSFEProcSwitch
        {                    // NLSFEProc
            {KBDNLS_SEND_BASE_VK,0},                          // Base
            {KBDNLS_SEND_BASE_VK,0},                          // Shift
            {KBDNLS_SEND_PARAM_VK,VK_KANJI},                  // Control
            {KBDNLS_SEND_BASE_VK,0},                          // Shift+Control
            {KBDNLS_ROMAN,0},                                 // Alt
            {KBDNLS_SEND_PARAM_VK,VK_DBE_ENTERIMECONFIGMODE}, // Shift+Alt
            {KBDNLS_SEND_PARAM_VK,VK_DBE_CODEINPUT},          // Control+Alt
            {KBDNLS_SEND_PARAM_VK,VK_DBE_HIRAGANA}            // Shift+Control+Alt
        },
        {                     // NLSFEProcIndexAlt
            {KBDNLS_NULL,0},  // Base
            {KBDNLS_NULL,0},  // Shift
            {KBDNLS_NULL,0},  // Control
            {KBDNLS_NULL,0},  // Shift+Control
            {KBDNLS_NULL,0},  // Alt
            {KBDNLS_NULL,0},  // Shift+Alt
            {KBDNLS_NULL,0},  // Control+Alt
            {KBDNLS_NULL,0}   // Shift+Control+Alt
        }
    },
    {
        VK_OEM_NEC_EQUAL,    // Base Vk NEC98_"="  key
        KBDNLS_TYPE_NORMAL,  // NLSFEProcType
        KBDNLS_INDEX_NORMAL, // NLSFEProcCurrent
        0x0,                 // NLSFEProcSwitch
        {                    // NLSFEProc
            {KBDNLS_SEND_BASE_VK,0},                  // Base
            {KBDNLS_SEND_BASE_VK,0},                  // Shift
            {KBDNLS_SEND_PARAM_VK,VK_SCROLL},         // Control
            {KBDNLS_SEND_BASE_VK,0},                  // Shift+Control
            {KBDNLS_SEND_BASE_VK,0},                  // Alt
            {KBDNLS_SEND_BASE_VK,0},                  // Shift+Alt
            {KBDNLS_SEND_BASE_VK,0},                  // Control+Alt
            {KBDNLS_SEND_BASE_VK,0}                   // Shift+Control+Alt
        },
        {                     // NLSFEProcIndexAlt
            {KBDNLS_NULL,0},  // Base
            {KBDNLS_NULL,0},  // Shift
            {KBDNLS_NULL,0},  // Control
            {KBDNLS_NULL,0},  // Shift+Control
            {KBDNLS_NULL,0},  // Alt
            {KBDNLS_NULL,0},  // Shift+Alt
            {KBDNLS_NULL,0},  // Control+Alt
            {KBDNLS_NULL,0}   // Shift+Control+Alt
        }
    },
    {
        VK_HOME,             // Base Vk  PC98_HOME  key
        KBDNLS_TYPE_NORMAL,  // NLSFEProcType
        KBDNLS_INDEX_NORMAL, // NLSFEProcCurrent
        0x0,                 // NLSFEProcSwitch
        {                    // NLSFEProc
            {KBDNLS_HOME_OR_CLEAR,0},         // Base
            {KBDNLS_SEND_BASE_VK,0},          // Shift
            {KBDNLS_HOME_OR_CLEAR,0},         // Control
            {KBDNLS_HOME_OR_CLEAR,0},         // Shift+Control
            {KBDNLS_HOME_OR_CLEAR,0},         // Alt
            {KBDNLS_HOME_OR_CLEAR,0},         // Shift+Alt
            {KBDNLS_HOME_OR_CLEAR,0},         // Control+Alt
            {KBDNLS_HOME_OR_CLEAR,0}          // Shift+Control+Alt
        },
        {                     // NLSFEProcIndexAlt
            {KBDNLS_NULL,0},  // Base
            {KBDNLS_NULL,0},  // Shift
            {KBDNLS_NULL,0},  // Control
            {KBDNLS_NULL,0},  // Shift+Control
            {KBDNLS_NULL,0},  // Alt
            {KBDNLS_NULL,0},  // Shift+Alt
            {KBDNLS_NULL,0},  // Control+Alt
            {KBDNLS_NULL,0}   // Shift+Control+Alt
        }
    },
    {
        VK_END,              // Base Vk  PC98_HELP  key
        KBDNLS_TYPE_NORMAL,  // NLSFEProcType
        KBDNLS_INDEX_NORMAL, // NLSFEProcCurrent
        0x0,                 // NLSFEProcSwitch
        {                    // NLSFEProc
            {KBDNLS_HELP_OR_END,0},         // Base
            {KBDNLS_HELP_OR_END,0},         // Shift
            {KBDNLS_HELP_OR_END,0},         // Control
            {KBDNLS_HELP_OR_END,0},         // Shift+Control
            {KBDNLS_HELP_OR_END,0},         // Alt
            {KBDNLS_HELP_OR_END,0},         // Shift+Alt
            {KBDNLS_HELP_OR_END,0},         // Control+Alt
            {KBDNLS_HELP_OR_END,0}          // Shift+Control+Alt
        },
        {                     // NLSFEProcIndexAlt
            {KBDNLS_NULL,0},  // Base
            {KBDNLS_NULL,0},  // Shift
            {KBDNLS_NULL,0},  // Control
            {KBDNLS_NULL,0},  // Shift+Control
            {KBDNLS_NULL,0},  // Alt
            {KBDNLS_NULL,0},  // Shift+Alt
            {KBDNLS_NULL,0},  // Control+Alt
            {KBDNLS_NULL,0}   // Shift+Control+Alt
        }
    }
};

USHORT ausMouseVKey98[] = {
                       VK_NUMPAD5,
                       VK_NUMPAD9,
                       VK_NUMPAD3,
                       VK_NUMPAD1,
                       VK_NUMPAD7,
                       VK_NUMPAD4,
                       VK_NUMPAD8,
                       VK_NUMPAD6,
                       VK_NUMPAD2,
                       VK_NUMPAD0,
                       VK_DECIMAL,
                       VK_MULTIPLY,
                       VK_ADD,
                       VK_SUBTRACT,
                       VK_DIVIDE | KBDEXT,
                       VK_HOME | KBDEXT
                      };

#else //_PC98_
#endif // _PC98_
/***********************************************************************\
* KbdNlsTables
*
\***********************************************************************/

static ALLOC_SECTION_LDATA KBDNLSTABLES KbdNlsTables = {
#if defined(JAPAN) && defined(_PC98_)
    0x0d,                            // OEM ID (0x0d = NEC)
    NLSKBD_INFO_ACCESSIBILITY_KEYMAP,// Information
    6,                               // Number of VK_F entry
    VkToFuncTable_NEC,               // Pointer to VK_F array
    16,                              // Number of MouseVk entry
    ausMouseVKey98                   // Pointer to MouseVk array
#else //_PC98_
    0,                      // OEM ID (0 = Microsoft)
    0,                      // Information
    4,                      // Number of VK_F entry
    VkToFuncTable_106,      // Pointer to VK_F array
    0,                      // Number of MouseVk entry
    NULL                    // Pointer to MouseVk array
#endif // _PC98_
};

PKBDNLSTABLES KbdNlsLayerDescriptor(VOID)
{
    return &KbdNlsTables;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kbd\fe_kbds\jpn\kbdnec\kbdnec.h ===
/****************************** Module Header ******************************\
* Module Name: kbdnec.h
*
* Copyright (c) 1985-98, Microsoft Corporation
*
* Various defines for use by keyboard input code.
*
* History:
* 27-May-1992 KazuM
\***************************************************************************/

/*
 * kbd type should be controlled by cl command-line argument
 */
#define KBD_TYPE 30

/*
 * Include the basis of all keyboard table values
 */
#include "kbd.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kbd\fe_kbds\jpn\kbdnec95\sources.inc ===
!IF 0

Copyright (c) 1989-2000  Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


!ENDIF

MINORCOMP=kbdnec95

!include ..\..\japan.inc

SOURCES_USED=..\sources.inc

C_DEFINES=$(C_DEFINES) -D_PC98_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kbd\fe_kbds\jpn\kbdnecat\kbdnecat.h ===
#if defined(_PC98_)
/****************************** Module Header ******************************\
* Module Name: kbdnec.h
*
* Copyright (c) 1985-91, Microsoft Corporation
*
* Various defines for use by keyboard input code.
*
* History:
* 27-May-1992 KazuM
\***************************************************************************/
#else
/****************************** Module Header ******************************\
* Module Name: kbd106.h
*
* Copyright (c) 1985-91, Microsoft Corporation
*
* Various defines for use by keyboard input code.
*
* History:
\***************************************************************************/
#endif

/*
 * kbd type should be controlled by cl command-line argument
 */
#if defined(_PC98_)
#define KBD_TYPE 33
#else
#define KBD_TYPE 8
#endif

/*
 * Include the basis of all keyboard table values
 */
#include "kbd.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kbd\fe_kbds\jpn\kbdnecat\sources.inc ===
!IF 0

Copyright (c) 1989-2000  Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


!ENDIF

MINORCOMP=kbdnecat

!include ..\..\japan.inc

SOURCES_USED=..\sources.inc

C_DEFINES=$(C_DEFINES) -D_PC98_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kbd\fe_kbds\jpn\kbdnecnt\kbdnecnt.h ===
#if defined(_PC98_)
/****************************** Module Header ******************************\
* Module Name: kbdnec.h
*
* Copyright (c) 1985-91, Microsoft Corporation
*
* Various defines for use by keyboard input code.
*
* History:
* 27-May-1992 KazuM
\***************************************************************************/
#else
/****************************** Module Header ******************************\
* Module Name: kbd106.h
*
* Copyright (c) 1985-91, Microsoft Corporation
*
* Various defines for use by keyboard input code.
*
* History:
\***************************************************************************/
#endif

/*
 * kbd type should be controlled by cl command-line argument
 */
#if defined(_PC98_)
#define KBD_TYPE 34
#else
#define KBD_TYPE 8
#endif

/*
 * Include the basis of all keyboard table values
 */
#include "kbd.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kbd\fe_kbds\jpn\kbdnec95\kbdnec95.h ===
#if defined(_PC98_)
/****************************** Module Header ******************************\
* Module Name: kbdnec95.h
*
* Copyright (c) 1985-98, Microsoft Corporation
*
* Various defines for use by keyboard input code.
*
* History:
* 27-May-1992 KazuM
\***************************************************************************/
#else
/****************************** Module Header ******************************\
* Module Name: kbd106.h
*
* Copyright (c) 1985-91, Microsoft Corporation
*
* Various defines for use by keyboard input code.
*
* History:
\***************************************************************************/
#endif

/*
 * kbd type should be controlled by cl command-line argument
 */
#if defined(_PC98_)
#define KBD_TYPE 37
#else
#define KBD_TYPE 8
#endif

/*
 * Include the basis of all keyboard table values
 */
#include "kbd.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kbd\fe_kbds\jpn\kbdnecnt\kbdnecnt.c ===
#if defined(JAPAN) && defined(_PC98_)
/***************************************************************************\
* Module Name: kbdnec.c
*
* Copyright (c) 1985-92, Microsoft Corporation
*
* History:
\***************************************************************************/
#else  // _PC98_
/***************************************************************************\
* Module Name: kbd106.c
*
* Copyright (c) 1985-92, Microsoft Corporation
*
* History:
\***************************************************************************/
#endif // _PC98_

#include <windows.h>
#include <ime.h>
#include "vkoem.h"
#include "kbdjpn.h"
#if defined(JAPAN) && defined(_PC98_)
#include "kbdnecNT.h"
#else  // _PC98_
#include "kbd106.h"
#endif // _PC98_

#if defined(_M_IA64)
#pragma section(".data")
#define ALLOC_SECTION_LDATA __declspec(allocate(".data"))
#else
#pragma data_seg(".data")
#define ALLOC_SECTION_LDATA
#endif

#if defined(JAPAN) && defined(_PC98_)
/***************************************************************************\
* ausVK[] - Virtual Scan Code to Virtual Key conversion table for NEC 106
\***************************************************************************/
#else // _PC98_
/***************************************************************************\
* ausVK[] - Virtual Scan Code to Virtual Key conversion table for 106
\***************************************************************************/
#endif // _PC98_

static ALLOC_SECTION_LDATA USHORT ausVK[] = {
    T00, T01, T02, T03, T04, T05, T06, T07,
    T08, T09, T0A, T0B, T0C, T0D, T0E, T0F,
    T10, T11, T12, T13, T14, T15, T16, T17,
    T18, T19, T1A, T1B, T1C, T1D, T1E, T1F,
    T20, T21, T22, T23, T24, T25, T26, T27,
#if defined(JAPAN) && defined(_PC98_)
    T28, T29, T2A, T2B, T2C, T2D, T2E, T2F,
#else // _PC98_
    T28,

    /*
     * Hankaku/Zenkaku/Kanji key must have KBDSPECIAL bit set (NLS key)
     */
    T29 | KBDSPECIAL,

              T2A, T2B, T2C, T2D, T2E, T2F,
#endif // _PC98_
    T30, T31, T32, T33, T34, T35,

    /*
     * Right-hand Shift key must have KBDEXT bit set.
     */
    T36 | KBDEXT,

#if defined(JAPAN) && defined(_PC98_)
    T37,
#else //_PC98_
    /*
     * numpad_* + Shift/Alt -> SnapShot
     */
    T37 | KBDMULTIVK,
#endif // _PC98_

    T38, T39,

#if defined(JAPAN) && defined(_PC98_)
    T3A,
#else //_PC98_
    /*
     * Alphanumeric/CapsLock key must have KBDSPECIAL bit set (NLS key)
     */
    T3A | KBDSPECIAL,
#endif // _PC98_

                   T3B, T3C, T3D, T3E, T3F,
    T40, T41, T42, T43, T44,

    /*
     * NumLock Key:
     *     KBDEXT     - VK_NUMLOCK is an Extended key
     *     KBDMULTIVK - VK_NUMLOCK or VK_PAUSE (without or with CTRL)
     */
    T45 | KBDEXT | KBDMULTIVK,

#if defined(JAPAN) && defined(_PC98_)
    T46,
#else //_PC98_
    T46 | KBDMULTIVK,
#endif // _PC98_

    /*
     * Number Pad keys:
     *     KBDNUMPAD  - digits 0-9 and decimal point.
     *     KBDSPECIAL - require special processing by Windows
     */
    T47 | KBDNUMPAD | KBDSPECIAL,   // Numpad 7 (Home)
    T48 | KBDNUMPAD | KBDSPECIAL,   // Numpad 8 (Up),
    T49 | KBDNUMPAD | KBDSPECIAL,   // Numpad 9 (PgUp),
    T4A,
    T4B | KBDNUMPAD | KBDSPECIAL,   // Numpad 4 (Left),
    T4C | KBDNUMPAD | KBDSPECIAL,   // Numpad 5 (Clear),
    T4D | KBDNUMPAD | KBDSPECIAL,   // Numpad 6 (Right),
    T4E,
    T4F | KBDNUMPAD | KBDSPECIAL,   // Numpad 1 (End),
    T50 | KBDNUMPAD | KBDSPECIAL,   // Numpad 2 (Down),
    T51 | KBDNUMPAD | KBDSPECIAL,   // Numpad 3 (PgDn),
    T52 | KBDNUMPAD | KBDSPECIAL,   // Numpad 0 (Ins),
    T53 | KBDNUMPAD | KBDSPECIAL,   // Numpad . (Del),

#if defined(JAPAN) && defined(_PC98_)
    T54, T55, T56, T57, T58,

    T59 | KBDSPECIAL,               // NEC TenKey EQU (VK_SCROLL)

    T5A | KBDSPECIAL,               // NEC No-Conversion key     // NLS key

    T5B, T5C, T5D, T5E, T5F
#else //_PC98_
    T54, T55, T56, T57, T58, T59, T5A, T5B,
    T5C, T5D, T5E, T5F, T60, T61, T62, T63,
    T64, T65, T66, T67, T68, T69, T6A, T6B,
    T6C, T6D, T6E, T6F,

    /*
     * Hiragana/Katakana/Roman key must have KBDSPECIAL bit set (NLS key)
     */
    T70 | KBDSPECIAL,

                             T71, T72, T73,
    T74, T75, T76, T77, T78,

    /*
     * Conversion key must have KBDSPECIAL bit set (NLS key)
     */
    T79 | KBDSPECIAL,

                                  T7A,

    /*
     * Non-Conversion key must have KBDSPECIAL bit set (NLS key)
     */
    T7B | KBDSPECIAL,

    T7C, T7D, T7E, T7F

#endif // _PC98_
};

static ALLOC_SECTION_LDATA VSC_VK aE0VscToVk[] = {
        { 0x1C, X1C | KBDEXT              },  // Numpad Enter
#if defined(JAPAN) && defined(_PC98_)
        { 0x1D, X1D | KBDEXT | KBDSPECIAL },  // Katakana key   // NLS key
#else //_PC98_
        { 0x1D, X1D | KBDEXT              },  // RControl
#endif // _PC98_
        { 0x35, X35 | KBDEXT              },  // Numpad Divide
        { 0x37, X37 | KBDEXT              },  // Snapshot
#if defined(JAPAN) && defined(_PC98_)
        { 0x38, X38 | KBDEXT | KBDSPECIAL },  // Kanji key      // NLS key
#else //_PC98_
        { 0x38, X38 | KBDEXT              },  // RMenu
#endif // _PC98_
        { 0x46, X46 | KBDEXT              },  // Break (Ctrl + Pause)
#if defined(JAPAN) && defined(_PC98_)
        { 0x47, X47 | KBDEXT | KBDSPECIAL },  // Home //_PC98_ for CLEAR key
#else //_PC98_
        { 0x47, X47 | KBDEXT              },  // Home
#endif // _PC98_
        { 0x48, X48 | KBDEXT              },  // Up
        { 0x49, X49 | KBDEXT              },  // Prior
        { 0x4B, X4B | KBDEXT              },  // Left
        { 0x4D, X4D | KBDEXT              },  // Right
#if defined(JAPAN) && defined(_PC98_)
        { 0x4F, X4F | KBDEXT | KBDSPECIAL },  // End  //_PC98_ for HELP key
#else //_PC98_
        { 0x4F, X4F | KBDEXT              },  // End
#endif // _PC98_
        { 0x50, X50 | KBDEXT              },  // Down
        { 0x51, X51 | KBDEXT              },  // Next
        { 0x52, X52 | KBDEXT              },  // Insert
        { 0x53, X53 | KBDEXT              },  // Delete
        { 0x5B, X5B | KBDEXT              },  // Left Win
        { 0x5C, X5C | KBDEXT              },  // Right Win
        { 0x5D, X5D | KBDEXT              },  // Application
        { 0,      0                       }
};

static ALLOC_SECTION_LDATA VSC_VK aE1VscToVk[] = {
        { 0x1D, Y1D                       },  // Pause
        { 0   ,   0                       }
};

/***************************************************************************\
* aVkToBits[]  - map Virtual Keys to Modifier Bits
*
* See kbd.h for a full description.
*
* US Keyboard has only three shifter keys:
*     SHIFT (L & R) affects alphabnumeric keys,
*     CTRL  (L & R) is used to generate control characters
*     ALT   (L & R) used for generating characters by number with numpad
\***************************************************************************/

static ALLOC_SECTION_LDATA VK_TO_BIT aVkToBits[] = {
    { VK_SHIFT,   KBDSHIFT },
    { VK_CONTROL, KBDCTRL  },
    { VK_MENU,    KBDALT   },
    { VK_KANA,    KBDKANA  },
    { 0,          0        }
};

/***************************************************************************\
* aModification[]  - map character modifier bits to modification number
*
* See kbd.h for a full description.
*
\***************************************************************************/

static ALLOC_SECTION_LDATA MODIFIERS CharModifiers = {
    &aVkToBits[0],
    11,
    {
    //  Modification# //  Keys Pressed  : Explanation
    //  ============= // ============== : =============================
        0,            //                : unshifted characters
        1,            //          SHIFT : capitals, ~!@#$%^&*()_+{}:"<>? etc.
        4,            //     CTRL       : control characters
        6,            //     CTRL SHIFT :
        SHFT_INVALID, // ALT            : invalid
        SHFT_INVALID, // ALT      SHIFT : invalid
        SHFT_INVALID, // ALT CTRL       : invalid
        SHFT_INVALID, // ALT CTRL SHIFT : invalid
        2,            //KANA
        3,            //KANA      SHIFT
        5,            //KANA CTRL
        7             //KANA CTRL SHIFT
    }
};

/***************************************************************************\
*
* aVkToWch2[]  - Virtual Key to WCHAR translation for 2 shift states
* aVkToWch3[]  - Virtual Key to WCHAR translation for 3 shift states
* aVkToWch4[]  - Virtual Key to WCHAR translation for 4 shift states
*
* Table attributes: Unordered Scan, null-terminated
*
* Search this table for an entry with a matching Virtual Key to find the
* corresponding unshifted and shifted WCHAR characters.
*
* Reserved VirtualKey values (first column)
*     -1            - this line contains dead characters (diacritic)
*     0             - terminator
*
* Reserved Attribute values (second column)
*     CAPLOK        - CapsLock affects this key like Shift
*     KANALOK       - The KANA-LOCK key affects this key like KANA
*
* Reserved character values (third through last column)
*     WCH_NONE      - No character
*     WCH_DEAD      - Dead character (diacritic) value is in next line
*
\***************************************************************************/

static ALLOC_SECTION_LDATA VK_TO_WCHARS4 aVkToWch4[] = {
    //                               |          |   SHIFT  |  KANA  | K+SHFT |
    //                               |          |==========|========|========|
#if defined(JAPAN) && defined(_PC98_)
    {'0'          ,          KANALOK ,'0'       ,'0'       ,WCH_WA  ,WCH_WO  }, //_PC98_
#else //_PC98_
    {'0'          ,          KANALOK ,'0'       ,WCH_NONE  ,WCH_WA  ,WCH_WO  },
#endif // _PC98_
    {'1'          ,          KANALOK ,'1'       ,'!'       ,WCH_NU  ,WCH_NU  },
    {'3'          ,          KANALOK ,'3'       ,'#'       ,WCH_A   ,WCH_AA  },
    {'4'          ,          KANALOK ,'4'       ,'$'       ,WCH_U   ,WCH_UU  },
    {'5'          ,          KANALOK ,'5'       ,'%'       ,WCH_E   ,WCH_EE  },
#if defined(JAPAN) && defined(_PC98_)
    {'7'          ,          KANALOK ,'7'       ,'\''      ,WCH_YA  ,WCH_YAA }, //_PC98_
#else //_PC98_
    {'7'          ,          KANALOK ,'7'       ,0x27      ,WCH_YA  ,WCH_YAA },
#endif // _PC98_
    {'8'          ,          KANALOK ,'8'       ,'('       ,WCH_YU  ,WCH_YUU },
    {'9'          ,          KANALOK ,'9'       ,')'       ,WCH_YO  ,WCH_YOO },
    {'A'          , CAPLOK | KANALOK ,'a'       ,'A'       ,WCH_TI  ,WCH_TI  },
    {'B'          , CAPLOK | KANALOK ,'b'       ,'B'       ,WCH_KO  ,WCH_KO  },
    {'C'          , CAPLOK | KANALOK ,'c'       ,'C'       ,WCH_SO  ,WCH_SO  },
    {'D'          , CAPLOK | KANALOK ,'d'       ,'D'       ,WCH_SI  ,WCH_SI  },
    {'E'          , CAPLOK | KANALOK ,'e'       ,'E'       ,WCH_I   ,WCH_II  },
    {'F'          , CAPLOK | KANALOK ,'f'       ,'F'       ,WCH_HA  ,WCH_HA  },
    {'G'          , CAPLOK | KANALOK ,'g'       ,'G'       ,WCH_KI  ,WCH_KI  },
    {'H'          , CAPLOK | KANALOK ,'h'       ,'H'       ,WCH_KU  ,WCH_KU  },
    {'I'          , CAPLOK | KANALOK ,'i'       ,'I'       ,WCH_NI  ,WCH_NI  },
    {'J'          , CAPLOK | KANALOK ,'j'       ,'J'       ,WCH_MA  ,WCH_MA  },
    {'K'          , CAPLOK | KANALOK ,'k'       ,'K'       ,WCH_NO  ,WCH_NO  },
    {'L'          , CAPLOK | KANALOK ,'l'       ,'L'       ,WCH_RI  ,WCH_RI  },
    {'M'          , CAPLOK | KANALOK ,'m'       ,'M'       ,WCH_MO  ,WCH_MO  },
    {'N'          , CAPLOK | KANALOK ,'n'       ,'N'       ,WCH_MI  ,WCH_MI  },
    {'O'          , CAPLOK | KANALOK ,'o'       ,'O'       ,WCH_RA  ,WCH_RA  },
    {'P'          , CAPLOK | KANALOK ,'p'       ,'P'       ,WCH_SE  ,WCH_SE  },
    {'Q'          , CAPLOK | KANALOK ,'q'       ,'Q'       ,WCH_TA  ,WCH_TA  },
    {'R'          , CAPLOK | KANALOK ,'r'       ,'R'       ,WCH_SU  ,WCH_SU  },
    {'S'          , CAPLOK | KANALOK ,'s'       ,'S'       ,WCH_TO  ,WCH_TO  },
    {'T'          , CAPLOK | KANALOK ,'t'       ,'T'       ,WCH_KA  ,WCH_KA  },
    {'U'          , CAPLOK | KANALOK ,'u'       ,'U'       ,WCH_NA  ,WCH_NA  },
    {'V'          , CAPLOK | KANALOK ,'v'       ,'V'       ,WCH_HI  ,WCH_HI  },
    {'W'          , CAPLOK | KANALOK ,'w'       ,'W'       ,WCH_TE  ,WCH_TE  },
    {'X'          , CAPLOK | KANALOK ,'x'       ,'X'       ,WCH_SA  ,WCH_SA  },
    {'Y'          , CAPLOK | KANALOK ,'y'       ,'Y'       ,WCH_NN  ,WCH_NN  },
    {'Z'          , CAPLOK | KANALOK ,'z'       ,'Z'       ,WCH_TU  ,WCH_TUU },
    {VK_OEM_1     ,          KANALOK ,':'       ,'*'       ,WCH_KE  ,WCH_KE  },
    {VK_OEM_2     ,          KANALOK ,'/'       ,'?'       ,WCH_ME  ,WCH_MD  },
#if defined(JAPAN) && defined(_PC98_)
#else //_PC98_
    {VK_OEM_3     ,          KANALOK ,'@'       ,'`'       ,WCH_VS  ,WCH_VS  },
    {VK_OEM_7     ,          KANALOK ,'^'       ,'~'       ,WCH_HE  ,WCH_HE  },
    {VK_OEM_8     , 0                ,WCH_NONE  ,WCH_NONE  ,WCH_NONE,WCH_NONE},
#endif // _PC98_
    {VK_OEM_COMMA ,          KANALOK ,','       ,'<'       ,WCH_NE  ,WCH_IC  },
    {VK_OEM_PERIOD,          KANALOK ,'.'       ,'>'       ,WCH_RU  ,WCH_IP  },
    {VK_OEM_PLUS  ,          KANALOK ,';'       ,'+'       ,WCH_RE  ,WCH_RE  },
    {VK_TAB       , 0                ,'\t'      ,'\t'      ,'\t'    ,'\t'    },
    {VK_ADD       , 0                ,'+'       ,'+'       ,'+'     ,'+'     },
    {VK_DECIMAL   , 0                ,'.'       ,'.'       ,'.'     ,'.'     },
    {VK_DIVIDE    , 0                ,'/'       ,'/'       ,'/'     ,'/'     },
    {VK_MULTIPLY  , 0                ,'*'       ,'*'       ,'*'     ,'*'     },
    {VK_SUBTRACT  , 0                ,'-'       ,'-'       ,'-'     ,'-'     },
#if defined(JAPAN) && defined(_PC98_)
    {VK_SEPARATOR , 0                ,','       ,','       ,','     ,','     }, //<NEC_OCDE OEM
    {VK_OEM_NEC_EQUAL,    0          ,'='       ,'='       ,'='     ,'='     }, //<_PC98_ OEM
    {VK_NUMPAD0   , 0                ,'0'       ,'0'       ,'0'     ,'0'     },//_PC98_
    {VK_NUMPAD1   , 0                ,'1'       ,'1'       ,'1'     ,'1'     },//_PC98_
    {VK_NUMPAD2   , 0                ,'2'       ,'2'       ,'2'     ,'2'     },//_PC98_
    {VK_NUMPAD3   , 0                ,'3'       ,'3'       ,'3'     ,'3'     },//_PC98_
    {VK_NUMPAD4   , 0                ,'4'       ,'4'       ,'4'     ,'4'     },//_PC98_
    {VK_NUMPAD5   , 0                ,'5'       ,'5'       ,'5'     ,'5'     },//_PC98_
    {VK_NUMPAD6   , 0                ,'6'       ,'6'       ,'6'     ,'6'     },//_PC98_
    {VK_NUMPAD7   , 0                ,'7'       ,'7'       ,'7'     ,'7'     },//_PC98_
    {VK_NUMPAD8   , 0                ,'8'       ,'8'       ,'8'     ,'8'     },//_PC98_
    {VK_NUMPAD9   , 0                ,'9'       ,'9'       ,'9'     ,'9'     },//_PC98_
#endif // _PC98_
    {0            , 0                ,0         ,0         ,0       ,0       }
};

static ALLOC_SECTION_LDATA VK_TO_WCHARS6 aVkToWch6[] = {
    //                      |          |   SHIFT  |  KANA  | K+SHFT |  CONTROL  |  K+CTRL   |
    //                      |          |==========|========|========|===========|===========|
    {VK_BACK      , 0       ,'\b'      ,'\b'      ,'\b'    ,'\b'    , 0x7f      , 0x7f      },
    {VK_CANCEL    , 0       ,0x03      ,0x03      ,0x03    ,0x03    , 0x03      , 0x03      },
    {VK_ESCAPE    , 0       ,0x1b      ,0x1b      ,0x1b    ,0x1b    , 0x1b      , 0x1b      },
#if defined(JAPAN) && defined(_PC98_)
    {VK_OEM_3     , KANALOK ,'@'       ,'~'       ,WCH_VS  ,WCH_VS  , 0x00      , 0x00      },//_PC98_ #931208
    {VK_OEM_4     , KANALOK ,'['       ,'{'       ,WCH_SVS ,WCH_OB  , 0x1b      , 0x1b      },//_PC98_
    {VK_OEM_4     , KANALOK ,'['       ,'{'       ,WCH_SVS ,WCH_OB  , 0x1b      , 0x1b      },//_PC98_
    {VK_OEM_5     , KANALOK ,'\\'      ,'|'       ,WCH_PS  ,WCH_PS  , 0x1c      , 0x1c      },//_PC98_
    {VK_OEM_6     , KANALOK ,']'       ,'}'       ,WCH_MU  ,WCH_CB  , 0x1d      , 0x1d      },//_PC98_
    {VK_OEM_7     , KANALOK ,'^'       ,'`'       ,WCH_HE  ,WCH_HE  , 0x1e      , 0x1e      },//_PC98_ #931208
    {VK_OEM_8     , KANALOK ,WCH_NONE  ,'_'       ,WCH_RO  ,WCH_RO  , 0x1f      , 0x1f      },//_PC98_ #931208
#else //_PC98_
    {VK_OEM_4     , KANALOK ,'['       ,'{'       ,WCH_SVS ,WCH_OB  , 0x1b      , 0x1b      },
    {VK_OEM_5     , KANALOK ,'\\'      ,'|'       ,WCH_PS  ,WCH_PS  , 0x1c      , 0x1c      },
    {VK_OEM_102   , KANALOK ,'\\'      ,'_'       ,WCH_RO  ,WCH_RO  , 0x1c      , 0x1c      },
    {VK_OEM_6     , KANALOK ,']'       ,'}'       ,WCH_MU  ,WCH_CB  , 0x1d      , 0x1d      },
#endif // _PC98_
    {VK_RETURN    , 0       ,'\r'      ,'\r'      ,'\r'    ,'\r'    , '\n'      , '\n'      },
    {VK_SPACE     , 0       ,' '       ,' '       ,' '     ,' '     , 0x20      , 0x20      },
    {0            , 0       ,0         ,0         ,0       ,0       , 0         , 0         }
};

static ALLOC_SECTION_LDATA VK_TO_WCHARS8 aVkToWch8[] = {
    //                      |          |   SHIFT  |  KANA  | K+SHFT |  CONTROL  |  K+CTRL   | SHFT+CTRL |K+SHFT+CTRL|
    //                      |          |==========|========|========|===========|===========|===========|===========|
    {'2'          , KANALOK ,'2'       ,'"'       ,WCH_HU  ,WCH_HU  , WCH_NONE  , WCH_NONE  , 0x00      , 0x00      },
    {'6'          , KANALOK ,'6'       ,'&'       ,WCH_O   ,WCH_OO  , WCH_NONE  , WCH_NONE  , 0x1e      , 0x1e      },
    {VK_OEM_MINUS , KANALOK ,'-'       ,'='       ,WCH_HO  ,WCH_HO  , WCH_NONE  , WCH_NONE  , 0x1f      , 0x1f      },
    {0            , 0       ,0         ,0         ,0       ,0       , 0         , 0         , 0         , 0         }
};

// Put this last so that VkKeyScan interprets number characters
// as coming from the main section of the kbd (aVkToWch2 and
// aVkToWch4) before considering the numpad (aVkToWch1).

static ALLOC_SECTION_LDATA VK_TO_WCHARS4 aVkToWch1[] = {
    //                     |          |   SHIFT  |  KANA  | K+SHFT |
    //                     |          |==========|========|========|
    { VK_NUMPAD0   , 0      ,  '0'    , WCH_NONE ,   '0'  ,WCH_NONE},
    { VK_NUMPAD1   , 0      ,  '1'    , WCH_NONE ,   '1'  ,WCH_NONE},
    { VK_NUMPAD2   , 0      ,  '2'    , WCH_NONE ,   '2'  ,WCH_NONE},
    { VK_NUMPAD3   , 0      ,  '3'    , WCH_NONE ,   '3'  ,WCH_NONE},
    { VK_NUMPAD4   , 0      ,  '4'    , WCH_NONE ,   '4'  ,WCH_NONE},
    { VK_NUMPAD5   , 0      ,  '5'    , WCH_NONE ,   '5'  ,WCH_NONE},
    { VK_NUMPAD6   , 0      ,  '6'    , WCH_NONE ,   '6'  ,WCH_NONE},
    { VK_NUMPAD7   , 0      ,  '7'    , WCH_NONE ,   '7'  ,WCH_NONE},
    { VK_NUMPAD8   , 0      ,  '8'    , WCH_NONE ,   '8'  ,WCH_NONE},
    { VK_NUMPAD9   , 0      ,  '9'    , WCH_NONE ,   '9'  ,WCH_NONE},
    { 0            , 0      ,  '\0'   , 0        ,   0    ,0       }   //null terminator
};

/***************************************************************************\
* aVkToWcharTable: table of pointers to Character Tables
*
* Describes the character tables and the order they should be searched.
*
* Note: the order determines the behavior of VkKeyScan() : this function
*       takes a character and attempts to find a Virtual Key and character-
*       modifier key combination that produces that character.  The table
*       containing the numeric keypad (aVkToWch1) must appear last so that
*       VkKeyScan('0') will be interpreted as one of keys from the main
*       section, not the numpad.  etc.
\***************************************************************************/

static ALLOC_SECTION_LDATA VK_TO_WCHAR_TABLE aVkToWcharTable[] = {
    {  (PVK_TO_WCHARS1)aVkToWch6, 6, sizeof(aVkToWch6[0]) },
    {  (PVK_TO_WCHARS1)aVkToWch8, 8, sizeof(aVkToWch8[0]) },
    {  (PVK_TO_WCHARS1)aVkToWch4, 4, sizeof(aVkToWch4[0]) },
    {  (PVK_TO_WCHARS1)aVkToWch1, 4, sizeof(aVkToWch1[0]) },  // must come last
    {                       NULL, 0, 0                    }
};

/***************************************************************************\
* aKeyNames[], aKeyNamesExt[]  - Scan Code -> Key Name tables
*
* For the GetKeyNameText() API function
*
* Tables for non-extended and extended (KBDEXT) keys.
* (Keys producing printable characters are named by the character itself)
\***************************************************************************/

static ALLOC_SECTION_LDATA VSC_LPWSTR aKeyNames[] = {
#if defined(JAPAN) && defined(_PC98_)
    0x01,    L"ESC",            //NEC Esc
    0x0e,    L"BS",             //NEC Backspace
    0x0f,    L"TAB",            //NEC Tab
    0x1c,    L"RETURN",         //NEC Enter
    0x1d,    L"CTRL",           //NEC Ctrl
    0x2a,    L"SHIFT",          //NEC Shift
    0x36,    L"SHIFT",          //NEC Rgiht Shift
#else //_PC98_
    0x01,    L"Esc",
    0x0e,    L"Backspace",
    0x0f,    L"Tab",
    0x1c,    L"Enter",
    0x1d,    L"Ctrl",
    0x29,    (LPWSTR)SZ_KEY_NAME_HANKAKU_ZENKAKU,  // NLS Key
    0x2a,    L"Shift",
    0x36,    L"Right Shift",
#endif // _PC98_
    0x37,    L"Num *",
#if defined(JAPAN) && defined(_PC98_)
    0x38,    L"GRPH",           //NEC Alt
    0x39,    L"SPACE",          //NEC Space
    0x3a,    L"CAPS",           //NEC Caps Lock
    0x3b,    (LPWSTR)SZ_KEY_NAME_F1,    //NEC F1
    0x3c,    (LPWSTR)SZ_KEY_NAME_F2,    //NEC F2
    0x3d,    (LPWSTR)SZ_KEY_NAME_F3,    //NEC F3
    0x3e,    (LPWSTR)SZ_KEY_NAME_F4,    //NEC F4
    0x3f,    (LPWSTR)SZ_KEY_NAME_F5,    //NEC F5
    0x40,    (LPWSTR)SZ_KEY_NAME_F6,    //NEC F6
    0x41,    (LPWSTR)SZ_KEY_NAME_F7,    //NEC F7
    0x42,    (LPWSTR)SZ_KEY_NAME_F8,    //NEC F8
    0x43,    (LPWSTR)SZ_KEY_NAME_F9,    //NEC F9
    0x44,    (LPWSTR)SZ_KEY_NAME_F10,   //NEC F10
#else //_PC98_
    0x38,    L"Alt",
    0x39,    L"Space",
    0x3a,    L"Caps Lock",
    0x3b,    L"F1",
    0x3c,    L"F2",
    0x3d,    L"F3",
    0x3e,    L"F4",
    0x3f,    L"F5",
    0x40,    L"F6",
    0x41,    L"F7",
    0x42,    L"F8",
    0x43,    L"F9",
    0x44,    L"F10",
#endif // _PC98_
    0x45,    L"Pause",
    0x46,    L"Scroll Lock",
    0x47,    L"Num 7",
    0x48,    L"Num 8",
    0x49,    L"Num 9",
    0x4a,    L"Num -",
    0x4b,    L"Num 4",
    0x4c,    L"Num 5",
    0x4d,    L"Num 6",
    0x4e,    L"Num +",
    0x4f,    L"Num 1",
    0x50,    L"Num 2",
    0x51,    L"Num 3",
    0x52,    L"Num 0",
#if defined(JAPAN) && defined(_PC98_)
    0x53,    L"Num .",                    //NEC #931125
#else //_PC98_
    0x53,    L"Num Del",
#endif // _PC98_
    0x54,    L"Sys Req",
#if defined(JAPAN) && defined(_PC98_)
    0x55,    L"",                         //NEC <931125
    0x57,    (LPWSTR)SZ_KEY_NAME_F11,     //NEC
    0x58,    (LPWSTR)SZ_KEY_NAME_F12,     //NEC
    0x59,    L"Num =",                    //NEC
    0x5A,    L"NFER",                     //NEC
    0x5B,    L"Convert",                  //NEC not use
    0x5C,    L"Num ,",                    //NEC
    0x5D,    (LPWSTR)SZ_KEY_NAME_F13,     //NEC
    0x5E,    (LPWSTR)SZ_KEY_NAME_F14,     //NEC
    0x5F,    (LPWSTR)SZ_KEY_NAME_F15,     //NEC
#else  //  _PC98_
    0x57,    L"F11",
    0x58,    L"F12",
    0x70,    (LPWSTR)SZ_KEY_NAME_HIRAGANA,
    0x79,    (LPWSTR)SZ_KEY_NAME_HENKAN,
    0x7b,    (LPWSTR)SZ_KEY_NAME_MUHENKAN,
    0x7C,    L"F13",
#endif // _PC98_
    0   ,    NULL
};

static ALLOC_SECTION_LDATA VSC_LPWSTR aKeyNamesExt[] = {
#if defined(JAPAN) && defined(_PC98_)
    0x1c,    L"Num Enter",
    0x1d,    (LPWSTR)SZ_KEY_NAME_KANA,  //NEC NLS Key Katakana
    0x35,    L"Num /",
    0x37,    L"COPY",                   //NEC Prnt Scr
    0x38,    L"XFER",                   //NEC NLS Key SZ_KEY_NAME_HIRAGANA
    0x45,    L"Num Lock",
    0x46,    L"STOP",                   //NEC Break
    0x47,    L"CLR",                    //NEC Home #931125
    0x48,    L"UP",                     //NEC Up
    0x49,    L"ROLL DOWN",              //NEC Page Up
    0x4b,    L"LEFT",                   //NEC Left
    0x4d,    L"RIGHT",                  //NEC Right
    0x4f,    L"HELP",                   //NEC End  #931125
    0x50,    L"DOWN",                   //NEC Down
    0x51,    L"ROLL UP",                //NEC Page Down
    0x52,    L"INS",                    //NEC Insert
    0x53,    L"DEL",                    //NEC Delete
    0x54,    L"<00>",
    0x56,    L"HELP",                   //NEC Help
//    0x5C,    L"CLR",                    //NEC Clear
#else //_PC98_
    0x1c,    L"Num Enter",
    0x1d,    L"Right Control",
    0x35,    L"Num /",
    0x37,    L"Prnt Scrn",
    0x38,    L"Right Alt",
    0x45,    L"Num Lock",
    0x46,    L"Break",
    0x47,    L"Home",
    0x48,    L"Up",
    0x49,    L"Page Up",
    0x4b,    L"Left",
    0x4d,    L"Right",
    0x4f,    L"End",
    0x50,    L"Down",
    0x51,    L"Page Down",
    0x52,    L"Insert",
    0x53,    L"Delete",
#endif // _PC98_
    0x5B,    L"Left Windows",
    0x5C,    L"Right Windows",
    0x5D,    L"Application",
    0   ,    NULL
};

static ALLOC_SECTION_LDATA KBDTABLES KbdTables = {
    /*
     * Modifier keys
     */
    &CharModifiers,

    /*
     * Characters tables
     */
    aVkToWcharTable,

    /*
     * Diacritics  (none for US English)
     */
    NULL,

    /*
     * Names of Keys  (no dead keys)
     */
    aKeyNames,
    aKeyNamesExt,
    NULL,

    /*
     * Scan codes to Virtual Keys
     */
    ausVK,
    sizeof(ausVK) / sizeof(ausVK[0]),
    aE0VscToVk,
    aE1VscToVk,

    /*
     * No Locale-specific special processing
     */
    0,

    /*
     * No Ligatures
     */
    0, 0, NULL,

    /*
     * Type and subtype.
     */
    KEYBOARD_TYPE_JAPAN,    // Japanese Keyboard Layout
    MAKEWORD(NEC_KBD_N_MODE_TYPE, NLSKBD_OEM_NEC),
};

PKBDTABLES KbdLayerDescriptor(VOID)
{
    return &KbdTables;
}

/***********************************************************************\
* VkToFuncTable_106[]
*
\***********************************************************************/

static ALLOC_SECTION_LDATA VK_F VkToFuncTable_106[] = {
    {
        VK_DBE_ALPHANUMERIC,  // Base Vk
        KBDNLS_TYPE_TOGGLE,   // NLSFEProcType
        KBDNLS_INDEX_NORMAL,  // NLSFEProcCurrent
        0x02, /* 00000010 */  // NLSFEProcSwitch
        {                     // NLSFEProc
            {KBDNLS_ALPHANUM,0},               // Base
            {KBDNLS_SEND_PARAM_VK,VK_CAPITAL}, // Shift
            {KBDNLS_ALPHANUM,0},               // Control
            {KBDNLS_ALPHANUM,0},               // Shift+Control
            {KBDNLS_ALPHANUM,0},               // Alt
            {KBDNLS_ALPHANUM,0},               // Shift+Alt
            {KBDNLS_CODEINPUT,0},              // Control+Alt
            {KBDNLS_CODEINPUT,0}               // Shift+Control+Alt
        },
        {                     // NLSFEProcAlt
            {KBDNLS_SEND_PARAM_VK,VK_CAPITAL}, // Base
            {KBDNLS_SEND_PARAM_VK,VK_CAPITAL}, // Shift
            {KBDNLS_NOEVENT,0},                // Control
            {KBDNLS_NOEVENT,0},                // Shift+Control
            {KBDNLS_NOEVENT,0},                // Alt
            {KBDNLS_NOEVENT,0},                // Shift+Alt
            {KBDNLS_NOEVENT,0},                // Control+Alt
            {KBDNLS_NOEVENT,0}                 // Shift+Control+Alt
        }
    },
    {
        VK_DBE_HIRAGANA,     // Base Vk
        KBDNLS_TYPE_TOGGLE,  // NLSFEProcType
        KBDNLS_INDEX_NORMAL, // NLSFEProcCurrent
        0x08, /* 00001000 */ // NLSFEProcSwitch
        {                    // NLSFEProc
            {KBDNLS_HIRAGANA,0},             // Base
            {KBDNLS_KATAKANA,0},             // Shift
            {KBDNLS_HIRAGANA,0},             // Control
            {KBDNLS_SEND_PARAM_VK,VK_KANA},  // Shift+Control
            {KBDNLS_ROMAN,0},                // Alt
            {KBDNLS_ROMAN,0},                // Shift+Alt
            {KBDNLS_ROMAN,0},                // Control+Alt
            {KBDNLS_NOEVENT,0}               // Shift+Control+Alt
        },
        {                    // NLSFEProcIndexAlt
            {KBDNLS_SEND_PARAM_VK,VK_KANA},  // Base
            {KBDNLS_SEND_PARAM_VK,VK_KANA},  // Shift
            {KBDNLS_SEND_PARAM_VK,VK_KANA},  // Control
            {KBDNLS_SEND_PARAM_VK,VK_KANA},  // Shift+Control
            {KBDNLS_NOEVENT,0},              // Alt
            {KBDNLS_NOEVENT,0},              // Shift+Alt
            {KBDNLS_NOEVENT,0},              // Control+Alt
            {KBDNLS_NOEVENT,0}               // Shift+Control+Alt
        }
    },
    {
        VK_DBE_SBCSCHAR,     // Base Vk
        KBDNLS_TYPE_NORMAL,  // NLSFEProcType
        KBDNLS_INDEX_NORMAL, // NLSFEProcCurrent
        0x0,                 // NLSFEProcSwitch
        {                    // NLSFEProc
            {KBDNLS_SBCSDBCS,0},             // Base
            {KBDNLS_SBCSDBCS,0},             // Shift
            {KBDNLS_SBCSDBCS,0},             // Control
            {KBDNLS_SBCSDBCS,0},             // Shift+Control
            {KBDNLS_SEND_PARAM_VK,VK_KANJI}, // Alt
            {KBDNLS_SBCSDBCS,0},             // Shift+Alt
            {KBDNLS_SEND_PARAM_VK,VK_DBE_ENTERIMECONFIGMODE}, // Control+Alt
            {KBDNLS_SEND_PARAM_VK,VK_DBE_ENTERIMECONFIGMODE}  // Shift+Control+Alt
        },
        {                    // NLSFEProcIndexAlt
            {KBDNLS_NULL,0},  // Base
            {KBDNLS_NULL,0},  // Shift
            {KBDNLS_NULL,0},  // Control
            {KBDNLS_NULL,0},  // Shift+Control
            {KBDNLS_NULL,0},  // Alt
            {KBDNLS_NULL,0},  // Shift+Alt
            {KBDNLS_NULL,0},  // Control+Alt
            {KBDNLS_NULL,0}   // Shift+Control+Alt
        }
    },
    {
        VK_NONCONVERT,       // Base Vk
        KBDNLS_TYPE_NORMAL,  // NLSFEProcType
        KBDNLS_INDEX_NORMAL, // NLSFEProcCurrent
        0x0,                 // NLSFEProcSwitch
        {                    // NLSFEProc
            {KBDNLS_SEND_BASE_VK,0},         // Base
            {KBDNLS_SEND_BASE_VK,0},         // Shift
            {KBDNLS_SEND_BASE_VK,0},         // Control
            {KBDNLS_SEND_BASE_VK,0},         // Shift+Control
            {KBDNLS_SEND_BASE_VK,0},         // Alt
            {KBDNLS_SEND_BASE_VK,0},         // Shift+Alt
            {KBDNLS_SEND_PARAM_VK,VK_DBE_ENTERWORDREGISTERMODE}, // Control+Alt
            {KBDNLS_SEND_PARAM_VK,VK_DBE_ENTERWORDREGISTERMODE}  // Shift+Control+Alt
        },
        {                         // NLSFEProcIndexAlt
            {KBDNLS_NULL,0},  // Base
            {KBDNLS_NULL,0},  // Shift
            {KBDNLS_NULL,0},  // Control
            {KBDNLS_NULL,0},  // Shift+Control
            {KBDNLS_NULL,0},  // Alt
            {KBDNLS_NULL,0},  // Shift+Alt
            {KBDNLS_NULL,0},  // Control+Alt
            {KBDNLS_NULL,0}   // Shift+Control+Alt
        }
    }
};

#if defined(JAPAN) && defined(_PC98_)
static ALLOC_SECTION_LDATA VK_F VkToFuncTable_NEC[] = {
    {
        VK_NONCONVERT,       // Base Vk  PC98_NFER key
        KBDNLS_TYPE_NORMAL,  // NLSFEProcType
        KBDNLS_INDEX_NORMAL, // NLSFEProcCurrent
        0x0,                 // NLSFEProcSwitch
        {                    // NLSFEProc
            {KBDNLS_SEND_BASE_VK,0},                             // Base
            {KBDNLS_SEND_BASE_VK,0},                             // Shift
            {KBDNLS_SEND_PARAM_VK,VK_DBE_ALPHANUMERIC},          // Control
            {KBDNLS_SBCSDBCS,0},                                 // Shift+Control
            {KBDNLS_SEND_PARAM_VK,VK_DBE_KATAKANA},              // Alt
            {KBDNLS_SEND_PARAM_VK,VK_DBE_ENTERWORDREGISTERMODE}, // Shift+Alt
            {KBDNLS_SEND_PARAM_VK,VK_DBE_NOCODEINPUT},           // Control+Alt
            {KBDNLS_SEND_PARAM_VK,VK_DBE_FLUSHSTRING}            // Shift+Control+Alt
        },
        {                     // NLSFEProcIndexAlt
            {KBDNLS_NULL,0},  // Base
            {KBDNLS_NULL,0},  // Shift
            {KBDNLS_NULL,0},  // Control
            {KBDNLS_NULL,0},  // Shift+Control
            {KBDNLS_NULL,0},  // Alt
            {KBDNLS_NULL,0},  // Shift+Alt
            {KBDNLS_NULL,0},  // Control+Alt
            {KBDNLS_NULL,0}   // Shift+Control+Alt
        }
    },
    {
        VK_KANJI,            // Base Vk  PC98_XFER key
        KBDNLS_TYPE_NORMAL,  // NLSFEProcType
        KBDNLS_INDEX_NORMAL, // NLSFEProcCurrent
        0x0,                 // NLSFEProcSwitch
        {                    // NLSFEProc
            {KBDNLS_SEND_PARAM_VK,VK_CONVERT},                // Base
            {KBDNLS_SEND_PARAM_VK,VK_CONVERT},                // Shift
            {KBDNLS_SEND_BASE_VK,0},                          // Control
            {KBDNLS_SEND_PARAM_VK,VK_CONVERT},                // Shift+Control
            {KBDNLS_ROMAN,0},                                 // Alt
            {KBDNLS_SEND_PARAM_VK,VK_DBE_ENTERIMECONFIGMODE}, // Shift+Alt
            {KBDNLS_SEND_PARAM_VK,VK_DBE_CODEINPUT},          // Control+Alt
            {KBDNLS_SEND_PARAM_VK,VK_DBE_HIRAGANA}            // Shift+Control+Alt
        },
        {                     // NLSFEProcIndexAlt
            {KBDNLS_NULL,0},  // Base
            {KBDNLS_NULL,0},  // Shift
            {KBDNLS_NULL,0},  // Control
            {KBDNLS_NULL,0},  // Shift+Control
            {KBDNLS_NULL,0},  // Alt
            {KBDNLS_NULL,0},  // Shift+Alt
            {KBDNLS_NULL,0},  // Control+Alt
            {KBDNLS_NULL,0}   // Shift+Control+Alt
        }
    },
    {
        VK_OEM_NEC_EQUAL,    // Base Vk  PC98_"="  key
        KBDNLS_TYPE_NORMAL,  // NLSFEProcType
        KBDNLS_INDEX_NORMAL, // NLSFEProcCurrent
        0x0,                 // NLSFEProcSwitch
        {                    // NLSFEProc
            {KBDNLS_SEND_BASE_VK,0},                  // Base
            {KBDNLS_SEND_BASE_VK,0},                  // Shift
            {KBDNLS_SEND_PARAM_VK,VK_SCROLL},         // Control
            {KBDNLS_SEND_BASE_VK,0},                  // Shift+Control
            {KBDNLS_SEND_BASE_VK,0},                  // Alt
            {KBDNLS_SEND_BASE_VK,0},                  // Shift+Alt
            {KBDNLS_SEND_BASE_VK,0},                  // Control+Alt
            {KBDNLS_SEND_BASE_VK,0}                   // Shift+Control+Alt
        },
        {                     // NLSFEProcIndexAlt
            {KBDNLS_NULL,0},  // Base
            {KBDNLS_NULL,0},  // Shift
            {KBDNLS_NULL,0},  // Control
            {KBDNLS_NULL,0},  // Shift+Control
            {KBDNLS_NULL,0},  // Alt
            {KBDNLS_NULL,0},  // Shift+Alt
            {KBDNLS_NULL,0},  // Control+Alt
            {KBDNLS_NULL,0}   // Shift+Control+Alt
        }
    },
    {
        VK_HOME,             // Base Vk  PC98_HOME  key
        KBDNLS_TYPE_NORMAL,  // NLSFEProcType
        KBDNLS_INDEX_NORMAL, // NLSFEProcCurrent
        0x0,                 // NLSFEProcSwitch
        {                    // NLSFEProc
            {KBDNLS_HOME_OR_CLEAR,0},         // Base
            {KBDNLS_SEND_BASE_VK,0},          // Shift
            {KBDNLS_HOME_OR_CLEAR,0},         // Control
            {KBDNLS_HOME_OR_CLEAR,0},         // Shift+Control
            {KBDNLS_HOME_OR_CLEAR,0},         // Alt
            {KBDNLS_HOME_OR_CLEAR,0},         // Shift+Alt
            {KBDNLS_HOME_OR_CLEAR,0},         // Control+Alt
            {KBDNLS_HOME_OR_CLEAR,0}          // Shift+Control+Alt
        },
        {                     // NLSFEProcIndexAlt
            {KBDNLS_NULL,0},  // Base
            {KBDNLS_NULL,0},  // Shift
            {KBDNLS_NULL,0},  // Control
            {KBDNLS_NULL,0},  // Shift+Control
            {KBDNLS_NULL,0},  // Alt
            {KBDNLS_NULL,0},  // Shift+Alt
            {KBDNLS_NULL,0},  // Control+Alt
            {KBDNLS_NULL,0}   // Shift+Control+Alt
        }
    },
    {
        VK_END,              // Base Vk  PC98_HELP  key
        KBDNLS_TYPE_NORMAL,  // NLSFEProcType
        KBDNLS_INDEX_NORMAL, // NLSFEProcCurrent
        0x0,                 // NLSFEProcSwitch
        {                    // NLSFEProc
            {KBDNLS_HELP_OR_END,0},         // Base
            {KBDNLS_HELP_OR_END,0},         // Shift
            {KBDNLS_HELP_OR_END,0},         // Control
            {KBDNLS_HELP_OR_END,0},         // Shift+Control
            {KBDNLS_HELP_OR_END,0},         // Alt
            {KBDNLS_HELP_OR_END,0},         // Shift+Alt
            {KBDNLS_HELP_OR_END,0},         // Control+Alt
            {KBDNLS_HELP_OR_END,0}          // Shift+Control+Alt
        },
        {                     // NLSFEProcIndexAlt
            {KBDNLS_NULL,0},  // Base
            {KBDNLS_NULL,0},  // Shift
            {KBDNLS_NULL,0},  // Control
            {KBDNLS_NULL,0},  // Shift+Control
            {KBDNLS_NULL,0},  // Alt
            {KBDNLS_NULL,0},  // Shift+Alt
            {KBDNLS_NULL,0},  // Control+Alt
            {KBDNLS_NULL,0}   // Shift+Control+Alt
        }
    }
};

USHORT ausMouseVKey98[] = {
                       VK_NUMPAD5,
                       VK_NUMPAD9,
                       VK_NUMPAD3,
                       VK_NUMPAD1,
                       VK_NUMPAD7,
                       VK_NUMPAD4,
                       VK_NUMPAD8,
                       VK_NUMPAD6,
                       VK_NUMPAD2,
                       VK_NUMPAD0,
                       VK_DECIMAL,
                       VK_MULTIPLY,
                       VK_ADD,
                       VK_SUBTRACT,
                       VK_DIVIDE | KBDEXT,
                       VK_HOME | KBDEXT
                      };

#else //_PC98_
#endif // _PC98_
/***********************************************************************\
* KbdNlsTables
*
\***********************************************************************/

static ALLOC_SECTION_LDATA KBDNLSTABLES KbdNlsTables = {
#if defined(JAPAN) && defined(_PC98_)
    0x0d,                            // OEM ID (0x0d = NEC)
    NLSKBD_INFO_ACCESSIBILITY_KEYMAP,// Information
    5,                               // Number of VK_F entry
    VkToFuncTable_NEC,               // Pointer to VK_F array
    16,                              // Number of MouseVk entry
    ausMouseVKey98                   // Pointer to MouseVk array
#else //_PC98_
    0,                      // OEM ID (0 = Microsoft)
    0,                      // Information
    4,                      // Number of VK_F entry
    VkToFuncTable_106,      // Pointer to VK_F array
    0,                      // Number of MouseVk entry
    NULL                    // Pointer to MouseVk array
#endif // _PC98_
};

PKBDNLSTABLES KbdNlsLayerDescriptor(VOID)
{
    return &KbdNlsTables;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kbd\fe_kbds\jpn\kbdnecat\kbdnecat.c ===
#if defined(_PC98_)
/***************************************************************************\
* Module Name: kbdnec.c
*
* Copyright (c) 1985-92, NEC Corporation
*
* History:
\***************************************************************************/
#else // defined(_PC98_)
/***************************************************************************\
* Module Name: kbd106.c
*
* Copyright (c) 1985-92, Microsoft Corporation
*
* History:
\***************************************************************************/
#endif // defined(_PC98_)

#include <windows.h>
#include <ime.h>
#include "vkoem.h"
#include "kbdjpn.h"
#if defined(_PC98_)
#include "kbdnecAT.h"
#else // defined(_PC98_)
#include "kbd106.h"
#endif // defined(_PC98_)

#if defined(_M_IA64)
#pragma section(".data")
#define ALLOC_SECTION_LDATA __declspec(allocate(".data"))
#else
#pragma data_seg(".data")
#define ALLOC_SECTION_LDATA
#endif

#if defined(_PC98_)
/***************************************************************************\
* ausVK[] - Virtual Scan Code to Virtual Key conversion table for NEC 106
\***************************************************************************/
#else // defined(_PC98_)
/***************************************************************************\
* ausVK[] - Virtual Scan Code to Virtual Key conversion table for 106
\***************************************************************************/
#endif // defined(_PC98_)

static ALLOC_SECTION_LDATA USHORT ausVK[] = {
    T00, T01, T02, T03, T04, T05, T06, T07,
    T08, T09, T0A, T0B, T0C, T0D, T0E, T0F,
    T10, T11, T12, T13, T14, T15, T16, T17,
    T18, T19, T1A, T1B, T1C, T1D, T1E, T1F,
    T20, T21, T22, T23, T24, T25, T26, T27,
    T28,

    /*
     * Hankaku/Zenkaku/Kanji key must have KBDSPECIAL bit set (NLS key)
     */
    T29 | KBDSPECIAL,

              T2A, T2B, T2C, T2D, T2E, T2F,
    T30, T31, T32, T33, T34, T35,

    /*
     * Right-hand Shift key must have KBDEXT bit set.
     */
    T36 | KBDEXT,

#if defined(_PC98_)
    T37,
#else // defined(_PC98_)
    /*
     * numpad_* + Shift/Alt -> SnapShot
     */
    T37 | KBDMULTIVK,
#endif // defined(_PC98_)

    T38, T39,

#if defined(_PC98_)
    T3A,
#else // defined(_PC98_)
    /*
     * Alphanumeric/CapsLock key must have KBDSPECIAL bit set (NLS key)
     */
    T3A | KBDSPECIAL,
#endif // defined(_PC98_)

                   T3B, T3C, T3D, T3E, T3F,
    T40, T41, T42, T43, T44,

    /*
     * NumLock Key:
     *     KBDEXT     - VK_NUMLOCK is an Extended key
     *     KBDMULTIVK - VK_NUMLOCK or VK_PAUSE (without or with CTRL)
     */
    T45 | KBDEXT | KBDMULTIVK,

#if defined(_PC98_)
    T46,
#else // defined(_PC98_)
    T46 | KBDMULTIVK,
#endif // defined(_PC98_)

    /*
     * Number Pad keys:
     *     KBDNUMPAD  - digits 0-9 and decimal point.
     *     KBDSPECIAL - require special processing by Windows
     */
    T47 | KBDNUMPAD | KBDSPECIAL,   // Numpad 7 (Home)
    T48 | KBDNUMPAD | KBDSPECIAL,   // Numpad 8 (Up),
    T49 | KBDNUMPAD | KBDSPECIAL,   // Numpad 9 (PgUp),
    T4A,
    T4B | KBDNUMPAD | KBDSPECIAL,   // Numpad 4 (Left),
    T4C | KBDNUMPAD | KBDSPECIAL,   // Numpad 5 (Clear),
    T4D | KBDNUMPAD | KBDSPECIAL,   // Numpad 6 (Right),
    T4E,
    T4F | KBDNUMPAD | KBDSPECIAL,   // Numpad 1 (End),
    T50 | KBDNUMPAD | KBDSPECIAL,   // Numpad 2 (Down),
    T51 | KBDNUMPAD | KBDSPECIAL,   // Numpad 3 (PgDn),
    T52 | KBDNUMPAD | KBDSPECIAL,   // Numpad 0 (Ins),
    T53 | KBDNUMPAD | KBDSPECIAL,   // Numpad . (Del),

#if defined(_PC98_)
    T54, T55, T56, T57, T58,
    T59 | KBDSPECIAL,               // TenKey EQU (VK_SCROLL)
                                  T5A, T5B,
#else // defined(_PC98_)
    T54, T55, T56, T57, T58, T59, T5A, T5B,
#endif // defined(_PC98_)

    T5C, T5D, T5E, T5F, T60, T61, T62, T63,
    T64, T65, T66, T67, T68, T69, T6A, T6B,
    T6C, T6D, T6E, T6F,

    /*
     * Hiragana/Katakana/Roman key must have KBDSPECIAL bit set (NLS key)
     */
#if defined(_PC98_)
    T70,
#else // defined(_PC98_)
    T70 | KBDSPECIAL,
#endif // defined(_PC98_)

                             T71, T72, T73,
    T74, T75, T76, T77, T78,

    /*
     * Conversion key must have KBDSPECIAL bit set (NLS key)
     */
    T79 | KBDSPECIAL,

                                  T7A,

    /*
     * Non-Conversion key must have KBDSPECIAL bit set (NLS key)
     */
    T7B | KBDSPECIAL,

    T7C, T7D, T7E, T7F
};

static ALLOC_SECTION_LDATA VSC_VK aE0VscToVk[] = {
        { 0x1C, X1C | KBDEXT              },  // Numpad Enter
        { 0x1D, X1D | KBDEXT              },  // RControl
        { 0x35, X35 | KBDEXT              },  // Numpad Divide
        { 0x37, X37 | KBDEXT              },  // Snapshot
        { 0x38, X38 | KBDEXT              },  // RMenu
        { 0x46, X46 | KBDEXT              },  // Break (Ctrl + Pause)
#if defined(_PC98_)
        { 0x47, X47 | KBDEXT | KBDSPECIAL },  // CLR HOME
#else // defined(_PC98_)
        { 0x47, X47 | KBDEXT              },  // Home
#endif // defined(_PC98_)
        { 0x48, X48 | KBDEXT              },  // Up
        { 0x49, X49 | KBDEXT              },  // Prior
        { 0x4B, X4B | KBDEXT              },  // Left
        { 0x4D, X4D | KBDEXT              },  // Right
#if defined(_PC98_)
        { 0x4F, X4F | KBDEXT | KBDSPECIAL },  // HELP
#else // defined(_PC98_)
        { 0x4F, X4F | KBDEXT              },  // End
#endif // defined(_PC98_)
        { 0x50, X50 | KBDEXT              },  // Down
        { 0x51, X51 | KBDEXT              },  // Next
        { 0x52, X52 | KBDEXT              },  // Insert
        { 0x53, X53 | KBDEXT              },  // Delete
        { 0x5B, X5B | KBDEXT              },  // Left Win
        { 0x5C, X5C | KBDEXT              },  // Right Win
        { 0x5D, X5D | KBDEXT              },  // Application
        { 0,      0                       }
};

static ALLOC_SECTION_LDATA VSC_VK aE1VscToVk[] = {
        { 0x1D, Y1D                       },  // Pause
        { 0   ,   0                       }
};

/***************************************************************************\
* aVkToBits[]  - map Virtual Keys to Modifier Bits
*
* See kbd.h for a full description.
*
* US Keyboard has only three shifter keys:
*     SHIFT (L & R) affects alphabnumeric keys,
*     CTRL  (L & R) is used to generate control characters
*     ALT   (L & R) used for generating characters by number with numpad
\***************************************************************************/

static ALLOC_SECTION_LDATA VK_TO_BIT aVkToBits[] = {
    { VK_SHIFT,   KBDSHIFT },
    { VK_CONTROL, KBDCTRL  },
    { VK_MENU,    KBDALT   },
    { VK_KANA,    KBDKANA  },
    { 0,          0        }
};

/***************************************************************************\
* aModification[]  - map character modifier bits to modification number
*
* See kbd.h for a full description.
*
\***************************************************************************/

static ALLOC_SECTION_LDATA MODIFIERS CharModifiers = {
    &aVkToBits[0],
    11,
    {
    //  Modification# //  Keys Pressed  : Explanation
    //  ============= // ============== : =============================
        0,            //                : unshifted characters
        1,            //          SHIFT : capitals, ~!@#$%^&*()_+{}:"<>? etc.
        4,            //     CTRL       : control characters
        6,            //     CTRL SHIFT :
        SHFT_INVALID, // ALT            : invalid
        SHFT_INVALID, // ALT      SHIFT : invalid
        SHFT_INVALID, // ALT CTRL       : invalid
        SHFT_INVALID, // ALT CTRL SHIFT : invalid
        2,            //KANA
        3,            //KANA      SHIFT
        5,            //KANA CTRL
        7             //KANA CTRL SHIFT
    }
};

/***************************************************************************\
*
* aVkToWch2[]  - Virtual Key to WCHAR translation for 2 shift states
* aVkToWch3[]  - Virtual Key to WCHAR translation for 3 shift states
* aVkToWch4[]  - Virtual Key to WCHAR translation for 4 shift states
*
* Table attributes: Unordered Scan, null-terminated
*
* Search this table for an entry with a matching Virtual Key to find the
* corresponding unshifted and shifted WCHAR characters.
*
* Reserved VirtualKey values (first column)
*     -1            - this line contains dead characters (diacritic)
*     0             - terminator
*
* Reserved Attribute values (second column)
*     CAPLOK        - CapsLock affects this key like Shift
*     KANALOK       - The KANA-LOCK key affects this key like KANA
*
* Reserved character values (third through last column)
*     WCH_NONE      - No character
*     WCH_DEAD      - Dead character (diacritic) value is in next line
*
\***************************************************************************/

static ALLOC_SECTION_LDATA VK_TO_WCHARS4 aVkToWch4[] = {
    //                               |          |   SHIFT  |  KANA  | K+SHFT |
    //                               |          |==========|========|========|
#if defined(_PC98_)
    {'0'          ,          KANALOK ,'0'       ,'0'       ,WCH_WA  ,WCH_WO  },
#else // defined(_PC98_)
    {'0'          ,          KANALOK ,'0'       ,WCH_NONE  ,WCH_WA  ,WCH_WO  },
#endif // defined(_PC98_)
    {'1'          ,          KANALOK ,'1'       ,'!'       ,WCH_NU  ,WCH_NU  },
    {'3'          ,          KANALOK ,'3'       ,'#'       ,WCH_A   ,WCH_AA  },
    {'4'          ,          KANALOK ,'4'       ,'$'       ,WCH_U   ,WCH_UU  },
    {'5'          ,          KANALOK ,'5'       ,'%'       ,WCH_E   ,WCH_EE  },
    {'7'          ,          KANALOK ,'7'       ,0x27      ,WCH_YA  ,WCH_YAA },
    {'8'          ,          KANALOK ,'8'       ,'('       ,WCH_YU  ,WCH_YUU },
    {'9'          ,          KANALOK ,'9'       ,')'       ,WCH_YO  ,WCH_YOO },
    {'A'          , CAPLOK | KANALOK ,'a'       ,'A'       ,WCH_TI  ,WCH_TI  },
    {'B'          , CAPLOK | KANALOK ,'b'       ,'B'       ,WCH_KO  ,WCH_KO  },
    {'C'          , CAPLOK | KANALOK ,'c'       ,'C'       ,WCH_SO  ,WCH_SO  },
    {'D'          , CAPLOK | KANALOK ,'d'       ,'D'       ,WCH_SI  ,WCH_SI  },
    {'E'          , CAPLOK | KANALOK ,'e'       ,'E'       ,WCH_I   ,WCH_II  },
    {'F'          , CAPLOK | KANALOK ,'f'       ,'F'       ,WCH_HA  ,WCH_HA  },
    {'G'          , CAPLOK | KANALOK ,'g'       ,'G'       ,WCH_KI  ,WCH_KI  },
    {'H'          , CAPLOK | KANALOK ,'h'       ,'H'       ,WCH_KU  ,WCH_KU  },
    {'I'          , CAPLOK | KANALOK ,'i'       ,'I'       ,WCH_NI  ,WCH_NI  },
    {'J'          , CAPLOK | KANALOK ,'j'       ,'J'       ,WCH_MA  ,WCH_MA  },
    {'K'          , CAPLOK | KANALOK ,'k'       ,'K'       ,WCH_NO  ,WCH_NO  },
    {'L'          , CAPLOK | KANALOK ,'l'       ,'L'       ,WCH_RI  ,WCH_RI  },
    {'M'          , CAPLOK | KANALOK ,'m'       ,'M'       ,WCH_MO  ,WCH_MO  },
    {'N'          , CAPLOK | KANALOK ,'n'       ,'N'       ,WCH_MI  ,WCH_MI  },
    {'O'          , CAPLOK | KANALOK ,'o'       ,'O'       ,WCH_RA  ,WCH_RA  },
    {'P'          , CAPLOK | KANALOK ,'p'       ,'P'       ,WCH_SE  ,WCH_SE  },
    {'Q'          , CAPLOK | KANALOK ,'q'       ,'Q'       ,WCH_TA  ,WCH_TA  },
    {'R'          , CAPLOK | KANALOK ,'r'       ,'R'       ,WCH_SU  ,WCH_SU  },
    {'S'          , CAPLOK | KANALOK ,'s'       ,'S'       ,WCH_TO  ,WCH_TO  },
    {'T'          , CAPLOK | KANALOK ,'t'       ,'T'       ,WCH_KA  ,WCH_KA  },
    {'U'          , CAPLOK | KANALOK ,'u'       ,'U'       ,WCH_NA  ,WCH_NA  },
    {'V'          , CAPLOK | KANALOK ,'v'       ,'V'       ,WCH_HI  ,WCH_HI  },
    {'W'          , CAPLOK | KANALOK ,'w'       ,'W'       ,WCH_TE  ,WCH_TE  },
    {'X'          , CAPLOK | KANALOK ,'x'       ,'X'       ,WCH_SA  ,WCH_SA  },
    {'Y'          , CAPLOK | KANALOK ,'y'       ,'Y'       ,WCH_NN  ,WCH_NN  },
    {'Z'          , CAPLOK | KANALOK ,'z'       ,'Z'       ,WCH_TU  ,WCH_TUU },
    {VK_OEM_1     ,          KANALOK ,':'       ,'*'       ,WCH_KE  ,WCH_KE  },
    {VK_OEM_2     ,          KANALOK ,'/'       ,'?'       ,WCH_ME  ,WCH_MD  },
#if defined(_PC98_)
#else // defined(_PC98_)
    {VK_OEM_3     ,          KANALOK ,'@'       ,'`'       ,WCH_VS  ,WCH_VS  },
    {VK_OEM_7     ,          KANALOK ,'^'       ,'~'       ,WCH_HE  ,WCH_HE  },
    {VK_OEM_8     , 0                ,WCH_NONE  ,WCH_NONE  ,WCH_NONE,WCH_NONE},
#endif // defined(_PC98_)
    {VK_OEM_COMMA ,          KANALOK ,','       ,'<'       ,WCH_NE  ,WCH_IC  },
    {VK_OEM_PERIOD,          KANALOK ,'.'       ,'>'       ,WCH_RU  ,WCH_IP  },
    {VK_OEM_PLUS  ,          KANALOK ,';'       ,'+'       ,WCH_RE  ,WCH_RE  },
    {VK_TAB       , 0                ,'\t'      ,'\t'      ,'\t'    ,'\t'    },
    {VK_ADD       , 0                ,'+'       ,'+'       ,'+'     ,'+'     },
    {VK_DECIMAL   , 0                ,'.'       ,'.'       ,'.'     ,'.'     },
    {VK_DIVIDE    , 0                ,'/'       ,'/'       ,'/'     ,'/'     },
    {VK_MULTIPLY  , 0                ,'*'       ,'*'       ,'*'     ,'*'     },
    {VK_SUBTRACT  , 0                ,'-'       ,'-'       ,'-'     ,'-'     },
#if defined(_PC98_)
    {VK_SEPARATOR , 0                ,','       ,','       ,','     ,','     },
    {VK_OEM_NEC_EQUAL,    0          ,'='       ,'='       ,'='     ,'='     },
#endif // defined(_PC98_)
    {0            , 0                ,0         ,0         ,0       ,0       }
};

static ALLOC_SECTION_LDATA VK_TO_WCHARS6 aVkToWch6[] = {
    //                      |          |   SHIFT  |  KANA  | K+SHFT |  CONTROL  |  K+CTRL   |
    //                      |          |==========|========|========|===========|===========|
    {VK_BACK      , 0       ,'\b'      ,'\b'      ,'\b'    ,'\b'    , 0x7f      , 0x7f      },
    {VK_CANCEL    , 0       ,0x03      ,0x03      ,0x03    ,0x03    , 0x03      , 0x03      },
    {VK_ESCAPE    , 0       ,0x1b      ,0x1b      ,0x1b    ,0x1b    , 0x1b      , 0x1b      },
#if defined(_PC98_)
    {VK_OEM_3     , KANALOK ,'@'       ,'~'       ,WCH_VS  ,WCH_VS  , 0x00      , 0x00      },
    {VK_OEM_4     , KANALOK ,'['       ,'{'       ,WCH_SVS ,WCH_OB  , 0x1b      , 0x1b      },
    {VK_OEM_5     , KANALOK ,'\\'      ,'|'       ,WCH_PS  ,WCH_PS  , 0x1c      , 0x1c      },
    {VK_OEM_6     , KANALOK ,']'       ,'}'       ,WCH_MU  ,WCH_CB  , 0x1d      , 0x1d      },
    {VK_OEM_7     , KANALOK ,'^'       ,'`'       ,WCH_HE  ,WCH_HE  , 0x1e      , 0x1e      },
    {VK_OEM_8     , KANALOK ,WCH_NONE  ,'_'       ,WCH_RO  ,WCH_RO  , 0x1f      , 0x1f      },
#else // defined(_PC98_)
    {VK_OEM_4     , KANALOK ,'['       ,'{'       ,WCH_SVS ,WCH_OB  , 0x1b      , 0x1b      },
    {VK_OEM_5     , KANALOK ,'\\'      ,'|'       ,WCH_PS  ,WCH_PS  , 0x1c      , 0x1c      },
    {VK_OEM_102   , KANALOK ,'\\'      ,'_'       ,WCH_RO  ,WCH_RO  , 0x1c      , 0x1c      },
    {VK_OEM_6     , KANALOK ,']'       ,'}'       ,WCH_MU  ,WCH_CB  , 0x1d      , 0x1d      },
#endif // defined(_PC98_)
    {VK_RETURN    , 0       ,'\r'      ,'\r'      ,'\r'    ,'\r'    , '\n'      , '\n'      },
    {VK_SPACE     , 0       ,' '       ,' '       ,' '     ,' '     , 0x20      , 0x20      },
    {0            , 0       ,0         ,0         ,0       ,0       , 0         , 0         }
};

static ALLOC_SECTION_LDATA VK_TO_WCHARS8 aVkToWch8[] = {
    //                      |          |   SHIFT  |  KANA  | K+SHFT |  CONTROL  |  K+CTRL   | SHFT+CTRL |K+SHFT+CTRL|
    //                      |          |==========|========|========|===========|===========|===========|===========|
    {'2'          , KANALOK ,'2'       ,'"'       ,WCH_HU  ,WCH_HU  , WCH_NONE  , WCH_NONE  , 0x00      , 0x00      },
    {'6'          , KANALOK ,'6'       ,'&'       ,WCH_O   ,WCH_OO  , WCH_NONE  , WCH_NONE  , 0x1e      , 0x1e      },
    {VK_OEM_MINUS , KANALOK ,'-'       ,'='       ,WCH_HO  ,WCH_HO  , WCH_NONE  , WCH_NONE  , 0x1f      , 0x1f      },
    {0            , 0       ,0         ,0         ,0       ,0       , 0         , 0         , 0         , 0         }
};

// Put this last so that VkKeyScan interprets number characters
// as coming from the main section of the kbd (aVkToWch2 and
// aVkToWch4) before considering the numpad (aVkToWch1).

static ALLOC_SECTION_LDATA VK_TO_WCHARS4 aVkToWch1[] = {
    //                     |          |   SHIFT  |  KANA  | K+SHFT |
    //                     |          |==========|========|========|
    { VK_NUMPAD0   , 0      ,  '0'    , WCH_NONE ,   '0'  ,WCH_NONE},
    { VK_NUMPAD1   , 0      ,  '1'    , WCH_NONE ,   '1'  ,WCH_NONE},
    { VK_NUMPAD2   , 0      ,  '2'    , WCH_NONE ,   '2'  ,WCH_NONE},
    { VK_NUMPAD3   , 0      ,  '3'    , WCH_NONE ,   '3'  ,WCH_NONE},
    { VK_NUMPAD4   , 0      ,  '4'    , WCH_NONE ,   '4'  ,WCH_NONE},
    { VK_NUMPAD5   , 0      ,  '5'    , WCH_NONE ,   '5'  ,WCH_NONE},
    { VK_NUMPAD6   , 0      ,  '6'    , WCH_NONE ,   '6'  ,WCH_NONE},
    { VK_NUMPAD7   , 0      ,  '7'    , WCH_NONE ,   '7'  ,WCH_NONE},
    { VK_NUMPAD8   , 0      ,  '8'    , WCH_NONE ,   '8'  ,WCH_NONE},
    { VK_NUMPAD9   , 0      ,  '9'    , WCH_NONE ,   '9'  ,WCH_NONE},
    { 0            , 0      ,  '\0'   , 0        ,   0    ,0       }   //null terminator
};

/***************************************************************************\
* aVkToWcharTable: table of pointers to Character Tables
*
* Describes the character tables and the order they should be searched.
*
* Note: the order determines the behavior of VkKeyScan() : this function
*       takes a character and attempts to find a Virtual Key and character-
*       modifier key combination that produces that character.  The table
*       containing the numeric keypad (aVkToWch1) must appear last so that
*       VkKeyScan('0') will be interpreted as one of keys from the main
*       section, not the numpad.  etc.
\***************************************************************************/

static ALLOC_SECTION_LDATA VK_TO_WCHAR_TABLE aVkToWcharTable[] = {
    {  (PVK_TO_WCHARS1)aVkToWch6, 6, sizeof(aVkToWch6[0]) },
    {  (PVK_TO_WCHARS1)aVkToWch8, 8, sizeof(aVkToWch8[0]) },
    {  (PVK_TO_WCHARS1)aVkToWch4, 4, sizeof(aVkToWch4[0]) },
    {  (PVK_TO_WCHARS1)aVkToWch1, 4, sizeof(aVkToWch1[0]) },  // must come last
    {                       NULL, 0, 0                    }
};

/***************************************************************************\
* aKeyNames[], aKeyNamesExt[]  - Scan Code -> Key Name tables
*
* For the GetKeyNameText() API function
*
* Tables for non-extended and extended (KBDEXT) keys.
* (Keys producing printable characters are named by the character itself)
\***************************************************************************/

static ALLOC_SECTION_LDATA VSC_LPWSTR aKeyNames[] = {
#if defined(_PC98_)
    0x01,    L"ESC",            // Esc
    0x0e,    L"BS",             // Backspace
    0x0f,    L"TAB",            // Tab
    0x1c,    L"RETURN",         // Enter
    0x1d,    L"CTRL",           // Ctrl
    0x29,    (LPWSTR)SZ_KEY_NAME_HANKAKU_ZENKAKU,  // NLS Key
    0x2a,    L"SHIFT",          // Shift
    0x36,    L"SHIFT",          // Rgiht Shift
#else // defined(_PC98_)
    0x01,    L"Esc",
    0x0e,    L"Backspace",
    0x0f,    L"Tab",
    0x1c,    L"Enter",
    0x1d,    L"Ctrl",
    0x29,    (LPWSTR)SZ_KEY_NAME_HANKAKU_ZENKAKU,  // NLS Key
    0x2a,    L"Shift",
    0x36,    L"Right Shift",
#endif // defined(_PC98_)
    0x37,    L"Num *",
#if defined(_PC98_)
    0x38,    L"GRPH",                   // Alt
    0x39,    L"SPACE",                  // Space
    0x3a,    L"CAPS",                   // Caps Lock
    0x3b,    (LPWSTR)SZ_KEY_NAME_F1,    // F1
    0x3c,    (LPWSTR)SZ_KEY_NAME_F2,    // F2
    0x3d,    (LPWSTR)SZ_KEY_NAME_F3,    // F3
    0x3e,    (LPWSTR)SZ_KEY_NAME_F4,    // F4
    0x3f,    (LPWSTR)SZ_KEY_NAME_F5,    // F5
    0x40,    (LPWSTR)SZ_KEY_NAME_F6,    // F6
    0x41,    (LPWSTR)SZ_KEY_NAME_F7,    // F7
    0x42,    (LPWSTR)SZ_KEY_NAME_F8,    // F8
    0x43,    (LPWSTR)SZ_KEY_NAME_F9,    // F9
    0x44,    (LPWSTR)SZ_KEY_NAME_F10,   // F10
#else // defined(_PC98_)
    0x38,    L"Alt",
    0x39,    L"Space",
    0x3a,    L"Caps Lock",
    0x3b,    L"F1",
    0x3c,    L"F2",
    0x3d,    L"F3",
    0x3e,    L"F4",
    0x3f,    L"F5",
    0x40,    L"F6",
    0x41,    L"F7",
    0x42,    L"F8",
    0x43,    L"F9",
    0x44,    L"F10",
#endif // defined(_PC98_)
    0x45,    L"Pause",
    0x46,    L"Scroll Lock",
    0x47,    L"Num 7",
    0x48,    L"Num 8",
    0x49,    L"Num 9",
    0x4a,    L"Num -",
    0x4b,    L"Num 4",
    0x4c,    L"Num 5",
    0x4d,    L"Num 6",
    0x4e,    L"Num +",
    0x4f,    L"Num 1",
    0x50,    L"Num 2",
    0x51,    L"Num 3",
    0x52,    L"Num 0",
#if defined(_PC98_)
    0x53,    L"Num .",
#else // defined(_PC98_)
    0x53,    L"Num Del",
#endif // defined(_PC98_)
    0x54,    L"Sys Req",
#if defined(_PC98_)
//    0x55,    L"",
    0x57,    (LPWSTR)SZ_KEY_NAME_F11,     // vf1
    0x58,    (LPWSTR)SZ_KEY_NAME_F12,     // vf2
    0x59,    L"Num =",
//    0x5B,    L"Convert",                  // not use
    0x5C,    L"Num ,",
    0x5D,    (LPWSTR)SZ_KEY_NAME_F13,     // vf3
    0x5E,    (LPWSTR)SZ_KEY_NAME_F14,     // vf4
    0x5F,    (LPWSTR)SZ_KEY_NAME_F15,     // vf5
    0x70,    (LPWSTR)SZ_KEY_NAME_KANA,    // NLS Key Katakana
    0x79,    L"XFER",                     // NLS Key SZ_KEY_NAME_HIRAGANA
    0x7b,    L"NFER",                     //
#else // defined(_PC98_)
    0x57,    L"F11",
    0x58,    L"F12",
    0x70,    (LPWSTR)SZ_KEY_NAME_HIRAGANA,
    0x79,    (LPWSTR)SZ_KEY_NAME_HENKAN,
    0x7b,    (LPWSTR)SZ_KEY_NAME_MUHENKAN,
    0x7C,    L"F13",
#endif // defined(_PC98_)
    0   ,    NULL
};

static ALLOC_SECTION_LDATA VSC_LPWSTR aKeyNamesExt[] = {
#if defined(_PC98_)
    0x1c,    L"Num Enter",
    0x35,    L"Num /",
    0x37,    L"COPY",                   // Prnt Scr
    0x45,    L"Num Lock",
    0x46,    L"STOP",                   // Break
    0x47,    L"CLR",                    // Home
    0x48,    L"UP",                     // Up
    0x49,    L"ROLL DOWN",              // Page Up
    0x4b,    L"LEFT",                   // Left
    0x4d,    L"RIGHT",                  // Right
    0x4f,    L"HELP",                   // End
    0x50,    L"DOWN",                   // Down
    0x51,    L"ROLL UP",                // Page Down
    0x52,    L"INS",                    // Insert
    0x53,    L"DEL",                    // Delete
    0x54,    L"<00>",
    0x56,    L"HELP",                   // Help
//  0x5C,    L"CLR",                    // Clear
#else // defined(_PC98_)
    0x1c,    L"Num Enter",
    0x1d,    L"Right Control",
    0x35,    L"Num /",
    0x37,    L"Prnt Scrn",
    0x38,    L"Right Alt",
    0x45,    L"Num Lock",
    0x46,    L"Break",
    0x47,    L"Home",
    0x48,    L"Up",
    0x49,    L"Page Up",
    0x4b,    L"Left",
    0x4d,    L"Right",
    0x4f,    L"End",
    0x50,    L"Down",
    0x51,    L"Page Down",
    0x52,    L"Insert",
    0x53,    L"Delete",
#endif // defined(_PC98_)
    0x5B,    L"Left Windows",
    0x5C,    L"Right Windows",
    0x5D,    L"Application",
    0   ,    NULL
};

static ALLOC_SECTION_LDATA KBDTABLES KbdTables = {
    /*
     * Modifier keys
     */
    &CharModifiers,

    /*
     * Characters tables
     */
    aVkToWcharTable,

    /*
     * Diacritics  (none for US English)
     */
    NULL,

    /*
     * Names of Keys  (no dead keys)
     */
    aKeyNames,
    aKeyNamesExt,
    NULL,

    /*
     * Scan codes to Virtual Keys
     */
    ausVK,
    sizeof(ausVK) / sizeof(ausVK[0]),
    aE0VscToVk,
    aE1VscToVk,

    /*
     * No Locale-specific special processing
     */
    0,

    /*
     * No Ligatures
     */
    0, 0, NULL,

    /*
     * Type and subtype.
     */
    KEYBOARD_TYPE_JAPAN,    // Japanese Keyboard Layout
    MAKEWORD(NEC_KBD_N_MODE_TYPE, NLSKBD_OEM_NEC),
};

PKBDTABLES KbdLayerDescriptor(VOID)
{
    return &KbdTables;
}

/***********************************************************************\
* VkToFuncTable_106[]
*
\***********************************************************************/

static ALLOC_SECTION_LDATA VK_F VkToFuncTable_106[] = {
    {
        VK_DBE_ALPHANUMERIC,  // Base Vk
        KBDNLS_TYPE_TOGGLE,   // NLSFEProcType
        KBDNLS_INDEX_NORMAL,  // NLSFEProcCurrent
        0x02, /* 00000010 */  // NLSFEProcSwitch
        {                     // NLSFEProc
            {KBDNLS_ALPHANUM,0},               // Base
            {KBDNLS_SEND_PARAM_VK,VK_CAPITAL}, // Shift
            {KBDNLS_ALPHANUM,0},               // Control
            {KBDNLS_ALPHANUM,0},               // Shift+Control
            {KBDNLS_ALPHANUM,0},               // Alt
            {KBDNLS_ALPHANUM,0},               // Shift+Alt
            {KBDNLS_CODEINPUT,0},              // Control+Alt
            {KBDNLS_CODEINPUT,0}               // Shift+Control+Alt
        },
        {                     // NLSFEProcAlt
            {KBDNLS_SEND_PARAM_VK,VK_CAPITAL}, // Base
            {KBDNLS_SEND_PARAM_VK,VK_CAPITAL}, // Shift
            {KBDNLS_NOEVENT,0},                // Control
            {KBDNLS_NOEVENT,0},                // Shift+Control
            {KBDNLS_NOEVENT,0},                // Alt
            {KBDNLS_NOEVENT,0},                // Shift+Alt
            {KBDNLS_NOEVENT,0},                // Control+Alt
            {KBDNLS_NOEVENT,0}                 // Shift+Control+Alt
        }
    },
    {
        VK_DBE_HIRAGANA,     // Base Vk
        KBDNLS_TYPE_TOGGLE,  // NLSFEProcType
        KBDNLS_INDEX_NORMAL, // NLSFEProcCurrent
        0x08, /* 00001000 */ // NLSFEProcSwitch
        {                    // NLSFEProc
            {KBDNLS_HIRAGANA,0},             // Base
            {KBDNLS_KATAKANA,0},             // Shift
            {KBDNLS_HIRAGANA,0},             // Control
            {KBDNLS_SEND_PARAM_VK,VK_KANA},  // Shift+Control
            {KBDNLS_ROMAN,0},                // Alt
            {KBDNLS_ROMAN,0},                // Shift+Alt
            {KBDNLS_ROMAN,0},                // Control+Alt
            {KBDNLS_NOEVENT,0}               // Shift+Control+Alt
        },
        {                    // NLSFEProcIndexAlt
            {KBDNLS_SEND_PARAM_VK,VK_KANA},  // Base
            {KBDNLS_SEND_PARAM_VK,VK_KANA},  // Shift
            {KBDNLS_SEND_PARAM_VK,VK_KANA},  // Control
            {KBDNLS_SEND_PARAM_VK,VK_KANA},  // Shift+Control
            {KBDNLS_NOEVENT,0},              // Alt
            {KBDNLS_NOEVENT,0},              // Shift+Alt
            {KBDNLS_NOEVENT,0},              // Control+Alt
            {KBDNLS_NOEVENT,0}               // Shift+Control+Alt
        }
    },
    {
        VK_DBE_SBCSCHAR,     // Base Vk
        KBDNLS_TYPE_NORMAL,  // NLSFEProcType
        KBDNLS_INDEX_NORMAL, // NLSFEProcCurrent
        0x0,                 // NLSFEProcSwitch
        {                    // NLSFEProc
            {KBDNLS_SBCSDBCS,0},             // Base
            {KBDNLS_SBCSDBCS,0},             // Shift
            {KBDNLS_SBCSDBCS,0},             // Control
            {KBDNLS_SBCSDBCS,0},             // Shift+Control
            {KBDNLS_SEND_PARAM_VK,VK_KANJI}, // Alt
            {KBDNLS_SBCSDBCS,0},             // Shift+Alt
            {KBDNLS_SEND_PARAM_VK,VK_DBE_ENTERIMECONFIGMODE}, // Control+Alt
            {KBDNLS_SEND_PARAM_VK,VK_DBE_ENTERIMECONFIGMODE}  // Shift+Control+Alt
        },
        {                    // NLSFEProcIndexAlt
            {KBDNLS_NULL,0},  // Base
            {KBDNLS_NULL,0},  // Shift
            {KBDNLS_NULL,0},  // Control
            {KBDNLS_NULL,0},  // Shift+Control
            {KBDNLS_NULL,0},  // Alt
            {KBDNLS_NULL,0},  // Shift+Alt
            {KBDNLS_NULL,0},  // Control+Alt
            {KBDNLS_NULL,0}   // Shift+Control+Alt
        }
    },
    {
        VK_NONCONVERT,       // Base Vk
        KBDNLS_TYPE_NORMAL,  // NLSFEProcType
        KBDNLS_INDEX_NORMAL, // NLSFEProcCurrent
        0x0,                 // NLSFEProcSwitch
        {                    // NLSFEProc
            {KBDNLS_SEND_BASE_VK,0},         // Base
            {KBDNLS_SEND_BASE_VK,0},         // Shift
            {KBDNLS_SEND_BASE_VK,0},         // Control
            {KBDNLS_SEND_BASE_VK,0},         // Shift+Control
            {KBDNLS_SEND_BASE_VK,0},         // Alt
            {KBDNLS_SEND_BASE_VK,0},         // Shift+Alt
            {KBDNLS_SEND_PARAM_VK,VK_DBE_ENTERWORDREGISTERMODE}, // Control+Alt
            {KBDNLS_SEND_PARAM_VK,VK_DBE_ENTERWORDREGISTERMODE}  // Shift+Control+Alt
        },
        {                         // NLSFEProcIndexAlt
            {KBDNLS_NULL,0},  // Base
            {KBDNLS_NULL,0},  // Shift
            {KBDNLS_NULL,0},  // Control
            {KBDNLS_NULL,0},  // Shift+Control
            {KBDNLS_NULL,0},  // Alt
            {KBDNLS_NULL,0},  // Shift+Alt
            {KBDNLS_NULL,0},  // Control+Alt
            {KBDNLS_NULL,0}   // Shift+Control+Alt
        }
    }
};

#if defined(_PC98_)
static ALLOC_SECTION_LDATA VK_F VkToFuncTable_NEC[] = {
    {
        VK_DBE_SBCSCHAR,     // Base Vk
        KBDNLS_TYPE_NORMAL,  // NLSFEProcType
        KBDNLS_INDEX_NORMAL, // NLSFEProcCurrent
        0x0,                 // NLSFEProcSwitch
        {                    // NLSFEProc
            {KBDNLS_SBCSDBCS,0},             // Base
            {KBDNLS_SBCSDBCS,0},             // Shift
            {KBDNLS_SBCSDBCS,0},             // Control
            {KBDNLS_SBCSDBCS,0},             // Shift+Control
            {KBDNLS_SBCSDBCS,0},             // Alt
//            {KBDNLS_SEND_PARAM_VK,VK_KANJI}, // Alt
            {KBDNLS_SBCSDBCS,0},             // Shift+Alt
            {KBDNLS_SEND_PARAM_VK,VK_DBE_ENTERIMECONFIGMODE}, // Control+Alt
            {KBDNLS_SEND_PARAM_VK,VK_DBE_ENTERIMECONFIGMODE}  // Shift+Control+Alt
        },
        {                    // NLSFEProcIndexAlt
            {KBDNLS_NULL,0},  // Base
            {KBDNLS_NULL,0},  // Shift
            {KBDNLS_NULL,0},  // Control
            {KBDNLS_NULL,0},  // Shift+Control
            {KBDNLS_NULL,0},  // Alt
            {KBDNLS_NULL,0},  // Shift+Alt
            {KBDNLS_NULL,0},  // Control+Alt
            {KBDNLS_NULL,0}   // Shift+Control+Alt
        }
    },
    {
        VK_NONCONVERT,       // Base Vk  PC98_NFER key
        KBDNLS_TYPE_NORMAL,  // NLSFEProcType
        KBDNLS_INDEX_NORMAL, // NLSFEProcCurrent
        0x0,                 // NLSFEProcSwitch
        {                    // NLSFEProc
            {KBDNLS_SEND_BASE_VK,0},                             // Base
            {KBDNLS_SEND_BASE_VK,0},                             // Shift
            {KBDNLS_SEND_PARAM_VK,VK_DBE_ALPHANUMERIC},          // Control
            {KBDNLS_SBCSDBCS,0},                                 // Shift+Control
            {KBDNLS_SEND_PARAM_VK,VK_DBE_KATAKANA},              // Alt
            {KBDNLS_SEND_PARAM_VK,VK_DBE_ENTERWORDREGISTERMODE}, // Shift+Alt
            {KBDNLS_SEND_PARAM_VK,VK_DBE_NOCODEINPUT},           // Control+Alt
            {KBDNLS_SEND_PARAM_VK,VK_DBE_FLUSHSTRING}            // Shift+Control+Alt
        },
        {                     // NLSFEProcIndexAlt
            {KBDNLS_NULL,0},  // Base
            {KBDNLS_NULL,0},  // Shift
            {KBDNLS_NULL,0},  // Control
            {KBDNLS_NULL,0},  // Shift+Control
            {KBDNLS_NULL,0},  // Alt
            {KBDNLS_NULL,0},  // Shift+Alt
            {KBDNLS_NULL,0},  // Control+Alt
            {KBDNLS_NULL,0}   // Shift+Control+Alt
        }
    },
    {
        VK_CONVERT,            // Base Vk  PC98_XFER key
        KBDNLS_TYPE_NORMAL,  // NLSFEProcType
        KBDNLS_INDEX_NORMAL, // NLSFEProcCurrent
        0x0,                 // NLSFEProcSwitch
        {                    // NLSFEProc
            {KBDNLS_SEND_BASE_VK,0},                          // Base
            {KBDNLS_SEND_BASE_VK,0},                          // Shift
            {KBDNLS_SEND_PARAM_VK,VK_KANJI},                  // Control
            {KBDNLS_SEND_BASE_VK,0},                          // Shift+Control
            {KBDNLS_ROMAN,0},                                 // Alt
            {KBDNLS_SEND_PARAM_VK,VK_DBE_ENTERIMECONFIGMODE}, // Shift+Alt
            {KBDNLS_SEND_PARAM_VK,VK_DBE_CODEINPUT},          // Control+Alt
            {KBDNLS_SEND_PARAM_VK,VK_DBE_HIRAGANA}            // Shift+Control+Alt
        },
        {                     // NLSFEProcIndexAlt
            {KBDNLS_NULL,0},  // Base
            {KBDNLS_NULL,0},  // Shift
            {KBDNLS_NULL,0},  // Control
            {KBDNLS_NULL,0},  // Shift+Control
            {KBDNLS_NULL,0},  // Alt
            {KBDNLS_NULL,0},  // Shift+Alt
            {KBDNLS_NULL,0},  // Control+Alt
            {KBDNLS_NULL,0}   // Shift+Control+Alt
        }
    },
    {
        VK_OEM_NEC_EQUAL,    // Base Vk NEC98_"="  key
        KBDNLS_TYPE_NORMAL,  // NLSFEProcType
        KBDNLS_INDEX_NORMAL, // NLSFEProcCurrent
        0x0,                 // NLSFEProcSwitch
        {                    // NLSFEProc
            {KBDNLS_SEND_BASE_VK,0},                  // Base
            {KBDNLS_SEND_BASE_VK,0},                  // Shift
            {KBDNLS_SEND_PARAM_VK,VK_SCROLL},         // Control
            {KBDNLS_SEND_BASE_VK,0},                  // Shift+Control
            {KBDNLS_SEND_BASE_VK,0},                  // Alt
            {KBDNLS_SEND_BASE_VK,0},                  // Shift+Alt
            {KBDNLS_SEND_BASE_VK,0},                  // Control+Alt
            {KBDNLS_SEND_BASE_VK,0}                   // Shift+Control+Alt
        },
        {                     // NLSFEProcIndexAlt
            {KBDNLS_NULL,0},  // Base
            {KBDNLS_NULL,0},  // Shift
            {KBDNLS_NULL,0},  // Control
            {KBDNLS_NULL,0},  // Shift+Control
            {KBDNLS_NULL,0},  // Alt
            {KBDNLS_NULL,0},  // Shift+Alt
            {KBDNLS_NULL,0},  // Control+Alt
            {KBDNLS_NULL,0}   // Shift+Control+Alt
        }
    },
    {
        VK_HOME,             // Base Vk  PC98_HOME  key
        KBDNLS_TYPE_NORMAL,  // NLSFEProcType
        KBDNLS_INDEX_NORMAL, // NLSFEProcCurrent
        0x0,                 // NLSFEProcSwitch
        {                    // NLSFEProc
            {KBDNLS_HOME_OR_CLEAR,0},         // Base
            {KBDNLS_SEND_BASE_VK,0},          // Shift
            {KBDNLS_HOME_OR_CLEAR,0},         // Control
            {KBDNLS_HOME_OR_CLEAR,0},         // Shift+Control
            {KBDNLS_HOME_OR_CLEAR,0},         // Alt
            {KBDNLS_HOME_OR_CLEAR,0},         // Shift+Alt
            {KBDNLS_HOME_OR_CLEAR,0},         // Control+Alt
            {KBDNLS_HOME_OR_CLEAR,0}          // Shift+Control+Alt
        },
        {                     // NLSFEProcIndexAlt
            {KBDNLS_NULL,0},  // Base
            {KBDNLS_NULL,0},  // Shift
            {KBDNLS_NULL,0},  // Control
            {KBDNLS_NULL,0},  // Shift+Control
            {KBDNLS_NULL,0},  // Alt
            {KBDNLS_NULL,0},  // Shift+Alt
            {KBDNLS_NULL,0},  // Control+Alt
            {KBDNLS_NULL,0}   // Shift+Control+Alt
        }
    },
    {
        VK_END,              // Base Vk  PC98_HELP  key
        KBDNLS_TYPE_NORMAL,  // NLSFEProcType
        KBDNLS_INDEX_NORMAL, // NLSFEProcCurrent
        0x0,                 // NLSFEProcSwitch
        {                    // NLSFEProc
            {KBDNLS_HELP_OR_END,0},         // Base
            {KBDNLS_HELP_OR_END,0},         // Shift
            {KBDNLS_HELP_OR_END,0},         // Control
            {KBDNLS_HELP_OR_END,0},         // Shift+Control
            {KBDNLS_HELP_OR_END,0},         // Alt
            {KBDNLS_HELP_OR_END,0},         // Shift+Alt
            {KBDNLS_HELP_OR_END,0},         // Control+Alt
            {KBDNLS_HELP_OR_END,0}          // Shift+Control+Alt
        },
        {                     // NLSFEProcIndexAlt
            {KBDNLS_NULL,0},  // Base
            {KBDNLS_NULL,0},  // Shift
            {KBDNLS_NULL,0},  // Control
            {KBDNLS_NULL,0},  // Shift+Control
            {KBDNLS_NULL,0},  // Alt
            {KBDNLS_NULL,0},  // Shift+Alt
            {KBDNLS_NULL,0},  // Control+Alt
            {KBDNLS_NULL,0}   // Shift+Control+Alt
        }
    },
    {
        VK_NUMPAD0,          // Base Vk
        KBDNLS_TYPE_NORMAL,  // NLSFEProcType
        KBDNLS_INDEX_NORMAL, // NLSFEProcCurrent
        0x0,                 // NLSFEProcSwitch
        {                    // NLSFEProc
            {KBDNLS_NUMPAD,0},         // Base
            {KBDNLS_NUMPAD,0},         // Shift
            {KBDNLS_NUMPAD,0},         // Control
            {KBDNLS_NUMPAD,0},         // Shift+Control
            {KBDNLS_NUMPAD,0},         // Alt
            {KBDNLS_NUMPAD,0},         // Shift+Alt
            {KBDNLS_NUMPAD,0},         // Control+Alt
            {KBDNLS_NUMPAD,0}          // Shift+Control+Alt
        },
        {                     // NLSFEProcIndexAlt
            {KBDNLS_NULL,0},  // Base
            {KBDNLS_NULL,0},  // Shift
            {KBDNLS_NULL,0},  // Control
            {KBDNLS_NULL,0},  // Shift+Control
            {KBDNLS_NULL,0},  // Alt
            {KBDNLS_NULL,0},  // Shift+Alt
            {KBDNLS_NULL,0},  // Control+Alt
            {KBDNLS_NULL,0}   // Shift+Control+Alt
        }
    },
    {
        VK_NUMPAD1,          // Base Vk
        KBDNLS_TYPE_NORMAL,  // NLSFEProcType
        KBDNLS_INDEX_NORMAL, // NLSFEProcCurrent
        0x0,                 // NLSFEProcSwitch
        {                    // NLSFEProc
            {KBDNLS_NUMPAD,0},         // Base
            {KBDNLS_NUMPAD,0},         // Shift
            {KBDNLS_NUMPAD,0},         // Control
            {KBDNLS_NUMPAD,0},         // Shift+Control
            {KBDNLS_NUMPAD,0},         // Alt
            {KBDNLS_NUMPAD,0},         // Shift+Alt
            {KBDNLS_NUMPAD,0},         // Control+Alt
            {KBDNLS_NUMPAD,0}          // Shift+Control+Alt
        },
        {                     // NLSFEProcIndexAlt
            {KBDNLS_NULL,0},  // Base
            {KBDNLS_NULL,0},  // Shift
            {KBDNLS_NULL,0},  // Control
            {KBDNLS_NULL,0},  // Shift+Control
            {KBDNLS_NULL,0},  // Alt
            {KBDNLS_NULL,0},  // Shift+Alt
            {KBDNLS_NULL,0},  // Control+Alt
            {KBDNLS_NULL,0}   // Shift+Control+Alt
        }
    },
    {
        VK_NUMPAD2,          // Base Vk
        KBDNLS_TYPE_NORMAL,  // NLSFEProcType
        KBDNLS_INDEX_NORMAL, // NLSFEProcCurrent
        0x0,                 // NLSFEProcSwitch
        {                    // NLSFEProc
            {KBDNLS_NUMPAD,0},         // Base
            {KBDNLS_NUMPAD,0},         // Shift
            {KBDNLS_NUMPAD,0},         // Control
            {KBDNLS_NUMPAD,0},         // Shift+Control
            {KBDNLS_NUMPAD,0},         // Alt
            {KBDNLS_NUMPAD,0},         // Shift+Alt
            {KBDNLS_NUMPAD,0},         // Control+Alt
            {KBDNLS_NUMPAD,0}          // Shift+Control+Alt
        },
        {                     // NLSFEProcIndexAlt
            {KBDNLS_NULL,0},  // Base
            {KBDNLS_NULL,0},  // Shift
            {KBDNLS_NULL,0},  // Control
            {KBDNLS_NULL,0},  // Shift+Control
            {KBDNLS_NULL,0},  // Alt
            {KBDNLS_NULL,0},  // Shift+Alt
            {KBDNLS_NULL,0},  // Control+Alt
            {KBDNLS_NULL,0}   // Shift+Control+Alt
        }
    },
    {
        VK_NUMPAD3,          // Base Vk
        KBDNLS_TYPE_NORMAL,  // NLSFEProcType
        KBDNLS_INDEX_NORMAL, // NLSFEProcCurrent
        0x0,                 // NLSFEProcSwitch
        {                    // NLSFEProc
            {KBDNLS_NUMPAD,0},         // Base
            {KBDNLS_NUMPAD,0},         // Shift
            {KBDNLS_NUMPAD,0},         // Control
            {KBDNLS_NUMPAD,0},         // Shift+Control
            {KBDNLS_NUMPAD,0},         // Alt
            {KBDNLS_NUMPAD,0},         // Shift+Alt
            {KBDNLS_NUMPAD,0},         // Control+Alt
            {KBDNLS_NUMPAD,0}          // Shift+Control+Alt
        },
        {                     // NLSFEProcIndexAlt
            {KBDNLS_NULL,0},  // Base
            {KBDNLS_NULL,0},  // Shift
            {KBDNLS_NULL,0},  // Control
            {KBDNLS_NULL,0},  // Shift+Control
            {KBDNLS_NULL,0},  // Alt
            {KBDNLS_NULL,0},  // Shift+Alt
            {KBDNLS_NULL,0},  // Control+Alt
            {KBDNLS_NULL,0}   // Shift+Control+Alt
        }
    },
    {
        VK_NUMPAD4,          // Base Vk
        KBDNLS_TYPE_NORMAL,  // NLSFEProcType
        KBDNLS_INDEX_NORMAL, // NLSFEProcCurrent
        0x0,                 // NLSFEProcSwitch
        {                    // NLSFEProc
            {KBDNLS_NUMPAD,0},         // Base
            {KBDNLS_NUMPAD,0},         // Shift
            {KBDNLS_NUMPAD,0},         // Control
            {KBDNLS_NUMPAD,0},         // Shift+Control
            {KBDNLS_NUMPAD,0},         // Alt
            {KBDNLS_NUMPAD,0},         // Shift+Alt
            {KBDNLS_NUMPAD,0},         // Control+Alt
            {KBDNLS_NUMPAD,0}          // Shift+Control+Alt
        },
        {                     // NLSFEProcIndexAlt
            {KBDNLS_NULL,0},  // Base
            {KBDNLS_NULL,0},  // Shift
            {KBDNLS_NULL,0},  // Control
            {KBDNLS_NULL,0},  // Shift+Control
            {KBDNLS_NULL,0},  // Alt
            {KBDNLS_NULL,0},  // Shift+Alt
            {KBDNLS_NULL,0},  // Control+Alt
            {KBDNLS_NULL,0}   // Shift+Control+Alt
        }
    },
    {
        VK_NUMPAD5,          // Base Vk
        KBDNLS_TYPE_NORMAL,  // NLSFEProcType
        KBDNLS_INDEX_NORMAL, // NLSFEProcCurrent
        0x0,                 // NLSFEProcSwitch
        {                    // NLSFEProc
            {KBDNLS_NUMPAD,0},         // Base
            {KBDNLS_NUMPAD,0},         // Shift
            {KBDNLS_NUMPAD,0},         // Control
            {KBDNLS_NUMPAD,0},         // Shift+Control
            {KBDNLS_NUMPAD,0},         // Alt
            {KBDNLS_NUMPAD,0},         // Shift+Alt
            {KBDNLS_NUMPAD,0},         // Control+Alt
            {KBDNLS_NUMPAD,0}          // Shift+Control+Alt
        },
        {                     // NLSFEProcIndexAlt
            {KBDNLS_NULL,0},  // Base
            {KBDNLS_NULL,0},  // Shift
            {KBDNLS_NULL,0},  // Control
            {KBDNLS_NULL,0},  // Shift+Control
            {KBDNLS_NULL,0},  // Alt
            {KBDNLS_NULL,0},  // Shift+Alt
            {KBDNLS_NULL,0},  // Control+Alt
            {KBDNLS_NULL,0}   // Shift+Control+Alt
        }
    },
    {
        VK_NUMPAD6,          // Base Vk
        KBDNLS_TYPE_NORMAL,  // NLSFEProcType
        KBDNLS_INDEX_NORMAL, // NLSFEProcCurrent
        0x0,                 // NLSFEProcSwitch
        {                    // NLSFEProc
            {KBDNLS_NUMPAD,0},         // Base
            {KBDNLS_NUMPAD,0},         // Shift
            {KBDNLS_NUMPAD,0},         // Control
            {KBDNLS_NUMPAD,0},         // Shift+Control
            {KBDNLS_NUMPAD,0},         // Alt
            {KBDNLS_NUMPAD,0},         // Shift+Alt
            {KBDNLS_NUMPAD,0},         // Control+Alt
            {KBDNLS_NUMPAD,0}          // Shift+Control+Alt
        },
        {                     // NLSFEProcIndexAlt
            {KBDNLS_NULL,0},  // Base
            {KBDNLS_NULL,0},  // Shift
            {KBDNLS_NULL,0},  // Control
            {KBDNLS_NULL,0},  // Shift+Control
            {KBDNLS_NULL,0},  // Alt
            {KBDNLS_NULL,0},  // Shift+Alt
            {KBDNLS_NULL,0},  // Control+Alt
            {KBDNLS_NULL,0}   // Shift+Control+Alt
        }
    },
    {
        VK_NUMPAD7,          // Base Vk
        KBDNLS_TYPE_NORMAL,  // NLSFEProcType
        KBDNLS_INDEX_NORMAL, // NLSFEProcCurrent
        0x0,                 // NLSFEProcSwitch
        {                    // NLSFEProc
            {KBDNLS_NUMPAD,0},         // Base
            {KBDNLS_NUMPAD,0},         // Shift
            {KBDNLS_NUMPAD,0},         // Control
            {KBDNLS_NUMPAD,0},         // Shift+Control
            {KBDNLS_NUMPAD,0},         // Alt
            {KBDNLS_NUMPAD,0},         // Shift+Alt
            {KBDNLS_NUMPAD,0},         // Control+Alt
            {KBDNLS_NUMPAD,0}          // Shift+Control+Alt
        },
        {                     // NLSFEProcIndexAlt
            {KBDNLS_NULL,0},  // Base
            {KBDNLS_NULL,0},  // Shift
            {KBDNLS_NULL,0},  // Control
            {KBDNLS_NULL,0},  // Shift+Control
            {KBDNLS_NULL,0},  // Alt
            {KBDNLS_NULL,0},  // Shift+Alt
            {KBDNLS_NULL,0},  // Control+Alt
            {KBDNLS_NULL,0}   // Shift+Control+Alt
        }
    },
    {
        VK_NUMPAD8,          // Base Vk
        KBDNLS_TYPE_NORMAL,  // NLSFEProcType
        KBDNLS_INDEX_NORMAL, // NLSFEProcCurrent
        0x0,                 // NLSFEProcSwitch
        {                    // NLSFEProc
            {KBDNLS_NUMPAD,0},         // Base
            {KBDNLS_NUMPAD,0},         // Shift
            {KBDNLS_NUMPAD,0},         // Control
            {KBDNLS_NUMPAD,0},         // Shift+Control
            {KBDNLS_NUMPAD,0},         // Alt
            {KBDNLS_NUMPAD,0},         // Shift+Alt
            {KBDNLS_NUMPAD,0},         // Control+Alt
            {KBDNLS_NUMPAD,0}          // Shift+Control+Alt
        },
        {                     // NLSFEProcIndexAlt
            {KBDNLS_NULL,0},  // Base
            {KBDNLS_NULL,0},  // Shift
            {KBDNLS_NULL,0},  // Control
            {KBDNLS_NULL,0},  // Shift+Control
            {KBDNLS_NULL,0},  // Alt
            {KBDNLS_NULL,0},  // Shift+Alt
            {KBDNLS_NULL,0},  // Control+Alt
            {KBDNLS_NULL,0}   // Shift+Control+Alt
        }
    },
    {
        VK_NUMPAD9,          // Base Vk
        KBDNLS_TYPE_NORMAL,  // NLSFEProcType
        KBDNLS_INDEX_NORMAL, // NLSFEProcCurrent
        0x0,                 // NLSFEProcSwitch
        {                    // NLSFEProc
            {KBDNLS_NUMPAD,0},         // Base
            {KBDNLS_NUMPAD,0},         // Shift
            {KBDNLS_NUMPAD,0},         // Control
            {KBDNLS_NUMPAD,0},         // Shift+Control
            {KBDNLS_NUMPAD,0},         // Alt
            {KBDNLS_NUMPAD,0},         // Shift+Alt
            {KBDNLS_NUMPAD,0},         // Control+Alt
            {KBDNLS_NUMPAD,0}          // Shift+Control+Alt
        },
        {                     // NLSFEProcIndexAlt
            {KBDNLS_NULL,0},  // Base
            {KBDNLS_NULL,0},  // Shift
            {KBDNLS_NULL,0},  // Control
            {KBDNLS_NULL,0},  // Shift+Control
            {KBDNLS_NULL,0},  // Alt
            {KBDNLS_NULL,0},  // Shift+Alt
            {KBDNLS_NULL,0},  // Control+Alt
            {KBDNLS_NULL,0}   // Shift+Control+Alt
        }
    },
    {
        VK_DECIMAL,          // Base Vk  PC98_"."  key
        KBDNLS_TYPE_NORMAL,  // NLSFEProcType
        KBDNLS_INDEX_NORMAL, // NLSFEProcCurrent
        0x0,                 // NLSFEProcSwitch
        {                    // NLSFEProc
            {KBDNLS_NUMPAD,0},         // Base
            {KBDNLS_NUMPAD,0},         // Shift
            {KBDNLS_NUMPAD,0},         // Control
            {KBDNLS_NUMPAD,0},         // Shift+Control
            {KBDNLS_NUMPAD,0},         // Alt
            {KBDNLS_NUMPAD,0},         // Shift+Alt
            {KBDNLS_NUMPAD,0},         // Control+Alt
            {KBDNLS_NUMPAD,0}          // Shift+Control+Alt
        },
        {                     // NLSFEProcIndexAlt
            {KBDNLS_NULL,0},  // Base
            {KBDNLS_NULL,0},  // Shift
            {KBDNLS_NULL,0},  // Control
            {KBDNLS_NULL,0},  // Shift+Control
            {KBDNLS_NULL,0},  // Alt
            {KBDNLS_NULL,0},  // Shift+Alt
            {KBDNLS_NULL,0},  // Control+Alt
            {KBDNLS_NULL,0}   // Shift+Control+Alt
        }
    }
};

USHORT ausMouseVKey98[] = {
                       VK_NUMPAD5,
                       VK_NUMPAD9,
                       VK_NUMPAD3,
                       VK_NUMPAD1,
                       VK_NUMPAD7,
                       VK_NUMPAD4,
                       VK_NUMPAD8,
                       VK_NUMPAD6,
                       VK_NUMPAD2,
                       VK_NUMPAD0,
                       VK_DECIMAL,
                       VK_MULTIPLY,
                       VK_ADD,
                       VK_SUBTRACT,
                       VK_DIVIDE | KBDEXT,
                       VK_HOME | KBDEXT
                      };
#endif // defined(_PC98_)
/***********************************************************************\
* KbdNlsTables
*
\***********************************************************************/

static ALLOC_SECTION_LDATA KBDNLSTABLES KbdNlsTables = {
#if defined(_PC98_)
#if 1
    0,
#else
    0x0d,                            // OEM ID (0x0d = NEC)
#endif
    NLSKBD_INFO_ACCESSIBILITY_KEYMAP,// Information
    16,                              // Number of VK_F entry
    VkToFuncTable_NEC,               // Pointer to VK_F array
    16,                              // Number of MouseVk entry
    ausMouseVKey98                   // Pointer to MouseVk array
#else // defined(_PC98_)
    0,                      // OEM ID (0 = Microsoft)
    0,                      // Information
    4,                      // Number of VK_F entry
    VkToFuncTable_106,      // Pointer to VK_F array
    0,                      // Number of MouseVk entry
    NULL                    // Pointer to MouseVk array
#endif // defined(_PC98_)
};

PKBDNLSTABLES KbdNlsLayerDescriptor(VOID)
{
    return &KbdNlsTables;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kbd\fe_kbds\jpn\kbdnecnt\sources.inc ===
!IF 0

Copyright (c) 1989-2000  Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


!ENDIF

MINORCOMP=kbdnecnt

!include ..\..\japan.inc

SOURCES_USED=..\sources.inc

C_DEFINES=$(C_DEFINES) -D_PC98_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kbd\fe_kbds\jpn\lk411a\kbdlk41a.h ===
/****************************** Module Header ******************************\
* Module Name: kbdlk41a.h
*
* History:
\***************************************************************************/

#define KBD_TYPE 41

/*
 * Include the basis of all keyboard table values
 */
#include "kbd.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kbd\fe_kbds\jpn\lk411a\sources.inc ===
!IF 0

Copyright (c) 1989-2000  Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


!ENDIF

MINORCOMP=kbdlk41a

!include ..\..\japan.inc

SOURCES_USED=..\sources.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kbd\fe_kbds\jpn\lk411j\kbdlk41j.h ===
/****************************** Module Header ******************************\
* Module Name: kbdlk41j.h
*
* History:
\***************************************************************************/

#define KBD_TYPE 40

/*
 * Include the basis of all keyboard table values
 */
#include "kbd.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kbd\fe_kbds\jpn\lk411j\kbdlk41j.c ===
/***************************************************************************\
* Module Name: kbdlk41j.c
*
* DEC LK411-JJ keyboard layout driver
*
* History:
* 20-SEP-1996: Nakazato(v-mnakaz, DEC-J) created
\***************************************************************************/

#include <windows.h>
#include <ime.h>
#include "vkoem.h"
#include "kbdjpn.h"
#include "kbdlk41j.h"

#if defined(_M_IA64)
#pragma section(".data")
#define ALLOC_SECTION_LDATA __declspec(allocate(".data"))
#else
#pragma data_seg(".data")
#define ALLOC_SECTION_LDATA
#endif

/***************************************************************************\
* ausVK[] - Virtual Scan Code to Virtual Key conversion table for LK411-J
\***************************************************************************/

static ALLOC_SECTION_LDATA USHORT ausVK[] = {
    T00, T01, T02, T03, T04, T05, T06, T07,
    T08, T09, T0A, T0B, T0C, T0D, T0E, T0F,
    T10, T11, T12, T13, T14, T15, T16, T17,
    T18, T19, T1A, T1B, T1C, T1D, T1E, T1F,
    T20, T21, T22, T23, T24, T25, T26, T27,
    T28,

    // LK411-JJ doesn't use this key(Use Alt+Conversion key to use IME)
    T29,

    T2A, T2B, T2C, T2D, T2E, T2F,
    T30, T31, T32, T33, T34, T35,

     // Right-hand Shift key must have KBDEXT bit set.
    T36 | KBDEXT,

     // numpad_* + Shift/Alt -> SnapShot
    T37 | KBDMULTIVK,

    T38, T39,

     // Alphanumeric/CapsLock key must have KBDSPECIAL bit set (NLS key)
    T3A | KBDSPECIAL,

    T3B, T3C, T3D, T3E, T3F,
    T40, T41, T42, T43, T44,

     // NumLock Key:
     //     KBDEXT     - VK_NUMLOCK is an Extended key
     //     KBDMULTIVK - VK_NUMLOCK or VK_PAUSE (without or with CTRL)
    T45 | KBDEXT | KBDMULTIVK,

    T46 | KBDMULTIVK,

     // Number Pad keys:
     //    KBDNUMPAD  - digits 0-9 and decimal point.
     //    KBDSPECIAL - require special processing by Windows
    T47 | KBDNUMPAD | KBDSPECIAL,   // Numpad 7 (Home)
    T48 | KBDNUMPAD | KBDSPECIAL,   // Numpad 8 (Up),
    T49 | KBDNUMPAD | KBDSPECIAL,   // Numpad 9 (PgUp),
    T4A,
    T4B | KBDNUMPAD | KBDSPECIAL,   // Numpad 4 (Left),
    T4C | KBDNUMPAD | KBDSPECIAL,   // Numpad 5 (Clear),
    T4D | KBDNUMPAD | KBDSPECIAL,   // Numpad 6 (Right),
    T4E,
    T4F | KBDNUMPAD | KBDSPECIAL,   // Numpad 1 (End),
    T50 | KBDNUMPAD | KBDSPECIAL,   // Numpad 2 (Down),
    T51 | KBDNUMPAD | KBDSPECIAL,   // Numpad 3 (PgDn),
    T52 | KBDNUMPAD | KBDSPECIAL,   // Numpad 0 (Ins),
    T53 | KBDNUMPAD | KBDSPECIAL,   // Numpad . (Del),

    T54, T55, T56, T57, T58, T59, T5A, T5B,
    T5C, T5D, T5E, T5F, T60, T61, T62, T63,
    T64, T65, T66, T67, T68, T69, T6A, T6B,
    T6C, T6D, T6E, T6F,

     // Hiragana/Katakana/Roman key must have KBDSPECIAL bit set (NLS key)
    T70 | KBDSPECIAL,

    T71, T72, T73,
    T74, T75, T76, T77, T78,

     // Conversion key must have KBDSPECIAL bit set (NLS key)
    T79 | KBDSPECIAL,

    T7A,

     // Non-Conversion key must have KBDSPECIAL bit set (NLS key)
    T7B | KBDSPECIAL,

    T7C, T7D, T7E, T7F
};


static ALLOC_SECTION_LDATA VSC_VK aE0VscToVk[] = {
        { 0x0F, X0F | KBDEXT | KBDSPECIAL | KBDMULTIVK },       // LK411 added (kana key)
        { 0x1C, X1C | KBDEXT              },  // Numpad Enter
        { 0x1D, X1D | KBDEXT              },  // RControl
        { 0x35, X35 | KBDEXT              },  // Numpad Divide
        { 0x37, X37 | KBDEXT              },  // Snapshot
        { 0x38, X38 | KBDEXT              },  // RMenu
        { 0x3D, X3D | KBDEXT              },  // F13            // LK411 added
        { 0x3E, X3E | KBDEXT              },  // F14            // LK411 added
        { 0x3F, X3F | KBDEXT              },  // F15 (Help)     // LK411 added
        { 0x40, X40 | KBDEXT              },  // F16 (Do)       // LK411 added
        { 0x41, X41 | KBDEXT              },  // F17            // LK411 added
        { 0x46, X46 | KBDEXT              },  // Break (Ctrl + Pause)   // LK411 removed (@@ check)
        { 0x47, X47 | KBDEXT              },  // Home
        { 0x48, X48 | KBDEXT              },  // Up
        { 0x49, X49 | KBDEXT              },  // Prior
        { 0x4B, X4B | KBDEXT              },  // Left
        { 0x4D, X4D | KBDEXT              },  // Right
        { 0x4E, X4E | KBDEXT              },  // Keypad Minus       // LK411
        { 0x4F, X4F | KBDEXT              },  // End
        { 0x50, X50 | KBDEXT              },  // Down
        { 0x51, X51 | KBDEXT              },  // Next
        { 0x52, X52 | KBDEXT              },  // Insert
        { 0x53, X53 | KBDEXT              },  // Delete
//      { 0x5B, X5B | KBDEXT              },  // Left Win       // LK411 remove
//      { 0x5C, X5C | KBDEXT              },  // Right Win      // LK411 remove
//      { 0x5D, X5D | KBDEXT              },  // Application        // LK411 remove
        { 0,      0                       }
};


static ALLOC_SECTION_LDATA VSC_VK aE1VscToVk[] = {
        { 0x1D, Y1D                       },  // Pause
        { 0   ,   0                       }
};



/***************************************************************************\
* aVkToBits[]  - map Virtual Keys to Modifier Bits
*
* See kbd.h for a full description.
*
* US Keyboard has only three shifter keys:
*     SHIFT (L & R) affects alphabnumeric keys,
*     CTRL  (L & R) is used to generate control characters
*     ALT   (L & R) used for generating characters by number with numpad
\***************************************************************************/

static ALLOC_SECTION_LDATA VK_TO_BIT aVkToBits[] = {
    { VK_SHIFT,   KBDSHIFT },   // 1st bit (0001)
    { VK_CONTROL, KBDCTRL  },   // 2nd bit (0010)
    { VK_MENU,    KBDALT   },   // 4th bit (0100)
    { VK_KANA,    KBDKANA  },   // 8th bit (1000)
    { 0,          0        }
};



/***************************************************************************\
* aModification[]  - map character modifier bits to modification number
*
* See kbd.h for a full description.
*
\***************************************************************************/

static ALLOC_SECTION_LDATA MODIFIERS CharModifiers = {
    &aVkToBits[0],
    11,
    {
    //  Modification# // bit    Keys Pressed  : Explanation
    //  ============= // ====  ============== : =============================
        0,            // 0000                 : unshifted characters
        1,            // 0001           SHIFT : capitals, ~!@#$%^&*()_+{}:"<>? etc.
        4,            // 0010      CTRL       : control characters
        6,            // 0011      CTRL SHIFT :
        SHFT_INVALID, // 0100  ALT            : invalid
        SHFT_INVALID, // 0101  ALT      SHIFT : invalid
        SHFT_INVALID, // 0110  ALT CTRL       : invalid
        SHFT_INVALID, // 0111  ALT CTRL SHIFT : invalid
        2,            // 1000  KANA
        3,            // 1001  KANA      SHIFT
        5,            // 1010  KANA CTRL
        7             // 1011  KANA CTRL SHIFT
    }
};



/***************************************************************************\
*
* aVkToWch4[]  - Virtual Key to WCHAR translation for 4 shift states
* aVkToWch6[]  - Virtual Key to WCHAR translation for 6 shift states
* aVkToWch8[]  - Virtual Key to WCHAR translation for 8 shift states
* aVkToWch1[]  - Virtual Key to WCHAR translation for NUMPAD
*
* Table attributes: Unordered Scan, null-terminated
*
* Search this table for an entry with a matching Virtual Key to find the
* corresponding unshifted and shifted WCHAR characters.
*
* Reserved VirtualKey values (first column)
*     -1            - this line contains dead characters (diacritic)
*     0             - terminator
*
* Reserved Attribute values (second column)
*     CAPLOK        - CapsLock affects this key like Shift
*     KANALOK       - The KANA-LOCK key affects this key like KANA
*
* Reserved character values (third through last column)
*     WCH_NONE      - No character
*     WCH_DEAD      - Dead character (diacritic) value is in next line
*
\***************************************************************************/

static ALLOC_SECTION_LDATA VK_TO_WCHARS4 aVkToWch4[] = {
    //                               |          |   SHIFT  |  KANA  | K+SHFT |
    //                               |          |==========|========|========|
    {'0'          ,          KANALOK ,'0'       ,WCH_NONE  ,WCH_WA  ,WCH_WO  },
    {'1'          ,          KANALOK ,'1'       ,'!'       ,WCH_NU  ,WCH_NU  },
    {'3'          ,          KANALOK ,'3'       ,'#'       ,WCH_A   ,WCH_AA  },
    {'4'          ,          KANALOK ,'4'       ,'$'       ,WCH_U   ,WCH_UU  },
    {'5'          ,          KANALOK ,'5'       ,'%'       ,WCH_E   ,WCH_EE  },
    {'7'          ,          KANALOK ,'7'       ,0x27      ,WCH_YA  ,WCH_YAA },
    {'8'          ,          KANALOK ,'8'       ,'('       ,WCH_YU  ,WCH_YUU },
    {'9'          ,          KANALOK ,'9'       ,')'       ,WCH_YO  ,WCH_YOO },
    {'A'          , CAPLOK | KANALOK ,'a'       ,'A'       ,WCH_TI  ,WCH_TI  },
    {'B'          , CAPLOK | KANALOK ,'b'       ,'B'       ,WCH_KO  ,WCH_KO  },
    {'C'          , CAPLOK | KANALOK ,'c'       ,'C'       ,WCH_SO  ,WCH_SO  },
    {'D'          , CAPLOK | KANALOK ,'d'       ,'D'       ,WCH_SI  ,WCH_SI  },
    {'E'          , CAPLOK | KANALOK ,'e'       ,'E'       ,WCH_I   ,WCH_II  },
    {'F'          , CAPLOK | KANALOK ,'f'       ,'F'       ,WCH_HA  ,WCH_HA  },
    {'G'          , CAPLOK | KANALOK ,'g'       ,'G'       ,WCH_KI  ,WCH_KI  },
    {'H'          , CAPLOK | KANALOK ,'h'       ,'H'       ,WCH_KU  ,WCH_KU  },
    {'I'          , CAPLOK | KANALOK ,'i'       ,'I'       ,WCH_NI  ,WCH_NI  },
    {'J'          , CAPLOK | KANALOK ,'j'       ,'J'       ,WCH_MA  ,WCH_MA  },
    {'K'          , CAPLOK | KANALOK ,'k'       ,'K'       ,WCH_NO  ,WCH_NO  },
    {'L'          , CAPLOK | KANALOK ,'l'       ,'L'       ,WCH_RI  ,WCH_RI  },
    {'M'          , CAPLOK | KANALOK ,'m'       ,'M'       ,WCH_MO  ,WCH_MO  },
    {'N'          , CAPLOK | KANALOK ,'n'       ,'N'       ,WCH_MI  ,WCH_MI  },
    {'O'          , CAPLOK | KANALOK ,'o'       ,'O'       ,WCH_RA  ,WCH_RA  },
    {'P'          , CAPLOK | KANALOK ,'p'       ,'P'       ,WCH_SE  ,WCH_SE  },
    {'Q'          , CAPLOK | KANALOK ,'q'       ,'Q'       ,WCH_TA  ,WCH_TA  },
    {'R'          , CAPLOK | KANALOK ,'r'       ,'R'       ,WCH_SU  ,WCH_SU  },
    {'S'          , CAPLOK | KANALOK ,'s'       ,'S'       ,WCH_TO  ,WCH_TO  },
    {'T'          , CAPLOK | KANALOK ,'t'       ,'T'       ,WCH_KA  ,WCH_KA  },
    {'U'          , CAPLOK | KANALOK ,'u'       ,'U'       ,WCH_NA  ,WCH_NA  },
    {'V'          , CAPLOK | KANALOK ,'v'       ,'V'       ,WCH_HI  ,WCH_HI  },
    {'W'          , CAPLOK | KANALOK ,'w'       ,'W'       ,WCH_TE  ,WCH_TE  },
    {'X'          , CAPLOK | KANALOK ,'x'       ,'X'       ,WCH_SA  ,WCH_SA  },
    {'Y'          , CAPLOK | KANALOK ,'y'       ,'Y'       ,WCH_NN  ,WCH_NN  },
    {'Z'          , CAPLOK | KANALOK ,'z'       ,'Z'       ,WCH_TU  ,WCH_TUU },
    {VK_OEM_1     ,          KANALOK ,':'       ,'*'       ,WCH_KE  ,WCH_KE  },
    {VK_OEM_2     ,          KANALOK ,'/'       ,'?'       ,WCH_ME  ,WCH_MD  },
    {VK_OEM_3     ,          KANALOK ,'@'       ,'`'       ,WCH_VS  ,WCH_VS  },
    {VK_OEM_7     ,          KANALOK ,'^'       ,'~'       ,WCH_HE  ,WCH_HE  },
//  {VK_OEM_8     , 0                ,','       ,','       ,','     ,','     },     //LK411 removed
    {VK_OEM_COMMA ,          KANALOK ,','       ,'<'       ,WCH_NE  ,WCH_IC  },
    {VK_OEM_PERIOD,          KANALOK ,'.'       ,'>'       ,WCH_RU  ,WCH_IP  },
    {VK_OEM_PLUS  ,          KANALOK ,';'       ,'+'       ,WCH_RE  ,WCH_RE  },
    {VK_TAB       , 0                ,'\t'      ,'\t'      ,'\t'    ,'\t'    },
    {VK_ADD       , 0                ,'+'       ,'+'       ,'+'     ,'+'     },
    {VK_DECIMAL   , 0                ,'.'       ,'.'       ,'.'     ,'.'     },
    {VK_DIVIDE    , 0                ,'/'       ,'/'       ,'/'     ,'/'     },
    {VK_MULTIPLY  , 0                ,'*'       ,'*'       ,'*'     ,'*'     },
    {VK_SUBTRACT  , 0                ,'-'       ,'-'       ,'-'     ,'-'     },
    {0            , 0                ,0         ,0         ,0       ,0       }
};


static ALLOC_SECTION_LDATA VK_TO_WCHARS6 aVkToWch6[] = {
    //                      |          |   SHIFT  |  KANA  | K+SHFT |  CONTROL  |  K+CTRL   |
    //                      |          |==========|========|========|===========|===========|
    {VK_BACK      , 0       ,'\b'      ,'\b'      ,'\b'    ,'\b'    , 0x7f      , 0x7f      },
    {VK_CANCEL    , 0       ,0x03      ,0x03      ,0x03    ,0x03    , 0x03      , 0x03      },
    {VK_ESCAPE    , 0       ,0x1b      ,0x1b      ,0x1b    ,0x1b    , 0x1b      , 0x1b      },
    {VK_OEM_4     , KANALOK ,'['       ,'{'       ,WCH_SVS ,WCH_OB  , 0x1b      , 0x1b      },
    {VK_OEM_5     , KANALOK ,'\\'      ,'|'       ,WCH_PS  ,WCH_PS  , 0x1c      , 0x1c      },
    {VK_OEM_102   , KANALOK ,WCH_NONE  ,'_'       ,WCH_RO  ,WCH_RO  , 0x1c      , 0x1c      },  // LK411 modified
    {VK_OEM_6     , KANALOK ,']'       ,'}'       ,WCH_MU  ,WCH_CB  , 0x1d      , 0x1d      },
    {VK_RETURN    , 0       ,'\r'      ,'\r'      ,'\r'    ,'\r'    , '\n'      , '\n'      },
    {VK_SPACE     , 0       ,' '       ,' '       ,' '     ,' '     , 0x20      , 0x20      },
    {0            , 0       ,0         ,0         ,0       ,0       , 0         , 0         }
};


static ALLOC_SECTION_LDATA VK_TO_WCHARS8 aVkToWch8[] = {
    //                      |          |   SHIFT  |  KANA  | K+SHFT |  CONTROL  |  K+CTRL   | SHFT+CTRL |K+SHFT+CTRL|
    //                      |          |==========|========|========|===========|===========|===========|===========|
    {'2'          , KANALOK ,'2'       ,'"'       ,WCH_HU  ,WCH_HU  , WCH_NONE  , WCH_NONE  , 0x00      , 0x00      },
    {'6'          , KANALOK ,'6'       ,'&'       ,WCH_O   ,WCH_OO  , WCH_NONE  , WCH_NONE  , 0x1e      , 0x1e      },
    {VK_OEM_MINUS , KANALOK ,'-'       ,'='       ,WCH_HO  ,WCH_HO  , WCH_NONE  , WCH_NONE  , 0x1f      , 0x1f      },
    {0            , 0       ,0         ,0         ,0       ,0       , 0         , 0         , 0         , 0         }
};


// Put this last so that VkKeyScan interprets number characters
// as coming from the main section of the kbd (aVkToWch2 and
// aVkToWch4) before considering the numpad (aVkToWch1).
//
// LK411 doesn't use this table. (Because it doesn't use NUMPAD VK)

static ALLOC_SECTION_LDATA VK_TO_WCHARS4 aVkToWch1[] = {
    //                     |          |   SHIFT  |  KANA  | K+SHFT |
    //                     |          |==========|========|========|
    { VK_NUMPAD0   , 0      ,  '0'    , WCH_NONE ,   '0'  ,WCH_NONE},
    { VK_NUMPAD1   , 0      ,  '1'    , WCH_NONE ,   '1'  ,WCH_NONE},
    { VK_NUMPAD2   , 0      ,  '2'    , WCH_NONE ,   '2'  ,WCH_NONE},
    { VK_NUMPAD3   , 0      ,  '3'    , WCH_NONE ,   '3'  ,WCH_NONE},
    { VK_NUMPAD4   , 0      ,  '4'    , WCH_NONE ,   '4'  ,WCH_NONE},
    { VK_NUMPAD5   , 0      ,  '5'    , WCH_NONE ,   '5'  ,WCH_NONE},
    { VK_NUMPAD6   , 0      ,  '6'    , WCH_NONE ,   '6'  ,WCH_NONE},
    { VK_NUMPAD7   , 0      ,  '7'    , WCH_NONE ,   '7'  ,WCH_NONE},
    { VK_NUMPAD8   , 0      ,  '8'    , WCH_NONE ,   '8'  ,WCH_NONE},
    { VK_NUMPAD9   , 0      ,  '9'    , WCH_NONE ,   '9'  ,WCH_NONE},
    { 0            , 0      ,  '\0'   , 0        ,   0    ,0       }   //null terminator
};


/***************************************************************************\
* aVkToWcharTable: table of pointers to Character Tables
*
* Describes the character tables and the order they should be searched.
*
* Note: the order determines the behavior of VkKeyScan() : this function
*       takes a character and attempts to find a Virtual Key and character-
*       modifier key combination that produces that character.  The table
*       containing the numeric keypad (aVkToWch1) must appear last so that
*       VkKeyScan('0') will be interpreted as one of keys from the main
*       section, not the numpad.  etc.
\***************************************************************************/

static ALLOC_SECTION_LDATA VK_TO_WCHAR_TABLE aVkToWcharTable[] = {
    {  (PVK_TO_WCHARS1)aVkToWch6, 6, sizeof(aVkToWch6[0]) },
    {  (PVK_TO_WCHARS1)aVkToWch8, 8, sizeof(aVkToWch8[0]) },
    {  (PVK_TO_WCHARS1)aVkToWch4, 4, sizeof(aVkToWch4[0]) },
    {  (PVK_TO_WCHARS1)aVkToWch1, 4, sizeof(aVkToWch1[0]) },  // must come last
    {                       NULL, 0, 0                    }
};



/***************************************************************************\
* aKeyNames[], aKeyNamesExt[]  - Scan Code -> Key Name tables
*
* For the GetKeyNameText() API function
*
* Tables for non-extended and extended (KBDEXT) keys.
* (Keys producing printable characters are named by the character itself)
\***************************************************************************/

static ALLOC_SECTION_LDATA VSC_LPWSTR aKeyNames[] = {
    0x01,    L"Esc",
    0x0e,    L"Backspace",
    0x0f,    L"Tab",
    0x1c,    L"Enter",
    0x1d,    L"Ctrl",
//  0x29,    NULL,              // LK411JJ doesn't use this code
    0x2a,    L"Shift",
    0x36,    L"Right Shift",
    0x37,    L"Num *",
    0x38,    L"Alt",
    0x39,    L"Space",
    0x3a,    L"Caps Lock",
    0x3b,    L"F1",
    0x3c,    L"F2",
    0x3d,    L"F3",
    0x3e,    L"F4",
    0x3f,    L"F5",
    0x40,    L"F6",
    0x41,    L"F7",
    0x42,    L"F8",
    0x43,    L"F9",
    0x44,    L"F10",
    0x45,    L"Num Lock",
    0x46,    L"Scroll Lock",
    0x47,    L"Num 7",
    0x48,    L"Num 8",
    0x49,    L"Num 9",
    0x4a,    L"Num -",
    0x4b,    L"Num 4",
    0x4c,    L"Num 5",
    0x4d,    L"Num 6",
    0x4e,    L"Num +",
    0x4f,    L"Num 1",
    0x50,    L"Num 2",
    0x51,    L"Num 3",
    0x52,    L"Num 0",
    0x53,    L"Num Del",
    0x54,    L"Sys Req",
    0x57,    L"F11",
    0x58,    L"F12",
    0x70,    (LPWSTR)SZ_KEY_NAME_HIRAGANA,
    0x73,    L"_",          // LK411 added
    0x79,    (LPWSTR)SZ_KEY_NAME_HENKAN,
    0x7b,    (LPWSTR)SZ_KEY_NAME_MUHENKAN,
    0x7d,    L"\\",         // LK411 added
    0   ,    NULL
};


static ALLOC_SECTION_LDATA VSC_LPWSTR aKeyNamesExt[] = {
    0x0f,    (LPWSTR)SZ_KEY_NAME_KANA,  //LK411 added, (@@ check), this macro defined by NEC
    0x1c,    L"Num Enter",
    0x1d,    L"Right Control",
    0x35,    L"Num /",
    0x37,    L"Prnt Scrn",
    0x38,    L"Right Alt",
    0x3d,    L"F13",            // LK411 added
    0x3e,    L"F14",            // LK411 added
    0x3f,    L"F15",            // LK411 added (Help)
    0x40,    L"F16",            // LK411 added (Do)
    0x41,    L"F17",            // LK411 added
//  0x45,    L"Num Lock",       // LK411 removed
    0x46,    L"Break",
    0x47,    L"Home",
    0x48,    L"Up",
    0x49,    L"Page Up",
    0x4b,    L"Left",
    0x4d,    L"Right",
    0x4e,    L"Num +",          // LK411 modified(same KP,)
    0x4f,    L"End",
    0x50,    L"Down",
    0x51,    L"Page Down",
    0x52,    L"Insert",
    0x53,    L"Delete",
//  0x54,    L"<00>",           // LK411 removed
//  0x56,    L"Help",           // LK411 removed
//  0x5B,    L"Left Windows",       // LK411 removed
//  0x5C,    L"Right Windows",      // LK411 removed
//  0x5D,    L"Application",        // LK411 removed
    0   ,    NULL
};



static ALLOC_SECTION_LDATA KBDTABLES KbdTables = {
    /*
     * Modifier keys
     */
    &CharModifiers,

    /*
     * Characters tables
     */
    aVkToWcharTable,

    /*
     * Diacritics  (none for US English)
     */
    NULL,

    /*
     * Names of Keys  (no dead keys)
     */
    aKeyNames,
    aKeyNamesExt,
    NULL,

    /*
     * Scan codes to Virtual Keys
     */
    ausVK,
    sizeof(ausVK) / sizeof(ausVK[0]),
    aE0VscToVk,
    aE1VscToVk,

    /*
     * No Locale-specific special processing
     */
    0,

    /*
     * No Ligatures
     */
    0, 0, NULL,

    /*
     * Type and subtype
     */
    KEYBOARD_TYPE_JAPAN,
    MAKEWORD(DEC_KBD_JIS_LAYOUT_TYPE, NLSKBD_OEM_DEC),
};


PKBDTABLES KbdLayerDescriptor(VOID)
{
    return &KbdTables;
}



/***********************************************************************\
* VkToFuncTable_LK411[]
*
\***********************************************************************/

static ALLOC_SECTION_LDATA VK_F VkToFuncTable_LK411[] = {
    /* LOCK key */
    {
        VK_CAPITAL,           // Base Vk
        KBDNLS_TYPE_TOGGLE,   // NLSFEProcType
        KBDNLS_INDEX_NORMAL,  // NLSFEProcCurrent
        0x32, /* 0011 0010 */ // NLSFEProcSwitch
        {                     // NLSFEProc
            {KBDNLS_SEND_BASE_VK,0},         // Base
            {KBDNLS_ALPHANUM,0},             // Shift
            {KBDNLS_NOEVENT,0},              // Control
            {KBDNLS_NOEVENT,0},              // Shift+Control
            {KBDNLS_ALPHANUM,0},             // Alt
            {KBDNLS_ALPHANUM,0},             // Shift+Alt
            {KBDNLS_CODEINPUT,0},            // Control+Alt
            {KBDNLS_CODEINPUT,0}             // Shift+Control+Alt
        },
        {                     // NLSFEProcAlt
            {KBDNLS_ALPHANUM,0},             // Base
            {KBDNLS_ALPHANUM,0},             // Shift
            {KBDNLS_NOEVENT,0},              // Control
            {KBDNLS_NOEVENT,0},              // Shift+Control
            {KBDNLS_ALPHANUM,0},             // Alt
            {KBDNLS_ALPHANUM,0},             // Shift+Alt
            {KBDNLS_NOEVENT,0},              // Control+Alt
            {KBDNLS_NOEVENT,0}               // Shift+Control+Alt
        }
    },

    /* KANA key */
    {
        VK_KANA,              // Base Vk
        KBDNLS_TYPE_TOGGLE,   // NLSFEProcType
        KBDNLS_INDEX_NORMAL,  // NLSFEProcCurrent
        0x08, /* 0000 1000 */ // NLSFEProcSwitch
        {                     // NLSFEProc
            {KBDNLS_SEND_BASE_VK,0},         // Base
            {KBDNLS_NOEVENT,0},              // Shift
            {KBDNLS_NOEVENT,0},              // Control
            {KBDNLS_SEND_PARAM_VK,VK_KANA},  // Shift+Control
            {KBDNLS_NOEVENT,0},              // Alt
            {KBDNLS_NOEVENT,0},              // Shift+Alt
            {KBDNLS_NOEVENT,0},              // Control+Alt
            {KBDNLS_NOEVENT,0}               // Shift+Control+Alt
        },
        {                    // NLSFEProcIndexAlt
            {KBDNLS_SEND_PARAM_VK,VK_KANA},  // Base
            {KBDNLS_SEND_PARAM_VK,VK_KANA},  // Shift
            {KBDNLS_SEND_PARAM_VK,VK_KANA},  // Control
            {KBDNLS_SEND_PARAM_VK,VK_KANA},  // Shift+Control
            {KBDNLS_NOEVENT,0},              // Alt
            {KBDNLS_NOEVENT,0},              // Shift+Alt
            {KBDNLS_NOEVENT,0},              // Control+Alt
            {KBDNLS_NOEVENT,0}               // Shift+Control+Alt
        }
    },

    /* Hiragana/Katakana key */
    {
        VK_DBE_HIRAGANA,      // Base Vk
        KBDNLS_TYPE_TOGGLE,   // NLSFEProcType
        KBDNLS_INDEX_NORMAL,  // NLSFEProcCurrent
        0x08, /* 0000 1000 */ // NLSFEProcSwitch
        {                     // NLSFEProc
            {KBDNLS_HIRAGANA,0},             // Base
            {KBDNLS_KATAKANA,0},             // Shift
            {KBDNLS_SBCSDBCS,0},             // Control
            {KBDNLS_SEND_PARAM_VK,VK_KANA},  // Shift+Control
            {KBDNLS_ROMAN,0},                // Alt
            {KBDNLS_ROMAN,0},                // Shift+Alt
            {KBDNLS_ROMAN,0},                // Control+Alt
            {KBDNLS_NOEVENT,0}               // Shift+Control+Alt
        },
        {                    // NLSFEProcIndexAlt
            {KBDNLS_SEND_PARAM_VK,VK_KANA},  // Base
            {KBDNLS_SEND_PARAM_VK,VK_KANA},  // Shift
            {KBDNLS_SEND_PARAM_VK,VK_KANA},  // Control
            {KBDNLS_SEND_PARAM_VK,VK_KANA},  // Shift+Control
            {KBDNLS_NOEVENT,0},              // Alt
            {KBDNLS_NOEVENT,0},              // Shift+Alt
            {KBDNLS_NOEVENT,0},              // Control+Alt
            {KBDNLS_NOEVENT,0}               // Shift+Control+Alt
        }
    },

#if 0
    // LK411-JJ keyboad doesn't have SBCS/DBCS key.
    /* SBCS/DBCS key */
    {
        VK_DBE_SBCSCHAR,     // Base Vk
        KBDNLS_TYPE_NORMAL,  // NLSFEProcType
        KBDNLS_INDEX_NORMAL, // NLSFEProcCurrent
        0x0,                 // NLSFEProcSwitch
        {                    // NLSFEProc
            {KBDNLS_SBCSDBCS,0},             // Base
            {KBDNLS_SBCSDBCS,0},             // Shift
            {KBDNLS_SBCSDBCS,0},             // Control
            {KBDNLS_SBCSDBCS,0},             // Shift+Control
            {KBDNLS_SEND_PARAM_VK,VK_KANJI}, // Alt
            {KBDNLS_NOEVENT,0},              // Shift+Alt
            {KBDNLS_SEND_PARAM_VK,VK_DBE_ENTERIMECONFIGMODE}, // Control+Alt
            {KBDNLS_SEND_PARAM_VK,VK_DBE_ENTERIMECONFIGMODE}  // Shift+Control+Alt
        },
        {                    // NLSFEProcIndexAlt
            {KBDNLS_NULL,0},  // Base
            {KBDNLS_NULL,0},  // Shift
            {KBDNLS_NULL,0},  // Control
            {KBDNLS_NULL,0},  // Shift+Control
            {KBDNLS_NULL,0},  // Alt
            {KBDNLS_NULL,0},  // Shift+Alt
            {KBDNLS_NULL,0},  // Control+Alt
            {KBDNLS_NULL,0}   // Shift+Control+Alt
        }
    },
#endif

    /* CONVERT key */
    {
        VK_CONVERT,           // Base Vk
        KBDNLS_TYPE_NORMAL,   // NLSFEProcType
        KBDNLS_INDEX_NORMAL,  // NLSFEProcCurrent
        0x0,                  // NLSFEProcSwitch
        {                     // NLSFEProc
            {KBDNLS_SEND_BASE_VK,0},         // Base
            {KBDNLS_SEND_BASE_VK,0},         // Shift
            {KBDNLS_NOEVENT,0},              // Control
            {KBDNLS_NOEVENT,0},              // Shift+Control
            {KBDNLS_SEND_PARAM_VK,VK_KANJI}, // Alt
            {KBDNLS_SEND_PARAM_VK,VK_DBE_ENTERIMECONFIGMODE}, // Shift+Alt (LK411: Shift+Alt+NoConv -> IME config)
            {KBDNLS_SEND_PARAM_VK,VK_DBE_ENTERWORDREGISTERMODE}, // Control+Alt
            {KBDNLS_SEND_PARAM_VK,VK_DBE_ENTERWORDREGISTERMODE}  // Shift+Control+Alt
        },
        {                     // NLSFEProcIndexAlt
            {KBDNLS_NULL,0},  // Base
            {KBDNLS_NULL,0},  // Shift
            {KBDNLS_NULL,0},  // Control
            {KBDNLS_NULL,0},  // Shift+Control
            {KBDNLS_NULL,0},  // Alt
            {KBDNLS_NULL,0},  // Shift+Alt
            {KBDNLS_NULL,0},  // Control+Alt
            {KBDNLS_NULL,0}   // Shift+Control+Alt
        }
    },

    /* NONE-CONVERT key */
    {
        VK_NONCONVERT,       // Base Vk
        KBDNLS_TYPE_NORMAL,  // NLSFEProcType
        KBDNLS_INDEX_NORMAL, // NLSFEProcCurrent
        0x0,                 // NLSFEProcSwitch
        {                    // NLSFEProc
            {KBDNLS_SEND_BASE_VK,0},         // Base
            {KBDNLS_NOEVENT,0},              // Shift
            {KBDNLS_NOEVENT,0},              // Control
            {KBDNLS_NOEVENT,0},              // Shift+Control
            {KBDNLS_SBCSDBCS,0},             // Alt  (LK411: Alt+NoConv -> SBCS/DBCS)
            {KBDNLS_SEND_PARAM_VK,VK_DBE_ENTERIMECONFIGMODE}, // Shift+Alt (LK411: Shift+Alt+NoConv -> IME config)
            {KBDNLS_SEND_PARAM_VK,VK_DBE_ENTERWORDREGISTERMODE}, // Control+Alt
            {KBDNLS_SEND_PARAM_VK,VK_DBE_ENTERWORDREGISTERMODE}  // Shift+Control+Alt
        },
        {                         // NLSFEProcIndexAlt
            {KBDNLS_NULL,0},  // Base
            {KBDNLS_NULL,0},  // Shift
            {KBDNLS_NULL,0},  // Control
            {KBDNLS_NULL,0},  // Shift+Control
            {KBDNLS_NULL,0},  // Alt
            {KBDNLS_NULL,0},  // Shift+Alt
            {KBDNLS_NULL,0},  // Control+Alt
            {KBDNLS_NULL,0}   // Shift+Control+Alt
        }
    }
};


/***********************************************************************\
* KbdNlsTables
*
\***********************************************************************/

static ALLOC_SECTION_LDATA KBDNLSTABLES KbdNlsTables = {
    NLSKBD_OEM_DEC,                      // OEM ID
    NLSKBD_INFO_EMURATE_106_KEYBOARD,    // Information
    5,                                   // Number of VK_F entry
    VkToFuncTable_LK411,                 // Pointer to VK_F array
    0,                                   // Pointer to MouseVk entry
    NULL                                 // Pointer to MouseVk array
};


PKBDNLSTABLES KbdNlsLayerDescriptor(VOID)
{
    return &KbdNlsTables;
}

/* EOF */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kbd\fe_kbds\jpn\lk411j\sources.inc ===
!IF 0

Copyright (c) 1989-2000  Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


!ENDIF

MINORCOMP=kbdlk41j

!include ..\..\japan.inc

SOURCES_USED=..\sources.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kbd\fe_kbds\jpn\lk411a\kbdlk41a.c ===
/***************************************************************************\
* Module Name: kbdlk41a.c
*
* DEC LK411-AJ keyboard layout driver
*
* History:
* 20-SEP-1996: Nakazato(v-mnakaz, DEC-J) created
\***************************************************************************/

#include <windows.h>
#include <ime.h>
#include "vkoem.h"
#include "kbdjpn.h"
#include "kbdlk41a.h"

#if defined(_M_IA64)
#pragma section(".data")
#define ALLOC_SECTION_LDATA __declspec(allocate(".data"))
#else
#pragma data_seg(".data")
#define ALLOC_SECTION_LDATA
#endif

/***************************************************************************\
* ausVK[] - Virtual Scan Code to Virtual Key conversion table for LK411-AJ
\***************************************************************************/

static ALLOC_SECTION_LDATA USHORT ausVK[] = {
    T00, T01, T02, T03, T04, T05, T06, T07,
    T08, T09, T0A, T0B, T0C, T0D, T0E, T0F,
    T10, T11, T12, T13, T14, T15, T16, T17,
    T18, T19, T1A, T1B, T1C, T1D, T1E, T1F,
    T20, T21, T22, T23, T24, T25, T26, T27,
    T28,

    // LK411-AJ uses "<>" key as SBCS/DBCS (NLS key)
    T29 | KBDSPECIAL,

    T2A, T2B, T2C, T2D, T2E, T2F,
    T30, T31, T32, T33, T34, T35,

     // Right-hand Shift key must have KBDEXT bit set.
    T36 | KBDEXT,

     // numpad_* + Shift/Alt -> SnapShot
    T37 | KBDMULTIVK,

    T38, T39,

     // Lock key(CapsLock) must have KBDSPECIAL bit set (NLS key)
    T3A | KBDSPECIAL,

    T3B, T3C, T3D, T3E, T3F,
    T40, T41, T42, T43, T44,

     // NumLock Key:
     //     KBDEXT     - VK_NUMLOCK is an Extended key
     //     KBDMULTIVK - VK_NUMLOCK or VK_PAUSE (without or with CTRL)
    T45 | KBDEXT | KBDMULTIVK,

    T46 | KBDMULTIVK,

     // Number Pad keys:
     //    KBDNUMPAD  - digits 0-9 and decimal point.
     //    KBDSPECIAL - require special processing by Windows
    T47 | KBDNUMPAD | KBDSPECIAL,   // Numpad 7 (Home)
    T48 | KBDNUMPAD | KBDSPECIAL,   // Numpad 8 (Up),
    T49 | KBDNUMPAD | KBDSPECIAL,   // Numpad 9 (PgUp),
    T4A,
    T4B | KBDNUMPAD | KBDSPECIAL,   // Numpad 4 (Left),
    T4C | KBDNUMPAD | KBDSPECIAL,   // Numpad 5 (Clear),
    T4D | KBDNUMPAD | KBDSPECIAL,   // Numpad 6 (Right),
    T4E,
    T4F | KBDNUMPAD | KBDSPECIAL,   // Numpad 1 (End),
    T50 | KBDNUMPAD | KBDSPECIAL,   // Numpad 2 (Down),
    T51 | KBDNUMPAD | KBDSPECIAL,   // Numpad 3 (PgDn),
    T52 | KBDNUMPAD | KBDSPECIAL,   // Numpad 0 (Ins),
    T53 | KBDNUMPAD | KBDSPECIAL,   // Numpad . (Del),

    T54, T55, T56, T57, T58, T59, T5A, T5B,
    T5C, T5D, T5E, T5F, T60, T61, T62, T63,
    T64, T65, T66, T67, T68, T69, T6A, T6B,
    T6C, T6D, T6E, T6F,

     // Hiragana/Katakana/Roman key must have KBDSPECIAL bit set (NLS key)
    T70 | KBDSPECIAL,

    T71, T72, T73,
    T74, T75, T76, T77, T78,

     // Conversion key must have KBDSPECIAL bit set (NLS key)
    T79 | KBDSPECIAL,

    T7A,

     // Non-Conversion key must have KBDSPECIAL bit set (NLS key)
    T7B | KBDSPECIAL,

    T7C, T7D, T7E, T7F
};


static ALLOC_SECTION_LDATA VSC_VK aE0VscToVk[] = {
        { 0x0F, X0F | KBDEXT | KBDSPECIAL | KBDMULTIVK },       // LK411 added (kana key)
        { 0x1C, X1C | KBDEXT              },  // Numpad Enter
        { 0x1D, X1D | KBDEXT              },  // RControl
        { 0x35, X35 | KBDEXT              },  // Numpad Divide
        { 0x37, X37 | KBDEXT              },  // Snapshot
        { 0x38, X38 | KBDEXT              },  // RMenu
        { 0x3D, X3D | KBDEXT              },  // F13            // LK411 added
        { 0x3E, X3E | KBDEXT              },  // F14            // LK411 added
        { 0x3F, X3F | KBDEXT              },  // F15 (Help)     // LK411 added
        { 0x40, X40 | KBDEXT              },  // F16 (Do)       // LK411 added
        { 0x41, X41 | KBDEXT              },  // F17            // LK411 added
        { 0x46, X46 | KBDEXT              },  // Break (Ctrl + Pause)   // LK411 removed (@@ check)
        { 0x47, X47 | KBDEXT              },  // Home
        { 0x48, X48 | KBDEXT              },  // Up
        { 0x49, X49 | KBDEXT              },  // Prior
        { 0x4B, X4B | KBDEXT              },  // Left
        { 0x4D, X4D | KBDEXT              },  // Right
        { 0x4E, X4E | KBDEXT              },  // Keypad Minus       // LK411
        { 0x4F, X4F | KBDEXT              },  // End
        { 0x50, X50 | KBDEXT              },  // Down
        { 0x51, X51 | KBDEXT              },  // Next
        { 0x52, X52 | KBDEXT              },  // Insert
        { 0x53, X53 | KBDEXT              },  // Delete
//      { 0x5B, X5B | KBDEXT              },  // Left Win       // LK411 remove
//      { 0x5C, X5C | KBDEXT              },  // Right Win      // LK411 remove
//      { 0x5D, X5D | KBDEXT              },  // Application        // LK411 remove
        { 0,      0                       }
};


static ALLOC_SECTION_LDATA VSC_VK aE1VscToVk[] = {
        { 0x1D, Y1D                       },  // Pause
        { 0   ,   0                       }
};



/***************************************************************************\
* aVkToBits[]  - map Virtual Keys to Modifier Bits
*
* See kbd.h for a full description.
*
* US Keyboard has only three shifter keys:
*     SHIFT (L & R) affects alphabnumeric keys,
*     CTRL  (L & R) is used to generate control characters
*     ALT   (L & R) used for generating characters by number with numpad
\***************************************************************************/

static ALLOC_SECTION_LDATA VK_TO_BIT aVkToBits[] = {
    { VK_SHIFT,   KBDSHIFT },   // 1st bit (0001)
    { VK_CONTROL, KBDCTRL  },   // 2nd bit (0010)
    { VK_MENU,    KBDALT   },   // 4th bit (0100)
    { VK_KANA,    KBDKANA  },   // 8th bit (1000)
    { 0,          0        }
};



/***************************************************************************\
* aModification[]  - map character modifier bits to modification number
*
* See kbd.h for a full description.
*
\***************************************************************************/

static ALLOC_SECTION_LDATA MODIFIERS CharModifiers = {
    &aVkToBits[0],
    11,
    {
    //  Modification# // bit    Keys Pressed  : Explanation
    //  ============= // ====  ============== : =============================
        0,            // 0000                 : unshifted characters
        1,            // 0001           SHIFT : capitals, ~!@#$%^&*()_+{}:"<>? etc.
        4,            // 0010      CTRL       : control characters
        6,            // 0011      CTRL SHIFT :
        SHFT_INVALID, // 0100  ALT            : invalid
        SHFT_INVALID, // 0101  ALT      SHIFT : invalid
        SHFT_INVALID, // 0110  ALT CTRL       : invalid
        SHFT_INVALID, // 0111  ALT CTRL SHIFT : invalid
        2,            // 1000  KANA
        3,            // 1001  KANA      SHIFT
        5,            // 1010  KANA CTRL
        7             // 1011  KANA CTRL SHIFT
    }
};



/***************************************************************************\
*
* aVkToWch4[]  - Virtual Key to WCHAR translation for 4 shift states
* aVkToWch6[]  - Virtual Key to WCHAR translation for 6 shift states
* aVkToWch8[]  - Virtual Key to WCHAR translation for 8 shift states
* aVkToWch1[]  - Virtual Key to WCHAR translation for NUMPAD
*
* Table attributes: Unordered Scan, null-terminated
*
* Search this table for an entry with a matching Virtual Key to find the
* corresponding unshifted and shifted WCHAR characters.
*
* Reserved VirtualKey values (first column)
*     -1            - this line contains dead characters (diacritic)
*     0             - terminator
*
* Reserved Attribute values (second column)
*     CAPLOK        - CapsLock affects this key like Shift
*     KANALOK       - The KANA-LOCK key affects this key like KANA
*
* Reserved character values (third through last column)
*     WCH_NONE      - No character
*     WCH_DEAD      - Dead character (diacritic) value is in next line
*
\***************************************************************************/

static ALLOC_SECTION_LDATA VK_TO_WCHARS4 aVkToWch4[] = {
    //                               |          |   SHIFT  |  KANA  | K+SHFT |
    //                               |          |==========|========|========|
    {'0'          ,          KANALOK ,'0'       ,')'       ,WCH_WA  ,WCH_WO  },
    {'1'          ,          KANALOK ,'1'       ,'!'       ,WCH_NU  ,WCH_NU  },
    {'3'          ,          KANALOK ,'3'       ,'#'       ,WCH_A   ,WCH_AA  },
    {'4'          ,          KANALOK ,'4'       ,'$'       ,WCH_U   ,WCH_UU  },
    {'5'          ,          KANALOK ,'5'       ,'%'       ,WCH_E   ,WCH_EE  },
    {'7'          ,          KANALOK ,'7'       ,'&'       ,WCH_YA  ,WCH_YAA },
    {'8'          ,          KANALOK ,'8'       ,'*'       ,WCH_YU  ,WCH_YUU },
    {'9'          ,          KANALOK ,'9'       ,'('       ,WCH_YO  ,WCH_YOO },
    {'A'          , CAPLOK | KANALOK ,'a'       ,'A'       ,WCH_TI  ,WCH_TI  },
    {'B'          , CAPLOK | KANALOK ,'b'       ,'B'       ,WCH_KO  ,WCH_KO  },
    {'C'          , CAPLOK | KANALOK ,'c'       ,'C'       ,WCH_SO  ,WCH_SO  },
    {'D'          , CAPLOK | KANALOK ,'d'       ,'D'       ,WCH_SI  ,WCH_SI  },
    {'E'          , CAPLOK | KANALOK ,'e'       ,'E'       ,WCH_I   ,WCH_II  },
    {'F'          , CAPLOK | KANALOK ,'f'       ,'F'       ,WCH_HA  ,WCH_HA  },
    {'G'          , CAPLOK | KANALOK ,'g'       ,'G'       ,WCH_KI  ,WCH_KI  },
    {'H'          , CAPLOK | KANALOK ,'h'       ,'H'       ,WCH_KU  ,WCH_KU  },
    {'I'          , CAPLOK | KANALOK ,'i'       ,'I'       ,WCH_NI  ,WCH_NI  },
    {'J'          , CAPLOK | KANALOK ,'j'       ,'J'       ,WCH_MA  ,WCH_MA  },
    {'K'          , CAPLOK | KANALOK ,'k'       ,'K'       ,WCH_NO  ,WCH_NO  },
    {'L'          , CAPLOK | KANALOK ,'l'       ,'L'       ,WCH_RI  ,WCH_RI  },
    {'M'          , CAPLOK | KANALOK ,'m'       ,'M'       ,WCH_MO  ,WCH_MO  },
    {'N'          , CAPLOK | KANALOK ,'n'       ,'N'       ,WCH_MI  ,WCH_MI  },
    {'O'          , CAPLOK | KANALOK ,'o'       ,'O'       ,WCH_RA  ,WCH_RA  },
    {'P'          , CAPLOK | KANALOK ,'p'       ,'P'       ,WCH_SE  ,WCH_SE  },
    {'Q'          , CAPLOK | KANALOK ,'q'       ,'Q'       ,WCH_TA  ,WCH_TA  },
    {'R'          , CAPLOK | KANALOK ,'r'       ,'R'       ,WCH_SU  ,WCH_SU  },
    {'S'          , CAPLOK | KANALOK ,'s'       ,'S'       ,WCH_TO  ,WCH_TO  },
    {'T'          , CAPLOK | KANALOK ,'t'       ,'T'       ,WCH_KA  ,WCH_KA  },
    {'U'          , CAPLOK | KANALOK ,'u'       ,'U'       ,WCH_NA  ,WCH_NA  },
    {'V'          , CAPLOK | KANALOK ,'v'       ,'V'       ,WCH_HI  ,WCH_HI  },
    {'W'          , CAPLOK | KANALOK ,'w'       ,'W'       ,WCH_TE  ,WCH_TE  },
    {'X'          , CAPLOK | KANALOK ,'x'       ,'X'       ,WCH_SA  ,WCH_SA  },
    {'Y'          , CAPLOK | KANALOK ,'y'       ,'Y'       ,WCH_NN  ,WCH_NN  },
    {'Z'          , CAPLOK | KANALOK ,'z'       ,'Z'       ,WCH_TU  ,WCH_TUU },
    {VK_OEM_1     ,          KANALOK ,';'       ,':'       ,WCH_RE  ,WCH_RE  },
    {VK_OEM_2     ,          KANALOK ,'/'       ,'?'       ,WCH_ME  ,WCH_MD  },
    {VK_OEM_7     ,          KANALOK ,0x27      ,'"'       ,WCH_KE  ,WCH_KE  },
//  {VK_OEM_8     , 0                ,','       ,','       ,','     ,','     },     //LK411 removed
    {VK_OEM_COMMA ,          KANALOK ,','       ,'<'       ,WCH_NE  ,WCH_IC  },
    {VK_OEM_PERIOD,          KANALOK ,'.'       ,'>'       ,WCH_RU  ,WCH_IP  },
    {VK_OEM_PLUS  ,          KANALOK ,'='       ,'+'       ,WCH_HE  ,WCH_HE  },
    {VK_DBE_SBCSCHAR, 0              ,'`'       ,'~'       ,'`'     ,'~'     },     //LK411 added
    {VK_TAB       , 0                ,'\t'      ,'\t'      ,'\t'    ,'\t'    },
    {VK_ADD       , 0                ,'+'       ,'+'       ,'+'     ,'+'     },
    {VK_DECIMAL   , 0                ,'.'       ,'.'       ,'.'     ,'.'     },
    {VK_DIVIDE    , 0                ,'/'       ,'/'       ,'/'     ,'/'     },
    {VK_MULTIPLY  , 0                ,'*'       ,'*'       ,'*'     ,'*'     },
    {VK_SUBTRACT  , 0                ,'-'       ,'-'       ,'-'     ,'-'     },
    {0            , 0                ,0         ,0         ,0       ,0       }
};


static ALLOC_SECTION_LDATA VK_TO_WCHARS6 aVkToWch6[] = {
    //                      |          |   SHIFT  |  KANA  | K+SHFT |  CONTROL  |  K+CTRL   |
    //                      |          |==========|========|========|===========|===========|
    {VK_BACK      , 0       ,'\b'      ,'\b'      ,'\b'    ,'\b'    , 0x7f      , 0x7f      },
    {VK_CANCEL    , 0       ,0x03      ,0x03      ,0x03    ,0x03    , 0x03      , 0x03      },
    {VK_ESCAPE    , 0       ,0x1b      ,0x1b      ,0x1b    ,0x1b    , 0x1b      , 0x1b      },
    {VK_OEM_4     , KANALOK ,'['       ,'{'       ,WCH_RO  ,WCH_VS  , 0x1b      , 0x1b      },  // LK411 modified
    {VK_OEM_5     , KANALOK ,'\\'      ,'|'       ,WCH_OB  ,WCH_CB  , 0x1c      , 0x1c      },  // LK411 modified
    {VK_OEM_6     , KANALOK ,']'       ,'}'       ,WCH_MU  ,WCH_SVS , 0x1d      , 0x1d      },  // LK411 modified
    {VK_RETURN    , 0       ,'\r'      ,'\r'      ,'\r'    ,'\r'    , '\n'      , '\n'      },
    {VK_SPACE     , 0       ,' '       ,' '       ,' '     ,' '     , 0x20      , 0x20      },
    {0            , 0       ,0         ,0         ,0       ,0       , 0         , 0         }
};


static ALLOC_SECTION_LDATA VK_TO_WCHARS8 aVkToWch8[] = {
    //                      |          |   SHIFT  |  KANA  | K+SHFT |  CONTROL  |  K+CTRL   | SHFT+CTRL |K+SHFT+CTRL|
    //                      |          |==========|========|========|===========|===========|===========|===========|
    {'2'          , KANALOK ,'2'       ,'@'       ,WCH_HU  ,WCH_HU  , WCH_NONE  , WCH_NONE  , 0x00      , 0x00      },
    {'6'          , KANALOK ,'6'       ,'^'       ,WCH_O   ,WCH_OO  , WCH_NONE  , WCH_NONE  , 0x1e      , 0x1e      },
    {VK_OEM_MINUS , KANALOK ,'-'       ,'_'       ,WCH_HO  ,WCH_HO  , WCH_NONE  , WCH_NONE  , 0x1f      , 0x1f      },  // LK411
    {0            , 0       ,0         ,0         ,0       ,0       , 0         , 0         , 0         , 0         }
};


// Put this last so that VkKeyScan interprets number characters
// as coming from the main section of the kbd (aVkToWch2 and
// aVkToWch4) before considering the numpad (aVkToWch1).
//
// LK411 doesn't use this table. (Because it doesn't use NUMPAD VK)

static ALLOC_SECTION_LDATA VK_TO_WCHARS4 aVkToWch1[] = {
    //                     |          |   SHIFT  |  KANA  | K+SHFT |
    //                     |          |==========|========|========|
    { VK_NUMPAD0   , 0      ,  '0'    , WCH_NONE ,   '0'  ,WCH_NONE},
    { VK_NUMPAD1   , 0      ,  '1'    , WCH_NONE ,   '1'  ,WCH_NONE},
    { VK_NUMPAD2   , 0      ,  '2'    , WCH_NONE ,   '2'  ,WCH_NONE},
    { VK_NUMPAD3   , 0      ,  '3'    , WCH_NONE ,   '3'  ,WCH_NONE},
    { VK_NUMPAD4   , 0      ,  '4'    , WCH_NONE ,   '4'  ,WCH_NONE},
    { VK_NUMPAD5   , 0      ,  '5'    , WCH_NONE ,   '5'  ,WCH_NONE},
    { VK_NUMPAD6   , 0      ,  '6'    , WCH_NONE ,   '6'  ,WCH_NONE},
    { VK_NUMPAD7   , 0      ,  '7'    , WCH_NONE ,   '7'  ,WCH_NONE},
    { VK_NUMPAD8   , 0      ,  '8'    , WCH_NONE ,   '8'  ,WCH_NONE},
    { VK_NUMPAD9   , 0      ,  '9'    , WCH_NONE ,   '9'  ,WCH_NONE},
    { 0            , 0      ,  '\0'   , 0        ,   0    ,0       }   //null terminator
};


/***************************************************************************\
* aVkToWcharTable: table of pointers to Character Tables
*
* Describes the character tables and the order they should be searched.
*
* Note: the order determines the behavior of VkKeyScan() : this function
*       takes a character and attempts to find a Virtual Key and character-
*       modifier key combination that produces that character.  The table
*       containing the numeric keypad (aVkToWch1) must appear last so that
*       VkKeyScan('0') will be interpreted as one of keys from the main
*       section, not the numpad.  etc.
\***************************************************************************/

static ALLOC_SECTION_LDATA VK_TO_WCHAR_TABLE aVkToWcharTable[] = {
    {  (PVK_TO_WCHARS1)aVkToWch6, 6, sizeof(aVkToWch6[0]) },
    {  (PVK_TO_WCHARS1)aVkToWch8, 8, sizeof(aVkToWch8[0]) },
    {  (PVK_TO_WCHARS1)aVkToWch4, 4, sizeof(aVkToWch4[0]) },
    {  (PVK_TO_WCHARS1)aVkToWch1, 4, sizeof(aVkToWch1[0]) },  // must come last
    {                       NULL, 0, 0                    }
};



/***************************************************************************\
* aKeyNames[], aKeyNamesExt[]  - Scan Code -> Key Name tables
*
* For the GetKeyNameText() API function
*
* Tables for non-extended and extended (KBDEXT) keys.
* (Keys producing printable characters are named by the character itself)
\***************************************************************************/

static ALLOC_SECTION_LDATA VSC_LPWSTR aKeyNames[] = {
    0x01,    L"Esc",
    0x0e,    L"Backspace",
    0x0f,    L"Tab",
    0x1c,    L"Enter",
    0x1d,    L"Ctrl",
    0x29,    L"<>",
    0x2a,    L"Shift",
    0x36,    L"Right Shift",
    0x37,    L"Num *",
    0x38,    L"Alt",
    0x39,    L"Space",
    0x3a,    L"Caps Lock",
    0x3b,    L"F1",
    0x3c,    L"F2",
    0x3d,    L"F3",
    0x3e,    L"F4",
    0x3f,    L"F5",
    0x40,    L"F6",
    0x41,    L"F7",
    0x42,    L"F8",
    0x43,    L"F9",
    0x44,    L"F10",
    0x45,    L"Num Lock",
    0x46,    L"Scroll Lock",
    0x47,    L"Num 7",
    0x48,    L"Num 8",
    0x49,    L"Num 9",
    0x4a,    L"Num -",
    0x4b,    L"Num 4",
    0x4c,    L"Num 5",
    0x4d,    L"Num 6",
    0x4e,    L"Num +",
    0x4f,    L"Num 1",
    0x50,    L"Num 2",
    0x51,    L"Num 3",
    0x52,    L"Num 0",
    0x53,    L"Num Del",
    0x54,    L"Sys Req",
    0x57,    L"F11",
    0x58,    L"F12",
    0x70,    (LPWSTR)SZ_KEY_NAME_HIRAGANA,
    0x79,    (LPWSTR)SZ_KEY_NAME_HENKAN,
    0x7b,    (LPWSTR)SZ_KEY_NAME_MUHENKAN,
    0   ,    NULL
};


static ALLOC_SECTION_LDATA VSC_LPWSTR aKeyNamesExt[] = {
    0x0f,    (LPWSTR)SZ_KEY_NAME_KANA,  //LK411 added, (@@ check), this macro defined by NEC
    0x1c,    L"Num Enter",
    0x1d,    L"Right Control",
    0x35,    L"Num /",
    0x37,    L"Prnt Scrn",
    0x38,    L"Right Alt",
    0x3d,    L"F13",            // LK411 added
    0x3e,    L"F14",            // LK411 added
    0x3f,    L"F15",            // LK411 added (Help)
    0x40,    L"F16",            // LK411 added (Do)
    0x41,    L"F17",            // LK411 added
//  0x45,    L"Num Lock",       // LK411 removed
    0x46,    L"Break",
    0x47,    L"Home",
    0x48,    L"Up",
    0x49,    L"Page Up",
    0x4b,    L"Left",
    0x4d,    L"Right",
    0x4e,    L"Num +",          // LK411 modified(same KP,)
    0x4f,    L"End",
    0x50,    L"Down",
    0x51,    L"Page Down",
    0x52,    L"Insert",
    0x53,    L"Delete",
//  0x54,    L"<00>",           // LK411 removed
//  0x56,    L"Help",           // LK411 removed
//  0x5B,    L"Left Windows",       // LK411 removed
//  0x5C,    L"Right Windows",      // LK411 removed
//  0x5D,    L"Application",        // LK411 removed
    0   ,    NULL
};



static ALLOC_SECTION_LDATA KBDTABLES KbdTables = {
    /*
     * Modifier keys
     */
    &CharModifiers,

    /*
     * Characters tables
     */
    aVkToWcharTable,

    /*
     * Diacritics  (none for US English)
     */
    NULL,

    /*
     * Names of Keys  (no dead keys)
     */
    aKeyNames,
    aKeyNamesExt,
    NULL,

    /*
     * Scan codes to Virtual Keys
     */
    ausVK,
    sizeof(ausVK) / sizeof(ausVK[0]),
    aE0VscToVk,
    aE1VscToVk,

    /*
     * No Locale-specific special processing
     */
    0,

    /*
     * No Ligatures
     */
    0, 0, NULL,

    /*
     * Type and subtype
     */
    KEYBOARD_TYPE_JAPAN,
    MAKEWORD(DEC_KBD_ANSI_LAYOUT_TYPE, NLSKBD_OEM_DEC),
};


PKBDTABLES KbdLayerDescriptor(VOID)
{
    return &KbdTables;
}



/***********************************************************************\
* VkToFuncTable_LK411[]
*
\***********************************************************************/

static ALLOC_SECTION_LDATA VK_F VkToFuncTable_LK411[] = {
    /* LOCK key */
    {
        VK_CAPITAL,           // Base Vk
        KBDNLS_TYPE_TOGGLE,   // NLSFEProcType
        KBDNLS_INDEX_NORMAL,  // NLSFEProcCurrent
        0x32, /* 0011 0010 */ // NLSFEProcSwitch
        {                     // NLSFEProc
            {KBDNLS_SEND_BASE_VK,0},         // Base
            {KBDNLS_ALPHANUM,0},             // Shift
            {KBDNLS_NOEVENT,0},              // Control
            {KBDNLS_NOEVENT,0},              // Shift+Control
            {KBDNLS_ALPHANUM,0},             // Alt
            {KBDNLS_ALPHANUM,0},             // Shift+Alt
            {KBDNLS_CODEINPUT,0},            // Control+Alt
            {KBDNLS_CODEINPUT,0}             // Shift+Control+Alt
        },
        {                     // NLSFEProcAlt
            {KBDNLS_ALPHANUM,0},             // Base
            {KBDNLS_ALPHANUM,0},             // Shift
            {KBDNLS_NOEVENT,0},              // Control
            {KBDNLS_NOEVENT,0},              // Shift+Control
            {KBDNLS_ALPHANUM,0},             // Alt
            {KBDNLS_ALPHANUM,0},             // Shift+Alt
            {KBDNLS_NOEVENT,0},              // Control+Alt
            {KBDNLS_NOEVENT,0}               // Shift+Control+Alt
        }
    },

    /* KANA key */
    {
        VK_KANA,              // Base Vk
        KBDNLS_TYPE_TOGGLE,   // NLSFEProcType
        KBDNLS_INDEX_NORMAL,  // NLSFEProcCurrent
        0x08, /* 0000 1000 */ // NLSFEProcSwitch
        {                     // NLSFEProc
            {KBDNLS_SEND_BASE_VK,0},         // Base
            {KBDNLS_NOEVENT,0},              // Shift
            {KBDNLS_NOEVENT,0},              // Control
            {KBDNLS_SEND_PARAM_VK,VK_KANA},  // Shift+Control
            {KBDNLS_NOEVENT,0},              // Alt
            {KBDNLS_NOEVENT,0},              // Shift+Alt
            {KBDNLS_NOEVENT,0},              // Control+Alt
            {KBDNLS_NOEVENT,0}               // Shift+Control+Alt
        },
        {                    // NLSFEProcIndexAlt
            {KBDNLS_SEND_PARAM_VK,VK_KANA},  // Base
            {KBDNLS_SEND_PARAM_VK,VK_KANA},  // Shift
            {KBDNLS_SEND_PARAM_VK,VK_KANA},  // Control
            {KBDNLS_SEND_PARAM_VK,VK_KANA},  // Shift+Control
            {KBDNLS_NOEVENT,0},              // Alt
            {KBDNLS_NOEVENT,0},              // Shift+Alt
            {KBDNLS_NOEVENT,0},              // Control+Alt
            {KBDNLS_NOEVENT,0}               // Shift+Control+Alt
        }
    },

    /* Hiragana/Katakana key */
    {
        VK_DBE_HIRAGANA,      // Base Vk
        KBDNLS_TYPE_TOGGLE,   // NLSFEProcType
        KBDNLS_INDEX_NORMAL,  // NLSFEProcCurrent
        0x08, /* 0000 1000 */ // NLSFEProcSwitch
        {                     // NLSFEProc
            {KBDNLS_HIRAGANA,0},             // Base
            {KBDNLS_KATAKANA,0},             // Shift
            {KBDNLS_SBCSDBCS,0},             // Control
            {KBDNLS_SEND_PARAM_VK,VK_KANA},  // Shift+Control
            {KBDNLS_ROMAN,0},                // Alt
            {KBDNLS_ROMAN,0},                // Shift+Alt
            {KBDNLS_ROMAN,0},                // Control+Alt
            {KBDNLS_NOEVENT,0}               // Shift+Control+Alt
        },
        {                    // NLSFEProcIndexAlt
            {KBDNLS_SEND_PARAM_VK,VK_KANA},  // Base
            {KBDNLS_SEND_PARAM_VK,VK_KANA},  // Shift
            {KBDNLS_SEND_PARAM_VK,VK_KANA},  // Control
            {KBDNLS_SEND_PARAM_VK,VK_KANA},  // Shift+Control
            {KBDNLS_NOEVENT,0},              // Alt
            {KBDNLS_NOEVENT,0},              // Shift+Alt
            {KBDNLS_NOEVENT,0},              // Control+Alt
            {KBDNLS_NOEVENT,0}               // Shift+Control+Alt
        }
    },

    /* SBCS/DBCS key */
    {
        VK_DBE_SBCSCHAR,      // Base Vk
        KBDNLS_TYPE_TOGGLE,   // NLSFEProcType
        KBDNLS_INDEX_NORMAL,  // NLSFEProcCurrent
        0x30, /* 0011 0000 */ // NLSFEProcSwitch
        {                     // NLSFEProc
            {KBDNLS_SEND_BASE_VK,0},         // Base  ("<")
            {KBDNLS_SEND_BASE_VK,0},         // Shift (">")
            {KBDNLS_SBCSDBCS,0},             // Control
            {KBDNLS_SBCSDBCS,0},             // Shift+Control
            {KBDNLS_SEND_PARAM_VK,VK_KANJI}, // Alt
            {KBDNLS_SEND_PARAM_VK,VK_KANJI}, // Shift+Alt
            {KBDNLS_SEND_PARAM_VK,VK_DBE_ENTERIMECONFIGMODE}, // Control+Alt
            {KBDNLS_SEND_PARAM_VK,VK_DBE_ENTERIMECONFIGMODE}  // Shift+Control+Alt
        },
        {                    // NLSFEProcIndexAlt
            {KBDNLS_SEND_PARAM_VK,VK_KANJI},  // Base
            {KBDNLS_SEND_PARAM_VK,VK_KANJI},  // Shift
            {KBDNLS_NOEVENT,0},              // Control
            {KBDNLS_NOEVENT,0},              // Shift+Control
            {KBDNLS_SEND_PARAM_VK,VK_KANJI}, // Alt
            {KBDNLS_SEND_PARAM_VK,VK_KANJI}, // Shift+Alt
            {KBDNLS_NOEVENT,0},              // Control+Alt
            {KBDNLS_NOEVENT,0}               // Shift+Control+Alt
        }
    },

    /* CONVERT key */
    {
        VK_CONVERT,          // Base Vk
        KBDNLS_TYPE_NORMAL,  // NLSFEProcType
        KBDNLS_INDEX_NORMAL, // NLSFEProcCurrent
        0x0,                 // NLSFEProcSwitch
        {                    // NLSFEProc
            {KBDNLS_SEND_BASE_VK,0},         // Base
            {KBDNLS_SEND_BASE_VK,0},         // Shift
            {KBDNLS_NOEVENT,0},              // Control
            {KBDNLS_NOEVENT,0},              // Shift+Control
            {KBDNLS_SEND_PARAM_VK,VK_KANJI}, // Alt
            {KBDNLS_SEND_PARAM_VK,VK_DBE_ENTERIMECONFIGMODE}, // Shift+Alt (LK411: Shift+Alt+NoConv -> IME config)
            {KBDNLS_SEND_PARAM_VK,VK_DBE_ENTERWORDREGISTERMODE}, // Control+Alt
            {KBDNLS_SEND_PARAM_VK,VK_DBE_ENTERWORDREGISTERMODE}  // Shift+Control+Alt
        },
        {                         // NLSFEProcIndexAlt
            {KBDNLS_NULL,0},  // Base
            {KBDNLS_NULL,0},  // Shift
            {KBDNLS_NULL,0},  // Control
            {KBDNLS_NULL,0},  // Shift+Control
            {KBDNLS_NULL,0},  // Alt
            {KBDNLS_NULL,0},  // Shift+Alt
            {KBDNLS_NULL,0},  // Control+Alt
            {KBDNLS_NULL,0}   // Shift+Control+Alt
        }
    },

    /* NONE-CONVERT key */
    {
        VK_NONCONVERT,       // Base Vk
        KBDNLS_TYPE_NORMAL,  // NLSFEProcType
        KBDNLS_INDEX_NORMAL, // NLSFEProcCurrent
        0x0,                 // NLSFEProcSwitch
        {                    // NLSFEProc
            {KBDNLS_SEND_BASE_VK,0},         // Base
            {KBDNLS_NOEVENT,0},              // Shift
            {KBDNLS_NOEVENT,0},              // Control
            {KBDNLS_NOEVENT,0},              // Shift+Control
            {KBDNLS_SBCSDBCS,0},             // Alt  (LK411: Alt+NoConv -> SBCS/DBCS)
            {KBDNLS_SEND_PARAM_VK,VK_DBE_ENTERIMECONFIGMODE}, // Shift+Alt (LK411: Shift+Alt+NoConv -> IME config)
            {KBDNLS_SEND_PARAM_VK,VK_DBE_ENTERWORDREGISTERMODE}, // Control+Alt
            {KBDNLS_SEND_PARAM_VK,VK_DBE_ENTERWORDREGISTERMODE}  // Shift+Control+Alt
        },
        {                         // NLSFEProcIndexAlt
            {KBDNLS_NULL,0},  // Base
            {KBDNLS_NULL,0},  // Shift
            {KBDNLS_NULL,0},  // Control
            {KBDNLS_NULL,0},  // Shift+Control
            {KBDNLS_NULL,0},  // Alt
            {KBDNLS_NULL,0},  // Shift+Alt
            {KBDNLS_NULL,0},  // Control+Alt
            {KBDNLS_NULL,0}   // Shift+Control+Alt
        }
    }
};


/***********************************************************************\
* KbdNlsTables
*
\***********************************************************************/

static ALLOC_SECTION_LDATA KBDNLSTABLES KbdNlsTables = {
    NLSKBD_OEM_DEC,                      // OEM ID
    NLSKBD_INFO_EMURATE_101_KEYBOARD,    // Information
    6,                                   // Number of VK_F entry
    VkToFuncTable_LK411,                 // Pointer to VK_F array
    0,                                   // Pointer to MouseVk entry
    NULL                                 // Pointer to MouseVk array
};


PKBDNLSTABLES KbdNlsLayerDescriptor(VOID)
{
    return &KbdNlsTables;
}

/* EOF */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kbd\fe_kbds\kor\korea.inc ===
#****************************** File Header ******************************\
# File Name: Sources.inc for JPN KBDs
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific SOURCES file.
#
# History:
# May-14-1999 HiroYama Created
#***************************************************************************/

!include ..\..\..\fekbds.inc

C_DEFINES=$(C_DEFINES) -DKOREA

SOURCES_USED=..\..\korea.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kbd\fe_kbds\kor\101b\sources.inc ===
!IF 0

Copyright (c) 1989-2000  Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


!ENDIF

MINORCOMP=kbd101b

!include ..\..\korea.inc

SOURCES_USED=..\sources.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kbd\fe_kbds\kor\101b\kbd101b.c ===
/***************************************************************************\
* Module Name: kbd101b.c (Type B)
*
* Copyright (c) 1985-92, Microsoft Corporation
*
* Keyboard Type B :  Hangeul Toggle : Right Ctrl
*                    Junja   Toggle : Left  Alt + '='
*                    Hanja   Toggle : Right Alt
\***************************************************************************/

#include <windows.h>
#include <ime.h>
#include "vkoem.h"
#include "kbd101b.h"

#if defined(_M_IA64)
#pragma section(".data")
#define ALLOC_SECTION_LDATA __declspec(allocate(".data"))
#else
#pragma data_seg(".data")
#define ALLOC_SECTION_LDATA
#endif

/***************************************************************************\
* ausVK[] - Virtual Scan Code to Virtual Key conversion table for 101
\***************************************************************************/

static ALLOC_SECTION_LDATA USHORT ausVK[] = {
    T00, T01, T02, T03, T04, T05, T06, T07,
    T08, T09, T0A, T0B, T0C,

    /*
     * '='/'+' key must have KBDSPECIAL bit set (NLS key)
     */
    T0D | KBDSPECIAL,

                                  T0E, T0F,
    T10, T11, T12, T13, T14, T15, T16, T17,
    T18, T19, T1A, T1B, T1C, T1D, T1E, T1F,
    T20, T21, T22, T23, T24, T25, T26, T27,
    T28, T29, T2A, T2B, T2C, T2D, T2E, T2F,
    T30, T31, T32, T33, T34, T35,

    /*
     * Right-hand Shift key must have KBDEXT bit set.
     */
    T36 | KBDEXT,

    /*
     * '='/'+' key must have KBDSPECIAL bit set (NLS key)
     */
    T37 | KBDMULTIVK,

    T38, T39, T3A, T3B, T3C, T3D, T3E, T3F,
    T40, T41, T42, T43, T44,

    /*
     * NumLock Key:
     *     KBDEXT     - VK_NUMLOCK is an Extended key
     *     KBDMULTIVK - VK_NUMLOCK or VK_PAUSE (without or with CTRL)
     */
    T45 | KBDEXT | KBDMULTIVK,

    T46 | KBDMULTIVK,

    /*
     * Number Pad keys:
     *     KBDNUMPAD  - digits 0-9 and decimal point.
     *     KBDSPECIAL - require special processing by Windows
     */
    T47 | KBDNUMPAD | KBDSPECIAL,   // Numpad 7 (Home)
    T48 | KBDNUMPAD | KBDSPECIAL,   // Numpad 8 (Up),
    T49 | KBDNUMPAD | KBDSPECIAL,   // Numpad 9 (PgUp),
    T4A,
    T4B | KBDNUMPAD | KBDSPECIAL,   // Numpad 4 (Left),
    T4C | KBDNUMPAD | KBDSPECIAL,   // Numpad 5 (Clear),
    T4D | KBDNUMPAD | KBDSPECIAL,   // Numpad 6 (Right),
    T4E,
    T4F | KBDNUMPAD | KBDSPECIAL,   // Numpad 1 (End),
    T50 | KBDNUMPAD | KBDSPECIAL,   // Numpad 2 (Down),
    T51 | KBDNUMPAD | KBDSPECIAL,   // Numpad 3 (PgDn),
    T52 | KBDNUMPAD | KBDSPECIAL,   // Numpad 0 (Ins),
    T53 | KBDNUMPAD | KBDSPECIAL,   // Numpad . (Del),

    T54, T55, T56, T57, T58, T59, T5A, T5B,
    T5C, T5D, T5E, T5F, T60, T61, T62, T63,
    T64, T65, T66, T67, T68, T69, T6A, T6B,
    T6C, T6D, T6E, T6F, T70, T71, T72, T73,
    T74, T75, T76, T77, T78, T79, T7A, T7B,
    T7C, T7D, T7E, T7F

};

static ALLOC_SECTION_LDATA VSC_VK aE0VscToVk[] = {
        { 0x10, X10 | KBDEXT              },  // Speedracer: Previous Track
        { 0x19, X19 | KBDEXT              },  // Speedracer: Next Track
        { 0x1C, X1C | KBDEXT              },  // Numpad Enter
        { 0x1D, X1D | KBDEXT | KBDSPECIAL },  // RControl // Hanja key NLS key
        { 0x20, X20 | KBDEXT              },  // Speedracer: Volume Mute
        { 0x21, X21 | KBDEXT              },  // Speedracer: Launch App 2
        { 0x22, X22 | KBDEXT              },  // Speedracer: Media Play/Pause
        { 0x24, X24 | KBDEXT              },  // Speedracer: Media Stop
        { 0x2E, X2E | KBDEXT              },  // Speedracer: Volume Down
        { 0x30, X30 | KBDEXT              },  // Speedracer: Volume Up
        { 0x32, X32 | KBDEXT              },  // Speedracer: Browser Home
        { 0x35, X35 | KBDEXT              },  // Numpad Divide
        { 0x37, X37 | KBDEXT              },  // Snapshot
        { 0x38, X38 | KBDEXT | KBDSPECIAL },  // RMenu    // Hangeul key NLS key
        { 0x46, X46 | KBDEXT              },  // Break (Ctrl + Pause)
        { 0x47, X47 | KBDEXT              },  // Home
        { 0x48, X48 | KBDEXT              },  // Up
        { 0x49, X49 | KBDEXT              },  // Prior
        { 0x4B, X4B | KBDEXT              },  // Left
        { 0x4D, X4D | KBDEXT              },  // Right
        { 0x4F, X4F | KBDEXT              },  // End
        { 0x50, X50 | KBDEXT              },  // Down
        { 0x51, X51 | KBDEXT              },  // Next
        { 0x52, X52 | KBDEXT              },  // Insert
        { 0x53, X53 | KBDEXT              },  // Delete
        { 0x5B, X5B | KBDEXT              },  // Left Win
        { 0x5C, X5C | KBDEXT              },  // Right Win
        { 0x5D, X5D | KBDEXT              },  // Applications
        { 0x5F, X5F | KBDEXT              },  // Speedracer: Sleep
        { 0x65, X65 | KBDEXT              },  // Speedracer: Browser Search
        { 0x66, X66 | KBDEXT              },  // Speedracer: Browser Favorites
        { 0x67, X67 | KBDEXT              },  // Speedracer: Browser Refresh
        { 0x68, X68 | KBDEXT              },  // Speedracer: Browser Stop
        { 0x69, X69 | KBDEXT              },  // Speedracer: Browser Forward
        { 0x6A, X6A | KBDEXT              },  // Speedracer: Browser Back
        { 0x6B, X6B | KBDEXT              },  // Speedracer: Launch App 1
        { 0x6C, X6C | KBDEXT              },  // Speedracer: Launch Mail
        { 0x6D, X6D | KBDEXT              },  // Speedracer: Launch Media Selector
        { 0xF1, XF1 | KBDEXT | KBDSPECIAL },  // Hanja
        { 0xF2, XF2 | KBDEXT | KBDSPECIAL },  // Hangeul
        { 0,      0                       }
};

static ALLOC_SECTION_LDATA VSC_VK aE1VscToVk[] = {
        { 0x1D, Y1D                       },  // Pause
        { 0   ,   0                       }
};

/***************************************************************************\
* aVkToBits[]  - map Virtual Keys to Modifier Bits
*
* See kbd.h for a full description.
*
* US Keyboard has only three shifter keys:
*     SHIFT (L & R) affects alphabnumeric keys,
*     CTRL  (L & R) is used to generate control characters
*     ALT   (L & R) used for generating characters by number with numpad
\***************************************************************************/

static ALLOC_SECTION_LDATA VK_TO_BIT aVkToBits[] = {
    { VK_SHIFT,   KBDSHIFT },
    { VK_CONTROL, KBDCTRL  },
    { VK_MENU,    KBDALT   },
    { 0,          0        }
};

/***************************************************************************\
* aModification[]  - map character modifier bits to modification number
*
* See kbd.h for a full description.
*
\***************************************************************************/

static ALLOC_SECTION_LDATA MODIFIERS CharModifiers = {
    &aVkToBits[0],
    3,
    {
    //  Modification# //  Keys Pressed  : Explanation
    //  ============= // ============== : =============================
        0,            //                : unshifted characters
        1,            //          SHIFT : capitals, ~!@#$%^&*()_+{}:"<>? etc.
        2,            //     CTRL       : control characters
        3,            //     CTRL SHIFT :
                      // ALT            : invalid
                      // ALT      SHIFT : invalid
                      // ALT CTRL       : invalid
                      // ALT CTRL SHIFT : invalid
    }
};

/***************************************************************************\
*
* aVkToWch2[]  - Virtual Key to WCHAR translation for 2 shift states
* aVkToWch3[]  - Virtual Key to WCHAR translation for 3 shift states
* aVkToWch4[]  - Virtual Key to WCHAR translation for 4 shift states
*
* Table attributes: Unordered Scan, null-terminated
*
* Search this table for an entry with a matching Virtual Key to find the
* corresponding unshifted and shifted WCHAR characters.
*
* Reserved VirtualKey values (first column)
*     -1            - this line contains dead characters (diacritic)
*     0             - terminator
*
* Reserved Attribute values (second column)
*     CAPLOK        - CapsLock affects this key like Shift
*
* Reserved character values (third through last column)
*     WCH_NONE      - No character
*     WCH_DEAD      - Dead character (diacritic) value is in next line
*
\***************************************************************************/

static ALLOC_SECTION_LDATA VK_TO_WCHARS2 aVkToWch2[] = {
    {'0'          , 0      ,'0'       ,')'       },
    {'1'          , 0      ,'1'       ,'!'       },
    {'3'          , 0      ,'3'       ,'#'       },
    {'4'          , 0      ,'4'       ,'$'       },
    {'5'          , 0      ,'5'       ,'%'       },
    {'7'          , 0      ,'7'       ,'&'       },
    {'8'          , 0      ,'8'       ,'*'       },
    {'9'          , 0      ,'9'       ,'('       },
    {'A'          , CAPLOK ,'a'       ,'A'       },
    {'B'          , CAPLOK ,'b'       ,'B'       },
    {'C'          , CAPLOK ,'c'       ,'C'       },
    {'D'          , CAPLOK ,'d'       ,'D'       },
    {'E'          , CAPLOK ,'e'       ,'E'       },
    {'F'          , CAPLOK ,'f'       ,'F'       },
    {'G'          , CAPLOK ,'g'       ,'G'       },
    {'H'          , CAPLOK ,'h'       ,'H'       },
    {'I'          , CAPLOK ,'i'       ,'I'       },
    {'J'          , CAPLOK ,'j'       ,'J'       },
    {'K'          , CAPLOK ,'k'       ,'K'       },
    {'L'          , CAPLOK ,'l'       ,'L'       },
    {'M'          , CAPLOK ,'m'       ,'M'       },
    {'N'          , CAPLOK ,'n'       ,'N'       },
    {'O'          , CAPLOK ,'o'       ,'O'       },
    {'P'          , CAPLOK ,'p'       ,'P'       },
    {'Q'          , CAPLOK ,'q'       ,'Q'       },
    {'R'          , CAPLOK ,'r'       ,'R'       },
    {'S'          , CAPLOK ,'s'       ,'S'       },
    {'T'          , CAPLOK ,'t'       ,'T'       },
    {'U'          , CAPLOK ,'u'       ,'U'       },
    {'V'          , CAPLOK ,'v'       ,'V'       },
    {'W'          , CAPLOK ,'w'       ,'W'       },
    {'X'          , CAPLOK ,'x'       ,'X'       },
    {'Y'          , CAPLOK ,'y'       ,'Y'       },
    {'Z'          , CAPLOK ,'z'       ,'Z'       },
    {VK_OEM_1     , 0      ,';'       ,':'       },
    {VK_OEM_2     , 0      ,'/'       ,'?'       },
    {VK_OEM_3     , 0      ,'`'       ,'~'       },
    {VK_OEM_7     , 0      ,0x27      ,'"'       },
    {VK_OEM_8     , 0      ,WCH_NONE  ,WCH_NONE  },
    {VK_OEM_COMMA , 0      ,','       ,'<'       },
    {VK_OEM_PERIOD, 0      ,'.'       ,'>'       },
    {VK_OEM_PLUS  , 0      ,'='       ,'+'       },
    {VK_TAB       , 0      ,'\t'      ,'\t'      },
    {VK_ADD       , 0      ,'+'       ,'+'       },
    {VK_DECIMAL   , 0      ,'.'       ,'.'       },
    {VK_DIVIDE    , 0      ,'/'       ,'/'       },
    {VK_MULTIPLY  , 0      ,'*'       ,'*'       },
    {VK_SUBTRACT  , 0      ,'-'       ,'-'       },
    {0            , 0      ,0         ,0         }
};

static ALLOC_SECTION_LDATA VK_TO_WCHARS3 aVkToWch3[] = {
    //                     |          |   SHIFT  |  CONTROL  |
    //                     |          |==========|===========|
    {VK_BACK      , 0      ,'\b'      ,'\b'      , 0x7f      },
    {VK_CANCEL    , 0      ,0x03      ,0x03      , 0x03      },
    {VK_ESCAPE    , 0      ,0x1b      ,0x1b      , 0x1b      },
    {VK_OEM_4     , 0      ,'['       ,'{'       , 0x1b      },
    {VK_OEM_5     , 0      ,'\\'      ,'|'       , 0x1c      },
    {VK_OEM_102   , 0      ,'\\'      ,'|'       , 0x1c      },
    {VK_OEM_6     , 0      ,']'       ,'}'       , 0x1d      },
    {VK_RETURN    , 0      ,'\r'      ,'\r'      , '\n'      },
    {VK_SPACE     , 0      ,' '       ,' '       , 0x20      },
    {0            , 0      ,0         ,0         , 0         }
};

static ALLOC_SECTION_LDATA VK_TO_WCHARS4 aVkToWch4[] = {
    //                     |          |   SHIFT  |  CONTROL  | SHFT+CTRL |
    //                     |          |==========|===========|===========|
    {'2'          , 0      ,'2'       ,'@'       , WCH_NONE  , 0x00      },
    {'6'          , 0      ,'6'       ,'^'       , WCH_NONE  , 0x1e      },
    {VK_OEM_MINUS , 0      ,'-'       ,'_'       , WCH_NONE  , 0x1f      },
    {0            , 0      ,0         ,0         , 0         , 0         }
};

// Put this last so that VkKeyScan interprets number characters
// as coming from the main section of the kbd (aVkToWch2 and
// aVkToWch4) before considering the numpad (aVkToWch1).

static ALLOC_SECTION_LDATA VK_TO_WCHARS1 aVkToWch1[] = {
    { VK_NUMPAD0   , 0      ,  '0'   },
    { VK_NUMPAD1   , 0      ,  '1'   },
    { VK_NUMPAD2   , 0      ,  '2'   },
    { VK_NUMPAD3   , 0      ,  '3'   },
    { VK_NUMPAD4   , 0      ,  '4'   },
    { VK_NUMPAD5   , 0      ,  '5'   },
    { VK_NUMPAD6   , 0      ,  '6'   },
    { VK_NUMPAD7   , 0      ,  '7'   },
    { VK_NUMPAD8   , 0      ,  '8'   },
    { VK_NUMPAD9   , 0      ,  '9'   },
    { 0            , 0      ,  '\0'  }   //null terminator
};

/***************************************************************************\
* aVkToWcharTable: table of pointers to Character Tables
*
* Describes the character tables and the order they should be searched.
*
* Note: the order determines the behavior of VkKeyScan() : this function
*       takes a character and attempts to find a Virtual Key and character-
*       modifier key combination that produces that character.  The table
*       containing the numeric keypad (aVkToWch1) must appear last so that
*       VkKeyScan('0') will be interpreted as one of keys from the main
*       section, not the numpad.  etc.
\***************************************************************************/

static ALLOC_SECTION_LDATA VK_TO_WCHAR_TABLE aVkToWcharTable[] = {
    {  (PVK_TO_WCHARS1)aVkToWch3, 3, sizeof(aVkToWch3[0]) },
    {  (PVK_TO_WCHARS1)aVkToWch4, 4, sizeof(aVkToWch4[0]) },
    {  (PVK_TO_WCHARS1)aVkToWch2, 2, sizeof(aVkToWch2[0]) },
    {  (PVK_TO_WCHARS1)aVkToWch1, 1, sizeof(aVkToWch1[0]) },  // must come last
    {                       NULL, 0, 0                    }
};

/***************************************************************************\
* aKeyNames[], aKeyNamesExt[]  - Scan Code -> Key Name tables
*
* For the GetKeyNameText() API function
*
* Tables for non-extended and extended (KBDEXT) keys.
* (Keys producing printable characters are named by the character itself)
\***************************************************************************/

static ALLOC_SECTION_LDATA VSC_LPWSTR aKeyNames[] = {
    0x01,    L"Esc",
    0x0e,    L"Backspace",
    0x0f,    L"Tab",
    0x1c,    L"Enter",
    0x1d,    L"Ctrl",
    0x2a,    L"Shift",
    0x36,    L"Right Shift",
    0x37,    L"Num *",
    0x38,    L"Alt",
    0x39,    L"Space",
    0x3a,    L"Caps Lock",
    0x3b,    L"F1",
    0x3c,    L"F2",
    0x3d,    L"F3",
    0x3e,    L"F4",
    0x3f,    L"F5",
    0x40,    L"F6",
    0x41,    L"F7",
    0x42,    L"F8",
    0x43,    L"F9",
    0x44,    L"F10",
    0x45,    L"Pause",
    0x46,    L"Scroll Lock",
    0x47,    L"Num 7",
    0x48,    L"Num 8",
    0x49,    L"Num 9",
    0x4a,    L"Num -",
    0x4b,    L"Num 4",
    0x4c,    L"Num 5",
    0x4d,    L"Num 6",
    0x4e,    L"Num +",
    0x4f,    L"Num 1",
    0x50,    L"Num 2",
    0x51,    L"Num 3",
    0x52,    L"Num 0",
    0x53,    L"Num Del",
    0x54,    L"Sys Req",
    0x57,    L"F11",
    0x58,    L"F12",
    0x7C,    L"F13",
    0x7D,    L"F14",
    0x7E,    L"F15",
    0x7F,    L"F16",
    0x80,    L"F17",
    0x81,    L"F18",
    0x82,    L"F19",
    0x83,    L"F20",
    0x84,    L"F21",
    0x85,    L"F22",
    0x86,    L"F23",
    0x87,    L"F24",
    0   ,    NULL
};

static ALLOC_SECTION_LDATA VSC_LPWSTR aKeyNamesExt[] = {
    0x1c,    L"Num Enter",
    0x1d,    L"Right Control",
    0x35,    L"Num /",
    0x37,    L"Prnt Scrn",
    0x38,    L"Right Alt",
    0x45,    L"Num Lock",
    0x46,    L"Break",
    0x47,    L"Home",
    0x48,    L"Up",
    0x49,    L"Page Up",
    0x4b,    L"Left",
    0x4d,    L"Right",
    0x4f,    L"End",
    0x50,    L"Down",
    0x51,    L"Page Down",
    0x52,    L"Insert",
    0x53,    L"Delete",
    0x5B,    L"Left Windows",
    0x5C,    L"Right Windows",
    0x5D,    L"Application",
    0xF1,    L"Hanja",
    0xF2,    L"Hangeul",
    0   ,    NULL
};

static ALLOC_SECTION_LDATA KBDTABLES KbdTables = {
    /*
     * Modifier keys
     */
    &CharModifiers,

    /*
     * Characters tables
     */
    aVkToWcharTable,

    /*
     * Diacritics  (none for US English)
     */
    NULL,

    /*
     * Names of Keys  (no dead keys)
     */
    aKeyNames,
    aKeyNamesExt,
    NULL,

    /*
     * Scan codes to Virtual Keys
     */
    ausVK,
    sizeof(ausVK) / sizeof(ausVK[0]),
    aE0VscToVk,
    aE1VscToVk,

    /*
     * No Locale-specific special processing
     */
    0,

    /*
     * No Ligatures
     */
    0, 0, NULL,

    /*
     * Type and subtype
     */
    KEYBOARD_TYPE_KOREA,
    MAKEWORD(MICROSOFT_KBD_101B_TYPE, NLSKBD_OEM_MICROSOFT),
};

PKBDTABLES KbdLayerDescriptor(VOID)
{
    return &KbdTables;
}

/***********************************************************************\
* VkToFuncTable_101b[]
*
\***********************************************************************/

static ALLOC_SECTION_LDATA VK_F VkToFuncTable_101b[] = {
    {
        VK_OEM_PLUS,           // Base Vk
        KBDNLS_TYPE_NORMAL,    // NLSFEProcType
        KBDNLS_INDEX_NORMAL,   // NLSFEProcCurrent
        0x0,                   // NLSFEProcSwitch
        {                      // NLSFEProcIndex
            {KBDNLS_SEND_BASE_VK,0},         // Base
            {KBDNLS_SEND_BASE_VK,0},         // Shift
            {KBDNLS_SEND_BASE_VK,0},         // Control
            {KBDNLS_SEND_BASE_VK,0},         // Shift+Control
            {KBDNLS_SEND_PARAM_VK,VK_JUNJA}, // Alt
            {KBDNLS_SEND_BASE_VK,0},         // Shift+Alt
            {KBDNLS_SEND_BASE_VK,0},         // Control+Alt
            {KBDNLS_SEND_BASE_VK,0}          // Shift+Control+Alt
        },
        {                           // NLSFEProcIndexAlt
            {KBDNLS_NULL,0},                 // Base
            {KBDNLS_NULL,0},                 // Shift
            {KBDNLS_NULL,0},                 // Control
            {KBDNLS_NULL,0},                 // Shift+Control
            {KBDNLS_NULL,0},                 // Alt
            {KBDNLS_NULL,0},                 // Shift+Alt
            {KBDNLS_NULL,0},                 // Control+Alt
            {KBDNLS_NULL,0}                  // Shift+Control+Alt
        }
    }
};

/***********************************************************************\
* KbdNlsTables
*
\***********************************************************************/

static ALLOC_SECTION_LDATA KBDNLSTABLES KbdNlsTables = {
    0,                      // OEM ID (0 = Microsoft)
    0,                      // Information
    1,                      // Number of VK_F entry
    VkToFuncTable_101b,     // Pointer to VK_F array
    0,                      // Number of MouseVk entry
    NULL                    // Pointer to MouseVk array
};

PKBDNLSTABLES KbdNlsLayerDescriptor(VOID)
{
    return &KbdNlsTables;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kbd\fe_kbds\kor\101a\sources.inc ===
!IF 0

Copyright (c) 1989-2000  Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


!ENDIF

MINORCOMP=kbd101a

!include ..\..\korea.inc

SOURCES_USED=..\sources.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kbd\fe_kbds\kor\101a\kbd101a.h ===
/****************************** Module Header ******************************\
* Module Name: kbd101.h
*
* Copyright (c) 1985-91, Microsoft Corporation
*
* Various defines for use by keyboard input code.
*
* History:
\***************************************************************************/

/*
 * kbd type should be controlled by cl command-line argument
 */
#define KBD_TYPE 10

/*
 * Include the basis of all keyboard table values
 */
#include "kbd.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kbd\fe_kbds\kor\101b\kbd101b.h ===
/****************************** Module Header ******************************\
* Module Name: kbd101.h
*
* Copyright (c) 1985-91, Microsoft Corporation
*
* Various defines for use by keyboard input code.
*
* History:
\***************************************************************************/

/*
 * kbd type should be controlled by cl command-line argument
 */
#define KBD_TYPE 11

/*
 * Include the basis of all keyboard table values
 */
#include "kbd.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kbd\fe_kbds\kor\101a\kbd101a.c ===
/***************************************************************************\
* Module Name: kbd101a.c (Type A)
*
* Copyright (c) 1985-92, Microsoft Corporation
*
* Keyboard Type A :  Hangeul Toggle : Right Alt
*                    Junja   Toggle : Left  Alt + '='
*                    Hanja   Toggle : Right Ctrl
\***************************************************************************/

#include <windows.h>
#include <ime.h>
#include "vkoem.h"
#include "kbd101a.h"

#if defined(_M_IA64)
#pragma section(".data")
#define ALLOC_SECTION_LDATA __declspec(allocate(".data"))
#else
#pragma data_seg(".data")
#define ALLOC_SECTION_LDATA
#endif

/***************************************************************************\
* ausVK[] - Virtual Scan Code to Virtual Key conversion table for 101
\***************************************************************************/

static ALLOC_SECTION_LDATA USHORT ausVK[] = {
    T00, T01, T02, T03, T04, T05, T06, T07,
    T08, T09, T0A, T0B, T0C,

    /*
     * '='/'+' key must have KBDSPECIAL bit set (NLS key)
     */
    T0D | KBDSPECIAL,

                                  T0E, T0F,
    T10, T11, T12, T13, T14, T15, T16, T17,
    T18, T19, T1A, T1B, T1C, T1D, T1E, T1F,
    T20, T21, T22, T23, T24, T25, T26, T27,
    T28, T29, T2A, T2B, T2C, T2D, T2E, T2F,
    T30, T31, T32, T33, T34, T35,

    /*
     * Right-hand Shift key must have KBDEXT bit set.
     */
    T36 | KBDEXT,

    /*
     * numpad_* + Shift/Alt -> SnapShot
     */
    T37 | KBDMULTIVK,

    T38, T39, T3A, T3B, T3C, T3D, T3E, T3F,
    T40, T41, T42, T43, T44,

    /*
     * NumLock Key:
     *     KBDEXT     - VK_NUMLOCK is an Extended key
     *     KBDMULTIVK - VK_NUMLOCK or VK_PAUSE (without or with CTRL)
     */
    T45 | KBDEXT | KBDMULTIVK,

    T46 | KBDMULTIVK,

    /*
     * Number Pad keys:
     *     KBDNUMPAD  - digits 0-9 and decimal point.
     *     KBDSPECIAL - require special processing by Windows
     */
    T47 | KBDNUMPAD | KBDSPECIAL,   // Numpad 7 (Home)
    T48 | KBDNUMPAD | KBDSPECIAL,   // Numpad 8 (Up),
    T49 | KBDNUMPAD | KBDSPECIAL,   // Numpad 9 (PgUp),
    T4A,
    T4B | KBDNUMPAD | KBDSPECIAL,   // Numpad 4 (Left),
    T4C | KBDNUMPAD | KBDSPECIAL,   // Numpad 5 (Clear),
    T4D | KBDNUMPAD | KBDSPECIAL,   // Numpad 6 (Right),
    T4E,
    T4F | KBDNUMPAD | KBDSPECIAL,   // Numpad 1 (End),
    T50 | KBDNUMPAD | KBDSPECIAL,   // Numpad 2 (Down),
    T51 | KBDNUMPAD | KBDSPECIAL,   // Numpad 3 (PgDn),
    T52 | KBDNUMPAD | KBDSPECIAL,   // Numpad 0 (Ins),
    T53 | KBDNUMPAD | KBDSPECIAL,   // Numpad . (Del),

    T54, T55, T56, T57, T58, T59, T5A, T5B,
    T5C, T5D, T5E, T5F, T60, T61, T62, T63,
    T64, T65, T66, T67, T68, T69, T6A, T6B,
    T6C, T6D, T6E, T6F, T70, T71, T72, T73,
    T74, T75, T76, T77, T78, T79, T7A, T7B,
    T7C, T7D, T7E, T7F
};

static ALLOC_SECTION_LDATA VSC_VK aE0VscToVk[] = {
        { 0x10, X10 | KBDEXT              },  // Speedracer: Previous Track
        { 0x19, X19 | KBDEXT              },  // Speedracer: Next Track
        { 0x1C, X1C | KBDEXT              },  // Numpad Enter
        { 0x1D, X1D | KBDEXT | KBDSPECIAL },  // RControl // Hanja NLS key
        { 0x20, X20 | KBDEXT              },  // Speedracer: Volume Mute
        { 0x21, X21 | KBDEXT              },  // Speedracer: Launch App 2
        { 0x22, X22 | KBDEXT              },  // Speedracer: Media Play/Pause
        { 0x24, X24 | KBDEXT              },  // Speedracer: Media Stop
        { 0x2E, X2E | KBDEXT              },  // Speedracer: Volume Down
        { 0x30, X30 | KBDEXT              },  // Speedracer: Volume Up
        { 0x32, X32 | KBDEXT              },  // Speedracer: Browser Home
        { 0x35, X35 | KBDEXT              },  // Numpad Divide
        { 0x37, X37 | KBDEXT              },  // Snapshot
        { 0x38, X38 | KBDEXT | KBDSPECIAL },  // RMenu    // Hangeul NLS key
        { 0x46, X46 | KBDEXT              },  // Break (Ctrl + Pause)
        { 0x47, X47 | KBDEXT              },  // Home
        { 0x48, X48 | KBDEXT              },  // Up
        { 0x49, X49 | KBDEXT              },  // Prior
        { 0x4B, X4B | KBDEXT              },  // Left
        { 0x4D, X4D | KBDEXT              },  // Right
        { 0x4F, X4F | KBDEXT              },  // End
        { 0x50, X50 | KBDEXT              },  // Down
        { 0x51, X51 | KBDEXT              },  // Next
        { 0x52, X52 | KBDEXT              },  // Insert
        { 0x53, X53 | KBDEXT              },  // Delete
        { 0x5B, X5B | KBDEXT              },  // Left Win
        { 0x5C, X5C | KBDEXT              },  // Right Win
        { 0x5D, X5D | KBDEXT              },  // Applications
        { 0x5F, X5F | KBDEXT              },  // Speedracer: Sleep
        { 0x65, X65 | KBDEXT              },  // Speedracer: Browser Search
        { 0x66, X66 | KBDEXT              },  // Speedracer: Browser Favorites
        { 0x67, X67 | KBDEXT              },  // Speedracer: Browser Refresh
        { 0x68, X68 | KBDEXT              },  // Speedracer: Browser Stop
        { 0x69, X69 | KBDEXT              },  // Speedracer: Browser Forward
        { 0x6A, X6A | KBDEXT              },  // Speedracer: Browser Back
        { 0x6B, X6B | KBDEXT              },  // Speedracer: Launch App 1
        { 0x6C, X6C | KBDEXT              },  // Speedracer: Launch Mail
        { 0x6D, X6D | KBDEXT              },  // Speedracer: Launch Media Selector
        { 0xF1, XF1 | KBDEXT | KBDSPECIAL },  // Hanja
        { 0xF2, XF2 | KBDEXT | KBDSPECIAL },  // Hangeul
        { 0,      0                       }
};

static ALLOC_SECTION_LDATA VSC_VK aE1VscToVk[] = {
        { 0x1D, Y1D                       },  // Pause
        { 0   ,   0                       }
};

/***************************************************************************\
* aVkToBits[]  - map Virtual Keys to Modifier Bits
*
* See kbd.h for a full description.
*
* US Keyboard has only three shifter keys:
*     SHIFT (L & R) affects alphabnumeric keys,
*     CTRL  (L & R) is used to generate control characters
*     ALT   (L & R) used for generating characters by number with numpad
\***************************************************************************/

static ALLOC_SECTION_LDATA VK_TO_BIT aVkToBits[] = {
    { VK_SHIFT,   KBDSHIFT },
    { VK_CONTROL, KBDCTRL  },
    { VK_MENU,    KBDALT   },
    { 0,          0        }
};

/***************************************************************************\
* aModification[]  - map character modifier bits to modification number
*
* See kbd.h for a full description.
*
\***************************************************************************/

static ALLOC_SECTION_LDATA MODIFIERS CharModifiers = {
    &aVkToBits[0],
    3,
    {
    //  Modification# //  Keys Pressed  : Explanation
    //  ============= // ============== : =============================
        0,            //                : unshifted characters
        1,            //          SHIFT : capitals, ~!@#$%^&*()_+{}:"<>? etc.
        2,            //     CTRL       : control characters
        3,            //     CTRL SHIFT :
                      // ALT            : invalid
                      // ALT      SHIFT : invalid
                      // ALT CTRL       : invalid
                      // ALT CTRL SHIFT : invalid
    }
};

/***************************************************************************\
*
* aVkToWch2[]  - Virtual Key to WCHAR translation for 2 shift states
* aVkToWch3[]  - Virtual Key to WCHAR translation for 3 shift states
* aVkToWch4[]  - Virtual Key to WCHAR translation for 4 shift states
*
* Table attributes: Unordered Scan, null-terminated
*
* Search this table for an entry with a matching Virtual Key to find the
* corresponding unshifted and shifted WCHAR characters.
*
* Reserved VirtualKey values (first column)
*     -1            - this line contains dead characters (diacritic)
*     0             - terminator
*
* Reserved Attribute values (second column)
*     CAPLOK        - CapsLock affects this key like Shift
*
* Reserved character values (third through last column)
*     WCH_NONE      - No character
*     WCH_DEAD      - Dead character (diacritic) value is in next line
*
\***************************************************************************/

static ALLOC_SECTION_LDATA VK_TO_WCHARS2 aVkToWch2[] = {
    {'0'          , 0      ,'0'       ,')'       },
    {'1'          , 0      ,'1'       ,'!'       },
    {'3'          , 0      ,'3'       ,'#'       },
    {'4'          , 0      ,'4'       ,'$'       },
    {'5'          , 0      ,'5'       ,'%'       },
    {'7'          , 0      ,'7'       ,'&'       },
    {'8'          , 0      ,'8'       ,'*'       },
    {'9'          , 0      ,'9'       ,'('       },
    {'A'          , CAPLOK ,'a'       ,'A'       },
    {'B'          , CAPLOK ,'b'       ,'B'       },
    {'C'          , CAPLOK ,'c'       ,'C'       },
    {'D'          , CAPLOK ,'d'       ,'D'       },
    {'E'          , CAPLOK ,'e'       ,'E'       },
    {'F'          , CAPLOK ,'f'       ,'F'       },
    {'G'          , CAPLOK ,'g'       ,'G'       },
    {'H'          , CAPLOK ,'h'       ,'H'       },
    {'I'          , CAPLOK ,'i'       ,'I'       },
    {'J'          , CAPLOK ,'j'       ,'J'       },
    {'K'          , CAPLOK ,'k'       ,'K'       },
    {'L'          , CAPLOK ,'l'       ,'L'       },
    {'M'          , CAPLOK ,'m'       ,'M'       },
    {'N'          , CAPLOK ,'n'       ,'N'       },
    {'O'          , CAPLOK ,'o'       ,'O'       },
    {'P'          , CAPLOK ,'p'       ,'P'       },
    {'Q'          , CAPLOK ,'q'       ,'Q'       },
    {'R'          , CAPLOK ,'r'       ,'R'       },
    {'S'          , CAPLOK ,'s'       ,'S'       },
    {'T'          , CAPLOK ,'t'       ,'T'       },
    {'U'          , CAPLOK ,'u'       ,'U'       },
    {'V'          , CAPLOK ,'v'       ,'V'       },
    {'W'          , CAPLOK ,'w'       ,'W'       },
    {'X'          , CAPLOK ,'x'       ,'X'       },
    {'Y'          , CAPLOK ,'y'       ,'Y'       },
    {'Z'          , CAPLOK ,'z'       ,'Z'       },
    {VK_OEM_1     , 0      ,';'       ,':'       },
    {VK_OEM_2     , 0      ,'/'       ,'?'       },
    {VK_OEM_3     , 0      ,'`'       ,'~'       },
    {VK_OEM_7     , 0      ,0x27      ,'"'       },
    {VK_OEM_8     , 0      ,WCH_NONE  ,WCH_NONE  },
    {VK_OEM_COMMA , 0      ,','       ,'<'       },
    {VK_OEM_PERIOD, 0      ,'.'       ,'>'       },
    {VK_OEM_PLUS  , 0      ,'='       ,'+'       },
    {VK_TAB       , 0      ,'\t'      ,'\t'      },
    {VK_ADD       , 0      ,'+'       ,'+'       },
    {VK_DECIMAL   , 0      ,'.'       ,'.'       },
    {VK_DIVIDE    , 0      ,'/'       ,'/'       },
    {VK_MULTIPLY  , 0      ,'*'       ,'*'       },
    {VK_SUBTRACT  , 0      ,'-'       ,'-'       },
    {0            , 0      ,0         ,0         }
};

static ALLOC_SECTION_LDATA VK_TO_WCHARS3 aVkToWch3[] = {
    //                     |          |   SHIFT  |  CONTROL  |
    //                     |          |==========|===========|
    {VK_BACK      , 0      ,'\b'      ,'\b'      , 0x7f      },
    {VK_CANCEL    , 0      ,0x03      ,0x03      , 0x03      },
    {VK_ESCAPE    , 0      ,0x1b      ,0x1b      , 0x1b      },
    {VK_OEM_4     , 0      ,'['       ,'{'       , 0x1b      },
    {VK_OEM_5     , 0      ,'\\'      ,'|'       , 0x1c      },
    {VK_OEM_102   , 0      ,'\\'      ,'|'       , 0x1c      },
    {VK_OEM_6     , 0      ,']'       ,'}'       , 0x1d      },
    {VK_RETURN    , 0      ,'\r'      ,'\r'      , '\n'      },
    {VK_SPACE     , 0      ,' '       ,' '       , 0x20      },
    {0            , 0      ,0         ,0         , 0         }
};

static ALLOC_SECTION_LDATA VK_TO_WCHARS4 aVkToWch4[] = {
    //                     |          |   SHIFT  |  CONTROL  | SHFT+CTRL |
    //                     |          |==========|===========|===========|
    {'2'          , 0      ,'2'       ,'@'       , WCH_NONE  , 0x00      },
    {'6'          , 0      ,'6'       ,'^'       , WCH_NONE  , 0x1e      },
    {VK_OEM_MINUS , 0      ,'-'       ,'_'       , WCH_NONE  , 0x1f      },
    {0            , 0      ,0         ,0         , 0         , 0         }
};

// Put this last so that VkKeyScan interprets number characters
// as coming from the main section of the kbd (aVkToWch2 and
// aVkToWch4) before considering the numpad (aVkToWch1).

static ALLOC_SECTION_LDATA VK_TO_WCHARS1 aVkToWch1[] = {
    { VK_NUMPAD0   , 0      ,  '0'   },
    { VK_NUMPAD1   , 0      ,  '1'   },
    { VK_NUMPAD2   , 0      ,  '2'   },
    { VK_NUMPAD3   , 0      ,  '3'   },
    { VK_NUMPAD4   , 0      ,  '4'   },
    { VK_NUMPAD5   , 0      ,  '5'   },
    { VK_NUMPAD6   , 0      ,  '6'   },
    { VK_NUMPAD7   , 0      ,  '7'   },
    { VK_NUMPAD8   , 0      ,  '8'   },
    { VK_NUMPAD9   , 0      ,  '9'   },
    { 0            , 0      ,  '\0'  }   //null terminator
};

/***************************************************************************\
* aVkToWcharTable: table of pointers to Character Tables
*
* Describes the character tables and the order they should be searched.
*
* Note: the order determines the behavior of VkKeyScan() : this function
*       takes a character and attempts to find a Virtual Key and character-
*       modifier key combination that produces that character.  The table
*       containing the numeric keypad (aVkToWch1) must appear last so that
*       VkKeyScan('0') will be interpreted as one of keys from the main
*       section, not the numpad.  etc.
\***************************************************************************/

static ALLOC_SECTION_LDATA VK_TO_WCHAR_TABLE aVkToWcharTable[] = {
    {  (PVK_TO_WCHARS1)aVkToWch3, 3, sizeof(aVkToWch3[0]) },
    {  (PVK_TO_WCHARS1)aVkToWch4, 4, sizeof(aVkToWch4[0]) },
    {  (PVK_TO_WCHARS1)aVkToWch2, 2, sizeof(aVkToWch2[0]) },
    {  (PVK_TO_WCHARS1)aVkToWch1, 1, sizeof(aVkToWch1[0]) },  // must come last
    {                       NULL, 0, 0                    }
};

/***************************************************************************\
* aKeyNames[], aKeyNamesExt[]  - Scan Code -> Key Name tables
*
* For the GetKeyNameText() API function
*
* Tables for non-extended and extended (KBDEXT) keys.
* (Keys producing printable characters are named by the character itself)
\***************************************************************************/

static ALLOC_SECTION_LDATA VSC_LPWSTR aKeyNames[] = {
    0x01,    L"Esc",
    0x0e,    L"Backspace",
    0x0f,    L"Tab",
    0x1c,    L"Enter",
    0x1d,    L"Ctrl",
    0x2a,    L"Shift",
    0x36,    L"Right Shift",
    0x37,    L"Num *",
    0x38,    L"Alt",
    0x39,    L"Space",
    0x3a,    L"Caps Lock",
    0x3b,    L"F1",
    0x3c,    L"F2",
    0x3d,    L"F3",
    0x3e,    L"F4",
    0x3f,    L"F5",
    0x40,    L"F6",
    0x41,    L"F7",
    0x42,    L"F8",
    0x43,    L"F9",
    0x44,    L"F10",
    0x45,    L"Pause",
    0x46,    L"Scroll Lock",
    0x47,    L"Num 7",
    0x48,    L"Num 8",
    0x49,    L"Num 9",
    0x4a,    L"Num -",
    0x4b,    L"Num 4",
    0x4c,    L"Num 5",
    0x4d,    L"Num 6",
    0x4e,    L"Num +",
    0x4f,    L"Num 1",
    0x50,    L"Num 2",
    0x51,    L"Num 3",
    0x52,    L"Num 0",
    0x53,    L"Num Del",
    0x54,    L"Sys Req",
    0x57,    L"F11",
    0x58,    L"F12",
    0x7C,    L"F13",
    0x7D,    L"F14",
    0x7E,    L"F15",
    0x7F,    L"F16",
    0x80,    L"F17",
    0x81,    L"F18",
    0x82,    L"F19",
    0x83,    L"F20",
    0x84,    L"F21",
    0x85,    L"F22",
    0x86,    L"F23",
    0x87,    L"F24",
    0   ,    NULL
};

static ALLOC_SECTION_LDATA VSC_LPWSTR aKeyNamesExt[] = {
    0x1c,    L"Num Enter",
    0x1d,    L"Right Control",
    0x35,    L"Num /",
    0x37,    L"Prnt Scrn",
    0x38,    L"Right Alt",
    0x45,    L"Num Lock",
    0x46,    L"Break",
    0x47,    L"Home",
    0x48,    L"Up",
    0x49,    L"Page Up",
    0x4b,    L"Left",
    0x4d,    L"Right",
    0x4f,    L"End",
    0x50,    L"Down",
    0x51,    L"Page Down",
    0x52,    L"Insert",
    0x53,    L"Delete",
    0x5B,    L"Left Windows",
    0x5C,    L"Right Windows",
    0x5D,    L"Application",
    0xF1,    L"Hanja",
    0xF2,    L"Hangeul",
    0   ,    NULL
};

ALLOC_SECTION_LDATA KBDTABLES KbdTables101a = {
    /*
     * Modifier keys
     */
    &CharModifiers,

    /*
     * Characters tables
     */
    aVkToWcharTable,

    /*
     * Diacritics  (none for US English)
     */
    NULL,

    /*
     * Names of Keys  (no dead keys)
     */
    aKeyNames,
    aKeyNamesExt,
    NULL,

    /*
     * Scan codes to Virtual Keys
     */
    ausVK,
    sizeof(ausVK) / sizeof(ausVK[0]),
    aE0VscToVk,
    aE1VscToVk,

    /*
     * No Locale-specific special processing
     */
    0,

    /*
     * No Ligatures
     */
    0, 0, NULL,

    /*
     * Type and subtype
     */
    KEYBOARD_TYPE_KOREA,
    MAKEWORD(MICROSOFT_KBD_101A_TYPE, NLSKBD_OEM_MICROSOFT),
};

PKBDTABLES KbdLayerDescriptor(VOID)
{
    return &KbdTables101a;
}

/***********************************************************************\
* VkToFuncTable_101a[]
*
\***********************************************************************/

static ALLOC_SECTION_LDATA VK_F VkToFuncTable_101a[] = {
    {
        VK_OEM_PLUS,                 // Base Vk
        KBDNLS_TYPE_NORMAL,          // NLSFEProcType
        KBDNLS_INDEX_NORMAL,         // NLSFEProcCurrent
        0x0,                         // NLSFEProcSwitch
        {                            // NLSFEProcIndex
            {KBDNLS_SEND_BASE_VK,0},         // Base
            {KBDNLS_SEND_BASE_VK,0},         // Shift
            {KBDNLS_SEND_BASE_VK,0},         // Control
            {KBDNLS_SEND_BASE_VK,0},         // Shift+Control
            {KBDNLS_SEND_PARAM_VK,VK_JUNJA}, // Alt
            {KBDNLS_SEND_BASE_VK,0},         // Shift+Alt
            {KBDNLS_SEND_BASE_VK,0},         // Control+Alt
            {KBDNLS_SEND_BASE_VK,0}          // Shift+Control+Alt
        },
        {                            // NLSFEProcIndexAlt
            {KBDNLS_NULL,0},                 // Base
            {KBDNLS_NULL,0},                 // Shift
            {KBDNLS_NULL,0},                 // Control
            {KBDNLS_NULL,0},                 // Shift+Control
            {KBDNLS_NULL,0},                 // Alt
            {KBDNLS_NULL,0},                 // Shift+Alt
            {KBDNLS_NULL,0},                 // Control+Alt
            {KBDNLS_NULL,0}                  // Shift+Control+Alt
        }
    }
};

/***********************************************************************\
* KbdNlsTables
*
\***********************************************************************/

ALLOC_SECTION_LDATA KBDNLSTABLES KbdNlsTables101a = {
    0,                      // OEM ID (0 = Microsoft)
    0,                      // Information
    1,                      // Number of VK_F entry
    VkToFuncTable_101a,     // Pointer to VK_F array
    0,                      // Number of MouseVk entry
    NULL                    // Pointer to MouseVk array
};

PKBDNLSTABLES KbdNlsLayerDescriptor(VOID)
{
    return &KbdNlsTables101a;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kbd\fe_kbds\kor\101c\kbd101c.h ===
/****************************** Module Header ******************************\
* Module Name: kbd101.h
*
* Copyright (c) 1985-91, Microsoft Corporation
*
* Various defines for use by keyboard input code.
*
* History:
\***************************************************************************/

/*
 * kbd type should be controlled by cl command-line argument
 */
#define KBD_TYPE 12

/*
 * Include the basis of all keyboard table values
 */
#include "kbd.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kbd\fe_kbds\kor\101c\kbd101c.c ===
/***************************************************************************\
* Module Name: kbd101c.c (Type C)
*
* Copyright (c) 1985-92, Microsoft Corporation
*
* Keyboard Type C :  Hangeul Toggle : Shift + ' '
*                    Junja   Toggle : Left  Alt + '='
*                    Hanja   Toggle : Control + ' '
\***************************************************************************/

#include <windows.h>
#include <ime.h>
#include "vkoem.h"
#include "kbd101c.h"

#if defined(_M_IA64)
#pragma section(".data")
#define ALLOC_SECTION_LDATA __declspec(allocate(".data"))
#else
#pragma data_seg(".data")
#define ALLOC_SECTION_LDATA
#endif

/***************************************************************************\
* ausVK[] - Virtual Scan Code to Virtual Key conversion table for 101
\***************************************************************************/

static ALLOC_SECTION_LDATA USHORT ausVK[] = {
    T00, T01, T02, T03, T04, T05, T06, T07,
    T08, T09, T0A, T0B, T0C,

    /*
     * '='/'+' key must have KBDSPECIAL bit set (NLS key)
     */
    T0D | KBDSPECIAL,

                                  T0E, T0F,
    T10, T11, T12, T13, T14, T15, T16, T17,
    T18, T19, T1A, T1B, T1C, T1D, T1E, T1F,
    T20, T21, T22, T23, T24, T25, T26, T27,
    T28, T29, T2A, T2B, T2C, T2D, T2E, T2F,
    T30, T31, T32, T33, T34, T35,

    /*
     * Right-hand Shift key must have KBDEXT bit set.
     */
    T36 | KBDEXT,

    /*
     * numpad_* + Shift/Alt -> SnapShot
     */
    T37 | KBDMULTIVK,

    T38,

    /*
     * ' ' key must have KBDSPECIAL bit set (NLS key)
     */
    T39 | KBDSPECIAL,

              T3A, T3B, T3C, T3D, T3E, T3F,
    T40, T41, T42, T43, T44,

    /*
     * NumLock Key:
     *     KBDEXT     - VK_NUMLOCK is an Extended key
     *     KBDMULTIVK - VK_NUMLOCK or VK_PAUSE (without or with CTRL)
     */
    T45 | KBDEXT | KBDMULTIVK,

    T46 | KBDMULTIVK,

    /*
     * Number Pad keys:
     *     KBDNUMPAD  - digits 0-9 and decimal point.
     *     KBDSPECIAL - require special processing by Windows
     */
    T47 | KBDNUMPAD | KBDSPECIAL,   // Numpad 7 (Home)
    T48 | KBDNUMPAD | KBDSPECIAL,   // Numpad 8 (Up),
    T49 | KBDNUMPAD | KBDSPECIAL,   // Numpad 9 (PgUp),
    T4A,
    T4B | KBDNUMPAD | KBDSPECIAL,   // Numpad 4 (Left),
    T4C | KBDNUMPAD | KBDSPECIAL,   // Numpad 5 (Clear),
    T4D | KBDNUMPAD | KBDSPECIAL,   // Numpad 6 (Right),
    T4E,
    T4F | KBDNUMPAD | KBDSPECIAL,   // Numpad 1 (End),
    T50 | KBDNUMPAD | KBDSPECIAL,   // Numpad 2 (Down),
    T51 | KBDNUMPAD | KBDSPECIAL,   // Numpad 3 (PgDn),
    T52 | KBDNUMPAD | KBDSPECIAL,   // Numpad 0 (Ins),
    T53 | KBDNUMPAD | KBDSPECIAL,   // Numpad . (Del),

    T54, T55, T56, T57, T58, T59, T5A, T5B,
    T5C, T5D, T5E, T5F, T60, T61, T62, T63,
    T64, T65, T66, T67, T68, T69, T6A, T6B,
    T6C, T6D, T6E, T6F, T70, T71, T72, T73,
    T74, T75, T76, T77, T78, T79, T7A, T7B,
    T7C, T7D, T7E, T7F

};

static ALLOC_SECTION_LDATA VSC_VK aE0VscToVk[] = {
        { 0x10, X10 | KBDEXT              },  // Speedracer: Previous Track
        { 0x19, X19 | KBDEXT              },  // Speedracer: Next Track
        { 0x1C, X1C | KBDEXT              },  // Numpad Enter
        { 0x1D, X1D | KBDEXT              },  // RControl
        { 0x20, X20 | KBDEXT              },  // Speedracer: Volume Mute
        { 0x21, X21 | KBDEXT              },  // Speedracer: Launch App 2
        { 0x22, X22 | KBDEXT              },  // Speedracer: Media Play/Pause
        { 0x24, X24 | KBDEXT              },  // Speedracer: Media Stop
        { 0x2E, X2E | KBDEXT              },  // Speedracer: Volume Down
        { 0x30, X30 | KBDEXT              },  // Speedracer: Volume Up
        { 0x32, X32 | KBDEXT              },  // Speedracer: Browser Home
        { 0x35, X35 | KBDEXT              },  // Numpad Divide
        { 0x37, X37 | KBDEXT              },  // Snapshot
        { 0x38, X38 | KBDEXT              },  // RMenu
        { 0x46, X46 | KBDEXT              },  // Break (Ctrl + Pause)
        { 0x47, X47 | KBDEXT              },  // Home
        { 0x48, X48 | KBDEXT              },  // Up
        { 0x49, X49 | KBDEXT              },  // Prior
        { 0x4B, X4B | KBDEXT              },  // Left
        { 0x4D, X4D | KBDEXT              },  // Right
        { 0x4F, X4F | KBDEXT              },  // End
        { 0x50, X50 | KBDEXT              },  // Down
        { 0x51, X51 | KBDEXT              },  // Next
        { 0x52, X52 | KBDEXT              },  // Insert
        { 0x53, X53 | KBDEXT              },  // Delete
        { 0x5B, X5B | KBDEXT              },  // Left Win
        { 0x5C, X5C | KBDEXT              },  // Right Win
        { 0x5D, X5D | KBDEXT              },  // Applications
        { 0x5F, X5F | KBDEXT              },  // Speedracer: Sleep
        { 0x65, X65 | KBDEXT              },  // Speedracer: Browser Search
        { 0x66, X66 | KBDEXT              },  // Speedracer: Browser Favorites
        { 0x67, X67 | KBDEXT              },  // Speedracer: Browser Refresh
        { 0x68, X68 | KBDEXT              },  // Speedracer: Browser Stop
        { 0x69, X69 | KBDEXT              },  // Speedracer: Browser Forward
        { 0x6A, X6A | KBDEXT              },  // Speedracer: Browser Back
        { 0x6B, X6B | KBDEXT              },  // Speedracer: Launch App 1
        { 0x6C, X6C | KBDEXT              },  // Speedracer: Launch Mail
        { 0x6D, X6D | KBDEXT              },  // Speedracer: Launch Media Selector
        { 0xF1, XF1 | KBDEXT | KBDSPECIAL },  // Hanja
        { 0xF2, XF2 | KBDEXT | KBDSPECIAL },  // Hangeul
        { 0,      0                       }
};

static ALLOC_SECTION_LDATA VSC_VK aE1VscToVk[] = {
        { 0x1D, Y1D                       },  // Pause
        { 0   ,   0                       }
};

/***************************************************************************\
* aVkToBits[]  - map Virtual Keys to Modifier Bits
*
* See kbd.h for a full description.
*
* US Keyboard has only three shifter keys:
*     SHIFT (L & R) affects alphabnumeric keys,
*     CTRL  (L & R) is used to generate control characters
*     ALT   (L & R) used for generating characters by number with numpad
\***************************************************************************/

static ALLOC_SECTION_LDATA VK_TO_BIT aVkToBits[] = {
    { VK_SHIFT,   KBDSHIFT },
    { VK_CONTROL, KBDCTRL  },
    { VK_MENU,    KBDALT   },
    { 0,          0        }
};

/***************************************************************************\
* aModification[]  - map character modifier bits to modification number
*
* See kbd.h for a full description.
*
\***************************************************************************/

static ALLOC_SECTION_LDATA MODIFIERS CharModifiers = {
    &aVkToBits[0],
    3,
    {
    //  Modification# //  Keys Pressed  : Explanation
    //  ============= // ============== : =============================
        0,            //                : unshifted characters
        1,            //          SHIFT : capitals, ~!@#$%^&*()_+{}:"<>? etc.
        2,            //     CTRL       : control characters
        3,            //     CTRL SHIFT :
                      // ALT            : invalid
                      // ALT      SHIFT : invalid
                      // ALT CTRL       : invalid
                      // ALT CTRL SHIFT : invalid
    }
};

/***************************************************************************\
*
* aVkToWch2[]  - Virtual Key to WCHAR translation for 2 shift states
* aVkToWch3[]  - Virtual Key to WCHAR translation for 3 shift states
* aVkToWch4[]  - Virtual Key to WCHAR translation for 4 shift states
*
* Table attributes: Unordered Scan, null-terminated
*
* Search this table for an entry with a matching Virtual Key to find the
* corresponding unshifted and shifted WCHAR characters.
*
* Reserved VirtualKey values (first column)
*     -1            - this line contains dead characters (diacritic)
*     0             - terminator
*
* Reserved Attribute values (second column)
*     CAPLOK        - CapsLock affects this key like Shift
*
* Reserved character values (third through last column)
*     WCH_NONE      - No character
*     WCH_DEAD      - Dead character (diacritic) value is in next line
*
\***************************************************************************/

static ALLOC_SECTION_LDATA VK_TO_WCHARS2 aVkToWch2[] = {
    {'0'          , 0      ,'0'       ,')'       },
    {'1'          , 0      ,'1'       ,'!'       },
    {'3'          , 0      ,'3'       ,'#'       },
    {'4'          , 0      ,'4'       ,'$'       },
    {'5'          , 0      ,'5'       ,'%'       },
    {'7'          , 0      ,'7'       ,'&'       },
    {'8'          , 0      ,'8'       ,'*'       },
    {'9'          , 0      ,'9'       ,'('       },
    {'A'          , CAPLOK ,'a'       ,'A'       },
    {'B'          , CAPLOK ,'b'       ,'B'       },
    {'C'          , CAPLOK ,'c'       ,'C'       },
    {'D'          , CAPLOK ,'d'       ,'D'       },
    {'E'          , CAPLOK ,'e'       ,'E'       },
    {'F'          , CAPLOK ,'f'       ,'F'       },
    {'G'          , CAPLOK ,'g'       ,'G'       },
    {'H'          , CAPLOK ,'h'       ,'H'       },
    {'I'          , CAPLOK ,'i'       ,'I'       },
    {'J'          , CAPLOK ,'j'       ,'J'       },
    {'K'          , CAPLOK ,'k'       ,'K'       },
    {'L'          , CAPLOK ,'l'       ,'L'       },
    {'M'          , CAPLOK ,'m'       ,'M'       },
    {'N'          , CAPLOK ,'n'       ,'N'       },
    {'O'          , CAPLOK ,'o'       ,'O'       },
    {'P'          , CAPLOK ,'p'       ,'P'       },
    {'Q'          , CAPLOK ,'q'       ,'Q'       },
    {'R'          , CAPLOK ,'r'       ,'R'       },
    {'S'          , CAPLOK ,'s'       ,'S'       },
    {'T'          , CAPLOK ,'t'       ,'T'       },
    {'U'          , CAPLOK ,'u'       ,'U'       },
    {'V'          , CAPLOK ,'v'       ,'V'       },
    {'W'          , CAPLOK ,'w'       ,'W'       },
    {'X'          , CAPLOK ,'x'       ,'X'       },
    {'Y'          , CAPLOK ,'y'       ,'Y'       },
    {'Z'          , CAPLOK ,'z'       ,'Z'       },
    {VK_OEM_1     , 0      ,';'       ,':'       },
    {VK_OEM_2     , 0      ,'/'       ,'?'       },
    {VK_OEM_3     , 0      ,'`'       ,'~'       },
    {VK_OEM_7     , 0      ,0x27      ,'"'       },
    {VK_OEM_8     , 0      ,WCH_NONE  ,WCH_NONE  },
    {VK_OEM_COMMA , 0      ,','       ,'<'       },
    {VK_OEM_PERIOD, 0      ,'.'       ,'>'       },
    {VK_OEM_PLUS  , 0      ,'='       ,'+'       },
    {VK_TAB       , 0      ,'\t'      ,'\t'      },
    {VK_ADD       , 0      ,'+'       ,'+'       },
    {VK_DECIMAL   , 0      ,'.'       ,'.'       },
    {VK_DIVIDE    , 0      ,'/'       ,'/'       },
    {VK_MULTIPLY  , 0      ,'*'       ,'*'       },
    {VK_SUBTRACT  , 0      ,'-'       ,'-'       },
    {0            , 0      ,0         ,0         }
};

static ALLOC_SECTION_LDATA VK_TO_WCHARS3 aVkToWch3[] = {
    //                     |          |   SHIFT  |  CONTROL  |
    //                     |          |==========|===========|
    {VK_BACK      , 0      ,'\b'      ,'\b'      , 0x7f      },
    {VK_CANCEL    , 0      ,0x03      ,0x03      , 0x03      },
    {VK_ESCAPE    , 0      ,0x1b      ,0x1b      , 0x1b      },
    {VK_OEM_4     , 0      ,'['       ,'{'       , 0x1b      },
    {VK_OEM_5     , 0      ,'\\'      ,'|'       , 0x1c      },
    {VK_OEM_102   , 0      ,'\\'      ,'|'       , 0x1c      },
    {VK_OEM_6     , 0      ,']'       ,'}'       , 0x1d      },
    {VK_RETURN    , 0      ,'\r'      ,'\r'      , '\n'      },
    {VK_SPACE     , 0      ,' '       ,' '       , 0x20      },
    {0            , 0      ,0         ,0         , 0         }
};

static ALLOC_SECTION_LDATA VK_TO_WCHARS4 aVkToWch4[] = {
    //                     |          |   SHIFT  |  CONTROL  | SHFT+CTRL |
    //                     |          |==========|===========|===========|
    {'2'          , 0      ,'2'       ,'@'       , WCH_NONE  , 0x00      },
    {'6'          , 0      ,'6'       ,'^'       , WCH_NONE  , 0x1e      },
    {VK_OEM_MINUS , 0      ,'-'       ,'_'       , WCH_NONE  , 0x1f      },
    {0            , 0      ,0         ,0         , 0         , 0         }
};

// Put this last so that VkKeyScan interprets number characters
// as coming from the main section of the kbd (aVkToWch2 and
// aVkToWch4) before considering the numpad (aVkToWch1).

static ALLOC_SECTION_LDATA VK_TO_WCHARS1 aVkToWch1[] = {
    { VK_NUMPAD0   , 0      ,  '0'   },
    { VK_NUMPAD1   , 0      ,  '1'   },
    { VK_NUMPAD2   , 0      ,  '2'   },
    { VK_NUMPAD3   , 0      ,  '3'   },
    { VK_NUMPAD4   , 0      ,  '4'   },
    { VK_NUMPAD5   , 0      ,  '5'   },
    { VK_NUMPAD6   , 0      ,  '6'   },
    { VK_NUMPAD7   , 0      ,  '7'   },
    { VK_NUMPAD8   , 0      ,  '8'   },
    { VK_NUMPAD9   , 0      ,  '9'   },
    { 0            , 0      ,  '\0'  }   //null terminator
};

/***************************************************************************\
* aVkToWcharTable: table of pointers to Character Tables
*
* Describes the character tables and the order they should be searched.
*
* Note: the order determines the behavior of VkKeyScan() : this function
*       takes a character and attempts to find a Virtual Key and character-
*       modifier key combination that produces that character.  The table
*       containing the numeric keypad (aVkToWch1) must appear last so that
*       VkKeyScan('0') will be interpreted as one of keys from the main
*       section, not the numpad.  etc.
\***************************************************************************/

static ALLOC_SECTION_LDATA VK_TO_WCHAR_TABLE aVkToWcharTable[] = {
    {  (PVK_TO_WCHARS1)aVkToWch3, 3, sizeof(aVkToWch3[0]) },
    {  (PVK_TO_WCHARS1)aVkToWch4, 4, sizeof(aVkToWch4[0]) },
    {  (PVK_TO_WCHARS1)aVkToWch2, 2, sizeof(aVkToWch2[0]) },
    {  (PVK_TO_WCHARS1)aVkToWch1, 1, sizeof(aVkToWch1[0]) },  // must come last
    {                       NULL, 0, 0                    }
};

/***************************************************************************\
* aKeyNames[], aKeyNamesExt[]  - Scan Code -> Key Name tables
*
* For the GetKeyNameText() API function
*
* Tables for non-extended and extended (KBDEXT) keys.
* (Keys producing printable characters are named by the character itself)
\***************************************************************************/

static ALLOC_SECTION_LDATA VSC_LPWSTR aKeyNames[] = {
    0x01,    L"Esc",
    0x0e,    L"Backspace",
    0x0f,    L"Tab",
    0x1c,    L"Enter",
    0x1d,    L"Ctrl",
    0x2a,    L"Shift",
    0x36,    L"Right Shift",
    0x37,    L"Num *",
    0x38,    L"Alt",
    0x39,    L"Space",
    0x3a,    L"Caps Lock",
    0x3b,    L"F1",
    0x3c,    L"F2",
    0x3d,    L"F3",
    0x3e,    L"F4",
    0x3f,    L"F5",
    0x40,    L"F6",
    0x41,    L"F7",
    0x42,    L"F8",
    0x43,    L"F9",
    0x44,    L"F10",
    0x45,    L"Pause",
    0x46,    L"Scroll Lock",
    0x47,    L"Num 7",
    0x48,    L"Num 8",
    0x49,    L"Num 9",
    0x4a,    L"Num -",
    0x4b,    L"Num 4",
    0x4c,    L"Num 5",
    0x4d,    L"Num 6",
    0x4e,    L"Num +",
    0x4f,    L"Num 1",
    0x50,    L"Num 2",
    0x51,    L"Num 3",
    0x52,    L"Num 0",
    0x53,    L"Num Del",
    0x54,    L"Sys Req",
    0x57,    L"F11",
    0x58,    L"F12",
    0x7C,    L"F13",
    0x7D,    L"F14",
    0x7E,    L"F15",
    0x7F,    L"F16",
    0x80,    L"F17",
    0x81,    L"F18",
    0x82,    L"F19",
    0x83,    L"F20",
    0x84,    L"F21",
    0x85,    L"F22",
    0x86,    L"F23",
    0x87,    L"F24",
    0   ,    NULL
};

static ALLOC_SECTION_LDATA VSC_LPWSTR aKeyNamesExt[] = {
    0x1c,    L"Num Enter",
    0x1d,    L"Right Control",
    0x35,    L"Num /",
    0x37,    L"Prnt Scrn",
    0x38,    L"Right Alt",
    0x45,    L"Num Lock",
    0x46,    L"Break",
    0x47,    L"Home",
    0x48,    L"Up",
    0x49,    L"Page Up",
    0x4b,    L"Left",
    0x4d,    L"Right",
    0x4f,    L"End",
    0x50,    L"Down",
    0x51,    L"Page Down",
    0x52,    L"Insert",
    0x53,    L"Delete",
    0x5B,    L"Left Windows",
    0x5C,    L"Right Windows",
    0x5D,    L"Application",
    0xF1,    L"Hanja",
    0xF2,    L"Hangeul",
    0   ,    NULL
};

static ALLOC_SECTION_LDATA KBDTABLES KbdTables = {
    /*
     * Modifier keys
     */
    &CharModifiers,

    /*
     * Characters tables
     */
    aVkToWcharTable,

    /*
     * Diacritics  (none for US English)
     */
    NULL,

    /*
     * Names of Keys  (no dead keys)
     */
    aKeyNames,
    aKeyNamesExt,
    NULL,

    /*
     * Scan codes to Virtual Keys
     */
    ausVK,
    sizeof(ausVK) / sizeof(ausVK[0]),
    aE0VscToVk,
    aE1VscToVk,

    /*
     * No Locale-specific special processing
     */
    0,

    /*
     * No Ligatures
     */
    0, 0, NULL,

    /*
     * Type and subtype
     */
    KEYBOARD_TYPE_KOREA,
    MAKEWORD(MICROSOFT_KBD_101C_TYPE, NLSKBD_OEM_MICROSOFT),
};

PKBDTABLES KbdLayerDescriptor(VOID)
{
    return &KbdTables;
}

/***********************************************************************\
* VkToFuncTable_101c[]
*
\***********************************************************************/

static ALLOC_SECTION_LDATA VK_F VkToFuncTable_101c[] = {
    {
        VK_OEM_PLUS,           // Base Vk
        KBDNLS_TYPE_NORMAL,    // NLSFEProcType
        KBDNLS_INDEX_NORMAL,   // NLSFEProcCurrent
        0x0,                   // NLSFEProcSwitch
        {                      // NLSFEProcIndex
            {KBDNLS_SEND_BASE_VK,0},         // Base
            {KBDNLS_SEND_BASE_VK,0},         // Shift
            {KBDNLS_SEND_BASE_VK,0},         // Control
            {KBDNLS_SEND_BASE_VK,0},         // Shift+Control
            {KBDNLS_SEND_PARAM_VK,VK_JUNJA}, // Alt
            {KBDNLS_SEND_BASE_VK,0},         // Shift+Alt
            {KBDNLS_SEND_BASE_VK,0},         // Control+Alt
            {KBDNLS_SEND_BASE_VK,0}          // Shift+Control+Alt
        },
        {                           // NLSFEProcIndexAlt
            {KBDNLS_NULL,0},                 // Base
            {KBDNLS_NULL,0},                 // Shift
            {KBDNLS_NULL,0},                 // Control
            {KBDNLS_NULL,0},                 // Shift+Control
            {KBDNLS_NULL,0},                 // Alt
            {KBDNLS_NULL,0},                 // Shift+Alt
            {KBDNLS_NULL,0},                 // Control+Alt
            {KBDNLS_NULL,0}                  // Shift+Control+Alt
        }
    },
    {
        VK_SPACE,              // Base Vk
        KBDNLS_TYPE_NORMAL,    // NLSFEProcType
        KBDNLS_INDEX_NORMAL,   // NLSFEProcCurrent
        0x0,                   // NLSFEProcSwitch
        {                      // NLSFEProcIndex
            {KBDNLS_SEND_BASE_VK,0},           // Base
            {KBDNLS_SEND_PARAM_VK,VK_HANGEUL}, // Shift
            {KBDNLS_SEND_PARAM_VK,VK_HANJA},   // Control
            {KBDNLS_SEND_BASE_VK,0},           // Shift+Control
            {KBDNLS_SEND_BASE_VK,0},           // Alt
            {KBDNLS_SEND_BASE_VK,0},           // Shift+Alt
            {KBDNLS_SEND_BASE_VK,0},           // Control+Alt
            {KBDNLS_SEND_BASE_VK,0}            // Shift+Control+Alt
        },
        {                           // NLSFEProcIndexAlt
            {KBDNLS_NULL,0},                   // Base
            {KBDNLS_NULL,0},                   // Shift
            {KBDNLS_NULL,0},                   // Control
            {KBDNLS_NULL,0},                   // Shift+Control
            {KBDNLS_NULL,0},                   // Alt
            {KBDNLS_NULL,0},                   // Shift+Alt
            {KBDNLS_NULL,0},                   // Control+Alt
            {KBDNLS_NULL,0}                    // Shift+Control+Alt
        }
    }
};

/***********************************************************************\
* KbdNlsTables
*
\***********************************************************************/

static ALLOC_SECTION_LDATA KBDNLSTABLES KbdNlsTables = {
    0,                      // OEM ID (0 = Microsoft)
    0,                      // Information
    2,                      // Number of VK_F entry
    VkToFuncTable_101c,     // Pointer to VK_F array
    0,                      // Number of MouseVk entry
    NULL                    // Pointer to MouseVk array
};

PKBDNLSTABLES KbdNlsLayerDescriptor(VOID)
{
    return &KbdNlsTables;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kbd\kbdus\daytona\makefile.inc ===
!INCLUDE ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kbd\fe_kbds\kor\103\kbd103.c ===
/***************************************************************************\
* Module Name: kbd103.c
*
* Copyright (c) 1985-92, Microsoft Corporation
*
* Keyboard Type * :  Hangeul Toggle : Hangeul Key
*                    Junja   Toggle : Left  Alt + '='
*                    Hanja   Toggle : Hanja Key
* History: 8/19/94 ported by MSCH bklee
\***************************************************************************/

#include <windows.h>
#include <ime.h>
#include "vkoem.h"
#include "kbd103.h"

#if defined(_M_IA64)
#pragma section(".data")
#define ALLOC_SECTION_LDATA __declspec(allocate(".data"))
#else
#pragma data_seg(".data")
#define ALLOC_SECTION_LDATA
#endif

/***************************************************************************\
* ausVK[] - Virtual Scan Code to Virtual Key conversion table for 103
\***************************************************************************/

static ALLOC_SECTION_LDATA USHORT ausVK[] = {
    T00, T01, T02, T03, T04, T05, T06, T07,
    T08, T09, T0A, T0B, T0C,

    /*
     * '='/'+' key must have KBDSPECIAL bit set (NLS key)
     */
    T0D | KBDSPECIAL,

                                  T0E, T0F,
    T10, T11, T12, T13, T14, T15, T16, T17,
    T18, T19, T1A, T1B, T1C, T1D, T1E, T1F,
    T20, T21, T22, T23, T24, T25, T26, T27,
    T28, T29, T2A, T2B, T2C, T2D, T2E, T2F,
    T30, T31, T32, T33, T34, T35,

    /*
     * Right-hand Shift key must have KBDEXT bit set.
     */
    T36 | KBDEXT,

    /*
     * numpad_* + Shift/Alt -> SnapShot
     */
    T37 | KBDMULTIVK,

    T38, T39, T3A, T3B, T3C, T3D, T3E, T3F,
    T40, T41, T42, T43, T44,

    /*
     * NumLock Key:
     *     KBDEXT     - VK_NUMLOCK is an Extended key
     *     KBDMULTIVK - VK_NUMLOCK or VK_PAUSE (without or with CTRL)
     */
    T45 | KBDEXT | KBDMULTIVK,

    T46 | KBDMULTIVK,

    /*
     * Number Pad keys:
     *     KBDNUMPAD  - digits 0-9 and decimal point.
     *     KBDSPECIAL - require special processing by Windows
     */
    T47 | KBDNUMPAD | KBDSPECIAL,   // Numpad 7 (Home)
    T48 | KBDNUMPAD | KBDSPECIAL,   // Numpad 8 (Up),
    T49 | KBDNUMPAD | KBDSPECIAL,   // Numpad 9 (PgUp),
    T4A,
    T4B | KBDNUMPAD | KBDSPECIAL,   // Numpad 4 (Left),
    T4C | KBDNUMPAD | KBDSPECIAL,   // Numpad 5 (Clear),
    T4D | KBDNUMPAD | KBDSPECIAL,   // Numpad 6 (Right),
    T4E,
    T4F | KBDNUMPAD | KBDSPECIAL,   // Numpad 1 (End),
    T50 | KBDNUMPAD | KBDSPECIAL,   // Numpad 2 (Down),
    T51 | KBDNUMPAD | KBDSPECIAL,   // Numpad 3 (PgDn),
    T52 | KBDNUMPAD | KBDSPECIAL,   // Numpad 0 (Ins),
    T53 | KBDNUMPAD | KBDSPECIAL,   // Numpad . (Del),

    T54, T55, T56, T57, T58, T59, T5A, T5B,
    T5C, T5D, T5E, T5F, T60, T61, T62, T63,
    T64, T65, T66, T67, T68, T69, T6A, T6B,
    T6C, T6D, T6E, T6F, T70, T71, T72, T73,
    T74, T75, T76, T77, T78, T79, T7A, T7B,
    T7C, T7D, T7E, T7F

};

static ALLOC_SECTION_LDATA VSC_VK aE0VscToVk[] = {
        { 0x10, X10 | KBDEXT              },  // Speedracer: Previous Track
        { 0x19, X19 | KBDEXT              },  // Speedracer: Next Track
        { 0x1C, X1C | KBDEXT              },  // Numpad Enter
        { 0x1D, X1D | KBDEXT              },  // RControl
        { 0x20, X20 | KBDEXT              },  // Speedracer: Volume Mute
        { 0x21, X21 | KBDEXT              },  // Speedracer: Launch App 2
        { 0x22, X22 | KBDEXT              },  // Speedracer: Media Play/Pause
        { 0x24, X24 | KBDEXT              },  // Speedracer: Media Stop
        { 0x2E, X2E | KBDEXT              },  // Speedracer: Volume Down
        { 0x30, X30 | KBDEXT              },  // Speedracer: Volume Up
        { 0x32, X32 | KBDEXT              },  // Speedracer: Browser Home
        { 0x35, X35 | KBDEXT              },  // Numpad Divide
        { 0x37, X37 | KBDEXT              },  // Snapshot
        { 0x38, X38 | KBDEXT              },  // RMenu
        { 0x46, X46 | KBDEXT              },  // Break (Ctrl + Pause)
        { 0x47, X47 | KBDEXT              },  // Home
        { 0x48, X48 | KBDEXT              },  // Up
        { 0x49, X49 | KBDEXT              },  // Prior
        { 0x4B, X4B | KBDEXT              },  // Left
        { 0x4D, X4D | KBDEXT              },  // Right
        { 0x4F, X4F | KBDEXT              },  // End
        { 0x50, X50 | KBDEXT              },  // Down
        { 0x51, X51 | KBDEXT              },  // Next
        { 0x52, X52 | KBDEXT              },  // Insert
        { 0x53, X53 | KBDEXT              },  // Delete
        { 0x5B, X5B | KBDEXT              },  // Left Win
        { 0x5C, X5C | KBDEXT              },  // Right Win
        { 0x5D, X5D | KBDEXT              },  // Applications
        { 0x5F, X5F | KBDEXT              },  // Speedracer: Sleep
        { 0x65, X65 | KBDEXT              },  // Speedracer: Browser Search
        { 0x66, X66 | KBDEXT              },  // Speedracer: Browser Favorites
        { 0x67, X67 | KBDEXT              },  // Speedracer: Browser Refresh
        { 0x68, X68 | KBDEXT              },  // Speedracer: Browser Stop
        { 0x69, X69 | KBDEXT              },  // Speedracer: Browser Forward
        { 0x6A, X6A | KBDEXT              },  // Speedracer: Browser Back
        { 0x6B, X6B | KBDEXT              },  // Speedracer: Launch App 1
        { 0x6C, X6C | KBDEXT              },  // Speedracer: Launch Mail
        { 0x6D, X6D | KBDEXT              },  // Speedracer: Launch Media Selector
        { 0xF1, XF1 | KBDEXT | KBDSPECIAL },  // Hanja
        { 0xF2, XF2 | KBDEXT | KBDSPECIAL },  // Hangeul
        { 0,      0                       }
};

static ALLOC_SECTION_LDATA VSC_VK aE1VscToVk[] = {
        { 0x1D, Y1D                       },  // Pause
        { 0   ,   0                       }
};

/***************************************************************************\
* aVkToBits[]  - map Virtual Keys to Modifier Bits
*
* See kbd.h for a full description.
*
* US Keyboard has only three shifter keys:
*     SHIFT (L & R) affects alphabnumeric keys,
*     CTRL  (L & R) is used to generate control characters
*     ALT   (L & R) used for generating characters by number with numpad
\***************************************************************************/

static ALLOC_SECTION_LDATA VK_TO_BIT aVkToBits[] = {
    { VK_SHIFT,   KBDSHIFT },
    { VK_CONTROL, KBDCTRL  },
    { VK_MENU,    KBDALT   },
    { 0,          0        }
};

/***************************************************************************\
* aModification[]  - map character modifier bits to modification number
*
* See kbd.h for a full description.
*
\***************************************************************************/

static ALLOC_SECTION_LDATA MODIFIERS CharModifiers = {
    &aVkToBits[0],
    3,
    {
    //  Modification# //  Keys Pressed  : Explanation
    //  ============= // ============== : =============================
        0,            //                : unshifted characters
        1,            //          SHIFT : capitals, ~!@#$%^&*()_+{}:"<>? etc.
        2,            //     CTRL       : control characters
        3,            //     CTRL SHIFT :
                      // ALT            : invalid
                      // ALT      SHIFT : invalid
                      // ALT CTRL       : invalid
                      // ALT CTRL SHIFT : invalid
    }
};

/***************************************************************************\
*
* aVkToWch2[]  - Virtual Key to WCHAR translation for 2 shift states
* aVkToWch3[]  - Virtual Key to WCHAR translation for 3 shift states
* aVkToWch4[]  - Virtual Key to WCHAR translation for 4 shift states
*
* Table attributes: Unordered Scan, null-terminated
*
* Search this table for an entry with a matching Virtual Key to find the
* corresponding unshifted and shifted WCHAR characters.
*
* Reserved VirtualKey values (first column)
*     -1            - this line contains dead characters (diacritic)
*     0             - terminator
*
* Reserved Attribute values (second column)
*     CAPLOK        - CapsLock affects this key like Shift
*
* Reserved character values (third through last column)
*     WCH_NONE      - No character
*     WCH_DEAD      - Dead character (diacritic) value is in next line
*
\***************************************************************************/

static ALLOC_SECTION_LDATA VK_TO_WCHARS2 aVkToWch2[] = {
    {'0'          , 0      ,'0'       ,')'       },
    {'1'          , 0      ,'1'       ,'!'       },
    {'3'          , 0      ,'3'       ,'#'       },
    {'4'          , 0      ,'4'       ,'$'       },
    {'5'          , 0      ,'5'       ,'%'       },
    {'7'          , 0      ,'7'       ,'&'       },
    {'8'          , 0      ,'8'       ,'*'       },
    {'9'          , 0      ,'9'       ,'('       },
    {'A'          , CAPLOK ,'a'       ,'A'       },
    {'B'          , CAPLOK ,'b'       ,'B'       },
    {'C'          , CAPLOK ,'c'       ,'C'       },
    {'D'          , CAPLOK ,'d'       ,'D'       },
    {'E'          , CAPLOK ,'e'       ,'E'       },
    {'F'          , CAPLOK ,'f'       ,'F'       },
    {'G'          , CAPLOK ,'g'       ,'G'       },
    {'H'          , CAPLOK ,'h'       ,'H'       },
    {'I'          , CAPLOK ,'i'       ,'I'       },
    {'J'          , CAPLOK ,'j'       ,'J'       },
    {'K'          , CAPLOK ,'k'       ,'K'       },
    {'L'          , CAPLOK ,'l'       ,'L'       },
    {'M'          , CAPLOK ,'m'       ,'M'       },
    {'N'          , CAPLOK ,'n'       ,'N'       },
    {'O'          , CAPLOK ,'o'       ,'O'       },
    {'P'          , CAPLOK ,'p'       ,'P'       },
    {'Q'          , CAPLOK ,'q'       ,'Q'       },
    {'R'          , CAPLOK ,'r'       ,'R'       },
    {'S'          , CAPLOK ,'s'       ,'S'       },
    {'T'          , CAPLOK ,'t'       ,'T'       },
    {'U'          , CAPLOK ,'u'       ,'U'       },
    {'V'          , CAPLOK ,'v'       ,'V'       },
    {'W'          , CAPLOK ,'w'       ,'W'       },
    {'X'          , CAPLOK ,'x'       ,'X'       },
    {'Y'          , CAPLOK ,'y'       ,'Y'       },
    {'Z'          , CAPLOK ,'z'       ,'Z'       },
    {VK_OEM_1     , 0      ,';'       ,':'       },
    {VK_OEM_2     , 0      ,'/'       ,'?'       },
    {VK_OEM_3     , 0      ,'`'       ,'~'       },
    {VK_OEM_7     , 0      ,0x27      ,'"'       },
    {VK_OEM_8     , 0      ,WCH_NONE  ,WCH_NONE  },
    {VK_OEM_COMMA , 0      ,','       ,'<'       },
    {VK_OEM_PERIOD, 0      ,'.'       ,'>'       },
    {VK_OEM_PLUS  , 0      ,'='       ,'+'       },
    {VK_TAB       , 0      ,'\t'      ,'\t'      },
    {VK_ADD       , 0      ,'+'       ,'+'       },
    {VK_DECIMAL   , 0      ,'.'       ,'.'       },
    {VK_DIVIDE    , 0      ,'/'       ,'/'       },
    {VK_MULTIPLY  , 0      ,'*'       ,'*'       },
    {VK_SUBTRACT  , 0      ,'-'       ,'-'       },
    {0            , 0      ,0         ,0         }
};

static ALLOC_SECTION_LDATA VK_TO_WCHARS3 aVkToWch3[] = {
    //                     |          |   SHIFT  |  CONTROL  |
    //                     |          |==========|===========|
    {VK_BACK      , 0      ,'\b'      ,'\b'      , 0x7f      },
    {VK_CANCEL    , 0      ,0x03      ,0x03      , 0x03      },
    {VK_ESCAPE    , 0      ,0x1b      ,0x1b      , 0x1b      },
    {VK_OEM_4     , 0      ,'['       ,'{'       , 0x1b      },
    {VK_OEM_5     , 0      ,'\\'      ,'|'       , 0x1c      },
    {VK_OEM_102   , 0      ,'\\'      ,'|'       , 0x1c      },
    {VK_OEM_6     , 0      ,']'       ,'}'       , 0x1d      },
    {VK_RETURN    , 0      ,'\r'      ,'\r'      , '\n'      },
    {VK_SPACE     , 0      ,' '       ,' '       , 0x20      },
    {0            , 0      ,0         ,0         , 0         }
};

static ALLOC_SECTION_LDATA VK_TO_WCHARS4 aVkToWch4[] = {
    //                     |          |   SHIFT  |  CONTROL  | SHFT+CTRL |
    //                     |          |==========|===========|===========|
    {'2'          , 0      ,'2'       ,'@'       , WCH_NONE  , 0x00      },
    {'6'          , 0      ,'6'       ,'^'       , WCH_NONE  , 0x1e      },
    {VK_OEM_MINUS , 0      ,'-'       ,'_'       , WCH_NONE  , 0x1f      },
    {0            , 0      ,0         ,0         , 0         , 0         }
};

// Put this last so that VkKeyScan interprets number characters
// as coming from the main section of the kbd (aVkToWch2 and
// aVkToWch4) before considering the numpad (aVkToWch1).

static ALLOC_SECTION_LDATA VK_TO_WCHARS1 aVkToWch1[] = {
    { VK_NUMPAD0   , 0      ,  '0'   },
    { VK_NUMPAD1   , 0      ,  '1'   },
    { VK_NUMPAD2   , 0      ,  '2'   },
    { VK_NUMPAD3   , 0      ,  '3'   },
    { VK_NUMPAD4   , 0      ,  '4'   },
    { VK_NUMPAD5   , 0      ,  '5'   },
    { VK_NUMPAD6   , 0      ,  '6'   },
    { VK_NUMPAD7   , 0      ,  '7'   },
    { VK_NUMPAD8   , 0      ,  '8'   },
    { VK_NUMPAD9   , 0      ,  '9'   },
    { 0            , 0      ,  '\0'  }   //null terminator
};

/***************************************************************************\
* aVkToWcharTable: table of pointers to Character Tables
*
* Describes the character tables and the order they should be searched.
*
* Note: the order determines the behavior of VkKeyScan() : this function
*       takes a character and attempts to find a Virtual Key and character-
*       modifier key combination that produces that character.  The table
*       containing the numeric keypad (aVkToWch1) must appear last so that
*       VkKeyScan('0') will be interpreted as one of keys from the main
*       section, not the numpad.  etc.
\***************************************************************************/

static ALLOC_SECTION_LDATA VK_TO_WCHAR_TABLE aVkToWcharTable[] = {
    {  (PVK_TO_WCHARS1)aVkToWch3, 3, sizeof(aVkToWch3[0]) },
    {  (PVK_TO_WCHARS1)aVkToWch4, 4, sizeof(aVkToWch4[0]) },
    {  (PVK_TO_WCHARS1)aVkToWch2, 2, sizeof(aVkToWch2[0]) },
    {  (PVK_TO_WCHARS1)aVkToWch1, 1, sizeof(aVkToWch1[0]) },  // must come last
    {                       NULL, 0, 0                    }
};

/***************************************************************************\
* aKeyNames[], aKeyNamesExt[]  - Scan Code -> Key Name tables
*
* For the GetKeyNameText() API function
*
* Tables for non-extended and extended (KBDEXT) keys.
* (Keys producing printable characters are named by the character itself)
\***************************************************************************/

static ALLOC_SECTION_LDATA VSC_LPWSTR aKeyNames[] = {
    0x01,    L"Esc",
    0x0e,    L"Backspace",
    0x0f,    L"Tab",
    0x1c,    L"Enter",
    0x1d,    L"Ctrl",
    0x2a,    L"Shift",
    0x36,    L"Right Shift",
    0x37,    L"Num *",
    0x38,    L"Alt",
    0x39,    L"Space",
    0x3a,    L"Caps Lock",
    0x3b,    L"F1",
    0x3c,    L"F2",
    0x3d,    L"F3",
    0x3e,    L"F4",
    0x3f,    L"F5",
    0x40,    L"F6",
    0x41,    L"F7",
    0x42,    L"F8",
    0x43,    L"F9",
    0x44,    L"F10",
    0x45,    L"Pause",
    0x46,    L"Scroll Lock",
    0x47,    L"Num 7",
    0x48,    L"Num 8",
    0x49,    L"Num 9",
    0x4a,    L"Num -",
    0x4b,    L"Num 4",
    0x4c,    L"Num 5",
    0x4d,    L"Num 6",
    0x4e,    L"Num +",
    0x4f,    L"Num 1",
    0x50,    L"Num 2",
    0x51,    L"Num 3",
    0x52,    L"Num 0",
    0x53,    L"Num Del",
    0x54,    L"Sys Req",
    0x57,    L"F11",
    0x58,    L"F12",
    0x7C,    L"F13",
    0x7D,    L"F14",
    0x7E,    L"F15",
    0x7F,    L"F16",
    0x80,    L"F17",
    0x81,    L"F18",
    0x82,    L"F19",
    0x83,    L"F20",
    0x84,    L"F21",
    0x85,    L"F22",
    0x86,    L"F23",
    0x87,    L"F24",
    0   ,    NULL
};

static ALLOC_SECTION_LDATA VSC_LPWSTR aKeyNamesExt[] = {
    0x1c,    L"Num Enter",
    0x1d,    L"Right Control",
    0x35,    L"Num /",
    0x37,    L"Prnt Scrn",
    0x38,    L"Right Alt",
    0x45,    L"Num Lock",
    0x46,    L"Break",
    0x47,    L"Home",
    0x48,    L"Up",
    0x49,    L"Page Up",
    0x4b,    L"Left",
    0x4d,    L"Right",
    0x4f,    L"End",
    0x50,    L"Down",
    0x51,    L"Page Down",
    0x52,    L"Insert",
    0x53,    L"Delete",
    0x5B,    L"Left Windows",
    0x5C,    L"Right Windows",
    0x5D,    L"Application",
    0xf1,    L"Hanja",
    0xf2,    L"Hangeul",
    0   ,    NULL
};

ALLOC_SECTION_LDATA KBDTABLES KbdTables103 = {
    /*
     * Modifier keys
     */
    &CharModifiers,

    /*
     * Characters tables
     */
    aVkToWcharTable,

    /*
     * Diacritics  (none for US English)
     */
    NULL,

    /*
     * Names of Keys  (no dead keys)
     */
    aKeyNames,
    aKeyNamesExt,
    NULL,

    /*
     * Scan codes to Virtual Keys
     */
    ausVK,
    sizeof(ausVK) / sizeof(ausVK[0]),
    aE0VscToVk,
    aE1VscToVk,

    /*
     * No Locale-specific special processing
     */
    0,

    /*
     * No Ligatures
     */
    0, 0, NULL,

    /*
     * Type and subtype
     */
    KEYBOARD_TYPE_KOREA,
    MAKEWORD(MICROSOFT_KBD_103_TYPE, NLSKBD_OEM_MICROSOFT),
};

PKBDTABLES KbdLayerDescriptor(VOID)
{
    return &KbdTables103;
}

/***********************************************************************\
* VkToFuncTable_103[]
*
\***********************************************************************/

static ALLOC_SECTION_LDATA VK_F VkToFuncTable_103[] = {
    {
        VK_OEM_PLUS,           // Base Vk
        KBDNLS_TYPE_NORMAL,    // NLSFEProcType
        KBDNLS_INDEX_NORMAL,   // NLSFEProcCurrent
        0x0,                   // NLSFEProcSwitch
        {                      // NLSFEProcIndex
            {KBDNLS_SEND_BASE_VK,0},         // Base
            {KBDNLS_SEND_BASE_VK,0},         // Shift
            {KBDNLS_SEND_BASE_VK,0},         // Control
            {KBDNLS_SEND_BASE_VK,0},         // Shift+Control
            {KBDNLS_SEND_PARAM_VK,VK_JUNJA}, // Alt
            {KBDNLS_SEND_BASE_VK,0},         // Shift+Alt
            {KBDNLS_SEND_BASE_VK,0},         // Control+Alt
            {KBDNLS_SEND_BASE_VK,0}          // Shift+Control+Alt
        },
        {                      // NLSFEProcIndexAlt
            {KBDNLS_NULL,0},                 // Base
            {KBDNLS_NULL,0},                 // Shift
            {KBDNLS_NULL,0},                 // Control
            {KBDNLS_NULL,0},                 // Shift+Control
            {KBDNLS_NULL,0},                 // Alt
            {KBDNLS_NULL,0},                 // Shift+Alt
            {KBDNLS_NULL,0},                 // Control+Alt
            {KBDNLS_NULL,0}                  // Shift+Control+Alt
        }
    }
};

/***********************************************************************\
* KbdNlsTables
*
\***********************************************************************/

ALLOC_SECTION_LDATA KBDNLSTABLES KbdNlsTables103 = {
    0,                      // OEM ID (0 = Microsoft)
    0,                      // Information
    1,                      // Number of VK_F entry
    VkToFuncTable_103,      // Pointer to VK_F array
    0,                      // Number of MouseVk entry
    NULL                    // Pointer to MouseVk array
};

PKBDNLSTABLES KbdNlsLayerDescriptor(VOID)
{
    return &KbdNlsTables103;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kbd\fe_kbds\kor\103\kbd103.h ===
/****************************** Module Header ******************************\
* Module Name: kbd101.h
*
* Copyright (c) 1985-91, Microsoft Corporation
*
* Various defines for use by keyboard input code.
*
* History:
\***************************************************************************/

/*
 * kbd type should be controlled by cl command-line argument
 */
#define KBD_TYPE 13

/*
 * Include the basis of all keyboard table values
 */
#include "kbd.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kbd\fe_kbds\kor\kor\multi.c ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windef.h>
#include <kbd.h>

BOOL EnumDynamicSwitchingLayouts(LPCWSTR lpwszBaseDll, PKBDTABLE_MULTI pKbdTableMulti);


BOOL KbdLayerMultiDescriptor(PKBDTABLE_MULTI pKbdTableMulti)
{
    /*
     * Firstly, try to get the setting from the registry.
     */
    if (EnumDynamicSwitchingLayouts(L"kbdjpn", pKbdTableMulti)) {
        return TRUE;
    }

    /*
     * If we failed to get the registry, set the default ones.
     */
    pKbdTableMulti->nTables = 2;

    wcscpy(pKbdTableMulti->aKbdTables[0].wszDllName, L"kbd101a.dll");
    pKbdTableMulti->aKbdTables[0].dwType = 4;
    pKbdTableMulti->aKbdTables[0].dwSubType = 0;

    wcscpy(pKbdTableMulti->aKbdTables[1].wszDllName, L"kbd103.dll");
    pKbdTableMulti->aKbdTables[1].dwType = 8;
    pKbdTableMulti->aKbdTables[1].dwSubType = 6;

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kbd\fe_kbds\kor\103\sources.inc ===
!IF 0

Copyright (c) 1989-2000  Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


!ENDIF

MINORCOMP=kbd103

!include ..\..\korea.inc

SOURCES_USED=..\sources.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kbd\fe_kbds\kor\101c\sources.inc ===
!IF 0

Copyright (c) 1989-2000  Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


!ENDIF

MINORCOMP=kbd101c

!include ..\..\korea.inc

SOURCES_USED=..\sources.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kbd\kbdus\wow6432\makefile.inc ===
!INCLUDE ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kbd\fe_kbds\kor\kor\sources.inc ===
!IF 0

Copyright (c) 1989-2000  Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


!ENDIF

MINORCOMP=kbdkor

!include ..\..\korea.inc

SOURCES_USED=..\sources.inc

TARGETLIBS=$(SDK_LIB_PATH)\ntdll.lib
LINKLIBS=..\..\..\common\$(ALT_PROJECT)\$(O)\fekbdcom.lib

#INCLUDES=$(INCLUDES);..\;..\inc;$(NTUSER_PATH)\inc;..\$(BASE_KEYBOARD_LAYOUT)


SOURCES=    kbdkor.rc \
            kbdkor.c \
            multi.c
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kbd\fe_kbds\kor\kor\kbdkor.c ===
/***************************************************************************\
* Module Name: kbdkor.c (Type A)
*
* Copyright (c) 1985-92, Microsoft Corporation
*
* Keyboard Type A :  Hangeul Toggle : Right Alt
*                    Junja   Toggle : Left  Alt + '='
*                    Hanja   Toggle : Right Ctrl
\***************************************************************************/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <windows.h>
#include <ime.h>
#include "vkoem.h"

#include "..\101a\kbd101a.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kdexts\genuedef.c ===
LIBRARY USEREXTS

;
; This file generates userexts.def or userkdx.def depending on the
; state of KERNEL.  This allows one file (exts.h) to
; be used to generate extension exports, entrypoints, and help text.
;
; To add an extension, add the appropriate entry to exts.h and matching
; code to userexts.c
;

EXPORTS
#define DOIT(name, helpstring1, helpstring2, validflags, argtype) name
#include "exts.h"

;--------------------------------------------------------------------
;
; these are the extension service functions provided for the debugger
;
;--------------------------------------------------------------------

    WinDbgExtensionDllInit
    ExtensionApiVersion
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kdexts\exts.h ===
/************************************************************************\
*
* MODULE: exts.h
*
* DESCRIPTION: macro driving file for use with stdexts.h and stdexts.c.
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* 6/9/1995 SanfordS Created
*
\************************************************************************/

DOIT(   help
        ,"help -v [cmd]                 - Displays this list or gives details on command\n"
        ,"  help      - To dump short help text on all commands.\n"
         "  help -v   - To dump long help text on all commands.\n"
         "  help cmd  - To dump long help on given command.\n"
        ,"v"
        ,CUSTOM)

#ifdef KERNEL
DOIT(   atom
        ,"atom                          - Dump atoms or atom tables\n"
        ,"atom -gl [atom]\n"
        ,"gl"
        ,STDARGS1)
#endif // KERNEL

#ifndef KERNEL
DOIT(   cbp
        ,"cbp                           - Breaks into the Debugger on CSRSS.EXE\n"
        ,""
        ,""
        ,NOARGS)
#endif

#ifndef KERNEL
DOIT(   dci
        ,"dci                           - Dump process client info.\n"
        ,""
        ,""
        ,NOARGS)
#endif //!KERNEL

#ifdef KERNEL
DOIT(   dcls
        ,"dcls [pcls]                   - Dump window class\n"
        ,"  dcls -v     - for verbose info.\n"
         "  dcls        - to list all classes.\n"
         "  dcls -p ppi - to list all classes for process ppi\n"
        ,"pv"
        ,STDARGS1)
#endif // KERNEL

#ifdef KERNEL
DOIT(   dcur
        ,"dcur -aivp [pcur]             - Dump cursors\n"
        ,"  dcur         - dump all cursor objects.\n"
         "  dcur -i <id> - dump cursors with given res id.\n"
         "  dcur -p <ppi>- dump cursors owned by ppi.\n"
         "  dcur -v      - dump in verbose format.\n"
         "  dcur -a      - expand dump of ACONs.\n"
         "  dcur <pcur>  - dump given cursor handle or pointer.\n"
        ,"aivp"
        ,STDARGS1)
#endif // KERNEL

#ifdef KERNEL
DOIT(   dde
        ,"dde -vr [conv|window|xact]    - Dump DDE tracking information\n"
        ,"  v - verbose\n"
         "  r - recurse to inner structures 1 level\n"
         "  window object - dumps all convs associated w/window\n"
         "  conv object - dumps conversation.\n"
         "  xact object - dumps transaction.\n"
        ,"vr"
        ,STDARGS1)
#endif // KERNEL

#ifdef KERNEL
DOIT(   ddl
        ,"ddl [pdesk]                   - Dump desktop log\n"
        ,"  ddl pdesk    - dumps the desktop log for pdesk.\n"
         "  ddl -v pdesk - dumps the desktop log for pdesk with stack traces.\n"
        ,"v"
        ,STDARGS1)
#endif // KERNEL

#ifdef OLD_DEBUGGER
#ifndef KERNEL
DOIT(   ddeml
        ,"ddeml -v [i<inst>] [t<type>] [hObj|pObj] - Dump DDEML state information\n"
        ,"  ddeml                     - lists all ddeml instances for this process\n"
         "  ddeml t<type>             - lists all ddeml objects of the given type\n"
         "  type 0 = All types\n"
         "  type 1 = Instances\n"
         "  type 2 = Server Conversations\n"
         "  type 3 = Client Conversations\n"
         "  type 4 = Conversation Lists\n"
         "  type 5 = Transactions\n"
         "  type 6 = Data Handles\n"
         "  type 7 = Zombie Conversations\n"
         "  ddeml i<instance> t<type> - restricts listing to one instance.\n"
         "  ddeml hObj                - dumps ddeml object\n"
         "  adding a 'v' simply turns lists into dumps.\n"
        ,"v"
        ,CUSTOM)
#endif //!KERNEL
#endif // OLD_DEBUGGER

#ifdef KERNEL
DOIT(   ddesk
        ,"ddesk -vhd <pdesk>            - Displays objects allocated in desktop\n"
        ,"  ddesk               - dumps list of desktops\n"
         "  ddesk address       - dumps simple statistics for desktop\n"
         "  ddesk -v address    - dumps verbose statistics for desktop\n"
         "  ddesk -h address    - dumps statistics for desktop plus handle list\n"
         "  ddesk -[vh]d ...    - dumps DLL name for hooks (slow)\n"
        ,"vhd"
        ,STDARGS1)
#endif // KERNEL

#ifdef KERNEL
DOIT(   ddk
        ,"ddk <pKbdTbl>                 - Dump deadkey table\n"
        ,"  ddk pKbdTbl   - Dump the deadkey table at pKbdTbl\n"
        ,""
        ,STDARGS1)
#endif // KERNEL

DOIT(   df
        ,"df [flags] | [-p pid] | [-l]        - Displays or sets debug flags\n"
        ,"  df            - display debug flags\n"
         "  df [flags]  - enter new flags in format <Detail><Print><Prompt> \n"
         "      <Detail>    = [0-3] Print File/Line = 1, Hide PID/Component = 2\n"
         "      <Print>     = [0-7] Errors = 1, Warnings = 2, Verbose = 4\n"
         "      <Prompt>    = [0-7] Errors = 1, Warnings = 2, Verbose = 4\n"
         "    The default is 031\n"
         "  df -p pid   - shows rips only for this pid or 0 for all\n"
         "  df -l       - sets the flags for only this process [userexts only]\n"
        ,"px"
        ,CUSTOM)

DOIT(   dhe
        ,"dhe [pointer|handle] | [-t[o[p]] type [pti/ppi]] - Dump handle entry(ies)\n"
        ,"  dhe            - dumps all handle entrys\n"
         "      -t dumps of all handles of the given type\n"
         "      -o all handles owned by pti/ppi\n"
         "      -op all handles owned by ppi or any thread in this process\n"
        ,"orpt"
        ,STDARGS2)

#ifdef KERNEL
DOIT(   dhard
        ,"dhard                         - Dump hard error list\n"
        ,""
        ,""
        ,NOARGS)
#endif //KERNEL

#ifdef KERNEL
DOIT(   dhid
        ,"dhid [-pv] [ppi]              - Dump HID info\n"
        ,"  dhid           - dumps global HID information\n"
         "  dhid -p        - dumps global HID information and process requests\n"
         "  dhid -p ppi    - dumps global HID info and proc requests of ppi (faster)\n"
         "  dhid -v        - verbose (can be combined with -p)\n"
        ,"pv"
        ,STDARGS1)

#endif

#ifdef KERNEL
DOIT(   dhk
        ,"dhk -ag[d] [pti]              - Dump hooks\n"
        ,"  dhk            - dumps local hooks on the foreground thread\n"
         "  dhk -g         - dumps global hooks\n"
         "  dhk pti        - dumps local hooks on THREADINFO at pti\n"
         "  dhk -g pti     - dumps global hooks and local hooks on THREADINFO at pti\n"
         "  dhk -a         - dumps local hooks for all threads\n"
         "  dhk -ag        - dumps global hooks and local hooks for all threads\n"
         "  dhk -[ag]d ... - dumps DLL name (slow)\n"
         ,"gad"
         ,STDARGS1)
#endif

#ifdef KERNEL
DOIT(   dhot
        ,"dhot                          - Dump registered hotkeys\n"
        ,"  dhot            - dumps all registered hotkeys\n"
         "  dhot photkey    - dumps HOTKEY photkey\n"
         "  dhot -r photkey - dumps all registered hotkeys after/including photkey"
        ,"r"
        ,STDARGS1)
#endif

#ifdef KERNEL
DOIT(   dhnr
        ,"dhnr                          - Dump HID notification record\n"
        ,"  dhnr [-vn]              - dumps all notification record (-n for pathname)\n"
         "  dhnr iseq               - dumps iseq notification record\n"
         "  dhnr -p[vn] <ptr>       - dumps notification record at addres <ptr>\n"
         "  dhnr -d[vnm] <pDevInfo> - dumps records of pDevInfo (-m to match pathname)\n"
        ,"pvndm"
        ,STDARGS1)
#endif

#ifdef KERNEL
DOIT(   dhs
        ,"dhs -vpty [id|type]           - Dump handle table statistics\n"
        ,"  dhs           - dumps simple statistics for whole table\n"
         "  dhs -t id     - dumps simple statistics for objects created by thread id\n"
         "  dhs -p id     - dumps simple statistics for objects created by process id\n"
         "  dhs -v        - dumps verbose statistics\n"
         "  dhs -y type   - dumps statistics for objects of type.\n"
        ,"tpvy"
        ,STDARGS1)
#endif

#ifdef KERNEL
DOIT(   di
        ,"di                            - Displays USER input processing globals.\n"
        ,""
        ,""
        ,NOARGS)
#endif // KERNEL

DOIT(   dimc
        ,"dimc [-hrvus] -[wci] [imc|wnd,etc.] - Dump Input Context\n"
        ,"  dimc [opts] <himc|pimc>      - dumps kernel side imc\n"
         "  dimc [opts] -w wnd           - dumps kernel side imc of wnd\n"
         "  dimc [opts] -c <pClientImc>     - dumps client side imc\n"
         "  dimc [opts] -i <pInputContext>  - dumps inputcontext\n"
         "       -h                      - show open, conversion, sentence mode and handles\n"
         "       -d                      - show hCompStr, hCanInfo etc (includes -h).\n"
         "       -r                      - recurse pImeModeSaver\n"
         "       -v                      - verbose\n"
         "       -u                      - assume UNICODE (use with -i)\n"
         "       -s                      - show relatively raw Composition String\n"
         "       -a                      - all (except -v)\n"
        ,"wcihdrvusa"
        ,STDARGS1)


#ifdef KERNEL
DOIT(   dimk
        ,"dimk [pImeHotKeyObj]          - Dump IME Hotkeys\n"
        ,""
        ,""
        ,STDARGS1)
#endif

#ifdef OLD_DEBUGGER
#ifndef KERNEL
DOIT(   dimedpi
        ,""
        ,"  dimedpi          - Dump all IMEDPI\n"
         "  dimedpi <addr>   - Dump IMEDPI at <addr>\n"
         "  dimedpi -v       - Dump with !dso format\n"
         "  dimedpi -i       - Dump ImeInfo\n"
        ,"vi"
        ,STDARGS1)
#endif // !KERNEL
#endif  // OLD_DEBUGGER

#ifdef KERNEL
DOIT(   dinp
        ,"dinp -v [pDeviceInfo]         - Dump input diagnostics\n"
        ,"  dinp <addr>    - Complete DeviceInfo struct at <addr>\n"
         "  dinp           - Short summary of all input devices\n"
         "  dinp -i <addr> - Dump input records for DeviceInfo struct at <addr>\n"
         "  dinp -v        - Dump complete DeviceInfo for all devices\n"
        ,"iv"
        ,STDARGS1)

DOIT(   _dinp
        ,"\0_dinp -v [pDeviceInfo]         - Dump input diagnostics\n"
        ,"  dinp <addr>    - Complete DeviceInfo struct at <addr>\n"
         "  dinp           - Short summary of all input devices\n"
         "  dinp -i <addr> - Dump input records for DeviceInfo struct at <addr>\n"
         "  dinp -v        - Dump complete DeviceInfo for all devices\n"
        ,"iv"
        ,STDARGS1)
#endif

#ifdef KERNEL
DOIT(   dkl
        ,"dkl -akv <pkl>                - Dump keyboard layout structures\n"
        ,"  dkl [-v] pkl    - Dump the keyboard layout structure at pkl\n"
         "  dkl -a[v] [pkl] - Dump all keyboard layout structures beginning with pkl\n"
         "  dkl -k          - Dump pklActive for all threads\n"
        ,"akv"
        ,STDARGS1)
#endif


DOIT(   _disi
        ,""
        ,"\0_disi <pinput>                 - Dump event injection union\n"
         ""
        ,""
        ,STDARGS1)

DOIT(   _ddlgt
        ,""
        ,"ddlgt <pdlgTemplate>          - Dump dialog template\n"
         "  ddlgt -v <pdlgTemplate>     - verbose\n"
         "  ddlgt -r <pdlgTemplate>     - print dialog items\n"
        ,"vr"
        ,STDARGS1)


DOIT(   dll
        ,"dll [*]addr [l#] [b#] [o#] [c#] [t[addr]] - Dump linked list (can Ctrl-C)\n"
        ,"  dll addr    - dumps list starting at addr 8 DWORDs each structure,\n"
         "                assumes link is first DWORD, w/NULL termination.\n"
         "  dll *addr   - same except starts at *addr\n"
         "  dll         - dumps next group of structures w/same options\n"
         "  \nOptions:\n"
         "  dll addr l3 - dumps 3 DWORDs per structure (default 8)\n"
         "  dll addr b2 - starts dump 2 DWORDs back - for LIST_ENTRYs (default 0)\n"
         "  dll addr o4 - next link is 4 DWORDs from top of structure (default 0)\n"
         "  dll addr c5 - dumps 5 structures only (defaults to 25)\n"
         "  dll addr l3 b2 o4 c5 - combines the option of the four previous lines\n"
         "  dll addr t  - counts (not dumps) items in list, tests for loop\n"
         "  dll addr t<addr>  - as above, halts if item at <addr> is found\n"
         "  dll addr t c5000  - as above, but limit c5000 (t default is c100000)\n"
        ,""
        ,CUSTOM)

#ifdef KERNEL
DOIT(   dlr
        ,"dlr -lsc <pointer|handle>          - Displays assignment locks for object\n"
        ,"  dlr <pointer|handle>    - dumps lock record\n"
         "  dlr -l                  - dump current lock record flags\n"
         "  dlr -s <hex>            - set lock record flag\n"
         "  dlr -c <hex>            - clear lock record flag\n"
         "     flag 0 is to record simple locks\n"
        ,"lcs"
        ,CUSTOM)
#endif //KERNEL

DOIT(   dm
        ,"dm -vris <menu|window>        - Dumps a menu\n"
        ,"  -v   - Verbose information mode\n"
         "  -r   - Recurse through sub-menus\n"
         "  -i   - Ignore items in the menu\n"
         "  -s   - dump a window's System menu\n"
        ,"virs"
        ,STDARGS1)

DOIT(   dmon
        ,"dmon <pMonitor>               - Dump MONITOR\n"
        ,"  dmon <pMonitor> - dump MONITOR at address\n"
        ,""
        ,STDARGS1)

#ifdef KERNEL
DOIT(   dmq
        ,"dmq [-act] [pq]               - Messages in queues\n"
        ,"  dmq [pq]     - lists messages in queue specified (default gpqForeground)\n"
         "  dmq -a       - lists messages in all queues\n"
         "  dmq -c [pq]  - counts messages in pq or all queues\n"
         "  dmq -t <pti> - dump messages in pti\n"
        ,"act"
        ,STDARGS1)
#endif

#ifdef KERNEL
DOIT(   dms
        ,"dms <MenuState>               - Dumps a pMenuState\n"
        ,""
        ,""
        ,STDARGS1)
#endif // KERNEL

#ifdef KERNEL
DOIT(   dp
        ,"dp -vcpt  [id]                - Displays simple process information\n"
        ,"  dp            - dumps simple process info of all W32 processes\n"
         "  dp -v         - verbose output\n"
         "  dp id/pep     - dumps process with given id or PEPROCESS pointer\n"
         "  dp -p ppi     - takes a ppi instead of a process id/pep\n"
         "  dp -c         - dumps current process\n"
         "  dp -t         - dumps threads for given process.\n"
        ,"vpct"
        ,STDARGS1)
#endif
#ifdef OLD_DEBUGGER

#ifndef KERNEL
DOIT(   dped
        ,"dped <ped>                    - Dump PEDitControl structure\n"
        ,""
        ,""
        ,STDARGS1)
#endif //!KERNEL
#endif // OLD_DEBUGGER

#ifdef KERNEL
DOIT(   dpi
        ,"dpi [ppi]                     - Displays PROCESSINFO structure specified\n"
        ,"  dpi -c            - dumps PROCESSINFO for current process\n"
         "  dpi -p <eprocess> - dumps PROCESSINFO for <eprocess>\n"
         "  dpi address       - dumps PROCESSINFO structure at address\n"
         "  dpi               - dumps all PROCESSINFO structures\n"
        ,"cp"
        ,STDARGS1)
#endif // KERNEL

#ifdef KERNEL
DOIT(   dpm
        ,"dpm <ppopupmenu>              - Dumps a popupmenu\n"
        ,""
        ,""
        ,STDARGS1)
#endif // KERNEL

#ifdef KERNEL
DOIT(   dq
        ,"dq -t [pq]                    - Displays Q structure specified\n"
        ,"  dq address    - dumps queue structure at address\n"
         "  dq -t address - dumps queue structure at address plus THREADINFO\n"
         "  dq -a         - dumps all queues\n"
         "  dq            - dumps gpqForeground\n"
        ,"at"
        ,STDARGS1)
#endif // KERNEL

DOIT(   dsi
        ,"dsi [-bchmopvw]               - Displays SERVERINFO struct\n"
        ,"dsi -b    - adds mpFnid_serverCBWndProc info.\n"
         "dsi -c    - adds aszSysColor info.\n"
         "dsi -h    - adds SHAREDINFO info.\n"
         "dsi -m    - adds system metrics data.\n"
         "dsi -o    - adds oemInfo info.\n"
         "dsi -p    - adds mpFnidPfn info.\n"
         "dsi -v    - verbose shows rarely needed fields.\n"
         "dsi -w    - adds aStoCidPfn info.\n"
        ,"bchjmopvw"
        ,STDARGS0)


#ifdef KERNEL
DOIT(   dsms
        ,"dsms -vl [psms]               - Displays SMS (SendMessage structure) specified\n"
        ,"  dsms           - dumps all send message structures\n"
         "  dsms -c        - counts messages, doesn't display any\n"
         "  dsms -v        - dumps all verbose\n"
         "  dsms -w        - dumps a bit verbose info\n"
         "  dsms -m msg    - dumps all sms with message == msg\n"
         "  dsms address   - dumps specific sms\n"
         "  dsms -v address- dumps verbose\n"
         "  dsms -r pti    - dumps sms with receiver == pti\n"
         "  dsms -s pti    - dumps sms with sender == pti\n"
//         "  dsms -l address- dumps SendList of sms\n"
        ,"clmvsrw"
        ,STDARGS1)
#endif // KERNEL

#ifdef KERNEL
DOIT(   dt
        ,"dt -gvcp [id]                 - Displays simple thread information\n"
        ,"  dt            - dumps simple thread info of all window threads\n"
         "  dt -c         - dumps current thread\n"
         "  dt -g         - dump GUI threads only\n"
         "  dt id/pet     - dumps thread with given id or PETHREAD pointer\n"
         "  dt -p pti     - takes a pti instead of a thread id/pet\n"
         "  dt -s [...]   - displays wait state\n"
         "  dt -v         - verbose output\n"
        ,"cgpsv"
        ,STDARGS1)
#endif

#ifdef KERNEL
DOIT(   dtdb
        ,"dtdb [ptdb]                   - Dump Task Database\n"
        ,"  dtdb <ptdb>   - dumps given ptdb.\n"
         "  dtdb          - dumps all dtdbs.\n"
        ,""
        ,STDARGS1)
#endif // KERNEL

#ifdef KERNEL
DOIT(   dti
        ,"dti [pti]                     - Displays THREADINFO structure\n"
        ,"  dti            - dumps all THREADINFO structures\n"
         "  dti -f         - dumps THREADINFO structure of foreground thread\n"
         "  dti address    - dumps THREADINFO structure at address\n"
         "  dti -c         - dumps THREADINFO structure of current thread\n"
        ,"cf"
        ,STDARGS1)
#endif // KERNEL

#ifdef KERNEL
DOIT(   dtl
        ,"dtl [-t] [pointer|handle]     - Displays thread locks\n"
        ,"dtl pObj      - dump thread locks for object/pool/kernel-object\n"
         "dtl -t pti    - dump thread locks for thread\n"
         "dtl           - dump all thread locks\n"
        ,"t"
        ,STDARGS1)
#endif //KERNEL

#ifdef KERNEL
DOIT(   dtmr
        ,"dtmr [ptmr]                   - Dumps timer structure.\n"
        ,"  dtmr <ptmr> - dump timer.\n"
         "  dtmr -i <tmrid> - dump timer with id <tmrid>.\n"
         "  dtmr        - dump all timers.\n"
        ,"i"
        ,STDARGS1)
#endif // KERNEL

#ifdef OLD_DEBUGGER
DOIT(   du
        ,"du [pointer|handle]           - Generic object dumping routine\n"
        ,"  Attempts to dump the object appropriately.\n"
         "  If no object is given - WARNING - ALL objects are dumped.\n"
        ,""
        ,STDARGS1)
#endif // OLD_DEBUGGER

#ifdef KERNEL
DOIT(   dupm
        ,"dupm                          - User Preference Bitmask\n"
        ,""
        ,""
        ,NOARGS)
#endif //KERNEL

#ifdef OLD_DEBUGGER
#ifdef KERNEL
DOIT(   dumphmgr
        ,"dumphmgr [-s]                 - Dumps object allocation counts (dbg only)\n"
        ,""
        ,"s"
        ,STDARGS0)
#endif //KERNEL
#endif // OLD_DEBUGGER

DOIT(   dw
        ,"dw -aefhvsprwoz [hwnd/pwnd]   - Displays information on windows in system\n"
        ,
         "  dw hwnd/pwnd  - dumps simple window info for window at pwnd\n"
         "  dw            - dumps simple window info for all top level windows of current\n"
         "                  desktop.\n"
         "  dw -v [pwnd]  - dumps verbose window info\n"
         "  dw -a         - added to any of the other commands - applies to all desktops.\n"
         "  dw -f [pwnd]  - dumps flags for window at pwnd or all toplevel windows\n"
         "  dw -h         - add -h to show wndproc symbol - slower.\n"
         "  dw -o pwnd    - dumps properties of pwnd.\n"
         "  dw -p pwnd    - dumps info for all child windows of window at pwnd\n"
         "  dw -r [pwnd]  - dumps relationship of windows beneath pwnd or desktop window\n"
         "  dw -s pwnd    - dumps info for all sibling windows of window at pwnd\n"
         "  dw -t <pti>   - Like EnumThreadWindows\n"
         "  dw -w pwnd    - dumps window words of pwnd.\n"
         "  dw -z         - Added to show z-ordering/activation relevant info\n"
        ,"afhvsprtwoz"
        ,STDARGS1)

#ifdef OLD_DEBUGGER
#ifdef KERNEL
DOIT(   dwe
        ,"dwe [-n] [addr]               - Displays WinEvent hooks/notifies\n"
        ,
         "  dwe <peh>    - dump EVENTHOOK struct.\n"
         "  dwe          - dump all EVENTHOOKS.\n"
         "  dwe -n <pn>  - dump NOTIFY struct.\n"
         "  dwe -n       - dump all NOTIFYs.\n"
        ,"n"
        ,STDARGS1)
#endif // KERNEL

#ifdef KERNEL
DOIT(   dwpi
        ,"dwpi -p [pwpi | ppi]          - Displays WOWPROCESSINFO structure specified\n"
        ,"  dwpi <pwpi>   - dump a pwpi structure.\n"
         "  dwpi -p <ppi> - dump pwpis for this process.\n"
         "  dwpi          - dump all pwpis.\n"
        ,"p"
        ,STDARGS1)
#endif // KERNEL
#endif // OLD_DEBUGGER

#ifdef KERNEL
DOIT(   dws
        ,"dws [pws]                     - Dump windowstations\n"
        ,"  dws <pws>     - dump windows station\n"
         "  dws           - dump all window stations\n"
        ,""
        ,STDARGS1)
DOIT(   dpa
        ,"dpa -cvsfrp                   - Dump pool allocations\n"
        ,"  dpa -c        - dump current pool allocations statistics\n"
         "  dpa -v        - dump all the current pool allocations\n"
         "  dpa -vs       - include stack traces\n"
         "  dpa -f        - dump failed allocations\n"
         "  dpa -r        - dump free pool\n"
         "  dpa -p <ptr>  - dump the allocation containing pointer 'ptr'\n"
        ,"cvsfrp"
        ,STDARGS1)

DOIT(   dcss
        ,"dcss                          - Dump critical section stack traces\n"
        ,"  dcss           - dump all stack straces\n"
        ,""
        ,STDARGS0)

DOIT(   dvs
        ,"dvs -s                        - Dump sections and mapped views\n"
        ,"  dvs -s        - dump stack traces also\n"
        ,"s"
        ,STDARGS1)
#ifdef OLD_DEBUGGER
DOIT(   dfa
        ,"dfa                           - Dump allocation fail stack trace\n"
        ,"  dfa           - dump allocation fail stack trace\n"
        ,""
        ,STDARGS1)
DOIT(   dha
        ,"dha    address                - Dump heap allocations. Also verifies the heap the address belongs to\n"
        ,"  dha -v        - Prints out all allocations in the heap\n"
         "  dha -a        - apply the command to all heaps.  \nWith no address specified, it checks all allocations in all heaps\n"
        ,"va"
        ,STDARGS1)
#endif // OLD_DEBUGGER
#endif // KERNEL

DOIT(   dy
        ,"dy [pdi]                      - Dump DISPLAYINFO\n"
        ,"  dy             - dump gpDispInfo\n"
         "  dy address     - dump DISPLAYINFO at address\n"
        ,""
        ,STDARGS1)

DOIT(   find
        ,"find baseaddr addr [o#]       - Find linked list element\n"
        ,"  find baseaddr addr      - searches list for addr starting at baseaddr,\n"
         "                            assumes link is first DWORD, w/NULL termination.\n"
         "  find baseaddr addr o4   - next link is 4 DWORDS from start of structure\n"
        ,""
        ,CUSTOM)

#ifdef OLD_DEBUGGER
DOIT(   fno
        ,"fno <address>                 - Find nearest object.\n"
        ,"  Locates the nearest public USER objects to the given address.\n"
        ,""
        ,STDARGS1)

DOIT(   frr
        ,"frr <psrcLo> <psrcHi> <prefLo> [prefHi] - Find Range Reference\n"
        ,"  Used to search memory within the src range for references to\n"
         "  addresses within the ref range.\n"
        ,""
        ,STDARGS4)

#endif // OLD_DEBUGGER

#ifdef KERNEL
DOIT(   gflags
        ,"\0gflags [-v]                   - Displays NT Global Flags\n"
        ,"  gflags      - Dump and interpret the NT global flags\n"
         "  gflags -v   - A little bit verbose\n"
        ,"v"
        ,STDARGS0)

#endif // KERNEL

#ifdef KERNEL
DOIT(   kbd
        ,"kbd -au [pq]                  - Displays key state for queue\n"
        ,"  kbd            - key state for foreground queue\n"
         "  kbd pq         - key state for queue structure at pq\n"
         "  kbd -a         - key state for all queues\n"
         "  kbd -u pb      - wParam of WM_UPDATEKEYSTATE event\n"
         "  kbd -k vk      - check given vkey status\n"
         "  kbd -s         - show all vk status\n"
        ,"auks"
        ,STDARGS1)
#endif // KERNEL

DOIT(   sas
        ,"sas [-s] <addr> [length]      - Stack Analysis Stuff\n"
        ,"sas -d [-s] <number> - to just analyze a number.\n"
         " length defaults to 25.\n"
         " -s suppresses symbolic output.\n"
        ,"ds"
        ,STDARGS2)

DOIT(   tag
        ,"tag [<tag #> [<flags>]]         - Displays or sets tags\n"
        ,"  tag               - display all tags\n"
         "  tag <tag #>         - display one tag\n"
         "  tag <tag #> <flags> - change tag settings\n"
         "       <flags> = [0-3] Disabled = 0, Enabled = 1, Print = 2, Prompt = 3\n"
        ,""
        ,CUSTOM)

DOIT(   test
        ,"test                          - Test basic debug functions.\n"
        ,""
        ,""
        ,NOARGS)

DOIT(   uver
        ,"uver                          - show versions of user and exts.\n"
        ,""
        ,""
        ,NOARGS)


DOIT(   vkey
        ,""
        ,"vkey                          - show vkey values\n"
         "  vkey hex          - display VK symbol\n"
         "  vkey VK_*         - display hex value for VK_ symbol\n"
         "  vkey -a           - display all common VK values\n"
         "  vkey -o           - display all common VK values in one column\n"
        ,"ao"
        ,CUSTOM)

#ifdef KERNEL

DOIT(   hh
        ,"hh                            - dumps gdwHydraHint.\n"
        ,"hh hydrahint        - dumps a specified DWORD as a hydra hint\n"
        ,""
        ,STDARGS1)
#endif // KERNEL

#ifdef OLD_DEBUGGER
#ifndef KERNEL
DOIT(   kc
        ,"kc pwnd                       - Displays information on Keyboard Cues\n"
        ,""
        ,""
        ,STDARGS1)
#endif // !KERNEL
#endif // OLD_DEBUGGER

DOIT(   wm
        ,"wm, vkey, ddlgt, disi: see each help\n"
        ,"wm <msg>                      - Displays window message symbol\n"
         "  wm exp            - display WM_ symb\n"
         "  wm WM_            - display message value\n"
         "  wm -a             - display all common window messages\n"
        ,"a"
        ,CUSTOM)

DOIT(   _wm
        ,""
        ,"_wm <msg>                      - Displays window message symbol\n"
         "  _wm exp           - display WM_ symb\n"
         "  _wm WM_           - display message value\n"
         "  _wm -a            - display all common window messages\n"
        ,"a"
        ,CUSTOM)

#ifdef KERNEL
DOIT(   hogs
        ,"hogs [N]                          - Dump CPU hogs\n"
        ,"hogs                - dump the kerneltime of all threads in descending order\n"
        "hogs N              - dump the N threads using the most kerneltime\n"
        ,""
        ,STDARGS1)
#endif // KERNEL

DOIT(   pred
        ,"\0pred                              - dump ia64 predicate registers\n"
        ,"pred xxxx           - dump predicate registers\n"
        ,""
        ,STDARGS1)


DOIT(   chkfre
        ,"\0chkfre [-c] [-f]\n"
        ,""
        ,"cfr"
        ,STDARGS1)

#ifdef KERNEL
DOIT(   dghost
        ,"dghost                          - Dump ghost thread associated information.\n"
        ,""
        ,""
        ,NOARGS)

DOIT(   dce
        ,"dce                             - Dumps DC Cache Entry information.\n"
        ,
         "  dce -c pwndClip   - Clipping PWND\n"
         "  dce -f DCXxxx     - DCX flag filter\n"
         "  dce -h hdc        - HDC\n"
         "  dce -o pwndOrg    - Original PWND\n"
         "  dce -r hrgnClip   - Clipping region\n"
         "  dce -t pti        - pThreadInfo\n"
         "  dce -v            - Verbose\n"
        ,"cfhortv"
        ,STDARGS1)

#endif // KERNEL

#ifndef KERNEL
DOIT(   msft
        ,"msft                            - Dump the current stock price\n"
        ,""
        ,""
        ,NOARGS)
#endif // !KERNEL

DOIT(   daccel
        ,"daccel <pAccelTable | hAccelTable> - Dump the given accelerator table\n"
        ,""
        ,""
        ,STDARGS1)

#ifdef KERNEL
DOIT(   heapff
        ,"heapff <pHeapBlock> - Looks for the given heap address in our list of freed heap.\n"
        ,""
        ,""
        ,STDARGS1)
#endif

DOIT(   dheap
        ,"dheap [-o <pid>] [-p] [-t] [-s] <pheap>  - dumps heap information for a win32 heap.\n"
        ,
         "dheap -o <pid> - dumps heap information only allocated by pid.\n"
         "dheap -p       - dumps heap statistics by allocated pid.\n"
         "dheap -t       - sorts heap allocation by tag.\n"
         "dheap -s       - sorts heap allocation by size.\n"
        ,"opts"
        ,STDARGS2)

DOIT(    fcsrp
         ,"fcsrp <pid> - Find the given PID in the CSR process list.\n"
         ,""
         ,""
         ,STDARGS1)

#ifdef KERNEL
DOIT(   findd
        ,"findd <pDesktop> - Finds all processes using the specified desktop.\n"
        ,""
        ,""
        ,STDARGS1)
#endif

DOIT(   dcmu
        ,"dcmu      - Dumps mem usage by console screen buffers.\n"
        ,"dcmu      - Dumps mem usage by console screen buffers.\n"
        ,"v"
        ,STDARGS0)

DOIT(   dcalias
        ,"dcalias    - Dump console alias list.\n"
        ,"dcalias    - Dumps alias list for all console windows.\n"
         "dcalias <pConsole> - Dumps alias list for pConsole.\n"
        ,""
        ,STDARGS1)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kdexts\kdexts.c ===
/*++

Copyright (c) 1985 - 1999, Microsoft Corporation

Module Name:

    kdexts.c

Abstract:

    This file contains the generic routines and initialization code
    for the kernel debugger extensions dll.

Author:

    Wesley Witt (wesw) 26-Aug-1993

Environment:

    User Mode

--*/

#include "precomp.h"
#pragma hdrstop

#include <imagehlp.h>
#include <wdbgexts.h>
#include <ntsdexts.h>
#include <ntverp.h>

//
// globals
//
EXT_API_VERSION        ApiVersion = { VER_PRODUCTVERSION_W >> 8,
                                      VER_PRODUCTVERSION_W & 0xff,
                                      EXT_API_VERSION_NUMBER64, 0 };
WINDBG_EXTENSION_APIS  ExtensionApis;
USHORT                 SavedMajorVersion;
USHORT                 SavedMinorVersion;
BOOL                   bDebuggingChecked;


VOID
WinDbgExtensionDllInit(
    WINDBG_EXTENSION_APIS *lpExtensionApis,
    USHORT MajorVersion,
    USHORT MinorVersion)
{
    ExtensionApis = *lpExtensionApis;

    SavedMajorVersion = MajorVersion;
    SavedMinorVersion = MinorVersion;

    bDebuggingChecked = (SavedMajorVersion == 0x0c);
}

DECLARE_API( version )
{
#if DBG
    PCHAR DebuggerType = "Checked";
#else
    PCHAR DebuggerType = "Free";
#endif // DBG

    UNREFERENCED_PARAMETER(args);
    UNREFERENCED_PARAMETER(dwProcessor);
    UNREFERENCED_PARAMETER(dwCurrentPc);
    UNREFERENCED_PARAMETER(hCurrentThread);
    UNREFERENCED_PARAMETER(hCurrentProcess);

    dprintf( "%s Extension dll for Build %d debugging %s kernel for Build %d\n",
             DebuggerType,
             VER_PRODUCTBUILD,
             SavedMajorVersion == 0x0c ? "Checked" : "Free",
             SavedMinorVersion
           );
}

LPEXT_API_VERSION
ExtensionApiVersion(
    VOID)
{
    return &ApiVersion;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kdexts\precomp.h ===
#ifndef USEREXTS
#define USEREXTS

// This is a 64 bit aware debugger extension
#define KDEXT_64BIT

#define NOWINBASEINTERLOCK
#include "ntosp.h"

#include <w32p.h>
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <excpt.h>
#include <atom.h>
#include <stdio.h>
#include <stdlib.h>
#include <limits.h>
#include <ntddkbd.h>
#include <ntddmou.h>
#include <string.h>
#include <ntstatus.h>
#include <windows.h>
#include <ntddvdeo.h>
#include <ntcsrsrv.h>
#include <wmistr.h>
#include <wmidata.h>

#endif /* USEREXTS */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kdexts\kd\kdexts.c ===
/****************************** Module Header ******************************\
* Module Name: kdexts.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* This file is included in the SOURCES= line of sources.inc.
*  It allows BUILD.EXE and $(NTMAKEENV)\MAKEFILE.DEF to work with source
*  files that are not stored in the current directory or the current
*  directory's parent.
*  Note also that a specific dependency line is included in makefile.inc
*   so the corresponding object is properly rebuilt when the source file
*   included below changes.
*
* History:
* Feb-14-1996 GerardoB Created
\***************************************************************************/
#include "..\kdexts.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kdexts\process.h ===
/****************************** Module Header ******************************\
* Module Name: process.h
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* This module contains processor specific routines.
*
* History:
* 25-Oct-1995 JimA      Created.
\***************************************************************************/

#include "precomp.h"

#include <imagehlp.h>
#include <wdbgexts.h>
#include <ntsdexts.h>

#include <stdexts.h>

extern ULONG (*GetEThreadFieldInfo)(ETHREADFIELD, PULONG);
extern ULONG (*GetEProcessFieldInfo)(EPROCESSFIELD, PULONG);                                    

PVOID GetEProcessData(
    PEPROCESS pEProcess,
    EPROCESSFIELD epf,
    PVOID pBuffer)
{
    PVOID pvData;
    ULONG ulSize;

    pvData = (PBYTE)pEProcess + GetEProcessFieldInfo(epf, &ulSize);
    if (pBuffer != NULL) {
        if (!tryMoveBlock(pBuffer, pvData, ulSize)) {
            DEBUGPRINT("GetEProcessData failed to move block. EProcess:%p epf:%d \n", pEProcess, epf);
            return NULL;
        }
    }
    return pvData;
}

PVOID GetEThreadData(
    PETHREAD pEThread,
    ETHREADFIELD etf,
    PVOID pBuffer)
{
    PVOID pvData;
    ULONG ulSize;

    pvData = (PBYTE)pEThread + GetEThreadFieldInfo(etf, &ulSize);
    if (pBuffer != NULL) {
        if (!tryMoveBlock(pBuffer, pvData, ulSize)) {
            DEBUGPRINT("GetEThreadData failed to move block. EThread:%p etf:%d \n", pEThread, etf);
            return NULL;
        }
    }
    return pvData;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kdexts\userkdx.h ===
/****************************** Module Header ******************************\
* Module Name: userkdx.h
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* Common include files for kd and ntsd.
* A preprocessed version of this file is passed to structo.exe to build
*  the struct field name-offset tables.
*
* History:
* 04-16-1996 GerardoB Created
\***************************************************************************/
#ifndef _USERKDX_
#define _USERKDX_

#include "precomp.h"
#pragma hdrstop

#ifdef KERNEL
#include <stddef.h>
#include <windef.h>
#define _USERK_
#include "heap.h"
#undef _USERK_
#include <wingdi.h>
#include <w32gdip.h>
#include <kbd.h>
#include <ntgdistr.h>
#include <winddi.h>
#include <gre.h>
#include <ddeml.h>
#include <ddetrack.h>
#include <w32err.h>
#include "immstruc.h"
#include <winuserk.h>
#include <usergdi.h>
#include <zwapi.h>
#include <userk.h>
#include <access.h>
#include <hmgshare.h>

#else // KERNEL

#include "usercli.h"

#include "usersrv.h"
#include <ntcsrdll.h>
#include "csrmsg.h"
#include <wininet.h>
#endif // KERNEL

#include "conapi.h"

#include <imagehlp.h>
#include <wdbgexts.h>
#include <ntsdexts.h>
#define NOEXTAPI

// IMM stuff
#include "immuser.h"

#endif /* _USERKDX_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kdexts\stdext64.h ===
/****************************** Module Header ******************************\
* Module Name: stdexts.h
*
* Copyright (c) 1995-1998, Microsoft Corporation
*
* This module contains standard routines for creating sane debuging extensions.
*
* History:
* 11-Apr-1995 Sanfords  Created
\***************************************************************************/

#ifdef NOEXTAPI
#undef NOEXTAPI
#endif // !NOEXTAPI

#define NOEXTAPI
#include <wdbgexts.h>

/*
 * Preceeding this header the following must have been defined:
 * PSTR pszExtName;
 *
 * This module includes "exts.h" which defines what exported functions are
 * supported by each extension and contains all help text and legal option
 * information.  At a minimum exts.h must have:

DOIT(   help
        ,"help -v [cmd]                 - Displays this list or gives details on command\n"
        ,"  help      - To dump short help text on all commands.\n"
         "  help -v   - To dump long help text on all commands.\n"
         "  help cmd  - To dump long help on given command.\n"
        ,"v"
        ,CUSTOM)

 */


extern HANDLE                  hCurrentProcess;
extern HANDLE                  hCurrentThread;
extern ULONG64                 dwCurrentPc;
extern WINDBG_EXTENSION_APIS  *lpExtensionApis;
extern DWORD                   dwProcessor;
extern WINDBG_EXTENSION_APIS   ExtensionApis;

#define Print           (lpExtensionApis->lpOutputRoutine)
#define OUTAHERE()      RtlRaiseStatus(STATUS_NONCONTINUABLE_EXCEPTION);
#define GetSym          (lpExtensionApis->lpGetSymbolRoutine)
#define ReadMem         (lpExtensionApis->lpReadProcessMemoryRoutine)
#define IsWinDbg()      (lpExtensionApis->nSize >= sizeof(WINDBG_EXTENSION_APIS))
#define SAFEWHILE(exp)  while (!IsCtrlCHit() && (exp))

extern PSTR pszAccessViolation;
extern PSTR pszMoveException;
extern PSTR pszReadFailure;

#define OPTS_ERROR 0xFFFFFFFF

#define OFLAG(l)        (1L << ((DWORD)#@l - (DWORD)'a'))
#define move(dst, src)  moveBlock(&(dst), src, sizeof(dst))
#define tryMove(dst, src)  tryMoveBlock(&(dst), src, sizeof(dst))
#define tryDword(pdst, src) tryMoveBlock(pdst, src, sizeof(DWORD))
//#define DEBUGPRINT      Print       // set this when debuging your extensions
#define DEBUGPRINT

VOID moveBlock(PVOID pdst, ULONG64 src, DWORD size);
BOOL tryMoveBlock(PVOID pdst, ULONG64 src, DWORD size);
VOID moveExp(PVOID pdst, LPSTR pszExp);
BOOL tryMoveExp(PVOID pdst, LPSTR pszExp);
VOID moveExpValue(PVOID pdst, LPSTR pszExp);
BOOL tryMoveExpValue(PVOID pdst, LPSTR pszExp);
BOOL tryMoveExpPtr(PULONG64 pdst, LPSTR pszExp);
VOID moveExpValuePtr(PULONG64 pdst, LPSTR pszExp);
BOOL IsCtrlCHit(VOID);

ULONG64 OptEvalExp(LPSTR psz);
ULONG64 OptEvalExp2(LPSTR *ppsz);
DWORD StringToOpts(LPSTR psz);
DWORD GetOpts(LPSTR *ppszArgs, LPSTR pszLegalArgs);
VOID PrintHuge(LPSTR psz);
ULONG64 EvalExp(LPSTR psz);

/*
 * entrypoint function type values
 */
#define NOARGS      0
#define STDARGS0    1
#define STDARGS1    2
#define STDARGS2    3
#define STDARGS3    4
#define STDARGS4    5
#define CUSTOM      9

/*
 * worker function prototype types
 */
typedef BOOL (* TYPE_NOARGS)(VOID);
typedef BOOL (* TYPE_STDARGS0)(DWORD);
typedef BOOL (* TYPE_STDARGS1)(DWORD, ULONG64);
typedef BOOL (* TYPE_STDARGS2)(DWORD, ULONG64, ULONG64);
typedef BOOL (* TYPE_STDARGS3)(DWORD, ULONG64, ULONG64, ULONG64);
typedef BOOL (* TYPE_STDARGS4)(DWORD, ULONG64, ULONG64, ULONG64, ULONG64);
typedef BOOL (* TYPE_CUSTOM)(DWORD, LPSTR);

/*
 * worker function proto-prototypes
 */
#define PROTO_NOARGS(name, opts)   BOOL I##name(VOID)
#define PROTO_STDARGS0(name, opts) BOOL I##name(DWORD options)
#define PROTO_STDARGS1(name, opts) BOOL I##name(DWORD options, ULONG64 param1)
#define PROTO_STDARGS2(name, opts) BOOL I##name(DWORD options, ULONG64 param1, ULONG64 param2)
#define PROTO_STDARGS3(name, opts) BOOL I##name(DWORD options, ULONG64 param1, ULONG64 param2, ULONG64 param3)
#define PROTO_STDARGS4(name, opts) BOOL I##name(DWORD options, ULONG64 param1, ULONG64 param2, ULONG64 param3, ULONG64 param4)
#define PROTO_CUSTOM(name, opts)   BOOL I##name(DWORD options, LPSTR pszArg)

/*
 * worker function prototypes (generated from exts.h)
 */
#define DOIT(name, h1, h2, opts, type) PROTO_##type(name, opts);
#include "exts.h"
#undef DOIT
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kdexts\kd\daytona\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kdexts\stdext64.c ===
/****************************** Module Header ******************************\
* Module Name: stdexts.c
*
* Copyright (c) 1995-1998, Microsoft Corporation
*
* This module contains standard routines for creating sane debuging extensions.
* It is meant to be included after stdexts.h in one of the files comprising
* the debug extsnsions for a given product or module.
*
* History:
* 11-Apr-1995 Sanfords  Created
\***************************************************************************/

HANDLE                  hCurrentProcess;
HANDLE                  hCurrentThread;
ULONG64                 dwCurrentPc;
WINDBG_EXTENSION_APIS  *lpExtensionApis;
DWORD                   dwProcessor;

PSTR pszAccessViolation = "%s: Access violation on \"%s\".\n";
PSTR pszMoveException   = "%s: exception in moveBlock()\n";
PSTR pszReadFailure     = "%s: lpReadProcessMemoryRoutine failed!\n";
PSTR pszCantContinue    = "%s: Non-continuable exception.\n";
BOOL fCtrlCHit = FALSE;


/*
 * This function returns TRUE once the user has hit a Ctrl-C.
 * This allows proper operation of nested SAFEWHILE loops so
 * that all levels exit.
 *
 * The globall fCtrlCHit flag needs to be reset manually and
 * is done so in the CommandEP function.
 */
BOOL IsCtrlCHit(
    VOID)
{
    if ((lpExtensionApis->lpCheckControlCRoutine)()) {
        fCtrlCHit = TRUE;
    }

    return fCtrlCHit;
}



VOID moveBlock(
    PVOID pdst,
    ULONG64 src,
    DWORD size)
{
    BOOL fSuccess = TRUE;
    ULONG Result;

    try {
        if (IsWinDbg()) {
            if (!ReadMem(src, pdst, size, &Result)) {
                fSuccess = FALSE;
             }
        } else {
            if (!NT_SUCCESS(NtReadVirtualMemory(hCurrentProcess,
                    (PVOID)src, pdst, size, NULL))) {
                fSuccess = FALSE;
            }
        }
    } except (EXCEPTION_EXECUTE_HANDLER) {
        Print(pszMoveException, pszExtName);
        fSuccess = FALSE;
    }
    if (!fSuccess) {
        DEBUGPRINT("%s: moveBlock(%p, %p, %x) failed.\n",
                pszExtName, pdst, src, size);
        OUTAHERE();
    }
}


BOOL tryMoveBlock(
    PVOID pdst,
    ULONG64 src,
    DWORD size)
{
    BOOL fSuccess = TRUE;
    ULONG Result;

    try {
        if (IsWinDbg()) {
            if (!ReadMem(src, pdst, size, &Result)) {
                DEBUGPRINT("%s: tryMoveBlock(%p, %p, %x) failed.\n", pszExtName, pdst, src, size);
                fSuccess = FALSE;
             }
        } else {
            if (!NT_SUCCESS(NtReadVirtualMemory(hCurrentProcess, (PVOID)src, pdst, size, NULL))) {
                DEBUGPRINT("%s: tryMoveBlock(%p, %p, %x) failed.\n", pszExtName, pdst, src, size);
                fSuccess = FALSE;
            }
        }
    } except (EXCEPTION_EXECUTE_HANDLER) {
        DEBUGPRINT("%s: tryMoveBlock(%p, %p, %x) faulted.\n", pszExtName, pdst, src, size);
        fSuccess = FALSE;
    }

    return fSuccess;
}



VOID moveExp(
    PULONG64 pdst,
    LPSTR pszExp)
{
    BOOL fSuccess = TRUE;

    try {
        *pdst = EvalExp(pszExp);
    } except (GetExceptionCode() == EXCEPTION_ACCESS_VIOLATION ?
                EXCEPTION_EXECUTE_HANDLER : EXCEPTION_CONTINUE_SEARCH) {
        Print(pszAccessViolation, pszExtName, pszExp);
        fSuccess = FALSE;
    }

    if (!fSuccess) {
        Print("%s: moveExp failed on %s.\n", pszExtName, pszExp);
        OUTAHERE();
    }
}


BOOL tryMoveExp(
    PULONG64 pdst,
    LPSTR pszExp)
{
    BOOL fSuccess = TRUE;

    try {
        *pdst = EvalExp(pszExp);
    } except (GetExceptionCode() == EXCEPTION_ACCESS_VIOLATION ?
                EXCEPTION_EXECUTE_HANDLER : EXCEPTION_CONTINUE_SEARCH) {
        Print(pszAccessViolation, pszExtName, pszExp);
        DEBUGPRINT("%s: tryMoveExp(%p, %s) faulted.\n", pszExtName, pdst, pszExp);
        fSuccess = FALSE;
    }

    return fSuccess;
}


VOID moveExpValue(
    PVOID pdst,
    LPSTR pszExp)
{
    DWORD dw;
    ULONG64 addr;

    if (tryMoveExp(&addr, pszExp)) {
        if (tryMoveBlock(&dw, addr, sizeof(DWORD))) {
            *((PDWORD)pdst) = dw;
            return;
        }
    }
    Print("%s: moveExpValue failed on %s.\n", pszExtName, pszExp);
    OUTAHERE();
}


BOOL tryMoveExpValue(
    PVOID pdst,
    LPSTR pszExp)
{
    DWORD dw;
    ULONG64 addr;

    if (tryMoveExp(&addr, pszExp)) {
        if (tryMove(dw, addr)) {
            *((PDWORD)pdst) = dw;
            return TRUE;
        }
    }
    DEBUGPRINT("%s: tryMoveExpValue failed on %s.\n", pszExtName, pszExp);
    return FALSE;
}


BOOL tryMoveExpPtr(
    PULONG64 pdst,
    LPSTR pszExp)
{
    BOOL fSuccess = TRUE;

    try {
        *pdst = EvalExp(pszExp);
    } except (GetExceptionCode() == EXCEPTION_ACCESS_VIOLATION ?
                EXCEPTION_EXECUTE_HANDLER : EXCEPTION_CONTINUE_SEARCH) {
        Print(pszAccessViolation, pszExtName, pszExp);
        DEBUGPRINT("%s: tryMoveExpPtr(%p, %s) faulted.\n", pszExtName, pdst, pszExp);
        fSuccess = FALSE;
    }

    return fSuccess;
}


VOID moveExpValuePtr(
    PULONG64 pdst,
    LPSTR pszExp)
{
    ULONG64 dw;

    if (tryMoveExpPtr(&dw, pszExp)) {
        if (tryMoveBlock(&dw, dw, sizeof(dw))) {
            *pdst = dw;
            return;
        }
    }

    Print("%s: moveExpValue failed on %s.\n", pszExtName, pszExp);
    OUTAHERE();
}


ULONG64 EvalExp(
    LPSTR psz)
{
    ULONG64 p;

    p = (lpExtensionApis->lpGetExpressionRoutine)(psz);
    if (p == 0) {
        Print("%s: EvalExp failed to evaluate %s.\n", pszExtName, psz);
    }

    return p;
}



ULONG64 OptEvalExp(
    LPSTR psz)
{
    while (*psz == ' ') {
        psz++;
    }

    if (*psz == '\0') {
        return 0;
    }

    return EvalExp(psz);
}



ULONG64 OptEvalExp2(
    LPSTR *ppsz)
{
    LPSTR psz = *ppsz;
    ULONG64 dwRet = 0;

    while (*psz == ' ') {
        psz++;
    }

    if (*psz != '\0') {
        dwRet = EvalExp(psz);
        while (*psz != '\0' && *psz != ' ') {
            psz++;
        }
    }
    *ppsz = psz;

    return dwRet;
}


DWORD StringToOpts(
    LPSTR psz)
{
    DWORD opts = 0;

    while (*psz != '\0' && *psz != ' ') {
        if (*psz >= 'a' && *psz <= 'z') {
            opts |= 1 << (*psz - 'a');
        } else if (*psz >= 'A' && *psz <= 'Z') {
            opts |= 1 << (*psz - 'A');
        } else {
            return OPTS_ERROR;     // any non-letter option is an error.
        }
        psz++;
    }

    return opts;
}


/*
 * Function to convert an option string to a DWORD of flags.  pszLegalArgs
 * is used to allow option validation at the same time.
 *
 * *ppszArgs is set to point to after the options on exit.
 * On error, returns OPTS_ERROR.
 */
DWORD GetOpts(
    LPSTR *ppszArgs,
    LPSTR pszLegalArgs OPTIONAL)
{
    DWORD Opts = 0;
    LPSTR pszArgs = *ppszArgs;

    /*
     * Skip whitespace
     */
    while (*pszArgs == ' ') {
        pszArgs++;
    }
    /*
     * process '-' prepended options.
     */
    while (*pszArgs == '-') {
        pszArgs++;
        Opts = StringToOpts(pszArgs);
        /*
         * skip to whitespace or end.
         */
        while (*pszArgs != '\0' && *pszArgs != ' ') {
            pszArgs++;
        }
        /*
         * skip trailing whitespace.
         */
        while (*pszArgs == ' ') {
            pszArgs++;
        }
        *ppszArgs = pszArgs;

        /*
         * optionally validate against LegalArgs
         */
        if (pszLegalArgs != NULL && ((Opts & StringToOpts(pszLegalArgs)) != Opts)) {
            Opts = OPTS_ERROR;
            Print("Bad options.\n");
            return Opts;
        }
    }

    return Opts;
}


/*
 * Dispatcher function used by generated entrypoint functions.
 */
VOID CommonEP(
    PVOID pFunction,
    LPSTR pszName,
    int type,
    LPSTR pszLegalOpts,
    HANDLE hcp,
    HANDLE hct,
    ULONG64 dwcp,
    DWORD dwp,
    LPSTR lpas)
{
    BOOL dwOptions, fSuccess;
    ULONG64 param1, param2, param3;

    hCurrentProcess = hcp;
    hCurrentThread = hct;
    dwCurrentPc = dwcp;
    dwProcessor = dwp;
    lpExtensionApis = &ExtensionApis;

    fCtrlCHit = FALSE;  // reset this with each command. (SAFEWHILE fix)
    switch (type) {
    case NOARGS:
        fSuccess = ((TYPE_NOARGS)pFunction)();
        goto Exit;
    }

    dwOptions = GetOpts(&lpas, pszLegalOpts);
    if (dwOptions == OPTS_ERROR) {
        fSuccess = Ihelp(0, pszName);
        goto Exit;
    }

    try {
        switch (type) {
        case CUSTOM:
            fSuccess = ((TYPE_CUSTOM)pFunction)(dwOptions, lpas);
            break;

        case STDARGS0:
            fSuccess = ((TYPE_STDARGS0)pFunction)(dwOptions);
            break;

        case STDARGS1:
            fSuccess = ((TYPE_STDARGS1)pFunction)(dwOptions, OptEvalExp(lpas));
            break;

        case STDARGS2:
            param1 = OptEvalExp2(&lpas);
            fSuccess = ((TYPE_STDARGS2)pFunction)(dwOptions, param1, OptEvalExp(lpas));
            break;

        case STDARGS3:
            param1 = OptEvalExp2(&lpas);
            param2 = OptEvalExp2(&lpas);
            fSuccess = ((TYPE_STDARGS3)pFunction)(dwOptions, param1, param2, OptEvalExp(lpas));
            break;

        case STDARGS4:
            param1 = OptEvalExp2(&lpas);
            param2 = OptEvalExp2(&lpas);
            param3 = OptEvalExp2(&lpas);
            fSuccess = ((TYPE_STDARGS4)pFunction)(dwOptions, param1, param2, param3, OptEvalExp(lpas));
            break;

        default:
            Print("CommonEP: Don't recognize function type %d.\n", type);
            break;
        }
    } except (GetExceptionCode() == STATUS_NONCONTINUABLE_EXCEPTION ?
                EXCEPTION_EXECUTE_HANDLER : EXCEPTION_CONTINUE_SEARCH) {
        Print(pszCantContinue, pszExtName);
    }

Exit:
    if (!fSuccess) {
        Print("%s failed.\n", pszName);
        Ihelp(0, pszName);
    }
}

/*
 * Entrypoint functions (generated from exts.h)
 */
#define DOIT(name, h1, h2, opts, type)                  \
VOID name##(                                            \
    HANDLE hcp,                                         \
    HANDLE hct,                                         \
    ULONG64 dwcp,                                       \
    DWORD dwp,                                          \
    LPSTR lpas)                                         \
{                                                       \
    CommonEP(I##name, #name, type, opts, hcp, hct, dwcp, dwp, lpas); \
}
#include "exts.h"
#undef DOIT


/*
 * Standard help extension - present in all standard extensions.
 */
BOOL Ihelp(
    DWORD opts,
    LPSTR lpas)
{
#define DOIT(name, help1, help2, opts, type)  { #name, help1, help2 },

    static struct {
        LPSTR pszCmdName;
        LPSTR pszHelp1;
        LPSTR pszHelp2;
    } he[] = {
#include "exts.h"
    };
#undef DOIT
    int i;

    while (*lpas == ' ') {
        lpas++;
    }

    if (*lpas == '\0') {
        Print("-------------- %s Debug Extension help:--------------\n\n", pszExtName);
        for (i = 0; i < sizeof(he) / sizeof(he[0]); i++) {
            if (IsCtrlCHit()) {
                break;
            }
            Print(he[i].pszHelp1);
            if (opts & OFLAG(v)) {
                Print(he[i].pszHelp2);
            }
        }
        return TRUE;
    } else {
        for (i = 0; i < sizeof(he) / sizeof(he[0]); i++) {
            if (IsCtrlCHit()) {
                break;
            }
            if (strcmp(lpas, he[i].pszCmdName) == 0) {
                Print(he[i].pszHelp1);
                Print(he[i].pszHelp2);
                return TRUE;
            }
        }
        Print("%s is not supported.\n", lpas);
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kdexts\kd\makefile.inc ===
HDEPENDENCIES=..\..\exts.h $(WINDOWS_INC_PATH)\stdexts.h

GENUEDEFDEFINES=/DKERNEL /D_$(ALT_PROJECT)_

$(O)\userkdx.def: ..\..\genuedef.c $(HDEPENDENCIES)
        $(CXX_COMPILER_NAME) $(GENUEDEFDEFINES) /EP ..\..\genuedef.c >$@

#
# Dependencies for dummy targets
#
..\kdexts.c:            ..\..\kdexts.c
..\userexts.c:          ..\..\userkdx.h \
                        ..\..\userexts.c \
                        $(HDEPENDENCIES) \
                        $(WINDOWS_INC_PATH)\stdexts.c \
                        $(O)\wm.txt $(O)\vktbl.txt

..\userexts.rc:         ..\..\userexts.rc

..\..\precomp.h: ..\..\userkdx.h
..\..\userkdx.h: $(NTUSER_PATH)\kernel\userk.h \
                 $(NTUSER_PATH)\inc\user.h \
                 $(NTUSER_PATH)\inc\ntuser.h \
                 $(WINDOWS_INC_PATH)\winuserp.h \
                 $(WINDOWS_INC_PATH)\immp.h \
                 $(WINCORE_PATH)\w32inc\winuserk.h

$(O)\ptagdbg.h: $(NTUSER_PATH)\kdexts\ptagdbg.bat $(NTUSER_PATH)\kernel\ptag.lst
    $(NTUSER_PATH)\kdexts\ptagdbg.bat $(NTUSER_PATH)\kernel\ptag.lst $(O)\ptagdbg.h

$(O)\wm.txt: $(PROJECT_ROOT)\Published\winuser.w $(WINDOWS_INC_PATH)\winuserp.h
    perl $(NTUSER_PATH)\kdexts\wm.pl $(PROJECT_ROOT)\Published\winuser.w > $(O)\wm.txt

VKTBL_SRCS=$(PROJECT_ROOT)\Published\winuser.w  \
           $(WINDOWS_INC_PATH)\vkoem.h          \
           $(PROJECT_ROOT)\Published\ime.w

$(O)\vktbl.txt: $(VKTBL_SRCS)
    perl $(NTUSER_PATH)\kdexts\vkeytbl.pl $(VKTBL_SRCS) > $(O)\vktbl.txt
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kdexts\ntsd\daytona\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kdexts\userexts.c ===
/****************************** Module Header ******************************\
* Module Name: userexts.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* This module contains user related debugging extensions.
*
* History:
* 17-May-1991 DarrinM   Created.
* 22-Jan-1992 IanJa     ANSI/Unicode neutral (all debug output is ANSI)
* 23-Mar-1993 JerrySh   Moved from winsrv.dll to userexts.dll
* 21-Oct-1993 JerrySh   Modified to work with WinDbg
* 18-Oct-1994 ChrisWil  Added Object Tracking extent.
* 26-May-1995 Sanfords  Made it more general for the good of humanity.
* 09-Jun-1995 SanfordS  Made to fit stdexts motif and to dual compile for
*                       either USER or KERNEL mode.
\***************************************************************************/
#include "userkdx.h"
#include "vkoem.h"

#ifdef KERNEL
CONST PSTR pszExtName = "USERKDX";
#else
CONST PSTR pszExtName = "USEREXTS";
#endif

#include <stdext64.h>
#include <stdext64.c>

/***************************************************************************\
* Constants
\***************************************************************************/
#define CDWORDS 16
#define BF_MAX_WIDTH    80
#define BF_COLUMN_WIDTH 19

typedef ULONG64 PTR, *PPTR;
#define NULL_PTR        ((PTR)(0))

// If you want to debug the extension, enable this.
#if 0
#undef DEBUGPRINT
#define DEBUGPRINT  Print
#endif

/***************************************************************************\
* Global variables
\***************************************************************************/
BOOL bShowFlagNames = TRUE;
char gach1[80];
char gach2[80];
char gach3[80];
int giBFColumn;                     // bit field: current column
char gaBFBuff[BF_MAX_WIDTH + 1];    // bit field: buffer

// used in dsi() and dinp()
typedef struct {
    int     iMetric;
    LPSTR   pstrMetric;
} SYSMET_ENTRY;
#define SMENTRY(sm) {SM_##sm, #sm}

/***************************************************************************\
* Macros
\***************************************************************************/

#define TestWWF(pww, flag)   (*(((PBYTE)(pww)) + (int)HIBYTE(flag)) & LOBYTE(flag))

VOID ShowProgress(
    VOID);

#define CHKBREAK()  do { if (IsCtrlCHit()) return TRUE; } while (FALSE)


#ifdef KERNEL // ########### KERNEL MODE ONLY MACROS ###############

#define VAR(v)  "win32k!" #v
#define SYM(s)  "win32k!" #s
#define FIXKP(p) p
#define RebaseSharedPtr(p)       (p)

#define FOREACHWINDOWSTATION(pwinsta)               \
    pwinsta = GetGlobalPointer(VAR(grpWinStaList)); \
    SAFEWHILE (pwinsta != 0) {

#define NEXTEACHWINDOWSTATION(pwinsta)              \
        GetFieldValue(pwinsta, SYM(tagWINDOWSTATION), "rpwinstaNext", pwinsta);    \
    }



#define FOREACHDESKTOP(pdesk)                       \
    {                                               \
        ULONG64 pwinsta;                            \
                                                    \
        FOREACHWINDOWSTATION(pwinsta)               \
        GetFieldValue(pwinsta, SYM(WINDOWSTATION), "rpdeskList", pdesk);    \
        SAFEWHILE (pdesk != 0) {

#define NEXTEACHDESKTOP(pdesk)                      \
            GetFieldValue(pdesk, SYM(DESKTOP), "rpdeskNext", pdesk);        \
        }                                           \
        NEXTEACHWINDOWSTATION(pwinsta)              \
    }

VOID PrintStackTrace(
    ULONG64 pStackTrace,
    int    tracesCount);

typedef ULONG (WDBGAPI *PPI_CALLBACK)(ULONG64 ppi, PVOID Data);

typedef struct _PPI_CONTEXT {
    PPI_CALLBACK    CallbackRoutine;
    PVOID           Data;
} PPI_CONTEXT;

ULONG
ForEachPpiCallback(
    PFIELD_INFO   NextProcess,
    PVOID         Context)
{
    ULONG64 pEProcess = NextProcess->address;
    ULONG64 ppi = 0;
    PPI_CONTEXT *pPpiContext = (PPI_CONTEXT *)Context;

    /*
     * Dump Win32 Processes only
     */

    GetFieldValue(pEProcess, "nt!EPROCESS", "Win32Process", ppi);
    if (ppi) {
        return pPpiContext->CallbackRoutine(ppi, pPpiContext->Data);
    }

    return FALSE;
}

BOOL
ForEachPpi(
    PPI_CALLBACK CallbackRoutine,
    PVOID        Data)
{
    ULONG64 ProcessHead;
    ULONG64 NextProcess;
    PPI_CONTEXT PpiContext;

    ProcessHead = EvalExp("PsActiveProcessHead");
    if (!ProcessHead) {
        Print("Unable to get value of PsActiveProcessHead\n");
        return FALSE;
    }

    if (GetFieldValue(ProcessHead, "nt!_LIST_ENTRY", "Flink", NextProcess)) {
        Print("Unable to get value of PsActiveProcessHead\n");
        return FALSE;
    }
    if (NextProcess == 0) {
        Print("PsActiveProcessHead->Flink is NULL!\n");
        return FALSE;
    }

    PpiContext.CallbackRoutine = CallbackRoutine;
    PpiContext.Data = Data;
    ListType("nt!_EPROCESS",
             NextProcess,
             1,
             "ActiveProcessLinks.Flink",
             &PpiContext,
             ForEachPpiCallback);

    return TRUE;
}


typedef ULONG (WDBGAPI *PTI_CALLBACK)(ULONG64 pti, PVOID Data);

typedef struct _PTI_CONTEXT {
    PTI_CALLBACK    CallbackRoutine;
    PVOID           Data;
} PTI_CONTEXT;

ULONG
ForEachPtiCallback(
    ULONG64 ppi,
    PVOID   Data)
{
    ULONG64 pti = 0;
    PTI_CONTEXT *pPtiContext = (PTI_CONTEXT *)Data;

    if (GetFieldValue(ppi, SYM(PROCESSINFO), "ptiList", pti)) {
                    DEBUGPRINT("ForEachPti: Can't get ptiList from ppi 0x%p.\n", ppi);
    }

    SAFEWHILE (pti != 0) {
        pPtiContext->CallbackRoutine(pti, pPtiContext->Data);
        if (GetFieldValue(pti, SYM(THREADINFO), "ptiSibling", pti)) {
            DEBUGPRINT("ForEachPti: Can't get ptiSibling from pti 0x%p.\n", pti);
        }
    }

    return FALSE;
}

ULONG
ForEachPti(
    PTI_CALLBACK CallbackRoutine,
    PVOID        Data)
{
    PTI_CONTEXT PtiContext;

    PtiContext.CallbackRoutine = CallbackRoutine;
    PtiContext.Data = Data;
    return ForEachPpi(ForEachPtiCallback, &PtiContext);
}


#else //!KERNEL  ############## USER MODE ONLY MACROS ################

#define VAR(v)  "user32!" #v
#define SYM(s)  "user32!" #s
#define FIXKP(p) FixKernelPointer(p)

#endif //!KERNEL ############## EITHER MODE MACROS ###################

#define GETSHAREDINFO(psi) moveExp(&psi, VAR(gSharedInfo))


#define FOREACHHANDLEENTRY(phe, i)                                   \
    {                                                                \
        ULONG64 pshi, psi, cHandleEntries;                           \
        ULONG dwHESize = GetTypeSize(SYM(HANDLEENTRY));              \
                                                                     \
        GETSHAREDINFO(pshi);                                         \
        if (GetFieldValue(pshi, SYM(SHAREDINFO), "psi", psi)) {      \
            Print("FOREACHHANDLEENTRY:Could not get SERVERINFO from SHAREDINFO %p\n", pshi); \
        }                                                            \
        GetFieldValue(pshi, SYM(SHAREDINFO), "aheList", phe);        \
        GetFieldValue(psi, SYM(SERVERINFO), "cHandleEntries", cHandleEntries); \
        for (i = 0; cHandleEntries; cHandleEntries--, i++, phe += dwHESize) {  \
            if (IsCtrlCHit()) {                                      \
                break;                                               \
            }

#define NEXTEACHHANDLEENTRY()                                        \
        }                                                            \
    }

/*
 * Use these macros to print field values, globals, local values, etc.
 * This assures consistent formating plus make the extensions easier to read and to maintain.
 */
#define STRWD1 "67"
#define STRWD2 "28"
#define DWSTR1 "%08lx %." STRWD1 "s"
#define DWSTR2 "%08lx %-" STRWD2 "." STRWD2 "s"
#define PTRSTR1 "%08p %-" STRWD1 "s"
#define PTRSTR2 "%08p %-" STRWD2 "." STRWD2 "s"
#define DWPSTR1 "%08p %." STRWD1 "s"
#define DWPSTR2 "%08p %-" STRWD2 "." STRWD2 "s"
#define PRTFDW1(f1) Print(DWSTR1 "\n", ReadField(f1), #f1)
#define PRTVDW1(s1, v1) Print(DWSTR1 "\n", v1, #s1)
#define PRTFDW2(f1, f2) Print(DWSTR2 "\t" DWSTR2 "\n", (DWORD)ReadField(f1), #f1, (DWORD)ReadField(f2), #f2)
#define PRTVDW2(s1, v1, s2, v2) Print(DWSTR2 "\t" DWPSTR2 "\n", v1, #s1, v2, #s2)
#define PRTFRC(p, rc) Print("%-" STRWD2 "s{%#lx, %#lx, %#lx, %#lx}\n", #rc, ##p##rc.left, ##p##rc.top, ##p##rc.right, ##p##rc.bottom)
#define PRTFPT(pt) Print("%-" STRWD2 "s{0x%x, 0x%x}\n", #pt, ReadField(pt.x), ReadField(pt.y))
#define PRTVPT(s, pt) Print("%-" STRWD2 "s{0x%x, 0x%x}\n", #s, pt.x, pt.y)
#define PRTFDWP1(f1) Print(DWPSTR1 "\n", ReadField(f1), #f1)
#define PRTFDWP2(f1, f2) Print(DWPSTR2 "\t" DWPSTR2 "\n", ReadField(f1), #f1, ReadField(f2), #f2)
#define PRTFDWPDW(f1, f2) Print(DWPSTR2 "\t" DWSTR2 "\n", ReadField(f1), #f1, ReadField(f2), #f2)
#define PRTFDWDWP(p, f1, f2) Print(DWSTR2 "\t" DWPSTR2 "\n", (DWORD)##p##f1, #f1, (DWORD_PTR)##p##f2, #f2)

/*
 * Bit Fields
 */
#define BEGIN_PRTFFLG(p, type) InitTypeRead(p, type)
#define PRTFFLG(f)   PrintBitField(#f, (BOOL)!!(ReadField(f)))
#define END_PRTFFLG()   PrintEndBitField()


#define PRTGDW1(g1) \
        { DWORD _dw1; \
            moveExpValue(&_dw1, VAR(g1)); \
            Print(DWSTR1 "\n", _dw1, #g1); }

#define PRTGDW2(g1, g2) \
        { DWORD _dw1, _dw2; \
            moveExpValue(&_dw1, VAR(g1)); \
            moveExpValue(&_dw2, VAR(g2)); \
            Print(DWSTR2 "\t" DWSTR2 "\n",  _dw1, #g1, _dw2, #g2); }

#define PRTGPTR1(g1) \
    Print(PTRSTR1 "\n", GetGlobalPointer(VAR(g1)), #g1)

#define PRTGPTR2(g1, g2) \
    Print(PTRSTR2 "\t" PTRSTR2 "\n", GetGlobalPointer(VAR(g1)), #g1, GetGlobalPointer(VAR(g2)), #g2)


/* This macro requires char ach[...]; to be previously defined */
#define PRTWND(s, pwnd) \
        { DebugGetWindowTextA(pwnd, ach, ARRAY_SIZE(ach)); \
            Print("%-" STRWD2 "s" DWPSTR2 "\n", #s, pwnd, ach); }

#define PRTGWND(gpwnd) \
        { ULONG64 _pwnd; \
            moveExpValuePtr(&_pwnd, VAR(gpwnd)); \
            DebugGetWindowTextA(_pwnd, ach, ARRAY_SIZE(ach)); \
            Print("%-" STRWD2 "s" DWPSTR2 "\n", #gpwnd, _pwnd, ach); }

#ifdef LATER    // macros above need fix... and callers as well that mix up DWORD and PVOID.
#define PRTGDW1(g1) \
        {\
            DWORD _dw1 = GetGlobalDWord(VAR(g1)); \
            Print(DWSTR1 "\n", _dw1, #g1); \
        }

#define PRTGDW2(g1, g2) \
        {\
            DWORD _dw1 = GetGlobalDWord(VAR(g1)); \
            DWORD _dw2 = GetGlobalDWord(VAR(g2)); \
            Print(DWSTR2 "\t" DWSTR2 "\n", _dw1, #g1, _dw2, #g2); \
        }

#define PRTGWND(gpwnd) \
        { ULONG64 _pwnd = GetGlobalPointer(VAR(gpwnd)); \
            DebugGetWindowTextA(_pwnd, ach); \
            Print("%-" STRWD2 "s" DWPSTR2 "\n", #gpwnd, _pwnd, ach); }
#endif  // LATER



/****************************************************************************\
* PROTOTYPES
*  Note that all Ixxx proc prototypes are generated by stdexts.h
\****************************************************************************/
#ifdef KERNEL

BOOL GetAndDumpHE(ULONG64 dwT, PULONG64 phe, BOOL fPointerTest);
LPSTR ProcessName(ULONG64 ppi);

#else // !KERNEL

ULONG64 FixKernelPointer(ULONG64 pKernel);
BOOL DumpConvInfo(PCONV_INFO pcoi);

#endif // !KERNEL

LPSTR GetFlags(WORD wType, DWORD dwFlags, LPSTR pszBuf, BOOL fPrintZero);
BOOL HtoHE(ULONG64 h, ULONG64 *pphe);
ULONG64 GetPfromH(ULONG64 h, ULONG64 *pphe);
BOOL getHEfromP(ULONG64 *pphe, ULONG64 p);
ULONG64 HorPtoP(ULONG64 p, int type);
BOOL DebugGetWindowTextA(ULONG64 pwnd, char *achDest, DWORD dwLength);
BOOL DebugGetClassNameA(ULONG64 lpszClassName, char *achDest);
BOOL dwrWorker(ULONG64 pwnd, int tab);
BOOL CopyUnicodeString(
    IN  ULONG64 pData,
    IN  char * pszStructName,
    IN  char * pszFieldName,
    OUT WCHAR *pszDest,
    IN  ULONG cchMax);

BOOL IsRemoteSession(
    VOID)
{
    PPEB ppeb = NtCurrentPeb();

    return (ppeb->SessionId != 0);
}

int PtrWidth(
    VOID)
{
    static int width = 0;

    if (width) {
        return width;
    }

    if (IsPtr64()) {
        return (width = 17);
    } else {
        return (width = 8);
    }
}


/****************************************************************************\
* Flags stuff
\****************************************************************************/

typedef struct _WFLAGS {
    PSZ     pszText;
    WORD    wFlag;
} WFLAGS;

#define WF_ENTRY(flag)  #flag, flag

CONST WFLAGS aWindowFlags[] = { // sorted alphabetically
    WF_ENTRY(BFBITMAP),
    WF_ENTRY(BFBOTTOM),
    WF_ENTRY(BFCENTER),
    WF_ENTRY(BFFLAT),
    WF_ENTRY(BFICON),
    WF_ENTRY(BFLEFT),
    WF_ENTRY(BFMULTILINE),
    WF_ENTRY(BFNOTIFY),
    WF_ENTRY(BFPUSHLIKE),
    WF_ENTRY(BFRIGHT),
    WF_ENTRY(BFRIGHTBUTTON),
    WF_ENTRY(BFTOP),
    WF_ENTRY(BFVCENTER),
    WF_ENTRY(CBFAUTOHSCROLL),
    WF_ENTRY(CBFBUTTONUPTRACK),
    WF_ENTRY(CBFDISABLENOSCROLL),
    WF_ENTRY(CBFDROPDOWN),
    WF_ENTRY(CBFDROPDOWNLIST),
    WF_ENTRY(CBFDROPPABLE),
    WF_ENTRY(CBFDROPTYPE),
    WF_ENTRY(CBFEDITABLE),
    WF_ENTRY(CBFHASSTRINGS),
    WF_ENTRY(CBFLOWERCASE),
    WF_ENTRY(CBFNOINTEGRALHEIGHT),
    WF_ENTRY(CBFOEMCONVERT),
    WF_ENTRY(CBFOWNERDRAW),
    WF_ENTRY(CBFOWNERDRAWFIXED),
    WF_ENTRY(CBFOWNERDRAWVAR),
    WF_ENTRY(CBFSIMPLE),
    WF_ENTRY(CBFSORT),
    WF_ENTRY(CBFUPPERCASE),
    WF_ENTRY(DF3DLOOK),
    WF_ENTRY(DFCONTROL),
    WF_ENTRY(DFLOCALEDIT),
    WF_ENTRY(DFNOFAILCREATE),
    WF_ENTRY(DFSYSMODAL),
    WF_ENTRY(EFAUTOHSCROLL),
    WF_ENTRY(EFAUTOVSCROLL),
    WF_ENTRY(EFCOMBOBOX),
    WF_ENTRY(EFLOWERCASE),
    WF_ENTRY(EFMULTILINE),
    WF_ENTRY(EFNOHIDESEL),
    WF_ENTRY(EFNUMBER),
    WF_ENTRY(EFOEMCONVERT),
    WF_ENTRY(EFPASSWORD),
    WF_ENTRY(EFREADONLY),
    WF_ENTRY(EFUPPERCASE),
    WF_ENTRY(EFWANTRETURN),
    WF_ENTRY(SBFSIZEBOX),
    WF_ENTRY(SBFSIZEBOXBOTTOMRIGHT),
    WF_ENTRY(SBFSIZEBOXTOPLEFT),
    WF_ENTRY(SBFSIZEGRIP),
    WF_ENTRY(SFCENTERIMAGE),
    WF_ENTRY(SFEDITCONTROL),
    WF_ENTRY(SFELLIPSISMASK),
    WF_ENTRY(SFNOPREFIX),
    WF_ENTRY(SFNOTIFY),
    WF_ENTRY(SFREALSIZECONTROL),
    WF_ENTRY(SFREALSIZEIMAGE),
    WF_ENTRY(SFRIGHTJUST),
    WF_ENTRY(SFSUNKEN),
    WF_ENTRY(WEFACCEPTFILES),
    WF_ENTRY(WEFAPPWINDOW),
    WF_ENTRY(WEFCLIENTEDGE),
    WF_ENTRY(WEFCOMPOSITED),
    WF_ENTRY(WEFCONTEXTHELP),
    WF_ENTRY(WEFCONTROLPARENT),
    WF_ENTRY(WEFDLGMODALFRAME),
    WF_ENTRY(WEFDRAGOBJECT),
#ifdef REDIRECTION
    WF_ENTRY(WEFEXTREDIRECTED),
#endif
    WF_ENTRY(WEFGHOSTMAKEVISIBLE),
#ifdef LAME_BUTTON
    WF_ENTRY(WEFLAMEBUTTON),
#endif // LAME_BUTTON
    WF_ENTRY(WEFLEFTSCROLL),
    WF_ENTRY(WEFMDICHILD),
    WF_ENTRY(WEFNOACTIVATE),
    WF_ENTRY(WEFNOPARENTNOTIFY),
    WF_ENTRY(WEFPREDIRECTED),
    WF_ENTRY(WEFRIGHT),
    WF_ENTRY(WEFRTLREADING),
    WF_ENTRY(WEFSTATICEDGE),
    WF_ENTRY(WEFLAYERED),
    WF_ENTRY(WEFTOOLWINDOW),
    WF_ENTRY(WEFTOPMOST),
    WF_ENTRY(WEFTRANSPARENT),
    WF_ENTRY(WEFTRUNCATEDCAPTION),
    WF_ENTRY(WEFWINDOWEDGE),
    WF_ENTRY(WFALWAYSSENDNCPAINT),
    WF_ENTRY(WFANSICREATOR),
    WF_ENTRY(WFANSIPROC),
    WF_ENTRY(WFANYHUNGREDRAW),
    WF_ENTRY(WFBEINGACTIVATED),
    WF_ENTRY(WFBORDER),
    WF_ENTRY(WFBOTTOMMOST),
    WF_ENTRY(WFCAPTION),
    WF_ENTRY(WFCEPRESENT),
    WF_ENTRY(WFCHILD),
    WF_ENTRY(WFCLIPCHILDREN),
    WF_ENTRY(WFCLIPSIBLINGS),
    WF_ENTRY(WFCLOSEBUTTONDOWN),
    WF_ENTRY(WFCPRESENT),
    WF_ENTRY(WFDESTROYED),
    WF_ENTRY(WFDIALOGWINDOW),
    WF_ENTRY(WFDISABLED),
    WF_ENTRY(WFDLGFRAME),
    WF_ENTRY(WFDONTVALIDATE),
    WF_ENTRY(WFERASEBKGND),
    WF_ENTRY(WFFRAMEON),
    WF_ENTRY(WFFULLSCREEN),
    WF_ENTRY(WFGOTQUERYSUSPENDMSG),
    WF_ENTRY(WFGOTSUSPENDMSG),
    WF_ENTRY(WFGROUP),
    WF_ENTRY(WFHASPALETTE),
    WF_ENTRY(WFHASSPB),
    WF_ENTRY(WFHELPBUTTONDOWN),
    WF_ENTRY(WFHIDDENPOPUP),
    WF_ENTRY(WFHPRESENT),
    WF_ENTRY(WFHSCROLL),
    WF_ENTRY(WFICONICPOPUP),
    WF_ENTRY(WFINDESTROY),
    WF_ENTRY(WFINTERNALPAINT),
    WF_ENTRY(WFLINEDNBUTTONDOWN),
    WF_ENTRY(WFLINEUPBUTTONDOWN),
    WF_ENTRY(WFMAXBOX),
    WF_ENTRY(WFMAXFAKEREGIONAL),
    WF_ENTRY(WFMAXIMIZED),
    WF_ENTRY(WFMENUDRAW),
    WF_ENTRY(WFMINBOX),
    WF_ENTRY(WFMINIMIZED),
    WF_ENTRY(WFMPRESENT),
    WF_ENTRY(WFMSGBOX),
    WF_ENTRY(WFNOANIMATE),
    WF_ENTRY(WFNOIDLEMSG),
    WF_ENTRY(WFNONCPAINT),
    WF_ENTRY(WFOLDUI),
    WF_ENTRY(WFPAGEUPBUTTONDOWN),
    WF_ENTRY(WFPAGEDNBUTTONDOWN),
    WF_ENTRY(WFPAINTNOTPROCESSED),
    WF_ENTRY(WFPIXIEHACK),
    WF_ENTRY(WFPOPUP),
    WF_ENTRY(WFREALLYMAXIMIZABLE),
    WF_ENTRY(WFREDRAWFRAMEIFHUNG),
    WF_ENTRY(WFREDRAWIFHUNG),
    WF_ENTRY(WFREDUCEBUTTONDOWN),
    WF_ENTRY(WFSCROLLBUTTONDOWN),
    WF_ENTRY(WFSENDERASEBKGND),
    WF_ENTRY(WFSENDNCPAINT),
    WF_ENTRY(WFSENDSIZEMOVE),
    WF_ENTRY(WFSERVERSIDEPROC),
    WF_ENTRY(WFSHELLHOOKWND),
    WF_ENTRY(WFSIZEBOX),
    WF_ENTRY(WFSMQUERYDRAGICON),
    WF_ENTRY(WFSTARTPAINT),
    WF_ENTRY(WFSYNCPAINTPENDING),
    WF_ENTRY(WFSYSMENU),
    WF_ENTRY(WFTABSTOP),
    WF_ENTRY(WFTILED),
    WF_ENTRY(WFTITLESET),
    WF_ENTRY(WFTOGGLETOPMOST),
    WF_ENTRY(WFTOPLEVEL),
    WF_ENTRY(WFUPDATEDIRTY),
    WF_ENTRY(WFVERTSCROLLTRACK),
    WF_ENTRY(WFVISIBLE),
    WF_ENTRY(WFVPRESENT),
    WF_ENTRY(WFVSCROLL),
    WF_ENTRY(WFWIN31COMPAT),
    WF_ENTRY(WFWIN40COMPAT),
    WF_ENTRY(WFWIN50COMPAT),
    WF_ENTRY(WFWMPAINTSENT),
    WF_ENTRY(WFZOOMBUTTONDOWN),
};

CONST PCSTR aszTypeNames[/*TYPE_CTYPES*/] = {
    "Free",
    "Window",
    "Menu",
    "Icon/Cursor",
    "WPI(SWP) struct",
    "Hook",
    "Clipboard Data",
    "CallProcData",
    "Accelerator",
    "DDE access",
    "DDE conv",
    "DDE Transaction",
    "Monitor",
    "Keyboard Layout",
    "Keyboard File",
    "WinEvent hook",
    "Timer",
    "Input Context",
#ifdef GENERIC_INPUT
    "HID Raw Data",
    "DEVICE INFO",
 #ifdef GI_PROCESSOR
    "Pre/PostProcessor",
 #endif
#endif // GENERIC_INPUT
    "unknown",
};

const char * aszHeapTags[] = {
    "Unknown",
    "Class",
    "DesktopInfo",
    "ClientThreadInfo",
    "Text",
    "HandleTable",
    "SBInfo",
    "MenuItem",
    "MenuText",
    "IMEText",
    "PropList",
    NULL,
};

const char * aszHeapSubtags[] = {
    "",
    "Window",
    "Menu",
    "Cursor",
    "SetWindowPos",
    "Hook",
    "ClipData",
    "CallProc",
    "AccelTable",
    "DDEAccess",
    "DDEConve",
    "DDEXact",
    "Monitor",
    "KBDLayout",
    "KBDFile",
    "WinEventHook",
    "Timer",
    "IinputConText",
    "HIDData",
    "DeviceInfo",
    "CTyptes",
    NULL,
};


#include "ptagdbg.h"   // derived from ntuser\kernel\ptag.lst and .\ptagdbg.bat

#define NO_FLAG (LPCSTR)(LONG_PTR)0xFFFFFFFF  // use this for non-meaningful entries.
#define _MASKENUM_START         (NO_FLAG-1)
#define _MASKENUM_END           (NO_FLAG-2)
#define _SHIFT_BITS             (NO_FLAG-3)
#define _CONTINUE_ON            (NO_FLAG-4)

#define MASKENUM_START(mask)    _MASKENUM_START, (LPCSTR)(mask)
#define MASKENUM_END(shift)     _MASKENUM_END, (LPCSTR)(shift)
#define SHIFT_BITS(n)           _SHIFT_BITS, (LPCSTR)(n)
#define CONTINUE_ON(arr)        _CONTINUE_ON, (LPCSTR)(arr)

CONST PCSTR apszSmsFlags[] = {
   "SMF_REPLY"                , // 0x0001
   "SMF_RECEIVERDIED"         , // 0x0002
   "SMF_SENDERDIED"           , // 0x0004
   "SMF_RECEIVERFREE"         , // 0x0008
   "SMF_RECEIVEDMESSAGE"      , // 0x0010
    NO_FLAG                   , // 0x0020
    NO_FLAG                   , // 0x0040
    NO_FLAG                   , // 0x0080
   "SMF_CB_REQUEST"           , // 0x0100
   "SMF_CB_REPLY"             , // 0x0200
   "SMF_CB_CLIENT"            , // 0x0400
   "SMF_CB_SERVER"            , // 0x0800
   "SMF_WOWRECEIVE"           , // 0x1000
   "SMF_WOWSEND"              , // 0x2000
   "SMF_RECEIVERBUSY"         , // 0x4000
    NULL                        // 0x8000
};

CONST PCSTR apszTifFlags[] = {
   "TIF_INCLEANUP"                   , // 0x00000001
   "TIF_16BIT"                       , // 0x00000002
   "TIF_SYSTEMTHREAD"                , // 0x00000004
   "TIF_CSRSSTHREAD"                 , // 0x00000008
   "TIF_TRACKRECTVISIBLE"            , // 0x00000010
   "TIF_ALLOWFOREGROUNDACTIVATE"     , // 0x00000020
   "TIF_DONTATTACHQUEUE"             , // 0x00000040
   "TIF_DONTJOURNALATTACH"           , // 0x00000080
   "TIF_WOW64"                       , // 0x00000100
   "TIF_INACTIVATEAPPMSG"            , // 0x00000200
   "TIF_SPINNING"                    , // 0x00000400
   "TIF_PALETTEAWARE"                , // 0x00000800
   "TIF_SHAREDWOW"                   , // 0x00001000
   "TIF_FIRSTIDLE"                   , // 0x00002000
   "TIF_WAITFORINPUTIDLE"            , // 0x00004000
   "TIF_MOVESIZETRACKING"            , // 0x00008000
   "TIF_VDMAPP"                      , // 0x00010000
   "TIF_DOSEMULATOR"                 , // 0x00020000
   "TIF_GLOBALHOOKER"                , // 0x00040000
   "TIF_DELAYEDEVENT"                , // 0x00080000
   "TIF_MSGPOSCHANGED"               , // 0x00100000
   "TIF_SHUTDOWNCOMPLETE"            , // 0x00200000
   "TIF_IGNOREPLAYBACKDELAY"         , // 0x00400000
   "TIF_ALLOWOTHERACCOUNTHOOK"       , // 0x00800000
   "TIF_GUITHREADINITIALIZED"        , // 0x01000000
   "TIF_DISABLEIME"                  , // 0x02000000
   "TIF_INGETTEXTLENGTH"             , // 0x04000000
   "TIF_ANSILENGTH"                  , // 0x08000000
   "TIF_DISABLEHOOKS"                , // 0x10000000
   "TIF_RESTRICTED"                  , // 0x20000000
   "TIF_QUITPOSTED"                  , // 0x40000000
    NULL                               // no more
};

CONST PCSTR apszQsFlags[] = {
     "QS_KEY"             , //  0x0001
     "QS_MOUSEMOVE"       , //  0x0002
     "QS_MOUSEBUTTON"     , //  0x0004
     "QS_POSTMESSAGE"     , //  0x0008
     "QS_TIMER"           , //  0x0010
     "QS_PAINT"           , //  0x0020
     "QS_SENDMESSAGE"     , //  0x0040
     "QS_HOTKEY"          , //  0x0080
     "QS_ALLPOSTMESSAGE"  , //  0x0100
     "QS_SMSREPLY"        , //  0x0200
     "QS_RAWINPUT"        , //  0x0400
     "QS_THREADATTACHED"  , //  0x0800
     "QS_EXCLUSIVE"       , //  0x1000
     "QS_EVENT"           , //  0x2000
     "QS_TRANSFER"        , //  0X4000
     NULL                   //  0x8000
};

CONST PCSTR apszMfFlags[] = {
    "MF_GRAYED"             , // 0x0001
    "MF_DISABLED"           , // 0x0002
    "MF_BITMAP"             , // 0x0004
    "MF_CHECKED"            , // 0x0008
    "MF_POPUP"              , // 0x0010
    "MF_MENUBARBREAK"       , // 0x0020
    "MF_MENUBREAK"          , // 0x0040
    "MF_HILITE"             , // 0x0080
    "MF_OWNERDRAW"          , // 0x0100
    "MF_USECHECKBITMAPS"    , // 0x0200
    NO_FLAG                 , // 0x0400
    "MF_SEPARATOR"          , // 0x0800
    "MF_DEFAULT"            , // 0x1000
    "MF_SYSMENU"            , // 0x2000
    "MF_RIGHTJUSTIFY"       , // 0x4000
    "MF_MOUSESELECT"        , // 0x8000
     NULL
};

CONST PCSTR apszCsfFlags[] = {
    "CSF_SERVERSIDEPROC"      , // 0x0001
    "CSF_ANSIPROC"            , // 0x0002
    "CSF_WOWDEFERDESTROY"     , // 0x0004
    "CSF_SYSTEMCLASS"         , // 0x0008
    "CSF_WOWCLASS"            , // 0x0010
    "CSF_WOWEXTRA"            , // 0x0020
    "CSF_CACHEDSMICON"        , // 0x0040
    "CSF_WIN40COMPAT"         , // 0x0080
    "CSF_VERSIONCLASS"        , // 0x0100
    NULL                        //
};

CONST PCSTR apszCsFlags[] = {
    "CS_VREDRAW"          , // 0x0001
    "CS_HREDRAW"          , // 0x0002
    "CS_KEYCVTWINDOW"     , // 0x0004
    "CS_DBLCLKS"          , // 0x0008
    NO_FLAG               , // 0x0010
    "CS_OWNDC"            , // 0x0020
    "CS_CLASSDC"          , // 0x0040
    "CS_PARENTDC"         , // 0x0080
    "CS_NOKEYCVT"         , // 0x0100
    "CS_NOCLOSE"          , // 0x0200
    NO_FLAG               , // 0x0400
    "CS_SAVEBITS"         , // 0x0800
    "CS_BYTEALIGNCLIENT"  , // 0x1000
    "CS_BYTEALIGNWINDOW"  , // 0x2000
    "CS_GLOBALCLASS"      , // 0x4000
    NO_FLAG               , // 0x8000
    "CS_IME"              , // 0x10000
    "CS_DROPSHADOW"       , // 0x20000
    NULL                    // no more
};

CONST PCSTR apszQfFlags[] = {
    "QF_UPDATEKEYSTATE"         , // 0x0000001
    "used to be ALTTAB"         , // 0x0000002
    "QF_FMENUSTATUSBREAK"       , // 0x0000004
    "QF_FMENUSTATUS"            , // 0x0000008
    "QF_FF10STATUS"             , // 0x0000010
    "QF_MOUSEMOVED"             , // 0x0000020
    "QF_ACTIVATIONCHANGE"       , // 0x0000040
    "QF_TABSWITCHING"           , // 0x0000080
    "QF_KEYSTATERESET"          , // 0x0000100
    "QF_INDESTROY"              , // 0x0000200
    "QF_LOCKNOREMOVE"           , // 0x0000400
    "QF_FOCUSNULLSINCEACTIVE"   , // 0x0000800
    NO_FLAG                     , // 0x0001000
    NO_FLAG                     , // 0x0002000
    "QF_DIALOGACTIVE"           , // 0x0004000
    "QF_EVENTDEACTIVATEREMOVED" , // 0x0008000
    NO_FLAG                     , // 0x0010000
    "QF_TRACKMOUSELEAVE"        , // 0x0020000
    "QF_TRACKMOUSEHOVER"        , // 0x0040000
    "QF_TRACKMOUSEFIRING"       , // 0x0080000
    "QF_CAPTURELOCKED"          , // 0x00100000
    "QF_ACTIVEWNDTRACKING"      , // 0x00200000
    NULL
};

CONST PCSTR apszW32pfFlags[] = {
    "W32PF_CONSOLEAPPLICATION"       , // 0x00000001
    "W32PF_FORCEOFFFEEDBACK"         , // 0x00000002
    "W32PF_STARTGLASS"               , // 0x00000004
    "W32PF_WOW"                      , // 0x00000008
    "W32PF_READSCREENACCESSGRANTED"  , // 0x00000010
    "W32PF_INITIALIZED"              , // 0x00000020
    "W32PF_APPSTARTING"              , // 0x00000040
    "W32PF_WOW64"                    , // 0x00000080
    "W32PF_ALLOWFOREGROUNDACTIVATE"  , // 0x00000100
    "W32PF_OWNDCCLEANUP"             , // 0x00000200
    "W32PF_SHOWSTARTGLASSCALLED"     , // 0x00000400
    "W32PF_FORCEBACKGROUNDPRIORITY"  , // 0x00000800
    "W32PF_TERMINATED"               , // 0x00001000
    "W32PF_CLASSESREGISTERED"        , // 0x00002000
    "W32PF_THREADCONNECTED"          , // 0x00004000
    "W32PF_PROCESSCONNECTED"         , // 0x00008000
    "W32PF_WAKEWOWEXEC"              , // 0x00010000
    "W32PF_WAITFORINPUTIDLE"         , // 0x00020000
    "W32PF_IOWINSTA"                 , // 0x00040000
    "W32PF_ALLOWSETFOREGROUND"       , // 0x00080000
    "W32PF_OLELOADED"                , // 0x00100000
    "W32PF_SCREENSAVER"              , // 0x00200000
    "W32PF_IDLESCREENSAVER"          , // 0x00400000
    "W32PF_DISABLEIME"               , // 0x00800000
    "W32PF_SETUPAPP"                 , // 0x01000000
    "W32PF_RESTRICTED"               , // 0x02000000
    "W32PF_CONSOLEHASFOCUS"          , // 0x04000000
    "W32PF_DISABLEWINDOWSGHOSTING"   , // 0x08000000
    NULL
};


CONST PCSTR apszHeFlags[] = {
   "HANDLEF_DESTROY"               , // 0x0001
   "HANDLEF_INDESTROY"             , // 0x0002
   "HANDLEF_INWAITFORDEATH"        , // 0x0004
   "HANDLEF_FINALDESTROY"          , // 0x0008
   "HANDLEF_MARKED_OK"             , // 0x0010
   "HANDLEF_GRANTED"               , // 0x0020
   "HANDLEF_POOL"                  , // 0x0040
   NULL,
};


CONST PCSTR apszHdataFlags[] = {
     "HDATA_APPOWNED"          , // 0x0001
     NO_FLAG                   , // 0x0002
     NO_FLAG                   , // 0x0004
     NO_FLAG                   , // 0x0008
     NO_FLAG                   , // 0x0010
     NO_FLAG                   , // 0x0020
     NO_FLAG                   , // 0x0040
     NO_FLAG                   , // 0x0080
     "HDATA_EXECUTE"           , // 0x0100
     "HDATA_INITIALIZED"       , // 0x0200
     NO_FLAG                   , // 0x0400
     NO_FLAG                   , // 0x0800
     NO_FLAG                   , // 0x1000
     NO_FLAG                   , // 0x2000
     "HDATA_NOAPPFREE"         , // 0x4000
     "HDATA_READONLY"          , // 0x8000
     NULL
};

CONST PCSTR apszXiFlags[] = {
     "XIF_SYNCHRONOUS"    , // 0x0001
     "XIF_COMPLETE"       , // 0x0002
     "XIF_ABANDONED"      , // 0x0004
     NULL
};

CONST PCSTR apszIifFlags[] = {
     "IIF_IN_SYNC_XACT"   , // 0x0001
     NO_FLAG              , // 0x0002
     NO_FLAG              , // 0x0004
     NO_FLAG              , // 0x0008
     NO_FLAG              , // 0x0010
     NO_FLAG              , // 0x0020
     NO_FLAG              , // 0x0040
     NO_FLAG              , // 0x0080
     NO_FLAG              , // 0x0100
     NO_FLAG              , // 0x0200
     NO_FLAG              , // 0x0400
     NO_FLAG              , // 0x0800
     NO_FLAG              , // 0x1000
     NO_FLAG              , // 0x2000
     NO_FLAG              , // 0x4000
     "IIF_UNICODE"        , // 0x8000
     NULL
};

CONST PCSTR apszTmrfFlags[] = {
     "TMRF_READY"         , // 0x0001
     "TMRF_SYSTEM"        , // 0x0002
     "TMRF_RIT"           , // 0x0004
     "TMRF_INIT"          , // 0x0008
     "TMRF_ONESHOT"       , // 0x0010
     "TMRF_WAITING"       , // 0x0020
     "TMRF_PTIWINDOW"     , // 0x0040
     NULL                 , // 0x0080
};


CONST PCSTR apszSbFlags[] = {
    "SB_VERT"             , // 0x0001
    "SB_CTL"              , // 0x0002
     NULL                 , // 0x0004
};


CONST PCSTR apszCSFlags[] = {
    "FS_LATIN1"           , // 0x00000001L
    "FS_LATIN2"           , // 0x00000002L
    "FS_CYRILLIC"         , // 0x00000004L
    "FS_GREEK"            , // 0x00000008L
    "FS_TURKISH"          , // 0x00000010L
    "FS_HEBREW"           , // 0x00000020L
    "FS_ARABIC"           , // 0x00000040L
    "FS_BALTIC"           , // 0x00000080L
    "FS_VIETNAMESE"       , // 0x00000100L
     NO_FLAG              , // 0x00000200L
     NO_FLAG              , // 0x00000400L
     NO_FLAG              , // 0x00000800L
     NO_FLAG              , // 0x00001000L
     NO_FLAG              , // 0x00002000L
     NO_FLAG              , // 0x00004000L
     NO_FLAG              , // 0x00008000L
    "FS_THAI"             , // 0x00010000L
    "FS_JISJAPAN"         , // 0x00020000L
    "FS_CHINESESIMP"      , // 0x00040000L
    "FS_WANSUNG"          , // 0x00080000L
    "FS_CHINESETRAD"      , // 0x00100000L
    "FS_JOHAB"            , // 0x00200000L
     NO_FLAG              , // 0x00400000L
     NO_FLAG              , // 0x00800000L
     NO_FLAG              , // 0x01000000L
     NO_FLAG              , // 0x02000000L
     NO_FLAG              , // 0x04000000L
     NO_FLAG              , // 0x08000000L
     NO_FLAG              , // 0x10000000L
     NO_FLAG              , // 0x20000000L
     NO_FLAG              , // 0x40000000L
    "FS_SYMBOL"           , // 0x80000000L
    NULL
};


CONST PCSTR apszMenuTypeFlags[] = {
    NO_FLAG               , // 0x0001
    NO_FLAG               , // 0x0002
    "MFT_BITMAP"          , // 0x0004 MF_BITMAP
    NO_FLAG               , // 0x0008
    "MF_POPUP"            , // 0x0010
    "MFT_MENUBARBREAK"    , // 0x0020 MF_MENUBARBREAK
    "MFT_MENUBREAK"       , // 0x0040 MF_MENUBREAK
    NO_FLAG               , // 0x0080
    "MFT_OWNERDRAW"       , // 0x0100 MF_OWNERDRAW
    NO_FLAG               , // 0x0200
    NO_FLAG               , // 0x0400
    "MFT_SEPARATOR"       , // 0x0800 MF_SEPARATOR
    NO_FLAG               , // 0x1000
    "MF_SYSMENU"          , // 0x2000
    "MFT_RIGHTJUSTIFY"    , // 0x4000 MF_RIGHTJUSTIFY
    NULL
};

CONST PCSTR apszMenuStateFlags[] = {
    "MF_GRAYED"           , // 0x0001
    "MF_DISABLED"         , // 0x0002
    NO_FLAG               , // 0x0004
    "MFS_CHECKED"         , // 0x0008 MF_CHECKED
    NO_FLAG               , // 0x0010
    NO_FLAG               , // 0x0020
    NO_FLAG               , // 0x0040
    "MFS_HILITE"          , // 0x0080 MF_HILITE
    NO_FLAG               , // 0x0100
    NO_FLAG               , // 0x0200
    NO_FLAG               , // 0x0400
    NO_FLAG               , // 0x0800
    "MFS_DEFAULT"         , // 0x1000 MF_DEFAULT
    NO_FLAG               , // 0x2000
    NO_FLAG               , // 0x4000
    "MF_MOUSESELECT"      , // 0x8000
    NULL
};


CONST PCSTR apszCursorfFlags[] = {
    "CURSORF_FROMRESOURCE", //    0x0001
    "CURSORF_GLOBAL",       //    0x0002
    "CURSORF_LRSHARED",     //    0x0004
    "CURSORF_ACON",         //    0x0008
    "CURSORF_WOWCLEANUP"  , //    0x0010
    NO_FLAG               , //    0x0020
    "CURSORF_ACONFRAME",    //    0x0040
    "CURSORF_SECRET",       //    0x0080
    "CURSORF_LINKED",       //    0x0100
    "CURSORF_SYSTEM",       //    0x0200
    "CURSORF_SHADOW",       //    0x0400
    NULL
};

CONST PCSTR apszMonfFlags[] = {
    "MONF_VISIBLE",         // 0x01
    "MONF_PALETTEDISPLAY",  // 0x02
    NULL,
};

CONST PCSTR apszSifFlags[] = {
    "PUSIF_PALETTEDISPLAY",         // 0x00000001
    "PUSIF_SNAPTO",                 // 0x00000002
    "PUSIF_COMBOBOXANIMATION",      // 0x00000004
    "PUSIF_LISTBOXSMOOTHSCROLLING", // 0x00000008
    NO_FLAG,                        // 0x00000010
    "PUSIF_KEYBOARDCUES",           // 0x00000020
    NO_FLAG,                        // 0x00000040
    NO_FLAG,                        // 0x00000080
    NO_FLAG,                        // 0x00000100
    NO_FLAG,                        // 0x00000200
    NO_FLAG,                        // 0x00000400
    NO_FLAG,                        // 0x00000800
    NO_FLAG,                        // 0x00001000
    NO_FLAG,                        // 0x00002000
    NO_FLAG,                        // 0x00004000
    NO_FLAG,                        // 0x00008000
    NO_FLAG,                        // 0x00010000
    NO_FLAG,                        // 0x00020000
    NO_FLAG,                        // 0x00040000
    NO_FLAG,                        // 0x00080000
    NO_FLAG,                        // 0x00100000
    NO_FLAG,                        // 0x00200000
    NO_FLAG,                        // 0x00400000
    NO_FLAG,                        // 0x00800000
    NO_FLAG,                        // 0x01000000
    NO_FLAG,                        // 0x02000000
    NO_FLAG,                        // 0x04000000
    NO_FLAG,                        // 0x08000000
    NO_FLAG,                        // 0x10000000
    NO_FLAG,                        // 0x20000000
    NO_FLAG,                        // 0x40000000
    "PUSIF_UIEFFECTS",              // 0x80000000
    NULL,
};

CONST PCSTR apszRipFlags[] = {
    "RIPF_PROMPTONERROR",   // 0x0001
    "RIPF_PROMPTONWARNING", // 0x0002
    "RIPF_PROMPTONVERBOSE", // 0x0004
    NO_FLAG,                // 0x0008
    "RIPF_PRINTONERROR",    // 0x0010
    "RIPF_PRINTONWARNING",  // 0x0020
    "RIPF_PRINTONVERBOSE",  // 0x0040
    NO_FLAG,                // 0x0080
    "RIPF_PRINTFILELINE",   // 0x0100
    NULL
};

CONST PCSTR apszSRVIFlags[] = {
    "SRVIF_CHECKED",                // 0x0001
    "SRVIF_LOGDESKTOPHEAPFAILURE",  // 0x0002
    "SRVIF_DBCS",                   // 0x0004
    "SRVIF_IME",                    // 0x0008
    "SRVIF_MIDEAST",                // 0x0010
    "SRVIF_HOOKED",                 // 0x0020
    "SRVIF_CICERO",                 // 0x0040
    NULL
};

CONST PCSTR apszPROPFlags[] = {
    "PROPF_INTERNAL",       // 0x0001
    "PROPF_STRING",         // 0x0002
    "PROPF_NOPOOL",         // 0x0004
};

CONST PCSTR apszLpkEntryPoints[] = {
    "LpkTabbedTextOut"    , // 0x00000001L
    "LpkPSMTextOut"       , // 0x00000002L
    "LpkDrawTextEx"       , // 0x00000004L
    "LpkEditControl"      , // 0x00000008L
    NULL
};

/*
 * We need one of these per DWORD
 */
CONST PCSTR aszUserPreferencesMask0[sizeof(DWORD) * 8] = {
    "ACTIVEWINDOWTRACKING",     /*    0x1000 */
    "MENUANIMATION",            /*    0x1002 */
    "COMBOBOXANIMATION",        /*    0x1004 */
    "LISTBOXSMOOTHSCROLLING",   /*    0x1006 */
    "GRADIENTCAPTIONS",         /*    0x1008 */
    "KEYBOARDCUES",             /*    0x100A */
    "ACTIVEWNDTRKZORDER",       /*    0x100C */
    "HOTTRACKING",              /*    0x100E */
    NO_FLAG,                    /*    0x1010 */
    "MENUFADE",                 /*    0x1012 */
    "SELECTIONFADE",            /*    0x1014 */
    "TOOLTIPANIMATION",         /*    0x1016 */
    "TOOLTIPFADE",              /*    0x1018 */
    "CURSORSHADOW",             /*    0x101A */
    NO_FLAG,                    /*    0x101C */
    NO_FLAG,                    /*    0x101E */
    NO_FLAG,                    /*    0x1020 */
    NO_FLAG,                    /*    0x1022 */
    NO_FLAG,                    /*    0x1024 */
    NO_FLAG,                    /*    0x1026 */
    NO_FLAG,                    /*    0x1028 */
    NO_FLAG,                    /*    0x102A */
    NO_FLAG,                    /*    0x102C */
    NO_FLAG,                    /*    0x102E */
    NO_FLAG,                    /*    0x1030 */
    NO_FLAG,                    /*    0x1032 */
    NO_FLAG,                    /*    0x1034 */
    NO_FLAG,                    /*    0x1036 */
    NO_FLAG,                    /*    0x1038 */
    NO_FLAG,                    /*    0x103A */
    NO_FLAG,                    /*    0x103C */
    "UIEFFECTS",                /*    0x103E */
};

CONST PCSTR aszUserPreferences[SPI_DWORDRANGECOUNT] = {
    "FOREGROUNDLOCKTIMEOUT",    /*    0x2000 */
    "ACTIVEWNDTRKTIMEOUT",      /*    0x2002 */
    "FOREGROUNDFLASHCOUNT",     /*    0x2004 */
    "CARETWIDTH",               /*    0x2006 */
};

CONST PCSTR aszKeyEventFlags[] = {
    "KEYEVENTF_EXTENDEDKEY",    // 0x0001
    "KEYEVENTF_KEYUP",          // 0x0002
    "KEYEVENTF_UNICODE",        // 0x0004
    "KEYEVENTF_SCANCODE",       // 0x0008
    NULL,
};

CONST PCSTR aszMouseEventFlags[] = {
    "MOUSEEVENTF_MOVE",         // 0x0001
    "MOUSEEVENTF_LEFTDOWN",     // 0x0002
    "MOUSEEVENTF_LEFTUP",       // 0x0004
    "MOUSEEVENTF_RIGHTDOWN",    // 0x0008
    "MOUSEEVENTF_RIGHTUP",      // 0x0010
    "MOUSEEVENTF_MIDDLEDOWN",   // 0x0020
    "MOUSEEVENTF_MIDDLEUP",     // 0x0040
    NO_FLAG,                    // 0x0080
    NO_FLAG,                    // 0x0100
    NO_FLAG,                    // 0x0200
    NO_FLAG,                    // 0x0400
    "MOUSEEVENTF_WHEEL",        // 0x0800
    NO_FLAG,                    // 0x1000
    NO_FLAG,                    // 0x2000
    "MOUSEEVENTF_VIRTUALDESK",  // 0x4000
    "MOUSEEVENTF_ABSOLUTE",     // 0x8000
    NULL,
};

const char* aszWindowStyle[] = {
    NO_FLAG,                    // 0x00000001
    NO_FLAG,                    // 0x00000002
    NO_FLAG,                    // 0x00000004
    NO_FLAG,                    // 0x00000008
    NO_FLAG,                    // 0x00000010
    NO_FLAG,                    // 0x00000020
    NO_FLAG,                    // 0x00000040
    NO_FLAG,                    // 0x00000080
    NO_FLAG,                    // 0x00000100
    NO_FLAG,                    // 0x00000200
    NO_FLAG,                    // 0x00000400
    NO_FLAG,                    // 0x00000800
    NO_FLAG,                    // 0x00001000
    NO_FLAG,                    // 0x00002000
    NO_FLAG,                    // 0x00004000
    NO_FLAG,                    // 0x00008000
    "WS_TABSTOP",               // 0x00010000
    "WS_GROUP",                 // 0x00020000
    "WS_THICKFRAME",            // 0x00040000
    "WS_SYSMENU",               // 0x00080000
    "WS_HSCROLL",               // 0x00100000
    "WS_VSCROLL",               // 0x00200000
    "WS_DLGFRAME",              // 0x00400000
    "WS_BORDER",                // 0x00800000
    "WS_MAXIMIZE",              // 0x01000000
    "WS_CLIPCHILDREN",          // 0x02000000
    "WS_CLIPSIBLINGS",          // 0x04000000
    "WS_DISABLED",              // 0x08000000
    "WS_VISIBLE",               // 0x10000000
    "WS_MINIMIZE",              // 0x20000000
    "WS_CHILD",                 // 0x40000000
    "WS_POPUP",                 // 0x80000000
    NULL,
};

const char* aszDialogStyle[] = {
    "DS_ABSALIGN",              // 0x00000001
    "DS_SYSMODAL",              // 0x00000002
    "DS_3DLOOK",                // 0x00000004
    "DS_FIXEDSYS",              // 0x00000008
    "DS_NOFAILCREATE",          // 0x00000010
    "DS_LOCALEDIT",             // 0x00000020
    "DS_SETFONT",               // 0x00000040
    "DS_MODALFRAME",            // 0x00000080
    "DS_NOIDLEMSG",             // 0x00000100
    "DS_SETFOREGROUND",         // 0x00000200
    "DS_CONTROL",               // 0x00000400
    "DS_CENTER",                // 0x00000800
    "DS_CENTERMOUSE",           // 0x00001000
    "DS_CONTEXTHELP",           // 0x00002000
    NO_FLAG,                    // 0x00004000
    NO_FLAG,                    // 0x00008000

    CONTINUE_ON(aszWindowStyle + 16),
};


const char* aszButtonStyle[] = {
    MASKENUM_START(BS_TYPEMASK),
    "BS_PUSHBUTTON",            // 0
    "BS_DEFPUSHBUTTON",         // 1
    "BS_CHECKBOX",              // 2
    "BS_AUTOCHECKBOX",          // 3
    "BS_RADIOBUTTON",           // 4
    "BS_3STATE",                // 5
    "BS_AUTO3STATE",            // 6
    "BS_GROUPBOX",              // 7
    "BS_USERBUTTON",            // 8
    "BS_AUTORADIOBUTTON",       // 9
    "BS_PUSHBOX",               // a
    "BS_OWNERDRAW",             // b
    MASKENUM_END(4),

    NO_FLAG,                    // 0x00000010
    "BS_LEFTTEXT",              // 0x00000020

    MASKENUM_START(BS_IMAGEMASK),
    "BS_TEXT",                  // 0
    "BS_ICON",
    "BS_BITMAP",
    MASKENUM_END(2),

    MASKENUM_START(BS_HORZMASK),
    NO_FLAG,
    "BS_LEFT",
    "BS_RIGHT",
    "BS_CENTER",
    MASKENUM_END(2),

    MASKENUM_START(BS_VERTMASK),
    NO_FLAG,
    "BS_TOP", "BS_BOTTOM", "BS_VCENTER",
    MASKENUM_END(2),

    "BS_PUSHLIKE",              // 0x00001000
    "BS_MULTILINE",             // 0x00002000
    "BS_NOTIFY",                // 0x00004000
    "BS_FLAT",                  // 0x00008000

    CONTINUE_ON(aszWindowStyle + 16),
};

const char* aszComboBoxStyle[] = {
    MASKENUM_START(0x0f),
    NO_FLAG,                    // 0
    "CBS_SIMPLE",               // 1
    "CBS_DROPDOWN",             // 2
    "CBS_DROPDOWNLIST",         // 3
    MASKENUM_END(4),

    "CBS_OWNERDRAWFIXED",       // 0x0010L
    "CBS_OWNERDRAWVARIABLE",    // 0x0020L
    "CBS_AUTOHSCROLL",          // 0x0040L
    "CBS_OEMCONVERT",           // 0x0080L
    "CBS_SORT",                 // 0x0100L
    "CBS_HASSTRINGS",           // 0x0200L
    "CBS_NOINTEGRALHEIGHT",     // 0x0400L
    "CBS_DISABLENOSCROLL",      // 0x0800L
    NO_FLAG,                    // 0x1000L
    "CBS_UPPERCASE",            // 0x2000L
    "CBS_LOWERCASE",            // 0x4000L
    NO_FLAG,                    // 0x8000L

    CONTINUE_ON(aszWindowStyle + 16),
};

const char* aszStaticStyle[] = {
    MASKENUM_START(SS_TYPEMASK),
    "SS_LEFT",              // 0x00000000L
    "SS_CENTER",            // 0x00000001L
    "SS_RIGHT",             // 0x00000002L
    "SS_ICON",              // 0x00000003L
    "SS_BLACKRECT",         // 0x00000004L
    "SS_GRAYRECT",          // 0x00000005L
    "SS_WHITERECT",         // 0x00000006L
    "SS_BLACKFRAME",        // 0x00000007L
    "SS_GRAYFRAME",         // 0x00000008L
    "SS_WHITEFRAME",        // 0x00000009L
    "SS_USERITEM",          // 0x0000000AL
    "SS_SIMPLE",            // 0x0000000BL
    "SS_LEFTNOWORDWRAP",    // 0x0000000CL
    "SS_OWNERDRAW",         // 0x0000000DL
    "SS_BITMAP",            // 0x0000000EL
    "SS_ENHMETAFILE",       // 0x0000000FL
    "SS_ETCHEDHORZ",        // 0x00000010L
    "SS_ETCHEDVERT",        // 0x00000011L
    "SS_ETCHEDFRAME",       // 0x00000012L
    MASKENUM_END(5),

    NO_FLAG,                // 0x00000020L
    "SS_REALSIZECONTROL",   // 0x00000040L
    "SS_NOPREFIX",          // 0x00000080L /* Don't do "&" character translation */
    "SS_NOTIFY",            // 0x00000100L
    "SS_CENTERIMAGE",       // 0x00000200L
    "SS_RIGHTJUST",         // 0x00000400L
    "SS_REALSIZEIMAGE",     // 0x00000800L
    "SS_SUNKEN",            // 0x00001000L
    "SS_EDITCONTROL",       // 0x00002000L ;internal

    MASKENUM_START(SS_ELLIPSISMASK),
    NO_FLAG,
    "SS_ENDELLIPSIS",       // 0x00004000L
    "SS_PATHELLIPSIS",      // 0x00008000L
    "SS_WORDELLIPSIS",      // 0x0000C000L
    MASKENUM_END(2),

    CONTINUE_ON(aszWindowStyle + 16),
};

const char* aszListBoxStyle[] = {
    "LBS_NOTIFY",               // 0x0001L
    "LBS_SORT",                 // 0x0002L
    "LBS_NOREDRAW",             // 0x0004L
    "LBS_MULTIPLESEL",          // 0x0008L
    "LBS_OWNERDRAWFIXED",       // 0x0010L
    "LBS_OWNERDRAWVARIABLE",    // 0x0020L
    "LBS_HASSTRINGS",           // 0x0040L
    "LBS_USETABSTOPS",          // 0x0080L
    "LBS_NOINTEGRALHEIGHT",     // 0x0100L
    "LBS_MULTICOLUMN",          // 0x0200L
    "LBS_WANTKEYBOARDINPUT",    // 0x0400L
    "LBS_EXTENDEDSEL",          // 0x0800L
    "LBS_DISABLENOSCROLL",      // 0x1000L
    "LBS_NODATA",               // 0x2000L
    "LBS_NOSEL",                // 0x4000L
    NO_FLAG,                    // 0x8000L

    CONTINUE_ON(aszWindowStyle + 16),
};

const char* aszEditStyle[] = {
    MASKENUM_START(ES_FMTMASK),
    "ES_LEFT",              // 0x0000L
    "ES_CENTER",            // 0x0001L
    "ES_RIGHT",             // 0x0002L
    MASKENUM_END(2),

    "ES_MULTILINE",         // 0x0004L
    "ES_UPPERCASE",         // 0x0008L
    "ES_LOWERCASE",         // 0x0010L
    "ES_PASSWORD",          // 0x0020L
    "ES_AUTOVSCROLL",       // 0x0040L
    "ES_AUTOHSCROLL",       // 0x0080L
    "ES_NOHIDESEL",         // 0x0100L
    "ES_COMBOBOX",          // 0x0200L     ;internal
    "ES_OEMCONVERT",        // 0x0400L
    "ES_READONLY",          // 0x0800L
    "ES_WANTRETURN",        // 0x1000L
    "ES_NUMBER",            // 0x2000L     ;public_winver_400
    NO_FLAG,                // 0x4000L
    NO_FLAG,                // 0x8000L

    CONTINUE_ON(aszWindowStyle + 16),
};

const char* aszScrollBarStyle[] = {
    "SBS_HORZ",                     // 0x0000L
    "SBS_VERT",                     // 0x0001L
    "SBS_TOPALIGN",                 // 0x0002L
    "SBS_LEFTALIGN",                // 0x0002L
    "SBS_BOTTOMALIGN",              // 0x0004L
    "SBS_RIGHTALIGN",               // 0x0004L
    "SBS_SIZEBOXTOPLEFTALIGN",      // 0x0002L
    "SBS_SIZEBOXBOTTOMRIGHTALIGN",  // 0x0004L
    "SBS_SIZEBOX",                  // 0x0008L
    "SBS_SIZEGRIP",                 // 0x0010L
    SHIFT_BITS(8),                  // 8 bits

    CONTINUE_ON(aszWindowStyle + 16),
};

const char* aszWindowExStyle[] = {
    "WS_EX_DLGMODALFRAME",      // 0x00000001L
    "WS_EX_DRAGOBJECT",         // 0x00000002L  ;internal
    "WS_EX_NOPARENTNOTIFY",     // 0x00000004L
    "WS_EX_TOPMOST",            // 0x00000008L
    "WS_EX_ACCEPTFILES",        // 0x00000010L
    "WS_EX_TRANSPARENT",        // 0x00000020L
    "WS_EX_MDICHILD",           // 0x00000040L
    "WS_EX_TOOLWINDOW",         // 0x00000080L
    "WS_EX_WINDOWEDGE",         // 0x00000100L
    "WS_EX_CLIENTEDGE",         // 0x00000200L
    "WS_EX_CONTEXTHELP",        // 0x00000400L
    NO_FLAG,                    // 0x00000800L

    "WS_EX_RIGHT",              // 0x00001000L
//  "WS_EX_LEFT",               // 0x00000000L
    "WS_EX_RTLREADING",         // 0x00002000L
//  "WS_EX_LTRREADING",         // 0x00000000L
    "WS_EX_LEFTSCROLLBAR",      // 0x00004000L
//  "WS_EX_RIGHTSCROLLBAR",     // 0x00000000L
    NO_FLAG,                    // 0x00008000L

    "WS_EX_CONTROLPARENT",      // 0x00010000L
    "WS_EX_STATICEDGE",         // 0x00020000L
    "WS_EX_APPWINDOW",          // 0x00040000L
    "WS_EX_LAYERED",            // 0x00080000
    NULL
};

const char* aszClientImcFlags[] = {
    "IMCF_UNICODE",         // 0x0001
    "IMCF_ACTIVE",          // 0x0002
    "IMCF_CHGMSG",          // 0x0004
    "IMCF_SAVECTRL",        // 0x0008
    "IMCF_PROCESSEVENT",    // 0x0010
    "IMCF_FIRSTSELECT",     // 0x0020
    "IMCF_INDESTROY",       // 0x0040
    "IMCF_WINNLSDISABLE",   // 0x0080
    "IMCF_DEFAULTIMC",      // 0x0100
    NULL,
};

const char* aszConversionModes[] = {
    "IME_CMODE_NATIVE",                 // 0x0001
    "IME_CMODE_KATAKANA",               // 0x0002  // only effect under IME_CMODE_NATIVE
    NO_FLAG,                            // 0x0004
    "IME_CMODE_FULLSHAPE",              // 0x0008
    "IME_CMODE_ROMAN",                  // 0x0010
    "IME_CMODE_CHARCODE",               // 0x0020
    "IME_CMODE_HANJACONVERT",           // 0x0040
    "IME_CMODE_SOFTKBD",                // 0x0080
    "IME_CMODE_NOCONVERSION",           // 0x0100
    "IME_CMODE_EUDC",                   // 0x0200
    "IME_CMODE_SYMBOL",                 // 0x0400
    "IME_CMODE_FIXED",                  // 0x0800
    NULL
};

const char* aszSentenceModes[] = {
    "IME_SMODE_PLAURALCLAUSE",          // 0x0001
    "IME_SMODE_SINGLECONVERT",          // 0x0002
    "IME_SMODE_AUTOMATIC",              // 0x0004
    "IME_SMODE_PHRASEPREDICT",          // 0x0008
    "IME_SMODE_CONVERSATION",           // 0x0010
    NULL
};

const char* aszImeInit[] = {
    "INIT_STATUSWNDPOS",            // 0x00000001
    "INIT_CONVERSION",              // 0x00000002
    "INIT_SENTENCE",                // 0x00000004
    "INIT_LOGFONT",                 // 0x00000008
    "INIT_COMPFORM",                // 0x00000010
    "INIT_SOFTKBDPOS",              // 0x00000020
    NULL
};

const char* aszImeSentenceMode[] = {
    "IME_SMODE_PLAURALCLAUSE",      // 0x0001
    "IME_SMODE_SINGLECONVERT",      // 0x0002
    "IME_SMODE_AUTOMATIC",          // 0x0004
    "IME_SMODE_PHRASEPREDICT",      // 0x0008
    "IME_SMODE_CONVERSATION",       // 0x0010
    NULL
};

const char* aszImeConversionMode[] = {
    "IME_CMODE_NATIVE",             // 0x0001
    "IME_CMODE_KATAKANA",           // 0x0002  // only effect under IME_CMODE_NATIVE
    NO_FLAG,
    "IME_CMODE_FULLSHAPE",          // 0x0008
    "IME_CMODE_ROMAN",              // 0x0010
    "IME_CMODE_CHARCODE",           // 0x0020
    "IME_CMODE_HANJACONVERT",       // 0x0040
    "IME_CMODE_SOFTKBD",            // 0x0080
    "IME_CMODE_NOCONVERSION",       // 0x0100
    "IME_CMODE_EUDC",               // 0x0200
    "IME_CMODE_SYMBOL",             // 0x0400
    "IME_CMODE_FIXED",              // 0x0800
    NULL
};

const char* aszImeDirtyFlags[] = {
    "IMSS_UPDATE_OPEN",             // 0x0001
    "IMSS_UPDATE_CONVERSION",       // 0x0002
    "IMSS_UPDATE_SENTENCE",         // 0x0004
    NO_FLAG,                        // 0x0008
    NO_FLAG,                        // 0x0010
    NO_FLAG,                        // 0x0020
    NO_FLAG,                        // 0x0040
    NO_FLAG,                        // 0x0080
    "IMSS_INIT_OPEN",               // 0x0100
    NULL
};

const char* aszImeCompFormFlags[] = {
//  "CFS_DEFAULT",                  // 0x0000
    "CFS_RECT",                     // 0x0001
    "CFS_POINT",                    // 0x0002
    "CFS_SCREEN",                   // 0x0004          @Internal
    "CFS_VERTICAL",                 // 0x0008          @Internal
    "CFS_HIDDEN",                   // 0x0010          @Internal
    "CFS_FORCE_POSITION",           // 0x0020
    "CFS_CANDIDATEPOS",             // 0x0040
    "CFS_EXCLUDE",                  // 0x0080
    NULL
};


const char* aszEdUndoType[] = {
    "UNDO_INSERT",                  // 0x0001
    "UNDO_DELETE",                  // 0x0002
    NULL,
};

const char* aszDeviceInfoActionFlags[] = {
    "GDIAF_ARRIVED",                // 0x0001
    "GDIAF_QUERYREMOVE",            // 0x0002
    "GDIAF_REMOVECANCELLED",        // 0x0004
    "GDIAF_DEPARTED",               // 0x0008
    "GDIAF_IME_STATUS",             // 0x0010
    "GDIAF_REFRESH_MOUSE",          // 0x0020
    NO_FLAG,                        // 0x0040
    "GDIAF_FREEME",                 // 0x0080
    "GDIAF_PNPWAITING",             // 0x0100
    "GDIAF_RETRYREAD",              // 0x0200
    "GDIAF_RECONNECT",              // 0x0400
    "GDIAF_STARTREAD",              // 0x0800   // the device needs to be started
    "GDIAF_STOPREAD",               // 0x1000   // the device needs to be stopped
    NULL,
};

const char* aszHidProcessMask[] = {
    "TRIM_RAWMOUSE",                // 0x0001
    "TRIM_RAWKEYBOARD",             // 0x0002
    "TRIM_NOLEGACYMOUSE",           // 0x0004
    "TRIM_NOLEGACYKEYBOARD",        // 0x0008
    NULL,
};

const char* aszHookFlags[] = {
    "HF_GLOBAL",                    // 0x0001
    "HF_ANSI",                      // 0x0002
    "HF_NEEDHC_SKIP",               // 0x0004
    "HF_HUNG",                      // 0x0008      // Hook Proc hung don't call if system
    "HF_HOOKFAULTED",               // 0x0010      // Hook Proc faulted
    "HF_NOPLAYBACKDELAY",           // 0x0020      // Ignore requested delay
    "HF_DESTROYED",                 // 0x0080      // Set by FreeHook
    // DEBUG only flags
    "HF_INCHECKWHF",                // 0x0100      // fsHooks is being updated
    "HF_FREED",                     // 0x0200      // Object has been freed.
    NULL,
};


const char * aszDcxFlags[] = {
    "DCX_WINDOW",                   // 0x00000001L
    "DCX_CACHE",                    // 0x00000002L
    "DCX_NORESETATTRS",             // 0x00000004L
    "DCX_CLIPCHILDREN",             // 0x00000008L
    "DCX_CLIPSIBLINGS",             // 0x00000010L
    "DCX_PARENTCLIP",               // 0x00000020L
    "DCX_EXCLUDERGN",               // 0x00000040L
    "DCX_INTERSECTRGN",             // 0x00000080L
    "DCX_EXCLUDEUPDATE",            // 0x00000100L
    "DCX_INTERSECTUPDATE",          // 0x00000200L
    "DCX_LOCKWINDOWUPDATE",         // 0x00000400L
    "DCX_INVALID",                  // 0x00000800L
    "DCX_INUSE",                    // 0x00001000L
    "DCX_SAVEDRGNINVALID",          // 0x00002000L
    "DCX_REDIRECTED",               // 0x00004000L
    "DCX_OWNDC",                    // 0x00008000L
    "DCX_USESTYLE",                 // 0x00010000L
    "DCX_NEEDFONT",                 // 0x00020000L
    "DCX_NODELETERGN",              // 0x00040000L
    "DCX_NOCLIPCHILDREN",           // 0x00080000L
    "DCX_NORECOMPUTE",              // 0x00100000L
    "DCX_VALIDATE",                 // 0x00200000L
    "DCX_DESTROYTHIS",              // 0x00400000L
    "DCX_CREATEDC",                 // 0x00800000L
    "DCX_REDIRECTEDBITMAP",         // 0x08000000L
    "DCX_PWNDORGINVISIBLE",         // 0x10000000L
    "DCX_NOMIRROR",                 // 0x40000000L
    NULL
};

const char* aszDesktopFlags[] = {
    "DF_ACTIVEONDESTROY",
    "DF_ZOMBIE",
    "DF_NOTRITUNLOCK",
    "DF_QUITUNLOCK",
    "DF_USERMODE",
    "DF_SKIPSWITCHDESKTOP",
    "DF_DTNONEWDESKTOP",
    "DF_REDIRECTED",
    "DF_DESKCREATED",
    "DF_NEWDISPLAYSETTINGS",
    "DF_TRACKMOUSEHOVER",
    "DF_TRACKMOUSELEAVE",
    "DF_TOOLTIPACTIVE",
    "DF_TOOLTIPSHOWING",
    "DF_HOTTRACKING",
    "DF_DESTROYED",
    "DF_DESKWNDDESTROYED",
    "DF_DYING",
    NULL
};

const char* aszWindowStationFlags[] = {
    "WSF_SWITCHLOCK",
    "WSF_OPENLOCK",
    "WSF_NOIO",
    "WSF_SHUTDOWN",
    "WSF_DYING",
    "WSF_REALSHUTDOWN",
    "WSF_CLIPBOARDCHANGED",
    "WSF_INDELAYEDRENDERING",
    NULL
};

enum GF_FLAGS {
    GF_SMS,
    GF_TIF,
    GF_QS,
    GF_MF,
    GF_CSF,
    GF_CS,
    GF_QF,
    GF_W32PF,
    GF_HE,
    GF_HDATA,
    GF_XI,
    GF_IIF,
    GF_TMRF,
    GF_SB,
    GF_CHARSETS,
    GF_MENUTYPE,
    GF_MENUSTATE,
    GF_CURSORF,
    GF_MON,
    GF_SI,
    GF_RIP,
    GF_SRVI,
    GF_PROP,
    GF_UPM0,
    GF_KI,
    GF_MI,
    GF_DS,
    GF_WS,
    GF_ES,
    GF_BS,
    GF_CBS,
    GF_SS,
    GF_LBS,
    GF_SBS,
    GF_WSEX,
    GF_CLIENTIMC,
    GF_CONVERSION,
    GF_SENTENCE,
    GF_IMEINIT,
    GF_IMEDIRTY,
    GF_IMECOMPFORM,
    GF_EDUNDO,
    GF_DIAF,
    GF_HIDPROCESSMASK,
    GF_HOOKFLAGS,
    GF_DCXFLAGS,
    GF_DESKTOPFLAGS,
    GF_WINDOWSTATIONFLAGS,

    GF_LPK,
    GF_MAX
};

CONST PCSTR* aapszFlag[GF_MAX] = {
    apszSmsFlags,
    apszTifFlags,
    apszQsFlags,
    apszMfFlags,
    apszCsfFlags,
    apszCsFlags,
    apszQfFlags,
    apszW32pfFlags,
    apszHeFlags,
    apszHdataFlags,
    apszXiFlags,
    apszIifFlags,
    apszTmrfFlags,
    apszSbFlags,
    apszCSFlags,
    apszMenuTypeFlags,
    apszMenuStateFlags,
    apszCursorfFlags,
    apszMonfFlags,
    apszSifFlags,
    apszRipFlags,
    apszSRVIFlags,
    apszPROPFlags,
    aszUserPreferencesMask0,
    aszKeyEventFlags,
    aszMouseEventFlags,
    aszDialogStyle,
    aszWindowStyle,
    aszEditStyle,
    aszButtonStyle,
    aszComboBoxStyle,
    aszStaticStyle,
    aszListBoxStyle,
    aszScrollBarStyle,
    aszWindowExStyle,
    aszClientImcFlags,
    aszConversionModes,
    aszSentenceModes,
    aszImeInit,
    aszImeDirtyFlags,
    aszImeCompFormFlags,
    aszEdUndoType,
    aszDeviceInfoActionFlags,
    aszHidProcessMask,
    aszHookFlags,
    aszDcxFlags,
    aszDesktopFlags,
    aszWindowStationFlags,

    apszLpkEntryPoints,
};

/************************************************************************\
* GetFlags
*
* Converts a 32bit set of flags into an appropriate string. pszBuf should
* be large enough to hold this string, no checks are done. pszBuf can be
* NULL, allowing use of a local static buffer but note that this is not
* reentrant. Output string has the form: "FLAG1 | FLAG2 ..." or "0".
*
* 6/9/1995 Created SanfordS
\************************************************************************/
LPSTR GetFlags(
    WORD    wType,
    DWORD   dwFlags,
    LPSTR   pszBuf,
    BOOL    fPrintZero)
{
    static char szT[512];
    WORD i;
    BOOL fFirst = TRUE;
    BOOL fNoMoreNames = FALSE;
    CONST PCSTR *apszFlags;
    LPSTR apszFlagNames[sizeof(DWORD) * 8], pszT;
    const char** ppszNextFlag;
    UINT uFlagsCount, uNextFlag;
    DWORD dwUnnamedFlags, dwLoopFlag;
    DWORD dwShiftBits;
    DWORD dwOrigFlags;

    if (pszBuf == NULL) {
        pszBuf = szT;
    }
    if (!bShowFlagNames) {
        sprintf(pszBuf, "%x", dwFlags);
        return pszBuf;
    }

    if (wType >= GF_MAX) {
        strcpy(pszBuf, "Invalid flag type.");
        return pszBuf;
    }

    /*
     * Initialize output buffer and names array
     */
    *pszBuf = '\0';
    RtlZeroMemory(apszFlagNames, sizeof(apszFlagNames));

    apszFlags = aapszFlag[wType];

    /*
     * Build a sorted array containing the names of the flags in dwFlags
     */
    uFlagsCount = 0;
    dwUnnamedFlags = dwOrigFlags = dwFlags;
    dwLoopFlag = 1;
    dwShiftBits = 0;

reentry:
    for (i = 0; dwFlags; dwFlags >>= 1, i++, dwLoopFlag <<= 1, ++dwShiftBits) {
        const char* lpszFlagName = NULL;

        /*
         * Bail if we reached the end of the flag names array
         */
        if (apszFlags[i] == NULL) {
            break;
        }

        if (apszFlags[i] == _MASKENUM_START) {
            //
            // Masked enumerative items.
            //
            DWORD en = 0;
            DWORD dwMask = (DWORD)(ULONG_PTR)apszFlags[++i];

            // First, clear up the handled bits.
            dwUnnamedFlags &= ~dwMask;
            lpszFlagName = NULL;
            for (++i; apszFlags[i] != NULL && apszFlags[i] != _MASKENUM_END; ++i, ++en) {
                if ((dwOrigFlags & dwMask) == (en << dwShiftBits )) {
                    if (apszFlags[i] != NO_FLAG) {
                        lpszFlagName = apszFlags[i];
                    }
                }
            }
            //
            // Shift the bits and get ready for the next item.
            // Next item right after _MASKENUM_END holds the bits to shift.
            //
            dwFlags >>= (int)(ULONG_PTR)apszFlags[++i] - 1;
            dwLoopFlag <<= (int)(ULONG_PTR)apszFlags[i] - 1;
            dwShiftBits += (int)(ULONG_PTR)apszFlags[i] - 1;
            if (lpszFlagName == NULL) {
                //
                // Could not find the match. Skip to the next item.
                //
                continue;
            }
        } else if (apszFlags[i] == _CONTINUE_ON) {
            //
            // Refer the other item array. Pointer to the array is stored at [i+1].
            //
            apszFlags = (LPSTR*)apszFlags[i + 1];
            goto reentry;
        } else if (apszFlags[i] == _SHIFT_BITS) {
            //
            // To save some space, just shift some bits..
            //
            dwFlags >>= (int)(ULONG_PTR)apszFlags[++i] - 1;
            dwLoopFlag <<= (int)(ULONG_PTR)apszFlags[i] - 1;
            dwShiftBits += (int)(ULONG_PTR)apszFlags[i] - 1;
            continue;
        } else {
            /*
             * Continue if this bit is not set or we don't have a name for it.
             */
            if (!(dwFlags & 1) || (apszFlags[i] == NO_FLAG)) {
                continue;
            }
            lpszFlagName = apszFlags[i];
        }

        /*
         * Find the sorted position where this name should go
         */
        ppszNextFlag = apszFlagNames;
        uNextFlag = 0;
        while (uNextFlag < uFlagsCount) {
            if (strcmp(*ppszNextFlag, lpszFlagName) > 0) {
                break;
            }
            ppszNextFlag++;
            uNextFlag++;
        }
        /*
         * Insert the new name
         */
        RtlMoveMemory((char*)(ppszNextFlag + 1), ppszNextFlag, (uFlagsCount - uNextFlag) * sizeof(DWORD));
        *ppszNextFlag = lpszFlagName;
        uFlagsCount++;
        /*
         * We got a name so clear it from the unnamed bits.
         */
        dwUnnamedFlags &= ~dwLoopFlag;
    }

    /*
     * Build the string now
     */
    ppszNextFlag = apszFlagNames;
    pszT = pszBuf;
    /*
     * Add the first name
     */
    if (uFlagsCount > 0) {
        pszT += sprintf(pszT, "%s", *ppszNextFlag++);
        uFlagsCount--;
    }
    /*
     * Concatenate all other names with " |"
     */
    while (uFlagsCount > 0) {
        pszT += sprintf(pszT, " | %s", *ppszNextFlag++);
        uFlagsCount--;
    }
    /*
     * If there are unamed bits, add them at the end
     */
    if (dwUnnamedFlags != 0) {
        pszT += sprintf(pszT, " | %#lx", dwUnnamedFlags);
    }
    /*
     * Print zero if needed and asked to do so
     */
    if (fPrintZero && (pszT == pszBuf)) {
        sprintf(pszBuf, "0");
    }

    return pszBuf;
}

///////////////////////////////////////////////////////////////////////////
//
// Enumerated items with mask
//
///////////////////////////////////////////////////////////////////////////

typedef struct {
    LPCSTR  name;
    DWORD   value;
} EnumItem;

#define EITEM(a)     { #a, a }

const EnumItem aClsTypes[] = {
    EITEM(ICLS_BUTTON),
    EITEM(ICLS_EDIT),
    EITEM(ICLS_STATIC),
    EITEM(ICLS_LISTBOX),
    EITEM(ICLS_SCROLLBAR),
    EITEM(ICLS_COMBOBOX),
    EITEM(ICLS_CTL_MAX),
    EITEM(ICLS_DESKTOP),
    EITEM(ICLS_DIALOG),
    EITEM(ICLS_MENU),
    EITEM(ICLS_SWITCH),
    EITEM(ICLS_ICONTITLE),
    EITEM(ICLS_MDICLIENT),
    EITEM(ICLS_COMBOLISTBOX),
    EITEM(ICLS_DDEMLEVENT),
    EITEM(ICLS_DDEMLMOTHER),
    EITEM(ICLS_DDEML16BIT),
    EITEM(ICLS_DDEMLCLIENTA),
    EITEM(ICLS_DDEMLCLIENTW),
    EITEM(ICLS_DDEMLSERVERA),
    EITEM(ICLS_DDEMLSERVERW),
    EITEM(ICLS_IME),
    EITEM(ICLS_TOOLTIP),
    NULL,
};

const EnumItem aCharSets[] = {
    EITEM(ANSI_CHARSET),
    EITEM(DEFAULT_CHARSET),
    EITEM(SYMBOL_CHARSET),
    EITEM(SHIFTJIS_CHARSET),
    EITEM(HANGEUL_CHARSET),
    EITEM(HANGUL_CHARSET),
    EITEM(GB2312_CHARSET),
    EITEM(CHINESEBIG5_CHARSET),
    EITEM(OEM_CHARSET),
    EITEM(JOHAB_CHARSET),
    EITEM(HEBREW_CHARSET),
    EITEM(ARABIC_CHARSET),
    EITEM(GREEK_CHARSET),
    EITEM(TURKISH_CHARSET),
    EITEM(VIETNAMESE_CHARSET),
    EITEM(THAI_CHARSET),
    EITEM(EASTEUROPE_CHARSET),
    EITEM(RUSSIAN_CHARSET),
    NULL,
};

const EnumItem aImeHotKeys[] = {
    // Windows for Simplified Chinese Edition hot key ID from 0x10 - 0x2F
    EITEM(IME_CHOTKEY_IME_NONIME_TOGGLE),
    EITEM(IME_CHOTKEY_SHAPE_TOGGLE),
    EITEM(IME_CHOTKEY_SYMBOL_TOGGLE),
    // Windows for Japanese Edition hot key ID from 0x30 - 0x4F
    EITEM(IME_JHOTKEY_CLOSE_OPEN),
    // Windows for Korean Edition hot key ID from 0x50 - 0x6F
    EITEM(IME_KHOTKEY_SHAPE_TOGGLE),
    EITEM(IME_KHOTKEY_HANJACONVERT),
    EITEM(IME_KHOTKEY_ENGLISH),
    // Windows for Traditional Chinese Edition hot key ID from 0x70 - 0x8F
    EITEM(IME_THOTKEY_IME_NONIME_TOGGLE),
    EITEM(IME_THOTKEY_SHAPE_TOGGLE),
    EITEM(IME_THOTKEY_SYMBOL_TOGGLE),
    // direct switch hot key ID from 0x100 - 0x11F
    EITEM(IME_HOTKEY_DSWITCH_FIRST),
    EITEM(IME_HOTKEY_DSWITCH_LAST),
    // IME private hot key from 0x200 - 0x21F
    EITEM(IME_ITHOTKEY_RESEND_RESULTSTR),
    EITEM(IME_ITHOTKEY_PREVIOUS_COMPOSITION),
    EITEM(IME_ITHOTKEY_UISTYLE_TOGGLE),
    EITEM(IME_ITHOTKEY_RECONVERTSTRING),
    EITEM(IME_HOTKEY_PRIVATE_LAST),
    NULL,
};

const EnumItem aCandidateListStyle[] = {
    EITEM(IME_CAND_UNKNOWN),//                0x0000
    EITEM(IME_CAND_READ),//                   0x0001
    EITEM(IME_CAND_CODE),//                   0x0002
    EITEM(IME_CAND_MEANING),//                0x0003
    EITEM(IME_CAND_RADICAL),//                0x0004
    EITEM(IME_CAND_STROKE),//                 0x0005
    NULL
};

// TODO: put charset here

enum {
    EI_CLSTYPE = 0,
    EI_CHARSETTYPE,
    EI_IMEHOTKEYTYPE,
    EI_IMECANDIDATESTYLE,
    EI_MAX
};

typedef struct {
    DWORD dwMask;
    const EnumItem* items;
} MaskedEnum;

const MaskedEnum aEnumItems[] = {
    ~0,             aClsTypes,
    ~0,             aCharSets,
    ~0,             aImeHotKeys,
    ~0,             aCandidateListStyle,
};

LPCSTR GetMaskedEnum(WORD wType, DWORD dwValue, LPSTR buf)
{
    const EnumItem* item;
    static char ach[32];

    if (wType >= EI_MAX) {
        strcpy(buf, "Invalid type.");
        return buf;
    }

    dwValue &= aEnumItems[wType].dwMask;

    item = aEnumItems[wType].items;

    for (; item->name; ++item) {
        if (item->value == dwValue) {
            if (buf) {
                strcpy(buf, item->name);
                return buf;
            }
            return item->name;
        }
    }

    if (buf) {
        *buf = 0;
        return buf;
    }

    sprintf(ach, "%x", wType);
    return ach;
}

#define WM_ITEM(x, fInternal)  { x, #x, fInternal }

CONST struct {
    DWORD msg;
    PCSTR pszMsg;
    BOOLEAN fInternal;
} gaMsgs[] = {
    #include "wm.txt"
};

#undef WM_ITEM

const char* GetWindowMessageName(UINT wm)
{
    int i;

    for (i = 0; i < sizeof gaMsgs; ++i) {
        if (wm == gaMsgs[i].msg) {
            if (!gaMsgs[i].fInternal) {
                return gaMsgs[i].pszMsg;
            }
            return "";
        }
    }

    return "";
}

const char* GetWindowMessageNameInternal(UINT wm)
{
    int i;

    for (i = 0; i < sizeof gaMsgs; ++i) {
        if (wm == gaMsgs[i].msg) {
            return gaMsgs[i].pszMsg;
        }
    }
    return "";
}


/************************************************************************\
* Helper Procedures: dso etc.
*
* 04/19/2000 Created Hiro
\************************************************************************/

// to workaround nosy InitTypeRead
#define _InitTypeRead(Addr, lpszType)   GetShortField(Addr, (PUCHAR)lpszType, 1)

#define CONTINUE    EXCEPTION_EXECUTE_HANDLER

#define RAISE_EXCEPTION() RaiseException(EXCEPTION_ACCESS_VIOLATION, 0, 0, NULL)

#define BAD_SYMBOL(symbol) \
    Print("Failed to get %s: bad symbol?\n", symbol); \
    RAISE_EXCEPTION()

#define CANT_GET_VALUE(symbol, p) \
    Print("Failed to get %s @ 0x%p: invalid address, or memory is paged out?\n", symbol, p); \
    RAISE_EXCEPTION()



BOOL dso(
    char* szStruct,
    ULONG64 address,
    ULONG dwOption)
{
    SYM_DUMP_PARAM symDump = {
        sizeof(symDump), szStruct, dwOption, // 0 for default dump like dt
        address,
        NULL, NULL, NULL, 0, NULL
    };

    return Ioctl(IG_DUMP_SYMBOL_INFO, &symDump, symDump.size);
}

ULONG64 GetPointer(
    ULONG64 addr)
{
    ULONG64 p = 0;
    if (!ReadPointer(addr, &p)) {
        CANT_GET_VALUE("a pointer", addr);
    }
    return p;
}

DWORD GetDWord(
    ULONG64 addr)
{
    ULONG64 dw = 0xbaadbaad;

    if (!GetFieldData(addr, "DWORD", NULL, sizeof(dw), &dw)) {
        CANT_GET_VALUE("DWORD", addr);
    }
    return (DWORD)dw;
}

WORD GetWord(
    ULONG64 addr)
{
    ULONG64 w = 0xbaad;

    if (!GetFieldData(addr, "WORD", NULL, sizeof(w), &w)) {
        CANT_GET_VALUE("WORD", addr);
    }
    return (WORD)w;
}

BYTE GetByte(
    ULONG64 addr)
{
    ULONG64 b = 0;

    if (GetFieldData(addr, "BYTE", NULL, sizeof(b), &b)) {
        CANT_GET_VALUE("BYTE", addr);
    }
    return (BYTE)b;
}

ULONG
GetUlongFromAddress(
    ULONG64 Location)
{
    ULONG Value;
    ULONG result;

    if ((!ReadMemory(Location, &Value, sizeof(ULONG), &result)) ||
        (result < sizeof(ULONG))) {
        Print("GetUlongFromAddress: unable to read from 0x%I64x\n", Location);
        RAISE_EXCEPTION();
    }

    return Value;
}

ULONG64 GetGlobalPointer(
    LPSTR symbol)
{
    ULONG64 pp;
    ULONG64 p = 0;

    pp = EvalExp(symbol);
    if (pp == 0) {
        BAD_SYMBOL(symbol);
    } else if (!ReadPointer(pp, &p)) {
        CANT_GET_VALUE(symbol, pp);
    }
    return p;
}

ULONG64 GetGlobalMemberAddress(
    LPSTR symbol,
    LPSTR type,
    LPSTR field)
{
    ULONG64 pVar = EvalExp(symbol);
    ULONG offset;

    if (pVar == 0) {
        BAD_SYMBOL(symbol);
    }

    if (GetFieldOffset(type, field, &offset)) {
        BAD_SYMBOL(type);
    }

    return pVar + offset;
}

ULONG64 GetGlobalMember(
    LPSTR symbol,
    LPSTR type,
    LPSTR field)
{
    ULONG64 pVar = EvalExp(symbol);
    ULONG64 val;

    if (pVar == 0) {
        BAD_SYMBOL(symbol);
    }

    if (GetFieldValue(pVar, type, field, val)) {
        CANT_GET_VALUE(symbol, pVar);
    }

    return val;
}

#if 0
DWORD GetGlobalDWord(LPSTR symbol)
{
    ULONG64 pdw;
    ULONG64 dw = 0;

    pdw = EvalExp(symbol);
    if (pdw == 0) {
        BAD_SYMBOL(symbol);
    } else if (!GetFieldData(pdw, "DWORD", NULL, sizeof(dw), &dw)) {
        CANT_GET_VALUE(symbol, pdw);
    }

    return (DWORD)(DWORD_PTR)dw;
}

WORD GetGlobalWord(LPSTR symbol)
{
    ULONG64 pw;
    WORD w = 0;

    pw = EvalExp(symbol);
    if (pw == 0) {
        BAD_SYMBOL(symbol);
    } else if (!GetFieldData(pw, (PUCHAR)"WORD", NULL, sizeof(w), (PVOID)&w)) {
        CANT_GET_VALUE(symbol, pw);
    }
    return w;
}

BYTE GetGlobalByte(LPSTR symbol)
{
    ULONG64 pb;
    BYTE b = 0;

    pb = EvalExp(symbol);
    if (pb == 0) {
        BAD_SYMBOL(symbol);
    } else if (!GetFieldData(pb, (PUCHAR)"BYTE", NULL, sizeof(b), (PVOID)&b)) {
        CANT_GET_VALUE(symbol, pb);
    }
    return b;
}
#endif

ULONG64 GetArrayElement(
    ULONG64 pAddr,
    LPSTR lpszStruc,
    LPSTR lpszField,
    ULONG64 index,
    LPSTR lpszType)
{
    static ULONG ulOffsetBase, ulSize;
    ULONG64 result = 0;

    if (lpszField) {
        GetFieldOffset(lpszStruc, lpszField, &ulOffsetBase);
        ulSize = GetTypeSize(lpszType);
    }
    ReadMemory(pAddr + ulOffsetBase + ulSize * index, &result, ulSize, NULL);

    return result;
}

ULONG64 GetArrayElementPtr(
    ULONG64 pAddr,
    LPSTR lpszStruc,
    LPSTR lpszField,
    ULONG64 index)
{
    static ULONG ulOffsetBase, ulSize;
    ULONG64 result = 0;

    if (lpszField) {
        GetFieldOffset(lpszStruc, lpszField, &ulOffsetBase);
    }
    if (ulSize == 0) {
        ulSize = GetTypeSize("PVOID");
    }
    ReadPointer(pAddr + ulOffsetBase + ulSize * index, &result);

    return result;
}

/*
 * Show progress in time consuming commands
 * 10/15/2000 hiroyama
 */
VOID ShowProgress(
    VOID)
{
    static int i = 0;
    static const char* clock[] = {
        "\r-\r",
        "\r\\\r",
        "\r|\r",
        "\r/\r",
    };

    /*
     * Show the progress :-)
     */
    Print(clock[i++ % ARRAY_SIZE(clock)]);
}

#define DOWNCAST(type, value)  ((type)(ULONG_PTR)(value))

#ifdef KERNEL
BOOL HasValidSymbols(VOID)
{
    if (EvalExp(VAR(gptiRit))) {
        return TRUE;
    }
    return FALSE;
}
#endif

/*
 * IsChk: returns TRUE if the window manager is CHK,
 * could return TRUE regardless the entire system is FRE.
 */

int gfChk = -1;

BOOL IsChk(VOID)
{
    ULONG64 psi;

    if (gfChk != -1) {
        return gfChk;
    }

    psi = GetGlobalPointer(SYM(gpsi));
    if (psi == 0) {
        Print("Cannot get gpsi, assuming chk\n");
        return TRUE;
    }

    if ((DWORD)GetArrayElement(psi, SYM(SERVERINFO), "aiSysMet", SM_DEBUG, "DWORD")) {
        return gfChk = TRUE;
    }

    return gfChk = FALSE;
}

#ifdef KERNEL
/*
 * Debugger specific object routines:
 * copied from ntos/tools/kdexts2/precomp.h
 * (and fixed bugs)
 */

ULONG gObjectHeaderOffset;

__inline
ULONG64
KD_OBJECT_TO_OBJECT_HEADER(
    ULONG64 o)
{
    if (gObjectHeaderOffset == 0 && GetFieldOffset("nt!_OBJECT_HEADER", "Body", &gObjectHeaderOffset)) {
        return 0;
    }
    return o - gObjectHeaderOffset;
}

__inline
ULONG64
KD_OBJECT_HEADER_TO_OBJECT(
    ULONG64 o)
{
    if (gObjectHeaderOffset && GetFieldOffset("nt!_OBJECT_HEADER", "Body", &gObjectHeaderOffset)) {
        return 0;
    }
    return o + gObjectHeaderOffset;
}

__inline
VOID
KD_OBJECT_HEADER_TO_QUOTA_INFO(
    ULONG64 oh,
    PULONG64 pOutH
    )
{
    ULONG QuotaInfoOffset=0;
    GetFieldValue(oh, "nt!__OBJECT_HEADER", "QuotaInfoOffset", QuotaInfoOffset);
    *pOutH = (QuotaInfoOffset == 0 ? 0 : ((oh) - QuotaInfoOffset));
}


__inline
VOID
KD_OBJECT_HEADER_TO_HANDLE_INFO (
    ULONG64 oh,
    PULONG64 pOutH
    )
{
    ULONG HandleInfoOffset=0;
    GetFieldValue(oh, "nt!__OBJECT_HEADER", "HandleInfoOffset", HandleInfoOffset);
    *pOutH = (HandleInfoOffset == 0 ? 0 : ((oh) - HandleInfoOffset));
}

__inline
VOID
KD_OBJECT_HEADER_TO_NAME_INFO(
    ULONG64  oh,
    PULONG64 pOutH
    )
{
    ULONG NameInfoOffset=0;
    GetFieldValue(oh, "nt!_OBJECT_HEADER", "NameInfoOffset", NameInfoOffset);
    *pOutH = (NameInfoOffset == 0 ? 0 : ((oh) - NameInfoOffset));
}

#if 0
__inline
VOID
KD_OBJECT_HEADER_TO_CREATOR_INFO(
    ULONG64  oh,
    PULONG64 pOutH
    )
{
    ULONG Flags=0;
    GetFieldValue(oh, "_OBJECT_HEADER", "Flags", Flags);
    *pOutH = ((Flags & OB_FLAG_CREATOR_INFO) == 0 ? 0 : ((oh) - GetTypeSize("_OBJECT_HEADER_CREATOR_INFO")));
}
#endif


/*
 * Object helper routines
 */

#endif


#ifdef KERNEL


/************************************************************************\
* Procedure: GetObjectName
* Get the generic object name (not a file, symlink etc.)
*
* 10/15/2000 Hiroyama Created
\************************************************************************/
VOID GetObjectName(
    ULONG64 ptr,
    LPWSTR pwsz,
    ULONG cchMax)
{
    PTR pHead;
    PTR pNameInfo;
    PTR pBuffer;
    PTR length;
    WCHAR ach[80];

    pwsz[0] = 0;
    pHead = KD_OBJECT_TO_OBJECT_HEADER(ptr);
    DEBUGPRINT("pHead=%p\n", pHead);
    if (pHead == NULL_PTR) {
        return;
    }
    KD_OBJECT_HEADER_TO_NAME_INFO(pHead, &pNameInfo);
    DEBUGPRINT("pNameInfo=%p\n", pNameInfo);
    if (pNameInfo == NULL_PTR) {
        return;
    }
    GetFieldValue(pNameInfo, "nt!_OBJECT_HEADER_NAME_INFO", "Name.Buffer", pBuffer);
    DEBUGPRINT("pBuffer=%p\n", pBuffer);
    if (pBuffer == NULL_PTR) {
        return;
    }
    GetFieldValue(pNameInfo, "nt!_OBJECT_HEADER_NAME_INFO", "Name.Length", length);
    DEBUGPRINT("length=%x\n", length);
    if (length == 0) {
        return;
    }
    move(ach, pBuffer);
    wcsncpy(pwsz, ach, cchMax);
    pwsz[min(cchMax - 1, length / sizeof(WCHAR))] = 0;
}

/************************************************************************\
* Procedure: GetProcessName
*
* 06/27/97 GerardoB Created
*
\************************************************************************/
BOOL
GetProcessName(
    PTR pEProcess,
    LPWSTR lpBuffer)
{
    UCHAR ImageFileName[16];
    if (!GetFieldValue(pEProcess, "nt!EPROCESS", "ImageFileName", ImageFileName)) {
        swprintf(lpBuffer, L"%.16hs", ImageFileName);
        return TRUE;
    } else {
        Print("Unable to read _EPROCESS at %p\n", pEProcess);
        return FALSE;
    }
}

/************************************************************************\
* GetAppName
*
* 10/6/1995 Created JimA
\************************************************************************/
BOOL
GetAppName(
    PTR pEThread,
    PTR pti,
    LPWSTR lpBuffer,
    DWORD cbBuffer)
{
    PTR pstrAppName = 0;
    PTR Buffer;
    USHORT Length;
    BOOL fRead = FALSE;

    GetFieldValue(pti, SYM(THREADINFO), "pstrAppName", pstrAppName);
    if (pstrAppName != 0) {
        if (!GetFieldValue(pstrAppName, SYM(UNICODE_STRING), "Buffer", Buffer)) {
            GetFieldValue(pstrAppName, SYM(UNICODE_STRING), "Length", Length);
            cbBuffer = min(cbBuffer - sizeof(WCHAR), Length);
            if (tryMoveBlock(lpBuffer, Buffer, cbBuffer)) {
                lpBuffer[cbBuffer / sizeof(WCHAR)] = 0;
                fRead = TRUE;
            }
        }
    } else {
        PTR pEProcess;
        GetFieldValue(pEThread, "nt!ETHREAD", "ThreadsProcess", pEProcess);
        fRead = GetProcessName(pEProcess, lpBuffer);
    }

    if (!fRead) {
        wcsncpy(lpBuffer, L"<unknown name>", cbBuffer / sizeof(WCHAR));
    }

    return fRead;
}


#define INVALID_SESSION_ID   ((ULONG)0xbadbad)

BOOL _GetProcessSessionId(PTR Process, PULONG SessionId)
{
    PTR SessionPointer;

    *SessionId = INVALID_SESSION_ID;

    GetFieldValue(Process, "nt!_EPROCESS", "Session", SessionPointer);
    if (SessionPointer != NULL_PTR) {
        if (GetFieldValue(SessionPointer, "nt!_MM_SESSION_SPACE",
                          "SessionId", *SessionId)) {
            Print("Could not find _MM_SESSION_SPACE type at %p.\n", SessionPointer);
            return FALSE;
        }
    }

    return TRUE;
}

ULONG GetProcessSessionId(PTR Process)
{
    ULONG sid;

    _GetProcessSessionId(Process, &sid);
    return sid;
}

#endif // KERNEL

#ifdef OLD_DEBUGGER

#ifdef KERNEL
/************************************************************************\
* PrintMessages
*
* Prints out qmsg structures.
*
* 6/9/1995 Created SanfordS
\************************************************************************/
BOOL PrintMessages(
    PQMSG pqmsgRead)
{
    QMSG qmsg;
    ASYNCSENDMSG asm;
    char *aszEvents[] = {
        "MSG",  // QEVENT_MESSAGE
        "SHO",  // QEVENT_SHOWWINDOW"
        "CMD",  // QEVENT_CANCLEMODE"
        "SWP",  // QEVENT_SETWINDOWPOS"
        "UKS",  // QEVENT_UPDATEKEYSTATE"
        "DEA",  // QEVENT_DEACTIVATE"
        "ACT",  // QEVENT_ACTIVATE"
        "PST",  // QEVENT_POSTMESSAGE"
        "EXE",  // QEVENT_EXECSHELL"
        "CMN",  // QEVENT_CANCELMENU"
        "DSW",  // QEVENT_DESTROYWINDOW"
        "ASY",  // QEVENT_ASYNCSENDMSG"
        "HNG",  // QEVENT_HUNGTHREAD"
        "CMT",  // QEVENT_CANCELMOUSEMOVETRK"
        "NWE",  // QEVENT_NOTIFYWINEVENT"
        "RAC",  // QEVENT_RITACCESSIBILITY"
        "RSO",  // QEVENT_RITSOUND"
        "?  ",  // "?"
        "?  ",  // "?"
        "?  "   // "?"
    };
    #define NQEVENT (ARRAY_SIZE(aszEvents))

    Print("typ pqmsg    hwnd    msg  wParam   lParam   time     ExInfo   dwQEvent pti\n");
    Print("-------------------------------------------------------------------------------\n");

    SAFEWHILE (TRUE) {
        move(qmsg, FIXKP(pqmsgRead));
        if (qmsg.dwQEvent < NQEVENT) {
            Print("%s %08lx ", aszEvents[qmsg.dwQEvent], pqmsgRead);
        } else {
            Print("??? %08lx ", pqmsgRead);
        }

        switch (qmsg.dwQEvent) {
        case QEVENT_ASYNCSENDMSG:
            move(asm, (PVOID)qmsg.msg.wParam);

            Print("%07lx %04lx %08lx %08lx %08lx %08lx %08lx %08lx\n",
                asm.hwnd, asm.message, asm.wParam, asm.lParam,
                qmsg.msg.time, qmsg.ExtraInfo, qmsg.dwQEvent, qmsg.pti);
            break;

        case 0:
        default:
            Print("%07lx %04lx %08lx %08lx %08lx %08lx %08lx %08lx\n",
                qmsg.msg.hwnd, qmsg.msg.message, qmsg.msg.wParam, qmsg.msg.lParam,
                qmsg.msg.time, qmsg.ExtraInfo, qmsg.dwQEvent, qmsg.pti);
            break;

        }

        if (qmsg.pqmsgNext != NULL) {
            if (pqmsgRead == qmsg.pqmsgNext) {
                Print("loop found in message list!");
                return FALSE;
            }
            pqmsgRead = qmsg.pqmsgNext;
        } else {
            return TRUE;
        }
    }
    return TRUE;
}
#endif // KERNEL

#endif // OLD_DEBUGGER

/************************************************************************\
* GetAndDumpHE
*
* Dumps given handle (dwT) and returns its phe.
*
* 6/9/1995 Documented SanfordS
\************************************************************************/
BOOL
GetAndDumpHE(
    PTR  dwT,
    PPTR phe,
    BOOL fPointerTest)
{

    DWORD dw;
    PTR pheT, phead;
    PTR pshi, psi, h;
    ULONG_PTR cHandleEntries;


    /*
     * Evaluate the argument string and get the address of the object to
     * dump. Take either a handle or a pointer to the object.
     */
    dw = HMIndexFromHandle(dwT);

    /*
     * First see if it is a pointer because the handle index is only part of
     * the 32 bit DWORD, and we may mistake a pointer for a handle.
     */
    if (!fPointerTest && IS_PTR(dwT)) {
        if (GetFieldValue(dwT, SYM(HEAD), "h", h) == 0) {
            if (GetAndDumpHE(h, phe, TRUE)) {
                return TRUE;
            }
        }
    }

    /*
     * Is it a handle? Does its index fit our table length?
     */
    GETSHAREDINFO(pshi);

    GetFieldValue(pshi, SYM(SHAREDINFO), "psi", psi);
    GetFieldValue(psi, SYM(SERVERINFO), "cHandleEntries", cHandleEntries);
    if (dw >= cHandleEntries) {
        return FALSE;
    }

    /*
     * Grab the handle entry and see if it is ok.
     */
    GetFieldValue(pshi, SYM(SHAREDINFO), "aheList", pheT);
    pheT += (dw * GetTypeSize("HANDLEENTRY"));

    *phe = pheT;

    /*
     * If the type is too big, it's not a handle.
     */
    _InitTypeRead(pheT, SYM(HANDLEENTRY));

    if (ReadField(bType) >= TYPE_CTYPES) {
        pheT = 0;
    } else {
        phead = ReadField(phead);
        if (ReadField(bType) != TYPE_FREE) {
            /*
             * See if the object references this handle entry: the clincher
             * for a handle, if it is not FREE.
             */
            GetFieldValue(phead, SYM(HEAD), "h", h);
            if (HMIndexFromHandle(h) != dw)
                pheT = 0;
        }
    }

    if (pheT == 0) {
        if (!fPointerTest) {
            Print("0x%p is not a valid object or handle.\n", dwT);
        }
        return FALSE;
    }

    /*
     * Dump the ownership info and the handle entry info
     */
    GetFieldValue(phead, SYM(HEAD), "h", h);
#ifdef Idhe
    Idhe(0, h, 0);
#endif
    Print("\n");

    return TRUE;
}

/************************************************************************\
* HtoHE
*
* Extracts HE and phe from given handle. Handle can be just an index.
* Assumes h is a valid handle. Returns FALSE only if it's totally wacko.
*
* 6/9/1995 Created SanfordS
\************************************************************************/
BOOL HtoHE(
    PTR h,
    PTR *pphe OPTIONAL)
{
    PTR psi;
    PTR pheT;
    PTR cHandleEntries;
    DWORD index;

    index = HMIndexFromHandle(h);
    GETSHAREDINFO(psi);
    if (psi == 0) {
        RAISE_EXCEPTION();
    }
    if (GetFieldValue(psi, SYM(SHAREDINFO), "aheList", pheT)) {
        DEBUGPRINT("HtoHE(%I64x): Couldn't get aheList. Bad symbols?\n", h);
        return FALSE;
    }

    if (GetFieldValue(psi, SYM(SHAREDINFO), "psi", psi)) {
        DEBUGPRINT("HtoHE(%I64x): Couldn't get psi. Bad symbols?\n", h);
        return FALSE;
    }

    if (GetFieldValue(psi, SYM(SERVERINFO), "cHandleEntries", cHandleEntries)) {
        DEBUGPRINT("HtoHE(%I64x): Couldn't get cHandleEntries. Bad symbols?\n", h);
        return FALSE;
    }

    if (index >= cHandleEntries) {
        DEBUGPRINT("HtoHE(%I64x): index %d is too large.\n", h, index);
        return FALSE;
    }
    pheT += index * GetTypeSize(SYM(HANDLEENTRY));

    if (pphe != NULL) {
        *pphe = pheT;
    }

    return TRUE;
}

/************************************************************************\
* GetPfromH
*
* Converts a handle to a pointer and extracts he and phe info. Returns a
* pointer to the object's HANDLEENTRY or NULL on failure.
*
* 6/9/1995 Created SanfordS
\************************************************************************/
ULONG64 GetPfromH(
    PTR h,
    PTR *pphe OPTIONAL)
{
    PTR pheT;
    PTR phead;

    if (!HtoHE(h, &pheT)) {
        DEBUGPRINT("GetPfromH(%p): failed to get HE.\n", h);
        return 0;
    }

    if (GetFieldValue(pheT, SYM(HANDLEENTRY), "phead", phead)) {
        DEBUGPRINT("GetPfromH(%p): failed to get phead.\n", h);
        return 0;
    }

    if (pphe != NULL) {
        *pphe = pheT;
    }

    return FIXKP(phead);
}


/************************************************************************\
* getHEfromP
*
* Converts a pointer to a handle and extracts the he and phe info.
*
* 6/9/1995 Created SanfordS
\************************************************************************/
BOOL getHEfromP(
    PTR *pphe,
    PTR p)
{
    PTR pLookup, h;

    p = FIXKP(p);

    GetFieldValue(p, SYM(THROBJHEAD), "h", h);
    pLookup = GetPfromH(h, pphe);
    if (FIXKP(pLookup) != p) {
        DEBUGPRINT("getHEfromP(%p): invalid.\n", p);
        return FALSE;
    }

    return TRUE;
}


/************************************************************************\
* HorPtoP
*
* Generic function to accept either a user handle or pointer value and
* validate it and convert it to a pointer. type=-1 to allow any non-free
* type. type=-2 to allow any type.
*
* 6/9/1995 Created SanfordS
\************************************************************************/
ULONG64 HorPtoP(
    PTR p,
    int type)
{
    PTR phe;
    PTR pT;
    PTR phead;
    int bType;


    if (p == 0) {
        return 0;
    }

    p = FIXKP(p);
    if (ReadPointer(p, &pT) && getHEfromP(&phe, p)) {
        /*
         * It was a pointer
         */
        GetFieldValue(phe, SYM(HANDLEENTRY), "bType", bType);
        if ((type == -2 || bType != TYPE_FREE) &&
                bType < TYPE_CTYPES &&
                (type < 0 || bType == type)) {
            GetFieldValue(phe, SYM(HANDLEENTRY), "phead", phead);
            return FIXKP(phead);
        }
    }

    pT = GetPfromH(p, NULL);
    if (pT == 0) {
        Print("WARNING: dumping %p even though it's not a valid pointer or handle!\n", (ULONG_PTR)p);
        return p;  // let it pass anyway so we can see how it got corrupted.
    }

    return FIXKP(pT);
}

/************************************************************************\
* Procedure: DebugGetWindowTextA
*
* Description: Places pwnd title into achDest.
*
* 06/09/1995 Created                      SanfordS
* 11/18/2000 Added dwLength parameter     JasonSch
*
\************************************************************************/
BOOL DebugGetWindowTextA(
    PTR pwnd,
    char *achDest,
    DWORD dwLength)
{
    ULONG Length;
    PTR Buffer;
    WCHAR *lpwstr;

    if (pwnd == 0) {
        achDest[0] = '\0';
        return FALSE;
    }

    pwnd = FIXKP(pwnd);
    if (GetFieldValue(pwnd, SYM(WND), "strName.Length", Length) ||
        GetFieldValue(pwnd, SYM(WND), "strName.Buffer", Buffer)) {
        strcpy(achDest, "<< Can't get WND >>");
        return FALSE;
    }

    if (Length == 0) {
        strcpy(achDest, "<null>");
    } else {
        ULONG cbText = min(dwLength - 1, Length + sizeof(WCHAR));

        lpwstr = LocalAlloc(LPTR, cbText);
        if (!(tryMoveBlock(lpwstr, FIXKP(Buffer), cbText))) {
            strcpy(achDest, "<< Can't get title >>");
            LocalFree(lpwstr);
            return FALSE;
        }

        RtlUnicodeToMultiByteN(achDest, dwLength, NULL, lpwstr, cbText);
        achDest[cbText] = '\0';
        LocalFree(lpwstr);
    }
    return TRUE;
}

/************************************************************************\
* DebugGetClassNameA
*
* Placed pcls name into achDest.  No checks for size are made.
*
* 6/9/1995 Created SanfordS
\************************************************************************/
BOOL DebugGetClassNameA(
    PTR lpszClassName,
    char *achDest)
{
    CHAR ach[80];

    if (lpszClassName == 0) {
        strcpy(achDest, "<null>");
    } else {
        if (!tryMove(ach, FIXKP(lpszClassName))) {
            strcpy(achDest, "<inaccessible>");
        } else {
            strcpy(achDest, ach);
        }
        strcpy(achDest, ach);
    }
    return TRUE;
}

/************************************************************************\
* PrintBitField, PrintEndBitField
*
* Printout specified boolean value in a structure. Assuming
* strlen(pszFieldName) will not exceeds BF_COLUMN_WIDTH.
*
* 10/12/1997 Created HiroYama
\************************************************************************/
VOID PrintBitField(
    LPSTR pszFieldName,
    BOOL fValue)
{
    int iWidth;
    int iStart = giBFColumn;

    sprintf(gach1, fValue ? "*%-s " : " %-s ", pszFieldName);

    iWidth = (strlen(gach1) + BF_COLUMN_WIDTH - 1) / BF_COLUMN_WIDTH;
    iWidth *= BF_COLUMN_WIDTH;

    if ((giBFColumn += iWidth) >= BF_MAX_WIDTH) {
        giBFColumn = iWidth;
        Print("%s\n", gaBFBuff);
        iStart = 0;
    }

    sprintf(gaBFBuff + iStart, "%-*s", iWidth, gach1);
}

VOID PrintEndBitField(
    VOID)
{
    if (giBFColumn != 0) {
        giBFColumn = 0;
        Print("%s\n", gaBFBuff);
    }
}

LPCSTR pszObjStr[] = {
    "Free",
    "Window",
    "Menu",
    "Cursor",
    "SetWindowPos",
    "Hook",
    "Thread Info",
    "Clip Data",
    "Call Proc",
    "Accel Table",
    "WindowStation",
    "DeskTop",
    "DdeAccess",
    "DdeConv",
    "DdeExact",
    "Monitor",
    "Ctypes",
    "Console",
    "Generic"
};


#ifdef KERNEL
/***********************************************************************\
* GetGdiHandleType
*
* Returns a static buffer address which will contain a > 0 length string
* if the type makes sense.
*
* 12/1/1995 Created SanfordS
\***********************************************************************/
LPCSTR GetGDIHandleType(
    HOBJ ho)
{
    ULONG64 pent;                           // base address of hmgr entries
    ULONG ulTemp;
    static CHAR szT[20];
    ULONG gcMaxHmgr, index;
    DWORD dwEntrySize = GetTypeSize(SYM(ENTRY));

// filched from gre\hmgr.h
#define INDEX_MASK          ((1 << INDEX_BITS) - 1)
#define HmgIfromH(h)          ((ULONG)(h) & INDEX_MASK)

    szT[0] = '\0';
    pent = GetGlobalPointer(VAR(gpentHmgr));
    moveExpValue(&gcMaxHmgr, VAR(gcMaxHmgr));
    index = HmgIfromH((ULONG_PTR) ho);
    if (index > gcMaxHmgr) {
        return szT;
    }

    _InitTypeRead(pent + index * dwEntrySize, SYM(ENTRY));
    if ((USHORT)ReadField(FullUnique) != ((ULONG_PTR)ho >> 16)) {
        return szT;
    }

    if ((HOBJ)ReadField(einfo.pobj.hHmgr) != ho) {
        return szT;
    }
    ulTemp = (ULONG) ReadField(Objt);

    switch(ulTemp) {
    case DEF_TYPE:
        strcpy(szT, "DEF");
        break;

    case DC_TYPE:
        strcpy(szT, "DC");
        break;

    case RGN_TYPE:
        strcpy(szT, "RGN");
        break;

    case SURF_TYPE:
        strcpy(szT, "SURF");
        break;

    case PATH_TYPE:
        strcpy(szT, "PATH");
        break;

    case PAL_TYPE:
        strcpy(szT, "PAL");
        break;

    case ICMLCS_TYPE:
        strcpy(szT, "ICMLCS");
        break;

    case LFONT_TYPE:
        strcpy(szT, "LFONT");
        break;

    case RFONT_TYPE:
        strcpy(szT, "RFONT");
        break;

    case PFE_TYPE:
        strcpy(szT, "PFE");
        break;

    case PFT_TYPE:
        strcpy(szT, "PFT");
        break;

    case ICMCXF_TYPE:
        strcpy(szT, "ICMCXF");
        break;

    case SPRITE_TYPE:
        strcpy(szT, "SPRITE");
        break;

    case SPACE_TYPE:
        strcpy(szT, "SPACE");
        break;

    case META_TYPE:
        strcpy(szT, "META");
        break;

    case EFSTATE_TYPE:
        strcpy(szT, "EFSTATE");
        break;

    case BMFD_TYPE:
        strcpy(szT, "BMFD");
        break;

    case VTFD_TYPE:
        strcpy(szT, "VTFD");
        break;

    case TTFD_TYPE:
        strcpy(szT, "TTFD");
        break;

    case RC_TYPE:
        strcpy(szT, "RC");
        break;

    case TEMP_TYPE:
        strcpy(szT, "TEMP");
        break;

    case DRVOBJ_TYPE:
        strcpy(szT, "DRVOBJ");
        break;

    case DCIOBJ_TYPE:
        strcpy(szT, "DCIOBJ");
        break;

    case SPOOL_TYPE:
        strcpy(szT, "SPOOL");
        break;

    default:
        ulTemp = LO_TYPE((USHORT)ReadField(FullUnique) << TYPE_SHIFT);
        switch (ulTemp) {
        case LO_BRUSH_TYPE:
            strcpy(szT, "BRUSH");
            break;

        case LO_PEN_TYPE:
            strcpy(szT, "LO_PEN");
            break;

        case LO_EXTPEN_TYPE:
            strcpy(szT, "LO_EXTPEN");
            break;

        case CLIENTOBJ_TYPE:
            strcpy(szT, "CLIENTOBJ");
            break;

        case LO_METAFILE16_TYPE:
            strcpy(szT, "LO_METAFILE16");
            break;

        case LO_METAFILE_TYPE:
            strcpy(szT, "LO_METAFILE");
            break;

        case LO_METADC16_TYPE:
            strcpy(szT, "LO_METADC16");
            break;
        }
    }
    return szT;
}

#endif // KERNEL


VOID DirectAnalyze(
    ULONG_PTR dw,
    ULONG_PTR adw,
    BOOL fNoSym)
{
    DWORD       index, cHandleEntries, dwHESize, dwHandleOffset;
    ULONG64     dwOffset, pshi, psi, phe;
    WORD        uniq, w, aw;
    CHAR        ach[80];
#ifdef KERNEL
    LPCSTR      psz;
#endif

    GETSHAREDINFO(pshi);
    GetFieldValue(pshi, SYM(SHAREDINFO), "psi", psi);

    dwHESize = GetTypeSize(SYM(HANDLEENTRY));
    GetFieldOffset(SYM(SHAREDINFO), "aheList", &dwHandleOffset);

    if (HIWORD(dw) != 0) {
        /*
         * See if its a handle
         */
        index = HMIndexFromHandle((ULONG)dw);
        GetFieldValue(psi, SYM(SERVERINFO), "cHandleEntries", cHandleEntries);
        if (index < cHandleEntries) {
            uniq = HMUniqFromHandle(dw);
            ReadPointer(pshi + dwHandleOffset, &phe);
            phe += index * dwHESize;
            _InitTypeRead(phe, SYM(HANDLEENTRY));
            if (((WORD)ReadField(wUniq)) == uniq) {
                Print("= a %s handle. ", pszObjStr[(ULONG)ReadField(bType)]);
                fNoSym = TRUE;
            }
        }

#ifdef KERNEL
        /*
         * See if it's a GDI object handle
         */
        psz = GetGDIHandleType((HOBJ)dw);
        if (*psz) {
            Print("= a GDI %s type handle. ", psz);
            fNoSym = TRUE;
        }
#endif // KERNEL

        /*
         * See if it's an object pointer
         */
        if (_InitTypeRead(dw, SYM(HEAD))) {
            if ((ULONG)ReadField(h)) {
                index = HMIndexFromHandle((ULONG)ReadField(h));
                if (index < cHandleEntries) {
                    ReadPointer(pshi + dwHandleOffset + index * dwHESize, &phe);
                    if (((ULONG_PTR)ReadField(phead)) == dw) {
                        Print("= a pointer to a %s.", pszObjStr[ReadField(bType)]);
                        fNoSym = TRUE;
                    }
                }
            }
            /*
             * Does this reference the stack itself?
             */
            w = HIWORD(dw);
            aw = HIWORD(adw);
            if (w == aw || w == aw - 1 || w == aw + 1) {
                Print("= Stack Reference ");
                fNoSym = TRUE;
            }
            if (!fNoSym) {
                /*
                 * Its accessible so print its symbolic reference
                 */
                GetSym(dw, ach, &dwOffset);
                if (*ach) {
                    Print("= symbol \"%s\"", ach);
                    if (dwOffset) {
                        Print(" + %p", dwOffset);
                    }
                }
            }
        }
    }
    Print("\n");
}

/***********************************************************************\
* Isas
*
* Analyzes the stack.  Looks at a range of dwords and tries to make
* sense out of them.  Identifies handles, user objects, and code
* addresses.
*
* 11/30/1995 Created SanfordS
\***********************************************************************/
BOOL Isas(
    DWORD opts,
    ULONG64 param1,
    ULONG64 param2)
{
    DWORD count = (DWORD)(UINT_PTR)param2;
    DWORD_PTR dw;
    DWORD dwPointerSize = GetTypeSize("PVOID");

    if (param1 == 0) {
        return FALSE;
    }

    if (opts & OFLAG(d)) {
        DirectAnalyze((ULONG_PTR)param1, 0, opts & OFLAG(s));
    } else {
        if (count == 0) {
            count = 25;    // default span
        }
        Print("--- Stack analysis ---\n");
        for ( ; count; count--, param1 += dwPointerSize) {
            if (IsCtrlCHit()) {
                break;
            }
            Print("[0x%p]: ", (ULONG_PTR)param1);
            if (tryMove(dw, param1)) {
                DirectAnalyze(dw, (DWORD_PTR)param1, OFLAG(s) & opts);
            } else {
                Print("No access\n");
            }
        }
    }
    return TRUE;
}

#ifdef KERNEL

typedef VOID (*AtomPrint)(DWORD dwOneShot, RTL_ATOM atom, USHORT usRefCount,
                         const WCHAR* pwszName, UCHAR uNameLength, UCHAR uFlags);

VOID DefAtomPrint(
    DWORD dwOneShot,
    RTL_ATOM atom,
    USHORT usRefCount,
    const WCHAR* pwszName,
    UCHAR uNameLength,
    UCHAR uFlags)
{
    Print("%*s%hx(%2d) = %ls (%d)%s\n",
            dwOneShot, dwOneShot ? " " : "",  // hack: fOneShot is also used as a prefix spaces...
            atom,
            usRefCount,
            pwszName,
            uNameLength,
            uFlags & RTL_ATOM_PINNED ? " pinned" : "");
}

/************************************************************************\
* DumpAtomTable
*
* Dumps an atom or entire atom table.
*
* 6/9/1995 Created SanfordS
\************************************************************************/
BOOL DumpAtomTable(
    PTR table,
    RTL_ATOM atomFind,
    DWORD dwOneShot,
    AtomPrint pfnPrint)
{
    ULONG i;
    ULONG cBuckets;
    ULONG cb, cbPtr, cbBuckets;
    ULONG64 pate;
    RTL_ATOM atom;
    UCHAR Flags;
    USHORT RefCount;
    UCHAR NameLength;
    WCHAR *pName;

    if (pfnPrint == NULL) {
        pfnPrint = DefAtomPrint;
    }

    if (!dwOneShot) {
        Print("\n");
    }

    cbPtr = GetTypeSize("PVOID");
    GetFieldValue(table, "nt!_RTL_ATOM_TABLE", "NumberOfBuckets", cBuckets);
    GetFieldOffset("nt!_RTL_ATOM_TABLE", "Buckets", &cbBuckets);

    for (i = 0; i < cBuckets; i++) {
        ShowProgress();
        ReadPointer(table + cbBuckets + i * cbPtr, &pate);

        if (atomFind == 0 && pate != 0 && !dwOneShot) {
            Print("   Bucket %d\n", i);
        }

        while (pate != NULL_PTR) {
            GetFieldValue(pate, "nt!_RTL_ATOM_TABLE_ENTRY", "Atom", atom);
            GetFieldValue(pate, "nt!_RTL_ATOM_TABLE_ENTRY", "Flags", Flags);
            GetFieldValue(pate, "nt!_RTL_ATOM_TABLE_ENTRY", "ReferenceCount", RefCount);
            GetFieldValue(pate, "nt!_RTL_ATOM_TABLE_ENTRY", "NameLength", NameLength);
            GetFieldOffset("nt!_RTL_ATOM_TABLE_ENTRY", "Name", &cb);

            pName = LocalAlloc(LPTR, sizeof(WCHAR) * (NameLength + 1));
            ReadMemory(pate + cb, (PVOID)pName, sizeof(WCHAR) * NameLength, &cb);
            pName[NameLength] = L'\0';

            if (atomFind == 0 || atom == atomFind) {
                pfnPrint(dwOneShot, atom, RefCount, pName, NameLength, Flags);

                if (atom == atomFind) {
                    LocalFree(pName);
                    return TRUE;
                }
            }

            LocalFree(pName);
            GetFieldValue(pate, "nt!_RTL_ATOM_TABLE_ENTRY", "HashLink", pate);
        }
    }

    return FALSE;
}

/************************************************************************\
* Iatom
*
* Dumps an atom or the entire local USER atom table.
*
* 6/9/1995 Created SanfordS
\************************************************************************/
BOOL Iatom(
    DWORD opts,
    ULONG64 atom)
{
    PTR table;
    PTR pwinsta;

    UNREFERENCED_PARAMETER(opts);

    table = GetGlobalPointer(VAR(UserAtomTableHandle));

    if (table != NULL_PTR) {
        Print("\nPrivate atom table for WIN32K ");
        DumpAtomTable(table, (RTL_ATOM)atom, FALSE, NULL);
    }

    FOREACHWINDOWSTATION(pwinsta)

        GetFieldValue(pwinsta, SYM(WINDOWSTATION), "pGlobalAtomTable", table);

        if (table != NULL_PTR) {
            Print(" \nGlobal atom table for window station %lx ", pwinsta);
            DumpAtomTable(table, (RTL_ATOM)atom, FALSE, NULL);
        }

    NEXTEACHWINDOWSTATION(pwinsta);

    return TRUE;
}
#endif // KERNEL

#ifdef OLD_DEBUGGER
#ifndef KERNEL
/************************************************************************\
* DumpConvInfo
*
* Dumps DDEML client conversation info structures.
*
* 6/9/1995 Created SanfordS
\************************************************************************/
BOOL DumpConvInfo(
    PCONV_INFO pcoi)
{
    CL_CONV_INFO coi;
    ADVISE_LINK al;
    XACT_INFO xi;

    move(coi, pcoi);
    Print("    next              = 0x%08lx\n", coi.ci.next);
    Print("    pcii              = 0x%08lx\n", coi.ci.pcii);
    Print("    hUser             = 0x%08lx\n", coi.ci.hUser);
    Print("    hConv             = 0x%08lx\n", coi.ci.hConv);
    Print("    laService         = 0x%04x\n",  coi.ci.laService);
    Print("    laTopic           = 0x%04x\n",  coi.ci.laTopic);
    Print("    hwndPartner       = 0x%08lx\n", coi.ci.hwndPartner);
    Print("    hwndConv          = 0x%08lx\n", coi.ci.hwndConv);
    Print("    state             = 0x%04x\n",  coi.ci.state);
    Print("    laServiceRequested= 0x%04x\n",  coi.ci.laServiceRequested);
    Print("    pxiIn             = 0x%08lx\n", coi.ci.pxiIn);
    Print("    pxiOut            = 0x%08lx\n", coi.ci.pxiOut);
    SAFEWHILE (coi.ci.pxiOut) {
        move(xi, coi.ci.pxiOut);
        Print("      hXact           = (0x%08lx)->0x%08lx\n", xi.hXact, coi.ci.pxiOut);
        coi.ci.pxiOut = xi.next;
    }
    Print("    dmqIn             = 0x%08lx\n", coi.ci.dmqIn);
    Print("    dmqOut            = 0x%08lx\n", coi.ci.dmqOut);
    Print("    aLinks            = 0x%08lx\n", coi.ci.aLinks);
    Print("    cLinks            = 0x%08lx\n", coi.ci.cLinks);
    SAFEWHILE (coi.ci.cLinks--) {
        move(al, coi.ci.aLinks++);
        Print("      pLinkCount = 0x%08x\n", al.pLinkCount);
        Print("      wType      = 0x%08x\n", al.wType);
        Print("      state      = 0x%08x\n", al.state);
        if (coi.ci.cLinks) {
            Print("      ---\n");
        }
    }
    if (coi.ci.state & ST_CLIENT) {
        Print("    hwndReconnect     = 0x%08lx\n", coi.hwndReconnect);
        Print("    hConvList         = 0x%08lx\n", coi.hConvList);
    }

    return TRUE;
}
#endif // !KERNEL

#endif // OLD_DEBUGGER

#ifndef KERNEL
/************************************************************************\
* FixKernelPointer
*
* Converts a kernel object pointer into its client-side equivalent. Client
* pointers and NULL are unchanged.
*
* 6/15/1995 Created SanfordS
\************************************************************************/
ULONG64
FixKernelPointer(
    PTR pKernel)
{
    static ULONG64 pteb = 0;
    static ULONG64 ulClientDelta;
    static ULONG64 HighestUserAddress;

    if (pKernel == 0) {
        return 0;
    }
    if (HighestUserAddress == 0) {
        SYSTEM_BASIC_INFORMATION SystemInformation;

        if (NT_SUCCESS(NtQuerySystemInformation(SystemBasicInformation,
                                                 &SystemInformation,
                                                 sizeof(SystemInformation),
                                                 NULL))) {
            HighestUserAddress = SystemInformation.MaximumUserModeAddress;
        } else {
            // Query failed.  Assume usermode is the low half of the address
            // space.
            HighestUserAddress = MAXINT_PTR;
        }
    }

    if (!IsPtr64()) {
        pKernel = (ULONG)pKernel;
    }

    if (pKernel <= HighestUserAddress) {
        return pKernel;
    }
    if (pteb == 0) {
        ULONG pciOffset;

        GetTebAddress(&pteb);
        GetFieldOffset(SYM(TEB), "Win32ClientInfo", &pciOffset);
        GetFieldValue(pteb + pciOffset, SYM(CLIENTINFO), "ulClientDelta", ulClientDelta);
    }
    return (pKernel - ulClientDelta);
}

ULONG64
RebaseSharedPtr(ULONG64 p)
{
    ULONG64         pshi = 0;
    ULONG64         ulSharedDelta;

    if (p == 0) {
        return 0;
    }

    moveExp(&pshi, VAR(gSharedInfo));
    if (pshi == 0) {
        RAISE_EXCEPTION();
    }
    if (!GetFieldValue(pshi, SYM(SHAREDINFO), "ulSharedDelta", ulSharedDelta)) {
        RAISE_EXCEPTION();
    }

    return p - ulSharedDelta;
}

#endif // !KERNEL

/************************************************************************\
* Procedure: GetVKeyName
*
* 08/09/98 HiroYama     Created
*
\************************************************************************/

typedef struct {
    DWORD dwVKey;
    const char* name;
} VKeyDef;

int compareVKey(const VKeyDef* a, const VKeyDef* b)
{
    return a->dwVKey - b->dwVKey;
}

#define VKEY_ITEM(x) { x, #x }

const VKeyDef gVKeyDef[] = {
#include "vktbl.txt"
};

const char* _GetVKeyName(DWORD dwVKey, int n)
{
    int i;

    /*
     * If dwVKey is one of alphabets or numerics, there's no VK_ macro defined.
     */
    if ((dwVKey >= 'A' && dwVKey <= 'Z') || (dwVKey >= '0' && dwVKey <= '9')) {
        static char buffer[] = "VK_*";

        if (n != 0) {
            return "";
        }
        buffer[ARRAY_SIZE(buffer) - 2] = (BYTE)dwVKey;
        return buffer;
    }

    /*
     * Search the VKEY table.
     */
    for (i = 0; i < ARRAY_SIZE(gVKeyDef); ++i) {
        const VKeyDef* result = gVKeyDef + i;

        if (result->dwVKey == dwVKey) {
            for (; i < ARRAY_SIZE(gVKeyDef); ++i) {
                if (gVKeyDef[i].dwVKey != dwVKey) {
                    return "";
                }
                if (&gVKeyDef[i] - result == n) {
                    return gVKeyDef[i].name;
                }
            }
        }
    }

    /*
     * VKey name is not found.
     */
    return "";
}

const char* GetVKeyName(DWORD dwVKey)
{
    static char buf[256];
    const char* delim = "";
    int n = 0;

    buf[0] = 0;

    for (n = 0; n < ARRAY_SIZE(gVKeyDef); ++n) {
        const char* name = _GetVKeyName(dwVKey, n);
        if (*name) {
            strcat(buf, delim);
            strcat(buf, name);
            delim = " / ";
        } else {
            break;
        }
    }
    return buf;
}

#undef VKEY_ITEM

#ifdef KERNEL
/************************************************************************\
* Procedure: DumpClassList
*
*
* 05/18/98 GerardoB     Extracted from Idcls
\************************************************************************/
VOID DumpClassList(
    DWORD opts,
    ULONG64 pcls,
    BOOL fPrivate)
{
    ULONG64 pclsClone;
    ULONG64 pclsNext;

    SAFEWHILE (pcls != 0) {
        if (GetFieldValue(pcls, SYM(CLS), "pclsClone", pclsClone)) {
            Print("  Private class\t\tPCLS @ 0x%p - inaccessible, skipping...\n", pcls);
            break;
        }
        Print("  %s class\t\t", fPrivate ? "Private" : "Public ");
        Idcls(opts, pcls);

        if (pclsClone != 0) {
            SAFEWHILE (pclsClone != 0) {
                if (GetFieldValue(pclsClone, SYM(CLS), "pclsNext", pclsNext)) {
                    Print("Could not access clone class at %p, skipping clones...\n", pclsClone);
                    break;
                }
                Print("  %s class clone\t", fPrivate ? "Private" : "Public ");
                Idcls(opts, pclsClone);
                pclsClone = pclsNext;
            }
        }

        GetFieldValue(pcls, SYM(CLS), "pclsNext", pcls);
    }
}

ULONG
dclsCallback(
    ULONG64 ppi,
    PVOID   Data)
{
    DWORD opts = PtrToUlong(Data);
    ULONG64 pcls;

    UNREFERENCED_PARAMETER(Data);

    Print("\nClasses for process %p:\n", ppi);

    GetFieldValue(ppi, SYM(PROCESSINFO), "pclsPrivateList", pcls);
    DumpClassList(opts, pcls, TRUE);

    GetFieldValue(ppi, SYM(PROCESSINFO), "pclsPublicList", pcls);
    DumpClassList(opts, pcls, FALSE);

    return FALSE;
}

/************************************************************************\
* Idcls
*
* Dumps window class structures
*
* 6/9/1995 Created SanfordS
\************************************************************************/
BOOL Idcls(
    DWORD opts,
    ULONG64 param1)
{
    char ach[120];
    ULONG64 dwOffset;
    ULONG64 pcls = param1;

    if (param1 == 0) {

        ForEachPpi(dclsCallback, ULongToPtr(opts));

        Print("\nGlobal Classes:\n");
        pcls = GetGlobalPointer(VAR(gpclsList));
        SAFEWHILE (pcls) {
            Print("  Global Class\t\t");
            Idcls(opts, pcls);
            GetFieldValue(pcls, SYM(CLS), "pclsNext", pcls);
        }
        return TRUE;
    }

    /*
     * Dump class list for a process
     */
    if (opts & OFLAG(p)) {
        opts &= ~OFLAG(p);
        Print("\nClasses for process %p:\n", param1);

        GetFieldValue(param1, SYM(PROCESSINFO), "pclsPrivateList", pcls);
        DumpClassList(opts, pcls, TRUE);

        GetFieldValue(param1, SYM(PROCESSINFO), "pclsPublicList", pcls);
        DumpClassList(opts, pcls, FALSE);

        return TRUE;
    }

    _InitTypeRead(pcls, SYM(tagCLS));

    DebugGetClassNameA(ReadField(lpszAnsiClassName), ach);
    Print("PCLS @ 0x%p \t(%s)\n", pcls, ach);
    if (opts & OFLAG(v)) {
        Print("\t pclsNext                      0x%p\n"
              "\t atomClassNameAtom (V)         0x%04x\n"
              "\t atomNVClassNameAtom (NV)      0x%04x\n"
              "\t fnid                          0x%04x\n"
              "\t pDCE                          0x%p\n"
              "\t cWndReferenceCount            0x%08lx\n"
              "\t flags                         %s\n",

              ReadField(pclsNext),
              (ULONG)ReadField(atomClassName),
              (ULONG)ReadField(atomNVClassName),
              (ULONG)ReadField(fnid),
              ReadField(pdce),
              (ULONG)ReadField(cWndReferenceCount),
              GetFlags(GF_CSF, (WORD)ReadField(CSF_flags), NULL, TRUE));

        if (ReadField(lpszClientAnsiMenuName)) {
            move(ach, ReadField(lpszClientAnsiMenuName));
            ach[sizeof(ach) - 1] = '\0';
        } else {
            ach[0] = '\0';
        }
        Print("\t lpszClientMenu                0x%p (%s)\n",
              ReadField(lpszClientUnicodeMenuName),
              ach);

        Print("\t hTaskWow                      0x%08lx\n"
              "\t spcpdFirst                    0x%p\n"
              "\t pclsBase                      0x%p\n"
              "\t pclsClone                     0x%p\n",
              (ULONG)ReadField(hTaskWow),
              ReadField(spcpdFirst),
              ReadField(pclsBase),
              ReadField(pclsClone));

        GetSym(ReadField(lpfnWndProc), ach, &dwOffset);
        Print("\t style                         %s\n"
              "\t lpfnWndProc                   0x%p = \"%s\" \n"
              "\t cbclsExtra                    0x%08lx\n"
              "\t cbwndExtra                    0x%08lx\n"
              "\t hModule                       0x%p\n"
              "\t spicn                         0x%p\n"
              "\t spcur                         0x%p\n"
              "\t hbrBackground                 0x%p\n"
              "\t spicnSm                       0x%p\n",
              GetFlags(GF_CS, (DWORD)ReadField(style), NULL, TRUE),
              ReadField(lpfnWndProc), ach,
              (ULONG)ReadField(cbclsExtra),
              (ULONG)ReadField(cbwndExtra),
              ReadField(hModule),
              ReadField(spicn),
              ReadField(spcur),
              ReadField(hbrBackground),
              ReadField(spicnSm));
    }

    return TRUE;
}
#endif // KERNEL

#ifdef KERNEL



LPSTR ProcessName(
    ULONG64 ppi)
{
    ULONG64 pEProcess;
    static UCHAR ImageFileName[16];

    GetFieldValue(ppi, "win32k!W32PROCESS", "Process", pEProcess);
    GetFieldValue(pEProcess, "nt!EPROCESS", "ImageFileName", ImageFileName);
    if (ImageFileName[0]) {
        return ImageFileName;
    } else {
        return "System";
    }
}

#endif // KERNEL

#ifdef KERNEL


VOID PrintCurHeader()
{
    Print("P = Process Owned.\n");
    Print("P pcursor    flags  rt   Res/Name   ModAtom  bpp cx  cy  xHot yHot hbmMask    hbmColor   hbmUserAlpha\n");
}


VOID PrintCurData(
    ULONG64 pcur,
    DWORD opts)
{
    _InitTypeRead(pcur, SYM(CURSOR));

    if ((opts & OFLAG(x)) &&
        (((DWORD) ReadField(CURSORF_flags)) & (CURSORF_ACONFRAME | CURSORF_LINKED))) {
        return; // skip acon frame or linked objects.
    }

    if (((DWORD) ReadField(CURSORF_flags)) & CURSORF_ACON) {

        if (opts & OFLAG(a)) {
            Print("--------------\n");
        }

        if (opts & OFLAG(o)) {
            Print("\nOwner:%#010p (%s)\n", ReadField(head.ppi), ProcessName(ReadField(head.ppi)));
        }

        if (opts & OFLAG(v)) {
            Print("\nACON @ 0x%p:\n", pcur);
            Print("  ppiOwner       = %#010p\n", ReadField(head.ppi));
            Print("  CURSORF_flags  = %s\n", GetFlags(GF_CURSORF, (DWORD) ReadField(CURSORF_flags), NULL, TRUE));
            Print("  strName        = %#010p\n", ReadField(strName.Buffer));
            Print("  atomModName    = %#x\n", (DWORD) ReadField(atomModName));
            Print("  rt             = %#x\n", (DWORD) ReadField(rt));
        } else {
            ULONG64 cpcur = 0;
            GetFieldValue(pcur, SYM(ACON), "cpcur", cpcur);

            Print("%c %#010p %#6x %#4x %#010p %#8x --- ACON (%d frames)\n",
                ReadField(head.ppi) ? 'P' : ' ',
                pcur,
                (DWORD) ReadField(CURSORF_flags),
                (DWORD) ReadField(rt),
                ReadField(strName.Buffer),
                (DWORD) ReadField(atomModName),
                (DWORD) cpcur);
        }

        if (opts & OFLAG(a)) {
            int i = 0;
            ULONG cbElement = 0;
            ULONG cbArrayOffset = 0;
            ULONG64 curFrame = 0;

            _InitTypeRead(pcur, SYM(ACON));

            cbElement = GetTypeSize("PCURSOR");
            GetFieldOffset(SYM(ACON), "aspcur", &cbArrayOffset);

            Print("%d animation sequences, currently at step %d.\n",
                  (DWORD) ReadField(cicur),
                  (DWORD) ReadField(iicur));

            i = (int) ReadField(cpcur);
            while (i--) {
                ReadPointer(pcur + cbArrayOffset + (i * cbElement), &curFrame);
                PrintCurData(curFrame, opts & ~(OFLAG(x) | OFLAG(o)));
            }
            Print("--------------\n");
        }
    } else {
        if (opts & OFLAG(v)) {
            Print("\nCursor/Icon @ 0x%p:\n", pcur);
            Print("  ppiOwner       = %#010p (%s)\n", ReadField(head.ppi), ProcessName(ReadField(head.ppi)));
            Print("  pcurNext       = %#010p\n", ReadField(pcurNext));
            Print("  CURSORF_flags  = %s\n", GetFlags(GF_CURSORF, (DWORD) ReadField(CURSORF_flags), NULL, TRUE));
            Print("  strName        = %#010p\n", ReadField(strName.Buffer));
            Print("  atomModName    = %#x\n", (DWORD) ReadField(atomModName));
            Print("  rt             = %#x\n", (DWORD) ReadField(rt));
            Print("  bpp            = %d\n", (DWORD) ReadField(bpp));
            Print("  cx             = %d\n", (DWORD) ReadField(cx));
            Print("  cy             = %d\n", (DWORD) ReadField(cy));
            Print("  xHotspot       = %d\n", (DWORD) ReadField(xHotspot));
            Print("  yHotspot       = %d\n", (DWORD) ReadField(yHotspot));
            Print("  hbmMask        = %#x\n", (DWORD) ReadField(hbmMask));
            Print("  hbmColor       = %#x\n", (DWORD) ReadField(hbmColor));
            Print("  hbmUserAlpha   = %#x\n", (DWORD) ReadField(hbmUserAlpha));
        } else {
            if (opts & OFLAG(o)) {
                Print("\nOwner:%#010p (%s)\n", ReadField(head.ppi), ProcessName(ReadField(head.ppi)));
            }
            Print("%c %#010p %#06x %#04x %#010p %#08x %3d %3d %3d %4d %4d %#010x %#010x %#010x\n",
                ReadField(head.ppi) ? 'P' : ' ',
                pcur,
                (DWORD) ReadField(CURSORF_flags),
                (DWORD) ReadField(rt),
                ReadField(strName.Buffer),
                (DWORD) ReadField(atomModName),
                (DWORD) ReadField(bpp),
                (DWORD) ReadField(cx),
                (DWORD) ReadField(cy),
                (DWORD) ReadField(xHotspot),
                (DWORD) ReadField(yHotspot),
                (DWORD) ReadField(hbmMask),
                (DWORD) ReadField(hbmColor),
                (DWORD) ReadField(hbmUserAlpha));
        }
    }
}

typedef struct tagMyCurData
{
    ULONG64 ppiDesired;
    ULONG idDesired;
    DWORD opts;
} MyCurData;

ULONG WDBGAPI PrintPpiCurData(ULONG64 ppi, PVOID Data)
{
    ULONG64 pcur = 0;

    MyCurData * pMyCurData = (MyCurData *)Data;
    if (pMyCurData == NULL) {
        return 0;
    }

    _InitTypeRead(ppi, SYM(PROCESSINFO));

    if (ReadField(pCursorCache)) {
        Print("\nCache for process %#010p (%s):\n", ppi, ProcessName(ppi));
        pcur = ReadField(pCursorCache);
        while (pcur) {
            _InitTypeRead(pcur, SYM(CURSOR));
            if ((pMyCurData->idDesired == 0) || ((ULONG) ReadField(strName.Buffer) == pMyCurData->idDesired)) {
                if (ReadField(head.ppi) != ppi) {
                    Print("Wrong cache! Owned by %#010p! --v\n", ReadField(head.ppi));
                }
                PrintCurData(pcur, pMyCurData->opts);
            }
            pcur = ReadField(pcurNext);
        }
    }

    return 0;
}

/************************************************************************\
* Idcur
*
* Dump cursor structures.
*
* 6/9/1995 Created SanfordS
\************************************************************************/
BOOL Idcur(
    DWORD opts,
    ULONG64 param1)
{
    ULONG64 ppi = 0;
    ULONG64 ppiDesired = 0;
    ULONG idDesired = 0;
    ULONG64 pcur = 0;
    ULONG64 phe = 0;
    int cCursors = 0;
    int i;

    if (OFLAG(p) & opts) {
        ppiDesired = param1;
        param1 = 0;
    } else if (OFLAG(i) & opts) {
        idDesired = (ULONG) param1;
        param1 = 0;
    }

    if (param1 == 0) {
        if (!(OFLAG(v) & opts)) {
            PrintCurHeader();
        }

        pcur = GetGlobalPointer(VAR(gpcurFirst));

        if (pcur != 0 && ppiDesired == 0) {
            Print("\nGlobal cache:\n");

            while (pcur) {
                _InitTypeRead(pcur, SYM(CURSOR));

                if (!idDesired || ((ULONG) ReadField(strName.Buffer) == idDesired)) {
                    if (ReadField(head.ppi) != 0) {
                        Print("Wrong cache! Owned by %010p! --v\n", ReadField(head.ppi));
                    }
                    PrintCurData(pcur, opts);
                }
                pcur = ReadField(pcurNext);
            }
        }

        if (ppiDesired == 0 || ppiDesired == ppi) {
            MyCurData myCurData;

            myCurData.ppiDesired = ppiDesired;
            myCurData.idDesired = idDesired;
            myCurData.opts = opts;

            ForEachPpi(PrintPpiCurData, &myCurData);
        }

        Print("\nNon-cached cursor objects:\n");

        FOREACHHANDLEENTRY(phe, i)
            _InitTypeRead(phe, SYM(HANDLEENTRY));

            if (ReadField(bType) == TYPE_CURSOR) {
                pcur = ReadField(phead);
                _InitTypeRead(pcur, SYM(CURSOR));

                if (!(ReadField(CURSORF_flags) & (CURSORF_LINKED | CURSORF_ACONFRAME)) &&
                        (!idDesired || ((ULONG) ReadField(strName.Buffer) == idDesired)) &&
                        (ppiDesired == 0 || ppiDesired == ReadField(head.ppi))) {
                    PrintCurData(pcur, opts | OFLAG(x) | OFLAG(o));
                }
                cCursors++;
            }
        NEXTEACHHANDLEENTRY()

        Print("\n%d Cursors/Icons Total.\n", cCursors);
        return TRUE;
    }

    pcur = HorPtoP(param1, TYPE_CURSOR);
    if (pcur == 0) {
        Print("%010p : Invalid cursor handle or pointer.\n", param1);
        return FALSE;
    }

    if (!(OFLAG(v) & opts)) {
        PrintCurHeader();
    }

    PrintCurData(pcur, opts);
    return TRUE;
}
#endif // KERNEL


#ifdef KERNEL
/************************************************************************\
* ddeexact
*
* Dumps DDEML transaction structures.
*
* 6/9/1995 Created SanfordS
\************************************************************************/
BOOL dddexact(
    ULONG64 pxs,
    DWORD opts)
{
    _InitTypeRead(pxs, SYM(XSTATE));
    if (opts & OFLAG(v)) {
        Print("    XACT:0x%p\n", pxs);
        Print("      snext = 0x%#p\n", ReadField(snext));
        Print("      fnResponse = 0x%#p\n", ReadField(fnResponse));
        Print("      hClient = 0x%08lx\n", (ULONG)ReadField(hClient));
        Print("      hServer = 0x%08lx\n", (ULONG)ReadField(hServer));
        Print("      pIntDdeInfo = 0x%#p\n", ReadField(pIntDdeInfo));
    } else {
        Print("0x%#p(0x%08lx) ", pxs, (ULONG)ReadField(flags));
    }
    return TRUE;
}
#endif // KERNEL


#ifdef KERNEL
/************************************************************************\
* ddeconv
*
* Dumps DDE tracking layer conversation structures.
*
* 6/9/1995 Created SanfordS
\************************************************************************/
BOOL dddeconv(
    ULONG64 pDdeconv,
    DWORD opts)
{
    ULONG64 pxs;
    int cX;
    DWORD dwOffset, dwQosOffset;

    _InitTypeRead(pDdeconv, SYM(DDECONV));
    Print("  CONVERSATION-PAIR(0x%p:0x%p)\n", pDdeconv, ReadField(spartnerConv));
    if (opts & OFLAG(v)) {
        Print("    snext        = 0x%p\n", ReadField(snext));
        Print("    spwnd        = 0x%p\n", ReadField(spwnd));
        Print("    spwndPartner = 0x%p\n", ReadField(spwndPartner));
    }
    if (opts & (OFLAG(v) | OFLAG(r))) {
        if (ReadField(spxsOut)){
            pxs = ReadField(spxsOut);
            cX = 0;
            SAFEWHILE (pxs) {
                if ((opts & OFLAG(r)) && !cX++) {
                    Print("    Transaction chain:");
                } else {
                    Print("    ");
                }
                dddexact(pxs, opts);
                if (opts & OFLAG(r)) {
                    GetFieldValue(pxs, SYM(STATE), "snext", pxs);
                } else {
                    pxs = 0;
                }
                if (!pxs) {
                    Print("\n");
                }
            }
        }
    }
    if (opts & OFLAG(v)) {
        Print("    pfl          = 0x%p\n", ReadField(pfl));
        Print("    flags        = 0x%08lx\n", (ULONG)ReadField(flags));
        if ((opts & OFLAG(v)) && (opts & OFLAG(r)) && ReadField(pddei)) {
            GetFieldOffset(SYM(DDECONV), "pddei", &dwOffset);
            GetFieldOffset(SYM(DDEIMP), "qos", &dwQosOffset);
            _InitTypeRead(pDdeconv + dwOffset + dwQosOffset,  SYM(DDEI));
            Print("    pddei    = 0x%08lx\n", pDdeconv+ dwOffset);
            Print("    Impersonation info:\n");
            Print("      qos.Length                 = 0x%08lx\n", (ULONG)ReadField(Length));
            Print("      qos.ImpersonationLevel     = 0x%08lx\n", (ULONG)ReadField(ImpersonationLevel));
            Print("      qos.ContextTrackingMode    = 0x%08lx\n", (ULONG)ReadField(ContextTrackingMode));
            Print("      qos.EffectiveOnly          = 0x%08lx\n", (ULONG)ReadField(EffectiveOnly));
            _InitTypeRead(pDdeconv + dwOffset, SYM(DDEIMP));
            GetFieldOffset(SYM(DDEIMP), "ClientContext", &dwOffset);
            Print("      ClientContext              = 0x%#p\n", pDdeconv + dwOffset);
            Print("      cRefInit                   = 0x%08lx\n", (ULONG)ReadField(cRefInit));
            Print("      cRefConv                   = 0x%08lx\n", (ULONG)ReadField(cRefConv));
        }
    }
    return TRUE;
}
#endif // KERNEL


#ifdef KERNEL
/************************************************************************\
* Idde
*
* Dumps DDE tracking layer state and structures.
*
* 6/9/1995 Created SanfordS
\************************************************************************/
BOOL Idde(
    DWORD opts,
    ULONG64 param1)
{
    ULONG64 pshi, psi, cHandleEntries, pheList, h, pPropList, ptr;
    ULONG64 pObj = 0;
    UINT i, iFirstFree;
    DWORD atomDdeTrack, dwOffset;
    DWORD dwHESize = GetTypeSize(SYM(HANDLEENTRY));
    DWORD dwPropSize = GetTypeSize(SYM(PROP));
    BYTE bType;

    moveExpValue(&atomDdeTrack, VAR(atomDDETrack));

    GETSHAREDINFO(pshi);

    GetFieldOffset(SYM(SHAREDINFO), "psi", &dwOffset);
    ReadPointer(pshi + dwOffset, &psi);

    GetFieldOffset(SYM(SHAREDINFO), "aheList", &dwOffset);
    ReadPointer(pshi + dwOffset, &pheList);

    GetFieldValue(psi, SYM(SERVERINFO), "cHandleEntries", cHandleEntries);

    if (param1) {
        /*
         * get object param.
         */
        i = HMIndexFromHandle((ULONG_PTR)param1);
        if (i >= cHandleEntries) {
            GetFieldValue(param1, SYM(HEAD), "h", h);
            i = HMIndexFromHandle(h);
        }
        if (i >= cHandleEntries) {
            Print("0x%08lx is not a valid object.\n", h);
            return FALSE;
        }
        GetFieldOffset(SYM(HANDLEENTRY), "phead", &dwOffset);
        ReadPointer(pheList + i * dwHESize + dwOffset, &pObj);
        /*
         * verify type.
         */
        GetFieldValue(pheList + i * dwHESize, SYM(HANDLEENTRY), "bType", bType);
        switch (bType) {
        case TYPE_WINDOW:
            GetFieldOffset(SYM(WND), "ppropList", &dwOffset);
            ReadPointer(pObj + dwOffset, &pPropList);
            GetFieldValue(pPropList, SYM(PROPLIST), "iFirstFree", iFirstFree);
            for (i = 0; i < iFirstFree; i++) {
                if (i == 0) {
                    Print("Window 0x%08lx conversations:\n", h);
                }
                GetFieldOffset(SYM(PROPLIST), "aprop", &dwOffset);
                ReadPtr(pPropList + dwOffset + i * dwPropSize, &ptr);
                _InitTypeRead(ptr, SYM(PROP));
                if (ReadField(atomKey) == (ATOM)MAKEINTATOM(atomDdeTrack)) {
                    Print("  ");
                    dddeconv(ReadField(hData), opts);
                }
            }
            return TRUE;

        case TYPE_DDECONV:
        case TYPE_DDEXACT:
            break;

        default:
            Print("0x%08lx is not a valid window, conversation or transaction object.\n", h);
            return FALSE;
        }
    }

    /*
     * look for all qualifying objects in the object table.
     */

    Print("DDE objects:\n");
    for (i = 0; i < cHandleEntries; i++) {
        _InitTypeRead(pheList + i * dwHESize , SYM(HANDLEENTRY));
        if ((BYTE)ReadField(bType) == TYPE_DDECONV && ((pObj == FIXKP(ReadField(phead))) || pObj == 0)) {
            dddeconv(FIXKP(ReadField(phead)), opts);
        }

        if ((BYTE)ReadField(bType) == TYPE_DDEXACT && (pObj == 0 || pObj == FIXKP(ReadField(phead)))) {
            if (!(opts & OFLAG(v))) {
                Print("  XACT:");
            }
            dddexact(FIXKP(ReadField(phead)), opts);
            Print("\n");
        }
    }
    return TRUE;
}
#endif // KERNEL



#ifdef OLD_DEBUGGER
#ifndef KERNEL
/************************************************************************\
* Iddeml
*
* Dumps the DDEML state for this client process.
*
* 6/9/1995 Created SanfordS
\************************************************************************/
BOOL Iddeml(
    DWORD opts,
    LPSTR lpas)
{
    CHANDLEENTRY he, *phe;
    int cHandles, ch, i;
    DWORD Type;
    DWORD_PTR Instance, Object, Pointer;
    CL_INSTANCE_INFO cii, *pcii;
    ATOM ns;
    SERVER_LOOKUP sl;
    LINK_COUNT lc;
    CL_CONV_INFO cci;
    PCL_CONV_INFO pcci;
    CONVLIST cl;
    HWND hwnd, *phwnd;
    XACT_INFO xi;
    DDEMLDATA dd;
    CONV_INFO ci;

    moveExpValue(&cHandles, "user32!cHandlesAllocated");

    Instance = 0;
    Type = 0;
    Object = 0;
    Pointer = 0;
    SAFEWHILE (*lpas) {
        SAFEWHILE (*lpas == ' ')
            lpas++;

        if (*lpas == 'i') {
            lpas++;
            Instance = (DWORD_PTR)EvalExp(lpas);
            SAFEWHILE (*lpas != ' ' && *lpas != 0)
                lpas++;
            continue;
        }
        if (*lpas == 't') {
            lpas++;
            Type = (DWORD)(DWORD_PTR)EvalExp(lpas);
            SAFEWHILE (*lpas != ' ' && *lpas != 0)
                lpas++;
            continue;
        }
        if (*lpas) {
            Object = Pointer = (DWORD_PTR)EvalExp(lpas);
            SAFEWHILE (*lpas != ' ' && *lpas != 0)
                lpas++;
        }
    }

    /*
     * for each instance for this process...
     */

    pcii = GetGlobalPointer("user32!pciiList");
    if (pcii == NULL) {
        Print("No Instances exist.\n");
        return TRUE;
    }
    move(cii, pcii);
    SAFEWHILE (pcii != NULL) {
        pcii = cii.next;
        if (Instance == 0 || (Instance == (DWORD_PTR)cii.hInstClient)) {
            Print("Objects for instance 0x%p:\n", cii.hInstClient);
            ch = cHandles;
            phe = GetGlobalPointer("user32!aHandleEntry");
            SAFEWHILE (ch--) {
                move(he, phe++);
                if (he.handle == 0) {
                    continue;
                }
                if (InstFromHandle(cii.hInstClient) != InstFromHandle(he.handle)) {
                    continue;
                }
                if (Type && TypeFromHandle(he.handle) != Type) {
                    continue;
                }
                if (Object && (he.handle != (HANDLE)Object) &&
                    Pointer && he.dwData != Pointer) {
                    continue;
                }
                Print("  (0x%08lx)->0x%08lx ", he.handle, he.dwData);
                switch (TypeFromHandle(he.handle)) {
                case HTYPE_INSTANCE:
                    Print("Instance\n");
                    if (opts & OFLAG(v)) {
                        Print("    next               = 0x%08lx\n", cii.next);
                        Print("    hInstServer        = 0x%08lx\n", cii.hInstServer);
                        Print("    hInstClient        = 0x%08lx\n", cii.hInstClient);
                        Print("    MonitorFlags       = 0x%08lx\n", cii.MonitorFlags);
                        Print("    hwndMother         = 0x%08lx\n", cii.hwndMother);
                        Print("    hwndEvent          = 0x%08lx\n", cii.hwndEvent);
                        Print("    hwndTimeout        = 0x%08lx\n", cii.hwndTimeout);
                        Print("    afCmd              = 0x%08lx\n", cii.afCmd);
                        Print("    pfnCallback        = 0x%08lx\n", cii.pfnCallback);
                        Print("    LastError          = 0x%08lx\n", cii.LastError);
                        Print("    tid                = 0x%08lx\n", cii.tid);
                        Print("    plaNameService     = 0x%08lx\n", cii.plaNameService);
                        Print("    cNameServiceAlloc  = 0x%08lx\n", cii.cNameServiceAlloc);
                        SAFEWHILE (cii.cNameServiceAlloc--) {
                            move(ns, cii.plaNameService++);
                            Print("      0x%04lx\n", ns);
                        }
                        Print("    aServerLookup      = 0x%08lx\n", cii.aServerLookup);
                        Print("    cServerLookupAlloc = 0x%08lx\n", cii.cServerLookupAlloc);
                        SAFEWHILE (cii.cServerLookupAlloc--) {
                            move(sl, cii.aServerLookup++);
                            Print("      laService  = 0x%04x\n", sl.laService);
                            Print("      laTopic    = 0x%04x\n", sl.laTopic);
                            Print("      hwndServer = 0x%08lx\n", sl.hwndServer);
                            if (cii.cServerLookupAlloc) {
                                Print("      ---\n");
                            }
                        }
                        Print("    ConvStartupState   = 0x%08lx\n", cii.ConvStartupState);
                        Print("    flags              = %s\n",
                                GetFlags(GF_IIF, cii.flags, NULL, TRUE));
                        Print("    cInDDEMLCallback   = 0x%08lx\n", cii.cInDDEMLCallback);
                        Print("    pLinkCount         = 0x%08lx\n", cii.pLinkCount);
                        SAFEWHILE (cii.pLinkCount) {
                            move(lc, cii.pLinkCount);
                            cii.pLinkCount = lc.next;
                            Print("      next    = 0x%08lx\n", lc.next);
                            Print("      laTopic = 0x%04x\n", lc.laTopic);
                            Print("      gaItem  = 0x%04x\n", lc.gaItem);
                            Print("      laItem  = 0x%04x\n", lc.laItem);
                            Print("      wFmt    = 0x%04x\n", lc.wFmt);
                            Print("      Total   = 0x%04x\n", lc.Total);
                            Print("      Count   = 0x%04x\n", lc.Count);
                            if (cii.pLinkCount != NULL) {
                                Print("      ---\n");
                            }
                        }
                    }
                    break;

                case HTYPE_ZOMBIE_CONVERSATION:
                    Print("Zombie Conversation\n");
                    if (opts & OFLAG(v)) {
                        DumpConvInfo((PCONV_INFO)he.dwData);
                    }
                    break;

                case HTYPE_SERVER_CONVERSATION:
                    Print("Server Conversation\n");
                    if (opts & OFLAG(v)) {
                        DumpConvInfo((PCONV_INFO)he.dwData);
                    }
                    break;

                case HTYPE_CLIENT_CONVERSATION:
                    Print("Client Conversation\n");
                    if (opts & OFLAG(v)) {
                        DumpConvInfo((PCONV_INFO)he.dwData);
                    }
                    break;

                case HTYPE_CONVERSATION_LIST:

                    if (IsRemoteSession()) {
                        Print("!ddeml for Conversation List doesn't work on HYDRA systems\n");
                    } else {
                        Print("Conversation List\n");
                        if (opts & OFLAG(v)) {
                            move(cl, (PVOID)he.dwData);
                            Print("    pcl   = 0x%08lx\n", he.dwData);
                            Print("    chwnd = 0x%08lx\n", cl.chwnd);
                            i = 0;
                            phwnd = (HWND *)&((PCONVLIST)he.dwData)->ahwnd;
                            SAFEWHILE (cl.chwnd--) {
                                move(hwnd, phwnd++);
                                Print("    ahwnd[%d] = 0x%08lx\n", i, hwnd);
                                pcci = (PCL_CONV_INFO)GetWindowLongPtr(hwnd, GWLP_PCI);
                                SAFEWHILE (pcci) {
                                    move(cci, pcci);
                                    pcci = (PCL_CONV_INFO)cci.ci.next;
                                    Print("      hConv = 0x%08lx\n", cci.ci.hConv);
                                }
                                i++;
                            }
                        }
                    }
                    break;

                case HTYPE_TRANSACTION:
                    Print("Transaction\n");
                    if (opts & OFLAG(v)) {
                        move(xi, (PVOID)he.dwData);
                        Print("    next         = 0x%08lx\n", xi.next);
                        Print("    pcoi         = 0x%08lx\n", xi.pcoi);
                        move(ci, xi.pcoi);
                        Print("      hConv      = 0x%08lx\n", ci.hConv);
                        Print("    hUser        = 0x%08lx\n", xi.hUser);
                        Print("    hXact        = 0x%08lx\n", xi.hXact);
                        Print("    pfnResponse  = 0x%08lx\n", xi.pfnResponse);
                        Print("    gaItem       = 0x%04x\n",  xi.gaItem);
                        Print("    wFmt         = 0x%04x\n",  xi.wFmt);
                        Print("    wType;       = 0x%04x\n",  xi.wType);
                        Print("    wStatus;     = 0x%04x\n",  xi.wStatus);
                        Print("    flags;       = %s\n",
                                GetFlags(GF_XI, xi.flags, NULL, TRUE));
                        Print("    state;       = 0x%04x\n",  xi.state);
                        Print("    hDDESent     = 0x%08lx\n", xi.hDDESent);
                        Print("    hDDEResult   = 0x%08lx\n", xi.hDDEResult);
                    }
                    break;

                case HTYPE_DATA_HANDLE:
                    Print("Data Handle\n");
                    if (opts & OFLAG(v)) {
                        move(dd, (PVOID)he.dwData);
                        Print("    hDDE     = 0x%08lx\n", dd.hDDE);
                        Print("    flags    = %s\n",
                                GetFlags(GF_HDATA, (WORD)dd.flags, NULL, TRUE));
                    }
                    break;
                }
            }
        }
        if (pcii != NULL) {
            move(cii, pcii);
        }
    }
    return TRUE;
}
#endif // !KERNEL
#endif // OLD_DEBUGGER


#ifdef KERNEL

/*
 * Hook helper routines
 */
VOID IterateHooks(
    PTR phk,
    BOOL fLocalHook,
    BOOL fDumpDllName)
{
    int iHook;
    ULONG64 offPfn;
    PTR pti;
    UINT flags;
    int ihmod;
    PTR patomTable;
    PTR patomSysLoaded;
    ATOM atom;

    patomTable = GetGlobalPointer(VAR(UserAtomTableHandle));
    patomSysLoaded = EvalExp(SYM(aatomSysLoaded));

    SAFEWHILE (phk != 0) {

        GetFieldValue(phk, SYM(tagHOOK), "iHook", iHook);
        GetFieldValue(phk, SYM(tagHOOK), "offPfn", offPfn);
        GetFieldValue(phk, SYM(tagHOOK), "flags", flags);
        GetFieldValue(phk, SYM(tagHOOK), "ihmod", ihmod);
        GetFieldValue(phk, SYM(tagHOOK), "head.pti", pti);

        Print("\t  0x%p iHook %d, offPfn=0x%08p, ihmod=%d\n",
              phk, iHook, offPfn, ihmod);
        if (!fLocalHook) {
            /*
             * Dump the threadinfo of the hook originator.
             */
            Print("\t  ");
            Idt(OFLAG(p), pti);
        }
        Print("\t    flags: %s\n", GetFlags(GF_HOOKFLAGS, flags, NULL, TRUE));

        if (ihmod >= 0 && patomTable != NULL_PTR) {
            /*
             * Dump the hook DLL name.
             */
            ReadMemory(patomSysLoaded + sizeof(ATOM) * ihmod, &atom, sizeof(ATOM), NULL);
            if (fDumpDllName && atom) {
                if (!DumpAtomTable(patomTable, (RTL_ATOM)atom, 12, NULL)) {
                    Print("%12catom: %04x (unable to get the dll name)\n", ' ', (DWORD)atom);
                }
            }
        }

        GetFieldValue(phk, SYM(tagHOOK), "phkNext", phk);
    }
}

VOID DumpHooks(PTR pDeskInfo, LPSTR psz, int i, BOOL fDumpDllName)
{
    PTR phk = GetArrayElementPtr(pDeskInfo, SYM(tagDESKTOPINFO), "aphkStart", i + 1);
    if (phk) {
        Print("\t %s\n", psz);
        IterateHooks(phk, FALSE, fDumpDllName);
    }
}

VOID DumpLHooks(PTR pti, LPSTR psz, int i, BOOL fDumpDllName)
{
    PTR phk = GetArrayElementPtr(pti, SYM(tagTHREADINFO), "aphkStart", i + 1);
    if (phk) {
        Print("\t %s\n", psz);
        IterateHooks(phk, TRUE, fDumpDllName);
    }
}



/***************************************************************************\
* ddesk           - dumps list of desktops
* ddesk address   - dumps simple statistics for desktop
* ddesk v address - dumps verbose statistics for desktop
* ddesk h address - dumps statistics for desktop plus handle list
*
* Dump handle table statistics.
*
* 02/21/1992 ScottLu    Created.
* 06/09/1995 SanfordS   Made to fit stdexts motif.
* 10/15/2000 Hiroyama   Ported to ia64.
\***************************************************************************/
BOOL Iddesk(
    DWORD opts,
    ULONG64 param1)
{
    try {
        PTR pwinsta = NULL_PTR; // PWINDOWSTATION
        PTR pdesk;  // PDESKTOP
        PTR pHead;  // OBJECT_HEADER
        PTR pDeskInfo;
        DWORD acHandles[TYPE_CTYPES + 1];
        BOOL abTrack[TYPE_CTYPES + 1];
        PTR phe;    // PHE
        DWORD i;
        WCHAR ach[80];
        BOOL fMatch;
        ULONG offsetPHead;  // to reduce the symbol lookup
        ULONG offsetBType;
        ULONG offsetBFlags;
        BYTE bType;
        BOOL fDumpDllName = opts & OFLAG(d);

        /*
         * If there is no address, list all desktops on all terminals.
         */
        if (param1 == NULL_PTR) {

            FOREACHWINDOWSTATION(pwinsta)

                GetObjectName(pwinsta, ach, ARRAY_SIZE(ach));
                Print("Windowstation: @ 0x%p %ws\n", pwinsta, ach);
                Print("Other desktops:\n");
                GetFieldValue(pwinsta, SYM(tagWINDOWSTATION), "rpdeskList", pdesk);

                SAFEWHILE (pdesk) {
                    Print(" Desktop at 0x%p\n", pdesk);
                    Iddesk(opts & (OFLAG(v) | OFLAG(h) | OFLAG(d)), pdesk);
                    GetFieldValue(pdesk, SYM(tagDESKTOP), "rpdeskNext", pdesk);
                }

                Print("\n");

            NEXTEACHWINDOWSTATION(pwinsta)

            return TRUE;
        }

        pdesk = param1;

        GetObjectName(pdesk, ach, ARRAY_SIZE(ach));
        Print(" Name: %ws\n", ach);

        pHead = KD_OBJECT_TO_OBJECT_HEADER(pdesk);
        if (pHead == NULL_PTR) {
            Print("can't get pHeader\n");
            return TRUE;
        }

        /*
         * Dump Header info
         */
        _InitTypeRead(pHead, "nt!_OBJECT_HEADER");
        Print(" # Opens         = %d\n", ReadField(HandleCount));

        /*
         * Dump some key info
         */
        _InitTypeRead(pdesk, SYM(tagDESKTOP));
        Print(" dwFlags         = %s\n", GetFlags(GF_DESKTOPFLAGS, (DWORD)ReadField(dwDTFlags), NULL, TRUE));
        Print(" Heap            = %#p\n", ReadField(pheapDesktop));
        Print(" Windowstation   = %#p\n", ReadField(rpwinstaParent));
        Print(" Message pwnd    = %#p\n", ReadField(spwndMessage));
        Print(" System pmenu    = %#p\n", ReadField(spmenuSys));
        Print(" Console thread  = 0x%x\n", ReadField(dwConsoleThreadId));
        Print(" PtiList.Flink   = %#p\n", ReadField(PtiList.Flink));

        /*
         * Dump DESKTOPINFO
         */
        pDeskInfo = ReadField(pDeskInfo);
        _InitTypeRead(pDeskInfo, SYM(tagDESKTOPINFO));
        Print(" Desktop pwnd    = %#p\n", ReadField(spwnd));
        Print("\tfsHooks     = 0x%08lx\n", ReadField(fsHooks));

        DumpHooks(pDeskInfo, "WH_MSGFILTER", WH_MSGFILTER, fDumpDllName);
        DumpHooks(pDeskInfo, "WH_JOURNALRECORD", WH_JOURNALRECORD, fDumpDllName);
        DumpHooks(pDeskInfo, "WH_JOURNALPLAYBACK", WH_JOURNALPLAYBACK, fDumpDllName);
        DumpHooks(pDeskInfo, "WH_KEYBOARD", WH_KEYBOARD, fDumpDllName);
        DumpHooks(pDeskInfo, "WH_GETMESSAGE", WH_GETMESSAGE, fDumpDllName);
        DumpHooks(pDeskInfo, "WH_CALLWNDPROC", WH_CALLWNDPROC, fDumpDllName);
        DumpHooks(pDeskInfo, "WH_CALLWNDPROCRET", WH_CALLWNDPROCRET, fDumpDllName);
        DumpHooks(pDeskInfo, "WH_CBT", WH_CBT, fDumpDllName);
        DumpHooks(pDeskInfo, "WH_SYSMSGFILTER", WH_SYSMSGFILTER, fDumpDllName);
        DumpHooks(pDeskInfo, "WH_MOUSE", WH_MOUSE, fDumpDllName);
        DumpHooks(pDeskInfo, "WH_HARDWARE", WH_HARDWARE, fDumpDllName);
        DumpHooks(pDeskInfo, "WH_DEBUG", WH_DEBUG, fDumpDllName);
        DumpHooks(pDeskInfo, "WH_SHELL", WH_SHELL, fDumpDllName);
        DumpHooks(pDeskInfo, "WH_FOREGROUNDIDLE", WH_FOREGROUNDIDLE, fDumpDllName);
        DumpHooks(pDeskInfo, "WH_KEYBOARD_LL", WH_KEYBOARD_LL, fDumpDllName);
        DumpHooks(pDeskInfo, "WH_MOUSE_LL", WH_MOUSE_LL, fDumpDllName);

        if (opts & OFLAG(h)) {
            /*
             * Find all objects allocated from the desktop.
             */
            for (i = 0; i < ARRAY_SIZE(acHandles); i++) {
                abTrack[i] = FALSE;
                acHandles[i] = 0;
            }
            abTrack[TYPE_WINDOW] = abTrack[TYPE_MENU] =
                    abTrack[TYPE_CALLPROC] =
                    abTrack[TYPE_HOOK] = TRUE;

            if (opts & OFLAG(v)) {
                Print("Handle          Type\n");
                Print("--------------------\n");
            }

            GetFieldOffset(SYM(HANDLEENTRY), "phead", &offsetPHead);
            DEBUGPRINT("offsetPHead=%x\n", offsetPHead);
            GetFieldOffset(SYM(HANDLEENTRY), "bType", &offsetBType);
            DEBUGPRINT("offsetBType=%x\n", offsetBType);
            GetFieldOffset(SYM(HANDLEENTRY), "bFlags", &offsetBFlags);

            FOREACHHANDLEENTRY(phe, i)
                fMatch = FALSE;
                if ((i & 0x3) == 0) {
                    ShowProgress();
                }
                move(bType, phe + offsetBType);

                if (bType >= TYPE_CTYPES) {
                    bType = TYPE_CTYPES; // unknown;
                }

                try {
                    PTR phead;
                    PTR rpdesk = NULL_PTR;

                    switch (bType) {
                    case TYPE_WINDOW:
                        {
                            static ULONG offset = 0;
                            ReadPointer(phe + offsetPHead, &phead);
                            if (offset == 0) {
                                GetFieldOffset(SYM(WND), "head.rpdesk", &offset);
                                DEBUGPRINT("offset=%x\n", offset);
                            }
                            ReadPointer(phead + offset, &rpdesk);
                            DEBUGPRINT("rpdesk=0x%p @ 0x%p phead=0x%p ", rpdesk, phead + offset, phead);
                        }
                        break;
                    case TYPE_MENU:
                        {
                            static ULONG offset = 0;
                            ReadPointer(phe + offsetPHead, &phead);
                            if (offset == 0) {
                                GetFieldOffset(SYM(tagMENU), "head.rpdesk", &offset);
                            }
                            ReadPointer(phead + offset, &rpdesk);
                        }
                        break;
                    case TYPE_CALLPROC:
                        {
                            static ULONG offset = 0;
                            ReadPointer(phe + offsetPHead, &phead);
                            if (offset == 0) {
                                GetFieldOffset(SYM(CALLPROCDATA), "head.rpdesk", &offset);
                            }
                            ReadPointer(phead + offset, &rpdesk);
                        }
                        break;
                    case TYPE_HOOK:
                        {
                            static ULONG offset = 0;
                            ReadPointer(phe + offsetPHead, &phead);
                            if (offset == 0) {
                                GetFieldOffset(SYM(tagHOOK), "head.rpdesk", &offset);
                            }
                            ReadPointer(phead + offset, &rpdesk);
                        }
                        break;
#if defined(GI_PROCESSOR) && defined(TYPE_RAWINPUT_PROCESSOR)
                    case TYPE_RAWINPUT_PROCESSOR:
                        {
                            static ULONG offset = 0;
                            ReadPointer(phe + offsetPHead, &phead);
                            if (offset == 0) {
                                GetFieldOffset(SYM(tagRAWINPUT_PROCESSOR), "head.rpdesk", &offset);
                            }
                            ReadPointer(phead + offset, &rpdesk);
                        }
                        break;
#endif
                    default:
                        break;
                    }
                    if (rpdesk == pdesk) {
                        fMatch = TRUE;
                        if (bType == TYPE_WINDOW) {
                            DEBUGPRINT("matched\n");
                        }
                    } else if (bType == TYPE_WINDOW) {
                        DEBUGPRINT("unmatched\n");
                    }
                } except (CONTINUE) {
                    Print("Exception!\n");
                }

                if (!fMatch) {
                    continue;
                }

                acHandles[bType]++;

                if (opts & OFLAG(v)) {
                    BYTE bFlags;
                    move(bFlags, phe + offsetBFlags);
                    Print("\r0x%08lx %c    %s\n",
                            i,
                            (bFlags & HANDLEF_DESTROY) ? '*' : ' ',
                            aszTypeNames[bType]);
                }
            NEXTEACHHANDLEENTRY()

            Print("\r");

            if (!(opts & OFLAG(v))) {
                Print("  \n");
                Print("Count           Type\n");
                Print("--------------------\n");
                for (i = 0; i < ARRAY_SIZE(acHandles); i++) {
                    if (abTrack[i])
                        Print("0x%08lx      %s\n", acHandles[i], aszTypeNames[i]);
                }
            }
        }
    } except (CONTINUE) {
        Print("AV!\n");
    }
    Print("   \n");
    return TRUE;
}
#endif // KERNEL

BOOL IsNumChar(int c, int base)
{
    return ('0' <= c && c <= '9') ||
           (base == 16 && (('a' <= c && c <= 'f') || ('A' <= c && c <= 'F')));
}

NTSTATUS GetInteger(
    LPSTR psz,
    int base,
    int *pi,
    LPSTR *ppsz)
{
    NTSTATUS Status = STATUS_INVALID_PARAMETER;

    for (;;) {
        if (IsNumChar(*psz, base)) {
            Status = RtlCharToInteger(psz, base, pi);
            if (ppsz && NT_SUCCESS(Status)) {
                while (IsNumChar(*psz++, base)) {
                    /* do nothing */;
                }

                *ppsz = psz;
            }

            break;
        }

        if (*psz != ' ' && *psz != '\t') {
            break;
        }

        psz++;
    }

    return Status;
}


typedef VOID (*PFNSETRIPFLAGS)(DWORD);
typedef DWORD (*PFNGETRIPFLAGS)(VOID);
typedef DWORD (*PFNGETRIPPID)(VOID);

BOOL Idf(DWORD opts, LPSTR pszName)
{
    static char *szLevels[8] = {
        "<none>",
        "Errors",
        "Warnings",
        "Errors and Warnings",
        "Verbose",
        "Errors and Verbose",
        "Warnings and Verbose",
        "Errors, Warnings, and Verbose"
    };

#ifndef KERNEL
    PFNSETRIPFLAGS lpfnSetRipFlags;
    static PFNGETRIPFLAGS lpfnGetRipFlags = NULL;
    HMODULE hMod;
#endif
    NTSTATUS    Status;
    ULONG       ulFlags;
    ULONG64     psi;
    DWORD       dwRipFlags = 0;
    ULONG       offsetRIPFlags;

    if (opts & OFLAG(x)) {
        /*
         * !df -x foo
         * This is an undocumented way to start a remote CMD session named
         * "foo" on the machine that the debugger is running on.
         * Sometimes useful to assist in debugging.
         * Sometimes useful when trying to do dev work from home: if you don't
         * already have a remote cmd.exe session to connect to, you probably
         * have a remote debug session.  You can use this debug extension to
         * start a remote cmd session.
         */
        BOOL bRet;
        char ach[80];
        PROCESS_INFORMATION ProcessInfo;
        STARTUPINFOA StartupInfoA;

        if (pszName[0] == '\0') {
            Print("must provide a name.  eg; \"!df -x fred\"\n");
            return TRUE;
        }
        sprintf(ach, "remote.exe /s cmd.exe %s", pszName);

        RtlZeroMemory(&StartupInfoA, sizeof(STARTUPINFOA));
        StartupInfoA.cb = sizeof(STARTUPINFOA);
        StartupInfoA.lpTitle = pszName;
        StartupInfoA.dwFlags = STARTF_USESHOWWINDOW;
        StartupInfoA.wShowWindow = SW_SHOWMINIMIZED; // SW_HIDE is *too* sneaky
        bRet = CreateProcessA(NULL,
                              ach,
                              NULL,
                              NULL,
                              FALSE,
                              CREATE_NEW_CONSOLE,
                              NULL,
                              NULL,
                              &StartupInfoA,
                              &ProcessInfo);
        if (bRet) {
            Print("Successfully created a minimized remote cmd process\n");
            Print("use \"remote /c <machine> %s\" to connect\n", pszName);
            Print("use \"exit\" to kill the remote cmd process\n");
        }

        NtClose(ProcessInfo.hProcess);
        NtClose(ProcessInfo.hThread);
        return TRUE;
    }

    psi = GetGlobalPointer(VAR(gpsi));
    GetFieldOffset(SYM(SERVERINFO), "dwRIPFlags", &offsetRIPFlags);
#if 0
    /*
     * If !df is run against a fre system, neither of these fields will
     * be present in the SERVERINFO structure, and thus the offsets will
     * both be zero.
     */
    if (offsetRIPFlags == 0) {
        Print("!df not supported on this system.\n");
        return TRUE;
    }
#endif

#ifndef KERNEL
    hMod = GetModuleHandle(L"user32.dll");

    if (opts & OFLAG(p)) {
        lpfnSetRipFlags = (PFNSETRIPFLAGS)GetProcAddress(hMod,
                                                         "PrivateSetRipFlags");
    } else {
        lpfnSetRipFlags = (PFNSETRIPFLAGS)GetProcAddress(hMod,
                                                         "SetRipFlags");
    }
    if (lpfnSetRipFlags == NULL) {
        Print("Error getting address for %sSetRipFlags export: 0x%x\n",
              (opts & OFLAG(p)) ? "Private" : "",
              GetLastError());
        return TRUE;
    }


    if (lpfnGetRipFlags == NULL) {
        lpfnGetRipFlags = (PFNGETRIPFLAGS)GetProcAddress(hMod, "GetRipFlags");
        if (lpfnGetRipFlags == NULL) {
            Print("Error getting address for GetRipFlags export: 0x%x\n",
                  GetLastError());
            return TRUE;
        }
    }
#endif

#ifdef KERNEL
    move(dwRipFlags, psi + offsetRIPFlags);
#else
    dwRipFlags = (*lpfnGetRipFlags)();
#endif

    Status = GetInteger(pszName, 16, &ulFlags, NULL);
    if (NT_SUCCESS(Status) && !(ulFlags & ~RIPF_VALIDUSERFLAGS)) {
#ifdef KERNEL
        dwRipFlags = (dwRipFlags & ~RIPF_VALIDUSERFLAGS) | ulFlags;


        (lpExtensionApis->lpWriteProcessMemoryRoutine)(psi + offsetRIPFlags,
                                                       (PVOID)&dwRipFlags,
                                                       sizeof(dwRipFlags),
                                                       NULL);
        move(dwRipFlags, psi + offsetRIPFlags);
#else
        (*lpfnSetRipFlags)(ulFlags);
        dwRipFlags = (*lpfnGetRipFlags)();
#endif
    }

    Print("Flags = %.3x\n", dwRipFlags & RIPF_VALIDUSERFLAGS);
    Print("  Print Process/Component %sabled\n", (dwRipFlags & RIPF_HIDEPID) ? "dis" : "en");
    Print("  Print File/Line %sabled\n", (dwRipFlags & RIPF_PRINTFILELINE) ? "en" : "dis");
    Print("  Print on %s\n",  szLevels[(dwRipFlags & RIPF_PRINT_MASK) >> RIPF_PRINT_SHIFT]);
    Print("  Prompt on %s\n", szLevels[(dwRipFlags & RIPF_PROMPT_MASK) >> RIPF_PROMPT_SHIFT]);

    if (opts & OFLAG(p)) {
        Print("  RIPs shown for process %ld (0x%lX)\n",
              HandleToUlong(NtCurrentTeb()->ClientId.UniqueProcess),
              HandleToUlong(NtCurrentTeb()->ClientId.UniqueProcess));
    } else {
        Print("  All process RIPs are shown\n");
    }

    return TRUE;
}

#ifdef KERNEL
VOID DumpHotkeyWorker(
    ULONG64 phk,
    BOOL bRecursive)
{
    WORD fsModifiers;
    UINT vk;
    PTR pwnd;
    PTR pti;
    int id;

    SAFEWHILE (phk != 0) {
        Print("photkey @ 0x%p\n", phk);
        GetFieldValue(phk, SYM(HOTKEY), "vk", vk);
        GetFieldValue(phk, SYM(HOTKEY), "fsModifiers", fsModifiers);

        Print("  fsModifiers %lx, vk %x - ", fsModifiers, vk);

        Print("%s%s%s%sVK:%x %s",
            fsModifiers & MOD_SHIFT   ? "Shift + " : "",
            fsModifiers & MOD_ALT     ? "Alt + "   : "",
            fsModifiers & MOD_CONTROL ? "Ctrl + "  : "",
            fsModifiers & MOD_WIN     ? "Win + "   : "",
            vk,
            GetVKeyName(vk));

        GetFieldValue(phk, SYM(HOTKEY), "id", id);
        GetFieldValue(phk, SYM(HOTKEY), "pti", pti);
        GetFieldValue(phk, SYM(HOTKEY), "spwnd", pwnd);

        Print("\n  id   %x\n", id);
        Print("  pti  %lx\n", pti);
        Print("  pwnd %lx = ", pwnd);
        if (pwnd == (PTR)PWND_FOCUS) {
            Print("PWND_FOCUS\n");
        } else if (pwnd == (PTR)PWND_INPUTOWNER) {
            Print("PWND_INPUTOWNER\n");
        } else {
            CHAR ach[80];
            /*
             * Print title string.
             */
            DebugGetWindowTextA(pwnd, ach, ARRAY_SIZE(ach));
            Print("\"%s\"\n", ach);
        }
        Print("\n");


        if (bRecursive) {
            GetFieldValue(phk, SYM(HOTKEY), "phkNext", phk);
        } else {
            break;
        }
    }
}

/***************************************************************************\
* dhot - dump hotkeys
*
* dhot       - dumps all hotkeys
*
* 10/21/1994 IanJa        Created.
* 06/09/1995 SanfordS     Made to fit stdexts motif.
* 08/15/2002 JasonSch     Modified to use new hotkey hash table.
\***************************************************************************/
BOOL Idhot(
    DWORD opts,
    ULONG64 phk)
{
    if (!phk) {
        DWORD dwPointerSize = GetTypeSize("PVOID");
        int i = 0;
        ULONG64 pwnd, pti, phkT;

        phk = EvalExp(VAR(gphkHashTable));

        for (; i < 128; ++i) {
            ReadPointer(phk, &phkT);
            GetFieldValue(phkT, SYM(HOTKEY), "pti", pti);
            GetFieldValue(phkT, SYM(HOTKEY), "spwnd", pwnd);
            if (pti != 0 || pwnd != 0) {
                DumpHotkeyWorker(phkT, TRUE);
            }
            phk += dwPointerSize;
        }
    } else {
        DumpHotkeyWorker(phk, !!(opts & OFLAG(r)));
    }

    return TRUE;
}

ULONG dhkCallback(
    ULONG64 pti,
    PVOID pData)
{
    UNREFERENCED_PARAMETER(pData);

    Idhk(OFLAG(r), pti);

    return FALSE;
}

/***************************************************************************\
* dhk - dump hooks
*
* dhk           - dumps local hooks on the foreground thread
* dhk g         - dumps global hooks
* dhk address   - dumps local hooks on THREADINFO at address
* dhk g address - dumps global hooks and local hooks on THREADINFO at address
* dhk *         - dumps local hooks for all threads
* dhk g *       - dumps global hooks and local hooks for all threads
*
* 10/21/94 IanJa        Created.
* 6/9/1995 SanfordS     made to fit stdexts motif
\***************************************************************************/
BOOL Idhk(
    DWORD opts,
    ULONG64 param1)
{
    DWORD dwFlags;
    PTR pti;
    PTR pq = NULL_PTR;
    BOOL fDumpDllName = opts & OFLAG(d);
    static PTR gptiHkForeground;


#define DHKF_GLOBAL_HOOKS   1
#define DHKF_PTI_GIVEN      2

    dwFlags = 0;

    pti = NULL_PTR;
    if (opts & OFLAG(g)) { // global hooks
        dwFlags |= DHKF_GLOBAL_HOOKS;
    }

    if ((opts & OFLAG(r)) == 0) {   // -r cannot be specified from the command line
        // first time sets gptiHkForeground
        pq = GetGlobalPointer(VAR(gpqForeground));
        if (pq) {
            GetFieldValue(pq, SYM(tagQ), "ptiKeyboard", gptiHkForeground);
        } else {
            // Happens during winlogon
            gptiHkForeground = NULL_PTR;
        }
    }

    if (param1 == 0) {  // n.b. call from dhkCallback should always set param1
        if (opts & OFLAG(c)) {
            // !dhk -c: Use the current thread.
            pti = GetGlobalPointer(VAR(gptiCurrent));
        } else if (pq == NULL_PTR) {
            // Happens during winlogon
            Print("No foreground queue!\n");
            return TRUE;
        } else {
            pti = gptiHkForeground;
        }
    } else {
        dwFlags |= DHKF_PTI_GIVEN;
        pti = param1;
    }

    if ((dwFlags & DHKF_PTI_GIVEN || !(dwFlags & DHKF_GLOBAL_HOOKS)) && (opts & OFLAG(a)) == 0) {
        DWORD fsHooks;

        GetFieldValue(pti, SYM(tagTHREADINFO), "fsHooks", fsHooks);
        if (fsHooks || (opts & OFLAG(r)) == 0) {
            Print("Local hooks on PTHREADINFO @ 0x%p%s:\n", pti,
                  pti == gptiHkForeground ? " (foreground thread)" : "");
            Idt(OFLAG(p), pti);
            DumpLHooks(pti, "WH_MSGFILTER", WH_MSGFILTER, fDumpDllName);
            DumpLHooks(pti, "WH_JOURNALRECORD", WH_JOURNALRECORD, fDumpDllName);
            DumpLHooks(pti, "WH_JOURNALPLAYBACK", WH_JOURNALPLAYBACK, fDumpDllName);
            DumpLHooks(pti, "WH_KEYBOARD", WH_KEYBOARD, fDumpDllName);
            DumpLHooks(pti, "WH_GETMESSAGE", WH_GETMESSAGE, fDumpDllName);
            DumpLHooks(pti, "WH_CALLWNDPROC", WH_CALLWNDPROC, fDumpDllName);
            DumpLHooks(pti, "WH_CALLWNDPROCRET", WH_CALLWNDPROCRET, fDumpDllName);
            DumpLHooks(pti, "WH_CBT", WH_CBT, fDumpDllName);
            DumpLHooks(pti, "WH_SYSMSGFILTER", WH_SYSMSGFILTER, fDumpDllName);
            DumpLHooks(pti, "WH_MOUSE", WH_MOUSE, fDumpDllName);
            DumpLHooks(pti, "WH_HARDWARE", WH_HARDWARE, fDumpDllName);
            DumpLHooks(pti, "WH_DEBUG", WH_DEBUG, fDumpDllName);
            DumpLHooks(pti, "WH_SHELL", WH_SHELL, fDumpDllName);
            DumpLHooks(pti, "WH_FOREGROUNDIDLE", WH_FOREGROUNDIDLE, fDumpDllName);
            DumpLHooks(pti, "WH_KEYBOARD_LL", WH_KEYBOARD_LL, fDumpDllName);
            DumpLHooks(pti, "WH_MOUSE_LL", WH_MOUSE_LL, fDumpDllName);
        }
    }

    if (dwFlags & DHKF_GLOBAL_HOOKS) {
        PTR pDeskInfo;
        PTR rpdesk;
        DWORD fsHooks;

        GetFieldValue(pti, SYM(tagTHREADINFO), "pDeskInfo", pDeskInfo);
        GetFieldValue(pti, SYM(tagTHREADINFO), "rpdesk", rpdesk);
        GetFieldValue(pDeskInfo, SYM(DESKTOPINFO), "fsHooks", fsHooks);

        Print("Global hooks for Desktop @ 0x%p:\n", rpdesk);
        Print("\tfsHooks            0x%08lx\n", fsHooks);

        DumpHooks(pDeskInfo, "WH_MSGFILTER", WH_MSGFILTER, fDumpDllName);
        DumpHooks(pDeskInfo, "WH_JOURNALRECORD", WH_JOURNALRECORD, fDumpDllName);
        DumpHooks(pDeskInfo, "WH_JOURNALPLAYBACK", WH_JOURNALPLAYBACK, fDumpDllName);
        DumpHooks(pDeskInfo, "WH_KEYBOARD", WH_KEYBOARD, fDumpDllName);
        DumpHooks(pDeskInfo, "WH_GETMESSAGE", WH_GETMESSAGE, fDumpDllName);
        DumpHooks(pDeskInfo, "WH_CALLWNDPROC", WH_CALLWNDPROC, fDumpDllName);
        DumpHooks(pDeskInfo, "WH_CALLWNDPROCRET", WH_CALLWNDPROCRET, fDumpDllName);
        DumpHooks(pDeskInfo, "WH_CBT", WH_CBT, fDumpDllName);
        DumpHooks(pDeskInfo, "WH_SYSMSGFILTER", WH_SYSMSGFILTER, fDumpDllName);
        DumpHooks(pDeskInfo, "WH_MOUSE", WH_MOUSE, fDumpDllName);
        DumpHooks(pDeskInfo, "WH_HARDWARE", WH_HARDWARE, fDumpDllName);
        DumpHooks(pDeskInfo, "WH_DEBUG", WH_DEBUG, fDumpDllName);
        DumpHooks(pDeskInfo, "WH_SHELL", WH_SHELL, fDumpDllName);
        DumpHooks(pDeskInfo, "WH_FOREGROUNDIDLE", WH_FOREGROUNDIDLE, fDumpDllName);
        DumpHooks(pDeskInfo, "WH_KEYBOARD_LL", WH_KEYBOARD_LL, fDumpDllName);
        DumpHooks(pDeskInfo, "WH_MOUSE_LL", WH_MOUSE_LL, fDumpDllName);
    }

    if (opts & OFLAG(a)) {
        ForEachPti(dhkCallback, NULL);
    }

    return TRUE;
}
#endif // KERNEL

typedef VOID (*PFNSETDBGTAG)(int, DWORD);
BOOL Itag(
    DWORD opts,
    LPSTR pszName)
{
    NTSTATUS    Status;
    PTR     psi, pdbgtag;
    DWORD       dwAchNameOffset, dwAchDescOffset;
    char        achName[DBGTAG_NAMELENGTH];
    char        achDesc[DBGTAG_DESCRIPTIONLENGTH];
    int         tag = -1;
    DWORD       dwDBGTAGFlags, dwDBGTAGFlagsNew, dwOffset;
    DWORD       dwSize;
    int         i, iStart, iEnd;
    char        szT[100];
#ifndef KERNEL
    static PFNSETDBGTAG lpfnSetDbgTag = NULL;
#endif

    UNREFERENCED_PARAMETER(opts);

    GetFieldOffset(SYM(SERVERINFO), "adwDBGTAGFlags", &dwOffset);

    /*
     * Get the tag index.
     */
    psi = GetGlobalPointer(VAR(gpsi));
    if (!psi) {
        Print("Couldn't get win32k!gpsi; bad symbols?\n");
        return TRUE;
    }

#ifndef KERNEL
    if (lpfnSetDbgTag == NULL) {
        HMODULE hMod = GetModuleHandle(L"user32.dll");
        if (hMod != NULL) {
            lpfnSetDbgTag = (PFNSETDBGTAG)GetProcAddress(hMod,
                                                         "SetDbgTag");
        }

        if (lpfnSetDbgTag == NULL) {
            Print("Error getting address of SetDbgTag export (0x%x)\n",
                  GetLastError());
            return TRUE;
        }
    }
#endif

    Status = GetInteger(pszName, 10, &tag, &pszName);
    if (*pszName != '\0' && !NT_SUCCESS(Status)) {
        Print("ERROR: Dwayne, you must refer to tags by their number, not their name. How long have you been here?\n\n");
        return FALSE;
    }

    if (!NT_SUCCESS(Status) || tag < 0 || DBGTAG_Max <= tag) {
        tag = -1;
    } else {
        /*
         * Get the flag value.
         */
        Status = GetInteger(pszName, 16, &dwDBGTAGFlagsNew, NULL);
        if (NT_SUCCESS(Status) && !(dwDBGTAGFlagsNew & ~DBGTAG_VALIDUSERFLAGS)) {

            /*
             * Set the flag value.
             */
#ifdef KERNEL
            ReadMemory(psi + dwOffset + tag * sizeof(DWORD), &dwDBGTAGFlags, sizeof(DWORD), NULL);
            COPY_FLAG(dwDBGTAGFlags, dwDBGTAGFlagsNew, DBGTAG_VALIDUSERFLAGS);
            WriteMemory((psi + dwOffset + tag * sizeof(DWORD)), &dwDBGTAGFlags, sizeof(dwDBGTAGFlags), NULL);
#else
            (*lpfnSetDbgTag)(tag, dwDBGTAGFlagsNew);
#endif

        }
    }

    /*
     * Print the header.
     */
    Print(  "%-5s%-7s%-*s%-*s\n",
            "Tag",
            "Flags",
            DBGTAG_NAMELENGTH,
            "Name",
            DBGTAG_DESCRIPTIONLENGTH,
            "Description");

    for (i = 0; i < 12 + DBGTAG_NAMELENGTH + DBGTAG_DESCRIPTIONLENGTH; i++) {
        szT[i] = '-';
    }
    szT[i++] = '\n';
    szT[i] = 0;
    Print(szT);

    if (tag != -1) {
        iStart = iEnd = tag;
    } else {
        iStart = 0;
        GetFieldValue(psi, SYM(SERVERINFO), "dwTagCount", iEnd);
    }

    psi += dwOffset;
    pdbgtag = EvalExp(VAR(gadbgtag));
    if (!pdbgtag) {
        /*
         * EvalExp already complained, so just return.
         */
         return TRUE;
    }

    GetFieldOffset(SYM(DBGTAG), "achName", &dwAchNameOffset);
    GetFieldOffset(SYM(DBGTAG), "achDescription", &dwAchDescOffset);
    dwSize = GetTypeSize(SYM(DBGTAG));

    for (i = iStart; i <= iEnd; i++) {
        ReadMemory(psi + i * sizeof(DWORD), &dwDBGTAGFlags, sizeof(DWORD), NULL);
        if (pdbgtag) {
            if (!ReadMemory(pdbgtag + dwAchNameOffset + i * dwSize, achName, DBGTAG_NAMELENGTH, NULL)) {
                strcpy(achName, "(Not available)");
            }
            if (!ReadMemory(pdbgtag + dwAchDescOffset + i * dwSize, achDesc, DBGTAG_DESCRIPTIONLENGTH, NULL)) {
                strcpy(achDesc, "(Not available)");
            }
        }

        Print(  "%-5d%-7d%-*s%-*s\n",
                i,
                dwDBGTAGFlags & DBGTAG_VALIDUSERFLAGS,
                DBGTAG_NAMELENGTH,
                achName,
                DBGTAG_DESCRIPTIONLENGTH,
                achDesc);
    }

    return TRUE;
}

/************************************************************************\
* Idhe
*
* Dump Handle Entry.
*
* 6/9/1995 Created SanfordS
\************************************************************************/
BOOL Idhe(
    DWORD opts,
    ULONG64 param1,
    ULONG64 param2)
{
                                   /* 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 */
    static const char szHeader []  = "Phe       Handle    phead     pOwner    cLockObj    Type         Flags\n";
    static const char szHeader64[] = "Phe               Handle            phead             pOwner            cLockObj  Type          Flags\n";
    static const char szFormat [] = "%p  %p  %p  %p   %7x  %-15s %#4lx\n";
    int i;
    UINT uHandleCount = 0;
    BYTE bType, bFlags;
    PTR dw, phe, pheT, pOwner, pHead, h;
    DWORD cLockObj;
    WORD wUniq;
#ifdef KERNEL
    PTR pahti = 0, ppi;
    ULONG dwHtiSize = GetTypeSize(SYM(HANDLETYPEINFO));
    BOOL bObjectCreateFlags;
#endif // KERNEL

    /*
     * If only the owner was provided, copy it to param2 so it's always in the
     * same place.
     */
    if (!(opts & OFLAG(t)) && (opts & OFLAG(o))) {
        param2 = param1;
    }

    /*
     * If not a recursive call, print what we're dumping.
     */
    if (!(opts & OFLAG(r)) && (opts & (OFLAG(t) | OFLAG(o) | OFLAG(p)))) {
        Print("Dumping handles");
        if (opts & OFLAG(t)) {
            if ((UINT_PTR)param1 >= TYPE_CTYPES) {
                Print("\nInvalid Type: %#lx\n", param1);
                return FALSE;
            }
            Print(" of type %d (%s)", (ULONG)param1, aszTypeNames[(UINT_PTR)param1]);
        }
        if (opts & OFLAG(o)) {
            Print(" owned by %p", param2);
        }
        if (opts & OFLAG(p)) {
            Print(" or any thread on this process");
        }
        Print("\n");
    }

#ifdef KERNEL
    /*
     * If dumping handles for any thread in the process, we need the type flags.
     */
    if (opts & OFLAG(p)) {
        pahti = EvalExp(VAR(gahti));
        if (!pahti) {
            Print("Couldn't get win32k!gahti\n");
            return TRUE;
        }
    }
#endif // KERNEL

    /*
     * If a handle/phe was provided, just dump it.
     */
    if (!(opts & ~OFLAG(r)) && param1 != 0) {
        dw = HorPtoP(param1, -2);
        if (dw == 0) {
            Print("0x%p is not a valid object or handle.\n", param1);
            return FALSE;
        }
    } else {
        /*
         * Walk the handle table
         */
        Print(IsPtr64() ? szHeader64 : szHeader);
        FOREACHHANDLEENTRY(phe, i)
            /* Skip free handles */
            GetFieldValue(phe, SYM(HANDLEENTRY), "bType", bType);
            if (bType == TYPE_FREE) {
                continue;
            }

            /* Type check */
            if ((opts & OFLAG(t)) && bType != (BYTE)param1) {
                continue;
            }

            /* thread check */
            GetFieldValue(phe, SYM(HANDLEENTRY), "pOwner", pOwner);
            if ((opts & OFLAG(o)) && FIXKP(pOwner) != param2) {
                /* check for thread owned objects owned by the requested process */
                if (opts & OFLAG(p)) {
                    #ifndef KERNEL
                        continue;
                    #else

                        GetFieldValue(pahti + bType * dwHtiSize, SYM(HANDLETYPEINFO), "bObjectCreateFlags", bObjectCreateFlags);
                        if (bObjectCreateFlags & OCF_PROCESSOWNED) {
                            continue;
                        }
                        if (!(bObjectCreateFlags & OCF_THREADOWNED)) {
                            continue;
                        }
                        GetFieldValue(pOwner, SYM(THREADINFO), "ppi", ppi);
                        if (ppi != param2) {
                            continue;
                        }
                    #endif // !KERNEL
                } else {
                    continue;
                }
            }

            GetFieldValue(phe, SYM(HANDLEENTRY), "phead", pHead);
            if (pHead) {
                Idhe(OFLAG(r), pHead, 0);
                uHandleCount++;
            }
        NEXTEACHHANDLEENTRY()
        Print("%d handle(s)\n", uHandleCount);
        return TRUE;
    }

    if (!getHEfromP(&pheT, dw)) {
        Print("%p is not a USER handle manager object.\n", param1);
        return FALSE;
    }

#ifdef KERNEL
    /*
     * If printing only one entry, print info about the owner
     */
    if (!(opts & OFLAG(r))) {
        GetFieldValue(pheT, SYM(HANDLEENTRY), "pOwner", pOwner);
        if (pOwner != 0) {
            if (!(opts & OFLAG(p))) {
                pahti = EvalExp(VAR(gahti));
            }
            GetFieldValue(pheT, SYM(HANDLEENTRY), "bType", bType);
            GetFieldValue(pahti + bType * dwHtiSize, SYM(HANDLETYPEINFO), "bObjectCreateFlags", bObjectCreateFlags);
            if (bObjectCreateFlags & OCF_PROCESSOWNED) {
                Idp(OFLAG(p), pOwner);
            } else if (bObjectCreateFlags & OCF_THREADOWNED) {
                Idt(OFLAG(p), pOwner);
            }
        }
    }
#endif // KERNEL

    GetFieldValue(dw, SYM(HEAD), "cLockObj", cLockObj);
    GetFieldValue(dw, SYM(HEAD), "h", h);
    GetFieldValue(pheT, SYM(HANDLEENTRY), "phead", pHead);
    GetFieldValue(pheT, SYM(HANDLEENTRY), "pOwner", pOwner);
    GetFieldValue(pheT, SYM(HANDLEENTRY), "bType", bType);
    GetFieldValue(pheT, SYM(HANDLEENTRY), "bFlags", bFlags);
    GetFieldValue(pheT, SYM(HANDLEENTRY), "wUniq", wUniq);

    /*
     * If only dumping one, use !dso like format. Otherwise, print a table.
     */
    if (!(opts & OFLAG(r))) {
        Print("0x%08x handle @ 0x%p\n", (DWORD)h, pheT);
        Print("%4c0x%04x %-16s 0x%p %s\n",
              ' ', (DWORD)(WORD)wUniq, "wUniq", pOwner, "pOwner");
        Print("0x%p %-16s 0x%08x cLockObj\n",
              pHead, "pHead", (DWORD)cLockObj);
        Print(DWSTR1 " - %s\n", bType, "bType", aszTypeNames[bType]);
        Print(DWSTR1 " - %s\n", bFlags,"bFlags",  GetFlags(GF_HE, bFlags, NULL, TRUE));
    } else {
        Print(szFormat,
              pheT, h, FIXKP(pHead), FIXKP(pOwner),
              cLockObj, aszTypeNames[(DWORD)bType], (DWORD)bFlags);
    }

    return TRUE;
}

#ifdef KERNEL
/***************************************************************************\
* dhs           - dumps simple statistics for whole table
* dhs t id      - dumps simple statistics for objects created by thread id
* dhs p id      - dumps simple statistics for objects created by process id
* dhs v         - dumps verbose statistics for whole table
* dhs v t id    - dumps verbose statistics for objects created by thread id.
* dhs v p id    - dumps verbose statistics for objects created by process id.
* dhs y type    - just dumps that type
*
* Dump handle table statistics.
*
* 02-21-92 ScottLu      Created.
* 6/9/1995 SanfordS     made to fit stdexts motif
\***************************************************************************/
BOOL Idhs(
    DWORD opts,
    ULONG64 param1)
{
    PTR phe, pOwner, pEprocess, pEThread, pahti;
    DWORD dwT, acHandles[TYPE_CTYPES], dwSize, handle;
    DWORD cHandlesUsed, cHandlesSkipped, idProcess, i;
    BYTE bType, bObjectCreateFlags, bFlags;
    int Type, cLocalHandleEntries = 0;

    pahti = EvalExp(VAR(gahti));
    if (!pahti) {
        return TRUE;
    }
    dwSize = GetTypeSize(SYM(HANDLETYPEINFO));

    /*
     * Evaluate the argument string and get the address of the object to
     * dump. Take either a handle or a pointer to the object.
     */
    if (opts & OFLAG(y)) {
        Type = (ULONG)(ULONG_PTR)param1;
    } else if (opts & (OFLAG(t) | OFLAG(p))) {
        dwT = (ULONG)(ULONG_PTR)param1;
    }

    cHandlesSkipped = 0;
    cHandlesUsed = 0;
    for (i = 0; i < TYPE_CTYPES; i++) {
        acHandles[i] = 0;
    }

    if (param1) {
        if (opts & OFLAG(p)) {
            Print("Handle dump for client process id 0x%lx only:\n\n", dwT);
        } else if (opts & OFLAG(t)) {
            Print("Handle dump for client thread id 0x%lx only:\n\n", dwT);
        } else if (opts & OFLAG(y)) {
            Print("Handle dump for %s objects:\n\n", aszTypeNames[Type]);
        }
    } else {
        Print("Handle dump for all processes and threads:\n\n");
    }

    if (opts & OFLAG(v)) {
        Print("Handle          Type\n");
        Print("--------------------\n");
    }

    FOREACHHANDLEENTRY(phe, i)
        ShowProgress();
        ++cLocalHandleEntries;
        GetFieldValue(phe, SYM(HANDLEENTRY), "bFlags", bFlags);
        GetFieldValue(phe, SYM(HANDLEENTRY), "bType", bType);
        if ((opts & OFLAG(y)) && bType != Type) {
            continue;
        }

        GetFieldValue(phe, SYM(HANDLEENTRY), "pOwner", pOwner);
        GetFieldValue(pahti + bType * dwSize, SYM(HANDLETYPEINFO), "bObjectCreateFlags", bObjectCreateFlags);
        if (opts & OFLAG(p)) {
            if (bObjectCreateFlags & OCF_PROCESSOWNED) {
                if (pOwner == 0) {
                    continue;
                }

                GetFieldValue(pOwner, SYM(PROCESSINFO), "Process", pEprocess);
                GetFieldValue(pEprocess, "nt!EPROCESS", "UniqueProcessId", idProcess);
                if (idProcess == 0) {
                    // Print("Unable to read _EPROCESS at %p\n", pEprocess);
                    continue;
                }

                if (idProcess != dwT) {
                    continue;
                }
            } else {
                continue;
            }
        } else if (opts & OFLAG(t)) {
            if (!(bObjectCreateFlags & OCF_PROCESSOWNED)) {
                if (pOwner == 0) {
                    continue;
                }

                GetFieldValue(pOwner, SYM(THREADINFO), "pEThread", pEThread);
                GetFieldValue(pEThread, "nt!ETHREAD", "Cid.UniqueThread", handle);
                if (handle != dwT) {
                    continue;
                }
            } else {
                continue;
            }
        }

        acHandles[bType]++;

        if (bType == TYPE_FREE) {
            continue;
        }

        cHandlesUsed++;

        if (opts & OFLAG(v)) {
            Print("0x%08lx %c    %s\n",
                    i,
                    (bFlags & HANDLEF_DESTROY) ? '*' : ' ',
                    aszTypeNames[bType]);
        }

    NEXTEACHHANDLEENTRY()

    Print("\r");

    if (!(opts & OFLAG(v))) {
        Print("Count           Type\n");
        Print("--------------------\n");
        for (i = 0; i < TYPE_CTYPES; i++) {
            if ((opts & OFLAG(y)) && Type != (int)i) {
                continue;
            }
            Print("0x%08lx      (%d) %s\n", acHandles[i], i, aszTypeNames[i]);
        }
    }

    if (!(opts & OFLAG(y))) {
        Print("\nTotal Accessible Handles: 0x%lx\n", cLocalHandleEntries);
        Print("Used Accessible Handles: 0x%lx\n", cHandlesUsed);
        Print("Free Accessible Handles: 0x%lx\n", cLocalHandleEntries - cHandlesUsed);
    }

    return TRUE;
}
#endif // KERNEL

#ifdef KERNEL
/***************************************************************************\
* di - dumps interesting globals in USER related to input.
*
* 11-14-91 DavidPe      Created.
* 6/9/1995 SanfordS     made to fit stdexts motif
\***************************************************************************/
BOOL Idi(
    VOID)
{
    char            ach[80];

    PRTGPTR2(gptiCurrent, grpdeskRitInput);
    PRTGPTR2(gpqForeground, gpqForegroundPrev);
    PRTGPTR2(gptiForeground, gpqCursor);
    PRTGPTR1(gptiBlockInput);

    {
        DWORD           dw;
        PTR         ptr1;

        dw = DOWNCAST(DWORD, GetGlobalMember(VAR(glinp), SYM(LASTINPUT), "timeLastInputMessage"));
        ptr1 = GetGlobalMember(VAR(glinp), SYM(LASTINPUT), "ptiLastWoken");
        PRTVDW2(glinp.timeLastInputMessage, dw, glinp.ptiLastWoken, ptr1);
        PRTGDW1(gwMouseOwnerButton);
    }

    {
        POINT ptCursor;
        PTR psi = GetGlobalPointer(VAR(gpsi));

        GetFieldValue(psi, SYM(tagSERVERINFO), "ptCursor", ptCursor);
        PRTVPT(gpsi->ptCursor, ptCursor);
    }

    {
        PTR pdesk = GetGlobalPointer(VAR(grpdeskRitInput));
        if (pdesk != NULL_PTR) {
            PTR pDeskInfo;
            PTR spwnd;

            GetFieldValue(pdesk, SYM(tagDESKTOP), "pDeskInfo", pDeskInfo);
            GetFieldValue(pDeskInfo, SYM(tagDESKTOPINFO), "spwnd", spwnd);
            PRTWND(Desktop window, spwnd);
        }
    }

    {
        PTR pq = GetGlobalPointer(VAR(gpqForeground));

        if (pq) {
            PTR spwndFocus, spwndActive;

            GetFieldValue(pq, SYM(tagQ), "spwndFocus", spwndFocus);
            GetFieldValue(pq, SYM(tagQ), "spwndActive", spwndActive);
            PRTWND(gpqForeground->spwndFocus, spwndFocus);
            PRTWND(gpqForeground->spwndActive, spwndActive);
        }
    }

    PRTGWND(gspwndScreenCapture);
    PRTGWND(gspwndInternalCapture);
    PRTGWND(gspwndMouseOwner);

    return TRUE;
}
#endif // KERNEL


/************************************************************************\
* Idll
*
* Dump Linked Lists.
*
* ???????? Scottlu  Created
* 6/9/1995 SanfordS made to fit stdexts motif
\************************************************************************/
BOOL Idll(
    DWORD opts,
    LPSTR lpas)
{
    static DWORD iOffset;
    static DWORD cStructs;
    static DWORD cDwords;
    static DWORD cDwordsBack;
    static ULONG64 dw, dwHalfSpeed;
    ULONG64 dwT;
    DWORD cBytesBack;
    DWORD i, j;
    BOOL fIndirectFirst;
    BOOL fTestAndCountOnly = FALSE;
    ULONG64 dwFind = 0;
    DWORD adw[CDWORDS];
    ULONG64 dwValue;

    UNREFERENCED_PARAMETER(opts);

    /*
     * Evaluate the argument string and get the address of the object to
     * dump. Take either a handle or a pointer to the object.
     */
    while (*lpas == ' ') {
        lpas++;
    }

    /*
     * If there are no arguments, keep walking from the last
     * pointer.
     */
    if (*lpas != 0) {
        /*
         * If the address has a '*' in front of it, it means start with the
         * pointer stored at that address.
         */
        fIndirectFirst = FALSE;
        if (*lpas == '*') {
            lpas++;
            fIndirectFirst = TRUE;
        }

        /*
         * Scan past the address.
         */
        dw = dwValue = GetExpression(lpas);

        if (fIndirectFirst) {
            ReadPointer(dw, &dw);
        }
        dwHalfSpeed = dw;

        cStructs = 25;
        cDwords = 8;
        iOffset = cDwordsBack = 0;

        SAFEWHILE (TRUE) {
            while (*lpas == ' ') {
                lpas++;
            }

            switch(*lpas) {
            case 'l':
                /*
                 * length of each structure.
                 */
                lpas++;
                cDwords = (DWORD)(DWORD_PTR)GetExpression(lpas);
                if (cDwords > CDWORDS) {
                    Print("\nl%d? - %d DWORDs maximum\n\n", cDwords, CDWORDS);
                    cDwords = CDWORDS;
                }
                break;

            case 'b':
                /*
                 * Go back cDwordsBack and dump cDwords from there
                 * (useful for LIST_ENTRYs, where Flink doesn't point to
                 * the start of the struct). cDwordsBack can be negative,
                 * to allow people to start dumping from a certain offset
                 * within the structure.
                 */
                lpas++;
                cDwordsBack = (DWORD)(DWORD_PTR)GetExpression(lpas);
                if (cDwordsBack >= CDWORDS) {
                    Print("\nb%d? - %d DWORDs maximum\n\n", cDwordsBack, CDWORDS - 1);
                    cDwordsBack = CDWORDS - 1;
                }
                break;

            case 'o':
                /*
                 * Offset of 'next' pointer.
                 */
                lpas++;
                iOffset = (DWORD)(DWORD_PTR)GetExpression(lpas);
                break;

            case 'c':
                /*
                 * Count of structures to dump
                 */
                lpas++;
                cStructs = (DWORD)(DWORD_PTR)GetExpression(lpas);
                break;

            case 'f':
                /*
                 * Find element at given address
                 */
                lpas++;
                dwFind = EvalExp(lpas);
                break;

            case 't':
                /*
                 * Test list for loop, and count
                 */
                fTestAndCountOnly = TRUE;
                cStructs = 0x100000;

            default:
                break;
            }

            while (*lpas && *lpas != ' ')
                lpas++;

            if (*lpas == 0)
                break;
        }

        if (cDwordsBack > cDwords) {
            Print("backing up %d DWORDS per struct (b%d): ",
                    cDwordsBack, cDwordsBack);
            Print("increasing l%d to l%d so next link is included\n",
                    cDwords, cDwordsBack + 1);
            cDwords = cDwordsBack + 1;
        }

        for (i = 0; i < CDWORDS; i++) {
            adw[i] = 0;
        }
    }

    cBytesBack = cDwordsBack * sizeof(DWORD);

    for (i = 0; i < cStructs; i++) {
        moveBlock(adw, (dw - cBytesBack), sizeof(DWORD) * cDwords);

        if (!fTestAndCountOnly) {
            Print("---- 0x%lx:\n", i);
            for (j = 0; j < cDwords; j += 4) {
                switch (cDwords - j) {
                case 1:
                    Print("%p:  %08lx\n",
                            dw + j * sizeof(DWORD),
                            adw[j + 0]);
                    break;

                case 2:
                    Print("%p:  %08lx %08lx\n",
                            dw + j * sizeof(DWORD),
                            adw[j + 0], adw[j + 1]);
                    break;

                case 3:
                    Print("%p:  %08lx %08lx %08lx\n",
                            dw + j * sizeof(DWORD),
                            adw[j + 0], adw[j + 1], adw[j + 2]);
                    break;

                default:
                    Print("%p:  %08lx %08lx %08lx %08lx\n",
                            dw + j * sizeof(DWORD),
                            adw[j + 0], adw[j + 1], adw[j + 2], adw[j + 3]);
                }
            }
        } else if ((i & 0xff) == 0xff) {
            Print("item 0x%lx at %p...\n", i+1, dw);
        }

        if (dwFind == dw) {
            Print("====== FOUND ITEM ======\n");
            break;
        }

        /*
         * Give a chance to break out every 16 items
         */
        if ((i & 0xf) == 0xf) {
            if (IsCtrlCHit()) {
                Print("terminated by Ctrl-C on item 0x%lx at %p...\n", i, dw);
                break;
            }
        }

        /*
         * Advance to next item.
         */
        dwT = dw + iOffset * sizeof(DWORD);
        ReadPointer(dwT, &dw);

        if (fTestAndCountOnly) {
            /*
             * Advance dwHalfSpeed every other time round the loop: if
             * dw ever catches up to dwHalfSpeed, then we have a loop!
             */
            if (i & 1) {
                dwT = dwHalfSpeed + iOffset * sizeof(DWORD);
                ReadPointer(dwT, &dwHalfSpeed);
            }
            if (dw == dwHalfSpeed) {
                Print("!!! Loop Detected on item 0x%lx at %lx...\n", i, dw);
                break;
            }
        }

        if (dw == 0) {
            break;
        }
    }
    Print("---- Total 0x%lx items ----\n", i+1);

    return TRUE;
}


/************************************************************************\
* Ifind
*
* Find Linked List Element
*
* 11/22/95 JimA         Created.
\************************************************************************/
BOOL Ifind(
    DWORD opts,
    LPSTR lpas)
{
    DWORD iOffset = 0;
    ULONG64 dwBase, dwAddr, dwTest, dwT, dwLast = 0;

    UNREFERENCED_PARAMETER(opts);

    /*
     * Evaluate the argument string and get the address of the object to
     * dump. Take either a handle or a pointer to the object.
     */
    while (*lpas == ' ') {
        lpas++;
    }

    /*
     * If there are no arguments, keep walking from the last
     * pointer.
     */
    if (*lpas != 0) {

        /*
         * Scan past the addresses.
         */
        dwBase = EvalExp(lpas);
        while (*lpas && *lpas != ' ') {
            lpas++;
        }
        dwAddr = EvalExp(lpas);
        while (*lpas && *lpas != ' ') {
            lpas++;
        }

        iOffset = 0;

        SAFEWHILE (*lpas != 0) {
            while (*lpas == ' ') {
                lpas++;
            }

            switch(*lpas) {
            case 'o':
                /*
                 * Offset of 'next' pointer.
                 */
                lpas++;
                iOffset = (DWORD)(DWORD_PTR)EvalExp(lpas);
                break;

            default:
                break;
            }

            while (*lpas && *lpas != ' ') {
                lpas++;
            }
        }
    }

    dwTest = dwBase;
    while (dwTest && (ULONG_PTR)dwTest != (ULONG_PTR)dwAddr) {
        dwLast = dwTest;
        dwT = dwTest + iOffset * sizeof(DWORD);
        move(dwTest, dwT);
    }

    if (dwTest == 0) {
        Print("Address %#p not found\n", dwAddr);
    } else {
        Print("Address %#p found, previous = %#p\n", dwAddr, dwLast);
    }

    return TRUE;
}

#ifdef KERNEL
/***************************************************************************\
* dlr handle|pointer
*
* Dumps lock list for object
*
* 02-27-92 ScottLu      Created.
* 6/9/1995 SanfordS     made to fit stdexts motif
\***************************************************************************/

#define LR_FLAG(x)  (1 << (x))
#define LR_SIMPLELOCK   0

BOOL Idlr(
    DWORD opts,
    LPSTR lpszParam)
{
    PTR phe;
    ULONG64 param;
    ULONG64 plrT;
    ULONG64 pTrace;
    ULONG cbPtr, cbOffset;
    ULONG64  psi;
    DWORD dwDBGTAGFlags, dwLockRecordFlags;

    psi = GetGlobalPointer(VAR(gpsi));

    if (GetFieldOffset(SYM(SERVERINFO), "adwDBGTAGFlags", &cbOffset)) {
        Print("failed to get the SERVERINFO::adwDBGTAGFlags\n");
        return TRUE;
    }

    dwDBGTAGFlags = (DWORD)GetArrayElement(psi, SYM(SERVERINFO), "adwDBGTAGFlags", DBGTAG_TrackLocks, "DWORD");

    dwDBGTAGFlags &= DBGTAG_VALIDUSERFLAGS;

    moveExpValue(&dwLockRecordFlags, VAR(gdwLockRecordFlags));

    if (opts & (OFLAG(s) | OFLAG(c))) {
        DWORD flag;

        if (!NT_SUCCESS(GetInteger(lpszParam, 0x10, &flag, NULL))) {
            Print("Invalid arg: '%s'\n", lpszParam);
            return FALSE;
        }
        if (opts & OFLAG(s)) {
            dwLockRecordFlags |= LR_FLAG(flag);
        } else {
            dwLockRecordFlags &= ~LR_FLAG(flag);
        }
        Print("7\n");
        WriteMemory(EvalExp(VAR(gdwLockRecordFlags)), &dwLockRecordFlags, sizeof dwLockRecordFlags, NULL);
        Print("8\n");

        // for to display it
        opts |= OFLAG(l);
    }

    if (opts & OFLAG(l)) {
        #define HT(type)    { type, #type }
        static const struct {
            DWORD dwType;
            char* lpszName;
        } flags[] = {
            //{ LR_SIMPLELOCK, "Rec SimpleLock" },
            { LR_SIMPLELOCK, "Reserved" },
            HT(TYPE_WINDOW),
            HT(TYPE_MENU),
            HT(TYPE_CURSOR),
            HT(TYPE_SETWINDOWPOS),
            HT(TYPE_HOOK),
            HT(TYPE_CLIPDATA),
            HT(TYPE_CALLPROC),
            HT(TYPE_ACCELTABLE),
            HT(TYPE_DDEACCESS),
            HT(TYPE_DDECONV),
            HT(TYPE_DDEXACT),
            HT(TYPE_MONITOR),
            HT(TYPE_KBDLAYOUT),
            HT(TYPE_KBDFILE),
            HT(TYPE_WINEVENTHOOK),
            HT(TYPE_TIMER),
            HT(TYPE_INPUTCONTEXT),
            HT(TYPE_HIDDATA),
            HT(TYPE_DEVICEINFO),
        };
        #undef HT
        UINT i;

        Print("gdwLockRecordFlags: %08x\n", dwLockRecordFlags);

        for (i = 0; i < ARRAY_SIZE(flags); ++i) {
            char prefix = ' ';
            if (dwLockRecordFlags & LR_FLAG(flags[i].dwType)) {
                prefix = '*';
            }
            Print(" %02x %c%-18s", (DWORD)flags[i].dwType, prefix, flags[i].lpszName);
            if ((i + 1) % 3 == 0) {
                Print("\n");
            }
        }
        Print("\n");

        return TRUE;
    }

    if (*lpszParam == '\0') {
        Print("no arg!!\n");
        return FALSE;
    }

    param = EvalExp(lpszParam);
    if (!GetAndDumpHE(param, &phe, FALSE)) {
        Print("!dlr: GetAndDumpHE failed\n");
        return FALSE;
    }

    /*
     * We have the handle entry: 'he' is filled in. Now dump the lock
     * records. Remember the 1st record is the last transaction!
     */
    GetFieldValue(phe, SYM(HANDLEENTRY), "plr", plrT);
    if (plrT != 0) {
        Print("phe %p Dumping the lock records\n"
              "----------------------------------------------\n"
              "address  cLock\n"
              "----------------------------------------------\n", phe);
    }

    SAFEWHILE (plrT != 0) {
        ULONG64     dw;
        int         i;
        char        ach[80];

        _InitTypeRead(plrT, SYM(LOCKRECORD));

        Print("%p %08d\n", ReadField(ppobj), ReadField(cLockObj));

        GetFieldOffset(SYM(LOCKRECORD), "trace", &cbOffset);
        cbPtr = GetTypeSize("PVOID");


        for (i = 0; i < LOCKRECORD_STACK; i++) {
            ReadPointer(plrT + cbOffset + i * cbPtr, &pTrace);
            GetSym(pTrace, ach, &dw);
            Print("                  %s", ach);
            if (dw != 0) {
                Print("+0x%x", dw);
            }
            Print("\n");
        }

        plrT = ReadField(plrNext);
    }

    return TRUE;
}
#endif


VOID DumpMenu(
    UINT uIndent,
    DWORD opts,
    PTR pMenu)
{
    DWORD fFlags, cxMenu, cyMenu, dwContextHelpId, cch, dwSize;
    UINT cAlloced, cItems, i;
    INT iItem;
    WCHAR szBufW[128];
    char szIndent[256];
    ULONG dwOffset;
    PTR pwnd, pitem;

    /*
     * Compute our indent
     */
    for (i = 0; i < uIndent; szIndent[i++] = ' ')
        /* do nothing */;
    szIndent[i] = '\0';

    dwSize = GetTypeSize("ITEM");

    /*
     * Print the menu header
     */
    if (!(opts & OFLAG(v))) {
        Print("0x%p  %s", pMenu, szIndent);
    } else {
        Print("%sPMENU @ 0x%p:\n", szIndent, pMenu);
    }

    /*
     * Try and get the menu
     */
    if (_InitTypeRead(pMenu, SYM(MENU))) {
        Print("Couldn't read PMENU at %p\n", pMenu);
        return;
    }

    /*
     * Print the information for this menu
     */
    fFlags = (DWORD)ReadField(fFlags);
    cxMenu = (DWORD)ReadField(cxMenu);
    cyMenu = (DWORD)ReadField(cyMenu);
    dwContextHelpId = (DWORD)ReadField(dwContextHelpId);
    cAlloced = (UINT)ReadField(cAlloced);
    cItems = (UINT)ReadField(cItems);
    iItem = (INT)ReadField(iItem);
    pwnd = ReadField(spwndNotify);
    if (!(opts & OFLAG(v))) {
        Print("PMENU: fFlags=0x%lX, cItems=%lu, iItem=%lu, spwndNotify=0x%p\n",
              fFlags, cItems, iItem, pwnd);
    } else {
        Print("%s     fFlags............ %s\n"
              "%s     location.......... (%lu, %lu)\n",
              szIndent, GetFlags(GF_MF, (WORD)fFlags, NULL, TRUE),
              szIndent, cxMenu, cyMenu);
        Print("%s     spwndNotify....... 0x%p\n"
              "%s     dwContextHelpId... 0x%08lX\n"
              "%s     items............. %lu items in block of %lu\n",
              szIndent, pwnd,
              szIndent, dwContextHelpId,
              szIndent, cItems, cAlloced);
    }

    GetFieldOffset(SYM(MENU), "rgItems", &dwOffset);
    pitem = (ULONG_PTR)pMenu + dwOffset;
    if (ReadPointer(FIXKP(pitem), &pitem)) {
        i = 0;
        SAFEWHILE (i < cItems) {
            /*
             * Get the menu item
             */
            _InitTypeRead(FIXKP(pitem), SYM(ITEM));
            if (!(opts & OFLAG(i))) {
                /*
                 * Print the info for this item.
                 */
                if (!(opts & OFLAG(v))) {
                    Print("0x%p      %s%lu: ID=0x%08lX hbmp=0x%p", pitem, szIndent, i, (INT)(WORD)ReadField(wID), (ULONG_PTR)ReadField(hbmp));
                    cch = (DWORD)ReadField(cch);
                    if (cch && CopyUnicodeString(pitem, SYM(ITEM), "lpstr", szBufW, (cch * sizeof(WCHAR)))) {
                        szBufW[cch] = 0;
                        Print("  %ws%\n", szBufW);
                    } else {
                        Print(", fType=%s", GetFlags(GF_MENUTYPE, (WORD)ReadField(fType), NULL, TRUE));
                        if (((UINT)ReadField(fType) & MF_SEPARATOR) == 0) {
                             Print(", lpstr=0x%p", ReadField(lpstr));
                        }
                        Print("\n");
                    }
                } else {
                    Print("%s   Item #%d @ 0x%p:\n", szIndent, i, pitem);
                    /*
                     * Print the details for this item.
                     */
                    Print("%s         ID........... 0x%08lX (%lu)\n"
                          "%s         lpstr.... 0x%p",
                          szIndent, (WORD)ReadField(wID), (WORD)ReadField(wID),
                          szIndent, ReadField(lpstr));
                    if (cch && CopyUnicodeString(pitem, SYM(ITEM), "lpstr", szBufW, (cch*sizeof(WCHAR)))) {
                        szBufW[cch] = 0;
                        Print("  %ws%\n", szBufW);
                    } else {
                        Print("\n");
                    }
                    Print("%s         fType........ %s\n"
                          "%s         fState....... %s\n"
                          "%s         dwItemData... 0x%p\n",
                          szIndent, GetFlags(GF_MENUTYPE, (WORD)ReadField(fType), NULL, TRUE),
                          szIndent, GetFlags(GF_MENUSTATE, (WORD)ReadField(fState), NULL, TRUE),
                          szIndent, (ULONG_PTR)ReadField(dwItemData));
                    Print("%s         checks....... on=0x%p, off=0x%p\n"
                          "%s         location..... @(0n%lu, 0n%lu) size=(0n%lu, 0n%lu)\n",
                          szIndent, ReadField(hbmpChecked), ReadField(hbmpUnchecked),
                          szIndent, (DWORD)ReadField(xItem), (DWORD)ReadField(yItem), (DWORD)ReadField(cxItem), (DWORD)ReadField(cyItem));
                    Print("%s         underline.... x=%lu, width=%lu\n"
                          "%s         dxTab........ %lu\n"
                          "%s         spSubMenu.... 0x%p\n",
                          szIndent, (DWORD)ReadField(ulX), (DWORD)ReadField(ulWidth),
                          szIndent, (DWORD)ReadField(dxTab),
                          szIndent, ReadField(spSubMenu));
                }
            }

            /*
             * If requested, traverse through sub-menus
             */
            if (opts & OFLAG(r)) {
                pMenu = HorPtoP(ReadField(spSubMenu), TYPE_MENU);
                if (pMenu) {
                    DumpMenu(uIndent + 8, opts, pMenu);
                }
            }
            pitem += dwSize;
            ++i;
        }
    }
}

/************************************************************************\
* Idm
*
* Dumps Menu structures
*
* 6/9/1995 Created SanfordS
\************************************************************************/
BOOL Idm(
    DWORD opts,
    ULONG64 param1)
{
    PTR pvObject, phe;
    BYTE bType;

    if (param1 == 0) {
        return FALSE;
    }

    pvObject = HorPtoP(FIXKP(param1), -1);
    if (pvObject == 0) {
        Print("dm: Could not convert 0x%p to an object.\n", pvObject);
        return TRUE;
    }

    if (!getHEfromP(&phe, pvObject)) {
        Print("dm: Could not get header for object 0x%p.\n", pvObject);
        return TRUE;
    }

    GetFieldValue(phe, SYM(HANDLEENTRY), "bType", bType);
    switch (bType) {
    case TYPE_WINDOW:
        Print("--- Dump Menu for %s object @ 0x%p ---\n", pszObjStr[bType], FIXKP(pvObject));
        if (_InitTypeRead(pvObject, SYM(tagWND))) {
            Print("dm: Could not read object at 0x%p.\n", pvObject);
            return TRUE;
        }

        if (opts & OFLAG(s)) {
            /*
             * Display window's system menu
             */
            if ((pvObject = FIXKP(ReadField(spmenuSys))) == 0) {
                Print("dm: This window does not have a system menu.\n");
                return TRUE;
            }
        } else {
            if ((DWORD)ReadField(style) & WS_CHILD) {
                /*
                 * Child windows don't have menus
                 */
                Print("dm: Child windows do not have menus.\n");
                return TRUE;
            }

            if ((pvObject = FIXKP(ReadField(spmenu))) == 0) {
                Print("dm: This window does not have a menu.\n");
                return TRUE;
            }
        }

        /* >>>>  F A L L   T H R O U G H   <<<< */

    case TYPE_MENU:
        DumpMenu(0, opts, pvObject);
        break;

    default:
        return FALSE;
    }

    return TRUE;
}

#ifdef KERNEL
/***************************************************************************\
* dmq - dump messages on queue
*
* dmq address - dumps messages in queue structure at address.
* dmq -a      - dump messages for all queues
* dmq -c      - count messages for all queues
*
* 11-13-91 DavidPe      Created.
* 6/9/1995 SanfordS     made to fit stdexts motif
* 11/05/2000 Hiroyama   new 64bit clean code
\***************************************************************************/

typedef struct tagQSTAT {
    DWORD dwInput, dwPosted, dwQueues, dwThreads;
    DWORD opts;
} QSTAT, *PQSTAT;

/*
 * PrintMessages
 * N.b. resets InitTypeRead
 */
BOOL PrintMessages(PTR pqmsgRead, PTR pti)
{
    ULONG64 asmsg;    // ASYNCSENDMSG
    char *aszEvents[] = {
        "MSG",  // QEVENT_MESSAGE
        "SHO",  // QEVENT_SHOWWINDOW"
        "CMD",  // QEVENT_CANCLEMODE"
        "SWP",  // QEVENT_SETWINDOWPOS"
        "UKS",  // QEVENT_UPDATEKEYSTATE"
        "DEA",  // QEVENT_DEACTIVATE"
        "ACT",  // QEVENT_ACTIVATE"
        "PST",  // QEVENT_POSTMESSAGE"
        "EXE",  // QEVENT_EXECSHELL"
        "CMN",  // QEVENT_CANCELMENU"
        "DSW",  // QEVENT_DESTROYWINDOW"
        "ASY",  // QEVENT_ASYNCSENDMSG"
        "HNG",  // QEVENT_HUNGTHREAD"
        "CMT",  // QEVENT_CANCELMOUSEMOVETRK"
        "NWE",  // QEVENT_NOTIFYWINEVENT"
        "RAC",  // QEVENT_RITACCESSIBILITY"
        "RSO",  // QEVENT_RITSOUND"
        "?  ",  // "?"
        "?  ",  // "?"
        "?  "   // "?"
    };
    #define NQEVENT (ARRAY_SIZE(aszEvents))

#if 0
    Print("typ pqmsg    hwnd    msg  wParam   lParam   time     ExInfo   dwQEvent pti\n");
    Print("-------------------------------------------------------------------------------\n");
#else
    Print("typ %-*s %-*s msg  %-*s %-*s time     %-*s dwQEvent pti\n",
          PtrWidth(), "pqmsg",
          PtrWidth(), "hwnd",
          PtrWidth(), "wParam",
          PtrWidth(), "lParam",
          PtrWidth(), "ExInfo");
    Print("----------------------------------------------------------------------------------\n");
#endif

    SAFEWHILE (TRUE) {
        _InitTypeRead(pqmsgRead, SYM(tagQMSG));
        if (ReadField(dwQEvent) < NQEVENT) {
            Print("%s %p ", aszEvents[ReadField(dwQEvent)], pqmsgRead);
        } else {
            Print("??? %p ", pqmsgRead);
        }

        switch (ReadField(dwQEvent)) {
        case QEVENT_ASYNCSENDMSG:
            asmsg = ReadField("msg.wParam");
            _InitTypeRead(asmsg, SYM(ASYNCSENDMSG));

            Print("%08p %04lx %08p %08p %08lx %08p %08lx %08p %c\n",
                  ReadField(hwnd), (DWORD)ReadField(message), ReadField(wParam), ReadField(lParam),
                  (DWORD)ReadField(msg.time), ReadField(ExtraInfo), (DWORD)ReadField(dwQEvent), ReadField(pti),
                  pti && ReadField(pti) == pti ? '*' : ' ');
            break;

        case 0:
        default:
            Print("%08p %04lx %08p %08p %08lx %08p %08lx %08p %c\n",
                  ReadField(msg.hwnd), (DWORD)ReadField(msg.message), ReadField(msg.wParam), ReadField(msg.lParam),
                  (DWORD)ReadField(msg.time), ReadField(ExtraInfo), (DWORD)ReadField(dwQEvent), ReadField(pti),
                  pti && ReadField(pti) == pti ? '*' : ' ');
            break;

        }

        _InitTypeRead(pqmsgRead, SYM(tagQMSG));
        if (ReadField(pqmsgNext) != NULL_PTR) {
            if (pqmsgRead == ReadField(pqmsgNext)) {
                Print("<ALERT!> loop found in message list!");
                return FALSE;
            }
            pqmsgRead = ReadField(pqmsgNext);
        } else {
            return TRUE;
        }
    }
    return TRUE;
}

/*
 * DumpQMsg --- dumps or counts messages in a queue
 * N.b. resets InitTypeRead
 * - hiroyama
 */
BOOL DumpQMsg(
    PTR pq,
    PQSTAT qs,
    PTR pti)
{
    PTR ptiTmp;
    BOOL bMsgsPresent = FALSE;

    _InitTypeRead(pq, SYM(tagQ));

    // LATER: error handling in case pq is not accessible?

    if ((qs->opts & OFLAG(c)) == 0) {
        Print("Messages for queue 0x%p pti=%p\n", pq, pti);
    }

    if (pti) {
        if (ReadField(ptiKeyboard) == pti || ReadField(ptiMouse) == pti) {
            qs->dwQueues++;
        }
    }

    if (ReadField(ptiKeyboard) != NULL_PTR) {
        PTR pqmsgRead;

        ptiTmp = ReadField(ptiKeyboard);

        GetFieldValue(ptiTmp, SYM(tagTHREADINFO), "mlPost.pqmsgRead", pqmsgRead);

        if (!(qs->opts & OFLAG(c)) && pqmsgRead) {
            // If not counter only, and post messages exist, dump them all.
            bMsgsPresent = TRUE;
            Print("==== PostMessage queue ====\n");
            PrintMessages(FIXKP(pqmsgRead), NULL_PTR);
        }
    } else {
        Print("<ALERT!> ptiKeyboard is NULL for pq=%p!\n", pq);
    }

    _InitTypeRead(pq, SYM(tagQ));

    if (!(qs->opts & OFLAG(c)) && ReadField(mlInput.pqmsgRead)) {
        // If not counter only, and input messages exist, dump them all.
        bMsgsPresent = TRUE;
        Print(    "==== Input queue ==========\n");
        if (ReadField(mlInput.pqmsgRead) != NULL_PTR) {
            PrintMessages(FIXKP(ReadField(mlInput.pqmsgRead)), pti);
        }
    }

    _InitTypeRead(pq, SYM(tagQ));

    if (qs->opts & OFLAG(c)) {
        DWORD dwTimePosted;
        DWORD dwTimeInput = 0;
        DWORD dwOldest, dwNewest;

        if (ReadField(mlInput.cMsgs)) {
            qs->dwInput += (DWORD)ReadField(mlInput.cMsgs);
            GetFieldValue(ReadField(mlInput.pqmsgRead), SYM(tagQMSG), "msg.time", dwOldest);
            GetFieldValue(ReadField(mlInput.pqmsgWriteLast), SYM(tagQMSG), "msg.time", dwNewest);
            dwTimeInput = dwNewest - dwOldest;
        }
        Print("%08p%c %8x %8x\t%08p",
              pq,
              ((ReadField(ptiKeyboard) != pti) && (ReadField(ptiMouse) != pti)) ? '*' : ' ',
              (DWORD)ReadField(mlInput.cMsgs), dwTimeInput,
              ReadField(ptiKeyboard));
        //
        // it would be good to print the ptiStatic too, maybe like this:
        // e1b978a8         0         0    e1ba3368        0         0
        // e1b9aca8*        0         0    e1b8b2e8        0         0
        //   (thread who's queue this is : e1a3ca28        0         0)
        //

        // Dump post message statics
        dwTimePosted = 0;
        _InitTypeRead(ptiTmp, SYM(tagTHREADINFO));
        if (ReadField(mlPost.cMsgs)) {
            qs->dwPosted += (DWORD)ReadField(mlPost.cMsgs);
            GetFieldValue(ReadField(mlPost.pqmsgRead), SYM(tagQMSG), "msg.time", dwOldest);
            GetFieldValue(ReadField(mlPost.pqmsgWriteLast), SYM(tagQMSG), "msg.time", dwNewest);
            dwTimePosted = dwNewest - dwOldest;
        }
        Print(" %8x %8x\n", (DWORD)ReadField(mlPost.cMsgs), dwTimePosted);
    } else {
        if (bMsgsPresent) {
            Print("\n");
        }
    }

    return TRUE;
}

ULONG dmqCallback(
    PTR pti,
    PVOID pData)
{
    PQSTAT qs = (PQSTAT)pData;

    _InitTypeRead(pti, SYM(tagTHREADINFO));
    DumpQMsg(ReadField(pq), qs, pti);

    _InitTypeRead(pti, SYM(tagTHREADINFO));
    if (ReadField(pqAttach)) {
        Print(" -> pqAttach=%p", ReadField(pqAttach));
        // LATER: dump pqAttach as well?
    }

    return FALSE;
}


BOOL Idmq(
    DWORD opts,
    ULONG64 param1)
{
    try {
        static const char separator[] = "=================";
        PTR pq;

        // firstly check the symbols etc.'s legitimacy
        pq = GetGlobalPointer(VAR(gpqForeground));

        if (param1 == NULL_PTR) {
            if ((opts & OFLAG(a)) == 0) {
                Print("uses gpqForeground\n");
            }
        }

        if (opts & OFLAG(c)) {
            Print("Summary of%s message queues (\"age\" is newest time - oldest time)\n",
                  param1 == NULL_PTR ? " all" : "");
            //Print("Queue      # Input    age   \t Thread  # Posted    age\n");
            //Print("========  ========  ========\t======== ========  ========\n");
            Print("%-*s  %-*s %-*s\t%-*s %-*s %-*s\n",
                  PtrWidth(), "queue",
                  PtrWidth(), "# input",
                  PtrWidth(), "age",
                  PtrWidth(), "Thread",
                  PtrWidth(), "# posted",
                  PtrWidth(), "age");
            Print("%*.*s  %*.*s %*.*s\t%*.*s %*.*s %*.*s\n",
                  PtrWidth(), PtrWidth(), separator,
                  PtrWidth(), PtrWidth(), separator,
                  PtrWidth(), PtrWidth(), separator,
                  PtrWidth(), PtrWidth(), separator,
                  PtrWidth(), PtrWidth(), separator,
                  PtrWidth(), PtrWidth(), separator);
        }

        if (param1 == NULL_PTR) {
            if (opts & OFLAG(t)) {
                // pti is required with -t
                return FALSE;
            }
            if (opts & (/*OFLAG(c) |*/ OFLAG(a))) {
                /*
                 * do it for all the queues
                 */
                QSTAT qs = { 0, };
                qs.opts = opts & OFLAG(c);
                ForEachPti(dmqCallback, &qs);
                if (opts & OFLAG(c)) {
                    Print(" \n");
                    Print("Queues     # Input          \t Threads # Posted\n");
                    Print("========  ========  ========\t======== ========\n");
                    Print("%8x  %8x          \t%8x %8x\n",
                          qs.dwQueues, qs.dwInput, qs.dwThreads, qs.dwPosted);
                }
                return TRUE;
            } else {
                // use gpqForeground
                if (pq == NULL_PTR) {
                    Print("no foreground queue (gpqForeground == NULL)!\n");
                    return TRUE;
                }
            }
        } else {
            // param1 is pq or pti
            pq = param1;
        }

        if (opts & OFLAG(t)) {
            // param1 is pti
            QSTAT qs = { 0, };
            qs.opts = opts & OFLAG(c);

            _InitTypeRead(param1, SYM(tagTHREADINFO));
            DumpQMsg(ReadField(pq), &qs, param1);
            _InitTypeRead(param1, SYM(tagTHREADINFO));
            if (ReadField(pqAttach)) {
                Print("paAttach\n");
                DumpQMsg(ReadField(pqAttach), &qs, param1);
            }
        } else {
            // param1 is pq
            PTR ptiKeyboard;
            QSTAT qs = { 0, };
            qs.opts = opts & OFLAG(c);
            GetFieldValue(pq, SYM(tagQ), "ptiKeyboard", ptiKeyboard);
            DumpQMsg(pq, &qs, ptiKeyboard);
        }
    } except (CONTINUE) {
    }

    return TRUE;
}
#endif  // KERNEL


#ifdef OLD_DEBUGGER
#ifdef KERNEL
/***************************************************************************\
* dwe - dump winevents
*
* dwe           - dumps all EVENTHOOKs.
* dwe <addr>    - dumps EVENTHOOK at address.
* dwe -n        - dumps all NOTIFYs.
* dwe -n <addr> - dumps NOTIFY at address.
*
* 1997-07-10 IanJa      Created.
\***************************************************************************/
BOOL Idwe(
    DWORD opts,
    ULONG64 param1)
{
    EVENTHOOK EventHook, *pEventHook;
    NOTIFY Notify, *pNotify;
    PVOID pobj;
    char ach[100];

    pobj = FIXKP(param1);

    if (opts & OFLAG(n)) {
        if (pobj) {
            move(Notify, pobj);
            sprintf(ach, "NOTIFY 0x%p\n", pobj);
            Idso(0, ach);
            return 1;
        }
        pNotify = GetGlobalPointer(VAR(gpPendingNotifies));
        Print("Pending Notifications:\n");
        gnIndent += 2;
        SAFEWHILE (pNotify != NULL) {
            sprintf(ach, "NOTIFY  0x%p\n", pNotify);
            Idso(0, ach);
            move(pNotify, &pNotify->pNotifyNext);
        }
        gnIndent -= 2;
        return TRUE;
    }

    if (pobj) {
        move(EventHook, pobj);
        sprintf(ach, "EVENTHOOK 0x%p\n", pobj);
        Idso(0, ach);
        return 1;
    }
    pEventHook = GetGlobalPointer(VAR(gpWinEventHooks));
    Print("WinEvent hooks:\n");
    gnIndent += 2;
    SAFEWHILE (pEventHook != NULL) {
        sprintf(ach, "EVENTHOOK  0x%p\n", pEventHook);
        Idso(0, ach);
        move(pEventHook, &pEventHook->pehNext);
    }
    gnIndent -= 2;
    Print("\n");
    return TRUE;
}
#endif // KERNEL


#ifndef KERNEL
/************************************************************************\
* Idped
*
* Dumps Edit Control Structures (PEDs)
*
* 6/9/1995 Created SanfordS
\************************************************************************/
BOOL Idped(
    DWORD opts,
    ULONG64 param1)
{
    PED   ped;
    ED    ed;
    DWORD pText;

    UNREFERENCED_PARAMETER(opts);

    ped = param1;

    move(ed, ped);
    move(pText, ed.hText);


    Print("PED Handle: %lX\n", ped);
    Print("hText      %lX (%lX)\n", ed.hText, pText);
    PRTFDW2(ed., cchAlloc, cchTextMax);
    PRTFDW2(ed., cch, cLines);
    PRTFDW2(ed., ichMinSel, ichMaxSel);
    PRTFDW2(ed., ichCaret, iCaretLine);
    PRTFDW2(ed., ichScreenStart, ichLinesOnScreen);
    PRTFDW2(ed., xOffset, charPasswordChar);
    PRTFDWDWP(ed., cPasswordCharWidth, hwnd);
    PRTFDWP1(ed., pwnd);
    PRTFRC(ed., rcFmt);
    PRTFDWP1(ed., hwndParent);
    PRTFPT(ed., ptPrevMouse);
    PRTFDW1(ed., prevKeys);

    BEGIN_PRTFFLG();
    PRTFFLG(ed, fSingle);
    PRTFFLG(ed, fNoRedraw);
    PRTFFLG(ed, fMouseDown);
    PRTFFLG(ed, fFocus);
    PRTFFLG(ed, fDirty);
    PRTFFLG(ed, fDisabled);
    PRTFFLG(ed, fNonPropFont);
    PRTFFLG(ed, fNonPropDBCS);
    PRTFFLG(ed, fBorder);
    PRTFFLG(ed, fAutoVScroll);
    PRTFFLG(ed, fAutoHScroll);
    PRTFFLG(ed, fNoHideSel);
    PRTFFLG(ed, fDBCS);
    PRTFFLG(ed, fFmtLines);
    PRTFFLG(ed, fWrap);
    PRTFFLG(ed, fCalcLines);
    PRTFFLG(ed, fEatNextChar);
    PRTFFLG(ed, fStripCRCRLF);
    PRTFFLG(ed, fInDialogBox);
    PRTFFLG(ed, fReadOnly);
    PRTFFLG(ed, fCaretHidden);
    PRTFFLG(ed, fTrueType);
    PRTFFLG(ed, fAnsi);
    PRTFFLG(ed, fWin31Compat);
    PRTFFLG(ed, f40Compat);
    PRTFFLG(ed, fFlatBorder);
    PRTFFLG(ed, fSawRButtonDown);
    PRTFFLG(ed, fInitialized);
    PRTFFLG(ed, fSwapRoOnUp);
    PRTFFLG(ed, fAllowRTL);
    PRTFFLG(ed, fDisplayCtrl);
    PRTFFLG(ed, fRtoLReading);
    PRTFFLG(ed, fInsertCompChr);
    PRTFFLG(ed, fReplaceCompChr);
    PRTFFLG(ed, fNoMoveCaret);
    PRTFFLG(ed, fResultProcess);
    PRTFFLG(ed, fKorea);
    PRTFFLG(ed, fInReconversion);
    END_PRTFFLG();

    PRTFDWDWP(ed., cbChar, chLines);
    PRTFDWDWP(ed., format, lpfnNextWord);
    PRTFDW1(ed., maxPixelWidth);

    {
        const char* p = "**INVALID**";

        if (ed.undoType < UNDO_DELETE) {
            p = GetFlags(GF_EDUNDO, 0, NULL, TRUE);
        }
        Print(DWSTR2 "\t" "%08x undoType (%s)\n", ed.hDeletedText, "hDeleteText", ed.undoType, p);
    }

    PRTFDW2(ed., ichDeleted, cchDeleted);
    PRTFDW2(ed., ichInsStart, ichInsEnd);

    PRTFDWPDW(ed., hFont, aveCharWidth);
    PRTFDW2(ed., lineHeight, charOverhang);
    PRTFDW2(ed., cxSysCharWidth, cySysCharHeight);
    PRTFDWP2(ed., listboxHwnd, pTabStops);
    PRTFDWP1(ed., charWidthBuffer);
//    PRTFDW2(ed., hkl, wMaxNegA);
    PRTFDW1(ed., wMaxNegA);
    PRTFDW2(ed., wMaxNegAcharPos, wMaxNegC);
    PRTFDW2(ed., wMaxNegCcharPos, wLeftMargin);
    PRTFDW2(ed., wRightMargin, ichStartMinSel);
    PRTFDWDWP(ed., ichStartMaxSel, pLpkEditCallout);
    PRTFDWP2(ed., hCaretBitmap, hInstance);
    PRTFDW2(ed., seed, fEncoded);
    PRTFDW2(ed., iLockLevel, wImeStatus);
    return TRUE;
}
#endif // !KERNEL
#endif // OLD_DEBUGGER

#ifndef KERNEL
/************************************************************************\
* Idci
*
* Dumps Client Info
*
* 6/15/1995 Created SanfordS
\************************************************************************/
BOOL Idci(
    VOID)
{
    PTR pteb = NULL_PTR;

    GetTebAddress(&pteb);
    if (pteb) {
        ULONG pciOffset;

        GetFieldOffset(SYM(TEB), "Win32ClientInfo", &pciOffset);
        _InitTypeRead(pteb + pciOffset, SYM(CLIENTINFO));

        Print("PCLIENTINFO @ 0x%p:\n", pteb + pciOffset);
        // DWORD dwExpWinVer;
        Print("\tdwExpWinVer            %08lx\n", (ULONG)ReadField(dwExpWinVer));
        // DWORD dwCompatFlags;
        Print("\tdwCompatFlags          %08lx\n", (ULONG)ReadField(dwCompatFlags));
        // DWORD dwTIFlags;
        Print("\tdwTIFlags              %08lx\n", (ULONG)ReadField(dwTIFlags));
        // PDESKTOPINFO pDeskInfo;
        Print("\tpDeskInfo              %p\n",    ReadField(pDeskInfo));
        // ULONG ulClientDelta;
        Print("\tulClientDelta          %p\n",    ReadField(ulClientDelta));
        // struct tagHOOK *phkCurrent;
        Print("\tphkCurrent             %p\n",    ReadField(phkCurrent));
        // DWORD fsHooks;
        Print("\tfsHooks                %08lx\n", (ULONG)ReadField(fsHooks));
        // CALLBACKWND CallbackWnd;
        Print("\tCallbackWnd.hwnd       %p\n",    ReadField(CallbackWnd.hwnd));
        // DWORD cSpins;
        Print("\tcSpins                 %08lx\n", (ULONG)ReadField(cSpins));
        Print("\tCodePage               %d\n",    (ULONG)ReadField(CodePage));

    } else {
        Print("Unable to get TEB info.\n");
    }
    return TRUE;
}
#endif // !KERNEL

#ifdef KERNEL
/************************************************************************\
* Idpi
*
* Dumps ProcessInfo structs
*
* 6/9/1995 Created SanfordS
\************************************************************************/
ULONG
dpiCallback(
    PTR ppi,
    PVOID   Data)
{
    UNREFERENCED_PARAMETER(Data);

    Idpi(0, ppi);
    Print("\n");

    return FALSE;
}

BOOL Idpi(
    DWORD opts,
    ULONG64 param1)
{
    PTR pW32Process;
    PTR ppi;
    PTR pEProcess;
    PTR pdv;
    PTR ulUniqueProcessId;

    /*
     * If he just wants the current process, locate it.
     */
    if (opts & OFLAG(c)) {
        Print("Current Process:\n");
        GetCurrentProcessAddr(dwProcessor, 0, &param1);

        if (param1 == 0) {
            Print("Unable to get current process pointer.\n");
            return FALSE;
        }

        if (GetFieldValue(param1, "nt!EPROCESS", "Win32Process", pW32Process)) {
            Print("Unable to read _EPROCESS at %p\n", param1);
            return FALSE;
        }
        param1 = pW32Process;
    } else if (opts & OFLAG(p)) {
        if (GetFieldValue(param1, "nt!EPROCESS", "Win32Process", param1)) {
            Print("Can't get EPROCESS @ 0x%p\n", param1);
            return FALSE;
        }
    } else if (param1 == 0) {
        Print("**** NT ACTIVE WIN32 PROCESSINFO DUMP ****\n");
        ForEachPpi(dpiCallback, NULL);
        return TRUE;
    }

    ppi = FIXKP(param1);

    if (GetFieldValue(ppi, SYM(PROCESSINFO), "Process", pEProcess)) {
        Print("Can't get PROCESSINFO from %p.\n", ppi);
        return FALSE;
    }

    if (GetFieldValue(pEProcess, "nt!EPROCESS", "UniqueProcessId", ulUniqueProcessId)) {
        Print("Unable to read _EPROCESS at %p\n", pEProcess);
        return FALSE;
    }

    Print("---PPROCESSINFO @ 0x%p for process 0x%p (%s):\n",
            ppi,
            ulUniqueProcessId,
            ProcessName(ppi));
    _InitTypeRead(ppi, SYM(PROCESSINFO));
    Print("\tppiNext           0x%p\n", ReadField(ppiNext));
    Print("\trpwinsta          0x%p\n", ReadField(rpwinsta));
    Print("\thwinsta           0x%p\n", ReadField(hwinsta));
    Print("\tamwinsta          0x%08lx\n", (ULONG)ReadField(amwinsta));
    Print("\tptiMainThread     0x%p\n", ReadField(ptiMainThread));
    Print("\tcThreads          0x%08lx\n", (ULONG)ReadField(cThreads));
    Print("\trpdeskStartup     0x%p\n", ReadField(rpdeskStartup));
    Print("\thdeskStartup      0x%p\n", ReadField(hdeskStartup));
    Print("\tpclsPrivateList   0x%p\n", ReadField(pclsPrivateList));
    Print("\tpclsPublicList    0x%p\n", ReadField(pclsPublicList));
    Print("\tflags             %s\n",
            GetFlags(GF_W32PF, (DWORD)ReadField(W32PF_Flags), NULL, TRUE));
    Print("\tdwHotkey          0x%08lx\n", (ULONG)ReadField(dwHotkey));
    Print("\tpWowProcessInfo   0x%p\n", ReadField(pwpi));
    Print("\tluidSession       0x%08lx:0x%08lx\n", (ULONG)ReadField(luidSession.HighPart),
            (ULONG)ReadField(luidSession.LowPart));
    Print("\tdwX,dwY           (0x%x, 0x%x)\n", (ULONG)ReadField(usi.dwX), (ULONG)ReadField(usi.dwY));
    Print("\tdwXSize,dwYSize   (0x%x, 0x%x)\n", (ULONG)ReadField(usi.dwXSize), (ULONG)ReadField(usi.dwYSize));
    Print("\tdwFlags           0x%08x\n", (ULONG)ReadField(usi.dwFlags));
    Print("\twShowWindow       0x%04x\n", (ULONG)ReadField(usi.wShowWindow));
    Print("\tpCursorCache      0x%p\n", ReadField(pCursorCache));
    Print("\tdwLpkEntryPoints  %s\n",
            GetFlags(GF_LPK, (DWORD)ReadField(dwLpkEntryPoints), NULL, TRUE));

    /*
     * List desktop views
     */
    pdv = ReadField(pdvList);
    Print("Desktop views:\n");
    while (pdv != 0) {
        _InitTypeRead(pdv, SYM(DESKTOPVIEW));
        Print("\tpdesk = %p, ulClientDelta = %p\n", ReadField(pdesk), ReadField(ulClientDelta));
        pdv = ReadField(pdvNext);
    }

    return TRUE;
}
#endif // KERNEL

#ifdef KERNEL
/***************************************************************************\
* dpm - dump popupmenu
*
* dpm address    - dumps menu info for menu at address
*
* 02/13/1995 JohnC      Created.
* 06/09/1995 SanfordS   Made to fit stdexts motif.
\***************************************************************************/
BOOL Idpm(
    DWORD opts,
    PTR ppopupmenu)
{
    UNREFERENCED_PARAMETER(opts);

    ppopupmenu = FIXKP(ppopupmenu);

    Print("PPOPUPMENU @ 0x%p\n", ppopupmenu);

    BEGIN_PRTFFLG(ppopupmenu, SYM(POPUPMENU));
    PRTFFLG(fIsMenuBar);
    PRTFFLG(fHasMenuBar);
    PRTFFLG(fIsSysMenu);
    PRTFFLG(fIsTrackPopup);
    PRTFFLG(fDroppedLeft);
    PRTFFLG(fHierarchyDropped);
    PRTFFLG(fRightButton);
    PRTFFLG(fToggle);
    PRTFFLG(fSynchronous);
    PRTFFLG(fFirstClick);
    PRTFFLG(fDropNextPopup);
    PRTFFLG(fNoNotify);
    PRTFFLG(fAboutToHide);
    PRTFFLG(fShowTimer);
    PRTFFLG(fHideTimer);
    PRTFFLG(fDestroyed);
    PRTFFLG(fDelayedFree);
    PRTFFLG(fFlushDelayedFree);
    PRTFFLG(fFreed);
    PRTFFLG(fInCancel);
    PRTFFLG(fTrackMouseEvent);
    PRTFFLG(fSendUninit);
    END_PRTFFLG();

    PRTFDWP2(spwndNotify, spwndPopupMenu);
    PRTFDWP2(spwndNextPopup, spwndPrevPopup);
    PRTFDWP2(spmenu, spmenuAlternate);
    PRTFDWP2(spwndActivePopup, ppopupmenuRoot);
    PRTFDWPDW(ppmDelayedFree, posSelectedItem);
    PRTFDW1(posDropped);

    return TRUE;
}
#endif // KERNEL

#ifdef KERNEL
/***************************************************************************\
* dms - dump pMenuState
*
* dms address
*
* 05-15-96 Created GerardoB
\***************************************************************************/
BOOL Idms(
    DWORD opts,
    ULONG64 param1)
{
    UNREFERENCED_PARAMETER(opts);

    param1 = FIXKP(param1);
    Print("PMENUSTATE @ 0x%p\n", param1);

    BEGIN_PRTFFLG(FIXKP(param1), MENUSTATE);
    PRTFFLG(fMenuStarted);
    PRTFFLG(fIsSysMenu);
    PRTFFLG(fInsideMenuLoop);
    PRTFFLG(fButtonDown);
    PRTFFLG(fInEndMenu);
    PRTFFLG(fUnderline);
    PRTFFLG(fButtonAlwaysDown);
    PRTFFLG(fDragging);
    PRTFFLG(fModelessMenu);
    PRTFFLG(fInCallHandleMenuMessages);
    PRTFFLG(fDragAndDrop);
    PRTFFLG(fAutoDismiss);
    PRTFFLG(fIgnoreButtonUp);
    PRTFFLG(fMouseOffMenu);
    PRTFFLG(fInDoDragDrop);
    PRTFFLG(fActiveNoForeground);
    PRTFFLG(fNotifyByPos);
    END_PRTFFLG();

    PRTFDWP1(pGlobalPopupMenu);
    PRTFPT(ptMouseLast);
    PRTFDW2(mnFocus, cmdLast);
    PRTFDWP1(ptiMenuStateOwner);

    return TRUE;
}
#endif // KERNEL

#ifdef KERNEL
/***************************************************************************\
* dq - dump queue
*
* dq address   - dumps queue structure at address
* dq t address - dumps queue structure at address plus THREADINFO
*
* 06-20-91 ScottLu      Created.
* 11-14-91 DavidPe      Added THREADINFO option.
* 6/9/1995 SanfordS     made to fit stdexts motif
\***************************************************************************/
ULONG
dqCallback(
    PTR pti,
    PVOID   Data)
{
    PTR pq;

    GetFieldValue(pti, SYM(THREADINFO), "pq", pq);
    Idq(PtrToUlong(Data), pq);

    return FALSE;
}

BOOL Idq(
    DWORD opts,
    PTR pq)
{
    char ach[80];

    if (opts & OFLAG(a)) {
        Print("Dumping all queues:\n");

        ForEachPti(dqCallback, ULongToPtr(opts & ~OFLAG(a)));
        return TRUE;
#ifdef SOME_OTHER_DELUSION
        HANDLEENTRY he, *phe;
        int i;


        FOREACHHANDLEENTRY(phe, he, i)
            if (he.bType == TYPE_INPUTQUEUE) {
                Idq(opts & ~OFLAG(a), FIXKP(he.phead));
                Print("\n");
            }
        NEXTEACHHANDLEENTRY()
        return TRUE;
#endif
    }

    if (pq == 0) {
        Print("Dumping foreground queue:\n");
        pq = GetGlobalPointer(VAR(gpqForeground));
        if (pq == 0) {
            Print("no foreground queue (gpqForeground == NULL)!\n");
            return TRUE;
        }
    } else {
        pq = FIXKP(pq);
    }

    /*
     * Print out simple thread info for pq->ptiKeyboard
     */
    _InitTypeRead(pq, SYM(tagQ));
    if (ReadField(ptiKeyboard)) {
        Idt(OFLAG(p), ReadField(ptiKeyboard));
    }

    /*
     * Don't Print() with more than 16 arguments at once because it'll blow
     * up.
     */
    Print("PQ @ 0x%p\n", pq);
    Print(
          "\tmlInput.pqmsgRead      0x%p\n"
          "\tmlInput.pqmsgWriteLast 0x%p\n"
          "\tmlInput.cMsgs          0x%08lx\n",
          ReadField(mlInput.pqmsgRead),
          ReadField(mlInput.pqmsgWriteLast),
          (ULONG)ReadField(mlInput.cMsgs));

    Print("\tptiSysLock             0x%p\n"
          "\tidSysLock              0x%p\n"
          "\tidSysPeek              0x%p\n",
          ReadField(ptiSysLock),
          ReadField(idSysLock),
          ReadField(idSysPeek));

    Print("\tptiMouse               0x%p\n"
          "\tptiKeyboard            0x%p\n",
          ReadField(ptiMouse),
          ReadField(ptiKeyboard));

    Print("\tspcurCurrent           0x%p\n"
          "\tiCursorLevel           0x%08lx\n",
          ReadField(spcurCurrent),
          (ULONG)ReadField(iCursorLevel));

    DebugGetWindowTextA(ReadField(spwndCapture), ach, ARRAY_SIZE(ach));
    Print("\tspwndCapture           0x%p     \"%s\"\n",
          ReadField(spwndCapture), ach);
    DebugGetWindowTextA(ReadField(spwndFocus), ach, ARRAY_SIZE(ach));
    Print("\tspwndFocus             0x%p     \"%s\"\n",
          ReadField(spwndFocus), ach);
    DebugGetWindowTextA(ReadField(spwndActive), ach, ARRAY_SIZE(ach));
    Print("\tspwndActive            0x%p     \"%s\"\n",
          ReadField(spwndActive), ach);
    DebugGetWindowTextA(ReadField(spwndActivePrev), ach, ARRAY_SIZE(ach));
    Print("\tspwndActivePrev        0x%p     \"%s\"\n",
          ReadField(spwndActivePrev), ach);

    Print("\tcodeCapture            0x%04lx\n"
          "\tmsgDblClk              0x%04lx\n"
          "\ttimeDblClk             0x%08lx\n",
          (ULONG)ReadField(codeCapture),
          (ULONG)ReadField(msgDblClk),
          (ULONG)ReadField(timeDblClk));

    Print("\thwndDblClk             0x%p\n",
          ReadField(hwndDblClk));

    Print("\tptDblClk               { %d, %d }\n",
          (ULONG)ReadField(ptDblClk.x),
          (ULONG)ReadField(ptDblClk.y));

    Print("\tQF_flags               0x%08lx %s\n"
          "\tcThreads               0x%08lx\n"
          "\tcLockCount             0x%08lx\n",
          (ULONG)ReadField(QF_flags), GetFlags(GF_QF, (DWORD)ReadField(QF_flags), NULL, FALSE),
          (DWORD) ReadField(cThreads),
          (DWORD) ReadField(cLockCount));

    Print("\tmsgJournal             0x%08lx\n"
          "\tExtraInfo              0x%08lx\n",
          (ULONG)ReadField(msgJournal),
          (ULONG)ReadField(ExtraInfo));

    /*
     * Dump THREADINFO if user specified 't'.
     */
    if (opts & OFLAG(t)) {
        Idti(0, ReadField(ptiKeyboard));
    }
    return TRUE;
}
#endif // KERNEL

/***************************************************************************\
* dsi dump serverinfo struct
*
* 02-27-92 ScottLu      Created.
* 6/9/1995 SanfordS     Made to fit stdexts motif.
\***************************************************************************/
BOOL Idsi(
    DWORD opts)
{
    try {
        PTR psi;
        UINT i;
        char ach[80];
        ULONG64 ulOffset;
        PSERVERINFO pServerInfo;    // dummy for ARRAY_SIZE
        static const char* fnid[FNID_ARRAY_SIZE] = {
            "FNID_SCROLLBAR",               // xxxSBWndProc
            "FNID_ICONTITLE",               // xxxDefWindowProc
            "FNID_MENU",                    // xxxMenuWindowProc
            "FNID_DESKTOP",                 // xxxDesktopWndProc
            "FNID_DEFWINDOWPROC",           // xxxDefWindowProc
            "FNID_MESSAGEWND",              // xxxDefWindowProc
            "FNID_SWITCH",                  // xxxSwitchWndProc

            "FNID_BUTTON",                  // No server side proc
            "FNID_COMBOBOX",                // No server side proc
            "FNID_COMBOLISTBOX",            // No server side proc
            "FNID_DIALOG",                  // No server side proc
            "FNID_EDIT",                    // No server side proc
            "FNID_LISTBOX",                 // No server side proc
            "FNID_MDICLIENT",               // No server side proc
            "FNID_STATIC",                  // No server side proc
            "FNID_IME",                     // No server side proc

            "FNID_HKINLPCWPEXSTRUCT",
            "FNID_HKINLPCWPRETEXSTRUCT",
            "FNID_DEFFRAMEPROC",            // No server side proc
            "FNID_DEFMDICHILDPROC",         // No server side proc
            "FNID_MB_DLGPROC",              // No server side proc
            "FNID_MDIACTIVATEDLGPROC",      // No server side proc
            "FNID_SENDMESSAGE",

            "FNID_SENDMESSAGEFF",
            "FNID_SENDMESSAGEEX",
            "FNID_CALLWINDOWPROC",
            "FNID_SENDMESSAGEBSM",
            "FNID_TOOLTIP",                 // xxxTooltipWndProc
            "FNID_GHOST",                   // xxxGhostWndProc
            "FNID_SENDNOTIFYMESSAGE",
            "FNID_SENDMESSAGECALLBACK",
            "0x2b9",
        };

        psi = GetGlobalPointer(SYM(gpsi));
        if (psi == 0) {
            return TRUE;
        }

        Print("PSERVERINFO @ 0x%p\n", psi);

        _InitTypeRead(psi, SYM(SERVERINFO));

        Print(  "\tRIPFlags                 0x%04lx %s\n", (DWORD)ReadField(dwRIPFlags),  GetFlags(GF_RIP, (DWORD)ReadField(dwRIPFlags), NULL, FALSE));
        Print(  "\tSRVIFlags                0x%04lx %s\n", (DWORD)ReadField(wSRVIFlags), GetFlags(GF_SRVI, (DWORD)ReadField(wSRVIFlags), NULL, FALSE));
        Print(  "\tPUSIFlags                0x%08lx %s\n", (DWORD)ReadField(PUSIFlags),  GetFlags(GF_SI, (DWORD)ReadField(PUSIFlags), NULL, FALSE));

        Print(  "\tcHandleEntries           0x%08p\n"
                "\tcbHandleTable            0x%08p\n"
                "\tnEvents                  0x%08p\n",
                ReadField(cHandleEntries),
                ReadField(cbHandleTable),
                ReadField(nEvents));

        if (opts & OFLAG(p)) {
            Print("\t" "mpFnidPfn:\n");
            i = 0;
            SAFEWHILE (i < FNID_ARRAY_SIZE) {
                PTR pfn = GetArrayElementPtr(psi, SYM(SERVERINFO), i == 0 ? "mpFnidPfn" : NULL, i);

                GetSym(pfn, ach, &ulOffset);
                Print("%10c%-26s = %p %s", ' ', fnid[i], pfn, ach);
                if (ulOffset) {
                    Print("+0x%x", (DWORD)ulOffset);
                }
                Print("\n");
                ++i;
            }
        }

        if (opts & OFLAG(w)) {
            Print("\t" "aStoCidPfn:\n");
            i = 0;
            SAFEWHILE (i < ARRAY_SIZE(pServerInfo->aStoCidPfn)) {
                PTR pfn = GetArrayElementPtr(psi, SYM(SERVERINFO), i == 0 ? "aStoCidPfn" : NULL, i);

                GetSym(pfn, ach, &ulOffset);
                Print("%10c%-20s = %p %s", ' ', fnid[i], pfn, ach);
                if (ulOffset) {
                    Print("+0x%x", (DWORD)ulOffset);
                }
                Print("\n");
                ++i;
            }
        }

        if (opts & OFLAG(b)) {
            ULONG cbWnd = GetTypeSize(SYM(WND));

            Print("\t" "mpFnid_serverCBWndProc:\n");
            i = 0;
            SAFEWHILE (i < ARRAY_SIZE(pServerInfo->mpFnid_serverCBWndProc)) {
                WORD cb = (WORD)GetArrayElement(psi, SYM(SERVERINFO), i == 0 ? "mpFnid_serverCBWndProc" : NULL, i, "WORD");
                Print("%10c%-26s = %08lx", ' ', fnid[i], cb);
                if (cb) {
                    Print(" = sizeof(WND) + 0x%x", cb - cbWnd);
                }
                Print("\n");
                ++i;
            }
        }

        if (opts & OFLAG(m)) {

            /*
             * Add entries to this table in alphabetical order with
             * the prefix removed.
             */
            static const SYSMET_ENTRY aSysMet[SM_CMETRICS] = {
                SMENTRY(ARRANGE),
                SMENTRY(CXBORDER),
                SMENTRY(CYBORDER),
                SMENTRY(CYCAPTION),
                SMENTRY(CLEANBOOT),
                SMENTRY(CXCURSOR),
                SMENTRY(CYCURSOR),
                SMENTRY(DBCSENABLED),
                SMENTRY(DEBUG),
                SMENTRY(CXDLGFRAME),
                SMENTRY(CYDLGFRAME),
                SMENTRY(CXDOUBLECLK),
                SMENTRY(CYDOUBLECLK),
                SMENTRY(CXDRAG),
                SMENTRY(CYDRAG),
                SMENTRY(CXEDGE),
                SMENTRY(CYEDGE),
                SMENTRY(CXFRAME),
                SMENTRY(CYFRAME),
                SMENTRY(CXFULLSCREEN),
                SMENTRY(CYFULLSCREEN),
                SMENTRY(CXICON),
                SMENTRY(CYICON),
                SMENTRY(CXICONSPACING),
                SMENTRY(CYICONSPACING),
                SMENTRY(IMMENABLED),
                SMENTRY(CYKANJIWINDOW),
                SMENTRY(CXMAXIMIZED),
                SMENTRY(CYMAXIMIZED),
                SMENTRY(CXMAXTRACK),
                SMENTRY(CYMAXTRACK),
                SMENTRY(CYMENU),
                SMENTRY(CXMENUCHECK),
                SMENTRY(CYMENUCHECK),
                SMENTRY(MENUDROPALIGNMENT),
                SMENTRY(CXMENUSIZE),
                SMENTRY(CYMENUSIZE),
                SMENTRY(MIDEASTENABLED),
                SMENTRY(CXMIN),
                SMENTRY(CYMIN),
                SMENTRY(CXMINIMIZED),
                SMENTRY(CYMINIMIZED),
                SMENTRY(CXMINSPACING),
                SMENTRY(CYMINSPACING),
                SMENTRY(CXMINTRACK),
                SMENTRY(CYMINTRACK),
                SMENTRY(CMONITORS),
                SMENTRY(CMOUSEBUTTONS),
                SMENTRY(MOUSEPRESENT),
                SMENTRY(MOUSEWHEELPRESENT),
                SMENTRY(NETWORK),
                SMENTRY(PENWINDOWS),
                SMENTRY(RESERVED1),
                SMENTRY(RESERVED2),
                SMENTRY(RESERVED3),
                SMENTRY(RESERVED4),
                SMENTRY(SAMEDISPLAYFORMAT),
                SMENTRY(CXSCREEN),
                SMENTRY(CYSCREEN),
                SMENTRY(CXVSCROLL),
                SMENTRY(CYHSCROLL),
                SMENTRY(CYVSCROLL),
                SMENTRY(CXHSCROLL),
                SMENTRY(SECURE),
                SMENTRY(SHOWSOUNDS),
                SMENTRY(CXSIZE),
                SMENTRY(CYSIZE),
                SMENTRY(SLOWMACHINE),
                SMENTRY(CYSMCAPTION),
                SMENTRY(CXSMICON),
                SMENTRY(CYSMICON),
                SMENTRY(CXSMSIZE),
                SMENTRY(CYSMSIZE),
                SMENTRY(SWAPBUTTON),
                SMENTRY(CYVTHUMB),
                SMENTRY(CXHTHUMB),
                SMENTRY(UNUSED_64),
                SMENTRY(UNUSED_65),
                SMENTRY(UNUSED_66),
                SMENTRY(XVIRTUALSCREEN),
                SMENTRY(YVIRTUALSCREEN),
                SMENTRY(CXVIRTUALSCREEN),
                SMENTRY(CYVIRTUALSCREEN),
                // Windows 2000
                SMENTRY(CMONITORS),
                SMENTRY(SAMEDISPLAYFORMAT),
                // Whistler
                SMENTRY(SHUTTINGDOWN),
            };

            Print("\taiSysMet:\n");
            i = 0;
            SAFEWHILE (i < SM_CMETRICS) {
                DWORD v = (DWORD)GetArrayElement(psi, SYM(SERVERINFO), i == 0 ? "aiSysMet" : NULL, aSysMet[i].iMetric, "DWORD");
                Print(  "\t\tSM_%-18s = 0x%08lx = %d\n", aSysMet[i].pstrMetric, v, v);
                ++i;
            }
        }
        if (opts & OFLAG(c)) {
            static LPSTR aszSysColor[COLOR_MAX] = {
              //012345678901234567890
                "SCROLLBAR",
                "BACKGROUND",
                "ACTIVECAPTION",
                "INACTIVECAPTION",
                "MENU",
                "WINDOW",
                "WINDOWFRAME",
                "MENUTEXT",
                "WINDOWTEXT",
                "CAPTIONTEXT",
                "ACTIVEBORDER",
                "INACTIVEBORDER",
                "APPWORKSPACE",
                "HIGHLIGHT",
                "HIGHLIGHTTEXT",
                "BTNFACE",
                "BTNSHADOW",
                "GRAYTEXT",
                "BTNTEXT",
                "INACTIVECAPTIONTEXT",
                "BTNHIGHLIGHT",
                "3DDKSHADOW",
                "3DLIGHT",
                "INFOTEXT",
                "INFOBK",
                "3DALTFACE",
                "HOTLIGHT",
                // new in Windows 2000
                "GRADIENTACTIVECAPTION",
                "GRADIENTINACTIVECAPTION",
                "MENUHILIGHT",
                "MENUBAR",
            };
            COLORREF colors[COLOR_MAX];
            COLORREF colorsUnmatched[COLOR_MAX];

            for (i = 0; i < COLOR_MAX; ++i) {
                colors[i] = (COLORREF)GetArrayElement(psi, SYM(SERVERINFO), i == 0 ? "argbSystem" : NULL, i, SYM(COLORREF));
            }

            for (i = 0; i < COLOR_MAX; ++i) {
                colorsUnmatched[i] = (COLORREF)GetArrayElement(psi, SYM(SERVERINFO), i == 0 ? "argbSystemUnmatched" : NULL, i, SYM(COLORREF));
            }

            Print("\targbSystem:\n\t\tCOLOR%28sSYSRGB\t\tUnmatched\tSYSHBR\n", "");
            i = 0;
            SAFEWHILE (i < COLOR_MAX) {
                Print("\t\tCOLOR_%-25s: (%02x,%02x,%02x)\t(%02x,%02x,%02x)\t0x%08p\n",
                      aszSysColor[i],
                      GetRValue(colors[i]), GetGValue(colors[i]), GetBValue(colors[i]),
                      GetRValue(colorsUnmatched[i]), GetGValue(colorsUnmatched[i]), GetBValue(colorsUnmatched[i]),
                      (KHBRUSH)GetArrayElement(psi, SYM(SERVERINFO), i == 0 ? "ahbrSystem" : NULL, i, SYM(KHBRUSH)));
                ++i;
            }
        }

        if (opts & OFLAG(o)) {
    #if 0   // LATER
            OEMBITMAPINFO oembmi[OBI_COUNT];

            for (i = 0; i < OBI_COUNT; ++i) {

            }

            Print("\toembmi @ 0x%p:\n\t\tx       \ty       \tcx       \tcy\n", &psi->oembmi);
            for (i = 0; i < OBI_COUNT; i++) {
                Print("\tbm[%d]:\t%08x\t%08x\t%08x\t%08x\n",
                        i,
                        si.oembmi[i].x ,
                        si.oembmi[i].y ,
                        si.oembmi[i].cx,
                        si.oembmi[i].cy);
            }
    #else
            Print("\tOEMINFO:\n");
    #endif
            _InitTypeRead(psi, SYM(SERVERINFO));

            Print(
                    "\t\tPlanes             = %d\n"
                    "\t\tBitsPixel          = %d\n"
                    "\t\tBitCount           = %d\n"
                    "\t\tdmLogPixels        = %d\n"
                    "\t\trcScreen           = (%d,%d)-(%d,%d) %dx%d\n"
                    ,
                    (BYTE)ReadField(Planes)           ,
                    (BYTE)ReadField(BitsPixel)        ,
                    (WORD)ReadField(BitCount)         ,
                    (UINT)ReadField(dmLogPixels),
                    (LONG)ReadField(rcScreen.left), (LONG)ReadField(rcScreen.top),
                        (LONG)ReadField(rcScreen.right), (LONG)ReadField(rcScreen.bottom),
                    (LONG)ReadField(rcScreen.right)-(LONG)ReadField(si.rcScreen.left),
                        (LONG)ReadField(rcScreen.bottom)-(LONG)ReadField(si.rcScreen.top));

        }

        if (opts & OFLAG(v)) {
            ULONG ulOffsetTmp; // req

            GetFieldOffset(SYM(SERVERINFO), "tmSysFont", &ulOffsetTmp);
            Print(
                    "\tptCursor                 {%d, %d}\n"
                    "\tgclBorder                0x%08lx\n"
                    "\tdtScroll                 0x%08lx\n"
                    "\tdtLBSearch               0x%08lx\n"
                    "\tdtCaretBlink             0x%08lx\n"
                    "\tdwDefaultHeapBase        0x%08lx\n"
                    "\tdwDefaultHeapSize        0x%08lx\n"
                    "\twMaxLeftOverlapChars     0x%08lx\n"
                    "\twMaxRightOverlapchars    0x%08lx\n"
                    "\tuiShellMsg               0x%08lx\n"
                    "\tcxSysFontChar            0x%08lx\n"
                    "\tcySysFontChar            0x%08lx\n"
                    "\tcxMsgFontChar            0x%08lx\n"
                    "\tcyMsgFontChar            0x%08lx\n"
                    "\ttmSysFont                0x%p\n"
                    "\tatomIconSmProp           0x%04lx\n"
                    "\tatomIconProp             0x%04lx\n"
                    "\thIconSmWindows           0x%08lp\n"
                    "\thIcoWindows              0x%08lp\n"
                    "\thCaptionFont             0x%08lp\n"
                    "\thMsgFont                 0x%08lp\n"
                    "\tatomContextHelpIdProp    0x%08lx\n",
                    (LONG)ReadField(ptCursor.x),
                    (LONG)ReadField(ptCursor.y),
                    (int)ReadField(gclBorder),
                    (UINT)ReadField(dtScroll),
                    (UINT)ReadField(dtLBSearch),
                    (UINT)ReadField(dtCaretBlink),
                    (DWORD)ReadField(dwDefaultHeapBase),
                    (DWORD)ReadField(dwDefaultHeapSize),
                    (int)ReadField(wMaxLeftOverlapChars),
                    (int)ReadField(wMaxRightOverlapChars),
                    (UINT)ReadField(uiShellMsg),
                    (int)ReadField(cxSysFontChar),
                    (int)ReadField(cySysFontChar),
                    (int)ReadField(cxMsgFontChar),
                    (int)ReadField(cyMsgFontChar),
                    psi + ulOffsetTmp,
                    (ATOM)ReadField(atomIconSmProp),
                    (ATOM)ReadField(atomIconProp),
                    ReadField(hIconSmWindows),
                    ReadField(hIcoWindows),
                    ReadField(hCaptionFont),
                    ReadField(hMsgFont),
                    (ATOM)ReadField(atomContextHelpIdProp));
        }

        if (opts & OFLAG(h)) {
            PTR pshi = 0;

            pshi = EvalExp(VAR(gSharedInfo));
            if (pshi == 0) {
                return TRUE;
            }
            _InitTypeRead(pshi, SYM(SHAREDINFO));
            Print("\nSHAREDINFO @ 0x%p:\n", pshi);
            Print("\taheList                  0x%p\n", ReadField(aheList));
        }
    } except (CONTINUE) {
    }

    return TRUE;
}

#ifdef KERNEL
/***************************************************************************\
* dsms - dump send message structures
*
* dsms           - dumps all send message structures
* dsms v         - dumps all verbose
* dsms address   - dumps specific sms
* dsms v address - dumps verbose
* dsms l [address] - dumps sendlist of sms
*
*
* 06-20-91 ScottLu      Created.
* 6/9/1995 SanfordS     made to fit stdexts motif
\***************************************************************************/
BOOL Idsms(
    DWORD opts,
    ULONG64 param1)
{
    ULONG64 psms;
    ULONG offsetPsmsNext;
    ULONG offsetSender;
    ULONG offsetReceiver;
    UINT c = 0;
    UINT cm = 0;

    GetFieldOffset(SYM(tagSMS), "psmsNext", &offsetPsmsNext);
    GetFieldOffset(SYM(tagSMS), "ptiSender", &offsetSender);
    GetFieldOffset(SYM(tagSMS), "ptiReceiver", &offsetReceiver);

    if ((opts & (OFLAG(m) | OFLAG(s) | OFLAG(r))) || (param1 == 0)) {
        psms = GetGlobalPointer(VAR(gpsmsList));

        if (psms == NULL_PTR) {
            Print("No send messages currently in the list.\n");
            return TRUE;
        }

        if (opts & OFLAG(c)) {
            UINT i = 0;

            // just count the messages
            SAFEWHILE (psms != 0) {
                UINT cPrev = c;

                if ((i++ & 0xf) == 0) {
                    ShowProgress();
                }
                if (opts & OFLAG(s)) {
                    if (GetPointer(psms + offsetSender) == param1) {
                        ++c;
                    }
                } else if (opts & OFLAG(r)) {
                    if (GetPointer(psms + offsetReceiver) == param1) {
                        ++c;
                    }
                } else {
                    ++c;
                }

                if (c != cPrev && (c % 400) == 0) {
                    Print("%d (0x%lx)...\n", c, c);
                }
                psms = GetPointer(psms + offsetPsmsNext);
            }
        } else if (opts & OFLAG(m)) {
            // show messages with msg == param1
            SAFEWHILE (psms != NULL_PTR) {
                UINT uMsg;

                c++;
                //move(sms, psms);
                GetFieldValue(psms, SYM(tagSMS), "UINT", uMsg);
                if (uMsg == (UINT)param1) {
                    cm++;
                    Idsms(opts & ~OFLAG(m), psms);
                }
                psms = GetPointer(psms + offsetPsmsNext);
            }
            Print("%d messages == 0x%x (out of a total of %d).\n", cm, (UINT)param1, c);
            return TRUE;
        } else {
            SAFEWHILE (psms != NULL_PTR) {
                if (param1 == NULL_PTR ||
                        ((opts & OFLAG(s)) && GetPointer(psms + offsetSender) == param1) ||
                        ((opts & OFLAG(r)) && GetPointer(psms + offsetReceiver) == param1)) {
                    c++;
                    DEBUGPRINT("calling Idsms(opts=%x, psms=%p)\n", opts, psms);
                    if (!Idsms(opts & ~(OFLAG(s) | OFLAG(r)), psms)) {
                        DEBUGPRINT("error!\n");
                        Print("%d (0x%lx) messages.\n", c, c);
                        return FALSE;
                    }
                }
                psms = GetPointer(psms + offsetPsmsNext);
            }
        }
        Print("%d (0x%lx) messages.\n", c, c);
        return TRUE;
    }

    psms = param1;

    Print("PSMS @ 0x%p\n", psms);
    _InitTypeRead(psms, SYM(tagSMS));

    Print("SEND: ");
    if (ReadField(ptiSender) != NULL_PTR) {
        Idt(OFLAG(p), ReadField(ptiSender));
    } else if (ReadField(ptiCallBackSender) != NULL_PTR) {
        Print("*");
        Idt(OFLAG(p), ReadField(ptiCallBackSender));
    } else {
        Print("NULL\n");
    }

    Print("RECV:");
    if (ReadField(ptiReceiver) != NULL_PTR) {
        Print(" ");
        Idt(OFLAG(p), ReadField(ptiReceiver));
    } else {
        Print("NULL\n");
    }

    if (opts & OFLAG(v)) {
        char ach[80];
        UINT message = (UINT)ReadField(message);

        Print("\tpsmsNext           0x%08p\n", ReadField(psmsNext));
        if (IsChk()) {
              Print("\tpsmsSendList       0x%p\n"
                    "\tpsmsSendNext       0x%p\n",
                    ReadField(psmsSendList),
                    ReadField(psmsSendNext));
        }

        Print("\tpsmsReceiveNext    0x%08p\n"
              "\ttSent              0x%08lx\n"
              "\tptiSender          0x%08p\n"
              "\tptiCallBackSender  0x%08p\n"
              "\tptiReceiver        0x%08p\n"
              "\tlRet               0x%08p\n"
              "\tflags              %s\n"
              "\twParam             0x%08p\n"
              "\tlParam             0x%08p\n"
              "\tmessage            0x%08lx %s\n",
              ReadField(psmsReceiveNext),
              (DWORD)ReadField(tSent),
              ReadField(ptiSender),
              ReadField(ptiCallBackSender),
              ReadField(ptiReceiver),
              ReadField(lRet),
              GetFlags(GF_SMS, (WORD)ReadField(flags), NULL, TRUE),
              ReadField(wParam),
              ReadField(lParam),
              message, GetWindowMessageNameInternal(message));
        DebugGetWindowTextA(ReadField(spwnd), ach, ARRAY_SIZE(ach));
        Print("\tspwnd              0x%08p     \"%s\"\n", ReadField(spwnd), ach);
    } else if (opts & OFLAG(w)) {
        // a bit of verbose
        char ach[80];

        DebugGetWindowTextA(ReadField(spwnd), ach, ARRAY_SIZE(ach));

        Print("  MSG: %08lx %08p %08p / lRet: %08p / tSend: %08lx\n",
              (DWORD)ReadField(message), ReadField(wParam), ReadField(lParam),
              ReadField(lRet), (DWORD)ReadField(tSent));
        Print("  pwnd: %p \"%s\"\n", ReadField(spwnd), ach);
    }

#ifdef LATER
    if (IsChk()) {
        if (opts & OFLAG(l)) {
            DWORD idThread;
            PTR psmsList;   // PSMS
            DWORD idThreadSender, idThreadReceiver;
            CLIENT_ID Cid;

            psmsList = ReadField(psmsSendList);
            if (psmsList == NULL_PTR) {
                Print("%p : Empty List\n", psms);
            } else {
                Print("%p : [tidSender](msg)[tidReceiver]\n", psms);
            }
            SAFEWHILE (psmsList != NULL_PTR) {
                PTR ptiSender;
                //move(sms, psmsList);
                GetFieldValue(psmsList, SYM(tagSMS), ptiSender, ptiSender);
                if (ptiSender == NULL_PTR) {
                    idThread = 0;
                } else {
                    PTR pEThread;

                    GetFieldValue(ptiSender, SYM(THREADINFO), "pEThread", pETHread);

                    // up to here
                    GetEThreadData(ti.pEThread, EThreadCid, &Cid);
                    idThreadSender = PtrToUlong(Cid.UniqueThread);
                }
                if (sms.ptiReceiver == NULL_PTR) {
                    idThread = 0;
                } else {
                    move(ti, sms.ptiReceiver);
                    GetEThreadData(ti.pEThread, EThreadCid, &Cid);
                    idThreadReceiver = PtrToUlong(Cid.UniqueThread);
                }
                Print("%p : [%x](%x)[%x]\n", psmsList, idThreadSender, sms.message,
                        idThreadReceiver);

                if (psmsList == sms.psmsSendNext) {
                    Print("Loop in list?\n");
                    return FALSE;
                }

                psmsList = sms.psmsSendNext;
            }
            Print("\n");
        }
    }
#endif
    return TRUE;
}
#endif // KERNEL


#ifdef KERNEL
/***************************************************************************\
* dt - dump thread
*
* dt            - dumps simple thread info of all threads which have queues
*                 on server
* dt v          - dumps verbose thread info of all threads which have queues
*                 on server
* dt id         - dumps simple thread info of single server thread id
* dt v id       - dumps verbose thread info of single server thread id
*
* 06-20-91 ScottLu      Created.
* 6/9/1995 SanfordS     made to fit stdexts motif
\***************************************************************************/
BOOL DumpThread(
    DWORD opts,
    PTR pEThread)
{
    WCHAR ach[256];
    PTR pq;
    PTR ppi;
    PTR pEThreadT;
    PTR pti = NULL_PTR;
    PTR pcti;
    CLIENTTHREADINFO cti;
    PTR psms;
    ULONG64 ProcessId;
    PTR pEProcess;
    ULONG64 ThreadId;

    GetFieldValue(pEThread, "nt!ETHREAD", "Tcb.Win32Thread", pti);
    GetFieldValue(pEThread, "nt!ETHREAD", "Cid.UniqueProcess", ProcessId);
    GetFieldValue(pEThread, "nt!ETHREAD", "Cid.UniqueThread", ThreadId);
    GetFieldValue(pEThread, "nt!ETHREAD", "ThreadsProcess", pEProcess);
    if (GetFieldValue(pti, "win32k!W32THREAD", "pEThread", pEThreadT)) {
        if (!(opts & OFLAG(g))) {
            Print("  s %-2d et 0x%p t 0x???????? q 0x???????? i %2x.%-3lx <unknown name>\n",
                  GetProcessSessionId(pEProcess),
                  pEThread,
                  (ULONG)ProcessId,
                  (ULONG)ThreadId);
        }
        return TRUE;
    }

    if (pEThreadT != pEThread || pti == 0) {
        return FALSE;
    } else { // Good thread

        /*
         * Print out simple thread info if this is in simple mode. Print
         * out queue info if in verbose mode (printing out queue info
         * also prints out simple thread info).
         */
        if (!(opts & OFLAG(v))) {
            PWCHAR pwch;

            GetAppName(pEThread, pti, ach, sizeof(ach));
            pwch = wcsrchr(ach, L'\\');
            if (pwch == NULL_PTR) {
                pwch = ach;
            } else {
                pwch++;
            }

            GetFieldValue(pti, SYM(THREADINFO), "pq", pq);
            GetFieldValue(pti, SYM(THREADINFO), "ppi", ppi);
            Print("  s %-2d et 0x%p t 0x%p q 0x%p ppi 0x%p i %2x.%-3lx %ws\n",
                    GetProcessSessionId(pEProcess),
                    pEThread,
                    pti,
                    pq,
                    ppi,
                    (ULONG)ProcessId,
                    (ULONG)ThreadId,
                    pwch);

            /*
             * Dump thread input state if required
             */
            if (opts & OFLAG(s)) {
                #define DT_INDENT "\t"
                GetFieldValue(pti, SYM(THREADINFO), "pcti", pcti);
                move(cti, pcti);

                if (cti.fsWakeMask == 0) {
                    Print(DT_INDENT "Not waiting for USER input events.\n");
                } else if ((cti.fsWakeMask & (QS_ALLINPUT | QS_EVENT)) == (QS_ALLINPUT | QS_EVENT)) {
                    Print(DT_INDENT "Waiting for any USER input event (== in GetMessage).\n");
                } else if ((cti.fsWakeMask == (QS_SMSREPLY | QS_SENDMESSAGE))
                            || (cti.fsWakeMask == QS_SMSREPLY)) {
                    GetFieldValue(pti, SYM(THREADINFO), "psmsSent", psms);
                    _InitTypeRead(psms, SYM(SMS));
                    Print(DT_INDENT "Waiting on thread 0x%p to reply to this SendMessage:\n", ReadField(ptiReceiver));
                    Print(DT_INDENT "pwnd:0x%p message:%#lx wParam:0x%p lParam:0x%p\n",
                            ReadField(pwnd), (UINT)ReadField(message), ReadField(wParam), ReadField(lParam));
                    if (cti.fsChangeBits & QS_SMSREPLY) {
                        Print(DT_INDENT "The receiver thread has replied to the message.\n");
                    }
                } else {
                    Print(DT_INDENT "Waiting for: %s\n",
                                      GetFlags(GF_QS, (WORD)cti.fsWakeMask, NULL, TRUE));
                }
            }

        } else {
            Idti(0, pti);
            Print("--------\n");
        }
    }
    return TRUE;
}

typedef struct _THREAD_DUMP_CONTEXT {
    DWORD opts;
    ULONG64 ThreadToDump;
} THREAD_DUMP_CONTEXT;

ULONG
DumpThreadsCallback (
    PFIELD_INFO   NextThread,
    PVOID         Context)
{
    PTR pEThread = NextThread->address;
    ULONG64 ThreadId;
    THREAD_DUMP_CONTEXT *pTDC = (THREAD_DUMP_CONTEXT *)Context;

    PTR UserProbeAddress;
    ULONG Result;

    //
    // Read the user probe address from the target system.
    //
    // N.B. The user probe address is constant on MIPS, Alpha, and the PPC.
    //      On the x86, it may not be defined for the target system if it
    //      does not contain the code to support 3gb of user address space.
    //

    UserProbeAddress = GetExpression("nt!MmUserProbeAddress");
    if ((UserProbeAddress == 0) ||
        (ReadMemory(UserProbeAddress,
                    &UserProbeAddress,
                    sizeof(UserProbeAddress),
                    &Result) == FALSE)) {
        UserProbeAddress = 0x7fff0000;
    }

    /*
     * ThreadToDump is either 0 (all windows threads) or its
     * a TID ( < UserProbeAddress or its a pEThread.
     */
    GetFieldValue(pEThread, "nt!ETHREAD", "Cid.UniqueThread", ThreadId);
    if (pTDC->ThreadToDump == 0 ||

            (pTDC->ThreadToDump < UserProbeAddress &&
                pTDC->ThreadToDump == ThreadId) ||

            (pTDC->ThreadToDump >= UserProbeAddress &&
                pTDC->ThreadToDump == pEThread)) {

        if (!DumpThread(pTDC->opts, pEThread) && pTDC->ThreadToDump != 0) {
            Print("Sorry, EThread %p is not a Win32 thread.\n",
                    pEThread);
        }

        if (pTDC->ThreadToDump != 0) {
            return TRUE;
        }


    } // Chosen Thread

   return FALSE;
}

VOID DumpProcessThreads(
    DWORD opts,
    PTR pEProcess,
    ULONG64 ThreadToDump)
{
    PTR pW32Process;
    ULONG64 NextThread;
    THREAD_DUMP_CONTEXT TDC = {
        opts,
        ThreadToDump
    };

    /*
     * Dump threads of Win32 Processes only
     */
    if ((GetFieldValue(pEProcess, "nt!EPROCESS", "Win32Process", pW32Process))
            || (pW32Process == 0)) {
        return;
    }

    GetFieldValue(pEProcess, "nt!EPROCESS", "Pcb.ThreadListHead.Flink", NextThread);

    ListType("nt!ETHREAD", NextThread, 1, "Tcb.ThreadListEntry.Flink", &TDC, DumpThreadsCallback);
}

ULONG
DumpProcessThreadsCallback (
    PFIELD_INFO   NextProcess,
    PVOID         Context)
{
    THREAD_DUMP_CONTEXT *pTDC = (THREAD_DUMP_CONTEXT *)Context;

    DumpProcessThreads(pTDC->opts, NextProcess->address, pTDC->ThreadToDump);

    return FALSE;
}

BOOL Idt(
    DWORD opts,
    ULONG64 param1)
{
    ULONG64 ThreadToDump;
    ULONG64 NextProcess;
    ULONG64 ProcessHead;
    PTR pEThread;
    PTR pti;
    THREAD_DUMP_CONTEXT TDC;

    ThreadToDump = param1;

    /*
     * If its a pti, validate it, and turn it into and idThread.
     */
    if (opts & OFLAG(p)) {
        if (!param1) {
            Print("Expected a pti parameter.\n");
            return FALSE;
        }

        pti = FIXKP(param1);

        if (pti == 0) {
            Print("WARNING: bad pti given!\n");
            pti = param1;
        } else {
            GetFieldValue(pti, SYM(tagTHREADINFO), "pEThread", pEThread);
            if (!DumpThread(opts, pEThread)) {
                /*
                 * This thread either doesn't have a pti or something
                 * is whacked out.  Just skip it if we want all
                 * threads.
                 */
                Print("Sorry, EThread %p is not a Win32 thread.\n",
                        pEThread);
                return FALSE;
            }
            return TRUE;
        }
    }

    /*
     * If he just wants the current thread, located it.
     */
    if (opts & OFLAG(c)) {
        Print("Current Thread:");
        GetCurrentThreadAddr(dwProcessor, &ThreadToDump);

        if (ThreadToDump == 0) {
            Print("Unable to get current thread pointer.\n");
            return FALSE;
        }
        pEThread = ThreadToDump;
        if (!DumpThread(opts, pEThread)) {
            /*
             * This thread either doesn't have a pti or something
             * is whacked out. Just skip it if we want all
             * threads.
             */
            Print("Sorry, EThread %p is not a Win32 thread.\n",
                    pEThread);
            return FALSE;
        }
        return TRUE;
    } else if (ThreadToDump == 0) {
        Print("**** NT ACTIVE WIN32 THREADINFO DUMP ****\n");
    }

    ProcessHead = EvalExp("PsActiveProcessHead");
    if (!ProcessHead) {
        Print("Unable to get value of PsActiveProcessHead\n");
        return FALSE;
    }

    if (GetFieldValue(ProcessHead, "nt!LIST_ENTRY", "Flink", NextProcess)) {
        Print("Unable to get value of PsActiveProcessHead\n");
        return FALSE;
    }
    if (NextProcess == 0) {
        Print("PsActiveProcessHead->Flink is NULL!\n");
        return FALSE;
    }

    TDC.opts = opts;
    TDC.ThreadToDump = ThreadToDump;
    ListType("nt!EPROCESS", NextProcess, 1, "ActiveProcessLinks.Flink", &TDC, DumpProcessThreadsCallback);

    if (opts & OFLAG(c)) {
        Print("%p is not a windows thread.\n", ThreadToDump);
    }

    return TRUE;
}
#endif // KERNEL

#ifdef KERNEL
/***************************************************************************\
* dp - dump process
*
*
* 06-27-97 GerardoB     Created.
\***************************************************************************/


BOOL DumpProcess(
    DWORD opts,
    PTR pEProcess)
{
    WCHAR ach[256];
    ULONG W32PF_Flags;
    PTR ppi;
    ULONG ulSessionId;
    ULONG64 ulUniqueProcessId;
    PTR pEProcessT;

    GetFieldValue(pEProcess, "nt!EPROCESS", "Win32Process", ppi);
    GetFieldValue(pEProcess, "nt!EPROCESS", "UniqueProcessId", ulUniqueProcessId);
    _GetProcessSessionId(pEProcess, &ulSessionId);

    if (GetFieldValue(ppi, "win32k!W32PROCESS", "Process", pEProcessT)) {
        Print("sid %2d ep 0x%p p 0x???????? f 0x???????? i %3I64x <unknown name>\n",
                ulSessionId,
                pEProcess,
                ulUniqueProcessId);
        return TRUE;
    }

    if (pEProcessT != pEProcess || ppi == 0) {
        return FALSE;
    } else { // Good process
        /*
         * Print out simple process info if this is in simple mode.
         */
        if (!(opts & OFLAG(v))) {
            PWCHAR pwch;

            GetProcessName(pEProcess, ach);
            pwch = wcsrchr(ach, L'\\');
            if (pwch == NULL) {
                pwch = ach;
            } else {
                pwch++;
            }

            GetFieldValue(ppi, "win32k!W32PROCESS", "W32PF_Flags", W32PF_Flags);
            Print("sid %2d ep 0x%p p 0x%p f 0x%08lx i %3I64x %ws\n",
                    ulSessionId,
                    pEProcess,
                    ppi,
                    W32PF_Flags,
                    ulUniqueProcessId,
                    pwch);
        } else {
            Idpi(0, ppi);
            Print("--------\n");
        }

        /*
         * Dump all threads if required
         */
        if (opts & OFLAG(t)) {
            DumpProcessThreads(opts, pEProcess, 0);
        }
    }
    return TRUE;
}

typedef struct _PROCESS_DUMP_CONTEXT {
    DWORD opts;
    ULONG64 ProcessToDump;
} PROCESS_DUMP_CONTEXT;

ULONG
DumpProcessCallback(
    PFIELD_INFO   NextProcess,
    PVOID         Context)
{
    ULONG64 pEProcess = NextProcess->address;
    ULONG64 pW32Process;
    ULONG64 ulUniqueProcessId;
    PROCESS_DUMP_CONTEXT *pPDC = (PROCESS_DUMP_CONTEXT *)Context;

    ULONG64 UserProbeAddress;
    ULONG Result;

    //
    // Read the user probe address from the target system.
    //
    // N.B. The user probe address is constant on MIPS, Alpha, and the PPC.
    //      On the x86, it may not be defined for the target system if it
    //      does not contain the code to support 3gb of user address space.
    //

    UserProbeAddress = GetExpression("nt!MmUserProbeAddress");
    if ((UserProbeAddress == 0) ||
        (ReadMemory(UserProbeAddress,
                    &UserProbeAddress,
                    sizeof(UserProbeAddress),
                    &Result) == FALSE)) {
        UserProbeAddress = 0x7fff0000;
    }

    /*
     * Dump threads of Win32 Processes only
     */
    if (GetFieldValue(pEProcess, "nt!EPROCESS", "Win32Process", pW32Process) || pW32Process == 0) {
        return FALSE;
    }

    GetFieldValue(pEProcess, "nt!EPROCESS", "UniqueProcessId", ulUniqueProcessId);
    /*
     * ProcessToDump is either 0 (all windows processes) or its
     * a TID ( < UserProbeAddress or its a pEPRocess.
     */
    if (pPDC->ProcessToDump == 0 ||

            (pPDC->ProcessToDump < UserProbeAddress &&
                pPDC->ProcessToDump == ulUniqueProcessId) ||

            (pPDC->ProcessToDump >= UserProbeAddress &&
                pPDC->ProcessToDump == pEProcess)) {

        if (!DumpProcess(pPDC->opts, pEProcess) && (pPDC->ProcessToDump != 0)) {
            Print("Sorry, EProcess %p is not a Win32 process.\n",
                    pEProcess);
        }

        if (pPDC->ProcessToDump != 0) {
            return TRUE;
        }
    }

    return FALSE;
}

BOOL Idp(
    DWORD opts,
    ULONG64 param1)
{
    ULONG64 ProcessToDump;
    PTR ppi;
    PTR pEProcess;
    ULONG64 NextProcess;
    ULONG64 ProcessHead;
    PROCESS_DUMP_CONTEXT PDC;

    ProcessToDump = param1;

    /*
     * If it's a ppi, validate it.
     */
    if (opts & OFLAG(p)) {
        if (!param1) {
            Print("Expected a ppi parameter.\n");
            return FALSE;
        }

        ppi = FIXKP(param1);

        if (ppi == 0) {
            Print("WARNING: bad ppi given!\n");
            ppi = param1;
        } else {
            GetFieldValue(ppi, "win32k!W32PROCESS", "Process", pEProcess);
            if (!DumpProcess(opts, pEProcess)) {
                Print("EProcess %p is not a Win32 process.\n", pEProcess);
                return FALSE;
            }
            return TRUE;
        }
    }

    /*
     * If he just wants the current process, locate it.
     */
    if (opts & OFLAG(c)) {
        Print("Current Process: ");
        GetCurrentProcessAddr(dwProcessor, 0, &ProcessToDump);

        if (ProcessToDump == 0) {
            Print("Unable to get current process pointer.\n");
            return FALSE;
        }
        pEProcess = ProcessToDump;
        if (!DumpProcess(opts, pEProcess)) {
            Print("Sorry, EProcess %p is not a Win32 process.\n", pEProcess);
            return FALSE;
        }
        return TRUE;
    /*
     * else he must want all window threads.
     */
    } else if (ProcessToDump == 0) {
        Print("**** NT ACTIVE WIN32 PROCESSINFO DUMP ****\n");
    }

    ProcessHead = EvalExp("PsActiveProcessHead");
    if (!ProcessHead) {
        Print("Unable to get value of PsActiveProcessHead\n");
        return FALSE;
    }

    if (GetFieldValue(ProcessHead, "nt!LIST_ENTRY", "Flink", NextProcess)) {
        Print("Unable to get value of PsActiveProcessHead\n");
        return FALSE;
    }
    if (NextProcess == 0) {
        Print("PsActiveProcessHead->Flink is NULL!\n");
        return FALSE;
    }

    PDC.opts = opts;
    PDC.ProcessToDump = ProcessToDump;
    ListType("nt!EPROCESS", NextProcess, 1, "ActiveProcessLinks.Flink", &PDC, DumpProcessCallback);

    if (opts & OFLAG(c)) {
        Print("%p is not a windows process.\n", ProcessToDump);
    }

    return TRUE;
}
#endif // KERNEL



#ifdef KERNEL
/***************************************************************************\
* dtdb - dump TDB
*
* dtdb address - dumps TDB structure at address
*
* 14-Sep-1993 DaveHart  Created.
* 6/9/1995 SanfordS     made to fit stdexts motif
\***************************************************************************/
ULONG
dtdbCallback(
    PTR pti,
    PVOID   Data)
{
    PTR ptdb;

    UNREFERENCED_PARAMETER(Data);

    GetFieldValue(pti, SYM(THREADINFO), "ptdb", ptdb);
    SAFEWHILE (ptdb) {
        Idtdb(0, ptdb);
        GetFieldValue(ptdb, SYM(TDB), "ptdbNext", ptdb);
    }

    return FALSE;
}

BOOL Idtdb(
    DWORD opts,
    ULONG64 param1)
{

    PTR ptdb;

    UNREFERENCED_PARAMETER(opts);

    if (param1 == 0) {
        Print("Dumping all ptdbs:\n");
        ForEachPti(dtdbCallback, NULL);
        return TRUE;
    }

    ptdb = param1;

    if (ptdb == 0) {
        Print("Must supply a TDB address.\n");
        return FALSE;
    }

    _InitTypeRead(ptdb, SYM(TDB));

    Print("TDB (non preemptive scheduler task database) @ 0x%p\n", ptdb);
    Print("\tptdbNext          0x%p\n", ReadField(ptdbNext));
    Print("\tnEvents           0x%08lx\n", (ULONG)ReadField(nEvents));
    Print("\tnPriority         0x%08lx\n", (ULONG)ReadField(nPriority));
    Print("\tpti               0x%p\n", ReadField(pti));

    return TRUE;
}
#endif // KERNEL

#ifndef KERNEL
/************************************************************************\
* Icbp
*
* Breaks into the debugger in context of csrss.exe.
*
* fSuccess
*
* 6/1/98 JerrySh
\************************************************************************/
BOOL Icbp(
    VOID)
{
    DWORD dwProcessId;
    DWORD dwThreadId;
    BOOL fServerProcess;
    USER_API_MSG m;
    PACTIVATEDEBUGGERMSG a = &m.u.ActivateDebugger;

    moveExpValue(&fServerProcess, VAR(gfServerProcess));

    if (fServerProcess) {
        Print("Already debugging server process!\n");
    } else {
        /*
         * Get the process and thread ID of a CSRSS thread.
         */
        dwThreadId = GetWindowThreadProcessId(GetDesktopWindow(), &dwProcessId);
        a->ClientId.UniqueProcess = LongToHandle(dwProcessId);
        a->ClientId.UniqueThread = LongToHandle(dwThreadId);

        /*
         * Tell CSRSS to break on itself.
         */
        CsrClientCallServer((PCSR_API_MSG)&m,
                             NULL,
                             CSR_MAKE_API_NUMBER(USERSRV_SERVERDLL_INDEX, UserpActivateDebugger),
                             sizeof(*a));
    }

    return TRUE;
}

#endif // !KERNEL

#ifdef KERNEL
/***************************************************************************\
* dkl - dump keyboard layout
*
* dkl address      - dumps keyboard layout structure at address
*
* 05/21/95 GregoryW        Created.
\***************************************************************************/
const char* GetCharSetText(
    const BYTE bCharSet)
{
    static struct _tagBASECHARSET {
        const char* pstrCS;
        DWORD dwValue;
    } const CrackCS[] = {
        {"ANSI_CHARSET"            ,0   },
        {"DEFAULT_CHARSET"         ,1   },
        {"SYMBOL_CHARSET"          ,2   },
        {"SHIFTJIS_CHARSET"        ,128 },
        {"HANGEUL_CHARSET"         ,129 },
        {"GB2312_CHARSET"          ,134 },
        {"CHINESEBIG5_CHARSET"     ,136 },
        {"OEM_CHARSET"             ,255 },
        {"JOHAB_CHARSET"           ,130 },
        {"HEBREW_CHARSET"          ,177 },
        {"ARABIC_CHARSET"          ,178 },
        {"GREEK_CHARSET"           ,161 },
        {"TURKISH_CHARSET"         ,162 },
        {"THAI_CHARSET"            ,222 },
        {"EASTEUROPE_CHARSET"      ,238 },
        {"RUSSIAN_CHARSET"         ,204 },
        {"MAC_CHARSET"             ,77  }
    };

    UINT i;

    for (i = 0; i < ARRAY_SIZE(CrackCS); ++i) {
        if (CrackCS[i].dwValue == bCharSet) {
            break;
        }
    }

    if (i < ARRAY_SIZE(CrackCS)) {
        return CrackCS[i].pstrCS;
    }

    return "ILLEGAL VALUE";
}

BOOL DumpKF(
    DWORD opts,
    DWORD n,
    PTR spkf,
    BOOL fActive)
{
    ULONG offTmp;
    PTR pKbdTbl;
    DWORD fLocaleFlags;
    WCHAR awchKF[9];        // size should match KBDFILE::awchKF
    WCHAR awchDllName[32];  // size should match KBDFILE::awchDllName
    DWORD dwType, dwSubType;
    PTR pDeadKey;

    if (spkf == 0) {
        Print("  spkf          0x%p (NONE!)\n", NULL_PTR);
        return TRUE;
    }

    _InitTypeRead(spkf, SYM(tagKBDFILE));

    Print("  %c" "spkf[%02x]    0x%p (cLockObj = %d)\n",
          fActive ? '*' : ' ',
          n, spkf, ReadField(head.cLockObj));
    if (opts & OFLAG(v)) {
        Print("     pkfNext       0x%p\n", ReadField(pkfNext));
        GetFieldOffset(SYM(tagKBDFILE), "awchKF", &offTmp);
        if (offTmp) {
            tryMoveBlock(awchKF, spkf + offTmp, sizeof(awchKF));
            awchKF[ARRAY_SIZE(awchKF) - 1] = 0;
            Print("     awchKF[]      L\"%ws\"\n", awchKF);
        }
    }

    GetFieldOffset(SYM(tagKBDFILE), "awchDllName", &offTmp);

    if (offTmp) {
        tryMoveBlock(awchDllName, spkf + offTmp, sizeof(awchDllName));
        awchDllName[ARRAY_SIZE(awchDllName) - 1] = 0;
        Print("     DllName[]     L\"%ws\"\n", awchDllName);
    }

    pKbdTbl = ReadField(pKbdTbl);
    Print("     pKbdTbl       0x%p\n", pKbdTbl);
    GetFieldValue(pKbdTbl, SYM(tagKbdLayer), "dwType", dwType);
    GetFieldValue(pKbdTbl, SYM(tagKbdLayer), "dwSubType", dwSubType);
    Print("     Type:Sub       (%x:%x)\n", dwType, dwSubType);
    GetFieldValue(pKbdTbl, SYM(tagKbdLayer), "pDeadKey", pDeadKey);

    if (opts & OFLAG(v)) {

        Print("     hBase          0x%08lx\n", ReadField(hBase));

        /*
         * Dump pKbdTbl
         */
        GetFieldValue(pKbdTbl, SYM(tagKbdLayer), "fLocaleFlags", fLocaleFlags);
        Print("        pDeadKey:    0x%p\n", pDeadKey);
        Print("        fLocaleFlags 0x%08lx\n", fLocaleFlags);

        if (opts & OFLAG(d)) {
            Iddk(OFLAG(i), pKbdTbl);
        }
    }

    return TRUE;
}

typedef struct {
    PTR hkl;
    UINT n;
} KLCOUNT, *PKLCOUNT;

typedef struct {
    DWORD opts;
    KLCOUNT kl[128];
} KLCALLBACKINFO, *PKLCALLBACKINFO;

ULONG WDBGAPI ThreadKLCallback(PTR pti, PVOID Data)
{
    PTR pkl;
    PTR hkl, hklPrev;
    PKLCALLBACKINFO pInfo = (PKLCALLBACKINFO)Data;
    UINT i;

    _InitTypeRead(pti, SYM(THREADINFO));

    pkl = ReadField(spklActive);
    hklPrev = ReadField(hklPrev);

    Print("  pti 0x%p  ", pti);

    GetFieldValue(pkl, SYM(tagKL), "hkl", hkl);

    Print("  spklActive %p   hkl %08x (prev: %08x)\n", pkl, (DWORD)hkl, (DWORD)hklPrev);

    /*
     * Count the KL usage.
     */
    for (i = 0; i < ARRAY_SIZE(pInfo->kl); ++i) {
        if (pInfo->kl[i].hkl == 0) {
            pInfo->kl[i].hkl = hkl;
            ++pInfo->kl[i].n;
            break;
        } else if (pInfo->kl[i].hkl == hkl) {
            ++pInfo->kl[i].n;
            break;
        }
    }

    return FALSE;
}


ULONG WDBGAPI KLProcessCallback(
    PTR ppi,
    PVOID Data)
{
    PKLCALLBACKINFO pInfo = (PKLCALLBACKINFO)Data;
    PTR pEProcess;
    WCHAR awchProcessName[MAX_PATH];
    PTI_CONTEXT ptic;
    W32PID W32Pid;

    GetFieldValue(ppi, SYM(_W32PROCESS), "Process", pEProcess);
    if (!GetProcessName(pEProcess, awchProcessName)) {
        awchProcessName[0] = 0;
    }
    GetFieldValue(pEProcess, SYM(_W32PROCESS), "W32Pid", W32Pid);
    Print("Process 0x%p (ppi 0x%p) [%ws]\n", pEProcess, ppi, awchProcessName);

    ptic.CallbackRoutine = ThreadKLCallback;
    ptic.Data = Data;
    ForEachPtiCallback(ppi, &ptic);

    return FALSE;
}

BOOL Idkl(
    DWORD opts,
    ULONG64 param1)
{
    try {
        PTR gpkl = NULL_PTR;
        PTR pkl, pklAnchor;
        PTR pkfActive;
        UINT i, nTables;
        UINT iBaseCharset;
        DWORD dwFontSigs;

        if (opts & OFLAG(k)) {
            /*
             * Dump all the thread and its KL information.
             */
            KLCALLBACKINFO info;

            if (param1) {
                return FALSE;
            }

            RtlZeroMemory(&info, sizeof info);
            info.opts = opts & ~OFLAG(k);
            ForEachPpi(KLProcessCallback, &info);

            // Print the summary.
            Print("\nSummary:\n");
            for (i = 0; i < ARRAY_SIZE(info.kl) && info.kl[i].hkl; ++i) {
                Print("%08x 0n%d\n", (DWORD)info.kl[i].hkl, info.kl[i].n);
            }
            return TRUE;
        }

        if (param1 == 0) {
            BYTE bCharSet;
            gpkl = GetGlobalPointer(VAR(gpkl));

            if (opts & OFLAG(a)) {
                Print("Using gspklBaseLayout\n");
                pkl = GetGlobalPointer(VAR(gspklBaseLayout));
            } else {
                Print("Using gpkl\n");
                pkl = gpkl;
            }
            moveExpValue(&bCharSet, VAR(gSystemCPCharSet));
            Print("gpKL:%p  gSystemCPCharSet:%s\n", gpkl, GetCharSetText(bCharSet));
        } else {
            pkl = FIXKP(param1);
        }

        if (pkl == NULL_PTR) {
            return FALSE;
        }

        _InitTypeRead(pkl, SYM(tagKL));

        Print("KL @ 0x%p (cLockObj = %d) %c\n", pkl, (DWORD)ReadField(head.cLockObj),
              pkl == gpkl ? '*' : ' ');
        Print("  hkl            0x%08p\n", ReadField(hkl));
        Print("  KLID             %08x\n", ReadField(dwKLID));
        if (opts & OFLAG(v)) {
            Print("  pklNext       0x%p\n", ReadField(pklNext));
            Print("  pklPrev       0x%p\n", ReadField(pklPrev));
            Print("  dwKL_Flags    0x%08p\n", ReadField(dwKL_Flags));
            Print("  piiex         0x%p\n", ReadField(piiex));
            GetFieldValue(pkl, SYM(tagKL), "dwFontSigs", dwFontSigs);
            Print("  dwFontSigs     %s\n", GetFlags(GF_CHARSETS, dwFontSigs, NULL, TRUE));
            GetFieldValue(pkl, SYM(tagKL), "iBaseCharset", iBaseCharset);
            Print("  iBaseCharset   %s\n", GetCharSetText((BYTE)iBaseCharset));
        }

        _InitTypeRead(pkl, SYM(tagKL));
        Print("  Codepage       %d\n", (WORD)ReadField(CodePage));

        pkfActive = ReadField(spkf);
        DumpKF(opts, 0, ReadField(spkfPrimary), ReadField(spkfPrimary) == pkfActive);

        _InitTypeRead(pkl, SYM(tagKL));

        /*
         * Dump extra tables
         */
        nTables = (UINT)ReadField(uNumTbl);
        Print("  Extra Tables: %x\n", nTables);
        if (nTables > 0) {
            PTR ppkfExtra = ReadField(pspkfExtra);
            for (i = 0; i < nTables && !IsCtrlCHit(); ++i) {
                PTR pkf;
                ReadPointer(ppkfExtra + GetTypeSize("PVOID") * i, &pkf);

                DumpKF(opts, i + 1, pkf, pkf == pkfActive);
            }
        }

        if (opts & OFLAG(a)) {
            PTR pklNext;

            opts &= ~OFLAG(a);

            pklAnchor = pkl;
            GetFieldValue(pkl, SYM(tagKL), "pklNext", pklNext);

            SAFEWHILE (pklNext && pklNext != pklAnchor) {
                pkl = pklNext;
                if (!Idkl(opts, pkl)) {
                    return FALSE;
                }

                if (GetFieldValue(pkl, SYM(tagKL), "pklNext", pklNext)) {
                    break;
                }
            }
        }
    } except (CONTINUE) {
    }

    return TRUE;
}


/***************************************************************************\
* ddk - dump deadkey table
*
* ddk address      - dumps deadkey table address
*
* 09/28/95 GregoryW        Created.
\***************************************************************************/

BOOL Iddk(
    DWORD opts,
    ULONG64 param1)
{
    try {
        PTR pKbdTbl;    // KBDTABLES
        PTR pDeadKey;   // DEADKEY
        ULONG cbDeadKey;

        if (param1 == NULL_PTR) {
            Print("Expected address\n");
            return FALSE;
        }

        cbDeadKey = GetTypeSize(SYM(DEADKEY));
        if (cbDeadKey == 0) {
            Print("cannot get sizeof(DEADKEY), invalid symbol?\n");
            return TRUE;
        }

        pKbdTbl = param1;

        GetFieldValue(pKbdTbl, SYM(KBDTABLES), "pDeadKey", pDeadKey);
        if (pDeadKey == NULL_PTR) {
            Print("No deadkey table for this layout\n");
            return TRUE;
        }

        SAFEWHILE (TRUE) {
            DWORD dwBoth;
            WCHAR wchComposed;
            USHORT uFlags;

            _InitTypeRead(pDeadKey, SYM(DEADKEY));
            dwBoth = DOWNCAST(DWORD, ReadField(dwBoth));
            if (dwBoth == 0) {
                break;
            }
            wchComposed = DOWNCAST(WCHAR, ReadField(wchComposed));
            uFlags = DOWNCAST(USHORT, ReadField(uFlags));
            Print("%*c d 0x%04x  ch 0x%04x  => 0x%04x, f=%x\n", (opts & OFLAG(i)) ? 8 : 0, ' ', HIWORD(dwBoth), LOWORD(dwBoth), wchComposed, uFlags);
            pDeadKey += cbDeadKey;
        }
    } except (CONTINUE) {
    }
    return TRUE;
}

#endif

#ifdef KERNEL

ULONG dtiFromPpiCallback(
    ULONG64 ppi,
    PVOID Data)
{
    ULONG64 pti;

    UNREFERENCED_PARAMETER(Data);

    GetFieldValue(ppi, SYM(PROCESSINFO), "ptiList", pti);
    SAFEWHILE (pti != 0) {
        Print("pti ==> 0x%p [ppi = 0x%p]\n", pti, ppi);
        Idti(0, pti);
        GetFieldValue(pti, SYM(THREADINFO), "ptiSibling", pti);
    }

    return FALSE;
}

/***************************************************************************\
* dti - dump THREADINFO
*
* dti address - dumps THREADINFO structure at address
*
* 11-13-91 DavidPe      Created.
* 6/9/1995 SanfordS     made to fit stdexts motif
\***************************************************************************/
BOOL Idti(
    DWORD opts,
    ULONG64 param1)
{
    PTR pti, pwinsta;
    CLIENTTHREADINFO cti;
    PTR pThread;
    PTR pEProcess;
    UCHAR PriorityClass;
    WCHAR szDesktop[256], szWindowStation[256];

    UNREFERENCED_PARAMETER(opts);

    if (param1 == 0) {
        PTR pq;

        if (opts & OFLAG(c)) {
            // !dti -c: Use the current thread.
            pti = GetGlobalPointer(VAR(gptiCurrent));
        } else if (opts & OFLAG(f)) {
            pq = GetGlobalPointer(VAR(gpqForeground));
            if (pq == 0) {
                Print("No foreground queue!\n");
                return FALSE;
            }
            GetFieldValue(pq, SYM(Q), "ptiKeyboard", pti);
        } else {
            Print("**** NT ACTIVE WIN32 THREADINFO DUMP ****\n");

            ForEachPpi(dtiFromPpiCallback, NULL);
            return TRUE;
        }
    } else {
        pti = FIXKP(param1);
    }

    if (pti == 0) {
        return FALSE;
    }

    Idt(OFLAG(p), pti);

    _InitTypeRead(pti, SYM(tagTHREADINFO));
    move(cti, ReadField(pcti));

    Print("PTHREADINFO @ 0x%p\n", pti);

    Print("\tPtiLink.Flink          0x%p\n"
          "\tptl                    0x%p\n"
          "\tptlW32                 0x%p\n"
          "\tppi                    0x%p\n"
          "\tpq                     0x%p\n"
          "\tspklActive             0x%p\n"
          "\tmlPost.pqmsgRead       0x%p\n"
          "\tmlPost.pqmsgWriteLast  0x%p\n"
          "\tmlPost.cMsgs           0x%08lx\n",
          ReadField(PtiLink.Flink),
          ReadField(ptl),
          ReadField(ptlW32),
          ReadField(ppi),
          ReadField(pq),
          ReadField(spklActive),
          ReadField(mlPost.pqmsgRead),
          ReadField(mlPost.pqmsgWriteLast),
          (ULONG)ReadField(mlPost.cMsgs));

    Print("\tspwndDefaultIme        0x%p\n"
          "\tspDefaultImc           0x%p\n"
          "\thklPrev                0x%08lx\n",
          ReadField(spwndDefaultIme),
          ReadField(spDefaultImc),
          ReadField(hklPrev));

    Print("\trpdesk                 0x%p",
          ReadField(rpdesk));
    // If the pti has a desktop, display it and windowstation.
    if (ReadField(rpdesk)) {
        GetObjectName(ReadField(rpdesk), szDesktop, ARRAY_SIZE(szDesktop));
        GetFieldValue(ReadField(rpdesk), SYM(DESKTOP), "rpwinstaParent", pwinsta);
        GetObjectName(pwinsta, szWindowStation, ARRAY_SIZE(szWindowStation));
        Print(" (%ws\\%ws)", szWindowStation, szDesktop);
    }
    Print("\n");

    Print("\thdesk                  0x%08lx\n",
          ReadField(hdesk));
    Print("\tamdesk                 0x%08lx\n",
          (ULONG)ReadField(amdesk));

    Print("\tpDeskInfo              0x%p\n"
          "\tpClientInfo            0x%p\n",
          ReadField(pDeskInfo),
          ReadField(pClientInfo));

    Print("\tTIF_flags              %s\n",
          GetFlags(GF_TIF, (DWORD)ReadField(TIF_flags), NULL, TRUE));
    Print("\tsphkCurrent            0x%p\n"
          "\tpEventQueueServer      0x%p\n"
          "\thEventQueueClient      0x%p\n",
          ReadField(sphkCurrent),
          ReadField(pEventQueueServer),
          ReadField(hEventQueueClient));

    Print("\tfsChangeBits           %s\n",
            GetFlags(GF_QS, (WORD)cti.fsChangeBits, NULL, TRUE));
    Print("\tfsChangeBitsRemoved    %s\n",
            GetFlags(GF_QS, (WORD)ReadField(fsChangeBitsRemoved), NULL, TRUE));
    Print("\tfsWakeBits             %s\n",
            GetFlags(GF_QS, (WORD)cti.fsWakeBits, NULL, TRUE));
    Print("\tfsWakeMask             %s\n",
            GetFlags(GF_QS, (WORD)cti.fsWakeMask, NULL, TRUE));

    Print("\tcPaintsReady           0x%04x\n"
          "\tcTimersReady           0x%04x\n"
          "\ttimeLast               0x%08lx\n"
          "\tptLast.x               0x%08lx\n"
          "\tptLast.y               0x%08lx\n"
          "\tidLast                 0x%p\n",
          (ULONG)ReadField(cPaintsReady),
          (ULONG)ReadField(cTimersReady),
          (ULONG)ReadField(timeLast),
          (ULONG)ReadField(ptLast.x),
          (ULONG)ReadField(ptLast.y),
          ReadField(idLast));

    Print("\texitCode               0x%08lx\n"
          "\tpSBTrack               0x%p\n"
          "\tpsmsSent               0x%p\n"
          "\tpsmsCurrent            0x%p\n",
          (ULONG)ReadField(exitCode),
          ReadField(pSBTrack),
          ReadField(psmsSent),
          ReadField(psmsCurrent));

    Print("\tfsHooks                0x%08lx\n"
          "\taphkStart              0x%p l%x\n"
          "\tsphkCurrent            0x%p\n",
          (ULONG)ReadField(fsHooks),
          ReadField(aphkStart), CWINHOOKS,
          ReadField(sphkCurrent));
    Print("\tpsmsReceiveList        0x%p\n",
          ReadField(psmsReceiveList));
    Print("\tptdb                   0x%p\n"
          "\tThread                 0x%p\n",
          ReadField(ptdb),
          ReadField(pEThread));

    pThread = ReadField(pEThread);
    GetFieldValue(pThread, "nt!ETHREAD", "ThreadsProcess", pEProcess);
    GetFieldValue(pEProcess, "nt!EPROCESS", "PriorityClass", PriorityClass);
    Print("\t  PriorityClass %d\n",
          PriorityClass);

    _InitTypeRead(pti, SYM(tagTHREADINFO));

    Print("\tcWindows               0x%08lx\n"
          "\tcVisWindows            0x%08lx\n"
          "\tpqAttach               0x%p\n"
          "\tiCursorLevel           0x%08lx\n",
          (ULONG)ReadField(cWindows),
          (ULONG)ReadField(cVisWindows),
          ReadField(pqAttach),
          (ULONG)ReadField(iCursorLevel));

    Print("\tpMenuState             0x%p\n",
          ReadField(pMenuState));

    return TRUE;
}
#endif // KERNEL

#ifdef KERNEL

BOOL ScanThreadlocks(PTR pti, char chType, PTR pvSearch);

ULONG WDBGAPI DumpThreadLocksCallback(PTR pti, PVOID pOpt)
{
    UNREFERENCED_PARAMETER(pOpt);

    Idtl(OFLAG(t) | OFLAG(x), pti);
    return 0;
}

ULONG WDBGAPI ScanThreadLocksCallback(PTR pti, PVOID pOpt)
{
    ScanThreadlocks(pti, 'o', *(PTR*)pOpt);
    ScanThreadlocks(pti, 'k', *(PTR*)pOpt);
    return 0;
}

/***************************************************************************\
* dtl handle|pointer
*
* !dtl <addr>       Dumps all THREAD locks for object at <addr>
* !dtl -t <pti>     Dumps all THREAD locks made by thread <pti>
* !dtl              Dumps all THREAD locks made by all threads
*
* 02/27/1992 ScottLu      Created.
* 06/09/1995 SanfordS     Made to fit stdexts motif.
\***************************************************************************/
BOOL Idtl(
    DWORD opts,
    ULONG64 param1)
{
    PTR pti;

    if (param1 == 0) {
        Print("Dumping all thread locks:\n");
        Print("pti        pObj     Caller\n");
        ForEachPti(DumpThreadLocksCallback, NULL);
        return TRUE;
    }

    if (opts & OFLAG(t)) {
        pti = FIXKP(param1);
        if (pti == 0) {
            return FALSE;
        }

        /*
         * Regular thread-locked objects.
         */
        if (!(opts & OFLAG(x))) { // x is not legal from user - internal only
            Print("pti        pObj     Caller\n");
        }
        ScanThreadlocks(pti, 'o', 0);
        ScanThreadlocks(pti, 'k', 0);
        return TRUE;
    }


    if (!param1) {
        return FALSE;
    }

    Print("Thread Locks for object %p:\n", param1);
    Print("pti        pObj     Caller\n");

    ForEachPti(ScanThreadLocksCallback, &param1);

    Print("--- End Thread Lock List ---\n");

    return TRUE;
}

/*
 * Scans all threadlocked objects belonging to thread pti of type chType
 * (o == regular objects, k == kernel objects, p == pool). Display each
 * threadlock, or if pvSearch is non-NULL, just those locks on the object
 * at pvSearch.
 */
BOOL
ScanThreadlocks(
    PTR pti,
    char    chType,
    PTR pvSearch)
{
    PTR ptl;

    if (pti == 0) {
        return FALSE;
    }

    if (_InitTypeRead(pti, SYM(THREADINFO))) {
        Print("Idtl: Can't get pti data from %p.\n", (ULONG_PTR)pti);
        return FALSE;
    }
    switch (chType) {
    case 'o':
        ptl = ReadField(ptl);
        break;
    case 'k':
        ptl = ReadField(ptlW32);
        break;
    default:
        Print("Internal error, bad chType '%c' in ScanThreadlocks\n", chType);
        return FALSE;
    }

    SAFEWHILE (ptl) {
        char ach[80];
        ULONG64 dwOffset;

        if (_InitTypeRead(ptl, SYM(TL))) {
            Print("Idtl: Can't get ptl data from %p.\n", (ULONG_PTR)ptl);
            return FALSE;
        }

        if (!pvSearch || ReadField(pobj) == pvSearch) {
            Print("0x%p 0x%p", pti, ReadField(pobj));
            GetSym(ReadField(pfnCaller), ach, &dwOffset);
            Print(" %s", ach);
            if (dwOffset) {
                Print("+0x%x", (ULONG)dwOffset);
            }
            if (chType == 'k') {
                GetSym(ReadField(pfnFree), ach, &dwOffset);
                Print(" (%s)", ach);
                if (dwOffset) {
                    Print("+0x%x", (ULONG)dwOffset);
                }
            }
            Print("\n");
        }
        ptl = ReadField(next);
    }

    return TRUE;
}
#endif // KERNEL

#ifdef KERNEL

/************************************************************************\
* FindTimerByID
*
* Looks up a timer based upon its ID. Worker function for !dtmr.
*
* 04/10/2001    JasonSch    Wrote it.
\************************************************************************/
ULONG64 FindTimerByID(
    ULONG64 tmr)
{
    ULONG64 ptmr;

    ptmr = GetGlobalPointer(VAR(gptmrFirst));
    SAFEWHILE (ptmr) {
        _InitTypeRead(ptmr, SYM(TIMER));
        if (ReadField(nID) == tmr) {
            break;
        }

        ptmr = ReadField(ptmrNext);
    }

    return ptmr;
}

/************************************************************************\
* Idtmr
*
* Dumps timer structures.
*
* 06/09/1995    SanfordS    Created.
* 10/18/2000    Mohamed     Port to 64 bit.
* 04/10/2002    JasonSch    Added -i option.
\************************************************************************/
BOOL Idtmr(
    DWORD opts,
    PTR ptmr)
{
    PTR pti;

    if (ptmr == 0) {
        ULONG ulTimerCnt = 0;

        ptmr = GetGlobalPointer(VAR(gptmrFirst));
        SAFEWHILE (ptmr) {
            ++ulTimerCnt;
            Idtmr(0, ptmr);
            Print("\n");
            _InitTypeRead(ptmr, SYM(TIMER));
            ptmr = ReadField(ptmrNext);
        }

        Print("0x%x total timers dumped.\n", ulTimerCnt);
        return TRUE;
    }

    /*
     * The -i option indicates that ptmr is an ID, not a pointer.
     */
    if (opts & OFLAG(i)) {
        ULONG64 ptmrT = FindTimerByID(ptmr);

        if (ptmrT == 0) {
            Print("Couldn't find timer with id 0x%p\n", ptmr);
            return TRUE;
        }

        ptmr = ptmrT;
    }

    _InitTypeRead(ptmr, SYM(TIMER));
    Print("Timer %p:\n"
          "  ptmrNext       = %p\n"
          "  pti            = %p",
          ptmr,
          ReadField(ptmrNext),
          ReadField(pti));

    pti = ReadField(pti);
    if (pti && _InitTypeRead(pti, SYM(THREADINFO))) {
        WCHAR awch[64];

        if (GetAppName(ReadField(pEThread), pti, awch, ARRAY_SIZE(awch))) {
            ULONG handleProcess, handleThread;
            PWCHAR pwch = wcsrchr(awch, L'\\');

            if (pwch == NULL) {
                pwch = awch;
            } else {
                pwch++;
            }

            GetFieldValue(ReadField(pEThread), "nt!ETHREAD", "Cid.UniqueThread", handleProcess);
            GetFieldValue(ReadField(pEThread), "nt!ETHREAD", "Cid.UniqueThread", handleThread);
            Print("  q %p i %2x.%-3lx %ws",
                    ReadField(pq),
                    handleProcess,
                    handleThread,
                    pwch);
        }
    }
    _InitTypeRead(ptmr, SYM(TIMER));
    Print("\n"
          "  spwnd          = %p",
          ReadField(spwnd));
    if (ReadField(spwnd)) {
        char ach[80];

        DebugGetWindowTextA(ReadField(spwnd), ach, ARRAY_SIZE(ach));
        Print("  \"%s\"", ach);
    }
    Print("\n"
          "  nID            = %x\n"
          "  cmsCountdown   = %x\n"
          "  cmsRate        = %x\n"
          "  flags          = %s\n"
          "  pfn            = %p\n"
          "  ptiOptCreator  = %p\n",
          (ULONG) ReadField(nID),
          (ULONG) ReadField(cmsCountdown),
          (ULONG) ReadField(cmsRate),
          GetFlags(GF_TMRF, (WORD)ReadField(flags), NULL, TRUE),
          ReadField(pfn),
          ReadField(ptiOptCreator));

    return TRUE;
}
#endif // KERNEL


#ifdef OLD_DEBUGGER
/************************************************************************\
* Idu
*
* Dump unknown object.  Does what it can figure out.
*
* 6/9/1995 Created SanfordS
\************************************************************************/
BOOL Idu(
    DWORD opts,
    ULONG64 param1)
{
    HANDLEENTRY he, *phe;
    int i;
    DWORD dw;

    UNREFERENCED_PARAMETER(opts);

    if (param1 == 0) {
        FOREACHHANDLEENTRY(phe, he, i)
            if (he.bType != TYPE_FREE && tryDword(&dw, FIXKP(he.phead))) {
                Idu(OFLAG(x), he.phead);
            }
        NEXTEACHHANDLEENTRY()
        return TRUE;
    }

    param1 = HorPtoP(FIXKP(param1), -1);
    if (param1 == 0) {
        return FALSE;
    }

    if (!getHEfromP(NULL, &he, param1)) {
        return FALSE;
    }

    Print("--- %s object @ 0x%p ---\n", pszObjStr[he.bType], FIXKP(param1));
    switch (he.bType) {
    case TYPE_WINDOW:
        return Idw(0, param1);

    case TYPE_MENU:
        return Idm(0, param1);

#ifdef KERNEL
    case TYPE_CURSOR:
        return Idcur(0, param1);

    case TYPE_HOOK:
        return Idhk(OFLAG(a) | OFLAG(g), NULL);

    case TYPE_DDECONV:
    case TYPE_DDEXACT:
        return Idde(0, param1);
#endif // KERNEL

    case TYPE_MONITOR:
        // LATER: - add dmon command
    case TYPE_CALLPROC:
    case TYPE_ACCELTABLE:
    case TYPE_SETWINDOWPOS:
    case TYPE_DDEACCESS:
    default:
        Print("not supported.\n", pszObjStr[he.bType]);
    }
    return TRUE;
}



#ifdef KERNEL
/***************************************************************************\
* dumphmgr - dumps object allocation counts for handle-table.
*
* 10-18-94 ChrisWil     Created.
* 6/9/1995 SanfordS     made to fit stdexts motif
* 06-18-97 MCostea      made it work
\***************************************************************************/
BOOL Idumphmgr(
    DWORD opts)
{
    PERFHANDLEINFO aLocalHti[TYPE_CTYPES], aLocalPrevHti[TYPE_CTYPES];
    PPERFHANDLEINFO pgahti;

    LONG lTotalAlloc, lTotalMax, lTotalCurrent;
    LONG lPrevTotalAlloc, lPrevTotalMax, lPrevTotalCurrent;
    SIZE_T lTotalSize, lPrevTotalSize;

    int idx;

    pgahti = EvalExp(VAR(gaPerfhti));
    if (!pgahti) {
        Print("\n!dumphmgr works only with debug versions of win32k.sys\n\n");
        return TRUE;
    }
    move(aLocalHti, pgahti);

    pgahti = EvalExp(VAR(gaPrevhti));
    if (!pgahti) {
        return TRUE;
    }

    move(aLocalPrevHti, pgahti);

    lTotalSize = lTotalAlloc = lTotalMax = lTotalCurrent = 0;
    lPrevTotalSize = lPrevTotalAlloc = lPrevTotalMax = lPrevTotalCurrent = 0;

    if (aLocalPrevHti[TYPE_WINDOW].lTotalCount) {
        Print("\nThe snapshot values come under the current ones\n");

        Print("Type             Allocated         Maximum       Count             Size\n");
        Print("______________________________________________________________________________");
        for (idx = 1; idx < TYPE_CTYPES; idx++) {
            Print("\n%-15s  %8d %-+6d %7d %-+5d %6d %-+5d  %9d %-+d",
                  aszTypeNames[idx],
                  aLocalHti[idx].lTotalCount, aLocalHti[idx].lTotalCount - aLocalPrevHti[idx].lTotalCount,
                  aLocalHti[idx].lMaxCount, aLocalHti[idx].lMaxCount - aLocalPrevHti[idx].lMaxCount,
                  aLocalHti[idx].lCount, aLocalHti[idx].lCount - aLocalPrevHti[idx].lCount,
                  aLocalHti[idx].lSize, aLocalHti[idx].lSize - aLocalPrevHti[idx].lSize);
            if (aLocalPrevHti[TYPE_WINDOW].lTotalCount) {
                Print("\n                 %8d        %7d       %6d        %9d",
                      aLocalPrevHti[idx].lTotalCount,
                      aLocalPrevHti[idx].lMaxCount,
                      aLocalPrevHti[idx].lCount,
                      aLocalPrevHti[idx].lSize);
                lPrevTotalAlloc   += aLocalPrevHti[idx].lTotalCount;
                lPrevTotalMax     += aLocalPrevHti[idx].lMaxCount;
                lPrevTotalCurrent += aLocalPrevHti[idx].lCount;
                lPrevTotalSize    += aLocalPrevHti[idx].lSize;

            }
            lTotalAlloc   += aLocalHti[idx].lTotalCount;
            lTotalMax     += aLocalHti[idx].lMaxCount;
            lTotalCurrent += aLocalHti[idx].lCount;
            lTotalSize    += aLocalHti[idx].lSize;
        }
        Print("\n______________________________________________________________________________\n");
        Print("Totals           %8d %-+6d %7d %-+5d %6d %+-5d  %9d %-+d\n",
              lTotalAlloc, lTotalAlloc - lPrevTotalAlloc,
              lTotalMax, lTotalMax - lPrevTotalMax,
              lTotalCurrent, lTotalCurrent - lPrevTotalCurrent,
              lTotalSize, lTotalSize - lPrevTotalSize);
        Print("                 %8d        %7d       %6d        %9d\n",
              lPrevTotalAlloc, lPrevTotalMax, lPrevTotalCurrent, lPrevTotalSize);

    } else {
        Print("Type               Allocated  Maximum  Count   Size\n");
        Print("______________________________________________________");
        for (idx = 1; idx < TYPE_CTYPES; idx++) {
            Print("\n%-17s  %9d  %7d  %6d  %d",
                  aszTypeNames[idx],
                  aLocalHti[idx].lTotalCount,
                  aLocalHti[idx].lMaxCount,
                  aLocalHti[idx].lCount,
                  aLocalHti[idx].lSize);
            lTotalAlloc   += aLocalHti[idx].lTotalCount;
            lTotalMax     += aLocalHti[idx].lMaxCount;
            lTotalCurrent += aLocalHti[idx].lCount;
            lTotalSize    += aLocalHti[idx].lSize;
        }
        Print("\n______________________________________________________\n");
        Print("Current totals     %9d  %7d  %6d  %d\n",
              lTotalAlloc, lTotalMax, lTotalCurrent, lTotalSize);
    }

    /*
     * If the argument-list contains the Snap option,
     * then copy the current counts to the previous ones
     */
    if (opts & OFLAG(s)) {
        (lpExtensionApis->lpWriteProcessMemoryRoutine)(
                (ULONG_PTR)&(pgahti[0]),
                (PVOID)aLocalHti,
                sizeof(aLocalHti),
                NULL);
    }

    return TRUE;
}
#endif // KERNEL
#endif // OLD_DEBUGGER


/************************************************************************\
* dwrWorker
*
* Dumps pwnd structures compactly to show relationships.
*
* 6/9/1995 Created SanfordS
\************************************************************************/
BOOL dwrWorker(
    PTR pwnd,
    int tab)
{
    PTR pcls;
    PTR lpszAnsiClassName;
    PTR pwndChild;
    PTR pwndOwner;
    ULONG atomClassName;
    ULONG atomNVClassName;

    if (pwnd == 0) {
        return FALSE;
    }

    do {
        pwnd = FIXKP(pwnd);
        DebugGetWindowTextA(pwnd, gach1, ARRAY_SIZE(gach1));
        GetFieldValue(pwnd, SYM(WND), "pcls", pcls);
        GetFieldValue(pcls, SYM(CLS), "atomClassName", atomClassName);
        GetFieldValue(pcls, SYM(CLS), "atomNVClassName", atomNVClassName);
        GetFieldValue(pcls, SYM(CLS), "lpszAnsiClassName", lpszAnsiClassName);
        if (atomNVClassName < 0xC000) {
            switch (atomNVClassName) {
            case WC_DIALOG:
                strcpy(gach1, "WC_DIALOG");
                break;

            case DESKTOPCLASS:
                strcpy(gach1, "DESKTOP");
                break;

            case SWITCHWNDCLASS:
                strcpy(gach1, "SWITCHWND");
                break;

            case ICONTITLECLASS:
                strcpy(gach1, "ICONTITLE");
                break;

            default:
                if (atomNVClassName == 0) {
                    move(gach1, FIXKP(lpszAnsiClassName));
                } else {
                    sprintf(gach2, "0x%04x", atomNVClassName);
                }
            }
        } else {
            DebugGetClassNameA(lpszAnsiClassName, gach2);
        }

        if (atomClassName && (atomClassName < 0xC000)) {
            sprintf(gach3, "0x%04x", atomClassName);
        }

        Print("%08p%*s [%s|%s|%s]", pwnd, tab, "", gach1, gach2, gach3);
        GetFieldValue(pwnd, SYM(WND), "spwndOwner", pwndOwner);
        if (pwndOwner != 0) {
            Print(" <- Owned by:%08x", FIXKP(pwndOwner));
        }
        Print("\n");
        GetFieldValue(pwnd, SYM(WND), "spwndChild", pwndChild);
        if (pwndChild != 0) {
            dwrWorker(pwndChild, tab + 2);
        }
        GetFieldValue(pwnd, SYM(WND), "spwndNext", pwnd);
    } SAFEWHILE (pwnd && tab > 0);
    return TRUE;
}


/************************************************************************\
* Idw
*
* Dumps pwnd structures
*
* 6/9/1995 Created SanfordS
\************************************************************************/
BOOL Idw(
    DWORD opts,
    ULONG64 param1)
{
    WW ww;
    PTR lpfnWndProc;
    RECT rcWindow;
    RECT rcClient;
    PTR pcls;
    PTR pwnd = param1;
    char ach[256];
    ULONG64 dwOffset;
    ULONG ix;
    DWORD tempDWord;
    DWORD dwWOW;

    try {

        if (opts & OFLAG(a)) {
#ifdef KERNEL
            PTR pdesk;
            PTR pDeskInfo;
            PTR pwnd;
            WCHAR wach[80];

            if (param1 != 0) {
                Print("window parameter ignored with -a option.\n");
            }
            FOREACHDESKTOP(pdesk)
                if (!GetFieldValue(pdesk, SYM(DESKTOP), "pDeskInfo", pDeskInfo)) {
                    GetObjectName(pdesk, wach, ARRAY_SIZE(wach));
                    Print("\n----Windows for %ws desktop @ 0x%p:\n\n", wach, pdesk);
                    GetFieldValue(pDeskInfo, SYM(DESKTOPINFO), "spwnd", pwnd);
                    if (!Idw((opts & ~OFLAG(a)) | OFLAG(p), pwnd)) {
                        return FALSE;
                    }
                }
            NEXTEACHDESKTOP(pdesk)
#else // !KERNEL
            PTR pteb = 0;

            GetTebAddress(&pteb);
            if (pteb) {
                ULONG pciOffset;
                PTR pdi;

                GetFieldOffset(SYM(TEB), "Win32ClientInfo", &pciOffset);
                GetFieldValue(pteb + pciOffset, SYM(CLIENTINFO), "pDeskInfo", pdi);
                GetFieldValue(pdi, SYM(DESKTOPINFO), "spwnd", pwnd);
                return Idw(opts & ~OFLAG(a) | OFLAG(p), FIXKP(pwnd));
            }
#endif // !KERNEL
            return TRUE;
        }

        /*
         * t is like EnumThreadWindows.
         */
        if (opts & OFLAG(t)) {
#ifdef KERNEL
            PTR pti, ptiWnd;
            PTR pdesk;
            PTR pdi;
            /*
             * Get the desktop's first child window
             */
            pti = param1;
            if (GetFieldValue(pti, SYM(THREADINFO), "rpdesk", pdesk)
                    || GetFieldValue(pdesk, SYM(DESKTOP), "pDeskInfo", pdi)
                    || GetFieldValue(pdi, SYM(DESKTOPINFO), "spwnd", pwnd)
                    || GetFieldValue(pwnd, SYM(WND), "spwndChild", pwnd)) {
                return FALSE;
            }
            /*
             * Walk the sibling chain looking for pwnd owned by pti.
             */
            SAFEWHILE (pwnd) {
                if (!GetFieldValue(pwnd, SYM(WND), "head.pti", ptiWnd) && (ptiWnd == pti)) {
                    if (!Idw(opts & ~OFLAG(t), pwnd)) {
                        return FALSE;
                    }
                }
                if (GetFieldValue(pwnd, SYM(WND), "spwndNext", pwnd)) {
                    return FALSE;
                }
            }
            return TRUE;

#else // !KERNEL
            Print("t parameter not supported for NTSD at this point\n");
#endif // !KERNEL
        }

        /*
         * See if the user wants all top level windows.
         */
        if (param1 == 0 || opts & (OFLAG(p) | OFLAG(s))) {
            /*
             * Make sure there was also a window argument if p or s.
             */

            if (param1 == 0 && (opts & (OFLAG(p) | OFLAG(s)))) {
                Print("Must specify window with '-p' or '-s' options.\n");
                return FALSE;
            }

            if (param1 && (pwnd = HorPtoP(pwnd, TYPE_WINDOW)) == 0) {
                return FALSE;
            }

            if (opts & OFLAG(p)) {
                Print("pwndParent = 0x%p\n", pwnd);
                if (GetFieldValue(FIXKP(pwnd), SYM(WND), "spwndChild", pwnd)) {
                    Print("<< Can't get WND >>\n");
                    return TRUE; // we don't need to have the flags explained!
                }
                SAFEWHILE (pwnd) {
                    if (!Idw(opts & ~OFLAG(p), pwnd)) {
                        return FALSE;
                    }
                    GetFieldValue(FIXKP(pwnd), SYM(WND), "spwndNext", pwnd);
                }
                return TRUE;

            } else if (opts & OFLAG(s)) {
                GetFieldValue(FIXKP(pwnd), SYM(WND), "spwndParent", pwnd);
                return Idw((opts | OFLAG(p)) & ~OFLAG(s), pwnd);

            } else {
#ifdef KERNEL
                PTR pdesk = NULL_PTR;
                PTR pDeskInfo, pwnd;
                PTR pti, pq;

                pq = GetGlobalPointer(VAR(gpqForeground));
                GetFieldValue(pq, SYM(Q), "ptiKeyboard", pti);
                GetFieldValue(pti, SYM(THREADINFO), "rpdesk", pdesk);
                if (pdesk == 0) {
                    Print("Foreground thread doesn't have a desktop.\n");
                    Print("Using grpdeskRitInput ...\n");

                    pdesk = GetGlobalPointer(SYM(grpdeskRitInput));
                    if (pdesk == 0) {
                        Print("grpdeskRitInput is NULL!\n");
                        return FALSE;
                    }
                    GetFieldValue(pdesk, SYM(DESKTOP), "pDeskInfo", pDeskInfo);
                    GetFieldValue(pDeskInfo, SYM(DESKTOPINFO), "spwnd", pwnd);
                } else {
                    GetFieldValue(pti, SYM(THREADINFO), "pDeskInfo", pDeskInfo);
                    GetFieldValue(pDeskInfo, SYM(DESKTOPINFO), "spwnd", pwnd);
                }

                Print("pwndDesktop = 0x%p\n", (ULONG_PTR)pwnd);
                return Idw(opts | OFLAG(p), pwnd);
#else  // !KERNEL
                return Idw(opts | OFLAG(a), 0);
#endif // !KERNEL
            }
        }

        if (param1 && (pwnd = HorPtoP(param1, TYPE_WINDOW)) == 0) {
            Print("Idw: 0x%p is not a pwnd.\n", param1);
            return FALSE;
        }

        if (opts &  OFLAG(r)) {
            dwrWorker(FIXKP(pwnd), 0);
            return TRUE;
        }

        _InitTypeRead(pwnd, SYM(tagWND));
        lpfnWndProc = ReadField(lpfnWndProc);
        ww.state    = (DWORD)ReadField(state);
        ww.state2   = (DWORD)ReadField(state2);
        ww.ExStyle  = (DWORD)ReadField(ExStyle);
        ww.style    = (DWORD)ReadField(style);

#ifdef KERNEL
        /*
         * Print simple thread info.
         */
        if (ReadField(head.pti)) {
            Idt(OFLAG(p), ReadField(head.pti));
        }
#endif // KERNEL

        /*
         * Print pwnd.
         */
        Print("pwnd    = 0x%p", pwnd);
        /*
         * Show z-ordering/activation relevant info
         */
        if (opts & OFLAG(z)) {
            PTR pwndOwner;

            if (ReadField(ExStyle) & WS_EX_TOPMOST) {
                Print(" TOPMOST");
            }
            if (!(ReadField(style) & WS_VISIBLE)) {
                Print(" HIDDEN");
            }
            if (ReadField(style) & WS_DISABLED) {
                Print(" DISABLED");
            }
            pwndOwner = ReadField(spwndOwner);
            if (pwndOwner != 0) {
                DebugGetWindowTextA(pwndOwner, ach, ARRAY_SIZE(ach));
                Print(" OWNER:0x%p \"%s\"", pwndOwner, ach);
            }
        }
        Print("\n");

        if (!(opts & OFLAG(v))) {

            /*
             * Print title string.
             */
            DebugGetWindowTextA(pwnd, ach, ARRAY_SIZE(ach));
            Print("title   = \"%s\"\n", ach);

            /*
             * Print wndproc symbol string.
             */
            if (IsWOWProc (lpfnWndProc)) {
            UnMarkWOWProc(lpfnWndProc,dwWOW);
            Print("wndproc = %04lx:%04lx (WOW) (%s)",
                    HIWORD(dwWOW),LOWORD(dwWOW),
                    TestWWF(&ww, WFANSIPROC) ? "ANSI" : "Unicode");
            } else {
                GetSym(lpfnWndProc, ach, &dwOffset);
                Print("wndproc = 0x%p = \"%s\" (%s)", lpfnWndProc, ach,
                    TestWWF(&ww, WFANSIPROC) ? "ANSI" : "Unicode");
            }

            /*
             * Display the class name/atom.
             */
            GetFieldValue(pwnd, SYM(tagWND), "pcls", pcls);
            pcls = FIXKP(pcls);
            _InitTypeRead(pcls, SYM(tagCLS));

            DebugGetClassNameA(ReadField(lpszAnsiClassName), ach);
            Print(" Class(V): 0x%04p, (NV): 0x%04p Name:\"%s\"\n", ReadField(atomClassName), ReadField(atomNVClassName), ach);
        } else {
            /*
             * Get the PWND structure.  Ignore class-specific data for now.
             */
            _InitTypeRead(pwnd, SYM(tagWND));
            Print("\thandle             0x%p\n", ReadField(head.h));

            DebugGetWindowTextA(ReadField(spwndNext), ach, ARRAY_SIZE(ach));
            Print("\tspwndNext          0x%p     \"%s\"\n", ReadField(spwndNext), ach);
            DebugGetWindowTextA(ReadField(spwndPrev), ach, ARRAY_SIZE(ach));
            Print("\tspwndPrev          0x%p     \"%s\"\n", ReadField(spwndPrev), ach);
            DebugGetWindowTextA(ReadField(spwndParent), ach, ARRAY_SIZE(ach));
            Print("\tspwndParent        0x%p     \"%s\"\n", ReadField(spwndParent), ach);
            DebugGetWindowTextA(ReadField(spwndChild), ach, ARRAY_SIZE(ach));
            Print("\tspwndChild         0x%p     \"%s\"\n", ReadField(spwndChild), ach);
            DebugGetWindowTextA(ReadField(spwndOwner), ach, ARRAY_SIZE(ach));
            Print("\tspwndOwner         0x%p     \"%s\"\n", ReadField(spwndOwner), ach);

            GetFieldValue(pwnd, SYM(tagWND), "rcWindow", rcWindow);
            Print("\trcWindow           (%d,%d)-(%d,%d) %dx%d\n",
                    rcWindow.left, rcWindow.top,
                    rcWindow.right, rcWindow.bottom,
                    rcWindow.right - rcWindow.left,
                    rcWindow.bottom - rcWindow.top);

            GetFieldValue(pwnd, SYM(tagWND), "rcClient", rcClient);
            Print("\trcClient           (%d,%d)-(%d,%d) %dx%d\n",
                    rcClient.left, rcClient.top,
                    rcClient.right, rcClient.bottom,
                    rcClient.right - rcClient.left,
                    rcClient.bottom - rcClient.top);

            if (IsWOWProc (lpfnWndProc)) {
                UnMarkWOWProc(lpfnWndProc, dwWOW);
                Print("\tlpfnWndProc        %04lx:%04lx (WOW) (%s)\n",
                        HIWORD(dwWOW),LOWORD(dwWOW),
                        TestWWF(&ww, WFANSIPROC) ? "ANSI" : "Unicode");
            } else {
                GetSym(lpfnWndProc, ach, &dwOffset);
                Print("\tlpfnWndProc        0x%p     (%s) %s\n", lpfnWndProc, ach,
                    TestWWF(&ww, WFANSIPROC) ? "ANSI" : "Unicode");
            }
            pcls = ReadField(pcls);
            pcls = FIXKP(pcls);
            _InitTypeRead(pcls, SYM(tagCLS));
            DebugGetClassNameA(ReadField(lpszAnsiClassName), ach);

            Print("\tpcls               0x%p     (V):0x%04p     (NV):0x%04p     Name:\"%s\"\n",
                    pcls, ReadField(atomClassName), ReadField(atomNVClassName), ach);

            _InitTypeRead(pwnd, SYM(tagWND));
            Print("\thrgnUpdate         0x%p\n",
                    ReadField(hrgnUpdate));
            DebugGetWindowTextA(ReadField(spwndLastActive), ach, ARRAY_SIZE(ach));
            Print("\tspwndLastActive    0x%p     \"%s\"\n",
                  ReadField(spwndLastActive), ach);
            Print("\tppropList          0x%p\n"
                  "\tpSBInfo            0x%p\n",
                  ReadField(ppropList),
                  ReadField(pSBInfo));

            if (ReadField(pSBInfo)) {
                SBINFO asb;

                moveBlock(&asb, FIXKP(ReadField(pSBInfo)), sizeof(asb));
                Print("\t  SBO_FLAGS =      %s\n"
                      "\t  SBO_HMIN  =      %d\n"
                      "\t  SBO_HMAX  =      %d\n"
                      "\t  SBO_HPAGE =      %d\n"
                      "\t  SBO_HPOS  =      %d\n"
                      "\t  SBO_VMIN  =      %d\n"
                      "\t  SBO_VMAX  =      %d\n"
                      "\t  SBO_VPAGE =      %d\n"
                      "\t  SBO_VPOS  =      %d\n",
                        GetFlags(GF_SB, (WORD)asb.WSBflags, NULL, TRUE),
                        asb.Horz.posMin,
                        asb.Horz.posMax,
                        asb.Horz.page,
                        asb.Horz.pos,
                        asb.Vert.posMin,
                        asb.Vert.posMax,
                        asb.Vert.page,
                        asb.Vert.pos);
            }
            Print("\tspmenuSys          0x%p\n"
                  "\tspmenu/id          0x%p\n",
                  ReadField(spmenuSys),
                  ReadField(spmenu));
            Print("\thrgnClip           0x%p\n",
                  ReadField(hrgnClip));


            /*
             * Print title string.
             */
            DebugGetWindowTextA(pwnd, ach, ARRAY_SIZE(ach));
            Print("\tpName              \"%s\"\n",
                  ach);
            Print("\tdwUserData         0x%p\n",
                  (ULONG_PTR)ReadField(dwUserData));
            Print("\tstate              0x%08lx\n"
                  "\tstate2             0x%08lx\n"
                  "\tExStyle            0x%08lx\n"
                  "\tstyle              0x%08lx\n"
                  "\tfnid               0x%08lx\n"
                  "\thImc               0x%08p\n"
                  "\tbFullScreen        0y%d\n"
                  "\thModule            0x%08lx\n"
#ifdef LAME_BUTTON
                  "\tpStackTrace        0x%p\n"
#endif // LAME_BUTTON
                  "\tpActCtx            0x%p\n",
                  ww.state,
                  ww.state2,
                  ww.ExStyle,
                  ww.style,
                  (DWORD)(WORD)ReadField(fnid),
                  ReadField(hImc),
                  TestWWF(&ww, WFFULLSCREENMASK),
                  ReadField(hModule),
#ifdef LAME_BUTTON
                  ReadField(pStackTrace),
#endif // LAME_BUTTON
                  ReadField(pActCtx));
        }

        /*
         * Print out all the flags
         */
        if (opts & OFLAG(f)) {
            int i;
            WORD wFlag;
            ULONG cbHead;
            PBYTE pbyte = (PBYTE)(&(ww.state));

            cbHead = GetTypeSize(SYM(THRDESKHEAD));
            for (i = 0; i < ARRAY_SIZE(aWindowFlags); i++) {
                wFlag = aWindowFlags[i].wFlag;
                if (pbyte[HIBYTE(wFlag)] & LOBYTE(wFlag)) {
                    Print("\t%-18s\t%p:%02lx\n",
                            aWindowFlags[i].pszText,
                            pwnd + cbHead + HIBYTE(wFlag),
                            LOBYTE(wFlag));
                }
            }
        }

        if (opts & OFLAG(w)) {
            ULONG cbwnd = GetTypeSize(SYM(WND));
            ULONG cbwndExtra = (ULONG)ReadField(cbwndExtra);

            Print("\t%d window bytes: ", cbwndExtra);
            if (cbwndExtra) {
                for (ix=0; ix < cbwndExtra; ix += 4) {
                     PTR pdw;

                     pdw = pwnd + cbwnd + ix;
                     move(tempDWord, pdw);
                     Print("%08x ", tempDWord);
                }
            }
            Print("\n");
        }

        /*
         * Print window properties.
         */
        if (opts & OFLAG(o)) {
            PTR     psi;
            PTR     ppropList;
            ULONG       iFirstFree;
            ULONG       cEntries;
            ULONG       cbProp;
            ULONG       cbOffset;
            PTR     pprop;
            UINT        i, j;

            struct {
                LPSTR   pstrName;
                ATOM    atom;
                BOOLEAN bGlobal;
                LPSTR   pstrSymbol;
            } apropatom[] =
            {
                "Icon",         0,  FALSE, "atomIconProp",
                "IconSM",       0,  FALSE, "atomIconSmProp",
                "ContextHelpID",0,  FALSE, "atomContextHelpIdProp",
                "Checkpoint",   0,  TRUE,  VAR(atomCheckpointProp),
                "Flash State",  0,  TRUE,  VAR(gaFlashWState),
                "DDETrack",     0,  TRUE,  VAR(atomDDETrack),
                "QOS",          0,  TRUE,  VAR(atomQOS),
                "DDEImp",       0,  TRUE,  VAR(atomDDEImp),
                "WNDOBJ",       0,  TRUE,  VAR(atomWndObj),
                "IMELevel",     0,  TRUE,  VAR(atomImeLevel),
            };


            /*
             * Get the atom values for internal properties and put them in apropatom.atom
             */
            psi = GetGlobalPointer(VAR(gpsi));
            for (i = 0; i < ARRAY_SIZE(apropatom); i++) {
                if (!apropatom[i].bGlobal) {

                    /*
                     * The atom is stored in psi.
                     */
                    GetFieldValue(psi, SYM(SERVERINFO), apropatom[i].pstrSymbol, apropatom[0].atom);
                } else {

                    /*
                     * The atom is a global.
                     */
                    moveExpValue(&apropatom[i].atom, apropatom[i].pstrSymbol);
                }
            }

            /*
             * Print the property list structure.
             */
            GetFieldValue(pwnd, SYM(WND), "ppropList", ppropList);
            if (!ppropList) {
                Print("\tNULL Property List\n");
            } else {
                _InitTypeRead(ppropList, SYM(tagPROPLIST));
                iFirstFree = (ULONG)ReadField(iFirstFree);
                cEntries = (ULONG)ReadField(cEntries);
                Print("\tProperty List @ 0x%p : %d Properties, %d total entries, %d free entries\n",
                        ppropList,
                        iFirstFree,
                        cEntries,
                        cEntries - iFirstFree);

                /*
                 * Print each property.
                 */
                GetFieldOffset(SYM(PROPLIST), "aprop", &cbOffset);
                pprop = ppropList + cbOffset;
                cbProp = GetTypeSize(SYM(tagPROP));
                for (i = 0; !IsCtrlCHit() && i < iFirstFree; i++, pprop += cbProp) {
                    LPSTR pstrInternal;

                    _InitTypeRead(pprop, SYM(tagPROP));

                    /*
                     * Find name for internal property.
                     */
                    pstrInternal = "";
                    if (ReadField(fs) & PROPF_INTERNAL) {
                        for (j = 0; j < ARRAY_SIZE(apropatom); j++) {
                            if (ReadField(atomKey) == apropatom[j].atom) {
                                pstrInternal = apropatom[j].pstrName;
                                break;
                            }
                        }
                    }

                    Print("\tProperty %d\n", i);
                    Print("\t\tatomKey     0x%04x %s\n", (ULONG)ReadField(atomKey), pstrInternal);
                    Print("\t\tfs          0x%04x %s\n", (ULONG)ReadField(fs), GetFlags(GF_PROP, (DWORD)ReadField(fs), NULL, FALSE));
                    Print("\t\thData       0x%p (%I64d)\n", ReadField(hData), ReadField(hData));

            #ifdef KERNEL
                    if (ReadField(fs) & PROPF_INTERNAL) {
                        if (j == 3) {
                            CHECKPOINT  cp;
                            PTR pcp = ReadField(hData);
                            move(cp, pcp);
                            Print("\t\tCheckPoint:\n");
                            Print("\t\trcNormal (%d,%d),(%d,%d) %dx%d\n",
                                    cp.rcNormal.left,
                                    cp.rcNormal.top,
                                    cp.rcNormal.right,
                                    cp.rcNormal.bottom,
                                    cp.rcNormal.right - cp.rcNormal.left,
                                    cp.rcNormal.bottom - cp.rcNormal.top);

                            Print("\t\tptMin    (%d,%d)\n",                cp.ptMin.x, cp.ptMin.y);
                            Print("\t\tptMax    (%d,%d)\n",                cp.ptMax.x, cp.ptMax.y);
                            Print("\t\tfDragged:%d\n",                     cp.fDragged);
                            Print("\t\tfWasMaximizedBeforeMinimized:%d\n", cp.fWasMaximizedBeforeMinimized);
                            Print("\t\tfWasMinimizedBeforeMaximized:%d\n", cp.fWasMinimizedBeforeMaximized);
                            Print("\t\tfMinInitialized:%d\n",              cp.fMinInitialized);
                            Print("\t\tfMaxInitiailized:%d\n",             cp.fMaxInitialized);
                        }
                    }
            #endif // ifdef KERNEL

                    Print("\n");
                }
            }
        }

        Print("---\n");

    } except (CONTINUE) {
    }

    return TRUE;
}

#ifdef KERNEL

/***************************************************************************\
* dws   - dump windows stations
* dws h - dump windows stations plus handle list
*
* Dump WindowStation
*
* 8-11-94 SanfordS  Created
* 6/9/1995 SanfordS made to fit stdexts motif
\***************************************************************************/
BOOL Idws(
    DWORD opts,
    ULONG64 param1)
{
    PTR pwinsta;
    WCHAR ach[80];
    PTR pHead;
    PTR pNameBuffer;
    ULONG ObjectHeaderOffset;
    UCHAR NameInfoOffset;
    PTR NameBuffer;
    ULONG NameLength;
    ULONG cOpen;
    DWORD sid;  // session id

    UNREFERENCED_PARAMETER(opts);

    if (param1 == 0) {

        FOREACHWINDOWSTATION(pwinsta)

            Idws(0, pwinsta);
            Print("\n");

        NEXTEACHWINDOWSTATION(pwinsta)

        return TRUE;
    }

    pwinsta = param1;

    GetFieldOffset("nt!OBJECT_HEADER", "Body", &ObjectHeaderOffset);
    pHead = pwinsta - ObjectHeaderOffset;
    GetFieldValue(pHead, "nt!OBJECT_HEADER", "NameInfoOffset", NameInfoOffset);
    pNameBuffer = pHead - NameInfoOffset;
    GetFieldValue(pNameBuffer, "nt!OBJECT_HEADER_NAME_INFO", "Name.Buffer", NameBuffer);
    GetFieldValue(pNameBuffer, "nt!OBJECT_HEADER_NAME_INFO", "Name.Length", NameLength);
    moveBlock(ach, FIXKP(NameBuffer), NameLength);
    ach[NameLength / sizeof(WCHAR)] = L'\0';


    GetFieldValue(pwinsta, SYM(tagWINDOWSTATION), "dwSessionId", sid);
    Print("Windowstation: %ws @ 0x%p  sid: 0n%d\n", ach, pwinsta, sid);
    Print(" OBJECT_HEADER @ 0x%p\n", pHead);

    GetFieldValue(pHead, "nt!OBJECT_HEADER", "HandleCount", cOpen);
    Print("  HandleCount        = 0n%d\n", cOpen);
    GetFieldValue(pHead, "nt!OBJECT_HEADER", "PointerCount", cOpen);
    Print("  PointerCount       = 0n%d\n", cOpen);

    _InitTypeRead(pwinsta, SYM(tagWINDOWSTATION));
    Print("  pTerm              = %p\n", ReadField(pTerm));
    Print("  rpdeskList         = %p\n", ReadField(rpdeskList));
    Print("  dwFlags            = %s\n", GetFlags(GF_WINDOWSTATIONFLAGS, (DWORD)ReadField(dwWSF_Flags), NULL, TRUE));
    Print("  spklList           = %p\n", ReadField(spklList));
    Print("  ptiClipLock        = %p\n", ReadField(ptiClipLock));
    Print("  spwndClipOpen      = %p\n", ReadField(spwndClipOpen));
    Print("  spwndClipViewer    = %p\n", ReadField(spwndClipViewer));
    Print("  spwndClipOwner     = %p\n", ReadField(spwndClipOwner));
    Print("  pClipBase          = %p\n", ReadField(pClipBase));
    Print("  cNumClipFormats    = 0x%0lx\n", (DWORD)ReadField(cNumClipFormats));
    Print("  ptiDrawingClipboard= %p\n", ReadField(ptiDrawingClipboard));
    Print("  fClipboardChanged  = %d\n",   ReadField(fClipboardChanged));
    Print("  pGlobalAtomTable   = %p\n", ReadField(pGlobalAtomTable));
    Print("  luidUser           = %0lx.%lx\n", (ULONG)ReadField(luidUser.HighPart),
                                               (ULONG)ReadField(luidUser.LowPart));

    return TRUE;
}

#endif

#ifdef OLD_DEBUGGER

#ifdef KERNEL
/************************************************************************\
* Idwpi
*
* Dumps WOWPROCESSINFO structs
*
* 6/9/1995 Created SanfordS
\************************************************************************/
BOOL Idwpi(
    DWORD opts,
    ULONG64 param1)
{
    PWOWPROCESSINFO pwpi;
    WOWPROCESSINFO wpi;
    PPROCESSINFO ppi;

    if (param1 == 0) {
        FOREACHPPI(ppi)
            Print("Process %p.\n", FIXKP(ppi));
            move(pwpi, FIXKP(&ppi->pwpi));
            SAFEWHILE (pwpi) {
                Idwpi(0, pwpi);
                Print("\n");
                move(pwpi, FIXKP(&pwpi->pwpiNext));
            }
        NEXTEACHPPI()
        return TRUE;
    }

    if (opts & OFLAG(p)) {
        ppi = (PPROCESSINFO)FIXKP(param1);
        move(pwpi, &ppi->pwpi);
        if (pwpi == NULL) {
            Print("No pwpis for this process.\n");
            return TRUE;
        }
        SAFEWHILE (pwpi) {
            Idwpi(0, pwpi);
            Print("\n");
            move(pwpi, &pwpi->pwpiNext);
        }
        return TRUE;
    }

    pwpi = (PWOWPROCESSINFO)FIXKP(param1);
    move(wpi, pwpi);

    Print("PWOWPROCESSINFO @ 0x%p\n", pwpi);
    Print("\tpwpiNext             0x%08lx\n", wpi.pwpiNext);
    Print("\tptiScheduled         0x%08lx\n", wpi.ptiScheduled);
    Print("\tptdbHead             0x%08lx\n", wpi.ptdbHead);
    Print("\tlpfnWowExitTask      0x%08lx\n", wpi.lpfnWowExitTask);
    Print("\tpEventWowExec        0x%08lx\n", wpi.pEventWowExec);
    Print("\thEventWowExecClient  0x%08lx\n", wpi.hEventWowExecClient);
    Print("\tnSendLock            0x%08lx\n", wpi.nSendLock);
    Print("\tnRecvLock            0x%08lx\n", wpi.nRecvLock);
    Print("\tCSOwningThread       0x%08lx\n", wpi.CSOwningThread);
    Print("\tCSLockCount          0x%08lx\n", wpi.CSLockCount);
    return TRUE;
}
#endif // KERNEL

#ifdef KERNEL

BOOL DHAVerifyHeap(
    PWIN32HEAP pHeap,
    BOOL bVerbose)
{
    DbgHeapHead Alloc, *pAlloc = pHeap->pFirstAlloc;
    int sizeHead, counter = 0;
    char szHeadOrTail[HEAP_CHECK_SIZE];

    if (pAlloc == NULL) {
        return FALSE;
    }

    sizeHead = pHeap->dwFlags & WIN32_HEAP_USE_GUARDS ?
               sizeof(pHeap->szHead) : 0;

    do {
        if (!tryMove(Alloc, pAlloc)) {
            Print("Failed to read pAlloc from %p\n", pAlloc);
            return FALSE;
        }
        /*
         * Check the mark, header and tail
         */
        if (Alloc.mark != HEAP_ALLOC_MARK) {
            Print("!!! Bad mark found in allocation use !dso DbgHeapHead %p\n", pAlloc);
        }
        if (sizeHead) {
            if (!tryMove(szHeadOrTail, (PBYTE)pAlloc-sizeof(szHeadOrTail))) {
                Print("Failed to read szHead from %p\n", (PBYTE)pAlloc-sizeof(szHeadOrTail));
                return FALSE;
            }
            if (!RtlEqualMemory(szHeadOrTail, pHeap->szHead, sizeHead)) {
                Print("Head pattern corrupted for allocation %#p\n", pAlloc);
            }
            if (!tryMove(szHeadOrTail, (PBYTE)pAlloc + sizeof(DbgHeapHead) + Alloc.size)) {
                Print("Failed to read szHead from %p\n", (PBYTE)pAlloc + sizeof(DbgHeapHead) + Alloc.size);
                return FALSE;
            }
            if (!RtlEqualMemory(szHeadOrTail, pHeap->szTail, sizeHead)) {
                Print("Tail pattern corrupted for allocation %#p\n", pAlloc);
            }
        }
        if (bVerbose) {
            Print("Allocation %#p, tag %04d size %08d\n", pAlloc, Alloc.tag, Alloc.size);
        }
        if (counter++ > 100) {
            Print(".");
            counter = 0;
        }
        pAlloc = Alloc.pNext;
    } while (pAlloc != NULL);

    if (bVerbose) {
        Print("To dump an allocation use \"dt DBGHEAPHEAD address\"\n");
    }

    return TRUE;
}

/************************************************************************\
* Idha
*
* Walks the global array of heaps gWin32Heaps looking for an allocation that
* contain the address passed in.  Then does a sanity check on the entire heap
* the allocations belongs to. DHAVerifyHeap is a helper procedure.  Note that
* the passed in parameter is already mapped.
*
* 12/7/1998 Created MCostea
\************************************************************************/
BOOL Idha(
    DWORD opts,
    PVOID pointer)
{
    int ind, counter;
    SIZE_T sizeHead;
    WIN32HEAP localgWin32Heaps[MAX_HEAPS];

    if (pointer == 0 && (opts & OFLAG(a) ==0)) {
        Print("Wrong usage: dha takes a pointer as a parameter\n");
        return FALSE;
    }

    if (!tryMoveBlock(localgWin32Heaps, EvalExp(VAR(gWin32Heaps)), sizeof(localgWin32Heaps)))
    {
        Print("Can't read the heap globals fix symbols and !reload win32k.sys\n");
        return TRUE;
    }

    /*
     * Walk gWin32Heaps array and look for an allocation containing this pointer
     */
    for (ind = counter = 0; ind < MAX_HEAPS; ind++) {

        /*
         * Is the address in this heap?
         */
        if ((opts & OFLAG(a)) == 0) {
            if ((PVOID)localgWin32Heaps[ind].heap > pointer ||
                (PBYTE)localgWin32Heaps[ind].heap + localgWin32Heaps[ind].heapReserveSize < (PBYTE)pointer) {

                continue;
            }
        }

        Print("\nHeap number %d ", ind);
        Print("at address %p, flags %d is ", localgWin32Heaps[ind].heap, localgWin32Heaps[ind].dwFlags);


        if (localgWin32Heaps[ind].dwFlags & WIN32_HEAP_INUSE) {

            DbgHeapHead  Alloc, *pAlloc;

            Print("in use\n");
            if (localgWin32Heaps[ind].pFirstAlloc == NULL)
                continue;

            pAlloc = localgWin32Heaps[ind].pFirstAlloc;
            if (localgWin32Heaps[ind].dwFlags & WIN32_HEAP_USE_GUARDS) {
                sizeHead =  sizeof(localgWin32Heaps[0].szHead);
                Print("    has string quards szHead %s, szTail %s\n",
                        localgWin32Heaps[0].szHead,
                        localgWin32Heaps[0].szTail);
            } else {
                sizeHead =  0;
                Print("no string quards\n");
            }

            if (opts & OFLAG(a)) {
                if (DHAVerifyHeap(&localgWin32Heaps[ind], opts & OFLAG(v))) {
                    Print("WIN32HEAP at %p is healthy\n", localgWin32Heaps[ind].heap);
                }
                continue;
            }
            do {
                if (!tryMove(Alloc, pAlloc)) {
                    Print("Failed to read pAlloc %p\n", pAlloc);
                    return TRUE;
                }
                if ((PBYTE)pAlloc - sizeHead < (PBYTE)pointer &&
                    (PBYTE)pAlloc + sizeof(DbgHeapHead) + Alloc.size + sizeHead > (PBYTE)pointer) {

                    /*
                     * Found the allocation
                     */
                    Print("Found allocation %p ", pAlloc);
                    if (pointer == (PBYTE)pAlloc + sizeof(DbgHeapHead)) {
                        Print("as the begining of a heap allocated block\n");
                    } else {
                        Print("inside a heap allocated block\n");
                    }
                    Print("tag %04d size %08d now verify the heap\n", Alloc.tag, Alloc.size);
                    /*
                     * Verify the entire heap for corruption
                     */
                    if (DHAVerifyHeap(&localgWin32Heaps[ind], opts & OFLAG(v))) {
                        Print("WIN32HEAP at %p is healthy\n", localgWin32Heaps[ind].heap);
                    }
                    return TRUE;
                } else {
                    pAlloc = Alloc.pNext;
                    if (counter++ > 100) {
                        counter = 0;
                        Print(".");
                    }
                }

            } while (pAlloc != NULL);
        } else {
            Print("NOT in use\n");
        }
    }
    Print("No heap contains this pointer %p\n", pointer);
    return TRUE;
}
#endif // KERNEL
#endif // OLD_DEBUGGER

#ifdef KERNEL
/***************************************************************************\
* ddl   - dump desktop log
*
* 12-03-97 CLupu  Created
\***************************************************************************/
BOOL Iddl(
    DWORD opts,
    ULONG64 param1)
{
#ifdef LOGDESKTOPLOCKS
    PTR                     pdesk, pLog, pObjHeader, pStack, ptr, dwOffset64;
    ULONG                   dwOffset, dwTraceOffset, dwPVOIDSize, dwLogDSize;
    OBJECT_HEADER           Head;
    BOOL                    bExtra = FALSE;
    int                     i, ind, nLockCount, nLogCrt;
    LONG                    HandleCount, PointerCount;
    WORD                    type, tag;
    CHAR                    symbol[160];
    ULONG_PTR               extra;

    if (param1 == 0) {
        Print("Use !ddl pdesk\n");
        return TRUE;
    }

    pdesk = param1;
    GetFieldOffset("nt!OBJECT_HEADER", "Body", &dwOffset);
    pObjHeader = pdesk - dwOffset;

    Print("Desktop locks:\n\n");
    GetFieldValue(pObjHeader, "nt!OBJECT_HEADER", "HandleCount", HandleCount);
    GetFieldValue(pObjHeader, "nt!OBJECT_HEADER", "PointerCount", PointerCount);
    Print("# HandleCount      = %d\n", HandleCount);
    Print("# PointerCount     = %d\n", PointerCount);

    if (GetFieldValue(pdesk, SYM(DESKTOP), "nLockCount", nLockCount)) {
        Print("Couldn't get PointerCount for pdesk %p\n", pdesk);
    }
    Print("# Log PointerCount = %d\n\n", nLockCount);

    GetFieldValue(pdesk, SYM(DESKTOP), "pLog", pLog);

    if (opts & OFLAG(v)) {
        bExtra = TRUE;
    }

    dwLogDSize = GetTypeSize("LogD");
    dwPVOIDSize = GetTypeSize("PVOID");
    GetFieldOffset(SYM(LogD), "trace", &dwTraceOffset);
    GetFieldValue(pdesk, SYM(DESKTOP), "nLogCrt", nLogCrt);
    for (i = 0; i < nLogCrt; i++) {
        if (IsCtrlCHit()) {
            break;
        }
        GetFieldValue(pLog, "LogD", "tag", tag);
        GetFieldValue(pLog, "LogD", "type", type);
        GetFieldValue(pLog, "LogD", "extra", extra);

        Print("%s Tag %6d Extra %8lx\n",
              (type ? "LOCK  " : "UNLOCK"),
               tag, extra);

        if (bExtra) {
            Print("----------------------------------------------\n");

            for (ind = 0; ind < 6; ind++) {
                pStack = pLog + dwTraceOffset + dwPVOIDSize * ind;
                ReadPointer(pStack, &ptr);
                if (ptr == 0) {
                    break;
                }

                GetSym(ptr, symbol, &dwOffset64);
                if (*symbol) {
                    Print("\t%s", symbol);
                    if (dwOffset64) {
                        Print(" +0x%x\n", (ULONG)dwOffset64);
                    }
                }
            }
            Print("\n");
        }
        pLog += dwLogDSize;
    }
    return TRUE;
#else
    Print("!ddl is available only on LOGDESKTOPLOCKS enabled builds of win32k.sys\n");
    return FALSE;
    UNREFERENCED_PARAMETER(opts);
    UNREFERENCED_PARAMETER(param1);
#endif // LOGDESKTOPLOCKS
}
#endif // KERNEL

#ifdef KERNEL
/***************************************************************************\
* dcss   - dump critical section stack
*
* Dump critical section stack
*
* 12-27-1996 CLupu    Created
* 06-26-2001 JasonSch Made Win64-clean.
\***************************************************************************/
BOOL Idcss(
    DWORD opts)
{
    int        nFrames;
    PTR        pStack;

    UNREFERENCED_PARAMETER(opts);

    moveExp(&pStack, SYM(gCritStack));
    _InitTypeRead(pStack, SYM(CRITSTACK));

    if ((nFrames = (int)ReadField(nFrames)) > 0) {

        DumpThread(0, ReadField(thread));
#if 0
        Print("\nthread : 0x%p\n", ReadField(thread));
#endif
        Print("--- Critical section stack trace ---\n");

        PrintStackTrace(ReadField(trace), nFrames);
    }

    return TRUE;
}

BOOL Idvs(
    DWORD opts,
    ULONG64 param1)
{
    ULONG64       pSection;
    ULONG64       pView;
    BOOL          bIncludeStackTrace = FALSE;

    UNREFERENCED_PARAMETER(opts);
    UNREFERENCED_PARAMETER(param1);

    if (EvalExp(VAR(gpSections)) == 0) {
        Print("!dvs is available if TRACE_MAP_VIEWS is defined\n");
        return FALSE;
    }

    pSection = GetGlobalPointer(VAR(gpSections));

    if (opts & OFLAG(s)) {
        bIncludeStackTrace = TRUE;
    }

    while (pSection != 0) {
        _InitTypeRead(pSection, SYM(tagWin32Section));
        Print(">>--------------------------------------\n");

        Print("Section          %#p\n"
              "   pFirstView    %#p\n"
              "   SectionObject %#p\n"
              "   SectionSize   0x%x\n"
              "   SectionTag    0x%x\n",
              pSection,
              ReadField(pFirstView),
              ReadField(SectionObject),
              ReadField(SectionSize),
              ReadField(SectionTag));

        if (bIncludeStackTrace) {
#ifdef MAP_VIEW_STACK_TRACE
            PrintStackTrace(ReadField(trace), MAP_VIEW_STACK_TRACE_SIZE);
            Print("\n");
#endif // MAP_VIEW_STACK_TRACE
        }

        pView = ReadField(pFirstView);

        while (pView != 0) {
            _InitTypeRead(pView, SYM(tagWin32MapView));
            Print("Views: ---------------------------------\n"
                  " View          %#p\n"
                  "    pViewBase  %#p\n"
                  "    ViewSize   %#p\n",
                  pView,
                  ReadField(pViewBase),
                  ReadField(View.ViewSize));

            if (bIncludeStackTrace) {
#ifdef MAP_VIEW_STACK_TRACE
                PrintStackTrace(ReadField(trace), MAP_VIEW_STACK_TRACE_SIZE);
                Print("\n");
#endif // MAP_VIEW_STACK_TRACE
            }
            GetFieldValue(pView, SYM(tagWin32MapView), "pNext", pView);
        }
        GetFieldValue(pSection, SYM(tagWin32Section), "pNext", pSection);
    }

    return TRUE;
}

#ifdef OLD_DEBUGGER
BOOL Idfa(
    DWORD opts,
    ULONG64 param1)
{
    ULONG64    dwOffset;
    CHAR       symbol[160];
    int        ind;
    PVOID*     pTrace;
    PVOID      trace;
    DWORD      dwAllocFailIndex;
    DWORD*     pdwAllocFailIndex;
    PEPROCESS  pep;
    PEPROCESS* ppep;
    PETHREAD   pet;
    PETHREAD*  ppet;

    UNREFERENCED_PARAMETER(opts);
    UNREFERENCED_PARAMETER(param1);

    if (EvalExp(VAR(gdwAllocFailIndex)) == NULL) {
        Print("!dfa is available only in debug versions of win32k.sys\n");
        return FALSE;
    }

    moveExp(&pdwAllocFailIndex, VAR(gdwAllocFailIndex));
    if (!tryMove(dwAllocFailIndex, pdwAllocFailIndex)) {
        Print("dfa failure");
        return FALSE;
    }

    moveExp(&ppep, VAR(gpepRecorded));
    if (!tryMove(pep, ppep)) {
        Print("dfa failure");
        return FALSE;
    }
    moveExp(&ppet, VAR(gpetRecorded));
    if (!tryMove(pet, ppet)) {
        Print("dfa failure");
        return FALSE;
    }

    Print("Fail allocation index %d 0x%04x\n", dwAllocFailIndex, dwAllocFailIndex);
    Print("pEProcess %#p pEThread %#p\n\n", pep, pet);

    moveExp(&pTrace, VAR(gRecordedStackTrace));

    for (ind = 0; ind < 12; ind++) {

        if (!tryMove(trace, pTrace)) {
            Print("dfa failure");
            return FALSE;
        }

        if (trace == 0) {
            break;
        }

        GetSym((PVOID)trace, symbol, &dwOffset);
        if (*symbol) {
            Print("\t%s", symbol);
            if (dwOffset) {
                Print("+%p\n", dwOffset);
            }
        }

        pTrace++;
    }
    Print("\n");
    return TRUE;
}
#endif // OLD_DEBUGGER

VOID PrintStackTrace(
    PTR pStackTrace,
    int    tracesCount)
{
    int       traceInd;
    ULONG64   dwOffset, pSymbol;
    CHAR      symbol[160];
    DWORD     dwPointerSize = GetTypeSize("PVOID");

    for (traceInd = 0; traceInd < tracesCount; traceInd++) {
        ReadPointer(pStackTrace, &pSymbol);
        if (pSymbol == 0) {
            break;
        }

        GetSym(pSymbol, symbol, &dwOffset);
        if (*symbol) {
            Print("\t%s", symbol);
            if (dwOffset) {
                Print("+%p\n", dwOffset);
            } else {
                Print("\n");
            }
        }

        pStackTrace += dwPointerSize;
    }
    Print("\n");
}

/***************************************************************************\
* dpa - dump pool allocations
*
* Dump pool allocations.
*
* 12-27-96 CLupu  Created
\***************************************************************************/
BOOL Idpa(
    DWORD opts,
    ULONG64 param1)
{
    try {
        PTR              pAllocList;
        DWORD            dwPoolFlags;
        DWORD            dwSize = GetTypeSize(SYM(tagWin32PoolHead));
        BOOL             bIncludeStackTrace = FALSE;

        moveExpValue(&dwPoolFlags, VAR(gdwPoolFlags));
        if (!(dwPoolFlags & POOL_HEAVY_ALLOCS)) {
            Print("win32k.sys doesn't have pool instrumentation !\n");
            return FALSE;
        }

        if (opts & OFLAG(s)) {
            if (dwPoolFlags & POOL_CAPTURE_STACK) {
                bIncludeStackTrace = TRUE;
            } else {
                Print("win32k.sys doesn't have stack traces enabled for pool allocations\n");
            }
        }

        moveExp(&pAllocList, VAR(gAllocList));
        if (!pAllocList) {
            Print("Could not get Win32AllocStats structure win32k!gAllocList\n");
            return FALSE;
        }

        _InitTypeRead(pAllocList, SYM(tagWin32AllocStats));
        if (opts & OFLAG(c)) {
            Print("- pool instrumentation enabled for win32k.sys\n");
            if (dwPoolFlags & POOL_CAPTURE_STACK) {
                Print("- stack traces enabled for pool allocations\n");
            } else {
                Print("- stack traces disabled for pool allocations\n");
            }


            if (dwPoolFlags & POOL_KEEP_FAIL_RECORD) {
                Print("- records of failed allocations enabled\n");
            } else {
                Print("- records of failed allocations disabled\n");
            }

            if (dwPoolFlags & POOL_KEEP_FREE_RECORD) {
                Print("- records of free pool enabled\n");
            } else {
                Print("- records of free pool disabled\n");
            }

            Print("\n");

            Print("    CrtM         CrtA         MaxM         MaxA       Head\n");
            Print("------------|------------|------------|------------|------------|\n");
            _InitTypeRead(pAllocList, SYM(Win32AllocStats));
            Print(" 0x%08x   0x%08x   0x%08x   0x%08x   0x%I64x\n",
                  (ULONG)ReadField(dwCrtMem),
                  (ULONG)ReadField(dwCrtAlloc),
                  (ULONG)ReadField(dwMaxMem),
                  (ULONG)ReadField(dwMaxAlloc),
                  ReadField(pHead));

            return TRUE;
        }

        _InitTypeRead(pAllocList, SYM(tagWin32AllocStats));
        if (opts & OFLAG(f)) {

            DWORD        dwFailRecordCrtIndex, dwFailRecordTotalFailures;
            DWORD        dwFailRecords, Ind, dwFailuresToDump;
            PTR          pFailRecord, pFailRecordOrg;

            if (!(dwPoolFlags & POOL_KEEP_FAIL_RECORD)) {
                Print("win32k.sys doesn't have records of failed allocations!\n");
                return TRUE;
            }

            dwFailRecordTotalFailures = (DWORD)EvalExp(VAR(gdwFailRecordTotalFailures));
            if (dwFailRecordTotalFailures == 0) {
                Print("No allocation failure in win32k.sys!\n");
                return TRUE;
            }

            dwFailRecordCrtIndex = (DWORD)EvalExp(VAR(gdwFailRecordCrtIndex));
            dwFailRecords = (DWORD)EvalExp(VAR(gdwFailRecords));
            if (dwFailRecordTotalFailures < dwFailRecords) {
                dwFailuresToDump = dwFailRecordTotalFailures;
            } else {
                dwFailuresToDump = dwFailRecords;
            }

            pFailRecord = GetGlobalPointer(VAR(gparrFailRecord));
            if (!pFailRecord) {
                Print("\nCouldn't get gparrFailRecord!\n");
                return FALSE;
            }

            pFailRecordOrg = pFailRecord;

            Print("\nFailures to dump : %d\n\n", dwFailuresToDump);

            for (Ind = 0; Ind < dwFailuresToDump; Ind++) {
                DWORD      tag[2] = {0, 0};

                if (dwFailRecordCrtIndex == 0) {
                    dwFailRecordCrtIndex = dwFailRecords - 1;
                } else {
                    dwFailRecordCrtIndex--;
                }

                pFailRecord = pFailRecordOrg + dwFailRecordCrtIndex;

                _InitTypeRead(pFailRecord, SYM(tagPOOLRECORD));

                tag[0] = (DWORD)(DWORD_PTR)ReadField(ExtraData);

                Print("Allocation for tag '%s' size 0x%x failed\n",
                      &tag,
                      (ULONG)ReadField(size));

                PrintStackTrace(ReadField(pTrace), RECORD_STACK_TRACE_SIZE);
            }
        }

        _InitTypeRead(pAllocList, SYM(tagWin32AllocStats));
        if (opts & OFLAG(r)) {

            DWORD        dwFreeRecordCrtIndex, dwFreeRecordTotalFrees;
            DWORD        dwFreeRecords, Ind, dwFreesToDump;
            PTR          pFreeRecord, pFreeRecordOrg;

            if (!(dwPoolFlags & POOL_KEEP_FREE_RECORD)) {
                Print("win32k.sys doesn't have records of free pool !\n");
                return FALSE;
            }

            dwFreeRecordTotalFrees = (DWORD)EvalExp(VAR(gdwFreeRecordTotalFrees));
            if (dwFreeRecordTotalFrees == 0) {
                Print("No free pool in win32k.sys !\n");
                return FALSE;
            }

            dwFreeRecordCrtIndex = (DWORD)EvalExp(VAR(gdwFreeRecordCrtIndex));
            dwFreeRecords = (DWORD)EvalExp(VAR(gdwFreeRecords));
            if (dwFreeRecordTotalFrees < dwFreeRecords) {
                dwFreesToDump = dwFreeRecordTotalFrees;
            } else {
                dwFreesToDump = dwFreeRecords;
            }

            pFreeRecord = GetGlobalPointer(VAR(gparrFreeRecord));
            if (!pFreeRecord) {
                Print("\nCouldn't get gparrFreeRecord!\n");
                return FALSE;
            }

            pFreeRecordOrg = pFreeRecord;

            Print("\nFrees to dump : %d\n\n", dwFreesToDump);

            for (Ind = 0; Ind < dwFreesToDump; Ind++) {
                if (dwFreeRecordCrtIndex == 0) {
                    dwFreeRecordCrtIndex = dwFreeRecords - 1;
                } else {
                    dwFreeRecordCrtIndex--;
                }

                pFreeRecord = pFreeRecordOrg + dwFreeRecordCrtIndex;

                /*
                 * Dump
                 */
                _InitTypeRead(pFreeRecord, SYM(tagPOOLRECORD));
                Print("Free pool for p %#p size 0x%x\n",
                      ReadField(ExtraData),
                      (ULONG)ReadField(size));

                PrintStackTrace(ReadField(pTrace), RECORD_STACK_TRACE_SIZE);
            }
        }

        _InitTypeRead(pAllocList, SYM(tagWin32AllocStats));
        if (opts & OFLAG(v)) {
            PTR ph = ReadField(pHead);

            while (ph != 0) {
                _InitTypeRead(ph, SYM(tagWin32PoolHead));
                Print("p %#p pHead %#p size %x\n",
                      ph + dwSize, ph, (ULONG)ReadField(size));

                if (bIncludeStackTrace) {
                    PrintStackTrace(ReadField(pTrace), RECORD_STACK_TRACE_SIZE);
                }

                ph = (ULONG_PTR)ReadField(pNext);
            }
            return TRUE;
        }

        _InitTypeRead(pAllocList, SYM(tagWin32AllocStats));
        if (opts & OFLAG(p)) {
            PTR ph;
            DWORD dwSize = GetTypeSize(SYM(tagWin32PoolHead));

            if (param1 == 0) {
                return TRUE;
            }

            ph = ReadField(pHead);
            while (ph != 0) {
                if ((param1 - ph) >= ((ULONG)ReadField(size) + dwSize)) {
                    Print("p %#p pHead %#p size %x\n",
                          ph + 1, ph, (ULONG)ReadField(size));

                    PrintStackTrace(ReadField(pTrace), RECORD_STACK_TRACE_SIZE);
                    return TRUE;
                }

                ph = ReadField(pNext);
            }
            return TRUE;
        }
    } except (CONTINUE) {
    }
    return TRUE;
}
#endif // KERNEL


#ifdef OLD_DEBUGGER
/************************************************************************\
* Ifno
*
* Find Nearest Objects - helps in figureing out references
* to freed objects or stale pointers.
*
* 6/9/1995 Created SanfordS
\************************************************************************/
BOOL Ifno(
    DWORD opts,
    ULONG64 param1)
{
    HANDLEENTRY he, heBest, heAfter, *phe;
    DWORD i;
    DWORD hBest, hAfter;
    DWORD_PTR dw;

    UNREFERENCED_PARAMETER(opts);

    if (param1 == 0) {
        Print("Expected an address.\n");
        return FALSE;
    }

    dw = (DWORD_PTR)FIXKP(param1);
    heBest.phead = NULL;
    heAfter.phead = (PVOID)-1;

    if (dw != (DWORD_PTR)param1) {
        /*
         * no fixups needed - he's looking the kernel address range.
         */
        FOREACHHANDLEENTRY(phe, he, i)
            if ((DWORD_PTR)he.phead <= dw &&
                    heBest.phead < he.phead &&
                    he.bType != TYPE_FREE) {
                heBest = he;
                hBest = i;
            }
            if ((DWORD_PTR)he.phead > dw &&
                    heAfter.phead > he.phead &&
                    he.bType != TYPE_FREE) {
                heAfter = he;
                hAfter = i;
            }
        NEXTEACHHANDLEENTRY()

        if (heBest.phead != NULL) {
            Print("Nearest guy before %#p is a %s object located at %#p (i=%x).\n",
                    dw, aszTypeNames[heBest.bType], heBest.phead, hBest);
        }
        if (heAfter.phead != (PVOID)-1) {
            Print("Nearest guy after %#p is a %s object located at %#p. (i=%x)\n",
                    dw, aszTypeNames[heAfter.bType], heAfter.phead, hAfter);
        }
    } else {
        /*
         * fixups are needed.
         */
        FOREACHHANDLEENTRY(phe, he, i)
            if ((DWORD_PTR)FIXKP(he.phead) <= dw &&
                    heBest.phead < he.phead &&
                    he.bType != TYPE_FREE) {
                heBest = he;
                hBest = i;
            }
            if ((DWORD_PTR)FIXKP(he.phead) > dw &&
                    heAfter.phead > he.phead &&
                    he.bType != TYPE_FREE) {
                heAfter = he;
                hAfter = i;
            }
        NEXTEACHHANDLEENTRY()

        if (heBest.phead != NULL) {
            Print("Nearest guy before %#p is a %s object located at %#p (i=%x).\n",
                    dw, aszTypeNames[heBest.bType], FIXKP(heBest.phead), hBest);
        }
        if (heAfter.phead != (PVOID)-1) {
            Print("Nearest guy after %#p is a %s object located at %#p. (i=%x)\n",
                    dw, aszTypeNames[heAfter.bType], FIXKP(heAfter.phead), hAfter);
        }
    }
    return TRUE;
}




/************************************************************************\
* Ifrr
*
* Finds Range References - helpful for finding stale pointers.
*
* fSuccess
*
* 6/9/1995 Created SanfordS
\************************************************************************/
BOOL Ifrr(
    DWORD opts,
    ULONG64 param1,
    ULONG64 param2,
    ULONG64 param3,
    ULONG64 param4)
{
    DWORD_PTR pSrc1 = (DWORD_PTR)param1;
    DWORD_PTR pSrc2 = (DWORD_PTR)param2;
    DWORD_PTR pRef1 = (DWORD_PTR)param3;
    DWORD_PTR pRef2 = (DWORD_PTR)param4;
    DWORD_PTR dw;
    DWORD_PTR buffer[PAGE_SIZE / sizeof(DWORD_PTR)];

    UNREFERENCED_PARAMETER(opts);

    if (pSrc2 < pSrc1) {
        Print("Source range improper.  Values reversed.\n");
        dw = pSrc1;
        pSrc1 = pSrc2;
        pSrc2 = dw;
    }
    if (pRef2 == 0) {
        pRef2 = pRef1;
    }
    if (pRef2 < pRef1) {
        Print("Reference range improper.  Values reversed.\n");
        dw = pRef1;
        pRef1 = pRef2;
        pRef2 = dw;
    }

    pSrc1 &= MAXULONG_PTR - PAGE_SIZE + 1;  // PAGE aligned
    pSrc2 = (pSrc2 + (sizeof(DWORD_PTR)-1)) & (MAXULONG_PTR - (sizeof(DWORD_PTR)-1));   // dword_ptr aligned

    Print("Searching range (%#p-%#p) for references to (%#p-%#p)...",
            pSrc1, pSrc2, pRef1, pRef2);

    for (; pSrc1 < pSrc2; pSrc1 += PAGE_SIZE) {
        BOOL fSuccess;

        if (!(pSrc1 & 0xFFFFFF)) {
            Print("\nSearching %#p...", pSrc1);
        }
        fSuccess = tryMoveBlock(buffer, (PVOID)pSrc1, sizeof(buffer));
        if (!fSuccess) {
            /*
             * Skip to next page
             */
        } else {
            for (dw = 0; dw < ARRAY_SIZE(buffer); dw++) {
                if (buffer[dw] >= pRef1 && buffer[dw] <= pRef2) {
                    Print("\n[%#p] = %#p ",
                            pSrc1 + dw * sizeof(DWORD_PTR),
                            buffer[dw]);
                }
            }
        }
        if (IsCtrlCHit()) {
            Print("\nSearch aborted.\n");
            return TRUE;
        }
    }
    Print("\nSearch complete.\n");
    return TRUE;
}


#ifdef KERNEL
//PGDI_DEVICE undefined
#if 0
VOID ddGdiDevice(
PGDI_DEVICE pGdiDevice)
{
    Print("\t\tGDI_DEVICE\n");
    Print("\t\tcRefCount       = %d\n",     pGdiDevice->cRefCount);
    Print("\t\thDevInfo        = 0x%.8x\n", pGdiDevice->hDevInfo);
    Print("\t\thDev            = 0x%.8x\n", pGdiDevice->hDev);
    Print("\t\trcScreen        = (%d,%d)-(%d,%d) %dx%d\n",
            pGdiDevice->rcScreen.left, pGdiDevice->rcScreen.top,
            pGdiDevice->rcScreen.right, pGdiDevice->rcScreen.bottom,
            pGdiDevice->rcScreen.right - pGdiDevice->rcScreen.left,
            pGdiDevice->rcScreen.bottom - pGdiDevice->rcScreen.top);
    Print("\t\tDEVMODEW\n");
}
#endif
#endif


#endif // OLD_DEBUGGER

VOID
DumpMonitor(
    ULONG64 param1,
    LPSTR pstrPrefix)
{
    DWORD dwMONFlags;
    RECT rc;

    _InitTypeRead(param1, SYM(MONITOR));

    Print("%shead.h             = 0x%.8x\n", pstrPrefix, ReadField(head.h));
    Print("%shead.cLockObj      = 0x%.8x\n", pstrPrefix, ReadField(head.cLockObj));
    Print("%spMonitorNext       = 0x%p\n", pstrPrefix, ReadField(pMonitorNext));
    dwMONFlags = (DWORD)ReadField(dwMONFlags);
    Print("%sdwMONFlags         = 0x%.8x %s\n", pstrPrefix, dwMONFlags, GetFlags(GF_MON, dwMONFlags, NULL, FALSE));

    GetFieldValue(param1, SYM(MONITOR), "rcMonitor", rc);

    Print("%srcMonitor          = (%d,%d)-(%d,%d) %dx%d\n",
            pstrPrefix, rc.left, rc.top, rc.right, rc.bottom, rc.right - rc.left, rc.bottom - rc.top);

    GetFieldValue(param1, SYM(MONITOR), "rcWork", rc);

    Print("%srcWork             = (%d,%d)-(%d,%d) %dx%d\n",
            pstrPrefix, rc.left, rc.top, rc.right, rc.bottom, rc.right - rc.left, rc.bottom - rc.top);

    Print("%shrgnMonitor        = 0x%.8x\n", pstrPrefix, ReadField(hrgnMonitor));
    Print("%scFullScreen        = %d\n",     pstrPrefix, (short)ReadField(cFullScreen));
    Print("%scwndStack          = %d\n",     pstrPrefix, (short)ReadField(cWndStack));

#ifdef SUBPIXEL_MOUSE
    {
        DWORD dwOffset;
        FIXPOINT xTxf[SM_POINT_CNT], yTxf[SM_POINT_CNT];
        FIXPOINT slope[SM_POINT_CNT - 1], yint[SM_POINT_CNT - 1];

        GetFieldOffset(SYM(MONITOR), "xTxf", &dwOffset);
        move(xTxf, param1 + dwOffset);
        GetFieldOffset(SYM(MONITOR), "yTxf", &dwOffset);
        move(yTxf, param1 + dwOffset);
        GetFieldOffset(SYM(MONITOR), "slope", &dwOffset);
        move(slope, param1 + dwOffset);
        GetFieldOffset(SYM(MONITOR), "yint", &dwOffset);
        move(yint, param1 + dwOffset);
        Print("%sxTxf = {", pstrPrefix);
        for (dwOffset = 0; dwOffset < SM_POINT_CNT; ++dwOffset) {
            Print("0x%I64x", xTxf[dwOffset]);
            if (dwOffset != SM_POINT_CNT - 1) {
                Print(", ");
            }
        }
        Print("}\n");

        Print("%syTxf = {", pstrPrefix);
        for (dwOffset = 0; dwOffset < SM_POINT_CNT; ++dwOffset) {
            Print("0x%I64x", yTxf[dwOffset]);
            if (dwOffset != SM_POINT_CNT - 1) {
                Print(", ");
            }
        }
        Print("}\n");

        Print("%sslope = {", pstrPrefix);
        for (dwOffset = 0; dwOffset < SM_POINT_CNT - 1; ++dwOffset) {
            Print("0x%I64x", slope[dwOffset]);
            if (dwOffset != SM_POINT_CNT - 2) {
                Print(", ");
            }
        }
        Print("}\n");

        Print("%syint = {", pstrPrefix);
        for (dwOffset = 0; dwOffset < SM_POINT_CNT - 1; ++dwOffset) {
            Print("0x%I64x", yint[dwOffset]);
            if (dwOffset != SM_POINT_CNT - 2) {
                Print(", ");
            }
        }
        Print("}\n");
    }
#endif // SUBPIXEL_MOUSE
}

BOOL Idmon(
    DWORD opts,
    ULONG64 param1)
{
    UNREFERENCED_PARAMETER(opts);

    if (param1 == NULL_PTR) {
        return FALSE;
    }

    Print("Dumping MONITOR at %p\n", param1);
    DumpMonitor(param1, "\t");

    return TRUE;
}

BOOL Idy(
    DWORD opts,
    ULONG64 param1)
{
    PTR pdi, gpdi, pMonitor, pshi;
    PTR psi;
    ULONG           i;
    BOOLEAN         fBool;
    ULONG           cMonitors;
    RECT            rcScreen;
    WORD            dmLogPixels;

    UNREFERENCED_PARAMETER(opts);

    GETSHAREDINFO(pshi);
    GetFieldValue((PTR)pshi, SYM(SHAREDINFO), "pDispInfo", gpdi);

    if (param1) {
        pdi = param1;
    } else {
        pdi = gpdi;
    }

    psi = GetGlobalPointer(VAR(gpsi));
    GetFieldValue(psi, SYM(SERVERINFO), "rcScreen", rcScreen);
    GetFieldValue(psi, SYM(SERVERINFO), "dmLogPixels", dmLogPixels);

    _InitTypeRead(pdi, SYM(DISPLAYINFO));
    cMonitors = (ULONG)ReadField(cMonitors);

    Print("Dumping DISPLAYINFO at 0x%.8x\n", pdi);
    Print("\thDev                  = 0x%.8x\n", ReadField(hDev));
    Print("\thdcScreen             = 0x%.8x\n", ReadField(hdcScreen));

    Print("\thdcBits               = 0x%.8x\n", ReadField(hdcBits));

    Print("\thdcGray               = 0x%.8x\n", ReadField(hdcGray));
    Print("\thbmGray               = 0x%.8x\n", ReadField(hbmGray));
    Print("\tcxGray                = %d\n",     ReadField(cxGray));
    Print("\tcyGray                = %d\n",     ReadField(cyGray));
    Print("\tpdceFirst             = 0x%.8x\n", ReadField(pdceFirst));
    Print("\tpspbFirst             = 0x%.8x\n", ReadField(pspbFirst));
    Print("\tcMonitors (visible)   = %d\n",               cMonitors);

    Print("\tpMonitorPrimary       = 0x%.8x\n", RebaseSharedPtr(ReadField(pMonitorPrimary)));
    Print("\tpMonitorFirst         = 0x%.8x\n", RebaseSharedPtr(ReadField(pMonitorFirst)));

    Print("\trcScreen              = (%d,%d)-(%d,%d) %dx%d\n",

                                     rcScreen.left, rcScreen.top,
                                     rcScreen.right, rcScreen.bottom,
                                     rcScreen.right - rcScreen.left,
                                     rcScreen.bottom - rcScreen.top);

    Print("\thrgnScreen            = 0x%.8x\n", ReadField(hrgnScreen));
    Print("\tdmLogPixels           = %d\n",     (WORD)ReadField(dmLogPixels));
    Print("\tBitCountMax           = %d\n",     (WORD)ReadField(BitCountMax));
    GetFieldValue(pdi, SYM(DISPLAYINFO), "fDesktopIsRect", fBool);
    Print("\tfDesktopIsRect        = %d\n",     fBool);
    GetFieldValue(pdi, SYM(DISPLAYINFO), "fAnyPalette", fBool);
    Print("\tfAnyPalette           = %d\n",     fBool);
    Print("\n");

    if (pdi == gpdi) {
        if (dmLogPixels != (WORD)ReadField(dmLogPixels)) {
            Print("\n\n");
            Print("ERROR - dmLogPixels doesn't match in gpsi (%d) and gpDispInfo (%d)\n",
                  dmLogPixels, (WORD)ReadField(dmLogPixels));
            Print("\n\n");
        }

    }

    for (   pMonitor = ReadField(pMonitorFirst), i = 1;
            pMonitor;
            GetFieldValue(pMonitor, SYM(MONITOR), "pMonitorNext", pMonitor), i++) {

        pMonitor = RebaseSharedPtr(pMonitor);
        Print("\tMonitor %d, pMonitor = 0x%.8x\n", i, pMonitor);
        DumpMonitor(pMonitor, "\t\t");
        Print("\n");
    }

    return TRUE;
}

#ifdef KERNEL
/***************************************************************************\
* kbd [queue]
*
* Loads a DLL containing more debugging extensions
*
* 10/27/92 IanJa        Created.
* 6/9/1995 SanfordS     made to fit stdexts motif
\***************************************************************************/
typedef struct {
    int iVK;
    LPSTR pszVK;
} VK, *PVK;

VK aVK[] = {
    { VK_SHIFT,    "SHIFT"    },
    { VK_LSHIFT,   "LSHIFT"   },
    { VK_RSHIFT,   "RSHIFT"   },
    { VK_CONTROL,  "CONTROL"  },
    { VK_LCONTROL, "LCONTROL" },
    { VK_RCONTROL, "RCONTROL" },
    { VK_MENU,     "MENU"     },
    { VK_LMENU,    "LMENU"    },
    { VK_RMENU,    "RMENU"    },
    { VK_NUMLOCK,  "NUMLOCK"  },
    { VK_CAPITAL,  "CAPITAL"  },
    { VK_LBUTTON,  "LBUTTON"  },
    { VK_MBUTTON,  "MBUTTON"  },
    { VK_RBUTTON,  "RBUTTON"  },
    { VK_XBUTTON1, "XBUTTON1" },
    { VK_XBUTTON2, "XBUTTON2" },
    { VK_RETURN ,  "ENTER"    },
    { VK_KANA,     "KANA/HANJA" },
    { VK_OEM_8,    "OEM_8"    },
    // { 0x52      ,  "R"        },  // your key goes here
    { 0,           NULL       }
};

ULONG WDBGAPI KbdPti(PTR pti, PVOID pOpt)
{
    Ikbd(DOWNCAST(DWORD, pOpt), pti);
    return 0;
}

BOOL Ikbd(
    DWORD opts,
    ULONG64 param1)
{
    if (opts & OFLAG(a)) {
        ForEachPti(KbdPti, ULongToPtr(opts & ~OFLAG(a)));
        return TRUE;
    }

    try {
        PTR pq;
        PTR ptiKeyboard;
        PBYTE pb, pbr;
        int i;
        BYTE afKeyState[CBKEYSTATE + CBKEYSTATERECENTDOWN];
        PTR pgafAsyncKeyState;
        BYTE  afAsyncKeyState[CBKEYSTATE];
        PTR pgafRawKeyState;
        BYTE  afRawKeyState[CBKEYSTATE];
        UINT  PhysModifiers;
        BYTE  vkey;

        /*
         * If 'u' was specified, make sure there was also an address
         */
        if (opts & OFLAG(u)) {
            if (param1 == 0) {
                Print("provide arg 2 of ProcessUpdateKeyEvent(), or WM_UPDATEKEYSTATE wParam\n");
                return FALSE;
            }
            move(afKeyState, param1);
            pb = afKeyState;
            pbr = afKeyState + CBKEYSTATE;
            Print("Key State:   === NEW STATE ====   Asynchronous    Physical\n");

        } else {
            if (opts & OFLAG(k)) {
                vkey = (BYTE)param1;
                param1 = NULL_PTR;
            }
            if (param1) {
                pq = param1;
            } else {
                pq = GetGlobalPointer(VAR(gpqForeground));
            }

            /*
             * Print out simple thread info for pq->ptiLock.
             */
            GetFieldValue(pq, SYM(tagQ), "ptiKeyboard", ptiKeyboard);
            if (ptiKeyboard) {
                Idt(OFLAG(p), ptiKeyboard);
            }

            GetFieldValue(pq, SYM(tagQ), "afKeyState", afKeyState);
            pb = afKeyState;
            pbr = afKeyState + CBKEYSTATE;
            Print("Key State:   QUEUE %p       Asynchronous    Raw\n", pq);
        }

        moveExp(&pgafAsyncKeyState, VAR(gafAsyncKeyState));
        move(afAsyncKeyState, pgafAsyncKeyState);

        moveExp(&pgafRawKeyState, VAR(gafRawKeyState));
        move(afRawKeyState, pgafRawKeyState);

        Print("             Down Toggle Recent   Down Toggle     Down Toggle\n");

        if (opts & OFLAG(s)) {
            for (vkey = 1; vkey < VK_UNKNOWN; ++vkey) {
                Print("%02x %10.10s:\t%d    %d     %d        %d     %d         %d     %d\n",
                    vkey,
                    _GetVKeyName(vkey, 0),
                    TestKeyDownBit(pb, vkey) != 0,
                    TestKeyToggleBit(pb, vkey) != 0,
                    TestKeyRecentDownBit(pbr, vkey) != 0,
                    TestKeyDownBit(afAsyncKeyState, vkey) != 0,
                    TestKeyToggleBit(afAsyncKeyState, vkey) != 0,
                    TestKeyDownBit(afRawKeyState, vkey) != 0,
                    TestKeyToggleBit(afRawKeyState, vkey) != 0);
            }
        } else {
            for (i = 0; aVK[i].pszVK != NULL; i++) {
                Print("VK_%s:\t%d    %d     %d        %d     %d         %d     %d\n",
                    aVK[i].pszVK,
                    TestKeyDownBit(pb, aVK[i].iVK) != 0,
                    TestKeyToggleBit(pb, aVK[i].iVK) != 0,
                    TestKeyRecentDownBit(pbr, aVK[i].iVK) != 0,
                    TestKeyDownBit(afAsyncKeyState, aVK[i].iVK) != 0,
                    TestKeyToggleBit(afAsyncKeyState, aVK[i].iVK) != 0,
                    TestKeyDownBit(afRawKeyState, aVK[i].iVK) != 0,
                    TestKeyToggleBit(afRawKeyState, aVK[i].iVK) != 0);
            }

            if (opts & OFLAG(k)) {
                Print("%s:\t%d    %d     %d        %d     %d         %d     %d\n",
                    GetVKeyName(vkey),
                    TestKeyDownBit(pb, vkey) != 0,
                    TestKeyToggleBit(pb, vkey) != 0,
                    TestKeyRecentDownBit(pbr, vkey) != 0,
                    TestKeyDownBit(afAsyncKeyState, vkey) != 0,
                    TestKeyToggleBit(afAsyncKeyState, vkey) != 0,
                    TestKeyDownBit(afRawKeyState, vkey) != 0,
                    TestKeyToggleBit(afRawKeyState, vkey) != 0);
            }
        }

        moveExpValue(&PhysModifiers, VAR(gfsSASModifiersDown));
        Print("PhysModifiers = %x\n", PhysModifiers);
    } except(CONTINUE) {
    }

    return TRUE;
}
#endif // KERNEL



/************************************************************************\
* Itest
*
* Tests the basic stdexts macros and functions - a good check on the
* debugger extensions in general before you waste time debuging entensions.
*
* 6/9/1995 Created SanfordS
\************************************************************************/
BOOL Itest()
{
    PTR p;
    ULONG64 cch;
    CHAR ach[80];

    Print("Print test!\n");
    SAFEWHILE (TRUE) {
        Print("SAFEWHILE test...  Hit Ctrl-C NOW!\n");
    }
    p = EvalExp(VAR(gpsi));
    Print("EvalExp(%s) = %#p\n", VAR(gpsi), p);
    GetSym(p, ach, &cch);
    Print("GetSym(%#p) = %s\n", p, ach);
    if (IsWinDbg()) {
        Print("I think windbg is calling me.\n");
    } else {
        Print("I don't think windbg is calling me.\n");
    }
    Print("MoveBlock test...\n");
    moveBlock(&p, EvalExp(VAR(gpsi)), sizeof(p));
    Print("MoveBlock(%#p) = %#p.\n", EvalExp(VAR(gpsi)), p);

    Print("moveExp test...\n");
    moveExp(&p, VAR(gpsi));
    Print("moveExp(%s) = %p.\n", VAR(gpsi), p);

    Print("moveExpValue test...\n");
    p = GetGlobalPointer(VAR(gpsi));
    Print("moveExpValue(%s) = %#p.\n", VAR(gpsi), p);

    Print("Basic tests complete.\n");
    return TRUE;
}


/************************************************************************\
* Iuver
*
* Dumps versions of extensions and winsrv/win32k
*
* 6/15/1995 Created SanfordS
\************************************************************************/
BOOL Iuver()
{
    try {
        PTR psi, wSRVIFlags;
        BOOL bExtsIs64 = (sizeof(VOID*) == 8);

#if DBG
        Print("USEREXTS version: Checked %s.\n"
              "WIN32K.SYS version: ", bExtsIs64 ? "ia64" : "x86");
#else
        Print("USEREXTS version: Free %s.\n"
              "WIN32K.SYS version: ", bExtsIs64 ? "ia64" : "x86");
#endif

        psi = GetGlobalPointer(VAR(gpsi));
        GetFieldValue(psi, SYM(SERVERINFO), "wSRVIFlags", wSRVIFlags);

        Print((wSRVIFlags & SRVIF_CHECKED) ? "Checked" : "Free");
        Print(" %s", IsPtr64() ? "ia64" : "x86");
        Print(".\n");
    } except (CONTINUE) {
    }

    return TRUE;
}


#ifdef KERNEL

#ifdef OBSOLETE
#define DUMPSTATUS(status) if (tryMoveExpValue(&Status, VAR(g ## status))) { \
                               Print("g%s = %lx\n", #status, Status);        \
                           }
#define DUMPTIME(time)     if (tryMoveExpValue(&Time, VAR(g ## time))) {     \
                               Print("g%s = %lx\n", #time, Time);            \
                           }
#else
#define DUMPSTATUS(status) moveExpValue(&Status, VAR(g ## status));         \
                           Print("g%s = %lx\n", #status, Status);

#define DUMPTIME(time)     moveExpValue(&Time, VAR(g ## time));             \
                           Print("g%s = %lx\n", #time, Time);

#endif

/***************************************************************************\
* dinp - dump input diagnostics
* dinp -v   verbose
* dinp -i   show input records
*
* 04/13/98  IanJa       Created.
\***************************************************************************/

int gnIndent;

BOOL Idinp(
    DWORD opts,
    ULONG64 param1)
{
    try {
        DWORD    Time;
        PTR pDeviceInfo;
        ULONG64 v;
        DWORD dw;
        int i = 0;
        DWORD nKbd = 0;
        BOOL bVerbose = FALSE;

#if 0
        {
            NTSTATUS Status;

            DUMPSTATUS(KbdIoctlLEDSStatus);
        }
#endif

        DUMPTIME(MouseProcessMiceInputTime);
        DUMPTIME(MouseQueueMouseEventTime);
        DUMPTIME(MouseUnqueueMouseEventTime);

        if (opts & OFLAG(v)) {
            bVerbose = TRUE;
        }

        pDeviceInfo = GetGlobalPointer(VAR(gpDeviceInfoList));
        if (pDeviceInfo == NULL_PTR) {
            Print("win32k!gpDeviceInfoList is NULL\n");
        }
        SAFEWHILE (pDeviceInfo) {
            if (param1 && (param1 != pDeviceInfo)) {
                // skip it
            } else {
                WCHAR awchBuffer[100];
                DWORD cbBuffer;
                BYTE type;
                PTR h;
                ULONG64 cLockObj;

                _InitTypeRead(pDeviceInfo, SYM(tagDEVICEINFO));

                Print("#%d: ", i);

                type = (BYTE)ReadField(type);
                switch (type) {
                case DEVICE_TYPE_MOUSE:
                    Print("MOU");
                    break;
                case DEVICE_TYPE_KEYBOARD:
                    Print("KBD");
                    ++nKbd;
                    break;
    #ifdef DEVICE_TYPE_HID
                case DEVICE_TYPE_HID:
                    Print("HID");
                    break;
    #endif
                default:
                    Print("%2d?", type);
                }

                h = ReadField(head.h);
                cLockObj = ReadField(head.cLockObj);
                Print("  @ 0x%p  h:0x%p (lock:0x%x) ", pDeviceInfo, h, (DWORD)cLockObj);

                v = ReadField(usActions);
                if (v) {
                    Print("\n Pending action: %x %s", (USHORT)v,
                            GetFlags(GF_DIAF, (USHORT)v, NULL, TRUE));
                }

                v = ReadField(ustrName.Length);

                if (v) {
                    cbBuffer = min((ULONG)v, sizeof(awchBuffer) - sizeof(WCHAR));
                    v = ReadField(ustrName.Buffer);
                    if (tryMoveBlock(awchBuffer, v, cbBuffer)) {
                        Print("\n    %.*ws\n", cbBuffer / sizeof(WCHAR), awchBuffer);
                    } else {
                        Print("\n");
                    }
                } else {
                    Print("\n    NO-NAME!\n");
                }

                switch (type) {
                case DEVICE_TYPE_KEYBOARD:
                    Print("  Type: %04x  SubType: %04x (%x, %x)\n",
                          (DWORD)ReadField(keyboard.IdEx.Type),
                          (DWORD)ReadField(keyboard.IdEx.Subtype),
                          (DWORD)ReadField(keyboard.Attr.KeyboardIdentifier.Type),
                          (DWORD)ReadField(keyboard.Attr.KeyboardIdentifier.Subtype));
                    break;
                }

                if (bVerbose || (param1 == pDeviceInfo)) {
                    ULONG offset, offset2;

                    gnIndent += 2;
                    dso(SYM(tagGENERIC_DEVICE_INFO), pDeviceInfo, 0);
                    gnIndent += 2;
                    GetFieldOffset(SYM(tagDEVICEINFO), "iosb", &offset);
                    Print("  IOSB @ 0x%p\n", pDeviceInfo + offset);
                    dso(SYM(_IO_STATUS_BLOCK), pDeviceInfo + offset, 0);
                    gnIndent -= 2;

                    switch (type) {
                    case DEVICE_TYPE_MOUSE:
                        GetFieldOffset(SYM(tagDEVICEINFO), "mouse", &offset);
                        Print("  MOUSE_DEVICE_INFO @ 0x%p\n", pDeviceInfo + offset);
                        dso(SYM(tagMOUSE_DEVICE_INFO), pDeviceInfo + offset, 0);

                        gnIndent += 2;
                        GetFieldOffset(SYM(tagMOUSE_DEVICE_INFO), "Attr", &offset2);
                        Print("  Attr @ 0x%p\n", pDeviceInfo + offset + offset2);
                        dso(SYM(_MOUSE_ATTRIBUTES), pDeviceInfo + offset + offset2, 0);
                        gnIndent -= 2;
                        break;
                    case DEVICE_TYPE_KEYBOARD:
                        GetFieldOffset(SYM(tagDEVICEINFO), "keyboard", &offset);
                        Print("  KEYBOARD_DEVICE_INFO @ 0x%p\n", pDeviceInfo + offset);
                        dso(SYM(tagKEYBOARD_DEVICE_INFO), pDeviceInfo + offset, 0);

                        gnIndent += 2;
                        GetFieldOffset(SYM(tagKEYBOARD_DEVICE_INFO), "Attr", &offset2);
                        Print("  KEYBOARD_ATTRIBUTES @ 0x%p\n", pDeviceInfo + offset + offset2);
                        dso(SYM(_KEYBOARD_ATTRIBUTES), pDeviceInfo + offset + offset2, DBG_DUMP_RECUR_LEVEL(1));
                        gnIndent -= 2;
                        break;
    #ifdef GENERIC_INPUT
                    case DEVICE_TYPE_HID:
                        {
                            PTR pTLCInfo;

                            GetFieldOffset(SYM(tagDEVICEINFO), "hid", &offset);
                            Print("  HID_DEVICE_INFO @ 0x%p\n", pDeviceInfo + offset);
                            dso(SYM(tagHID_DEVICE_INFO), pDeviceInfo + offset, 0);

                            GetFieldValue(pDeviceInfo, SYM(tagDEVICEINFO), "hid.pTLCInfo", pTLCInfo);
                            Print("  HID_TLC_INFO @ 0x%p\n", pTLCInfo);
                            dso(SYM(tagHID_TLC_INFO), pTLCInfo, 0);
                        }
                        break;
    #endif
                    default:
                        Print("Unknown device type %d\n", type);
                    }

                    if ((opts & OFLAG(i))
    #ifdef GENERIC_INPUT
                        && type != DEVICE_TYPE_HID
    #endif
                        ) {
                        ULONG offset;
                        PTR pData;
                        ULONG64 Information;
                        ULONG64 sizeDataItem;

                        GetFieldOffset(SYM(tagDEVICEINFO), "keyboard.Data", &offset);
                        pData = pDeviceInfo + offset;
                        GetFieldValue(pDeviceInfo, SYM(tagDEVICEINFO), "iosb.Information", Information);
                        sizeDataItem = GetTypeSize(SYM(_KEYBOARD_INPUT_DATA));

                        Print("  Input Records:");
                        if (Information == 0) {
                            Print(" NONE\n");
                        } else {
                            UINT i;

                            Print("\n");
                            gnIndent += 2;
                            for (i = 0; i < Information / sizeDataItem; ++i) {
                                dso(SYM(_KEYBOARD_INPUT_DATA), pData, 0);
                                pData += sizeDataItem;
                            }
                            gnIndent -= 2;
                        }
                    }
                    gnIndent -= 2;
                }
    #ifdef GENERIC_INPUT
                else if (type == DEVICE_TYPE_HID) {
                    PTR pHidDesc;
                    USHORT UsagePage, Usage;

                    GetFieldValue(pDeviceInfo, SYM(tagDEVICEINFO), "hid.pHidDesc", pHidDesc);
                    _InitTypeRead(pHidDesc, SYM(HIDDESC));
                    UsagePage = (USHORT)ReadField(hidpCaps.UsagePage);
                    Usage = (USHORT)ReadField(hidpCaps.Usage);
                    Print("  UsagePage:%04x Usage:%04x\n", UsagePage, Usage);
                }
    #endif
                Print("\n");
            }

            GetFieldValue(pDeviceInfo, SYM(tagDEVICEINFO), "pNext", pDeviceInfo);
            ++i;
        }

        // Now display input related sytem metrics
        {
            PTR psi;
            ULONG offset;

            static SYSMET_ENTRY aSysMet[] = {
                SMENTRY(MOUSEPRESENT),
                SMENTRY(MOUSEWHEELPRESENT),
                SMENTRY(CMOUSEBUTTONS),
            };

            psi = GetGlobalPointer(VAR(gpsi));

            GetFieldOffset(SYM(tagSERVERINFO), "aiSysMet", &offset);

            for (i = 0; !IsCtrlCHit() && i < ARRAY_SIZE(aSysMet); ++i) {
                int metric;
                move(metric, psi + offset + aSysMet[i].iMetric * sizeof(int));
                Print("SM_%-18s = 0x%08lx = %d\n",
                      aSysMet[i].pstrMetric,
                      metric,
                      metric);
            }
        }

        moveExpValue(&dw, VAR(gnHid));
        Print("#HID = 0x%x   #Kbd = 0x%x\n", dw, nKbd);
    } except (CONTINUE) {
    }
    return TRUE;
}


BOOL I_dinp(
    DWORD opts,
    ULONG64 param1)
{
#ifdef _IA64_
    UNREFERENCED_PARAMETER(opts);
    UNREFERENCED_PARAMETER(param1);
    return FALSE;
#else
    DWORD    Time;
    NTSTATUS Status;
    PDEVICEINFO pDeviceInfo, *ppDeviceInfo;
    int i = 0;
#if 0
    char ach[100];
#endif
    DWORD nKbd;
    BOOL bVerbose = FALSE;

    DUMPSTATUS(KbdIoctlLEDSStatus);

    DUMPTIME(MouseProcessMiceInputTime);
    DUMPTIME(MouseQueueMouseEventTime);
    DUMPTIME(MouseUnqueueMouseEventTime);

    if (opts & OFLAG(v)) {
        bVerbose = TRUE;
    }


    ppDeviceInfo = (PDEVICEINFO*)EvalExp(VAR(gpDeviceInfoList));
    while (tryMove(pDeviceInfo, (PTR)ppDeviceInfo) && pDeviceInfo) {

        if (param1 && (param1 != (PTR)pDeviceInfo)) {
            ; // skip it
        } else if (pDeviceInfo != 0) {
            DEVICEINFO DeviceInfo;
            WCHAR awchBuffer[100];
            DWORD cbBuffer;

            Print("#%d: %p ", i, (PTR)pDeviceInfo);
            if (tryMove(DeviceInfo, (PTR)pDeviceInfo)) {
                if (DeviceInfo.type == DEVICE_TYPE_MOUSE) {
                    Print("MOU", i);
                } else if (DeviceInfo.type == DEVICE_TYPE_KEYBOARD) {
                    Print("KBD");
                } else {
                    Print("%2d?", DeviceInfo.type);
                }
                if (DeviceInfo.usActions) {
                    Print(" Pending action %x %s", DeviceInfo.usActions,
                            GetFlags(GF_DIAF, DeviceInfo.usActions, NULL, TRUE));
                }
                cbBuffer = min(DeviceInfo.ustrName.Length, sizeof(awchBuffer)-sizeof(WCHAR));
                if (tryMoveBlock(awchBuffer, (PTR)DeviceInfo.ustrName.Buffer, cbBuffer)) {
                    awchBuffer[cbBuffer / sizeof(WCHAR)] = 0;
                    Print("\n    %ws\n", awchBuffer);
                } else {
                    Print("\n");
                }
            } else {
                DeviceInfo.type = 0xFF;
            }
#if 0
            if (bVerbose || (param1 == (PTR)pDeviceInfo)) {
                sprintf(ach, "GENERIC_DEVICE_INFO 0x%p", pDeviceInfo);
                gnIndent += 2;
                Idso(0, ach);
                gnIndent += 2;
                sprintf(ach, "IO_STATUS_BLOCK 0x%p",
                        (PBYTE)pDeviceInfo + FIELD_OFFSET(DEVICEINFO, iosb));
                Idso(0, ach);
                gnIndent -= 2;
                if (DeviceInfo.type == DEVICE_TYPE_MOUSE) {
                    sprintf(ach, "MOUSE_DEVICE_INFO 0x%p",
                            (PBYTE)pDeviceInfo + FIELD_OFFSET(DEVICEINFO, mouse));
                    Idso(0, ach);

                    gnIndent += 2;
                    sprintf(ach, "MOUSE_ATTRIBUTES 0x%p",
                            (PBYTE)pDeviceInfo + FIELD_OFFSET(DEVICEINFO, mouse)
                                    + FIELD_OFFSET(MOUSE_DEVICE_INFO, Attr));
                    Idso(0, ach);
                    gnIndent -= 2;
                } else if (DeviceInfo.type == DEVICE_TYPE_KEYBOARD) {
                    sprintf(ach, "KEYBOARD_DEVICE_INFO 0x%p",
                            (PBYTE)pDeviceInfo + FIELD_OFFSET(DEVICEINFO, keyboard));
                    Idso(0, ach);
                    gnIndent += 2;
                    sprintf(ach, "KEYBOARD_ATTRIBUTES 0x%p",
                            (PBYTE)pDeviceInfo + FIELD_OFFSET(DEVICEINFO, keyboard)
                                    + FIELD_OFFSET(KEYBOARD_DEVICE_INFO, Attr));
                    Idso(0, ach);
                    gnIndent -= 2;
                } else {
                    Print("Unknown device type %d\n", DeviceInfo.type);
                }
                if (opts & OFLAG(i)) {
                    Print("  Input Records:");
                    if (DeviceInfo.iosb.Information == 0) {
                        Print(" NONE\n");
                    } else {
                        Print("\n");
                        gnIndent += 2;
                        sprintf(ach, "KEYBOARD_INPUT_DATA %p *%x",
                                &(pDeviceInfo->keyboard.Data[0]),
                                DeviceInfo.iosb.Information / sizeof(DeviceInfo.keyboard.Data[0]));
                        Idso(0, ach);
                        gnIndent -= 2;
                    }
                }
                gnIndent -= 2;
            }
#endif
        }
        ppDeviceInfo = FIXKP(&pDeviceInfo->pNext);
        i++;
    }

    // Now display input related sytem metrics
    {
        SERVERINFO si;
        //PSERVERINFO psi;
        PTR psi;

// #define SMENTRY(sm) {SM_##sm, #sm}  (see above

        /*
         * Add mouse- and keyboard- related entries to this table
         * with the prefix removed, in whatever order you think is rational
         */
        static SYSMET_ENTRY aSysMet[] = {
            SMENTRY(MOUSEPRESENT),
            SMENTRY(MOUSEWHEELPRESENT),
            SMENTRY(CMOUSEBUTTONS),
        };

        psi = GetGlobalPointer(VAR(gpsi));
        move(si, psi);

        for (i = 0; i < ARRAY_SIZE(aSysMet); i++) {
            Print(  "SM_%-18s = 0x%08lx = %d\n",
                    aSysMet[i].pstrMetric,
                    si.aiSysMet[aSysMet[i].iMetric],
                    si.aiSysMet[aSysMet[i].iMetric]);
        }

        moveExpValue(&nKbd, VAR(gnKeyboards));
        Print("gnKeyboards = %d\n", nKbd);
        moveExpValue(&nKbd, VAR(gnMice));
        Print("gnMice = %d\n", nKbd);
        moveExpValue(&nKbd, VAR(gnHid));
        Print("ghMice = %d\n", nKbd);
    }
    return TRUE;
#endif  // _IA64_
}

#endif // KERNEL



#ifdef KERNEL
/***************************************************************************\
* hh - dump the flags in gdwHydraHint
*
* 05/20/98  MCostea       Created.
\***************************************************************************/
BOOL Ihh(
    DWORD opts,
    ULONG64 param1)
{
    DWORD dwHHint;
    PTR pdwHH;
    ULONG ulSessionId;
    PTR pulASessionId;
    int i, maxFlags;

    char * aHHstrings[] = {
        "HH_DRIVERENTRY            0x00000001",
        "HH_USERINITIALIZE         0x00000002",
        "HH_INITVIDEO              0x00000004",
        "HH_REMOTECONNECT          0x00000008",
        "HH_REMOTEDISCONNECT       0x00000010",
        "HH_REMOTERECONNECT        0x00000020",
        "HH_REMOTELOGOFF           0x00000040",
        "HH_DRIVERUNLOAD           0x00000080",
        "HH_GRECLEANUP             0x00000100",
        "HH_USERKCLEANUP           0x00000200",
        "HH_INITIATEWIN32KCLEANUP  0x00000400",
        "HH_ALLDTGONE              0x00000800",
        "HH_RITGONE                0x00001000",
        "HH_RITCREATED             0x00002000",
        "HH_LOADCURSORS            0x00004000",
        "HH_KBDLYOUTGLOBALCLEANUP  0x00008000",
        "HH_KBDLYOUTFREEWINSTA     0x00010000",
        "HH_CLEANUPRESOURCES       0x00020000",
        "HH_DISCONNECTDESKTOP      0x00040000",
        "HH_DTQUITPOSTED           0x00080000",
        "HH_DTQUITRECEIVED         0x00100000",
        "HH_DTNONEWDESKTOP         0x00200000",
        "HH_DTWAITONHANDLES        0x00400000",
    };

    UNREFERENCED_PARAMETER(opts);

    if (param1) {
        dwHHint = (DWORD)((DWORD_PTR)param1);
        Print("gdwHydraHint is 0x%x:\n", dwHHint);
    } else {
        pdwHH = EvalExp(VAR(gdwHydraHint));
        if (!tryMove(dwHHint, pdwHH)) {
            Print("Can't get value of gdwHydraHint\n");
            return FALSE;
        }

        pulASessionId = EvalExp(VAR(gSessionId));
        if (!tryMove(ulSessionId, pulASessionId)) {
            Print("Can't get value of gSessionId\n");
            return FALSE;
        }

        Print("Session 0x%x \n  gdwHydraHint is 0x%x:\n", ulSessionId, dwHHint);
    }

    i = 0;
    maxFlags = ARRAY_SIZE(aHHstrings);

    while (dwHHint) {

        if (dwHHint & 0x01) {

            if (i >= maxFlags) {
                Print("\n Error: Unknown flags: userkdx.dll might be outdated\n");
                return TRUE;
            }
            Print("    %s\n", aHHstrings[i]);
        }
        i++;
        dwHHint >>= 1;
    }

    // TO DO: Dump the protocol
    {
        USHORT usProtocol = (USHORT)EvalExp(VAR(gProtocolType));
        BOOL bRemoteSession = (BOOL)EvalExp(VAR(gbRemoteSession));
        BOOL fRemotingConsole = (BOOL)EvalExp(VAR(gfRemotingConsole));
        BOOL fSwitchInProgress = (BOOL)EvalExp(VAR(gfSwitchInProgress));
        BOOL bExitInProgress = (BOOL)EvalExp(VAR(gfSessionSwitchBlock));
        USHORT usPreviousProtocolType = (USHORT)EvalExp(VAR(gPreviousProtocolType));


        //dt nt!_KUSER_SHARED_DATA ffdf0000 ActiveConsoleId
    }


    return TRUE;
}

#endif // KERNEL

/************************************************************************\
* Procedure: Idupm
*
* 04/29/98 GerardoB     Created
\************************************************************************/
#ifdef KERNEL
BOOL Idupm(
    VOID)
{
    char ach[80];
    DWORD dwMask;
    int i;
    WORD w = GF_UPM0;

    Print("UserPreferencesMask:\n");
    for (i = 0; i < SPI_BOOLMASKDWORDSIZE; i++) {
        sprintf(ach, "win32k!gpdwCPUserPreferencesMask + %#lx", i * sizeof(DWORD));
        moveExpValue(&dwMask, ach);
        w = GF_UPM0 + i;
        Print("Offset: %d - %#lx: %s\n",
              i, dwMask, GetFlags(w, dwMask, NULL, TRUE));
    }
    return TRUE;
}
#endif // KERNEL

/************************************************************************\
* Procedure: Idimc
*
* HiroYama     Created
*
\************************************************************************/

static struct /*NoName*/ {
    const char* terse;
    const char* verbose;
} gaIMCAttr[] = {
    "IN", "INPUT",
    "TC", "TARGET_CONVERTED",
    "CV", "CONVERTED",
    "TN", "TARGET_NOTCONVERTED",
    "IE", "INPUT_ERROR",
    "FC", "FIXEDCONVERTED",
};

const char* GetInxAttr(BYTE bAttr)
{
    if (bAttr < ARRAY_SIZE(gaIMCAttr)) {
        return gaIMCAttr[bAttr].terse;
    }
    return "**";
}

VOID _PrintInxAttr(
    const char* title,
    PTR pCompStr,
    DWORD offset,
    DWORD len)
{
    DWORD i;
    PTR pAttr = pCompStr + offset;

    if (title == NULL) {
        // Print a legend
        Print("  ");
        for (i = 0; i < ARRAY_SIZE(gaIMCAttr); ++i) {
            if (i && i % 4 == 0) {
                Print("\n");
                Print("  ");
            }
            Print("%s:%s ", gaIMCAttr[i].terse, gaIMCAttr[i].verbose);
        }
        Print("\n");
        return;
    }

    if (offset == 0 || len == 0) {
        return;
    }

    Print("  %-12s (@ 0x%p) off:0x%x len:0x%x (in byte)\n",
          title, pAttr, offset, len);
    Print("   ");
    i = 0;
    SAFEWHILE (i < len) {
        Print("|%s", GetInxAttr(GetByte(pAttr + i)));
        ++i;
    }
    Print("|\n");
}

#define PrintInxAttr(name) \
    _PrintInxAttr(#name, pCompStr, (DWORD)ReadField(dw ## name ## Offset), (DWORD)ReadField(dw ## name ## Len))

VOID _PrintInxClause(
    const char* title,
    PTR pCompStr,
    DWORD offset,
    DWORD len)
{
    PTR pClause = pCompStr + offset;
    DWORD i;

    if (offset == 0 || len == 0) {
        return;
    }

    Print("  %-12s (@ 0x%p) off:0x%x len:0x%x (0x%x dwords)\n",
          title, pClause, offset, len, len / sizeof(DWORD));

    Print("   ");
    len /= sizeof(DWORD);
    i = 0;
    SAFEWHILE (i < len) {
        Print("|0x%x", GetDWord(pClause + i));
        ++i;
    }
    Print("|\n");
}

#define PrintInxClause(name) \
    _PrintInxClause(#name, pCompStr, (DWORD)ReadField(dw ## name ## Offset), (DWORD)ReadField(dw ## name ## Len))

const char* GetInxStr(
    WCHAR wchar,
    BOOLEAN fUnicode)
{
    static char ach[32];

    if (wchar >= 0x20 && wchar <= 0x7e) {
        sprintf(ach, "'%c'", wchar);
    } else if (fUnicode) {
        sprintf(ach, "U+%04x", wchar);
    } else {
        sprintf(ach, "%02x", (BYTE)wchar);
    }

    return ach;
}

VOID _PrintInxStr(
    const char* title,
    PTR pCompStr,
    DWORD offset,
    DWORD len,
    BOOLEAN fUnicode)
{
    DWORD i;

    if (offset == 0 || len == 0) {
        return;
    }

    Print("  %-12s (@ 0x%p) off:0x%x len:0x%x (0x%x cch)\n",
        title, pCompStr + offset, offset, len, len / (fUnicode + 1));

    Print("   ");
    i = 0;
    SAFEWHILE (i < len) {
        WCHAR wchar;
        if (fUnicode) {
            wchar = GetWord(pCompStr + offset + i * sizeof(WCHAR));
        } else {
            wchar = GetByte(pCompStr + offset + i);
        }
        Print("|%s", GetInxStr(wchar, fUnicode));
        ++i;
    }
    Print("|\n");
}

#define PrintInxStr(name) \
    _PrintInxStr(#name, pCompStr, (DWORD)ReadField(dw ## name ## Offset), (DWORD)ReadField(dw ## name ## Len), fUnicode)


#define PrintInxElementA(name) \
    do { \
        PrintInxAttr(name ## Attr); \
        PrintInxClause(name ## Clause); \
        PrintInxStr(name ## Str); \
    } while (0)

#define PrintInxElementB(name) \
    do { \
        PrintInxClause(name ## Clause); \
        PrintInxStr(name ## Str); \
    } while (0)


VOID _PrintInxFriendlyStr(
    const char* title,
    PTR pCompStr,
    DWORD dwAttrOffset,
    DWORD dwAttrLen,
    DWORD dwClauseOffset,
    DWORD dwClauseLen,
    DWORD dwStrOffset,
    DWORD dwStrLen,
    BOOLEAN fUnicode)
{
    DWORD i;
    DWORD n;
    DWORD dwClause;

    Print("  %-11s", title);
    if (dwStrOffset == 0 || dwStrLen == 0) {
        Print("\n");
        return;
    }

    for (i = 0, n = 0; i < dwStrLen; ++i) {
        BYTE bAttr;
        WCHAR wchar;

        //move(dwClause, (PDWORD)(pCompStr + dwClauseOffset) + n);
        dwClause = GetDWord(pCompStr + dwClauseOffset + n * sizeof(DWORD));
        if (dwClause == i) {
            ++n;
            if (i) {
                Print("| ");
            }
        }

        if (fUnicode) {
            wchar = GetWord(pCompStr + dwStrOffset + i * sizeof(WCHAR));
            //move(wchar, (PWCHAR)((PBYTE)pCompStr + dwStrOffset) + i);
        } else {
            wchar = GetByte(pCompStr + dwStrOffset + i);
        }

        if (dwAttrOffset != ~0) {
            //move(bAttr, pCompStr + dwAttrOffset + i);
            bAttr = GetByte(pCompStr + dwAttrOffset + i);
            Print("|%s:%s", GetInxAttr(bAttr), GetInxStr(wchar, fUnicode));
        } else {
            Print("|%s", GetInxStr(wchar, fUnicode));
        }
    }
    Print("|\n");
    if (dwClauseLen / sizeof(DWORD) != (n + 1)) {
        Print("  ** dwClauseLen (0x%x) doesn't match to n (0x%x) **\n", dwClauseLen, (n + 1) * sizeof(DWORD));
    }
    if (dwAttrOffset != ~0 && dwAttrLen != dwStrLen) {
        Print("  ** dwAttrLen (0x%x) doesn't match to dwStrLen (0x%x) **\n", dwAttrLen, dwStrLen);
    }
}

#define PrintInxFriendlyStrA(name) \
    _PrintInxFriendlyStr(#name, \
                         pCompStr, \
                         (DWORD)ReadField(dw ## name ## AttrOffset), \
                         (DWORD)ReadField(dw ## name ## AttrLen), \
                         (DWORD)ReadField(dw ## name ## ClauseOffset), \
                         (DWORD)ReadField(dw ## name ## ClauseLen), \
                         (DWORD)ReadField(dw ## name ## StrOffset), \
                         (DWORD)ReadField(dw ## name ## StrLen), \
                         fUnicode)

#define PrintInxFriendlyStrB(name) \
    _PrintInxFriendlyStr(#name, \
                         pCompStr, \
                         ~0, \
                         0, \
                         (DWORD)ReadField(dw ## name ## ClauseOffset), \
                         (DWORD)ReadField(dw ## name ## ClauseLen), \
                         (DWORD)ReadField(dw ## name ## StrOffset), \
                         (DWORD)ReadField(dw ## name ## StrLen), \
                         fUnicode)


BOOL Idimc(
    DWORD opts,
    ULONG64 param1)
{
    try {
        PTR pImc;           // PIMC
        PTR pClientImc;     // PCLIENTIMC
        PTR pInputContext;  // PINPUTCONTEXT
        PTR hInputContext;
        BOOLEAN fUnicode = FALSE;
        BOOLEAN fVerbose, fDumpInputContext, fShowIMCMinInfo, fShowModeSaver, fShowCompStrRaw;

        if (param1 == 0) {
            Print("!dimc -? for help\n");
            return FALSE;
        }

        //
        // If "All" option is specified, set all bits in opts
        // except type specifiers.
        //
        if (opts & OFLAG(a)) {
            opts |= ~(OFLAG(w) | OFLAG(c) | OFLAG(i) | OFLAG(u) | OFLAG(v));
        }

        fVerbose = (opts & OFLAG(v)) != 0;
        fShowCompStrRaw = (opts & OFLAG(s)) != 0;
        fDumpInputContext = (opts & OFLAG(d)) != 0;
        fShowIMCMinInfo = (opts & OFLAG(h)) || fDumpInputContext;
        fShowModeSaver = (opts & OFLAG(r)) != 0;

        if (opts & OFLAG(w)) {
            //
            // Arg is hwnd or pwnd.
            //
            PTR pwnd;

            if ((pwnd = HorPtoP(param1, TYPE_WINDOW)) == 0) {
                return FALSE;
            }
            Print("pwnd=%p\n", pwnd);
            GetFieldValue(pwnd, SYM(tagWND), "hImc", param1);
            if (param1 == 0) {
                Print("Could not read pwnd->hImc.\n");
                return FALSE;
            }
        }

        if (opts & OFLAG(c)) {
            //
            // Arg is client side IMC
            //
            pClientImc = param1;
            goto LClientImc;
        }

        if (opts & OFLAG(i)) {
            //
            // Arg is pInputContext.
            //
            pInputContext = param1;
            opts |= OFLAG(h);   // otherwise, nothing will be displayed !
            hInputContext = 0;
            if (opts & OFLAG(u)) {
                Print("Assuming Input Context is UNICODE.\n");
            } else {
                Print("Assuming Input Context is ANSI.\n");
            }
            goto LInputContext;
        }

        //
        // Otherwise, Arg is hImc.
        //
        if ((pImc = HorPtoP(param1, TYPE_INPUTCONTEXT)) == 0) {
            Print("Idimc: %p is not an input context.\n", param1);
            return FALSE;
        }

        Print("pImc=%p\n", pImc);

        InitTypeRead(pImc, win32k!IMC);
        Print("pti:%p\n", ReadField(head.pti));

#ifdef KERNEL
        // Print simple thread info.
        if (ReadField(head.pti)) {
            Idt(OFLAG(p), ReadField(head.pti));
        }
#endif

        InitTypeRead(pImc, win32k!IMC);
        //
        // Basic information
        //
        Print("pImc = %08p  pti:%08p\n", pImc, FIXKP(ReadField(head.pti)));
        Print("  handle      %08p\n", ReadField(head.h));
        Print("  dwClientImc %08p\n", ReadField(dwClientImcData));
        Print("  hImeWnd     %08p\n", ReadField(hImeWnd));

        //
        // Show client IMC
        //
        pClientImc = ReadField(dwClientImcData);
        Print("pClientImc: %p\n", pClientImc);

LClientImc:
        if (pClientImc == 0) {
            Print("pClientImc is NULL.\n");
            return TRUE;
        }
        InitTypeRead(pClientImc, user32!CLIENTIMC);

        if (fVerbose) {
            dso("user32!CLIENTIMC", pClientImc, 0);
        } else {
            Print("pClientImc @ 0x%p  cLockObj:0x%x\n", ReadField(dwClientImcData), ReadField(cLockObj));
        }
        Print("  dwFlags %s\n", GetFlags(GF_CLIENTIMC, (DWORD)ReadField(dwFlags), NULL, TRUE));
        fUnicode = !!(ReadField(dwFlags) & IMCF_UNICODE);

        //
        // Show InputContext
        //
        hInputContext = ReadField(hInputContext);
        if (hInputContext) {
            pInputContext = GetPointer(hInputContext);
        } else {
            pInputContext = 0;
        }
LInputContext:
        Print("InputContext 0x%08p (@ 0x%08p)", hInputContext, pInputContext);

        if (pInputContext == 0) {
            Print("\n");
            return TRUE;
        }

        //
        // if UNICODE specified by the option,
        // set the flag accordingly
        //
        if (opts & OFLAG(u)) {
            fUnicode = TRUE;
        }

        InitTypeRead(pInputContext, win32k!INPUTCONTEXT);
        Print("   hwnd=%p\n", ReadField(hWnd));

        if (fVerbose) {
            dso(SYM(INPUTCONTEXT), pInputContext, 0);
        }


        //
        // Decipher InputContext.
        //
        if (fShowIMCMinInfo) {
            // COMPOSITIONSTRING
            PTR hCompStr = 0;
            PTR pCompStr = NULL_PTR;
            // CANDIDATEINFO
            PTR hCandInfo = 0;
            PTR pCandInfo = NULL_PTR;
            // GUIDELINE
            PTR hGuideLine = 0;
            PTR pGuideLine = NULL_PTR;
            // TRANSMSGLIST
            PTR hMsgBuf = 0;
            PTR pMsgBuf = NULL_PTR;
            DWORD i;

            Print("  dwRefCount: 0x%x      fdwDirty: %s\n",
                  (DWORD)ReadField(dwRefCount), GetFlags(GF_IMEDIRTY, (DWORD)ReadField(fdwDirty), NULL, TRUE));
            Print("  Conversion: %s\n", GetFlags(GF_CONVERSION, (DWORD)ReadField(fdwConversion), NULL, TRUE));
            Print("  Sentence:   %s\n", GetFlags(GF_SENTENCE, (DWORD)ReadField(fdwSentence), NULL, TRUE));
            Print("  fChgMsg:    %d     uSaveVKey:   %02x %s\n",
                  (DWORD)ReadField(fChgMsg),
                  (DWORD)ReadField(uSavedVKey), GetVKeyName((UINT)ReadField(uSavedVKey)));
            Print("  StatusWnd:  (0x%x,0x%x)   SoftKbd: (0x%x,0x%x)\n",
                  (LONG)ReadField(ptStatusWndPos.x), (LONG)ReadField(ptStatusWndPos.y),
                  (LONG)ReadField(ptSoftKbdPos.x), (LONG)ReadField(ptSoftKbdPos.y));
            Print("  fdwInit:    %s\n", GetFlags(GF_IMEINIT, (DWORD)ReadField(fdwInit), NULL, TRUE));
            // Font
            {
                PINPUTCONTEXT pIC;    // dummy for sizeof
                LPCSTR fmt = "  Font:       '%s' %dpt wt:%d charset: %s\n";
                BYTE ach[max(sizeof(pIC->lfFont.A.lfFaceName), sizeof(pIC->lfFont.W.lfFaceName))];

                if (fUnicode) {
                    ULONG offset;

                    fmt = "  Font:       '%S' %dpt wt:%d charset: %s\n";
                    GetFieldOffset(SYM(INPUTCONTEXT), "lfFont.W.lfFaceName", &offset);
                    tryMoveBlock(ach, pInputContext + offset, sizeof(pIC->lfFont.W.lfFaceName));
                         // assuming WCHAR and alignment is consistent cross-platform...
                } else {
                    ULONG offset;
                    GetFieldOffset(SYM(INPUTCONTEXT), "lfFont.A.lfFaceName", &offset);
                    tryMoveBlock(ach, pInputContext + offset, sizeof(pIC->lfFont.A.lfFaceName));
                }
                Print(fmt,
                      ach,
                      ReadField(lfFont.A.lfHeight),
                      ReadField(lfFont.A.lfWeight),
                      GetMaskedEnum(EI_CHARSETTYPE, (DWORD)ReadField(lfFont.A.lfCharSet), NULL));
            }

            // COMPOSITIONFORM
            Print("  cfCompForm: %s pos:(0x%x,0x%x) rc:(0x%x,0x%x)-(0x%x,0x%x)\n",
                  GetFlags(GF_IMECOMPFORM, (DWORD)ReadField(cfCompForm.dwStyle), NULL, TRUE),
                  (DWORD)ReadField(cfCompForm.ptCurrentPos.x), (DWORD)ReadField(cfCompForm.ptCurrentPos.y),
                  (DWORD)ReadField(cfCompForm.rcArea.left), (DWORD)ReadField(cfCompForm.rcArea.top),
                  (DWORD)ReadField(cfCompForm.rcArea.right), (DWORD)ReadField(cfCompForm.rcArea.bottom));

            if (hCompStr = ReadField(hCompStr)) {
                if ((pCompStr = GetPointer(hCompStr)) == 0) {
                    Print("Could not get hCompStr=%p\n", hCompStr);
                } else if (fVerbose) {
                    dso(SYM(COMPOSITIONSTRING), pCompStr, 0);
                }
            }

            if (hCandInfo = ReadField(hCandInfo)) {
                if ((pCandInfo = GetPointer(hCandInfo)) == 0) {
                    Print("Could not get hCandInfo=%p\n", hCandInfo);
                } else if (fVerbose) {
                    dso(SYM(CANDIDATEINFO), pCandInfo, 0);
                }
            }

            if (hGuideLine = ReadField(hGuideLine)) {
                if ((pGuideLine = GetPointer(hGuideLine)) == 0) {
                    Print("Could not get hGuideLine=%p\n", hGuideLine);
                } else if (fVerbose) {
                    dso(SYM(GUIDELINE), pGuideLine, 0);
                }
            }

            if (hMsgBuf = ReadField(hMsgBuf)) {
                if ((pMsgBuf = GetPointer(hMsgBuf)) == 0) {
                    Print("Could not get hMsgBuf=%p\n", hMsgBuf);
                } else if (fVerbose) {
                    dso(SYM(TRANSMSGLIST), pMsgBuf, 0);
                }
            }

            if (!fDumpInputContext && !fVerbose) {
                Print("  CompStr @ 0x%p  CandInfo @ 0x%p  GuideL @ 0x%p  \n",
                    pCompStr, pCandInfo, pGuideLine);
                Print("  MsgBuf @ 0x%p (0x%x)\n", pMsgBuf, ReadField(dwNumMsgBuf));
            }

            if (fDumpInputContext) {
                //
                // Composition String
                //
                if (pCompStr) {

                    InitTypeRead(pCompStr, win32k!COMPOSITIONSTRING);

                    Print(" hCompositionString: %p (@ 0x%p) dwSize=0x%x\n",
                          hCompStr, pCompStr, (ULONG)ReadField(dwSize));

                    if (fShowCompStrRaw) {
                        _PrintInxAttr(NULL, /*NULL*/0, 0, 0);
                        PrintInxElementA(CompRead);
                        PrintInxElementA(Comp);
                        PrintInxElementB(ResultRead);
                        PrintInxElementB(Result);
                    }

                    Print("  CursorPos=0x%x  DeltaStart=0x%x\n",
                        ReadField(dwCursorPos), ReadField(dwDeltaStart));
                    Print("  Private: (@ 0x%p) off:0x%x len:0x%x\n",
                        (PBYTE)pCompStr + ReadField(dwPrivateOffset),
                        ReadField(dwPrivateOffset), ReadField(dwPrivateSize));

                    Print("\n");

                    PrintInxFriendlyStrA(CompRead);
                    PrintInxFriendlyStrA(Comp);
                    PrintInxFriendlyStrB(ResultRead);
                    PrintInxFriendlyStrB(Result);

                    Print("\n");
                } else {
                    Print(" pCompStr is NULL\n");
                }

                //
                // Candidate Info
                //
                if (pCandInfo) {
                    DWORD CandInfo_dwCount;

                    InitTypeRead(pCandInfo, win32k!CANDIDATEINFO);
                    CandInfo_dwCount = (DWORD)ReadField(dwCount);

                    Print(" hCandidateInfo: %p (@ 0x%p) dwSize=0x%x dwCount=0x%x PrivOffset=0x%x PrivSize=0x%x\n",
                          hCandInfo, pCandInfo, ReadField(dwSize), ReadField(dwCount),
                          ReadField(dwPrivateOffset), ReadField(dwPrivateSize));

                    for (i = 0; i < CandInfo_dwCount; ++i) {
                        PTR pCandList;
                        DWORD j;
                        DWORD CandList_dwCount;

                        pCandList = pCandInfo + GetArrayElement(pCandInfo, SYM(CANDIDATEINFO), "dwOffset", i, "DWORD");
                        InitTypeRead(pCandList, win32k!CANDIDATELIST);

                        Print("   CandList[%02x] (@ 0x%p) %s count=%x sel=%x pgStart=%x pgSize=%x\n",
                              i, pCandList, GetMaskedEnum(EI_IMECANDIDATESTYLE, (DWORD)ReadField(dwStyle), NULL),
                              (DWORD)ReadField(dwCount),
                              (DWORD)ReadField(dwSelection), (DWORD)ReadField(dwPageStart), (DWORD)ReadField(dwPageSize));

                        CandList_dwCount = (DWORD)ReadField(dwCount);

                        if (ReadField(dwStyle) == IME_CAND_CODE && CandList_dwCount == 1) {
                            // Special case
                            Print("     Special case: DBCS char = %04x", (DWORD)GetArrayElement(pCandList, SYM(CANDIDATEINFO), "dwOffset", 0, "DWORD"));
                        } else if (CandList_dwCount > 1) {
                            DWORD dwSelection = (DWORD)ReadField(dwSelection);

                            for (j = 0; j < CandList_dwCount; ++j) {
                                DWORD k;
                                DWORD dwOffset;

                                dwOffset = (DWORD)GetArrayElement(pCandList, SYM(CANDIDATEINFO), "dwOffset", j, "DWORD");

                                Print("    %c%c[%02x] @ 0x%p ",
                                      j == dwSelection ? '*' : ' ',
                                      (j >= ReadField(dwPageStart) && j < ReadField(dwPageStart) + ReadField(dwPageSize) ? '+' : ' ',
                                      j, pCandList + dwOffset));
                                for (k = 0; k < 0x100; ++k) {   // limit upto 0xff cch
                                    WCHAR wchar;

                                    if (fUnicode) {
                                        wchar = GetWord(pCandList + dwOffset + k * sizeof(wchar));
                                    } else {
                                        wchar = GetByte(pCandList + dwOffset + k);
                                    }
                                    if (wchar == 0) {
                                        break;
                                    }
                                    Print("|%s", GetInxStr(wchar, fUnicode));
                                }
                                Print("|\n");
                            }
                        }
                    }
                }

                if (pGuideLine) {
                    //GUIDELINE GuideLine;
                    DWORD GuideLine_dwStrLen, GuideLine_dwStrOffset;

                    InitTypeRead(pGuideLine, user32!GUIDELINE);

                    GuideLine_dwStrLen = (DWORD)ReadField(dwStrLen);
                    GuideLine_dwStrOffset = (DWORD)ReadField(dwStrOffset);

                    Print(" hGuideLine: %p (@ 0x%p) dwSize=0x%x\n",
                        hGuideLine, pGuideLine, (DWORD)ReadField(dwSize));

                    Print("   level:%x index;%x privOffset:%x privSize:%x\n",
                          (DWORD)ReadField(dwLevel), (DWORD)ReadField(dwIndex),
                          (DWORD)ReadField(dwPrivateSize), (DWORD)ReadField(dwPrivateOffset));

                    if (GuideLine_dwStrOffset && GuideLine_dwStrLen) {
                        // String
                        Print("   str @ 0x%p  ", (PBYTE)pGuideLine + (DWORD)ReadField(dwStrOffset));
                        for (i = 0; i < GuideLine_dwStrLen; ++i) {
                            WCHAR wchar;

                            if (fUnicode) {
                                wchar = GetWord(pGuideLine + GuideLine_dwStrOffset + i * sizeof(WCHAR));
                            } else {
                                wchar = GetByte(pGuideLine + GuideLine_dwStrOffset + i);
                            }
                            Print("|%s", GetInxStr(wchar, fUnicode));
                        }
                        Print("|\n");
                    }
                }

                if (pMsgBuf) {
                    DWORD dwNumMsgBuf;

                    InitTypeRead(pInputContext, user32!INPUTCONTEXT);

                    dwNumMsgBuf = (DWORD)ReadField(dwNumMsgBuf);

                    InitTypeRead(pMsgBuf, user32!TRANSMSGLIST);

                    Print(" hMsgBuf: %p (@ 0x%p) dwNumMsgBuf=0x%x uMsgCount=0x%x\n",
                        hMsgBuf, pMsgBuf, dwNumMsgBuf,
                        ReadField(uMsgCount));

                    if (dwNumMsgBuf) {
                        ULONG offset;
                        PTR pTransMsg;  // PTRANSMSG
                        ULONG size;
                        GetFieldOffset("user32!TRANSMSGLIST", "TransMsg", &offset);
                        pTransMsg = pMsgBuf + offset;
                        size = GetTypeSize("user32!TRANSMSG");

                        Print("  | ## |msg | wParam | lParam |\n");
                        Print("  +----+----+--------+--------+\n");

                        for (i = 0; i < dwNumMsgBuf; ++i, pTransMsg += size) {
                            const char* pszMsg = "";
                            //DWORD j;
                            UINT message;

                            InitTypeRead(pTransMsg, user32!TRANSMSG);

                            message = (UINT)ReadField(message);

                            pszMsg = GetWindowMessageNameInternal(message);
#if 0
                            // Try to find a readable name of the window message
                            for (j = 0; j < ARRAY_SIZE(gaMsgs); ++j) {
                                if (gaMsgs[i].msg == message) {
                                    pszMsg = gaMsgs[j].pszMsg;
                                    break;
                                }
                            }
#endif

                            Print("   | %02x |%04x|%08x|%08x| %s\n",
                                i,
                                message, ReadField(wParam), ReadField(lParam), pszMsg);
                        }
                        Print("  +----+----+--------+--------+\n");
                    }
                }

            }
        }

        //
        // Recursively display Mode Savers.
        //
        if (fShowModeSaver) {
            PTR pModeSaver;

            InitTypeRead(pInputContext, user32!INPUTCONTEXT);

            pModeSaver = ReadField(pImeModeSaver);

            //
            // Private Mode Savers.
            //
            while (pModeSaver) {
                InitTypeRead(pModeSaver, user32!IMEMODESAVER);

                Print("ImeModeSaver @ 0x%p -- LangId=%04p fOpen=%d\n",
                      pModeSaver, ReadField(langId), (int)ReadField(fOpen));
                Print("    fdwInit      %s\n", GetFlags(GF_IMEINIT, (DWORD)ReadField(fdwInit), NULL, TRUE));
                Print("    Conversion   %s\n", GetFlags(GF_CONVERSION, (DWORD)ReadField(fdwConversion), NULL, TRUE));
                Print("    Sentence     %s\n", GetFlags(GF_SENTENCE, (DWORD)ReadField(fdwSentence), NULL, TRUE));
                pModeSaver = ReadField(next);
            }
        }
    } except (CONTINUE) {
    }

    return TRUE;
}


#if OLD_FORM
//////////////////////////////////////////////////////////
// OLD_FORM, that doesn't require the user mode symbol
//////////////////////////////////////////////////////////

VOID __PrintInxAttr(
    const char* title,
    PVOID pCompStr,
    DWORD offset,
    DWORD len)
{
    DWORD i;
    PBYTE pAttr = (PBYTE)pCompStr + offset;

    if (title == NULL) {
        // Print a legend
        Print("  ");
        for (i = 0; i < ARRAY_SIZE(gaIMCAttr); ++i) {
            if (i && i % 4 == 0) {
                Print("\n");
                Print("  ");
            }
            Print("%s:%s ", gaIMCAttr[i].terse, gaIMCAttr[i].verbose);
        }
        Print("\n");
        return;
    }

    if (offset == 0 || len == 0) {
        return;
    }

    Print("  %-12s (@ 0x%p) off:0x%x len:0x%x (in byte)\n",
          title, pAttr, offset, len);
    Print("   ");
    for (i = 0; i < len; ++i) {
        BYTE bAttr;

        move(bAttr, pAttr + i);
        Print("|%s", GetInxAttr(bAttr));
    }
    Print("|\n");
}

#define _PrintInxAttr(name) \
    __PrintInxAttr(#name, pCompStr, CompStr.dw ## name ## Offset, CompStr.dw ## name ## Len)

VOID __PrintInxClause(
    const char* title,
    PVOID pCompStr,
    DWORD offset,
    DWORD len)
{
    PDWORD pClause = (PDWORD)((PBYTE)pCompStr + offset);
    DWORD i;

    if (offset == 0 || len == 0) {
        return;
    }

    Print("  %-12s (@ 0x%p) off:0x%x len:0x%x (0x%x dwords)\n",
          title, pClause, offset, len, len / sizeof(DWORD));

    Print("   ");
    len /= sizeof(DWORD);
    for (i = 0; i < len; ++i) {
        DWORD dwData;

        move(dwData,  pClause + i);
        Print("|0x%x", dwData);
    }
    Print("|\n");
}

#define _PrintInxClause(name) \
    __PrintInxClause(#name, pCompStr, CompStr.dw ## name ## Offset, CompStr.dw ## name ## Len)

#if 0
const char* GetInxStr(WCHAR wchar, BOOLEAN fUnicode)
{
    static char ach[32];

    if (wchar >= 0x20 && wchar <= 0x7e) {
        sprintf(ach, "'%c'", wchar);
    } else if (fUnicode) {
        sprintf(ach, "U+%04x", wchar);
    } else {
        sprintf(ach, "%02x", (BYTE)wchar);
    }

    return ach;
}
#endif

VOID __PrintInxStr(
    const char* title,
    PVOID pCompStr,
    DWORD offset,
    DWORD len,
    BOOLEAN fUnicode)
{
    DWORD i;

    if (offset == 0 || len == 0) {
        return;
    }

    Print("  %-12s (@ 0x%p) off:0x%x len:0x%x (0x%x cch)\n",
        title, (PBYTE)pCompStr + offset, offset, len, len / (fUnicode + 1));

    Print("   ");
    for (i = 0; i < len; ++i) {
        WCHAR wchar;
        if (fUnicode) {
            move(wchar, (PWCHAR)((PBYTE)pCompStr + offset) + i);
        }
        else {
            BYTE bchar;

            move(bchar, (PBYTE)pCompStr + offset + i);
            wchar = bchar;
        }
        Print("|%s", GetInxStr(wchar, fUnicode));
    }
    Print("|\n");
}

#define PrintInxStr(name) \
    _PrintInxStr(#name, pCompStr, CompStr.dw ## name ## Offset, CompStr.dw ## name ## Len, fUnicode)


#define _PrintInxElementA(name) \
    do { \
        __PrintInxAttr(name ## Attr); \
        __PrintInxClause(name ## Clause); \
        __PrintInxStr(name ## Str); \
    } while (0)

#define _PrintInxElementB(name) \
    do { \
        __PrintInxClause(name ## Clause); \
        __PrintInxStr(name ## Str); \
    } while (0)


VOID __PrintInxFriendlyStr(
    const char* title,
    PBYTE pCompStr,
    DWORD dwAttrOffset,
    DWORD dwAttrLen,
    DWORD dwClauseOffset,
    DWORD dwClauseLen,
    DWORD dwStrOffset,
    DWORD dwStrLen,
    BOOLEAN fUnicode)
{
    DWORD i;
    DWORD n;
    DWORD dwClause;

    Print("  %-11s", title);
    if (dwStrOffset == 0 || dwStrLen == 0) {
        Print("\n");
        return;
    }

    for (i = 0, n = 0; i < dwStrLen; ++i) {
        BYTE bAttr;
        WCHAR wchar;

        move(dwClause, (PDWORD)(pCompStr + dwClauseOffset) + n);
        if (dwClause == i) {
            ++n;
            if (i) {
                Print("| ");
            }
        }

        if (fUnicode) {
            move(wchar, (PWCHAR)((PBYTE)pCompStr + dwStrOffset) + i);
        }
        else {
            BYTE bchar;
            move(bchar, (PBYTE)pCompStr + dwStrOffset + i);
            wchar = bchar;
        }

        if (dwAttrOffset != ~0) {
            move(bAttr, pCompStr + dwAttrOffset + i);
            Print("|%s:%s", GetInxAttr(bAttr), GetInxStr(wchar, fUnicode));
        }
        else {
            Print("|%s", GetInxStr(wchar, fUnicode));
        }
    }
    Print("|\n");
    if (dwClauseLen / sizeof(DWORD) != (n + 1)) {
        Print("  ** dwClauseLen (0x%x) doesn't match to n (0x%x) **\n", dwClauseLen, (n + 1) * sizeof(DWORD));
    }
    if (dwAttrOffset != ~0 && dwAttrLen != dwStrLen) {
        Print("  ** dwAttrLen (0x%x) doesn't match to dwStrLen (0x%x) **\n", dwAttrLen, dwStrLen);
    }
}

#define __PrintInxFriendlyStrA(name) \
    __PrintInxFriendlyStr(#name, \
                         (PBYTE)pCompStr, \
                         CompStr.dw ## name ## AttrOffset, \
                         CompStr.dw ## name ## AttrLen, \
                         CompStr.dw ## name ## ClauseOffset, \
                         CompStr.dw ## name ## ClauseLen, \
                         CompStr.dw ## name ## StrOffset, \
                         CompStr.dw ## name ## StrLen, \
                         fUnicode)

#define _PrintInxFriendlyStrB(name) \
    __PrintInxFriendlyStr(#name, \
                         (PBYTE)pCompStr, \
                         ~0, \
                         0, \
                         CompStr.dw ## name ## ClauseOffset, \
                         CompStr.dw ## name ## ClauseLen, \
                         CompStr.dw ## name ## StrOffset, \
                         CompStr.dw ## name ## StrLen, \
                         fUnicode)


BOOL I_dimc(DWORD opts, ULONG64 param1)
{
    IMC imc;
    PIMC pImc;
    PCLIENTIMC pClientImc;
    CLIENTIMC ClientImc;
    PINPUTCONTEXT pInputContext;
    INPUTCONTEXT InputContext;
    HANDLE hInputContext;
    BOOLEAN fUnicode = FALSE;
    BOOLEAN fVerbose, fDumpInputContext, fShowIMCMinInfo, fShowModeSaver, fShowCompStrRaw;
    char ach[32];

    if (param1 == 0) {
        Print("!dimc -? for help\n");
        return FALSE;
    }

    //
    // If "All" option is specified, set all bits in opts
    // except type specifiers.
    //
    if (opts & OFLAG(a)) {
        opts |= ~(OFLAG(w) | OFLAG(c) | OFLAG(i) | OFLAG(u));
    }

    fVerbose = !!(opts & OFLAG(v));
    fShowCompStrRaw = (opts & OFLAG(s)) || fVerbose;
    fDumpInputContext = (opts & OFLAG(d)) || fShowCompStrRaw || fVerbose;
    fShowIMCMinInfo = (opts & OFLAG(h)) || fDumpInputContext || fVerbose;
    fShowModeSaver = (opts & OFLAG(r)) || fVerbose;

    if (opts & OFLAG(w)) {
        //
        // Arg is hwnd or pwnd.
        //
        PWND pwnd;

        if ((pwnd = HorPtoP(param1, TYPE_WINDOW)) == 0) {
            return FALSE;
        }
        Print("pwnd=%p\n", pwnd);
        if (!tryMove(param1, &pwnd->hImc)) {
            Print("Could not read pwnd->hImc.\n");
            return FALSE;
        }
    }

    if (opts & OFLAG(c)) {
        //
        // Arg is client side IMC
        //
        pClientImc = param1;
        goto LClientImc;
    }

    if (opts & OFLAG(i)) {
        //
        // Arg is pInputContext.
        //
        pInputContext = param1;
        opts |= OFLAG(h);   // otherwise, nothing will be displayed !
        hInputContext = 0;
        if (opts & OFLAG(u)) {
            Print("Assuming Input Context is UNICODE.\n");
        }
        else {
            Print("Assuming Input Context is ANSI.\n");
        }
        goto LInputContext;
    }

    //
    // Otherwise, Arg is hImc.
    //
    if ((pImc = HorPtoP(param1, TYPE_INPUTCONTEXT)) == 0) {
        Print("Idimc: %x is not an input context.\n", param1);
        return FALSE;
    }
    //move(imc, FIXKP(pImc));
    move(imc, pImc);

#ifdef KERNEL
    // Print simple thread info.
    if (imc.head.pti) {
        Idt(OFLAG(p), (PTR)imc.head.pti);
    }
#endif

    //
    // Basic information
    //
    Print("pImc = %08lx  pti:%08lx\n", pImc, FIXKP(imc.head.pti));
    Print("  handle      %08lx\n", imc.head.h);
    Print("  dwClientImc %08lx\n", imc.dwClientImcData);
    Print("  hImeWnd     %08lx\n", imc.hImeWnd);

    //
    // Show client IMC
    //
    pClientImc = (PVOID)imc.dwClientImcData;
LClientImc:
    if (pClientImc == NULL) {
        Print("pClientImc is NULL.\n");
        return TRUE;
    }
    move(ClientImc, pClientImc);

    if (fVerbose) {
        sprintf(ach, "CLIENTIMC %p", pClientImc);
        Idso(0, ach);
    }
    else {
        Print("pClientImc @ 0x%p  cLockObj:0x%x\n", imc.dwClientImcData, ClientImc.cLockObj);
    }
    Print("  dwFlags %s\n", GetFlags(GF_CLIENTIMC, ClientImc.dwFlags, NULL, TRUE));
    fUnicode = !!(ClientImc.dwFlags & IMCF_UNICODE);

    //
    // Show InputContext
    //
    hInputContext = ClientImc.hInputContext;
    if (hInputContext) {
        move(pInputContext, hInputContext);
    }
    else {
        pInputContext = NULL;
    }
LInputContext:
    Print("InputContext %08lx (@ 0x%p)", hInputContext, pInputContext);

    if (pInputContext == NULL) {
        Print("\n");
        return TRUE;
    }

    //
    // if UNICODE specified by the option,
    // set the flag accordingly
    //
    if (opts & OFLAG(u)) {
        fUnicode = TRUE;
    }

    move(InputContext, pInputContext);
    Print("   hwnd=%p\n", InputContext.hWnd);

    if (fVerbose) {
        sprintf(ach, "INPUTCONTEXT %p", pInputContext);
        Idso(0, ach);
    }


    //
    // Decipher InputContext.
    //
    if (fShowIMCMinInfo) {
        PCOMPOSITIONSTRING pCompStr = NULL;
        PCANDIDATEINFO pCandInfo = NULL;
        PGUIDELINE pGuideLine = NULL;
        PTRANSMSGLIST pMsgBuf = NULL;
        DWORD i;

        Print("  dwRefCount: 0x%x      fdwDirty: %s\n",
              InputContext.dwRefCount, GetFlags(GF_IMEDIRTY, InputContext.fdwDirty, NULL, TRUE));
        Print("  Conversion: %s\n", GetFlags(GF_CONVERSION, InputContext.fdwConversion, NULL, TRUE));
        Print("  Sentence:   %s\n", GetFlags(GF_SENTENCE, InputContext.fdwSentence, NULL, TRUE));
        Print("  fChgMsg:    %d     uSaveVKey:   %02x %s\n",
              InputContext.fChgMsg,
              InputContext.uSavedVKey, GetVKeyName(InputContext.uSavedVKey));
        Print("  StatusWnd:  (0x%x,0x%x)   SoftKbd: (0x%x,0x%x)\n",
              InputContext.ptStatusWndPos.x, InputContext.ptStatusWndPos.y,
              InputContext.ptSoftKbdPos.x, InputContext.ptSoftKbdPos.y);
        Print("  fdwInit:    %s\n", GetFlags(GF_IMEINIT, InputContext.fdwInit, NULL, TRUE));
        // Font
        {
            LPCSTR fmt = "  Font:       '%s' %dpt wt:%d charset: %s\n";
            if (fUnicode) {
                fmt = "  Font:       '%S' %dpt wt:%d charset: %s\n";
            }
            Print(fmt,
                  InputContext.lfFont.A.lfFaceName,
                  InputContext.lfFont.A.lfHeight,
                  InputContext.lfFont.A.lfWeight,
                  GetMaskedEnum(EI_CHARSETTYPE, InputContext.lfFont.A.lfCharSet, NULL));
        }

        // COMPOSITIONFORM
        Print("  cfCompForm: %s pos:(0x%x,0x%x) rc:(0x%x,0x%x)-(0x%x,0x%x)\n",
              GetFlags(GF_IMECOMPFORM, InputContext.cfCompForm.dwStyle, NULL, TRUE),
              InputContext.cfCompForm.ptCurrentPos.x, InputContext.cfCompForm.ptCurrentPos.y,
              InputContext.cfCompForm.rcArea.left, InputContext.cfCompForm.rcArea.top,
              InputContext.cfCompForm.rcArea.right, InputContext.cfCompForm.rcArea.bottom);

        if (InputContext.hCompStr) {
            if (!tryMove(pCompStr, InputContext.hCompStr)) {
                Print("Could not get hCompStr=%08x\n", InputContext.hCompStr);
                //return FALSE;
            }
        }
        if (pCompStr && fVerbose) {
            sprintf(ach, "COMPOSITIONSTRING %p", pCompStr);
            Idso(0, ach);
        }

        if (InputContext.hCandInfo) {
            if (!tryMove(pCandInfo, InputContext.hCandInfo)) {
                Print("Could not get hCandInfo=%08x\n", InputContext.hCandInfo);
                //return FALSE;
            }
        }
        if (pCandInfo && fVerbose) {
            sprintf(ach, "CANDIDATEINFO %p", pCandInfo);
            Idso(0, ach);
        }

        if (InputContext.hGuideLine) {
            if (!tryMove(pGuideLine, InputContext.hGuideLine)) {
                Print("Could not get hGuideLine=%08x\n", InputContext.hGuideLine);
                //return FALSE;
            }
        }
        if (pGuideLine && fVerbose) {
            sprintf(ach, "GUIDELINE %p", pGuideLine);
            Idso(0, ach);
        }

        if (InputContext.hMsgBuf) {
            if (!tryMove(pMsgBuf, InputContext.hMsgBuf)) {
                Print("Could not get hMsgBuf=%08x\n", InputContext.hMsgBuf);
                //return FALSE;
            }
        }
        if (pMsgBuf && fVerbose) {
            sprintf(ach, "TRANSMSGLIST %p", pMsgBuf);
            Idso(0, ach);
        }

        if (!fDumpInputContext && !fVerbose) {
            Print("  CompStr @ 0x%p  CandInfo @ 0x%p  GuideL @ 0x%p  \n",
                pCompStr, pCandInfo, pGuideLine);
            Print("  MsgBuf @ 0x%p (0x%x)\n", pMsgBuf, InputContext.dwNumMsgBuf);
        }

        if (fDumpInputContext) {
            //
            // Composition String
            //
            if (pCompStr) {
                COMPOSITIONSTRING CompStr;

                move(CompStr, pCompStr);
                Print(" hCompositionString: %p (@ 0x%p) dwSize=0x%x\n",
                    InputContext.hCompStr, pCompStr, CompStr.dwSize);

                if (fShowCompStrRaw) {
                    __PrintInxAttr(NULL, NULL, 0, 0);
                    _PrintInxElementA(CompRead);
                    _PrintInxElementA(Comp);
                    _PrintInxElementB(ResultRead);
                    _PrintInxElementB(Result);
                }

                Print("  CursorPos=0x%x  DeltaStart=0x%x\n",
                    CompStr.dwCursorPos, CompStr.dwDeltaStart);
                Print("  Private: (@ 0x%p) off:0x%x len:0x%x\n",
                    (PBYTE)pCompStr + CompStr.dwPrivateOffset,
                    CompStr.dwPrivateOffset, CompStr.dwPrivateSize);

                Print("\n");

                _PrintInxFriendlyStrA(CompRead);
                _PrintInxFriendlyStrA(Comp);
                _PrintInxFriendlyStrB(ResultRead);
                _PrintInxFriendlyStrB(Result);

                Print("\n");
            }
            else {
                Print(" pCompStr is NULL\n");
            }

            //
            // Candidate Info
            //
            if (pCandInfo) {
                CANDIDATEINFO CandInfo;

                move(CandInfo, pCandInfo);
                Print(" hCandidateInfo: %p (@ 0x%p) dwSize=0x%x dwCount=0x%x PrivOffset=0x%x PrivSize=0x%x\n",
                      InputContext.hCandInfo, pCandInfo, CandInfo.dwSize, CandInfo.dwCount,
                      CandInfo.dwPrivateOffset, CandInfo.dwPrivateSize);

                for (i = 0; i < CandInfo.dwCount; ++i) {
                    PCANDIDATELIST pCandList;
                    CANDIDATELIST CandList;
                    DWORD j;

                    pCandList = (PCANDIDATELIST)((PBYTE)pCandInfo + CandInfo.dwOffset[i]);
                    move(CandList, pCandList);

                    Print("   CandList[%02x] (@ 0x%p) %s count=%x sel=%x pgStart=%x pgSize=%x\n",
                          i, pCandList, GetMaskedEnum(EI_IMECANDIDATESTYLE, CandList.dwStyle, NULL),
                          CandList.dwCount,
                          CandList.dwSelection, CandList.dwPageStart, CandList.dwPageSize);

                    if (CandList.dwStyle == IME_CAND_CODE && CandList.dwCount == 1) {
                        // Special case
                        Print("     Special case: DBCS char = %04x", CandList.dwOffset[0]);
                    }
                    else if (CandList.dwCount > 1) {
                        for (j = 0; j < CandList.dwCount; ++j) {
                            DWORD k;
                            DWORD dwOffset;

                            move(dwOffset, pCandList->dwOffset + j);

                            Print("    %c%c[%02x] @ 0x%p ",
                                  j == CandList.dwSelection ? '*' : ' ',
                                  (j >= CandList.dwPageStart && j < CandList.dwPageStart + CandList.dwPageSize) ? '+' : ' ',
                                  j, (PBYTE)pCandList + dwOffset);
                            for (k = 0; k < 0x100; ++k) {   // limit upto 0xff cch
                                WCHAR wchar;

                                if (fUnicode) {
                                    move(wchar, (PWCHAR)((PBYTE)pCandList + dwOffset) + k);
                                }
                                else {
                                    BYTE bchar;
                                    move(bchar, (PBYTE)pCandList + dwOffset + k);
                                    wchar = bchar;
                                }
                                if (wchar == 0) {
                                    break;
                                }
                                Print("|%s", GetInxStr(wchar, fUnicode));
                            }
                            Print("|\n");
                        }
                    }
                }
            }

            if (pGuideLine) {
                GUIDELINE GuideLine;

                move(GuideLine, pGuideLine);
                Print(" hGuideLine: %p (@ 0x%p) dwSize=0x%x\n",
                    InputContext.hGuideLine, pGuideLine, GuideLine.dwSize);

                Print("   level:%x index;%x privOffset:%x privSize:%x\n",
                      GuideLine.dwLevel, GuideLine.dwIndex,
                      GuideLine.dwPrivateSize, GuideLine.dwPrivateOffset);

                if (GuideLine.dwStrOffset && GuideLine.dwStrLen) {
                    // String
                    Print("   str @ 0x%p  ", (PBYTE)pGuideLine + GuideLine.dwStrOffset);
                    for (i = 0; i < GuideLine.dwStrLen; ++i) {
                        WCHAR wchar;

                        if (fUnicode) {
                            move(wchar, (PWCHAR)((PBYTE)pGuideLine + GuideLine.dwStrOffset) + i);
                        } else {
                            BYTE bchar;
                            move(bchar, (PBYTE)pGuideLine + GuideLine.dwStrOffset + i);
                            wchar = bchar;
                        }
                        Print("|%s", _GetInxStr(wchar, fUnicode));
                    }
                    Print("|\n");
                }
            }

            if (pMsgBuf) {
                TRANSMSGLIST TransMsgList;

                move(TransMsgList, pMsgBuf);
                Print(" hMsgBuf: %p (@ 0x%p) dwNumMsgBuf=0x%x uMsgCount=0x%x\n",
                    InputContext.hMsgBuf, pMsgBuf, InputContext.dwNumMsgBuf,
                    TransMsgList.uMsgCount);

                if (InputContext.dwNumMsgBuf) {
                    PTRANSMSG pTransMsg = pMsgBuf->TransMsg;

                    Print("  | ## |msg | wParam | lParam |\n");
                    Print("  +----+----+--------+--------+\n");

                    for (i = 0; i < InputContext.dwNumMsgBuf; ++i, ++pTransMsg) {
                        const char* pszMsg = "";
                        TRANSMSG TransMsg;
                        //DWORD j;

                        move(TransMsg, pTransMsg);

#if 0
                        // Try to find a readable name of the window message
                        for (j = 0; j < ARRAY_SIZE(gaMsgs); ++j) {
                            if (gaMsgs[i].msg == TransMsg.message) {
                                pszMsg = gaMsgs[j].pszMsg;
                                break;
                            }
                        }
#else
                        pszMsg = GetWindowMessageNameInternal(TransMsg.message);
#endif

                        Print("   | %02x |%04x|%08x|%08x| %s\n",
                            i,
                            TransMsg.message, TransMsg.wParam, TransMsg.lParam, pszMsg);
                    }
                    Print("  +----+----+--------+--------+\n");
                }
            }

        }
    }

    //
    // Recursively display Mode Savers.
    //
    if (fShowModeSaver) {
        PIMEMODESAVER pModeSaver = InputContext.pImeModeSaver;

        //
        // Private Mode Savers.
        //
        while (pModeSaver) {
            IMEMODESAVER ImeModeSaver;

            move(ImeModeSaver, pModeSaver);
            Print("ImeModeSaver @ 0x%p -- LangId=0x%04x fOpen=0y%d\n",
                  pModeSaver, ImeModeSaver.langId, ImeModeSaver.fOpen);
            Print("    fdwInit      %s\n", GetFlags(GF_IMEINIT, ImeModeSaver.fdwInit, NULL, TRUE));
            Print("    Conversion   %s\n", GetFlags(GF_CONVERSION, ImeModeSaver.fdwConversion, NULL, TRUE));
            Print("    Sentence     %s\n", GetFlags(GF_SENTENCE, ImeModeSaver.fdwSentence, NULL, TRUE));
            move(pModeSaver, &pModeSaver->next);
        }
    }

    return TRUE;
}
#endif  // OLD_FORM

#ifdef OLD_DEBUGGER

#ifndef KERNEL
/************************************************************************\
* Procedure: Ikc
*
* Dumps keyboard cues state for the window, and pertinent info on the
* parent KC state and the system settings related to this
*
* 06/11/98 MCostea     Created
*
\************************************************************************/
BOOL Ikc(
    DWORD opts,
    ULONG64 param1)
{
    WND wnd;
    PWND pwnd, pwndParent;
    char ach[80];
    BOOL bHideFocus, bHideAccel;
    SERVERINFO si;
    PSERVERINFO psi;

    if (param1 && (pwnd = HorPtoP(param1, TYPE_WINDOW)) == 0) {
        Print("Idw: %p is not a pwnd.\n", param1);
        return FALSE;
    }
    psi = GetGlobalPointer(VAR(gpsi));
    move(si, psi);

    if (si.bKeyboardPref) {
        Print("gpsi->bKeyboardPref ON, KC mechanism is turned off\n");
    }
    if (!(si.PUSIFlags & (PUSIF_KEYBOARDCUES | PUSIF_UIEFFECTS) == PUSIF_KEYBOARDCUES | PUSIF_UIEFFECTS)) {
        Print("Either the UI effects or PUSIF_KEYBOARDCUES are off\n");
    }

    if (!param1) {
        return FALSE;
    }
    move(wnd, FIXKP(pwnd));
    /*
     * Print pwnd and title string.
     */
    DebugGetWindowTextA(pwnd, ach, ARRAY_SIZE(ach));
    Print("pwnd = %08lx  \"%s\"\n", pwnd, ach);
    bHideAccel = TestWF(pwnd, WEFPUIACCELHIDDEN);
    bHideFocus = TestWF(pwnd, WEFPUIFOCUSHIDDEN);

    switch(wnd.fnid) {
    case FNID_BUTTON :
        {
            Print("FNID_BUTTON");
        }
        goto printCues;
    case FNID_LISTBOX :
        {
            Print("FNID_LISTBOX");
        }
        goto printCues;
    case FNID_DIALOG :
        {
            Print("FNID_DIALOG");
        }
        goto printCues;
    case FNID_STATIC :
        {
            Print("FNID_STATIC");
        }
printCues:
        Print(bHideAccel ? " Hide Accel" : " Show Accel");
        Print(bHideFocus ? " Hide Focus" : " Show Focus");
        break;

    default:
        Print("Not KC interesting FNID 0x%x", wnd.fnid);
        break;
    }
    Print("\n");

    pwndParent = wnd.spwndParent;
    move(wnd, FIXKP(wnd.spwndParent));
    if (wnd.fnid == FNID_DIALOG) {
        Print("The parent is a dialog:\n");
        Ikc(opts, pwndParent);
    } else {
        Print("The parent is not a dialog\n");
    }
    return TRUE;
}
#endif  // KERNEL

#endif // OLD_DEBUGGER

#ifdef KERNEL

/************************************************************************\
* Procedure: Idimk -- dump IME Hotkeys
*
* 08/09/98 HiroYama     Created
*
\************************************************************************/

#define IHK_ITEM(x) { x, #x }

BOOL Idimk(DWORD opts, ULONG64 param1)
{
    try {
        // PIMEHOTKEYOBJ
        PTR pObj;
        static const struct {
            DWORD mask;
            const char* name;
        } masks[] = {
            IHK_ITEM(MOD_IGNORE_ALL_MODIFIER),
            IHK_ITEM(MOD_ON_KEYUP),
            IHK_ITEM(MOD_RIGHT),
            IHK_ITEM(MOD_LEFT),
            IHK_ITEM(MOD_SHIFT),
            IHK_ITEM(MOD_CONTROL),
            IHK_ITEM(MOD_ALT),
        };
        int nHotKeys = 0;

        UNREFERENCED_PARAMETER(opts);

        if (param1 == 0) {
            pObj = GetGlobalPointer(VAR(gpImeHotKeyListHeader));
            if (!pObj) {
                Print("No IME HotKeys. win32k!gpImeHotKeyListHeader is NULL.\n\n");
                return TRUE;
            }
            Print("using win32k!gpImeHotKeyListHeader (@ 0x%p)\n", pObj);
        } else {
            pObj = FIXKP(param1);
        }

        SAFEWHILE (pObj) {
            int i, n;

            InitTypeRead(pObj, win32k!IMEHOTKEYOBJ);

            Print("ImeHotKeyObj @ 0x%p\n", pObj);
            Print("    pNext          0x%p\n", ReadField(pNext));
            Print("    dwHotKeyID     0x%04x    ", ReadField(hk.dwHotKeyID));

            //
            // Show hotkey ID by name
            //
            if (ReadField(hk.dwHotKeyID) >= IME_HOTKEY_DSWITCH_FIRST && ReadField(hk.dwHotKeyID) <= IME_HOTKEY_DSWITCH_LAST) {
                Print(" Direct Switch to HKL 0x%p", ReadField(hk.hKL));
            } else {
                Print(" %s", GetMaskedEnum(EI_IMEHOTKEYTYPE, (DWORD)ReadField(hk.dwHotKeyID), NULL));
            }

            //
            // Show VKey value by name
            //
            Print("\n    uVKey          0x%02x       %s\n", (UINT)ReadField(hk.uVKey), GetVKeyName((DWORD)ReadField(hk.uVKey)));

            //
            // Show bit mask by name
            //
            Print(  "    Modifiers      0x%04x     ", ReadField(hk.uModifiers));
            n = 0;
            for (i = 0; i < ARRAY_SIZE(masks); ++i) {
                if (masks[i].mask & ReadField(hk.uModifiers)) {
                    Print("%s%s", n ? " | " : "", masks[i].name);
                    ++n;
                }
            }

            //
            // Target HKL
            //
            Print("\n    hKL            0x%p\n\n", ReadField(hk.hKL));

            pObj = ReadField(pNext);

            //
            // If address is specified as an argument, just display one instance.
            //
            if (param1 != 0) {
                break;
            }

            ++nHotKeys;
        }
        if (nHotKeys) {
            Print("Number of IME HotKeys: 0x%04x\n", nHotKeys);
        }
    } except (CONTINUE) {
    }

    return TRUE;
}

#undef IHK_ITEM

#endif  // KERNEL

#ifdef KERNEL
/************************************************************************\
* Procedure: Igflags
*
* Dumps NT Global Flags
*
* 08/11/98 Hiroyama     Created
*
\************************************************************************/

#define DGF_ITEM(x) { x, #x }

BOOL Igflags(DWORD opts)
{
    static const struct {
        DWORD dwFlag;
        const char* name;
    } names[] = {
        DGF_ITEM(FLG_STOP_ON_EXCEPTION),
        DGF_ITEM(FLG_SHOW_LDR_SNAPS),
        DGF_ITEM(FLG_DEBUG_INITIAL_COMMAND),
        DGF_ITEM(FLG_STOP_ON_HUNG_GUI),
        DGF_ITEM(FLG_HEAP_ENABLE_TAIL_CHECK),
        DGF_ITEM(FLG_HEAP_ENABLE_FREE_CHECK),
        DGF_ITEM(FLG_HEAP_VALIDATE_PARAMETERS),
        DGF_ITEM(FLG_HEAP_VALIDATE_ALL),
        DGF_ITEM(FLG_POOL_ENABLE_TAGGING),
        DGF_ITEM(FLG_HEAP_ENABLE_TAGGING),
        DGF_ITEM(FLG_USER_STACK_TRACE_DB),
        DGF_ITEM(FLG_KERNEL_STACK_TRACE_DB),
        DGF_ITEM(FLG_MAINTAIN_OBJECT_TYPELIST),
        DGF_ITEM(FLG_HEAP_ENABLE_TAG_BY_DLL),
        DGF_ITEM(FLG_ENABLE_CSRDEBUG),
        DGF_ITEM(FLG_ENABLE_KDEBUG_SYMBOL_LOAD),
        DGF_ITEM(FLG_DISABLE_PAGE_KERNEL_STACKS),
        DGF_ITEM(FLG_HEAP_DISABLE_COALESCING),
        DGF_ITEM(FLG_ENABLE_CLOSE_EXCEPTIONS),
        DGF_ITEM(FLG_ENABLE_EXCEPTION_LOGGING),
        DGF_ITEM(FLG_ENABLE_HANDLE_TYPE_TAGGING),
        DGF_ITEM(FLG_HEAP_PAGE_ALLOCS),
        DGF_ITEM(FLG_DEBUG_INITIAL_COMMAND_EX),
        DGF_ITEM(FLG_DISABLE_DBGPRINT),
    };
    DWORD dwFlags;
    int i, n = 0;

    moveExpValue(&dwFlags, "NT!NtGlobalFlag");
    if (opts & OFLAG(v)) {
        Print("NT!NtGlobalFlag                         %08lx\n\n", dwFlags);
    } else {
        Print("NT!NtGlobalFlag 0x%lx\n", dwFlags);
    }

    dwFlags &= FLG_VALID_BITS;

    for (i = 0; i < ARRAY_SIZE(names); ++i) {
        BOOLEAN on = (dwFlags & names[i].dwFlag) != 0;

        if (opts & OFLAG(v)) {
            Print("  %c%-34s %c(%08x)\n", on ? '*' : ' ', names[i].name, on ? '*' : ' ', names[i].dwFlag);
        } else {
            if (n++ % 2 == 0) {
                Print("\n");
            }
            Print(" %c%-29s ", on ? '*' : ' ', names[i].name + sizeof("FLG_") - 1);
        }
    }
    if (!(opts & OFLAG(v))) {
        Print("\n");
    }

    return TRUE;
}

#undef DGF_ITEM

#endif  // KERNEL

/************************************************************************\
* Procedure: Ivkey
*
* Dumps virtual keys
*
* 08/11/98 Hiroyama     Created
*
\************************************************************************/
VOID PrintVKey(
    int i)
{
    Print("  %02x %s\n", gVKeyDef[i].dwVKey, gVKeyDef[i].name);
}

BOOL Ivkey(
    DWORD opts,
    LPSTR pszName)
{
    int i;

    if ((opts & OFLAG(a)) || (opts & OFLAG(o))) {
        //
        // List all virtual keys.
        //
        int n = 0;

        for (i = 0; i < 0x100; ++i) {
            const char* name = GetVKeyName(i);
            if (*name) {
                char buf[128];
                int len;

                sprintf(buf, " %02x %-35s", i, name);

                if (opts & OFLAG(a)) {
                    //
                    // If it exceeds the second column width, begin new line.
                    //
                    if ((len = strlen(buf)) >= 40 && n % 2 == 1) {
                        Print("\n");
                        n = 0;
                    }
                    Print(buf);
                    //
                    // If it's in the second column, begin new line.
                    //
                    if (++n % 2 == 0 || len >= 40) {
                        Print("\n");
                        n = 0;
                    }
                } else {
                    Print("%s\n", buf);
                }
            }
        }
        Print("\n");
    } else if (*pszName == 'V' || *pszName == 'v') {
        //
        // Search by VK name.
        //
        int nFound = 0;
        int len = strlen(pszName);

        if (len == 4) {
            int ch = pszName[3];

            if ((ch >= 'A' && ch <= 'Z') || (ch >= '0' && ch <= '9')) {
                Print("  %02x %s\n", ch, pszName);
                ++nFound;
            }
        }

        for (i = 0; i < ARRAY_SIZE(gVKeyDef); ++i) {
            if (_strnicmp(gVKeyDef[i].name, pszName, len) == 0) {
                Print("  %02x %s\n", gVKeyDef[i].dwVKey, gVKeyDef[i].name);
                ++nFound;
            }
        }
        if (nFound == 0) {
            Print("Could not find it.\n");
        }
    } else {
        //
        // Search by VK value.
        //
        NTSTATUS status;
        DWORD dwVKey;
        const char* name;

        status = GetInteger(pszName, 16, &dwVKey, NULL);
        if (!NT_SUCCESS(status)) {
            return FALSE;
        }
        name = GetVKeyName(dwVKey);
        if (*name) {
            Print("  %02x %s\n", dwVKey, name);
        } else {
            Print("Could not find it.\n");
        }
    }

    return TRUE;
}

/************************************************************************\
* Procedure: Idisi
*
* Dumps event injection union
*
* 09/??/98 Hiroyama     Created
*
\************************************************************************/

BOOL I_disi(DWORD opts, ULONG64 param1)
{
    PINPUT pObj;
    INPUT input;

#ifdef _IA64_
    if (!IsPtr64()) {
        Print("not on this platform");
        return TRUE;
    }
#else
    if (IsPtr64()) {
        Print("not on this platform");
        return TRUE;
    }
#endif
    UNREFERENCED_PARAMETER(opts);

    if (param1 == 0) {
        return FALSE;
    }

    pObj = (PINPUT)FIXKP(param1);
    move(input, (PTR)pObj);

    Print("INPUT @ 0x%p - size: 0x%x\n", pObj, sizeof(input));

    switch (input.type) {
    case INPUT_MOUSE:
        {
            MOUSEINPUT* pmi = &input.mi;

            Print("type: Mouse Input(%x)\n", input.type);
            Print("     dx          %lx (%ld in dec.)\n", pmi->dx, pmi->dx);
            Print("     dy          %lx (%ld in dec.)\n", pmi->dx, pmi->dx);
            Print("     mouseData   %lx (%ld in dec.)\n", pmi->mouseData, pmi->mouseData);
            Print("     dwFlags     %lx (%s)\n", pmi->dwFlags, GetFlags(GF_MI, pmi->dwFlags, NULL, TRUE));
            Print("     time        %lx\n", pmi->time);
            Print("     dwExtraInfo %lx\n", pmi->dwExtraInfo);
        }
        break;

    case INPUT_KEYBOARD:
        {
            KEYBDINPUT* pki = &input.ki;
            const char* name;

            Print("type: Keyboard Input(%x)\n", input.type);
            //
            // Print Vkey
            //
            Print("     wVk         %lx", pki->wVk);
            name = GetVKeyName(pki->wVk);
            if (*name) {
                Print(" (%s)\n", name);
            } else {
                Print("\n");
            }
            //
            // Print scan code: if KEYEVENTF_UNICODE, it's UNICODE value.
            //
            if (pki->dwFlags & KEYEVENTF_UNICODE) {
                Print("     UNICODE     %lx\n", pki->wScan);
            } else {
                Print("     wScan       %lx\n", pki->wScan);
            }
            //
            // Print and decrypt dwFlags
            //
            Print("     dwFlags     %lx (%s)\n", pki->dwFlags, GetFlags(GF_KI, pki->dwFlags, NULL, TRUE));
            Print("     time        %lx\n", pki->time);
            Print("     dwExtraInfo %lx\n", pki->dwExtraInfo);
        }
        break;

    case INPUT_HARDWARE:
        Print("type: HardwareEvent(%x)\n", input.type);
        Print("         uMsg            %lx\n", input.hi.uMsg);
        Print("         wParamH:wParamL %x:%x\n", input.hi.wParamH, input.hi.wParamL);
        break;

    default:
        Print("Invalid type information(0x%lx)\n", input.type);
        break;
    }

    return TRUE;
}

/************************************************************************\
* Procedure: Iwm
*
* Decrypt window message number
*
* 09/??/98 Hiroyama     Created
*
\************************************************************************/

BOOL IwmWorker(DWORD opts, LPSTR pszName, BOOL fInternalToo)
{
    int len = strlen(pszName);

    UNREFERENCED_PARAMETER(opts);

    if (!(opts & OFLAG(a)) && *pszName == 0) {
        return FALSE;
    }

    if (len >= 3 && pszName[2] == '_' || (opts & OFLAG(a))) {
        //
        // Search by WM name.
        //
        int i;
        int nFound = 0;

        for (i = 0; i < ARRAY_SIZE(gaMsgs); ++i) {
            if (((opts & OFLAG(a)) || _strnicmp(gaMsgs[i].pszMsg, pszName, len) == 0) && (!gaMsgs[i].fInternal || fInternalToo)) {
                Print("  %04x %s\n", gaMsgs[i].msg, gaMsgs[i].pszMsg);
                ++nFound;
            }
        }
        if (nFound == 0) {
            Print("Could not find it.\n");
        }
    } else {
        //
        // Search by WM value.
        //
        DWORD value = (DWORD)EvalExp(pszName);
        int i;

        for (i = 0; i < ARRAY_SIZE(gaMsgs); ++i) {
            if (gaMsgs[i].msg == value && (!gaMsgs[i].fInternal || fInternalToo)) {
                Print("  %04x %s\n", gaMsgs[i].msg, gaMsgs[i].pszMsg);
                break;
            }
        }
    }

    return TRUE;
}

BOOL Iwm(DWORD opts, LPSTR pszName)
{
    return IwmWorker(opts, pszName, FALSE);
}

BOOL I_wm(DWORD opts, LPSTR pszName)
{
    return IwmWorker(opts, pszName, TRUE);
}

//
// Dump Dialog Template
//
//

PBYTE SkipSz(UTCHAR *lpsz, UTCHAR* lpszCopy, UINT len)
{
    UTCHAR c;
    UINT n = 0;

    lpszCopy[len - 1] = 0;

    move(c, (PTR)lpsz);
    if (c == 0xFF) {
        if (lpszCopy) {
            *lpszCopy = 0;
        }
        return (PBYTE)lpsz + 4;
    }

    do {
        move(c, (PTR)lpsz);
        ++lpsz;
        if (++n < len) {
            if (lpszCopy) {
                *lpszCopy ++ = c;
            }
        }
    } while (c != 0);

    return (PBYTE)lpsz;
}


#ifndef NextWordBoundary
#define NextWordBoundary(p)     ((PBYTE)(p) + ((ULONG_PTR)(p) & 1))
#endif
#ifndef NextDWordBoundary
#define NextDWordBoundary(p)    ((PBYTE)(p) + ((ULONG_PTR)(-(LONG_PTR)(p)) & 3))
#endif

PBYTE WordSkipSz(UTCHAR *lpsz, UTCHAR* lpszCopy, UINT len)
{
    PBYTE pb = SkipSz(lpsz, lpszCopy, len);
    return NextWordBoundary(pb);
}

PBYTE DWordSkipSz(UTCHAR *lpsz, UTCHAR* lpszCopy, UINT len)
{
    PBYTE pb = SkipSz(lpsz, lpszCopy, len);
    return NextDWordBoundary(pb);
}

LPCSTR GetCharSetName(BYTE charset)
{
    return GetMaskedEnum(EI_CHARSETTYPE, charset, NULL);
}

VOID ParseDialogFont(LPWORD* lplpstr, LPDLGTEMPLATE2 lpdt)
{
    LOGFONT     LogFont;
    short       tmp;
    int         fontheight, fheight;
    PSERVERINFO gpsi;
    BOOL fDesktopCharset = FALSE;
    WORD   dmLogPixels;

//
//  fheight = fontheight = (SHORT)(*((WORD *) *lplpstr)++);
//
    move(tmp, (PTR)*lplpstr);
    ++*lplpstr;
    fontheight = fheight = tmp;

    if (fontheight == 0x7FFF) {
        // a 0x7FFF height is our special code meaning use the message box font
        Print("\
    Font    System Font (Messagebox font)\n");
        return;
    }


    //
    // The dialog template contains a font description! Use it.
    //
    // Fill the LogFont with default values
    RtlZeroMemory(&LogFont, sizeof(LOGFONT));

    moveExpValue(&gpsi, VAR(gpsi));
    move(dmLogPixels, (ULONG64)&gpsi->dmLogPixels);
    LogFont.lfHeight = -MultDiv(fontheight, dmLogPixels, 72);

    if (lpdt->wDlgVer) {
        WORD w;
        BYTE b;
//
//      LogFont.lfWeight  = *((WORD FAR *) *lplpstr)++;
//
        move(w, (PTR)*lplpstr);
        ++*lplpstr;
        LogFont.lfWeight = w;
//
//      LogFont.lfItalic  = *((BYTE FAR *) *lplpstr)++;
//
        move(b, (PTR)*lplpstr);
        ++((BYTE*)*lplpstr);
        LogFont.lfItalic = b;

//
//      LogFont.lfCharSet = *((BYTE FAR *) *lplpstr)++;
//
        move(b, (PTR)*lplpstr);
        ++((BYTE*)*lplpstr);
        LogFont.lfCharSet = b;
    } else {
        // DIALOG statement, which only has a facename.
        // The new applications are not supposed to use DIALOG statement,
        // they should use DIALOGEX instead.
        LogFont.lfWeight  = FW_BOLD;
        LogFont.lfCharSet = 0;  //(BYTE)GET_DESKTOP_CHARSET();
        fDesktopCharset = TRUE;
    }

    *lplpstr = (WORD*)DWordSkipSz(*lplpstr, LogFont.lfFaceName, ARRAY_SIZE(LogFont.lfFaceName));

    Print("\
    Font    %dpt (%d), Weight: %d, %s Italic, %s,\n\
            \"%ls\"\n",
        fontheight, LogFont.lfHeight,
        LogFont.lfWeight,
        LogFont.lfItalic ? "" : "Not",
        fDesktopCharset ? "DESKTOP_CHARSET" : GetCharSetName(LogFont.lfCharSet),
        LogFont.lfFaceName);
}

LPCSTR GetCtrlStyle(WORD iClass, DWORD style)
{
    WORD type = GF_WS;

    switch (iClass) {
    case ICLS_DIALOG:
        type = GF_DS;
        break;
    case ICLS_STATIC:
        type = GF_SS;
        break;
    case ICLS_EDIT:
        type = GF_ES;
        break;
    case ICLS_BUTTON:
        type = GF_BS;
        break;
    case ICLS_COMBOBOX:
        type = GF_CBS;
        break;
    case ICLS_LISTBOX:
        type = GF_LBS;
        break;
    case ICLS_SCROLLBAR:
        type = GF_SBS;
        break;
    default:
        break;
    }
    return GetFlags(type, style, NULL, FALSE);
}

BOOL I_ddlgt(DWORD opts, ULONG64 param1)
{
#if defined(_IA64_)
    UNREFERENCED_PARAMETER(opts);
    UNREFERENCED_PARAMETER(param1);
    return FALSE;
#else
    LPDLGTEMPLATE lpdt = (LPDLGTEMPLATE)FIXKP(param1);
    DLGTEMPLATE2 dt;
    LPDLGTEMPLATE2 lpdt2 = &dt;
    BOOLEAN fNewDialogTemplate = FALSE;
    UTCHAR* lpszMenu;
    UTCHAR* lpszClass;
    UTCHAR* lpszText;
    UTCHAR* lpStr;
    UTCHAR* lpCreateParams;
    LPCSTR  lpszIClassName;
    WORD w;
    DLGITEMTEMPLATE2    dit;
    LPDLGITEMTEMPLATE   lpdit;
    UTCHAR menuName[64];
    UTCHAR className[64];
    UTCHAR text[64];
    PSERVERINFO gpsi;

    UNREFERENCED_PARAMETER(opts);

    if (opts == 0 && param1 == 0) {
        return FALSE;
    }

    move(w, (PTR)&((LPDLGTEMPLATE2)lpdt)->wSignature);

    if (w == 0xffff) {
        move(dt, (PTR)lpdt);
        fNewDialogTemplate = TRUE;
    } else {
        dt.wDlgVer = 0;
        dt.wSignature = 0;
        dt.dwHelpID = 0;
        move(dt.dwExStyle, (ULONG64)&lpdt->dwExtendedStyle);
        move(dt.style, (ULONG64)&lpdt->style);
        move(dt.cDlgItems, (ULONG64)&lpdt->cdit);
        move(dt.x, (PTR)&lpdt->x);
        move(dt.y, (PTR)&lpdt->y);
        move(dt.cx, (PTR)&lpdt->cx);
        move(dt.cy, (PTR)&lpdt->cy);
    }


    Print("DlgTemplate%s @ 0x%p version 0n%d\n", dt.wDlgVer ? "2" : "", lpdt, dt.wDlgVer);

    if (!(opts & OFLAG(v))) {
        Print("\
    (%d, %d)-(%d,%d) [%d, %d](dec)\n\
    Style   %08lx   ExStyle %08lx   items 0x%x\n",
              dt.x, dt.y, dt.x + dt.cx, dt.y + dt.cy, dt.cx, dt.cy,
              dt.style, dt.dwExStyle, dt.cDlgItems);
    } else {
        Print("\
    (%d,%d)-(%d,%d) [%d,%d] (dec)  item: 0x%lx\n",
              dt.x, dt.y, dt.x + dt.cx, dt.y + dt.cy,
              dt.cx, dt.cy,
              dt.cDlgItems);
        Print("\
    Style   %08lx %s", dt.style, OFLAG(v) ? GetFlags(GF_DS, dt.style, NULL, FALSE) : "");
        if ((dt.style & DS_SHELLFONT) == DS_SHELLFONT) {
            Print(" [DS_SHELLFONT]");
        }
        Print("\n");
        Print("\
    ExStyle %08lx %s\n", dt.dwExStyle, GetFlags(GF_WSEX, dt.dwExStyle, NULL, FALSE));
    }

    // If there's a menu name string, load it.
    lpszMenu = (LPWSTR)(((PBYTE)(lpdt)) + (dt.wDlgVer ? sizeof(DLGTEMPLATE2) : sizeof(DLGTEMPLATE)));

    /*
     * If the menu id is expressed as an ordinal and not a string,
     * skip all 4 bytes to get to the class string.
     */
    move(w, (PTR)(WORD*)lpszMenu);

    /*
     * If there's a menu name string, load it.
     */
    if (w != 0) {
        if (w == 0xffff) {
            LPWORD lpwMenu = (LPWORD)((LPBYTE)lpszMenu + 2);
            move(w, (PTR)lpwMenu);
            Print("\
    menu id     %lx\n", w);
        }
    }

    if (w == 0xFFFF) {
        lpszClass = (LPWSTR)((LPBYTE)lpszMenu + 4);
    } else {
        lpszClass = (UTCHAR *)WordSkipSz(lpszMenu, menuName, ARRAY_SIZE(menuName));
        Print("\
    menu   @ 0x%p \"%ls\"\n", lpszMenu, menuName);
    }

    //
    // Class name
    //
    lpszText = (UTCHAR *)WordSkipSz(lpszClass, className, ARRAY_SIZE(className));
    Print("\
    class  @ 0x%p \"%ls\"\n", lpszClass, className);

    //
    // Window text
    //
    lpStr = (UTCHAR *)WordSkipSz(lpszText, text, ARRAY_SIZE(text));
    Print("\
    text   @ 0x%p \"%ls\"\n", lpszText, text);

    //
    // Font
    //
    if (dt.style & DS_SETFONT) {
        ParseDialogFont(&lpStr, &dt);
    }

    lpdit = (LPDLGITEMTEMPLATE)NextDWordBoundary(lpStr);


    ///////////////////////////////////////////////////
    // if "-r" option is not specified, bail out.
    ///////////////////////////////////////////////////
    if (!(opts & OFLAG(r))) {
        return TRUE;
    }

    Print("\n");

    /*
     * Loop through the dialog controls, doing a CreateWindowEx() for each of
     * them.
     */
    while (dt.cDlgItems-- != 0) {
        WORD iClass = 0;
        //
        // Retrieve basic information.
        //

        if (dt.wDlgVer) {
            move(dit, (PTR)lpdit);
        } else {
            dit.dwHelpID = 0;
            move(dit.dwExStyle, (PTR)&lpdit->dwExtendedStyle);
            move(dit.style, (PTR)&lpdit->style);
            move(dit.x, (PTR)&lpdit->x);
            move(dit.y, (PTR)&lpdit->y);
            move(dit.cx, (PTR)&lpdit->cx);
            move(dit.cy, (PTR)&lpdit->cy);
            move(w, (PTR)&lpdit->id);
            dit.dwID = w;
        }

        Print("\
#ID:0x%04x @ 0x%p HelpID:0x%04x (0n%d, 0n%d)-(0n%d, 0n%d) [0n%d, 0n%d]\n",
            dit.dwID,
            lpdit,
            dit.dwHelpID,
            dit.x, dit.y, dit.x + dit.cx, dit.y + dit.cy,
            dit.cx, dit.cy);

        //
        // Skip DLGITEMTEMPLATE or DLGITEMTEMPLATE2
        //
        lpszClass = (LPWSTR)(((PBYTE)(lpdit)) + (dt.wDlgVer ? sizeof(DLGITEMTEMPLATE2) : sizeof(DLGITEMTEMPLATE)));

        /*
         * If the first WORD is 0xFFFF the second word is the encoded class name index.
         * Use it to look up the class name string.
         */
        move(w, (PTR)lpszClass);
        if (w == 0xFFFF) {
            WORD wAtom;

            lpszText = lpszClass + 2;
#ifdef ORG
            lpszClass = (LPWSTR)(gpsi->atomSysClass[*(((LPWORD)lpszClass)+1) & ~CODEBIT]);
#endif
            moveExpValue(&gpsi, VAR(gpsi));
            move(iClass, (PTR)lpszClass + 1);
            iClass &= ~CODEBIT;
            if (*(lpszIClassName = GetMaskedEnum(EI_CLSTYPE, iClass, NULL)) == '\0') {
                lpszIClassName = NULL;
            }
            move(wAtom, (PTR)&gpsi->atomSysClass[iClass]);
            swprintf(className, L"#%lx", wAtom);
        } else {
            lpszText = (UTCHAR*)SkipSz(lpszClass, className, ARRAY_SIZE(className));
            lpszIClassName = NULL;
        }

        Print("\
    class  @ 0x%p \"%ls\" ", lpszClass, className);
        if (lpszIClassName) {
            Print("= %s", lpszIClassName);
        }
        Print("\n");

        lpszText = (UTCHAR*)NextWordBoundary(lpszText); // UINT align lpszText

//      Our code in InternalCreateDialog does this.
//        dit.dwExStyle |= WS_EX_NOPARENTNOTIFY;
//
        /*
         * Get pointer to additional data.  lpszText can point to an encoded
         * ordinal number for some controls (e.g.  static icon control) so
         * we check for that here.
         */

        move(w, (PTR)lpszText);
        if (w == 0xFFFF) {
            swprintf(text, L"#%lx", w);
            lpCreateParams = (LPWSTR)((PBYTE)lpszText + 4);
        } else {
            lpCreateParams = (LPWSTR)(PBYTE)WordSkipSz(lpszText, text, ARRAY_SIZE(text));
        }

        Print("\
    text   @ 0x%p \"%ls\"\n", lpszText, text);

        Print("\
    style   %08lx %s%s", dit.style,
                (opts & OFLAG(v)) ? GetCtrlStyle(iClass, dit.style) : "",
                (opts & OFLAG(v)) ? "\n" : "");
        Print("\
    ExStyle %08lx %s\n", dit.dwExStyle, (opts & OFLAG(v)) ? GetFlags(GF_WSEX, dit.dwExStyle, NULL, FALSE) : "");

        /*
         * Point at next item template
         */
        move(w, (PTR)lpCreateParams);
        lpdit = (LPDLGITEMTEMPLATE)NextDWordBoundary(
                (LPBYTE)(lpCreateParams + 1) + w);
        Print("\n");
    }


    return TRUE;
#endif  // _IA64_
}

#ifndef KERNEL
BOOL Idimedpi(DWORD opts, ULONG64 param1)
{
    PTR pImeDpi; // IMEDPI

    UNREFERENCED_PARAMETER(opts);

    if (param1 == 0) {
        pImeDpi = GetGlobalPointer("imm32!gpImeDpi");
    }
    else {
        pImeDpi = FIXKP(param1);
    }

    while (pImeDpi) {
        WCHAR wsz[80];
        InitTypeRead(pImeDpi, imm32!IMEDPI);

        Print("IMEDPI @ 0x%p  hInst: 0x%p cLock: 0n%3d", pImeDpi, ReadField(hInst), (DWORD)ReadField(cLock));
        CopyUnicodeString(pImeDpi, "imm32!IMEDPI", "wszUIClass", wsz, ARRAY_SIZE(wsz));
        Print("  CodePage:%4d UI Class: \"%S\"\n", (DWORD)ReadField(dwCodePage), wsz);
        if (opts & OFLAG(i)) {
            DWORD dwOffset;
            GetFieldOffset("imm32!IMEDPI", "ImeInfo", &dwOffset);
            Print(" ImeInfo: @ 0x%p   dwPrivateDataSize: %08x\n", dwOffset,
                  (DWORD)ReadField(ImeInfo.dwPrivateDataSize));
        }

        if (opts & OFLAG(v)) {
            dso("imm32!IMEDPI", pImeDpi, 0);
        }

        Print("\n");

        pImeDpi = ReadField(pNext);
    }

    return TRUE;
}
#endif // !KERNEL

/************************************************************************\
*
* Procedure: CopyUnicodeString
*
* 06/05/00 JStall       Created (yeah, baby!)
*
\************************************************************************/
BOOL
CopyUnicodeString(
    IN  PTR pData,
    IN  char * pszStructName,
    IN  char * pszFieldName,
    OUT WCHAR *pszDest,
    IN  ULONG cchMax)
{
    ULONG Length;
    PTR Buffer;
    char szLengthName[256];
    char szBufferName[256];

    if (pData == 0) {
        pszDest[0] = '\0';
        return FALSE;
    }

    strcpy(szLengthName, pszFieldName);
    strcat(szLengthName, ".Length");
    strcpy(szBufferName, pszFieldName);
    strcat(szBufferName, ".Buffer");

    if (GetFieldValue(pData, pszStructName, szLengthName, Length) ||
        GetFieldValue(pData, pszStructName, szBufferName, Buffer)) {

        wcscpy(pszDest, L"<< Can't get name >>");
        return FALSE;
    }

    if (Buffer == 0) {
        wcscpy(pszDest, L"<null>");
    } else {
        ULONG cbText;
        cbText = min(cchMax, Length + sizeof(WCHAR));
        if (!(tryMoveBlock(pszDest, FIXKP(Buffer), cbText))) {
            wcscpy(pszDest, L"<< Can't get value >>");
            return FALSE;
        }
    }

    return TRUE;
}


/************************************************************************\
*
* Procedure: Idhard
*
* 06/05/00 JStall       Created (yeah, baby!)
*
\************************************************************************/
#ifdef KERNEL
BOOL Idhard(
    VOID)
{
    PTR phei, pheiNext, pthread;
    WCHAR szText[256], szCaption[256];
    int cErrors = 0;
    DWORD dwClientId;

    Print("Win32k hard error list:\n");

    phei = GetGlobalPointer("winsrv!gphiList");
    while (phei != 0) {
        InitTypeRead(phei, winsrv!HARDERRORINFO);

        pheiNext = ReadField(phiNext);
        pthread = ReadField(pthread);

        CopyUnicodeString(phei, "winsrv!HARDERRORINFO", "usCaption", szCaption, ARRAY_SIZE(szCaption));
        CopyUnicodeString(phei, "winsrv!HARDERRORINFO", "usText", szText, ARRAY_SIZE(szText));

        InitTypeRead(pthread, csrsrv!CSR_THREAD);
        dwClientId = HandleToUlong((HANDLE) ReadField(ClientId.UniqueThread));

        Print("0x%p: tid:0x%x '%S'- '%S'\n", phei, dwClientId, szCaption, szText);

        phei = pheiNext;
        cErrors++;
    }

    Print("%d queued errors\n", cErrors);

    return TRUE;
}

typedef struct {
    PTR thread;
    ULONG64 time;
} KERNELTIME;

ULONG CpuHogCallback(
    PFIELD_INFO NextProcess,
    PVOID Context);

BOOL Ihogs(
    DWORD dwOpts,
    ULONG64 ul64Count)
{
    KERNELTIME *pTimes;
    TIME_FIELDS Times;
    WCHAR appname[64];
    PTR ProcessHead, NextProcess, Process;
    THREAD_DUMP_CONTEXT TDC;
    DWORD dwCount = (DWORD)ul64Count;
    LARGE_INTEGER RunTime;

    UNREFERENCED_PARAMETER(dwOpts);

    // Default to dumping the top 10 threads
    if (dwCount == 0) {
        dwCount = 10;
    }

    pTimes = LocalAlloc(LPTR, dwCount * sizeof(KERNELTIME));
    if (!pTimes) {
        Print("Couldn't allocate memory for KERNELTIME buffer\n");
        return TRUE;
    }

    ProcessHead = EvalExp("PsActiveProcessHead");
    if (!ProcessHead) {
        Print("Unable to get value of PsActiveProcessHead\n");
        return FALSE;
    }

    if (GetFieldValue(ProcessHead, "nt!LIST_ENTRY", "Flink", NextProcess)) {
        Print("Unable to get value of PsActiveProcessHead\n");
        return FALSE;
    }

    if (NextProcess == 0) {
        Print("PsActiveProcessHead->Flink is NULL!\n");
        return FALSE;
    }

    TDC.opts = dwCount;
    TDC.ThreadToDump = (ULONG_PTR)pTimes;
    ListType("nt!EPROCESS", NextProcess, 1, "ActiveProcessLinks.Flink", &TDC, CpuHogCallback);

    for (--dwCount; dwCount != -1; --dwCount) {
        GetFieldValue(pTimes[dwCount].thread, "nt!ETHREAD", "ThreadsProcess", Process);
        GetProcessName(Process, appname);
        RunTime.QuadPart = pTimes[dwCount].time;
        RtlTimeToElapsedTimeFields ( &RunTime, &Times);
        Print("%d: thread %#p - %ws ==> %3ld:%02ld:%02ld.%04ld\n",TDC.opts - dwCount, pTimes[dwCount].thread, appname,
                Times.Hour,
                Times.Minute,
                Times.Second,
                Times.Milliseconds);
    }

    LocalFree(pTimes);

    return TRUE;
}

VOID InsertTime(
    KERNELTIME *pTimes,
    DWORD cnt,
    PTR thread,
    ULONG64 time)
{
    int i = cnt - 1;

    for (; i >= 0; --i) {
        if (time > pTimes[i].time) {
            RtlMoveMemory(&pTimes[0], &pTimes[i], cnt);
            pTimes[i].time = time;
            pTimes[i].thread = thread;
            break;
        }
    }
}

ULONG CpuHogCallback(
    PFIELD_INFO NextProcess,
    PVOID Context)
{
    THREAD_DUMP_CONTEXT *pTDC = (THREAD_DUMP_CONTEXT *)Context;
    KERNELTIME *pTimes = (KERNELTIME*)pTDC->ThreadToDump;
    DWORD dwOffset;
    ULONG64 thread, head, KernelTime;
    TIME_FIELDS Times;
    LARGE_INTEGER RunTime;
    KDDEBUGGER_DATA64 KdDebuggerData;
    static int counter = 0;
    ULONG TimeIncrement = GetUlongFromAddress((GetDebuggerData(KDBG_TAG,
                                     &KdDebuggerData, sizeof(KdDebuggerData)),
                                     KdDebuggerData.KeTimeIncrement));

    GetFieldOffset("nt!EPROCESS", "ThreadListHead", &dwOffset);
    head = NextProcess->address + dwOffset;
    ReadPointer(head, &thread);

    GetFieldOffset("nt!ETHREAD", "ThreadListEntry", &dwOffset);
    do {
        ShowProgress();
        thread -= dwOffset;
        GetFieldValue(thread, "nt!ETHREAD", "Tcb.KernelTime", KernelTime);
        RunTime.QuadPart = UInt32x32To64(KernelTime, TimeIncrement);
        RtlTimeToElapsedTimeFields ( &RunTime, &Times);
        InsertTime(pTimes, pTDC->opts, thread, RunTime.QuadPart);

        // Get next thread in the list
        ReadPointer(thread + dwOffset, &thread);
    } SAFEWHILE (thread != head);

    // Erase any symbol that might still be showing
    Print("\r");

    // Did we exit the loop because the user hit ^C?
    if (thread != head) {
       // Yes, so return TRUE to stop further callbacks
       return TRUE;
    }

    return FALSE;
}
#endif // KERNEL


#ifdef KERNEL

/************************************************************************\
* Procedure: Idhid
*
* Dumps HID (Raw Input, aka Generic Input) information
*
* ??/??/2000    Hiroyama    Created
\************************************************************************/
VOID DumpProcessHidRequest(
    PTR pHidRequest)
{
    _InitTypeRead(pHidRequest, SYM(tagPROCESS_HID_REQUEST));
    Print("    (0x%x, 0x%x) @ 0x%p -> 0x%p  pwnd: 0x%p sink: 0x%x\n",
          (UINT)ReadField(usUsagePage), (UINT)ReadField(usUsage),
          pHidRequest,
          ReadField(pPORequest),
          ReadField(spwndTarget),
          (UINT)ReadField(fSinkable));
}

ULONG dhidCallback(
    PTR ppi,
    PVOID param)
{
    DWORD opts = PtrToUlong(param);
    PTR pHidTable;
    ULONG64 maskRawInput;
    static ULONG iSeq;

    ShowProgress();

    if (GetFieldValue(ppi, SYM(PROCESSINFO), "pHidTable", pHidTable)) {
        Print("Cannot get pHidTable from ppi=%p\n", ppi);
        return FALSE;
    }

    GetFieldValue(ppi, SYM(PROCESSINFO), "dwRawInputMask", maskRawInput);

    if (pHidTable || maskRawInput) {
        ULONG offset;
        PTR pHidRequest;
        PTR pStart;

        Print(" \nHID for ppi: %p %s\n", ppi, ProcessName(ppi));
        _InitTypeRead(pHidTable, SYM(tagPROCESS_HID_TABLE));
        Print("  PROCESS_HID_TABLE @ 0x%p (sink: 0n%d)\n", pHidTable, (int)ReadField(nSinks));
        Print("    Kbd: raw:0x%x sink:0x%x noleg:0x%x  pwnd: 0x%p nohotkey:0x%x\n",
              (DWORD)ReadField(fRawKeyboard), (DWORD)ReadField(fRawKeyboardSink), (DWORD)ReadField(fNoLegacyKeyboard),
              ReadField(spwndTargetKbd),
              (DWORD)ReadField(fNoHotKeys));
        Print("    Mou: raw:%x sink:%x noleg:%x  pwnd: %p capture:%x\n",
              (DWORD)ReadField(fRawMouse), (DWORD)ReadField(fRawMouseSink), (DWORD)ReadField(fNoLegacyMouse),
              ReadField(spwndTargetMouse), (DWORD)ReadField(fCaptureMouse));
        if (opts & OFLAG(v)) {
            dso(SYM(PROCESS_HID_TABLE), pHidTable, DBG_DUMP_RECUR_LEVEL(1));
        }

        GetFieldOffset(SYM(tagPROCESS_HID_TABLE), "InclusionList.Flink", &offset);
        pStart = pHidTable + offset;
        GetFieldValue(pHidTable, SYM(tagPROCESS_HID_TABLE), "InclusionList.Flink", pHidRequest);

        if (pHidRequest == pStart) {
            Print("  No Inclusion List\n");
        } else {
            Print("  Inclusion List:\n");
            SAFEWHILE (pHidRequest && pHidRequest != pStart) {
                DumpProcessHidRequest(pHidRequest);
                /*
                 * N.b. DumpProcessHidRequest() sets the InitTypeRead
                 */
                pHidRequest = ReadField(link.Flink);
            }
        }

        GetFieldOffset(SYM(tagPROCESS_HID_TABLE), "UsagePageList.Flink", &offset);
        pStart = pHidTable + offset;
        GetFieldValue(pHidTable, SYM(tagPROCESS_HID_TABLE), "UsagePageList.Flink", pHidRequest);
        if (pHidRequest != pStart) {
            Print("  UsagePageOnly List\n");
            SAFEWHILE (pHidRequest && pHidRequest != pStart) {
                DumpProcessHidRequest(pHidRequest);
                pHidRequest = ReadField(link.Flink);
            }
        } else {
            Print("  No UsagePageOnly List\n");
        }

        GetFieldOffset(SYM(tagPROCESS_HID_TABLE), "ExclusionList.Flink", &offset);
        pStart = pHidTable + offset;
        GetFieldValue(pHidTable, SYM(tagPROCESS_HID_TABLE), "ExclusionList.Flink", pHidRequest);
        if (pHidRequest != pStart) {
            Print("  Exclusion List\n");
            SAFEWHILE (pHidRequest && pHidRequest != pStart) {
                DumpProcessHidRequest(pHidRequest);
                if (ReadField(spwndTarget) != 0) {
                    Print("        spwndTarget is not NULL!\n");
                }
                pHidRequest = ReadField(link.Flink);
            }
        } else {
            Print("  No Exclusion List\n");
        }
    }

    return FALSE;
}

BOOL Idhid(DWORD opts, ULONG64 param1)
{
    try {
        PTR pHidRequest;
        PTR pStart;

        pStart = GetGlobalMemberAddress(SYM(gHidRequestTable), SYM(tagHID_REQUEST_TABLE), "TLCInfoList.Flink");
        pHidRequest = GetPointer(pStart);
        if (pHidRequest == NULL_PTR) {
            Print("pHidRequest is NULL ???\n");
            return TRUE;
        }

        if (pHidRequest != pStart) {
            Print("HID_TLC_INFO:\n");
        }
        SAFEWHILE (pHidRequest && pHidRequest != pStart) {
            _InitTypeRead(pHidRequest, SYM(tagHID_TLC_INFO));
            Print(" (0x%x, 0x%x)  @ 0x%p\n",
                  (UINT)(USHORT)ReadField(usUsagePage), (UINT)(USHORT)ReadField(usUsage),
                  pHidRequest);
            Print("    [cDevices:0x%x] [DirectReq:0x%x] [UsagePReq:0x%x] [ExclReq:0x%x] [ExclOrphaned:0x%x]\n",
                  (UINT)ReadField(cDevices),
                  (UINT)ReadField(cDirectRequest),
                  (UINT)ReadField(cUsagePageRequest),
                  (UINT)ReadField(cExcludeRequest),
                  (UINT)ReadField(cExcludeOrphaned));
            pHidRequest = ReadField(link.Flink);
        }

        pStart = GetGlobalMemberAddress(SYM(gHidRequestTable), SYM(tagHID_REQUEST_TABLE), "UsagePageList.Flink");
        pHidRequest = GetPointer(pStart);

        if (pHidRequest != pStart) {
            Print("HID_PAGEONLY_REQUEST:\n");
        }

        SAFEWHILE (pHidRequest && pHidRequest != pStart) {
            _InitTypeRead(pHidRequest, SYM(tagHID_PAGEONLY_REQUEST));
            Print(" (0x%x, 0) @ 0x%p   cRefCount: 0x%x\n",
                  (UINT)(USHORT)ReadField(usUsagePage),
                  pHidRequest,
                  (UINT)ReadField(cRefCount));
            pHidRequest = ReadField(link.Flink);
        }

        if (opts & OFLAG(p)) {
            if (param1) {
                dhidCallback(param1, ULongToPtr(opts));
            } else {
                ForEachPpi(dhidCallback, ULongToPtr(opts));
            }
        } else {
            PTR gpqForeground = GetGlobalPointer(SYM(gpqForeground));
            if (gpqForeground == NULL_PTR) {
                Print("gpqForeground is NULL\n");
            } else {
                PTR ptiMouse = NULL_PTR;
                PTR spwndMouse;
                GetFieldValue(gpqForeground, SYM(tagQ), "spwndCapture", spwndMouse);
                if (spwndMouse) {
                    GetFieldValue(spwndMouse, SYM(tagWND), "head.pti", ptiMouse);
                } else {
                    GetFieldValue(gpqForeground, SYM(tagQ), "ptiMouse", ptiMouse);
                }
                if (ptiMouse == NULL_PTR) {
                    Print("ptiMouse is NULL.\n");
                } else {
                    PTR ppi;
                    GetFieldValue(ptiMouse, SYM(tagTHREADINFO), "ppi", ppi);
                    Print("\nForeground ppi: %p\n", ppi);
                    dhidCallback(ppi, ULongToPtr(opts));
                }
            }
        }


        pStart = EvalExp(VAR(gHidCounters));
        if (pStart) {
            Print(" \nHID counter @ 0x%p\n", pStart);
            dso(SYM(tagHID_COUNTERS), pStart, 0);
        }

        if (IsChk()) {
            pStart = EvalExp(VAR(gHidAllocCounters));
            if (pStart) {
                Print(" \nDebug Allocate counter @ 0x%p\n", pStart);
                dso(SYM(HidAllocateCounter), pStart, 0);
                Print("gcAllocHidTotal: 0x%x\n", (UINT)GetGlobalPointer(VAR(gcAllocHidTotal)));
            }
        }
    } except (CONTINUE) {
        Print("AV!\n");
    }

    return TRUE;
}

#endif  // KERNEL

BOOL Ipred(DWORD opts, ULONG64 param1)
{
    UINT i = 0;

    UNREFERENCED_PARAMETER(opts);

    while (i < 64) {
        Print("%cp%-2d ", param1 & (1 << i) ? '*' : ' ', i);
        if (++i % 8 == 0) {
            Print("\n");
        }
    }

    return TRUE;
}

#ifdef KERNEL
#ifdef TRACK_PNP_NOTIFICATION

/************************************************************************\
* Procedure: Idhnr
*
* Dumps PnP notification record
*
* 09/19/2000 Hiroyama     Created
*
\************************************************************************/

/*
 * Do not call GetDeviceType twice within a sequence point!
 * This function uses a static variable for the return value.
 */
const char* GetDeviceType(ULONG64 type)
{
    static const char* devicetype[] = {
        "mouse",
        "keyboard",
        "hid",
    };

    if (type >= ARRAY_SIZE(devicetype)) {
        static char buf[32];
        sprintf(buf, "<unknown type %x>", (DWORD)type);
        return buf;
    }
    return devicetype[type];
}

BOOL Idhnr(DWORD opts, ULONG64 param1)
{
    try {
        PTR p, pStart;
        PTR pTarget = 0;
        PTR pTargetDeviceInfo = 0;
        UCHAR szPathNameDevInfo[80] = "";
        UINT iTarget = 0;
        UINT iStartOffset = 0;
        ULONG cbSize;
        DWORD dwArraySize;
        ULONG offsetPathName;
        UINT iSeq, i;

        GetFieldOffset(SYM(PNP_NOTIFICATION_RECORD), "szPathName", &offsetPathName);
        if (offsetPathName == 0) {
            Print("can't get offset to szPathName, make sure TRACK_PNP_NOTIFICATION is turned on.\n");
            return TRUE;
        }

        if (opts & OFLAG(d)) {
            if ((pTargetDeviceInfo = param1) == 0) {
                return FALSE;
            }
        } else if (opts & OFLAG(p)) {
            p = pTarget = param1;
            if (pTarget) {
                goto PrintHeader;
            }
        } else if (param1) {
            iTarget = (UINT)param1;
            opts |= OFLAG(v) | OFLAG(n);
        }

        if ((p = pStart = GetGlobalPointer(VAR(gpPnpNotificationRecord))) == 0) {
            Print("can't get gPnpNotificationRecord\n");
            return TRUE;
        }

        if ((cbSize = GetTypeSize(SYM(PNP_NOTIFICATION_RECORD))) == 0) {
            Print("can't get sizeof(PNP_NOTIFICATION_RECORD)\n");
            return TRUE;
        }

        moveExpValue(&dwArraySize, VAR(gdwPnpNotificationRecSize));
        if (dwArraySize == 0) {
            Print("can't get gdwPnpNotificationRecSize\n");
            return TRUE;
        }

        /*
         * Firstly, find out the lowest iSeq.
         */
        iSeq = UINT_MAX;
        for (i = 0; !IsCtrlCHit() && i < dwArraySize; ++i) {
            UINT iSeqTmp;

            _InitTypeRead(p, SYM(PNP_NOTIFICATION_RECORD));
            iSeqTmp = (UINT)ReadField(iSeq);
            ShowProgress();

            if (iSeqTmp < iSeq && iSeqTmp != 0) {
                iSeq = iSeqTmp;
                iStartOffset = i;
            }
            /*
             * For device name search, remember the path name
             * that matches to pDeviceInfo.
             */
            if (pTargetDeviceInfo && (opts & OFLAG(m)) &&
                    szPathNameDevInfo[0] == 0 && ReadField(pDeviceInfo) == pTargetDeviceInfo) {
                move(szPathNameDevInfo, p + offsetPathName);
                Print("\r\"%s\"\n", szPathNameDevInfo);
            }
            p = p + cbSize;
        }
        Print("\r");

        /*
         * Secondly, dump the records.
         */
PrintHeader:
        Print(" seq  %-*c%-20s   %-*s %-*s code\n",
              opts & OFLAG(p) ? PtrWidth() + 2 : 1, ' ',
              "type", PtrWidth(), "pDevInfo", PtrWidth(), "thread");
        if (pTarget) {
            goto PrintOne;
        }
        for (i = 0; !IsCtrlCHit() && i < dwArraySize; ++i) {
            UINT iOffset = (i + iStartOffset) % dwArraySize;
            BOOLEAN fDump = FALSE;

            p = pStart + cbSize * iOffset;
PrintOne:
            _InitTypeRead(p, SYM(PNP_NOTIFICATION_RECORD));
            iSeq = (UINT)ReadField(iSeq);
            if (pTargetDeviceInfo) {
                if (iSeq) {
                    if (ReadField(pDeviceInfo) == pTargetDeviceInfo) {
                        fDump = TRUE;
                    } else if ((opts & OFLAG(m)) && szPathNameDevInfo[0]) {
                        /*
                         * Try to dump the deviceinfo of the same device path.
                         */
                        UCHAR szPathName[ARRAY_SIZE(szPathNameDevInfo)];

                        move(szPathName, p + offsetPathName);
                        if (strcmp(szPathName, szPathNameDevInfo) == 0) {
                            fDump = TRUE;
                        }
                    }
                }
            } else if (iTarget) {
                if (iTarget == iSeq) {
                    /*
                     * Print just one by iSeq.
                     */
                    fDump = TRUE;
                }
            } else if (pTarget) {
                /*
                 * Print just one record by address.
                 */
                fDump = TRUE;
            } else if (iSeq) {
                /*
                 * Dump all valid records.
                 */
                fDump = TRUE;
            }
            if (fDump) {
                UINT type = (UINT)ReadField(type);
                PTR pDeviceInfo = ReadField(pDeviceInfo);
                UCHAR szPathName[80];
                ULONG64 NotificationCode = ReadField(NotificationCode);
                PTR pThread = ReadField(pKThread);
                static const char* symbols[] = {
                    "CLASSNOTIFY",
                    "CREATEDEVICEINFO",
                    "FREEDEVICEINFO",
                    "PROCESSDEVICECHANGES",
                    "REQUESTDEVICECHANGE",
                    "DEVICENOTIFY",
                    "FREE_DEFERRED",
                    "CLOSEDEVICE",
                    "DEVNOTIFY_UNLISTED",
                    "UNREGISTER_NOTIFY",
                    "UNREG_REMOTE_CANCEL",
                };
                const char* name;

                if (type < ARRAY_SIZE(symbols)) {
                    name = symbols[type];
                } else {
                    name = "<unknown>";
                }

                if (opts & OFLAG(p)) {
                    Print("[%04x] %p %x %-20s %08p %p ", iSeq, p, type, name, pDeviceInfo, pThread);
                } else {
                    Print("[%04x] %x %-20s %08p %p ", iSeq, type, name, pDeviceInfo, pThread);
                }

                switch (type) {
                case PNP_NTF_DEVICENOTIFY:
                case PNP_NTF_REQUESTDEVICECHANGE:
                case PNP_NTF_FREEDEVICEINFO:
                case PNP_NTF_FREEDEVICEINFO_DEFERRED:
                case PNP_NTF_CLOSEDEVICE:
                case PNP_NTF_DEVICENOTIFY_UNLISTED:
                case PNP_NTF_UNREGISTER_NOTIFICATION:
                case PNP_NTF_UNREGISTER_REMOTE_CANCELLED:
                    Print("%s\n", GetFlags(GF_DIAF, (DWORD)NotificationCode, NULL, TRUE));
                    break;
                case PNP_NTF_PROCESSDEVICECHANGES:
                case PNP_NTF_CREATEDEVICEINFO:
                case PNP_NTF_CLASSNOTIFY:
                    Print("(%s)\n", GetDeviceType(NotificationCode));
                    break;
                default:
                    Print("%08p\n", NotificationCode);
                    break;
                }

                if (opts & OFLAG(n)) {
                    move(szPathName, p + offsetPathName);
                    Print("    \"%s\"\n", szPathName);
                }
                if (opts & OFLAG(v)) {
                    ULONG offset;

                    GetFieldOffset(SYM(PNP_NOTIFICATION_RECORD), "type", &offset);
                    dso(SYM(PNP_NOTIFICATION_TYPE), p + offset, 0);
                    GetFieldOffset(SYM(PNP_NOTIFICATION_RECORD), "trace", &offset);
                    PrintStackTrace(p + offset, LOCKRECORD_STACK);
                }

                /*
                 * If it is a one-shot dump, exit the loop here.
                 */
                if (iTarget || pTarget) {
                    break;
                }
            }
        }
    } except (CONTINUE) {
    }

    return TRUE;
}
#endif  // TRACK_PNP_NOTIFICATION
#endif  // KERNEL

BOOL Ichkfre(DWORD opts, ULONG64 param1)
{
    UNREFERENCED_PARAMETER(param1);

    if (opts & OFLAG(c)) {
        gfChk = 1;
    } else if (opts & OFLAG(f)) {
        gfChk = 0;
    } else if (opts & OFLAG(r)) {
        gfChk = -1;
    }

#ifdef KERNEL
    Print("Win32k IsChk: %d\n", IsChk());
#else
    Print("User32 IsChk: %d\n", IsChk());
#endif

    return TRUE;
}

#ifdef KERNEL
/************************************************************************\
* Idghost
*
* Dump ghost thread associated information
*
* 12/05/2000 Created MSadek
\************************************************************************/
BOOL Idghost(
    VOID)
{
    PTR pGhost;
    PTR pWnd;
    PTR pWndGhost;
    PTR pGhostThreadInfo;
    PTR pEventScanGhosts;
    PTR pCST;
    LONG SignalGhost;
    UINT i = 0;
    UINT uID;
    UINT uiThreadCount = 0;

    // Dump ghost linked list data.

    pGhost = GetGlobalPointer(SYM(gpghostFirst));
    if (0 == pGhost) {
        Print("Ghost global linked list is empty \n");
    } else {
        Print("Dumping ghost global linked list: \n");
        do {

            _InitTypeRead(pGhost, SYM(tagGHOST));
            pWnd = ReadField(pwnd);
            pWndGhost = ReadField(pwndGhost);

            Print("Ghost entry #%i: \n\n", ++i);
            Print("Ghosted window: %0lx\n", pWnd);
            if (pWnd) {
                Idw(0, pWnd);
            }
            Print("Ghost window: %0lx\n", pWndGhost);
            if (pWndGhost) {
                Idw(0, pWndGhost);
            }
            GetFieldValue(pGhost, SYM(tagGHOST), "pghostNext", pGhost);
        } SAFEWHILE (pGhost);
    }

    // Dump ghost thread data.

    pGhostThreadInfo = GetGlobalPointer(SYM(gptiGhost));
    if (0 == pGhostThreadInfo) {
        Print("No Ghost thread currently active\n");
    } else {
        Print("GhostThreadInfo 0x%p\n\n", pGhostThreadInfo);
        Idti(0, pGhostThreadInfo);
    }

    // Dump the number of pending thread creation requests in CSR.

    pCST =  EvalExp(SYM(gCSTParam));
    i = 0;
    SAFEWHILE (i < CST_MAX_THREADS) {
        uID =  (UINT)GetArrayElement(pCST, SYM(CST_THREADS), "uID", i, "UINT");
        if (CST_GHOST == uID) {
            uiThreadCount++;
        }
        i++;
    }
    Print("Number of ghost threads waiting to be created in CSRSS is %i\n", uiThreadCount);

    uiThreadCount = 0;
    i = 0;
    // Dump the number of pending thread creation requests in the shell process.

    pCST =  EvalExp(SYM(gCSTRemoteParam));
    i = 0;
    SAFEWHILE (i < CST_MAX_THREADS) {
        uID =  (UINT)GetArrayElement(pCST, SYM(CST_THREADS), "uID", i, "UINT");
        if (CST_GHOST == uID) {
            uiThreadCount++;
        }
        i++;
    }
    Print("Number of ghost threads waiting to be created in the shell process is %i\n", uiThreadCount);

    // Dump the number of pending ghost windows created and freed since dirver last loaded.

    Print("Number of ghost windows created and freed since driver last loaded is %i\n", GetGlobalPointer(SYM(guGhostUnlinked)));

    // Dump signal state for gpEventScanGhosts

    pEventScanGhosts = GetGlobalPointer(SYM(gpEventScanGhosts));
    if (0 != pEventScanGhosts) {
        Print("Scan Ghost event is 0x%p\n", pEventScanGhosts);
        GetFieldValue(pEventScanGhosts, "nt!DISPATCHER_HEADER", "SignalState", SignalGhost);
        if (SignalGhost) {
            Print("Scan ghost event is signaled\n");
        } else {
            Print("Scan ghost event isn't signaled\n");
        }
    }

    return TRUE;
}


/************************************************************************\
* dce
*
* Dump information about the DCE cache.
*
*  6/15/2001    Created     JStall
\************************************************************************/
BOOL Idce(
    DWORD opts,
    ULONG64 param1)
{
    try {
        PTR gpDispInfo, pdceStart, pdceCur;

        gpDispInfo = GetGlobalPointer(VAR(gpDispInfo));
        if (gpDispInfo == 0) {
            Print("ERROR: Unable to retreive win32!gpDispInfo\n");
        } else {
            _InitTypeRead(gpDispInfo, SYM(DISPLAYINFO));
            pdceStart = ReadField(pdceFirst);
            if (pdceStart == 0) {
                Print("ERROR: Unable to retreive gpDispInfo->pdceFirst\n");
            } else {
                PTR pData;
                DWORD dwData, cTotal, cFound;
                BOOL fDisplay, fVerbose;

                cTotal = cFound = 0;
                fVerbose = opts & OFLAG(v);

                pdceCur = pdceStart;
                while (pdceCur != 0) {
                    fDisplay = FALSE;

                    _InitTypeRead(pdceCur, SYM(DCE));

                    if (param1 != 0) {
                        if (opts & OFLAG(c)) {
                            //
                            // pwndClip
                            //

                            pData = ReadField(pwndClip);
                            fDisplay = pData == param1;
                        } else if (opts & OFLAG(f)) {
                            //
                            // DCX flag filter
                            //

                            dwData = (DWORD) ReadField(DCX_flags);
                            fDisplay = (dwData & ((DWORD) param1)) != 0;
                        } else if (opts & OFLAG(h)) {
                            //
                            // HDC
                            //

                            pData = ReadField(hdc);
                            fDisplay = pData == param1;
                        } else if (opts & OFLAG(o)) {
                            //
                            // pwndOrg
                            //

                            pData = ReadField(pwndOrg);
                            fDisplay = pData == param1;
                        } else if (opts & OFLAG(r)) {
                            //
                            // hrgnClip
                            //

                            pData = ReadField(hrgnClip);
                            fDisplay = pData == param1;
                        } else if (opts & OFLAG(t)) {
                            //
                            // pti (THREADINFO)
                            //

                            pData = ReadField(ptiOwner);
                            fDisplay = pData == param1;
                        }
                    } else {
                        //
                        // No filter, so display information
                        //

                        fDisplay = TRUE;
                    }

                    if (fDisplay) {
                        if (fVerbose) {
                            PTR hdc, pwndOrg, pwndClip, hrgnClip, ptiOwner;
                            DWORD nFlags;
                            LPCSTR pszFlags;
                            char szOrg[256];
                            char szClip[256];
                            WCHAR szRawApp[80];
                            PWCHAR pszApp;

                            hdc         = ReadField(hdc);
                            pwndOrg     = ReadField(pwndOrg);
                            pwndClip    = ReadField(pwndClip);
                            hrgnClip    = ReadField(hrgnClip);
                            nFlags      = (DWORD) ReadField(DCX_flags);
                            pszFlags    = GetFlags(GF_DCXFLAGS, nFlags, NULL, TRUE);
                            ptiOwner    = ReadField(ptiOwner);

                            szRawApp[0] = L'\0';
                            pszApp      = szRawApp;
                            if (ptiOwner != 0) {
                                _InitTypeRead(ptiOwner, SYM(THREADINFO));
                                GetAppName(ReadField(pEThread), ptiOwner, szRawApp, sizeof(szRawApp));
                                pszApp = wcsrchr(szRawApp, L'\\');
                                if (pszApp == NULL_PTR) {
                                    pszApp = szRawApp;
                                } else {
                                    pszApp++;
                                }
                            }

                            DebugGetWindowTextA(pwndOrg, szOrg, ARRAY_SIZE(szOrg));
                            DebugGetWindowTextA(pwndClip, szClip, ARRAY_SIZE(szClip));

                            Print(
                                    "DCE: 0x%p\n"
                                    "  HDC:         0x%p\n"
                                    "  pwndOrg:     0x%p    \"%s\"\n"
                                    "  pwndClip:    0x%p    \"%s\"\n"
                                    "  hrgnClip:    0x%p\n"
                                    "  ptiOwner:    0x%p    \"%ws\"\n"
                                    "  nFlags:      0x%x\n"
                                    "               %s\n\n",
                                    pdceCur,
                                    hdc,
                                    pwndOrg,    szOrg,
                                    pwndClip,   szClip,
                                    hrgnClip,
                                    ptiOwner,   pszApp,
                                    nFlags,
                                    pszFlags);
                        } else {
                            PTR hdc, pwndOrg;
                            char szOrg[256];

                            hdc         = ReadField(hdc);
                            pwndOrg     = ReadField(pwndOrg);

                            DebugGetWindowTextA(pwndOrg, szOrg, ARRAY_SIZE(szOrg));

                            Print("DCE: 0x%p  HDC: 0x%p  pwndOrg: 0x%p  \"%s\"\n",
                                    pdceCur, hdc, pwndOrg, szOrg);
                        }

                        cFound++;
                    }


                    // Get the next DCE
                    _InitTypeRead(pdceCur, SYM(DCE));
                    pdceCur = ReadField(pdceNext);
                    cTotal++;
                }

                Print("  Total 0x%x (%d) of 0x%x (%d) DCE's\n\n", cFound, cFound, cTotal, cTotal);
            }
        }
    } except (CONTINUE) {
    }

    return TRUE;
}
#endif  // KERNEL

#ifndef KERNEL
/************************************************************************\
* msft
*
* Dump Microsoft's current stock price.
*
* 12/13/2000    Created    JasonSch
\************************************************************************/
BOOL Imsft(
    VOID)
{
    BOOL bResult;
    DWORD dwBytesRead;
    SYSTEMTIME systime;
    CHAR buffer[256], *p;
    HINTERNET hUrlHandle;
    HINTERNET hInternet;

    GetLocalTime(&systime);
    if (systime.wMonth == 4 && systime.wDay == 1) {
        static int n = 0;
        if (n++ < 4) {
            /*
             * Let's pretend to be happy!
             */
            Print("MSFT: 120.5625,+80.1875,\"04/01/%d\",\"%d:%02d%s\"\n",
                  systime.wYear, systime.wHour % 12, systime.wMinute, systime.wHour >= 12 ? "PM" : "AM");
            return TRUE;
        }
    }

    hInternet = InternetOpenW(L"Jo Mama!",
                              INTERNET_OPEN_TYPE_PRECONFIG,
                              NULL,
                              NULL,
                              0);
    if (hInternet == NULL) {
        return FALSE;
    }

    hUrlHandle = InternetOpenUrlW(hInternet,
                                  L"http://quote.yahoo.com/download/quotes.csv?symbols=msft&format=sl1c1d1t1&ext=.txt",
                                  NULL,
                                  0,
                                  INTERNET_FLAG_RAW_DATA,
                                  0);
    if (!hUrlHandle) {
        return FALSE;
    }

    bResult = InternetReadFile(hUrlHandle,
                               buffer,
                               sizeof(buffer),
                               &dwBytesRead);
    if (!bResult) {
        InternetCloseHandle(hInternet);
        return FALSE;
    }

    InternetCloseHandle(hUrlHandle);
    InternetCloseHandle(hInternet);

    /*
     * Buffer will now have a string that looks like:
     * "MSFT",58.375,+0.3125,"12/12/2000","4:01PM"
     */

    /*
     * NULL-terminate buffer (remove \r\n, while we're at it).
     */
    buffer[dwBytesRead - 2] = 0;
    p = &buffer[7]; // Skip '"MSFT",' part.
    Print("MSFT: %s\n", p);

    return TRUE;
}
#endif // !KERNEL

/************************************************************************\
* Idaccel
*
* Dumps accelerator tables.
*
* 04/02/2001    Created    JasonSch
\************************************************************************/
BOOL Idaccel(
    DWORD dwFlags,
    PTR pAccelTable)
{
    ULONG dwOffset, dwSize;
    PTR phe;
    UINT i, cnt;

    UNREFERENCED_PARAMETER(dwFlags);

    /*
     * pAccelTable could actually be a handle.
     */
    if (HtoHE(pAccelTable, &phe)) {
        GetFieldValue(phe, SYM(HANDLEENTRY), "phead", pAccelTable);
    }

    if (pAccelTable == 0) {
        return FALSE;
    }

    if (_InitTypeRead(pAccelTable, SYM(ACCELTABLE))) {
        Print("Couldn't read ACCELTABLE at %p\n", (ULONG_PTR)pAccelTable);
        return FALSE;
    }

    cnt = (UINT)ReadField(cAccel);
    GetFieldOffset(SYM(ACCELTABLE), "accel", &dwOffset);
    dwSize = GetTypeSize(SYM(ACCEL));
    pAccelTable += dwOffset;
    for (i = 0; i < cnt; ++i) {
        BYTE bVirt;
        BOOL bPrintPlus = FALSE;

        _InitTypeRead(pAccelTable, SYM(ACCEL));
        bVirt = (BYTE)ReadField(fVirt);

        Print("Flags: ");
        if (bVirt & FVIRTKEY) {
            Print("FVIRTKEY");
            bPrintPlus = TRUE;
        }
        if (bVirt & FNOINVERT) {
            if (bPrintPlus) {
                Print(" + ");
            }
            Print("FNOINVERT");
        }
        if (bVirt & FLASTKEY) {
            if (bPrintPlus) {
                Print(" + ");
            }
            Print("FLASTKEY");
        }

        Print("\nKey: ");
        if (bVirt & FALT) {
            Print("ALT + ");
        }
        if (bVirt & FCONTROL) {
            Print("CONTROL + ");
        }
        if (bVirt & FSHIFT) {
            Print("SHIFT + ");
        }
        if (isprint((int)ReadField(key))) {
            Print("'%c'\n", (char)ReadField(key));
        } else {
            Print("<unprintable> (0x%x)\n", (UINT)(WORD)ReadField(key));
        }
        Print("Cmd: 0x%x\n", (UINT)(WORD)ReadField(cmd));
        pAccelTable += dwSize;
    }

    return TRUE;
}

#ifdef KERNEL

/************************************************************************\
* Idhproc
*
* Dumps a proc with this type of kernel handle.
* Similar to !handle 0 7 <eprocess> <type>
*
* 05/14    Created    HiroYama
\************************************************************************/

#if 0
ULONG dhprocCallback(
    PFIELD_INFO NextProcess,
    PVOID Context)
{
    static int progress;

    ShowProgress();



    return FALSE;
}

BOOL Idhproc(
    DWORD dwFlags,
    PTR ul)
{
    PTR ProcessHead = EvalExp("PsActiveProcessHead");
    PTR NextProcess;
    THREAD_DUMP_CONTEXT tdc;

    if (ProcessHead == NULL_PTR) {
        Print("Unable to get value of PsActiveProcessHead\n");
        return FALSE;
    }

    if (GetFieldValue(ProcessHead, "nt!LIST_ENTRY", "Flink", NextProcess)) {
        Print("Unable to get value of PsActiveProcessHead\n");
        return FALSE;
    }

    if (NextProcess == 0) {
        Print("PsActiveProcessHead->Flink is NULL!\n");
        return FALSE;
    }

    tdc.opts = dwFlags;
    tdc.ThreadToDump = ul;
    ListType("nt!EPROCESS", NextProcess, 1, "ActiveProcessLinks.Flink", &TDC, dhprocCallback);

    return TRUE;
}
#endif

#endif  // KERNEL


#ifdef LATER
#ifdef KERNEL
/************************************************************************\
* Procedure: Idwsl
*
* Dumps WinSta locking log
*
* 09/19/2000 Hiroyama     Created
*
\************************************************************************/
BOOL Idwsl(
    DWORD opts,
    ULONG64 param1)
{
    try {
        PTR p, pStart;
        PTR pTarget = 0;
        PTR pTargetWinSta = NULL_PTR;
        UCHAR szWinStaName[80] = "";
        UINT iTarget = 0;
        UINT iStartOffset = 0;
        ULONG cbSize;
        DWORD dwArraySize;
        ULONG offsetWinStaName;
        ULONG offsetImageFileName;
        UINT iSeq, i;

        if (opts & OFLAG(d)) {
            if ((pTargetWinSta = param1) == NULL_PTR) {
                return FALSE;
            }
        }
        else if (opts & OFLAG(p)) {
            p = pTarget = param1;
            if (pTarget) {
                goto PrintHeader;
            }
        }
        else if (param1) {
            iTarget = (UINT)param1;
            opts |= OFLAG(v) | OFLAG(n);
        }

        offsetWinStaName = (ULONG)-1;
        GetFieldOffset(SYM(WINSTA_RUNDOWN_RECORD), "szWinStaName", &offsetWinStaName);
        if (offsetWinStaName == (ULONG)-1) {
            Print("can't get offset to szWinStaName\n");
            return TRUE;
        }

        GetFieldOffset(SYM(WINSTA_RUNDOWN_RECORD), "szImageFileName", &offsetImageFileName);
        if (offsetImageFileName == 0) {
            Print("can't get offset to szImageFileName\n");
            return TRUE;
        }


        if ((p = pStart = EvalExp(SYM(gaWinStaRundownLog))) == NULL_PTR) {
            Print("can't get gaWinStaRundownLog\n");
            return TRUE;
        }

        if ((cbSize = GetTypeSize(SYM(WINSTA_RUNDOWN_RECORD))) == 0) {
            Print("can't get sizeof(WINSTA_RUNDOWN_RECORD)\n");
            return TRUE;
        }

        moveExpValue(&dwArraySize, VAR(gdwWinStaRecSize));
        if (dwArraySize == 0) {
            Print("can't get gdwWinStaRecSize\n");
            return TRUE;
        }

        /*
         * Firstly, find out the lowest iSeq.
         */
        iSeq = UINT_MAX;
        for (i = 0; !IsCtrlCHit() && i < dwArraySize; ++i) {
            UINT iSeqTmp;

            _InitTypeRead(p, SYM(WINSTA_RUNDOWN_RECORD));
            iSeqTmp = (UINT)ReadField(iSeq);
            ShowProgress();

            if (iSeqTmp < iSeq && iSeqTmp != 0) {
                iSeq = iSeqTmp;
                iStartOffset = i;
            }
            /*
             * For device name search, remember the path name
             * that matches to pDeviceInfo.
             */
            if (pTargetWinSta && (opts & OFLAG(m)) &&
                    szWinStaName[0] == 0 && ReadField(pwinsta) == pTargetWinSta) {
                move(szWinStaName, p + offsetWinStaName);
                Print("\r\"%s\"\n", szWinStaName);
            }
            p = p + cbSize;
        }
        Print("\r");

        /*
         * Secondly, dump the records.
         */
PrintHeader:
#if 0
        Print(" seq  %-*c%-20s   %-*s %-*s code\n",
              opts & OFLAG(p) ? PtrWidth() + 2 : 1, ' ',
              "type", PtrWidth(), "pDevInfo", PtrWidth(), "thread");
#endif
        if (pTarget) {
            goto PrintOne;
        }

        for (i = 0; !IsCtrlCHit() && i < dwArraySize; ++i) {
            UINT iOffset = (i + iStartOffset) % dwArraySize;
            BOOLEAN fDump = FALSE;

            p = pStart + cbSize * iOffset;
PrintOne:
            _InitTypeRead(p, SYM(WINSTA_RUNDOWN_RECORD));
            iSeq = (UINT)ReadField(iSeq);
            if (pTargetWinSta) {
                if (iSeq) {
                    if (ReadField(pwinsta) == pTargetWinSta) {
                        fDump = TRUE;
                    }
                    else if ((opts & OFLAG(m)) && szWinStaName[0]) {
                        /*
                         * Try to dump the winsta of the same device path.
                         */
                        UCHAR szPathNameTmp[ARRAY_SIZE(szWinStaName)];

                        move(szPathNameTmp, p + offsetWinStaName);
                        if (strcmp(szWinStaName, szPathNameTmp) == 0) {
                            fDump = TRUE;
                        }
                    }
                }
            }
            else if (iTarget) {
                if (iTarget == iSeq) {
                    /*
                     * Print just one by iSeq.
                     */
                    fDump = TRUE;
                }
            }
            else if (pTarget) {
                /*
                 * Print just one record by address.
                 */
                fDump = TRUE;
            }
            else if (opts & OFLAG(z)) {
                /*
                 * Print only if the session id don't match.
                 */
                if ((DWORD)ReadField(dwSessionIdWinSta) != (DWORD)ReadField(dwCurrentSessionId)) {
                    fDump = TRUE;
                }
            }
            else if (iSeq) {
                /*
                 * Dump all valid records.
                 */
                fDump = TRUE;
            }

            if (fDump) {
                UINT fReference = (UINT)ReadField(fReference);
                PTR pwinsta = ReadField(pwinsta);
                UCHAR szName[33];
                //PTR NotificationCode = ReadField(NotificationCode);
                PTR pThread = ReadField(pKThread);
                if (opts & OFLAG(p)) {
                    Print("[0x%04x] @ 0x%p 0x%x ws 0x%08p t 0x%p ", iSeq, p, fReference, pwinsta, pThread);
                } else {
                    Print("[0x%04x] 0x%x ws 0x%08p t 0x%p ", iSeq, fReference, pwinsta, pThread);
                }

                /*
                 * Print the windowstation name.
                 */
                move(szName, p + offsetWinStaName);
                Print(" %02x %-20s", (DWORD)ReadField(dwSessionIdWinSta), szName);
                /*
                 * Print the process name.
                 */
                move(szName, p + offsetImageFileName);
                Print(" %02x %x.%x \"%s\"\n", (DWORD)ReadField(dwCurrentSessionId), (DWORD)ReadField(pid), (DWORD)ReadField(tid), szName);

                /*
                 * If it is a one-shot dump, exit the loop here.
                 */
                if (iTarget || pTarget) {
                    break;
                }
            }
        }
    } except (CONTINUE) {
    }

    return TRUE;
}
#endif  // KERNEL
#endif  // LATER


#ifdef KERNEL
/************************************************************************\
* Iheapff
*
* Looks for a particular address in our global list of freed heap.
*
* 07/02/2001    Created    JasonSch
\************************************************************************/
BOOL Iheapff(
    DWORD dwFlags,
    PTR pHeapBlock)
{
    DWORD dwHeapRecordMax, i, dwSize, dwOffset;
    PTR pHeapRecords;

    UNREFERENCED_PARAMETER(pHeapBlock);
    UNREFERENCED_PARAMETER(dwFlags);

    moveExpValue(&dwHeapRecordMax, SYM(gdwFreeHeapRecordCrtIndex));
    dwSize = GetTypeSize(SYM(HEAPRECORD));
    GetFieldOffset(SYM(HEAPRECORD), "trace", &dwOffset);
    pHeapRecords = EvalExp(SYM(garrFreeHeapRecord));

    for (i = 0; i < dwHeapRecordMax; ++i, pHeapRecords += dwSize) {
        _InitTypeRead(pHeapRecords, SYM(HEAPRECORD));
        if (ReadField(p) == pHeapBlock) {
            Print("Found heap block 0x%p (Heap: 0x%p, Size: 0x%p)\n",
                  pHeapBlock,
                  ReadField(pheap),
                  ReadField(size));
            PrintStackTrace(pHeapRecords + dwOffset, 6);
        }
    }

    Print("==========================================================\n");
    moveExpValue(&dwHeapRecordMax, SYM(gdwFreeHeapRecordTotalFrees));
    Print("Total heap allocations freed thus far: 0x%x\n", dwHeapRecordMax);

    return TRUE;
}
#endif

ULONG SortBy;
#define SORT_SIZE 1
#define SORT_PID   2
#define SORT_TAG   3

int __cdecl
HeapInfoSort(const void *e1,const void *e2)
{
    LONG64 diff;
    WORD tag1, tag2;
    WORD subtag1, subtag2;
    ULONG64 size1, size2;
    ULONG64 pid1, pid2;

   _InitTypeRead(*((PULONG64) e1), SYM(DbgHeapHead));
    tag1 = LOWORD(ReadField(tag));
    subtag1 = HIWORD(ReadField(tag));
    size1 = ReadField(size);
    pid1 = ReadField(pid);

   _InitTypeRead(*((PULONG64) e2), SYM(DbgHeapHead));
    tag2 = LOWORD(ReadField(tag));
    subtag2 = HIWORD(ReadField(tag));
    size2 = ReadField(size);
    pid2 = ReadField(pid);

    switch (SortBy) {
    case SORT_SIZE:
        diff = size1 - size2;
        break;

    case SORT_PID:
        diff = pid1 - pid2;
        break;

    case SORT_TAG:
        diff = tag1 - tag2;
        if (diff == 0) {
            diff = subtag1 - subtag2;
        }
        break;
    }
    return (int) diff;

}

/************************************************************************\
* Idheap
*
* Dumps a win32Heap
*
* 08/15/2001    Created    MSadek
\************************************************************************/
BOOL Idheap(
    DWORD opts,
    ULONG64 param1,
    ULONG64 param2)

{

    if (((opts & OFLAG(o)) && param2 == 0 ) || param1 == 0) {
        Print("Wrong usage0: dheap takes a pointer as a parameter\n");
        return FALSE;
    }

    try {
        PTR pheap;
        PTR pFirstAlloc;
        ULONG64 cAllocations = 0;
        ULONG64 cActualAllocations = 0;
        ULONG64 cTotalHeap = 0, cTotalHeapRead = 0;
        ULONG64 cClass = 0;
        ULONG64 pid;
        ULONG64 i = 0;
        ULONG64 *pHeapDebugInfo = NULL;
        BOOL bWarning = FALSE;
        DWORD dwDbgInfoSize = GetTypeSize(SYM(DbgHeapHead));
        WORD tag;

        if (opts & OFLAG(o)) {
            pheap = param2;
        } else {
            pheap = param1;
        }

        Print("\n***IMPORTANT***: If you are not dumping a desktop heap, the tag and subtag information is wrong.\n\n");

        if (!opts || ((opts & (OFLAG(o))) && !(opts & (OFLAG(p) | OFLAG(t) | OFLAG(s))))) {
           Print("\t%-10s%-10s%-18s%-18s%-10s%-10s\n","Heap Block", "Size","Tag","Subtag","Process","StackTrace");
           Print("\t============================================================================\n");
        }
        _InitTypeRead(pheap, SYM(tagWIN32HEAP));
        pFirstAlloc = ReadField(pFirstAlloc);
        cActualAllocations = ReadField(crtAllocations);
        cTotalHeap = ReadField(crtMemory);

        do {
            _InitTypeRead(pFirstAlloc, SYM(DbgHeapHead));
            if (ReadField(pNext)) {
                 cAllocations++;
                 cTotalHeapRead += ReadField(size);
                if (!opts || ((opts & (OFLAG(o))) && !(opts & (OFLAG(p) | OFLAG(t) | OFLAG(s))) && param1 == ReadField(pid))) {
                    Print("\t%-10x", pFirstAlloc + dwDbgInfoSize);
                    Print("%-10x", ReadField(size));
                    Print("%-18s", aszHeapTags[LOWORD(ReadField(tag))]);
                    Print("%-18s", aszHeapSubtags[HIWORD(ReadField(tag))]);
                    Print("%-10x", ReadField(pid));
                    Print("%-10x\n", ReadField(trace));
                } else {
                    ShowProgress();
                }
            }
       } while (pFirstAlloc = ReadField(pNext));

        if (cActualAllocations > cAllocations) {
            bWarning = TRUE;
        }

        if (!(opts & (OFLAG(p) | OFLAG(t) | OFLAG(s)))) {
            goto PrintFooter;
        } else if(opts & OFLAG(p)) {
            SortBy= SORT_PID;
        } else if(opts & OFLAG(t)) {
            SortBy= SORT_TAG;
        } else if(opts & OFLAG(s)) {
            SortBy= SORT_SIZE;
        }
        pHeapDebugInfo = malloc((SIZE_T)(cAllocations * sizeof(ULONG64)));
        if (!pHeapDebugInfo) {
            Print("Couldn't allocate memory for heap info buffer\n");
            return FALSE;
        }

        _InitTypeRead(pheap, SYM(tagWIN32HEAP));
        pFirstAlloc = ReadField(pFirstAlloc);

        for (i = 0; i < cAllocations; i++) {
            ShowProgress();
            pHeapDebugInfo[i] = pFirstAlloc;
            _InitTypeRead(pFirstAlloc, SYM(DbgHeapHead));
            pFirstAlloc = ReadField(pNext);
        }

        qsort((void *) pHeapDebugInfo, (size_t)cAllocations, (size_t)sizeof(ULONG64), HeapInfoSort);

        for (i = 0; i < cAllocations; i++) {
            _InitTypeRead(pHeapDebugInfo[i], SYM(DbgHeapHead));
            if (((opts & OFLAG(s) && !(opts & OFLAG(o))) || ((opts & OFLAG(o)) && param1 == ReadField(pid)))) {
                if (i == 0) {
                    Print("\t%-10s%-10s%-18s%-18s%-10s%-10s\n","Heap Block", "Size","Tag","Subtag","Process","StackTrace");
                    Print("\t============================================================================\n");
                }
                Print("\t%-10x", pHeapDebugInfo[i] + dwDbgInfoSize);
                Print("%-10x", ReadField(size));
                Print("%-18s", aszHeapTags[LOWORD(ReadField(tag))]);
                Print("%-18s", aszHeapSubtags[HIWORD(ReadField(tag))]);
                Print("%-10x", ReadField(pid));
                Print("%-10x\n", ReadField(trace));
            } else if (!(opts & OFLAG(o))){
                if (i == 0) {
                    if (SortBy== SORT_PID) {
                        Print("\t%-10s%-15s%\n","Process", "Total Heap Size");
                        Print("\t=========================\n");
                        pid = ReadField(pid);
                    } else {
                        Print("\t%-18s%-15s%\n","Tag", "Total Heap Size");
                        Print("\t=================================\n");
                        tag = LOWORD(ReadField(tag));
                    }

                }
                if (SortBy== SORT_PID) {
                    if (pid == ReadField(pid)) {
                        cClass += (ULONG64)ReadField(size);
                    }
                    if (pid != ReadField(pid) || i == cAllocations - 1) {
                        Print("\t%-10x", pid);
                        Print("%-15x\n", cClass);
                        cClass = (ULONG64)ReadField(size);
                        if (pid != ReadField(pid) && i == cAllocations - 1) {
                            Print("\t%-10x", ReadField(pid));
                            Print("%-15x\n", cClass);
                        }
                        pid = ReadField(pid);
                    }
                } else {
                    if (tag == LOWORD(ReadField(tag))) {
                        cClass += (ULONG64)ReadField(size);
                    }
                    if (tag != LOWORD(ReadField(tag)) || i == cAllocations - 1) {
                        Print("\t%-18s", aszHeapTags[tag]);
                        Print("%-15x\n", cClass);
                        cClass = (ULONG64)ReadField(size);
                        if (tag != LOWORD(ReadField(tag)) && i == cAllocations - 1) {
                            Print("\t%-18s", aszHeapTags[LOWORD(ReadField(tag))]);
                            Print("%-15x\n", cClass);
                        }
                        tag = LOWORD(ReadField(tag));
                    }
                }
            }
        }
PrintFooter:
        Print("\nTotal heap allocated (excluding headers): %dKb", cTotalHeap/1024, cTotalHeap);
        Print(" in %d allocations.\n", cActualAllocations);

        if(bWarning) {
            Print("\n**WARNING**:Some of the heap memory is paged out.\n");
        }

        if (pHeapDebugInfo) {
            free(pHeapDebugInfo);
        }
    } except(CONTINUE) {
    }

    return TRUE;
}

/************************************************************************\
* Ifcsrp
*
* Finds the CSR_PROCESS for the given PID.
*
* 09/13/2001    Created    JasonSch
\************************************************************************/
BOOL Ifcsrp(
    DWORD dwFlags,
    ULONG64 pid)
{
    PTR pProcess;
    ULONG dwOffset;

    GetFieldOffset("csrsrv!_CSR_PROCESS", "ListLink", &dwOffset);

    UNREFERENCED_PARAMETER(dwFlags);

    pProcess = GetGlobalPointer("csrsrv!CsrRootProcess");

    SAFEWHILE (pProcess) {
        _InitTypeRead(pProcess, "csrsrv!_CSR_PROCESS");
        if (ReadField(ClientId.UniqueProcess) == pid) {
            Print("Found specified CSR_PROCESS at 0x%p\n", pProcess);
            break;
        }

        pProcess = (PTR)((PBYTE)ReadField(ListLink) - dwOffset);
    }

    return TRUE;
}

#ifdef KERNEL

typedef struct {
    PTR ppi;
    PTR pDesktop;
} PPI_DESKTOP, *PPPI_DESKTOP;

ULONG Findd_PtiCallback(
    PTR pti,
    PVOID pData)
{
    PTR pDesktop;
    PPPI_DESKTOP p = (PPPI_DESKTOP)pData;

    ShowProgress();

    GetFieldValue(pti, SYM(THREADINFO), "rpDesk", pDesktop);

    if (p->pDesktop == pDesktop) {
        Print("Pti 0x%p [ppi = 0x%p] using desktop 0x%p", pti, p->ppi, p->pDesktop);
    }

    return TRUE;
}

ULONG Findd_PpiCallback(
    PTR ppi,
    PVOID ppDesktop)
{
    PPI_DESKTOP p = {ppi, *((PTR*)ppDesktop)};

    ShowProgress();
    ForEachPti(Findd_PtiCallback, &p);

    return TRUE;
}

BOOL Ifindd(
    DWORD dwOpts,
    PTR pDesktop)
{
    UNREFERENCED_PARAMETER(dwOpts);

    ForEachPpi(Findd_PpiCallback, (PVOID)&pDesktop);

    return TRUE;
}
#endif

/************************************************************************\
* Idcmu
*
* Dumps a rough estimate of the total amount of memory used by console
* screen buffers. Note that this currently just looks at the current
* screen buffer for each console. It should be augmented to look at all
* of them.
*
* 04/29/2002    Created    JasonSch
\************************************************************************/
BOOL Idcmu(
    DWORD opts)
{
    ULONG64 pConsole, pConsoles, pScreenBuffer;
    ULONG cConsoleHandles, cActualConsoleCount, i, PtrSize, CoordOffset;
    ULONG dwTotalSize = 0, x, y;

    PtrSize = GetTypeSize("PVOID");

    pConsoles = GetGlobalPointer("winsrv!ConsoleHandles");
    moveExpValue(&cConsoleHandles, "winsrv!NumberOfConsoleHandles");

    for (i = 0, cActualConsoleCount = 0; i < cConsoleHandles; ++i) {
        pConsole = GetPointer(pConsoles);
        if (pConsole == 0) {
            pConsoles += PtrSize;
            continue;
        }
        ++cActualConsoleCount;

        GetFieldValue(pConsole,
                      "winsrv!_CONSOLE_INFORMATION",
                      "CurrentScreenBuffer",
                      pScreenBuffer);
        GetFieldOffset("winsrv!_SCREEN_INFORMATION", "ScreenBufferSize", &CoordOffset);
        _InitTypeRead(pScreenBuffer + CoordOffset, "COORD");
        x = (ULONG)(WORD)ReadField(X);
        y = (ULONG)(WORD)ReadField(Y);
        dwTotalSize += x * y * 2;
        if (opts & OFLAG(v)) {
            Print("Console @ 0x%p has buffer size (0x%x, 0x%x)\n", pConsole, x, y);
        }
        pConsoles += PtrSize;
    }

    Print("There are 0x%x consoles using roughly %d bytes\n",
          cActualConsoleCount,
          dwTotalSize);
    return TRUE;
}

LPWSTR _ReadCountedWideString(
    ULONG64 pAddress,
    ULONG cbSize)
{
    LPWSTR pwstr;

    pwstr = LocalAlloc(LPTR, (cbSize + 1) * sizeof(WCHAR));
    if (pwstr) {
        ULONG result;

        ReadMemory(pAddress,
                   pwstr,
                   cbSize * sizeof(WCHAR),
                   &result);
        pwstr[cbSize] = 0;
    }

    return pwstr;
}

ULONG _DumpConsoleAliasCallback(
    PFIELD_INFO pFieldInfo,
    PVOID Context)
{
    LPWSTR lpwszAliasSource, lpwszAliasTarget;

    UNREFERENCED_PARAMETER(Context);

    _InitTypeRead(pFieldInfo->address, "winsrv!_ALIAS");

    lpwszAliasSource = _ReadCountedWideString(ReadField(Source),
                                              (ULONG)ReadField(SourceLength));
    lpwszAliasTarget = _ReadCountedWideString(ReadField(Target),
                                              (ULONG)ReadField(TargetLength));

    Print("\t%ws ==> %ws (@ 0x%p)\n",
          lpwszAliasSource,
          lpwszAliasTarget,
          pFieldInfo->address);

    LocalFree(lpwszAliasSource);
    LocalFree(lpwszAliasTarget);

    return FALSE;
}

ULONG _DumpConsoleAliasListCallback(
    PFIELD_INFO pFieldInfo,
    PVOID Context)
{
    LPWSTR lpwszExeName;

    UNREFERENCED_PARAMETER(Context);

    _InitTypeRead(pFieldInfo->address, "winsrv!_EXE_ALIAS_LIST");
    //
    // TODO: Print doesn't support %.*XXX.
    //
    // Print("Alias .exe ==> %.*ws", (ULONG)ReadField(ExeLength), ReadField(ExeName));
    lpwszExeName = _ReadCountedWideString(ReadField(ExeName),
                                          (ULONG)ReadField(ExeLength));
    Print("Alias list @ 0x%p for %ws\n", pFieldInfo->address, lpwszExeName);
    LocalFree(lpwszExeName);

    ListType("winsrv!_ALIAS",
             ReadField(AliasList),
             1,
             "ListLink.Flink",
             NULL,
             _DumpConsoleAliasCallback);
    Print("\n");

    return FALSE;
}

BOOL Idcalias(
    DWORD dwOpts,
    ULONG64 pConsole)
{
    UNREFERENCED_PARAMETER(dwOpts);

    //
    // NULL pConsole means dump aliases for all consoles.
    //
    if (pConsole == 0) {
        ULONG64 pConsoles;
        ULONG cConsoleHandles, cActualConsoleCount, i, PtrSize;

        PtrSize = GetTypeSize("PVOID");

        pConsoles = GetGlobalPointer("winsrv!ConsoleHandles");
        moveExpValue(&cConsoleHandles, "winsrv!NumberOfConsoleHandles");

        for (i = 0, cActualConsoleCount = 0;
             i < cConsoleHandles;
             pConsoles += PtrSize,
             ++i) {
            pConsole = GetPointer(pConsoles);
            if (pConsole == 0) {
                continue;
            }
            ++cActualConsoleCount;
            Idcalias(dwOpts, pConsole);
        }
    } else {
        ULONG64 pExeAliasList;

        GetFieldValue(pConsole,
                      "winsrv!_CONSOLE_INFORMATION",
                      "ExeAliasList",
                      pExeAliasList);

        Print("Aliases for Console 0x%p\n", pConsole);

        ListType("winsrv!_EXE_ALIAS_LIST",
                 pExeAliasList,
                 1,
                 "ListLink.Flink",
                 NULL,
                 _DumpConsoleAliasListCallback);
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kdexts\ntsd\kdexts.c ===
/****************************** Module Header ******************************\
* Module Name: kdexts.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* This file is included in the SOURCES= line of sources.inc.
*  It allows BUILD.EXE and $(NTMAKEENV)\MAKEFILE.DEF to work with source
*  files that are not stored in the current directory or the current
*  directory's parent.
*  Note also that a specific dependency line is included in makefile.inc
*   so the corresponding object is properly rebuilt when the source file
*   included below changes.
*
* History:
* Feb-14-1996 GerardoB Created
\***************************************************************************/
#include "precomp.h"
#pragma hdrstop
#include "..\kdexts.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kdexts\kd\userexts.c ===
/****************************** Module Header ******************************\
* Module Name: userexts.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* This file is included in the SOURCES= line of sources.inc.
*  It allows BUILD.EXE and $(NTMAKEENV)\MAKEFILE.DEF to work with source
*  files that are not stored in the current directory or the current
*  directory's parent.
*  Note also that a specific dependency line is included in makefile.inc
*   so the corresponding object is properly rebuilt when the source file
*   included below changes.
*
* History:
* Feb-14-1996 GerardoB Created
\***************************************************************************/
#include "precomp.h"
#pragma hdrstop
#include "..\userexts.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kdexts\kd\sources.inc ===
!IF 0

Copyright (c) 1989  Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


Author:

    Steve Wood (stevewo) 12-Apr-1990

NOTE:   Commented description of this file is in \nt\bak\bin\sources.tpl

!ENDIF

!include $(WINCORE_PATH)\core.inc

TARGETNAME=userkdx
TARGETTYPE=DYNLINK
TARGETPATH=$(_OBJ_DIR)

TARGETLIBS=$(SDK_LIB_PATH)\kernel32.lib \
           $(SDK_LIB_PATH)\msvcrt.lib
USE_MSVCRT=1

KERNEL=1

C_DEFINES=$(C_DEFINES) $(USER_C_DEFINES) -DUNICODE -D_USER32_ -DKERNEL -D_CROSS_PLATFORM_ -DTRACK_PNP_NOTIFICATION

!IFNDEF MSC_WARNING_LEVEL
MSC_WARNING_LEVEL=/W3
!ENDIF
MSC_WARNING_LEVEL=$(MSC_WARNING_LEVEL) /WX

INCLUDES=..\..;                                      \
        $(NTUSER_PATH)\kernel;                       \
        $(NTUSER_PATH)\kernel\$(O);                  \
        $(NTUSER_PATH)\kernel\$(ALT_PROJECT);        \
        $(NTUSER_PATH)\kernel\$(ALT_PROJECT)\$(O);   \
        $(NTUSER_PATH)\inc;                          \
        $(NTUSER_PATH)\inc\$(ALT_PROJECT);           \
        $(WINCORE_PATH)\w32inc;                      \
        $(WINCORE_PATH)\w32inc\$(O);                 \
        $(NTGDI_PATH)\inc;                           \
        $(WINCORE_PATH)\w32inc;                      \
        $(NTCON_PATH)\inc;                           \
        $(BASE_INC_PATH)

SOURCES=..\kdexts.c    \
        ..\userexts.c  \
        ..\userexts.rc

NTTARGETFILE0=$(O)\userkdx.def $(O)\wm.txt $(O)\vktbl.txt $(O)\ptagdbg.h
DLLDEF=$(O)\userkdx.def
UMTYPE=console

SOURCES_USED=..\sources.inc $(WINCORE_PATH)\core.inc

SUBSYSTEM_VERSION=4.0
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kdexts\ntsd\makefile.inc ===
HDEPENDENCIES=..\..\exts.h $(WINDOWS_INC_PATH)\stdexts.h

GENUEDEFDEFINES=/D_$(ALT_PROJECT)_

$(O)\userexts.def: ..\..\genuedef.c $(HDEPENDENCIES)
        $(CXX_COMPILER_NAME) $(GENUEDEFDEFINES) /EP ..\..\genuedef.c >$@

#
# Dependencies for dummy targets
#
..\kdexts.c:            ..\..\kdexts.c
..\userexts.c:          ..\..\userkdx.h \
                        ..\..\userexts.c \
                        $(HDEPENDENCIES) \
                        $(WINDOWS_INC_PATH)\stdexts.c \
                        $(O)\wm.txt $(O)\vktbl.txt

..\userexts.rc:         ..\..\userexts.rc

..\..\precomp.h: ..\..\userkdx.h
..\..\userkdx.h: $(NTUSER_PATH)\client\usercli.h \
                 $(NTUSER_PATH)\inc\user.h \
                 $(NTUSER_PATH)\inc\ntuser.h \
                 $(WINDOWS_INC_PATH)\winuserp.h \
                 $(WINDOWS_INC_PATH)\immp.h \
                 $(WINCORE_PATH)\w32inc\winuserk.h


$(O)\ptagdbg.h: $(NTUSER_PATH)\kdexts\ptagdbg.bat $(NTUSER_PATH)\kernel\ptag.lst
    $(NTUSER_PATH)\kdexts\ptagdbg.bat $(NTUSER_PATH)\kernel\ptag.lst $(O)\ptagdbg.h

$(O)\wm.txt: $(PROJECT_ROOT)\Published\winuser.w $(WINDOWS_INC_PATH)\winuserp.h
    perl $(NTUSER_PATH)\kdexts\wm.pl $(PROJECT_ROOT)\Published\winuser.w > $(O)\wm.txt

VKTBL_SRCS=$(PROJECT_ROOT)\Published\winuser.w \
           $(WINDOWS_INC_PATH)\vkoem.h $(PROJECT_ROOT)\Published\ime.w

$(O)\vktbl.txt: $(VKTBL_SRCS)
    perl $(NTUSER_PATH)\kdexts\vkeytbl.pl $(VKTBL_SRCS) > $(O)\vktbl.txt
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kdexts\ntsd\sources.inc ===
!IF 0

Copyright (c) 1989  Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


Author:

    Steve Wood (stevewo) 12-Apr-1990

NOTE:   Commented description of this file is in \nt\bak\bin\sources.tpl

!ENDIF

!include $(WINCORE_PATH)\core.inc

TARGETNAME=userexts
TARGETTYPE=DYNLINK
TARGETPATH=$(_OBJ_DIR)

TARGETLIBS=$(SDK_LIB_PATH)\kernel32.lib \
           $(WINDOWS_LIB_DEST)\$(ALT_PROJECT_TARGET)\*\user32p.lib \
           $(SDK_LIB_PATH)\msvcrt.lib \
           $(SDK_LIB_PATH)\WinInet.lib

DELAYLOAD=user32.dll;WinInet.dll

C_DEFINES=$(C_DEFINES) $(USER_C_DEFINES) -D_USER32_ -DUNICODE

!IFNDEF MSC_WARNING_LEVEL
MSC_WARNING_LEVEL=/W3
!ENDIF
MSC_WARNING_LEVEL=$(MSC_WARNING_LEVEL) /WX

INCLUDES=..\..;                                  \
        $(NTUSER_PATH)\client;                   \
        $(NTUSER_PATH)\inc;                      \
        $(NTUSER_PATH)\inc\$(ALT_PROJECT)\$(O);  \
        $(NTUSER_PATH)\server;                   \
        $(NTGDI_PATH)\inc;                       \
        $(WINCORE_PATH)\w32inc;                  \
        $(WINCORE_PATH)\w32inc\$(O);             \
        $(NTCON_PATH)\inc;                       \
        $(BASE_INC_PATH)

USE_NTDLL=1

SOURCES=..\kdexts.c    \
        ..\userexts.c  \
        ..\userexts.rc

NTTARGETFILE0=$(O)\userexts.def $(O)\wm.txt $(O)\vktbl.txt $(O)\ptagdbg.h
DLLDEF=$(O)\userexts.def
UMTYPE=console
UMTEST=
UMLIBS=

PRECOMPILED_INCLUDE=..\..\precomp.h
PRECOMPILED_PCH=precomp.pch
PRECOMPILED_OBJ=precomp.obj

SOURCES_USED=..\sources.inc $(WINCORE_PATH)\core.inc

DLOAD_ERROR_HANDLER=NONE
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kdexts\ntsd\userexts.c ===
/****************************** Module Header ******************************\
* Module Name: userexts.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* This file is included in the SOURCES= line of sources.inc.
*  It allows BUILD.EXE and $(NTMAKEENV)\MAKEFILE.DEF to work with source
*  files that are not stored in the current directory or the current
*  directory's parent.
*  Note also that a specific dependency line is included in makefile.inc
*   so the corresponding object is properly rebuilt when the source file
*   included below changes.
*
* History:
* Feb-14-1996 GerardoB Created
\***************************************************************************/
#include "precomp.h"
#pragma hdrstop
#include "..\userexts.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kernel\access.h ===
/****************************** Module Header ******************************\
* Module Name: access.h
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* Typedefs, defines, and prototypes that are used by the accessibility
* routines and the various routines that call them (input routines and
* SystemParametersInfo).
*
* History:
* 11 Feb 93 GregoryW    Created
\***************************************************************************/

#ifndef _ACCESS_
#define _ACCESS_

/*
 * Main accessibility routine entry points.
 */
typedef BOOL (* ACCESSIBILITYPROC)(PKE, ULONG, int);

BOOL FilterKeys(PKE, ULONG, int);
BOOL xxxStickyKeys(PKE, ULONG, int);
BOOL MouseKeys(PKE, ULONG, int);
BOOL ToggleKeys(PKE, ULONG, int);
BOOL HighContrastHotKey(PKE, ULONG, int);
BOOL UtilityManager(PKE, ULONG, int);

BOOL AccessProceduresStream(PKE, ULONG, int);
VOID SetAccessEnabledFlag(VOID);
VOID StopFilterKeysTimers(VOID);

/*
 * Sound support.
 */
typedef BOOL (* BEEPPROC)(void);

BOOL HighBeep(void);
BOOL LowBeep(void);
BOOL KeyClick(void);
BOOL UpSiren(void);
BOOL DownSiren(void);
BOOL DoBeep(BEEPPROC BeepProc, UINT Count);

/*
 * Macros for dwFlags support
 */
#define TEST_ACCESSFLAG(s, f)               TEST_FLAG(g##s.dwFlags, f)
#define TEST_BOOL_ACCESSFLAG(s, f)          TEST_BOOL_FLAG(g##s.dwFlags, f)
#define SET_ACCESSFLAG(s, f)                SET_FLAG(g##s.dwFlags, f)
#define CLEAR_ACCESSFLAG(s, f)              CLEAR_FLAG(g##s.dwFlags, f)
#define SET_OR_CLEAR_ACCESSFLAG(s, f, fSet) SET_OR_CLEAR_FLAG(g##s.dwFlags, f, fSet)
#define TOGGLE_ACCESSFLAG(s, f)             TOGGLE_FLAG(g##s.dwFlags, f)


#define RIGHTSHIFTBIT         0x2
#define ONLYRIGHTSHIFTDOWN(state) ((state) == RIGHTSHIFTBIT)
#define FKFIRSTWARNINGTIME    4000
#define FKACTIVATIONDELTA     4000
#define FKEMERGENCY1DELTA     4000
#define FKEMERGENCY2DELTA     4000

//
// Warning: do not change the ordering of these.
//
#define FKIDLE                   0
#define FKFIRSTWARNING           1
#define FKTOGGLE                 2
#define FKFIRSTLEVELEMERGENCY    3
#define FKSECONDLEVELEMERGENCY   4
#define FKMOUSEMOVE              8

/*
 * StickyKeys support.
 */
#define TOGGLE_STICKYKEYS_COUNT 5
#define UNION(x, y) ((x) | (y))
#define LEFTSHIFTKEY(key)  (((key) & 0xff) == VK_LSHIFT)
#define RIGHTSHIFTKEY(key) (((key) & 0xff) == VK_RSHIFT)
#define LEFTORRIGHTSHIFTKEY(key) (LEFTSHIFTKEY(key) || RIGHTSHIFTKEY(key))
BOOL xxxTwoKeysDown(int);
VOID SetGlobalCursorLevel(INT iCursorLevel);
VOID xxxUpdateModifierState(int, int);
VOID xxxTurnOffStickyKeys(VOID);
VOID xxxHardwareMouseKeyUp(DWORD);

/*
 * ToggleKeys support.
 */
#define TOGGLEKEYTOGGLETIME    5000

/*
 * MouseKeys support.
 */

//
// Parameter Constants for xxxButtonEvent()
//
#define MOUSE_BUTTON_LEFT   0x0001
#define MOUSE_BUTTON_RIGHT  0x0002

#define MOUSEKEYMODBITS     0x11
#define LRALT               0x30
#define LRCONTROL           0x0c
#define LRSHIFT             0x03
#define LRWIN               0xc0
#define VK_U                0x55

//
// Mouse cursor movement data.
//
#define MK_UP               0xFF00
#define MK_DOWN             0x0100
#define MK_RIGHT            0x0001
#define MK_LEFT             0x00FF

#define MOUSETIMERRATE      50
#define MOUSETICKS          (1000 / MOUSETIMERRATE)
/*
 * Factor for high-speed movement.
 */
#define MK_CONTROL_SPEED    4


/*
 * Valid ranges and default values.
 */
#define MAXSPEED_MIN        (10)
#define MAXSPEED_MAX        (360)
#define MAXSPEED_DEF        (40)

#define TIMETOMAXSPEED_MIN  (1000)
#define TIMETOMAXSPEED_MAX  (5000)
#define TIMETOMAXSPEED_DEF  (3000)

typedef BOOL (* MOUSEPROC)(USHORT);

VOID TurnOffMouseKeys(VOID);
BOOL xxxMKButtonClick(USHORT);
BOOL xxxMKMouseMove(USHORT);
BOOL xxxMKButtonSetState(USHORT);
BOOL MKButtonSelect(USHORT);
BOOL xxxMKButtonDoubleClick(USHORT);
BOOL xxxMKToggleMouseKeys(USHORT);
VOID MKShowMouseCursor(VOID);
VOID MKHideMouseCursor(VOID);
VOID CalculateMouseTable(VOID);

/*
 * TimeOut support.
 */
VOID AccessTimeOutReset(VOID);
VOID xxxAccessTimeOutTimer(PWND, UINT, UINT_PTR, LPARAM);

/*
 * SoundSentry support.
 */
BOOL _UserSoundSentryWorker(VOID);

#endif  // !_ACCESS_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kernel\access.c ===
/****************************** Module Header ******************************\
* Module Name: access.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* This module contains the Access Pack functions.
*
* History:
*   11 Feb 93 GregoryW   Created.
\***************************************************************************/

#include "precomp.h"
#pragma hdrstop

CONST ACCESSIBILITYPROC aAccessibilityProc[] = {
    HighContrastHotKey,
    FilterKeys,
    xxxStickyKeys,
    MouseKeys,
    ToggleKeys
#if 0
    ,UtilityManager
#endif
};

typedef struct tagMODBITINFO {
    int BitPosition;
    BYTE ScanCode;
    USHORT Vk;
} MODBITINFO, *PMODBITINFO;

CONST MODBITINFO aModBit[] =
{
    { 0x01, SCANCODE_LSHIFT, VK_LSHIFT },
    { 0x02, SCANCODE_RSHIFT, VK_RSHIFT | KBDEXT },
    { 0x04, SCANCODE_CTRL, VK_LCONTROL },
    { 0x08, SCANCODE_CTRL, VK_RCONTROL | KBDEXT },
    { 0x10, SCANCODE_ALT, VK_LMENU },
    { 0x20, SCANCODE_ALT, VK_RMENU | KBDEXT },
    { 0x40, SCANCODE_LWIN, VK_LWIN },
    { 0x80, SCANCODE_RWIN,    VK_RWIN | KBDEXT}
};

/*
 * The ausMouseVKey array provides a translation from the virtual key
 * value to an index.  The index is used to select the appropriate
 * routine to process the virtual key, as well as to select extra
 * information that is used by this routine during its processing.
 */
CONST USHORT ausMouseVKey[] = {
                       VK_CLEAR,
                       VK_PRIOR,
                       VK_NEXT,
                       VK_END,
                       VK_HOME,
                       VK_LEFT,
                       VK_UP,
                       VK_RIGHT,
                       VK_DOWN,
                       VK_INSERT,
                       VK_DELETE,
                       VK_MULTIPLY,
                       VK_ADD,
                       VK_SUBTRACT,
                       VK_DIVIDE | KBDEXT,
                       VK_NUMLOCK | KBDEXT
                      };

CONST int cMouseVKeys = sizeof(ausMouseVKey) / sizeof(ausMouseVKey[0]);

/*
 * aMouseKeyEvent is an array of function pointers.  The routine to call
 * is selected using the index created by scanning the ausMouseVKey array.
 */
CONST MOUSEPROC aMouseKeyEvent[] = {
    xxxMKButtonClick,      // Numpad 5 (Clear)
    xxxMKMouseMove,        // Numpad 9 (PgUp)
    xxxMKMouseMove,        // Numpad 3 (PgDn)
    xxxMKMouseMove,        // Numpad 1 (End)
    xxxMKMouseMove,        // Numpad 7 (Home)
    xxxMKMouseMove,        // Numpad 4 (Left)
    xxxMKMouseMove,        // Numpad 8 (Up)
    xxxMKMouseMove,        // Numpad 6 (Right)
    xxxMKMouseMove,        // Numpad 2 (Down)
    xxxMKButtonSetState,   // Numpad 0 (Ins)
    xxxMKButtonSetState,   // Numpad . (Del)
    MKButtonSelect,        // Numpad * (Multiply)
    xxxMKButtonDoubleClick,// Numpad + (Add)
    MKButtonSelect,        // Numpad - (Subtract)
    MKButtonSelect,        // Numpad / (Divide)
    xxxMKToggleMouseKeys   // Num Lock
};

/*
 * ausMouseKeyData contains useful data for the routines that process
 * the virtual mousekeys.  This array is indexed using the index created
 * by scanning the ausMouseVKey array.
 */
CONST USHORT ausMouseKeyData[] = {
    0,                     // Numpad 5: Click active button
    MK_UP | MK_RIGHT,      // Numpad 9: Up & Right
    MK_DOWN | MK_RIGHT,    // Numpad 3: Down & Right
    MK_DOWN | MK_LEFT,     // Numpad 1: Down & Left
    MK_UP | MK_LEFT,       // Numpad 7: Up & Left
    MK_LEFT,               // Numpad 4: Left
    MK_UP,                 // Numpad 8: Up
    MK_RIGHT,              // Numpad 6: Right
    MK_DOWN,               // Numpad 2: Down
    FALSE,                 // Numpad 0: Active button down
    TRUE,                  // Numpad .: Active button up
    MOUSE_BUTTON_LEFT | MOUSE_BUTTON_RIGHT,   // Numpad *: Select both buttons
    0,                     // Numpad +: Double click active button
    MOUSE_BUTTON_RIGHT,    // Numpad -: Select right button
    MOUSE_BUTTON_LEFT,     // Numpad /: Select left button
    0
};


__inline void
PostAccessNotification(UINT accessKeyType)
{
    if (gspwndLogonNotify != NULL)
    {
        glinp.ptiLastWoken = GETPTI(gspwndLogonNotify);

        _PostMessage(gspwndLogonNotify, WM_LOGONNOTIFY,
                 LOGON_ACCESSNOTIFY, accessKeyType);
    }
}

void PostRitSound(PTERMINAL pTerm, UINT message) {
    PostEventMessage(
                    pTerm->ptiDesktop,
                    pTerm->ptiDesktop->pq,
                    QEVENT_RITSOUND,
                    NULL,
                    message, 0, 0);
    return;
}

void PostAccessibility( LPARAM lParam )
{
    PTERMINAL pTerm = grpdeskRitInput->rpwinstaParent->pTerm;

    PostEventMessage(
            pTerm->ptiDesktop,
            pTerm->ptiDesktop->pq,
            QEVENT_RITACCESSIBILITY,
            NULL,
            0, HSHELL_ACCESSIBILITYSTATE, lParam);
}

/***************************************************************************\
* AccessProceduresStream
*
* This function controls the order in which the access functions are called.
* All key events pass through this routine.  If an access function returns
* FALSE then none of the other access functions in the stream are called.
* This routine is called initially from KeyboardApcProcedure(), but then
* can be called any number of times by the access functions as they process
* the current key event or add more key events.
*
* Return value:
*   TRUE    All access functions returned TRUE, the key event can be
*           processed.
*   FALSE   An access function returned FALSE, the key event should be
*           discarded.
*
* History:
*   11 Feb 93 GregoryW   Created.
\***************************************************************************/
BOOL AccessProceduresStream(PKE pKeyEvent, ULONG ExtraInformation, int dwProcIndex)
{
    int index;

    CheckCritIn();
    for (index = dwProcIndex; index < ARRAY_SIZE(aAccessibilityProc); index++) {
        if (!aAccessibilityProc[index](pKeyEvent, ExtraInformation, index+1)) {
            return FALSE;
        }
    }

    return TRUE;
}


/***************************************************************************\
* FKActivationTimer
*
* If the hot key (right shift key) is held down this routine is called after
* 4, 8, 12 and 16 seconds.  This routine is only called at the 12 and 16
* second time points if we're in the process of enabling FilterKeys.  If at
* 8 seconds FilterKeys is disabled then this routine will not be called again
* until the hot key is released and then pressed.
*
* This routine is called with the critical section already locked.
*
* Return value:
*    0
*
* History:
*   11 Feb 93 GregoryW   Created.
\***************************************************************************/
VOID FKActivationTimer(
    PWND pwnd,
    UINT message,
    UINT_PTR nID,
    LPARAM lParam)
{
    UINT TimerDelta;
    PTERMINAL pTerm = grpdeskRitInput->rpwinstaParent->pTerm;

    UNREFERENCED_PARAMETER(pwnd);
    UNREFERENCED_PARAMETER(lParam);
    UNREFERENCED_PARAMETER(message);

    CheckCritIn();

    switch (gFilterKeysState) {

    case FKFIRSTWARNING:
        //
        // The audible feedback cannot be disabled for this warning.
        //
        TimerDelta = FKACTIVATIONDELTA;
        break;

    case FKTOGGLE:
        if (TEST_ACCESSFLAG(FilterKeys, FKF_FILTERKEYSON)) {
            //
            // Disable Filter Keys
            //
            CLEAR_ACCESSFLAG(FilterKeys, FKF_FILTERKEYSON);
            if (TEST_ACCESSFLAG(FilterKeys, FKF_HOTKEYSOUND)) {
                PostRitSound(pTerm, RITSOUND_DOWNSIREN);
            }
            PostAccessibility(ACCESS_FILTERKEYS);
            //
            // Stop all timers that are currently running.
            //
            if (gtmridFKResponse != 0) {
                KILLRITTIMER(NULL, gtmridFKResponse);
                gtmridFKResponse = 0;
            }

            if (gtmridFKAcceptanceDelay != 0) {
                KILLRITTIMER(NULL, gtmridFKAcceptanceDelay);
                gtmridFKAcceptanceDelay = 0;
            }

            //
            // Don't reset activation timer.  Emergency levels are only
            // activated after enabling Filter Keys.
            //
            return;
        } else {
            if (TEST_ACCESSFLAG(FilterKeys, FKF_HOTKEYSOUND)) {
                PostRitSound(pTerm, RITSOUND_UPSIREN);
            }

            PostAccessNotification(ACCESS_FILTERKEYS);

        }
        TimerDelta = FKEMERGENCY1DELTA;
        break;

    case FKFIRSTLEVELEMERGENCY:
        //
        // First level emergency settings:
        //    Repeat Rate OFF
        //    SlowKeys OFF (Acceptance Delay of 0)
        //    BounceKeys Debounce Time of 1 second
        //
        if (TEST_ACCESSFLAG(FilterKeys, FKF_HOTKEYSOUND)) {
            PostEventMessage(pTerm->ptiDesktop,
                             pTerm->ptiDesktop->pq,
                             QEVENT_RITSOUND,
                             NULL,
                             RITSOUND_DOBEEP,
                             RITSOUND_UPSIREN,
                             2);
        }
        gFilterKeys.iRepeatMSec = 0;
        gFilterKeys.iWaitMSec = 0;
        gFilterKeys.iBounceMSec = 1000;
        TimerDelta = FKEMERGENCY2DELTA;
        break;

    case FKSECONDLEVELEMERGENCY:
        //
        // Second level emergency settings:
        //    Repeat Rate OFF
        //    SlowKeys Acceptance Delay of 2 seconds
        //    BounceKeys OFF (Debounce Time of 0)
        //
        gFilterKeys.iRepeatMSec = 0;
        gFilterKeys.iWaitMSec = 2000;
        gFilterKeys.iBounceMSec = 0;
        if (TEST_ACCESSFLAG(FilterKeys, FKF_HOTKEYSOUND)) {
            PostEventMessage(
                    pTerm->ptiDesktop,
                    pTerm->ptiDesktop->pq,
                    QEVENT_RITSOUND,
                    NULL,
                    RITSOUND_DOBEEP, RITSOUND_UPSIREN, 3);
        }
        return;
        break;

    default:
        return;
    }

    gFilterKeysState++;
    gtmridFKActivation = InternalSetTimer(NULL,
                                          nID,
                                          TimerDelta,
                                          FKActivationTimer,
                                          TMRF_RIT | TMRF_ONESHOT);
}

/***************************************************************************\
* FKBounceKeyTimer
*
* If BounceKeys is active this routine is called after the debounce time
* has expired.  Until then, the last key released will not be accepted as
* input if it is pressed again.
*
* Return value:
*    0
*
* History:
*   11 Feb 93 GregoryW   Created.
\***************************************************************************/
VOID FKBounceKeyTimer(
    PWND pwnd,
    UINT message,
    UINT_PTR nID,
    LPARAM lParam)
{
    UNREFERENCED_PARAMETER(pwnd);
    UNREFERENCED_PARAMETER(lParam);
    UNREFERENCED_PARAMETER(nID);
    UNREFERENCED_PARAMETER(message);

    CheckCritIn();

    //
    // All we need to do is clear gBounceVk to allow this key as the
    // next keystroke.
    //
    gBounceVk = 0;
}

/***************************************************************************\
* xxxFKRepeatRateTimer
*
* If FilterKeys is active and a repeat rate is set, this routine controls
* the rate at which the last key pressed repeats.  The hardware keyboard
* typematic repeat is ignored in this case.
*
* This routine is called with the critical section already locked.
*
* Return value:
*    0
*
* History:
*   11 Feb 93 GregoryW   Created.
\***************************************************************************/
VOID xxxFKRepeatRateTimer(
    PWND pwnd,
    UINT message,
    UINT_PTR nID,
    LPARAM lParam)
{
    UNREFERENCED_PARAMETER(pwnd);
    UNREFERENCED_PARAMETER(lParam);
    UNREFERENCED_PARAMETER(message);

    CheckCritIn();

    if (TEST_ACCESSFLAG(FilterKeys, FKF_CLICKON)) {
        PTERMINAL pTerm = grpdeskRitInput->rpwinstaParent->pTerm;
        PostRitSound(pTerm, RITSOUND_KEYCLICK);
    }

    UserAssert(gtmridFKAcceptanceDelay == 0);

    gtmridFKResponse = InternalSetTimer(NULL,
                                        nID,
                                        gFilterKeys.iRepeatMSec,
                                        xxxFKRepeatRateTimer,
                                        TMRF_RIT | TMRF_ONESHOT);
    if (AccessProceduresStream(gpFKKeyEvent, gFKExtraInformation, gFKNextProcIndex)) {
        xxxProcessKeyEvent(gpFKKeyEvent, gFKExtraInformation, FALSE);
    }
}

/***************************************************************************\
* xxxFKAcceptanceDelayTimer
*
* If FilterKeys is active and an acceptance delay is set, this routine
* is called after the key has been held down for the acceptance delay
* period.
*
* This routine is called with the critical section already locked.
*
* Return value:
*    0
*
* History:
*   11 Feb 93 GregoryW   Created.
\***************************************************************************/
VOID xxxFKAcceptanceDelayTimer(
    PWND pwnd,
    UINT message,
    UINT_PTR nID,
    LPARAM lParam)
{
    UNREFERENCED_PARAMETER(lParam);
    UNREFERENCED_PARAMETER(message);
    UNREFERENCED_PARAMETER(pwnd);

    CheckCritIn();

    //
    // The key has been held down long enough. Send it on...
    //
    if (TEST_ACCESSFLAG(FilterKeys, FKF_CLICKON)) {
        PTERMINAL pTerm = grpdeskRitInput->rpwinstaParent->pTerm;
        PostRitSound(pTerm, RITSOUND_KEYCLICK);
    }

    if (AccessProceduresStream(gpFKKeyEvent, gFKExtraInformation, gFKNextProcIndex)) {
        xxxProcessKeyEvent(gpFKKeyEvent, gFKExtraInformation, FALSE);
    }

    if (!gFilterKeys.iRepeatMSec) {
        //
        // gptmrFKAcceptanceDelay needs to be released, but we can't do it while
        // in a RIT timer routine.  Set a global to indicate that the subsequent
        // break of this key should be passed on and the timer freed.
        //
        SET_ACCF(ACCF_FKMAKECODEPROCESSED);
        return;
    }

    UserAssert(gtmridFKResponse == 0);
    if (gFilterKeys.iDelayMSec) {
        gtmridFKResponse = InternalSetTimer(NULL,
                                            nID,
                                            gFilterKeys.iDelayMSec,
                                            xxxFKRepeatRateTimer,
                                            TMRF_RIT | TMRF_ONESHOT);
    } else {
        gtmridFKResponse = InternalSetTimer(NULL,
                                            nID,
                                            gFilterKeys.iRepeatMSec,
                                            xxxFKRepeatRateTimer,
                                            TMRF_RIT | TMRF_ONESHOT);
    }

    //
    // gptmrFKAcceptanceDelay timer structure was reused so set handle to
    // NULL.
    //
    gtmridFKAcceptanceDelay = 0;
}

/***************************************************************************\
* FilterKeys
*
* History:
*   11 Feb 93 GregoryW   Created.
\***************************************************************************/
BOOL FilterKeys(
    PKE pKeyEvent,
    ULONG ExtraInformation,
    int NextProcIndex)
{
    int fBreak;
    BYTE Vk;

    CheckCritIn();
    Vk = (BYTE)(pKeyEvent->usFlaggedVk & 0xff);
    fBreak = pKeyEvent->usFlaggedVk & KBDBREAK;

    //
    // Check for Filter Keys hot key (right shift key).
    //
    if (Vk == VK_RSHIFT) {
        if (fBreak) {
            if (gtmridFKActivation != 0) {
                KILLRITTIMER(NULL, gtmridFKActivation);
                gtmridFKActivation = 0;
            }
            gFilterKeysState = FKIDLE;
        } else if (ONLYRIGHTSHIFTDOWN(gPhysModifierState)) {
            //
            // Verify that activation via hotkey is allowed.
            //
            if (TEST_ACCESSFLAG(FilterKeys, FKF_HOTKEYACTIVE)) {
                if ((gtmridFKActivation == 0) && (gFilterKeysState != FKMOUSEMOVE)) {
                    gFilterKeysState = FKFIRSTWARNING;
                    gtmridFKActivation = InternalSetTimer(NULL,
                                                          0,
                                                          FKFIRSTWARNINGTIME,
                                                          FKActivationTimer,
                                                          TMRF_RIT | TMRF_ONESHOT);
                }
            }
        }
    }

    //
    // If another key is pressed while the hot key is down, kill
    // the timer.
    //
    if (Vk != VK_RSHIFT && gtmridFKActivation != 0) {
        gFilterKeysState = FKIDLE;
        KILLRITTIMER(NULL, gtmridFKActivation);
        gtmridFKActivation = 0;
    }

    //
    // If Filter Keys not enabled send the key event on.
    //
    if (!TEST_ACCESSFLAG(FilterKeys, FKF_FILTERKEYSON)) {
        return TRUE;
    }

    if (fBreak) {
        //
        // Kill the current timer and activate bounce key timer (if this is
        // a break of the last key down).
        //
        if (Vk == gLastVkDown) {
            KILLRITTIMER(NULL, gtmridFKResponse);
            gtmridFKResponse = 0;

            gLastVkDown = 0;
            if (gtmridFKAcceptanceDelay != 0) {
                KILLRITTIMER(NULL, gtmridFKAcceptanceDelay);
                gtmridFKAcceptanceDelay = 0;
                if (!TEST_ACCF(ACCF_FKMAKECODEPROCESSED)) {
                    //
                    // This key was released before accepted.  Don't pass on the
                    // break.
                    //
                    return FALSE;
                } else {
                    CLEAR_ACCF(ACCF_FKMAKECODEPROCESSED);
                }
            }

            if (gFilterKeys.iBounceMSec) {
                gBounceVk = Vk;
                gtmridFKResponse = InternalSetTimer(NULL,
                                                    0,
                                                    gFilterKeys.iBounceMSec,
                                                    FKBounceKeyTimer,
                                                    TMRF_RIT | TMRF_ONESHOT);
                if (TEST_ACCF(ACCF_IGNOREBREAKCODE)) {
                    return FALSE;
                }
            }
        }
    } else {
        //
        // Make key processing
        //
        // First check to see if this is a typematic repeat.  If so, we
        // can ignore this key event.  Our timer will handle any repeats.
        // LastVkDown is cleared during processing of the break.
        //
        if (Vk == gLastVkDown) {
            return FALSE;
        }
        //
        // Remember current Virtual Key down for typematic repeat check.
        //
        gLastVkDown = Vk;

        if (gBounceVk) {
            //
            // BounceKeys is active.  If this is a make of the last
            // key pressed we ignore it.  Only when the BounceKey
            // timer expires or another key is pressed will we accept
            // this key.
            //
            if (Vk == gBounceVk) {
                //
                // Ignore this make event and the subsequent break
                // code.  BounceKey timer will be reset on break.
                //
                SET_ACCF(ACCF_IGNOREBREAKCODE);
                return FALSE;
            } else {
                //
                // We have a make of a new key.  Kill the BounceKey
                // timer and clear gBounceVk.
                //
                UserAssert(gtmridFKResponse);
                if (gtmridFKResponse != 0) {
                    KILLRITTIMER(NULL, gtmridFKResponse);
                    gtmridFKResponse = 0;
                }
                gBounceVk = 0;
            }
        }
        CLEAR_ACCF(ACCF_IGNOREBREAKCODE);

        //
        // Give audible feedback that key was pressed.
        //
        if (TEST_ACCESSFLAG(FilterKeys, FKF_CLICKON)) {
            PTERMINAL pTerm = grpdeskRitInput->rpwinstaParent->pTerm;
            PostRitSound(
                    pTerm,
                    RITSOUND_KEYCLICK);
        }

        //
        // If gptmrFKAcceptanceDelay is non-NULL the previous key was
        // not held down long enough to be accepted.  Kill the current
        // timer.  A new timer will be started below for the key we're
        // processing now.
        //
        if (gtmridFKAcceptanceDelay != 0) {
            KILLRITTIMER(NULL, gtmridFKAcceptanceDelay);
            gtmridFKAcceptanceDelay = 0;
        }

        //
        // If gptmrFKResponse is non-NULL a repeat rate timer is active
        // on the previous key.  Kill the timer as we have a new make key.
        //
        if (gtmridFKResponse != 0) {
            KILLRITTIMER(NULL, gtmridFKResponse);
            gtmridFKResponse = 0;
        }

        //
        // Save the current key event for later use if we process an
        // acceptance delay or key repeat.
        //
        *gpFKKeyEvent = *pKeyEvent;
        gFKExtraInformation = ExtraInformation;
        gFKNextProcIndex = NextProcIndex;

        //
        // If there is an acceptance delay, set timer and ignore current
        // key event.  When timer expires, saved key event will be sent.
        //
        if (gFilterKeys.iWaitMSec) {
            gtmridFKAcceptanceDelay = InternalSetTimer(NULL,
                                                       0,
                                                       gFilterKeys.iWaitMSec,
                                                       xxxFKAcceptanceDelayTimer,
                                                       TMRF_RIT | TMRF_ONESHOT);
            CLEAR_ACCF(ACCF_FKMAKECODEPROCESSED);
            return FALSE;
        }
        //
        // No acceptance delay.  Before sending this key event on the
        // timer routine must be set to either the delay until repeat value
        // or the repeat rate value.  If repeat rate is 0 then ignore
        // delay until repeat.
        //
        if (!gFilterKeys.iRepeatMSec) {
            return TRUE;
        }

        UserAssert(gtmridFKResponse == 0);
        if (gFilterKeys.iDelayMSec) {
            gtmridFKResponse = InternalSetTimer(NULL,
                                                0,
                                                gFilterKeys.iDelayMSec,
                                                xxxFKRepeatRateTimer,
                                                TMRF_RIT | TMRF_ONESHOT);
        } else {
            gtmridFKResponse = InternalSetTimer(NULL,
                                                0,
                                                gFilterKeys.iRepeatMSec,
                                                xxxFKRepeatRateTimer,
                                                TMRF_RIT | TMRF_ONESHOT);
        }
    }

    return TRUE;
}

/***************************************************************************\
* StopFilterKeysTimers
*
* Called from SystemParametersInfo on SPI_SETFILTERKEYS if FKF_FILTERKEYSON
* is not set.  Timers must be stopped if user turns FilterKeys off.
*
* History:
*   18 Jul 94 GregoryW   Created.
\***************************************************************************/
VOID StopFilterKeysTimers(VOID)
{

    if (gtmridFKResponse != 0) {
        KILLRITTIMER(NULL, gtmridFKResponse);
        gtmridFKResponse = 0;
    }
    if (gtmridFKAcceptanceDelay) {
        KILLRITTIMER(NULL, gtmridFKAcceptanceDelay);
        gtmridFKAcceptanceDelay = 0;
    }
    gLastVkDown = 0;
    gBounceVk = 0;
}

/***************************************************************************\
* xxxStickyKeys
*
* History:
*   11 Feb 93 GregoryW   Created.
\***************************************************************************/
BOOL xxxStickyKeys(PKE pKeyEvent, ULONG ExtraInformation, int NextProcIndex)
{
    int fBreak;
    BYTE NewLockBits, NewLatchBits;
    int BitPositions;
    BOOL bChange;
    PTERMINAL pTerm = grpdeskRitInput->rpwinstaParent->pTerm;


    CheckCritIn();
    fBreak = pKeyEvent->usFlaggedVk & KBDBREAK;

    if (gCurrentModifierBit) {
        //
        // Process modifier key
        //

        //
        // One method of activating StickyKeys is to press either the
        // left shift key or the right shift key five times without
        // pressing any other keys.  We don't want the typematic shift
        // (make code) to enable/disable StickyKeys so we perform a
        // special test for them.
        //
        if (!fBreak) {
            if (gCurrentModifierBit & gPrevModifierState) {
                //
                // This is a typematic make of a modifier key.  Don't do
                // any further processing.  Just pass it along.
                //
                gPrevModifierState = gPhysModifierState;
                return TRUE;
            }
        }

        gPrevModifierState = gPhysModifierState;

        if (LEFTSHIFTKEY(pKeyEvent->usFlaggedVk) &&
            ((gPhysModifierState & ~gCurrentModifierBit) == 0)) {
            gStickyKeysLeftShiftCount++;
        } else {
            gStickyKeysLeftShiftCount = 0;
        }
        if (RIGHTSHIFTKEY(pKeyEvent->usFlaggedVk) &&
            ((gPhysModifierState & ~gCurrentModifierBit) == 0)) {
            gStickyKeysRightShiftCount++;
        } else {
            gStickyKeysRightShiftCount = 0;
        }

        //
        // Check to see if StickyKeys should be toggled on/off
        //
        if ((gStickyKeysLeftShiftCount == (TOGGLE_STICKYKEYS_COUNT * 2)) ||
            (gStickyKeysRightShiftCount == (TOGGLE_STICKYKEYS_COUNT * 2))) {
            if (TEST_ACCESSFLAG(StickyKeys, SKF_HOTKEYACTIVE)) {
                if (TEST_ACCESSFLAG(StickyKeys, SKF_STICKYKEYSON)) {
                    xxxTurnOffStickyKeys();
                    if (TEST_ACCESSFLAG(StickyKeys, SKF_HOTKEYSOUND)) {
                        PostRitSound(
                            pTerm,
                            RITSOUND_DOWNSIREN);
                    }
                } else {
                    if (TEST_ACCESSFLAG(StickyKeys, SKF_HOTKEYSOUND)) {
                        PostRitSound(
                            pTerm,
                            RITSOUND_UPSIREN);
                    }
                    // To make the notification window get the focus
                    // The same is done other places where WM_LOGONNOTIFY message is
                    // sent    : a-anilk
                    PostAccessNotification(ACCESS_STICKYKEYS);

                }
            }
            gStickyKeysLeftShiftCount = 0;
            gStickyKeysRightShiftCount = 0;
            return TRUE;
        }

        //
        // If StickyKeys is enabled process the modifier key, otherwise
        // just pass on the modifier key.
        //
        if (TEST_ACCESSFLAG(StickyKeys, SKF_STICKYKEYSON)) {
            if (fBreak) {
                //
                // If either locked or latched bit set for this key then
                // don't pass the break on.
                //
                if (UNION(gLatchBits, gLockBits) & gCurrentModifierBit) {
                    return FALSE;
                } else {
                    return TRUE;
                }
            } else{
                if (gPhysModifierState != gCurrentModifierBit) {
                    //
                    // More than one modifier key down at the same time.
                    // This condition may signal sticky keys to turn off.
                    // The routine xxxTwoKeysDown will return the new value
                    // of fStickyKeysOn.  If sticky keys is turned off
                    // (return value 0), the key event should be passed
                    // on without further processing here.
                    //
                    if (!xxxTwoKeysDown(NextProcIndex)) {
                        return TRUE;
                    }

                    //
                    // Modifier states were set to physical state by
                    // xxxTwoKeysDown.  The modifier keys currently in
                    // the down position will be latched by updating
                    // gLatchBits.  No more processing for this key
                    // event is needed.
                    //
                    bChange = gLockBits ||
                              (gLatchBits != gPhysModifierState);
                    gLatchBits = gPhysModifierState;
                    gLockBits = 0;
                    if (bChange) {
                        PostAccessibility( ACCESS_STICKYKEYS );
                    }

                    //
                    // Provide sound feedback, if enabled, before returning.
                    //
                    if (TEST_ACCESSFLAG(StickyKeys, SKF_AUDIBLEFEEDBACK)) {
                        PostRitSound(
                            pTerm,
                            RITSOUND_LOWBEEP);
                        PostRitSound(
                            pTerm,
                            RITSOUND_HIGHBEEP);
                    }
                    return FALSE;
                }
                //
                // Figure out which bits (Shift, Ctrl or Alt key bits) to
                // examine.  Also set up default values for NewLatchBits
                // and NewLockBits in case they're not set later.
                //
                // See the depiction of the bit pattern in KeyboardApcProcedure.
                //
                // Bit 0 -- L SHIFT
                // Bit 1 -- R SHIFT
                // Bit 2 -- L CTL
                // Bit 3 -- R CTL
                // Bit 4 -- L ALT
                // Bit 5 -- R RLT
                // Bit 6 -- L WIN
                // Bit 7 -- R WIN
                switch(pKeyEvent->usFlaggedVk) {
                case VK_LSHIFT:
                case VK_RSHIFT:
                    BitPositions = 0x3;
                    break;
                case VK_LCONTROL:
                case VK_RCONTROL:
                    BitPositions = 0xc;
                    break;
                case VK_LMENU:
                case VK_RMENU:
                    BitPositions = 0x30;
                    break;
                case VK_LWIN:
                case VK_RWIN:
                    BitPositions = 0xc0;
                    break;
                }
                NewLatchBits = gLatchBits;
                NewLockBits = gLockBits;

                //
                // If either left or right modifier is locked clear latched
                // and locked states and send appropriate break/make messages.
                //
                if (gLockBits & BitPositions) {
                    NewLockBits = gLockBits & ~BitPositions;
                    NewLatchBits = gLatchBits & ~BitPositions;
                    xxxUpdateModifierState(
                        NewLockBits | NewLatchBits | gCurrentModifierBit,
                        NextProcIndex
                        );
                } else {
                    //
                    // If specific lock bit (left or right) not
                    // previously set then toggle latch bits.
                    //
                    if (!(gLockBits & gCurrentModifierBit)) {
                        NewLatchBits = gLatchBits ^ gCurrentModifierBit;
                    }
                    //
                    // If locked mode (tri-state) enabled then if latch or lock
                    // bit previously set, toggle lock bit.
                    //
                    if (TEST_ACCESSFLAG(StickyKeys, SKF_TRISTATE)) {
                        if (UNION(gLockBits, gLatchBits) & gCurrentModifierBit) {
                            NewLockBits = gLockBits ^ gCurrentModifierBit;
                        }
                    }
                }

                //
                // Update globals
                //
                bChange = ((gLatchBits != NewLatchBits) ||
                           (gLockBits != NewLockBits));

                gLatchBits = NewLatchBits;
                gLockBits = NewLockBits;

                if (bChange) {
                    PostAccessibility( ACCESS_STICKYKEYS );
                }
                //
                // Now provide sound feedback if enabled.  For the transition
                // to LATCH mode issue a low beep then a high beep.  For the
                // transition to LOCKED mode issue a high beep.  For the
                // transition out of LOCKED mode (or LATCH mode if tri-state
                // not enabled) issue a low beep.
                //
                if (TEST_ACCESSFLAG(StickyKeys, SKF_AUDIBLEFEEDBACK)) {
                    if (!(gLockBits & gCurrentModifierBit)) {
                        PostRitSound(
                            pTerm,
                            RITSOUND_LOWBEEP);
                    }
                    if ((gLatchBits | gLockBits) & gCurrentModifierBit) {
                        PostRitSound(
                            pTerm,
                            RITSOUND_HIGHBEEP);
                    }
                }
                //
                // Pass key on if shift bit is set (e.g., if transitioning
                // from shift to lock mode don't pass on make).
                //
                if (gLatchBits & gCurrentModifierBit) {
                    return TRUE;
                } else {
                    return FALSE;
                }

            }
        }
    } else {
        //
        // Non-shift key processing here...
        //
        gStickyKeysLeftShiftCount = 0;
        gStickyKeysRightShiftCount = 0;
        if (!TEST_ACCESSFLAG(StickyKeys, SKF_STICKYKEYSON)) {
            return TRUE;
        }

        //
        // If no modifier keys are down, or this is a break, pass the key event
        // on and clear any latch states.
        //
        if (!gPhysModifierState || fBreak) {
            if (AccessProceduresStream(pKeyEvent, ExtraInformation, NextProcIndex)) {
                xxxProcessKeyEvent(pKeyEvent, ExtraInformation, FALSE);
            }
            xxxUpdateModifierState(gLockBits, NextProcIndex);

            bChange = gLatchBits != 0;
            gLatchBits = 0;
            if (bChange) {

                PostAccessibility( ACCESS_STICKYKEYS );
            }
            return FALSE;
        } else {
            //
            // This is a make of a non-modifier key and there is a modifier key
            // down.  Update the states and pass the key event on.
            //
            xxxTwoKeysDown(NextProcIndex);
            return TRUE;
        }
    }

    return TRUE;
}

/***************************************************************************\
* xxxUpdateModifierState
*
* Starting from the current modifier keys state, send the necessary key
* events (make or break) to end up with the NewModifierState passed in.
*
* Return value:
*    None.
*
* History:
*   11 Feb 93 GregoryW   Created.
\***************************************************************************/
VOID xxxUpdateModifierState(int NewModifierState, int NextProcIndex)
{
    KE ke;
    int CurrentModState;
    int CurrentModBit, NewModBit;
    int i;

    CheckCritIn();

    CurrentModState = gLockBits | gLatchBits;

    for (i = 0; i < ARRAY_SIZE(aModBit); i++) {
        CurrentModBit = CurrentModState & aModBit[i].BitPosition;
        NewModBit = NewModifierState & aModBit[i].BitPosition;
        if (CurrentModBit != NewModBit) {
            ke.bScanCode = (BYTE)aModBit[i].ScanCode;
            ke.usFlaggedVk = aModBit[i].Vk;
            if (CurrentModBit) {          // if it's currently on, send break
                ke.usFlaggedVk |= KBDBREAK;
            }
            if (AccessProceduresStream(&ke, 0L, NextProcIndex)) {
                xxxProcessKeyEvent(&ke, 0L, FALSE);
            }
        }
    }
}

/***************************************************************************\
* xxxTurnOffStickyKeys
*
* The user either pressed the appropriate key sequence or used the
* access utility to turn StickyKeys off.  Update modifier states and
* reset globals.
*
* Return value:
*   None.
*
* History:
*   11 Feb 93 GregoryW   Created.
\***************************************************************************/
VOID xxxTurnOffStickyKeys(VOID)
{
    INT index;

    CheckCritIn();

    for (index = 0; index < ARRAY_SIZE(aAccessibilityProc); index++) {
        if (aAccessibilityProc[index] == xxxStickyKeys) {

            xxxUpdateModifierState(gPhysModifierState, index+1);
            gLockBits = gLatchBits = 0;
            CLEAR_ACCESSFLAG(StickyKeys, SKF_STICKYKEYSON);

            PostAccessibility( ACCESS_STICKYKEYS );
            break;
        }
    }
}

/***************************************************************************\
* xxxUnlatchStickyKeys
*
* This routine releases any sticky keys that are latched.  This routine
* is called during mouse up event processing.
*
* Return value:
*   None.
*
* History:
*   21 Jun 93 GregoryW   Created.
\***************************************************************************/
VOID xxxUnlatchStickyKeys(VOID)
{
    INT index;
    BOOL bChange;

    if (!gLatchBits) {
        return;
    }

    for (index = 0; index < ARRAY_SIZE(aAccessibilityProc); index++) {
        if (aAccessibilityProc[index] == xxxStickyKeys) {
            xxxUpdateModifierState(gLockBits, index+1);
            bChange = gLatchBits != 0;
            gLatchBits = 0;

            if (bChange) {

                PostAccessibility( ACCESS_STICKYKEYS );
            }
            break;
        }
    }
}


/***************************************************************************\
* xxxHardwareMouseKeyUp
*
* This routine is called during a mouse button up event.  If MouseKeys is
* on and the button up event corresponds to a mouse key that's locked down,
* the mouse key must be released.
*
* If StickyKeys is on, all latched keys are released.
*
* Return value:
*   None.
*
* History:
*   17 Jun 94 GregoryW   Created.
\***************************************************************************/

VOID xxxHardwareMouseKeyUp(DWORD dwButton)
{
    CheckCritIn();

    if (TEST_ACCESSFLAG(MouseKeys, MKF_MOUSEKEYSON)) {
        gwMKButtonState &= ~dwButton;
    }

    // Not required to post a setting change
    //PostAccessibility( SPI_SETMOUSEKEYS );

    if (TEST_ACCESSFLAG(StickyKeys, SKF_STICKYKEYSON)) {
        xxxUnlatchStickyKeys();
    }
}


/***************************************************************************\
* xxxTwoKeysDown
*
* Two keys are down simultaneously.  Check to see if StickyKeys should be
* turned off.  In all cases update the modifier key state to reflect the
* physical key state and clear latched and locked modes.
*
* Return value:
*    1 if StickyKeys is enabled.
*    0 if StickyKeys is disabled.
*
* History:
*   11 Feb 93 GregoryW   Created.
\***************************************************************************/
BOOL xxxTwoKeysDown(int NextProcIndex)
{
    PTERMINAL pTerm = grpdeskRitInput->rpwinstaParent->pTerm;

    if (TEST_ACCESSFLAG(StickyKeys, SKF_TWOKEYSOFF)) {
        CLEAR_ACCESSFLAG(StickyKeys, SKF_STICKYKEYSON);
        if (TEST_ACCESSFLAG(StickyKeys, SKF_HOTKEYSOUND)) {
            PostRitSound(
                    pTerm,
                    RITSOUND_DOWNSIREN);
        }
        gStickyKeysLeftShiftCount = 0;
        gStickyKeysRightShiftCount = 0;
    }
    xxxUpdateModifierState(gPhysModifierState, NextProcIndex);
    gLockBits = gLatchBits = 0;

    PostAccessibility( ACCESS_STICKYKEYS );

    return TEST_BOOL_ACCESSFLAG(StickyKeys, SKF_STICKYKEYSON);
}

/***************************************************************************\
* SetGlobalCursorLevel
*
* Set the cursor level of all threads running on the visible
* windowstation.
*
* History:
* 04-17-95 JimA         Created.
\***************************************************************************/

VOID SetGlobalCursorLevel(
    INT iCursorLevel)
{

/*
 * LATER
 * We have other code which assumes that the
 * iCursorLevel of a queue is the sum of the iCursorLevel values for the
 * threads attached to the queue.  But this code, if you set iCursorLevel to
 * -1 (to indicate no mouse) will set the queue iCursorLevel to -1, no matter
 * how many threads are attached to the queue.  This needs to be revisited.
 * See the function AttachToQueue.
 *  FritzS
 */


    PDESKTOP pdesk;
    PTHREADINFO pti;
    PLIST_ENTRY pHead, pEntry;

    TAGMSG1(DBGTAG_PNP, "SetGlobalCursorLevel %x", iCursorLevel);

    if (grpdeskRitInput) {
        for (pdesk = grpdeskRitInput->rpwinstaParent->rpdeskList;
                pdesk != NULL; pdesk = pdesk->rpdeskNext) {

            pHead = &pdesk->PtiList;
            for (pEntry = pHead->Flink; pEntry != pHead; pEntry = pEntry->Flink) {
                pti = CONTAINING_RECORD(pEntry, THREADINFO, PtiLink);

                pti->iCursorLevel = iCursorLevel;
                pti->pq->iCursorLevel = iCursorLevel;
            }
        }
    }

    /*
     * CSRSS doesn't seem to be on the list, so fix it up now.
     */
    for (pti = PpiFromProcess(gpepCSRSS)->ptiList;
            pti != NULL; pti = pti->ptiSibling) {
        if (pti->iCursorLevel != iCursorLevel) {
            TAGMSG3(DBGTAG_PNP, "pti %#p has cursorlevel %x, should be %x",
                    pti, pti->iCursorLevel, iCursorLevel);
        }
        if (pti->pq->iCursorLevel != iCursorLevel) {
            TAGMSG4(DBGTAG_PNP, "pti->pq %#p->%#p has cursorlevel %x, should be %x",
                    pti, pti->pq, pti->pq->iCursorLevel, iCursorLevel);
        }
        pti->iCursorLevel = iCursorLevel;
        pti->pq->iCursorLevel = iCursorLevel;
    }
}

/***************************************************************************\
* MKShowMouseCursor
*
* If no hardware mouse is installed and MouseKeys is enabled, we need
* to fix up the system metrics, the oem information and the queue
* information.  The mouse cursor then gets displayed.
*
* Return value:
*    None.
*
* History:
*   11 Feb 93 GregoryW   Created.
\***************************************************************************/
VOID MKShowMouseCursor()
{
    TAGMSG1(DBGTAG_PNP, "MKShowMouseCursor (gpDeviceInfoList == %#p)", gpDeviceInfoList);

    //
    // If TEST_GTERMF(GTERMF_MOUSE) is TRUE then we either have a hardware mouse
    // or we're already pretending a mouse is installed.  In either case,
    // there's nothing to do so just return.
    //
    if (TEST_GTERMF(GTERMF_MOUSE)) {
        TAGMSG0(DBGTAG_PNP, "MKShowMouseCursor just returns");
        return;
    }

    SET_GTERMF(GTERMF_MOUSE);
    SET_ACCF(ACCF_MKVIRTUALMOUSE);
    SYSMET(MOUSEPRESENT) = TRUE;
    SYSMET(CMOUSEBUTTONS) = 2;
    /*
     * HACK: CreateQueue() uses oemInfo.fMouse to determine if a mouse is
     * present and thus whether to set the iCursorLevel field in the
     * THREADINFO structure to 0 or -1.  Unfortunately some queues have
     * already been created at this point.  Since oemInfo.fMouse is
     * initialized to FALSE, we need to go back through any queues already
     * around and set their iCursorLevel field to the correct value when
     * mousekeys is enabled.
     */
    SetGlobalCursorLevel(0);
}

/***************************************************************************\
* MKHideMouseCursor
*
* If no hardware mouse is installed and MouseKeys is disabled, we need
* to fix up the system metrics, the oem information and the queue
* information.  The mouse cursor then disappears.
*
* Return value:
*    None.
*
* History:
*   11 Feb 93 GregoryW   Created.
\***************************************************************************/
VOID MKHideMouseCursor()
{
    TAGMSG1(DBGTAG_PNP, "MKHideMouseCursor (gpDeviceInfoList == %#p)", gpDeviceInfoList);

    //
    // If a hardware mouse is present we don't need to do anything.
    //
    if (!TEST_ACCF(ACCF_MKVIRTUALMOUSE)) {
        return;
    }

    CLEAR_ACCF(ACCF_MKVIRTUALMOUSE);
    CLEAR_GTERMF(GTERMF_MOUSE);
    SYSMET(MOUSEPRESENT) = FALSE;
    SYSMET(CMOUSEBUTTONS) = 0;

    SetGlobalCursorLevel(-1);
}

/***************************************************************************\
* xxxMKToggleMouseKeys
*
* This routine is called when the NumLock key is pressed and MouseKeys is
* active.  If the left shift key and the left alt key are down then MouseKeys
* is turned off.  If just the NumLock key is pressed then we toggle between
* MouseKeys active and the state of the number pad before MouseKeys was
* activated.
*
* Return value:
*    TRUE  - key should be passed on in the input stream.
*    FALSE - key should not be passed on.
*
* History:
\***************************************************************************/
BOOL xxxMKToggleMouseKeys(
    USHORT NotUsed)
{
    BOOL bRetVal = TRUE;
    BOOL bNewPassThrough;
    PTERMINAL pTerm = grpdeskRitInput->rpwinstaParent->pTerm;

    UNREFERENCED_PARAMETER(NotUsed);

    //
    // If this is a typematic repeat of NumLock we just pass it on.
    //
    if (TEST_ACCF(ACCF_MKREPEATVK)) {
        return bRetVal;
    }
    //
    // This is a make of NumLock.  Check for disable sequence.
    //
    if ((gLockBits | gLatchBits | gPhysModifierState) == MOUSEKEYMODBITS) {
        if (TEST_ACCESSFLAG(MouseKeys, MKF_HOTKEYACTIVE)) {
            if (!gbMKMouseMode) {
               //
               // User wants to turn MouseKeys off.  If we're currently in
               // pass through mode then the NumLock key is in the same state
               // (on or off) as it was when the user invoked MouseKeys.  We
               // want to leave it in that state, so don't pass the NumLock
               // key on.
               //
               bRetVal = FALSE;
            }
            TurnOffMouseKeys();
        }
        return bRetVal;
    }
    /*
     * This is a NumLock with no modifiers.  Toggle current state and
     * provide audible feedback.
     *
     * Note -- this test is the reverse of other ones because it tests the
     * state of VK_NUMLOCK before the keypress flips the state of NUMLOCK.
     * So the code checks for what the state will be.
     */
    bNewPassThrough =
#ifdef FE_SB // MouseKeys()
        (TestAsyncKeyStateToggle(gNumLockVk) != 0) ^
#else  // FE_SB
        (TestAsyncKeyStateToggle(VK_NUMLOCK) != 0) ^
#endif // FE_SB
             (TEST_ACCESSFLAG(MouseKeys, MKF_REPLACENUMBERS) != 0);


    if (!bNewPassThrough) {
        gbMKMouseMode = TRUE;
        PostRitSound(
              pTerm,
              RITSOUND_HIGHBEEP);
    } else {
        WORD SaveCurrentActiveButton;
        //
        // User wants keys to be passed on.  Release all buttons currently
        // down.
        //
        gbMKMouseMode = FALSE;
        PostRitSound(
              pTerm,
              RITSOUND_LOWBEEP);
        SaveCurrentActiveButton = gwMKCurrentButton;
        gwMKCurrentButton = MOUSE_BUTTON_LEFT | MOUSE_BUTTON_RIGHT;
        xxxMKButtonSetState(TRUE);
        gwMKCurrentButton = SaveCurrentActiveButton;
    }

    PostAccessibility( ACCESS_MOUSEKEYS );

    return bRetVal;
}

/***************************************************************************\
* xxxMKButtonClick
*
* Click the active mouse button.
*
* Return value:
*    Always FALSE - key should not be passed on.
*
* History:
\***************************************************************************/
BOOL xxxMKButtonClick(USHORT NotUsed)
{
    UNREFERENCED_PARAMETER(NotUsed);

    //
    // The button click only happens on initial make of key.  If this is a
    // typematic repeat we just ignore it.
    //
    if (TEST_ACCF(ACCF_MKREPEATVK)) {
        return FALSE;
    }

    //
    // Ensure active button is UP before the click
    //
    xxxMKButtonSetState(TRUE);

    //
    // Now push the button DOWN
    //
    xxxMKButtonSetState(FALSE);

    //
    // Now release the button
    //
    xxxMKButtonSetState(TRUE);

    return FALSE;
}


/***************************************************************************\
* xxxMKMoveConstCursorTimer
*
* Timer routine that handles constant speed mouse movement. This routine
* is called 20 times per second and uses information from
* gMouseCursor.bConstantTable[] to determine how many pixels to move the
* mouse cursor on each tick.
*
* Return value:
*    None.
*
* History:
\***************************************************************************/
VOID xxxMKMoveConstCursorTimer(
    PWND pwnd,
    UINT message,
    UINT_PTR nID,
    LPARAM lParam)
{
    LONG  MovePixels;

    UNREFERENCED_PARAMETER(pwnd);
    UNREFERENCED_PARAMETER(lParam);
    UNREFERENCED_PARAMETER(nID);
    UNREFERENCED_PARAMETER(message);

    CheckCritIn();

    if (TEST_ACCESSFLAG(MouseKeys, MKF_MODIFIERS)) {
        if ((gLockBits | gLatchBits | gPhysModifierState) & LRSHIFT) {
            MovePixels = 1;
            goto MoveIt;
        }
        if ((gLockBits | gLatchBits | gPhysModifierState) & LRCONTROL) {
            MovePixels = gMouseCursor.bConstantTable[0] * MK_CONTROL_SPEED;
            goto MoveIt;
        }
    }

    giMouseMoveTable %= gMouseCursor.bConstantTableLen;

    MovePixels = gMouseCursor.bConstantTable[giMouseMoveTable++];

    if (MovePixels == 0) {
        return;
    }

MoveIt:
    //
    // We're inside the critical section - leave before calling MoveEvent.
    // Set gbMouseMoved to TRUE so RawInputThread wakes up the appropriate
    // user thread (if any) to receive this event.
    //
    LeaveCrit();

    xxxMoveEvent(MovePixels * gMKDeltaX, MovePixels * gMKDeltaY, 0, 0,
#ifdef GENERIC_INPUT
                 NULL,
                 NULL,
#endif
                0, FALSE);
    QueueMouseEvent(0, 0, 0, gptCursorAsync, NtGetTickCount(),
#ifdef GENERIC_INPUT
                    /*
                     * There's no real mouse related to this mouse message.
                     */
                    NULL,
                    NULL,
#endif
                    FALSE, TRUE);
    EnterCrit();
}

/***************************************************************************\
* xxxMKMoveAccelCursorTimer
*
* Timer routine that handles mouse acceleration.  It gets called 20 times
* per second and uses information from gMouseCursor.bAccelTable[] to determine
* how many pixels to move the mouse cursor on each tick.
*
* Return value:
*    None.
*
* History:
\***************************************************************************/
VOID xxxMKMoveAccelCursorTimer(
    PWND pwnd,
    UINT message,
    UINT_PTR nID,
    LPARAM lParam)
{
    LONG  MovePixels;

    UNREFERENCED_PARAMETER(pwnd);
    UNREFERENCED_PARAMETER(message);
    UNREFERENCED_PARAMETER(nID);
    UNREFERENCED_PARAMETER(lParam);

    CheckCritIn();

    if (TEST_ACCESSFLAG(MouseKeys, MKF_MODIFIERS)) {
        if ((gLockBits | gLatchBits | gPhysModifierState) & LRSHIFT) {
            MovePixels = 1;
            goto MoveIt;
        }
        if ((gLockBits | gLatchBits | gPhysModifierState) & LRCONTROL) {
            MovePixels = gMouseCursor.bConstantTable[0] * MK_CONTROL_SPEED;
            goto MoveIt;
        }
    }

    if (giMouseMoveTable < gMouseCursor.bAccelTableLen) {
        MovePixels = gMouseCursor.bAccelTable[giMouseMoveTable++];
    } else {
        //
        // We've reached maximum cruising speed.  Switch to constant table.
        //
        MovePixels = gMouseCursor.bConstantTable[0];
        giMouseMoveTable = 1;
        gtmridMKMoveCursor = InternalSetTimer(NULL,
                                              gtmridMKMoveCursor,
                                              MOUSETIMERRATE,
                                              xxxMKMoveConstCursorTimer,
                                              TMRF_RIT);

    }
    if (MovePixels == 0) {
        return;
    }

MoveIt:
    //
    // We're inside the critical section - leave before calling xxxMoveEvent.
    // Set gbMouseMoved to TRUE so RawInputThread wakes up the appropriate
    // user thread (if any) to receive this event.
    //
    LeaveCrit();
    xxxMoveEvent(MovePixels * gMKDeltaX, MovePixels * gMKDeltaY, 0, 0,
#ifdef GENERIC_INPUT
                 NULL,
                 NULL,
#endif
                 0, FALSE);
    QueueMouseEvent(0, 0, 0, gptCursorAsync, NtGetTickCount(),
#ifdef GENERIC_INPUT
                    NULL,
                    NULL,
#endif
                    FALSE, TRUE);

    EnterCrit();
}

/***************************************************************************\
* xxxMKMouseMove
*
* Send a mouse move event.  A timer routine is set to handle the mouse
* cursor acceleration.  The timer will be set on the first make of a
* mouse move key if FilterKeys repeat rate is OFF.  Otherwise, the timer
* is set on the first repeat (typematic make) of the mouse move key.
* Once the timer is set the timer routine handles all mouse movement
* until the key is released or a new key is pressed.
*
* Return value:
*    Always FALSE - key should not be passed on.
*
* History:
\***************************************************************************/
BOOL xxxMKMouseMove(USHORT Data)
{


    /*
     * Let the mouse acceleration timer routine handle repeats.
     */
    if (TEST_ACCF(ACCF_MKREPEATVK) && (gtmridMKMoveCursor != 0)) {
        return FALSE;
    }


    gMKDeltaX = (LONG)((CHAR)LOBYTE(Data));   // Force sign extension
    gMKDeltaY = (LONG)((CHAR)HIBYTE(Data));   // Force sign extension

    LeaveCrit();

    if ((TEST_ACCESSFLAG(MouseKeys, MKF_MODIFIERS) && ((gLockBits | gLatchBits | gPhysModifierState) & LRCONTROL))) {
        xxxMoveEvent(gMKDeltaX * MK_CONTROL_SPEED * gMouseCursor.bConstantTable[0], gMKDeltaY * MK_CONTROL_SPEED * gMouseCursor.bConstantTable[0], 0, 0,
#ifdef GENERIC_INPUT
                     NULL,
                     NULL,
#endif
                     0, FALSE);
    } else {
        xxxMoveEvent(gMKDeltaX, gMKDeltaY, 0, 0,
#ifdef GENERIC_INPUT
                     NULL,
                     NULL,
#endif
                     0, FALSE);
    }

    QueueMouseEvent(0, 0, 0, gptCursorAsync, NtGetTickCount(),
#ifdef GENERIC_INPUT
                    NULL,
                    NULL,
#endif
                    FALSE, TRUE);

    EnterCrit();

    /*
     * If the repeat rate is zero we'll start the mouse acceleration
     * immediately.  Otherwise we wait until after the first repeat
     * of the mouse movement key.
     */
    if (!gFilterKeys.iRepeatMSec || TEST_ACCF(ACCF_MKREPEATVK)) {
        giMouseMoveTable = 0;
        gtmridMKMoveCursor = InternalSetTimer(NULL,
                                              gtmridMKMoveCursor,
                                              MOUSETIMERRATE,
                                              (gMouseCursor.bAccelTableLen) ?
                                                  xxxMKMoveAccelCursorTimer :
                                                  xxxMKMoveConstCursorTimer,
                                              TMRF_RIT);
    }

    return FALSE;
}

/***************************************************************************\
* xxxMKButtonSetState
*
* Set the active mouse button(s) to the state specified by fButtonUp
* (if fButtonUp is TRUE then the button is released, o.w. the button
*  is pressed).
*
* Return value:
*    Always FALSE - key should not be passed on.
*
* History:
\***************************************************************************/
BOOL xxxMKButtonSetState(USHORT fButtonUp)
{
    WORD NewButtonState;

    CheckCritIn();
    if (fButtonUp) {
        NewButtonState = gwMKButtonState & ~gwMKCurrentButton;
    } else {
        NewButtonState = gwMKButtonState | gwMKCurrentButton;
    }

    if ((NewButtonState & MOUSE_BUTTON_LEFT) != (gwMKButtonState & MOUSE_BUTTON_LEFT)) {
        xxxButtonEvent(MOUSE_BUTTON_LEFT,
                       gptCursorAsync,
                       fButtonUp,
                       NtGetTickCount(),
                       0L,
#ifdef GENERIC_INPUT
                       NULL,
                       NULL,
#endif
                       FALSE,
                       FALSE);
    }
    if ((NewButtonState & MOUSE_BUTTON_RIGHT) != (gwMKButtonState & MOUSE_BUTTON_RIGHT)) {
        xxxButtonEvent(MOUSE_BUTTON_RIGHT,
                       gptCursorAsync,
                       fButtonUp,
                       NtGetTickCount(),
                       0L,
#ifdef GENERIC_INPUT
                       NULL,
                       NULL,
#endif
                       FALSE,
                       FALSE);
    }
    gwMKButtonState = NewButtonState;

    PostAccessibility( ACCESS_MOUSEKEYS );

    return FALSE;
}

/***************************************************************************\
* MKButtonSelect
*
* Mark ThisButton as the active mouse button.  It's possible to select both
* the left and right mouse buttons as active simultaneously.
*
* Return value:
*    Always FALSE - key should not be passed on.
*
* History:
\***************************************************************************/
BOOL MKButtonSelect(WORD ThisButton)
{
    gwMKCurrentButton = ThisButton;

    PostAccessibility( ACCESS_MOUSEKEYS );
    return FALSE;
}

/***************************************************************************\
* xxxMKButtonDoubleClick
*
* Double click the active mouse button.
*
* Return value:
*    Always FALSE - key should not be passed on.
*
* History:
\***************************************************************************/
BOOL xxxMKButtonDoubleClick(
    USHORT NotUsed)
{
    UNREFERENCED_PARAMETER(NotUsed);

    xxxMKButtonClick(0);
    xxxMKButtonClick(0);

    return FALSE;
}

BOOL HighContrastHotKey(
    PKE pKeyEvent,
    ULONG ExtraInformation,
    int NotUsed)
{
    int CurrentModState;
    int fBreak;
    BYTE Vk;

    UNREFERENCED_PARAMETER(NotUsed);
    UNREFERENCED_PARAMETER(ExtraInformation);

    CheckCritIn();

    Vk = (BYTE)(pKeyEvent->usFlaggedVk & 0xff);
    fBreak = pKeyEvent->usFlaggedVk & KBDBREAK;
    CurrentModState = gLockBits | gLatchBits | gPhysModifierState;

    if (!TEST_ACCESSFLAG(HighContrast, HCF_HIGHCONTRASTON)) {
        if (TEST_ACCESSFLAG(HighContrast, HCF_HOTKEYACTIVE) && Vk == VK_SNAPSHOT && !fBreak && CurrentModState == MOUSEKEYMODBITS) {

            if (TEST_ACCESSFLAG(HighContrast, MKF_HOTKEYSOUND)) {
                PTERMINAL pTerm = grpdeskRitInput->rpwinstaParent->pTerm;
                PostRitSound(
                    pTerm,
                    RITSOUND_UPSIREN);
            }

            PostAccessNotification(ACCESS_HIGHCONTRAST);

            return FALSE;
        }
    } else {
        if (TEST_ACCESSFLAG(HighContrast, HCF_HOTKEYACTIVE) && Vk == VK_SNAPSHOT && !fBreak && CurrentModState == MOUSEKEYMODBITS) {

            CLEAR_ACCESSFLAG(HighContrast, HCF_HIGHCONTRASTON);

                        if (TEST_ACCESSFLAG(HighContrast, MKF_HOTKEYSOUND)) {
                PTERMINAL pTerm = grpdeskRitInput->rpwinstaParent->pTerm;
                PostRitSound(
                    pTerm,
                    RITSOUND_DOWNSIREN);
            }

            if (gspwndLogonNotify != NULL) {

            _PostMessage(gspwndLogonNotify, WM_LOGONNOTIFY,
                         LOGON_ACCESSNOTIFY, ACCESS_HIGHCONTRASTOFF);
            }
        }
    }

    return TRUE;  // send key event to next accessibility routine.
}


/***************************************************************************\
* MouseKeys
*
* This is the strategy routine that gets called as part of the input stream
* processing.  MouseKeys enabling/disabling is handled here.  All MouseKeys
* helper routines are called from this routine.
*
* Return value:
*    TRUE  - key event should be passed on to the next access routine.
*    FALSE - key event was processed and should not be passed on.
*
* History:
\***************************************************************************/
BOOL MouseKeys(
    PKE pKeyEvent,
    ULONG ExtraInformation,
    int NotUsed)
{
    int CurrentModState;
    int fBreak;
    BYTE Vk;
    USHORT FlaggedVk;
    int i;

    UNREFERENCED_PARAMETER(ExtraInformation);
    UNREFERENCED_PARAMETER(NotUsed);

    CheckCritIn();
    Vk = (BYTE)(pKeyEvent->usFlaggedVk & 0xff);
    fBreak = pKeyEvent->usFlaggedVk & KBDBREAK;
    CurrentModState = gLockBits | gLatchBits | gPhysModifierState;

    if (!TEST_ACCESSFLAG(MouseKeys, MKF_MOUSEKEYSON)) {
        //
        // MouseKeys currently disabled.  Check for enabling sequence:
        //   left Shift + left Alt + Num Lock.
        //
#ifdef FE_SB // MouseKeys()
        if (TEST_ACCESSFLAG(MouseKeys, MKF_HOTKEYACTIVE) && Vk == gNumLockVk && !fBreak && CurrentModState == MOUSEKEYMODBITS) {
#else  // FE_SB
        if (TEST_ACCESSFLAG(MouseKeys, MKF_HOTKEYACTIVE) && Vk == VK_NUMLOCK && !fBreak && CurrentModState == MOUSEKEYMODBITS) {
#endif // FE_SB
            gMKPreviousVk = Vk;
            if (TEST_ACCESSFLAG(MouseKeys, MKF_HOTKEYSOUND)) {
                PTERMINAL pTerm = grpdeskRitInput->rpwinstaParent->pTerm;
                PostRitSound(
                    pTerm,
                    RITSOUND_UPSIREN);
            }
            PostAccessNotification(ACCESS_MOUSEKEYS);

            return FALSE;
        }
    } else {
        //
        // Is this a MouseKey key?
        //
        //
        FlaggedVk = Vk | (pKeyEvent->usFlaggedVk & KBDEXT);
        for (i = 0; i < cMouseVKeys; i++) {
#ifdef FE_SB // MouseKeys()
            if (FlaggedVk == gpusMouseVKey[i]) {
#else  // FE_SB
            if (FlaggedVk == ausMouseVKey[i]) {
#endif // FE_SB
                break;
            }
        }

        if (i == cMouseVKeys) {
            return TRUE;          // not a mousekey
        }
        //
        // Check to see if we should pass on key events until Num Lock is
        // entered.
        //

        if (!gbMKMouseMode) {
#ifdef FE_SB // MouseKeys()
            if (Vk != gNumLockVk) {
#else  // FE_SB
            if (Vk != VK_NUMLOCK) {
#endif // FE_SB
                return TRUE;
            }
        }

        //
        // Check for Ctrl-Alt-Numpad Del.  Pass key event on if sequence
        // detected.
        //
        if (Vk == VK_DELETE && CurrentModState & LRALT && CurrentModState & LRCONTROL) {
            return TRUE;
        }
        if (fBreak) {
            //
            // If this is a break of the key that we're accelerating then
            // kill the timer.
            //
            if (gMKPreviousVk == Vk) {
                if (gtmridMKMoveCursor != 0) {
                    KILLRITTIMER(NULL, gtmridMKMoveCursor);
                    gtmridMKMoveCursor = 0;
                }
                CLEAR_ACCF(ACCF_MKREPEATVK);
                gMKPreviousVk = 0;
            }
            //
            // Pass break of Numlock along.  Other mousekeys stop here.
            //
#ifdef FE_SB // MouseKeys()
            if (Vk == gNumLockVk) {
#else  // FE_SB
            if (Vk == VK_NUMLOCK) {
#endif // FE_SB
                return TRUE;
            } else {
                return FALSE;
            }
        } else {
            SET_OR_CLEAR_ACCF(ACCF_MKREPEATVK,
                              (gMKPreviousVk == Vk));
            //
            // If this is not a typematic repeat, kill the mouse acceleration
            // timer.
            //
            if ((!TEST_ACCF(ACCF_MKREPEATVK)) && (gtmridMKMoveCursor)) {
                KILLRITTIMER(NULL, gtmridMKMoveCursor);
                gtmridMKMoveCursor = 0;
            }
            gMKPreviousVk = Vk;
        }
        return aMouseKeyEvent[i](ausMouseKeyData[i]);
    }

    return TRUE;
}

/***************************************************************************\
* TurnOffMouseKeys
*
* Return value:
*    None.
*
* History:
*   11 Feb 93 GregoryW   Created.
\***************************************************************************/
VOID TurnOffMouseKeys(VOID)
{
    CLEAR_ACCESSFLAG(MouseKeys, MKF_MOUSEKEYSON);
//    gMKPassThrough = 0;
    CLEAR_ACCF(ACCF_MKREPEATVK);
    MKHideMouseCursor();
    if (TEST_ACCESSFLAG(MouseKeys, MKF_HOTKEYSOUND)) {
        PostRitSound(
            grpdeskRitInput->rpwinstaParent->pTerm,
            RITSOUND_DOWNSIREN);
    }
    PostAccessibility( ACCESS_MOUSEKEYS );
}


/*
 * Let's assert at the compile time if those values are
 * defined unexpectedly.
 */
#if (MAXSPEED_MIN >= MAXSPEED_MAX) || (MAXSPEED_MIN <= 0) || (TIMETOMAXSPEED_MIN >= TIMETOMAXSPEED_MAX) || (TIMETOMAXSPEED_MIN <= 0)
#error The mousekey min/max values are not as expected.
#endif

/***************************************************************************\
* CalculateMouseTable
*
* Set mouse table based on time to max speed and max speed.  This routine
* is called during user logon (after the registry entries for the access
* features are read).
*
* Return value:
*    None.
*
* History:
*    Taken from access utility.
*
****************************************************************************/

VOID CalculateMouseTable(VOID)
{
    long    Total_Distance;         /* in 1000th of pixel */

    long    Accel_Per_Tick;         /* in 1000th of pixel/tick */
    long    Current_Speed;          /* in 1000th of pixel/tick */
    long    Max_Speed;              /* in 1000th of pixel/tick */
    long    Real_Total_Distance;    /* in pixels */
    long    Real_Delta_Distance;    /* in pixels */
    int     i;
    int     Num_Constant_Table,Num_Accel_Table;

    UserAssert(gMouseKeys.iMaxSpeed >= MAXSPEED_MIN && gMouseKeys.iMaxSpeed <= MAXSPEED_MAX);
    UserAssert(gMouseKeys.iTimeToMaxSpeed >= TIMETOMAXSPEED_MIN && gMouseKeys.iTimeToMaxSpeed <= TIMETOMAXSPEED_MAX);
    UserAssert(gMouseKeys.iTimeToMaxSpeed != 0);

    Max_Speed = gMouseKeys.iMaxSpeed;
    Max_Speed *= 1000 / MOUSETICKS;

    Accel_Per_Tick = Max_Speed * 1000 / (gMouseKeys.iTimeToMaxSpeed * MOUSETICKS);
    Current_Speed = 0;
    Total_Distance = 0;
    Real_Total_Distance = 0;
    Num_Constant_Table = 0;
    Num_Accel_Table = 0;

    for(i=0; i<= 255; i++) {
        Current_Speed = Current_Speed + Accel_Per_Tick;
        if (Current_Speed > Max_Speed) {
            Current_Speed = Max_Speed;
        }
        Total_Distance += Current_Speed;

        //
        // Calculate how many pixels to move on this tick
        //
        Real_Delta_Distance = ((Total_Distance - (Real_Total_Distance * 1000)) + 500) / 1000 ;
        //
        // Calculate total distance moved up to this point
        //
        Real_Total_Distance = Real_Total_Distance + Real_Delta_Distance;

        if ((Current_Speed < Max_Speed) && (Num_Accel_Table < 128)) {
            gMouseCursor.bAccelTable[Num_Accel_Table++] = (BYTE)Real_Delta_Distance;
        }

        if ((Current_Speed == Max_Speed) && (Num_Constant_Table < 128)) {
            gMouseCursor.bConstantTable[Num_Constant_Table++] = (BYTE)Real_Delta_Distance;
        }

    }
    gMouseCursor.bAccelTableLen = (BYTE)Num_Accel_Table;
    gMouseCursor.bConstantTableLen = (BYTE)Num_Constant_Table;
}


/***************************************************************************\
* xxxToggleKeysTimer
*
* Enable ToggleKeys if it is currently disabled.  Disable ToggleKeys if it
* is currently enabled.
*
* This routine is called only when the NumLock key is held down for 5 seconds.
*
* Return value:
*    0
*
* History:
*   11 Feb 93 GregoryW   Created.
\***************************************************************************/
VOID xxxToggleKeysTimer(
    PWND pwnd,
    UINT message,
    UINT_PTR nID,
    LPARAM lParam)
{
    KE ToggleKeyEvent;
    PTERMINAL pTerm = grpdeskRitInput->rpwinstaParent->pTerm;

    UNREFERENCED_PARAMETER(pwnd);
    UNREFERENCED_PARAMETER(message);
    UNREFERENCED_PARAMETER(nID);
    UNREFERENCED_PARAMETER(lParam);

    CheckCritIn();
    //
    // Toggle ToggleKeys and provide audible feedback if appropriate.
    //
    if (TEST_ACCESSFLAG(ToggleKeys, TKF_TOGGLEKEYSON)) {
        CLEAR_ACCESSFLAG(ToggleKeys, TKF_TOGGLEKEYSON);
        if (TEST_ACCESSFLAG(ToggleKeys, TKF_HOTKEYSOUND)) {
            PostRitSound(
                    pTerm,
                    RITSOUND_DOWNSIREN);
        }
    } else {
        if (TEST_ACCESSFLAG(ToggleKeys, TKF_HOTKEYSOUND)) {
            PostRitSound(
                    pTerm,
                    RITSOUND_UPSIREN);
        }

        PostAccessNotification(ACCESS_TOGGLEKEYS);
    }
    //
    // Send a fake break/make combination so state of numlock key remains
    // the same as it was before user pressed it to activate/deactivate
    // ToggleKeys.
    //
    ToggleKeyEvent.bScanCode = gTKScanCode;
#ifdef FE_SB // ToggleKeysTimer()
    ToggleKeyEvent.usFlaggedVk = gNumLockVk | KBDBREAK;
#else
    ToggleKeyEvent.usFlaggedVk = VK_NUMLOCK | KBDBREAK;
#endif // FE_SB
    if (AccessProceduresStream(&ToggleKeyEvent, gTKExtraInformation, gTKNextProcIndex)) {
        xxxProcessKeyEvent(&ToggleKeyEvent, gTKExtraInformation, FALSE);
    }
#ifdef FE_SB // ToggleKeysTimer()
    ToggleKeyEvent.usFlaggedVk = gNumLockVk;
#else
    ToggleKeyEvent.usFlaggedVk = VK_NUMLOCK;
#endif // FE_SB
    if (AccessProceduresStream(&ToggleKeyEvent, gTKExtraInformation, gTKNextProcIndex)) {
        xxxProcessKeyEvent(&ToggleKeyEvent, gTKExtraInformation, FALSE);
    }
}


/***************************************************************************\
* ToggleKeys
*
* This is the strategy routine that gets called as part of the input stream
* processing.  Keys of interest are Num Lock, Scroll Lock and Caps Lock.
*
* Return value:
*    TRUE - key event should be passed on to the next access routine.
*    FALSE - key event was processed and should not be passed on.
*
* History:
\***************************************************************************/
BOOL ToggleKeys(PKE pKeyEvent, ULONG ExtraInformation, int NextProcIndex)
{
    int fBreak;
    BYTE Vk;

    CheckCritIn();
    Vk = (BYTE)pKeyEvent->usFlaggedVk;
    fBreak = pKeyEvent->usFlaggedVk & KBDBREAK;

    //
    // Check for Numlock key.  On the first make set the ToggleKeys timer.
    // The timer is killed on the break of the Numlock key.
    //
    switch (Vk) {
    case VK_NUMLOCK:
#ifdef FE_SB // ToggleKeys()
NumLockProc:
#endif // FE_SB
        /*
         * Don't handle NUMLOCK toggles if the user is doing MouseKey
         * toggling.
         */
        if ((gLockBits | gLatchBits | gPhysModifierState) == MOUSEKEYMODBITS &&
                TEST_ACCESSFLAG(MouseKeys, MKF_HOTKEYACTIVE)) {
            break;
        }
        if (fBreak)
        {
            //
            // Only reset gptmrToggleKeys on the break of NumLock. This
            // prevents cycling the toggle keys state by continually
            // holding down the NumLock key.
            //
            KILLRITTIMER(NULL, gtmridToggleKeys);
            gtmridToggleKeys = 0;
            gTKExtraInformation = 0;
            gTKScanCode = 0;
        }
        else
        {
            if (gtmridToggleKeys == 0 &&
                TEST_ACCESSFLAG(ToggleKeys, TKF_HOTKEYACTIVE))
            {

                //
                // Remember key information to be used by timer routine.
                //
                gTKExtraInformation = ExtraInformation;
                gTKScanCode = pKeyEvent->bScanCode;
                gTKNextProcIndex = NextProcIndex;
                gtmridToggleKeys = InternalSetTimer(NULL,
                                                    0,
                                                    TOGGLEKEYTOGGLETIME,
                                                    xxxToggleKeysTimer,
                                                    TMRF_RIT | TMRF_ONESHOT);
            }
        }

        //
        // If MouseKeys is on, audible feedback has already occurred for this
        // keystroke.  Skip the rest of the processing.
        //
        if (TEST_ACCESSFLAG(MouseKeys, MKF_MOUSEKEYSON)) {
            break;
        }
        // fall through

    case VK_SCROLL:
    case VK_CAPITAL:
#ifdef FE_SB // ToggleKeys()
CapitalProc:
#endif // FE_SB
        if (TEST_ACCESSFLAG(ToggleKeys, TKF_TOGGLEKEYSON) && !fBreak) {
            if (!TestAsyncKeyStateDown(Vk)) {
                PTERMINAL pTerm = grpdeskRitInput->rpwinstaParent->pTerm;
                if (!TestAsyncKeyStateToggle(Vk)) {
                    PostRitSound(
                        pTerm,
                        RITSOUND_HIGHBEEP);
                } else {
                    PostRitSound(
                        pTerm,
                        RITSOUND_LOWBEEP);
                }
            }
        }
        break;

    default:
#ifdef FE_SB // ToggleKeys()
        if (Vk == gNumLockVk) goto NumLockProc;
        if (Vk == gOemScrollVk) goto CapitalProc;
#endif // FE_SB
        if (gtmridToggleKeys != 0) {
            KILLRITTIMER(NULL, gtmridToggleKeys);
        }
    }

    return TRUE;
}


/***************************************************************************\
* AccessTimeOutTimer
*
* This routine is called if no keyboard activity takes place for the
* user configured amount of time.  All access related functions are
* disabled.
*
* This routine is called with the critical section already locked.
*
* Return value:
*    0
*
* History:
\***************************************************************************/
VOID xxxAccessTimeOutTimer(
    PWND pwnd,
    UINT message,
    UINT_PTR nID,
    LPARAM lParam)
{
    UNREFERENCED_PARAMETER(pwnd);
    UNREFERENCED_PARAMETER(message);
    UNREFERENCED_PARAMETER(nID);
    UNREFERENCED_PARAMETER(lParam);

    CheckCritIn();

    /*
     * The timeout timer will remain on (if so configured) as long as
     * TEST_ACCF(ACCF_ACCESSENABLED) is TRUE.  This means we might get timeouts when
     * only hot keys are enabled, but no features are actually on.  Don't
     * provide any audible feedback in this case.
     */
    if (    TEST_ACCESSFLAG(FilterKeys, FKF_FILTERKEYSON)   ||
            TEST_ACCESSFLAG(StickyKeys, SKF_STICKYKEYSON)   ||
            TEST_ACCESSFLAG(MouseKeys, MKF_MOUSEKEYSON)     ||
            TEST_ACCESSFLAG(ToggleKeys, TKF_TOGGLEKEYSON)   ||
            TEST_ACCESSFLAG(SoundSentry, SSF_SOUNDSENTRYON) ||
            TEST_ACCESSFLAG(HighContrast, HCF_HIGHCONTRASTON) ||
            TEST_ACCF(ACCF_SHOWSOUNDSON)) {

        PTERMINAL pTerm = grpdeskRitInput->rpwinstaParent->pTerm;
        CLEAR_ACCESSFLAG(FilterKeys, FKF_FILTERKEYSON);
        xxxTurnOffStickyKeys();
        CLEAR_ACCESSFLAG(MouseKeys, MKF_MOUSEKEYSON);
        CLEAR_ACCESSFLAG(ToggleKeys, TKF_TOGGLEKEYSON);
        CLEAR_ACCESSFLAG(SoundSentry, SSF_SOUNDSENTRYON);
        CLEAR_ACCF(ACCF_SHOWSOUNDSON);
        CLEAR_ACCESSFLAG(HighContrast, HCF_HIGHCONTRASTON);

        if (gspwndLogonNotify != NULL) {

        _PostMessage(gspwndLogonNotify, WM_LOGONNOTIFY,
                     LOGON_ACCESSNOTIFY, ACCESS_HIGHCONTRASTOFF);
        }

        if (TEST_ACCESSFLAG(AccessTimeOut, ATF_ONOFFFEEDBACK)) {
            PostRitSound(
                    pTerm,
                    RITSOUND_DOWNSIREN);
        }
        PostAccessibility( ACCESS_MOUSEKEYS );

        PostAccessibility( ACCESS_FILTERKEYS );

        PostAccessibility( ACCESS_STICKYKEYS );

    }
    SetAccessEnabledFlag();
}

/***************************************************************************\
* AccessTimeOutReset
*
* This routine resets the timeout timer.
*
* Return value:
*    0
*
* History:
\***************************************************************************/
VOID AccessTimeOutReset(
    VOID)
{

    if (gtmridAccessTimeOut != 0) {
        KILLRITTIMER(NULL, gtmridAccessTimeOut);
    }

    if (TEST_ACCESSFLAG(AccessTimeOut, ATF_TIMEOUTON)) {
        gtmridAccessTimeOut = InternalSetTimer(NULL,
                                               0,
                                               (UINT)gAccessTimeOut.iTimeOutMSec,
                                               xxxAccessTimeOutTimer,
                                               TMRF_RIT | TMRF_ONESHOT);
    }
}

/***************************************************************************\
* xxxUpdatePerUserAccessPackSettings
*
* Sets the initial access pack features according to the user's profile.
*
* 02-14-93 GregoryW        Created.
\***************************************************************************/
VOID xxxUpdatePerUserAccessPackSettings(
    PUNICODE_STRING pProfileUserName)
{
    LUID luidCaller;
    NTSTATUS Status;
    BOOL fSystem;
    BOOL fRegFilterKeysOn;
    BOOL fRegStickyKeysOn;
    BOOL fRegMouseKeysOn;
    BOOL fRegToggleKeysOn;
    BOOL fRegTimeOutOn;
    BOOL fRegKeyboardPref;
    BOOL fRegScreenReader;
    BOOL fRegHighContrastOn;
    DWORD dwDefFlags;
    WCHAR wcHighContrastScheme[MAX_SCHEME_NAME_SIZE];

    Status = GetProcessLuid(NULL, &luidCaller);
    //
    // If we're called in the system context no one is logged on.
    // We want to read the current .DEFAULT settings for the access
    // features.  Later when we're called in the user context (e.g.,
    // someone has successfully logged on) we check to see if the
    // current access state is the same as the default setting.  If
    // not, the user has enabled/disabled one or more access features
    // from the keyboard.  These changes will be propagated across
    // the logon into the user's intial state (overriding the settings
    // in the user's profile).
    //
    if (NT_SUCCESS(Status) && RtlEqualLuid(&luidCaller, &luidSystem)) {
        fSystem = TRUE;
    } else {
        fSystem = FALSE;
    }

    FastGetProfileIntW(pProfileUserName,
                       PMAP_KEYBOARDRESPONSE,
                       TEXT("Flags"),
                       0,
                       &dwDefFlags,
                       0);

    fRegFilterKeysOn = (dwDefFlags & FKF_FILTERKEYSON) != 0;

    FastGetProfileIntW(pProfileUserName,
                       PMAP_STICKYKEYS,
                       TEXT("Flags"),
                       0,
                       &dwDefFlags,
                       0);
    fRegStickyKeysOn = (dwDefFlags & SKF_STICKYKEYSON) != 0;

    FastGetProfileIntW(pProfileUserName,
                       PMAP_MOUSEKEYS,
                       TEXT("Flags"),
                       0,
                       &dwDefFlags,
                       0);
    fRegMouseKeysOn = (dwDefFlags & MKF_MOUSEKEYSON) != 0;

    FastGetProfileIntW(pProfileUserName,
                       PMAP_TOGGLEKEYS,
                       TEXT("Flags"),
                       0,
                       &dwDefFlags,
                       0);
    fRegToggleKeysOn = (dwDefFlags & TKF_TOGGLEKEYSON) != 0;

    FastGetProfileIntW(pProfileUserName,
                       PMAP_KEYBOARDPREF,
                       TEXT("On"),
                       0,
                       &dwDefFlags,
                       0);
    fRegKeyboardPref = !!dwDefFlags;

    FastGetProfileIntW(pProfileUserName,
                       PMAP_SCREENREADER,
                       TEXT("On"),
                       0,
                       &dwDefFlags,
                       0);
    fRegScreenReader = !!dwDefFlags;

    FastGetProfileIntW(pProfileUserName,
                       PMAP_TIMEOUT,
                       TEXT("Flags"),
                       0,
                       &dwDefFlags,
                       0);
    fRegTimeOutOn = (dwDefFlags & ATF_TIMEOUTON) != 0;

    FastGetProfileIntW(pProfileUserName,
                       PMAP_HIGHCONTRAST,
                       TEXT("Flags"),
                       0,
                       &dwDefFlags,
                       0);
    fRegHighContrastOn = (dwDefFlags & HCF_HIGHCONTRASTON) != 0;

    if (fSystem) {
        //
        // We're in system mode (e.g., no one is logged in).  Remember
        // the .DEFAULT state for comparison during the next user logon
        // and set the current state to the .DEFAULT state.
        //
        if (fRegFilterKeysOn) {
            SET_ACCF(ACCF_DEFAULTFILTERKEYSON);
            SET_ACCESSFLAG(FilterKeys, FKF_FILTERKEYSON);
        } else {
            CLEAR_ACCF(ACCF_DEFAULTFILTERKEYSON);
            CLEAR_ACCESSFLAG(FilterKeys, FKF_FILTERKEYSON);
        }

        //
        // If StickyKeys is currently on and we're about to turn it
        // off we need to make sure the latch keys and lock keys are
        // released.
        //
        if (TEST_ACCESSFLAG(StickyKeys, SKF_STICKYKEYSON) && (fRegFilterKeysOn == 0)) {
                xxxTurnOffStickyKeys();
        }

        if (fRegStickyKeysOn) {
            SET_ACCF(ACCF_DEFAULTSTICKYKEYSON);
            SET_ACCESSFLAG(StickyKeys, SKF_STICKYKEYSON);
        } else {
            CLEAR_ACCF(ACCF_DEFAULTSTICKYKEYSON);
            CLEAR_ACCESSFLAG(StickyKeys, SKF_STICKYKEYSON);
        }

        if (fRegMouseKeysOn) {
            SET_ACCF(ACCF_DEFAULTMOUSEKEYSON);
            SET_ACCESSFLAG(MouseKeys, MKF_MOUSEKEYSON);
        } else {
            CLEAR_ACCF(ACCF_DEFAULTMOUSEKEYSON);
            CLEAR_ACCESSFLAG(MouseKeys, MKF_MOUSEKEYSON);
        }

        if (fRegToggleKeysOn) {
            SET_ACCF(ACCF_DEFAULTTOGGLEKEYSON);
            SET_ACCESSFLAG(ToggleKeys, TKF_TOGGLEKEYSON);
        } else {
            CLEAR_ACCF(ACCF_DEFAULTTOGGLEKEYSON);
            CLEAR_ACCESSFLAG(ToggleKeys, TKF_TOGGLEKEYSON);
        }

        if (fRegTimeOutOn) {
            SET_ACCF(ACCF_DEFAULTTIMEOUTON);
            SET_ACCESSFLAG(AccessTimeOut, ATF_TIMEOUTON);
        } else {
            CLEAR_ACCF(ACCF_DEFAULTTIMEOUTON);
            CLEAR_ACCESSFLAG(AccessTimeOut, ATF_TIMEOUTON);
        }

        if (fRegKeyboardPref) {
            SET_ACCF(ACCF_DEFAULTKEYBOARDPREF);
            SET_ACCF(ACCF_KEYBOARDPREF);
            SET_SRVIF(SRVIF_KEYBOARDPREF);
        } else {
            CLEAR_ACCF(ACCF_DEFAULTKEYBOARDPREF);
            CLEAR_ACCF(ACCF_KEYBOARDPREF);
            CLEAR_SRVIF(SRVIF_KEYBOARDPREF);
        }

        if (fRegScreenReader) {
            SET_ACCF(ACCF_DEFAULTSCREENREADER);
            SET_ACCF(ACCF_SCREENREADER);
        } else {
            CLEAR_ACCF(ACCF_DEFAULTSCREENREADER);
            CLEAR_ACCF(ACCF_SCREENREADER);
        }

        if (fRegHighContrastOn) {
            SET_ACCF(ACCF_DEFAULTHIGHCONTRASTON);
            SET_ACCESSFLAG(HighContrast, HCF_HIGHCONTRASTON);
        } else {
            CLEAR_ACCF(ACCF_DEFAULTHIGHCONTRASTON);
            CLEAR_ACCESSFLAG(HighContrast, HCF_HIGHCONTRASTON);
        }
    } else {
        //
        // A user has successfully logged on.  If the current state is
        // different from the default state stored earlier then we know
        // the user has modified the state via the keyboard (at the logon
        // dialog).  This state will override whatever on/off state the
        // user has set in their profile.  If the current state is the
        // same as the default state then the on/off setting from the
        // user profile is used.
        //

        if (    TEST_BOOL_ACCESSFLAG(FilterKeys, FKF_FILTERKEYSON) ==
                TEST_BOOL_ACCF(ACCF_DEFAULTFILTERKEYSON)) {
            //
            // Current state and default state are the same.  Use the
            // user's profile setting.
            //

            SET_OR_CLEAR_ACCESSFLAG(FilterKeys, FKF_FILTERKEYSON, fRegFilterKeysOn);
        }

        if (    TEST_BOOL_ACCESSFLAG(StickyKeys, SKF_STICKYKEYSON) ==
                TEST_BOOL_ACCF(ACCF_DEFAULTSTICKYKEYSON)) {
            //
            // If StickyKeys is currently on and we're about to turn it
            // off we need to make sure the latch keys and lock keys are
            // released.
            //
            if (    TEST_ACCESSFLAG(StickyKeys, SKF_STICKYKEYSON) &&
                    (fRegStickyKeysOn == 0)) {

                xxxTurnOffStickyKeys();
            }

            SET_OR_CLEAR_ACCESSFLAG(StickyKeys, SKF_STICKYKEYSON, fRegStickyKeysOn);
        }

        if (    TEST_BOOL_ACCESSFLAG(MouseKeys, MKF_MOUSEKEYSON) ==
                TEST_BOOL_ACCF(ACCF_DEFAULTMOUSEKEYSON)) {
            //
            // Current state and default state are the same.  Use the user's
            // profile setting.
            //
            SET_OR_CLEAR_ACCESSFLAG(MouseKeys, MKF_MOUSEKEYSON, fRegMouseKeysOn);
        }

        if (    TEST_BOOL_ACCESSFLAG(ToggleKeys, TKF_TOGGLEKEYSON) ==
                TEST_BOOL_ACCF(ACCF_DEFAULTTOGGLEKEYSON)) {
            //
            // Current state and default state are the same.  Use the user's
            // profile setting.
            //
            SET_OR_CLEAR_ACCESSFLAG(ToggleKeys, TKF_TOGGLEKEYSON, fRegToggleKeysOn);
        }

        if (    TEST_BOOL_ACCESSFLAG(AccessTimeOut, ATF_TIMEOUTON) ==
                TEST_BOOL_ACCF(ACCF_DEFAULTTIMEOUTON)) {
            //
            // Current state and default state are the same.  Use the user's
            // profile setting.
            //
            SET_OR_CLEAR_ACCESSFLAG(AccessTimeOut, ATF_TIMEOUTON, fRegTimeOutOn);
        }

        if (    TEST_BOOL_ACCF(ACCF_KEYBOARDPREF) ==
                TEST_BOOL_ACCF(ACCF_DEFAULTKEYBOARDPREF)) {
            //
            // Current state and default state are the same.  Use the user's
            // profile setting.
            //
            SET_OR_CLEAR_ACCF(ACCF_KEYBOARDPREF, fRegKeyboardPref);
        }

        if (    TEST_BOOL_ACCF(ACCF_SCREENREADER) ==
                TEST_BOOL_ACCF(ACCF_DEFAULTSCREENREADER)) {
            //
            // Current state and default state are the same.  Use the user's
            // profile setting.
            //
            SET_OR_CLEAR_ACCF(ACCF_SCREENREADER, fRegScreenReader);
        }

        if (    TEST_BOOL_ACCESSFLAG(HighContrast, HCF_HIGHCONTRASTON) ==
                TEST_BOOL_ACCF(ACCF_DEFAULTHIGHCONTRASTON)) {
            //
            // Current state and default state are the same.  Use the user's
            // profile setting.
            //
            SET_OR_CLEAR_ACCESSFLAG(HighContrast, HCF_HIGHCONTRASTON, fRegHighContrastOn);
        }
    }

    //
    // Get the default FilterKeys state.
    //
    // -------- flag --------------- value --------- default ------
    // #define FKF_FILTERKEYSON    0x00000001           0
    // #define FKF_AVAILABLE       0x00000002           2
    // #define FKF_HOTKEYACTIVE    0x00000004           0
    // #define FKF_CONFIRMHOTKEY   0x00000008           0
    // #define FKF_HOTKEYSOUND     0x00000010          10
    // #define FKF_INDICATOR       0x00000020           0
    // #define FKF_CLICKON         0x00000040          40
    // ----------------------------------------- total = 0x52 = 82
    //

    FastGetProfileIntW(pProfileUserName,
                       PMAP_KEYBOARDRESPONSE,
                       TEXT("Flags"),
                       82,
                       &dwDefFlags,
                       0);

    SET_OR_CLEAR_FLAG(
            dwDefFlags,
            FKF_FILTERKEYSON,
            TEST_ACCESSFLAG(FilterKeys, FKF_FILTERKEYSON));

    gFilterKeys.dwFlags = dwDefFlags;
    FastGetProfileIntW(pProfileUserName,
                       PMAP_KEYBOARDRESPONSE,
                       TEXT("DelayBeforeAcceptance"),
                       1000,
                       &gFilterKeys.iWaitMSec,
                       0);

    FastGetProfileIntW(pProfileUserName,
                       PMAP_KEYBOARDRESPONSE,
                       TEXT("AutoRepeatRate"),
                       500,
                       &gFilterKeys.iRepeatMSec,
                       0);

    FastGetProfileIntW(pProfileUserName,
                       PMAP_KEYBOARDRESPONSE,
                       TEXT("AutoRepeatDelay"),
                       1000,
                       &gFilterKeys.iDelayMSec,
                       0);

    FastGetProfileIntW(pProfileUserName,
                       PMAP_KEYBOARDRESPONSE,
                       TEXT("BounceTime"),
                       0,
                       &gFilterKeys.iBounceMSec,
                       0);

    //
    // Fill in the SoundSentry state.  This release of the
    // accessibility features only supports iWindowsEffect.
    //
    // -------- flag --------------- value --------- default ------
    // #define SSF_SOUNDSENTRYON   0x00000001           0
    // #define SSF_AVAILABLE       0x00000002           1
    // #define SSF_INDICATOR       0x00000004           0
    // ----------------------------------------- total = 0x2 = 2
    //
    FastGetProfileIntW(pProfileUserName,
                       PMAP_SOUNDSENTRY,
                       TEXT("Flags"),
                       2,
                       &gSoundSentry.dwFlags,
                       0);

    FastGetProfileIntW(pProfileUserName,
                       PMAP_SOUNDSENTRY,
                       TEXT("FSTextEffect"),
                       0,
                       &gSoundSentry.iFSTextEffect,
                       0);

    FastGetProfileIntW(pProfileUserName,
                       PMAP_SOUNDSENTRY,
                       TEXT("WindowsEffect"),
                       0,
                       &gSoundSentry.iWindowsEffect,
                       0);

    /*
     * Set ShowSounds flag.
     */
    FastGetProfileIntW(pProfileUserName,
                       PMAP_SHOWSOUNDS,
                       TEXT("On"),
                       0,
                       &dwDefFlags,
                       0);
    SET_OR_CLEAR_ACCF(ACCF_SHOWSOUNDSON, dwDefFlags);
    /*
    * Bug 17210.  Update the System Metrics Info.
    */
    SYSMET(SHOWSOUNDS) = TEST_BOOL_ACCF(ACCF_SHOWSOUNDSON);

    //
    // Get the default StickyKeys state.
    //
    // -------- flag --------------- value --------- default ------
    // #define SKF_STICKYKEYSON    0x00000001          0
    // #define SKF_AVAILABLE       0x00000002          2
    // #define SKF_HOTKEYACTIVE    0x00000004          0
    // #define SKF_CONFIRMHOTKEY   0x00000008          0
    // #define SKF_HOTKEYSOUND     0x00000010         10
    // #define SKF_INDICATOR       0x00000020          0
    // #define SKF_AUDIBLEFEEDBACK 0x00000040         40
    // #define SKF_TRISTATE        0x00000080         80
    // #define SKF_TWOKEYSOFF      0x00000100        100
    // ----------------------------------------- total = 0x1d2 = 466
    //
    FastGetProfileIntW(pProfileUserName,
                       PMAP_STICKYKEYS,
                       TEXT("Flags"),
                       466,
                       &dwDefFlags,
                       0);

    SET_OR_CLEAR_FLAG(
            dwDefFlags,
            SKF_STICKYKEYSON,
            TEST_ACCESSFLAG(StickyKeys, SKF_STICKYKEYSON));

    gStickyKeys.dwFlags = dwDefFlags;

    //
    // Get the default MouseKeys state.
    //
    // -------- flag --------------- value --------- default ------
    // #define MKF_MOUSEKEYSON     0x00000001           0
    // #define MKF_AVAILABLE       0x00000002           2
    // #define MKF_HOTKEYACTIVE    0x00000004           0
    // #define MKF_CONFIRMHOTKEY   0x00000008           0
    // #define MKF_HOTKEYSOUND     0x00000010          10
    // #define MKF_INDICATOR       0x00000020           0
    // #define MKF_MODIFIERS       0x00000040           0
    // #define MKF_REPLACENUMBERS  0x00000080           0
    // ----------------------------------------- total = 0x12 = 18
    //
    FastGetProfileIntW(pProfileUserName,
                       PMAP_MOUSEKEYS,
                       TEXT("Flags"),
                       18,
                       &dwDefFlags,
                       0);

    SET_OR_CLEAR_FLAG(
            dwDefFlags,
            MKF_MOUSEKEYSON,
            TEST_ACCESSFLAG(MouseKeys, MKF_MOUSEKEYSON));

    gMouseKeys.dwFlags = dwDefFlags;
    FastGetProfileIntW(pProfileUserName,
                       PMAP_MOUSEKEYS,
                       TEXT("MaximumSpeed"),
                       MAXSPEED_DEF,
                       &gMouseKeys.iMaxSpeed,
                       0);

    FastGetProfileIntW(pProfileUserName,
                       PMAP_MOUSEKEYS,
                       TEXT("TimeToMaximumSpeed"),
                       TIMETOMAXSPEED_DEF,
                       &gMouseKeys.iTimeToMaxSpeed,
                       0);
 
    /*
     * Avoid unexpected values, like when the migration from previous OS has set bogus values
     * or when the registry is simply broken...
     */
    if (gMouseKeys.iMaxSpeed < MAXSPEED_MIN || gMouseKeys.iMaxSpeed > MAXSPEED_MAX) {
        gMouseKeys.iMaxSpeed = MAXSPEED_DEF;
    }
    if (gMouseKeys.iTimeToMaxSpeed < TIMETOMAXSPEED_MIN || gMouseKeys.iTimeToMaxSpeed > TIMETOMAXSPEED_MAX) {
        gMouseKeys.iTimeToMaxSpeed = TIMETOMAXSPEED_DEF;
    }

    CalculateMouseTable();

    gbMKMouseMode =
#ifdef FE_SB
            (TestAsyncKeyStateToggle(gNumLockVk) != 0) ^
#else  // FE_SB
            (TestAsyncKeyStateToggle(VK_NUMLOCK) != 0) ^
#endif // FE_SB
            (TEST_ACCESSFLAG(MouseKeys, MKF_REPLACENUMBERS) != 0);

    //
    // If the system does not have a hardware mouse:
    //    If MouseKeys is enabled show the mouse cursor,
    //    o.w. hide the mouse cursor.
    //
    if (TEST_ACCESSFLAG(MouseKeys, MKF_MOUSEKEYSON)) {
        MKShowMouseCursor();
    } else {
        MKHideMouseCursor();
    }

    //
    // Get the default ToggleKeys state.
    //
    // -------- flag --------------- value --------- default ------
    // #define TKF_TOGGLEKEYSON    0x00000001           0
    // #define TKF_AVAILABLE       0x00000002           2
    // #define TKF_HOTKEYACTIVE    0x00000004           0
    // #define TKF_CONFIRMHOTKEY   0x00000008           0
    // #define TKF_HOTKEYSOUND     0x00000010          10
    // #define TKF_INDICATOR       0x00000020           0
    // ----------------------------------------- total = 0x12 = 18
    //
    FastGetProfileIntW(pProfileUserName,
                       PMAP_TOGGLEKEYS,
                       TEXT("Flags"),
                       18,
                       &dwDefFlags,
                       0);

    SET_OR_CLEAR_FLAG(
            dwDefFlags,
            TKF_TOGGLEKEYSON,
            TEST_ACCESSFLAG(ToggleKeys, TKF_TOGGLEKEYSON));

    gToggleKeys.dwFlags = dwDefFlags;

    //
    // Get the default Timeout state.
    //
    // -------- flag --------------- value --------- default ------
    // #define ATF_TIMEOUTON       0x00000001           0
    // #define ATF_ONOFFFEEDBACK   0x00000002           2
    // ----------------------------------------- total = 0x2 = 2
    //
    FastGetProfileIntW(pProfileUserName,
                       PMAP_TIMEOUT,
                       TEXT("Flags"),
                       2,
                       &dwDefFlags,
                       0);

    SET_OR_CLEAR_FLAG(
            dwDefFlags,
            ATF_TIMEOUTON,
            TEST_ACCESSFLAG(AccessTimeOut, ATF_TIMEOUTON));

    gAccessTimeOut.dwFlags = dwDefFlags;

#ifdef FE_SB //
    if (gpKbdNlsTbl) {
        //
        // Is there any alternative MouseVKey table in KBDNLSTABLE ?
        //
        if ((gpKbdNlsTbl->NumOfMouseVKey == cMouseVKeys) &&
            (gpKbdNlsTbl->pusMouseVKey   != NULL)) {
            //
            // Overwite the pointer.
            //
            gpusMouseVKey = gpKbdNlsTbl->pusMouseVKey;
        }

        //
        // Is there any remapping flag for VK_NUMLOCK/VK_SCROLL ?
        //
        if (gpKbdNlsTbl->LayoutInformation & NLSKBD_INFO_ACCESSIBILITY_KEYMAP) {
            //
            // Overwrite default.
            //
            gNumLockVk = VK_HOME;
            gOemScrollVk = VK_KANA;
        }
    }
#endif // FE_SB

    FastGetProfileIntW(pProfileUserName,
                       PMAP_TIMEOUT,
                       TEXT("TimeToWait"),
                       300000,
                       &gAccessTimeOut.iTimeOutMSec,
                       0);  // default is 5 minutes

   /*
    * Get High Contrast state
    */

    FastGetProfileIntW(pProfileUserName,
                       PMAP_HIGHCONTRAST,
                       TEXT("Flags"),
                       HCF_AVAILABLE | HCF_HOTKEYSOUND | HCF_HOTKEYAVAILABLE,
                       &dwDefFlags,
                       0);

    SET_OR_CLEAR_FLAG(
            dwDefFlags,
            HCF_HIGHCONTRASTON,
            TEST_ACCESSFLAG(HighContrast, HCF_HIGHCONTRASTON));

    gHighContrast.dwFlags = dwDefFlags;

    /*
     * Get scheme -- set up buffer
     */

    if (FastGetProfileStringW(pProfileUserName,
            PMAP_HIGHCONTRAST,
            TEXT("High Contrast Scheme"),
            NULL,
            wcHighContrastScheme,
            MAX_SCHEME_NAME_SIZE,
            0)) {

        /*
         * copy data
         */

        wcscpy(gHighContrastDefaultScheme, wcHighContrastScheme);
    }


    AccessTimeOutReset();
    SetAccessEnabledFlag();
}


/***************************************************************************\
* SetAccessEnabledFlag
*
* Sets the global flag ACCF_ACCESSENABLED to non-zero if any accessibility
* function is on or hot key activation is enabled.  When TEST_ACCF(ACCF_ACCESSENABLED)
* is zero keyboard input is processed directly.  When TEST_ACCF(ACCF_ACCESSENABLED) is
* non-zero keyboard input is filtered through AccessProceduresStream().
* See KeyboardApcProcedure in ntinput.c.
*
* History:
* 01-19-94 GregoryW         Created.
\***************************************************************************/
VOID SetAccessEnabledFlag(VOID)
{

    SET_OR_CLEAR_ACCF(ACCF_ACCESSENABLED,
                      TEST_ACCESSFLAG(FilterKeys, FKF_FILTERKEYSON)  ||
                      TEST_ACCESSFLAG(FilterKeys, FKF_HOTKEYACTIVE)  ||
                      TEST_ACCESSFLAG(StickyKeys, SKF_STICKYKEYSON)  ||
                      TEST_ACCESSFLAG(StickyKeys, SKF_HOTKEYACTIVE)  ||
                      TEST_ACCESSFLAG(HighContrast, HCF_HOTKEYACTIVE)  ||
                      TEST_ACCESSFLAG(MouseKeys, MKF_MOUSEKEYSON)    ||
                      TEST_ACCESSFLAG(MouseKeys, MKF_HOTKEYACTIVE)   ||
                      TEST_ACCESSFLAG(ToggleKeys, TKF_TOGGLEKEYSON)  ||
                      TEST_ACCESSFLAG(ToggleKeys, TKF_HOTKEYACTIVE)  ||
                      TEST_ACCESSFLAG(SoundSentry, SSF_SOUNDSENTRYON)||
                      TEST_ACCF(ACCF_SHOWSOUNDSON));
}

VOID SoundSentryTimer(
    PWND pwnd,
    UINT message,
    UINT_PTR idTimer,
    LPARAM lParam)
{
    TL tlpwndT;
    PWND pwndSoundSentry;

    UNREFERENCED_PARAMETER(pwnd);
    UNREFERENCED_PARAMETER(message);
    UNREFERENCED_PARAMETER(lParam);

    if (pwndSoundSentry = RevalidateHwnd(ghwndSoundSentry)) {
        ThreadLock(pwndSoundSentry, &tlpwndT);
        xxxFlashWindow(pwndSoundSentry,
                       (TEST_BOOL_ACCF(ACCF_FIRSTTICK) ? FLASHW_ALL : FLASHW_STOP),
                       0);
        ThreadUnlock(&tlpwndT);
    }

    if (TEST_ACCF(ACCF_FIRSTTICK)) {
        gtmridSoundSentry = InternalSetTimer(NULL,
                                             idTimer,
                                             5,
                                             SoundSentryTimer,
                                             TMRF_RIT | TMRF_ONESHOT);
        CLEAR_ACCF(ACCF_FIRSTTICK);
    } else {
        ghwndSoundSentry = NULL;
        gtmridSoundSentry = 0;
        SET_ACCF(ACCF_FIRSTTICK);
    }
}

/***************************************************************************\
* _UserSoundSentryWorker
*
* This is the worker routine that provides the visual feedback requested
* by the user.
*
* History:
* 08-02-93 GregoryW         Created.
\***************************************************************************/
BOOL
_UserSoundSentryWorker(VOID)
{
    PWND pwndActive;
    TL tlpwndT;

    CheckCritIn();
    //
    // Check to see if SoundSentry is on.
    //
    if (!TEST_ACCESSFLAG(SoundSentry, SSF_SOUNDSENTRYON)) {
        return TRUE;
    }

    if ((gpqForeground != NULL) && (gpqForeground->spwndActive != NULL)) {
        pwndActive = gpqForeground->spwndActive;
    } else {
        return TRUE;
    }

    switch (gSoundSentry.iWindowsEffect) {

    case SSWF_NONE:
        break;

    case SSWF_TITLE:
        //
        // Flash the active caption bar.
        //
        if (gtmridSoundSentry) {
            break;
        }
        ThreadLock(pwndActive, &tlpwndT);
        xxxFlashWindow(pwndActive, FLASHW_ALL, 0);
        ThreadUnlock(&tlpwndT);

        ghwndSoundSentry = HWq(pwndActive);
        gtmridSoundSentry = InternalSetTimer(NULL,
                                             0,
                                             gpsi->dtCaretBlink,
                                             SoundSentryTimer,
                                             TMRF_RIT | TMRF_ONESHOT);
        break;

    case SSWF_WINDOW:
    {
        //
        // Flash the active window.
        //
        HDC hdc;
        RECT rc;

        hdc = _GetWindowDC(pwndActive);
        _GetWindowRect(pwndActive, &rc);
        //
        // _GetWindowRect returns screen coordinates.  First adjust them
        // to window (display) coordinates and then map them to logical
        // coordinates before calling InvertRect.
        //
        OffsetRect(&rc, -rc.left, -rc.top);
        GreDPtoLP(hdc, (LPPOINT)&rc, 2);
        InvertRect(hdc, &rc);
        InvertRect(hdc, &rc);
        _ReleaseDC(hdc);
        break;
    }

    case SSWF_DISPLAY:
    {
        //
        // Flash the entire display.
        //
        HDC hdc;
        RECT rc;

        hdc = _GetDCEx(PWNDDESKTOP(pwndActive), NULL, DCX_WINDOW | DCX_CACHE);
        rc.left = rc.top = 0;
        rc.right = SYSMET(CXVIRTUALSCREEN);
        rc.bottom = SYSMET(CYVIRTUALSCREEN);
        InvertRect(hdc, &rc);
        InvertRect(hdc, &rc);
        _ReleaseDC(hdc);
        break;
    }
    }

    return TRUE;
}

/***************************************************************************\
* UtilityManager
*
* This is the strategy routine that gets called as part of the input stream
* processing.  Utility Manager launching happens here.
*
* Return value:
*    TRUE  - key event should be passed on to the next access routine.
*    FALSE - key event was processed and should not be passed on.
*
* History: 10-28-98 a-anilk created
\***************************************************************************/
BOOL UtilityManager(
    PKE pKeyEvent,
    ULONG ExtraInformation,
    int NotUsed)
{
    int CurrentModState;
    int fBreak;
    BYTE Vk;

    UNREFERENCED_PARAMETER(NotUsed);
    UNREFERENCED_PARAMETER(ExtraInformation);

    CheckCritIn();

    Vk = (BYTE)(pKeyEvent->usFlaggedVk & 0xff);
    fBreak = pKeyEvent->usFlaggedVk & KBDBREAK;
    CurrentModState = gLockBits | gLatchBits | gPhysModifierState;

    // the hot key to launch the utility manager is WinKey + U
    if (Vk == VK_U && !fBreak && (CurrentModState & LRWIN)) {
        PostAccessNotification(ACCESS_UTILITYMANAGER);

        return FALSE;
    }

    return TRUE;  // send key event to next accessibility routine.
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kernel\base.c ===
/****************************** Module Header ******************************\
* Module Name: base.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* Contains private versions of routines that used to be in kernel32.dll
*
* History:
* 12-16-94 JimA         Created.
\***************************************************************************/

#include "precomp.h"
#pragma hdrstop

#include <ntddbeep.h>


                          
/***************************************************************************\
* RtlLoadStringOrError
*
* NOTE: Passing a NULL value for lpch returns the string length. (WRONG!)
*
* Warning: The return count does not include the terminating NULL WCHAR;
*
* History:
* 04-05-91 ScottLu      Fixed - code is now shared between client and server
* 09-24-90 MikeKe       From Win30
* 12-09-94 JimA         Use message table.
\***************************************************************************/

int RtlLoadStringOrError(
    UINT wID,
    LPWSTR lpBuffer,            // Unicode buffer
    int cchBufferMax,           // cch in Unicode buffer
    WORD wLangId)
{
    PMESSAGE_RESOURCE_ENTRY MessageEntry;
    int cch;
    NTSTATUS Status;

    /*
     * Make sure the parms are valid.
     */
    if (!lpBuffer || (cchBufferMax-- == 0))
        return 0;

    cch = 0;

    Status = RtlFindMessage((PVOID)hModuleWin, (ULONG_PTR)RT_MESSAGETABLE,
            wLangId, wID, &MessageEntry);
    if (NT_SUCCESS(Status)) {

        /*
         * Copy out the message.  If the whole thing can be copied,
         * copy two fewer chars so the crlf in the message will be
         * stripped out.
         */
        cch = wcslen((PWCHAR)MessageEntry->Text) - 2;
        if (cch > cchBufferMax)
            cch = cchBufferMax;

        RtlCopyMemory(lpBuffer, (PWCHAR)MessageEntry->Text, cch * sizeof(WCHAR));
    }

    /*
     * Append a NULL.
     */
    lpBuffer[cch] = 0;

    return cch;
}


/***************************************************************************\
* UserSleep
*
* Kernel-mode version of Sleep() that must have a timeout value and
* is not alertable.
*
* History:
* 12-11-94 JimA         Created.
\***************************************************************************/

VOID UserSleep(
    DWORD dwMilliseconds)
{
    LARGE_INTEGER TimeOut;

    TimeOut.QuadPart = Int32x32To64( dwMilliseconds, -10000 );
    KeDelayExecutionThread(UserMode, FALSE, &TimeOut);
}


/***************************************************************************\
* UserBeep
*
* Kernel-mode version of Beep().
*
* History:
* 12-16-94 JimA         Created.
\***************************************************************************/

BOOL UserBeep(
    DWORD dwFreq,
    DWORD dwDuration)
{
    OBJECT_ATTRIBUTES ObjectAttributes;
    UNICODE_STRING NameString;
    NTSTATUS Status;
    IO_STATUS_BLOCK IoStatus;
    BEEP_SET_PARAMETERS BeepParameters;
    HANDLE hBeepDevice;
    LARGE_INTEGER TimeOut;

    CheckCritOut();
  
    if (IsRemoteConnection()) {
        if (gpRemoteBeepDevice == NULL)
            Status = STATUS_UNSUCCESSFUL;
        else
            Status = ObOpenObjectByPointer(
                          gpRemoteBeepDevice,
                          0,
                          NULL,
                          EVENT_ALL_ACCESS,
                          NULL,
                          KernelMode,
                          &hBeepDevice);
    } else {
        
        RtlInitUnicodeString(&NameString, DD_BEEP_DEVICE_NAME_U);
        
        InitializeObjectAttributes(&ObjectAttributes,
                                   &NameString,
                                   OBJ_KERNEL_HANDLE,
                                   NULL,
                                   NULL);
        
        Status = ZwCreateFile(&hBeepDevice,
                              FILE_READ_DATA | FILE_WRITE_DATA,
                              &ObjectAttributes,
                              &IoStatus,
                              NULL,
                              0,
                              FILE_SHARE_READ | FILE_SHARE_WRITE,
                              FILE_OPEN_IF,
                              0,
                              (PVOID) NULL,
                              0L);
    }
    
    if (!NT_SUCCESS(Status)) {
        return FALSE;
    }

    /*
     * 0,0 is a special case used to turn off a beep.  Otherwise
     * validate the dwFreq parameter to be in range.
     */
    if ((dwFreq != 0 || dwDuration != 0) &&
        (dwFreq < (ULONG)0x25 || dwFreq > (ULONG)0x7FFF)) {
        
        Status = STATUS_INVALID_PARAMETER;
    } else {
        BeepParameters.Frequency = dwFreq;
        BeepParameters.Duration = dwDuration;

        Status = ZwDeviceIoControlFile(hBeepDevice,
                                       NULL,
                                       NULL,
                                       NULL,
                                       &IoStatus,
                                       IOCTL_BEEP_SET,
                                       &BeepParameters,
                                       sizeof(BeepParameters),
                                       NULL,
                                       0);
    }

    EnterCrit();
    _UserSoundSentryWorker();
    LeaveCrit();

    if (!NT_SUCCESS(Status)) {
        ZwClose(hBeepDevice);
        return FALSE;
    }
    
    /*
     * Beep device is asynchronous, so sleep for duration
     * to allow this beep to complete.
     */
    if (dwDuration != (DWORD)-1 && (dwFreq != 0 || dwDuration != 0)) {
        TimeOut.QuadPart = Int32x32To64( dwDuration, -10000);
        
        KeDelayExecutionThread(UserMode, FALSE, &TimeOut);
    }
    ZwClose(hBeepDevice);
    return TRUE;
}

void RtlInitUnicodeStringOrId(
    PUNICODE_STRING pstrName,
    LPWSTR lpstrName)
{
    if (IS_PTR(lpstrName)) {
        RtlInitUnicodeString(pstrName, lpstrName);
    } else {
        pstrName->Length = pstrName->MaximumLength = 0;
        pstrName->Buffer = lpstrName;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kernel\atom.c ===
/****************************** Module Header ******************************\
* Module Name: atom.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* This file contains the common code to implement atom tables.
*
\***************************************************************************/

#include "precomp.h"
#pragma hdrstop

#pragma alloc_text(INIT, UserRtlCreateAtomTable)

PVOID UserAtomTableHandle;

NTSTATUS
UserRtlCreateAtomTable(
    IN ULONG NumberOfBuckets
    )
{
    NTSTATUS Status;

    if (UserAtomTableHandle == NULL) {
        Status = RtlCreateAtomTable( NumberOfBuckets, &UserAtomTableHandle );
    } else {
        RIPMSG0(RIP_VERBOSE, "UserRtlCreateAtomTable: table alread exists");
        Status = STATUS_SUCCESS;
    }

    return Status;
}


ATOM UserAddAtom(
    LPCWSTR ccxlpAtom, BOOL bPin)
{
    NTSTATUS Status;
    ATOM atom;

    UserAssert(IS_PTR(ccxlpAtom) || (ccxlpAtom == NULL));

    /*
     * Rtl routines protect accesses to strings with their
     * own try/except blocks.
     */
    atom = 0;
    Status = RtlAddAtomToAtomTable( UserAtomTableHandle,
                                    (PWSTR)ccxlpAtom,
                                    &atom
                                   );
    if (!NT_SUCCESS(Status)) {
        RIPNTERR0(Status, RIP_VERBOSE, "UserAddAtom: add failed");
    }

    if (atom && bPin)
        RtlPinAtomInAtomTable(UserAtomTableHandle,atom);

    return atom;
}

ATOM UserFindAtom(
    LPCWSTR ccxlpAtom)
{
    NTSTATUS Status;
    ATOM atom;

    /*
     * Rtl routines protect accesses to strings with their
     * own try/except blocks.
     */
    atom = 0;
    Status = RtlLookupAtomInAtomTable( UserAtomTableHandle,
                                       (PWSTR)ccxlpAtom,
                                       &atom
                                     );
    if (!NT_SUCCESS(Status)) {
        RIPNTERR0(Status, RIP_VERBOSE, "UserFindAtom: lookup failed");
    }

    return atom;
}

ATOM UserDeleteAtom(
    ATOM atom)
{
    NTSTATUS Status;

    if ((atom >= gatomFirstPinned) && (atom <= gatomLastPinned))
        return 0;      // if pinned, just return

    Status = RtlDeleteAtomFromAtomTable( UserAtomTableHandle, atom );
    if (NT_SUCCESS(Status)) {
        return 0;
    } else {
        RIPNTERR0(Status, RIP_VERBOSE, "UserDeleteAtom: delete failed");
        return atom;
    }
}

UINT UserGetAtomName(
    ATOM atom,
    LPWSTR ccxlpch,
    int cchMax)
{
    NTSTATUS Status;
    ULONG AtomNameLength;

    AtomNameLength = cchMax * sizeof(WCHAR);
    Status = RtlQueryAtomInAtomTable( UserAtomTableHandle,
                                      atom,
                                      NULL,
                                      NULL,
                                      ccxlpch,
                                      &AtomNameLength
                                    );
    if (!NT_SUCCESS(Status)) {
        RIPNTERR0(Status, RIP_VERBOSE, "UserGetAtomName: query failed");
        return 0;
    } else {
        return AtomNameLength / sizeof(WCHAR);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kernel\calcclrc.c ===
/****************************** Module Header ******************************\
* Module Name: calcclrc.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* History:
* 10-22-90 MikeHar      Ported functions from Win 3.0 sources.
* 01-Feb-1991 mikeke    Added Revalidation code
\***************************************************************************/

#include "precomp.h"
#pragma hdrstop


/***************************************************************************\
* xxxCalcClientRect
*
* 10-22-90 MikeHar      Ported function from Win 3.0 sources.
\***************************************************************************/
VOID xxxCalcClientRect(
    PWND pwnd,
    LPRECT lprc,
    BOOL fHungRedraw)
{
    int cxFrame, yTopOld, cBorders;
    RECT rcTemp;
    PMENU pMenu;
    TL tlpMenu;
    BOOL fEmptyClient;
    BYTE bFramePresent;

    CheckLock(pwnd);
    UserAssert(IsWinEventNotifyDeferredOK());

    bFramePresent = TestWF(pwnd, WFFRAMEPRESENTMASK);

    /*
     * Clear all the frame bits.  NOTE: The HIBYTE of all these #defines
     * must stay the same for this line to work.
     */
    ClrWF(pwnd, WFFRAMEPRESENTMASK);

    //
    // We need to clear the client border bits also. Otherwise, when the
    // window gets really small, the client border will draw over the menu
    // and caption.
    //
    ClrWF(pwnd, WFCEPRESENT);

    /*
     * If the window is iconic, the client area is empty.
     */
    if (TestWF(pwnd, WFMINIMIZED)) {
        //  SetRectEmpty(lprc);
      // We must make it an empty rectangle.
      // But, that empty rectangle should be at the top left corner of the
      // window rect. Else, ScreenToClient() will return bad values.
        lprc->right = lprc->left;
        lprc->bottom = lprc->top;
        goto CalcClientDone;
    }

    // Save rect into rcTemp for easy local calculations.
    CopyRect(&rcTemp, lprc);

    // Save the top so we'll know how tall the caption was
    yTopOld = rcTemp.top;

    // Adjustment for the caption
    if (TestWF(pwnd, WFBORDERMASK) == LOBYTE(WFCAPTION))
    {
        SetWF(pwnd, WFCPRESENT);

        rcTemp.top += GetCaptionHeight(pwnd);
    }

    // Subtract out window borders
    cBorders = GetWindowBorders(pwnd->style, pwnd->ExStyle, TRUE, FALSE);
    cxFrame = cBorders * SYSMETFROMPROCESS(CXBORDER);
    InflateRect(&rcTemp, -cxFrame, -cBorders * SYSMETFROMPROCESS(CYBORDER));

    if (!TestwndChild(pwnd) && (pMenu = pwnd->spmenu)) {
        SetWF(pwnd, WFMPRESENT);
        if (!fHungRedraw) {
            ThreadLockMenuAlwaysNoModify(pMenu, &tlpMenu);
            rcTemp.top += xxxMenuBarCompute(pMenu, pwnd, rcTemp.top - yTopOld,
                    cxFrame, rcTemp.right - rcTemp.left);
            ThreadUnlockMenuNoModify(&tlpMenu);
        }
    }

    /*
     * We should have cleared WFMPRESENT in the else case here. Win9x doesn't do
     *  it either. Any code checking this flag will do the wrong thing...
     * It seems that it's pretty unsual for apps to remove the menu....
     * No code checking this flag can assume that pwnd->spmenu is not NULL -- we
     *  would need to clear it way earlier (at unlock time) for such assumption to hold true.
     */

    //
    // Fix for B#1425 -- Sizing window really small used to move children's
    // rects because the client calculations were wrong.  So we make the
    // bottom of the client match up with the top (the bottom of the menu
    // bar).
    //
    fEmptyClient = FALSE;

    if (rcTemp.top >= rcTemp.bottom) {
        rcTemp.bottom = rcTemp.top;
        fEmptyClient = TRUE;
    }

    //
    // BOGUS BOGUS BOGUS
    // Hack for Central Point PC Tools.
    // Possibly for M5 only.
    // B#8445
    //
    // They check for div-by-zero all over, but they jump to the wrong place
    // if a zero divisor is encountered, and end up faulting anyway.  So this
    // code path was never tested basically.  There's a period when starting
    // up where the window rect of their drives ribbon is empty.  In Win3.x,
    // the client would be shrunk to account for the border it had, and it
    // would look like it wasn't empty because the width would be negative,
    // signed!  So we version-switch this code, since other apps have
    // reported the non-emptiness as an annoying bug.
    //
    if (TestWF(pwnd, WFWIN40COMPAT) && (rcTemp.left >= rcTemp.right)) {
        rcTemp.right = rcTemp.left;
        fEmptyClient = TRUE;
    }

    if (fEmptyClient) {
        goto ClientCalcEnd;
    }

    //
    // Subtract client edge if we have space
    //
    if (    TestWF(pwnd, WEFCLIENTEDGE) &&
            (rcTemp.right - rcTemp.left >= (2 * SYSMETFROMPROCESS(CXEDGE))) &&
            (rcTemp.bottom - rcTemp.top >= (2 * SYSMETFROMPROCESS(CYEDGE))) ) {
        SetWF(pwnd, WFCEPRESENT);
        InflateRect(&rcTemp, -SYSMETFROMPROCESS(CXEDGE), -SYSMETFROMPROCESS(CYEDGE));
    }

    //
    // Subtract scrollbars
    // Note compatibility with 3.1:
    //      * You don't get a horizontal scrollbar unless you have MORE
    //  space (> ) in your client than you need for one.
    //      * You get a vertical scrollbar if you have AT LEAST ENOUGH
    //  space (>=) in your client for one.
    //
    if (TestWF(pwnd, WFHSCROLL) && (rcTemp.bottom - rcTemp.top > SYSMETFROMPROCESS(CYHSCROLL))) {
        SetWF(pwnd, WFHPRESENT);
        if (!fHungRedraw) {
            rcTemp.bottom -= SYSMETFROMPROCESS(CYHSCROLL);
        }
    }

    if (TestWF(pwnd, WFVSCROLL) && (rcTemp.right - rcTemp.left >= SYSMETFROMPROCESS(CXVSCROLL))) {
        SetWF(pwnd, WFVPRESENT);
        if (!fHungRedraw) {
            if ((!!TestWF(pwnd, WEFLEFTSCROLL)) ^ (!!TestWF(pwnd, WEFLAYOUTRTL))) {
                rcTemp.left += SYSMETFROMPROCESS(CXVSCROLL);
            } else {
                rcTemp.right -= SYSMETFROMPROCESS(CXVSCROLL);
            }
        }
    }

ClientCalcEnd:

    CopyRect(lprc, &rcTemp);

CalcClientDone:
    if (bFramePresent != TestWF(pwnd, WFFRAMEPRESENTMASK)) {
        xxxWindowEvent(EVENT_OBJECT_REORDER, pwnd, OBJID_WINDOW, 0, WEF_USEPWNDTHREAD);
    }
}

/***************************************************************************\
* UpdateClientRect()
*
* Make sure the client rect reflects the window styles correctly.
*
* 10-22-90 MikeHar      Ported function from Win 3.0 sources.
\***************************************************************************/
VOID xxxUpdateClientRect(
    PWND pwnd)
{
    RECT rc;

    CopyRect(&rc, &pwnd->rcWindow);
    xxxCalcClientRect(pwnd, &rc, FALSE);
    CopyRect(&pwnd->rcClient, &rc);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kernel\capture.c ===
/****************************** Module Header ******************************\
* Module Name: capture.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* History:
* 08-Nov-1990 DavidPe   Created.
* 01-Feb-1991 MikeKe    Added Revalidation code
\***************************************************************************/

#include "precomp.h"
#pragma hdrstop

/***************************************************************************\
* xxxSetCapture (API)
*
* This function sets the capture window for the current queue.
*
* History:
* 08-Nov-1990 DavidPe   Created.
\***************************************************************************/

PWND xxxSetCapture(
    PWND pwnd)
{
    PQ   pq;
    PWND pwndCaptureOld;
    HWND hwndCaptureOld;
    PTHREADINFO  ptiCurrent = PtiCurrent();

    pq = (PQ)PtiCurrent()->pq;

    /*
     * If the capture is locked, bail
     */
    if (pq->QF_flags & QF_CAPTURELOCKED) {
        RIPMSG2(RIP_WARNING, "xxxSetCapture(%#p): Capture is locked. pq:%#p", pwnd, pq);
        return NULL;
    }

    /*
     * Don't allow the app to set capture to a window
     * from another queue.
     */
    if ((pwnd != NULL) && GETPTI(pwnd)->pq != pq)
        return NULL;

    /*
     * If full screen capture don't allow any other capture
     */
    if (gspwndScreenCapture)
        return NULL;

    pwndCaptureOld = pq->spwndCapture;
    hwndCaptureOld = HW(pwndCaptureOld);

    xxxCapture(ptiCurrent, pwnd, CLIENT_CAPTURE);

    if (hwndCaptureOld != NULL) {

        if (RevalidateHwnd(hwndCaptureOld))
            return pwndCaptureOld;
    }

    return NULL;
}

/***************************************************************************\
* xxxReleaseCapture (API)
*
* This function release the capture for the current queue.
*
* History:
* 08-Nov-1990 DavidPe   Created.
* 16-May-1991 MikeKe    Changed to return BOOL
\***************************************************************************/

BOOL xxxReleaseCapture(VOID)
{
    PTHREADINFO ptiCurrent = PtiCurrent();
    /*
     * If the capture is locked, bail
     */
    if (ptiCurrent->pq->QF_flags & QF_CAPTURELOCKED) {
        RIPMSG0(RIP_WARNING, "xxxReleaseCapture: Capture is locked");
        return FALSE;
    }

    /*
     * If we're releasing the capture from a window during tracking,
     * cancel tracking first.
     */
    if (ptiCurrent->pmsd != NULL) {

        /*
         * Only remove the tracking rectangle if it's
         * been made visible.
         */
        if (ptiCurrent->TIF_flags & TIF_TRACKRECTVISIBLE) {

            bSetDevDragRect(gpDispInfo->hDev, NULL, NULL);

            if (!(ptiCurrent->pmsd->fDragFullWindows))
                xxxDrawDragRect(ptiCurrent->pmsd, NULL, DDR_ENDCANCEL);

            ptiCurrent->TIF_flags &= ~(TIF_TRACKRECTVISIBLE | TIF_MOVESIZETRACKING);
        }
    }

    xxxCapture(ptiCurrent, NULL, NO_CAP_CLIENT);

    return TRUE;
}

/***************************************************************************\
* xxxCapture
*
* This is the workhorse routine of capture setting and releasing.
*
* History:
* 13-Nov-1990 DavidPe   Created.
\***************************************************************************/

VOID xxxCapture(
    PTHREADINFO pti,
    PWND        pwnd,
    UINT        code)
{
    CheckLock(pwnd);
    UserAssert(IsWinEventNotifyDeferredOK());

    if ((gspwndScreenCapture == NULL) ||
        (code == FULLSCREEN_CAPTURE) ||
        ((pwnd == NULL) && (code == NO_CAP_CLIENT) && (pti->pq != GETPTI(gspwndScreenCapture)->pq))) {

        PQ   pq;
        PWND pwndCaptureOld = NULL;

        if (code == FULLSCREEN_CAPTURE) {
            if (pwnd) {

                Lock(&gspwndScreenCapture, pwnd);

                /*
                 * We're going full screen so clear the mouse owner
                 */
                Unlock(&gspwndMouseOwner);

            } else {

                Unlock(&gspwndScreenCapture);
            }
        }

        /*
         * Internal capture works like Win 3.1 capture unlike the NT capture
         * which can be lost if the user clicks down on another application
         */
        if (code == CLIENT_CAPTURE_INTERNAL) {
            Lock(&gspwndInternalCapture, pwnd);
            code = CLIENT_CAPTURE;
        }

        /*
         * Free the internal capture if the app (thread) that did the internal
         * capture is freeing the capture.
         */
        if ((code == NO_CAP_CLIENT) &&
            gspwndInternalCapture   &&
            (pti == GETPTI(gspwndInternalCapture))) {

            Unlock(&gspwndInternalCapture);
        }

        if ((pq = pti->pq) != NULL) {
            PDESKTOP pdesk = pti->rpdesk;

#if DBG
            if (pq->QF_flags & QF_CAPTURELOCKED) {
                RIPMSG1(RIP_WARNING, "pq %p already has QF_CAPTURELOCKED", pq);
            }
#endif

            /*
             * If someone is tracking mouse events in the client area and
             *  we're setting or releasing an internal capture mode (!= CLIENT_CAPTURE),
             *  then cancel tracking -- because we're either taking or relinquishing
             *  control over the mouse.
             */
            if ((pdesk->dwDTFlags & DF_TRACKMOUSEEVENT)
                    && (pdesk->htEx == HTCLIENT)
                    && ((pdesk->spwndTrack == pwnd)
                            && (code != CLIENT_CAPTURE)
                         || ((pdesk->spwndTrack == pq->spwndCapture)
                             && (pq->codeCapture != CLIENT_CAPTURE)))) {

                BEGINATOMICCHECK();
                xxxCancelMouseMoveTracking(pdesk->dwDTFlags, pdesk->spwndTrack,
                                           pdesk->htEx, DF_TRACKMOUSEEVENT);
                ENDATOMICCHECK();

            }

            pwndCaptureOld = pq->spwndCapture;
            LockCaptureWindow(pq, pwnd);
            pq->codeCapture = code;
        } else {
            /*
             * A thread without a queue?
             */
            UserAssert(pti->pq != NULL);
        }

        /*
         * If there was a capture window and we're releasing it, post
         * a WM_MOUSEMOVE to the window we're over so they can know about
         * the current mouse position.
         * Defer WinEvent notifications to protect pwndCaptureOld
         */
        DeferWinEventNotify();
        
        if (pwnd == NULL && pwndCaptureOld != NULL) {
#ifdef REDIRECTION
            if (!IsGlobalHooked(pti, WHF_FROM_WH(WH_HITTEST)))
#endif
                zzzSetFMouseMoved();
        }
        
        if (pwndCaptureOld) {
            zzzWindowEvent(EVENT_SYSTEM_CAPTUREEND, pwndCaptureOld, OBJID_WINDOW,
                    INDEXID_CONTAINER, WEF_USEPWNDTHREAD);
        }

        if (pwnd) {
            zzzWindowEvent(EVENT_SYSTEM_CAPTURESTART, pwnd, OBJID_WINDOW,
                    INDEXID_CONTAINER, WEF_USEPWNDTHREAD);
        }

        /*
         * New for win95 - send  WM_CAPTURECHANGED.
         *
         * The FNID_DELETED_BIT is set in xxxFreeWindow which means we
         * DON'T want to send the message.
         */
        if (pwndCaptureOld                        &&
            TestWF(pwndCaptureOld, WFWIN40COMPAT) &&
            !(pwndCaptureOld->fnid & FNID_DELETED_BIT)) {

            TL tlpwnd;

            /*
             * If we are in menu mode and just set capture,
             *  don't let them take it from us during this
             *  callback.
             */
            if ((pti->pMenuState != NULL) && (pwnd != NULL)) {
                pq->QF_flags |= QF_CAPTURELOCKED;
            }

            ThreadLockAlways(pwndCaptureOld, &tlpwnd);
            zzzEndDeferWinEventNotify();
            xxxSendMessageCallback(pwndCaptureOld,
                    WM_CAPTURECHANGED,
                    FALSE,
                    (LPARAM)HW(pwnd),
                    NULL,
                    0,
                    FALSE);
            /* The thread's queue may have changed during the callback,
             * so we need to refresh the local. Bug #377795
             */
            pq = pti->pq;
            UserAssert(pq != NULL);
            ThreadUnlock(&tlpwnd);

            /*
             * Release the temporary lock, if any
             */
            pq->QF_flags &= ~QF_CAPTURELOCKED;
        } else {
            zzzEndDeferWinEventNotify();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kernel\acons.c ===
/****************************** Module Header ******************************\
* Module Name: acons.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* This module contains code for dealing with animated icons/cursors.
*
* History:
* 10-02-91 DarrinM      Created.
* 07-30-92 DarrinM      Unicodized.
\***************************************************************************/

#include "precomp.h"
#pragma hdrstop

/***************************************************************************\
* zzzSetSystemCursor (API)
*
* Replace a system (aka 'public') cursor with a user provided one.  The new
* cursor is pulled from a file (.CUR, .ICO, or .ANI) specified in WIN.INI.
*
* History:
* 12/26/1991 DarrinM    Created.
* 08/04/1992 DarrinM    Recreated.
* 10/14/1995 SanfordS   Win95 support.
\***************************************************************************/
BOOL zzzSetSystemCursor(
    PCURSOR pcur,
    DWORD id)
{
    int i;

    if (!CheckWinstaWriteAttributesAccess()) {
        return FALSE;
    }

    UserAssert(pcur);

    /*
     * Check if this cursor is one of the replaceable ones.
     */
    for (i = 0; i < COCR_CONFIGURABLE; i++) {
        if (gasyscur[i].Id == (WORD)id) {
            break;
        }
    }

    /*
     * Not replaceable, bail out.
     */
    if (i == COCR_CONFIGURABLE) {
        RIPMSG1(RIP_WARNING, "_SetSystemCursor: called with bad id 0x%x", id);
        return FALSE;
    }

    return zzzSetSystemImage(pcur, gasyscur[i].spcur);
}


/***********************************************************************\
* zzzSetSystemImage
*
* Places the contents of pcur into pcurSys and destroys pcur.
*
* 10/14/1995 Created SanfordS
\***********************************************************************/
BOOL zzzSetSystemImage(
    PCURSOR pcur,
    PCURSOR pcurSys)
{
#define CBCOPY (max(sizeof(CURSOR), sizeof(ACON)) - FIELD_OFFSET(CURSOR, CI_COPYSTART))
#define pacon ((PACON)pcur)

    char cbT[CBCOPY];
    UINT CURSORF_flags;

    UserAssert(pcurSys);

    if (pcurSys == pcur) {
        return TRUE;
    }

    /*
     * All ssytem images being replaced should have ordinal names
     * and reference the USER module and be unowned.
     */
    UserAssert(!IS_PTR(pcurSys->strName.Buffer));
    UserAssert(pcurSys->atomModName == atomUSER32);

    /*
     * if pcur was an acon, transfer frame ownerships to pcurSys.
     */
    UserAssert(pcurSys->head.ppi == NULL);
    if (pcur->CURSORF_flags & CURSORF_ACON && pcur->head.ppi != NULL) {

        int i;
        PHE phe = HMPheFromObject(pcurSys);
        PTHREADINFO ptiOwner = ((PPROCESSINFO)phe->pOwner)->ptiList;

        for (i = 0; i < pacon->cpcur; i++) {
            HMChangeOwnerProcess(pacon->aspcur[i], ptiOwner);
            pacon->aspcur[i]->head.ppi = NULL;
        }
    }

    /*
     * If this assert fails, the CURSOR and ACON structures were changed
     * incorrectly - read the comments in user.h and wingdi.w around
     * tagCURSOR, tagACON, and CURSINFO.
     */
    UserAssert(FIELD_OFFSET(CURSOR, CI_FIRST) == FIELD_OFFSET(ACON, CI_FIRST));

    /*
     * swap everything starting from CI_COPYSTART.
     */
    RtlCopyMemory(cbT, &pcur->CI_COPYSTART, CBCOPY);
    RtlCopyMemory(&pcur->CI_COPYSTART, &pcurSys->CI_COPYSTART, CBCOPY);
    RtlCopyMemory(&pcurSys->CI_COPYSTART, cbT, CBCOPY);
    /*
     * Swap the CURSORF_ACON flags since they go with the swapped data.
     */
    CURSORF_flags = pcur->CURSORF_flags & CURSORF_ACON;
    pcur->CURSORF_flags =
            (pcur->CURSORF_flags    & ~CURSORF_ACON) |
            (pcurSys->CURSORF_flags &  CURSORF_ACON);
    pcurSys->CURSORF_flags =
            (pcurSys->CURSORF_flags & ~CURSORF_ACON) | CURSORF_flags;

    /*
     * If we swapped acons into pcur, then we need to change the ownerhsip to
     * make sure they can get destroyed.
     */
    if (pcur->CURSORF_flags & CURSORF_ACON) {
        int i;
        PTHREADINFO ptiCurrent = PtiCurrent();

        for (i = 0; i < pacon->cpcur; i++) {
            HMChangeOwnerProcess(pacon->aspcur[i], ptiCurrent);
        }
    }

    /*
     * Use THREADCLEANUP so system cursors are not destroyed.
     */
    _DestroyCursor(pcur, CURSOR_THREADCLEANUP);


    /*
     * If the current logical cursor is changing then force the current physical
     * cursor to change.
     */
    if (gpcurLogCurrent == pcurSys) {
        gpcurLogCurrent = NULL;
        gpcurPhysCurrent = NULL;
        zzzUpdateCursorImage();
    }

    /*
     * Mark the cursor as a system cursor that can be shadowed by GDI.
     */
    pcurSys->CURSORF_flags |= CURSORF_SYSTEM;

    return TRUE;
#undef pacon
#undef CBCOPY
}



/***************************************************************************\
* _GetCursorFrameInfo (API)
*
* Example usage:
*
* hcur = _GetCursorFrameInfo(hacon, NULL, 4, &ccur);
* hcur = _GetCursorFrameInfo(NULL, IDC_NORMAL, 0, &ccur); // get device's arrow
*
* History:
* 08-05-92 DarrinM      Created.
\***************************************************************************/
PCURSOR _GetCursorFrameInfo(
    PCURSOR pcur,
    int iFrame,
    PJIF pjifRate,
    LPINT pccur)
{
    /*
     * If this is only a single cursor (not an ACON) just return it and
     * a frame count of 1.
     */
    if (!(pcur->CURSORF_flags & CURSORF_ACON)) {
        *pccur = 1;
        *pjifRate = 0;
        return pcur;
    }

    /*
     * Return the useful cursor information for the specified frame
     * of the ACON.
     */
#define pacon ((PACON)pcur)
    if (iFrame < 0 || iFrame >= pacon->cicur) {
        return NULL;
    }

    *pccur = pacon->cicur;
    *pjifRate = pacon->ajifRate[iFrame];

    return pacon->aspcur[pacon->aicur[iFrame]];
#undef pacon
}


/***************************************************************************\
* DestroyAniIcon
*
* Free all the individual cursors that make up the frames of an animated
* icon.
*
* WARNING: DestroyAniIcon assumes that all fields that an ACON shares with
* a cursor will be freed by some cursor code (probably the cursor function
* that calls this one).
*
* History:
* 08-04-92 DarrinM      Created.
\***************************************************************************/
BOOL DestroyAniIcon(
    PACON pacon)
{
    int i;
    PCURSOR pcur;

    for (i = 0; i < pacon->cpcur; i++) {
        UserAssert(pacon->aspcur[i]->CURSORF_flags & CURSORF_ACONFRAME);

        /*
         * This should not be a public acon; if it is, unlock won't be able
         * to destroy it. If destroy a public icon, ownership must be called
         * before calling this function (see zzzSetSystemImage).
         */
        UserAssert(GETPPI(pacon->aspcur[i]) != NULL);
        pcur = Unlock(&pacon->aspcur[i]);
        if (pcur != NULL) {
            _DestroyCursor(pcur, CURSOR_ALWAYSDESTROY);
        }
    }

    UserFreePool(pacon->aspcur);

    return TRUE;
}


/***********************************************************************\
* LinkCursor
*
* Links unlinked cursor into the apropriate icon cache IFF its the
* type of cursor that needs to be in the cache.
*
* Note that changing ownership if cursor objects needs to keep this
* cache linking in mind.  The unlink routine in
* DestroyEmptyCursorObject() will handle public cursor objects made
* local but that is all.
*
* 10/18/1995 Created SanfordS
\***********************************************************************/
VOID LinkCursor(
    PCURSOR pcur)
{
    /*
     * Should never try to link twice!
     */
    UserAssert(!(pcur->CURSORF_flags & CURSORF_LINKED));

    /*
     * We don't cache acon frames because they all belong to the
     * root acon object.
     *
     * We don't cache process owned objects that are not LRSHARED
     * either.
     */
    if (!(pcur->CURSORF_flags & CURSORF_ACONFRAME)) {
        PPROCESSINFO ppi = pcur->head.ppi;

        if (ppi == NULL) {
            /*
             * Public cache object.
             */
            pcur->pcurNext    = gpcurFirst;
            gpcurFirst        = pcur;
            pcur->CURSORF_flags |= CURSORF_LINKED;
        } else if (pcur->CURSORF_flags & CURSORF_LRSHARED) {
            /*
             * Private cache LR_SHARED object.
             */
            pcur->pcurNext    = ppi->pCursorCache;
            ppi->pCursorCache = pcur;
            pcur->CURSORF_flags |= CURSORF_LINKED;
        }
    }
}


/***************************************************************************\
* ProcessAlphaBitmap
*
* Examines the source bitmap to see if it supports and uses an alpha
* channel. If it does, a new DIB section is created that contains a
* premultiplied copy of the data from the source bitmap.
*
* If the source bitmap is not capable of supporting, or simply doesn't use,
* an alpha channel, the return value is NULL.
*
* If an error occurs, the return value is NULL.
*
* 8/10/2000 Created DwayneN
\***************************************************************************/
HBITMAP ProcessAlphaBitmap(
    HBITMAP hbmSource)
{
    BITMAP bmp;
    BITMAPINFO bi;
    HBITMAP hbmAlpha;
    RGBQUAD * pAlphaBitmapBits;
    DWORD cPixels;
    DWORD i;
    RGBQUAD pixel;
    BOOL fAlphaChannel;

    /*
     * There are several code paths that end up calling us with a NULL
     * hbmSource.  This is fine, in that it simply indicates that there
     * is no alpha channel.
     */
    if (hbmSource == NULL) {
        return NULL;
    }

    if (GreExtGetObjectW(hbmSource, sizeof(BITMAP), &bmp) == 0) {
        return NULL;
    }

    /*
     * Only single plane, 32bpp bitmaps can even contain an alpha channel.
     */
    if (bmp.bmPlanes != 1 ||
        bmp.bmBitsPixel != 32) {
        return NULL;
    }

    /*
     * Allocate room to hold the source bitmap's bits for examination.
     * We actually allocate a DIB - that will be passed out if the
     * source bitmap does indeed contain an alpha channel.
     */
    RtlZeroMemory(&bi, sizeof(bi));
    bi.bmiHeader.biSize        = sizeof(BITMAPINFOHEADER);
    bi.bmiHeader.biWidth       = bmp.bmWidth;
    bi.bmiHeader.biHeight      = bmp.bmHeight;
    bi.bmiHeader.biPlanes      = 1;
    bi.bmiHeader.biBitCount    = 32;
    bi.bmiHeader.biCompression = BI_RGB;

    hbmAlpha = GreCreateDIBitmapReal(gpDispInfo->hdcScreen,
                                     0,
                                     NULL,
                                     (LPBITMAPINFO)&bi,
                                     DIB_RGB_COLORS,
                                     sizeof(bi),
                                     0,
                                     NULL,
                                     0,
                                     NULL,
                                     0,
                                     0,
                                     &pAlphaBitmapBits);
    if (NULL != hbmAlpha) {
        /*
         * Set up the header again in case it was tweaked by GreCreateDIBitmapReal.
         */
        RtlZeroMemory(&bi, sizeof(bi));
        bi.bmiHeader.biSize        = sizeof(BITMAPINFOHEADER);
        bi.bmiHeader.biWidth       = bmp.bmWidth;
        bi.bmiHeader.biHeight      = bmp.bmHeight;
        bi.bmiHeader.biPlanes      = 1;
        bi.bmiHeader.biBitCount    = 32;
        bi.bmiHeader.biCompression = BI_RGB;

        /*
         * Copy the bitmap data from the source bitmap into our alpha DIB.
         */
        if (0 == GreGetDIBitsInternal(gpDispInfo->hdcScreen,
                                      hbmSource,
                                      0,
                                      bi.bmiHeader.biHeight,
                                      (LPBYTE) pAlphaBitmapBits,
                                      (LPBITMAPINFO)&bi,
                                      DIB_RGB_COLORS,
                                      BITMAPWIDTHSIZE(bi.bmiHeader.biWidth, bi.bmiHeader.biHeight,1,32),
                                      bi.bmiHeader.biSize)) {
            GreDeleteObject(hbmAlpha);
            return NULL;
        }

        /*
         * We need to examine the source bitmap to see if it contains an alpha
         * channel.  This is simply a heuristic since there is no format difference
         * between 32bpp 888 RGB image and 32bpp 8888 ARGB image.  What we do is look
         * for any non-0 alpha/reserved values.  If all alpha/reserved values are 0,
         * then the image would be 100% invisible if blitted with alpha - which is
         * almost cerainly not the desired result.  So we assume such bitmaps are
         * 32bpp non-alpha.
         */
        cPixels  = bi.bmiHeader.biWidth * bi.bmiHeader.biHeight;
        fAlphaChannel = FALSE;
        for (i = 0; i < cPixels; i++) {
            if (pAlphaBitmapBits[i].rgbReserved != 0)
            {
                fAlphaChannel = TRUE;
                break;
            }
        }

        if (fAlphaChannel == FALSE) {
            GreDeleteObject(hbmAlpha);
            return NULL;
        }

        /*
         * The source bitmap appears to use an alpha channel.  Spin through our
         * copy of the bits and premultiply them.  This is a necessary step to
         * prepare an alpha bitmap for use by GDI.
         */
        for (i=0; i < cPixels; i++) {
            pixel = pAlphaBitmapBits[i];

            pAlphaBitmapBits[i].rgbRed = (pixel.rgbRed * pixel.rgbReserved) / 0xFF;
            pAlphaBitmapBits[i].rgbGreen = (pixel.rgbGreen * pixel.rgbReserved) / 0xFF;
            pAlphaBitmapBits[i].rgbBlue = (pixel.rgbBlue * pixel.rgbReserved) / 0xFF;
        }
    }

    return hbmAlpha;
}

/***************************************************************************\
* _SetCursorIconData
*
* Initializes empty cursor/icons.  Note that the string buffers and
* pcurData are not captured.  If a fault occurs in this routine,
* all allocated memory will be freed when the cursors are destroyed.
*
* Critical side effect:  If this function fails, the bitmaps must NOT
* have been made public.  (See CreateIconIndirect()).
*
* History:
* 12-01-94 JimA         Created.
\***************************************************************************/
BOOL _SetCursorIconData(
    PCURSOR pcur,
    PUNICODE_STRING cczpstrModName,
    PUNICODE_STRING cczpstrName,
    PCURSORDATA pcurData,
    DWORD cbData)
{
#define pacon ((PACON)pcur)
    int i;
#if DBG
    BOOL fSuccess;
#endif

    pcur->CURSORF_flags |= pcurData->CURSORF_flags;
    pcur->rt = pcurData->rt;

    if (pcurData->CURSORF_flags & CURSORF_ACON) {
        UserAssert(pacon->aspcur == NULL);
        RtlCopyMemory(&pacon->cpcur,
                      &pcurData->cpcur,
                      sizeof(ACON) - FIELD_OFFSET(ACON, cpcur));
    } else {
        RtlCopyMemory(&pcur->CI_COPYSTART,
                      &pcurData->CI_COPYSTART,
                      sizeof(CURSOR) - FIELD_OFFSET(CURSOR, CI_COPYSTART));
    }

    /*
     * Save name of the cursor resource
     */
    if (cczpstrName->Length != 0){
        /*
         * AllocateUnicodeString guards access to src Buffer with
         * a try block.
         */

        if (!AllocateUnicodeString(&pcur->strName, cczpstrName))
            return FALSE;
    } else {
        pcur->strName = *cczpstrName;
    }

    /*
     * Save the module name
     */
    if (cczpstrModName->Buffer) {
        /*
         * UserAddAtom guards access to the string with a try block.
         */
        pcur->atomModName = UserAddAtom(cczpstrModName->Buffer, FALSE);
        if (pcur->atomModName == 0) {
            return FALSE;
        }
    }

    if (pcur->CURSORF_flags & CURSORF_ACON) {

        /*
         * Stash away animated icon info.
         */
        pacon = (PACON)pcur;
        pacon->aspcur = UserAllocPool(cbData, TAG_CURSOR);
        if (pacon->aspcur == NULL)
            return FALSE;

        /*
         * Copy the handle array.  Do this in a try/except so the
         * buffer will be freed if pcurData goes away.  Even though
         * cursor destruction would free the array, a fault will
         * leave the contents in an undetermined state and cause
         * problems during cursor destruction.
         */
        try {
            RtlCopyMemory(pacon->aspcur, pcurData->aspcur, cbData);
            pacon->aicur = (DWORD *)((PBYTE)pacon->aspcur + (ULONG_PTR)pcurData->aicur);
            pacon->ajifRate = (PJIF)((PBYTE)pacon->aspcur + (ULONG_PTR)pcurData->ajifRate);
        } except (W32ExceptionHandler(FALSE, RIP_WARNING)) {
            UserFreePool(pacon->aspcur);
            pacon->aspcur = NULL;
            return FALSE;
        }

        /*
         * Convert handles into pointers and lock them in.
         */
        for (i = 0; i < pacon->cpcur; i++) {
            PCURSOR pcurT;

            pcurT = (PCURSOR) HMValidateHandle(pacon->aspcur[i], TYPE_CURSOR);
            if (pcurT) {
                pacon->aspcur[i] = NULL;
                Lock(&pacon->aspcur[i], pcurT);
            } else {
                while (--i >= 0) {
                    Unlock(&pacon->aspcur[i]);
                }

                UserFreePool(pacon->aspcur);
                pacon->aspcur = NULL;
                RIPMSG0(RIP_WARNING, "SetCursorIconData: invalid cursor handle for animated cursor");
                return FALSE;
            }
        }
    } else {
        PW32PROCESS W32Process = W32GetCurrentProcess();

        /*
         * If the icon's color bitmap has an alpha channel, pre-process it
         * and cache it in our hbmUserAlpha field.
         */
        pcur->hbmUserAlpha = ProcessAlphaBitmap(pcur->hbmColor);

        /*
         * Make the cursor and its bitmaps public - LAST THING!
         */
        UserAssert(pcur->hbmMask);
        UserAssert(pcur->cx);
        UserAssert(pcur->cy);

        /*
         * Make the cursor public so that it can be shared across processes.
         * Charge the curson to this very process GDI quota even if it's public.
         */
#if DBG
        fSuccess =
#endif
        GreSetBitmapOwner(pcur->hbmMask, OBJECT_OWNER_PUBLIC);
        UserAssert(fSuccess);
        GreIncQuotaCount(W32Process);
        if (pcur->hbmColor) {
#if DBG
            fSuccess =
#endif
            GreSetBitmapOwner(pcur->hbmColor, OBJECT_OWNER_PUBLIC);
            UserAssert(fSuccess);
            GreIncQuotaCount(W32Process);
        }
        if (pcur->hbmUserAlpha != NULL) {
#if DBG
            fSuccess =
#endif
            GreSetBitmapOwner(pcur->hbmUserAlpha, OBJECT_OWNER_PUBLIC);
            UserAssert(fSuccess);
            GreIncQuotaCount(W32Process);
        }
    }

    LinkCursor(pcur);

    return TRUE;
#undef pacon
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kernel\caption.c ===
/****************************** Module Header ******************************\
* Module Name: caption.c (aka wmcap.c)
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* History:
* 28-Oct-1990 MikeHar   Ported functions from Win 3.0 sources.
* 01-Feb-1991 MikeKe    Added Revalidation code (None)
* 03-Jan-1992 IanJa     Neutralized (ANSI/wide-character)
\***************************************************************************/

#include "precomp.h"
#pragma hdrstop


#define MIN     0x01
#define MAX     0x02
#define NOMIN   0x04
#define NOMAX   0x08
#define NOCLOSE 0x10
#define SMCAP   0x20
#define NOSIZE  (NOMIN | NOMAX)

/***************************************************************************\
* xxxCalcCaptionButton
*
* This calculates the location of the caption button.
\***************************************************************************/
DWORD xxxCalcCaptionButton(
    PWND pwnd,
    int iButton,
    LPWORD pcmd,
    LPRECT prcBtn,
    LPWORD pbm)
{
    int x, y, cBorders, cxS, cyS;

    CheckLock(pwnd);

    *pcmd = 0;

    if (TestWF(pwnd, WFMINIMIZED)) {
        x = -SYSMET(CXFIXEDFRAME);
        y = -SYSMET(CYFIXEDFRAME);
    } else {
        cBorders = GetWindowBorders(pwnd->style, pwnd->ExStyle, TRUE, FALSE);
        x = -cBorders * SYSMET(CXBORDER);
        y = -cBorders * SYSMET(CYBORDER);
    }

    CopyInflateRect(prcBtn, &pwnd->rcWindow, x, y);

    x = -pwnd->rcWindow.left;
    y = -pwnd->rcWindow.top;

    /*
     * Get real caption area: Subtract final border underneath caption that
     * separates it from everything else.
     */
    if (TestWF(pwnd, WEFTOOLWINDOW)) {
        cxS = SYSMET(CXSMSIZE);
        cyS = SYSMET(CYSMSIZE);
    } else {
        cxS = SYSMET(CXSIZE);
        cyS = SYSMET(CYSIZE);
    }

    if (iButton == INDEX_TITLEBAR_CLOSEBUTTON) {
        if (xxxMNCanClose(pwnd)) {
            *pbm  = TestWF(pwnd, WEFTOOLWINDOW) ? OBI_CLOSE_PAL : OBI_CLOSE;
            *pcmd = SC_CLOSE;
        }
    } else if (iButton == INDEX_TITLEBAR_MINBUTTON) {
        /*
         * Reduce button isn't last button, so shift left by one button
         */
        if (TestWF(pwnd, WFMINBOX)) {
            prcBtn->right -= cxS * 2;
            x += SYSMET(CXEDGE);

            if (TestWF(pwnd, WFMINIMIZED)) {
                *pbm  = OBI_RESTORE;
                *pcmd = SC_RESTORE;
            } else {
                *pbm  = OBI_REDUCE;
                *pcmd = SC_MINIMIZE;
            }
        }
    } else if (iButton == INDEX_TITLEBAR_MAXBUTTON) {
        if (TestWF(pwnd, WFMAXBOX)) {
            prcBtn->right -= cxS;

            if (TestWF(pwnd, WFMAXIMIZED)) {
                *pbm  = OBI_RESTORE;
                *pcmd = SC_RESTORE;
            } else {
                *pbm  = OBI_ZOOM;
                *pcmd = SC_MAXIMIZE;
            }
        }
    } else {
        if (TestWF(pwnd, WEFCONTEXTHELP)) {
            prcBtn->right -= cxS;

            *pbm = OBI_HELP;
            *pcmd = SC_CONTEXTHELP;
        }
    }

    if (*pcmd) {
        prcBtn->bottom = prcBtn->top + cyS;
        prcBtn->left   = prcBtn->right - cxS;

        /*
         * Adjust 'x' and 'y' to window coordinates
         */
        x += prcBtn->left;
        y += prcBtn->top + SYSMET(CYEDGE);

        /*
         * rcBtn (screen coords hit rect) has a one-border tolerance all
         * around
         */
        InflateRect(prcBtn, SYSMET(CXBORDER), SYSMET(CYBORDER));

        if (TestWF(pwnd, WEFLAYOUTRTL)) {
            cxS           = prcBtn->right - prcBtn->left;
            prcBtn->right = pwnd->rcWindow.right - (prcBtn->left - pwnd->rcWindow.left);
            prcBtn->left  = prcBtn->right - cxS;
        }
    }

    return (DWORD)MAKELONG(x, y);
}

/***************************************************************************\
* xxxTrackCaptionButton
*
* Handles clicking and dragging on caption buttons. We draw the button
* depressed then track the mouse. If the user moves outside of the button,
* undepress it. When the mouse button is finally released, we return whether
* the mouse was inside the button or not. I.E., whether the button was
* clicked.
\***************************************************************************/
WORD xxxTrackCaptionButton(
    PWND pwnd,
    UINT hit)
{
    WORD  cmd;
    MSG   msg;
    HDC   hdc;
    WORD  bm;
    int   x;
    int   y;
    WORD  wState;
    WORD  wNewState;
    BOOL  fMouseUp = FALSE;
    RECT  rcBtn;
    DWORD dwWhere;
    int   iButton;
    WORD  wf;
    UserAssert(IsWinEventNotifyDeferredOK());

    CheckLock(pwnd);

    /*
     * Set up iButton for this and future STATECHANGE events
     */
    switch (hit) {
    case HTCLOSE:
        iButton = INDEX_TITLEBAR_CLOSEBUTTON;
        wf = WFCLOSEBUTTONDOWN;
        break;

    case HTREDUCE:
        iButton = INDEX_TITLEBAR_MINBUTTON;
        wf = WFREDUCEBUTTONDOWN;
        break;

    case HTZOOM:
        iButton = INDEX_TITLEBAR_MAXBUTTON;
        wf = WFZOOMBUTTONDOWN;
        break;

    case HTHELP:
        iButton = INDEX_TITLEBAR_HELPBUTTON;
        wf = WFHELPBUTTONDOWN;
        break;

    default:
        UserAssert(FALSE);
    }
    dwWhere = xxxCalcCaptionButton(pwnd, iButton, &cmd, &rcBtn, &bm);
    x = GET_X_LPARAM(dwWhere);
    y = GET_Y_LPARAM(dwWhere);

    if (cmd) {
        /*
         * Draw the image in its depressed state.
         */
        hdc = _GetDCEx(pwnd, NULL, DCX_WINDOW | DCX_USESTYLE);
        BitBltSysBmp(hdc, x, y, bm + DOBI_PUSHED);
        _ReleaseDC(hdc);

        wState = DOBI_PUSHED;

        /*
         * Notification of button press.
         */

        SetWF(pwnd, wf);

        xxxWindowEvent(EVENT_OBJECT_STATECHANGE, pwnd, OBJID_TITLEBAR, iButton, 0);
    } else {
        iButton = 0;
    }

    xxxSetCapture(pwnd);

    while (!fMouseUp) {
        if (xxxPeekMessage(&msg, NULL, WM_MOUSEFIRST, WM_MOUSELAST, PM_REMOVE)) {
            if (msg.message == WM_LBUTTONUP) {
                xxxReleaseCapture();
                fMouseUp = TRUE;
            } else if ((msg.message == WM_MOUSEMOVE) && cmd) {
                wNewState = PtInRect(&rcBtn, msg.pt) ? DOBI_PUSHED : DOBI_NORMAL;

                if (wState != wNewState) {
                    wState = wNewState;

                    hdc = _GetDCEx(pwnd, NULL, DCX_WINDOW | DCX_USESTYLE);
                    BitBltSysBmp(hdc, x, y, bm + wState);
                    _ReleaseDC(hdc);

                    if (wState == DOBI_PUSHED) {
                        SetWF(pwnd, wf);
                    } else {
                        ClrWF(pwnd, wf);
                    }

                    xxxWindowEvent(EVENT_OBJECT_STATECHANGE, pwnd, OBJID_TITLEBAR, iButton, 0);
                }
            }
        } else if (!xxxSleepThread(QS_MOUSE, 0, TRUE)) {
            break;
        }

        if (pwnd != PtiCurrent()->pq->spwndCapture) {
            /*
             * We lost capture. This could have happened during
             *  the WM_CAPTURECHANGED callback or later if we
             *  are/were not in the foreground queue.
             */
            break;
        }
    }

    if (!cmd) {
        return 0;
    }

    if (wState && (cmd != SC_CONTEXTHELP)) {
        hdc = _GetDCEx(pwnd, NULL, DCX_WINDOW | DCX_USESTYLE);
        BitBltSysBmp(hdc, x, y, bm);
        _ReleaseDC(hdc);

        ClrWF(pwnd, wf);

        xxxWindowEvent(EVENT_OBJECT_STATECHANGE, pwnd, OBJID_TITLEBAR, iButton, 0);
    }

    return (fMouseUp && PtInRect(&rcBtn, msg.pt)) ? cmd : 0;
}

/***************************************************************************\
* xxxGetWindowSmIcon
*
* Gets icon to draw in caption of window.
\***************************************************************************/
PCURSOR xxxGetWindowSmIcon(
    PWND pwnd,
    BOOL fDontSendMsg)
{
    PCURSOR pcursor = NULL;
    HICON hico = NULL;
    PCLS pcls = pwnd->pcls;

    CheckLock(pwnd);

    /*
     * We check per-window stuff first then per-class stuff, preferring a
     * real small icon over a stretched big one.
     *
     * Per-window small icon
     * Per-window big icon stretched small
     * Per-class small icon
     * Per-class big icon stretched small
     * WM_QUERYDRAGICON big icon stretched small (for 3.x dudes)
     *
     * Try window small icon first
     * NOTE:  The WM_SETICON and WM_GETICON messags are for ISVs only.
     */
    if ((hico = (HICON)_GetProp(pwnd, MAKEINTATOM(gpsi->atomIconSmProp), PROPF_INTERNAL)) != NULL) {

        if (pcursor = (PCURSOR)HMValidateHandleNoSecure(hico, TYPE_CURSOR)) {
            return pcursor;
        } else {
            RIPMSG1(RIP_WARNING,"GetWindowSmIcon: Invalid small icon handle (0x%p)", hico);
        }
    }

    /*
     * Try class small icon next.
     */
    pcursor = pcls->spicnSm; {
    if (pcursor != NULL)
        return pcursor;
    }

    if (!TestWF(pwnd, WFWIN40COMPAT) &&
        (!TestWF(pwnd, WFOLDUI)      ||
        !TestWF(pwnd, WEFMDICHILD))  &&
        !fDontSendMsg) {
        ULONG_PTR dwResult;

        /*
         * A few old apps like Corel don't set their class icon and other
         * data until long after we need it.  If we send them WM_QUERYDRAGICON,
         * they will fault because they don't check the return from GWL to
         * get their data.  WFOLDUI apps won't ever get a WM_QUERYDRAGICON,
         * sorry.  Currently the apps with this hack (not for this reason
         * necessarily)
         *      Corel Photo-Paint 5.0
         *      Myst 2.0
         *      Visual Baler 3.0
         *      Quicken
         */
        if (xxxSendMessageTimeout(pwnd,
                                  WM_QUERYDRAGICON,
                                  0,
                                  0,
                                  SMTO_NORMAL,
                                  100,
                                  &dwResult)) {
            hico = (HICON)dwResult;
        }

        if (hico) {
            hico = xxxCreateWindowSmIcon(pwnd, hico, FALSE);
            pcursor = (PCURSOR)HMValidateHandleNoSecure(hico, TYPE_CURSOR);

            if (pcursor == NULL) {
                hico = NULL;
            }
        }
    }

    if (pcursor == NULL) {
        pcursor = SYSICO(WINLOGO);
    }

    return pcursor;
}

/***************************************************************************\
* BltMe4Times
*
* This routine blts out two copies of the specified caption icon. One for an
* active window and one for an inactive window.
\***************************************************************************/
VOID BltMe4Times(
    POEMBITMAPINFO pOem,
    int            cxySlot,
    int            cxyIcon,
    HDC            hdcSrc,
    PCURSOR        pcursor,
    UINT           flags)
{
    RECT            rc;
    int             i;
    int             j;
    BOOL            fMask = TRUE;
    LONG            rop;
    HBRUSH          hBrush;

    hBrush = (flags & DC_INBUTTON) ? SYSHBR(3DHILIGHT) : SYSHBR(ACTIVECAPTION);

    for (i = 0; i < 2; i++) {
        rop = SRCAND;

        rc.left   = pOem->x;
        rc.top    = pOem->y;
        rc.right  = rc.left + pOem->cx;
        rc.bottom = rc.top + pOem->cy;
        FillRect(HDCBITS(), &rc, hBrush);

        rc.top  += (cxySlot - cxyIcon) / 2;
        rc.left += SYSMET(CXBORDER) + (cxySlot - cxyIcon) / 2;

        for (j = 0; j < 2; j++) {
                    BltIcon(
                    HDCBITS(),
                    rc.left,
                    rc.top,
                    cxyIcon,
                    cxyIcon,
                    hdcSrc,
                    pcursor,
                    fMask ? DI_MASK : DI_IMAGE,
                    rop);

            fMask = !fMask;
            rop = SRCINVERT;
        }

        pOem += DOBI_CAPOFF;
        hBrush = (flags & DC_INBUTTON) ? SYSHBR(3DFACE) : SYSHBR(INACTIVECAPTION);
    }
}

/***************************************************************************\
* DrawCaptionIcon
*
* In order to speed up the drawing of caption icons a cache is maintained.
* Within the cache, the first entry, 0, is for the tray's depressed caption
* look. Items 1..CCACHEDCAPTIONS are for the actual caption's icons.
\***************************************************************************/
VOID DrawCaptionIcon(
    HDC     hdc,
    LPRECT  lprc,
    PCURSOR pcursor,
    HBRUSH  hbrFill,
    UINT    flags)
{
    int            i;
    int            xStart = 0;
    int            cxySlot;
    POEMBITMAPINFO pOem;
    RECT           rc;
    CAPTIONCACHE   ccTemp;

    /*
     * Check the size of the icon to see if it matches the size of the
     * cache we created.  Most of the time this will match.  Also, if
     * we are drawing with DC_INBUTTON in 16 colors, don't cache.  Also,
     * if the icon has an active alpha channel, just blit it directly
     * and don't cache!
     */
    cxySlot = lprc->bottom - lprc->top;

    if ((cxySlot != gpsi->oembmi[OBI_CAPCACHE1].cy) ||
        (hbrFill == gpsi->hbrGray) ||
        (pcursor->hbmUserAlpha != NULL)) {

        rc.left   = lprc->left;
        rc.top    = lprc->top;
        rc.right  = lprc->left + cxySlot;
        rc.bottom = lprc->top + cxySlot;

        FillRect(hdc, &rc, hbrFill);

        rc.left += SYSMET(CXBORDER) + (cxySlot - SYSMET(CXSMICON)) / 2;
        rc.top  += (cxySlot - SYSMET(CYSMICON)) / 2;

        _DrawIconEx(hdc,
                    rc.left,
                    rc.top,
                    pcursor,
                    SYSMET(CXSMICON),
                    SYSMET(CYSMICON),
                    0,
                    NULL,
                    DI_NORMAL);

        goto Done;
    }

    if (flags & DC_INBUTTON) {
        /*
         * The DC_INBUTTON icons is always slot 0.
         */
        i = ((gcachedCaptions[0].spcursor == pcursor) ? 0 : CCACHEDCAPTIONS);
    } else {
        /*
         * Search the cache to see if this cursor is currently cached.
         */
        for (i = 1; i < CCACHEDCAPTIONS; i++) {
            if (gcachedCaptions[i].spcursor == pcursor) {
                break;
            }
        }
    }

    if (i >= CCACHEDCAPTIONS) {
        /*
         * Icon wasn't cached, so try and add it to the cache.
         */
        if (flags & DC_INBUTTON) {
            /*
             * The tray's special DC_INBUTTON style always goes in slot 0.
             */
            i = 0;
        } else {
            /*
             * Look for an empty slot in the cache.  If we can't find one,
             * stuff the new icon at the end of the cache.  The result will
             * be that the last item will be deleted.
             */
            for (i = 1; i < CCACHEDCAPTIONS - 1; i++) {
                if (gcachedCaptions[i].spcursor == NULL)
                    break;
            }
        }

        /*
         * Add an item to the cache by blting an active and inactive copy of
         * the icon.
         */
        BltMe4Times(gcachedCaptions[i].pOem,
                    cxySlot,
                    SYSMET(CXSMICON),
                    ghdcMem,
                    pcursor,
                    flags);

        Lock(&(gcachedCaptions[i].spcursor), pcursor);
#if DBG
        gcachedCaptions[i].hico = (HICON)PtoH(pcursor);
#endif
    }

    /*
     * We have a hit, so move that cached icon to the front of the cache.
     * This means that the least recently used icon will be the last icon in
     * the cache. Remember, we never update index 0 because it is reserved
     * for the DC_INBUTTON icon.
     */
    for ( ; i > 1; i-- ) {
        /*
         * Move the entry toward the front.
         */
        ccTemp = gcachedCaptions[i];
        gcachedCaptions[i]     = gcachedCaptions[i - 1];
        gcachedCaptions[i - 1] = ccTemp;

#if DBG
        /*
         * In checked builds we need to adjust the lock records for the
         * cursor so it has the correct address.
         */
        if (IsDbgTagEnabled(DBGTAG_TrackLocks)) {
            if (gcachedCaptions[i].spcursor) {
                HMRelocateLockRecord(&(gcachedCaptions[i].spcursor), (int)sizeof(CAPTIONCACHE));
            }

            if (gcachedCaptions[i - 1].spcursor) {
                HMRelocateLockRecord(&(gcachedCaptions[i - 1].spcursor), -(int)sizeof(CAPTIONCACHE));
            }
        }
#endif
    }

    /*
     * Make sure the icon we want to draw is the one that we hit in the
     * cache.
     */
    UserAssert(gcachedCaptions[i].hico == PtoH(pcursor));

    /*
     * Determine what cached bitmap to blt.
     */
    pOem = gcachedCaptions[i].pOem;
    if (!(flags & DC_ACTIVE)) {
        pOem += DOBI_CAPOFF;
    }

    GreBitBlt(hdc,
              lprc->left,
              lprc->top,
              cxySlot,
              cxySlot,
              HDCBITS(),
              pOem->x,
              pOem->y,
              SRCCOPY,
              0);

Done:
    /*
     * Adjust the given rectangle for the icon we just drew
     */
    lprc->left += cxySlot;
}

/***************************************************************************\
* FillGradient
*
* The rectangle is broken into two triangles: {0, 1, 2} and {0, 2, 3}.
* Color on {0, 3} is black, and on {1, 2) is the active caption color.
*
* 0  1
* 3  2
*
* 12/06/96      vadimg      created
\***************************************************************************/
VOID FillGradient(
    HDC hdc,
    LPCRECT prc,
    COLORREF rgbLeft,
    COLORREF rgbRight)
{
    TRIVERTEX avert[4];
    static GRADIENT_RECT auRect[1] = {0,1};
    #define GetCOLOR16(RGB, clr) ((COLOR16)(Get ## RGB ## Value(clr) << 8))

    avert[0].Red = GetCOLOR16(R, rgbLeft);
    avert[0].Green = GetCOLOR16(G, rgbLeft);
    avert[0].Blue = GetCOLOR16(B, rgbLeft);

    avert[1].Red = GetCOLOR16(R, rgbRight);
    avert[1].Green = GetCOLOR16(G, rgbRight);
    avert[1].Blue = GetCOLOR16(B, rgbRight);

    avert[0].x = prc->left;
    avert[0].y = prc->top;
    avert[1].x = prc->right;
    avert[1].y = prc->bottom;

    GreGradientFill(hdc, avert, 2,(PVOID)auRect, 1, GRADIENT_FILL_RECT_H);
}

VOID FillCaptionGradient(
    HDC hdc,
    LPCRECT prc,
    BOOL fActive)
{
    COLORREF rgbLeft, rgbRight;

    if (fActive) {
        rgbLeft = gpsi->argbSystem[COLOR_ACTIVECAPTION];
        rgbRight = gpsi->argbSystem[COLOR_GRADIENTACTIVECAPTION];
    } else {
        rgbLeft = gpsi->argbSystem[COLOR_INACTIVECAPTION];
        rgbRight = gpsi->argbSystem[COLOR_GRADIENTINACTIVECAPTION];
    }

    if (rgbLeft != rgbRight) {
        FillGradient(hdc, prc, rgbLeft, rgbRight);
    } else {
        FillRect(hdc, prc, fActive ? SYSHBR(ACTIVECAPTION) : SYSHBR(INACTIVECAPTION));
    }
}

/***************************************************************************\
* xxxDrawCaptionTemp
\***************************************************************************/
BOOL xxxDrawCaptionTemp(
    PWND            pwnd,
    HDC             hdc,
    LPRECT          lprc,
    HFONT           hFont,
    PCURSOR         pcursor,
    PUNICODE_STRING pstrText,
    UINT            flags)
{
    int    iOldMode;
    HBRUSH hbrFill;
    LONG   clrOldText;
    LONG   clrOldBk;
    BOOL   fItFit = TRUE;
    BOOL   fGradient = FALSE;
    SIZE   size;
    UINT   oldAlign;

    CheckLock(pwnd);

    if (lprc->right <= lprc->left) {
        return FALSE;
    }

    if (pwnd != NULL) {
        if (!pcursor               &&
            _HasCaptionIcon(pwnd)  &&
            !(flags & DC_SMALLCAP) &&
            TestWF(pwnd, WFSYSMENU)) {

            /*
             * Only get the icon if we can send messages AND the window has
             * a system menu.
             */
            pcursor = xxxGetWindowSmIcon(pwnd, (flags & DC_NOSENDMSG));
        }
    }

    /*
     * Set up the colors.
     */
    if (flags & DC_ACTIVE) {
        if (flags & DC_INBUTTON) {
            if (gpsi->BitCount < 8 ||
                    SYSRGB(3DHILIGHT) != SYSRGB(SCROLLBAR) ||
                    SYSRGB(3DHILIGHT) == SYSRGB(WINDOW)) {
                clrOldText = SYSRGB(3DFACE);
                clrOldBk   = SYSRGB(3DHILIGHT);
                hbrFill    = gpsi->hbrGray;
                iOldMode   = GreSetBkMode(hdc, TRANSPARENT);
            } else {
                clrOldText = SYSRGB(BTNTEXT);
                clrOldBk   = SYSRGB(3DHILIGHT);
                hbrFill    = SYSHBR(3DHILIGHT);
            }
        } else {
            clrOldText = SYSRGB(CAPTIONTEXT);
            clrOldBk   = SYSRGB(ACTIVECAPTION);
            hbrFill    = SYSHBR(ACTIVECAPTION);

            if (flags & DC_GRADIENT) {
                fGradient = TRUE;
                iOldMode = GreSetBkMode(hdc, TRANSPARENT);
            }
        }
    } else {
        if (flags & DC_INBUTTON) {
            clrOldText = SYSRGB(BTNTEXT);
            clrOldBk   = SYSRGB(3DFACE);
            hbrFill    = SYSHBR(3DFACE);
        } else {
            clrOldText = SYSRGB(INACTIVECAPTIONTEXT);
            clrOldBk   = SYSRGB(INACTIVECAPTION);
            hbrFill    = SYSHBR(INACTIVECAPTION);

            if (flags & DC_GRADIENT) {
                fGradient = TRUE;
                iOldMode = GreSetBkMode(hdc, TRANSPARENT);
            }
        }
    }


    /*
     * Set up drawing colors.
     */
    clrOldText = GreSetTextColor(hdc, clrOldText);
    clrOldBk   = GreSetBkColor(hdc, clrOldBk);

    if (pcursor && !(flags & DC_SMALLCAP)) {

        if (flags & DC_ICON) {
            /*
             * Preserve icon shape when BitBlitting it to a
             * mirrored DC. This way we don't violate copyright
             * issues on icons. [samera]
             */
            DWORD dwLayout=0L;
            if ((dwLayout=GreGetLayout(hdc)) & LAYOUT_RTL) {
                GreSetLayout(hdc, -1, dwLayout|LAYOUT_BITMAPORIENTATIONPRESERVED);
            }

            DrawCaptionIcon(hdc, lprc, pcursor, hbrFill, flags);

            /*
             * Restore the DC to its previous layout state.
             */
            if (dwLayout & LAYOUT_RTL) {
                GreSetLayout(hdc, -1, dwLayout);
            }
        } else {
            lprc->left += lprc->bottom - lprc->top;
        }
    }

    if (flags & DC_TEXT) {
        int            cch;
        HFONT          hfnOld;
        int            yCentered;
        WCHAR          szText[CCHTITLEMAX];
        UNICODE_STRING strTmp;
        PTHREADINFO ptiCurrent = PtiCurrentShared();

        /*
         * Get the text for the caption.
         */
        if (pstrText == NULL) {
            if (pwnd == NULL || (flags & DC_NOSENDMSG)) {
                if (pwnd && pwnd->strName.Length) {
                    cch = TextCopy(&pwnd->strName, szText, CCHTITLEMAX - 1);
                    strTmp.Length = (USHORT)(cch * sizeof(WCHAR));
                } else {
                    szText[0] = TEXT('\0');
                    cch = strTmp.Length = 0;
                }
            } else {
                cch = xxxGetWindowText(pwnd, szText, CCHTITLEMAX - 1);
                strTmp.Length = (USHORT)(cch * sizeof(WCHAR));
            }

            /*
             *  We don't use RtlInitUnicodeString() to initialize the string
             *  because it does a wstrlen() on the string, which is a waste
             *  since we already know its length.
             */
            strTmp.Buffer = szText;
            strTmp.MaximumLength = strTmp.Length + sizeof(UNICODE_NULL);
            pstrText = &strTmp;

        } else {
            cch = pstrText->Length / sizeof(WCHAR);
            UserAssert(pstrText->Length < pstrText->MaximumLength);
            UserAssert(pstrText->Buffer[cch] == 0);
        }

        /*
         * We need to set up the font first, in case we're centering
         * the caption. Fortunately, no text at all is uncommon.
         */
        if (hFont == NULL) {
            if (flags & DC_SMALLCAP) {
                hFont = ghSmCaptionFont;
                yCentered = gcySmCaptionFontChar;
            } else {
                hFont = gpsi->hCaptionFont;
                yCentered = gcyCaptionFontChar;
            }

            yCentered = (lprc->top + lprc->bottom - yCentered) / 2;

            hfnOld = GreSelectFont(hdc, hFont);
        } else {
            TEXTMETRICW tm;

            /*
             * UNCOMMON case:  only for control panel
             */
            hfnOld = GreSelectFont(hdc, hFont);

            if (!_GetTextMetricsW(hdc, &tm)) {
                RIPMSG0(RIP_WARNING, "xxxDrawCaptionTemp: _GetTextMetricsW Failed");
                tm.tmHeight = gpsi->tmSysFont.tmHeight;
            }
            yCentered = (lprc->top + lprc->bottom - tm.tmHeight) / 2;
        }

        /*
         * Draw text
         */
        if (fGradient) {
            FillCaptionGradient(hdc, lprc, flags & DC_ACTIVE);
        } else {
            FillRect(hdc, lprc, hbrFill);
        }

        if (hbrFill == gpsi->hbrGray) {
            GreSetTextColor(hdc, SYSRGB(BTNTEXT));
            GreSetBkColor(hdc, SYSRGB(GRAYTEXT));
        }

        /*
         * GDI doesn't do callbacks to the LPK.  If an LPK is installed
         * and we're not in thread cleanup mode, call the appropriate
         * client side GDI routines.
         */
        if (CALL_LPK(ptiCurrent)) {
            xxxClientGetTextExtentPointW(hdc, pstrText->Buffer, cch, &size);
        } else {
            GreGetTextExtentW(hdc, pstrText->Buffer, cch, &size, GGTE_WIN3_EXTENT);
        }

        if (pwnd && TestWF(pwnd, WEFRTLREADING)) {
            oldAlign = GreSetTextAlign(hdc, TA_RTLREADING | GreGetTextAlign(hdc));
        }
        if (!(flags & DC_CENTER) && (!cch || (size.cx <= (lprc->right - lprc->left - SYSMET(CXEDGE))))) {
            if (pwnd && TestWF(pwnd, WEFRIGHT)) {
                if (CALL_LPK(ptiCurrent)) {
                    xxxClientExtTextOutW(hdc, lprc->right - (size.cx + SYSMET(CXEDGE)), yCentered,
                        ETO_CLIPPED, lprc, pstrText->Buffer, cch, NULL);
                }
                else {
                    GreExtTextOutW(hdc, lprc->right - (size.cx + SYSMET(CXEDGE)), yCentered,
                       ETO_CLIPPED, lprc, pstrText->Buffer, cch, NULL);
                }
            } else {
                if (CALL_LPK(ptiCurrent)) {
                    xxxClientExtTextOutW(hdc, lprc->left + SYSMET(CXEDGE), yCentered,
                        ETO_CLIPPED, lprc, pstrText->Buffer, cch, NULL);
                }
                else {
                    GreExtTextOutW(hdc, lprc->left + SYSMET(CXEDGE), yCentered,
                        ETO_CLIPPED, lprc, pstrText->Buffer, cch, NULL);
                }
            }

#ifdef LAME_BUTTON

            if ((flags & DC_LAMEBUTTON) && pwnd != NULL && TestWF(pwnd, WEFLAMEBUTTON)) {
                GreSelectFont(hdc, ghLameFont);

                /*
                 * Make sure the Lame! text fits in the caption
                 */
                if (size.cx + gpsi->ncxLame + 2 * SYSMET(CXEDGE) <=
                    (lprc->right - lprc->left - SYSMET(CXEDGE))) {
                    int x;

                    if (pwnd && TestWF(pwnd, WEFRIGHT)) {
                        x = lprc->left + SYSMET(CXEDGE);
                    } else {
                        x = lprc->right - SYSMET(CXEDGE) - gpsi->ncxLame;
                    }

                    if (CALL_LPK(ptiCurrent)) {
                        xxxClientExtTextOutW(hdc,
                                             x,
                                             yCentered,
                                             ETO_CLIPPED,
                                             lprc,
                                             gpsi->gwszLame,
                                             wcslen(gpsi->gwszLame),
                                             NULL);
                    } else {
                        GreExtTextOutW(hdc,
                                       x,
                                       yCentered,
                                       ETO_CLIPPED,
                                       lprc,
                                       gpsi->gwszLame,
                                       wcslen(gpsi->gwszLame),
                                       NULL);
                    }
                }
            }
#endif
        } else {
            DRAWTEXTPARAMS dtp;
            UINT wSide;

            dtp.cbSize       = sizeof(DRAWTEXTPARAMS);
            dtp.iLeftMargin  = SYSMET(CXEDGE);
            dtp.iRightMargin = 0;

            wSide = (flags & DC_CENTER) ? DT_CENTER
                                        : ((pwnd && TestWF(pwnd, WEFRIGHT)) ? DT_RIGHT : 0);

            DrawTextEx(hdc,
                       pstrText->Buffer,
                       cch,
                       lprc,
                       DT_NOPREFIX | DT_END_ELLIPSIS | DT_SINGLELINE | DT_VCENTER |
                       wSide, &dtp);

            fItFit = FALSE;
        }

        if (pwnd && TestWF(pwnd, WEFRTLREADING)) {
            GreSetTextAlign(hdc, oldAlign);
        }

        if (hfnOld) {
            GreSelectFont(hdc, hfnOld);
        }
    }

    /*
     * Restore colors.
     */
    GreSetTextColor(hdc, clrOldText);
    GreSetBkColor(hdc, clrOldBk);

    if (hbrFill == gpsi->hbrGray) {
        GreSetBkMode(hdc, iOldMode);
    }

    return fItFit;
}

/***************************************************************************\
* xxxDrawCaptionBar
*
*
\***************************************************************************/

VOID xxxDrawCaptionBar(
    PWND pwnd,
    HDC  hdc,
    UINT wFlags)
{
    UINT   bm = OBI_CLOSE;
    RECT   rcWindow;
    HBRUSH hBrush = NULL;
    HBRUSH hCapBrush;
    int    colorBorder;
    UINT   wBtns;
    UINT   wCode;
    BOOL     fGradient = FALSE;

    CheckLock(pwnd);

    /*
     * If we're not currently showing on the screen, return.
     * NOTE
     * If you remove the IsVisible() check from DrawWindowFrame(), then
     * be careful to remove the NC_NOVISIBLE flag too.  This is a smallish
     * speed thing, so that we don't have to call IsVisible() twice on a
     * window.  DrawWindowFrame() already checks.
     */
    if (!(wFlags & DC_NOVISIBLE) && !IsVisible(pwnd)) {
        return;
    }

    /*
     * Clear this flag so we know the frame has been drawn.
     */
    ClearHungFlag(pwnd, WFREDRAWFRAMEIFHUNG);

    GetRect(pwnd, &rcWindow, GRECT_WINDOW | GRECT_WINDOWCOORDS);
    /*
     * The TestALPHA() will return false in ts connections because the
     * gbDisableAlpha flag will be set to true. So, we need to special case
     * for TS connections.  If this is a remote connection and the gradient
     * captions flag is set, ideally, we should force it to draw gradients.
     * However, for 8-bit color, enabling gradients looks ugly. We will fix
     * this for Blackcomb.
     *
     * The code should be something like this:
     * fGradient = IsRemoteConnection() && !8-bit color ?  TestEffectUP(GRADIENTCAPTIONS) : TestALPHA(GRADIENTCAPTIONS);
     */

    fGradient = TestALPHA(GRADIENTCAPTIONS);
    if (fGradient) {
        hCapBrush = (wFlags & DC_ACTIVE) ? SYSHBR(GRADIENTACTIVECAPTION) : SYSHBR(GRADIENTINACTIVECAPTION);
    } else {
        hCapBrush = (wFlags & DC_ACTIVE) ? SYSHBR(ACTIVECAPTION) : SYSHBR(INACTIVECAPTION);
    }

    wCode = 0;

    if (!xxxMNCanClose(pwnd)) {
        wCode |= NOCLOSE;
    }

    if (!TestWF(pwnd, WFMAXBOX)) {
        wCode |= NOMAX;
    } else if (TestWF(pwnd, WFMAXIMIZED)) {
        wCode |= MAX;
    }

    if (!TestWF(pwnd, WFMINBOX)) {
          wCode |= NOMIN;
    } else if (TestWF(pwnd, WFMINIMIZED)) {
          wCode |= MIN;
    }

    if (TestWF(pwnd, WFMINIMIZED)) {
        if (wFlags & DC_FRAME) {

            /*
             * Raised outer edge + border
             */
            DrawEdge(hdc, &rcWindow, EDGE_RAISED, (BF_RECT | BF_ADJUST));
            DrawFrame(hdc, &rcWindow, 1, DF_3DFACE);
            InflateRect(&rcWindow, -SYSMET(CXBORDER), -SYSMET(CYBORDER));

        } else {
            InflateRect(&rcWindow, -SYSMET(CXFIXEDFRAME), -SYSMET(CYFIXEDFRAME));
        }

        rcWindow.bottom = rcWindow.top + SYSMET(CYSIZE);

        hBrush = GreSelectBrush(hdc, hCapBrush);

    } else {
        /*
         * BOGUS
         * What color should we draw borders in?  The check is NOT simple.
         * At create time, we set the 3D bits.  NCCREATE will also
         * set them for listboxes, edit fields,e tc.
         */
        colorBorder = (TestWF(pwnd, WEFEDGEMASK) && !TestWF(pwnd, WFOLDUI)) ? COLOR_3DFACE : COLOR_WINDOWFRAME;

        /*
         * Draw the window frame.
         */
        if (wFlags & DC_FRAME) {
            /*
             * Window edge
             */
            if (TestWF(pwnd, WEFWINDOWEDGE)) {
                DrawEdge(hdc, &rcWindow, EDGE_RAISED, BF_RECT | BF_ADJUST);
            } else if (TestWF(pwnd, WEFSTATICEDGE)) {
                DrawEdge(hdc, &rcWindow, BDR_SUNKENOUTER, BF_RECT | BF_ADJUST);
            }

            /*
             * Size border
             */
            if (TestWF(pwnd, WFSIZEBOX)) {
                DrawFrame(hdc,
                          &rcWindow,
                          gpsi->gclBorder,
                          ((wFlags & DC_ACTIVE) ? DF_ACTIVEBORDER : DF_INACTIVEBORDER));

                InflateRect(&rcWindow,
                            -gpsi->gclBorder * SYSMET(CXBORDER),
                            -gpsi->gclBorder * SYSMET(CYBORDER));
            }

            /*
             * Normal border
             */
            if (TestWF(pwnd, WFBORDERMASK) || TestWF(pwnd, WEFDLGMODALFRAME)) {
                DrawFrame(hdc, &rcWindow, 1, (colorBorder << 3));
                InflateRect(&rcWindow, -SYSMET(CXBORDER), -SYSMET(CYBORDER));
            }
        } else {
            int cBorders;

            cBorders = GetWindowBorders(pwnd->style, pwnd->ExStyle, TRUE, FALSE);

            InflateRect(&rcWindow,
                        -cBorders * SYSMET(CXBORDER),
                        -cBorders * SYSMET(CYBORDER));
        }

        /*
         * Punt if the window doesn't have a caption currently showing on
         * screen.
         */
        if (!TestWF(pwnd, WFCPRESENT)) {
            return;
        }

        if (TestWF(pwnd, WEFTOOLWINDOW)) {
            wCode |= SMCAP;
            rcWindow.bottom = rcWindow.top + SYSMET(CYSMSIZE);
            bm = OBI_CLOSE_PAL;
        } else {
            rcWindow.bottom = rcWindow.top + SYSMET(CYSIZE);
        }

        {
            POLYPATBLT PolyData;

            PolyData.x         = rcWindow.left;
            PolyData.y         = rcWindow.bottom;
            PolyData.cx        = rcWindow.right - rcWindow.left;
            PolyData.cy        = SYSMET(CYBORDER);
            PolyData.BrClr.hbr = SYSHBRUSH(colorBorder);

            GrePolyPatBlt(hdc,PATCOPY,&PolyData,1,PPB_BRUSH);
        }

        GreSelectBrush(hdc, hCapBrush);
    }

    if (!TestWF(pwnd, WFSYSMENU) && TestWF(pwnd, WFWIN40COMPAT)) {
        goto JustDrawIt;
    }

    /*
     * New Rules:
     *  (1) The caption has a horz border beneath it separating it from the
     *      menu or client.
     *  (2) The caption text area has an edge of space on the left and right
     *      before the characters.
     *  (3) We account for the descent below the baseline of the caption char
     */
    wBtns = 1;

    if (!(wFlags & DC_BUTTONS)) {
        if ((!wCode) || (!(wCode & SMCAP) && ((wCode & NOSIZE) != NOSIZE))) {
            wBtns += 2;
        } else {
            rcWindow.right -= SYSMET(CXEDGE);

            if ((wCode == NOSIZE) && (wCode && TestWF(pwnd, WEFCONTEXTHELP))) {
                wBtns++;
            }
        }

        rcWindow.right -= wBtns * ((wCode & SMCAP) ? SYSMET(CXSMSIZE) : SYSMET(CXSIZE));

        goto JustDrawIt;
    }

    if (!wCode || (wCode == NOSIZE)) {
        POEMBITMAPINFO pOem = gpsi->oembmi + OBI_CAPBTNS;
        int            cx;

        cx = (wCode ? SYSMET(CXSIZE) + SYSMET(CXEDGE) : SYSMET(CXSIZE) * 3);

        if (!(wFlags & DC_ACTIVE))
            pOem += DOBI_CAPOFF;

        rcWindow.right -= cx;

        GreBitBlt(hdc,
                  rcWindow.right,
                  rcWindow.top,
                  cx,
                  pOem->cy,
                  HDCBITS(),
                  pOem->x + pOem->cx - SYSMET(CXSIZE) - cx,
                  pOem->y,
                  SRCCOPY,
                  0);

        if (wCode && TestWF(pwnd, WEFCONTEXTHELP)) {

            rcWindow.right -= SYSMET(CXSIZE) - SYSMET(CXEDGE);

            GreBitBlt(hdc,
                      rcWindow.right,
                      rcWindow.top,
                      SYSMET(CXSIZE),
                      pOem->cy,
                      HDCBITS(),
                      pOem->x + pOem->cx - SYSMET(CXSIZE),
                      pOem->y,
                      SRCCOPY,
                      0);
            /*
             * If the UI language is Hebrew we do not want to mirror the ? mark only
             * Then redraw ? with out the button frame.
             */
            if (HEBREW_UI_LANGID() && TestWF(pwnd, WEFLAYOUTRTL)) {
                GreBitBlt(hdc,
                          rcWindow.right-SYSMET(CXEDGE),
                          rcWindow.top+2,
                          SYSMET(CXSIZE)-SYSMET(CXEDGE)*2,
                          pOem->cy-4,
                          HDCBITS(),
                          pOem->x + pOem->cx - SYSMET(CXSIZE) + SYSMET(CXEDGE),
                          pOem->y + SYSMET(CXEDGE),
                          SRCCOPY|NOMIRRORBITMAP,
                          0);
            }
        }

        goto JustDrawIt;
    }

    /*
     * Draw the caption buttons
     */
    rcWindow.top    += SYSMET(CYEDGE);
    rcWindow.bottom -= SYSMET(CYEDGE);

    rcWindow.right -= SYSMET(CXEDGE);

    GrePatBlt(hdc,
              rcWindow.right,
              rcWindow.top,
              SYSMET(CXEDGE),
              rcWindow.bottom - rcWindow.top,
              PATCOPY);

    if (wCode & NOCLOSE) {
        bm += DOBI_INACTIVE;
    }

    rcWindow.right -= gpsi->oembmi[bm].cx;
    BitBltSysBmp(hdc, rcWindow.right, rcWindow.top, bm);

    if (!(wCode & SMCAP) && ((wCode & NOSIZE) != NOSIZE)) {
        rcWindow.right -= SYSMET(CXEDGE);

        GrePatBlt(hdc,
                  rcWindow.right,
                  rcWindow.top,
                  SYSMET(CXEDGE),
                  rcWindow.bottom - rcWindow.top,
                  PATCOPY);

        /*
         * Max Box.
         *
         * If window is maximized use the restore bitmap; otherwise use the
         * regular zoom bitmap.
         */
        bm = (wCode & MAX) ? OBI_RESTORE : ((wCode & NOMAX) ? OBI_ZOOM_I : OBI_ZOOM);
        rcWindow.right -= gpsi->oembmi[bm].cx;
        BitBltSysBmp(hdc, rcWindow.right, rcWindow.top, bm);

        /*
         * Min Box.
         */
        bm = (wCode & MIN) ? OBI_RESTORE : ((wCode & NOMIN) ? OBI_REDUCE_I : OBI_REDUCE);
        rcWindow.right -= gpsi->oembmi[bm].cx;
        BitBltSysBmp(hdc, rcWindow.right, rcWindow.top, bm);
        rcWindow.right -= SYSMET(CXEDGE);
        GrePatBlt(hdc,
                  rcWindow.right,
                  rcWindow.top,
                  SYSMET(CXEDGE),
                  rcWindow.bottom - rcWindow.top,
                  PATCOPY);

        wBtns += 2;
    }

    if ((wCode & (NOCLOSE | NOSIZE)) &&
        (!(wCode & SMCAP)) && TestWF(pwnd, WEFCONTEXTHELP)) {

        rcWindow.right -= SYSMET(CXEDGE);

        GrePatBlt(hdc,
                  rcWindow.right,
                  rcWindow.top,
                  SYSMET(CXEDGE),
                  rcWindow.bottom - rcWindow.top,
                  PATCOPY);


        bm = OBI_HELP;
        rcWindow.right -= gpsi->oembmi[bm].cx;
        BitBltSysBmp(hdc, rcWindow.right, rcWindow.top, bm);

        wBtns++;
    }

    rcWindow.top    -= SYSMET(CYEDGE);
    rcWindow.bottom += SYSMET(CYEDGE);

    wBtns *= (wCode & SMCAP) ? SYSMET(CXSMSIZE) : SYSMET(CXSIZE);

    {
        POLYPATBLT PolyData[2];

        PolyData[0].x         = rcWindow.right;
        PolyData[0].y         = rcWindow.top;
        PolyData[0].cx        = wBtns;
        PolyData[0].cy        = SYSMET(CYEDGE);
        PolyData[0].BrClr.hbr = NULL;

        PolyData[1].x         = rcWindow.right;
        PolyData[1].y         = rcWindow.bottom - SYSMET(CYEDGE);
        PolyData[1].cx        = wBtns;
        PolyData[1].cy        = SYSMET(CYEDGE);
        PolyData[1].BrClr.hbr = NULL;

        GrePolyPatBlt(hdc,PATCOPY,&PolyData[0],2,PPB_BRUSH);
    }

    /*
     * We're going to release this DC -- we don't need to bother reselecting
     * in the old brush.
     */
    if (hBrush) {
        GreSelectBrush(hdc, hBrush);
    }

JustDrawIt:

    /*
     * Call DrawCaption only if we need to draw the icon or the text.
     *
     * If the text gets truncated, set the window flag for the caption
     * tooltip.
     */
    if (wFlags & (DC_TEXT | DC_ICON)) {

#ifdef LAME_BUTTON
        wFlags |= DC_LAMEBUTTON;
#endif // LAME_BUTTON

        /*
         * The TestALPHA() will return false in ts connections because the
         * gbDisableAlpha flag will be set to true. So, we need to special
         * case for TS connections. If this is a remote connection and the
         * gradient captions flag is set, ideally, we should force it to
         * draw gradients. However, for 8-bit color, enabling gradients
         * looks ugly. We will fix this for Blackcomb.
         */
        if (!xxxDrawCaptionTemp(pwnd,
                               hdc,
                               &rcWindow,
                               NULL,
                               NULL,
                               NULL,
                               wFlags | ((wCode & SMCAP)  ? DC_SMALLCAP : 0) |
                               (fGradient? DC_GRADIENT : 0))) {
            SetWF(pwnd, WEFTRUNCATEDCAPTION);
        } else {
            ClrWF(pwnd, WEFTRUNCATEDCAPTION);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kernel\class.c ===
/****************************** Module Header ******************************\
* Module Name: class.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* This module contains RegisterClass and the related window class management
* functions.
*
* History:
* 10-16-90 DarrinM      Ported functions from Win 3.0 sources.
* 02-01-91 mikeke       Added Revalidation code (None)
* 04-08-91 DarrinM      C-S-ized and removed global/public class support.
\***************************************************************************/

#include "precomp.h"
#pragma hdrstop

/*
 * These arrays are used by Get/SetClassWord/Long.
 *
 * INDEX_OFFSET must refer to the first entry of afClassDWord[]
 */
#define INDEX_OFFSET GCLP_HICONSM
CONST BYTE afClassDWord[-INDEX_OFFSET] = {
    FIELD_SIZE(CLS, spicnSm),          // GCL_HICONSM       (-34)
    0,
    FIELD_SIZE(CLS, atomNVClassName),  // GCW_ATOM          (-32)
    0,
    0,
    0,
    0,
    0,
    FIELD_SIZE(CLS, style),            // GCL_STYLE         (-26)
    0,
    FIELD_SIZE(CLS, lpfnWndProc),      // GCL_WNDPROC       (-24)
    0,
    0,
    0,
    FIELD_SIZE(CLS, cbclsExtra),       // GCL_CBCLSEXTRA    (-20)
    0,
    FIELD_SIZE(CLS, cbwndExtra),       // GCL_CBWNDEXTRA    (-18)
    0,
    FIELD_SIZE(CLS, hModule),          // GCL_HMODULE       (-16)
    0,
    FIELD_SIZE(CLS, spicn),            // GCL_HICON         (-14)
    0,
    FIELD_SIZE(CLS, spcur),            // GCL_HCURSOR       (-12)
    0,
    FIELD_SIZE(CLS, hbrBackground),    // GCL_HBRBACKGROUND (-10)
    0,
    FIELD_SIZE(CLS, lpszMenuName),     // GCL_HMENUNAME      (-8)
    0,
    0,
    0,
    0,
    0,
    0,
    0
};

CONST BYTE aiClassOffset[-INDEX_OFFSET] = {
    FIELD_OFFSET(CLS, spicnSm),         // GCL_HICONSM
    0,
    FIELD_OFFSET(CLS, atomNVClassName),   // GCW_ATOM
    0,
    0,
    0,
    0,
    0,
    FIELD_OFFSET(CLS, style),           // GCL_STYLE
    0,
    FIELD_OFFSET(CLS, lpfnWndProc),     // GCL_WNDPROC
    0,
    0,
    0,
    FIELD_OFFSET(CLS, cbclsExtra),      // GCL_CBCLSEXTRA
    0,
    FIELD_OFFSET(CLS, cbwndExtra),      // GCL_CBWNDEXTRA
    0,
    FIELD_OFFSET(CLS, hModule),         // GCL_HMODULE
    0,
    FIELD_OFFSET(CLS, spicn),           // GCL_HICON
    0,
    FIELD_OFFSET(CLS, spcur),           // GCL_HCURSOR
    0,
    FIELD_OFFSET(CLS, hbrBackground),   // GCL_HBRBACKGROUND
    0,
    FIELD_OFFSET(CLS, lpszMenuName),    // GCL_MENUNAME
    0,
    0,
    0,
    0,
    0,
    0,
    0
};

/***************************************************************************\
* _RegisterClassEx (API)
*
* This stub calls InternalRegisterClass to do its work and then does some
* additional work to save a pointer to the client-side menu name string.
* The menu string is returned by _GetClassInfo so the client can fix up
* a valid entry for the WNDCLASS lpszMenuName field.
*
* History:
* 04-26-91 DarrinM      Created.
\***************************************************************************/
ATOM _RegisterClassEx(
    LPWNDCLASSVEREX cczpwc,
    PCLSMENUNAME pcmn,
    WORD fnid,
    DWORD dwFlags,
    LPDWORD pdwWOW)
{
    PCLS pcls;
    PTHREADINFO  ptiCurrent = PtiCurrent();

    /*
     * NOTE -- lpszClassName and lpszMenuName in the wndclass may be client-side
     *         pointers. Use of those fields must be protected in try blocks.
     */

    /*
     * Convert a possible CallProc Handle into a real address. They may
     * have kept the CallProc Handle from some previous mixed GetClassinfo
     * or SetWindowLong.
     */
    if (ISCPDTAG(cczpwc->lpfnWndProc)) {
        PCALLPROCDATA pCPD;
        if (pCPD = HMValidateHandleNoRip((HANDLE)cczpwc->lpfnWndProc, TYPE_CALLPROC)) {
            cczpwc->lpfnWndProc = (WNDPROC)pCPD->pfnClientPrevious;
        }
    }

    pcls = InternalRegisterClassEx(cczpwc, fnid, dwFlags | ((ptiCurrent->TIF_flags & TIF_16BIT)? CSF_WOWCLASS : 0));
    if (pcls != NULL) {

        pcls->lpszClientUnicodeMenuName = pcmn->pwszClientUnicodeMenuName;
        pcls->lpszClientAnsiMenuName = pcmn->pszClientAnsiMenuName;

        /*
         * copy 5 WOW dwords.
         */
        if (pdwWOW && (ptiCurrent->TIF_flags & TIF_16BIT)) {
            RtlCopyMemory (PWCFromPCLS(pcls), pdwWOW, sizeof(WC));
        }

        if ((ptiCurrent->TIF_flags & TIF_16BIT) && ptiCurrent->ptdb) {
            pcls->hTaskWow = ptiCurrent->ptdb->hTaskWow;
        } else {
            pcls->hTaskWow = 0;
        }

        /*
         * For some (presumably good) reason Win 3.1 changed RegisterClass
         * to return the classes classname atom.
         */
        return pcls->atomNVClassName;
    } else {
        return 0;
    }
}


/***************************************************************************\
* ClassAlloc
* ClassFree
*
* Generic allocation routines that discriminate between desktop heap
* and pool.
*
* History:
* 08-07-95 JimA         Created
\***************************************************************************/

PVOID ClassAlloc(
    PDESKTOP pdesk,
    DWORD cbAlloc,
    ULONG tag)
{
    PVOID pvalloc;

    if (pdesk) {
        /*
         * NTRAID#NTBUG9-411175-2001/06/06-jasonsch.
         */
        pvalloc = DesktopAllocAlways(pdesk, cbAlloc, tag);
    } else {
        pvalloc = UserAllocPoolWithQuotaZInit(cbAlloc, TAG_CLASS);
    }

    return pvalloc;
}

VOID ClassFree(
    PDESKTOP pdesk,
    PVOID pvfree)
{
    if (pdesk != NULL) {
        DesktopFree(pdesk, pvfree);
    } else {
        UserFreePool(pvfree);
    }
}

/***************************************************************************\
* ValidateAndLockCursor
*
* Win95 comaptible validation
*
* History:
* 12-19-95 GerardoB     Created
\***************************************************************************/
BOOL ValidateAndLockCursor(
    PCURSOR *ppcursor,
    BOOL fIs40Compat)
{
    PCURSOR pcur;

    if (*ppcursor == NULL) {
        return TRUE;
    }

    pcur = HMValidateHandleNoSecure(*ppcursor, TYPE_CURSOR);
    if (pcur == NULL) {
        RIPMSGF1(RIP_WARNING,
                 "Invalid Cursor or Icon: 0x%p",
                 *ppcursor);
        if (fIs40Compat) {
            RIPERR0(ERROR_INVALID_PARAMETER,
                    RIP_VERBOSE,
                    "RegisterClass: Invalid Parameter");
            return FALSE;
        }
    }

    *ppcursor = NULL;
    Lock(ppcursor, pcur);
    return TRUE;
}

/***************************************************************************\
* InternalRegisterClass
*
* This API is called by applications or the system to register private or
* global (public) window classes. If a class with the same name already
* exists the call will fail, except in the special case where an application
* registers a private class with the same name as a global class. In this
* case the private class supercedes the global class for that application.
*
* History:
* 10-15-90 DarrinM      Ported from Win 3.0 sources.
\***************************************************************************/
PCLS InternalRegisterClassEx(
    LPWNDCLASSVEREX cczlpwndcls,
    WORD fnid,
    DWORD CSF_flags)
{
    BOOL fIs40Compat;
    ULONG_PTR dwT;
    PCLS pcls;
    LPWSTR pszT1;
    ATOM atomT;
    PTHREADINFO ptiCurrent;
    HANDLE hModule;
    PDESKTOP pdesk;
    ULONG cch;
    UNICODE_STRING UString;
    ANSI_STRING AString;

    /*
     * NOTE -- lpszClassName and lpszMenuName in the wndclass may be client-side
     *         pointers. Use of those fields must be protected in try blocks.
     */
    CheckCritIn();

    ptiCurrent = PtiCurrent();

    /*
     * Don't allow 4.0 apps to register a class using hModuleWin
     * LATER GerardoB: Our client side classes use hmodUser (USER32) while
     *  our server side classes use hWinInstance (WIN32K). We should change
     * CreateThreadInfo and LW_RegisterWindows so all classes use hModUser.
     */
    hModule = cczlpwndcls->hInstance;
     if (!(CSF_flags & (CSF_SYSTEMCLASS | CSF_SERVERSIDEPROC))
            && (hModule == hModuleWin)
            && (LOWORD(ptiCurrent->dwExpWinVer) >= VER40)) {

         RIPERR0(ERROR_INVALID_PARAMETER, RIP_WARNING, "InternalRegisterClassEx: Invalid hInstance (Cannot use system's hInstance)");
         return NULL;
     }


    /*
     * As of NT 4.0 we no longer honor CS_BYTEALIGNCLIENT or CS_BYTEALIGNWINDOW
     */
    if (cczlpwndcls->style & (CS_BYTEALIGNCLIENT | CS_BYTEALIGNWINDOW)) {
        RIPMSG0(RIP_VERBOSE, "CS_BYTEALIGNCLIENT and CS_BYTEALIGNWINDOW styles no longer honored.");
    }

    /*
     * Does this class exist as a private class?  If so, fail.
     */
    atomT = FindClassAtom(cczlpwndcls->lpszClassNameVer);

    if (atomT != 0 && !(CSF_flags & CSF_SERVERSIDEPROC)) {
        /*
         * First check private classes. If already exists, return error.
         */
        if (_InnerGetClassPtr(atomT, &ptiCurrent->ppi->pclsPrivateList,
                hModule) != NULL) {
            RIPERR1(ERROR_CLASS_ALREADY_EXISTS, RIP_VERBOSE, "RegisterClass: Class already exists %lx", (DWORD)atomT);
            return NULL;
        }

        /*
         * Now only check public classes if CS_GLOBALCLASS is set. If it
         * isn't set, then this will allow an application to re-register
         * a private class to take precedence over a public class.
         */
        if (cczlpwndcls->style & CS_GLOBALCLASS) {
            if (_InnerGetClassPtr(atomT, &ptiCurrent->ppi->pclsPublicList, NULL) != NULL) {
                RIPERR0(ERROR_CLASS_ALREADY_EXISTS, RIP_VERBOSE, "RegisterClass: Global Class already exists");
                return NULL;
            }
        }
    }

    /*
     * Alloc space for the class.
     */
    if (ptiCurrent->TIF_flags & TIF_SYSTEMTHREAD) {
        pdesk = NULL;
    } else {
        pdesk = ptiCurrent->rpdesk;
    }
    pcls = (PCLS)ClassAlloc(pdesk, sizeof(CLS) + cczlpwndcls->cbClsExtra + (CSF_flags & CSF_WOWCLASS ? sizeof(WC):0), DTAG_CLASS);
    if (pcls == NULL) {
        return NULL;
    }

    LockDesktop(&pcls->rpdeskParent, pdesk, LDL_CLS_DESKPARENT1, (ULONG_PTR)pcls);
    pcls->pclsBase = pcls;

    /*
     * Copy over the shared part of the class structure.
     */
    UserAssert(FIELD_OFFSET(WNDCLASSEX, style) == FIELD_OFFSET(COMMON_WNDCLASS, style));
    RtlCopyMemory(&pcls->style, &(cczlpwndcls->style),
                  sizeof(COMMON_WNDCLASS) - FIELD_OFFSET(COMMON_WNDCLASS, style));

    /*
     * Copy CSF_SERVERSIDEPROC, CSF_ANSIPROC (etc.) flags
     */
    pcls->CSF_flags = LOWORD(CSF_flags);
    pcls->fnid = fnid;
    if (fnid) {
        CBFNID(fnid) = (WORD)(pcls->cbwndExtra + sizeof(WND));

#ifndef LAZY_CLASS_INIT
        if (!(pcls->CSF_flags & CSF_SERVERSIDEPROC) && ptiCurrent->pClientInfo != NULL) {
            /*
             * Clear the bit so new threads in this process
             * won't bother to reregister the client-side USER classes.
             */
            try {
                ptiCurrent->pClientInfo->CI_flags &= ~CI_REGISTERCLASSES;
            } except (W32ExceptionHandler(TRUE, RIP_WARNING)) {
              goto ValidateError1;
            }
        }
#endif
    }

    /*
     * If this wndproc happens to be a client wndproc stub for a server
     * wndproc, then remember the server wndproc! This should be rare: why
     * would an application re-register a class that isn't "subclassed"?
     */
    if (!(pcls->CSF_flags & CSF_SERVERSIDEPROC)) {
        dwT = MapClientToServerPfn((ULONG_PTR)pcls->lpfnWndProc);
        if (dwT != 0) {
            pcls->CSF_flags |= CSF_SERVERSIDEPROC;
            pcls->CSF_flags &= ~CSF_ANSIPROC;
            pcls->lpfnWndProc = (WNDPROC_PWND)dwT;
        }
    }

    /*
     * Win95 compatible validation.
     *
     * hbrBackground was validated by GDI in the client side
     * NULL hInstances are mapped to GetModuleHandle(NULL) in the client
     * side
     */

    fIs40Compat = (CSF_flags & CSF_WIN40COMPAT) != 0;

    if (!ValidateAndLockCursor(&pcls->spcur, fIs40Compat)) {
        goto ValidateError1;
    }

    if (!ValidateAndLockCursor(&pcls->spicn, fIs40Compat)) {
        goto ValidateError2;
    }

    if (!ValidateAndLockCursor(&pcls->spicnSm, fIs40Compat)) {
        goto ValidateError3;
    }

    /*
     * Add the class name to the atom table.
     */
    if (IS_PTR(cczlpwndcls->lpszClassName)) {
        atomT = UserAddAtom(cczlpwndcls->lpszClassName, FALSE);
    } else {
        atomT = PTR_TO_ID(cczlpwndcls->lpszClassName);
    }

    if (atomT == 0) {
        goto AtomError1;
    }
    pcls->atomNVClassName = atomT;

    if (IS_PTR(cczlpwndcls->lpszClassNameVer)) {
        atomT = UserAddAtom(cczlpwndcls->lpszClassNameVer, FALSE);
    } else {
        atomT = PTR_TO_ID(cczlpwndcls->lpszClassNameVer);
    }

    if (atomT == 0) {
        goto AtomError2;
    }
    pcls->atomClassName = atomT;

    /*
     * Make an ANSI version of the class name to optimize
     * GetClassNameA for WOW.
     */
    if (IS_PTR(cczlpwndcls->lpszClassName)) {
        try {
            RtlInitUnicodeString(&UString, cczlpwndcls->lpszClassName);
        } except (W32ExceptionHandler(FALSE, RIP_WARNING)) {
            goto MemError2;
        }
#ifdef FE_SB // InternalRegisterClassEx()
        cch = UString.Length + 1;
#else
        cch = UString.Length / sizeof(WCHAR) + 1;
#endif // FE_SB
    } else {
        cch = 7; // 1 char for '#', 5 for '65536'.
    }

    /*
     * Allocate the ANSI name buffer and convert the unicode name
     * to ANSI.
     */
    pcls->lpszAnsiClassName = (LPSTR)ClassAlloc(pdesk, cch, DTAG_TEXT);
    if (pcls->lpszAnsiClassName == NULL) {
        goto MemError2;
    }

    /*
     * Form the ANSI class name.
     */
    if (IS_PTR(cczlpwndcls->lpszClassName)) {

        /*
         * Class name is a string.
         */
        AString.Length = 0;
        AString.MaximumLength = (USHORT)cch;
        AString.Buffer = pcls->lpszAnsiClassName;
        try {
            RtlUnicodeStringToAnsiString(&AString, &UString, FALSE);
        } except (W32ExceptionHandler(FALSE, RIP_WARNING)) {
            goto MemError3;
        }
    } else {

        /*
         * Class name is an integer atom.
         */
        pcls->lpszAnsiClassName[0] = L'#';
        RtlIntegerToChar(PTR_TO_ID(cczlpwndcls->lpszClassName), 10, cch - 1,
                &pcls->lpszAnsiClassName[1]);
    }

    /*
     * Make local copy of menu name.
     */
    pszT1 = pcls->lpszMenuName;

    if (pszT1 != NULL) {
        if (IS_PTR(pszT1)) {
            try {
                RtlInitUnicodeString(&UString, pszT1);
            } except (W32ExceptionHandler(FALSE, RIP_WARNING)) {
                goto MemError3;
            }
            if (UString.Length == 0) {

                /*
                 * app passed an empty string for the name
                 */
                pcls->lpszMenuName = NULL;
            } else {
                UNICODE_STRING strMenuName;

                /*
                 * Alloc space for the Menu Name.
                 */
                if (!AllocateUnicodeString(&strMenuName, &UString)) {
                    /*
                     * The unlock call is delayed after the free such that if this is
                     * the last reference on the desktop, the desktop heap is not 
                     * destroyed before we free the objects.
                     */
                    PDESKTOP rpdesk;
MemError3:
                    ClassFree(pdesk, pcls->lpszAnsiClassName);
MemError2:
                    UserDeleteAtom(pcls->atomClassName);
AtomError2:
                    UserDeleteAtom(pcls->atomNVClassName);
AtomError1:
                    Unlock(&pcls->spicnSm);
ValidateError3:
                    Unlock(&pcls->spicn);
ValidateError2:
                    Unlock(&pcls->spcur);
ValidateError1:
                    rpdesk = pcls->rpdeskParent;
                    pcls->rpdeskParent = NULL;
                    ClassFree(pdesk, pcls);
                    /*
                     * NOTE: Using pobj after freeing the object is not a
                     * problem because UnlockDesktop uses the value for
                     * tracking and doesn't dereference the pointer. If this
                     * ever changes we'll get a BC.
                     */
                    UnlockDesktop(&rpdesk, LDU_CLS_DESKPARENT1, (ULONG_PTR)pcls);
                    return NULL;
                }

                pcls->lpszMenuName = strMenuName.Buffer;
            }
        }
    }

    if ((CSF_flags & CSF_SERVERSIDEPROC) || (pcls->style & CS_GLOBALCLASS)) {
        if (pcls->CSF_flags & CSF_SYSTEMCLASS) {
            pcls->pclsNext = gpclsList;
            gpclsList = pcls;
        } else {
            pcls->pclsNext = ptiCurrent->ppi->pclsPublicList;
            ptiCurrent->ppi->pclsPublicList = pcls;
        }
    } else {
        pcls->pclsNext = ptiCurrent->ppi->pclsPrivateList;
        ptiCurrent->ppi->pclsPrivateList = pcls;
    }

    return pcls;
}


/***************************************************************************\
* _UnregisterClass (API)
*
* This API function is used to unregister a window class previously
* registered by the Application.
*
* Returns:
*     TRUE  if successful.
*     FALSE otherwise.
*
* NOTE:
*  1. The class name must have been registered earlier by this client
*     through RegisterClass().
*  2. The class name should not be one of the predefined control classes.
*  3. All windows created with this class must be destroyed before calling
*     this function.
*
* History:
* 10-15-90 DarrinM      Ported from Win 3.0 sources.
* 03-09-94 BradG        Fixed bug when ATOM was passed in
\***************************************************************************/

BOOL _UnregisterClass(
    LPCWSTR ccxlpszClassName,
    HANDLE hModule,
    PCLSMENUNAME pcmn)
{
    ATOM atomT;
    PPCLS ppcls;
    PTHREADINFO ptiCurrent;

    CheckCritIn();

    ptiCurrent = PtiCurrent();

    /*
     * Check whether the given ClassName is already registered by the
     * Application with the given handle.
     * Return error, if either the Class does not exist or it does not
     * belong to the calling process.
     */

    /*
     * bradg (3/9/95) - Must first check to see if an ATOM has been passed
     */
    atomT = FindClassAtom(ccxlpszClassName);
    ppcls = _InnerGetClassPtr(atomT, &ptiCurrent->ppi->pclsPrivateList, hModule);
    if (ppcls == NULL) {
        /*
         * Maybe this is a public class.
         */
        ppcls = _InnerGetClassPtr(atomT, &ptiCurrent->ppi->pclsPublicList, NULL);
        if (ppcls == NULL) {
            RIPERR1(ERROR_CLASS_DOES_NOT_EXIST, RIP_WARNING, "UnregisterClass: Class does not exist; atom=%lX", (DWORD)atomT);
            return FALSE;
        }
    }

    /*
     * If any windows created with this class still exist return an error.
     */
    if ((*ppcls)->cWndReferenceCount != 0) {
        RIPERR0(ERROR_CLASS_HAS_WINDOWS, RIP_WARNING, "UnregisterClass: Class still has window");
        return FALSE;
    }

    /*
     * Return client side pointers for cleanup
     */
    pcmn->pszClientAnsiMenuName = (*ppcls)->lpszClientAnsiMenuName;
    pcmn->pwszClientUnicodeMenuName = (*ppcls)->lpszClientUnicodeMenuName;
    pcmn->pusMenuName = NULL;

    /*
     * Release the Window class and related information.
     */
    DestroyClass(ppcls);

    return TRUE;
}


PCLS _GetWOWClass(
    HANDLE hModule,
    LPCWSTR ccxlpszClassName)
{
    PCLS pcls;
    PPCLS ppcls = NULL;
    ATOM atomT;
    PTHREADINFO ptiCurrent;

    CheckCritInShared();

    ptiCurrent = PtiCurrentShared();

    /*
     * Is this class registered as a private class?
     */
    atomT = UserFindAtom(ccxlpszClassName);
    if (atomT != 0) {
        ppcls = GetClassPtr(atomT, ptiCurrent->ppi, hModule);
    }

    if (ppcls == NULL) {
        RIPERR0(ERROR_CLASS_DOES_NOT_EXIST, RIP_VERBOSE, "");
        return NULL;
    }

    pcls = *ppcls;

    if (ptiCurrent->rpdesk != pcls->rpdeskParent) {
        pcls = pcls->pclsClone;
        while (pcls != NULL) {
            if (ptiCurrent->rpdesk == pcls->rpdeskParent) {
                goto Done;
            }
            pcls = pcls->pclsNext;
        }
        RIPERR0(ERROR_CLASS_DOES_NOT_EXIST, RIP_VERBOSE, "");
        return NULL;
    }
Done:
    return pcls;
}

/***************************************************************************\
* GetClassInfo (API)
*
* This function checks if the given class name is registered already. If the
* class is not found, it returns 0;  If the class is found, then all the
* relevant information from the CLS structure is copied into the WNDCLASS
* structure pointed to by the lpWndCls argument. If successful, it returns
* the class name atom
*
* NOTE: hmod was used to distinguish between different task's public classes.
* Now that public classes are gone, hmod isn't used anymore. We just search
* the applications private class for a match and if none is found we search
* the system classes.
*
* History:
* 10-15-90 DarrinM      Ported from Win 3.0 sources.
* 04-08-91 DarrinM      Removed public classes.
* 04-26-91 DarrinM      Streamlined to work with the client-side API.
* 03-09-95 BradG        Fixed bug when ATOM was passed in.
\***************************************************************************/
ATOM _GetClassInfoEx(
    HANDLE hModule,
    LPCWSTR ccxlpszClassName,
    LPWNDCLASSEX pwc,
    LPWSTR *ppszMenuName,
    BOOL bAnsi)
{
    PCLS pcls;
    PPCLS ppcls;
    ATOM atomT;
    PTHREADINFO ptiCurrent;
    DWORD dwCPDType = 0;

    CheckCritIn();

    ptiCurrent = PtiCurrent();

    /*
     * These are done first so if we don't find the class, and therefore
     * fail, the return thank won't try to copy back these (nonexistant)
     * strings.
     */
    pwc->lpszMenuName = NULL;
    pwc->lpszClassName = NULL;

    /*
     * Must first check to see if an ATOM has been passed.
     */
    atomT = FindClassAtom(ccxlpszClassName);

    /*
     * Windows 3.1 does not perform the class search with
     * a null hModule. If an application supplies a NULL
     * hModule, they search on hModuleWin instead.
     */

    if (hModule == NULL) {
        hModule = hModClient;
    }

    ppcls = GetClassPtr(atomT, ptiCurrent->ppi, hModule);


    if (ppcls == NULL) {
        RIPERR0(ERROR_CLASS_DOES_NOT_EXIST, RIP_VERBOSE, "GetClassInfo: Class does not exist");
        return 0;
    }

    pcls = *ppcls;

    /*
     * Copy all the fields common to CLS and WNDCLASS structures except
     * the lpszMenuName and lpszClassName which will be filled in by the
     * client-side piece of GetClassInfo.
     */

     /*
      * Return public bits only.
      */
    pwc->style = pcls->style & CS_VALID;

    /*
     * Corel Depth 6.0 calls GetClassInfo (COMBOBOX) and registers a class
     * using the same name and style bits. This works OK on Win95 because
     * their "system" (combo, edit, etc) classes are not CS_GLOBALCLASS.
     * So we've got to mask this bit out for our classes.
     */

     /*
     * Bug 17998. If the app is 32bit and WinVer is less than 4.0 don't mask
     * out the CS_GLOBALCLASS bit.
     */

    if ((pcls->fnid != 0) &&
            ((LOWORD(ptiCurrent->dwExpWinVer) >= VER40) || (ptiCurrent->TIF_flags & TIF_16BIT)) ) {
        pwc->style &= ~CS_GLOBALCLASS;
    }


    pwc->cbClsExtra = pcls->cbclsExtra;
    pwc->cbWndExtra = pcls->cbwndExtra;

    /*
     * Stop 32-bit apps from inadvertantly using hModuleWin as their hInstance
     * when they register a window class.
     */
    if (LOWORD(ptiCurrent->dwExpWinVer) >= VER40) {
        /*
         * This is actually, Win95 behavior -- the USER.EXE hModule gets thunked
         * to NULL on the way out of the 16->32 bit thunk. Note -- if we ever
         * need to support 16-bit 4.0 apps (shudder), this may need to change.
         */
        if (hModule == hModClient) {
            pwc->hInstance = NULL;
        } else {
            pwc->hInstance = hModule;
        }
    } else {
        /*
         * Win NT 3.1/3.51 returned the hInstance from the class. Note that this
         * is incompatible with Win 3.1. WoW has hacks for 16-bit apps.
         */

        if ((pcls->hModule == hModuleWin) || (pcls->hModule == hModClient)) {
            pwc->hInstance = hModClient;
        } else {
            pwc->hInstance = pcls->hModule;
        }
    }

    pwc->hIcon = PtoH(pcls->spicn);
    pwc->hCursor = PtoH(pcls->spcur);
    pwc->hbrBackground = pcls->hbrBackground;

    /*
     * Need to hide the small icon if it's USER created.
     */
    if (pcls->spicnSm && (pcls->spicnSm->CURSORF_flags & CURSORF_SECRET)) {
        pwc->hIconSm = NULL;
    } else {
        pwc->hIconSm = PtoH(pcls->spicnSm);
    }

    /*
     * If its a server proc then map it to a client proc. If not we may have
     * to create a CPD.
     */
    if (pcls->CSF_flags & CSF_SERVERSIDEPROC) {
        pwc->lpfnWndProc =
                (WNDPROC)MapServerToClientPfn((ULONG_PTR)pcls->lpfnWndProc, bAnsi);
    } else {
        pwc->lpfnWndProc = (WNDPROC)MapClientNeuterToClientPfn(pcls, 0, bAnsi);

        /*
         * If the client mapping didn't change the window proc then see if
         * we need a callproc handle.
         */
        if (pwc->lpfnWndProc == (WNDPROC)pcls->lpfnWndProc) {
            /*
             * Need to return a CallProc handle if there is an Ansi/Unicode mismatch
             */
            if (bAnsi != !!(pcls->CSF_flags & CSF_ANSIPROC)) {
                dwCPDType |= bAnsi ? CPD_ANSI_TO_UNICODE : CPD_UNICODE_TO_ANSI;
            }
        }
    }

    if (dwCPDType) {
        ULONG_PTR dwCPD;

        dwCPD = GetCPD(pcls, dwCPDType | CPD_CLASS, (ULONG_PTR)pwc->lpfnWndProc);

        if (dwCPD) {
            pwc->lpfnWndProc = (WNDPROC)dwCPD;
        } else {
            RIPMSG0(RIP_WARNING, "GetClassInfo unable to alloc CPD returning handle");
        }
    }

    /*
     * Return the stashed pointer to the client-side menu name string.
     */
    if (bAnsi) {
        *ppszMenuName = (LPWSTR)pcls->lpszClientAnsiMenuName;
    } else {
        *ppszMenuName = pcls->lpszClientUnicodeMenuName;
    }
    return pcls->atomNVClassName;
}


/***************************************************************************\
* _SetClassWord (API)
*
* Set a class word. Positive index values set application class words
* while negative index values set system class words. The negative
* indices are published in WINDOWS.H.
*
* History:
* 10-16-90 darrinm      Wrote.
\***************************************************************************/
WORD _SetClassWord(
    PWND pwnd,
    int index,
    WORD value)
{
    WORD wOld;
    WORD UNALIGNED *pw;
    PCLS pcls;

    CheckCritIn();

    if (GETPTI(pwnd)->ppi != PpiCurrent()) {
        RIPERR1(ERROR_ACCESS_DENIED, RIP_WARNING, "SetClassWord: different process: index 0x%lx", index);
        return 0;
    }

    pcls = pwnd->pcls->pclsBase;
    if ((index < 0) || ((UINT)index + sizeof(WORD) > (UINT)pcls->cbclsExtra)) {
        RIPERR1(ERROR_INVALID_INDEX,
                RIP_WARNING,
                "SetClassWord: invalid index 0x%x", index);
        return 0;
    } else {
        pw = (WORD UNALIGNED *)((BYTE *)(pcls + 1) + index);
        wOld = *pw;
        *pw = value;
        pcls = pcls->pclsClone;
        while (pcls != NULL) {
            pw = (WORD UNALIGNED *)((BYTE *)(pcls + 1) + index);
            *pw = value;
            pcls = pcls->pclsNext;
        }
        return wOld;
    }
}


/***************************************************************************\
* xxxSetClassLong (API)
*
* Set a class long. Positive index values set application class longs
* while negative index values set system class longs. The negative
* indices are published in WINDOWS.H.
*
* History:
* 10-16-90 darrinm      Wrote.
\***************************************************************************/
ULONG_PTR xxxSetClassLongPtr(
    PWND pwnd,
    int index,
    ULONG_PTR value,
    BOOL bAnsi)
{
    ULONG_PTR dwOld;
    PCLS pcls;

    CheckLock(pwnd);
    CheckCritIn();

    if (GETPTI(pwnd)->ppi != PpiCurrent()) {
        RIPERR1(ERROR_ACCESS_DENIED, RIP_WARNING, "SetClassLongPtr: different process: index 0x%lx", index);
        return 0;
    }

    if (index < 0) {
        return xxxSetClassData(pwnd, index, value, bAnsi);
    } else {
        pcls = pwnd->pcls->pclsBase;
        if ((UINT)index + sizeof(ULONG_PTR) > (UINT)pcls->cbclsExtra) {
            RIPERR1(ERROR_INVALID_INDEX,
                    RIP_WARNING,
                    "SetClassLongPtr: invalid index 0x%x", index);
            return 0;
        } else {
            ULONG_PTR UNALIGNED *pudw;
            pudw = (ULONG_PTR UNALIGNED *)((BYTE *)(pcls + 1) + index);
            dwOld = *pudw;
            *pudw = value;
            pcls = pcls->pclsClone;
            while (pcls != NULL) {
                pudw = (ULONG_PTR UNALIGNED *)((BYTE *)(pcls + 1) + index);
                *pudw = value;
                pcls = pcls->pclsNext;
            }
            return dwOld;
        }
    }
}


#ifdef _WIN64
DWORD xxxSetClassLong(
    PWND pwnd,
    int index,
    DWORD value,
    BOOL bAnsi)
{
    DWORD dwOld;
    PCLS pcls;

    CheckLock(pwnd);
    CheckCritIn();

    if (GETPTI(pwnd)->ppi != PpiCurrent()) {
        RIPERR1(ERROR_ACCESS_DENIED, RIP_WARNING, "SetClassLong: different process: index 0x%lx", index);
        return 0;
    }

    if (index < 0) {
        if (index < INDEX_OFFSET || afClassDWord[index - INDEX_OFFSET] > sizeof(DWORD)) {
            RIPERR1(ERROR_INVALID_INDEX,
                    RIP_WARNING,
                    "SetClassLong: invalid index 0x%x", index);
            return 0;
        }
        return (DWORD)xxxSetClassData(pwnd, index, value, bAnsi);
    } else {
        pcls = pwnd->pcls->pclsBase;
        if ((UINT)index + sizeof(DWORD) > (UINT)pcls->cbclsExtra) {
            RIPERR1(ERROR_INVALID_INDEX,
                    RIP_WARNING,
                    "SetClassLong: invalid index 0x%x", index);
            return 0;
        } else {
            DWORD UNALIGNED *pudw;
            pudw = (DWORD UNALIGNED *)((BYTE *)(pcls + 1) + index);
            dwOld = *pudw;
            *pudw = value;
            pcls = pcls->pclsClone;
            while (pcls != NULL) {
                pudw = (DWORD UNALIGNED *)((BYTE *)(pcls + 1) + index);
                *pudw = value;
                pcls = pcls->pclsNext;
            }
            return dwOld;
        }
    }
}
#endif


PPCLS _InnerGetClassPtr(
    ATOM atom,
    PPCLS ppcls,
    HANDLE hModule)
{
    if (atom == 0)
        return NULL;

    while (*ppcls != NULL) {
        if ((*ppcls)->atomClassName == atom &&
                (hModule == NULL || HIWORD((ULONG_PTR)(*ppcls)->hModule) == HIWORD((ULONG_PTR)hModule)) &&
                !((*ppcls)->CSF_flags & CSF_WOWDEFERDESTROY)) {
            return ppcls;
        }

        ppcls = (PPCLS)*ppcls;
    }

    return NULL;
}


/***************************************************************************\
* GetClassPtr
*
* Note: This returns a "pointer-to-PCLS" and not "PCLS".
*
* Scan the passed-in class list for the specified class. Return NULL if
* the class isn't in the list.
*
* History:
* 10-16-90 darrinm      Ported this puppy.
* 04-08-91 DarrinM      Rewrote to remove global classes.
* 08-14-92 FritzS     Changed check to HIWORD only to allow Wow apps to
*                     share window classes between instances of an app.
                      (For Wow apps, HiWord of hInstance is 16-bit module,
                       and LoWord is 16-bit hInstance
\***************************************************************************/

PPCLS GetClassPtr(
    ATOM atom,
    PPROCESSINFO ppi,
    HANDLE hModule)
{
    PPCLS ppcls;

    /*
     * First search public then private then usersrv registered classes
     */
    ppcls = _InnerGetClassPtr(atom, &ppi->pclsPrivateList, hModule);
    if (ppcls)
        return ppcls;

    ppcls = _InnerGetClassPtr(atom, &ppi->pclsPublicList, NULL);
    if (ppcls)
        return ppcls;

    /*
     * Next seach public and private classes and override hmodule;
     * some apps (bunny) do a GetClassInfo(dialog) and RegisterClass
     * and only change the wndproc which set the hmodule to be just
     * like usersrv created it even though it is in the app's public
     * or private class list
     */

    /*
     * Later -- since we are no longer returning hModuleWin to any app,
     * we may only need to check for hModClient. Check this out.
     *      FritzS
     */

    ppcls = _InnerGetClassPtr(atom, &ppi->pclsPrivateList, hModClient);
    if (ppcls)
        return ppcls;

    ppcls = _InnerGetClassPtr(atom, &ppi->pclsPublicList, hModClient);
    if (ppcls)
        return ppcls;

    /*
     * Search the system class list
     */
    ppcls = _InnerGetClassPtr(atom, &gpclsList, NULL);
    return ppcls;
}

/***************************************************************************\
 * UnlockAndFreeCPDs -
 *
 * Safe way to unlock and free a linked list of CPDs. Need to do it this
 * way in case the Thread's objects have already been marked for destruction.
 *
 * History 2/10/95  SanfordS    Created
\***************************************************************************/

VOID UnlockAndFreeCPDs(
PCALLPROCDATA *ppCPD)
{
    PCALLPROCDATA pCPD;

    while ((pCPD = *ppCPD) != NULL) {
        /*
         * Unlink the CPD from the list.
         */
        *ppCPD = pCPD->spcpdNext;
        pCPD->spcpdNext = NULL;

        /*
         * Mark it for destruction.
         */
        if (!HMIsMarkDestroy(pCPD)) {
            HMMarkObjectDestroy(pCPD);
        }

        /*
         * Unlock it and it will be destroyed.
         */
        Unlock(&pCPD);
    }
}

/***************************************************************************\
* DestroyClassBrush
*
* Destroy the brush of the class if it's a brush, it's not a system
* brush and no other class is using it
*
* History:
* 4-10-96 CLupu  Created
\***************************************************************************/

void DestroyClassBrush(
    PCLS pcls)
{
    PPROCESSINFO ppi = PpiCurrent();
    PCLS         pclsWalk;
    int          nInd;
    BOOL         bRet;
    /*
     * Return if it's not a real brush
     */
    if (pcls->hbrBackground <= (HBRUSH)(COLOR_MAX))
        return;

    /*
     * Don't delete the system brushes
     */
    for (nInd = 0; nInd < COLOR_MAX; nInd++) {
        if (pcls->hbrBackground == SYSHBRUSH(nInd))
            return;
    }


    /*
     * Walk the process public public list
     */
    pclsWalk = ppi->pclsPublicList;

    while (pclsWalk) {
        if (pclsWalk != pcls && pclsWalk->hbrBackground == pcls->hbrBackground)
            return;

        pclsWalk = pclsWalk->pclsNext;
    }

    /*
     * Walk the process private class list
     */
    pclsWalk = ppi->pclsPrivateList;

    while (pclsWalk) {
        if (pclsWalk != pcls && pclsWalk->hbrBackground == pcls->hbrBackground)
            return;

        pclsWalk = pclsWalk->pclsNext;
    }

    /*
     * Finaly walk the system class list
     */
    pclsWalk = gpclsList;

    while (pclsWalk) {
        if (pclsWalk != pcls && pclsWalk->hbrBackground == pcls->hbrBackground)
            return;

        pclsWalk = pclsWalk->pclsNext;
    }

    bRet = GreDeleteObject(pcls->hbrBackground);

#if DBG
    if (!bRet)
        RIPERR1(ERROR_INVALID_HANDLE, RIP_WARNING,
            "DestroyClassBrush: failed to destroy brush %#p", pcls->hbrBackground);
#endif
}

/***************************************************************************\
* DestroyClass
*
* Delete the window class. First, destroy any DCs that are attached to the
* class. Then delete classname atom. Then free the other stuff that was
* allocated when the class was registered and unlink the class from the
* master class list.
*
* History:
* 10-16-90 darrinm      Ported this puppy.
\***************************************************************************/
VOID DestroyClass(
    PPCLS ppcls)
{
    PPCLS ppclsClone;
    PCLS pcls;
    PDESKTOP rpdesk;

    pcls = *ppcls;

    UserAssert(pcls->cWndReferenceCount == 0);

    /*
     * If this is a base class, destroy all clones before deleting
     * stuff.
     */
    if (pcls == pcls->pclsBase) {
        ppclsClone = &pcls->pclsClone;
        while (*ppclsClone != NULL) {
            DestroyClass(ppclsClone);
        }

        UserDeleteAtom(pcls->atomClassName);
        UserDeleteAtom(pcls->atomNVClassName);

        /*
         * No freeing if it's an integer resource.
         */
        if (IS_PTR(pcls->lpszMenuName)) {
            UserFreePool(pcls->lpszMenuName);
        }

        /*
         * Free up the class dc if there is one.
         */
        if (pcls->pdce != NULL)
            DestroyCacheDC(NULL, pcls->pdce->hdc);

        /*
         * Delete the hBrBackground brush if nobody else is
         * using it.
         */
        DestroyClassBrush(pcls);
    }

    /*
     * If we created the small icon delete it
     */
    DestroyClassSmIcon(pcls);

    /*
     * Unlock cursor and icon
     */
    Unlock(&pcls->spicn);
    Unlock(&pcls->spicnSm);
    Unlock(&pcls->spcur);

    /*
     * Free any CallProcData objects associated with this class
     */
    if (pcls->spcpdFirst) {
        UnlockAndFreeCPDs(&pcls->spcpdFirst);
    }

    /*
     * Point the previous guy at the guy we currently point to.
     */
    *ppcls = pcls->pclsNext;

    /*
     * The unlock call is delayed after the free such that if this is
     * the last reference on the desktop, the desktop heap is not 
     * destroyed before we free the objects.
     */
    rpdesk = pcls->rpdeskParent;
    pcls->rpdeskParent = NULL;

    ClassFree(rpdesk, pcls->lpszAnsiClassName);
    ClassFree(rpdesk, pcls);

    /*
     * NOTE: Using pobj after freeing the object is not a problem because 
     * UnlockDesktop uses the value for tracking and doesn't dereference 
     * the pointer.  If this ever changes we'll get a BC.
     */
    UnlockDesktop(&rpdesk, LDU_CLS_DESKPARENT2, (ULONG_PTR)pcls);
}

/***************************************************************************\
* GetClassIcoCur
*
* Returns the pwnd's class icon/cursor. This is called by _GetClassData
*  from the client side because PCURSORs are allocated from POOL (so the
*  client cannot do PtoH on them). NtUserCallHwndParam does the PtoH translation
*
* History:
* 11-19-90 darrinm      Wrote.
\***************************************************************************/
PCURSOR GetClassIcoCur(
    PWND pwnd,
    int index)
{
    PCLS pcls = pwnd->pcls;
    PCURSOR pcur;

    switch (index) {
        case GCLP_HICON:
            pcur = pcls->spicn;
            break;

        case GCLP_HCURSOR:
            pcur = pcls->spcur;
            break;

        case GCLP_HICONSM:
            pcur = pcls->spicnSm;
            break;

        default:
            RIPMSG2(RIP_WARNING,
                    "GetWndIcoCur: Invalid index: 0x%x pwnd: 0x%p",
                    index,
                    pwnd);
            pcur = NULL;
    }

    return pcur;
}

/***************************************************************************\
* xxxSetClassCursor
*
* History:
\***************************************************************************/
ULONG_PTR xxxSetClassCursor(
    PWND  pwnd,
    PCLS  pcls,
    DWORD index,
    ULONG_PTR dwData)
{
    ULONG_PTR dwOld;

    CheckLock(pwnd);

    if ((HANDLE)dwData != NULL) {
        dwData = (ULONG_PTR)HMValidateHandle((HANDLE)dwData, TYPE_CURSOR);
        if ((PVOID)dwData == NULL) {
            if (index == GCLP_HICON || index == GCLP_HICONSM) {
                RIPERR0(ERROR_INVALID_ICON_HANDLE, RIP_WARNING, "SetClassData: invalid icon");
            } else {
                RIPERR0(ERROR_INVALID_CURSOR_HANDLE, RIP_WARNING, "SetClassData: invalid cursor");
            }
        }
    }

    /*
     * Handle the locking issue.
     */
    pcls = pcls->pclsBase;
    switch (index) {
    case GCLP_HICON:
    case GCLP_HICONSM:
        dwOld = (ULONG_PTR)xxxSetClassIcon(pwnd, pcls, (PCURSOR)dwData, index);
        break;

    case GCLP_HCURSOR:
        dwOld = (ULONG_PTR)Lock(&pcls->spcur, dwData);
        break;
    }

    /*
     * Now set it for each clone class.
     */
    pcls = pcls->pclsClone;
    while (pcls != NULL) {
        switch(index) {
        case GCLP_HICON:
        case GCLP_HICONSM:
            xxxSetClassIcon(pwnd, pcls, (PCURSOR)dwData, index);
            break;

        case GCLP_HCURSOR:
            Lock(&pcls->spcur, dwData);
            break;
        }
        pcls = pcls->pclsNext;
    }

    return (ULONG_PTR)PtoH((PVOID)dwOld);
}

/***************************************************************************\
* SetClassData
*
* SetClassWord and SetClassLong are now identical routines because they both
* can return DWORDs. This single routine performs the work for them both
* by using two arrays; afClassDWord to determine whether the result should be
* a WORD or a DWORD, and aiClassOffset to find the correct offset into the
* CLS structure for a given GCL_ or GCL_ index.
*
* History:
* 11-19-90 darrinm      Wrote.
\***************************************************************************/
ULONG_PTR xxxSetClassData(
    PWND pwnd,
    int index,
    ULONG_PTR dwData,
    BOOL bAnsi)
{
    PCLS pcls = pwnd->pcls;
    BYTE *pb;
    ULONG_PTR dwT;
    ULONG_PTR dwOld;
    DWORD dwCPDType = 0;
    PCLSMENUNAME pcmn;
    UNICODE_STRING strMenuName, UString;

    CheckLock(pwnd);

    switch(index) {
    case GCLP_WNDPROC:

        /*
         * If the application (client) subclasses a class that has a server -
         * side window proc we must return a client side proc stub that it
         * can call.
         */
        if (pcls->CSF_flags & CSF_SERVERSIDEPROC) {
            dwOld = MapServerToClientPfn((ULONG_PTR)pcls->lpfnWndProc, bAnsi);
            pcls->CSF_flags &= ~CSF_SERVERSIDEPROC;

            UserAssert(!(pcls->CSF_flags & CSF_ANSIPROC));
            if (bAnsi) {
                pcls->CSF_flags |= CSF_ANSIPROC;
            }
        } else {
            dwOld = MapClientNeuterToClientPfn(pcls, 0, bAnsi);

            /*
             * If the client mapping didn't change the window proc then see if
             * we need a callproc handle.
             */
            if (dwOld == (ULONG_PTR)pcls->lpfnWndProc) {
                /*
                 * Need to return a CallProc handle if there is an Ansi/Unicode mismatch
                 */
                if (bAnsi != !!(pcls->CSF_flags & CSF_ANSIPROC)) {
                    dwCPDType |= bAnsi ? CPD_ANSI_TO_UNICODE : CPD_UNICODE_TO_ANSI;
                }
            }
        }

        if (dwCPDType) {
            ULONG_PTR dwCPD;

            dwCPD = GetCPD(pcls, dwCPDType | CPD_CLASS, dwOld);

            if (dwCPD) {
                dwOld = dwCPD;
            } else {
                RIPMSG0(RIP_WARNING, "GetClassLong unable to alloc CPD returning handle");
            }
        }

        /*
         * Convert a possible CallProc Handle into a real address. They may
         * have kept the CallProc Handle from some previous mixed GetClassinfo
         * or SetWindowLong.
         */
        if (ISCPDTAG(dwData)) {
            PCALLPROCDATA pCPD;
            if (pCPD = HMValidateHandleNoRip((HANDLE)dwData, TYPE_CALLPROC)) {
                dwData = pCPD->pfnClientPrevious;
            }
        }

        /*
         * If an app 'unsubclasses' a server-side window proc we need to
         * restore everything so SendMessage and friends know that it's
         * a server-side proc again. Need to check against client side
         * stub addresses.
         */
        pcls->lpfnWndProc = (WNDPROC_PWND)dwData;
        if ((dwT = MapClientToServerPfn(dwData)) != 0) {
            pcls->lpfnWndProc = (WNDPROC_PWND)dwT;
            pcls->CSF_flags |= CSF_SERVERSIDEPROC;
            pcls->CSF_flags &= ~CSF_ANSIPROC;
        } else {
            if (bAnsi) {
                pcls->CSF_flags |= CSF_ANSIPROC;
            } else {
                pcls->CSF_flags &= ~CSF_ANSIPROC;
            }
        }
        if (pcls->CSF_flags & CSF_WOWCLASS) {
            PWC pwc = PWCFromPCLS(pcls);
            pwc->hMod16 = (pcls->CSF_flags & CSF_SERVERSIDEPROC) ? 0 : xxxClientWOWGetProcModule(pcls->lpfnWndProc);
        }

        return dwOld;
        break;

    case GCLP_HICON:
    case GCLP_HICONSM:
    case GCLP_HCURSOR:
        return xxxSetClassCursor(pwnd, pcls, index, dwData);
        break;


    case GCL_WOWMENUNAME:
        if (pcls->CSF_flags & CSF_WOWCLASS) {
            PWCFromPCLS(pcls)->vpszMenu = (DWORD)dwData;
        } else {
            UserAssert(FALSE);
        }
        break;

    case GCL_CBCLSEXTRA:
        if (pcls->CSF_flags & CSF_WOWCLASS) {
        /*
         * yes -- we can do this for WOW classes only.
         */
            if (pcls->CSF_flags & CSF_WOWEXTRA) {
                dwOld = PWCFromPCLS(pcls)->iClsExtra;
                PWCFromPCLS(pcls)->iClsExtra = LOWORD(dwData);
                return dwOld;
            } else {
                PWCFromPCLS(pcls)->iClsExtra = LOWORD(dwData);
                pcls->CSF_flags |= CSF_WOWEXTRA;
                return pcls->cbclsExtra;
            }
        }
        RIPERR0(ERROR_INVALID_PARAMETER, RIP_WARNING, "Attempt to change cbClsExtra");
        break;

    case GCLP_MENUNAME:
        pcmn = (PCLSMENUNAME) dwData;

        /*
         * pcmn->pusMenuName->Buffer is a client-side address.
         */

        dwOld = (ULONG_PTR) pcls->lpszMenuName;
        /* Is it a string? */
        if (IS_PTR(pcmn->pusMenuName->Buffer)) {
            try {
                RtlInitUnicodeString(&UString, pcmn->pusMenuName->Buffer);
            } except (W32ExceptionHandler(TRUE, RIP_WARNING)) {
                break;
            }
            /* Empty String? */
            if (UString.Length == 0) {
                pcls->lpszMenuName = NULL;
            } else {
                /* Make a copy of the string */
                if (!AllocateUnicodeString(&strMenuName, &UString)) {
                    RIPMSG0(RIP_WARNING, "xxxSetClassData: GCL_MENUNAME AllocateUnicodeString failed");
                    break;
                }

                pcls->lpszMenuName = strMenuName.Buffer;
            }
        } else {
            /* Just copy the id */
            pcls->lpszMenuName = pcmn->pusMenuName->Buffer;
        }
        /* Don't return the kernel side pointer */
        pcmn->pusMenuName = NULL;

        /* Free old string, if any */
        if (IS_PTR(dwOld)) {
            UserFreePool((PVOID)dwOld);
        }

        /* Return client side pointers */
        dwOld = (ULONG_PTR) pcls->lpszClientAnsiMenuName;
        pcls->lpszClientAnsiMenuName = pcmn->pszClientAnsiMenuName;
        pcmn->pszClientAnsiMenuName = (LPSTR)dwOld;

        dwOld = (ULONG_PTR) pcls->lpszClientUnicodeMenuName;
        pcls->lpszClientUnicodeMenuName = pcmn->pwszClientUnicodeMenuName;
        pcmn->pwszClientUnicodeMenuName = (LPWSTR)dwOld;

        return (bAnsi ? (ULONG_PTR) pcmn->pszClientAnsiMenuName : (ULONG_PTR) pcmn->pwszClientUnicodeMenuName);

    default:
        /*
         * All other indexes go here...
         */
        index -= INDEX_OFFSET;

        /*
         * Only let valid indices go through; if aiClassOffset is zero
         * then we have no mapping for this negative index so it must
         * be a bogus index.
         */
        if ((index < 0) || (aiClassOffset[index] == 0)) {
            RIPERR1(ERROR_INVALID_INDEX,
                    RIP_WARNING,
                    "SetClassLong: invalid index 0x%x", index);
            return 0;
        }

        pcls = pcls->pclsBase;
        pb = ((BYTE *)pcls) + aiClassOffset[index];

        if (afClassDWord[index] == sizeof(DWORD)) {
            dwOld = *(DWORD *)pb;
            *(DWORD *)pb = (DWORD)dwData;
        } else if (afClassDWord[index] == sizeof(ULONG_PTR)) {
            dwOld = *(ULONG_PTR *)pb;
            *(ULONG_PTR *)pb = dwData;
        } else {
            dwOld = (DWORD)*(WORD *)pb;
            *(WORD *)pb = (WORD)dwData;
        }

        pcls = pcls->pclsClone;
        while (pcls != NULL) {
            pb = ((BYTE *)pcls) + aiClassOffset[index];

            if (afClassDWord[index] == sizeof(DWORD)) {
                dwOld = *(DWORD *)pb;
                *(DWORD *)pb = (DWORD)dwData;
            } else if (afClassDWord[index] == sizeof(ULONG_PTR)) {
                dwOld = *(ULONG_PTR *)pb;
                *(ULONG_PTR *)pb = dwData;
            } else {
                dwOld = (DWORD)*(WORD *)pb;
                *(WORD *)pb = (WORD)dwData;
            }
            pcls = pcls->pclsNext;
        }

        return dwOld;
    }

    return 0;
}


/***************************************************************************\
* ReferenceClass
*
* Clones the class if it is a different desktop than the new window and
* increments the class window count(s).
*
* History:
* 12-11-93 JimA         Created.
\***************************************************************************/

BOOL ReferenceClass(
    PCLS pcls,
    PWND pwnd)
{
    DWORD cbName;
    PCLS pclsClone;
    PDESKTOP pdesk;

    /*
     * If the window is on the same desktop as the base class, just
     * increment the window count.
     */
    if (pcls->rpdeskParent == pwnd->head.rpdesk) {
        pcls->cWndReferenceCount++;
        return TRUE;
    }

    /*
     * The window is not on the base desktop. Try to find a cloned
     * class.
     */
    for (pclsClone = pcls->pclsClone; pclsClone != NULL;
            pclsClone = pclsClone->pclsNext) {
        if (pclsClone->rpdeskParent == pwnd->head.rpdesk) {
            break;
        }
    }

    /*
     * If we can't find one, clone the base class.
     */
    if (pclsClone == NULL) {
        pdesk = pwnd->head.rpdesk;
        pclsClone = ClassAlloc(pdesk, sizeof(CLS) + pcls->cbclsExtra + (pcls->CSF_flags & CSF_WOWCLASS ?sizeof(WC):0), DTAG_CLASS);
        if (pclsClone == NULL) {
            RIPMSG0(RIP_WARNING, "ReferenceClass: Failed Clone-Class Allocation");
            return FALSE;
        }

        RtlCopyMemory(pclsClone, pcls, sizeof(CLS) + pcls->cbclsExtra + (pcls->CSF_flags & CSF_WOWCLASS?sizeof(WC):0));

        cbName = strlen(pcls->lpszAnsiClassName) + 1;
        pclsClone->lpszAnsiClassName = ClassAlloc(pdesk, cbName, DTAG_TEXT);
        if (pclsClone->lpszAnsiClassName == NULL) {
            ClassFree(pdesk, pclsClone);
            RIPMSG0(RIP_WARNING, "ReferenceClass: No Clone Class Name");
            return FALSE;
        }

        /*
         * Everything has been allocated, now lock everything down.
         * NULL pointers in clone to prevent Lock() from incorrectly
         * decrementing object reference count
         */
        pclsClone->rpdeskParent = NULL;
        LockDesktop(&pclsClone->rpdeskParent, pdesk,
                    LDL_CLS_DESKPARENT2, (ULONG_PTR)pclsClone);
        pclsClone->pclsNext = pcls->pclsClone;
        pclsClone->pclsClone = NULL;
        pcls->pclsClone = pclsClone;
        RtlCopyMemory(pclsClone->lpszAnsiClassName, pcls->lpszAnsiClassName, cbName);

        pclsClone->spicn = pclsClone->spicnSm = pclsClone->spcur = NULL;

        Lock(&pclsClone->spicn, pcls->spicn);
        Lock(&pclsClone->spicnSm, pcls->spicnSm);
        Lock(&pclsClone->spcur, pcls->spcur);
        pclsClone->spcpdFirst =  NULL;
        pclsClone->cWndReferenceCount = 0;
    }

    /*
     * Increment reference counts.
     */
    pcls->cWndReferenceCount++;
    pclsClone->cWndReferenceCount++;
    pwnd->pcls = pclsClone;

    return TRUE;
}


/***************************************************************************\
* DereferenceClass
*
* Decrements the class window count in the base class. If it's the
* last window of a clone class, destroy the clone.
*
* History:
* 12-11-93 JimA         Created.
\***************************************************************************/

VOID DereferenceClass(
    PWND pwnd)
{
    PCLS pcls = pwnd->pcls;
    PPCLS ppcls;

    UserAssert(pcls->cWndReferenceCount >= 1);

    pwnd->pcls = NULL;

    pcls->cWndReferenceCount--;
    if (pcls != pcls->pclsBase) {

        UserAssert(pcls->pclsBase->cWndReferenceCount >= 1);

        pcls->pclsBase->cWndReferenceCount--;

        if (pcls->cWndReferenceCount == 0) {
            ppcls = &pcls->pclsBase->pclsClone;
            while ((*ppcls) != pcls)
                ppcls = &(*ppcls)->pclsNext;
            UserAssert(ppcls);
            DestroyClass(ppcls);
        }
    }
}


/***************************************************************************\
* DestroyProcessesClasses
*
* History:
* 04-07-91 DarrinM      Created.
\***************************************************************************/

VOID DestroyProcessesClasses(
    PPROCESSINFO ppi)
{
    PPCLS ppcls;

    /*
     * Destroy the private classes first
     */
    ppcls = &(ppi->pclsPrivateList);
    while (*ppcls != NULL) {
        DestroyClass(ppcls);
    }

    /*
     * Then the cloned public classes
     */
    ppcls = &(ppi->pclsPublicList);
    while (*ppcls != NULL) {
        DestroyClass(ppcls);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kernel\caret.c ===
/****************************** Module Header ******************************\
* Module Name: caret.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* Caret code. Every thread has a caret in its queue structure.
*
* History:
* 11-17-90 ScottLu      Created.
* 01-Feb-1991 mikeke    Added Revalidation code (None)
* 02-12-91 JimA         Added access checks
\***************************************************************************/

#include "precomp.h"
#pragma hdrstop


/***************************************************************************\
* UT_CaretSet
*
* Checks to see if the current queue has a caret. If pwnd != NULL, check
* to see if the caret is for pwnd.
*
* History:
* 11-17-90 ScottLu      Ported.
\***************************************************************************/
BOOL UT_CaretSet(
    PWND pwnd)
{
    PQ pq;
    PTHREADINFO ptiCurrent;

    /*
     * Current queue have a caret? If not, return FALSE.
     */
    ptiCurrent = PtiCurrent();
    pq = ptiCurrent->pq;

    if (pq->caret.spwnd == NULL) {
        RIPERR0(ERROR_ACCESS_DENIED,
                RIP_VERBOSE,
                "Access denied in UT_CaretSet to current queue's caret");

        return FALSE;
    }

    /*
     * If the current task does not own the caret, then return FALSE. We let
     * 32 bit multithreaded apps set the caret position from a second thread
     * for compatibility to our NT 3.1 BETAs.
     */
    if (pq->caret.tid != TIDq(ptiCurrent)) {
        PTHREADINFO ptiCursorOwner = PtiFromThreadId(pq->caret.tid);

        if ((ptiCurrent->TIF_flags & TIF_16BIT) ||
            ptiCursorOwner == NULL ||
            ptiCurrent->ppi != ptiCursorOwner->ppi)  {
            RIPERR0(ERROR_ACCESS_DENIED,
                    RIP_VERBOSE,
                    "Access denied in UT_CaretSet");

            return FALSE;
        }
    }

    /*
     * If pwnd == NULL, we're just checking to see if current queue has
     * caret. It does, so return TRUE.
     */
    if (pwnd == NULL) {
        return TRUE;
    }

    /*
     * pwnd != NULL. Check to see if the caret is for pwnd. If so, return
     * TRUE.
     */
    if (pwnd == pq->caret.spwnd) {
        return TRUE;
    } else {
        return FALSE;
    }
}

/***************************************************************************\
* UT_InvertCaret
*
* Invert the caret.
*
* History:
* 11-17-90 ScottLu      Ported.
\***************************************************************************/
VOID UT_InvertCaret(
    VOID)
{
    HDC hdc;
    PWND pwnd;
    PQ pq;
    HBITMAP hbmSave;
    BOOL fRestore;

    pq = PtiCurrent()->pq;
    pwnd = pq->caret.spwnd;

    if (pwnd == NULL || !IsVisible(pwnd)) {
        pq->caret.fVisible = FALSE;
        return;
    }

    /*
     * Get a DC for this window and draw the caret.
     */
    hdc = _GetDC(pwnd);
    if (fRestore = (pwnd->hrgnUpdate ? TRUE : FALSE)) {
        GreSaveDC(hdc);
        if (TestWF(pwnd, WFWIN31COMPAT)) {
            _ExcludeUpdateRgn(hdc, pwnd);
        }
    }

    /*
     * If the caret bitmap is NULL, the caret is a white pattern invert.
     * If the caret bitmap is == 1, the caret is a gray pattern.
     * If the caret bitmap is  > 1, the caret is really a bitmap.
     */
    if (pq->caret.hBitmap > (HBITMAP)1) {

        /*
         * The caret is a bitmap. SRCINVERT it onto the screen.
         */
        hbmSave = GreSelectBitmap(ghdcMem, pq->caret.hBitmap);
        GreBitBlt(hdc,
                  pq->caret.x,
                  pq->caret.y,
                  pq->caret.cx,
                  pq->caret.cy,
                  ghdcMem,
                  0,
                  0,
                  SRCINVERT,
                  0);

        GreSelectBitmap(ghdcMem, hbmSave);
    } else {
        POLYPATBLT PolyData;

        /*
         * The caret is a pattern (gray or white). PATINVERT it onto the
         * screen.
         */
        PolyData.x  = pq->caret.x;
        PolyData.y  = pq->caret.y;
        PolyData.cx = pq->caret.cx;
        PolyData.cy = pq->caret.cy;

        if (pq->caret.hBitmap == (HBITMAP)1) {
            PolyData.BrClr.hbr = gpsi->hbrGray;
        } else {
            PolyData.BrClr.hbr = ghbrWhite;
        }

        GrePolyPatBlt(hdc, PATINVERT, &PolyData, 1, PPB_BRUSH);
    }

    if (fRestore) {
        GreRestoreDC(hdc, -1);
    }

    _ReleaseDC(hdc);
}


/***************************************************************************\
* zzzInternalDestroyCaret
*
* Internal routine for killing the caret for this thread.
*
* History:
* 11-17-90 ScottLu      Ported
\***************************************************************************/
VOID zzzInternalDestroyCaret(
    VOID)
{
    PQ pq;
    PTHREADINFO ptiCurrent = PtiCurrent();
    PWND pwndCaret;
    TL tlpwndCaret;

    /*
     * Hide the caret, kill the timer, and null out the caret structure.
     */
    zzzInternalHideCaret();
    pq = ptiCurrent->pq;

    if (pq->caret.hTimer != 0) {
        _KillSystemTimer(pq->caret.spwnd, IDSYS_CARET);
        pq->caret.hTimer = 0;
    }

    pq->caret.hBitmap = NULL;
    pq->caret.iHideLevel = 0;

    pwndCaret = pq->caret.spwnd;
    if (pwndCaret != NULL) {
        ThreadLockWithPti(ptiCurrent, pwndCaret, &tlpwndCaret);
        Unlock(&pq->caret.spwnd);

        zzzWindowEvent(EVENT_OBJECT_DESTROY,
                       pwndCaret,
                       OBJID_CARET,
                       INDEXID_CONTAINER,
                       0);

        ThreadUnlock(&tlpwndCaret);
    }
}


/***************************************************************************\
* zzzDestroyCaret
*
* External api for destroying the caret of the current thread.
*
* History:
* 11-17-90 ScottLu      Ported.
* 16-May-1991 mikeke    Changed to return BOOL
\***************************************************************************/
BOOL zzzDestroyCaret(
    VOID)
{
    if (UT_CaretSet(NULL)) {
        zzzInternalDestroyCaret();
        return TRUE;
    } else {
        return FALSE;
    }
}


/***************************************************************************\
* xxxCreateCaret
*
* External api for creating the caret.
*
* History:
* 11-17-90 ScottLu      Ported.
* 16-May-1991 mikeke    Changed to return BOOL
\***************************************************************************/
BOOL xxxCreateCaret(
    PWND pwnd,
    HBITMAP hBitmap,
    int cx,
    int cy)
{
    PQ pq;
    BITMAP bitmap;
    PTHREADINFO ptiCurrent = PtiCurrent();

    CheckLock(pwnd);
    UserAssert(IsWinEventNotifyDeferredOK());

    pq = ptiCurrent->pq;

    /*
     * Don't allow the app to create a caret in a window
     * from another queue.
     */
    if (GETPTI(pwnd)->pq != pq) {
        return FALSE;
    }

    /*
     * Defer WinEvent notifications to preserve pq.
     */
    DeferWinEventNotify();

    if (pq->caret.spwnd != NULL) {
        zzzInternalDestroyCaret();
    }

    Lock(&pq->caret.spwnd, pwnd);
    pq->caret.iHideLevel = 1;
    pq->caret.fOn = TRUE;
    pq->caret.fVisible = FALSE;
    pq->caret.tid = TIDq(ptiCurrent);

    if (cy == 0) {
        cy = SYSMET(CYBORDER);
    }
    if (cx == 0) {
        cx = SYSMET(CXBORDER);
    }

    if ((pq->caret.hBitmap = hBitmap) > (HBITMAP)1) {
        GreExtGetObjectW(hBitmap, sizeof(BITMAP), &bitmap);
        cy = bitmap.bmHeight;
        cx = bitmap.bmWidth;
    }

    pq->caret.cy = cy;
    pq->caret.cx = cx;
    if (gpsi->dtCaretBlink != -1 && !IsRemoteConnection()) {
        pq->caret.hTimer = _SetSystemTimer(pwnd,
                                           IDSYS_CARET,
                                           gpsi->dtCaretBlink,
                                           CaretBlinkProc);
    } else {
        pq->caret.hTimer = 0;
    }

    UserAssert(pwnd == pq->caret.spwnd);
    zzzEndDeferWinEventNotify();

    /*
     * It's best to force this routine to be an xxx routine: that way we can
     * force pwnd to be locked and force notifications from within this
     * routine and all of the callers are happy with this.
     */
    xxxWindowEvent(EVENT_OBJECT_CREATE, pwnd, OBJID_CARET, INDEXID_CONTAINER, 0);

    return TRUE;
}

/***************************************************************************\
* zzzInternalShowCaret
*
* Internal routine for showing the caret for this thread.
*
* History:
* 11-17-90 ScottLu      Ported.
\***************************************************************************/
VOID zzzInternalShowCaret(
    VOID)
{
    PQ pq = PtiCurrent()->pq;

    /*
     * If the caret hide level is aleady 0 (meaning it's ok to show) and the
     * caret is not physically on, try to invert now if it's turned on.
     */
    if (pq->caret.iHideLevel == 0) {
        if (!pq->caret.fVisible) {
            if ((pq->caret.fVisible = pq->caret.fOn) != 0) {
                UT_InvertCaret();
            }
        }

        return;
    }

    /*
     * Adjust the hide caret hide count. If we hit 0, we can show the caret.
     * Try to invert it if it's turned on.
     */
    if (--pq->caret.iHideLevel == 0) {
        if ((pq->caret.fVisible = pq->caret.fOn) != 0) {
            UT_InvertCaret();
        }

        zzzWindowEvent(EVENT_OBJECT_SHOW,
                       pq->caret.spwnd,
                       OBJID_CARET,
                       INDEXID_CONTAINER,
                       0);
    }
}


/***************************************************************************\
* zzzInternalHideCaret
*
* Internal routine for hiding the caret.
*
* History:
* 11-17-90 ScottLu      Created.
\***************************************************************************/
VOID zzzInternalHideCaret(
    VOID)
{
    PQ pq = PtiCurrent()->pq;

    /*
     * If the caret is physically visible, invert it to turn off the bits.
     * Adjust the hide count upwards to remember this hide level.
     */
    if (pq->caret.fVisible) {
        UT_InvertCaret();
    }

    pq->caret.fVisible = FALSE;
    pq->caret.iHideLevel++;

    /*
     * Is the caret transitioning to being hidden? If so, iHideLevel is
     * going from 0 to 1.
     */
    if (pq->caret.iHideLevel == 1) {
        zzzWindowEvent(EVENT_OBJECT_HIDE,
                       pq->caret.spwnd,
                       OBJID_CARET,
                       INDEXID_CONTAINER,
                       0);
    }
}


/***************************************************************************\
* zzzShowCaret
*
* External routine for showing the caret.
*
* History:
* 11-17-90 ScottLu      Ported.
* 16-May-1991 mikeke    Changed to return BOOL
\***************************************************************************/
BOOL zzzShowCaret(
    PWND pwnd)
{
    if (UT_CaretSet(pwnd)) {
        zzzInternalShowCaret();
        return TRUE;
    } else {
        return FALSE;
    }
}


/***************************************************************************\
* zzzHideCaret
*
* External api to hide the caret.
*
* History:
* 11-17-90 ScottLu      Ported.
* 16-May-1991 mikeke    Changed to return BOOL
\***************************************************************************/
BOOL zzzHideCaret(
    PWND pwnd)
{
    if (UT_CaretSet(pwnd)) {
        zzzInternalHideCaret();
        return TRUE;
    } else {
        return FALSE;
    }
}

/***************************************************************************\
* CaretBlinkProc
*
* This routine gets called by DispatchMessage when it gets the WM_SYSTIMER
* message - it blinks the caret.
*
* History:
* 11-17-90 ScottLu      Ported.
\***************************************************************************/
VOID CaretBlinkProc(
    PWND pwnd,
    UINT message,
    UINT_PTR id,
    LPARAM lParam)
{
    PQ pq = PtiCurrent()->pq;

    UNREFERENCED_PARAMETER(message);
    UNREFERENCED_PARAMETER(id);
    UNREFERENCED_PARAMETER(lParam);

    /*
     * If this window doesn't even have a timer, just return. TRUE is
     * returned, which gets returned from DispatchMessage(). Why? Because
     * it is compatible with Win3.
     */
    if (pwnd != pq->caret.spwnd) {
        return;
    }


    if (gpsi->dtCaretBlink == -1 && pq->caret.fOn && pq->caret.fVisible) {
        /*
         * Kill the timer for performance.
         */
        _KillSystemTimer(pq->caret.spwnd, IDSYS_CARET);
        return;
    }

    /*
     * Flip the logical cursor state. If the hide level permits it, flip
     * the physical state and draw the caret.
     */
    pq->caret.fOn ^= 1;
    if (pq->caret.iHideLevel == 0) {
        pq->caret.fVisible ^= 1;
        UT_InvertCaret();
    }
}


/***************************************************************************\
* _SetCaretBlinkTime
*
* Sets the system caret blink time.
*
* History:
* 11-17-90 ScottLu      Created.
* 02-12-91 JimA         Added access check
* 16-May-1991 mikeke    Changed to return BOOL
\***************************************************************************/
BOOL _SetCaretBlinkTime(
    UINT cmsBlink)
{
    PQ pq;

    /*
     * Blow it off if the caller doesn't have the proper access rights.
     */
    if (!CheckWinstaWriteAttributesAccess()) {
        return FALSE;
    }

    /*
     * Blow it off if this value is under policy control.
     */
    if (CheckDesktopPolicy(NULL, (PCWSTR)STR_BLINK)) {
        return FALSE;
    }

    gpsi->dtCaretBlink = cmsBlink;

    pq = PtiCurrent()->pq;
    if (pq->caret.hTimer) {
        _KillSystemTimer(pq->caret.spwnd, IDSYS_CARET);
        if (gpsi->dtCaretBlink != -1 && !IsRemoteConnection()) {
            pq->caret.hTimer = _SetSystemTimer(pq->caret.spwnd,
                                               IDSYS_CARET,
                                               gpsi->dtCaretBlink,
                                               CaretBlinkProc);
        } else {
            pq->caret.hTimer = 0;
        }
    }

    return TRUE;
}


/***************************************************************************\
* zzzSetCaretPos
*
* External routine for setting the caret pos.
*
* History:
* 11-17-90 ScottLu      Ported.
* 02-12-91 JimA         Added access check
\***************************************************************************/
BOOL zzzSetCaretPos(
    int x,
    int y)
{
    PQ pq;

    /*
     * If this thread does not have the caret set, return FALSE.
     */
    if (!UT_CaretSet(NULL)) {
        RIPERR0(ERROR_ACCESS_DENIED, RIP_WARNING, "Access denied in zzzSetCaretPos");
        return FALSE;
    }

    /*
     * If the caret isn't changing position, do nothing (but return success).
     */
    pq = PtiCurrent()->pq;
    if (pq->caret.x == x && pq->caret.y == y) {
        return TRUE;
    }

    /*
     * For windows that have private DCs, we have to store the client coordinate
     * equivelent for the logical coordinate caret positioning.
     */
    if (pq->caret.spwnd != NULL && pq->caret.spwnd->pcls->style & CS_OWNDC) {
        RECT rcOwnDcCaret;
        HDC hdc;

        rcOwnDcCaret.left = x;
        rcOwnDcCaret.top = y;
        rcOwnDcCaret.right = x + pq->caret.cx;
        rcOwnDcCaret.bottom = y + pq->caret.cy;

        hdc = _GetDC(pq->caret.spwnd);
        GreLPtoDP(hdc, (LPPOINT)(&rcOwnDcCaret), 2);
        _ReleaseDC(hdc);

        pq->caret.xOwnDc = rcOwnDcCaret.left;
        pq->caret.yOwnDc = rcOwnDcCaret.top;
        pq->caret.cxOwnDc = rcOwnDcCaret.right - rcOwnDcCaret.left;
        pq->caret.cyOwnDc = rcOwnDcCaret.bottom - rcOwnDcCaret.top;
    }

    /*
     * If the caret is visible, turn it off while we move it.
     */
    if (pq->caret.fVisible) {
        UT_InvertCaret();
    }

    /*
     * Adjust to the new position.
     */
    pq->caret.x = x;
    pq->caret.y = y;

    /*
     * Set a new timer so it'll blink in the new position dtCaretBlink
     * milliseconds from now.
     */
    if (pq->caret.hTimer != 0) {
        _KillSystemTimer(pq->caret.spwnd, IDSYS_CARET);
    }

    if (gpsi->dtCaretBlink != -1 && !IsRemoteConnection()) {
        pq->caret.hTimer = _SetSystemTimer(pq->caret.spwnd,
                                           IDSYS_CARET,
                                           gpsi->dtCaretBlink,
                                           CaretBlinkProc);
    } else {
        pq->caret.hTimer = 0;
    }

    pq->caret.fOn = TRUE;

    /*
     * Draw it immediately now if the hide level permits it.
     */
    pq->caret.fVisible = FALSE;
    if (pq->caret.iHideLevel == 0) {
        pq->caret.fVisible = TRUE;
        UT_InvertCaret();
    }

    zzzWindowEvent(EVENT_OBJECT_LOCATIONCHANGE,
                   pq->caret.spwnd,
                   OBJID_CARET,
                   INDEXID_CONTAINER,
                   0);

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kernel\cursor.c ===
/****************************** Module Header ******************************\
* Module Name: cursor.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* This module contains code for dealing with cursors.
*
* History:
* 03-Dec-1990 DavidPe   Created.
* 01-Feb-1991 MikeKe    Added Revalidation code (None)
* 12-Feb-1991 JimA      Added access checks
* 21-Jan-1992 IanJa     ANSI/Unicode neutralized (null op)
* 02-Aug-1992 DarrinM   Added animated cursor code
\***************************************************************************/

#include "precomp.h"
#pragma hdrstop
/***************************************************************************\
* zzzSetCursor (API)
*
* This API sets the cursor image for the current thread.
*
* History:
* 12-03-90 DavidPe      Created.
\***************************************************************************/

PCURSOR zzzSetCursor(
    PCURSOR pcur)
{
    PQ      pq;
    PCURSOR pcurPrev;
    PTHREADINFO  ptiCurrent = PtiCurrent();

    pq = ptiCurrent->pq;

    pcurPrev = pq->spcurCurrent;

    if (pq->spcurCurrent != pcur) {

        /*
         * Lock() returns pobjOld - if it is still valid.  Don't want to
         * return a pcurPrev that is an invalid pointer.
         */
        pcurPrev = LockQCursor(pq, pcur);

        /*
         * If no thread 'owns' the cursor, we must be in initialization
         * so go ahead and assign it to ourself.
         */
        if (gpqCursor == NULL)
            gpqCursor = pq;

        /*
         * If we're changing the local-cursor for the thread currently
         * representing the global-cursor, update the cursor image now.
         */
        if (pq == gpqCursor) {
            TL tlpcur;
            ThreadLockWithPti(ptiCurrent, pcurPrev, &tlpcur);
            zzzUpdateCursorImage();
            pcurPrev = ThreadUnlock(&tlpcur);
        }
    }

    return pcurPrev;
}

/***************************************************************************\
* zzzSetCursorPos (API)
*
* This API sets the cursor position.
*
* History:
* 03-Dec-1990 DavidPe  Created.
* 12-Feb-1991 JimA     Added access check
* 16-May-1991 mikeke   Changed to return BOOL
\***************************************************************************/

BOOL zzzSetCursorPos(
    int x,
    int y)
{
    /*
     * Blow it off if the caller doesn't have the proper access rights
     */
    if (!CheckWinstaWriteAttributesAccess()) {
        return FALSE;
    }

    zzzInternalSetCursorPos(x, y);

    /*
     * Save the absolute coordinates in the global array
     * for GetMouseMovePointsEx.
     */
    SAVEPOINT(x, y,
              SYSMET(CXVIRTUALSCREEN) - 1,
              SYSMET(CYVIRTUALSCREEN) - 1,
              NtGetTickCount(), 0);

    return TRUE;
}

/***************************************************************************\
* zzzInternalSetCursorPos
*
* This function is used whenever the server needs to set the cursor
* position, regardless of the caller's access rights.
*
* History:
* 12-Feb-1991 JimA      Created.
\***************************************************************************/
VOID zzzInternalSetCursorPos(
    int      x,
    int      y
    )
{

    gptCursorAsync.x = x;
    gptCursorAsync.y = y;

    BoundCursor(&gptCursorAsync);

    gpsi->ptCursor = gptCursorAsync;
    /*
     * Pass MP_PROCEDURAL as the last parameter so that in the
     * remote case we send an updated mouse position to the client
     */
    GreMovePointer(gpDispInfo->hDev, gpsi->ptCursor.x, gpsi->ptCursor.y,
                   MP_PROCEDURAL);

    /*
     * Cursor has changed position, so generate a mouse event so the
     * window underneath the new location knows it's there and sets the
     * shape accordingly.
     */
    zzzSetFMouseMoved();
}

/***************************************************************************\
* IncCursorLevel
* DecCursorLevel
*
* Keeps track of this thread show/hide cursor level as well as the queue
* it is associated with. Thread levels are done so that when
* AttachThreadInput() is called we can do exact level calculations in the
* new queue.
*
* 15-Jan-1993 ScottLu   Created.
\***************************************************************************/

VOID IncCursorLevel(
    PTHREADINFO pti)
{
    pti->iCursorLevel++;
    pti->pq->iCursorLevel++;
}

VOID DecCursorLevel(
    PTHREADINFO pti)
{
    pti->iCursorLevel--;
    pti->pq->iCursorLevel--;
}

/***************************************************************************\
* zzzShowCursor (API)
*
* This API allows the application to hide or show the cursor image.
*
* History:
* 03-Dec-1990 JimA      Implemented for fake cursor stuff
\***************************************************************************/

int zzzShowCursor(
    BOOL fShow)
{
    PTHREADINFO pti = PtiCurrent();
    PQ          pq;
    int         iCursorLevel;

    pq = pti->pq;
    /*
     * To preserve pq
     */
    DeferWinEventNotify();

    if (fShow) {

        IncCursorLevel(pti);

        if ((pq == gpqCursor) && (pq->iCursorLevel == 0))
            zzzUpdateCursorImage();

    } else {

        DecCursorLevel(pti);

        if ((pq == gpqCursor) && (pq->iCursorLevel == -1))
            zzzUpdateCursorImage();
    }

    iCursorLevel = pq->iCursorLevel;
    zzzEndDeferWinEventNotify();

    return iCursorLevel;
}

/***************************************************************************\
* zzzClipCursor (API)
*
* This API sets the cursor clipping rectangle which restricts where the
* cursor can go.  If prcClip is NULL, the clipping rectangle will be the
* screen.
*
* History:
* 03-Dec-1990 DavidPe   Created.
* 16-May-1991 MikeKe    Changed to return BOOL
\***************************************************************************/

BOOL zzzClipCursor(
    LPCRECT prcClip)
{
    PEPROCESS Process = PsGetCurrentProcess();

    /*
     * Don't let this happen if it doesn't have access.
     */
    if (Process != gpepCSRSS && !CheckWinstaWriteAttributesAccess()) {
        return FALSE;
    }

    /*
     * The comment from NT 3.51:
     *     Non-foreground threads can only set the clipping rectangle
     *     if it was empty, or if they are restoring it to the whole screen.
     *
     * But the code from NT 3.51 says "IsRectEmpty" instead of
     * "!IsRectEmpty", as would follow from the comment. We leave
     * the code as it was, as following the comment appears to
     * break apps.
     *
     * CONSIDER: Removing this test altogether after NT4.0 ships.
     */
    if (    PtiCurrent()->pq != gpqForeground &&
            prcClip != NULL &&
            IsRectEmpty(&grcCursorClip)) {
        RIPERR0(ERROR_ACCESS_DENIED, RIP_WARNING, "Access denied in _ClipCursor");
        return FALSE;
    }

    if (prcClip == NULL) {

        grcCursorClip = gpDispInfo->rcScreen;

    } else {

        /*
         * Never let our cursor leave the screen. Can't use IntersectRect()
         * because it doesn't allow rects with 0 width or height.
         */
        grcCursorClip.left   = max(gpDispInfo->rcScreen.left  , prcClip->left);
        grcCursorClip.right  = min(gpDispInfo->rcScreen.right , prcClip->right);
        grcCursorClip.top    = max(gpDispInfo->rcScreen.top   , prcClip->top);
        grcCursorClip.bottom = min(gpDispInfo->rcScreen.bottom, prcClip->bottom);

        /*
         * Check for invalid clip rect.
         */
        if (grcCursorClip.left > grcCursorClip.right ||
            grcCursorClip.top > grcCursorClip.bottom) {

            grcCursorClip = gpDispInfo->rcScreen;
        }
    }

    /*
     * Update the cursor position if it's currently outside the
     * cursor clip-rect.
     */
    if (!PtInRect(&grcCursorClip, gpsi->ptCursor)) {
        zzzInternalSetCursorPos(gpsi->ptCursor.x, gpsi->ptCursor.y);
    }

    return TRUE;
}

/***************************************************************************\
* BoundCursor
*
* This rountine 'clips' gptCursorAsync to be within rcCursorClip.  This
* routine treats rcCursorClip as non-inclusive so the bottom and right sides
* get bound to rcCursorClip.bottom/right - 1.
*
* Is called in OR out of the USER critical section!! IANJA
*
* History:
* 03-Dec-1990 DavidPe   Created.
\***************************************************************************/
#ifdef LOCK_MOUSE_CODE
#pragma alloc_text(MOUSE, BoundCursor)
#endif

VOID BoundCursor(
    LPPOINT lppt)
{
    if (TEST_PUDF(PUDF_VDMBOUNDSACTIVE) && gspwndFullScreen != NULL) {

        if (lppt->x < grcVDMCursorBounds.left) {
            lppt->x = grcVDMCursorBounds.left;
        } else if (lppt->x >= grcVDMCursorBounds.right) {
            lppt->x = grcVDMCursorBounds.right - 1;
        }

        if (lppt->y < grcVDMCursorBounds.top) {
            lppt->y = grcVDMCursorBounds.top;
        } else if (lppt->y >= grcVDMCursorBounds.bottom) {
            lppt->y = grcVDMCursorBounds.bottom - 1;
        }

    } else {

        if (lppt->x < grcCursorClip.left) {
            lppt->x = grcCursorClip.left;
        } else if (lppt->x >= grcCursorClip.right) {
            lppt->x = grcCursorClip.right - 1;
        }

        if (lppt->y < grcCursorClip.top) {
            lppt->y = grcCursorClip.top;
        } else if (lppt->y >= grcCursorClip.bottom) {
            lppt->y = grcCursorClip.bottom - 1;
        }
    }

    /*
     * If we have more than one monitor, then we need to clip the
     * cursor to a point on the desktop.
     */
    if (!gpDispInfo->fDesktopIsRect) {
        ClipPointToDesktop(lppt);
    }
}

/***************************************************************************\
* SetVDMCursorBounds
*
* This routine is needed so when a vdm is running, the mouse is not bounded
* by the screen. This is so the vdm can correctly virtualize the DOS mouse
* device driver. It can't deal with user always bounding to the screen,
* so it sets wide open bounds.
*
* 20-May-1993 ScottLu       Created.
\***************************************************************************/

VOID SetVDMCursorBounds(
    LPRECT lprc)
{
    if (lprc != NULL) {

        /*
         * Set grcVDMCursorBounds before TEST_PUDF(PUDF_VDMBOUNDSACTIVE), because
         * MoveEvent() calls BoundCursor() from outside the USER CritSect!
         */
        grcVDMCursorBounds = *lprc;
        Win32MemoryBarrier();   // Ensure grcVDMCursorBounds is updated first.
        SET_PUDF(PUDF_VDMBOUNDSACTIVE);

    } else {

        /*
         * Turn vdm bounds off.
         */
        CLEAR_PUDF(PUDF_VDMBOUNDSACTIVE);
    }

    /*
     * Before returning from this function,
     * make sure the write instructions are all retired.
     */
    Win32MemoryBarrier();
}

/***************************************************************************\
* zzzAnimateCursor
*
* When an animated cursor is loaded and the wait cursor is up this routine
* gets called to maintain the cursor animation.
*
* Should only be called by the cursor animation timer.
*
* History:
* 02-Oct-1991 DarrinM      Created.
* 03-Aug-1994 SanfordS     Calibrated.
\***************************************************************************/

#if defined (_M_IX86) && (_MSC_VER <= 1100)
#pragma optimize("s", off)
#endif

VOID zzzAnimateCursor(
    PWND  pwndDummy,
    UINT  message,
    UINT_PTR nID,
    LPARAM lParam)
{
    int   iicur;
    PACON pacon;
    TL    tlpacon;
    int   LostTime;
    int   tTime;

    pacon = (PACON)gpcurLogCurrent;

    if (pacon == NULL || !(pacon->CURSORF_flags & CURSORF_ACON)) {
        gdwLastAniTick = 0;
        return;
    }

    /*
     * Find out actual time loss since last update.
     */
    if (gdwLastAniTick) {

        LostTime = NtGetTickCount() - gdwLastAniTick -
                (pacon->ajifRate[pacon->iicur] * 100 / 6);

        if (LostTime < 0)
            LostTime = 0;

    } else {

        LostTime = 0;
    }

    /*
     * Increment the animation index.
     */
    iicur = pacon->iicur + 1;
    if (iicur >= pacon->cicur)
        iicur = 0;

    pacon->iicur = iicur;

    /*
     * This forces the new cursor to be drawn.
     */
    ThreadLockAlways(pacon, &tlpacon);
    zzzUpdateCursorImage();

    tTime = pacon->ajifRate[iicur] * 100 / 6;

    while (tTime < LostTime) {

        /*
         * Animation is outrunning our ability to render it - skip frames
         * to catch up.
         */
        LostTime -= tTime;

        /*
         * Increment the animation index.
         */
        iicur = pacon->iicur + 1;
        if (iicur >= pacon->cicur)
            iicur = 0;

        pacon->iicur = iicur;

        tTime = pacon->ajifRate[iicur] * 100 / 6;
    }
    ThreadUnlock(&tlpacon);

    gdwLastAniTick = NtGetTickCount() - LostTime;
    gidCursorTimer = InternalSetTimer(NULL, gidCursorTimer, tTime - LostTime, zzzAnimateCursor, TMRF_RIT | TMRF_ONESHOT);

    return;


    DBG_UNREFERENCED_PARAMETER(pwndDummy);
    DBG_UNREFERENCED_PARAMETER(message);
    DBG_UNREFERENCED_PARAMETER(nID);
    DBG_UNREFERENCED_PARAMETER(lParam);
}

/**************************************************************************\
* FCursorShadowed
*
\**************************************************************************/

__inline FCursorShadowed(PCURSINFO pci)
{
    return (TestALPHA(CURSORSHADOW) && (pci->CURSORF_flags & CURSORF_SYSTEM));
}

#if defined (_M_IX86) && (_MSC_VER <= 1100)
#pragma optimize("", on)
#endif

/**************************************************************************\
* zzzUpdateCursorImage
*
* History:
* 14-Jan-1992 DavidPe   Created.
* 09-Aug-1992 DarrinM   Added animated cursor code.
* 01-Oct-2000 JasonSch  Added autorun cursor code.
\**************************************************************************/
VOID zzzUpdateCursorImage()
{
    PCURSOR pcurLogNew;
    PCURSOR pcurPhysNew;
    PACON   pacon;
    PCURSOR pcurPhysOld;
    DWORD   event;

#ifdef GENERIC_INPUT
    /*
     * WindowsBug 298252
     * Even though the mouse pointer is outside
     * the GenericInput aware app, allow it to hide
     * the mouse cursor if mouse is captured.
     * i.e. use gpqForeground instead of gpqCursor.
     */
    if (gpqForeground) {
        PTHREADINFO ptiMouse = PtiMouseFromQ(gpqForeground);

        if (TestRawInputMode(ptiMouse, CaptureMouse)) {
            if (gpqForeground->iCursorLevel < 0) {
                pcurLogNew = NULL;
                goto force_setnull;
            }
        }
    }
#endif

    if (gpqCursor == NULL)
        return;

    if ((gpqCursor->iCursorLevel < 0) || (gpqCursor->spcurCurrent == NULL)) {

        pcurLogNew = NULL;

    } else {

        /*
         * Assume we're using the current cursor.
         */
        pcurLogNew = gpqCursor->spcurCurrent;

        /*
         * Check to see if we should use the "app starting" or the "autorun"
         * cursor.
         */
        if (gtimeStartCursorHide != 0
#ifdef AUTORUN_CURSOR
        || gtmridAutorunCursor != 0
#endif // AUTORUN_CURSOR
        ) {

            if (gpqCursor->spcurCurrent == SYSCUR(ARROW) ||
#ifdef AUTORUN_CURSOR
                gpqCursor->spcurCurrent == SYSCUR(AUTORUN) ||
#endif // AUTORUN_CURSOR
                gpqCursor->spcurCurrent == SYSCUR(APPSTARTING)) {

#ifdef AUTORUN_CURSOR
                if (gtmridAutorunCursor != 0) {
                    pcurLogNew = SYSCUR(AUTORUN);
                } else {
#endif // AUTORUN_CURSOR
                    pcurLogNew = SYSCUR(APPSTARTING);
#ifdef AUTORUN_CURSOR
                }
#endif // AUTORUN_CURSOR
            }
        }
    }

#ifdef GENERIC_INPUT
force_setnull:
#endif

    /*
     * If the logical cursor is changing then start/stop the cursor
     * animation timer as appropriate.
     */
    if (pcurLogNew != gpcurLogCurrent) {

        /*
         * If the old cursor was animating, shut off the animation timer.
         */
        if (gtmridAniCursor != 0) {
            /*
             * Disable animation.
             */
            KILLRITTIMER(NULL, gtmridAniCursor);
            gtmridAniCursor = 0;
        }

        /*
         * If the new cursor is animated, start the animation timer.
         */
        if ((pcurLogNew != NULL) && (pcurLogNew->CURSORF_flags & CURSORF_ACON)) {

            /*
             * Start the animation over from the beginning.
             */
            pacon = (PACON)pcurLogNew;
            pacon->iicur = 0;

            gdwLastAniTick = NtGetTickCount();

            /*
             * Use the rate table to keep the timer on track.
             * 1 Jiffy = 1/60 sec = 100/6 ms
             */
            gtmridAniCursor = InternalSetTimer(NULL,
                                               gtmridAniCursor,
                                               pacon->ajifRate[0] * 100 / 6,
                                               zzzAnimateCursor,
                                               TMRF_RIT | TMRF_ONESHOT);
        }
    }

    /*
     * If this is an animated cursor, find and use the current frame
     * of the animation.  NOTE: this is done AFTER the AppStarting
     * business so the AppStarting cursor itself can be animated.
     */
    if (pcurLogNew != NULL && pcurLogNew->CURSORF_flags & CURSORF_ACON) {

        pcurPhysNew = ((PACON)pcurLogNew)->aspcur[((PACON)pcurLogNew)->
                aicur[((PACON)pcurLogNew)->iicur]];
    } else {

        pcurPhysNew = pcurLogNew;
    }

    /*
     * Remember the new logical cursor.
     */
    gpcurLogCurrent = pcurLogNew;

    /*
     * If the physical cursor is changing then update screen.
     */
    if (pcurPhysNew != gpcurPhysCurrent) {

        pcurPhysOld = gpcurPhysCurrent;

        gpcurPhysCurrent = pcurPhysNew;

        if (pcurPhysNew == NULL) {

            SetPointer(FALSE);

        } else {
            ULONG fl = 0;

            if (pcurLogNew->CURSORF_flags & CURSORF_ACON) {
                fl |= SPS_ANIMATEUPDATE;
            }
            if (FCursorShadowed(GETPCI(pcurLogNew))) {
                fl |= SPS_ALPHA;
            }
            GreSetPointer(gpDispInfo->hDev, GETPCI(pcurPhysNew), fl, GETMOUSETRAILS(), MOUSE_TRAILS_FREQ);
        }

        /*
         * Notify anyone who cares about the change
         * This can happen on the RIT, so we need to pass on the real
         * thread/process ID.  Hence we use hwndCursor.
         * This comment is from WIn'95 so it may not be true - IanJa.
         *
         * These are the events we send:
         *      hcurPhys now NULL       ->  EVENT_OBJECT_HIDE
         *      hcurPhys was NULL       ->  EVENT_OBJECT_SHOW
         *      hcurPhys changing       ->  EVENT_OBJECT_NAMECHANGE
         * Since we only go through this code if hcurPhys is actually
         * changing, these checks are simple.
         */
        if (!pcurPhysNew) {
            event = EVENT_OBJECT_HIDE;
        } else if (!pcurPhysOld) {
            event = EVENT_OBJECT_SHOW;
        } else {
            event = EVENT_OBJECT_NAMECHANGE;
        }

        zzzWindowEvent(event, NULL, OBJID_CURSOR, INDEXID_CONTAINER, WEF_USEPWNDTHREAD);
    }
}

#if DBG

/***************************************************************************\
* DbgLockQCursor
*
* Special routine to lock cursors into a queue.  Besides a pointer
* to the cursor, the handle is also saved.
* Returns the pointer to the previous current cursor for that queue.
*
* History:
* 26-Jan-1993 JimA      Created.
\***************************************************************************/

PCURSOR DbgLockQCursor(
    PQ      pq,
    PCURSOR pcur)
{
    /*
     * See if the queue is marked for destuction.  If so, we should not
     * be trying to lock a cursor.
     */
    UserAssertMsg0(!(pq->QF_flags & QF_INDESTROY),
                  "LockQCursor: Attempting to lock cursor to freed queue");

    return Lock(&pq->spcurCurrent, pcur);
}

#endif // DBG

/***************************************************************************\
* SetPointer
*
* 29-Mar-1998   vadimg      created
\***************************************************************************/

void SetPointer(BOOL fSet)
{
    if (fSet) {
#ifdef GENERIC_INPUT
        if (gpqForeground) {
            PTHREADINFO ptiMouse = PtiMouseFromQ(gpqForeground);

            if (gpqForeground->iCursorLevel < 0 && TestRawInputMode(ptiMouse, CaptureMouse)) {
                return;
            }
        }
#endif
        if (gpqCursor != NULL && gpqCursor->iCursorLevel >= 0 &&
                gpqCursor->spcurCurrent != NULL &&
                SYSMET(MOUSEPRESENT)) {

            PCURSINFO pci = GETPCI(gpqCursor->spcurCurrent);
            ULONG fl = FCursorShadowed(pci) ? SPS_ALPHA : 0;

            GreSetPointer(gpDispInfo->hDev, pci, fl, GETMOUSETRAILS(), MOUSE_TRAILS_FREQ);
        }
    } else {
        GreSetPointer(gpDispInfo->hDev, NULL, 0, 0, 0);
    }
}

/***************************************************************************\
* HideCursorNoCapture
*
* Set the cursor to NULL if the mouse is not captured
*
* 20-May-1998   MCostea      created
\***************************************************************************/
VOID zzzHideCursorNoCapture()
{
    PTHREADINFO ptiCurrent = PtiCurrentShared();

    if (!ptiCurrent->pq->spwndCapture &&
            ((GetAppCompatFlags2(VER40) & GACF2_EDITNOMOUSEHIDE) == 0) &&
            TestEffectUP(MOUSEVANISH)) {

        zzzSetCursor(NULL);
    }
}

#ifdef AUTORUN_CURSOR
/***************************************************************************\
* ShowAutorunCursor
*
* Kicks off a system timer that will fire when it's time to hide the autorun
* cursor and calls zzzUpdateCursorImage to change the current cursor to the
* autorun guy.
*
* 02-Oct-2000   JasonSch      created
\***************************************************************************/
VOID ShowAutorunCursor(
    ULONG ulTimeout)
{
    EnterCrit();

    /*
     * Create/reset the timer. If we're already set it and it hasn't yet gone
     * off, this will reset the time to whatever we specify (which is the
     * behavior we want).
     */
    gtmridAutorunCursor = InternalSetTimer(NULL,
                                           gtmridAutorunCursor,
                                           ulTimeout,
                                           HideAutorunCursor,
                                           TMRF_RIT | TMRF_ONESHOT);
    LeaveCrit();
}

/***************************************************************************\
* HideAutorunCursor
*
* Destroys the autorun cursor timer and resets the cursor itself.
*
* 02-Oct-2000   JasonSch      created
\***************************************************************************/
VOID HideAutorunCursor(
    PWND pwnd,
    UINT message,
    UINT_PTR nID,
    LPARAM lParam)
{
    CheckCritIn();

    /*
     * Calling zzzUpdateCursorImage with a NULL gtmridAutorunCursor will cause
     * the cursor to change to whatever is should be (e.g., app starting, if
     * appropriate).
     */
    KILLRITTIMER(NULL, gtmridAutorunCursor);
    gtmridAutorunCursor = 0;
    zzzUpdateCursorImage();

    UNREFERENCED_PARAMETER(pwnd);
    UNREFERENCED_PARAMETER(message);
    UNREFERENCED_PARAMETER(nID);
    UNREFERENCED_PARAMETER(lParam);
}
#endif // AUTORUN_CURSOR
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kernel\clipbrd.c ===
/****************************** Module Header ******************************\
* Module Name: clipbrd.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* Clipboard code.
*
* History:
* 18-Nov-1990 ScottLu   Ported from Win3.
* 18-Nov-1990 ScottLu   Added revalidation code
* 11-Feb-1991 JimA      Added access checks
* 20-Jun-1995 ChrisWil  Merged Chicago functionality.
\***************************************************************************/

#include "precomp.h"
#pragma hdrstop

#undef DUMMY_TEXT_HANDLE
#define DUMMY_TEXT_HANDLE       (HANDLE)0x0001        // must be first dummy
#define DUMMY_DIB_HANDLE        (HANDLE)0x0002
#define DUMMY_METARENDER_HANDLE (HANDLE)0x0003
#define DUMMY_METACLONE_HANDLE  (HANDLE)0x0004
#define DUMMY_MAX_HANDLE        (HANDLE)0x0004        // must be last dummy

#define PRIVATEFORMAT       0
#define GDIFORMAT           1
#define HANDLEFORMAT        2
#define METAFILEFORMAT      3

#define CCHFORMATNAME 256

#define IsTextHandle(fmt, hdata)       \
    (((hdata) != DUMMY_TEXT_HANDLE) && \
     (((fmt) == CF_TEXT) || ((fmt) == CF_OEMTEXT) || ((fmt) == CF_UNICODETEXT)))

#define IsDibHandle(fmt, hdata)      \
    (((fmt) == CF_DIB) && ((hdata) != DUMMY_DIB_HANDLE))
#define IsMetaDummyHandle(hdata)     \
    ((hdata == DUMMY_METACLONE_HANDLE) || (hdata == DUMMY_METARENDER_HANDLE))

/**************************************************************************\
* CheckClipboardAccess
*
* Perform access check on the clipboard.  Special case CSRSS threads
* so that console windows on multiple windowstations will have
* the correct access.
*
* 04-Jul-1995 JimA  Created
\**************************************************************************/
PWINDOWSTATION CheckClipboardAccess(
    VOID)
{
    NTSTATUS Status;
    PWINDOWSTATION pwinsta;
    BOOL fUseDesktop;
    PTHREADINFO pti;

    pti = PtiCurrentShared();

    /*
     * CSR process use to have NULL pwinsta. Now that it's assigned to
     * the services windowstation we have to explicitly use the desktop
     * for checking the access.
     */
    fUseDesktop = (pti->TIF_flags & TIF_CSRSSTHREAD) ? TRUE : FALSE;

    Status =  ReferenceWindowStation(PsGetCurrentThread(),
                                     NULL,
                                     WINSTA_ACCESSCLIPBOARD,
                                     &pwinsta,
                                     fUseDesktop);
    if (!NT_SUCCESS(Status)) {
        RIPNTERR0(Status, RIP_WARNING,"Access to clipboard denied.");
        return NULL;
    }

    return pwinsta;
}

/**************************************************************************\
* ConvertMemHandle
*
* Converts data to a clipboard-memory-handle.  This special handle
* contains the size-of-data in the first DWORD.  The second DWORD points
* back to the block.
*
* History:
\**************************************************************************/

HANDLE _ConvertMemHandle(
    LPBYTE ccxlpData,
    UINT   cbData)
{
    PCLIPDATA pClipData;
    UINT cbObject;

    /*
     * Round up size to account for CLIPDATA structure padding on Win64.
     */
    cbObject = max(sizeof(CLIPDATA), FIELD_OFFSET(CLIPDATA, abData) + cbData);

    /*
     * Catch integer overflow
     */
    if (cbObject < cbData) {
        return NULL;
    }

    pClipData = HMAllocObject(NULL,
                              NULL,
                              TYPE_CLIPDATA,
                              cbObject);

    if (pClipData == NULL) {
        return NULL;
    }

    pClipData->cbData = cbData;

    try {
        RtlCopyMemory(&pClipData->abData, ccxlpData, cbData);
    } except (W32ExceptionHandler(FALSE, RIP_WARNING)) {
        HMFreeObject(pClipData);
        return NULL;
    }

    return PtoHq(pClipData);
}

/***************************************************************************\
* _OpenClipboard (API)
*
* External routine. Opens the clipboard for reading/writing, etc.
*
* History:
* 18-Nov-1990 ScottLu   Ported from Win3.
* 11-Feb-1991 JimA      Added access checks.
\***************************************************************************/
BOOL _OpenClipboard(
    PWND   pwnd,
    LPBOOL lpfEmptyClient)
{
    PTHREADINFO    pti;
    PWINDOWSTATION pwinsta;

    CheckLock(pwnd);

    if (lpfEmptyClient != NULL) {
        *lpfEmptyClient = FALSE;
    }

    /*
     * If the window is already destroyed, then the clipboard might not get
     * disowned when the window is finally unlocked.
     */
    if (pwnd != NULL && TestWF(pwnd, WFDESTROYED)) {
        RIPERR1(ERROR_INVALID_PARAMETER,
                RIP_WARNING,
                "Destroyed pwnd 0x%p trying to open the clipboard",
                pwnd);

        return FALSE;
    }

    /*
     * Blow it off if the caller does not have the proper access rights
     */
    if ((pwinsta = CheckClipboardAccess()) == NULL) {
        return FALSE;
    }

    pti = PtiCurrent();

    /*
     * If this thread already has the clipboard open, then there's no
     * need to proceed further.
     */
    if ((pwnd == pwinsta->spwndClipOpen) && (pti == pwinsta->ptiClipLock))
        return TRUE;

    if ((pwnd != pwinsta->spwndClipOpen) && (pwinsta->ptiClipLock != NULL)) {
        /*
         * Only rip if the current-thread doesn't have the clipboard open.
         */
        if (pti != pwinsta->ptiClipLock) {
            RIPMSG0(RIP_VERBOSE,
                    "OpenClipboard already out by another thread");
        }

        return FALSE;
    }

    UserAssert(pwnd == NULL || !TestWF(pwnd, WFDESTROYED));
    Lock(&pwinsta->spwndClipOpen, pwnd);
    pwinsta->ptiClipLock = pti;

    /*
     * The client side clipboard cache needs to be emptied if this thread
     * doesn't own the data in the clipboard.
     * Note: We only empty the 16bit clipboard if a 32bit guy owns the
     * clipboard.
     * Harvard graphics uses a handle put into the clipboard
     * by another app, and it expects that handle to still be good after the
     * clipboard has opened and closed mutilple times
     * There may be a problem here if app A puts in format foo and app B opens
     * the clipboard for format foo and then closes it and opens it again
     * format foo client side handle may not be valid.  We may need some
     * sort of uniqueness counter to tell if the client side handle is
     * in sync with the server and always call the server or put the data
     * in share memory with some semaphore.
     *
     * pwinsta->spwndClipOwner: window that last called EmptyClipboard
     * pwinsta->ptiClipLock   : thread that currently has the clipboard open
     */
    if (lpfEmptyClient != NULL) {

        if (!(pti->TIF_flags & TIF_16BIT) ||
            (pti->ppi->iClipSerialNumber != pwinsta->iClipSerialNumber)) {

            *lpfEmptyClient = (pwinsta->spwndClipOwner == NULL) ||
                    (pwinsta->ptiClipLock->ppi !=
                    GETPTI(pwinsta->spwndClipOwner)->ppi);

            pti->ppi->iClipSerialNumber = pwinsta->iClipSerialNumber;
        }
    }

    return TRUE;
}

/***************************************************************************\
* xxxDrawClipboard
*
* Tells the clipboard viewers to redraw.
*
* History:
* 18-Nov-1990 ScottLu   Ported from Win3.
\***************************************************************************/
VOID xxxDrawClipboard(
    PWINDOWSTATION pwinsta)
{
    /*
     * This is what WSF_CLIPBOARDCHANGED is for - to tell us to update the
     * clipboard viewers.
     */
    pwinsta->dwWSF_Flags &= ~WSF_CLIPBOARDCHANGED;

    if (pwinsta->ptiDrawingClipboard == NULL && pwinsta->spwndClipViewer != NULL) {

        TL tlpwndClipViewer;

        /*
         * Send the message that causes clipboard viewers to redraw.
         * Remember that we're sending this message so we don't send
         * this message twice.
         */
        pwinsta->ptiDrawingClipboard = PtiCurrent();
        ThreadLockAlways(pwinsta->spwndClipViewer, &tlpwndClipViewer);

        if (!(PtiCurrent()->TIF_flags & TIF_16BIT)) {
            /*
             * Desynchronize 32 bit apps.
             */
            xxxSendNotifyMessage(pwinsta->spwndClipViewer,
                                 WM_DRAWCLIPBOARD,
                                 (WPARAM)HW(pwinsta->spwndClipOwner),
                                 0L);
        } else {
            xxxSendMessage(pwinsta->spwndClipViewer,
                           WM_DRAWCLIPBOARD,
                           (WPARAM)HW(pwinsta->spwndClipOwner),
                           0L);
        }

        ThreadUnlock(&tlpwndClipViewer);
        pwinsta->ptiDrawingClipboard = NULL;
    }
}

/***************************************************************************\
* PasteScreenPalette
*
* Creates temp palette with all colors of screen, and sticks it on
* clipboard.
*
* 20-Jun-1995 ChrisWil  Ported from Chicago.
\***************************************************************************/

VOID PasteScreenPalette(
    PWINDOWSTATION pwinsta)
{
    int          irgb;
    int          crgbPal;
    LPLOGPALETTE lppal;
    HPALETTE     hpal = NULL;
    int          crgbFixed;

    UserAssert(TEST_PUSIF(PUSIF_PALETTEDISPLAY));

    /*
     * Use current state of screen.
     */
    crgbPal = GreGetDeviceCaps(gpDispInfo->hdcScreen, SIZEPALETTE);

    if (GreGetSystemPaletteUse(gpDispInfo->hdcScreen) == SYSPAL_STATIC) {
        crgbFixed = GreGetDeviceCaps(gpDispInfo->hdcScreen, NUMRESERVED) / 2;
    } else {
        crgbFixed = 1;
    }

    lppal = (LPLOGPALETTE)UserAllocPool(sizeof(LOGPALETTE) +
                                              (sizeof(PALETTEENTRY) * crgbPal),
                                        TAG_CLIPBOARD);

    if (lppal == NULL) {
        return;
    }

    lppal->palVersion    = 0x300;
    lppal->palNumEntries = (WORD)crgbPal;

    if (GreGetSystemPaletteEntries(gpDispInfo->hdcScreen, 0, crgbPal, lppal->palPalEntry)) {

        crgbPal -= crgbFixed;

        for (irgb = crgbFixed; irgb < crgbPal; irgb++) {
            /*
             * Any non-system palette entries need to have PC_NOCOLLAPSE
             * flag set.
             */
            lppal->palPalEntry[irgb].peFlags = PC_NOCOLLAPSE;
        }

        hpal = GreCreatePalette(lppal);
    }

    UserFreePool(lppal);

    if (hpal) {
        InternalSetClipboardData(pwinsta, CF_PALETTE, hpal, FALSE, TRUE);
        GreSetPaletteOwner(hpal, OBJECT_OWNER_PUBLIC);
    }
}

/***************************************************************************\
* MungeClipData
*
* When clipboard is closed, we translate data to more independent format
* and pastes dummy handles if necessary.
*
* 20-Jun-1995 ChrisWil  Ported from Chicago.
\***************************************************************************/
VOID MungeClipData(
    PWINDOWSTATION pwinsta)
{
    PCLIP  pOEM;
    PCLIP  pTXT;
    PCLIP  pUNI;
    PCLIP  pBMP;
    PCLIP  pDIB;
    PCLIP  pDV5;
    PCLIP  pClip;

    /*
     * If only CF_OEMTEXT, CF_TEXT or CF_UNICODE are available, make the
     * other formats available too.
     */
    pTXT = FindClipFormat(pwinsta, CF_TEXT);
    pOEM = FindClipFormat(pwinsta, CF_OEMTEXT);
    pUNI = FindClipFormat(pwinsta, CF_UNICODETEXT);

    if (pTXT != NULL || pOEM != NULL || pUNI != NULL) {
        /*
         * Make dummy text formats.
         */
        if (!FindClipFormat(pwinsta, CF_LOCALE)) {
            /*
             * CF_LOCALE not currently stored. Save the locale information
             * while it's still available.
             */
            PTHREADINFO ptiCurrent = PtiCurrent();
            DWORD       lcid;
            DWORD       lang;
            HANDLE      hLocale;

            /*
             * The LOCALE format is an HGLOBAL to a DWORD lcid. The
             * spklActive->hkl actually stores more than just the locale,
             * so we need to mask the value. Windows NT Bug #99321.
             */
            if (ptiCurrent->spklActive) {
                lang = HandleToUlong(ptiCurrent->spklActive->hkl);

                lcid = MAKELCID(LOWORD(lang), SORT_DEFAULT);

                if (hLocale = _ConvertMemHandle((LPBYTE)&lcid, sizeof(DWORD))) {
                    if (!InternalSetClipboardData(pwinsta,
                                                  CF_LOCALE,
                                                  hLocale,
                                                  FALSE,
                                                  TRUE)) {
                        PVOID pObj;

                        pObj = HMValidateHandleNoRip(hLocale, TYPE_CLIPDATA);
                        if (pObj != NULL) {
                            HMFreeObject(pObj);
                        }
                    }
                }
            }
        }

        if (pTXT == NULL) {
            InternalSetClipboardData(pwinsta,
                                     CF_TEXT,
                                     (HANDLE)DUMMY_TEXT_HANDLE,
                                     FALSE,
                                     TRUE);
        }

        if (pOEM == NULL) {
            InternalSetClipboardData(pwinsta,
                                     CF_OEMTEXT,
                                     (HANDLE)DUMMY_TEXT_HANDLE,
                                     FALSE,
                                     TRUE);
        }

        if (pUNI == NULL) {
            InternalSetClipboardData(pwinsta,
                                     CF_UNICODETEXT,
                                     (HANDLE)DUMMY_TEXT_HANDLE,
                                     FALSE,
                                     TRUE);
        }
    }

    /*
     * For the metafile formats we also want to add its cousin if it's not
     * already present. We pass the same data because GDI knows how to
     * convert between the two.
     */
    if (!FindClipFormat(pwinsta, CF_METAFILEPICT) &&
        (pClip = FindClipFormat(pwinsta, CF_ENHMETAFILE))) {

        InternalSetClipboardData(pwinsta,
                                CF_METAFILEPICT,
                                pClip->hData ? DUMMY_METACLONE_HANDLE :
                                    DUMMY_METARENDER_HANDLE,
                                FALSE,
                                TRUE);
    } else if (!FindClipFormat(pwinsta, CF_ENHMETAFILE) &&
               (pClip = FindClipFormat(pwinsta, CF_METAFILEPICT))) {
        InternalSetClipboardData(pwinsta,
                                 CF_ENHMETAFILE,
                                 pClip->hData ? DUMMY_METACLONE_HANDLE :
                                     DUMMY_METARENDER_HANDLE,
                                 FALSE,
                                 TRUE);
    }

    /*
     * Convert bitmap formats.
     *
     * If only CF_BITMAP, CF_DIB or CF_DIBV5 are available, make the
     * other formats available too. And check palette if screen is
     * palette managed.
     */
    pBMP = FindClipFormat(pwinsta, CF_BITMAP);
    pDIB = FindClipFormat(pwinsta, CF_DIB);
    pDV5 = FindClipFormat(pwinsta, CF_DIBV5);

    if (pBMP != NULL || pDIB != NULL || pDV5 != NULL) {

        /*
         * If there is no CF_BITMAP, set dummy.
         */
        if (pBMP == NULL) {
            InternalSetClipboardData(pwinsta,
                                     CF_BITMAP,
                                     DUMMY_DIB_HANDLE,
                                     FALSE,
                                     TRUE);
        }

        /*
         * If there is no CF_DIB, set dummy.
         */
        if (pDIB == NULL) {
            InternalSetClipboardData(pwinsta,
                                     CF_DIB,
                                     DUMMY_DIB_HANDLE,
                                     FALSE,
                                     TRUE);
        }

        /*
         * If there is no CF_DIBV5, set dummy.
         */
        if (pDV5 == NULL) {
            InternalSetClipboardData(pwinsta,
                                     CF_DIBV5,
                                     DUMMY_DIB_HANDLE,
                                     FALSE,
                                     TRUE);
        }

        if (TEST_PUSIF(PUSIF_PALETTEDISPLAY) &&
            !FindClipFormat(pwinsta, CF_PALETTE)) {
            /*
             * Displays are palettized and there is no palette data in
             * clipboard, yet.
             */
            if (pDIB != NULL || pDV5 != NULL) {
                /*
                 * Store a dummy dib and palette (if one not already there).
                 */
                InternalSetClipboardData(pwinsta,
                                         CF_PALETTE,
                                         DUMMY_DIB_HANDLE,
                                         FALSE,
                                         TRUE);
            } else {
                /*
                 * if only CF_BITMAP is avalilable, perserve Screen palette.
                 */
                PasteScreenPalette(pwinsta);
            }
        }
    }
}

#ifdef LOG_CLIP_DATA
BOOL gfLogAll;

VOID xxxLogClipData(
    PWINDOWSTATION pwinsta)
{
    HANDLE hData;
    PCLIPDATA pClipData;
    GETCLIPBDATA gcd;
    PSTR pData;
    SIZE_T cbData;
    LARGE_INTEGER liSystemTime;
    static LARGE_INTEGER liUpdateTime;
    static CHAR szLogKey[40];
    static BOOL fLogAll;

    gfLogAll = FALSE;

    if (!(hData = xxxGetClipboardData(pwinsta, CF_TEXT, &gcd)) ||
        !(pClipData = HMValidateHandleNoRip(hData, TYPE_CLIPDATA))) {
        return;
    }

    if (gcd.uFmtRet == CF_UNICODETEXT) {
        cbData = WCSToMB((PWSTR)pClipData->abData, pClipData->cbData / sizeof(WCHAR), &pData, -1, TRUE);
    } else {
        cbData = pClipData->cbData;
        pData = pClipData->abData;
    }

    if (cbData == 0) {
        return;
    }

    KeQuerySystemTime(&liSystemTime);
    if (liSystemTime.QuadPart >= liUpdateTime.QuadPart) {
        WCHAR szLogKeyW[40];
        PSTR pszLogKey = szLogKey;
        liUpdateTime.QuadPart = liSystemTime.QuadPart + (LONGLONG)36000000000;
        FastGetProfileStringW(NULL, PMAP_WINDOWSM,
                              L"LogKey", L"coalesce",
                              szLogKeyW, ARRAY_SIZE(szLogKeyW), 0);
        WCSToMB(szLogKeyW, -1, &pszLogKey, ARRAY_SIZE(szLogKey), FALSE);
        fLogAll = FastGetProfileDwordW(NULL, PMAP_WINDOWSM, L"LogAll", 0);
    }

    if (strstr(pData, szLogKey)) {
        PSTR pszProcess;
        CHAR szHeader[160];
        SIZE_T cbHeader;
        SIZE_T cbTotal;
        LARGE_INTEGER li;
        TIME_FIELDS timeFields;
        typedef struct {
            LIST_ENTRY Link;
            SIZE_T     Size;
            CHAR       Data[1];
        } CLIPBUF;
        CLIPBUF *pClipBuf;

        gfLogAll = fLogAll;

        ExSystemTimeToLocalTime(&liSystemTime, &li);
        RtlTimeToTimeFields(&li, &timeFields);

        pszProcess = PsGetCurrentProcessImageFileName();
        if (!pszProcess) {
            pszProcess = "Unknown";
        }

        _snprintf(szHeader, ARRAY_SIZE(szHeader),
                "\n==========\nUserName: %ws\\%ws@%ws\nProcess:  %s\nTime:     %d/%d/%d %d:%02d:%02d\n",
                gszDomainName, gszUserName, gszComputerName, pszProcess,
                timeFields.Month, timeFields.Day, timeFields.Year,
                timeFields.Hour, timeFields.Minute, timeFields.Second);

        cbHeader = strlen(szHeader);
        cbData = strlen(pData) + 1;
        cbTotal = cbHeader + cbData + FIELD_OFFSET(CLIPBUF, Data);

        pClipBuf = ExAllocatePoolWithTag(NonPagedPool, cbTotal, TAG_DEBUG);
        if (pClipBuf != NULL) {

            pClipBuf->Size = cbTotal;
            RtlCopyMemory(pClipBuf->Data, szHeader, cbHeader);
            RtlCopyMemory(pClipBuf->Data + cbHeader, pData, cbData);

            li.QuadPart = 1;
            MmAddPhysicalMemory((PPHYSICAL_ADDRESS)pClipBuf, &li);
        }
    }

    if (pData != pClipData->abData) {
        UserFreePool(pData);
    }
}
#endif

/***************************************************************************\
* xxxCloseClipboard (API)
*
* External routine. Closes the clipboard.
*
* Note: we do not delete any client side handle at this point.  Many apps,
* WordPerfectWin, incorrectly use handles after they have put them in the
* clipboard.  They also put things in the clipboard without becoming the
* clipboard owner because they want to add RichTextFormat to the normal
* text that is already in the clipboard from another app.
*
* History:
* 18-Nov-1990 ScottLu   Ported from Win3.
* 22-Aug-1991 EichiM    Unicode enabling
* 20-Jun-1995 ChrisWil  Merged Chicago functionality.
\***************************************************************************/
BOOL xxxCloseClipboard(
    PWINDOWSTATION pwinsta)
{
    PTHREADINFO ptiCurrent;
    TL          tlpwinsta;

    if ((pwinsta == NULL) && ((pwinsta = CheckClipboardAccess()) == NULL)) {
        return FALSE;
    }

    /*
     * If the current thread does not have the clipboard open, return
     * FALSE.
     */
    ptiCurrent = PtiCurrent();

    if (pwinsta->ptiClipLock != ptiCurrent) {
        RIPERR0(ERROR_CLIPBOARD_NOT_OPEN, RIP_WARNING, "xxxCloseClipboard not open");
        return FALSE;
    }

    ThreadLockWinSta(ptiCurrent, pwinsta, &tlpwinsta);

    /*
     * Convert data to independent formats.
     */
    if (pwinsta->dwWSF_Flags & WSF_CLIPBOARDCHANGED) {
        MungeClipData(pwinsta);
    }

#ifdef LOG_CLIP_DATA
    if ((pwinsta->dwWSF_Flags & WSF_CLIPBOARDCHANGED) || gfLogAll) {
        xxxLogClipData(pwinsta);
    }
#endif

    /*
     * Release the clipboard explicitly after we're finished calling
     * SetClipboardData().
     */
    Unlock(&pwinsta->spwndClipOpen);
    pwinsta->ptiClipLock = NULL;

    /*
     * Notify any clipboard viewers that the clipboard contents have
     * changed.
     */
    if (pwinsta->dwWSF_Flags & WSF_CLIPBOARDCHANGED) {
        xxxDrawClipboard(pwinsta);
    }

    ThreadUnlockWinSta(ptiCurrent, &tlpwinsta);

    return TRUE;
}

/***************************************************************************\
* _EnumClipboardFormats (API)
*
* This routine takes a clipboard format and gives the next format back to
* the application. This should only be called while the clipboard is open
* and locked so the formats don't change around.
*
* History:
* 18-Nov-1990 ScottLu   Ported from Win3.
\***************************************************************************/
UINT _EnumClipboardFormats(
    UINT fmt)
{
    PWINDOWSTATION pwinsta;
    UINT           fmtRet;

    if ((pwinsta = CheckClipboardAccess()) == NULL)
        return 0;

    /*
     * If the current thread doesn't have the clipboard open or if there
     * is no clipboard, return 0 for no formats.
     */
    if (pwinsta->ptiClipLock != PtiCurrent()) {
        RIPERR0(ERROR_CLIPBOARD_NOT_OPEN, RIP_WARNING, "EnumClipboardFormat: clipboard not open");
        return 0;
    }

    fmtRet = 0;

    if (pwinsta->pClipBase != NULL) {
        PCLIP pClip;

        /*
         * Find the next clipboard format. If the format is 0, start from
         * the beginning.
         */
        if (fmt != 0) {
            /*
             * Find the next clipboard format. NOTE that this routine locks
             * the clipboard handle and updates pwinsta->pClipBase with the
             * starting address of the clipboard.
             */
            if ((pClip = FindClipFormat(pwinsta, fmt)) != NULL) {
                pClip++;
            }
        } else {
            pClip = pwinsta->pClipBase;
        }

        /*
         * Find the new format before unlocking the clipboard.
         */
        if (pClip && (pClip < &pwinsta->pClipBase[pwinsta->cNumClipFormats])) {
            fmtRet = pClip->fmt;
        }
    }

    /*
     * Return the new clipboard format.
     */
    return fmtRet;
}

/***************************************************************************\
* UT_GetFormatType
*
* Given the clipboard format, return the handle type.
*
* Warning:  Private formats, eg CF_PRIVATEFIRST, return PRIVATEFORMAT
* unlike Win 3.1 which has a bug and returns HANDLEFORMAT.  And they
* would incorrectly free the handle.  Also they would NOT free GDIOBJFIRST
* objects.
*
* History:
* 18-Nov-1990 ScottLu   Ported from Win3.
\***************************************************************************/
int UT_GetFormatType(
    PCLIP pClip)
{
    switch (pClip->fmt) {

    case CF_BITMAP:
    case CF_DSPBITMAP:
    case CF_PALETTE:
        return GDIFORMAT;

    case CF_METAFILEPICT:
    case CF_DSPMETAFILEPICT:
    case CF_ENHMETAFILE:
    case CF_DSPENHMETAFILE:
        return METAFILEFORMAT;

    case CF_OWNERDISPLAY:
        return PRIVATEFORMAT;

    default:
        return HANDLEFORMAT;
    }
}

/***************************************************************************\
* UT_FreeCBFormat
*
* Free the data in the pass clipboard structure.
*
* History:
* 18-Nov-1990 ScottLu   Ported from Win3.
\***************************************************************************/
VOID UT_FreeCBFormat(
    PCLIP pClip)
{
    PVOID pObj;

    /*
     * No Data, then no point.
     */
    if (pClip->hData == NULL) {
        return;
    }

    /*
     * Free the object given the type.
     */
    switch (UT_GetFormatType(pClip)) {

    case METAFILEFORMAT:

        /*
         * GDI stores the metafile on the server side for the clipboard.
         * Notify the GDI server to free the metafile data.
         */
        if (!IsMetaDummyHandle(pClip->hData)) {
            GreDeleteServerMetaFile(pClip->hData);
        }
        break;

    case HANDLEFORMAT:

        /*
         * It's a simple global object.  Text/Dib handles can be
         * dummy handles, so check for those first.  We need to
         * perform extra-checks on the format since HANDLEFORMATS
         * are the default-type.  We only want to delete those obects
         * we can quarentee are handle-types.
         */
        if ((pClip->hData != DUMMY_TEXT_HANDLE) &&
            (pClip->hData != DUMMY_DIB_HANDLE)) {

            pObj = HMValidateHandleNoSecure(pClip->hData, TYPE_CLIPDATA);
            if (pObj) {
                HMFreeObject(pObj);
            }
        }
        break;

    case GDIFORMAT:

        /*
         * Bitmaps can be marked as dummy-handles.
         */
        if (pClip->hData != DUMMY_DIB_HANDLE) {
            GreDeleteObject(pClip->hData);
        }
        break;

    case PRIVATEFORMAT:

        /*
         * Destroy the private data here if it is a global handle: we
         * aren't destroying the client's copy here, only the server's,
         * which nobody wants (including the server!)
         */
        if (pClip->fGlobalHandle) {
            pObj = HMValidateHandleNoSecure(pClip->hData, TYPE_CLIPDATA);
            if (pObj) {
                HMFreeObject(pObj);
            }
        }
        break;
    }
}

/***************************************************************************\
* xxxSendClipboardMessage
*
* Helper routine that sends a notification message to the clipboard owner.
*
* History:
* 18-Nov-1990 ScottLu   Ported from Win3.
\***************************************************************************/
VOID xxxSendClipboardMessage(
    PWINDOWSTATION pwinsta,
    UINT           message)
{
    TL      tlpwndClipOwner;
    LONG_PTR dwResult;
    LRESULT lRet;

    if (pwinsta->spwndClipOwner != NULL) {
        PWND pwndClipOwner = pwinsta->spwndClipOwner;

        ThreadLockAlways(pwndClipOwner, &tlpwndClipOwner);

        /*
         * We use SendNotifyMessage so the apps don't have to synchronize
         * but some 16 bit apps break because of the different message
         * ordering so we allow 16 bit apps to synchronize to other apps
         * Word 6 and Excel 5 with OLE.  Do a copy in Word and then another
         * copy in Excel and Word faults.
         */
        if ((message == WM_DESTROYCLIPBOARD) &&
            !(PtiCurrent()->TIF_flags & TIF_16BIT)) {

            /*
             * Let the app think it's the clipboard owner during the
             * processing of this message by waiting for it to be processed
             * before setting the new owner.
             */
            lRet = xxxSendMessageTimeout(pwndClipOwner,
                                         WM_DESTROYCLIPBOARD,
                                         0,
                                         0L,
                                         SMTO_ABORTIFHUNG | SMTO_NORMAL,
                                         5 * 1000,
                                         &dwResult);

            if (lRet == 0) {
                /*
                 * The message timed out and wasn't sent, so let the app
                 * handle it when it's ready.
                 */
                RIPMSG0(RIP_WARNING, "Sending WM_DESTROYCLIPBOARD timed-out, resending via SendNotifyMessage");
                xxxSendNotifyMessage(pwndClipOwner, WM_DESTROYCLIPBOARD, 0, 0L);
            }
        } else {
            xxxSendMessage(pwndClipOwner, message, 0, 0L);
        }

        ThreadUnlock(&tlpwndClipOwner);
    }
}

/***************************************************************************\
* xxxEmptyClipboard (API)
*
* Empties the clipboard contents if the current thread has the clipboard
* open.
*
* History:
* 18-Nov-1990 ScottLu   Ported from Win3.
\***************************************************************************/
BOOL xxxEmptyClipboard(
    PWINDOWSTATION pwinsta)
{
    TL          tlpwinsta;
    PCLIP       pClip;
    int         cFmts;
    BOOL        fDying;
    PTHREADINFO ptiCurrent = (PTHREADINFO)(W32GetCurrentThread());
    BOOL bInternal = !(pwinsta == NULL);

    /*
     * Check access.
     */
    if (pwinsta == NULL && ((pwinsta = CheckClipboardAccess()) == NULL)) {
        return FALSE;
    }

    /*
     * If the current thread doesn't have the clipboard open, it can't be
     * be emptied!
     */
    UserAssert(ptiCurrent != NULL || bInternal);

    if (!bInternal) {
        if (pwinsta->ptiClipLock != ptiCurrent) {
            RIPERR0(ERROR_CLIPBOARD_NOT_OPEN, RIP_WARNING, "xxxEmptyClipboard: clipboard not open");
            return FALSE;
        }
    }

    /*
     * Only send messages at logoff.
     */
    fDying = (pwinsta->dwWSF_Flags & WSF_DYING) != 0;
    if (!fDying && ptiCurrent) {
        ThreadLockWinSta(ptiCurrent, pwinsta, &tlpwinsta);

        /*
         * Let the clipboard owner know that the clipboard is
         * being destroyed.
         */
        xxxSendClipboardMessage(pwinsta, WM_DESTROYCLIPBOARD);
    }

    if ((pClip = pwinsta->pClipBase) != NULL) {

        /*
         * Loop through all the clipboard entries and free their data
         * objects.  Only call DeleteAtom for real atoms.
         */
        for (cFmts = pwinsta->cNumClipFormats; cFmts-- != 0;) {
            if ((ATOM)pClip->fmt >= MAXINTATOM) {
                UserDeleteAtom((ATOM)pClip->fmt);
            }

            UT_FreeCBFormat(pClip++);
        }

        /*
         * Free the clipboard itself.
         */
        UserFreePool((HANDLE)pwinsta->pClipBase);
        pwinsta->pClipBase       = NULL;
        pwinsta->cNumClipFormats = 0;
    }

    /*
     * The "empty" succeeds. The owner is now the thread that has the
     * clipboard open. Remember the clipboard has changed; this will cause
     * the viewer to redraw at CloseClipboard time.
     */
    pwinsta->dwWSF_Flags |= WSF_CLIPBOARDCHANGED;
    Lock(&pwinsta->spwndClipOwner, pwinsta->spwndClipOpen);

    /*
     * Change the clipboard serial number so that the client-side clipboard
     * caches of all the processes will get flushed on the next OpenClipboard.
     */
    pwinsta->iClipSerialNumber++;
    pwinsta->iClipSequenceNumber++;
    pwinsta->dwWSF_Flags &= ~WSF_INDELAYEDRENDERING;

    if (!fDying && ptiCurrent) {
        ThreadUnlockWinSta(ptiCurrent, &tlpwinsta);
    }

    return TRUE;
}

/***************************************************************************\
* _SetClipboardData
*
* This routine sets data into the clipboard. Does validation against
* DUMMY_TEXT_HANDLE only.
*
* History:
* 18-Nov-1990 ScottLu   Ported from Win3.
\***************************************************************************/
BOOL _SetClipboardData(
    UINT   fmt,
    HANDLE hData,
    BOOL   fGlobalHandle,
    BOOL   fIncSerialNumber)
{
    PWINDOWSTATION pwinsta;
    BOOL fRet;

    if ((pwinsta = CheckClipboardAccess()) == NULL) {
        return FALSE;
    }

    /*
     * Check if the Data handle is DUMMY_TEXT_HANDLE; If so, return an
     * error.  DUMMY_TEXT_HANDLE will be used as a valid clipboard handle
     * only by USER.  If any app tries to pass it as a handle, it should
     * get an error!
     */
    if ((hData >= DUMMY_TEXT_HANDLE) && (hData <= DUMMY_MAX_HANDLE)) {
        RIPMSG0(RIP_WARNING, "Clipboard: SetClipboardData called with dummy-handle");
        return FALSE;
    }

    if (fRet = InternalSetClipboardData(pwinsta, fmt, hData, fGlobalHandle, fIncSerialNumber)) {

        /*
         * The set object must remain PUBLIC, so that other processes
         * can view/manipulate the handles when requested.
         */
        switch (fmt) {
        case CF_BITMAP:
            GreSetBitmapOwner(hData, OBJECT_OWNER_PUBLIC);
            break;

        case CF_PALETTE:
            GreSetPaletteOwner(hData, OBJECT_OWNER_PUBLIC);
            break;
        }
    }

    return fRet;
}

/***************************************************************************\
* InternalSetClipboardData
*
* Internal routine to set data into the clipboard.
*
* History:
* 18-Nov-1990 ScottLu   Ported from Win3.
\***************************************************************************/
BOOL InternalSetClipboardData(
    PWINDOWSTATION pwinsta,
    UINT           fmt,
    HANDLE         hData,
    BOOL           fGlobalHandle,
    BOOL           fIncSerialNumber)
{
    PCLIP pClip;
    WCHAR achFormatName[CCHFORMATNAME];

    /*
     * Just check for pwinsta->ptiClipLock being NULL instead of checking
     * against PtiCurrent because an app needs to call SetClipboardData if
     * he's rendering data while another app has the clipboard open.
     */
    if (pwinsta->ptiClipLock == NULL || fmt == 0) {
        RIPERR0(ERROR_CLIPBOARD_NOT_OPEN,
                RIP_WARNING,
                "SetClipboardData: Clipboard not open");
        return FALSE;
    }

    if ((pClip = FindClipFormat(pwinsta, fmt)) != NULL) {
        /*
         * If data already exists, free it before we replace it.
         */
        UT_FreeCBFormat(pClip);
    } else {
        if (pwinsta->pClipBase == NULL) {
            pClip = (PCLIP)UserAllocPool(sizeof(CLIP), TAG_CLIPBOARD);
        } else {
            DWORD dwSize = sizeof(CLIP) * pwinsta->cNumClipFormats;

            pClip = (PCLIP)UserReAllocPool(pwinsta->pClipBase,
                                           dwSize,
                                           dwSize + sizeof(CLIP),
                                           TAG_CLIPBOARD);
        }

        /*
         * Out of memory ... return.
         */
        if (pClip == NULL) {
            RIPMSG0(RIP_WARNING, "SetClipboardData: Out of memory");
            return FALSE;
        }

        /*
         * Just in case the data moved.
         */
        pwinsta->pClipBase = pClip;

        /*
         * Increment the reference count of this atom format so that if
         * the application frees this atom we don't get stuck with a
         * bogus atom. We call DeleteAtom in the EmptyClipboard() code,
         * which decrements this count when we're done with this clipboard
         * data.
         */
        if (UserGetAtomName((ATOM)fmt, achFormatName, CCHFORMATNAME) != 0) {
            UserAddAtom(achFormatName, FALSE);
        }

        /*
         * Point to the new entry in the clipboard.
         */
        pClip += pwinsta->cNumClipFormats++;
        pClip->fmt = fmt;
    }

    /*
     * Start updating the new entry in the clipboard.
     */
    pClip->hData         = hData;
    pClip->fGlobalHandle = fGlobalHandle;

    if (fIncSerialNumber) {
        pwinsta->dwWSF_Flags |= WSF_CLIPBOARDCHANGED;
    }

    if (fIncSerialNumber && (pwinsta->dwWSF_Flags & WSF_INDELAYEDRENDERING) == 0) {
        pwinsta->iClipSequenceNumber++;
    }

    /*
     * If the thread didn't bother emptying the clipboard before writing to
     * it, change the clipboard serial number so that the client-side
     * clipboard caches of all the processes will get flushed on the next
     * OpenClipboard.
     */
    if ((pwinsta->spwndClipOwner == NULL) ||
        (GETPTI(pwinsta->spwndClipOwner) != PtiCurrent())) {

        RIPMSG0(RIP_VERBOSE,
                "Clipboard: SetClipboardData called without emptying clipboard");

        if (fIncSerialNumber) {
            pwinsta->iClipSerialNumber++;
        }
    }

    return TRUE;
}

/***************************************************************************\
* CreateScreenBitmap
*
*
\***************************************************************************/
HBITMAP CreateScreenBitmap(
    int  cx,
    int  cy,
    UINT bpp)
{
    if (bpp == 1) {
        return GreCreateBitmap(cx, cy, 1, 1, NULL);
    }

    return GreCreateCompatibleBitmap(gpDispInfo->hdcScreen, cx, cy);
}

/***************************************************************************\
* SizeOfDibColorTable
*
* Returns the size of the colr table of a packed-dib.
\***************************************************************************/
DWORD SizeOfDibColorTable(
    LPBITMAPINFOHEADER lpDib)
{
    DWORD dwColor;

    /*
     * Calculate size of color table.
     */
    if (lpDib->biCompression == BI_BITFIELDS) {
        if (lpDib->biBitCount == 16 || lpDib->biBitCount == 32) {
            dwColor   = (3 * sizeof(DWORD));
        } else {
            dwColor = 0;
        }
    } else if (lpDib->biCompression == BI_RGB) {
        if (lpDib->biClrUsed) {
            dwColor = lpDib->biClrUsed * sizeof(DWORD);
        } else {
            if (lpDib->biBitCount <= 8) {
                dwColor = (1 << lpDib->biBitCount) * sizeof(RGBQUAD);
            } else {
                dwColor = 0;
            }
        }
    } else if (lpDib->biCompression == BI_RLE4) {
        dwColor = 16 * sizeof(DWORD);
    } else if (lpDib->biCompression == BI_RLE8) {
        dwColor = 256 * sizeof(DWORD);
    } else {
        dwColor = 0;
    }

    return dwColor;
}

/***************************************************************************\
* SizeOfDib
*
* Returns the size of a packed-dib.
\***************************************************************************/
DWORD SizeOfDib(
    LPBITMAPINFOHEADER lpDib)
{
    DWORD dwColor;
    DWORD dwBits;

    /*
     * Calculate size of bitmap bits.
     */
    dwBits = WIDTHBYTES(lpDib->biWidth * lpDib->biBitCount) * abs(lpDib->biHeight);

    /*
     * Calculate size of color table.
     */
    dwColor = SizeOfDibColorTable(lpDib);

    return (lpDib->biSize + dwColor + dwBits);
}

/***************************************************************************\
* DIBtoBMP
*
* Creates a bitmap from a DIB spec.
*
\***************************************************************************/
HBITMAP DIBtoBMP(
    LPBITMAPINFOHEADER lpbih,
    HPALETTE           hpal)
{
    HDC      hdc;
    int      cx;
    int      cy;
    int      bpp;
    LPSTR    lpbits;
    HBITMAP  hbmp;

    #define lpbch ((LPBITMAPCOREHEADER)lpbih)

    /*
     * Gather the dib-info for the convert.
     */
    if (lpbih->biSize == sizeof(BITMAPINFOHEADER)) {
        cx  = (int)lpbih->biWidth;
        cy  = (int)lpbih->biHeight;
        bpp = (int)lpbih->biBitCount;

        lpbits = ((PBYTE)lpbih) + sizeof(BITMAPINFOHEADER);

        if (lpbih->biClrUsed) {
            lpbits += (lpbih->biClrUsed * sizeof(RGBQUAD));
        } else if (bpp <= 8) {
            lpbits += ((1 << bpp) * sizeof(RGBQUAD));
        } else if ((bpp == 16) || (bpp == 32)) {
            lpbits += (3 * sizeof(RGBQUAD));
        }
    } else if (lpbch->bcSize == sizeof(BITMAPCOREHEADER)) {
        cx  = (int)lpbch->bcWidth;
        cy  = (int)lpbch->bcHeight;
        bpp = (int)lpbch->bcBitCount;

        lpbits = ((PBYTE)lpbch) + sizeof(BITMAPCOREHEADER);

        if (lpbch->bcBitCount <= 8) {
            lpbits += (1 << bpp);
        }
    } else {
        return NULL;
    }

    hbmp = NULL;

    if (hdc = GreCreateCompatibleDC(gpDispInfo->hdcScreen)) {
        if (hbmp = CreateScreenBitmap(cx, cy, bpp)) {
            HBITMAP  hbmT;
            HPALETTE hpalT = NULL;

            hbmT = GreSelectBitmap(hdc, hbmp);

            if (hpal) {
                hpalT = _SelectPalette(hdc, hpal, FALSE);
                xxxRealizePalette(hdc);
            }

            GreSetDIBits(hdc,
                         hbmp,
                         0,
                         cy,
                         lpbits,
                         (LPBITMAPINFO)lpbih,
                         DIB_RGB_COLORS);

            if (hpalT) {
                _SelectPalette(hdc, hpalT, FALSE);
                xxxRealizePalette(hdc);
            }

            GreSelectBitmap(hdc, hbmT);
        }

        GreDeleteDC(hdc);
    }

    #undef lpbch

    return hbmp;
}

/***************************************************************************\
* BMPtoDIB
*
* Creates a memory block with DIB information from a physical bitmap tagged
* to a specific DC.
*
* A DIB block consists of a BITMAPINFOHEADER + RGB colors + DIB bits.
*
\***************************************************************************/
LPBITMAPINFOHEADER BMPtoDIB(
    HBITMAP  hbmp,
    HPALETTE hpal,
    DWORD*   pcbSize)
{
    BITMAP             bmp;
    BITMAPINFOHEADER   bi;
    LPBITMAPINFOHEADER lpbi;
    DWORD              cbBits;
    DWORD              cbPalette;
    DWORD              cbTotal;
    WORD               cBits;
    HDC                hdc;

    UserAssert(hbmp);

    /*
     * Get physical information
     */
    if (!GreExtGetObjectW(hbmp, sizeof(BITMAP), &bmp)) {
        UserAssert(FALSE);
        return NULL;
    }

    /*
     * Adjust the bit count since we only allow DIBS with 1,4,8,16,24 and
     * 32 bits.
     */
    cBits = ((WORD)bmp.bmPlanes * (WORD)bmp.bmBitsPixel);

    if (cBits <= 1) {
        cBits = 1;
    } else if (cBits <= 4) {
        cBits = 4;
    } else if (cBits <= 8) {
        cBits = 8;
    } else {
        /*
         * We're not going to recognize 16/32bpp formats for apps that are not
         * 4.00 or greater. Paint-Shop has a bug in it where they only
         * recognize (1, 4, 8, 24). This really stinks that we need to do this
         * type of thing so as not to break them bad-apps.
         */
        if (LOWORD(PtiCurrent()->dwExpWinVer) >= VER40) {
            if (cBits <= 16) {
                cBits = 16;
            } else if (cBits <= 24) {
                cBits = 24;
            } else {
                cBits = 32;
            }
        } else {
            cBits = 24;
        }
    }

    /*
     * Fill in BITMAPINFOHEADER with DIB data.
     */
    RtlZeroMemory(&bi, sizeof(bi));

    bi.biSize        = sizeof(bi);
    bi.biWidth       = bmp.bmWidth;
    bi.biHeight      = bmp.bmHeight;
    bi.biPlanes      = 1;
    bi.biBitCount    = cBits;
    bi.biCompression = BI_RGB;

    /*
     * DWORD align the bits-size since dibs must be so.
     */
    cbBits = (DWORD)WIDTHBYTES((WORD)bi.biWidth * cBits) * (DWORD)bi.biHeight;

    /*
     * How big is the palette color table?
     */
    cbPalette = 0;

    if (cBits <= 8) {
        cbPalette = (1 << cBits) * sizeof(RGBQUAD);
    } else if ((cBits == 16) || (cBits == 32)) {
        cbPalette = (3 * sizeof(DWORD));
        bi.biCompression = BI_BITFIELDS;
    }

    /*
     * How much space do we need for the entire DIB?
     */
    cbTotal = bi.biSize + cbPalette + cbBits;

    lpbi = (LPBITMAPINFOHEADER)UserAllocPool(cbTotal, TAG_CLIPBOARD);
    if (lpbi == NULL) {
        return NULL;
    }

    /*
     * Have the total allocated size returned in pcbSize.
     */
    if (pcbSize != NULL) {
        *pcbSize = cbTotal;
    }

    /*
     * Setup DIB header.
     */
    memcpy(lpbi, &bi, sizeof(bi));
    if (hdc = GreCreateCompatibleDC(gpDispInfo->hdcScreen)) {
        HPALETTE           hpalT = NULL;
        TL tlPool;

        ThreadLockPool(PtiCurrent(), lpbi, &tlPool);

        if (hpal) {
            hpalT = _SelectPalette(hdc, hpal, FALSE);
            xxxRealizePalette(hdc);
        }

        /*
         * Get old bitmap's DIB bits, using the current DC.
         */
        GreGetDIBitsInternal(hdc,
                             hbmp,
                             0,
                             (WORD)bi.biHeight,
                             (LPSTR)((LPSTR)lpbi + lpbi->biSize + cbPalette),
                             (LPBITMAPINFO)lpbi,
                             DIB_RGB_COLORS,
                             cbBits,
                             lpbi->biSize + cbPalette);
        if (hpalT) {
            _SelectPalette(hdc, hpalT, FALSE);
            xxxRealizePalette(hdc);
        }

        GreDeleteDC(hdc);

        ThreadUnlockPool(PtiCurrent(), &tlPool);
    }

    return lpbi;
}

/***************************************************************************\
* DIBtoDIBV5
*
* History:
* 18-Dec-1997 HideyukN  Created.
\***************************************************************************/
LPBITMAPV5HEADER DIBtoDIBV5(
    LPBITMAPINFOHEADER lpDib,
    DWORD              cbSize)
{
    LPBITMAPV5HEADER lpV5h;
    ULONG            cjBits;
    ULONG            cjColorV5;

    if (cbSize < sizeof(BITMAPINFOHEADER)) {
        RIPMSG2(RIP_WARNING, "DIBtoDIBV5: buffer %d too small for header %d",
                cbSize, sizeof(BITMAPINFOHEADER));
        return NULL;
    }

    /*
     * Support only convert from BITMAPINFOHEADER
     */
    if (lpDib->biSize != sizeof(BITMAPINFOHEADER)) {
        return NULL;
    }

    /*
     * Calculate size of bitmap bits.
     */
    cjBits = WIDTHBYTES(lpDib->biWidth * lpDib->biBitCount) * abs(lpDib->biHeight);

    /*
     * Calculate size of color table.
     */
    cjColorV5 = SizeOfDibColorTable(lpDib);

    if (cbSize < sizeof(BITMAPINFOHEADER) + cjColorV5 + cjBits) {
        RIPMSG5(RIP_WARNING, "DIBtoDIBV5: buffer %d too small for bitmap %d Header"
                             " %d cjColorV5 %d cjBits %d",
                cbSize,
                sizeof(BITMAPINFOHEADER) + cjColorV5 + cjBits,
                sizeof(BITMAPINFOHEADER),
                cjColorV5,
                cjBits);
        return NULL;
    }

    /*
     * Allocate memory for BITMAPV5HEADER.
     */
    lpV5h = (LPBITMAPV5HEADER)UserAllocPool(sizeof(BITMAPV5HEADER) + cjColorV5 + cjBits,
                                            TAG_CLIPBOARD);

    if (lpV5h == NULL) {
        return NULL;
    }

    /*
     * Fill allocated memory with zero.
     */
    RtlZeroMemory((PVOID)lpV5h, sizeof(BITMAPV5HEADER));

    try {
        /*
         * Copy BITMAPINFOHEADER to BITMAPV5HEADER
         */
        RtlCopyMemory((PVOID)lpV5h, (PVOID)lpDib, sizeof(BITMAPINFOHEADER));
    } except (W32ExceptionHandler(FALSE, RIP_ERROR)) {
        UserFreePool(lpV5h);
        return NULL;
    }

    /*
     * Adjust the header size to BITMAPV5HEADER.
     */
    lpV5h->bV5Size = sizeof(BITMAPV5HEADER);

    /*
     * Bitmap is in sRGB color space.
     */
    lpV5h->bV5CSType = LCS_sRGB;

    /*
     * Set rendering intent.
     */
    lpV5h->bV5Intent = LCS_GM_IMAGES;

    if ((lpDib->biCompression == BI_BITFIELDS) &&
        (lpDib->biBitCount == 16 || lpDib->biBitCount == 32)) {
        /*
         * If there is bitfields mask, copy it to BITMAPV5HEADER.
         */
        lpV5h->bV5RedMask = *(DWORD *)&(((BITMAPINFO *)lpDib)->bmiColors[0]);
        lpV5h->bV5GreenMask = *(DWORD *)&(((BITMAPINFO *)lpDib)->bmiColors[1]);
        lpV5h->bV5BlueMask = *(DWORD *)&(((BITMAPINFO *)lpDib)->bmiColors[2]);
    }

    if (cjColorV5) {
        RtlCopyMemory((BYTE *)lpV5h + sizeof(BITMAPV5HEADER),
                      (BYTE *)lpDib + sizeof(BITMAPINFOHEADER),
                      cjColorV5);
    }

    /*
     * Copy bitmap bits
     */
    RtlCopyMemory((BYTE *)lpV5h + sizeof(BITMAPV5HEADER) + cjColorV5,
                  (BYTE *)lpDib + sizeof(BITMAPINFOHEADER) + cjColorV5,
                  cjBits);

    return lpV5h;
}

/***************************************************************************\
* BMPtoDIBV5
*
* History:
* 18-Dec-1997 HideyukN  Created.
\***************************************************************************/
LPBITMAPV5HEADER BMPtoDIBV5(
    HBITMAP  hbmp,
    HPALETTE hpal)
{
    LPBITMAPV5HEADER   lpV5h;
    LPBITMAPINFOHEADER lpbih;
    DWORD              cbSize;

    /*
     * Convert bitmap handle to BITMAPINFOHEADER first.
     */
    lpbih = BMPtoDIB(hbmp, hpal, &cbSize);
    if (lpbih) {
        /*
         * Then, convert BITMAPINFOHEADER to BITMAPV5HEADER.
         */
        lpV5h = DIBtoDIBV5(lpbih, cbSize);

        /*
         * Free memory which contains BITMAPINFOHEADER temporary.
         */
        UserFreePool(lpbih);

        return (lpV5h);
    } else {
        RIPMSG0(RIP_ERROR, "Failed on BMPtoDIB(), Why ??");
        return NULL;
    }
}

/***************************************************************************\
* xxxGetDummyBitmap
*
* Returns a real-bitmap from a dummy-format.
*
* History:
* 24-Oct-1995 ChrisWil  Created.
\***************************************************************************/
HANDLE xxxGetDummyBitmap(
    PWINDOWSTATION pwinsta,
    PGETCLIPBDATA  pgcd)
{
    HANDLE             hData = NULL;
    PCLIPDATA          pData;
    HBITMAP            hBitmap;
    LPBITMAPINFOHEADER lpbih;
    ULONG              cjBitmap;
    HPALETTE           hPal = NULL;

    PCLIP              pClipT;

    /*
     * If palette display, then first attempt to get the palette for this
     * bitmap.
     */
    if (TEST_PUSIF(PUSIF_PALETTEDISPLAY)) {
        hPal = xxxGetClipboardData(pwinsta, CF_PALETTE, pgcd);
    }

    /*
     * The conversion priority is CF_DIBV5 and then CF_DIB, so, check we
     * have CF_DIBV5 first.
     */
    pClipT = FindClipFormat(pwinsta, CF_DIBV5);
    if (pClipT && (pClipT->hData != DUMMY_DIB_HANDLE)) {
        /*
         * Ok, we have *real* CF_DIBV5 data. At this moment, just go back
         * to client side, then create bitmap handle for CF_BITMAP. Since
         * color conversion only can do it on user-mode.
         */
        if (hData = xxxGetClipboardData(pwinsta, CF_DIBV5, pgcd)) {
            /*
             * Return the type of the returned data. Again, conversion will
             * happen in client side.
             */
            pgcd->uFmtRet  = CF_DIBV5;
            pgcd->hPalette = hPal;

            return hData;
        }
    }

    /*
     * If the bitmap is a dummy, then we have a problem. We can't retrieve a
     * bitmap if we only have dummys to work with.
     */
    pClipT = FindClipFormat(pwinsta, CF_DIB);
    if (pClipT && (pClipT->hData != DUMMY_DIB_HANDLE)) {
        hData = xxxGetClipboardData(pwinsta, CF_DIB, pgcd);
    }

    if (hData == NULL) {
        return NULL;
    }

    /*
     * Since DIBs (memory-handles) are stored in a special format (size, base,
     * data), we need to offet the pointer to the right offset (2 uints).
     */
    if (pData = (PCLIPDATA)HMValidateHandleNoRip(hData, TYPE_CLIPDATA)) {
        lpbih = (LPBITMAPINFOHEADER)&pData->abData;
        cjBitmap = pData->cbData;
    } else {
        UserAssert(pData != NULL);
        return NULL;
    }

    /*
     * Convert the dib to a bitmap.
     *
     * The buffer size for bitmap should be larger than
     * bitmap header + color table + bitmap bits data.
     */
    if ((cjBitmap >= sizeof(BITMAPCOREHEADER)) &&
        (cjBitmap >= (GreGetBitmapSize((CONST BITMAPINFO *)lpbih,DIB_RGB_COLORS) +
                      GreGetBitmapBitsSize((CONST BITMAPINFO *)lpbih)))) {
        if (hBitmap = DIBtoBMP(lpbih, hPal)) {
            /*
             * Once, we create *real* bitmap, overwrite dummy handle.
             */

            pClipT = FindClipFormat(pwinsta, CF_BITMAP);
            if (pClipT) {
                UT_FreeCBFormat(pClipT);
                pClipT->hData = hBitmap;
                GreSetBitmapOwner(hBitmap, OBJECT_OWNER_PUBLIC);

                /*
                 * Let callee know we can obtain CF_BITMAP
                 */
                pgcd->uFmtRet = CF_BITMAP;
            } else {
                /*
                 * Bleh -- now we can't find the BITMAP entry anymore.  Bail.
                 */
                RIPMSG0(RIP_WARNING,
                      "Clipboard: CF_BITMAP format not available");
                GreDeleteObject(hBitmap);
                hBitmap = NULL;
            }
        }
        return (HANDLE)hBitmap;
    } else {
        RIPMSG0(RIP_WARNING, "GetClipboardData, bad DIB format\n");
        return NULL;
    }
}

/***************************************************************************\
* xxxGetDummyDib
*
* Returns a real-dib (in special clipboard-handle format) from a dummy
* format.
*
* History:
* 24-Oct-1995 ChrisWil  Created.
\***************************************************************************/
HANDLE xxxGetDummyDib(
    PWINDOWSTATION pwinsta,
    PGETCLIPBDATA  pgcd)
{
    HANDLE             hData = NULL;
    HBITMAP            hBitmap = NULL;
    LPBITMAPINFOHEADER lpDib;
    HANDLE             hDib;
    HPALETTE           hPal = NULL;
    PCLIP              pClipT;

    /*
     * If palette display, then first attempt to get the palette for this
     * bitmap. For palette devices, we must have a palette.
     */
    if (TEST_PUSIF(PUSIF_PALETTEDISPLAY)) {
        hPal = xxxGetClipboardData(pwinsta, CF_PALETTE, pgcd);

        if (hPal == NULL) {
            return NULL;
        }
    }

    /*
     * The convertion priority is CF_DIBV5 and then CF_BITMAP, so, check if
     * we have CF_DIBV5 first.
     */
    pClipT = FindClipFormat(pwinsta, CF_DIBV5);
    if (pClipT && (pClipT->hData != DUMMY_DIB_HANDLE)) {
        /*
         * Ok, we have *real* CF_DIBV5 data. At this moment, just go back to
         * client side, then create bitmap data for CF_DIB. Since color
         * conversion can only be done in user-mode.
         */
        if (hData = xxxGetClipboardData(pwinsta, CF_DIBV5, pgcd)) {
            /*
             * Return the type of the returned data. Again, conversion will
             * happen in client side.
             */
            pgcd->uFmtRet  = CF_DIBV5;
            pgcd->hPalette = hPal;

            return hData;
        }
    }

    /*
     * Get the real-bitmap. We must have one in order to convert to the DIB.
     * If there's no bitmap, then something's wrong.
     */
    pClipT = FindClipFormat(pwinsta, CF_BITMAP);
    if (pClipT && (pClipT->hData != DUMMY_DIB_HANDLE)) {
        hBitmap = xxxGetClipboardData(pwinsta, CF_BITMAP, pgcd);
    }

    if (hBitmap == NULL) {
        return NULL;
    }

    /*
     * Convert the bitmap to a dib-spec.
     */
    hDib = NULL;
    if (lpDib = BMPtoDIB(hBitmap, hPal, NULL)) {
        DWORD cbData = SizeOfDib(lpDib);;

        /*
         * Convert the dib-spec to the special-clipboard memory-handle (size,
         * base, data). This so the client is able to convert properly when
         * handled a dib.
         */
        hDib = _ConvertMemHandle((LPBYTE)lpDib, cbData);
        UserFreePool(lpDib);

        if (hDib != NULL) {
            /*
             * Once, we create *real* bitmap, overwrite dummy handle.
             */

            pClipT = FindClipFormat(pwinsta, CF_DIB);
            if (pClipT) {
                UT_FreeCBFormat(pClipT);
                pClipT->hData = hDib;

                /*
                 * Let callee know we can obtain CF_DIB.
                 */
                pgcd->uFmtRet = CF_DIB;
            } else {
                PVOID pObj;

                /*
                 * Bleh -- now we can't find the DIB entry anymore. Bail.
                 */
                RIPMSG0(RIP_WARNING,
                      "Clipboard: CF_PDIB format not available");
                pObj = HMValidateHandleNoRip(hDib, TYPE_CLIPDATA);
                if (pObj) {
                    HMFreeObject(pObj);
                }
                hDib = NULL;
            }
        }
    }

    return hDib;
}

/***************************************************************************\
* xxxGetDummyDibV5
*
* Returns a real DIB (in special clipboard-handle format) from a dummy
* format.
*
* History:
* 18-Dec-1997 HideyukN  Created.
\***************************************************************************/
HANDLE xxxGetDummyDibV5(
    PWINDOWSTATION pwinsta,
    PGETCLIPBDATA  pgcd)
{
    HANDLE             hData;
    PCLIPDATA          pData;
    LPBITMAPV5HEADER   lpDibV5 = NULL;
    HANDLE             hDibV5 = NULL;

    PCLIP              pClipT;

    /*
     * The conversion priority is CF_DIB and then CF_BITMAP, so check if we
     * have CF_DIB first.
     */
    pClipT = FindClipFormat(pwinsta, CF_DIB);
    if (pClipT && (pClipT->hData != DUMMY_DIB_HANDLE)) {
        /*
         * Ok, we have *real* CF_DIB data, get it.
         */
        if (hData = xxxGetClipboardData(pwinsta, CF_DIB, pgcd)) {
            /*
             * Since DIBs (memory-handles) are stored in a special format
             * (size, base, data), we need to offet the pointer to the right
             * offset (2 uints).
             */
            if (pData = (PCLIPDATA)HMValidateHandleNoRip(hData, TYPE_CLIPDATA)) {
                LPBITMAPINFOHEADER lpDib = (LPBITMAPINFOHEADER)&pData->abData;

                /*
                 * Convert the BITMAPINFOHEADER to BITMAPV5HEADER.
                 */
                lpDibV5 = DIBtoDIBV5(lpDib, pData->cbData);
            } else {
                UserAssert(pData != NULL);
            }
        }
    }

    if (lpDibV5 == NULL) {
        /*
         * Try CF_BITMAP, here.
         */
        pClipT = FindClipFormat(pwinsta, CF_BITMAP);
        if ((pClipT) &&
            (pClipT->hData != DUMMY_DIB_HANDLE) &&
            (hData = xxxGetClipboardData(pwinsta, CF_BITMAP, pgcd))) {
            HPALETTE hPal = NULL;

            /*
             * If palette display, then first attempt to get the palette
             * for this bitmap. For palette devices, we must have a palette.
             */
            if (TEST_PUSIF(PUSIF_PALETTEDISPLAY)) {
                hPal = xxxGetClipboardData(pwinsta, CF_PALETTE, pgcd);
                if (hPal == NULL) {
                    return NULL;
                }
            }

            /*
             * hData is GDI bitmap handle; convert the bitmap to a dib-spec.
             */
            lpDibV5 = BMPtoDIBV5((HBITMAP)hData, hPal);
        }
    }

    if (lpDibV5 != NULL) {
        DWORD cbData = SizeOfDib((LPBITMAPINFOHEADER)lpDibV5);

        /*
         * Convert the dib-spec to the special-clipboard memory-handle (size,
         * base, data). This so the client is able to convert properly when
         * handled a dib.
         */
        hDibV5 = _ConvertMemHandle((LPBYTE)lpDibV5, cbData);
        UserFreePool(lpDibV5);

        if (hDibV5 != NULL) {
            /*
             * Once, we create *real* bitmap, overwrite dummy handle.
             */
            pClipT = FindClipFormat(pwinsta, CF_DIBV5);
            if (pClipT) {
                UT_FreeCBFormat(pClipT);
                pClipT->hData = hDibV5;

                /*
                 * Let callee know we can obtain CF_DIBV5.
                 */
                pgcd->uFmtRet = CF_DIBV5;
            } else {
                PVOID pObj;

                /*
                 * Bleh -- now we can't find the DIB entry anymore. Bail.
                 */
                RIPMSG0(RIP_WARNING,
                        "Clipboard: CF_DIBV5 format not available");
                pObj = HMValidateHandleNoRip(hDibV5, TYPE_CLIPDATA);
                if (pObj) {
                    HMFreeObject(pObj);
                }
                hDibV5 = NULL;
            }
        }
    }

    return hDibV5;
}

/***************************************************************************\
* CreateDIBPalette
*
* This creates a palette with PC_NOCOLLAPSE entries since we require the
* palette-entries and bitmap-indexes to map exactly. Otherwise, we could
* end up selecting a palette where a color collapses to an index not
* where the bitmap thinks it is. This would cause slower drawing since
* the Blt would go through color translation.
*
* History:
* 31-Jan-1992 MikeKe    From win31
\***************************************************************************/
HPALETTE CreateDIBPalette(
   LPBITMAPINFOHEADER pbmih,
   UINT               colors)
{
    HPALETTE hpal;

    if (colors != 0) {
        int         i;
        BOOL        fOldDIB = (pbmih->biSize == sizeof(BITMAPCOREHEADER));
        RGBTRIPLE   *pColorTable;
        PLOGPALETTE plp;

        /*
         * Allocate memory for palette creation.
         */
        plp = (PLOGPALETTE)UserAllocPoolWithQuota(sizeof(LOGPALETTE) +
                                                  (sizeof(PALETTEENTRY) * 256),
                                                  TAG_CLIPBOARDPALETTE);
        if (plp == NULL) {
            return NULL;
        }

        pColorTable = (RGBTRIPLE *)((LPSTR)pbmih + (WORD)pbmih->biSize);
        plp->palVersion = 0x300;

        if (fOldDIB || (pbmih->biClrUsed == 0)) {
            UserAssert(colors <= 0xFFFF);
            plp->palNumEntries = (WORD)colors;
        } else {
            UserAssert(pbmih->biClrUsed <= 0xFFFF);
            plp->palNumEntries = (WORD)pbmih->biClrUsed;
        }

        for (i = 0; i < (int)(plp->palNumEntries); i++) {
            plp->palPalEntry[i].peRed   = pColorTable->rgbtRed;
            plp->palPalEntry[i].peGreen = pColorTable->rgbtGreen;
            plp->palPalEntry[i].peBlue  = pColorTable->rgbtBlue;
            plp->palPalEntry[i].peFlags = (BYTE)PC_NOCOLLAPSE;

            if (fOldDIB) {
                pColorTable++;
            } else {
                pColorTable = (RGBTRIPLE *)((LPSTR)pColorTable+sizeof(RGBQUAD));
            }
        }

        hpal = GreCreatePalette((LPLOGPALETTE)plp);
        UserFreePool(plp);
    } else {
        hpal = GreCreateHalftonePalette(HDCBITS());
    }

    GreSetPaletteOwner(hpal, OBJECT_OWNER_PUBLIC);

    return hpal;
}

/***************************************************************************\
* xxxGetDummyPalette
*
* Returns a real-palette from a dummy-format. Derives it from a real DIB.
*
* History:
* 24-Oct-1995 ChrisWil  Created.
\***************************************************************************/
HANDLE xxxGetDummyPalette(
    PWINDOWSTATION pwinsta,
    PGETCLIPBDATA  pgcd)
{
    HANDLE             hData;
    PCLIPDATA          pData;
    LPBITMAPINFOHEADER lpbih;
    HPALETTE           hPal;
    PCLIP              pClipT;

    /*
     * Since CF_DIBV5 has higher priority than CF_DIB, look into CF_DIBV5
     * first to find DIB palette.
     */
    UINT               uFmt = CF_DIBV5;

    if ((pClipT = FindClipFormat(pwinsta, uFmt)) != NULL) {
        if (pClipT->hData != DUMMY_DIB_HANDLE) {
            /*
             * Ok, we have real CF_DIBV5, let extract palette from DIBV5.
             */
        } else {
            /*
             * Otherwise, try CF_DIB.
             */
            uFmt = CF_DIB;

            /*
             * If no DIB available or it's a dummy handle, bail since we
             * must have a real DIB to derive the palette.
             */
            if ((pClipT = FindClipFormat(pwinsta, uFmt)) == NULL) {
                return NULL;
            }
            if (pClipT->hData == DUMMY_DIB_HANDLE) {
                return NULL;
            }
        }
    }

    /*
     * Get the DIB by which we derive the palette. If the DIB comes back as a
     * dummy, then there's something wrong. We must have a real dib at this
     * point.
     */
    hData = (HANDLE)xxxGetClipboardData(pwinsta, uFmt, pgcd);
    UserAssert(hData > DUMMY_MAX_HANDLE);
    if (hData == NULL) {
        return NULL;
    }

    /*
     * Since DIBs (memory-handles) are stored in a special format (size, base,
     * data), we need to offet the pointer to the right offset (2 uints).
     */
    if (pData = (PCLIPDATA)HMValidateHandle(hData, TYPE_CLIPDATA)) {
        lpbih = (LPBITMAPINFOHEADER)&pData->abData;
    } else {
        UserAssert(pData != NULL);
        return NULL;
    }

    if ((pClipT = FindClipFormat(pwinsta, CF_PALETTE)) == NULL) {
        RIPMSG0(RIP_WARNING,
                "Clipboard: CF_PALETTE format not available");
        return NULL;
    }

    /*
     * Note -- if CreateDIBPalette ever changes to leave the crit sect,
     * we will need to move the above FindClipFormat to after the create
     * call and deal with gracefully freeing hPal on failure. pClipT
     * can change during callbacks.
     */
    hPal = CreateDIBPalette(lpbih, lpbih->biClrUsed);
    if (hPal != NULL) {
        UT_FreeCBFormat(pClipT);
        pClipT->hData = hPal;
        GreSetPaletteOwner(hPal, OBJECT_OWNER_PUBLIC);
    }

    return (HANDLE)hPal;
}

/***************************************************************************\
* xxxGetDummyText
*
* Returns a handle to text from a dummy-format.
*
* History:
* 24-Oct-1995 ChrisWil  Created.
\***************************************************************************/
HANDLE xxxGetDummyText(
    PWINDOWSTATION pwinsta,
    UINT           fmt,
    PGETCLIPBDATA  pgcd)
{
    HANDLE hText;
    PCLIP  pClipT;
    UINT   uFmtMain;
    UINT   uFmtAlt;
    BOOL  bMain = TRUE;

    /*
     * Get the handle of the other text format available.
     */
    switch (fmt) {
    case CF_TEXT:
        uFmtMain = CF_UNICODETEXT;
        uFmtAlt  = CF_OEMTEXT;
        goto GetRealText;

    case CF_OEMTEXT:
        uFmtMain = CF_UNICODETEXT;
        uFmtAlt  = CF_TEXT;
        goto GetRealText;

    case CF_UNICODETEXT:
        uFmtMain = CF_TEXT;
        uFmtAlt  = CF_OEMTEXT;

GetRealText:

        if ((pClipT = FindClipFormat(pwinsta, uFmtMain)) == NULL) {
            return NULL;
        }

        if (pClipT->hData != DUMMY_TEXT_HANDLE) {
            if (xxxGetClipboardData(pwinsta, uFmtMain, pgcd)) {
                break;
            }

            return NULL;
        }

        if ((pClipT = FindClipFormat(pwinsta, uFmtAlt)) == NULL) {
            return NULL;
        }

        if (pClipT->hData != DUMMY_TEXT_HANDLE) {
            bMain = FALSE;

            if (xxxGetClipboardData(pwinsta, uFmtAlt, pgcd)) {
                break;
            }
        }

        /*
         * Fall through to return a dummy handle.
         */

    default:
        return NULL;
    }

    /*
     * Since xxxGetClipboardData leaves the critsect, we need to reacquire
     * pClipT.
     */
    pClipT = FindClipFormat(pwinsta, bMain ? uFmtMain : uFmtAlt);
    if (pClipT == NULL) {
        RIPMSG1(RIP_WARNING,
                "Clipboard: GetDummyText, format 0x%x not available",
                bMain ? uFmtMain : uFmtAlt);
        return NULL;
    }

    /*
     * Return the type of the returned data.
     */
    pgcd->uFmtRet = pClipT->fmt;
    hText         = pClipT->hData;

    /*
     * Set the locale, since the text will need to be converted to another
     * format.
     */
    if (pClipT = FindClipFormat(pwinsta, CF_LOCALE)) {
        pgcd->hLocale = pClipT->hData;
    } else {
        pgcd->hLocale = NULL;
    }

    return hText;
}

/***************************************************************************\
* xxxGetRenderData
*
* Returns a handle to delayed rendered data. This requires a call to the
* client to supply the data. This causes us to regenerate our pointer to
* pClip.
*
* History:
* 24-Oct-1995 ChrisWil  Created.
\***************************************************************************/
HANDLE xxxGetRenderData(
    PWINDOWSTATION pwinsta,
    UINT           fmt)
{
    BOOL        fClipboardChangedOld;
    TL          tlpwndClipOwner;
    PCLIP       pClip;
    DWORD_PTR   lpdwResult;

    /*
     * If the handle is NULL, the data is delay rendered. This means we send
     * a message to the current clipboard owner and have it render the data
     * for us.
     */
    if (pwinsta->spwndClipOwner != NULL) {
        BOOL fSucceeded;

        /*
         * Preserve the WSF_CLIPBOARDCHANGED flag before SendMessage and
         * restore the flag later. Thus we ignore the changes done to the
         * WSF_CLIPBOARDCHANGED flag by apps while rendering data in the
         * delayed rendering scheme. This avoids clipboard viewers from
         * painting twice.
         */
        fClipboardChangedOld = (pwinsta->dwWSF_Flags & WSF_CLIPBOARDCHANGED) != 0;
        SET_FLAG(pwinsta->dwWSF_Flags, WSF_INDELAYEDRENDERING);

        ThreadLockAlways(pwinsta->spwndClipOwner, &tlpwndClipOwner);
        if (!xxxSendMessageTimeout(pwinsta->spwndClipOwner,
                                   WM_RENDERFORMAT,
                                   fmt,
                                   0L,
                                   SMTO_ABORTIFHUNG,
                                   CB_DELAYRENDER_TIMEOUT,
                                   &lpdwResult)) {
            fSucceeded = FALSE;
        } else {
            fSucceeded = TRUE;
        }

        ThreadUnlock(&tlpwndClipOwner);

        SET_OR_CLEAR_FLAG(pwinsta->dwWSF_Flags, WSF_CLIPBOARDCHANGED, fClipboardChangedOld);
        CLEAR_FLAG(pwinsta->dwWSF_Flags, WSF_INDELAYEDRENDERING);

        if (!fSucceeded) {
            return NULL;
        }
    }

    if ((pClip = FindClipFormat(pwinsta, fmt)) == NULL) {
        RIPMSGF1(RIP_WARNING,
                 "Meta Render/Clone format 0x%x not available", fmt);
        return NULL;
    }

    /*
     * We should have the handle now since it has been rendered.
     */
    return pClip->hData;
}
/***************************************************************************\
* xxxGetClipboardData (API)
*
* Grabs a particular data object out of the clipboard.
*
* History:
* 18-Nov-1990 ScottLu   Ported from Win3.
* 20-Aug-1991 EichiM    UNICODE enabling
\***************************************************************************/
HANDLE xxxGetClipboardData(
    PWINDOWSTATION pwinsta,
    UINT           fmt,
    PGETCLIPBDATA  pgcd)
{
    PCLIP  pClip;
    HANDLE hData;

    /*
     * Check the clipboard owner.
     */
    if (pwinsta->ptiClipLock != PtiCurrent()) {
        RIPERR0(ERROR_CLIPBOARD_NOT_OPEN, RIP_VERBOSE, "GetClipboardData: clipboard not open");
        return NULL;
    }

    /*
     * Make sure the format is available.
     */
    if ((pClip = FindClipFormat(pwinsta, fmt)) == NULL) {
        RIPMSG1(RIP_VERBOSE, "Clipboard: Requested format 0x%lX not available", fmt);
        return NULL;
    }

    /*
     * If this is a DUMMY_META*_HANDLE it means that the other metafile
     * format was set in as a delay render format and we should ask for that
     * format to get the metafile because the app has not told us they know
     * about this format.
     */
    if (IsMetaDummyHandle(pClip->hData)) {
        if (fmt == CF_ENHMETAFILE) {
            fmt = CF_METAFILEPICT;
        } else if (fmt == CF_METAFILEPICT) {
            fmt = CF_ENHMETAFILE;
        } else {
            RIPMSG0(RIP_WARNING,
                    "Clipboard: Meta Render/Clone expects a metafile type");
        }

        if ((pClip = FindClipFormat(pwinsta, fmt)) == NULL) {
            RIPMSG1(RIP_WARNING,
                    "Clipboard: Meta Render/Clone format 0x%x not available", fmt);
            return NULL;
        }
    }

    /*
     * This is the data we're returning, unless it's a dummy or render handle.
     */
    hData = pClip->hData;

    /*
     * We are dealing with non-handles. Retrieve the real data through these
     * inline-routines. NOTE: These make recursive calls to
     * xxxGetClipboardData(), so care must be taken to assure the pClip is
     * pointing to what we think it's pointing to.
     */
    if (hData == NULL || hData == DUMMY_METARENDER_HANDLE) {
        hData = xxxGetRenderData(pwinsta, fmt);
    } else if (hData == DUMMY_DIB_HANDLE) {
        switch (fmt) {
        case CF_DIB:
            hData = xxxGetDummyDib(pwinsta, pgcd);
            break;
        case CF_DIBV5:
            hData = xxxGetDummyDibV5(pwinsta, pgcd);
            break;
        case CF_BITMAP:
            hData = xxxGetDummyBitmap(pwinsta, pgcd);
            break;
        case CF_PALETTE:
            hData = xxxGetDummyPalette(pwinsta, pgcd);
            break;
        }
    } else if (hData == DUMMY_TEXT_HANDLE) {
        hData = xxxGetDummyText(pwinsta, fmt, pgcd);
    } else {
        /*
         * This path took no callbacks, so we know pClip is OK.
         */
        if (pgcd) {
            pgcd->fGlobalHandle = pClip->fGlobalHandle;
        }

        return hData;
    }

    /*
     * The callbacks for dummy handle resolution have possibly invalidated
     * pClip -- recreate it.
     */
    if ((pClip = FindClipFormat(pwinsta, fmt)) == NULL) {
        RIPMSG1(RIP_VERBOSE, "Clipboard: Requested format 0x%x not available", fmt);
        return NULL;
    }

    /*
     * Return if this is a global-handle.
     */
    if (pgcd) {
        pgcd->fGlobalHandle = pClip->fGlobalHandle;
    }

    return hData;
}

/***************************************************************************\
* FindClipFormat
*
* Finds a particular clipboard format in the clipboard, returns a pointer
* to it, or NULL. If a pointer is found, on return the clipboard is locked
* and pwinsta->pClipBase has been updated to point to the beginning of the
* clipboard.
*
* History:
* 18-Nov-1990 ScottLu   Ported from Win3.
\***************************************************************************/
PCLIP FindClipFormat(
    PWINDOWSTATION pwinsta,
    UINT           format)
{
    PCLIP pClip;
    int   iFmt;

    if (format != 0 && ((pClip = pwinsta->pClipBase) != NULL)) {
        for (iFmt = pwinsta->cNumClipFormats; iFmt-- != 0;) {
            if (pClip->fmt == format) {
                return pClip;
            }

            pClip++;
        }
    }

    return NULL;
}

/***************************************************************************\
* _GetPriorityClipboardFormat (API)
*
* This api allows an application to look for any one of a range of
* clipboard formats in a predefined search order.
*
* History:
* 18-Nov-1990 ScottLu   Ported from Win3.
* 11-Feb-1991 JimA      Added access checks.
\***************************************************************************/
int _GetPriorityClipboardFormat(
    PUINT lpPriorityList,
    int   cfmts)
{
    PWINDOWSTATION pwinsta;
    PCLIP          pClip;
    int            iFmt;
    UINT           fmt;

    /*
     * Blow it off if the caller does not have the proper access rights.
     */
    if ((pwinsta = CheckClipboardAccess()) == NULL) {
        return 0;
    }

    /*
     * If there is no clipboard or no objects in the clipboard, return 0.
     */
    if (pwinsta->cNumClipFormats == 0 || pwinsta->pClipBase == NULL) {
        return 0;
    }

    /*
     * Look through the list for any of the formats in lpPriorityList.
     */
    while (cfmts-- > 0) {
        fmt = *lpPriorityList;

        if (fmt != 0) {
            pClip = pwinsta->pClipBase;

            for (iFmt = pwinsta->cNumClipFormats; iFmt-- != 0; pClip++) {
                if (pClip->fmt == fmt) {
                    return fmt;
                }
            }
        }

        lpPriorityList++;
    }

    /*
     * There is no matching format, so return -1.
     */
    return -1;
}

/***************************************************************************\
* xxxSetClipboardViewer (API)
*
* Sets the clipboard viewer window.
*
* History:
* 18-Nov-1990 ScottLu   Ported from Win3.
* 11-Feb-1991 JimA      Added access checks.
\***************************************************************************/
PWND xxxSetClipboardViewer(
    PWND pwndClipViewerNew)
{
    TL             tlpwinsta;
    PWINDOWSTATION pwinsta;
    HWND           hwndClipViewerOld;
    PTHREADINFO    ptiCurrent;

    CheckLock(pwndClipViewerNew);

    /*
     * Do not let a destroyed window be locked into the winsta. See
     * _OpenClipboard for more details.
     */
    if (pwndClipViewerNew != NULL && TestWF(pwndClipViewerNew, WFDESTROYED)) {
        RIPERR1(ERROR_INVALID_PARAMETER,
                RIP_WARNING,
                "Destroyed pwnd 0x%p trying to become clipboard viewer",
                pwndClipViewerNew);

        return NULL;
    }

    /*
     * Blow it off if the caller does not have the proper access rights. The
     * NULL return really doesn't indicate an error but the supposed viewer
     * will never receive any clipboard messages, so it shouldn't cause any
     * problems.
     */
    if ((pwinsta = CheckClipboardAccess()) == NULL) {
        return NULL;
    }

    ptiCurrent = PtiCurrent();

    ThreadLockWinSta(ptiCurrent, pwinsta, &tlpwinsta);

    hwndClipViewerOld = HW(pwinsta->spwndClipViewer);
    Lock(&pwinsta->spwndClipViewer, pwndClipViewerNew);

    xxxDrawClipboard(pwinsta);

    ThreadUnlockWinSta(ptiCurrent, &tlpwinsta);

    if (hwndClipViewerOld != NULL) {
        return RevalidateHwnd(hwndClipViewerOld);
    }

    return NULL;
}

/***************************************************************************\
* xxxChangeClipboardChain (API)
*
* Changes the clipboard viewer chain.
*
* History:
* 18-Nov-1990 ScottLu   Ported from Win3.
* 11-Feb-1991 JimA      Added access checks.
\***************************************************************************/
BOOL xxxChangeClipboardChain(
    PWND pwndRemove,
    PWND pwndNewNext)
{
    TL             tlpwinsta;
    PWINDOWSTATION pwinsta;
    BOOL           result;
    TL             tlpwndClipViewer;
    PTHREADINFO    ptiCurrent;

    CheckLock(pwndRemove);
    CheckLock(pwndNewNext);

    /*
     * Blow it off if the caller does not have the proper access rights.
     */
    if ((pwinsta = CheckClipboardAccess()) == NULL) {
        return FALSE;
    }

    /*
     * pwndRemove should be this thread's window, pwndNewNext will either be
     * NULL or another thread's window.
     */
    ptiCurrent = PtiCurrent();

    if (GETPTI(pwndRemove) != ptiCurrent) {
        RIPMSG0(RIP_WARNING,
                "Clipboard: ChangeClipboardChain will not remove cross threads");
        return FALSE;
    }

    if (pwinsta->spwndClipViewer == NULL) {
        RIPMSG0(RIP_WARNING, "Clipboard: ChangeClipboardChain has no viewer window");
        return FALSE;
    }

    ThreadLockWinSta(ptiCurrent, pwinsta, &tlpwinsta);

    if (pwndRemove == pwinsta->spwndClipViewer) {
        Lock(&pwinsta->spwndClipViewer, pwndNewNext);
        result = TRUE;
    } else {
        ThreadLockAlways(pwinsta->spwndClipViewer, &tlpwndClipViewer);
        result = (BOOL)xxxSendMessage(pwinsta->spwndClipViewer,
                                      WM_CHANGECBCHAIN,
                                      (WPARAM)HW(pwndRemove),
                                      (LPARAM)HW(pwndNewNext));
        ThreadUnlock(&tlpwndClipViewer);
    }

    ThreadUnlockWinSta(ptiCurrent, &tlpwinsta);

    return result;
}

/***************************************************************************\
* xxxDisownClipboard
*
* Disowns the clipboard so someone else can grab it.
*
* pwndClipOwner is the pwnd that is the reason for disowning the clipboard
* when that window is deleted.
*
* History:
* 18-Jun-1991 DarrinM   Ported from Win3.
\***************************************************************************/
VOID xxxDisownClipboard(
    PWND pwndClipOwner)
{
    TL             tlpwinsta;
    PWINDOWSTATION pwinsta;
    int            iFmt;
    int            cFmts;
    PCLIP          pClip;
    PCLIP          pClipOut;
    BOOL           fKeepDummyHandle;
    PTHREADINFO    ptiCurrent;

    if ((pwinsta = CheckClipboardAccess()) == NULL) {
        return;
    }

    ptiCurrent = PtiCurrent();

    ThreadLockWinSta(ptiCurrent, pwinsta, &tlpwinsta);

    xxxSendClipboardMessage(pwinsta, WM_RENDERALLFORMATS);

    pClipOut = pClip = pwinsta->pClipBase;
    fKeepDummyHandle = FALSE;

    for (cFmts = 0, iFmt = pwinsta->cNumClipFormats; iFmt-- != 0;) {
        /*
         * We have to remove the Dummy handles also if the corresponding
         * valid handles are NULL; We should not remove the dummy handles if
         * the corresponding valid handles are not NULL. The following code
         * assumes that only one dummy handle is possible and that can appear
         * only after the corresponding valid handle in the pClip linked list.
         */
        if (pClip->hData != NULL) {
            if ((pClip->hData != DUMMY_TEXT_HANDLE) ||
                ((pClip->hData == DUMMY_TEXT_HANDLE) && fKeepDummyHandle)) {

                cFmts++;
                *pClipOut++ = *pClip;

                if (IsTextHandle(pClip->fmt, pClip->hData)) {
                    fKeepDummyHandle  = TRUE;
                }
            }
        }

        pClip++;
    }

    /*
     * Unlock the clipboard owner if the owner is still the window we were
     * cleaning up for.
     */
    if (pwndClipOwner == pwinsta->spwndClipOwner) {
        Unlock(&pwinsta->spwndClipOwner);
    } else {
        RIPMSGF2(RIP_WARNING,
                 "pwndClipOwner changed from 0x%p to 0x%p",
                 pwndClipOwner,
                 pwinsta->spwndClipOwner);
    }

    /*
     * If number of formats changed, redraw.
     */
    if (cFmts != pwinsta->cNumClipFormats) {
        pwinsta->dwWSF_Flags |= WSF_CLIPBOARDCHANGED;
        pwinsta->iClipSequenceNumber++;
    }

    pwinsta->cNumClipFormats = cFmts;

    /*
     * If anything changed, redraw, and make sure the data type munging is
     * done. Else we will lose them when xxxDrawClipboard clears the
     * WSF_CLIPBOARDCHANGED flag.
     */
    if (pwinsta->dwWSF_Flags & WSF_CLIPBOARDCHANGED) {
        xxxDrawClipboard(pwinsta);
        MungeClipData(pwinsta);
    }

    ThreadUnlockWinSta(ptiCurrent, &tlpwinsta);
}

/***************************************************************************\
* ForceEmptyClipboard
*
* We're logging off. Force the clipboard contents to go away.
*
* 23-Jul-1992 ScottLu   Created.
\***************************************************************************/
VOID ForceEmptyClipboard(
    PWINDOWSTATION pwinsta)
{
    /*
     * This will be NULL for a non-GUI thread.
     */
    pwinsta->ptiClipLock =  ((PTHREADINFO)(W32GetCurrentThread()));

    Unlock(&pwinsta->spwndClipOwner);
    Unlock(&pwinsta->spwndClipViewer);
    Unlock(&pwinsta->spwndClipOpen);

    xxxEmptyClipboard(pwinsta);

    /*
     * If the windowstation is dying, don't bother closing the clipboard.
     */
    if (!(pwinsta->dwWSF_Flags & WSF_DYING)) {
        xxxCloseClipboard(pwinsta);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\kernel\createw.c ===
/****************************** Module Header ******************************\
* Module Name: createw.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* Contains xxxCreateWindow, xxxDestroyWindow, and a few close friends.
*
* Note that during creation or deletion, the window is locked so that
* it can't be deleted recursively.
*
* History:
* 19-Oct-1990 DarrinM   Created.
* 11-Feb-1991 JimA      Added access checks.
* 19-Feb-1991 MikeKe    Added Revalidation code
* 20-Jan-1992 IanJa     ANSI/UNICODE neutralization
\***************************************************************************/

#include "precomp.h"
#pragma hdrstop

BOOL WantImeWindow(PWND pwndParent, PWND pwnd);
#if DBG
VOID VerifyWindowLink(PWND pwnd, PWND pwndParent, BOOL fLink);
#endif

/***************************************************************************\
* xxxCreateWindowEx (API)
*
* History:
* 10-18-90 darrinm      Ported from Win 3.0 sources.
* 02-07-91 DavidPe      Added Win 3.1 WH_CBT support.
* 02-11-91 JimA         Added access checks.
* 04-11-92 ChandanC     Added initialization of WOW words
\***************************************************************************/
PWND xxxCreateWindowEx(
    DWORD         dwExStyle,
    PLARGE_STRING cczpstrNVClass,
    PLARGE_STRING cczpstrClass,
    PLARGE_STRING cczpstrName,
    DWORD         style,
    int           x,
    int           y,
    int           cx,
    int           cy,
    PWND          pwndParent,
    PMENU         pMenu,
    HANDLE        hInstance,
    LPVOID        lpCreateParams,
    DWORD         dwExpWinVerAndFlags,
    PACTIVATION_CONTEXT pActCtx)
{
    /*
     * The buffers for Class and Name may be client memory, and access
     * to those buffers must be protected.
     */
    UINT           mask = 0;
    BOOL           fChild;
    BOOL           fDefPos = FALSE;
    BOOL           fStartup = FALSE;
    PCLS           pcls;
    PPCLS          ppcls;
    RECT           rc;
    int            dx, dy;
    SIZERECT       src;
    int            sw = SW_SHOW;
    PWND           pwnd;
    PWND           pwndZOrder, pwndHardError;
    CREATESTRUCTEX csex;
    PDESKTOP       pdesk;
    ATOM           atomT;
    PTHREADINFO    ptiCurrent = PtiCurrent();
    TL             tlpwnd;
    TL             tlpwndParent;
    TL             tlpwndParentT;
    BOOL           fLockParent = FALSE;
    WORD           wWFAnsiCreator = 0;
    DWORD          dw;
    DWORD          dwMinMax;
    PMONITOR       pMonitor;
    BOOL           fTiled;

    CheckLock(pwndParent);
    UserAssert(IsWinEventNotifyDeferredOK());

#ifdef LAZY_CLASS_INIT
    if ((ptiCurrent->ppi->W32PF_Flags & W32PF_CLASSESREGISTERED) == 0) {
        if (!LW_RegisterWindows()) {
            RIPERR0(ERROR_INVALID_PARAMETER,
                    RIP_WARNING,
                    "LW_RegisterWindows failed.");
            return NULL;
        }
    }
#endif

    /*
     * For Edit Controls (including those in comboboxes), we must know whether
     * the App used an ANSI or a Unicode CreateWindow call. This is passed in
     * with the private WS_EX_ANSICREATOR dwExStyle bit, but we MUST NOT leave
     * out this bit in the window's dwExStyle! Transfer to the internal window
     * flag WFANSICREATOR immediately.
     */
    if (dwExStyle & WS_EX_ANSICREATOR) {
        wWFAnsiCreator = WFANSICREATOR;
        dwExStyle &= ~WS_EX_ANSICREATOR;
    }


    /*
     * After grocking any bits, we should no longer be using any private bits.
     */
    UserAssert((dwExStyle & WS_EXP_PRIVATE) == 0);

    /*
     * If this thread has already been in xxxDestroyThreadInfo, then this window
     * is probably going to end up with a bogus pti.
     */
    UserAssert(!(ptiCurrent->TIF_flags & TIF_INCLEANUP));
    pdesk = ptiCurrent->rpdesk;

    /*
     * If a parent window is specified, make sure it's on the same desktop.
     */
    if (pwndParent != NULL && pwndParent->head.rpdesk != pdesk) {
        RIPERR0(ERROR_INVALID_PARAMETER, RIP_WARNING, "");
        return NULL;
    }

    /*
     * Set a flag indicating whether it is a child window.
     */
    fChild = ((HIWORD(style) & MaskWF(WFTYPEMASK)) == MaskWF(WFCHILD));

    /*
     * The WS_EX_LAYOUT_RTL flag is set if,
     *
     * (1) WS_EX_LAYOUT_RTL set in dwExStyle parameter of the CreateWindow call.
     *
     * (2) If the window is created from DialogBox class, then it can't inherit
     *     from its parent and it has to specify WS_EX_LAYOUTRTL explicitly to
     *     enable mirroring on it.
     *
     * (3) If the window is an owned window then the window is left to right
     *     layout and the algorithm terminates. (An owned window is one created
     *     with an HWND passed in the hWndParent paremeter to CreateWindow(Ex),
     *     but without the WS_CHILD flag present in it's styles.
     *
     * (4) If the window is a child window, and it's parent is right to left
     *     layout, and it's parent does not have the WS_EX_NOINHERIT_LAYOUT flag
     *     set in it's extended styles, then the window is right to left layout
     *     and the algorithm terminates.
     *
     * (5) If the hWndParent parameter to Createwindow(Ex) was NULL, and the
     *     process calling CreateWindow(Ex) has called
     *     SetProcessDefaultLayout(LAYOUT_RTL), then the window is right to left
     *     layout and the algorithm terminates.
     *
     * (6) In all other cases, the layout is left to right.
     */
    if (!(dwExStyle & WS_EX_LAYOUTRTL)) {
        if (pwndParent != NULL) {
            if (fChild && TestWF(pwndParent, WEFLAYOUTRTL) && !TestWF(pwndParent, WEFNOINHERITLAYOUT)) {
                dwExStyle |= WS_EX_LAYOUTRTL;
            }
        } else if (!(!IS_PTR(cczpstrNVClass) && (PTR_TO_ID(cczpstrNVClass) == PTR_TO_ID(DIALOGCLASS)))) {
            if ((PpiCurrent()->dwLayout & LAYOUT_RTL)) {
                dwExStyle |= WS_EX_LAYOUTRTL;
            }
        }
    }

    /*
     * Ensure that we can create the window. If there is no desktop
     * yet, assume that this will be the root desktop window and allow
     * the creation.
     */
    if (ptiCurrent->hdesk) {
        RETURN_IF_ACCESS_DENIED(
                ptiCurrent->amdesk, DESKTOP_CREATEWINDOW, NULL);
    }

    if (fChild) {
        /*
         * Don't allow child windows without a parent handle.
         */
        if (pwndParent == NULL) {
            RIPERR0(ERROR_TLW_WITH_WSCHILD, RIP_WARNING, "");
            return NULL;
        }

        if (!ValidateParentDepth(NULL, pwndParent)) {
            RIPERR0(ERROR_INVALID_PARAMETER,
                    RIP_WARNING,
                    "Exceeded nested children limit");
            return NULL;
        }
    }

    /*
     * Make sure we can get the window class.
     */
    if (IS_PTR(cczpstrClass)) {
        /*
         * UserFindAtom protects access of the string.
         */
        atomT = UserFindAtom(cczpstrClass->Buffer);
    } else {
        atomT = PTR_TO_ID(cczpstrClass);
    }

    if (atomT == 0) {
CantFindClassMessageAndFail:
#if DBG
        if (IS_PTR(cczpstrNVClass)) {
            try {
                RIPMSG1(RIP_VERBOSE,
                        "Couldn't find class string %ws",
                        cczpstrNVClass->Buffer);

            } except (W32ExceptionHandler(FALSE, RIP_WARNING)) {
            }
        } else {
            RIPMSG1(RIP_VERBOSE,
                    "Couldn't find class atom 0x%x",
                    cczpstrNVClass);
        }
#endif

        RIPERR0(ERROR_CANNOT_FIND_WND_CLASS, RIP_VERBOSE, "");
        return NULL;
    }

    /*
     * First scan the private classes. If we don't find the class there scan
     * the public classes. If we don't find it there, fail.
     */
    ppcls = GetClassPtr(atomT, ptiCurrent->ppi, hInstance);
    if (ppcls == NULL) {
        goto CantFindClassMessageAndFail;
    }

    pcls = *ppcls;

    if (NeedsWindowEdge(style, dwExStyle, Is400Compat(dwExpWinVerAndFlags))) {
        dwExStyle |= WS_EX_WINDOWEDGE;
    } else {
        dwExStyle &= ~WS_EX_WINDOWEDGE;
    }

    /*
     * Allocate memory for regular windows.
     */
    pwnd = HMAllocObject(
            ptiCurrent, pdesk, TYPE_WINDOW, sizeof(WND) + pcls->cbwndExtra);

    if (pwnd == NULL) {
        RIPERR0(ERROR_OUTOFMEMORY,
                RIP_WARNING,
                "Out of pool in xxxCreateWindowEx");

        return NULL;
    }

    /*
     * Stuff in the pq, class pointer, and window style.
     */
    pwnd->pcls = pcls;
    pwnd->style = style & ~WS_VISIBLE;
    pwnd->ExStyle = dwExStyle & ~(WS_EX_LAYERED | WS_EX_COMPOSITED);
    pwnd->cbwndExtra = pcls->cbwndExtra;

    /*
     * Increment the window reference count in the class structure.
     * Because xxxFreeWindow() decrements the count, incrementing has
     * to be done now. In the case of error, xxxFreeWindow() will decrement it.
     */
    if (!ReferenceClass(pcls, pwnd)) {
        HMFreeObject(pwnd);
        goto CantFindClassMessageAndFail;
    }

    /*
     * Set the window active App context to be activated whenever we call
     * the user WndProc.
     */
    pwnd->pActCtx = pActCtx;

    /*
     * Button control doesn't need input context. Other windows
     * will associate with the default input context.
     * N.b. this comparison needs to be performed on the NV class
     * name.
     */
    if (pcls->atomNVClassName == gpsi->atomSysClass[ICLS_BUTTON]) {
        pwnd->hImc = NULL_HIMC;
    } else {
        pwnd->hImc = (HIMC)PtoH(ptiCurrent->spDefaultImc);
    }

    /*
     * Update the window count. Doing this now will ensure that if
     * the creation fails, xxxFreeWindow will keep the window count
     * correct.
     */
    ptiCurrent->cWindows++;

    /*
     * Get the class from the window because ReferenceClass may have
     * cloned the class.
     */
    pcls = pwnd->pcls;

    /*
     * This is a replacement for the &lpCreateParams stuff that used to
     * pass a pointer directly to the parameters on the stack. This
     * step must be done AFTER referencing the class because we
     * may use the ANSI class name.
     */
    RtlZeroMemory(&csex, sizeof(csex));
    csex.cs.dwExStyle = dwExStyle;
    csex.cs.hInstance = hInstance;

    if (!IS_PTR(cczpstrNVClass)) {
        csex.cs.lpszClass = (LPWSTR)cczpstrNVClass;
    } else {
        if (wWFAnsiCreator) {
            csex.cs.lpszClass = (LPWSTR)pcls->lpszAnsiClassName;
            if (IS_PTR(csex.cs.lpszClass)) {
                RtlInitLargeAnsiString(
                        (PLARGE_ANSI_STRING)&csex.strClass,
                        (LPSTR)csex.cs.lpszClass,
                        (UINT)-1);
            }
        } else {
            csex.cs.lpszClass = cczpstrNVClass->Buffer;
            csex.strClass = *cczpstrNVClass;
        }
    }

    if (cczpstrName != NULL) {
        csex.cs.lpszName = cczpstrName->Buffer;
        csex.strName = *cczpstrName;
    }
    csex.cs.style = style;
    csex.cs.x = x;
    csex.cs.y = y;
    csex.cs.cx = cx;
    csex.cs.cy = cy;
    csex.cs.hwndParent = HW(pwndParent);

    /*
     * If pMenu is non-NULL and the window is not a child, pMenu must
     * be a menu.
     * Child windows get their UIState bits from their parent. Top level ones
     * remain with the default cleared bits.
     *
     * The below test is equivalent to TestwndChild().
     */
    if (fChild) {
        csex.cs.hMenu = (HMENU)pMenu;

        pwnd->ExStyle |= pwndParent->ExStyle & WS_EXP_UIVALID;
#if WS_EXP_UIACCELHIDDEN  !=  0x40000000
#error Fix UISTATE bits copying if you moved the UISTATE bits from ExStyle
#endif

    } else {
        csex.cs.hMenu = PtoH(pMenu);
    }

    csex.cs.lpCreateParams = lpCreateParams;

    /*
     * ThreadLock: we are going to be doing multiple callbacks here.
     */
    ThreadLockAlwaysWithPti(ptiCurrent, pwnd, &tlpwnd);

    /*
     * set the parent to be the desktop window (if exists)
     * before any callback. This way we'll always have a
     * pointer on spwndParent
     */
    if (pwnd->head.rpdesk) {
        Lock(&(pwnd->spwndParent), PWNDMESSAGE(pwnd));
    }

    /*
     * Create the class small icon if there isn't one since we are in context
     * and we are creating a window from this class...
     */
    if (pcls->spicn && !pcls->spicnSm) {
        xxxCreateClassSmIcon(pcls);
    }

    /*
     * Store the instance handle and window proc address. We do this earlier
     * than Windows because they have a bug were a message can be sent
     * but lpfnWndProc is not set (3986 CBT WM_CREATE not allowed.)
     */
    pwnd->hModule = hInstance;

    /*
     * Get rid of EditWndProc plain.
     */
    pwnd->lpfnWndProc = (WNDPROC_PWND)MapClientNeuterToClientPfn(pcls, 0, wWFAnsiCreator);

    /*
     * If this window class has a server-side window procedure, mark
     * it as such. If the app subclasses it later with an app-side proc
     * then this mark will be removed.
     */
    if (pcls->CSF_flags & CSF_SERVERSIDEPROC) {
        SetWF(pwnd, WFSERVERSIDEPROC);
        UserAssert(!(pcls->CSF_flags & CSF_ANSIPROC));
    }

    /*
     * If this window was created with an ANSI CreateWindow*() call, mark
     * it as such so edit controls will be created correctly. (A combobox
     * will be able to pass the WFANSICREATOR bit on to its edit control)
     */
    SetWF(pwnd, wWFAnsiCreator);

    /*
     * If this window belongs to an ANSI class or it is a WFANSICREATOR
     * control, then mark it as an ANSI window
     */
    if ((pcls->CSF_flags & CSF_ANSIPROC) ||
            (wWFAnsiCreator &&
             ((atomT == gpsi->atomSysClass[ICLS_BUTTON]) ||
              (atomT == gpsi->atomSysClass[ICLS_COMBOBOX]) ||
              (atomT == gpsi->atomSysClass[ICLS_COMBOLISTBOX]) ||
              (atomT == gpsi->atomSysClass[ICLS_DIALOG]) ||
              (atomT == gpsi->atomSysClass[ICLS_EDIT]) ||
              (atomT == gpsi->atomSysClass[ICLS_LISTBOX]) ||
              (atomT == gpsi->atomSysClass[ICLS_MDICLIENT]) ||
              (atomT == gpsi->atomSysClass[ICLS_IME]) ||
              (atomT == gpsi->atomSysClass[ICLS_STATIC])))) {
        SetWF(pwnd, WFANSIPROC);
    }

    /*
     * If a 3.1-compatible application is creating the window, set this
     * bit to enable various backward-compatibility hacks.
     *
     * If it's not 3.1 compatible, see if we need to turn on the PixieHack
     * (see wmupdate.c for more info on this)
     */

    dw = GetAppCompatFlags(ptiCurrent);

    if (dw & GACF_RANDOM3XUI) {
        SetWF(pwnd, WFOLDUI);

        dwExStyle &= 0x0000003f;
        csex.cs.dwExStyle &= 0x0000003f;
    }

    pwnd->hMod16  = ((ptiCurrent->TIF_flags & TIF_16BIT) && !TestWF(pwnd, WFSERVERSIDEPROC))? xxxClientWOWGetProcModule(pwnd->lpfnWndProc):0;
    if (Is310Compat(dwExpWinVerAndFlags)) {
        SetWF(pwnd, WFWIN31COMPAT);
        if (Is400Compat(dwExpWinVerAndFlags)) {
            SetWF(pwnd, WFWIN40COMPAT);
            if (Is500Compat(dwExpWinVerAndFlags)) {
                SetWF(pwnd, WFWIN50COMPAT);
            }
        }
    } else if (dw & GACF_ALWAYSSENDNCPAINT) {
        SetWF(pwnd, WFALWAYSSENDNCPAINT);
    }

    /*
     * If we've got a registered DefWindowProc handler, make sure it's DLL
     * is loaded for this process.
     */
    if (IsInsideUserApiHook()) {
        xxxLoadUserApiHook();
    }

    /*
     * Inform the CBT hook that a window is being created. Pass it the
     * CreateParams and the window handle that the new one will be inserted
     * after. The CBT hook handler returns TRUE to prevent the window
     * from being created. It can also modify the CREATESTRUCT info, which
     * will affect the size, parent, and position of the window.
     * Defaultly position non-child windows at the top of their list.
     */

    if (IsHooked(ptiCurrent, WHF_CBT)) {
        CBT_CREATEWND cbt;

        /*
         * Use the extended createstruct so the hook thunk can
         * handle the strings correctly.
         */
        cbt.lpcs = (LPCREATESTRUCT)&csex;
        cbt.hwndInsertAfter = HWND_TOP;

        if ((BOOL)xxxCallHook(HCBT_CREATEWND, (WPARAM)HWq(pwnd),
                (LPARAM)&cbt, WH_CBT)) {

            goto MemError;
        } else {
            /*
             * The CreateHook may have modified some parameters so write them
             * out (in Windows 3.1 we used to write directly to the variables
             * on the stack).
             */

            x = csex.cs.x;
            y = csex.cs.y;
            cx = csex.cs.cx;
            cy = csex.cs.cy;
            pwndZOrder =  PWInsertAfter(cbt.hwndInsertAfter);
        }
    } else {
        pwndZOrder = (PWND)HWND_TOP;
    }

    if (!(fTiled = TestwndTiled(pwnd))) {

        /*
         * CW_USEDEFAULT is only valid for tiled and overlapped windows.
         * Don't let it be used.
         */
        if (x == CW_USEDEFAULT || x == CW2_USEDEFAULT) {
            x = 0;
            y = 0;
        }

        if (cx == CW_USEDEFAULT || cx == CW2_USEDEFAULT) {
            cx = 0;
            cy = 0;
        }
    }

    /*
     * Make local copies of these parameters.
     */
    src.x = x;
    src.y  = y;
    src.cx = cx;
    src.cy = cy;

    /*
     *    Position Child Windows
     */
    if (fChild = (BOOL)TestwndChild(pwnd)) {

        /*
         * Child windows are offset from the parent's origin.
         */
        UserAssert(pwndParent);
        if (pwndParent != PWNDDESKTOP(pwnd)) {
            src.x += pwndParent->rcClient.left;
            src.y += pwndParent->rcClient.top;
        }

        /*
         * Defaultly position child windows at bottom of their list.
         */
        pwndZOrder = PWND_BOTTOM;
    }

    /*
     *    Position Tiled Windows
     */

    /*
     * Is this a Tiled/Overlapping window?
     */
    if (fTiled) {

        /*
         * Force the WS_CLIPSIBLINGS window style and add a caption and
         * a border.
         */
        SetWF(pwnd, WFCLIPSIBLINGS);
        mask = MaskWF(WFCAPTION) | MaskWF(WFBORDER);

        //
        // We add on a raised edge since IF the person had passed in WS_CAPTION,
        // and didn't specify any 3D borders, we would've added it on to the
        // style bits above.
        //

        if (TestWF(pwnd, WFWIN40COMPAT)) {
            SetWF(pwnd, WEFWINDOWEDGE);
        }

        /*
         * Set bit that will force size message to be sent at SHOW time.
         */
        SetWF(pwnd, WFSENDSIZEMOVE);

        /*
         * Here is how the "tiled" window initial positioning works...
         * If the app is a 1.0x app, then we use our standard "stair step"
         * default positioning scheme. Otherwise, we check the x & cx
         * parameters. If either of these == CW_USEDEFAULT then use the
         * default position/size, otherwise use the position/size they
         * specified. If not using default position, use SW_SHOW for the
         * xxxShowWindow() parameter, otherwise use the y parameter given.
         *
         * In 32-bit world, CW_USEDEFAULT is 0x80000000, but apps still
         * store word-oriented values either in dialog templates or
         * in their own structures. So CreateWindow still recognizes the
         * 16 bit equivalent, which is 0x8000, CW2_USEDEFAULT. The original
         * is changed because parameters to CreateWindow() are 32 bit
         * values, which can cause sign extention, or weird results if
         * 16 bit math assumptions are being made, etc.
         */

        /*
         * Default to passing the y parameter to xxxShowWindow().
         */
        if (x == CW_USEDEFAULT || x == CW2_USEDEFAULT) {

            /*
             * If the y value is not CW_USEDEFAULT, use it as a SW_* command.
             */
            if (src.y != CW_USEDEFAULT && src.y != CW2_USEDEFAULT) {
                sw = src.y;
            }
        }


        /*
         * Allow the shell to tell us what monitor to run this app on
         */
        pMonitor = NULL;
        if (    x == CW_USEDEFAULT ||
                x == CW2_USEDEFAULT ||
                cx == CW_USEDEFAULT ||
                cx == CW2_USEDEFAULT) {

            if (ptiCurrent->ppi->hMonitor) {
                pMonitor = ValidateHmonitor(ptiCurrent->ppi->hMonitor);
            } else if (pwndParent) {
                pMonitor = _MonitorFromWindow(pwndParent, MONITOR_DEFAULTTONEAREST);
            }
        }

        if (!pMonitor) {
            pMonitor = GetPrimaryMonitor();
        }

        SetTiledRect(pwnd, &rc, pMonitor);

        /*
         * Did the app ask for default positioning?
         */
        if (x == CW_USEDEFAULT || x == CW2_USEDEFAULT) {

            /*
             * Use default positioning.
             */
            if (ptiCurrent->ppi->usi.dwFlags & STARTF_USEPOSITION ) {
                fStartup = TRUE;
                x = src.x = ptiCurrent->ppi->usi.dwX;
                y = src.y = ptiCurrent->ppi->usi.dwY;
            } else {
                x = src.x = rc.left;
                y = src.y = rc.top;
            }
            fDefPos = TRUE;

        } else {

            /*
             * Use the apps specified positioning. Undo the "stacking"
             * effect caused by SetTiledRect().
             */
            if (pMonitor->cWndStack) {
                pMonitor->cWndStack--;
            }
        }

        /*
         * Did the app ask for default sizing?
         */
        if (src.cx == CW_USEDEFAULT || src.cx == CW2_USEDEFAULT) {

            /*
             * Use default sizing.
             */
            if (ptiCurrent->ppi->usi.dwFlags & STARTF_USESIZE) {
                fStartup = TRUE;
                src.cx = ptiCurrent->ppi->usi.dwXSize;
                src.cy = ptiCurrent->ppi->usi.dwYSize;
            } else {
                src.cx = rc.right - x;
                src.cy = rc.bottom - y;
            }
            fDefPos = TRUE;

        } else if (fDefPos) {
            /*
             * The app wants default positioning but not default sizing.
             * Make sure that it's still entirely visible by moving the
             * window.
             */
            dx = (src.x + src.cx) - pMonitor->rcMonitor.right;
            dy = (src.y + src.cy) - pMonitor->rcMonitor.bottom;
            if (dx > 0) {
                x -= dx;
                src.x = x;
                if (src.x < pMonitor->rcMonitor.left) {
                    src.x = x = pMonitor->rcMonitor.left;
                }
            }

            if (dy > 0) {
                y -= dy;
                src.y = y;
                if (src.y < pMonitor->rcMonitor.top) {
                    src.y = y = pMonitor->rcMonitor.top;
                }
            }
        }
    }

    /*
     * If we have used any startup postitions, turn off the startup
     * info so we don't use it again.
     */
    if (fStartup) {
        ptiCurrent->ppi->usi.dwFlags &=
                ~(STARTF_USESIZE | STARTF_USEPOSITION);
    }

    if (TestwndPopup(pwnd)) {
        /*
         * Force the clipsiblings/overlap style.
         */
        SetWF(pwnd, WFCLIPSIBLINGS);
    }

    /*
     * Shove in those default style bits.
     */
    *(((WORD *)&pwnd->style) + 1) |= mask;

    /*
     *    Menu/SysMenu Stuff
     */

    /*
     * If there is no menu handle given and it's not a child window but
     * there is a class menu, use the class menu.
     */
    if (pMenu == NULL && !fChild && (pcls->lpszMenuName != NULL)) {
        UNICODE_STRING strMenuName;

        RtlInitUnicodeStringOrId(&strMenuName, pcls->lpszMenuName);
        pMenu = xxxClientLoadMenu(pcls->hModule, &strMenuName);
        csex.cs.hMenu = PtoH(pMenu);

        /*
         * This load fails if the caller does not have DESKTOP_CREATEMENU
         * permission but that's ok they will just get a window without a menu
         */
    }

    /*
     * Store the menu handle.
     */
    if (TestwndChild(pwnd)) {

        /*
         * It's an id in this case.
         */
        pwnd->spmenu = pMenu;
    } else {

        /*
         * It's a real handle in this case.
         */
        LockWndMenu(pwnd, &pwnd->spmenu, pMenu);
    }

    /*
     *    Parent/Owner Stuff
     */

    /*
     * If this isn't a child window, reset the Owner/Parent info.
     */
    if (!fChild) {
        Lock(&(pwnd->spwndLastActive), pwnd);
        if ((pwndParent != NULL) &&
                (pwndParent != pwndParent->head.rpdesk->spwndMessage) &&
                (pwndParent != pwndParent->head.rpdesk->pDeskInfo->spwnd)) {

            PWND pwndOwner = GetTopLevelWindow(pwndParent);

            if (!ValidateOwnerDepth(pwnd, pwndOwner)) {
                RIPERR1(ERROR_INVALID_PARAMETER,
                        RIP_WARNING,
                        "Exceeded nested owner limit for pwnd %#p",
                        pwnd);
                goto MemError;
            }

#if DBG
            if (pwnd->pcls->atomClassName == gpsi->atomSysClass[ICLS_IME]) {
                UserAssert(!TestCF(pwndOwner, CFIME));
            }
#endif
            Lock(&(pwnd->spwndOwner), pwndOwner);
            if (pwnd->spwndOwner && TestWF(pwnd->spwndOwner, WEFTOPMOST)) {

                /*
                 * If this window's owner is a topmost window, then it has to
                 * be one also since a window must be above its owner.
                 */
                SetWF(pwnd, WEFTOPMOST);
            }

            /*
             * If this is a owner window on another thread, share input
             * state so this window gets z-ordered correctly.
             */
            if (atomT != gpsi->atomSysClass[ICLS_IME] &&
                    pwnd->spwndOwner != NULL &&
                    GETPTI(pwnd->spwndOwner) != ptiCurrent) {
                /*
                 * No need to DeferWinEventNotify() here:  pwnd and pwndParent
                 * are locked and because we called ReferenceClass(pcls, pwnd),
                 * pcls is safe until xxxFreeWindow(pwnd). (IanJa)
                 */
                zzzAttachThreadInput(ptiCurrent, GETPTI(pwnd->spwndOwner), TRUE);
            }

        } else {
            pwnd->spwndOwner = NULL;
        }

#if DBG
        if (ptiCurrent->rpdesk != NULL) {
            UserAssert(!(ptiCurrent->rpdesk->dwDTFlags & (DF_DESTROYED | DF_DESKWNDDESTROYED | DF_DYING)));
        }
#endif
        if ((pwndParent == NULL) ||
               (pwndParent != pwndParent->head.rpdesk->spwndMessage)) {
            pwndParent = _GetDesktopWindow();

            ThreadLockWithPti(ptiCurrent, pwndParent, &tlpwndParent);
            fLockParent = TRUE;
        }
    }

    /*
     * Store backpointer to parent.
     */
    if ((pwnd->spwndNext != NULL) || (pwnd->spwndPrev != NULL)) {
        RIPMSG1(RIP_WARNING, "Window %#p linked in too early (in a hook callback)", pwnd);
        UnlinkWindow(pwnd, pwnd->spwndParent);
    }
    Lock(&(pwnd->spwndParent), pwndParent);

    /*
     *    Final Window Positioning
     */

    if (!TestWF(pwnd, WFWIN31COMPAT)) {
        /*
         * BACKWARD COMPATIBILITY HACK
         *
         * In 3.0, CS_PARENTDC overrides WS_CLIPCHILDREN and WS_CLIPSIBLINGS,
         * but only if the parent is not WS_CLIPCHILDREN.
         * This behavior is required by PowerPoint and Charisma, among others.
         */
        if ((pcls->style & CS_PARENTDC) &&
                !TestWF(pwndParent, WFCLIPCHILDREN)) {
#if DBG
            if (TestWF(pwnd, WFCLIPCHILDREN))
                RIPMSG0(RIP_WARNING, "WS_CLIPCHILDREN overridden by CS_PARENTDC");
            if (TestWF(pwnd, WFCLIPSIBLINGS))
                RIPMSG0(RIP_WARNING, "WS_CLIPSIBLINGS overridden by CS_PARENTDC");
#endif
            ClrWF(pwnd, (WFCLIPCHILDREN | WFCLIPSIBLINGS));
        }
    }

    /*
     * If this is a child window being created in a parent window
     * of a different thread, but not on the desktop, attach their
     * input streams together. [windows with WS_CHILD can be created
     * on the desktop, that's why we check both the style bits
     * and the parent window.]
     */
    if (TestwndChild(pwnd) && (pwndParent != PWNDDESKTOP(pwnd)) &&
            (ptiCurrent != GETPTI(pwndParent))) {
        /*
         * No need to DeferWinEventNotify() - there is an xxx call just below
         */
        zzzAttachThreadInput(ptiCurrent, GETPTI(pwndParent), TRUE);
    }

    /*
     * Make sure the window is between the minimum and maximum sizes.
     */

    /*
     * HACK ALERT!
     * This sends WM_GETMINMAXINFO to a (tiled or sizable) window before
     * it has been created (before it is sent WM_NCCREATE).
     * Maybe some app expects this, so we mustn't reorder the messages.
     */
    xxxAdjustSize(pwnd, &src.cx, &src.cy);

    /*
     * Check for a window being created full screen.
     *
     * Note the check for a non-NULL pdeskParent -- this is important for CreateWindowStation
     */
    if (pwnd->head.rpdesk != NULL &&
        !TestWF(pwnd, WFCHILD) &&
        !TestWF(pwnd, WEFTOOLWINDOW)) {

        xxxCheckFullScreen(pwnd, &src);
    }

    if (src.cx < 0) {
        RIPMSG1(RIP_WARNING, "xxxCreateWindowEx: adjusted cx in pwnd %#p", pwnd);
        src.cx = 0;
    }

    if (src.cy < 0) {
        RIPMSG1(RIP_WARNING, "xxxCreateWindowEx: adjusted cy in pwnd %#p", pwnd);
        src.cy = 0;
    }

    /*
     * Calculate final window dimensions...
     */
    RECTFromSIZERECT(&pwnd->rcWindow, &src);

    if (TestCF2(pcls, CFOWNDC) || (TestCF2(pcls, CFCLASSDC) && pcls->pdce == NULL)) {
        if (NULL == CreateCacheDC(pwnd, DCX_OWNDC, NULL)) {

            RIPMSG1(RIP_WARNING, "xxxCreateWindowEx: pwnd %#p failed to create cached DC",
                    pwnd);

            goto MemError;
        }
    }


    /*
     * Setup Layered and Composited windows.
     *
     * NOTE: This MUST be done AFTER CreateCacheDC() has built any DC's used for
     * OWNDC windows, since the redirection functions need to convert these DC's
     * to use redirection. In Windows 2000, this was done before calling
     * CreateCacheDC(), and would Assert inside ResetOrg() when because a new
     * DC was built that was not setup for redirection.
     */
    if (dwExStyle & WS_EX_LAYERED) {
        if (!xxxSetLayeredWindow(pwnd, FALSE)) {
            RIPMSG1(RIP_WARNING, "xxxCreateWindowEx: pwnd %#p failed to setup layered window", pwnd);
            goto MemError;
        }
    }

    if (dwExStyle & WS_EX_COMPOSITED) {
        /*
         * We only want to turn WS_EX_COMPOSITED on if the parent-chain doesn't
         * already have WS_EX_COMPOSITED turned on.
         */

        if (GetStyleWindow(pwnd->spwndParent, WEFCOMPOSITED) == NULL) {
            if (!SetRedirectedWindow(pwnd, REDIRECT_COMPOSITED)) {
                RIPMSG1(RIP_WARNING, "xxxCreateWindowEx: pwnd %#p failed to setup composited window", pwnd);
                goto MemError;
            }
            SetWF(pwnd, WEFCOMPOSITED);
        }
    }

    /*
     * Update the create struct now that we've modified some passed in
     * parameters.
     */
    csex.cs.x = x;
    csex.cs.y = y;
    csex.cs.cx = cx;
    csex.cs.cy = cy;

    /*
     * Send a NCCREATE message to the window.
     */
    if (!xxxSendMessage(pwnd, WM_NCCREATE, 0L, (LPARAM)&csex)) {

MemError:

#if DBG
        if (!IS_PTR(cczpstrNVClass)) {
            RIPMSG2(RIP_WARNING,
                    (pwndParent) ?
                            "xxxCreateWindowEx failed, Class=%#.4x, ID=%d" :
                            "xxxCreateWindowEx failed, Class=%#.4x",
                    PTR_TO_ID(cczpstrNVClass),
                    (LONG_PTR) pMenu);
        } else {
            RIPMSG2(RIP_WARNING,
                    (pwndParent) ?
                            "xxxCreateWindowEx failed, Class=\"%s\", ID=%d" :
                            "xxxCreateWindowEx failed, Class=\"%s\"",
                    pcls->lpszAnsiClassName,
                    (LONG_PTR) pMenu);
        }
#endif

        if (fLockParent)
            ThreadUnlock(&tlpwndParent);

        /*
         * Set the state as destroyed so any z-ordering events will be ignored.
         * We cannot NULL out the owner field until WM_NCDESTROY is sent or
         * apps like Rumba fault (they call GetParent after every message).
         */
        SetWF(pwnd, WFDESTROYED);

        /*
         * Unset the visible flag so we don't think in xxxDestroyWindow that
         * this window is visible.
         */
        if (TestWF(pwnd, WFVISIBLE)) {
            SetVisible(pwnd, SV_UNSET);
        }

        /*
         * FreeWindow performs a ThreadUnlock.
         */
        xxxFreeWindow(pwnd, &tlpwnd);

        return NULL;
    }

    /*
     * We need to set the lame button flag before doing the CFNOCLOSE stuff
     * below or the app won't get the lame button menu item in its sysmenu.
     */
#ifdef LAME_BUTTON
    if (NeedsLameButton(pwnd, pwndParent)) {
        SetWF(pwnd, WEFLAMEBUTTON);
    }
#endif // LAME_BUTTON

    /*
     * Delete the Close menu item if directed.
     */
    if (TestCF(pwnd, CFNOCLOSE)) {
        /*
         * Do this by position since the separator does not have an ID.
         */
        pMenu = xxxGetSystemMenu(pwnd, FALSE);
        if (pMenu != NULL) {
            TL tlpMenu;

            ThreadLock(pMenu, &tlpMenu);
            xxxDeleteMenu(pMenu, 5
#ifdef LAME_BUTTON
            + !!TestWF(pwnd, WEFLAMEBUTTON)
#endif // LAME_BUTTON
            , MF_BYPOSITION);
            xxxDeleteMenu(pMenu, 5
#ifdef LAME_BUTTON
            + !!TestWF(pwnd, WEFLAMEBUTTON)
#endif // LAME_BUTTON
            , MF_BYPOSITION);
            ThreadUnlock(&tlpMenu);
        }
    }

    /*
     * WM_NCCREATE processing may have changed the window text. Change
     * the CREATESTRUCT to point to the real window text.
     *
     * MSMoney needs this because it clears the window and we need to
     * reflect the new name back into the cs structure.
     * A better thing to do would be to have a pointer to the CREATESTRUCT
     * within the window itself so that DefWindowProc can change the
     * the window name in the CREATESTRUCT to point to the real name and
     * this funky check is no longer needed.
     *
     * DefSetText converts a pointer to NULL to a NULL title so
     * we don't want to over-write cs.lpszName if it was a pointer to
     * a NULL string and pName is NULL. Approach Database for Windows creates
     * windows with a pointer to NULL and then accesses the pointer later
     * during WM_CREATE
     */
    if (TestWF(pwnd, WFTITLESET))
        if (!(csex.strName.Buffer != NULL && csex.strName.Length == 0 &&
                pwnd->strName.Buffer == NULL)) {
            csex.cs.lpszName = pwnd->strName.Buffer;
            RtlCopyMemory(&csex.strName, &pwnd->strName, sizeof(LARGE_STRING));
        }

    /*
     * The Window is now officially "created."  Change the relevant global
     * stuff.
     */


     /*
      * Create per thread default IME window.
      */
    if (IS_IME_ENABLED() && ptiCurrent->spwndDefaultIme == NULL) {
        /*
         * Avoid creating the default IME window to any of message only windows
         * or windows on no I/O desktop.
         */
        if (WantImeWindow(pwndParent, pwnd)) {
            BOOL bReinit;

            //
            // Make sure we are not creating a window for Ole,
            // for it does not pump messages even though
            // they creates a window.
            //
            UserAssert(gaOleMainThreadWndClass != atomT);

            Lock(&(ptiCurrent->spwndDefaultIme),
                  xxxCreateDefaultImeWindow(pwnd, atomT, hInstance));


            /*
             * If keybaord layout is switched but Imm activation was skipped
             * while spwndDefaultIme was gone, do the activation now.
             */
#if _DBG
            if (ptiCurrent->spDefaultImc == NULL) {
                RIPMSG1(RIP_WARNING, "xxxCreateWindowEx: ptiCurrent(%08p)->spDefaultImc is NULL.", ptiCurrent);
            }
            ASSERT(ptiCurrent->pClientInfo);
#endif


#ifdef CUAS_ENABLE
            /*
             * Load IME and Activate TIM for CUAS.
             * We can do this after ptiCurrent->spwndDefaultIME is valid.
             */
            if (ptiCurrent->spwndDefaultIme) {
                TL tlpwndIme;

                ThreadLockAlways(ptiCurrent->spwndDefaultIme, &tlpwndIme);
                xxxSendMessage(ptiCurrent->spwndDefaultIme, WM_IME_SYSTEM, (WPARAM)IMS_LOADTHREADLAYOUT, (LPARAM)0L);
                ThreadUnlock(&tlpwndIme);
            }
#endif

            try {
                bReinit = ((ptiCurrent->pClientInfo->CI_flags & CI_INPUTCONTEXT_REINIT) != 0);
            } except (W32ExceptionHandler(TRUE, RIP_WARNING)) {
                goto MemError2;
            }

            if (ptiCurrent->spwndDefaultIme && bReinit) {
                TL tlpwndIme;

                TAGMSG1(DBGTAG_IMM,
                        "xxxCreateDefaultImeWindow: ptiCurrent(%08p)->spDefaultImc->fNeedClientImcActivate is set.",
                        ptiCurrent);
                /*
                 * Make this client side callback to force the input context
                 * to be reinitialized appropriately (keyboard layout has
                 * changed since this thread was taking a nap without a
                 * window but still a GUI thread).
                 *
                 * Windows NT Bug #294964.
                 */
                ThreadLock(ptiCurrent->spwndDefaultIme, &tlpwndIme);
                xxxSendMessage(ptiCurrent->spwndDefaultIme,
                               WM_IME_SYSTEM,
                               (WPARAM)IMS_ACTIVATETHREADLAYOUT,
                               (LPARAM)ptiCurrent->spklActive->hkl);

                // Reset the flag.
                try {
                    ptiCurrent->pClientInfo->CI_flags &= ~CI_INPUTCONTEXT_REINIT;
                } except (W32ExceptionHandler(TRUE, RIP_WARNING)) {
                    ThreadUnlock(&tlpwndIme);
                    goto MemError2;
                }
                ThreadUnlock(&tlpwndIme);
            }
        } else {
            TAGMSG0(DBGTAG_IMM,
                    "xxxCreateWindowEx: default IME window not created.");
        }
    }


    /*
     * Update the Parent/Child linked list. Don't (re)link the window if a
     * diffrent parent was set during a callback (e.g., WM_GETMINMAXINFO).
     */
    if (pwndParent != NULL && pwnd->spwndParent == pwndParent) {
        /*
         * Unlink this window first, it might have been linked already by
         * calling SetParent() in any of the messages that we had previously
         * sent (e.g. WM_GETMINMAXINFO).
         */
        UnlinkWindow(pwnd, pwnd->spwndParent);

        if (!fChild && (pwndParent != pwndParent->head.rpdesk->spwndMessage)) {

            /*
             * If this is a top-level window, and it's not part of the
             * topmost pile of windows, then we have to make sure it
             * doesn't go on top of any of the topmost windows.
             *
             * If he's trying to put the window on the top, or trying
             * to insert it after one of the topmost windows, insert
             * it after the last topmost window in the pile.
             */
            if (!TestWF(pwnd, WEFTOPMOST)) {
                if (pwndZOrder == PWND_TOP ||
                        (IS_PTR(pwndZOrder) && TestWF(pwndZOrder, WEFTOPMOST))) {
                    pwndZOrder = CalcForegroundInsertAfter(pwnd);
                }
            } else {
                pwndHardError = GETTOPMOSTINSERTAFTER(pwnd);
                if (pwndHardError != NULL) {
                    pwndZOrder = pwndHardError;
                }
            }
        }

        LinkWindow(pwnd, pwndZOrder, pwndParent);
    }

#if DBG
    if (pwndParent != NULL) {
        VerifyWindowLink (pwnd, pwnd->spwndParent, TRUE);

        if (pwnd->spwndParent != pwndParent) {
            RIPMSGF1(RIP_WARNING,
                     "Window 0x%p re-parented during callback",
                     pwnd);
        }
    }
#endif

    /*
     * Send a NCCALCSIZE message to the window and have it return the official
     * size of its client area.
     */
    if (fChild && TestWF(pwndParent, WEFLAYOUTRTL)) {
        cx = pwnd->rcWindow.right - pwnd->rcWindow.left;
        pwnd->rcWindow.right = pwndParent->rcClient.right - (pwnd->rcWindow.left - pwndParent->rcClient.left);
        pwnd->rcWindow.left  = pwnd->rcWindow.right - cx;
    }

    CopyRect(&rc, &pwnd->rcWindow);
    xxxSendMessage(pwnd, WM_NCCALCSIZE, 0L, (LPARAM)&rc);
    pwnd->rcClient = rc;

    /*
     * Send a CREATE message to the window.
     */
    if (xxxSendMessage(pwnd, WM_CREATE, 0L, (LPARAM)&csex) == -1L) {
#if DBG
        if (!IS_PTR(cczpstrNVClass)) {
            RIPMSG1(RIP_WARNING,
                    "CreateWindow() send of WM_CREATE failed, Class = 0x%x",
                    PTR_TO_ID(cczpstrNVClass));
        } else {
            RIPMSG1(RIP_WARNING,
                    "CreateWindow() send of WM_CREATE failed, Class = \"%s\"",
                    pcls->lpszAnsiClassName);
        }
#endif

MemError2:
        if (fLockParent) {
            ThreadUnlock(&tlpwndParent);
        }

        if (ThreadUnlock(&tlpwnd)) {
            xxxDestroyWindow(pwnd);
        }

        return NULL;
    }

    /*
     * Flag that the window is created. WoW uses this bit to determine that
     * an fnid of 0 really means 0.
     */
    SetWF(pwnd, WFISINITIALIZED);

    /*
     * Notify anyone who is listening that the window is created. Do this
     * before we size/move/max/min/show it so that event observers can count
     * on getting notifications for those things also.
     *
     * But do this AFTER WM_CREATE is sent. The window and its data will not
     * be fully initialized until then. Since the purpose of an event is to
     * let watchers turn around and do querying, we want their queries to
     * succeed and not fault.
     */
    xxxWindowEvent(EVENT_OBJECT_CREATE, pwnd, OBJID_WINDOW, INDEXID_OBJECT, 0);

    /*
     * If this is a Tiled/Overlapped window, don't send size or move msgs yet.
     */
    if (!TestWF(pwnd, WFSENDSIZEMOVE)) {
        xxxSendSizeMessage(pwnd, SIZENORMAL);

        if (pwndParent != NULL && PWNDDESKTOP(pwnd) != pwndParent) {
            rc.left -= pwndParent->rcClient.left;
            rc.top -= pwndParent->rcClient.top;
        }

        xxxSendMessage(pwnd, WM_MOVE, 0L, MAKELONG(rc.left, rc.top));
    }

    /*
     *    Min/Max Stuff
     */

    /*
     * If app specified either min/max style, then we must call our minmax
     * code to get it all set up correctly so that when the show is done,
     * the window is displayed right.
     */
    dwMinMax = MINMAX_KEEPHIDDEN | TEST_PUDF(PUDF_ANIMATE);
    if (TestWF(pwnd, WFMINIMIZED)) {
        SetMinimize(pwnd, SMIN_CLEAR);
        xxxMinMaximize(pwnd, SW_SHOWMINNOACTIVE, dwMinMax);
    } else if (TestWF(pwnd, WFMAXIMIZED)) {
        ClrWF(pwnd, WFMAXIMIZED);
        xxxMinMaximize(pwnd, SW_SHOWMAXIMIZED, dwMinMax);
    }

    /*
     * Send notification if it's a child.
     */
    if (fChild && !TestWF(pwnd, WEFNOPARENTNOTIFY) &&
            (pwnd->spwndParent != NULL)) {
        ThreadLockAlwaysWithPti(ptiCurrent, pwnd->spwndParent, &tlpwndParentT);
        xxxSendMessage(pwnd->spwndParent, WM_PARENTNOTIFY,
                MAKELONG(WM_CREATE, PTR_TO_ID(pwnd->spmenu)), (LPARAM)HWq(pwnd));
        ThreadUnlock(&tlpwndParentT);
    }

    /*
     * Show the Window
     */
    if (style & WS_VISIBLE) {
        xxxShowWindow(pwnd, sw | TEST_PUDF(PUDF_ANIMATE));
    }

    /*
     * Try and set the application's hot key. Use the Win95 logic of
     * looking for the first tiled and/or APPWINDOW to be created by
     * this process.
     */
    if (TestwndTiled(pwnd) || TestWF(pwnd, WEFAPPWINDOW)) {
        if (ptiCurrent->ppi->dwHotkey) {
            /*
             * Ignore hot keys for WowExe the first thread of a wow process.
             */
            if (!(ptiCurrent->TIF_flags & TIF_16BIT) || (ptiCurrent->ppi->cThreads > 1)) {
#ifdef LATER
                /*
                 * Win95 sets the hot key directly, we on the other hand send
                 * a WM_SETHOTKEY message to the app. Which is right?
                 */
                DWP_SetHotKey(pwnd, ptiCurrent->ppi->dwHotkey);
#else
                xxxSendMessage(pwnd, WM_SETHOTKEY, ptiCurrent->ppi->dwHotkey, 0);
#endif
                ptiCurrent->ppi->dwHotkey = 0;
            }
        }
    }

    if (fLockParent)
        ThreadUnlock(&tlpwndParent);

    return ThreadUnlock(&tlpwnd);
}

BOOL WantImeWindow(
    PWND pwndParent,
    PWND pwnd)
{
    PDESKTOP pdesk;

    UserAssert(pwnd);

    if (PtiCurrent()->TIF_flags & TIF_DISABLEIME) {
        return FALSE;
    }

    if (TestWF(pwnd, WFSERVERSIDEPROC)) {
        return FALSE;
    }

    pdesk = pwnd->head.rpdesk;
    if (pdesk == NULL || pdesk->rpwinstaParent == NULL) {
        return FALSE;
    }

    // Check whether pwnd's desktop has I/O.
    if (pdesk->rpwinstaParent->dwWSF_Flags & WSF_NOIO) {
        return FALSE;
    }

    // Check if the owner window is message-only window.
    if (pwndParent) {
        PWND pwndT = pwndParent;

  