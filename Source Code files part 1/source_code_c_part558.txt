Set[i].guidPropertySet == guidQueryCorePropset )
        {
            CopyPropertySet( xPropSet[cPropSetsCopied], _xPropSet[i], index );
            cPropSetsCopied++;
        }
        else if ( _xPropSet[i].guidPropertySet == guidCiFsExt )
        {
            CopyPropertySet( xPropSet[cPropSetsCopied], _xPropSet[i], index );
            cPropSetsCopied++;
        }
        else
        {
            //
            // Other property sets just get copied verbatim (e.g. index == 0)
            //

            CopyPropertySet( xPropSet[cPropSetsCopied], _xPropSet[i], 0 );
            cPropSetsCopied++;
        }
    }

    *cPropSets =  cPropSetsCopied;
    *ppPropSet =  xPropSet.Acquire();
}

//+---------------------------------------------------------------------------
//
//  Member:     CGetCmdProps::CopyPropertySet, private
//
//  Synopsis:   Copies srcPropSet to destPropSet - using index for distributed props.
//
//  Arguments:  [destPropSet]     -- destination prop set
//              [srcPropSet]      -- source prop set
//              [index]           -- specifies which of the distributed properties to use
//
//  Returns:    none - throws upon failure.
//
//  History:    05-12-97    mohamedn    created
//
//----------------------------------------------------------------------------

void CGetCmdProps::CopyPropertySet( CDbPropSet &destPropSet, CDbPropSet &srcPropSet, ULONG index )
{
     RtlZeroMemory( &destPropSet, sizeof (CDbPropSet) );
     RtlCopyMemory( &destPropSet.guidPropertySet, &srcPropSet.guidPropertySet, sizeof GUID );

     XArrayOLEInPlace<CDbProp>  xDestDbPrp(srcPropSet.cProperties);

     //
     // copy all the properties from the src property set
     //
     for ( unsigned i = 0; i < srcPropSet.cProperties; i++ )
     {
        CDbProp & destProp = xDestDbPrp[i];
        CDbProp & srcProp  = (CDbProp &)srcPropSet.rgProperties[i];

        RtlZeroMemory(&destProp, sizeof (CDbProp) );


        if ( srcProp.dwStatus != DBPROPSTATUS_OK )
        {
            destProp.dwPropertyID = srcPropSet.rgProperties[i].dwPropertyID;
            destProp.dwStatus     = DBPROPSTATUS_NOTSET;
            destProp.vValue.vt    = VT_EMPTY;

            ciDebugOut(( DEB_TRACE, "PropID: %x, dwStatus: %x\n",
                         srcPropSet.rgProperties[i].dwPropertyID, srcProp.dwStatus ));
            continue;
        }

        if ( destPropSet.guidPropertySet == guidQueryCorePropset )
        {
            switch (srcProp.dwPropertyID)
            {
                case DBPROP_MACHINE:

                     CopyDbProp(destProp, srcProp, index);

                     break;

                default:
                     if ( !destProp.Copy( srcProp ) )
                         THROW( CException(E_OUTOFMEMORY) );
            }
        }
        else if ( destPropSet.guidPropertySet == guidCiFsExt )
        {
            switch (srcProp.dwPropertyID)
            {
                case DBPROP_CI_INCLUDE_SCOPES:
                case DBPROP_CI_DEPTHS:

                     //
                     // in none-distributed case, Scope and Depth cardinality can be > 1
                     //

                     if ( _cCardinality <= 1 )
                     {
                         if ( !destProp.Copy( srcProp ) )
                             THROW( CException(E_OUTOFMEMORY) );
                     }
                     else
                     {
                        // distributed case.
                        CopyDbProp(destProp, srcProp, index);
                     }
                     break;

                case DBPROP_CI_CATALOG_NAME:

                     CopyDbProp(destProp, srcProp, index);

                     break;

                default:
                     if ( !destProp.Copy( srcProp ) )
                         THROW( CException(E_OUTOFMEMORY) );
            }

       } // if-else-if
       else
       {
           if ( !destProp.Copy( srcProp ) )
               THROW( CException(E_OUTOFMEMORY) );
       }
    } // for

    destPropSet.rgProperties = xDestDbPrp.Acquire();
    destPropSet.cProperties  = srcPropSet.cProperties;
} //CopyPropertySet

//+---------------------------------------------------------------------------
//
//  Member:     CGetCmdProps::CopyDbProp
//
//  Synopsis:   copies source dbprop to the dest dbprop.
//
//  Arguments:  [destProp]  -- destination dbProp
//              [srcProp]   -- source dbprop
//              [index]     -- specifies which property to copy
//
//  Returns:    None - throws upon failure.
//
//  History:    05-12-97    mohamedn    created
//
//----------------------------------------------------------------------------

void CGetCmdProps::CopyDbProp(CDbProp &destProp, CDbProp &srcProp, ULONG index)
{
     RtlCopyMemory(&destProp,&srcProp,sizeof(CDbProp));

     VARIANT & srcVar = srcProp.vValue;
     VARIANT & destVar= destProp.vValue;

     RtlZeroMemory( &destVar, sizeof (VARIANT) );

     //
     // index must be 0 if variant is not a safearray
     //
     if ( !(srcVar.vt & VT_ARRAY) &&  (0 != index) )
     {
        ciDebugOut(( DEB_ERROR, "index must be zero if not using VT_ARRAY, Index: %x\n", index));
        THROW( CException( STATUS_INVALID_PARAMETER ) );
     }
     else if ( (srcVar.vt & VT_ARRAY) && (index >= srcVar.parray->rgsabound[0].cElements) )
     {
        ciDebugOut(( DEB_ERROR, "index value out of range: %x\n", index ));
        THROW( CException( STATUS_INVALID_PARAMETER ) );
     }

     //
     // copy dbprop
     //
     switch (srcVar.vt)
     {
        case VT_ARRAY|VT_BSTR:
           {
             SAFEARRAY & sa = *srcVar.parray;
             BSTR * pBstr = (BSTR *)sa.pvData;

             if ( sa.cDims != 1 )
                THROW( CException( STATUS_INVALID_PARAMETER ) );

             destVar.vt = VT_BSTR;
             destVar.bstrVal = SysAllocString(pBstr[index]);

             if ( 0 == destVar.bstrVal )
                THROW( CException(E_OUTOFMEMORY) );
           }
           break;

        case VT_BSTR:
           {
             destVar.vt = VT_BSTR;
             destVar.bstrVal = SysAllocString(srcVar.bstrVal);

             if ( 0 == destVar.bstrVal )
                THROW( CException(E_OUTOFMEMORY) );
           }
           break;

        case VT_ARRAY|VT_I4:
        case VT_ARRAY|VT_UI4:
           {
             SAFEARRAY & sa = *srcVar.parray;
             DWORD     * pdwDepths = (DWORD *)sa.pvData;

             if ( sa.cDims != 1 )
                THROW( CException( STATUS_INVALID_PARAMETER ) );

             destVar.vt   = VT_I4;
             destVar.lVal = pdwDepths[index];
           }
           break;

        case VT_I4:
        case VT_UI4:
           {
            destVar.vt   = VT_I4;
            destVar.lVal = srcVar.lVal;
           }
           break;

        default:

            ciDebugOut(( DEB_ERROR,"Invalid VARIANT type: %x\n",destVar.vt));

            THROW( CException( STATUS_INVALID_PARAMETER ) );
     }
}

//+---------------------------------------------------------------------------
//
//  Member:     CGetDbProps::ProcessDbInitPropSet
//
//  Synopsis:   Processes the DBPROPSET_INIT property set.
//
//  Arguments:  [propSet] - The property set to process.
//
//  Returns:    none - throws upon failure.
//
//  History:    1-13-97   srikants   Created
//              5-12-97   mohamedn   fs/core prop set splits.
//
//----------------------------------------------------------------------------

void CGetCmdProps::ProcessDbInitPropSet( DBPROPSET & propSet )
{
    CDbPropSet * pDbPropSet = (CDbPropSet *) &propSet;

    for ( ULONG i = 0; i < propSet.cProperties; i++ )
    {
        CDbProp * pDbProp = pDbPropSet->GetProperty(i);

        if ( DBPROPSTATUS_OK != pDbProp->dwStatus )
        {
            ciDebugOut(( DEB_TRACE, "DbProp.dwPropertyID: %x has dwStatus= %x\n",
                         pDbProp->dwPropertyID,pDbProp->dwStatus));

            continue;
        }

        switch ( pDbProp->dwPropertyID )
        {
            case DBPROP_MACHINE:
                // machine count can be greater than 1

                _aMachines = GetWCharFromVariant(*pDbProp, &_cMachines);

                Win4Assert( 0 != _aMachines );

                break;

            case DBPROP_CLIENT_CLSID:
                {
                   WCHAR **apGuids = GetWCharFromVariant(*pDbProp, &_cGuids);

                   if ( _cGuids == 1 )
                   {
                       CGuidUtil::StringToGuid( apGuids[0], _clientGuid );
                       _fGuidValid = TRUE;
                   }
                   else
                   {
                       ciDebugOut(( DEB_ERROR, "Invalid value for PropertyID(%x)\n",
                                    pDbProp->dwPropertyID ));

                       THROW( CException(STATUS_INVALID_PARAMETER) );
                   }
                }
                break;

            default:
                ciDebugOut(( DEB_ERROR, "InvalidPropertyID(%x)\n",
                             pDbProp->dwPropertyID ));

                THROW( CException(STATUS_INVALID_PARAMETER) );
        }
    }
} //ProcessDbInitPropSet

//+---------------------------------------------------------------------------
//
//  Member:     CGetCmdProps::ProcessCiFsExtPropSet
//
//  Synopsis:   Processes the FSCI extension property set.
//
//  Arguments:  [propSet] - The propety set to process.
//  Returns:    none - throws upon failure.
//
//  History:    1-13-97   srikants   Created
//              5-12-97   mohamedn   fs/core prop set splits.
//
//----------------------------------------------------------------------------

void CGetCmdProps::ProcessCiFsExtPropSet( DBPROPSET & propSet )
{
    CDbPropSet * pDbPropSet = (CDbPropSet *) &propSet;

    for ( ULONG i = 0; i < propSet.cProperties; i++ )
    {
        CDbProp * pDbProp = pDbPropSet->GetProperty(i);

        if ( pDbProp->dwStatus != DBPROPSTATUS_OK )
        {
            ciDebugOut(( DEB_TRACE, "PropStatus (0x%X) for (%d) th property\n",
                         pDbProp->dwStatus, i ));
            continue;
        }

        switch ( pDbProp->dwPropertyID )
        {
            case DBPROP_CI_CATALOG_NAME:
                 _aCatalogs = GetWCharFromVariant(*pDbProp,&_cCatalogs);
                 break;

            case DBPROP_CI_DEPTHS:
                 _aDepths =  GetDepthsFromVariant(*pDbProp, &_cDepths,
                                                  (ULONG)~( QUERY_SHALLOW       |
                                                            QUERY_DEEP          |
                                                            QUERY_PHYSICAL_PATH |
                                                            QUERY_VIRTUAL_PATH  ) );
                 break;

            case DBPROP_CI_INCLUDE_SCOPES:
                 _aPaths = GetWCharFromVariant(*pDbProp, &_cScopes);
                 break;

            case DBPROP_CI_QUERY_TYPE:
                 switch ( pDbProp->vValue.vt)
                 {
                    case VT_I4:
                    case VT_UI4:
                         _type = (CiMetaData) pDbProp->vValue.ulVal;
                         break;

                    default:
                        ciDebugOut(( DEB_ERROR, "DBPROP_CI_QUERY_TYPE: invalid variant type: %x\n",
                                     pDbProp->vValue.vt ));

                        THROW( CException(STATUS_INVALID_PARAMETER) );
                 }
                 break;

            default:
                {
                    //
                    // skip extra properties
                    //
                    ciDebugOut(( DEB_TRACE, "non-Native PropID(%x)\n",
                                 pDbProp->dwPropertyID ));
                }
        }
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CGetCmdProps::ProcessPropSet
//
//  Synopsis:   Processes the given property set.
//
//  Arguments:  [propSet] -
//
//  History:    1-13-97   srikants   Created
//
//----------------------------------------------------------------------------

void CGetCmdProps::ProcessPropSet( DBPROPSET & propSet )
{
    if ( propSet.guidPropertySet == guidCiFsExt )
    {
        ProcessCiFsExtPropSet( propSet );
    }
    else if ( propSet.guidPropertySet == guidQueryCorePropset )
    {
        ProcessDbInitPropSet( propSet );
    }
    else
    {
        //
        // skip other property sets -- not needed for Indexing Service.
        //
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\icommand\dbcmdbas.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 2000.
//
//  File:       dbcmdbas.cxx
//
//  Contents:   Wrapper classes for DBCOMMANDTREE
//
//  Classes:    CDbCmdTreeNode
//              CDbColumnNode
//
//  History:    6-06-95   srikants   Created
//
//----------------------------------------------------------------------------


#include <pch.cxx>
#pragma hdrstop

#include <sstream.hxx>

const GUID CDbCmdTreeNode::guidNull = DB_NULLGUID;

inline BOOL IsNotImplemented( WORD wKind )
{
    return (wKind & DBVALUEKIND_VECTOR) || (wKind & DBVALUEKIND_ARRAY);
}

//+---------------------------------------------------------------------------
//
//  Method:     CDbCmdTreeNode::PutWString, static public
//
//  Synopsis:   Marshal a wide charater string.
//
//  Arguments:  [stm]     - Serialization stream
//              [pwszStr] - String to be serialized
//
//  Returns:    -NOTHING-
//
//  History:    6-21-95   srikants   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

void CDbCmdTreeNode::PutWString( PSerStream & stm,
                                 WCHAR const * pwszStr )
{
    ULONG cwc = (0 != pwszStr) ? wcslen( pwszStr ) : 0;

    stm.PutULong( cwc );
    if (cwc)
        stm.PutWChar( pwszStr, cwc );
}

//+---------------------------------------------------------------------------
//
//  Method:     CDbCmdTreeNode::GetWString, static public
//
//  Synopsis:   Unmarshal a wide character string.
//
//  Arguments:  [stm]      - Deserialization stream
//              [fSuccess] - On return, TRUE if string allocation was successful
//              [fBstr]    - TRUE if output string should be a BSTR
//
//  Returns:    WCHAR * - output string, can be null.
//
//  History:    6-21-95   srikants   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

WCHAR * CDbCmdTreeNode::GetWString( PDeSerStream & stm,
                                    BOOL & fSuccess,
                                    BOOL fBstr )
{
    ULONG cwc = stm.GetULong();

    // Guard against attack

    if ( cwc >= 65536 )
    {
        fSuccess = FALSE;
        return 0;
    }

    fSuccess = TRUE;

    if ( 0 == cwc )
    {
        return 0;
    }

    WCHAR * pwszStr = 0;
    if (fBstr)
    {
        pwszStr = (WCHAR *)SysAllocStringLen( L"", cwc );
    }
    else
    {
        ULONG cb = (cwc+1) * sizeof(WCHAR);
        pwszStr = (WCHAR *) CoTaskMemAlloc( cb  );
    }
    if ( 0 == pwszStr )
    {
        fSuccess = FALSE;
        return 0;
    }

    stm.GetWChar( pwszStr, cwc );
    pwszStr[cwc] = L'\0';

    return pwszStr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CDbCmdTreeNode::AllocAndCopyWString, static public
//
//  Synopsis:
//
//  Arguments:  [pSrc] -
//
//  Returns:
//
//  History:    6-22-95   srikants   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

WCHAR * CDbCmdTreeNode::AllocAndCopyWString( const WCHAR * pSrc )
{
    WCHAR * pDst = 0;
    if ( 0 != pSrc )
    {
        const cb = ( wcslen( pSrc ) + 1 ) * sizeof(WCHAR);
        pDst = (WCHAR *) CoTaskMemAlloc( cb );
        if ( 0 != pDst )
        {
            RtlCopyMemory( pDst, pSrc, cb );
        }
    }

    return pDst;
}

//+---------------------------------------------------------------------------
//
//  Method:     CDbCmdTreeNode::UnMarshallTree, static public
//
//  Synopsis:
//
//  Arguments:  [stm] -
//
//  Returns:
//
//  History:    6-21-95   srikants   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

CDbCmdTreeNode * CDbCmdTreeNode::UnMarshallTree( PDeSerStream & stm )
{
    CDbCmdTreeNode * pRoot = new CDbCmdTreeNode();
    if ( 0 != pRoot )
    {
        if ( !pRoot->UnMarshall(stm) )
        {
            delete pRoot;
            pRoot = 0;
        }
    }

    return pRoot;
}


void CDbCmdTreeNode::CleanupDataValue()
{

    if ( IsNotImplemented(wKind) )
    {
        Win4Assert( !"Type Not Implemented" );
        return;
    }

    void * pMemToFree = 0;

    //
    // Deallocate any memory allocated for this node.
    //
    switch ( wKind )
    {
        case DBVALUEKIND_EMPTY:
                break;

        case DBVALUEKIND_WSTR:
                pMemToFree =  (void *) value.pwszValue;
                break;

        case DBVALUEKIND_BSTR:
                SysFreeString( (BSTR)value.pbstrValue );
                break;

        case DBVALUEKIND_COMMAND:
                if ( 0 != value.pCommand )
                {
                    value.pCommand->Release();
                }
                break;

        case DBVALUEKIND_IDISPATCH:
                if ( 0 != value.pDispatch )
                {
                    value.pDispatch->Release();
                }
                break;

        case DBVALUEKIND_MONIKER:
                if ( 0 != value.pMoniker )
                {
                    value.pMoniker->Release();
                }
                break;

        case DBVALUEKIND_ROWSET:

                if ( 0 != value.pRowset )
                {
                    value.pRowset->Release();
                }
                break;

        case DBVALUEKIND_IUNKNOWN:

                if ( 0 != value.pUnknown )
                {
                    value.pUnknown->Release();
                }
                break;


        case DBVALUEKIND_BYGUID:

                if ( 0 != value.pdbbygdValue )
                {
                    delete ((CDbByGuid *) value.pdbbygdValue);
                }
                break;


        case DBVALUEKIND_LIKE:

                if ( 0 != value.pdblikeValue )
                {
                    delete ((CDbLike *) value.pdblikeValue);
                }
                break;

        case DBVALUEKIND_COLDESC:

                Win4Assert(! "DBVALUEKIND_COLDESC unsupported !");
                break;

        case DBVALUEKIND_ID:

                if ( 0 != value.pdbidValue )
                {
                    delete ((CDbColId *) value.pdbidValue);
                }
                break;

        case DBVALUEKIND_CONTENT:

                if ( 0 != value.pdbcntntValue )
                {
                    delete ((CDbContent *) value.pdbcntntValue);
                }
                break;

        case DBVALUEKIND_CONTENTPROXIMITY:

                if ( 0 != value.pdbcntntproxValue )
                {
                    delete ((CDbContentProximity *) value.pdbcntntproxValue);
                }
                break;

        case DBVALUEKIND_CONTENTSCOPE:
                if ( 0 != value.pdbcntntscpValue )
                {
                    delete ((CDbContentScope *) value.pdbcntntscpValue);
                }
                break;

        case DBVALUEKIND_CONTENTTABLE:
                if ( 0 != value.pdbcntnttblValue )
                {
                    delete ((CDbContentTable *) value.pdbcntnttblValue);
                }
                break;

        case DBVALUEKIND_CONTENTVECTOR:

                if ( 0 != value.pdbcntntvcValue )
                {
                    delete ((CDbContentVector *) value.pdbcntntvcValue );
                }
                break;

        case DBVALUEKIND_GROUPINFO:

                if ( 0 != value.pdbgrpinfValue )
                {
                    Win4Assert( !"NYI - DBVALUEKIND_GROUPINFO" );
                    delete ((CDbGroupInfo *) value.pdbgrpinfValue );
                }
                break;

        case DBVALUEKIND_PARAMETER:

                if ( 0 != value.pdbparamValue )
                {
                    Win4Assert( !"NYI - DBVALUEKIND_PARAMETER" );
                    delete ((CDbParameter *) value.pdbparamValue );
                }
                break;

        case DBVALUEKIND_PROPERTY:

                if ( 0 != value.pdbpropValue )
                {
                    Win4Assert( !"NYI - DBVALUEKIND_PROPERTY" );
                    delete ((CDbPropSet *) value.pdbpropValue);
                }
                break;

        case DBVALUEKIND_SETFUNC:

                if ( 0 != value.pdbstfncValue )
                {
                    Win4Assert( !"NYI - DBVALUEKIND_SETFUNC" );
                //  delete ((CDbSetFunc *) value.pdbstfncValue);
                }
                break;

        case DBVALUEKIND_SORTINFO:

                if ( 0 != value.pdbsrtinfValue )
                {
                    delete ((CDbSortInfo *) value.pdbsrtinfValue);
                }
                break;

        case DBVALUEKIND_TEXT:

                if ( 0 != value.pdbtxtValue )
                {
                    Win4Assert( !"NYI - DBVALUEKIND_TEXT" );
                    delete ((CDbText *) value.pdbtxtValue );
                }
                break;

        case DBVALUEKIND_VARIANT:

                if ( 0 != value.pvarValue )
                {
                    CStorageVariant * pVarnt = CastToStorageVariant( *value.pvarValue );
                    delete pVarnt;
                }
                break;

        case DBVALUEKIND_GUID:
                pMemToFree = (void *) value.pGuid;
                break;

        case DBVALUEKIND_BYTES:
                pMemToFree = (void *) value.pbValue;
                break;

        case DBVALUEKIND_STR:
                pMemToFree = (void *) value.pzValue;
                break;

        case DBVALUEKIND_NUMERIC:
                delete ((CDbNumeric *) value.pdbnValue );
                break;

#if CIDBG==1

        case DBVALUEKIND_BOOL:
        case DBVALUEKIND_UI1:
        case DBVALUEKIND_I1:
        case DBVALUEKIND_UI2:
        case DBVALUEKIND_I2:
        case DBVALUEKIND_I4:
        case DBVALUEKIND_UI4:
        case DBVALUEKIND_R4:
        case DBVALUEKIND_R8:
        case DBVALUEKIND_CY:
        case DBVALUEKIND_DATE:
        case DBVALUEKIND_ERROR:
        case DBVALUEKIND_I8:
        case DBVALUEKIND_UI8:
            break;

        default:
            Win4Assert( !"Illegal Case Statement" );
#endif  // CIDBG==1

    };

    if ( 0 != pMemToFree )
    {
        CoTaskMemFree( pMemToFree );
    }

    RtlZeroMemory( &value, sizeof(value) );
}

//+---------------------------------------------------------------------------
//
//  Method:     CDbCmdTreeNode::CDbCmdTreeNode, public
//
//  Synopsis:
//
//  Returns:
//
//  History:    6-06-95   srikants   Created
//
//  Notes:
//
//----------------------------------------------------------------------------


CDbCmdTreeNode::~CDbCmdTreeNode()
{
    //
    //  Unlink pointers before deleting, in case the caller gives
    //  a tree with cycles.
    //
    if ( 0 != pctFirstChild )
    {
        CDbCmdTreeNode * pTree = (CDbCmdTreeNode *)pctFirstChild;
        pctFirstChild = 0;
        delete pTree;
    }

    if ( 0 != pctNextSibling )
    {
        CDbCmdTreeNode * pTree = GetNextSibling();
        pctNextSibling = 0;
        while ( 0 != pTree)
        {
            CDbCmdTreeNode * pNext = pTree->GetNextSibling();
            pTree->pctNextSibling = 0;
            delete pTree;
            pTree = pNext;
        }
    }

    CleanupDataValue();
}

//+---------------------------------------------------------------------------
//
//  Method:     CDbCmdTreeNode::AppendChild, protected
//
//  Synopsis:   Add a node to the end of the child list.
//
//  Arguments:  [pChild] -
//
//  Returns:    Nothing
//
//  History:    6-06-95   srikants   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

void CDbCmdTreeNode::AppendChild( CDbCmdTreeNode *pChild )
{
    Win4Assert( 0 != pChild );

    if ( 0 == pctFirstChild )
    {
        pctFirstChild = pChild;
    }
    else
    {
        DBCOMMANDTREE * pCurr = pctFirstChild;
        while ( 0 != pCurr->pctNextSibling )
        {
            pCurr = pCurr->pctNextSibling;
        }

        pCurr->pctNextSibling = pChild;
    }
}

//+---------------------------------------------------------------------------
//
//  Method:     CDbCmdTreeNode::InsertChild, protected
//
//  Synopsis:   Add a node to the beginning of the child list.
//
//  Arguments:  [pChild] -
//
//  Returns:    Nothing
//
//  History:    6-06-95   srikants   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

void CDbCmdTreeNode::InsertChild( CDbCmdTreeNode *pChild )
{
    Win4Assert( 0 != pChild );
    Win4Assert( 0 == pChild->pctNextSibling );

    pChild->pctNextSibling = pctFirstChild;
    pctFirstChild = pChild;
}


//+---------------------------------------------------------------------------
//
//  Method:     CDbCmdTreeNode::SetChildren, protected
//
//  Synopsis:   Add a list of nodes as children
//
//  Arguments:  [pChild] - head of list
//
//  Returns:    Nothing
//
//  History:    23 Apr 1997   AlanW    Created
//
//  Notes:      Could be inline if it weren't for the asserts
//
//----------------------------------------------------------------------------

void CDbCmdTreeNode::SetChildren( CDbCmdTreeNode *pChild )
{
    Win4Assert( 0 != pChild );
    Win4Assert( 0 == pctFirstChild );

    pctFirstChild = pChild;
}

//+---------------------------------------------------------------------------
//
//  Method:     CDbCmdTreeNode::RemoveFirstChild, protected
//
//  Synopsis:   Unlink first child node and return it.
//
//  Arguments:  -NONE-
//
//  Returns:    First child node.  NULL if no children.
//
//  Notes:
//
//  History:    13 July 1995   AlanW   Created
//
//----------------------------------------------------------------------------

CDbCmdTreeNode * CDbCmdTreeNode::RemoveFirstChild( )
{
    CDbCmdTreeNode * pChild = (CDbCmdTreeNode *)pctFirstChild;

    if (0 != pChild)
    {
        pctFirstChild = pChild->pctNextSibling;
        pChild->pctNextSibling = 0;

    }
    return pChild;
}


//+---------------------------------------------------------------------------
//
//  Method:     CDbCmdTreeNode::AppendSibling, protected
//
//  Synopsis:   Append a node to the end of the sibling list
//
//  Arguments:  [pSibling] - node to be added to the sibling list
//
//  Returns:    Nothing
//
//  History:    6-13-95   srikants   Created
//
//  Notes:      The pSibling may have siblings and children.
//
//----------------------------------------------------------------------------

void CDbCmdTreeNode::AppendSibling( CDbCmdTreeNode *pSibling )
{
    Win4Assert( 0 != pSibling );

    if ( 0 == pctNextSibling )
    {
        pctNextSibling = pSibling;
    }
    else
    {
        DBCOMMANDTREE * pCurr = pctNextSibling;

        while ( 0 != pCurr->pctNextSibling )
        {
            pCurr = pCurr->pctNextSibling;
        }

        pCurr->pctNextSibling = pSibling;
    }
}


//+---------------------------------------------------------------------------
//
//  Method:     CDbCmdTreeNode::TransferNode, public
//
//  Synopsis:   Transfer pointers and data from one command tree node
//              to another.
//
//  Arguments:  [pNode] - pointer to target node.
//
//  Returns:    nothing
//
//  History:    27 Jun 1995   AlanW   Created
//
//  Notes:      Specific to the needs of IQuery::AddPostProcessing;
//              not available to client code.
//
//----------------------------------------------------------------------------

void CDbCmdTreeNode::TransferNode( CDbCmdTreeNode *pNode )
{
    RtlCopyMemory( pNode, this, sizeof(CDbCmdTreeNode));
    RtlZeroMemory( this, sizeof(CDbCmdTreeNode) );
    op = DBOP_DEFAULT;
    wKind = DBVALUEKIND_EMPTY;
}

//+---------------------------------------------------------------------------
//
//  Method:     CDbCmdTreeNode::Clone, public
//
//  Synopsis:   Create a copy of a command tree
//
//  Arguments:  [fCopyErrors] - optional, TRUE if error fields are to be copied
//
//  Returns:    CdbCmdTreeNode* - the copy of the tree
//
//  History:    6-13-95   srikants   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

CDbCmdTreeNode * CDbCmdTreeNode::Clone( BOOL fCopyErrors ) const
{

    if ( IsNotImplemented(wKind) )
    {
        Win4Assert( !"Type Not Implemented" );
        return 0;
    }

    CDbCmdTreeNode * pCopy = new CDbCmdTreeNode( op );

    if ( 0 == pCopy )
        return 0;

    if (fCopyErrors)
        pCopy->hrError = hrError;
    else
        pCopy->hrError =  S_OK;

    BOOL fSuccess = TRUE;
    pCopy->wKind = wKind;

    switch ( wKind )
    {

        case DBVALUEKIND_EMPTY:
                break;

        case DBVALUEKIND_BOOL:
        case DBVALUEKIND_UI1:
        case DBVALUEKIND_I1:
        case DBVALUEKIND_UI2:
        case DBVALUEKIND_I2:
        case DBVALUEKIND_I4:
        case DBVALUEKIND_UI4:
        case DBVALUEKIND_R4:
        case DBVALUEKIND_R8:
        case DBVALUEKIND_CY:
        case DBVALUEKIND_DATE:
        case DBVALUEKIND_ERROR:
        case DBVALUEKIND_I8:
        case DBVALUEKIND_UI8:
            //
            // Just copy the eight bytes.
            //
            pCopy->value.llValue = value.llValue;
            break;

        case DBVALUEKIND_WSTR:

            if ( 0 != value.pwszValue )
            {
                pCopy->value.pwszValue = AllocAndCopyWString( value.pwszValue );
                fSuccess = 0 != pCopy->value.pwszValue;
            }
            break;

        case DBVALUEKIND_BSTR:

            if ( 0 != value.pbstrValue )
            {
                *((BSTR*)&(pCopy->value.pbstrValue)) = SysAllocStringLen( (BSTR)value.pbstrValue,
                                                            SysStringLen( (BSTR)value.pbstrValue ) );
                fSuccess = ( 0 != pCopy->value.pbstrValue );
            }
            break;

        case DBVALUEKIND_COMMAND:

            if ( 0 != value.pCommand )
            {
                value.pCommand->AddRef();
                pCopy->value.pCommand = value.pCommand;
            }
            break;

        case DBVALUEKIND_IDISPATCH:

            if ( 0 != value.pDispatch )
            {
                value.pDispatch->AddRef();
                pCopy->value.pDispatch = value.pDispatch;
            }
            break;

        case DBVALUEKIND_MONIKER:

            if ( 0 != value.pMoniker )
            {
                value.pMoniker->AddRef();
                pCopy->value.pMoniker = value.pMoniker;
            }
            break;

        case DBVALUEKIND_ROWSET:

            if ( 0 != value.pRowset )
            {
                value.pRowset->AddRef();
                pCopy->value.pRowset = value.pRowset;
            }
            break;

        case DBVALUEKIND_IUNKNOWN:

            if ( 0 != value.pUnknown )
            {
                value.pUnknown->AddRef();
                pCopy->value.pUnknown = value.pUnknown;
            }
            break;

        case DBVALUEKIND_BYGUID:

            if ( 0 != value.pdbbygdValue )
            {
                CDbByGuid * pTemp = new CDbByGuid( *value.pdbbygdValue );
                if ( 0 != pTemp )
                {
                    pCopy->value.pdbbygdValue = pTemp->CastToStruct();
                }
                else
                {
                    fSuccess = FALSE;
                }
            }
            break;

        case DBVALUEKIND_COLDESC:

            Win4Assert(! "DBVALUEKIND_COLDESC unsupported !");
            break;

        case DBVALUEKIND_ID:

            if ( 0 != value.pdbidValue )
            {
                CDbColId * pId = new CDbColId( *value.pdbidValue );
                if ( 0 != pId )
                {
                    if ( !pId->IsValid() )
                    {
                        delete pId;
                        fSuccess = FALSE;
                    }
                    else
                        pCopy->value.pdbidValue = pId->CastToStruct();
                }
                else
                {
                    fSuccess = FALSE;
                }
            }
            break;

        case DBVALUEKIND_CONTENT:

            if ( 0 != value.pdbcntntValue )
            {
                CDbContent * pContent = new CDbContent( *value.pdbcntntValue );
                if ( 0 != pContent )
                {
                    if ( !pContent->IsValid() )
                    {
                        delete pContent;
                        fSuccess = FALSE;
                    }
                    else
                        pCopy->value.pdbcntntValue = (DBCONTENT *) pContent;
                }
                else
                {
                    fSuccess = FALSE;
                }
            }
            break;

        case DBVALUEKIND_CONTENTSCOPE:

            if ( 0 != value.pdbcntntscpValue )
            {
                CDbContentScope * pContentScp = new CDbContentScope( *value.pdbcntntscpValue );
                if ( 0 != pContentScp )
                {
                    if ( !pContentScp->IsValid() )
                    {
                        delete pContentScp;
                        fSuccess = FALSE;
                    }
                    else
                        pCopy->value.pdbcntntscpValue = (DBCONTENTSCOPE *) pContentScp;
                }
                else
                {
                    fSuccess = FALSE;
                }
            }
            break;

        case DBVALUEKIND_CONTENTTABLE:

            if ( 0 != value.pdbcntnttblValue )
            {
                CDbContentTable * pContentTbl = new CDbContentTable( *value.pdbcntnttblValue );
                if ( 0 != pContentTbl )
                {
                    if ( !pContentTbl->IsValid() )
                    {
                        delete pContentTbl;
                        fSuccess = FALSE;
                    }
                    else
                        pCopy->value.pdbcntnttblValue = (DBCONTENTTABLE *) pContentTbl;
                }
                else
                {
                    fSuccess = FALSE;
                }
            }
            break;

        case DBVALUEKIND_CONTENTVECTOR:

            if ( 0 != value.pdbcntntvcValue )
            {
                CDbContentVector * pTemp = new CDbContentVector( *value.pdbcntntvcValue );
                if ( pTemp )
                {
                    if ( !pTemp->IsValid() )
                    {
                        delete pTemp;
                        fSuccess = FALSE;
                    }
                    else
                        pCopy->value.pdbcntntvcValue = pTemp->CastToStruct();
                }
                else
                {
                    fSuccess = FALSE;
                }
            }
            break;

        case DBVALUEKIND_CONTENTPROXIMITY:

            if ( 0 != value.pdbcntntproxValue )
            {
                CDbContentProximity * pTemp = new CDbContentProximity( *value.pdbcntntproxValue );
                if (pTemp)
                {
                    if ( !pTemp->IsValid() )
                    {
                        delete pTemp;
                        fSuccess = FALSE;
                    }
                    else
                        pCopy->value.pdbcntntproxValue = pTemp->CastToStruct();
                }
                else
                {
                    fSuccess = FALSE;
                }
            }
            break;

        case DBVALUEKIND_LIKE:

            if ( 0 != value.pdblikeValue )
            {
                CDbLike * pTemp = new CDbLike( *value.pdblikeValue );
                if (pTemp)
                {
                    if ( !pTemp->IsValid() )
                    {
                        delete pTemp;
                        fSuccess = FALSE;
                    }
                    else
                        pCopy->value.pdblikeValue = pTemp->CastToStruct();
                }
                else
                {
                    fSuccess = FALSE;
                }
            }
            break;

        case DBVALUEKIND_GROUPINFO:

            if ( 0 != value.pdbgrpinfValue )
            {
                CDbGroupInfo * pTemp = new CDbGroupInfo( *value.pdbgrpinfValue );
                if ( pTemp )
                {
                    if ( !pTemp->IsValid() )
                    {
                        delete pTemp;
                        fSuccess = FALSE;
                    }
                    else
                        pCopy->value.pdbgrpinfValue = (CDbGroupInfo *) pTemp;
                }
                else
                {
                    fSuccess = FALSE;
                }
            }
            break;

        case DBVALUEKIND_PARAMETER:

            if ( 0 != value.pdbparamValue )
            {
                CDbParameter * pTemp = new CDbParameter( *value.pdbparamValue );
                if ( pTemp )
                {
                    if ( !pTemp->IsValid() )
                    {
                        delete pTemp;
                        fSuccess = FALSE;
                    }
                    else
                        pCopy->value.pdbparamValue = pTemp->CastToStruct();
                }
                else
                {
                    fSuccess = FALSE;
                }
            }
            break;

        case DBVALUEKIND_PROPERTY:

            if ( 0 != value.pdbpropValue )
            {
                CDbPropSet * pTemp = new CDbPropSet( *value.pdbpropValue );
                if ( 0 != pTemp )
                {
                    if ( !pTemp->IsValid() )
                    {
                        delete pTemp;
                        fSuccess = FALSE;
                    }
                    else
                        pCopy->value.pdbpropValue = pTemp->CastToStruct();
                }
                else
                {
                    fSuccess = FALSE;
                }
            }

            break;

        case DBVALUEKIND_SETFUNC:

            Win4Assert( !"NYI - DBVALUEKIND_SETFUNC");
            break;

        case DBVALUEKIND_SORTINFO:

            if ( 0 != value.pdbsrtinfValue )
            {
                CDbSortInfo * pTemp = new CDbSortInfo( *value.pdbsrtinfValue );
                if ( 0 != pTemp )
                {
                    if ( !pTemp->IsValid() )
                    {
                        delete pTemp;
                        fSuccess = FALSE;
                    }
                    else
                        pCopy->value.pdbsrtinfValue = (DBSORTINFO *) pTemp;
                }
                else
                {
                    fSuccess = FALSE;
                }
            }
            break;

        case DBVALUEKIND_TEXT:

            if ( 0 != value.pdbtxtValue )
            {
                CDbText * pTemp = new CDbText( *value.pdbtxtValue );
                if ( pTemp )
                {
                    if ( !pTemp->IsValid() )
                    {
                        delete pTemp;
                        fSuccess = FALSE;
                    }
                    else
                        pCopy->value.pdbtxtValue = (DBTEXT *) pTemp;
                }
                else
                {
                    fSuccess = FALSE;
                }
            }
            break;

        case DBVALUEKIND_VARIANT:

            if ( 0 != value.pvarValue )
            {
                CStorageVariant const * pSrcVarnt =  CastToStorageVariant( *value.pvarValue );
                CStorageVariant * pDstVarnt = new CStorageVariant( *pSrcVarnt );
                fSuccess = ( 0 != pDstVarnt ) && pDstVarnt->IsValid();

                if ( fSuccess )
                    pCopy->value.pvarValue = (VARIANT *) (void *) pDstVarnt;
                else
                    delete pDstVarnt;
            }
            break;

        case DBVALUEKIND_GUID:

            if ( 0 != value.pGuid )
            {
                GUID * pTemp = (GUID *) CoTaskMemAlloc( sizeof(GUID) );
                if ( 0 != pTemp )
                {
                    *pTemp = *value.pGuid;
                    pCopy->value.pGuid = pTemp;
                }
                else
                {
                    fSuccess = FALSE;
                }
            }
            break;

        case DBVALUEKIND_BYTES:

            // how do we know the length of this ??
            Win4Assert( !"NYI - DBVALUEKIND_BYTES" );
            break;

        case DBVALUEKIND_STR:

            if ( 0 != value.pzValue )
            {
                unsigned cb = strlen( value.pzValue ) + 1;
                char * pTemp = (char *) CoTaskMemAlloc( cb );
                if ( pTemp )
                {
                    strcpy( pTemp, value.pzValue );
                    pCopy->value.pzValue = pTemp;
                }
                else
                {
                    fSuccess = FALSE;
                }
            }

            break;

        case DBVALUEKIND_NUMERIC:
            Win4Assert( !"NYI - DBVALUEKIND_NUMERIC" );
            break;

        case DBVALUEKIND_BYREF:
            Win4Assert( !"NYI - DBVALUEKIND_BYREF" );
            break;

        default:
            Win4Assert( !"Invalid Case Statement" );
            pCopy->wKind = DBVALUEKIND_EMPTY;
    }

    if ( !fSuccess )
    {
        delete pCopy;
        return 0;
    }

    //
    // Next allocate the children nodes
    //
    if ( 0 != pctFirstChild )
    {
        CDbCmdTreeNode * pFirstChild = GetFirstChild();
        pCopy->pctFirstChild = pFirstChild->Clone( fCopyErrors );
        if ( 0 == pCopy->pctFirstChild )
        {
            delete pCopy;
            return 0;
        }
    }

    //
    // Next allocate all the siblings.
    // If stack space on the client becomes an issue we could iterate to
    // reduce stack depth.
    //
    if ( 0 != pctNextSibling )
    {
        CDbCmdTreeNode * pSibling = GetNextSibling();
        pCopy->pctNextSibling = pSibling->Clone( fCopyErrors );
        if ( 0 == pCopy->pctNextSibling )
        {
            delete pCopy;
            return 0;
        }
    }

    return pCopy;
}

//+---------------------------------------------------------------------------
//
//  Method:     CDbCmdTreeNode::Marshall
//
//  Synopsis:
//
//  Arguments:  [stm] -
//
//  Returns:
//
//  History:    6-20-95   srikants   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

void CDbCmdTreeNode::Marshall( PSerStream & stm ) const
{

    if ( IsNotImplemented( wKind ) )
    {
        Win4Assert( !"Type Not Implemented" );
        return;
    }

    //
    // Serialize the operator
    //
    stm.PutULong( (ULONG) op );

    //
    // Indicate the kind of the value.
    //
    Win4Assert( sizeof(wKind) == sizeof(USHORT) );
    stm.PutUShort( wKind );

    //
    // Serialize the hrError
    //
    Win4Assert( sizeof(hrError) == sizeof(hrError) );
    stm.PutULong( hrError );

    //
    //
    // Indicate if the child is null or not
    //
    if ( 0 != pctFirstChild  )
    {
        stm.PutByte(1);
    }
    else
    {
        stm.PutByte(0);
    }

    //
    // Indicate if the sibling is null or not
    //
    if ( 0 != pctNextSibling )
    {
        stm.PutByte(1);
    }
    else
    {
        stm.PutByte(0);
    }


    //
    // Next serialize the value.
    //
    switch ( wKind )
    {
        case DBVALUEKIND_EMPTY:
            break;          // nothing to marshall

        case DBVALUEKIND_BOOL:
            Win4Assert( sizeof(DBTYPE_BOOL) == sizeof(BYTE) );
        case DBVALUEKIND_UI1:
        case DBVALUEKIND_I1:
            stm.PutByte( (BYTE) value.schValue );
            break;

        case DBVALUEKIND_UI2:
        case DBVALUEKIND_I2:
            stm.PutUShort( (USHORT) value.sValue );
            break;

        case DBVALUEKIND_I4:
        case DBVALUEKIND_UI4:
            stm.PutULong( (ULONG) value.ulValue );
            break;

        case DBVALUEKIND_R4:
            stm.PutFloat( value.flValue );
            break;

        case DBVALUEKIND_R8:
            stm.PutDouble( value.dblValue );
            break;

        case DBVALUEKIND_CY:
        case DBVALUEKIND_DATE:
        case DBVALUEKIND_ERROR:
        case DBVALUEKIND_I8:
        case DBVALUEKIND_UI8:
            stm.PutBlob( (BYTE *) &value, sizeof(value) );
            break;

        case DBVALUEKIND_WSTR:
            stm.PutWString( value.pwszValue );
            break;

        case DBVALUEKIND_BSTR:
        {
            ULONG cwc = (0 != value.pbstrValue) ? SysStringLen( (BSTR)value.pbstrValue ) : 0;

            stm.PutULong( cwc );
            if (cwc)
                stm.PutWChar( (BSTR)value.pbstrValue, cwc );
        }
            break;

        case DBVALUEKIND_COMMAND:
        case DBVALUEKIND_IDISPATCH:
        case DBVALUEKIND_MONIKER:
        case DBVALUEKIND_ROWSET:
        case DBVALUEKIND_IUNKNOWN:
                // How do you marshall an open interface?
            stm.PutByte(0);
            break;

        case DBVALUEKIND_BYGUID:

            if ( value.pdbbygdValue )
            {
                stm.PutByte(1);
                CDbByGuid * pTemp = (CDbByGuid *) value.pdbbygdValue;
                pTemp->Marshall( stm );
            }
            else
            {
                stm.PutByte(0);
            }
            break;

        case DBVALUEKIND_COLDESC:

            Win4Assert(! "DBVALUEKIND_COLDESC unsupported !");
            break;

        case DBVALUEKIND_ID:

            if ( value.pdbidValue )
            {
                stm.PutByte(1);
                CDbColId * pTemp = (CDbColId *)  value.pdbidValue;
                pTemp->Marshall( stm );
            }
            else
            {
                stm.PutByte(0);
            }
            break;

        case DBVALUEKIND_CONTENT:

            if ( value.pdbcntntValue )
            {
                stm.PutByte(1);
                CDbContent * pTemp = (CDbContent *) value.pdbcntntValue;
                pTemp->Marshall( stm );
            }
            else
            {
                stm.PutByte(0);
            }
            break;

        case DBVALUEKIND_CONTENTVECTOR:

            if ( value.pdbcntntvcValue )
            {
                stm.PutByte(1);
                CDbContentVector * pTemp =
                        (CDbContentVector *)value.pdbcntntvcValue;
                pTemp->Marshall( stm );
            }
            else
            {
                stm.PutByte(0);
            }
            break;

        case DBVALUEKIND_LIKE:

            if (value.pdblikeValue )
            {
                stm.PutByte(1);
                CDbLike * pTemp = (CDbLike *)value.pdblikeValue;
                pTemp->Marshall( stm );
            }
            else
            {
                stm.PutByte( 0 );
            }
            break;

        case DBVALUEKIND_CONTENTPROXIMITY:

            if (value.pdbcntntproxValue )
            {
                stm.PutByte(1);
                CDbContentProximity * pTemp = (CDbContentProximity *)value.pdbcntntproxValue;
                pTemp->Marshall( stm );
            }
            else
            {
                stm.PutByte( 0 );
            }
            break;

        case DBVALUEKIND_GROUPINFO:

            if ( value.pdbgrpinfValue )
            {
                stm.PutByte(1);
                CDbGroupInfo * pTemp =
                        (CDbGroupInfo *)value.pdbgrpinfValue;
                pTemp->Marshall( stm );
            }
            else
            {
                stm.PutByte(0);
            }
            break;

        case DBVALUEKIND_PARAMETER:

            if ( value.pdbparamValue )
            {
                stm.PutByte(1);
                CDbParameter * pTemp = (CDbParameter *)value.pdbparamValue;
                pTemp->Marshall( stm );
            }
            else
            {
                stm.PutByte(0);
            }
            break;

        case DBVALUEKIND_PROPERTY:

            if ( value.pdbpropValue )
            {
                stm.PutByte(1);
                CDbPropSet * pTemp = (CDbPropSet *)value.pdbpropValue;
                pTemp->Marshall( stm );
            }
            else
            {
                stm.PutByte(0);
            }
            break;

        case DBVALUEKIND_SETFUNC:

            stm.PutByte(0);
            Win4Assert( !"NYI - DBVALUEKIND_SETFUNC" );
            break;

        case DBVALUEKIND_SORTINFO:

            if ( value.pdbsrtinfValue )
            {
                stm.PutByte(1);
                CDbSortInfo const * pSortInfo = (CDbSortInfo const *)
                                        value.pdbsrtinfValue;
                pSortInfo->Marshall( stm );
            }
            else
            {
                stm.PutByte(0);
            }

            break;


        case DBVALUEKIND_TEXT:

            if ( value.pdbtxtValue )
            {
                stm.PutByte(1);
                CDbText * pTemp = (CDbText *) value.pdbtxtValue;
                pTemp->Marshall(stm);
            }
            else
            {
                stm.PutByte(0);
            }
            break;

        case DBVALUEKIND_VARIANT:

            if ( value.pvarValue )
            {
                stm.PutByte(1);
                CStorageVariant * pVarnt = CastToStorageVariant( *value.pvarValue );
                pVarnt->Marshall(stm);
            }
            else
            {
                stm.PutByte(0);
            }
            break;

        case DBVALUEKIND_GUID:

            if ( value.pGuid )
            {
                stm.PutByte(1);
                stm.PutBlob( (BYTE *) value.pGuid, sizeof(GUID) );
            }
            else
            {
                stm.PutByte(0);
            }
            break;

        case DBVALUEKIND_BYTES:

            stm.PutByte(0);
            Win4Assert( !"NYI - DBVALUEKIND_BYTES" );
            break;

        case DBVALUEKIND_STR:

            stm.PutByte(0);
            Win4Assert( !"NYI - DBVALUEKIND_STR" );

//            if ( value.pzValue )
//            {
//                stm.PutByte(1);
//                stm.PutString( value.pzValue );
//            }
//            else
//            {
//                stm.PutByte(0);
//            }

            break;

        case DBVALUEKIND_NUMERIC:

            if ( value.pdbnValue )
            {
                stm.PutByte(1);
                CDbNumeric * pTemp = (CDbNumeric *) value.pdbnValue;
                pTemp->Marshall( stm );
            }
            else
            {
                stm.PutByte(0);
            }
            break;

        case DBVALUEKIND_BYREF:

            stm.PutByte(0);
            Win4Assert( !"NYI - DBVALUEKIND_BYREF" );
            break;

        default:

            Win4Assert( !"CDbCmdNode::Marshall - Invalid wKind" );
    }

    //
    // If the child is non-null, serialize the child
    //
    if ( 0 != pctFirstChild )
    {
        GetFirstChild()->Marshall(stm);
    }

    //
    // If the sibling is non-null, serialize the sibling
    // If stack space on the client becomes an issue we could iterate to
    // reduce stack depth.
    //

    if ( 0 != pctNextSibling )
    {
        GetNextSibling()->Marshall(stm);
    }
}

//+---------------------------------------------------------------------------
//
//  Method:     CDbCmdTreeNode::UnMarshall, public
//
//  Synopsis:
//
//  Arguments:  [stm] -
//
//  Returns:
//
//  History:    6-20-95   srikants   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

BOOL CDbCmdTreeNode::UnMarshall( PDeSerStream & stm )
{
    CleanupValue();

    //
    // De-Serialize the operator
    //
    op = (DBCOMMANDOP)stm.GetULong();

    //
    // Indicate the kind of the value.
    //
    Win4Assert( sizeof(wKind) == sizeof(USHORT) );
    wKind = stm.GetUShort();
    Win4Assert( !IsNotImplemented(wKind) );

    hrError = stm.GetULong();

    //
    // Indicate if the child is null or not
    //
    BOOL fChildPresent = 0 != stm.GetByte();
    BOOL fSiblingPresent = 0 != stm.GetByte();

    //
    // Next serialize the value.
    //
    WCHAR * pwszStr;

    BOOL fSuccess = TRUE;

    switch ( wKind )
    {
        case DBVALUEKIND_EMPTY:
            break;          // nothing to marshall

        case DBVALUEKIND_BOOL:
            Win4Assert( sizeof(DBTYPE_BOOL) == sizeof(BYTE) );
        case DBVALUEKIND_UI1:
        case DBVALUEKIND_I1:
            value.schValue = (BYTE) stm.GetByte();
            break;

        case DBVALUEKIND_UI2:
        case DBVALUEKIND_I2:
            value.usValue = stm.GetUShort();
            break;

        case DBVALUEKIND_I4:
        case DBVALUEKIND_UI4:
            value.ulValue = stm.GetULong();
            break;

        case DBVALUEKIND_R4:
            value.flValue = stm.GetFloat();
            break;

        case DBVALUEKIND_R8:
            value.dblValue = stm.GetDouble();
            break;

        case DBVALUEKIND_CY:
        case DBVALUEKIND_DATE:
        case DBVALUEKIND_ERROR:
        case DBVALUEKIND_I8:
        case DBVALUEKIND_UI8:
            stm.GetBlob( (BYTE *) &value, sizeof(value) );
            break;

        case DBVALUEKIND_WSTR:
            pwszStr = GetWString( stm, fSuccess);
            if ( fSuccess )
            {
                value.pwszValue = pwszStr;
            }
            break;

        case DBVALUEKIND_BSTR:
            pwszStr = GetWString( stm, fSuccess, TRUE );
            if ( fSuccess )
            {
                value.pwszValue = pwszStr;
            }
            break;

        case DBVALUEKIND_COMMAND:
        case DBVALUEKIND_IDISPATCH:
        case DBVALUEKIND_MONIKER:
        case DBVALUEKIND_ROWSET:
        case DBVALUEKIND_IUNKNOWN:
            vqDebugOut(( DEB_WARN, "CDbCmdNode::UnMarshall -- Unmarshalling "
                                   "interface pointer failed\n" ));
            stm.GetByte();
            wKind = DBVALUEKIND_EMPTY;
            break;

        case DBVALUEKIND_BYGUID:

            if ( 0 != stm.GetByte() )
            {
                CDbByGuid * pTemp = new CDbByGuid();
                if ( pTemp )
                {
                    value.pdbbygdValue = pTemp->CastToStruct();
                    fSuccess = pTemp->UnMarshall( stm );
                }
                else
                {
                    fSuccess = FALSE;
                }
            }
            break;

        case DBVALUEKIND_COLDESC:

            Win4Assert(! "DBVALUEKIND_COLDESC unsupported !");
            break;

        case DBVALUEKIND_ID:

            if ( 0 != stm.GetByte() )
            {
                CDbColId * pTemp = new CDbColId();
                if ( pTemp )
                {
                    value.pdbidValue = pTemp->CastToStruct();
                    fSuccess = pTemp->UnMarshall( stm );
                }
                else
                {
                    fSuccess = FALSE;
                }
            }
            break;

        case DBVALUEKIND_CONTENT:

            if ( 0 != stm.GetByte() )
            {
                CDbContent * pTemp = new CDbContent();
                if ( pTemp )
                {
                    value.pdbcntntValue = pTemp->CastToStruct();
                    fSuccess = pTemp->UnMarshall( stm );
                }
                else
                {
                    fSuccess = FALSE;
                }
            }
            break;

        case DBVALUEKIND_CONTENTPROXIMITY:

            if ( 0 != stm.GetByte() )
            {
                CDbContentProximity * pTemp = new CDbContentProximity();
                if ( pTemp )
                {
                    value.pdbcntntproxValue = pTemp->CastToStruct();
                    fSuccess = pTemp->UnMarshall( stm );
                }
                else
                {
                    fSuccess = FALSE;
                }
            }
            break;

        case DBVALUEKIND_CONTENTVECTOR:

            if ( 0 != stm.GetByte() )
            {
                CDbContentVector * pTemp = new CDbContentVector();
                if ( pTemp )
                {
                    value.pdbcntntvcValue = pTemp->CastToStruct();
                    fSuccess = pTemp->UnMarshall( stm );
                }
                else
                {
                    fSuccess = FALSE;
                }
            }
            break;

        case DBVALUEKIND_LIKE:

            if ( 0 != stm.GetByte() )
            {
                CDbLike * pTemp = new CDbLike();
                if ( pTemp )
                {
                    value.pdblikeValue = pTemp->CastToStruct();
                    fSuccess = pTemp->UnMarshall( stm );
                }
                else
                {
                    fSuccess = FALSE;
                }
            }
            break;

        case DBVALUEKIND_GROUPINFO:

            if ( 0 != stm.GetByte() )
            {
                CDbGroupInfo * pTemp = new CDbGroupInfo;
                if ( pTemp )
                {
                    value.pdbgrpinfValue = pTemp->CastToStruct();
                    fSuccess = pTemp->UnMarshall( stm );
                }
                else
                {
                    fSuccess = FALSE;
                }
            }
            break;

        case DBVALUEKIND_PARAMETER:

            if ( 0 != stm.GetByte() )
            {
                CDbParameter * pTemp = new CDbParameter();
                if ( pTemp )
                {
                    value.pdbparamValue = pTemp->CastToStruct();
                    fSuccess = pTemp->UnMarshall(stm);
                }
                else
                {
                    fSuccess = FALSE;
                }
            }

            break;

        case DBVALUEKIND_PROPERTY:

            if ( 0 != stm.GetByte() )
            {
                CDbPropSet * pTemp = new CDbPropSet();
                if ( pTemp )
                {
                    value.pdbpropValue = pTemp->CastToStruct();
                    fSuccess = pTemp->UnMarshall( stm );
                }
                else
                {
                    fSuccess = FALSE;
                }
            }
            break;

        case DBVALUEKIND_SETFUNC:

            stm.GetByte();
            Win4Assert( !"NYI - DBVALUEKIND_SETFUNC" );
            break;

        case DBVALUEKIND_SORTINFO:

            if ( 0 != stm.GetByte() )
            {
                CDbSortInfo * pTemp =  new CDbSortInfo();
                if ( pTemp )
                {
                    value.pdbsrtinfValue = pTemp->CastToStruct();
                    fSuccess = pTemp->UnMarshall( stm );
                }
                else
                {
                    fSuccess = FALSE;
                }
            }

            break;


        case DBVALUEKIND_TEXT:

            if ( stm.GetByte() )
            {
                CDbText * pTemp = new CDbText();
                if ( pTemp )
                {
                    value.pdbtxtValue = pTemp->CastToStruct();
                    fSuccess = pTemp->UnMarshall( stm );
                }
                else
                {
                    fSuccess = FALSE;
                }
            }
            break;

        case DBVALUEKIND_VARIANT:

            if ( stm.GetByte() )
            {
                CStorageVariant * pTemp = new CStorageVariant(stm);
                if ( pTemp )
                {
                    value.pvarValue = (VARIANT *) (void *) pTemp;
                }
                else
                {
                    fSuccess = FALSE;
                }
            }
            break;

        case DBVALUEKIND_GUID:

            if ( stm.GetByte() )
            {
                value.pGuid = new GUID;
                if ( value.pGuid )
                {
                    stm.GetBlob( (BYTE *) value.pGuid, sizeof(GUID) );
                }
                else
                {
                    fSuccess = FALSE;
                }
            }
            break;

        case DBVALUEKIND_BYTES:

            stm.GetByte();
            Win4Assert( !"NYI - DBVALUEKIND_BYTES" );
            break;

        case DBVALUEKIND_STR:

            stm.GetByte();
            Win4Assert( !"NYI - DBVALUEKIND_STR" );
            break;

        case DBVALUEKIND_NUMERIC:

            if ( stm.GetByte() )
            {
                CDbNumeric * pTemp = new CDbNumeric();
                if ( pTemp )
                {
                    value.pdbnValue = pTemp->CastToStruct();
                    fSuccess = pTemp->UnMarshall(stm);
                }
                else
                {
                    fSuccess = FALSE;
                }
            }
            break;

        case DBVALUEKIND_BYREF:

            stm.GetByte();
            Win4Assert( !"NYI - DBVALUEKIND_BYREF" );
            break;

        default:
            Win4Assert( !"CDbCmdNode::UnMarshall - Invalid wKind" );
    }

    if ( !fSuccess )
    {
        vqDebugOut(( DEB_WARN, "UnMarshalling 0x%X Failed for out of memory\n",
                     this ));
        return FALSE;
    }

    //
    // If the child is non-null, serialize the child
    //
    if ( fChildPresent )
    {
        pctFirstChild = new CDbCmdTreeNode();
        if ( 0 != pctFirstChild )
            fSuccess = GetFirstChild()->UnMarshall(stm);
        else
            fSuccess = FALSE;
    }

    if ( !fSuccess )
    {
        return FALSE;
    }

    //
    // If the sibling is non-null, serialize the sibling
    //
    if ( fSiblingPresent )
    {
        pctNextSibling = new CDbCmdTreeNode();
        if ( 0 != pctNextSibling )
        {
            fSuccess = GetNextSibling()->UnMarshall(stm);
        }
        else
        {
            fSuccess = FALSE;
        }
    }

    return fSuccess;
}

//+---------------------------------------------------------------------------
//
//  Method:     CDbCmdTreeNode::GetWeight, protected
//
//  Synopsis:
//
//  Arguments:  [lWeight] - The weight to be set.
//
//  Returns:    The weight.
//
//  History:    13-Aug-97   KrishnaN   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

void CDbCmdTreeNode::SetWeight( LONG lWeight )
{
    switch (GetValueType())
    {
        // Takes care of DBOP_content and DBOP_content_freetext
        case DBVALUEKIND_CONTENT:
        {
            CDbContentRestriction *pCont = (CDbContentRestriction *)this;

            pCont->SetWeight( lWeight );
            break;
        }

        // Takes care of DBOP_vector_or
        case DBVALUEKIND_CONTENTVECTOR:
        {
            CDbVectorRestriction *pVector = (CDbVectorRestriction *)this;
            pVector->SetWeight(lWeight);
            break;
        }

        case DBVALUEKIND_LIKE:
        {
            Win4Assert(DBOP_like == GetCommandType());
            CDbPropertyRestriction *pProp = (CDbPropertyRestriction *)this;
            pProp->SetWeight(lWeight);
            break;
        }

        case DBVALUEKIND_CONTENTPROXIMITY:
        {
            Win4Assert(DBOP_content_proximity == GetCommandType());
            CDbProximityNodeRestriction *pProx = (CDbProximityNodeRestriction *)this;
            pProx->SetWeight(lWeight);
            break;
        }

        case DBVALUEKIND_I4:
        {
            switch (GetCommandType())
            {
                case DBOP_equal:
                case DBOP_not_equal:
                case DBOP_less:
                case DBOP_less_equal:
                case DBOP_greater:
                case DBOP_greater_equal:

                case DBOP_equal_any:
                case DBOP_not_equal_any:
                case DBOP_less_any:
                case DBOP_less_equal_any:
                case DBOP_greater_any:
                case DBOP_greater_equal_any:

                case DBOP_equal_all:
                case DBOP_not_equal_all:
                case DBOP_less_all:
                case DBOP_less_equal_all:
                case DBOP_greater_all:
                case DBOP_greater_equal_all:

                case DBOP_anybits:
                case DBOP_allbits:
                case DBOP_anybits_any:
                case DBOP_allbits_any:
                case DBOP_anybits_all:
                case DBOP_allbits_all:
                {
                    CDbPropertyRestriction *pProp = (CDbPropertyRestriction *)this;
                    pProp->SetWeight(lWeight);
                    break;
                }

                case DBOP_not:
                {
                    CDbNotRestriction *pNot = (CDbNotRestriction *)this;
                    pNot->SetWeight(lWeight);
                    break;
                }

                case DBOP_or:
                case DBOP_and:
                {
                    CDbBooleanNodeRestriction *pBoolean = (CDbBooleanNodeRestriction *)this;
                    pBoolean->SetWeight(lWeight);
                    break;
                }

                default:
                    Win4Assert(!"How did we get here?");
                    break;
            }
            break;
        }

        default:
            Win4Assert(!"How did we get here?");
            break;
    }
}

//+---------------------------------------------------------------------------
//
//  Method:     CDbCmdTreeNode::GetWeight, protected
//
//  Synopsis:
//
//  Returns:    The weight.
//
//  History:    13-Aug-97   KrishnaN   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

LONG CDbCmdTreeNode::GetWeight() const
{
    switch (GetValueType())
    {
        case DBVALUEKIND_CONTENT:
            {
                CDbContentRestriction *pCont = (CDbContentRestriction *)this;
                return pCont->GetWeight();
            }

        case DBVALUEKIND_CONTENTVECTOR:
        {
            CDbVectorRestriction *pVector = (CDbVectorRestriction *)this;
            return pVector->GetWeight();
        }

        case DBVALUEKIND_CONTENTPROXIMITY:
        {
            CDbProximityNodeRestriction *pProx = (CDbProximityNodeRestriction *)this;
            return pProx->GetWeight();
        }

        case DBVALUEKIND_LIKE:
        {
            CDbPropertyRestriction *pProp = (CDbPropertyRestriction *)this;
            return pProp->GetWeight();
        }

        case DBVALUEKIND_I4:
        {
            switch (GetCommandType())
            {
                case DBOP_equal:
                case DBOP_not_equal:
                case DBOP_less:
                case DBOP_less_equal:
                case DBOP_greater:
                case DBOP_greater_equal:

                case DBOP_equal_any:
                case DBOP_not_equal_any:
                case DBOP_less_any:
                case DBOP_less_equal_any:
                case DBOP_greater_any:
                case DBOP_greater_equal_any:

                case DBOP_equal_all:
                case DBOP_not_equal_all:
                case DBOP_less_all:
                case DBOP_less_equal_all:
                case DBOP_greater_all:
                case DBOP_greater_equal_all:

                case DBOP_anybits:
                case DBOP_allbits:
                case DBOP_anybits_any:
                case DBOP_allbits_any:
                case DBOP_anybits_all:
                case DBOP_allbits_all:

                {
                    CDbPropertyRestriction *pProp = (CDbPropertyRestriction *)this;
                    return pProp->GetWeight();
                }

                case DBOP_not:
                {
                    CDbNotRestriction *pNot = (CDbNotRestriction *)this;
                    return pNot->GetWeight();
                }

                case DBOP_or:
                case DBOP_and:
                {
                    CDbBooleanNodeRestriction *pVector = (CDbBooleanNodeRestriction *)this;
                    return pVector->GetWeight();
                }

                default:
                    Win4Assert(!"How did we get here?");
                    break;
            }
            break;
        }

        default:
            Win4Assert(!"Need to call the GetWeight for the appropriate class.");
            break;
    }

    return MAX_QUERY_RANK;
}

//+---------------------------------------------------------------------------
//
//  Method:     CDbColumnNode::CDbColumnNode, public
//
//  Synopsis:   Construct a CDbColumnNode
//
//  Arguments:  [guidPropSet] -
//              [wcsProperty] -
//
//  History:    6-06-95   srikants   Created
//
//  Notes:      The assert here validates an assumption in the inline
//              SetPropSet and GetPropSet methods.
//
//----------------------------------------------------------------------------

CDbColumnNode::CDbColumnNode( GUID const & guidPropSet,
                              WCHAR const * wcsProperty )
                  : CDbCmdTreeNode(DBOP_column_name)
{
    wKind = DBVALUEKIND_ID;
    CDbColId * pTemp = new CDbColId( guidPropSet, wcsProperty );
    if ( 0 != pTemp && !pTemp->IsValid() )
    {
        delete pTemp;
        pTemp = 0;
    }

    value.pdbidValue = (DBID *) pTemp;
}


//+---------------------------------------------------------------------------
//
//  Method:     CDbColumnNode::CDbColumnNode, public
//
//  Synopsis:   Construct a CDbColumnNode from a DBID
//
//  Arguments:  [rColSpec] - DBID from which to initialize the node
//
//  History:    6-20-95   srikants   Created
//
//  Notes:      The column must be named by guid & number, or guid & name.
//
//----------------------------------------------------------------------------

CDbColumnNode::CDbColumnNode( DBID const & propSpec, BOOL fIMeanIt )
                : CDbCmdTreeNode(DBOP_column_name)
{

    wKind = DBVALUEKIND_ID;
    CDbColId * pTemp = new CDbColId( propSpec );
    if ( 0 != pTemp && !pTemp->IsValid() )
    {
        delete pTemp;
        pTemp = 0;
    }

    value.pdbidValue = (DBID *) pTemp;
}

//+---------------------------------------------------------------------------
//
//  Member:     CDbScalarValue::Value
//
//  Synopsis:   Gets the value in the scalar into a variant.
//
//  Arguments:  [valOut] -  Output value.
//
//  Returns:    TRUE if successful. FALSE o/w
//
//  History:    11-16-95   srikants   Created
//
//----------------------------------------------------------------------------

void CDbScalarValue::Value( CStorageVariant & valOut )
{
    //
    // Deallocate any memory allocated for this node.
    //
    switch ( wKind )
    {
        case DBVALUEKIND_EMPTY:
            valOut.SetEMPTY();
            break;

        case DBVALUEKIND_BOOL:
            valOut.SetBOOL((SHORT)value.fValue);
            break;

        case DBVALUEKIND_UI1:
            valOut.SetUI1( value.uchValue );
            break;

        case DBVALUEKIND_I1:
            valOut.SetI1( value.schValue );
            break;

        case DBVALUEKIND_UI2:
            valOut = value.usValue;
            break;

        case DBVALUEKIND_I2:
            valOut = value.sValue;
            break;

        case DBVALUEKIND_I4:
            valOut = value.lValue;
            break;

        case DBVALUEKIND_UI4:
            valOut = value.ulValue;
            break;

        case DBVALUEKIND_R4:
            valOut = value.flValue;
            break;

        case DBVALUEKIND_R8:
            valOut = value.dblValue;
            break;

        case DBVALUEKIND_CY:
            valOut = value.cyValue;
            break;

        case DBVALUEKIND_DATE:
            valOut = value.dateValue;
            break;

        case DBVALUEKIND_ERROR:
            valOut = value.scodeValue;
            break;

        case DBVALUEKIND_I8:
            valOut.SetI8( *((LARGE_INTEGER *)(&value.llValue)) );
            break;

        case DBVALUEKIND_UI8:
            valOut.SetUI8( *((ULARGE_INTEGER *)(&value.ullValue)) );
            break;

        case DBVALUEKIND_WSTR:
            valOut = value.pwszValue;
            break;

        case DBVALUEKIND_BSTR:
            valOut.SetBSTR( (BSTR)value.pbstrValue );
            break;

        case DBVALUEKIND_VARIANT:

            {
                CStorageVariant * pVarnt = _GetStorageVariant();
                if ( 0 != pVarnt )
                {
                    valOut = *pVarnt;
                }
                else
                {
                    valOut.SetEMPTY();
                }
            }

            break;

        case DBVALUEKIND_STR:

            if ( value.pzValue )
            {
                valOut = value.pzValue;
            }
            else
            {
                valOut.SetEMPTY();
            }
            break;

        case DBVALUEKIND_BYTES:
        case DBVALUEKIND_NUMERIC:
        case DBVALUEKIND_BYREF:
            valOut.SetEMPTY();
            Win4Assert( !"CDbScalarValue::Value - Not Implemented" );
            break;

        default:
            valOut.SetEMPTY();
            Win4Assert( !"Illegal Case Statement" );

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\icommand\cmdcreat.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 2000.
//
//  File:       cmdcreat.cxx
//
//  Contents:   IQuery for file-based queries
//
//  Classes:    CSimpleCommandCreator
//
//  History:    20 Aug 1998   AlanW   Created - split from stdqspec.cxx
//
//----------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

extern long gulcInstances;

#include <lgplist.hxx>
#include <ciregkey.hxx>
#include "svcquery.hxx"
#include <svccatpx.hxx>

#include "stdqspec.hxx"
#include "cmdcreat.hxx"

SCODE ProxyErrorToCIError( CException & e );
IDBProperties * CreateDbProperties( WCHAR const * pwcCatalog,
                                    WCHAR const * pwcMachine,
                                    WCHAR const * pwcScopes = 0,
                                    CiMetaData eType = CiAdminOp );

//+-------------------------------------------------------------------------
//
//  Method:     CSimpleCommandCreator::CSimpleCommandCreator, public
//
//  Synopsis:   Constructor
//
//  History:    13-May-1997     KrishnaN   Created
//
//--------------------------------------------------------------------------

CSimpleCommandCreator::CSimpleCommandCreator()
        : _cRefs( 1 ),
          xDefaultCatalogValue( 0 )
{
    InterlockedIncrement( &gulcInstances );
}

//+-------------------------------------------------------------------------
//
//  Method:     CSimpleCommandCreator::~CSimpleCommandCreator
//
//  Synopsis:   Desstructor
//
//  History:    13-May-1997     KrishnaN   Created
//
//--------------------------------------------------------------------------

CSimpleCommandCreator::~CSimpleCommandCreator()
{
    InterlockedDecrement( &gulcInstances );
}

//+-------------------------------------------------------------------------
//
//  Method:     CSimpleCommandCreator::QueryInterface, public
//
//  Synopsis:   Rebind to other interface
//
//  Arguments:  [riid]      -- IID of new interface
//              [ppvObject] -- New interface * returned here
//
//  Returns:    S_OK if bind succeeded, E_NOINTERFACE if bind failed
//
//  History:    13-May-1997     KrishnaN   Created
//              26-Aug-1997     KrishnaN   Added IColumnMapperCreator.
//
//--------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE CSimpleCommandCreator::QueryInterface(
    REFIID   riid,
    void  ** ppvObject )
{
    SCODE sc = 0;

    if ( 0 == ppvObject )
        return E_INVALIDARG;

    *ppvObject = 0;

    if ( IID_IClassFactory == riid )
        *ppvObject =  (IClassFactory *)this;
    else if ( IID_ITypeLib == riid )
        sc = E_NOTIMPL;
    else if ( IID_ISimpleCommandCreator == riid )
        *ppvObject = (IUnknown *)(ISimpleCommandCreator *)this;
    else if ( IID_IColumnMapperCreator == riid )
        *ppvObject = (IUnknown *)(IColumnMapperCreator *)this;
    else if ( IID_IUnknown == riid )
        *ppvObject =  (IUnknown *)(IClassFactory *)this;
    else
        sc = E_NOINTERFACE;

    if ( SUCCEEDED( sc ) )
        AddRef();

    return sc;
} //QueryInterface

//+-------------------------------------------------------------------------
//
//  Method:     CSimpleCommandCreator::AddRef, public
//
//  Synopsis:   Increments refcount
//
//  History:    13-May-1997     KrishnaN   Created
//
//--------------------------------------------------------------------------

ULONG STDMETHODCALLTYPE CSimpleCommandCreator::AddRef()
{
    return InterlockedIncrement( &_cRefs );
}

//+-------------------------------------------------------------------------
//
//  Method:     CSimpleCommandCreator::Release, public
//
//  Synopsis:   Decrement refcount.  Delete if necessary.
//
//  History:    13-May-1997     KrishnaN   Created
//
//--------------------------------------------------------------------------

ULONG STDMETHODCALLTYPE CSimpleCommandCreator::Release()
{
    unsigned long uTmp = InterlockedDecrement( &_cRefs );

    if ( 0 == uTmp )
        delete this;

    return(uTmp);
}


//+-------------------------------------------------------------------------
//
//  Method:     CSimpleCommandCreator::CreateInstance, public
//
//  Synopsis:   Creates new CSimpleCommandCreator object
//
//  Arguments:  [pOuterUnk] -- 'Outer' IUnknown
//              [riid]      -- Interface to bind
//              [ppvObject] -- Interface returned here
//
//  History:    13-May-1997     KrishnaN   Created
//
//--------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE CSimpleCommandCreator::CreateInstance( IUnknown * pOuterUnk,
                                                               REFIID riid,
                                                               void  * * ppvObject )
{
    return QueryInterface( riid, ppvObject );
}

//+-------------------------------------------------------------------------
//
//  Method:     CSimpleCommandCreator::LockServer, public
//
//  Synopsis:   Force class factory to remain loaded
//
//  Arguments:  [fLock] -- TRUE if locking, FALSE if unlocking
//
//  Returns:    S_OK
//
//  History:    13-May-1997     KrishnaN   Created
//
//--------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE CSimpleCommandCreator::LockServer(BOOL fLock)
{
    if(fLock)
        InterlockedIncrement( &gulcInstances );
    else
        InterlockedDecrement( &gulcInstances );

    return(S_OK);
}

//+-------------------------------------------------------------------------
//
//  Method:     CSimpleCommandCreator::CreateICommand, public
//
//  Synopsis:   Creates a ICommand.
//
//  Arguments:  [ppUnknown]  -- Returns the IUnknown for the command
//              [pOuterUnk]  -- (optional) outer unknown pointer
//
//  History:    13-May-1997     KrishnaN   Created
//              29-May-1997     EmilyB     Added aggregation support, so now
//                                         returns IUnknown ptr and caller
//                                         must now call QI to get ICommand ptr
//
//--------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE CSimpleCommandCreator::CreateICommand( IUnknown ** ppUnknown,
                                                               IUnknown * pOuterUnk )
{
    if ( 0 == ppUnknown )
        return E_INVALIDARG;

    SCODE sc = S_OK;

    *ppUnknown = 0;
    CQuerySpec * pQuery = 0;

    TRANSLATE_EXCEPTIONS;
    TRY
    {
       pQuery = new CQuerySpec( 0, ppUnknown );
    }
    CATCH(CException, e)
    {
        Win4Assert(0 == pQuery);
        sc = e.GetErrorCode();
    }
    END_CATCH
    UNTRANSLATE_EXCEPTIONS;

    return sc;
}

//+---------------------------------------------------------------------------
//
//  Member:     CSimpleCommandCreator::VerifyCatalog, public
//
//  Synopsis:   Validate catalog location
//
//  Arguments:  [pwszMachine]     -- Machine on which catalog exists
//              [pwszCatalogName] -- Catalog Name
//
//  Returns:    S_OK if catalog is accessible, various errors otherwise.
//
//  History:    22-Jul-97   KyleP   Created
//
//----------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE CSimpleCommandCreator::VerifyCatalog(
                                           WCHAR const * pwszMachine,
                                           WCHAR const * pwszCatalogName )
{
    //  Verify that we have legal parameters

    if ( 0 == pwszMachine ||
         0 == pwszCatalogName )
        return E_INVALIDARG;

    SCODE status = S_OK;

    TRANSLATE_EXCEPTIONS;
    TRY
    {
        // Just try to connect to the catalog.  We don't actually need to
        // do anything!
        XInterface<IDBProperties> xDbProps( CreateDbProperties( pwszCatalogName,
                                                                pwszMachine ) );

        CSvcCatProxy cat( pwszMachine, xDbProps.GetPointer() );
    }
    CATCH( CException, e )
    {
        status = ProxyErrorToCIError( e );
    }
    END_CATCH
    UNTRANSLATE_EXCEPTIONS;

    return status;
}

//+---------------------------------------------------------------------------
//
//  Member:     CSimpleCommandCreator::GetDefaultCatalog, public
//
//  Synopsis:   Determine 'default' catalog for system
//
//  Arguments:  [pwszCatalogName] -- Catalog Name
//              [cwcIn]           -- Size in characters of [pwszCatalogName]
//              [pcwcOut]         -- Size of catalog name
//
//  Returns:    Contents of IsapiDefaultCatalogDirectory registry value.
//
//  History:    22-Jul-97   KyleP   Created
//
//----------------------------------------------------------------------------

CStaticMutexSem g_mtxCommandCreator;

SCODE STDMETHODCALLTYPE CSimpleCommandCreator::GetDefaultCatalog(
                                                  WCHAR * pwszCatalogName,
                                                  ULONG cwcIn,
                                                  ULONG * pcwcOut )
{
    SCODE sc = S_OK;
    TRANSLATE_EXCEPTIONS;
    TRY
    {
        *pcwcOut = 0;

        if ( xDefaultCatalogValue.IsNull() )
        {
            CLock lock(g_mtxCommandCreator);
            if ( xDefaultCatalogValue.IsNull() )
                xDefaultCatalogValue.Set( new CRegAutoStringValue(
                                                   wcsRegAdminTree,
                                                   wcsISDefaultCatalogDirectory,
                                                   L"system" ) );
        }

        *pcwcOut = xDefaultCatalogValue->Get( pwszCatalogName, cwcIn );
    }
    CATCH(CException, e)
    {
        sc = e.GetErrorCode();
    }
    END_CATCH
    UNTRANSLATE_EXCEPTIONS;
    return sc;
}

// IColumnMapperCreator methods

//+-------------------------------------------------------------------------
//
//  Method:     CSimpleCommandCreator::GetColumnMapper, public
//
//  Synopsis:   Retrieves a column mapper object.
//
//  Arguments:  [wcsMachineName]  -- Machine on which the catalog exists
//              [wcsCatalogName]  -- Catalog for which col. mapper is requested
//              [ppColumnMapper]  -- Stores the outgoing column mapper ptr
//
//  History:    26-Aug-1997     KrishnaN   Created
//
//--------------------------------------------------------------------------

const short StaticPropList = 0;
const short DynamicPropList = 1;

SCODE STDMETHODCALLTYPE CSimpleCommandCreator::GetColumnMapper
                               ( WCHAR const *wcsMachineName,
                                 WCHAR const *wcsCatalogName,
                                 IColumnMapper **ppColumnMapper )
{
    if (0 == ppColumnMapper || 0 == wcsCatalogName)
        return E_INVALIDARG;

    //
    // We currently only understand "." or NULL for machine name. Both
    // map to the local machine.
    // We currently only understand constant SYSTEM_DEFAULT_CAT for catalog
    // name. Any catalog name other than this will cause the dynamic list
    // to be returned.
    //

    // Optimize a bit, avoid wcscmp more than once for the same name
    short sCatUsed = DynamicPropList;

    if ( 0 == wcscmp(wcsCatalogName, SYSTEM_DEFAULT_CAT) )
        sCatUsed = StaticPropList;

    if (wcsMachineName && 0 != wcscmp(wcsMachineName, LOCAL_MACHINE))
        return E_INVALIDARG;

    SCODE sc = S_OK;
    *ppColumnMapper = 0;

    TRANSLATE_EXCEPTIONS;
    TRY
    {
        if (DynamicPropList == sCatUsed)
        {
            // return the file based property list
            *ppColumnMapper = GetGlobalPropListFile();
        }
        else
        {
            // return the static default property list
            Win4Assert(StaticPropList == sCatUsed);
            *ppColumnMapper = GetGlobalStaticPropertyList();
        }
    }
    CATCH(CException, e)
    {
        sc = e.GetErrorCode();
    }
    END_CATCH
    UNTRANSLATE_EXCEPTIONS;
    
    return sc;
}

//+---------------------------------------------------------------------------
//
//  Function:   MakeICommand
//
//  Synopsis:   Instantiates an ICommand
//
//  Arguments:  [ppUnknown]  -- Returns the IUnknown for the command
//              [wcsCat]     -- catalog name
//              [wcsMachine] -- machine name
//              [pOuterUnk]  -- (optional) outer unknown pointer
//
//  Returns:    SCODE result of the operation
//
//  History:    21-Feb-96   SitaramR     Created header
//              28-Feb-97   KyleP        Scope to command properties
//              29-May-97   EmilyB       Added aggregation support, so now
//                                       returns IUnknown ptr and caller
//                                       must now call QI to get ICommand ptr
//
//----------------------------------------------------------------------------

SCODE MakeICommand( IUnknown **   ppUnknown,
                    WCHAR const * wcsCat,
                    WCHAR const * wcsMachine,
                    IUnknown * pOuterUnk )
{

    //
    // don't allow setting of catalog/machine here,
    // Call SetScopeProperties after MakeICommand to set properties.
    // maintain this declaration for indexsrv compatibility.
    //
    Win4Assert( wcsCat == 0 && wcsMachine == 0 );

    //
    // Check for invalid parameters
    //
    if ( 0 == ppUnknown )
        return E_INVALIDARG;

    *ppUnknown = 0;

    CQuerySpec * pQuery = 0;
    SCODE sc = S_OK;

    TRANSLATE_EXCEPTIONS;
    TRY
    {
        // pUnknown is modified if CQuerySpec's constructor throws!

        IUnknown * pUnknown = 0;
        pQuery = new CQuerySpec( pOuterUnk, &pUnknown );
        *ppUnknown = pUnknown;
    }
    CATCH( CException, e )
    {
        Win4Assert(0 == pQuery);
        sc = e.GetErrorCode();
    }
    END_CATCH
    UNTRANSLATE_EXCEPTIONS;

    return sc;
} //MakeIQuery

//+---------------------------------------------------------------------------
//
//  Function:   MakeLocalICommand
//
//  Synopsis:   Instantiates an ICommand on the local machine and with
//              the given doc store.
//
//  Arguments:  [ppUnknown]  -- Returns the IUnknown for the command
//              [pDocStore]  -- Doc store
//              [pOuterUnk]  -- (optional) outer unknown pointer
//
//  Returns:    SCODE result of the operation
//
//  History:    23-Apr-97   KrishnaN     Created
//              29-May-97   EmilyB       Added aggregation support, so now
//                                       returns IUnknown ptr and caller
//                                       must now call QI to get ICommand ptr
//
//----------------------------------------------------------------------------

SCODE MakeLocalICommand( IUnknown **   ppUnknown,
                         ICiCDocStore * pDocStore,
                         IUnknown * pOuterUnk)
{
    //
    // Check for invalid parameters
    //
    if ( 0 == ppUnknown || 0 == pDocStore )
        return E_INVALIDARG;

    *ppUnknown = 0;

    CQuerySpec * pQuery = 0;
    SCODE sc = S_OK;

    TRANSLATE_EXCEPTIONS;
    TRY
    {
        // pUnknown is modified if CQuerySpec's constructor throws!

        IUnknown * pUnknown = 0;
        pQuery = new CQuerySpec( pOuterUnk, &pUnknown, pDocStore );
        *ppUnknown = pUnknown;
    }
    CATCH( CException, e )
    {
        Win4Assert(0 == pQuery);
        sc = e.GetErrorCode();
    }
    END_CATCH
    UNTRANSLATE_EXCEPTIONS;

    return sc;
} //MakeLocalICommand

//+---------------------------------------------------------------------------
//
//  Function:   GetSimpleCommandCreatorCF, public
//
//  Synopsis:   Returns SimpleCommandCreatorCF.
//
//  Returns:    IClassFactory. Can throw exceptions.
//
//  History:    14-May-97   KrishnaN     Created
//
//  Note:       Used to avoid having to include stdqspec.hxx
//              into the file exposing the class factory. That
//              requires having to include a whole lot of files.
//
//----------------------------------------------------------------------------

IClassFactory * GetSimpleCommandCreatorCF()
{
    return ((IClassFactory *)new CSimpleCommandCreator);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\icommand\dbrstrct.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       dbrstrct.cxx
//
//  Contents:   C++ Wrapper classes for DBCOMMANDTREE boolean operators
//
//  Classes:    CDbRestriction
//              CDbNodeRestriction
//              CDbNotRestriction
//              CDbPropBaseRestriction
//              CDbPropertyRestriction
//              CDbContentBaseRestriction
//              CDbContentRestriction
//              CDbNatLangContentRestriction
//
//  History:    6-06-95   srikants   Created
//
//----------------------------------------------------------------------------

#include "pch.cxx"
#pragma hdrstop


extern const GUID DBGUID_LIKE_OFS;

//+---------------------------------------------------------------------------
//
//  Method:     CDbPropBaseRestriction::SetProperty
//
//  Synopsis:   Set property node on a content restriction
//
//  Arguments:  [Property] - property identifier to be set on node
//
//  Returns:    
//
//  History:    6-11-95   srikants   Created
//
//  Notes:      
//
//----------------------------------------------------------------------------

BOOL CDbPropBaseRestriction::SetProperty( DBID const & Property )
{
    //
    // If a child property node already exists, we must delete it
    //

    CDbCmdTreeNode * pChild = GetFirstChild();
    Win4Assert( 0 == pChild || pChild->IsColumnName() );

    BOOL fSuccess = TRUE;

    if ( 0 != pChild && pChild->IsColumnName())
    {
        RemoveFirstChild( );
        delete pChild;
    }
    
    XPtr<CDbColumnNode> xProperty( new CDbColumnNode( Property, TRUE ) );
    if ( !xProperty.IsNull() && xProperty->IsValid() )
    {
        InsertChild( xProperty.GetPointer() );
        xProperty.Acquire();
    }
    else
        fSuccess = FALSE;

    return fSuccess;
}

//+---------------------------------------------------------------------------
//
//  Method:     CDbPropBaseRestriction::SetProperty
//
//  Synopsis:   Set property node on a content restriction
//
//  Arguments:  [Property] - property identifier to be set on node
//
//  Returns:    
//
//  History:    6-11-95   srikants   Created
//
//  Notes:      
//
//----------------------------------------------------------------------------

BOOL CDbPropBaseRestriction::SetProperty( CDbColumnNode const & Property )
{
    //
    // If a child node already exists, we must delete it
    //

    CDbCmdTreeNode * pChild = GetFirstChild();
    Win4Assert( 0 == pChild || pChild->IsColumnName() );


    if ( 0 != pChild && pChild->IsColumnName() )
    {
        RemoveFirstChild();
        delete pChild;
    }

    BOOL fSuccess = TRUE;
    XPtr<CDbColumnNode> xProperty( new CDbColumnNode( Property ) );
    if ( !xProperty.IsNull() && xProperty->IsValid() )
    {
        InsertChild( xProperty.GetPointer() );
        xProperty.Acquire();
    }
    else
        fSuccess = FALSE;
    
    return fSuccess;
}

//+---------------------------------------------------------------------------
//
//  Method:     CDbPropertyRestriction::CDbPropertyRestriction
//
//  Synopsis:   
//
//  Arguments:  [relop]    - relation operator
//              [Property] - property identifier to be set on node
//              [prval]    - 
//
//  Returns:    
//
//  History:    6-07-95   srikants   Created
//
//  Notes:      
//
//----------------------------------------------------------------------------

CDbPropertyRestriction::CDbPropertyRestriction( DBCOMMANDOP relop,
                                                DBID const & Property,
                                                CStorageVariant const & prval )
{
    SetRelation( relop );
    SetProperty( Property );
    SetValue( prval );
    if (DBOP_like == relop)
        _SetLikeRelation();
    else
        SetValueType(DBVALUEKIND_I4);

    SetWeight(0);
}


//+---------------------------------------------------------------------------
//
//  Method:     CDbPropertyRestriction::IsCIDialect, private
//
//  Synopsis:   Set up for a DBOP_like node.
//
//  Arguments:  -none-
//
//  Returns:    BOOL - TRUE if value is the GUID for the CI regexp dialect
//
//  History:    26 Jul 1995   AlanW   Created
//
//  Notes:      
//
//----------------------------------------------------------------------------

BOOL CDbPropertyRestriction::IsCIDialect( )
{
    if ( DBVALUEKIND_LIKE == wKind )
    {
        CDbLike * pLike = (CDbLike *) value.pdblikeValue;

        if ( 0 != pLike )
            return DBGUID_LIKE_OFS == pLike->GetDialect();
    }

    return FALSE;
}

//+---------------------------------------------------------------------------
//
//  Method:     CDbPropertyRestriction::_FindOrAddValueNode
//
//  Synopsis:   
//
//  Returns:    
//
//  History:    6-11-95   srikants   Created
//
//  Notes:      
//
//----------------------------------------------------------------------------

CDbScalarValue * CDbPropertyRestriction::_FindOrAddValueNode()
{
    CDbScalarValue * pValue = _FindValueNode();
    if ( 0 == pValue )
    {
        pValue = new CDbScalarValue();
        if ( 0 != pValue )
            AppendChild( pValue );
    }

    return pValue;
}


//+---------------------------------------------------------------------------
//
//  Method:     CDbContentRestriction::CDbContentRestriction
//
//  Synopsis:   
//
//  Arguments:  [pwcsPhrase] - 
//              [Property]   - property identifier to be set on node
//              [ulGenerateMethod]    - 
//              [lcid]       - 
//
//  Returns:    
//
//  History:    6-11-95   srikants   Created
//
//  Notes:      
//
//----------------------------------------------------------------------------

CDbContentRestriction::CDbContentRestriction(
                           const WCHAR * pwcsPhrase,
                           CDbColumnNode const & Property,
                           ULONG ulGenerateMethod,
                           LCID lcid ) :
                           CDbContentBaseRestriction( DBOP_content,
                                      ulGenerateMethod, MAX_QUERY_RANK, lcid, pwcsPhrase )
{

    if ( IsContentValid() )
        SetProperty( Property );
}


//+---------------------------------------------------------------------------
//
//  Method:     CDbContentRestriction::CDbContentRestriction
//
//  Synopsis:   
//
//  Arguments:  [pwcsPhrase] - 
//              [Property]   - property identifier to be set on node
//              [ulGenerateMethod]    - 
//              [lcid]       - 
//
//  Returns:    
//
//  History:    3-20-96   dlee   Created
//
//  Notes:      
//
//----------------------------------------------------------------------------

CDbContentRestriction::CDbContentRestriction(
                           const WCHAR * pwcsPhrase,
                           DBID const & Property,
                           ULONG ulGenerateMethod,
                           LCID lcid ) :
                           CDbContentBaseRestriction( DBOP_content,
                                      ulGenerateMethod, MAX_QUERY_RANK, lcid, pwcsPhrase )
{

    if ( IsContentValid() )
        SetProperty( Property );
}


//+---------------------------------------------------------------------------
//
//  Method:     CDbNatLangRestriction::CdbNatLangRestriction
//
//  Synopsis:   
//
//  Arguments:  [pwcsPhrase] - 
//              [Property]   - property identifier to be set on node
//              [lcid]       - 
//
//  Returns:    
//
//  History:    6-11-95   srikants   Created
//
//  Notes:      
//
//----------------------------------------------------------------------------

CDbNatLangRestriction::CDbNatLangRestriction(
                           const WCHAR * pwcsPhrase,
                           CDbColumnNode const & Property,
                           LCID lcid )
    : CDbContentBaseRestriction( DBOP_content_freetext, GENERATE_METHOD_EXACT,
                                 MAX_QUERY_RANK, lcid, pwcsPhrase )
{
    if ( IsContentValid() )
        SetProperty( Property );
}

CDbNatLangRestriction::CDbNatLangRestriction(
                           const WCHAR * pwcsPhrase,
                           DBID const & Property,
                           LCID lcid )
    : CDbContentBaseRestriction( DBOP_content_freetext, GENERATE_METHOD_EXACT,
                                 MAX_QUERY_RANK, lcid, pwcsPhrase )
{
    if ( IsContentValid() )
        SetProperty( Property );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\icommand\metqspec.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       StdQSpec.cxx
//
//  Contents:   ICommand for file-based queries
//
//  Classes:    CMetadataQuerySpec
//
//  History:    30 Jun 1995   AlanW   Created
//
//----------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include "metqspec.hxx"

//+-------------------------------------------------------------------------
//
//  Member:     CMetadataQuerySpec::CMetadataQuerySpec, public
//
//  Synopsis:   Constructor of a CMetadataQuerySpec
//
//  Arguments:  [pOuterUnk] - Outer unknown
//              [ppMyUnk] - OUT:  filled in with pointer to non-delegated
//                          IUnknown on return
//              [eType] - Class of metadata to return
//              [pCat]  - Content index catalog
//              [pMachine]
//
//  History:    08-Feb-96   KyleP    Added support for virtual paths
//
//--------------------------------------------------------------------------

CMetadataQuerySpec::CMetadataQuerySpec (
    IUnknown * pOuterUnk, 
    IUnknown ** ppMyUnk, 
    CiMetaData    eType,
    WCHAR const * pCat,
    WCHAR const * pMachine )
        : CRootQuerySpec(pOuterUnk, ppMyUnk),
          _eType( eType )
{
    //
    //  Make a copy of the catalog string for ICommand::Clone
    //

    unsigned len = wcslen( pCat ) + 1;
    _xCat.Set( new WCHAR[len] );
    RtlCopyMemory( _xCat.GetPointer(), pCat, len * sizeof(WCHAR) );

    //
    //  Make a copy of the machine string for ICommand::Clone
    //

    if ( 0 != pMachine )
    {
        len = wcslen( pMachine ) + 1;
        _xMachine.Set( new WCHAR[len] );
        RtlCopyMemory( _xMachine.GetPointer(), pMachine, len * sizeof(WCHAR) );
    }
}

//+-------------------------------------------------------------------------
//
//  Member:     CMetadataQuerySpec::QueryInternalQuery, protected
//
//  Synopsis:   Instantiates internal query, using current parameters.
//
//  Returns:    Pointer to internal query object.
//
//  History:    03-Mar-1997   KyleP   Created
//
//--------------------------------------------------------------------------

PIInternalQuery * CMetadataQuerySpec::QueryInternalQuery()
{
    //
    // get a pointer to the IInternalQuery interface
    //

    PIInternalQuery * pQuery = 0;
    SCODE sc = EvalMetadataQuery( &pQuery,
                                  _eType,
                                  _xCat.GetPointer(),
                                  _xMachine.GetPointer() );

    if ( FAILED( sc ) )
        THROW( CException( sc ) );

    return pQuery;
}

//+---------------------------------------------------------------------------
//
//  Member:     MakeMetadataICommand
//
//  Synopsis:   Evaluate the metadata query
//
//  Arguments:  [ppQuery]    -- Returns the IUnknown for the command
//              [eType]      -- Type of metadata (vroot, proot, etc)
//              [wcsCat]     -- Catalog
//              [wcsMachine] -- Machine name for meta query
//              [pOuterUnk]  -- (optional) outer unknown pointer
//
//  Returns     SCODE result
//
//  History:    15-Apr-96   SitaramR     Created header
//              29-May-97   EmilyB       Added aggregation support, so now 
//                                       returns IUnknown ptr and caller 
//                                       must now call QI to get ICommand ptr
//
//----------------------------------------------------------------------------

SCODE MakeMetadataICommand(
    IUnknown **   ppQuery,
    CiMetaData    eType,
    WCHAR const * wcsCat,
    WCHAR const * wcsMachine,
    IUnknown * pOuterUnk )
{
    //
    // Check for invalid parameters
    //

    if ( 0 == wcsCat ||
         0 == ppQuery ||
         ( eType != CiVirtualRoots &&
           eType != CiPhysicalRoots &&
           eType != CiProperties ) )
    {
        return E_INVALIDARG;
    }

    *ppQuery = 0;

    CMetadataQuerySpec * pQuery = 0;
    SCODE sc = S_OK;

    TRANSLATE_EXCEPTIONS;
    TRY
    {
        pQuery = new CMetadataQuerySpec( pOuterUnk,
                                         ppQuery,
                                         eType,
                                         wcsCat,
                                         wcsMachine );
    }
    CATCH( CException, e )
    {
        Win4Assert(0 == pQuery);
        sc = e.GetErrorCode();
    }
    END_CATCH
    UNTRANSLATE_EXCEPTIONS;

    return sc;
} //MakeMetadataICommand

//+---------------------------------------------------------------------------
//
//  Method:     CMetadataQuerySpec::GetProperties, public
//
//  Synopsis:   Get rowset properties
//
//  Arguments:  [cPropertySetIDs]  - number of desired property set IDs or 0
//              [rgPropertySetIDs] - array of desired property set IDs or NULL
//              [pcPropertySets]   - number of property sets returned
//              [prgPropertySets]  - array of returned property sets
//
//  Returns:    SCODE - result code indicating error return status.  One of
//                      S_OK, DB_S_ERRORSOCCURRED or DB_E_ERRORSOCCURRED.  Any
//                      other errors are thrown.
//
//  History:    12-Mayr-97   dlee       Created
//
//----------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE CMetadataQuerySpec::GetProperties(
    ULONG const       cPropertySetIDs,
    DBPROPIDSET const rgPropertySetIDs[],
    ULONG *           pcPropertySets,
    DBPROPSET **      prgPropertySets)
{
    _DBErrorObj.ClearErrorInfo();
    SCODE scParent = CRootQuerySpec::GetProperties( cPropertySetIDs,
                                                    rgPropertySetIDs,
                                                    pcPropertySets,
                                                    prgPropertySets );

    if ( S_OK != scParent )
        _DBErrorObj.PostHResult( scParent, IID_ICommandProperties );

    return scParent;
} //GetProperties

//+---------------------------------------------------------------------------
//
//  Method:     CMetadataQuerySpec::SetProperties, public
//
//  Synopsis:   Set rowset scope properties
//
//  Arguments:  [cPropertySets]   - number of property sets
//              [rgPropertySets]  - array of property sets
//
//  Returns:    SCODE - result code indicating error return status.  One of
//                      S_OK, DB_S_ERRORSOCCURRED or DB_E_ERRORSOCCURRED.  Any
//                      other errors are thrown.
//
//  History:    12-Mayr-97   dlee       Created
//
//----------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE CMetadataQuerySpec::SetProperties(
    ULONG     cPropertySets,
    DBPROPSET rgPropertySets[] )
{
    _DBErrorObj.ClearErrorInfo();
    SCODE scParent = CRootQuerySpec::SetProperties( cPropertySets,
                                                    rgPropertySets );
    if ( S_OK != scParent )
        _DBErrorObj.PostHResult( scParent, IID_ICommandProperties );

    return scParent;
} //SetProperties
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\icommand\dbcmdop.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 2000.
//
//  File:       dbcmdop.cxx
//
//  Contents:   Wrapper classes for DBCOMMANDTREE structure
//
//  Classes:    CDbSelectNode
//              CDbProjectNode
//              CDbProjectListAnchor
//              CDbSortNode
//              CDbSortListAnchor
//              CDbNestingNode
//
//  History:    6-15-95   srikants   Created
//
//----------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

//+---------------------------------------------------------------------------
//
//  Method:     CDbSelectNode::CDbSelectNode
//
//  Synopsis:   Construct a select node.
//
//  Arguments:  -NONE-
//
//  History:    6-15-95   srikants   Created
//
//  Notes:      Only the normal select can be created.  For OFS,
//              order-preserving functions identially with normal select.
//
//----------------------------------------------------------------------------

CDbSelectNode::CDbSelectNode( )
    : CDbCmdTreeNode( DBOP_select )
{
    CDbTableId * pTableId = new CDbTableId( DBTABLEID_NAME );

    if ( 0 != pTableId  )
    {
        if ( pTableId->IsValid() )
        {
            InsertChild( pTableId );
        }
        else
        {
            delete pTableId;
        }
    }
}

//+---------------------------------------------------------------------------
//
//  Method:     CDbSelectNode::SetRestriction
//
//  Synopsis:   Set the restriction expression
//
//  Arguments:  [pRestr] - restriction expression to be set.
//
//  History:    6-15-95   srikants   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

BOOL CDbSelectNode::SetRestriction( CDbCmdTreeNode * pRestr )
{
    if ( IsValid() &&
         GetFirstChild() &&
         GetFirstChild()->GetNextSibling() != 0 )
    {
        //
        //  Restriction expression already set on node.  Remove and
        //  replace it.
        //

        CDbCmdTreeNode * pTableNode = RemoveFirstChild();
        CDbCmdTreeNode * pOldRst = RemoveFirstChild();

        Win4Assert( 0 == GetFirstChild() );   // don't expect any more children

        delete pOldRst;
        InsertChild(pTableNode);
    }
    return AddRestriction(pRestr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CDbListAnchor::_AppendListElement
//
//  Synopsis:   Helper function to add a list-element node and the given
//              column node to the anchor.
//
//  Arguments:  [eleType] -  The type of the element node.
//              [pColumn] -  The column specification node. This will be made
//                           the child of the newly created list element.
//
//  Returns:    TRUE if successful; FALSE otherwise.
//
//  History:    11-16-95   srikants   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

BOOL CDbListAnchor::_AppendListElement( DBCOMMANDOP eleType, CDbColumnNode * pColumn )
{
    Win4Assert( _IsValidListElement( eleType ) );

    Win4Assert( 0 != pColumn );
    CDbCmdTreeNode * pLE = new CDbCmdTreeNode( eleType );

    if ( 0 != pLE )
    {
        pLE->InsertChild( pColumn );
        AppendChild( pLE );
    }

    return (0 != pLE);

}

//+---------------------------------------------------------------------------
//
//  Method:     CDbListAnchor::AppendList, protected
//
//  Synopsis:   Appends a list of elements to a list anchor
//
//  Arguments:  [pListElement] - pointer to head list element
//
//  Returns:    BOOL - TRUE if successful, FALSE otherwise
//
//  History:    17 Aug 1995   AlanW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

BOOL CDbListAnchor::AppendList( CDbCmdTreeNode * pListElement )
{
    Win4Assert( _IsValidListElement( pListElement->GetCommandType() ));
    Win4Assert( pListElement->GetFirstChild() != 0 );

    AppendChild( pListElement );

    return TRUE;
}

//+---------------------------------------------------------------------------
//
//  Method:     CDbListAnchor::AppendListElement, protected
//
//  Synopsis:   Appends a single element to a list anchor
//
//  Arguments:  [pListElement] - pointer to list element
//
//  Returns:    BOOL - TRUE if successful, FALSE otherwise
//
//  History:    17 Aug 1995   AlanW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

BOOL CDbListAnchor::AppendListElement( CDbCmdTreeNode * pListElement )
{
    Win4Assert( _IsValidListElement( pListElement->GetCommandType() ) &&
                 pListElement->GetNextSibling() == 0 );

    Win4Assert( pListElement->GetFirstChild() != 0 );

    AppendChild( pListElement );

    return TRUE;
}


//+---------------------------------------------------------------------------
//
//  Method:     CDbListAnchor::AppendListElement, protected
//
//  Synopsis:
//
//  Arguments:  [eleType]     - list element type
//              [PropSpec]    - Full property spec of column to add
//
//  Returns:    BOOL - TRUE if successful, FALSE otherwise
//
//  History:    6-15-95   srikants   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

BOOL CDbListAnchor::AppendListElement( DBCOMMANDOP eleType,
                                       const DBID & PropSpec)
{
    XPtr<CDbColumnNode> pColumn( new CDbColumnNode( PropSpec, TRUE ) );

    if ( 0 == pColumn.GetPointer() || !pColumn->IsValid() )
        return FALSE;

    if ( _AppendListElement( eleType, pColumn.GetPointer() ) )
    {
        pColumn.Acquire();
        return TRUE;
    }
    else
    {
        return FALSE;
    }
}

//+---------------------------------------------------------------------------
//
//  Method:     CDbProjectListAnchor::AppendListElement, public
//
//  Synopsis:   Add a project_list_element node to the end of the list
//
//  Arguments:  [propSpec] - column to be added to the list
//              [pwszName] - name of column
//
//  Returns:    BOOL - TRUE if successful, FALSE otherwise
//
//  History:    6-15-95   srikants   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

BOOL CDbProjectListAnchor::AppendListElement( const DBID & propSpec, LPWSTR pwszName )
{
    BOOL fSuccess = FALSE;

    XPtr<CDbProjectListElement> pListElem( new CDbProjectListElement( ) );
    if ( 0 == pListElem.GetPointer() )
        return FALSE;

    if ( !pListElem->SetName(pwszName) )
        return FALSE;

    XPtr<CDbColumnNode> pColumn( new CDbColumnNode( propSpec, TRUE ) );
    if ( 0 == pColumn.GetPointer() || !pColumn->IsValid() )
        return FALSE;

    if ( pListElem->SetColumn( pColumn.GetPointer() ) )
        pColumn.Acquire();
    else
        return FALSE;

    AppendChild( pListElem.GetPointer() );
    pListElem.Acquire();

    return TRUE;
}

//+---------------------------------------------------------------------------
//
//  Method:     CDbProjectNode::_FindOrAddAnchor, private
//
//  Synopsis:   Return the project list anchor node.  Add one if there
//              isn't one.
//
//  Returns:    CDbProjectListAnchor* - pointer to the anchor node, or NULL
//              if there was an allocation failure.
//
//  History:    6-15-95   srikants   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

CDbProjectListAnchor * CDbProjectNode::_FindOrAddAnchor()
{
    CDbCmdTreeNode * pChild = GetFirstChild();

    while ( 0 != pChild )
    {
        if (pChild->IsListAnchor())
        {
            Win4Assert( DBOP_project_list_anchor == pChild->GetCommandType() );
            return (CDbProjectListAnchor *)pChild;
        }

        pChild = pChild->GetNextSibling();
    }

    CDbProjectListAnchor * pAnchor = new CDbProjectListAnchor();
    if ( 0 != pAnchor )
    {
        AppendChild( pAnchor );
    }

    return pAnchor;
}


//+---------------------------------------------------------------------------
//
//  Method:     CDbSortNode::_FindOrAddAnchor, private
//
//  Synopsis:   Return the sort list anchor node.  Add one if there
//              isn't one.
//
//  Returns:    CDbSortListAnchor* - pointer to the anchor node, or NULL
//              if there was an allocation failure.
//
//  History:    6-15-95   srikants   Created
//
//  Notes:      We should probably implement this in a base class
//              with the method taking the list anchor type.
//
//----------------------------------------------------------------------------

CDbSortListAnchor * CDbSortNode::_FindOrAddAnchor()
{
    CDbCmdTreeNode * pChild = GetFirstChild();

    while ( 0 != pChild )
    {
        if (pChild->IsListAnchor())
        {
            Win4Assert( DBOP_sort_list_anchor == pChild->GetCommandType() );
            return (CDbSortListAnchor *)pChild;
        }

        pChild = pChild->GetNextSibling();
    }

    CDbSortListAnchor * pAnchor = new CDbSortListAnchor();
    if ( 0 != pAnchor )
    {
        AppendChild( pAnchor );
    }

    return pAnchor;
}


//+---------------------------------------------------------------------------
//
//  Method:     CDbSortNode::AddSortColumn, public
//
//  Synopsis:   Add a sort column to the sort list.
//
//  Returns:    TRUE if successful, FALSE otherwise (allocation failure).
//
//  History:    17 Aug 1995   AlanW   Created
//
//  Notes:      Sort lists consist of a sort list anchor, with a chain
//              of sort list elements as children.  Each sort list element
//              has information pertaining to the sort (direction and locale)
//              and one child which is a column specification.
//
//----------------------------------------------------------------------------

BOOL CDbSortNode::AddSortColumn(DBID const & propSpec,
                                BOOL fDirection,
                                LCID locale)
{
    CDbSortListAnchor * pAnchor = _FindOrAddAnchor();
    XPtr<CDbColumnNode> pCol( new CDbColumnNode( propSpec, TRUE ) );

    if ( 0 == pCol.GetPointer() || 0 == pAnchor || !pCol->IsValid() )
        return FALSE;

    CDbSortListElement * pSortInfo = new CDbSortListElement( fDirection,
                                                             locale );
    if ( 0 != pSortInfo )
    {
        if ( pSortInfo->IsValid() )
        {
            pSortInfo->AddColumn( pCol.Acquire() );
            if ( pAnchor->AppendListElement( pSortInfo ) )
                return TRUE;
        }

        delete pSortInfo;
    }

    return FALSE;
} //AddSortColumn


//+---------------------------------------------------------------------------
//
//  Method:     CDbNestingNode::AddTable, public
//
//  Synopsis:   Add a table node to a nesting.  Remove an existing
//              table node if there is one there.
//
//  Arguments:  [pTable] - node to be added to tree.  Ownership passes
//                         to the command tree.
//
//  Returns:    BOOL - TRUE if operation worked
//
//  History:    08 Aug 1995   AlanW   Created
//
//  Notes:      Nesting nodes are expected to have 0, 1, 4 or 5 child
//              nodes depending upon whether AddTable and _FindGroupListAnchor
//              have been called.
//
//----------------------------------------------------------------------------

BOOL CDbNestingNode::AddTable( CDbCmdTreeNode * pTable )
{
    Win4Assert (! pTable->IsListAnchor());

    CDbCmdTreeNode * pChild = GetFirstChild();

    if ( 0 != pChild && ! pChild->IsListAnchor())
    {
        // Found a table???  Assert on this; we could be nice to the
        // caller and replace it.
        Win4Assert ( ! pChild->IsListAnchor() );
        return FALSE;
    }

    InsertChild( pTable );
    return TRUE;
}


//+---------------------------------------------------------------------------
//
//  Method:     CDbNestingNode::_FindGroupListAnchor, private
//
//  Synopsis:   Return the group list anchor node.  If there is none,
//              add it and the parent list node, the child list node and
//              the grouping column node.
//
//  Returns:    CDbProjectListAnchor* - pointer to the anchor node, or NULL
//              if there was an allocation failure.
//
//  History:    08 Aug 1995   AlanW   Created
//
//  Notes:      Nesting nodes are expected to have 0, 1, 4 or 5 child
//              nodes depending upon whether AddTable and _FindGroupListAnchor
//              have been called.
//
//----------------------------------------------------------------------------

CDbProjectListAnchor * CDbNestingNode::_FindGroupListAnchor()
{
    CDbCmdTreeNode * pChild = GetFirstChild();

    if ( 0 != pChild )
    {
        if (! pChild->IsListAnchor())
        {
            pChild = pChild->GetNextSibling();
        }

        if ( 0 != pChild )
        {
            Win4Assert( DBOP_project_list_anchor == pChild->GetCommandType() );
            return (CDbProjectListAnchor *)pChild;
        }
    }

    XPtr<CDbProjectListAnchor> pGroupList = new CDbProjectListAnchor();
    XPtr<CDbProjectListAnchor> pParentList = new CDbProjectListAnchor();
    XPtr<CDbProjectListAnchor> pChildList = new CDbProjectListAnchor();
    XPtr<CDbColumnNode> pGroupColumn = new CDbColumnNode(
                                                      //, PROPID_CHAPTER
                                                         );

    if ( ! pGroupList.IsNull() &&
         ! pParentList.IsNull() &&
         ! pChildList.IsNull() &&
         ! pGroupColumn.IsNull() )
    {
        pGroupList->AppendSibling(pGroupColumn.Acquire());
        pGroupList->InsertSibling(pChildList.Acquire());
        pGroupList->InsertSibling(pParentList.Acquire());
        AppendChild(pGroupList.GetPointer());
        return pGroupList.Acquire();
    }

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\icommand\dbwrap.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 2000.
//
//  File:       dbwrap.cxx
//
//  Contents:   C++ wrapper classes for DBCOMMANDTREE value structures
//
//  Classes:    CDbColId
//
//  Functions:
//
//  History:    6-22-95   srikants   Created
//
//----------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

//+-------------------------------------------------------------------------
//
//  Member:     CDbColId::CDbColId, public
//
//  Synopsis:   Default constructor
//
//  Effects:    Defines column with null guid and propid 0
//
//  History:    19 Jul 1995   AlanW     Created
//
//--------------------------------------------------------------------------

CDbColId::CDbColId()
{
    eKind = DBKIND_PROPID;
    uName.ulPropid = 0;
}

//+---------------------------------------------------------------------------
//
//  Method:     CDbColId::CDbColId
//
//  Synopsis:   Construct a CDbColId
//
//  Arguments:  [guidPropSet] -
//              [wcsProperty] -
//
//  History:    6-06-95   srikants   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

CDbColId::CDbColId( GUID const & guidPropSet,
                    WCHAR const * wcsProperty )
{
    eKind = DBKIND_GUID_PROPID;
    BOOL fSuccess = SetProperty( wcsProperty );
    if (fSuccess)
        SetPropSet( guidPropSet );
}



//+---------------------------------------------------------------------------
//
//  Method:     CDbColId::CDbColId
//
//  Synopsis:   Construct a CDbColId from a DBID
//
//  Arguments:  [propSpec] - DBID from which to initialize the node
//
//  History:    6-20-95   srikants   Created
//
//  Notes:      The column must be named by guid & number, or guid & name.
//
//----------------------------------------------------------------------------

CDbColId::CDbColId( DBID const & propSpec )
{
    BOOL fSuccess = TRUE;

    eKind = DBKIND_GUID_PROPID;

    CDbColId const * rhs = (CDbColId const *) &propSpec;

    if ( rhs->IsPropertyName() )
    {
        fSuccess = SetProperty(  rhs->GetPropertyName() );
    }
    else  if ( rhs->IsPropertyPropid() )
    {
        SetProperty( rhs->GetPropertyPropid() );
    }
    else
    {
        return;
    }

    if ( fSuccess && rhs->IsPropSetPresent() )
    {
        SetPropSet( rhs->GetPropSet() );
    }
}

//+---------------------------------------------------------------------------
//
//  Method:     CDbColId::CDbColId
//
//  Synopsis:   Construct a CDbColId from another CDbColId
//
//  Arguments:  [propSpec] - CDbColId from which to initialize the node
//
//  History:    6-20-95   srikants   Created
//
//  Notes:      The column must be named by guid & number, or guid & name.
//
//----------------------------------------------------------------------------

CDbColId::CDbColId( CDbColId const & propSpec )
{
    BOOL fSuccess = TRUE;

    eKind = DBKIND_GUID_PROPID;

    if ( propSpec.IsPropertyName() )
    {
        fSuccess = SetProperty(  propSpec.GetPropertyName() );
    }
    else  if ( propSpec.IsPropertyPropid() )
    {
        SetProperty( propSpec.GetPropertyPropid() );
    }
    else
    {
        return;
    }

    if ( fSuccess && propSpec.IsPropSetPresent() )
    {
        SetPropSet( propSpec.GetPropSet() );
    }
}


//+---------------------------------------------------------------------------
//
//  Method:     CDbColId::SetProperty
//
//  Synopsis:
//
//  Arguments:  [wcsProperty] -
//
//  Returns:
//
//  History:    6-06-95   srikants   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

BOOL CDbColId::SetProperty( WCHAR const * wcsProperty )
{
    if ( !_IsValidKind() )
    {
        eKind = DBKIND_GUID_PROPID;
    }
    else if ( DBKIND_NAME == eKind ||
         DBKIND_GUID_NAME == eKind ||
         DBKIND_PGUID_NAME == eKind )
    {
        if ( uName.pwszName )
        {
            CoTaskMemFree( uName.pwszName );
            uName.pwszName = 0;
        }
    }

    BOOL fResult = TRUE;

    if ( wcsProperty )
    {
        uName.pwszName = CDbCmdTreeNode::AllocAndCopyWString( wcsProperty );
        if ( DBKIND_PROPID == eKind )
        {
            eKind = DBKIND_NAME;
        }
        else if ( DBKIND_GUID_PROPID == eKind )
        {
            eKind = DBKIND_GUID_NAME;
        }
        else if ( DBKIND_PGUID_PROPID == eKind )
        {
            eKind = DBKIND_PGUID_NAME;
        }

        fResult = (0 != uName.pwszName);
    }

    return fResult;
}


//+---------------------------------------------------------------------------
//
//  Method:     CDbColId::operator=
//
//  Synopsis:
//
//  Arguments:  [Property] -
//
//  Returns:
//
//  History:    6-12-95   srikants   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

CDbColId & CDbColId::operator=( CDbColId const & Property )
{

    if ( !_IsValidKind() )
    {
        eKind = DBKIND_GUID_PROPID;
    }
    else
    {
        Cleanup();
    }


    if ( DBKIND_GUID_PROPID == Property.eKind ||
         DBKIND_PGUID_PROPID == Property.eKind ||
         DBKIND_PROPID == Property.eKind )
    {
        uName.ulPropid = Property.uName.ulPropid;

        if ( DBKIND_PROPID == Property.eKind )
        {
            eKind = DBKIND_PROPID;
        }
        else if ( DBKIND_GUID_PROPID == Property.eKind  )
        {
            eKind = DBKIND_GUID_PROPID;
            if ( DBKIND_GUID_PROPID == Property.eKind )
            {
                uGuid.guid = Property.uGuid.guid;
            }
            else
            {
                uGuid.guid = *(Property.uGuid.pguid);
            }
        }
    }
    else
    {
        Win4Assert( DBKIND_GUID_NAME  == Property.eKind ||
                    DBKIND_PGUID_NAME == Property.eKind ||
                    DBKIND_NAME == Property.eKind );

        if ( SetProperty( Property.GetPropertyName() ) )
        {
            SetPropSet( Property.GetPropSet() );
        }
    }

    return *this;
}

//+---------------------------------------------------------------------------
//
//  Method:     CDbColId::operator==
//
//  Synopsis:   Compare two column IDs for equality
//
//  Arguments:  [Property] - column ID to be compared with
//
//  Returns:    TRUE if Property is equivalent to this one, FALSE otherwise
//
//  Notes:      The PGUID forms are not considered equivalent to the
//              forms with GUIDs embedded.  It just isn't worth it!
//
//  History:    6-13-95   srikants   Created
//
//----------------------------------------------------------------------------

BOOL CDbColId::operator==( CDbColId const & Property ) const
{
    if ( eKind != Property.eKind )
    {
        return FALSE;
    }

    if ( DBKIND_GUID_PROPID == eKind )
    {
        return uName.ulPropid == Property.uName.ulPropid &&
               uGuid.guid ==    Property.uGuid.guid;
    }
    else if ( DBKIND_GUID_NAME == eKind )
    {
        return ( uGuid.guid ==  Property.uGuid.guid ) &&
               ( 0 == _wcsicmp( uName.pwszName, Property.uName.pwszName ) );
    }
    else if ( DBKIND_PROPID == eKind )
    {
        return uName.ulPropid == Property.uName.ulPropid;
    }
    else if ( DBKIND_NAME == eKind )
    {
        return 0 == _wcsicmp( uName.pwszName, Property.uName.pwszName );
    }
    else if ( DBKIND_PGUID_PROPID == eKind )
    {
        return uName.ulPropid == Property.uName.ulPropid &&
               *uGuid.pguid ==   *Property.uGuid.pguid;
    }
    else if ( DBKIND_PGUID_NAME == eKind )
    {
        return ( *uGuid.pguid ==  *Property.uGuid.pguid ) &&
               ( 0 == _wcsicmp( uName.pwszName, Property.uName.pwszName ) );
    }
    else
        return FALSE;
}

//+---------------------------------------------------------------------------
//
//  Method:     CDbColId::Marshall
//
//  Synopsis:
//
//  Arguments:  [stm] -
//
//  Returns:
//
//  History:    6-21-95   srikants   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

void CDbColId::Marshall( PSerStream & stm ) const
{
    stm.PutULong( eKind );

    switch ( eKind )
    {
        case DBKIND_PROPID:
            stm.PutGUID( uGuid.guid );
            break;

        case DBKIND_GUID_NAME:
            stm.PutGUID( uGuid.guid );
            CDbCmdTreeNode::PutWString( stm, uName.pwszName );
            break;

        case DBKIND_GUID_PROPID:
            stm.PutGUID( uGuid.guid );
            stm.PutULong( uName.ulPropid );
            break;

        case DBKIND_NAME:
            CDbCmdTreeNode::PutWString( stm, uName.pwszName );
            break;

        case DBKIND_PGUID_NAME:
        case DBKIND_PGUID_PROPID:

            if ( 0 != uGuid.pguid )
            {
                stm.PutGUID( *uGuid.pguid );
            }
            else
            {
                stm.PutGUID( CDbCmdTreeNode::guidNull );
            }

            if ( DBKIND_PGUID_PROPID == eKind )
            {
                stm.PutULong( uName.ulPropid );
            }
            else
            {
                CDbCmdTreeNode::PutWString( stm, uName.pwszName );
            }

        default:
           Win4Assert( !"Illegal Case Statement" );
    }
}

//+---------------------------------------------------------------------------
//
//  Method:     CDbColId::UnMarshall
//
//  Synopsis:
//
//  Arguments:  [stm] -
//
//  Returns:
//
//  History:    6-21-95   srikants   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

BOOL CDbColId::UnMarshall( PDeSerStream & stm )
{
    eKind = stm.GetULong();

    BOOL fSuccess = TRUE;

    switch ( eKind )
    {
        case DBKIND_PROPID:
            stm.GetGUID( uGuid.guid );
            break;

        case DBKIND_GUID_NAME:
            stm.GetGUID( uGuid.guid );
            uName.pwszName = CDbCmdTreeNode::GetWString( stm, fSuccess );

            // patch broken old clients

            if ( fSuccess && 0 == uName.pwszName )
                eKind = DBKIND_GUID_PROPID;
            break;

        case DBKIND_GUID_PROPID:
            stm.GetGUID( uGuid.guid );
            uName.ulPropid  = stm.GetULong();
            break;

        case DBKIND_NAME:
            uName.pwszName = CDbCmdTreeNode::GetWString( stm, fSuccess );

            // patch broken old clients

            if ( fSuccess && 0 == uName.pwszName )
                eKind = DBKIND_GUID_PROPID;
            break;

        case DBKIND_PGUID_NAME:
        case DBKIND_PGUID_PROPID:

            stm.GetGUID( uGuid.guid );

            if ( DBKIND_PGUID_PROPID == eKind )
            {
                eKind  = DBKIND_GUID_PROPID;
                uName.ulPropid = stm.GetULong();
            }
            else
            {
                eKind = DBKIND_GUID_NAME;
                uName.pwszName = CDbCmdTreeNode::GetWString( stm, fSuccess );
            }

            // We don't support these two yet -- so assert and return FALSE

            // break;

        default:
           Win4Assert( !"Illegal Case Statement" );
           fSuccess = FALSE;
    }

    return fSuccess;
}


//+---------------------------------------------------------------------------
//
//  Method:     CDbColId::Cleanup, public
//
//  Synopsis:   Cleans out allocated fields in a CDbColId structure
//
//  Returns:
//
//  History:    6-21-95   srikants   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

void CDbColId::Cleanup()
{
    WCHAR * pwszStr = 0;

    switch ( eKind )
    {
        case DBKIND_GUID_NAME:
        case DBKIND_NAME:
            pwszStr = (WCHAR *) uName.pwszName;
            uName.pwszName = 0;
            break;

        case DBKIND_PGUID_NAME:
            pwszStr = (WCHAR *) uName.pwszName;
            uName.pwszName = 0;
            // NOTE:  fall through

        case DBKIND_PGUID_PROPID:
            CoTaskMemFree( uGuid.pguid );
            uGuid.pguid = 0;
    }

    if ( 0 != pwszStr )
    {
        CoTaskMemFree( pwszStr );
    }
}

BOOL CDbColId::Copy( DBID const & rhs )
{
    CDbColId const * pRhs = (CDbColId *) &rhs;
    *this =  *pRhs;

    //
    // If the source is a bogus NAME propid with a 0 value, don't fail
    // the copy.  This is true for broken old clients who pass a fully
    // 0 DBID.
    //

    if ( DBKIND_GUID_NAME == rhs.eKind && 0 == rhs.uName.pwszName )
        eKind = DBKIND_GUID_PROPID;

    return IsValid();
}


//+---------------------------------------------------------------------------
//
//  Member:     CDbByGuid::Marshall
//
//  Synopsis:
//
//  Arguments:  [stm] -
//
//  History:    11-17-95   srikants   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

void CDbByGuid::Marshall( PSerStream & stm ) const
{
    stm.PutBlob( (BYTE *) &guid, sizeof(guid) );
    stm.PutULong( (ULONG) cbInfo );
    if ( cbInfo )
    {
        Win4Assert( 0 != pbInfo );
        stm.PutBlob( pbInfo, (ULONG) cbInfo );
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CDbByGuid::UnMarshall
//
//  Synopsis:
//
//  Arguments:  [stm] -
//
//  Returns:    TRUE if successful; FALSE o/w
//
//  History:    11-17-95   srikants   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

BOOL CDbByGuid::UnMarshall( PDeSerStream & stm )
{
    _Cleanup();

    stm.GetBlob( (BYTE *) &guid, sizeof(guid) );
    cbInfo = stm.GetULong();

    // Guard against attack

    if ( cbInfo > 1000 )
        return FALSE;

    if ( cbInfo )
    {
        pbInfo = (BYTE *) CoTaskMemAlloc( (ULONG) cbInfo );
        if ( 0 != pbInfo )
        {
            stm.GetBlob( pbInfo, (ULONG) cbInfo );
        }
    }

    return IsValid();
}

//+---------------------------------------------------------------------------
//
//  Member:     CDbByGuid::operator
//
//  Synopsis:
//
//  Arguments:  [rhs] -
//
//  Returns:
//
//  History:    11-21-95   srikants   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

CDbByGuid & CDbByGuid::operator=( CDbByGuid const & rhs )
{
    _Cleanup();

    guid = rhs.guid;
    cbInfo = rhs.cbInfo;
    if ( cbInfo )
    {
        pbInfo = (BYTE *) CoTaskMemAlloc( (ULONG) cbInfo );
        if ( 0 != pbInfo )
        {
            RtlCopyMemory( pbInfo, rhs.pbInfo, cbInfo );
        }
    }

    return *this;
}

//+---------------------------------------------------------------------------
//
//  Member:     CDbParameter::Marshall
//
//  Synopsis:
//
//  Arguments:  [stm] -
//
//  History:    11-17-95   srikants   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

void CDbParameter::Marshall( PSerStream & stm ) const
{
    if ( 0 != pwszName )
    {
        stm.PutByte(1);
        stm.PutWString( pwszName );
    }
    else
    {
        stm.PutByte(0);
    }

    stm.PutULong( wType );

    stm.PutULong( (ULONG) cbMaxLength );

    if ( pNum )
    {
        stm.PutByte(1);
        CDbNumeric * pNumeric = (CDbNumeric *) pNum;
        pNumeric->Marshall( stm );
    }
    else
    {
        stm.PutByte(0);
    }

    Win4Assert( sizeof(dwFlags) == sizeof(ULONG) );

    stm.PutULong( dwFlags );

}

//+---------------------------------------------------------------------------
//
//  Member:     CDbParameter::_Cleanup
//
//  Synopsis:
//
//  History:    11-21-95   srikants   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

void CDbParameter::_Cleanup()
{
    if ( pwszName )
    {
        CoTaskMemFree( pwszName );
        pwszName = 0;
    }

    if ( pTypeInfo )
    {
        pTypeInfo->Release();
        pTypeInfo = 0;
    }

    if ( pNum )
    {
        CDbNumeric * pNumeric = (CDbNumeric *) pNum;
        delete pNumeric;
        pNum = 0;
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CDbParameter::UnMarshall
//
//  Synopsis:
//
//  Arguments:  [stm] -
//
//  Returns:    TRUE if successful; FALSE o/w
//
//  History:    11-17-95   srikants   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

BOOL CDbParameter::UnMarshall( PDeSerStream & stm )
{
    _Cleanup();

    if ( stm.GetByte() )
    {
        BOOL fSuccess;
        pwszName = CDbCmdTreeNode::GetWString( stm, fSuccess );
        if ( 0 == pwszName || !fSuccess )
            return FALSE;
    }

    Win4Assert( sizeof(wType) == sizeof(ULONG) );
    wType = (DBTYPE) stm.GetULong();

    cbMaxLength = stm.GetULong();

    if ( stm.GetByte() )
    {
        CDbNumeric * pNumeric = new CDbNumeric();
        if ( pNumeric )
        {
            pNumeric->UnMarshall( stm );
            pNum = pNumeric->CastToStruct();
        }
        else
        {
            _Cleanup();
            return FALSE;
        }
    }

    Win4Assert( sizeof(dwFlags) == sizeof(ULONG) );

    dwFlags = stm.GetULong();

    return TRUE;
}

//+---------------------------------------------------------------------------
//
//  Member:     CDbParameter::Copy
//
//  Synopsis:
//
//  Arguments:  [rhs] -
//
//  Returns:
//
//  History:    11-21-95   srikants   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

BOOL CDbParameter::Copy( DBPARAMETER const & rhs )
{
    _Cleanup();

    if ( rhs.pwszName )
    {
        pwszName = CDbCmdTreeNode::AllocAndCopyWString( rhs.pwszName );
        if ( 0 == pwszName )
        {
            return FALSE;
        }
    }

    wType =  rhs.wType;

    if ( rhs.pTypeInfo )
    {
        pTypeInfo = rhs.pTypeInfo;
        pTypeInfo->AddRef();
    }

    cbMaxLength = rhs.cbMaxLength;

    if ( rhs.pNum )
    {
        CDbNumeric * pTemp = new CDbNumeric( *rhs.pNum );
        if ( 0 == pTemp )
        {
            _Cleanup();
            return FALSE;
        }
    }

    dwFlags = rhs.dwFlags;

    return TRUE;
}


CDbProp::~CDbProp()
{
    Cleanup();
}

void CDbProp::Cleanup()
{
    ((CDbColId &)colid).Cleanup( );

    //
    // In their infinite wisdom, the OLE-DB headers are #pragma pack(2)
    // which can mess up the alignment of this Variant.
    //

    #if (_X86_ == 1)
        CStorageVariant * pVarnt = CastToStorageVariant( vValue );
        pVarnt->SetEMPTY();
    #else
        CStorageVariant * pVarnt = CastToStorageVariant( vValue );

        if ( (((ULONG_PTR)pVarnt) & 0x7) == 0 )
            pVarnt->SetEMPTY();
        else
        {
            VARIANT var;
            Win4Assert( sizeof(var) == sizeof(CStorageVariant) );

            RtlCopyMemory( &var, pVarnt, sizeof(var) );

            ((CStorageVariant *)&var)->SetEMPTY();

            RtlCopyMemory( pVarnt, &var, sizeof(var) );
        }
    #endif
}

CDbPropSet::~CDbPropSet()
{
    if (rgProperties)
    {
        for (unsigned i=0; i<cProperties; i++)
            GetProperty(i)->Cleanup();

        deleteOLE(rgProperties);
    }
}

CDbPropIDSet::~CDbPropIDSet()
{
    deleteOLE(rgPropertyIDs);
}

BOOL CDbPropIDSet::Copy( const DBPROPIDSET & rhs )
{
    if ( cPropertyIDs )
    {
        deleteOLE(rgPropertyIDs);
        rgPropertyIDs = 0;
        cPropertyIDs = 0;
    }

    guidPropertySet = rhs.guidPropertySet;

    if ( rhs.cPropertyIDs )
    {
        XArrayOLE<DBPROPID> aPropId;
        aPropId.InitNoThrow( rhs.cPropertyIDs );
        if ( aPropId.IsNull() )
            return FALSE;

        RtlCopyMemory( aPropId.GetPointer(), rhs.rgPropertyIDs,
                       rhs.cPropertyIDs * sizeof DBPROPID );
        rgPropertyIDs = aPropId.Acquire();
        cPropertyIDs = rhs.cPropertyIDs;
    }

    return TRUE;
}

//+---------------------------------------------------------------------------
//
//  Member:     CDbPropSet::Marshall
//
//  Synopsis:
//
//  Arguments:  [stm] -
//
//  History:    11-17-95   srikants   Created
//
//----------------------------------------------------------------------------

void CDbPropSet::Marshall( PSerStream & stm ) const
{
    stm.PutBlob( (BYTE *) &guidPropertySet, sizeof(guidPropertySet) );

    stm.PutULong( cProperties );

    for (unsigned i=0; i<cProperties; i++)
        GetProperty(i)->Marshall( stm );
}

//+---------------------------------------------------------------------------
//
//  Member:     CDbPropSet::UnMarshall
//
//  Synopsis:   Unmarshalls the object from a stream
//
//  Arguments:  [stm] -- The stream from which the object is unmarshalled
//
//  Returns:    TRUE if successful; FALSE o/w
//
//  History:    11-17-95   srikants   Created
//
//----------------------------------------------------------------------------

BOOL CDbPropSet::UnMarshall( PDeSerStream & stm )
{
    stm.GetBlob( (BYTE *) &guidPropertySet, sizeof(guidPropertySet) );
    cProperties = stm.GetULong();

    // Guard against attack

    if ( cProperties > 100 )
        return FALSE;

    XArrayOLE<DBPROP> xDbProp;
    xDbProp.InitNoThrow( cProperties );
    if ( xDbProp.IsNull() )
        return FALSE;

    CDbProp * pProps = (CDbProp *) xDbProp.Get();

    BOOL fStatus = TRUE;
    unsigned cOk = 0;
    for (unsigned i=0; fStatus && i < cProperties; i++)
    {
        fStatus = pProps[i].UnMarshall( stm );
        if ( fStatus )
            cOk++;
    }

    if (fStatus)
    {
        rgProperties = pProps;
        xDbProp.Acquire();
    }
    else
    {
        for ( i = 0; i < cOk; i++ )
            pProps[i].Cleanup();

        cProperties = 0;
        rgProperties = 0;
    }

    return fStatus;
} //UnMarshall

//+---------------------------------------------------------------------------
//
//  Member:     CDbProp::Marshall
//
//  Synopsis:
//
//  Arguments:  [stm] -
//
//  History:    11-17-95   srikants   Created
//
//----------------------------------------------------------------------------

void CDbProp::Marshall( PSerStream & stm ) const
{
    stm.PutULong( dwPropertyID );
    stm.PutULong( dwOptions );
    stm.PutULong( dwStatus );

    ((CDbColId &)colid).Marshall( stm );

    CStorageVariant const * pVarnt = CastToStorageVariant( vValue );

    //
    // In their infinite wisdom, the OLE-DB headers are #pragma pack(2)
    // which can mess up the alignment of this Variant.
    //

    #if (_X86_ == 1)
        pVarnt->Marshall( stm );
    #else
        if ( (((ULONG_PTR)pVarnt) & 0x7) == 0 )
            pVarnt->Marshall( stm );
        else
        {
            VARIANT var;
            RtlCopyMemory( &var, pVarnt, sizeof(var) );

            ((CStorageVariant *)&var)->Marshall( stm );
        }
    #endif
} //Marshall

//+---------------------------------------------------------------------------
//
//  Member:     CDbProp::UnMarshall
//
//  Synopsis:
//
//  Arguments:  [stm] -
//
//  Returns:    TRUE if successful; FALSE o/w
//
//  History:    11-17-95   srikants   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

BOOL CDbProp::UnMarshall( PDeSerStream & stm )
{
    dwPropertyID = stm.GetULong( );
    dwOptions = stm.GetULong( );
    dwStatus = stm.GetULong( );

    ((CDbColId &)colid).Cleanup();

    if ( !((CDbColId &)colid).UnMarshall( stm ) )
        return FALSE;

    //
    // The OLE-DB headers are #pragma pack(2), which can mess up the
    // alignment of this Variant.  As a work-around, unmarshall into a
    // variant on the stack, then copy the bytes over to vVariant.
    //

    CStorageVariant temp( stm );
    if ( !temp.IsValid() )
        return FALSE;

    RtlCopyMemory( &vValue, &temp, sizeof VARIANT );
    RtlZeroMemory( &temp, sizeof temp );

    return TRUE;
} //UnMarshall

//+---------------------------------------------------------------------------
//
//  Member:     CDbPropSet::Copy
//
//  Synopsis:   Copies a prop set
//
//  Arguments:  [rhs] - the source prop set
//
//  Returns:    TRUE if successful, FALSE otherwise
//
//  History:    11-21-95   srikants   Created
//
//----------------------------------------------------------------------------

BOOL CDbPropSet::Copy( const DBPROPSET & rhs )
{
    //
    // Cleanup existing properties.
    //
    if ( rgProperties )
    {
        for (unsigned i=0; i<cProperties; i++)
            GetProperty(i)->Cleanup();

        deleteOLE(rgProperties);
        rgProperties = 0;
    }

    guidPropertySet = rhs.guidPropertySet;
    cProperties = rhs.cProperties;

    if (cProperties == 0)
        return TRUE;

    XArrayOLE<DBPROP> xDbProp;
    xDbProp.InitNoThrow( cProperties );
    if ( xDbProp.IsNull() )
        return FALSE;

    CDbProp * pProps = (CDbProp *) xDbProp.Get();

    BOOL fStatus = TRUE;
    ULONG cOk = 0;
    for (unsigned i=0; fStatus && i<cProperties; i++)
    {
        fStatus = pProps[i].Copy( rhs.rgProperties[i] );
        if ( fStatus )
            cOk++;
    }

    if (fStatus)
    {
        rgProperties = pProps;
        xDbProp.Acquire();
    }
    else
    {
        for ( i = 0; i < cOk; i++ )
            pProps[ i ].Cleanup();

        cProperties = 0;
        rgProperties = 0;
    }

    return fStatus;
}

//+---------------------------------------------------------------------------
//
//  Member:     CDbProp::Copy
//
//  Synopsis:
//
//  Arguments:  [rhs] -
//
//  Returns:
//
//  History:    11-21-95   srikants   Created
//
//----------------------------------------------------------------------------

#if CIDBG == 1
LONG g_cDbPropCopies = 0;
#endif

BOOL CDbProp::Copy( const DBPROP & rhs )
{
#if CIDBG == 1
    g_cDbPropCopies++;
#endif

    dwPropertyID = rhs.dwPropertyID;
    dwOptions = rhs.dwOptions;
    dwStatus  = rhs.dwStatus;

    #if (_X86_ == 1)

        BOOL fOK = ((CDbColId &) colid).Copy( rhs.colid );

        if ( !fOK )
            return FALSE;

        * CastToStorageVariant( vValue ) = * CastToStorageVariant( rhs.vValue );

        return CastToStorageVariant( vValue )->IsValid();

    #else

        // rhs.colid is NOT 8 Byte aligned

        DBID rhsDbId, lhsDbId;

        RtlCopyMemory( &rhsDbId, &rhs.colid, sizeof DBID );
        RtlCopyMemory( &lhsDbId, &colid, sizeof DBID );
        BOOL fOK = ((CDbColId &)lhsDbId).Copy( rhsDbId );
        RtlCopyMemory( &colid, &lhsDbId, sizeof DBID );

        if ( !fOK )
            return FALSE;

        // vValue is not 8 Byte aligned

        VARIANT lhsVar, rhsVar;
        RtlCopyMemory( &rhsVar, &rhs.vValue, sizeof VARIANT );
        RtlCopyMemory( &lhsVar, &vValue, sizeof VARIANT );

        CStorageVariant * pLeft = CastToStorageVariant( lhsVar );
        CStorageVariant const * pRight = CastToStorageVariant( rhsVar );
        *pLeft = *pRight;

        RtlCopyMemory( &vValue, &lhsVar, sizeof VARIANT );
        return pLeft->IsValid();

    #endif
} //Copy

//+---------------------------------------------------------------------------
//
//  Member:     CDbContentVector::Marshall
//
//  Synopsis:
//
//  Arguments:  [stm] -
//
//  History:    11-17-95   srikants   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

void CDbContentVector::Marshall( PSerStream & stm ) const
{
    Win4Assert( !"Not Yet Implemented" );
}

//+---------------------------------------------------------------------------
//
//  Member:     CDbContentVector::UnMarshall
//
//  Synopsis:
//
//  Arguments:  [stm] -
//
//  Returns:    TRUE if successful; FALSE o/w
//
//  History:    11-17-95   srikants   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

BOOL CDbContentVector::UnMarshall( PDeSerStream & stm )
{
    Win4Assert( !"Not Yet Implemented" );
    return TRUE;
}

//+---------------------------------------------------------------------------
//
//  Member:     CDbNumeric::Marshall
//
//  Synopsis:
//
//  Arguments:  [stm] -
//
//  History:    11-17-95   srikants   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

void CDbNumeric::Marshall( PSerStream & stm ) const
{
    stm.PutByte( precision );
    stm.PutByte( scale );
    stm.PutByte( sign );
    stm.PutBlob( (BYTE *) &val[0], sizeof(val) );
}

//+---------------------------------------------------------------------------
//
//  Member:     CDbNumeric::UnMarshall
//
//  Synopsis:
//
//  Arguments:  [stm] -
//
//  Returns:    TRUE if successful; FALSE o/w
//
//  History:    11-17-95   srikants   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

BOOL CDbNumeric::UnMarshall( PDeSerStream & stm )
{
    precision = stm.GetByte();
    scale = stm.GetByte();
    sign = stm.GetByte();
    stm.GetBlob( (BYTE *) &val[0], sizeof(val) );

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\icommand\parstree.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1995 - 2000.
//
//  File:       Parstree.cxx
//
//  Contents:   Converts OLE-DB command tree into CColumns, CSort, CRestriction
//              and CCategorization.
//
//  Classes:    CParseCommandTree
//
//  History:    31 May 95    AlanW    Created
//
//--------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include <coldesc.hxx>
#include <pidmap.hxx>
#include <parstree.hxx>

static GUID guidBmk = DBBMKGUID;
const CFullPropSpec colChapter( guidBmk, PROPID_DBBMK_CHAPTER );
const CFullPropSpec colBookmark( guidBmk, PROPID_DBBMK_BOOKMARK );

//+---------------------------------------------------------------------------
//
//  Method:     CParseCommandTree::~CParseCommandTree, public
//
//  Synopsis:   Destructor of CParseCommandTree
//
//----------------------------------------------------------------------------

CParseCommandTree::~CParseCommandTree( void )
{
    if (_prst) delete _prst;
}


//--------------------------------------------------------------------------
//
//  Command tree syntax accepted:
//
//      QueryTree :
//              Table |
//              ContentTable |
//              SetUnion |
//              Categorization |
//              Projection |
//              OrderedQueryTree |
//              Restriction |
//              TopNode QueryTree
//      Categorization :
//              nesting OrderedQueryTree GroupingList ParentList ChildList coldef
//      ContentTable :
//              <empty> |
//              scope_list_anchor scope_list_element | 
//              ScopeList scope_list_element
//      GroupingList : ProjectList
//      ParentList : ProjectList
//      ChildList : ProjectList
//      Projection :
//              ProjectOperator QueryTree ProjectList
//      ProjectOperator :
//              project | project_order_preserving
//      ProjectList :
//              project_list_anchor project_list_element |
//              ProjectList project_list_element
//      OrderedQueryTree :
//              sort QueryTree SortList
//      ScopeList :
//              scope_list_anchor scope_list_element |
//              ScopeList scope_list_element
//      SetUnion:
//              ContentTable ContentTable |
//              SetUnion ContentTable
//      SortList :
//              sort_list_anchor sort_list_element |
//              SortList sort_list_element
//      Restriction :
//              select QueryTree ExprTree |
//              select_order_preserving QueryTree ExprTree
//      Table :
//              scalar_identifier( Table )
//      ExprTree :
//              not ExprTree |
//              and ExprList |
//              or ExprList |
//              content_proximity ContentExprList
//              vector_or ContentExprList
//              ExprTerm
//      ExprList :
//              ExprTree ExprTree |
//              ExprList ExprTree
//      ExprTerm :
//              ContentExpr |
//              ValueExpr |
//              LikeExpr
//      ValueExpr :
//              ValueOperator scalar_identifier(ColId) scalar_constant
//      ValueOperator :
//              equal | not_equal | less | less_equal | greater | greater_equal |
//              equal_any | not_equal_any | less_any | less_equal_any |
//              greater_any | greater_equal_any |
//              equal_all | not_equal_all | less_all | less_equal_all |
//              greater_all | greater_equal_all | any_bits | all_bits
//      LikeExpr :
//              like(OfsRegexp) scalar_identifier(ColId) scalar_constant
//      ContentExprTree :
//              not ContentExprTree |
//              and ContentExprList |
//              or ContentExprList |
//              content_proximity ContentExprList
//              ContentExpr
//      ContentExprList :
//              ContentExprTree ContentExprTree |
//              ContentExprList ContentExprTree
//      ContentExpr :
//              content PhraseList |
//              freetext_content PhraseList
//
//+---------------------------------------------------------------------------



//+---------------------------------------------------------------------------
//
//  Method:     CParseCommandTree::ParseTree, public
//
//  Synopsis:   Parse a CDbCmdTreeNode into projection, sort, restriction
//              and categorizations.
//
//  Arguments:  [pTree]   -- CDbCmdTreeNode node at root of tree to be parsed
//
//  Returns:    nothing.  Throws if error in tree.
//
//  History:    31 May 95   AlanW       Created
//
//----------------------------------------------------------------------------

void CParseCommandTree::ParseTree( CDbCmdTreeNode * pTree )
{
    CheckRecursionLimit();
    
    if (pTree == 0)
    {
        vqDebugOut(( DEB_WARN, "ParseTree - null tree\n"));
        THROW( CException( E_INVALIDARG ));
    }

    switch (pTree->GetCommandType())
    {
    case DBOP_project:
    case DBOP_project_order_preserving:
        ParseProjection( pTree );
        break;

    case DBOP_sort:
        ParseSort( pTree );
        break;

    case DBOP_select:
//  case DBOP_select_order_preserving:
        ParseRestriction( pTree );
        break;

    case DBOP_nesting:
        ParseCategorization( pTree );
        break;

    case DBOP_table_name:
        if ( _wcsicmp( ((CDbTableId *)pTree)->GetTableName(), DBTABLEID_NAME ))
            SetError( pTree );
        break;

    case DBOP_top:
        ParseTopNode( pTree );
        break;

    case DBOP_firstrows:
        ParseFirstRowsNode( pTree );
        break;

    case DBOP_content_table:
        ParseScope( pTree );
        break;

    case DBOP_set_union:
        ParseMultiScopes( pTree );
        break;

    default:
        vqDebugOut(( DEB_WARN, "ParseTree - unexpected operator %d\n", pTree->GetCommandType() ));
        SetError( pTree );
        break;
    }
    return;
}

//+---------------------------------------------------------------------------
//
//  Method:     CParseCommandTree::ParseScope, public
//
//  Synopsis:   Parse a CDbCmdTreeNode scope operator
//
//  Arguments:  [pTree]   -- CDbCmdTreeNode scope specification node
//
//  History:    09-15-98        danleg      Created
//
//  Notes:      Here is a variation of a tree with scope nodes.  This routine 
//              gets a tree rooted either at a content_table node if a single 
//              scope is specified, or a set_union node if there are multiple 
//              scopes.
//
//                                                          proj
//                                          _________________/
//                                         /
//                                     select ___________________ LA-proj
//                         _____________/                      ____/
//                        /                                   /
//                     set_union ________ content         LE_proj ____ LE_proj
//                    ____/                ____/         ___/           __/
//                   /                    /             /              /
//                  /                column_name   column_name    column_name
//                 /
//              set_union ________________ content_table
//              __/                            __/
//             /                              /
//            /                              ...
//     content_table ____ content_table
//        ___/               ___/
//       /                  /
//    LA_scp            LA_scp
//    __/              __/
//   /                /
// LE_scp ...      LE_scp ___ LE_scp ___ ...
//
//----------------------------------------------------------------------------

void CParseCommandTree::ParseScope( CDbCmdTreeNode * pTree )
{
    CheckRecursionLimit();
    
    Win4Assert( DBOP_content_table == pTree->GetCommandType() );

    if ( 0 != pTree->GetFirstChild() )
    {
        //
        // qualified scope
        //

        ParseScopeListElements( pTree );
    }
    else
    {
        //
        // unqualified scope
        //

        _cScopes++;

        _xaMachines.SetSize( _cScopes );
        _xaScopes.SetSize( _cScopes );
        _xaFlags.SetSize( _cScopes );
        _xaCatalogs.SetSize( _cScopes );

        CDbContentTable * pCntntTbl = 
            (CDbContentTable *) (pTree->CastToStruct())->value.pdbcntnttblValue;

        _xaMachines[_cScopes-1] = pCntntTbl->GetMachine();
        _xaCatalogs[_cScopes-1] = pCntntTbl->GetCatalog();
        _xaFlags[_cScopes-1]    = QUERY_DEEP | QUERY_PHYSICAL_PATH;
        _xaScopes[_cScopes-1]   = L"\\";
    }

    if (  0 != pTree->GetNextSibling() &&
          DBOP_content_table == pTree->GetNextSibling()->GetCommandType() )
        ParseTree( pTree->GetNextSibling() );
}

//+---------------------------------------------------------------------------
//
//  Method:     CParseCommandTree::ParseScopeListElements, public
//
//  Synopsis:   
//
//  Arguments:  [pcntntTbl]  -- node consisting of catalog/machine name info
//              [pTree]      -- CDbCmdTreeNode scope specification node
//
//  History:    01-24-99        danleg      Created
//
//----------------------------------------------------------------------------

void CParseCommandTree::ParseScopeListElements( CDbCmdTreeNode * pTree )
{
    CheckRecursionLimit();
    
    if ( 0 == pTree->GetFirstChild() )
    {
        SetError( pTree );
    }
    if ( DBOP_scope_list_anchor != pTree->GetFirstChild()->GetCommandType() )
    {
        SetError( pTree->GetFirstChild() );
    }
    CheckOperatorArity( pTree->GetFirstChild(), -1 );

    CDbContentTable * pCntntTbl = 
                        (CDbContentTable *) (pTree->CastToStruct())->value.pdbcntnttblValue;
    CDbCmdTreeNode * pLE_SCP = pTree->GetFirstChild()->GetFirstChild();

    for (   ;
            pLE_SCP;
            pLE_SCP = pLE_SCP->GetNextSibling() )
    {
        if ( DBOP_scope_list_element != pLE_SCP->GetCommandType() ||
             0 != pLE_SCP->GetFirstChild() )
        {
            SetError( pLE_SCP );
        }
        VerifyValueType( pLE_SCP, DBVALUEKIND_CONTENTSCOPE );

        CDbContentScope * pCntntScp = 
                    (CDbContentScope *) (pLE_SCP->CastToStruct())->value.pdbcntntscpValue;

        _cScopes++;

        _xaMachines.SetSize( _cScopes );
        _xaScopes.SetSize( _cScopes );
        _xaFlags.SetSize( _cScopes );
        _xaCatalogs.SetSize( _cScopes );

        _xaMachines[_cScopes-1] = pCntntTbl->GetMachine();
        _xaCatalogs[_cScopes-1] = pCntntTbl->GetCatalog();

        //
        // DBPROP_CI_SCOPE_FLAGS
        //
        if ( pCntntScp->GetType() & SCOPE_TYPE_WINPATH )
            _xaFlags[_cScopes-1] = QUERY_PHYSICAL_PATH;
        else if ( pCntntScp->GetType() & SCOPE_TYPE_VPATH )
            _xaFlags[_cScopes-1] = QUERY_VIRTUAL_PATH;
        else    
        {
            // unknown flag
            SetError( pLE_SCP );
        }

        if ( pCntntScp->GetFlags() & SCOPE_FLAG_DEEP )
            _xaFlags[_cScopes-1] |= QUERY_DEEP;
        else
            _xaFlags[_cScopes-1] |= QUERY_SHALLOW;

        //
        // DBPROP_CI_INCLUDE_SCOPES
        //

        _xaScopes[_cScopes-1] = pCntntScp->GetValue();
    }
}

//+---------------------------------------------------------------------------
//
//  Method:     CParseCommandTree::ParseMultiScopes, public
//
//  Synopsis:   
//
//  Arguments:  [pcntntTbl]  -- node consisting of catalog/machine name info
//              [pTree]      -- CDbCmdTreeNode scope specification node
//
//  History:    01-24-99        danleg      Created
//
//  Notes:      Two possibilities:
//
//                      set_union ___ content
//           ______________/
//          /
//   content_table ___ content_table ___ ... ___ content_table
//
// 
//  -- or --
//
//                        set_union ___ content
//                ___________/
//               /
//           set_union _____________________________ set_union
//         _____/                                ______/
//        /                                     /
//  content_table ___ content_table      content_table ___ content_table
//
//----------------------------------------------------------------------------

void CParseCommandTree::ParseMultiScopes( CDbCmdTreeNode * pTree )
{
    CheckRecursionLimit();
    
    Win4Assert( DBOP_set_union == pTree->GetCommandType() );

    Win4Assert( 0 != pTree->GetFirstChild() && 
                0 != pTree->GetNextSibling() );
    
    if ( DBOP_content_table == pTree->GetCommandType() )
    {
        CDbCmdTreeNode * pCntntTbl = pTree->GetFirstChild();

        for (   ;
                pCntntTbl;
                pCntntTbl = pCntntTbl->GetNextSibling() )
        {
            if ( DBOP_content_table != pCntntTbl->GetCommandType() )
                SetError( pCntntTbl );

            ParseScope( pCntntTbl );
        }
    }
    else
    {
        Win4Assert( DBOP_set_union == pTree->GetCommandType() );

        if ( DBOP_content_table != pTree->GetFirstChild()->GetCommandType() &&
                    DBOP_set_union != pTree->GetFirstChild()->GetCommandType() )
            SetError( pTree );

        ParseTree( pTree->GetFirstChild() );

        //
        // Note that the DBOP_content branch gets parsed by ParseRestriction
        //
        if ( DBOP_content_table == pTree->GetNextSibling()->GetCommandType() ||
             DBOP_set_union == pTree->GetNextSibling()->GetCommandType() )
            ParseTree( pTree->GetNextSibling() );
    }
}

//+---------------------------------------------------------------------------
//
//  Method:     CParseCommandTree::ParseProjection, public
//
//  Synopsis:   Parse a CDbCmdTreeNode project operator
//
//  Arguments:  [pTree]   -- CDbCmdTreeNode node at root of tree to be parsed
//
//  History:    31 May 95   AlanW       Created
//
//----------------------------------------------------------------------------

void CParseCommandTree::ParseProjection( CDbCmdTreeNode * pTree )
{
    CheckRecursionLimit();
    
    CheckOperatorArity( pTree, 2 );

    CDbCmdTreeNode * pChild = pTree->GetFirstChild();

    //
    //  Parse the projection list first, so a projection higher in the
    //  tree takes precedence.  A projection is not permitted in a tree
    //  that also contains a nesting node.
    //
    //  Should a higher level projection take precedence?
    //  We currently return an error.
    //
    if (_categ.Count() == 0 && _cols.Count() == 0)
        ParseProjectList ( pChild->GetNextSibling(), _cols );
    else
        SetError( pTree );

    ParseTree( pChild );
}


//+---------------------------------------------------------------------------
//
//  Method:     CParseCommandTree::ParseProjectList, public
//
//  Synopsis:   Parse a CDbCmdTreeNode project list
//
//  Arguments:  [pTree]   -- CDbCmdTreeNode node for project list head
//              [Cols]    -- CColumnSet in which columns are collected
//
//  History:    31 May 95   AlanW       Created
//
//----------------------------------------------------------------------------

void CParseCommandTree::ParseProjectList( CDbCmdTreeNode *pTree, CColumnSet& Cols )
{
    CheckRecursionLimit();

    if (pTree->GetCommandType() != DBOP_project_list_anchor ||
        pTree->GetFirstChild() == 0)
    {
        SetError( pTree );
    }

    CFullPropSpec Col;

    CDbProjectListElement* pList = (CDbProjectListElement *) pTree->GetFirstChild();
    for ( ;
          pList;
          pList = (CDbProjectListElement *)pList->GetNextSibling())
    {
        if ( pList->GetCommandType() != DBOP_project_list_element ||
             pList->GetFirstChild() == 0 )
        {
            SetError( pList );
        }

        CDbCmdTreeNode * pColumn = pList->GetFirstChild();
        if ( !pColumn->IsColumnName() )
        {
            SetError( pColumn );
        }

        // Add element to projection list
        PROPID pid = GetColumnPropSpec(pColumn, Col);
        Cols.Add( pid, Cols.Count() );

        if ( 0 != pList->GetName() )
            _pidmap.SetFriendlyName( pid, pList->GetName() ); 
    }
}


//+---------------------------------------------------------------------------
//
//  Method:     CParseCommandTree::ParseSort, public
//
//  Synopsis:   Parse a CDbCmdTreeNode sort node
//
//  Arguments:  [pTree]   -- CDbCmdTreeNode node for sort list head
//
//  Notes:      Sort nodes are added to the CSortSet in private data
//
//  History:    31 May 95   AlanW       Created
//
//----------------------------------------------------------------------------

void CParseCommandTree::ParseSort( CDbCmdTreeNode * pTree )
{
    CheckRecursionLimit();
    
    CheckOperatorArity( pTree, 2 );
    CDbCmdTreeNode * pChild = pTree->GetFirstChild();

    //
    //  Parse the sort list first, so a sort higher in the
    //  tree is primary.
    //
    ParseSortList ( pChild->GetNextSibling() );
    ParseTree( pChild );
}

//+---------------------------------------------------------------------------
//
//  Method:     CParseCommandTree::ParseSortList, public
//
//  Synopsis:   Parse a CDbCmdTreeNode sort list
//
//  Arguments:  [pTree]   -- CDbCmdTreeNode node for sort list head
//
//  Notes:      Sort nodes are added to the CSortSet in private data
//
//  History:    31 May 95   AlanW       Created
//
//----------------------------------------------------------------------------

void CParseCommandTree::ParseSortList( CDbCmdTreeNode * pTree )
{
    CheckRecursionLimit();
    
    if (pTree->GetCommandType() != DBOP_sort_list_anchor ||
        pTree->GetFirstChild() == 0)
    {
        SetError( pTree );
    }

    CDbSortListAnchor *pSortAnchor = (CDbSortListAnchor *) pTree;

    unsigned i = 0;
    for (CDbCmdTreeNode * pSortList = pSortAnchor->GetFirstChild();
         pSortList;
         pSortList = pSortList->GetNextSibling(), i++)
    {
        if (pSortList->GetCommandType() != DBOP_sort_list_element)
        {
            SetError( pSortList );
        }
        VerifyValueType( pSortList, DBVALUEKIND_SORTINFO );
        CheckOperatorArity( pSortList, 1 );

        CDbSortListElement* pSLE = (CDbSortListElement *) pSortList;
        CFullPropSpec Col;
        PROPID pid = GetColumnPropSpec(pSLE->GetFirstChild(), Col);

        DWORD dwOrder = pSLE->GetDirection() ? QUERY_SORTDESCEND :
                                               QUERY_SORTASCEND;
        LCID  locale  = pSLE->GetLocale();

        if ( _categ.Count() != 0 && i < _sort.Count() )
        {
        //
        //  Check that the sort specification matches any set as a result of
        //  the categorization (but which may differ in sort direction and
        //  locale).
        //
            SSortKey & sortkey = _sort.Get(i);
            if (sortkey.pidColumn != pid)
            {
                SetError(pSLE);
            }

            if (sortkey.dwOrder != dwOrder)
                sortkey.dwOrder = dwOrder;

            if (sortkey.locale != locale)
                sortkey.locale = locale;
        }
        else
        {
            // Add element to the sort list
            SSortKey sortkey(pid, dwOrder, locale);
            _sort.Add( sortkey, _sort.Count() );
        }
    }
}


//+---------------------------------------------------------------------------
//
//  Method:     CParseCommandTree::ParseRestriction, public
//
//  Synopsis:   Parse a CDbCmdTreeNode select node
//
//  Arguments:  [pTree]   -- CDbCmdTreeNode node for select tree
//
//  History:    31 May 95   AlanW       Created
//
//----------------------------------------------------------------------------

void CParseCommandTree::ParseRestriction( CDbCmdTreeNode *pTree )
{
    CheckRecursionLimit();
    
    //
    // Only one selection can exist in the tree; there must be exactly
    // two operands:  the selection expression and a table identifier.
    // For use with AddPostProcessing, another select should be
    // allowed higher in the tree, with the restrictions anded
    // together.
    //
    if (_prst != 0 )
        SetError( pTree );
    CheckOperatorArity( pTree, 2 );
    VerifyValueType( pTree, DBVALUEKIND_EMPTY );

    CDbCmdTreeNode * pTable = pTree->GetFirstChild();
    CDbCmdTreeNode * pExpr  = pTable->GetNextSibling();

    _prst = ParseExpression( pExpr );

    ParseTree( pTable );
}


//+---------------------------------------------------------------------------
//
//  Method:     CParseCommandTree::ParseCategorization, public
//
//  Synopsis:   Parse a CDbCmdTreeNode nesting node
//
//  Arguments:  [pTree]   -- CDbCmdTreeNode node for nesting tree
//
//  History:    31 Jul 1995   AlanW       Created
//
//  Notes:      Syntax accepted:
//
//                      Categorization :
//                              nesting OrderedQueryTree GroupingList
//                                      ParentList ChildList coldef
//                      GroupingList : ProjectList
//                      ParentList : ProjectList
//                      ChildList : ProjectList
//
//              The GroupingList may be a list of columns on which
//              to do a unique value categorization, or a defined-by-guid
//              function that specifies one of the other categorizations.
//              The ParentList may only specify columns in the GroupingList,
//              columns in upper level groupings, or certain aggregations
//              on those columns.
//              The ChildList forms the projectlist for the base table.
//              The coldef node for the nesting column can give only the
//              special column id for the chapter column.
//
//  Only the unique value categorization is implemented at present.
//
//----------------------------------------------------------------------------

void CParseCommandTree::ParseCategorization( CDbCmdTreeNode *pTree )
{
    CheckRecursionLimit();
    
    CheckOperatorArity( pTree, 5 );
    VerifyValueType( pTree, DBVALUEKIND_EMPTY );

    //
    //  We can't sort or project the output of a categorized table.  We can,
    //  however permit a sort as a side-effect of an existing
    //  nesting node for a unique value categorization.
    //
    if (_categ.Count() == 0 &&
        (_sort.Count() > 0 || _cols.Count() > 0))
         SetError( pTree, E_INVALIDARG );

    Win4Assert(_sort.Count() == _categ.Count());

    CDbCmdTreeNode * pTable = pTree->GetFirstChild();
    CDbCmdTreeNode * pGroupingList  = pTable->GetNextSibling();
    CDbCmdTreeNode * pParentList  = pGroupingList->GetNextSibling();
    CDbCmdTreeNode * pChildList  = pParentList->GetNextSibling();
    CDbCmdTreeNode * pNestingColumn  = pChildList->GetNextSibling();

    CheckOperatorArity( pGroupingList, 1 );   // one grouping col. now
//  CheckOperatorArity( pParentList, -1 );
//  CheckOperatorArity( pChildList, -1 );
    CheckOperatorArity( pNestingColumn, 0 );

    //
    //  For now, the only supported categorization is a unique
    //  value categorization.  For this, the grouping list is
    //  just a projection list that gives the unique columns.
    //

    CColumnSet colGroup;
    ParseProjectList( pGroupingList, colGroup );

    for (unsigned i = 0; i < colGroup.Count(); i++)
    {
        SSortKey sortkey(colGroup.Get(i), QUERY_SORTASCEND);
        _sort.Add( sortkey, _sort.Count() );
    }

    //
    //  For now, the parent list can only mention columns also
    //  in the grouping list (which are now in the sort list).
    //  In addition, the bookmark and chapter columns will be
    //  available in the parent table.
    //  We should also one day allow some aggregations.
    //

    CColumnSet colParent;
    if (pParentList->GetFirstChild() != 0)
    {
        ParseProjectList( pParentList, colParent );
        if (colParent.Count() > _sort.Count() + 2)
        {
            SetError( pParentList, E_INVALIDARG );
        }
    }

    //
    //  Check that the columns are valid
    //
    pParentList = pParentList->GetFirstChild();
    BOOL fChapterFound = FALSE;
    for (i = 0; i < colParent.Count(); i++)
    {
        CFullPropSpec const * pCol = _pidmap.PidToName(colParent.Get(i));

        if (*pCol == colChapter)
        {
            fChapterFound = TRUE;
        }
        else if (*pCol == colBookmark)
        {
            //  Bookmark is permitted in any parent column list
            ;
        }
        else
        {
            BOOL fFound = FALSE;
            for (unsigned j = 0; j < _sort.Count(); j++)
                if ( colParent.Get(i) == _sort.Get(j).pidColumn )
                {
                    fFound = TRUE;
                    break;
                }

            if (!fFound)
                SetError(pParentList, E_INVALIDARG);
        }

        pParentList = pParentList->GetNextSibling();
    }
    if (! fChapterFound)
        colParent.Add( _pidmap.NameToPid(colChapter), colParent.Count());

    //
    //  Columns in the child list replace any existing project list
    //  (which can only have been set by a higher-level nesting node).
    //

    if (_cols.Count())
    {
        vqDebugOut(( DEB_WARN, "CParseCommandTree - "
                     "child list in multi-nested command tree ignored\n" ));
        _cols.Clear();
    }

    if ( 0 != pChildList->GetFirstChild() )
        ParseProjectList( pChildList, _cols );

    XPtr<CCategSpec> pCatParam = new CUniqueCategSpec( );
    XPtr<CCategorizationSpec> pCat =
                    new CCategorizationSpec( pCatParam.GetPointer(),
                                             colParent.Count() );
    pCatParam.Acquire();
    
    for (i = 0; i < colParent.Count(); i++)
    {
        pCat->SetColumn( colParent.Get(i), i );
    }

    _categ.Add( pCat.GetPointer(), _categ.Count() );
    pCat.Acquire();

    //
    //  Now parse the rest of the tree, and check that _cols was set
    //  either here or by a lower level nesting node.
    //
    ParseTree( pTable );
    if ( 0 == _cols.Count() )
    {
        Win4Assert( 0 == pChildList->GetFirstChild() );
        SetError( pChildList );
    }
}


//+---------------------------------------------------------------------------
//
//  Method:     CParseCommandTree::ParseTopNode, public
//
//  Synopsis:   Parse a CDbTopNode operator
//
//  Arguments:  [pTree] -- CDbTopNode node at root of tree to be parsed
//
//  History:    21 Feb 96   AlanW       Created
//
//----------------------------------------------------------------------------

void CParseCommandTree::ParseTopNode( CDbCmdTreeNode *pTree )
{
    CheckRecursionLimit();
    
    CheckOperatorArity( pTree, 1 );

    ULONG cMaxResults = ((CDbTopNode *)pTree)->GetValue();
    if ( cMaxResults == 0 )
    {
        //
        // A query with zero results is uninteresting
        //
        SetError( pTree );
    }

    //
    // If a top node has already been encountered, then set the
    // limit on results to the minimum of the two Top values
    //
    if ( _cMaxResults == 0 )
    {
        _cMaxResults = cMaxResults;
    }
    else
    {
        if ( cMaxResults < _cMaxResults )
            _cMaxResults = cMaxResults;
    }

    CDbCmdTreeNode *pChild = pTree->GetFirstChild();

    ParseTree( pChild );
}


//+---------------------------------------------------------------------------
//
//  Method:     CParseCommandTree::ParseFirstRowsNode, public
//
//  Synopsis:   Parse a CDbFirstRowsNode operator
//
//  Arguments:  [pTree] -- CDbFirstRowsNode node at root of tree to be parsed
//
//  History:    19-Jun-2000     KitmanH       Created
//
//----------------------------------------------------------------------------

void CParseCommandTree::ParseFirstRowsNode( CDbCmdTreeNode *pTree )
{
    CheckRecursionLimit();
    
    CheckOperatorArity( pTree, 1 );

    ULONG cFirstRows = ((CDbFirstRowsNode *)pTree)->GetValue();
    if ( cFirstRows == 0 )
    {
        //
        // A query with zero results is uninteresting
        //
        SetError( pTree );
    }

    //
    // If a top node has already been encountered, then set the
    // limit on results to the minimum of the two Top values
    //
    if ( _cFirstRows == 0 )
    {
        _cFirstRows = cFirstRows;
    }
    else
    {
        if ( cFirstRows < _cFirstRows )
            _cFirstRows = cFirstRows;
    }

    CDbCmdTreeNode *pChild = pTree->GetFirstChild();

    ParseTree( pChild );
}


//+---------------------------------------------------------------------------
//
//  Method:     CParseCommandTree::SetError, private
//
//  Synopsis:   Mark an error in a command tree node.
//
//  Arguments:  [pNode]   -- CDbCmdTreeNode node to check
//              [scError] -- optional error code.
//
//  Returns:    doesn't.  Throws the error set in the node.
//
//  History:    31 May 95   AlanW       Created
//
//----------------------------------------------------------------------------

void CParseCommandTree::SetError(
    CDbCmdTreeNode* pNode,
    SCODE       scError)
{
    vqDebugOut(( DEB_ERROR, "SetError - node %x error %x\n",
                                                      pNode, scError ));
    pNode->SetError( scError );
    if ( ! SUCCEEDED( _scError ))
    {
        _scError = scError;
        _pErrorNode = pNode;
    }

    THROW( CException( DB_E_ERRORSINCOMMAND ));
}


//+---------------------------------------------------------------------------
//
//  Method:     CParseCommandTree::CheckOperatorArity, private
//
//  Synopsis:   Verify that a tree node has the correct number of
//              operands.
//
//  Arguments:  [pNode]   -- CDbCmdTreeNode node to check
//              [cOperands] -- number of operands expected.  If
//                              cOperands is negative, at least -cOperands
//                              must be present.  Otherwise, exactly cOperands
//                              must be present.
//
//  Returns:    unsigned - the number of operands found
//
//  History:    31 May 95   AlanW       Created
//
//----------------------------------------------------------------------------

unsigned CParseCommandTree::CheckOperatorArity(
    CDbCmdTreeNode* pNode,
    int cOperands)
{
    int cOps = 0;

    for (CDbCmdTreeNode* pChild = pNode->GetFirstChild();
         pChild;
         pChild = pChild->GetNextSibling(), cOps++)
    {
        if (cOperands >= 0 && cOps > cOperands)
            pChild->SetError( E_UNEXPECTED );
    }

    if (cOperands < 0)
    {
        //
        //  -(cOperands) or more operands are permitted
        //

        if (cOps < -(cOperands))
            SetError(pNode, E_INVALIDARG);
    }
    else
    {
        if (cOps != cOperands)
            SetError(pNode, E_INVALIDARG);
    }
    return (unsigned) cOps;
}

//+---------------------------------------------------------------------------
//
//  Method:     CParseCommandTree::GetColumnPropSpec, private
//
//  Synopsis:   Return a column identifier from a tree node argument
//
//  Arguments:  [pNode]   -- CDbCmdTreeNode node to check
//              [eKind]   -- expected value kind
//
//  Returns:    PROPID from the pidmapper
//
//  History:    12 Jun 95   AlanW       Created
//
//----------------------------------------------------------------------------

PROPID CParseCommandTree::GetColumnPropSpec(
    CDbCmdTreeNode* pNode,
    CFullPropSpec& Col)
{
    if (pNode->GetValueType() != DBVALUEKIND_ID)
        SetError(pNode, E_INVALIDARG);

    CDbColumnNode * pColumnNode = (CDbColumnNode *)pNode;

    if (pColumnNode->IsPropertyPropid())
    {
        // pids 0 and 1 are reserved

        if ( ( PID_CODEPAGE == pColumnNode->GetPropertyPropid() ) ||
             ( PID_DICTIONARY == pColumnNode->GetPropertyPropid() ) )
            SetError(pNode, E_INVALIDARG);

        Col.SetProperty( pColumnNode->GetPropertyPropid() );
    }
    else /* (pColumnNode->IsPropertyName()) */
    {
        Col.SetProperty( pColumnNode->GetPropertyName() );
    }
    Col.SetPropSet( pColumnNode->GetPropSet() );

    return _pidmap.NameToPid( Col );
}

//+---------------------------------------------------------------------------
//
//  Method:     CParseCommandTree::GetValue, private
//
//  Synopsis:   Return a scalar constant from a tree node argument
//
//  Arguments:  [pNode]   -- CDbCmdTreeNode node to check
//
//  Returns:    CStorageVariant& - reference to value of variant in node
//
//  History:    12 Jun 95   AlanW       Created
//
//----------------------------------------------------------------------------

BOOL CParseCommandTree::GetValue (
   CDbCmdTreeNode* pNode,
   CStorageVariant & val )
{
    ((CDbScalarValue *)pNode)->Value( val );
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\icommand\parsexpr.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1995 - 2000.
//
//  File:       Parsexpr.cxx
//
//  Contents:   Converts OLE-DB boolean expression into a restriction
//
//  Functions:  CParseCommandTree::ParseExpression
//
//  History:    31 May 95    AlanW    Created from parse.cxx
//
//--------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include <coldesc.hxx>
#include <pidmap.hxx>
#include <parstree.hxx>

//+---------------------------------------------------------------------------
//
//  Method:     CParseCommandTree::ParseExpression, private
//
//  Synopsis:   Convert an OLE-DB boolean expression into a CRestriction
//
//  Arguments:  [pdbt]   -- CDbCmdTreeNode to convert
//
//  Returns:    A pointer to the CRestriction which will resolve [pdbt]
//
//  History:    31 May 95   AlanW       Created
//
//  Notes:
//
//----------------------------------------------------------------------------

CRestriction * CParseCommandTree::ParseExpression( CDbCmdTreeNode * pdbt )
{
    CheckRecursionLimit();
    
    XRestriction prst;

    CNodeRestriction * pnrst;
    unsigned cres;

    //
    // The weight is retrieved from pdbt and set into prst at the end
    // of the switch statement.
    //

    switch ( pdbt->GetCommandType() )
    {
    case DBOP_not:
    {
        VerifyValueType(pdbt, DBVALUEKIND_I4);
        CheckOperatorArity(pdbt, 1);

        XRestriction pTemp( ParseExpression( pdbt->GetFirstChild() ) );

        prst.Set( new CNotRestriction( pTemp.GetPointer() ) );
        vqDebugOut((DEB_PARSE, "NOT node with weight of %d\n", ((CDbNotRestriction *)pdbt)->GetWeight()));

        pTemp.Acquire();

        break;
    }

    case DBOP_and:
    case DBOP_or:
    {
        VerifyValueType(pdbt, DBVALUEKIND_I4);
        cres = CheckOperatorArity(pdbt, -2);

        DWORD nt = (pdbt->GetCommandType() == DBOP_and) ?
                        RTAnd : RTOr;

        pnrst = new CNodeRestriction( nt, cres );

        prst.Set( pnrst );
        vqDebugOut(( DEB_PARSE,
                     "ParseExpression: %s node, %d restrictions, %d weight\n",
                     (nt == RTAnd) ? "AND" : "OR", cres, ((CDbBooleanNodeRestriction *)pdbt)->GetWeight() ));

        for ( CDbCmdTreeNode *pChild = pdbt->GetFirstChild();
              cres;
              cres--, pChild = pChild->GetNextSibling() )
        {
            XRestriction pTemp( ParseExpression( pChild ) );

            pnrst->AddChild( pTemp.GetPointer() );
            pTemp.Acquire();
        }
        break;
    }

    case DBOP_content_vector_or:
    {
        // NOTE:  We permit vector-or nodes with only one operand simply
        //        for client convenience.
        //
        cres = CheckOperatorArity(pdbt, -1);

        VerifyValueType(pdbt, DBVALUEKIND_CONTENTVECTOR);

        CDbVectorRestriction * pdbVector = (CDbVectorRestriction *) pdbt;

        ULONG RankMethod = pdbVector->RankMethod();

        if ( RankMethod > VECTOR_RANK_JACCARD )
            SetError( pdbt, E_INVALIDARG );

        pnrst = new CVectorRestriction( RankMethod, cres );

        prst.Set( pnrst );
        vqDebugOut(( DEB_PARSE,
                     "ParseExpression: VECTOR node, %d restrictions, "
                     "RankMethod %lu, Weight %d\n", cres, RankMethod, ((CDbVectorRestriction *)pdbt)->GetWeight() ));

        //
        // Ordering is important in the vector and must be preserved.
        //

        unsigned iWeight = 0;
        for ( CDbCmdTreeNode *pChild = pdbt->GetFirstChild();
              cres;
              cres--, pChild = pChild->GetNextSibling(), iWeight++ )
        {
            XRestriction pTemp( ParseExpression( pChild ) );

            //
            // We should be able to get weights for all the nodes.
            //

            pTemp->SetWeight( pChild->GetWeight() );

            pnrst->AddChild( pTemp.GetPointer() );
            pTemp.Acquire();
        }

        break;
    }

    case DBOP_equal:
    case DBOP_not_equal:
    case DBOP_less:
    case DBOP_less_equal:
    case DBOP_greater:
    case DBOP_greater_equal:

    case DBOP_equal_any:
    case DBOP_not_equal_any:
    case DBOP_less_any:
    case DBOP_less_equal_any:
    case DBOP_greater_any:
    case DBOP_greater_equal_any:

    case DBOP_equal_all:
    case DBOP_not_equal_all:
    case DBOP_less_all:
    case DBOP_less_equal_all:
    case DBOP_greater_all:
    case DBOP_greater_equal_all:

    case DBOP_anybits:
    case DBOP_allbits:
    case DBOP_anybits_any:
    case DBOP_allbits_any:
    case DBOP_anybits_all:
    case DBOP_allbits_all:
    {
        CheckOperatorArity(pdbt, 2);   // exactly two operands
        VerifyValueType( pdbt, DBVALUEKIND_I4 );

        CDbCmdTreeNode * pProp = pdbt->GetFirstChild();
        CDbCmdTreeNode * pValue = pProp->GetNextSibling();

        if ( ! pProp->IsColumnName() )
            SetError( pProp );

        CFullPropSpec Prop;
        GetColumnPropSpec( pProp, Prop );

        XPtr<CStorageVariant>   xValue( new CStorageVariant );
        if ( 0 == xValue.GetPointer() )
        {
            THROW( CException(E_OUTOFMEMORY) );
        }

        GetValue( pValue, xValue.GetReference() );

        //
        // compute relation from query tree operator
        //
        int Relation = 0;
        int fAnyOrAll = 0;
        switch (pdbt->GetCommandType())
        {
        case DBOP_equal_any:
            fAnyOrAll |= PRAny;
        case DBOP_equal_all:
            fAnyOrAll |= PRAll;
        case DBOP_equal:
            Relation = PREQ;    break;

        case DBOP_not_equal_any:
            fAnyOrAll |= PRAny;
        case DBOP_not_equal_all:
            fAnyOrAll |= PRAll;
        case DBOP_not_equal:
            Relation = PRNE;    break;

        case DBOP_less_any:
            fAnyOrAll |= PRAny;
        case DBOP_less_all:
            fAnyOrAll |= PRAll;
        case DBOP_less:
            Relation = PRLT;    break;

        case DBOP_less_equal_any:
            fAnyOrAll |= PRAny;
        case DBOP_less_equal_all:
            fAnyOrAll |= PRAll;
        case DBOP_less_equal:
            Relation = PRLE;    break;

        case DBOP_greater_any:
            fAnyOrAll |= PRAny;
        case DBOP_greater_all:
            fAnyOrAll |= PRAll;
        case DBOP_greater:
            Relation = PRGT;    break;

        case DBOP_greater_equal_any:
            fAnyOrAll |= PRAny;
        case DBOP_greater_equal_all:
            fAnyOrAll |= PRAll;
        case DBOP_greater_equal:
            Relation = PRGE;    break;

        case DBOP_anybits_any:
            fAnyOrAll |= PRAny;
        case DBOP_anybits_all:
            fAnyOrAll |= PRAll;
        case DBOP_anybits:
            Relation = PRSomeBits;      break;

        case DBOP_allbits_any:
            fAnyOrAll |= PRAny;
        case DBOP_allbits_all:
            fAnyOrAll |= PRAll;
        case DBOP_allbits:
            Relation = PRAllBits;       break;
        }

        if (fAnyOrAll & PRAny)
            Relation |= PRAny;
        else if (fAnyOrAll & PRAll)
            Relation |= PRAll;

        prst.Set( new CPropertyRestriction( Relation, Prop, xValue.GetReference() ) );
        vqDebugOut((DEB_PARSE, "Relational Property node with weight %d\n", ((CDbPropertyRestriction *)pdbt)->GetWeight() ));
        break;
    }

    case DBOP_like:
    {
        CheckOperatorArity(pdbt, 2);   // exactly two operands
        VerifyValueType(pdbt, DBVALUEKIND_LIKE);
        CDbPropertyRestriction * pInputRst = (CDbPropertyRestriction *)pdbt;
        if ( ! pInputRst->IsCIDialect() )
            SetError( pdbt );

        CDbCmdTreeNode * pProp = pdbt->GetFirstChild();
        CDbCmdTreeNode * pValue = pProp->GetNextSibling();

        if ( ! pProp->IsColumnName() )
            SetError( pProp );

        CFullPropSpec Prop;
        GetColumnPropSpec( pProp, Prop );

        XPtr<CStorageVariant>  xValue(new CStorageVariant);
        if ( 0 == xValue.GetPointer() )
        {
            THROW( CException(E_OUTOFMEMORY) );
        }

        GetValue( pValue, xValue.GetReference() );

        prst.Set( new CPropertyRestriction( PRRE, Prop, xValue.GetReference() ) );
        vqDebugOut((DEB_PARSE, "Reg Expr node with weight of %d\n", ((CDbPropertyRestriction *)pdbt)->GetWeight() ));
        break;
    }

    case DBOP_content:
    case DBOP_content_freetext:
    case DBOP_content_proximity:
        prst.Set( ParseContentExpression( pdbt ) );
        break;

    default:
        vqDebugOut(( DEB_ERROR, "Unhandled expression type %d\n",
                                pdbt->GetCommandType() ));
        Win4Assert( !"Unhandled expression type" );
        SetError( pdbt, E_INVALIDARG );
        break;
    }

    prst->SetWeight(pdbt->GetWeight());

    return( prst.Acquire() );
}


//+---------------------------------------------------------------------------
//
//  Method:     CParseCommandTree::ParseContentExpression, private
//
//  Synopsis:   Convert an OLE-DB boolean expression with content restrictions
//              into a CRestriction.  Like ParseExpression, but each node
//              must be content.
//
//
//  Arguments:  [pdbt]   -- CDbCmdTreeNode to convert
//
//  Returns:    A pointer to the CRestriction which will resolve [pdbt]
//
//  History:    31 May 95   AlanW       Created
//
//----------------------------------------------------------------------------

CRestriction * CParseCommandTree::ParseContentExpression(
    CDbCmdTreeNode * pdbt )
{
    CheckRecursionLimit();
    
    XRestriction prst;

    CNodeRestriction * pnrst;
    unsigned cres;

    switch ( pdbt->GetCommandType() )
    {
    case DBOP_content_proximity:
    {
        VerifyValueType(pdbt, DBVALUEKIND_CONTENTPROXIMITY);
        cres = CheckOperatorArity(pdbt, -2);

        pnrst = new CNodeRestriction( RTProximity, cres );

        prst.Set( pnrst );
        vqDebugOut(( DEB_PARSE,
                     "ParseContentExpression: Proximity node, %d restrictions, weight %d\n",
                     cres, ((CDbProximityNodeRestriction *)pdbt)->GetWeight() ));

        for ( CDbCmdTreeNode *pChild = pdbt->GetFirstChild();
              cres;
              cres--, pChild = pChild->GetNextSibling() )
        {
            XRestriction pTemp( ParseExpression( pChild ) );

            pnrst->AddChild( pTemp.GetPointer() );
            pTemp.Acquire();
        }
        break;
    }

    case DBOP_content:
    {
        VerifyValueType(pdbt, DBVALUEKIND_CONTENT);
        cres = CheckOperatorArity(pdbt, 1); 

        CDbContentRestriction *pInputRst = (CDbContentRestriction *)pdbt;

        CFullPropSpec Prop;
        GetColumnPropSpec( pdbt->GetFirstChild(), Prop );

        XRestriction pCRst ( new CContentRestriction (
                                                        pInputRst->GetPhrase(),
                                                        Prop,
                                                        pInputRst->GenerateMethod(),
                                                        pInputRst->GetLocale()
                                                     ) );

        prst.Set( pCRst.Acquire() );

        vqDebugOut((DEB_PARSE, "Content node with weight %d\n", pInputRst->GetWeight() ));
        break;
    }

    case DBOP_content_freetext:
    {
        VerifyValueType(pdbt, DBVALUEKIND_CONTENT);
        cres = CheckOperatorArity(pdbt, 1);

        CDbNatLangRestriction *pInputRst = (CDbNatLangRestriction *)pdbt;

        CFullPropSpec Prop;
        GetColumnPropSpec( pdbt->GetFirstChild(), Prop );

        XRestriction pCRst ( new CNatLanguageRestriction (
                                                        pInputRst->GetPhrase(),
                                                        Prop,
                                                        pInputRst->GetLocale()
                                                     ) );
        prst.Set( pCRst.Acquire() );

        vqDebugOut((DEB_PARSE, "Freetext node with weight %d\n", pInputRst->GetWeight() ));
        break;
    }

    default:
        vqDebugOut(( DEB_ERROR, "Unhandled expression type %d\n", pdbt->GetCommandType() ));
        Win4Assert( !"Unhandled expression type" );
        SetError( pdbt, E_INVALIDARG );
        break;
    }

    prst->SetWeight(pdbt->GetWeight());

    return( prst.Acquire() );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\icommand\propbase.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1999.
//
//  File:       propbase.cxx
//
//  Contents:   Utility object containing implementation of base property
//
//  Classes:    CUtlProps
//
//  History:    10-28-97        danleg    Created from monarch uprops.cpp
//
//----------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include "propbase.hxx"



//+---------------------------------------------------------------------------
//
//  Method:     CUtlProps::CUtlProps, public
//
//  Synopsis:   Constructor for CUtlProps
//
//  History:    11-12-97    danleg      Created from Monarch
//
//----------------------------------------------------------------------------

CUtlProps::CUtlProps( DWORD dwFlags ) :
    _cPropSetDex(0),
    _cUPropSet(0),
    _cUPropSetHidden(0),
    _pUPropSet(0),
    _dwFlags(dwFlags),
    _xaUProp(),
    _cElemPerSupported(0),
    _xadwSupported(),
    _xadwPropsInError(),
    _xaiPropSetDex()
{
}

//+---------------------------------------------------------------------------
//
//  Method:     CUtlProps::~CUtlProps, public
//
//  Synopsis:   Destructor for CUtlProps
//
//  History:    11-12-97    danleg      Created from Monarch
//
//----------------------------------------------------------------------------

CUtlProps::~CUtlProps()
{
    FreeMemory();
}

//+---------------------------------------------------------------------------
//
//  Method:     CUtlProps::FillDefaultValues, public
//
//  Synopsis:   Fill all the default values.  Note that failure might leave
//              things only half done.  
//
//  Arguments:  [ulPropSetTarget]   - Propset to fill if only one
//
//  History:    11-12-97    danleg      Created from Monarch
//
//----------------------------------------------------------------------------

SCODE CUtlProps::FillDefaultValues( ULONG ulPropSetTarget )
{
    SCODE sc = S_OK;
    ULONG ulPropId;
    ULONG iNewDex;

    // Fill in all the actual values.
    // Note that the UPROP (with values) array may be a subset of the UPROPINFO array.
    // Only writable properties are in UPROP array.

    // Maybe restrict to a single PropSet if within valid range [0..._cUPropSet-1].
    // Otherwise do all propsets.
    ULONG iPropSet = (ulPropSetTarget < _cUPropSet) ? ulPropSetTarget : 0;

    for( ; iPropSet<_cUPropSet; iPropSet++)
    {
        iNewDex = 0;
        for(ulPropId=0; ulPropId<_pUPropSet[iPropSet].cUPropInfo; ulPropId++)
        {
            if ( _pUPropSet[iPropSet].pUPropInfo[ulPropId].dwFlags & 
                (DBPROPFLAGS_WRITE | DBPROPFLAGS_CHANGE) )
            {
                // Initialize dwFlags element of UPropVal
                _xaUProp[iPropSet].pUPropVal[iNewDex].dwFlags = 0;

                VariantClear( &_xaUProp[iPropSet].pUPropVal[iNewDex].vValue );
                sc = GetDefaultValue(
                        iPropSet, 
                        _pUPropSet[iPropSet].pUPropInfo[ulPropId].dwPropId, 
                        &_xaUProp[iPropSet].pUPropVal[iNewDex].dwOption, 
                        &_xaUProp[iPropSet].pUPropVal[iNewDex].vValue );
                if ( FAILED(sc) )
                    return sc;
                iNewDex++;
            }
        }

        // We're through if restricting to single PropSet.
        if ( ulPropSetTarget < _cUPropSet )
            break;
    }
    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Method:     CUtlProps::GetPropertiesArgChk, public
//
//  Synopsis:   Initialize the buffers and check for E_INVALIDARG cases.
//              This routine is used by RowsetInfo, CommandProperties and 
//              IDBProperties
//
//  Arguments:  [cPropertySets]     - number of property sets
//              [rgPropertySets]    - property classes and ids
//              [pcProperties]      - count of structs returned [out]
//              [prgProperties]     - array of properties [out]
//
//  History:    11-12-97    danleg      Created from Monarch
//
//----------------------------------------------------------------------------

void CUtlProps::GetPropertiesArgChk
    (
    const ULONG         cPropertySets,      
    const DBPROPIDSET   rgPropertySets[],   
    ULONG*              pcProperties,       
    DBPROPSET**         prgProperties       
    )
{
    ULONG ul;

    // Initialize values
    if ( pcProperties )
        *pcProperties = 0;
    if ( prgProperties )
        *prgProperties = 0; 

    // Check Arguments
    if ( ((cPropertySets > 0) && !rgPropertySets) ||
        !pcProperties || !prgProperties )
        THROW( CException(E_INVALIDARG) );

    // New argument check for > 1 cPropertyIDs and NULL pointer for 
    // array of property ids.
    for(ul=0; ul<cPropertySets; ul++)
    {
        if ( rgPropertySets[ul].cPropertyIDs && 
            !(rgPropertySets[ul].rgPropertyIDs) )
            THROW( CException(E_INVALIDARG) );
    
        // Check for propper formation of DBPROPSET_PROPERTIESINERROR
        if ( (_dwFlags & ARGCHK_PROPERTIESINERROR) && 
            rgPropertySets[ul].guidPropertySet == DBPROPSET_PROPERTIESINERROR )
        {
            if ( (cPropertySets > 1) ||
                (rgPropertySets[ul].cPropertyIDs != 0) ||
                (rgPropertySets[ul].rgPropertyIDs != 0) )
                THROW( CException(E_INVALIDARG) );
        }
    }
}

//+---------------------------------------------------------------------------
//
//  Method:     CUtlProps::SetPropertiesArgChk, public
//
//  Synopsis:   Initialize the buffers and check for E_INVALIDARG cases
//              NOTE: This routine is used by CommandProperties and 
//                    IDBProperties
//
//  Arguments:  [cPropertySets]     - count of structs returned
//              [rgPropertySets]    - array of propertysets
//
//  History:    11-12-97    danleg      Created from Monarch
//
//----------------------------------------------------------------------------

void CUtlProps::SetPropertiesArgChk
    (
    const ULONG     cPropertySets,      
    const DBPROPSET rgPropertySets[]    
    )
{
    ULONG   ul;

    // Argument Checking
    if ( cPropertySets > 0 && !rgPropertySets )
        THROW( CException(E_INVALIDARG) );

    // New argument check for > 1 cPropertyIDs and NULL pointer for 
    // array of property ids.
    for(ul=0; ul<cPropertySets; ul++)
    {
        if ( rgPropertySets[ul].cProperties &&
             !(rgPropertySets[ul].rgProperties) )
            THROW( CException(E_INVALIDARG) );
    }
}

//+---------------------------------------------------------------------------
//
//  Method:     CUtlProps::GetProperties, public
//
//  Synopsis:   Collect the property information that the consumer is 
//              interested in.  If no restriction guids are supplied, 
//              return all known properties.
//
//              NOTE: If cProperties is 0, this function will return an array
//              of guids that had been previously set.  IF cProperties is non 0,
//              the routine will use the array of property guids passed in and
//              return informatino about the properties asked for only.
//
//              This routine is used by RowsetInfo and CommandProperties.
//
//  Arguments:  [cPropertySets]     - number of property setes
//              [rgPropertySets]    - property classes and ids
//              [pcProperties]      - count of structs returned [out]
//              [prgProperties]     - array of properties [out]
//
//  History:    11-12-97    danleg      Created from Monarch
//
//----------------------------------------------------------------------------

SCODE CUtlProps::GetProperties(
    const ULONG       cPropertySets,      
    const DBPROPIDSET rgPropertySets[],   
    ULONG*            pcProperties,       
    DBPROPSET**       prgProperties )
{
    UPROPVAL*  pUPropVal;
    ULONG      ulCurProp;
    ULONG      cTmpPropertySets = cPropertySets;
    SCODE      sc = S_OK;
    ULONG      ulSet = 0;
    ULONG      ulNext = 0;
    ULONG      cSets = 0;
    ULONG      cProps = 0;
    ULONG      ulProp = 0;
    DWORD      dwStatus = 0;
    DBPROP*    pProp = 0;
    UPROPINFO* pUPropInfo = 0;
    ULONG      ulCurSet;
    ULONG      iPropSet;

    // We need to have special handling for DBPROPSET_PROPERTIESINERROR.
    // Turn on a flags to indicate this mode and make cTmpPropertySets
    // appear to be 0.

    if ( (_dwFlags & ARGCHK_PROPERTIESINERROR) &&
         rgPropertySets && 
         (rgPropertySets[0].guidPropertySet == DBPROPSET_PROPERTIESINERROR) )
    {
        cTmpPropertySets = 0;
        dwStatus |= GETPROP_PROPSINERROR;
    }

    // If the consumer does not restrict the property sets by specify an
    // array of property sets and a cTmpPropertySets greater than 0, then we
    // need to make sure we have some to return

    if ( 0 == cTmpPropertySets )
    {
        // Determine the number of property sets supported

        cSets = _cUPropSet;
    }
    else
    {
        // Since special property set guids are not supported by
        // GetProperties, we can just use the count of property sets given to
        // us.

        cSets = cTmpPropertySets;
    }

    // If no properties set, then return

    if ( 0 == cSets )
        return S_OK;
                    
    // Allocate the DBPROPSET structures

    DBPROPSET * pPropSet = (DBPROPSET *) CoTaskMemAlloc( cSets * sizeof DBPROPSET );
    if ( 0 != pPropSet )
    {
        RtlZeroMemory( pPropSet, cSets * sizeof(DBPROPSET) );

        // Fill in the output array
        iPropSet = 0;
        for(ulSet=0; ulSet<cSets; ulSet++)
        {
            // Depending of if Property sets are specified store the
            // return property set.
            if ( cTmpPropertySets == 0 )
            {
                if ( _pUPropSet[ulSet].dwFlags & UPROPSET_HIDDEN )
                    continue;
                
                pPropSet[iPropSet].guidPropertySet = *(_pUPropSet[ulSet].pPropSet);
            }
            else
                pPropSet[iPropSet].guidPropertySet = rgPropertySets[ulSet].guidPropertySet;         

            iPropSet++;
        }
    }
    else
    {
        vqDebugOut(( DEB_ERROR, "Could not allocate DBPROPSET array for GetProperties\n" ));
        return E_OUTOFMEMORY;
    }

    TRY
    {
        // Process requested or derived Property sets
    
        iPropSet=0;
        for( ulSet = 0; ulSet < cSets; ulSet++ )
        {
            XCoMem<DBPROP> xProp;
            cProps  = 0;
            pProp   = 0;
            ulNext  = 0;
            dwStatus &= (GETPROP_ERRORSOCCURRED | GETPROP_VALIDPROP | GETPROP_PROPSINERROR);
    
            // Calculate the number of property nodes needed for this
            // property set.
    
            if ( 0 == cTmpPropertySets )
            {
                // If processing requesting all property sets, do not
                // return the hidden sets.
    
                if ( _pUPropSet[ulSet].dwFlags & UPROPSET_HIDDEN )
                    continue;
    
                cProps = _pUPropSet[ulSet].cUPropInfo;
    
                dwStatus |= GETPROP_ALLPROPIDS;
                ulCurSet = ulSet;
            }
            else
            {
                Win4Assert( ulSet == iPropSet );
    
                // If the count of PROPIDs is 0 or it is a special property set,
                // then the consumer is requesting all propids for this property
                // set.
    
                if ( 0 == rgPropertySets[ulSet].cPropertyIDs )
                {
                    dwStatus |= GETPROP_ALLPROPIDS;
    
                    // We have to determine if the property set is supported and
                    // if so the count of properties in the set.
    
                    if ( S_OK == GetIndexofPropSet( &(pPropSet[iPropSet].guidPropertySet),
                                                    &ulCurSet ) )
                    {
                        cProps += _pUPropSet[ulCurSet].cUPropInfo;
                    }
                    else
                    {
                        // Not Supported
    
                        dwStatus |= GETPROP_ERRORSOCCURRED;
                        goto NEXT_SET;
                    }
                }
                else
                {
                    cProps = rgPropertySets[ulSet].cPropertyIDs;
    //@TODO determine extra nodes needed for colids based on restriction array, it is
    //possible that the same restriction is used twice, thus using our other calculation method
    //would cause an overflow.
                    if (GetIndexofPropSet(&(pPropSet[iPropSet].guidPropertySet), &ulCurSet) != S_OK)
                    {
                        dwStatus |= GETPROP_NOTSUPPORTED;
                        dwStatus |= GETPROP_ERRORSOCCURRED;
                    }
                }
            }
    
            // Allocate DBPROP array
    
            if ( 0 == cProps )          //Possible with Hidden Passthrough sets
                goto NEXT_SET;
    
            pProp = (DBPROP *) CoTaskMemAlloc( cProps * sizeof(DBPROP) );
            xProp.Set( pProp );
    
            if ( 0 != pProp )
            {
                // Now that we have determined we can support the property set,
                // we need to gather current property values
    
                for( ulProp=0; ulProp < cProps; ulProp++ )
                {
                    // initialize the structure.  Memberwise initialization is
                    // faster than old memset code -- MDW
    
                    pProp[ulProp].dwPropertyID = 0;
                    pProp[ulProp].dwOptions = 0;
                    pProp[ulProp].dwStatus = 0;
                    RtlZeroMemory( &(pProp[ulProp].colid), sizeof DBID );
                    VariantInit( &(pProp[ulProp].vValue) );
    
                    if ( 0 != ( dwStatus & GETPROP_NOTSUPPORTED ) )
                    {
                        // Not supported, so we need to mark all as NOT_SUPPORTED
    
                        pProp[ulProp].dwPropertyID = rgPropertySets[ulSet].rgPropertyIDs[ulProp];
                        pProp[ulProp].dwStatus     = DBPROPSTATUS_NOTSUPPORTED;
                        continue;
                    }                   
    
                    DBPROP * pCurProp = &(pProp[ulNext]);
    
                    // Initialize Variant Value
    
                    pCurProp->dwStatus = DBPROPSTATUS_OK;
    
                    // Retrieve current value of properties
    
                    if ( 0 != ( dwStatus & GETPROP_ALLPROPIDS ) )
                    {
                        // Verify property is supported, if not do not return
    
                        if ( !TESTBIT(&(_xadwSupported[ulCurSet * _cElemPerSupported]), ulProp) )
                            continue;
    
                        // If we are looking for properties in error, then we
                        // should ignore all that are not in error.
    
                        if ( ( 0 != (dwStatus & GETPROP_PROPSINERROR) ) &&
                            !TESTBIT(&(_xadwPropsInError[ulCurSet * _cElemPerSupported]), ulProp) )
                            continue;
    
                        pUPropInfo = (UPROPINFO*)&(_pUPropSet[ulCurSet].pUPropInfo[ulProp]);
    
                        Win4Assert( pUPropInfo );
    
                        pCurProp->dwPropertyID = pUPropInfo->dwPropId;
                        pCurProp->colid = DB_NULLID;
    
                        // If the property is WRITEABLE or CHANGABLE and not
                        // inerror, then the value will be gotten from the
                        // UPROPVAL array, else it will be derive from the
                        // GetDefaultValue
    
                        if ( 0 != ( pUPropInfo->dwFlags &
                                    ( DBPROPFLAGS_WRITE | DBPROPFLAGS_CHANGE ) ) )
                        {
                            pUPropVal = &(_xaUProp[ulCurSet].
                                        pUPropVal[GetUPropValIndex( ulCurSet,
                                                                    pCurProp->dwPropertyID )]);
                            Win4Assert( 0 != pUPropVal );
    
                            if ( 0 != ( pUPropVal->dwFlags & DBINTERNFLAGS_INERROR ) )
                            {
                                sc = GetDefaultValue( ulCurSet,
                                                      pUPropInfo->dwPropId, 
                                                      &(pCurProp->dwOptions),
                                                      &(pCurProp->vValue) );
    
                                if ( FAILED( sc ) )
                                {
                                    pCurProp->vValue.vt = VT_EMPTY;
                                    THROW( CException( sc ) );
                                }
                            }
                            else
                            {
                                pCurProp->dwOptions = pUPropVal->dwOption;
                                sc = VariantCopy( &(pCurProp->vValue),
                                                  &(pUPropVal->vValue) );
    
                                if ( FAILED( sc ) )
                                {
                                    pCurProp->vValue.vt = VT_EMPTY;
                                    THROW( CException( sc ) );
                                }
                            }
                        }
                        else
                        {
                            sc = GetDefaultValue( ulCurSet,
                                                  pUPropInfo->dwPropId, 
                                                  &(pCurProp->dwOptions),
                                                  &(pCurProp->vValue) );
                            if ( FAILED( sc ) )
                            {
                                pCurProp->vValue.vt = VT_EMPTY;
                                THROW( CException( sc ) );
                            }
                        }
        
                        // Return all Properties in Error with CONFLICT status
    
                        if ( 0 != ( dwStatus & GETPROP_PROPSINERROR ) )
                            pCurProp->dwStatus = DBPROPSTATUS_CONFLICTING;
                        
                        dwStatus |= GETPROP_VALIDPROP;
                    }
                    else
                    {
                        // Process Properties based on Restriction array.
    
                        pCurProp->dwPropertyID = rgPropertySets[ulSet].rgPropertyIDs[ulProp];
                        pCurProp->colid = DB_NULLID;
    
                        if ( S_OK == GetIndexofPropIdinPropSet( ulCurSet,
                                                                pCurProp->dwPropertyID, 
                                                                &ulCurProp ) )
                        {
                            // Supported
    
                            pUPropInfo = (UPROPINFO*)&(_pUPropSet[ulCurSet].pUPropInfo[ulCurProp]);
                            Win4Assert( 0 != pUPropInfo );
    
                            // If the property is WRITEABLE, then the value will
                            // be gotten from the UPROPVAL array, else it will be
                            // derive from the GetDefaultValue
    
                            if ( 0 != ( pUPropInfo->dwFlags &
                                        (DBPROPFLAGS_WRITE | DBPROPFLAGS_CHANGE) ) )
                            {
                                pUPropVal = &(_xaUProp[ulCurSet].
                                    pUPropVal[GetUPropValIndex(ulCurSet, pCurProp->dwPropertyID)]);
                                Win4Assert( 0 != pUPropVal );
                            
                                pCurProp->dwOptions = pUPropVal->dwOption;
                                sc = VariantCopy(&(pCurProp->vValue), &(pUPropVal->vValue));
                            }
                            else
                            {
                                sc = GetDefaultValue( ulCurSet,
                                                      pUPropInfo->dwPropId, 
                                                      &(pCurProp->dwOptions),
                                                      &(pCurProp->vValue) );
    
                            }
    
                            if ( FAILED( sc ) )
                            {
                                pCurProp->vValue.vt = VT_EMPTY;
                                THROW( CException( sc ) );
                            }
    
                            dwStatus |= GETPROP_VALIDPROP;
                        }
                        else
                        {
                            // Not Supported
    
                            pCurProp->dwStatus = DBPROPSTATUS_NOTSUPPORTED;
                            dwStatus |= GETPROP_ERRORSOCCURRED;
                        }
                    }
    
                    // Increment return nodes count
    
                    ulNext++;
                }
    
                // Make sure we support the property set
    
                if ( 0 != ( dwStatus & GETPROP_NOTSUPPORTED ) )
                {
                    ulNext = cProps;
                    goto NEXT_SET;
                }
            }
            else
            {
                THROW( CException( E_OUTOFMEMORY ) );
            }
    
NEXT_SET:
            // It is possible that all properties are not supported,
            // thus we should delete that memory and set rgProperties
            // to NULL
    
            if ( 0 == ulNext && 0 != pProp )
            {
                CoTaskMemFree( pProp );
                pProp = 0;
            }
    
            xProp.Acquire();
    
            pPropSet[iPropSet].cProperties = ulNext;
            pPropSet[iPropSet].rgProperties = pProp;
            iPropSet++;
            Win4Assert( iPropSet <= cSets );
        }
    
        Win4Assert( iPropSet <= cSets );
    
        *pcProperties = iPropSet;
        *prgProperties = pPropSet;
        
        // At least one propid was marked as not S_OK
    
        if ( dwStatus & GETPROP_ERRORSOCCURRED )
        {
            // If at least 1 property was set
            if ( dwStatus & GETPROP_VALIDPROP )
                return DB_S_ERRORSOCCURRED;
            else
            {
                // Do not free any of the memory on a DB_E_
                return DB_E_ERRORSOCCURRED;
            }
        }
    
        sc = S_OK;
    }
    CATCH( CException, e )
    {
        // Since we have no properties to return we need to free allocated memory
    
        if ( 0 != pPropSet )
        {
            // Free any DBPROP arrays
    
            for( ulSet = 0; ulSet < cSets; ulSet++ )
            {
                // Need to loop through all the VARIANTS and clear them
    
                for( ulProp = 0; ulProp < pPropSet[ulSet].cProperties; ulProp++ )
                    VariantClear(&(pPropSet[ulSet].rgProperties[ulProp].vValue));
    
                CoTaskMemFree( pPropSet[ulSet].rgProperties );
            }
    
            // Free DBPROPSET
    
            CoTaskMemFree( pPropSet );
        }
    
        *pcProperties = 0;
        *prgProperties = 0;

        sc = e.GetErrorCode();
    }
    END_CATCH
    
    return sc;
} //CUtlProps::GetProperties

//+---------------------------------------------------------------------------
//
//  Method:     CUtlProp::SetProperties, public
//
//  Synopsis:   This routine takes the array of properties that the consumer 
//              has give, determines whether each property can be supported.
//              For the ones supported, it sets a bit.  
// 
//  Arguments:  [cPropertySets]     - count of DBPROPSETS in rgPropertySets
//              [rgPropertySets]    - array of DBPROPSETS of values to be set
//
//  Returns:    SCODE indicating the following:
//              S_OK                - Success
//              E_FAIL              - Provider specific error
//              DB_S_ERRORSOCCURRED - One or more properties not set
//
//  History:    11-12-97    danleg      Created from Monarch
//
//----------------------------------------------------------------------------

SCODE CUtlProps::SetProperties
    (
    const ULONG             cPropertySets,      
    const DBPROPSET         rgPropertySets[]    
    )
{
    DWORD           dwState = 0;
    ULONG           ulSet, ulCurSet, ulCurProp, ulProp;
    DBPROP*         rgDBProp;
    UPROPINFO*      pUPropInfo;
    VARIANT         vDefaultValue;
    DWORD           dwOption;
    
    Win4Assert( ! cPropertySets || rgPropertySets );

    // Initialize Variant
    VariantInit(&vDefaultValue);

    // Process property sets
    for(ulSet=0; ulSet<cPropertySets; ulSet++)
    {
        Win4Assert( ! rgPropertySets[ulSet].cProperties || rgPropertySets[ulSet].rgProperties );

        // Make sure we support the property set
        if ( GetIndexofPropSet(&(rgPropertySets[ulSet].guidPropertySet),
            &ulCurSet) == S_FALSE )
        {
            // Not supported, thus we need to mark all as NOT_SUPPORTED
            rgDBProp = rgPropertySets[ulSet].rgProperties;
            for(ulProp=0; ulProp<rgPropertySets[ulSet].cProperties; ulProp++)
            {
                dwState |= SETPROP_ERRORS;
                rgDBProp[ulProp].dwStatus = DBPROPSTATUS_NOTSUPPORTED;
            }
            continue;
        }

        // Handle properties of a supported property set
        rgDBProp = rgPropertySets[ulSet].rgProperties;
        for(ulProp=0; ulProp<rgPropertySets[ulSet].cProperties; ulProp++)
        {
            // Is this a supported PROPID for this property set
            if ( GetIndexofPropIdinPropSet(ulCurSet, rgDBProp[ulProp].dwPropertyID, 
                &ulCurProp) == S_FALSE)
            {
                dwState |= SETPROP_ERRORS;
                rgDBProp[ulProp].dwStatus = DBPROPSTATUS_NOTSUPPORTED;
                continue;
            }

            // Set the pUPropInfo pointer
            pUPropInfo = (UPROPINFO*)&(_pUPropSet[ulCurSet].pUPropInfo[ulCurProp]); 
            Win4Assert( pUPropInfo );

            // check dwOption for a valid option
            if ( (rgDBProp[ulProp].dwOptions != DBPROPOPTIONS_REQUIRED)  &&
                (rgDBProp[ulProp].dwOptions != DBPROPOPTIONS_OPTIONAL) )
            {
                vqDebugOut(( DEB_WARN, "SetProperties dwOptions Invalid: %u\n", rgDBProp[ulProp].dwOptions ));
                dwState |= SETPROP_ERRORS;
                rgDBProp[ulProp].dwStatus = DBPROPSTATUS_BADOPTION;
                continue;
            }

            // Check that the property is settable
            // @devnote: We do not check against DBPROPFLAGS_CHANGE here
            if ( (pUPropInfo->dwFlags & DBPROPFLAGS_WRITE) == 0 )
            {
                rgDBProp[ulProp].dwStatus = DBPROPSTATUS_OK;

                VariantClear(&vDefaultValue);

                // VT_EMPTY against a read only property should be a no-op since
                // the VT_EMPTY means the default.
                if ( V_VT(&rgDBProp[ulProp].vValue) == VT_EMPTY )
                {
                    dwState |= SETPROP_VALIDPROP;
                    continue;
                }

                if ( SUCCEEDED(GetDefaultValue(ulCurSet, rgDBProp[ulProp].dwPropertyID, 
                        &dwOption, &(vDefaultValue))) )
                {
                    if ( V_VT(&rgDBProp[ulProp].vValue) ==  V_VT(&vDefaultValue) )
                    {
                        switch( V_VT(&vDefaultValue) )
                        {
                            case VT_BOOL:
                                if ( V_BOOL(&rgDBProp[ulProp].vValue) == V_BOOL(&vDefaultValue) )
                                {
                                    dwState |= SETPROP_VALIDPROP;
                                    continue;
                                }
                                break;
                            case VT_I2:
                                if ( V_I2(&rgDBProp[ulProp].vValue) == V_I2(&vDefaultValue) )
                                {
                                    dwState |= SETPROP_VALIDPROP;
                                    continue;
                                }
                                break;
                            case VT_I4:
                                if ( V_I4(&rgDBProp[ulProp].vValue) == V_I4(&vDefaultValue) )
                                {
                                    dwState |= SETPROP_VALIDPROP;
                                    continue;
                                }
                                break;
                            case VT_BSTR:
                                if ( wcscmp(V_BSTR(&rgDBProp[ulProp].vValue), V_BSTR(&vDefaultValue)) == 0 )
                                {
                                    dwState |= SETPROP_VALIDPROP;
                                    continue;
                                }
                                break;
                        }
                    }
                }

                dwState |= SETPROP_ERRORS;
                rgDBProp[ulProp].dwStatus = DBPROPSTATUS_NOTSETTABLE;
                continue;
            }

            // Check that the property is being set with the correct VARTYPE
            if ( (rgDBProp[ulProp].vValue.vt != pUPropInfo->VarType) && 
                (rgDBProp[ulProp].vValue.vt != VT_EMPTY) )
            {
                dwState |= SETPROP_ERRORS;
                rgDBProp[ulProp].dwStatus = DBPROPSTATUS_BADVALUE;
                continue;
            }

            // Check that the value is legal
            if ( (rgDBProp[ulProp].vValue.vt != VT_EMPTY) && 
                IsValidValue(ulCurSet, &(rgDBProp[ulProp])) == S_FALSE )
            {
                dwState |= SETPROP_ERRORS;
                rgDBProp[ulProp].dwStatus = DBPROPSTATUS_BADVALUE;
                continue;
            }


            if ( SUCCEEDED(SetProperty(ulCurSet, ulCurProp, &(rgDBProp[ulProp]))) )
            {
                dwState |= SETPROP_VALIDPROP;
            }
        }
    }

    VariantClear(&vDefaultValue);

    // At least one propid was marked as not S_OK
    if ( dwState & SETPROP_ERRORS )
    {
        // If at least 1 property was set
        if ( dwState & SETPROP_VALIDPROP )
            return DB_S_ERRORSOCCURRED;
        else
            return DB_E_ERRORSOCCURRED;
    }
    
    return S_OK;
} // CUtlProp::SetProperties

//+---------------------------------------------------------------------------
//
//  Method:     CUtlProp::IsPropSet, public
//
//  Synopsis:   Check if a VT_BOOL property is true or false
//
//  History:    11-12-97    danleg      Created from Monarch
//
//----------------------------------------------------------------------------

BOOL CUtlProps::IsPropSet
    (
    const GUID*     pguidPropSet,
    DBPROPID        dwPropId
    )
{
    SCODE       sc = S_OK;
    ULONG       iPropSet;
    ULONG       iPropId;
    VARIANT     vValue;
    DWORD       dwOptions;

    VariantInit(&vValue);

    if ( GetIndexofPropSet(pguidPropSet, &iPropSet) == S_OK )
    {
        if ( GetIndexofPropIdinPropSet(iPropSet, dwPropId, &iPropId) == S_OK )
        {       
            if ( _pUPropSet[iPropSet].pUPropInfo[iPropId].dwFlags & 
                (DBPROPFLAGS_WRITE | DBPROPFLAGS_CHANGE) )
            {
                ULONG iPropVal = GetUPropValIndex(iPropSet, dwPropId);
                
                dwOptions = _xaUProp[iPropSet].pUPropVal[iPropVal].dwOption;
                sc = VariantCopy( &vValue,
                                  &(_xaUProp[iPropSet].pUPropVal[iPropVal].vValue) );
            }
            else
            {
                sc = GetDefaultValue( iPropSet, dwPropId, 
                                      &dwOptions, &vValue );
            }

            if ( dwOptions == DBPROPOPTIONS_REQUIRED )
            {
                if ( SUCCEEDED(sc) )
                {
                    Win4Assert( vValue.vt == VT_BOOL );
                    if ( V_BOOL(&vValue) == VARIANT_TRUE )
                    {
                        VariantClear(&vValue);
                        return TRUE;
                    }
                }
            }
        }
    }

    VariantClear(&vValue);
    return FALSE;
}

//+---------------------------------------------------------------------------
//
//  Method:     CUtlProp::GetPropValue, public
//
//  Synopsis:   
//
//  History:    11-12-97    danleg      Created from Monarch
//
//----------------------------------------------------------------------------

SCODE CUtlProps::GetPropValue
    (
    const GUID*     pguidPropSet, 
    DBPROPID        dwPropId, 
    VARIANT*        pvValue
    )
{
    SCODE       sc = E_FAIL;
    ULONG       iPropSet;
    ULONG       iPropId;
    DWORD       dwOptions;

    if ( GetIndexofPropSet(pguidPropSet, &iPropSet) == S_OK )
    {
        if ( GetIndexofPropIdinPropSet(iPropSet, dwPropId, &iPropId) == S_OK )
        {       
            if ( _pUPropSet[iPropSet].pUPropInfo[iPropId].dwFlags & (DBPROPFLAGS_WRITE | DBPROPFLAGS_CHANGE) )
            {
                sc = VariantCopy( pvValue, 
                                  &(_xaUProp[iPropSet].pUPropVal[
                                    GetUPropValIndex(iPropSet, dwPropId)].vValue) );
            }
            else
            {
                VariantClear(pvValue);

                sc = GetDefaultValue( iPropSet, 
                                      dwPropId, 
                                      &dwOptions, 
                                      pvValue );
            }
        }
    }

    return sc;
}

//+---------------------------------------------------------------------------
//
//  Method:     CUtlProp::SetPropValue, public
//
//  Synopsis:   
//
//  History:    11-12-97    danleg      Created from Monarch
//
//----------------------------------------------------------------------------

HRESULT CUtlProps::SetPropValue
    (
    const GUID*     pguidPropSet,
    DBPROPID        dwPropId, 
    VARIANT*        pvValue
    )
{
    SCODE       sc = E_FAIL;
    ULONG       iPropSet;
    ULONG       iPropId;

    if ( GetIndexofPropSet(pguidPropSet, &iPropSet) == S_OK )
    {
        if ( GetIndexofPropIdinPropSet(iPropSet, dwPropId, &iPropId) == S_OK )
        {       
            Win4Assert( _pUPropSet[iPropSet].pUPropInfo[iPropId].dwFlags & (DBPROPFLAGS_WRITE | DBPROPFLAGS_CHANGE) );

            sc = VariantCopy( &(_xaUProp[iPropSet].pUPropVal[
                                    GetUPropValIndex(iPropSet, dwPropId)].vValue), 
                              pvValue );
        }
    }

    return sc;
}


//+---------------------------------------------------------------------------
//
//  Method:     CUtlProps::CopyUPropVal, public
//
//  Synopsis:   Copy the values stored in UpropVal
//
//  History:    11-12-97    danleg      Created from Monarch
//
//----------------------------------------------------------------------------

SCODE CUtlProps::CopyUPropVal
    (
    ULONG           iPropSet,
    UPROPVAL*       rgUPropVal
    )
{
    SCODE  sc = S_OK;
    DBPROP dbProp;

    Win4Assert( rgUPropVal );
    Win4Assert( iPropSet < _cUPropSet );
    
    VariantInit(&dbProp.vValue);

    UPROP * pUProp = &(_xaUProp[iPropSet]);

    for(ULONG ul=0; ul<pUProp->cPropIds; ul++)
    {
        UPROPVAL * pUPropVal = &(pUProp->pUPropVal[ul]);

        // Transfer dwOptions
        rgUPropVal[ul].dwOption = pUPropVal->dwOption;

        // Transfer Flags
        rgUPropVal[ul].dwFlags = pUPropVal->dwFlags;

        // Transfer value
        VariantInit(&(rgUPropVal[ul].vValue));
        sc = VariantCopy( &(rgUPropVal[ul].vValue), &(pUPropVal->vValue) );

        if ( FAILED(sc) )
            break;
    }

    VariantClear( &(dbProp.vValue) );
    return sc;
}

//+---------------------------------------------------------------------------
//
//  Method:     CUtlProps::GetIndexofPropSet, public
//
//  Synopsis:   Given a propset guid, find the index of the propset in our 
//              current set to be returned.
//
//  Arguments:  [pPropset]      - Guid of propset to find index of
//              [pulCurSet]     - Index of current property set [out]
//
//  Returns:    SCODE indicating the following:
//              S_OK    - guid was matched and index returned
//              S_FALSE - guid was not matched
//
//  History:    11-12-97    danleg      Created from Monarch
//
//----------------------------------------------------------------------------

SCODE CUtlProps::GetIndexofPropSet
    (
    const GUID* pPropSet,   
    ULONG*  pulCurSet       
    )
{
    ULONG ul;

    Win4Assert( pPropSet && pulCurSet );

    for(ul=0; ul<_cUPropSet; ul++)
    {
        if ( *pPropSet == *(_pUPropSet[ul].pPropSet) )
        {
            *pulCurSet = ul;
            return S_OK;
        }
    }

    return S_FALSE;
}

//+---------------------------------------------------------------------------
//
//  Method:     CUtlProps::GetIndexofPropIdinPropSet, public
//
//  Synopsis:   Given a propertyset guid, determine what index in our current
//              set of property sets is to be returned
//
//  Arguments:  [iCurSet]       - Index of current property set
//              [dwPropertyId]  - Property id
//              [piCurPropId]   - Index of requeted id [out]
//
//  Returns:    SCODE as follows:
//              S_OK    - Propid found in propset
//              S_FALSE - Propid not found in propset
//
//  History:    11-12-97    danleg      Created from Monarch
//
//----------------------------------------------------------------------------

SCODE CUtlProps::GetIndexofPropIdinPropSet
    (
    ULONG       iCurSet,        
    DBPROPID    dwPropertyId,   
    ULONG*      piCurPropId     
    )
{
    ULONG       ul;
    UPROPINFO*  pUPropInfo;

    Win4Assert( piCurPropId );

    pUPropInfo = (UPROPINFO*)_pUPropSet[iCurSet].pUPropInfo;

    for(ul=0; ul<_pUPropSet[iCurSet].cUPropInfo; ul++)
    {
        if ( dwPropertyId == pUPropInfo[ul].dwPropId )
        {
            *piCurPropId = ul;

            // Test to see if the property is supported for this
            // instantiation
            if ( TESTBIT(&(_xadwSupported[iCurSet * _cElemPerSupported]), ul) )
                return S_OK;
            else
                return S_FALSE;
        }
    }

    return S_FALSE;
}

//+---------------------------------------------------------------------------
//
//  Method:     CUtlProps::FInit, protected
//
//  Synopsis:   Initialization.  Called from constructors of derived classes.
//
//  History:    11-12-97    danleg      Created from Monarch
//
//----------------------------------------------------------------------------

void CUtlProps::FInit( CUtlProps * pCopyMe )
{
    SCODE               sc = S_OK;
    ULONG               ulPropId;
    ULONG               cPropIds;
    ULONG               iPropSet;
    ULONG               iNewDex;
    XArray<UPROPINFO*>  xapUPropInfo;
    XArray<UPROPVAL>    xaUPropVal;
    UPROPINFO *         pUPropInfo;
    
    // If a pointer is passed in, we should copy that property object
    if ( pCopyMe )
    {
        // Establish some base values
        pCopyMe->CopyAvailUPropSets( &_cUPropSet, 
                                     &_pUPropSet,
                                     &_cElemPerSupported );

        Win4Assert( (_cUPropSet != 0)  && (_cElemPerSupported != 0) );
        
        // Retrieve Supported Bitmask
        _xadwPropsInError.Init( _cUPropSet * _cElemPerSupported );
        ClearPropertyInError();
        
        // This uses XArray<>::Init to allocate and copy into _xadwSupported
        pCopyMe->CopyUPropSetsSupported( _xadwSupported );
    }
    else
    {
        sc = InitAvailUPropSets( &_cUPropSet, &_pUPropSet, &_cElemPerSupported );
        if ( FAILED(sc) )
            THROW( CException(sc) );

        Win4Assert( (_cUPropSet != 0)  && (_cElemPerSupported != 0) );
        if ( !_cUPropSet || !_cElemPerSupported )
            THROW( CException(E_FAIL) );

        _xadwSupported.Init( _cUPropSet * _cElemPerSupported );
        _xadwPropsInError.Init( _cUPropSet * _cElemPerSupported );

        ClearPropertyInError();
        
        // Set all slots to an initial value
        sc = InitUPropSetsSupported( _xadwSupported.GetPointer() ); 
        if ( FAILED(sc) )
        {
            _xadwSupported.Free();
            THROW( CException(sc) );
        }
    }

    // Allocate UPROPS structures for the count of Property sets
    _xaUProp.Init( _cUPropSet );

    RtlZeroMemory( _xaUProp.GetPointer(), _cUPropSet * sizeof(UPROP) );

    // Within the UPROPS Structure allocate and intialize the
    // Property IDs that belong to this property set.
    for(iPropSet=0; iPropSet<_cUPropSet; iPropSet++)
    {
        cPropIds = GetCountofWritablePropsInPropSet( iPropSet );

        if ( cPropIds > 0 )
        {
            // Initialize/allocate xaUPropVal.  Even when we are copying, the
            // copy routine simply does a member-wise value assignment.

            xaUPropVal.Init( cPropIds );

            if ( pCopyMe )
            {
                // CopyUPropInfo uses XArray<>::Init to allocate/copy xapUPropInfo

                pCopyMe->CopyUPropInfo( iPropSet, xapUPropInfo );

                // CopyUPropVal only transfers values.  Allocate xaUPropVal before calling this
                Win4Assert( !xaUPropVal.IsNull() );
                sc = pCopyMe->CopyUPropVal( iPropSet, xaUPropVal.GetPointer() );
                if ( FAILED(sc) )
                    THROW( CException(sc) );
            }
            else
            {
                // Initialize and allocate arrays
                xapUPropInfo.Init( cPropIds );

                // Clear Pointer Array
                RtlZeroMemory( xapUPropInfo.GetPointer(), cPropIds * sizeof(UPROPINFO *) );

                // Set Pointer to correct property ids with a property set
                pUPropInfo = (UPROPINFO *) _pUPropSet[iPropSet].pUPropInfo;

                // Set up the writable property buffers
                iNewDex = 0;
                for(ulPropId=0; ulPropId<_pUPropSet[iPropSet].cUPropInfo; ulPropId++)
                {
                    if ( pUPropInfo[ulPropId].dwFlags & (DBPROPFLAGS_WRITE | DBPROPFLAGS_CHANGE) )
                    {
                        // Following assert indicates that the are more
                        // writable properties then space allocated
                        Win4Assert( iNewDex < cPropIds );

                        xapUPropInfo[iNewDex] = &(pUPropInfo[ulPropId]);
                        xaUPropVal[iNewDex].dwOption = DBPROPOPTIONS_OPTIONAL;
                        xaUPropVal[iNewDex].dwFlags = 0;
                        VariantInit(&(xaUPropVal[iNewDex].vValue));

                        sc = GetDefaultValue( iPropSet, 
                                              pUPropInfo[ulPropId].dwPropId, 
                                              &(xaUPropVal[iNewDex].dwOption), 
                                              &(xaUPropVal[iNewDex].vValue) );

                        if ( FAILED( sc ) )
                            THROW( CException(sc) );

                        iNewDex++;
                    }
                }
                
                Win4Assert( cPropIds == iNewDex );
            }

            _xaUProp[iPropSet].rgpUPropInfo = xapUPropInfo.Acquire();
            _xaUProp[iPropSet].pUPropVal = xaUPropVal.Acquire();
            _xaUProp[iPropSet].cPropIds = cPropIds;
        }
    }

    // Finally determine if there are any hidden property sets..  Those
    // that do not show up in GetPropertyInfo and should not be returns on 
    // a 0, NULL call to GetProperties
    for(iPropSet=0; iPropSet<_cUPropSet; iPropSet++)
    {
        if ( _pUPropSet[iPropSet].dwFlags & UPROPSET_HIDDEN )
            _cUPropSetHidden++;
    }
} // CUtlProps::FInit


//+---------------------------------------------------------------------------
//
//  Method:     CUtlProps::FreeMemory, private
//
//  Synopsis:   Free all memory
//
//  History:    11-12-97    danleg      Created from Monarch
//
//----------------------------------------------------------------------------

void CUtlProps::FreeMemory()
{
    ULONG       ulPropSet;
    ULONG       ulPropId;
    UPROPVAL*   pUPropVal;

    // Remove Property Information
    if ( !_xaUProp.IsNull() )
    {
        //
        // Reset _cUPropSet to its max. Used by derived classes that expose a subset
        // of their prop sets in some states. (eg. CMDSProps hides all but DBPROPSET_INIT
        // if the datasource is in an uninitlaized state)
        //
        for(ulPropSet=0; ulPropSet<_cUPropSet; ulPropSet++)
        {
            pUPropVal = _xaUProp[ulPropSet].pUPropVal;
            for(ulPropId=0; ulPropId<_xaUProp[ulPropSet].cPropIds; ulPropId++)
            {
                VariantClear(&(pUPropVal[ulPropId].vValue));
            }
            // TODO: UPROPSET change structure to use XArray
            delete[] _xaUProp[ulPropSet].rgpUPropInfo;
            delete[] _xaUProp[ulPropSet].pUPropVal;
        }
    
        _xaUProp.Free();
    }
    
    _xadwSupported.Free();
    _xadwPropsInError.Free();
    _xaiPropSetDex.Free();

    _cPropSetDex        = 0;
    _cUPropSet          = 0;
    _cUPropSetHidden    = 0;
    _dwFlags            = 0;
    _cElemPerSupported  = 0;
}

//+---------------------------------------------------------------------------
//
//  Method:     CUtlProps::GetCountofWritablePropsInPropSet, private
//
//  Synopsis:   Given an index to the property set, count the number of
//              writable or changable properties under this property set.
//              devnote: this includes properties with the internal flag of
//                       DBPROPFLAGS_CHANGE along with DBPROPFLAGS_WRITE
//
//  Returns:    Count of writable properties
//
//  History:    11-12-97    danleg      Created from Monarch
//
//----------------------------------------------------------------------------

ULONG CUtlProps::GetCountofWritablePropsInPropSet
    (
    ULONG   iPropSet            //@parm IN | Index of Property Set
    )
{
    ULONG       ul;
    ULONG       cWritable = 0;
    UPROPINFO*  pUPropInfo;

    Win4Assert( _pUPropSet );
    Win4Assert( iPropSet < _cUPropSet );

    pUPropInfo = (UPROPINFO*)_pUPropSet[iPropSet].pUPropInfo;
    
    for(ul=0; ul<_pUPropSet[iPropSet].cUPropInfo; ul++)
    {
        if ( pUPropInfo[ul].dwFlags & (DBPROPFLAGS_WRITE | DBPROPFLAGS_CHANGE) )
            cWritable++;
    }
    
    return cWritable;
}

//+---------------------------------------------------------------------------
//
//  Method:     CUtlProps::GetUPropValIndex, private
//
//  Synopsis:   
//
//  History:    11-12-97    danleg      Created from Monarch
//
//----------------------------------------------------------------------------

ULONG CUtlProps::GetUPropValIndex
    (
    ULONG       iCurSet,
    DBPROPID    dwPropId
    )
{
    ULONG ul;

    for(ul=0; ul<_xaUProp[iCurSet].cPropIds; ul++)
    {
        if ( (_xaUProp[iCurSet].rgpUPropInfo[ul])->dwPropId == dwPropId )
            return ul;
    }

    return 0;
}


//+---------------------------------------------------------------------------
//
//  Method:     CUtlProps::SetProperty, private
//
//  Synopsis:   The iCurProp is an index into _pUPropSet, not into _xaUProp
//
//  Arguments:  [iCurSet]   - Index within _xaUProp and _pUPropSet
//              [iCurProp]  -
//              [pDBProp]   - Pointer to current property node [out]
//
//  History:    11-12-97    danleg      Created from Monarch
//
//----------------------------------------------------------------------------

SCODE CUtlProps::SetProperty
    (
    ULONG       iCurSet,        //@parm IN | Index within _xaUProp and _pUPropSet
    ULONG       iCurProp,
    DBPROP*     pDBProp         //@PARM INOUT | Pointer to current property node
    )
{
    SCODE       sc = S_OK;
    UPROP*      pUProp;
    UPROPVAL*   pUPropVal;
    UPROPINFO*  pUPropInfo;
    ULONG       iUProp;

    Win4Assert( pDBProp );

    // Set pointer to correct set
    pUProp = &(_xaUProp[iCurSet]);
    Win4Assert( pUProp );

    pUPropInfo = (UPROPINFO*)&(_pUPropSet[iCurSet].pUPropInfo[iCurProp]);
    Win4Assert( pUPropInfo );

    // Determine the index within _xaUProp  
    for(iUProp=0; iUProp<pUProp->cPropIds; iUProp++)
    {
        if ( (pUProp->rgpUPropInfo[iUProp])->dwPropId == pDBProp->dwPropertyID )
            break; 
    }

    if ( iUProp >= pUProp->cPropIds )
    {
        Win4Assert( !"Should have found index of property to set" );
        sc = E_FAIL;
        pDBProp->dwStatus = DBPROPSTATUS_NOTSUPPORTED;
        goto EXIT;
    }

    //Get the UPROPVAL node pointer within that propset.
    pUPropVal = &(pUProp->pUPropVal[iUProp]);
    Win4Assert( pUPropVal );

    // Handle VT_EMPTY, which indicates to the provider to 
    // reset this property to the providers default
    if ( pDBProp->vValue.vt == VT_EMPTY )
    {
        // Should clear here, since previous values may already
        // have been cached and need to be replaced.
        VariantClear(&(pUPropVal->vValue));

        pUPropVal->dwFlags &= ~DBINTERNFLAGS_CHANGED;
        sc = GetDefaultValue( iCurSet, 
                              pDBProp->dwPropertyID, 
                              &(pUPropVal->dwOption), 
                              &(pUPropVal->vValue) );

        goto EXIT;
    }
        
    pUPropVal->dwOption = pDBProp->dwOptions;
    sc = VariantCopy( &(pUPropVal->vValue), &(pDBProp->vValue) );
    if ( FAILED(sc)  )
        goto EXIT;
    pUPropVal->dwFlags |= DBINTERNFLAGS_CHANGED;

EXIT:
    if ( SUCCEEDED(sc) )
        pDBProp->dwStatus = DBPROPSTATUS_OK;

    return sc;
}


//
//  CUtlPropInfo methods
//

//+---------------------------------------------------------------------------
//
//  Method:     CUtlPropInfo::CUtlPropInfo, public
//
//  Synopsis:   Constructor
//
//  History:    11-12-97    danleg      Created from Monarch
//
//----------------------------------------------------------------------------

CUtlPropInfo::CUtlPropInfo() :
    _cUPropSet(0),
    _cPropSetDex(0),
    _cElemPerSupported(0),
    _pUPropSet(0)
{
}

//+---------------------------------------------------------------------------
//
//  Method:     CUtlPropInfo::GetPropertyInfo, public
//
//  Synopsis:   Retrieve the requested property info
//
//  Arguments:  [cPropertySets]       - Count of property sets
//              [rgPropertySets]      - Property sets
//              [pcPropertyInfoSets]  - Count of properties returned [out]
//              [prgPropertyInfoSets] - Property information returned [out]
//              [ppDescBuffer]        - Buffer for returned descriptions [out]
//
//  Returns:    SCODE as follows:
//              S_OK    - At least one index returned
//              S_FALSE - No matching property set found
//
//  History:    11-12-97    danleg      Created from Monarch
//
//----------------------------------------------------------------------------

SCODE CUtlPropInfo::GetPropertyInfo
    (
    ULONG               cPropertySets,      
    const DBPROPIDSET   rgPropertySets[],   
    ULONG*              pcPropertyInfoSets, 
    DBPROPINFOSET**     prgPropertyInfoSets,
    WCHAR**             ppDescBuffer        
    )
{
    SCODE           sc = S_OK;
    ULONG           ul, ulSet, ulNext, ulEnd, ulProp;
    ULONG           ulOutIndex;
    ULONG           cSets;
    ULONG           cPropInfos;
    DWORD           dwStatus = 0;
    DBPROPINFO*     pCurPropInfo = 0;
    WCHAR*          pDescBuffer = 0;
    UPROPINFO*      pUPropInfo = 0;
    WCHAR           wszBuff[256];
    int             cch;


    XArrayOLE<DBPROPINFO>   xaPropInfo;
    XArrayOLE<WCHAR>        xawszDescBuffer;

    // If the consumer does not restrict the property sets
    // by specify an array of property sets and a cPropertySets
    // greater than 0, then we need to make sure we 
    // have some to return
    if ( cPropertySets == 0 )
    {
        // Determine the number of property sets supported
        cSets = _cUPropSet;
    }
    else
    {
        cSets = 0;

        // Determine number of property sets required 
        // This is only required when any of the "special" property set GUIDs were specified
        for(ulSet=0; ulSet<cPropertySets; ulSet++)
        {
            // Note that we always allocate nodes, mark all bad properties,
            // and return DB_E_ERRORSOCCURRED.  See Nile spec bug 2665.
            // We always allocate at least one.
            if ( GetPropertySetIndex(&(rgPropertySets[ulSet].guidPropertySet)) == S_OK )
                cSets += _cPropSetDex;
            else
                cSets++;
        }
    }
    Win4Assert( cSets );

    //
    // Allocate the DBPROPINFOSET structures.  XArray zeors out the memory.
    //
    XArrayOLE<DBPROPINFOSET>    xaPropInfoSet( cSets );

    ulOutIndex = 0;
    ulEnd = cPropertySets == 0 ? cSets : cPropertySets; 

    // Fill in the output array
    for(ulSet=0; ulSet<ulEnd; ulSet++)
    {
        // Depending of if Property sets are specified store the
        // return property set.
        if (cPropertySets == 0)
        {
            xaPropInfoSet[ulSet].guidPropertySet = *(_pUPropSet[ulSet].pPropSet);
        }
        else
        {
            if ( ((rgPropertySets[ulSet].guidPropertySet == DBPROPSET_DATASOURCEALL) ||
                 (rgPropertySets[ulSet].guidPropertySet == DBPROPSET_DATASOURCEINFOALL) ||
                 (rgPropertySets[ulSet].guidPropertySet == DBPROPSET_DBINITALL) ||
                 (rgPropertySets[ulSet].guidPropertySet == DBPROPSET_SESSIONALL) ||
                 (rgPropertySets[ulSet].guidPropertySet == DBPROPSET_ROWSETALL)) &&
                (GetPropertySetIndex(&(rgPropertySets[ulSet].guidPropertySet)) == S_OK) )
            {
                for(ul=0; ul<_cPropSetDex; ul++,ulOutIndex++)
                {
                    xaPropInfoSet[ulOutIndex].guidPropertySet   = *(_pUPropSet[_xaiPropSetDex[ul]].pPropSet);
                    xaPropInfoSet[ulOutIndex].cPropertyInfos    = 0;
                }
            }
            else
            {
                // Handle non-category property sets
                // Handle unknown property sets
                xaPropInfoSet[ulOutIndex].guidPropertySet = rgPropertySets[ulSet].guidPropertySet; 
                xaPropInfoSet[ulOutIndex].cPropertyInfos  = rgPropertySets[ulSet].cPropertyIDs; 
                ulOutIndex++;
            }
        }
    }
        
    // Allocate a Description Buffer if needed
    if ( ppDescBuffer )
    {
        ULONG cBuffers = CalcDescripBuffers(cSets, xaPropInfoSet.GetPointer());
        if ( 0 != cBuffers )
        {
            xawszDescBuffer.Init( cBuffers * CCH_GETPROPERTYINFO_DESCRIP_BUFFER_SIZE );
            pDescBuffer = xawszDescBuffer.GetPointer();
        }
        else
        {
            // No buffers needed.  Make sure client already set to NULL.
            Win4Assert( 0 == *ppDescBuffer );
        }
    }

    TRANSLATE_EXCEPTIONS;
    TRY
    {
        // Process requested or derived Property sets
        dwStatus = 0;
        for(ulSet=0; ulSet<cSets; ulSet++)
        {
            ulNext=0;
            cPropInfos = 0;

            dwStatus &= (GETPROPINFO_ERRORSOCCURRED | GETPROPINFO_VALIDPROP);

            // Calculate the number of property nodes needed for this
            // property set.
            if ( cPropertySets == 0 )
            {
                cPropInfos = _pUPropSet[ulSet].cUPropInfo;
                dwStatus |= GETPROPINFO_ALLPROPIDS;
                _xaiPropSetDex[0] = ulSet;
                _cPropSetDex = 1;
            }
            else
            {
                // If the count of PROPIDs is 0 (NOTE: the above routine already determined
                // if it belonged to a category and if so set the count of properties to 0 for
                // each propset in that category.
                if ( 0 == xaPropInfoSet[ulSet].cPropertyInfos )
                {
                    dwStatus |= GETPROPINFO_ALLPROPIDS;
                    // We have to determine if the property set is supported and if so
                    // the count of properties in the set.
                    if ( GetPropertySetIndex(&(xaPropInfoSet[ulSet].guidPropertySet)) == S_OK )             
                    {
                        Win4Assert( _cPropSetDex == 1 );
                        
                        cPropInfos += _pUPropSet[_xaiPropSetDex[0]].cUPropInfo;
                    }
                    else
                    {
                        // Not Supported                    
                        dwStatus |= GETPROPINFO_ERRORSOCCURRED;
                        goto NEXT_SET;
                    }
                }
                else
                {
                    cPropInfos = xaPropInfoSet[ulSet].cPropertyInfos;
                    if ( GetPropertySetIndex(&(xaPropInfoSet[ulSet].guidPropertySet)) == S_FALSE )
                    {
                        dwStatus |= GETPROPINFO_NOTSUPPORTED;
                        dwStatus |= GETPROPINFO_ERRORSOCCURRED;
                    }
                }
            }


            // Allocate DBPROP array
            Win4Assert( cPropInfos != 0 );
        
            xaPropInfo.Init( cPropInfos ); 

            for(ulProp=0; ulProp<cPropInfos; ulProp++)
            {
                VariantInit(&(xaPropInfo[ulProp].vValues));
                if ( dwStatus & GETPROPINFO_NOTSUPPORTED )
                {
                    // Not supported, thus we need to mark all as NOT_SUPPORTED
                    xaPropInfo[ulProp].dwPropertyID = rgPropertySets[ulSet].rgPropertyIDs[ulProp];
                    xaPropInfo[ulProp].dwFlags = DBPROPFLAGS_NOTSUPPORTED;
                    dwStatus |= GETPROPINFO_ERRORSOCCURRED;
                }                   
            }
            // Make sure we support the property set
            if ( dwStatus & GETPROPINFO_NOTSUPPORTED )
            {
                ulNext = cPropInfos;
                goto NEXT_SET;
            }

            // Retrieve the property information for this property set
            for(ul=0; ul<_cPropSetDex; ul++)
            {
                pUPropInfo = (UPROPINFO*)(_pUPropSet[_xaiPropSetDex[ul]].pUPropInfo);
                Win4Assert( pUPropInfo );
                            
                // Retrieve current value of properties
                if ( dwStatus & GETPROPINFO_ALLPROPIDS )
                {
                    for(ulProp=0; ulProp<_pUPropSet[_xaiPropSetDex[ul]].cUPropInfo; ulProp++)
                    {
                        // Verify property is supported, if not do not return 
                        if ( !TESTBIT(&(_xadwSupported[_xaiPropSetDex[ul] * _cElemPerSupported]), ulProp) )
                            continue;

                        pCurPropInfo = &(xaPropInfo[ulNext]);

                        // If the ppDescBuffer pointer was not NULL, then
                        // we need supply description of the properties
                        if ( ppDescBuffer )
                        {
                            // Set Buffer pointer
                            pCurPropInfo->pwszDescription = pDescBuffer;
                            // Load the string into temp buffer
    //@TODO Add Reallocation routine
                            cch = LoadDescription( pUPropInfo[ulProp].pwszDesc, 
                                                   wszBuff, 
                                                   NUMELEM(wszBuff) );
                            if ( 0 != cch )
                            {
                                // Adjust for '\0'
                                cch++;

                                // Transfer to official buffer if room
                                RtlCopyMemory( pDescBuffer, wszBuff, cch * sizeof(WCHAR) );
                                pDescBuffer += cch;
                            }
                            else
                            {
                                wcscpy( pDescBuffer, L"UNKNOWN" );
                                pDescBuffer += NUMELEM(L"UNKNOWN");
                            }
                        }

                        pCurPropInfo->dwPropertyID  = pUPropInfo[ulProp].dwPropId;
                        pCurPropInfo->dwFlags       = pUPropInfo[ulProp].dwFlags;
                        pCurPropInfo->vtType        = pUPropInfo[ulProp].VarType;
    //@TODO for some there will be a list
                        pCurPropInfo->vValues.vt    = VT_EMPTY;

                        dwStatus |= GETPROPINFO_VALIDPROP;
                        // Increment to next available buffer
                        ulNext++;
                    }
                }
                else
                {
                    Win4Assert( _cPropSetDex == 1 );

                    for( ulProp = 0; ulProp < cPropInfos; ulProp++, ulNext++ )
                    {
                        pCurPropInfo = &(xaPropInfo[ulNext]);

                        // Process Properties based on Restriction array.
                        pCurPropInfo->dwPropertyID = rgPropertySets[ulSet].rgPropertyIDs[ulProp];
                    
                        if ( S_OK == GetUPropInfoPtr( _xaiPropSetDex[ul], 
                                                      pCurPropInfo->dwPropertyID, 
                                                      &pUPropInfo) )
                        {
                            // If the ppDescBuffer pointer was not NULL, then
                            // we need supply description of the properties
                            if ( ppDescBuffer )
                            {
                                // Set Buffer pointer
                                pCurPropInfo->pwszDescription = pDescBuffer;

                                // Load the string into temp buffer
                                if ( cch = LoadDescription( pUPropInfo->pwszDesc, 
                                                            wszBuff, 
                                                            NUMELEM(wszBuff)) )
                                {
                                    // Adjust for '\0'
                                    cch++;

                                    // Transfer to official buffer if room
                                    RtlCopyMemory( pDescBuffer, wszBuff, cch * sizeof(WCHAR) );
                                    pDescBuffer += cch;
                                }
                                else
                                {
                                    wcscpy(pDescBuffer, L"UNKNOWN");
                                    pDescBuffer += (wcslen(L"UNKNOWN") + 1);
                                }
                            }

                            pCurPropInfo->dwPropertyID  = pUPropInfo->dwPropId;
                            pCurPropInfo->dwFlags       = pUPropInfo->dwFlags;
                            pCurPropInfo->vtType        = pUPropInfo->VarType;

                            dwStatus |= GETPROPINFO_VALIDPROP;
                        }
                        else
                        {
                            // Not Supported
                            pCurPropInfo->dwFlags = DBPROPFLAGS_NOTSUPPORTED;
                            dwStatus |= GETPROPINFO_ERRORSOCCURRED;
                        }
                    }
                }
            }

NEXT_SET:
            xaPropInfoSet[ulSet].cPropertyInfos = ulNext;
            xaPropInfoSet[ulSet].rgPropertyInfos = xaPropInfo.Acquire();
        }

        // Success, set return values
        *pcPropertyInfoSets  = cSets;
        *prgPropertyInfoSets = xaPropInfoSet.Acquire();

        if ( ppDescBuffer )
            *ppDescBuffer = xawszDescBuffer.Acquire();

        // At least one propid was marked as not S_OK
        if ( dwStatus & GETPROPINFO_ERRORSOCCURRED )
        {
            // If at least 1 property was set
            if ( dwStatus & GETPROPINFO_VALIDPROP )
                return DB_S_ERRORSOCCURRED;
            else
            {
                // Do not free any of the rgPropertyInfoSets, but
                // do free the ppDescBuffer
                if ( pDescBuffer )
                {
                    Win4Assert( ppDescBuffer );
                    CoTaskMemFree( pDescBuffer );
                    *ppDescBuffer = 0;
                }
                return DB_E_ERRORSOCCURRED;
            }
        }

    }
    CATCH( CException, e )
    {
        // most likely E_OUTOFMEMORY
        sc = e.GetErrorCode();

        // Check if failure and clean up any allocated memory
        if ( FAILED(sc) ) 
        {
            // Free Description Buffer
            if ( pDescBuffer )
            {
                Win4Assert( ppDescBuffer );
                CoTaskMemFree( *ppDescBuffer );
                *ppDescBuffer = 0;
            }

            if ( !xaPropInfoSet.IsNull() )
            {
                // Loop through Property Sets
                for(ulSet=0; ulSet<cSets; ulSet++)
                {
                    if ( xaPropInfoSet[ulSet].rgPropertyInfos )
                        CoTaskMemFree( xaPropInfoSet[ulSet].rgPropertyInfos );
                }
            }
        }
        
        // Rethrow exception to the calling function
        RETHROW();
    }
    END_CATCH;
    UNTRANSLATE_EXCEPTIONS;

    
    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Method:     CUtlPropInfo::FInit, protected
//
//  Synopsis:   Initialization.  Called from constructors of derived classes.
//
//  History:    11-12-97    danleg      Created from Monarch
//
//----------------------------------------------------------------------------

void CUtlPropInfo::FInit
    (
    )
{
    SCODE sc = S_OK;

    InitAvailUPropSets( &_cUPropSet, 
                        &_pUPropSet, 
                        &_cElemPerSupported );

    Win4Assert( (_cUPropSet != 0)  && (_cElemPerSupported != 0) );
    if ( !_cUPropSet || !_cElemPerSupported )
        THROW( CException(E_FAIL) );

    _xadwSupported.Init( _cUPropSet * _cElemPerSupported );

    sc = InitUPropSetsSupported( _xadwSupported.GetPointer() );
    if ( FAILED(sc) )
    {
        _xadwSupported.Free();
        THROW( CException(sc) );
    }

    if ( _cUPropSet )
    {
        _xaiPropSetDex.Init( _cUPropSet );
    }

    return;
}

//+---------------------------------------------------------------------------
//
//  Method:     CUtlPropInfo::GetUPropInfoPtr, private
//
//  Synopsis:   Retrieve a pointer to the UPROPINFO structure that contains
//              information about this property id within this property set
//
//  Arguments:  [iPropSetDex]   - Index into UPropSets
//              [dwPropertyId]  - Property to search for with UPropSet
//              [ppUPropInfo]   - Pointer in which to return ptr to UPropInfo [out]
//
//  Returns:    SCODE as follows:
//              S_OK    - Property id found
//              S_FALSE - No matching prop id found or property not supported
//
//  History:    11-12-97    danleg      Created from Monarch
//
//----------------------------------------------------------------------------

SCODE CUtlPropInfo::GetUPropInfoPtr
    (
    ULONG       iPropSetDex,        //@parm IN | Index into UPropSets
    DBPROPID    dwPropertyId,       //@parm IN | Propery to search for with UPropSet
    UPROPINFO** ppUPropInfo         //@parm OUT | Pointer in which to return ptr to UPropInfo
    )
{
    ULONG ulProps;

    // Scan through the property sets looking for matching attributes
    for(ulProps=0; ulProps<_pUPropSet[iPropSetDex].cUPropInfo; ulProps++)
    {
        if ( _pUPropSet[iPropSetDex].pUPropInfo[ulProps].dwPropId == dwPropertyId )
        {
            *ppUPropInfo = (UPROPINFO*)&(_pUPropSet[iPropSetDex].pUPropInfo[ulProps]);

            // Test to see if the property is supported for this instantiation
            if ( TESTBIT(&(_xadwSupported[iPropSetDex * _cElemPerSupported]), ulProps) )
                return S_OK;
            else
                return S_FALSE;
        }
    }

    return S_FALSE;
}

//+---------------------------------------------------------------------------
//
//  Method:     CUtlPropInfo::GetPropertySetIndex, private
//
//  Synopsis:   Retrieve the index or indices of PropertySets that match the
//              given guid.
//
//              NOTE: If given a DBPROPET_DATASOURCEALL, DBPROPSET_DATASOURCEINFOALL
//                    or DBPROPSET_ROWSETALL, the routine may return multiple 
//                    indices.
//  Returns:    SCODE as follows:
//              S_OK    - At least one index was returned.
//              S_FALSE - No matching property set found
//
//  History:    11-12-97    danleg      Created from Monarch
//
//----------------------------------------------------------------------------

SCODE CUtlPropInfo::GetPropertySetIndex
    (
    const GUID* pPropertySet        //@parm IN | Pointer to Property Set Guid
    )
{
    DWORD   dwFlag = 0;
    ULONG   ulSet;

    Win4Assert( _cUPropSet && _pUPropSet );
    Win4Assert( !_xaiPropSetDex.IsNull() );
    Win4Assert( pPropertySet );

    _cPropSetDex = 0;

    if ( *pPropertySet == DBPROPSET_DATASOURCEALL )
    {
        dwFlag = DBPROPFLAGS_DATASOURCE;
    }
    else if ( *pPropertySet == DBPROPSET_DATASOURCEINFOALL )
    {
        dwFlag = DBPROPFLAGS_DATASOURCEINFO;
    }
    else if ( *pPropertySet == DBPROPSET_ROWSETALL )
    {
        dwFlag = DBPROPFLAGS_ROWSET;
    }
    else if ( *pPropertySet == DBPROPSET_DBINITALL )
    {
        dwFlag = DBPROPFLAGS_DBINIT;
    }
    else if ( *pPropertySet == DBPROPSET_SESSIONALL )
    {
        dwFlag = DBPROPFLAGS_SESSION;
    }
    else // No scan required, just look for match.
    {
        for(ulSet=0; ulSet<_cUPropSet; ulSet++)
        {
            if ( *(_pUPropSet[ulSet].pPropSet) == *pPropertySet )
            {
                _xaiPropSetDex[_cPropSetDex] = ulSet;
                _cPropSetDex++;
                break;
            }
        }
        goto EXIT;
    }

    // Scan through the property sets looking for matching attributes
    for(ulSet=0; ulSet<_cUPropSet; ulSet++)
    {
        if ( _pUPropSet[ulSet].pUPropInfo[0].dwFlags & dwFlag )
        {
            _xaiPropSetDex[_cPropSetDex] = ulSet;
            _cPropSetDex++;
        }
    }

EXIT:
    return (_cPropSetDex) ? S_OK : S_FALSE;
}


//+---------------------------------------------------------------------------
//
//  Method:     CUtlPropInfo::CalcDescripBuffers, private
//
//  Synopsis:   Calculate the number of description buffers that will be needed
//
//  Argunemts:  [cPropInfoSet]  - Count of propinfo sets
//              [pPropInfoSet]  - Property info sets
//
//  Returns:    Number of buffers needed
//
//  History:    11-12-97    danleg      Created from Monarch
//
//----------------------------------------------------------------------------

ULONG CUtlPropInfo::CalcDescripBuffers
    (
    ULONG           cPropInfoSet,       //@parm IN | count of property info sets
    DBPROPINFOSET*  pPropInfoSet        //@parm IN | property info sets
    )
{
    ULONG   ul, ulSet;
    ULONG   cBuffers = 0;

    Win4Assert( _pUPropSet && cPropInfoSet && pPropInfoSet );

    for(ulSet=0; ulSet<cPropInfoSet; ulSet++)
    {
        if ( GetPropertySetIndex(&(pPropInfoSet[ulSet].guidPropertySet)) == S_OK)
        {
            for(ul=0; ul<_cPropSetDex; ul++)
            {
                cBuffers += _pUPropSet[_xaiPropSetDex[ul]].cUPropInfo;
            }
        }
    }

    return cBuffers;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\icommand\proprst.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 2000.
//
//  File:       proprst.cxx
//
//  Contents:   This object handles rowset/command properties
//
//  Classes:    CMRowsetProps   : public CUtlProps
//
//  History:    10-28-97    danleg      Created
//
//----------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#define DBINITCONSTANTS
#include <propglob.hxx>
#undef DBINITCONSTANTS

#include <ocidl.h>
#include <ntverp.h>
#include <proprst.hxx>
#include <rstprop.hxx>
#include "propinfr.h"
#include "proptbl.hxx"

//
// Constants
//
static const LCID   InvalidLCID             = 0xFFFFFFFF;

//
//  This array describes all the known rowset properties
//
const SPropDescription CMRowsetProps::aPropDescriptions[] = {
    { DBPROP_ABORTPRESERVE,             FALSE, eNotSupported,   -1 },
    { DBPROP_APPENDONLY,                FALSE, eNotSupported,   -1 },
    { DBPROP_BLOCKINGSTORAGEOBJECTS,    FALSE, eDefaultFalse,   -1 },
    { DBPROP_BOOKMARKS,                 TRUE,  eLocatable,      eid_PROPVAL_BOOKMARKS },
    { DBPROP_BOOKMARKSKIPPED,           FALSE, eDefaultFalse,   -1 },
    { DBPROP_BOOKMARKTYPE,              FALSE, eNumeric,        -1 },
    { DBPROP_CACHEDEFERRED,             FALSE, eColumnProp,     -1 },
    { DBPROP_CANFETCHBACKWARDS,         FALSE, eLocatable,      -1 },
    { DBPROP_CANHOLDROWS,               TRUE,  eHoldRows,       eid_PROPVAL_CANHOLDROWS },
    { DBPROP_CANSCROLLBACKWARDS,        FALSE, eLocatable,      -1 },
    { DBPROP_CHANGEINSERTEDROWS,        FALSE, eNotSupported,   -1 },
    { DBPROP_COLUMNRESTRICT,            FALSE, eDefaultFalse,   -1 },
//    { DBPROP_CHAPTERED,               FALSE, eChaptered,        -1 },
    { DBPROP_COMMANDTIMEOUT,            TRUE,  eNumeric,        eid_PROPVAL_COMMANDTIMEOUT },
    { DBPROP_COMMITPRESERVE,            FALSE, eNotSupported,   -1 },
    { DBPROP_DEFERRED,                  FALSE, eColumnProp,     -1 },
    { DBPROP_DELAYSTORAGEOBJECTS,       FALSE, eNotSupported,   -1 },
    { DBPROP_IMMOBILEROWS,              FALSE, eNotSupported,   -1 },
    { DBPROP_LITERALBOOKMARKS,          FALSE, eDefaultFalse,   -1 },
    { DBPROP_LITERALIDENTITY,           FALSE, eLocatable,      -1 },
    { DBPROP_MAXOPENROWS,               FALSE, eNumeric,        -1 },
    { DBPROP_MAXPENDINGROWS,            FALSE, eNotSupported,   -1 },
    { DBPROP_MAXROWS,                   TRUE,  eNumeric,        eid_PROPVAL_MAXROWS },
    { DBPROP_FIRSTROWS,                 TRUE,  eFirstRows,      eid_PROPVAL_FIRSTROWS },
    { DBPROP_MAYWRITECOLUMN,            FALSE, eColumnProp,     -1 },
    { DBPROP_MEMORYUSAGE,               TRUE,  eNumeric,        eid_PROPVAL_MEMORYUSAGE },
//    { DBPROP_MULTICHAPTERED,            FALSE, eChaptered,      -1 },
//    { DBPROP_MULTIPLEACCESSORS,         FALSE, eDefaultTrue,    -1 },
//    { DBPROP_MULTIPLERESULTSETS,        FALSE, eNotSupported,   -1 },
//    { DBPROP_NOTIFICATIONGRANULARITY,   FALSE, eNumeric,        -1 },
    { DBPROP_NOTIFICATIONPHASES,        FALSE, eNumeric,        -1 },
    { DBPROP_NOTIFYROWSETRELEASE,       FALSE, eNumeric,        -1 },
    { DBPROP_NOTIFYROWSETFETCHPOSITIONCHANGE,FALSE, eNumeric,   -1 },
//   9 additional notification properties, all unsupported

    { DBPROP_ORDEREDBOOKMARKS,          FALSE, eLocatable,      -1 }, 
    { DBPROP_OTHERINSERT,               FALSE, eAsynchronous,   -1 },
    { DBPROP_OTHERUPDATEDELETE,         FALSE, eAsynchronous,   -1 },
    { DBPROP_OWNINSERT,                 FALSE, eNotSupported,   -1 },
    { DBPROP_OWNUPDATEDELETE,           FALSE, eNotSupported,   -1 },
    { DBPROP_QUICKRESTART,              FALSE, eLocatable,      -1 },
    { DBPROP_REENTRANTEVENTS,           FALSE, eDefaultFalse,   -1 },
    { DBPROP_REMOVEDELETED,             FALSE, eDefaultTrue,    -1 },
    { DBPROP_REPORTMULTIPLECHANGES,     FALSE, eNotSupported,   -1 },
    { DBPROP_RETURNPENDINGINSERTS,      FALSE, eNotSupported,   -1 },
    { DBPROP_ROWRESTRICT,               FALSE, eDefaultTrue,    -1 },
    { DBPROP_ROWTHREADMODEL,            FALSE, eNumeric,        -1 },
    { DBPROP_SERVERCURSOR,              FALSE, eDefaultTrue,    -1 },
    { DBPROP_STRONGIDENTITY,            FALSE, eLocatable,      -1 },
    { DBPROP_TRANSACTEDOBJECT,          FALSE, eColumnProp,     -1 },
    { DBPROP_UPDATABILITY,              FALSE, eNumeric,        -1 },
    { DBPROP_ROWSET_ASYNCH,             TRUE,  eNumeric,        eid_PROPVAL_ROWSET_ASYNCH },

    //
    //  Supported interfaces
    //
    { DBPROP_IAccessor,                 FALSE, eDefaultTrue,    -1 },
    { DBPROP_IColumnsInfo,              FALSE, eDefaultTrue,    -1 },
    { DBPROP_IColumnsRowset,            FALSE, eNotSupported,   -1 },
    { DBPROP_IConnectionPointContainer, FALSE, eDefaultTrue,    -1 },
    { DBPROP_IConvertType,              FALSE, eDefaultTrue,    -1 },
    { DBPROP_IRowset,                   FALSE, eDefaultTrue,    -1 },
    { DBPROP_IRowsetIdentity,           TRUE,  eLocatable,      eid_PROPVAL_IRowsetIdentity },
    { DBPROP_IRowsetInfo,               FALSE, eDefaultTrue,    -1 },
    { DBPROP_IRowsetLocate,             TRUE,  eLocatable,      eid_PROPVAL_IRowsetLocate },
    { DBPROP_IRowsetScroll,             TRUE,  eScrollable,     eid_PROPVAL_IRowsetScroll },
    { DBPROP_IRowsetExactScroll,        TRUE,  eScrollable,     eid_PROPVAL_IRowsetExactScroll },
    { DBPROP_IDBAsynchStatus,           TRUE,  eAsynchronous,   eid_PROPVAL_IDBAsynchStatus },
    { DBPROP_IRowsetAsynch,             TRUE,  eAsynchronous,   eid_PROPVAL_IRowsetAsynch },  // deprecated
    { DBPROP_IRowsetWatchAll,           TRUE,  eWatchable,      eid_PROPVAL_IRowsetWatchAll },
    { DBPROP_IRowsetWatchRegion,        TRUE,  eWatchable,      eid_PROPVAL_IRowsetWatchRegion },
    { DBPROP_ISupportErrorInfo,         FALSE, eDefaultTrue,    -1 },
    { DBPROP_IChapteredRowset,          FALSE, eChaptered,      -1 },
};

const ULONG CMRowsetProps::cPropDescriptions =
                sizeof CMRowsetProps::aPropDescriptions /
                sizeof CMRowsetProps::aPropDescriptions[0];

//
//  This array gives the Index Server property extensions
//
const SPropDescription CMRowsetProps::aQueryExtPropDescriptions[] = {
    { DBPROP_USECONTENTINDEX,           TRUE, eUseCI,           eid_PROPVAL_USECONTENTINDEX },
    { DBPROP_DEFERNONINDEXEDTRIMMING,   TRUE, eDeferTrimming,   eid_PROPVAL_DEFERNONINDEXEDTRIMMING },
    { DBPROP_USEEXTENDEDDBTYPES,        TRUE, eExtendedTypes,   eid_PROPVAL_USEEXTENDEDDBTYPES },
};

const ULONG CMRowsetProps::cQueryExtPropDescriptions =
                sizeof CMRowsetProps::aQueryExtPropDescriptions /
                sizeof CMRowsetProps::aQueryExtPropDescriptions[0];


//
// This is used by CMRowsetProps.
//
static const UPROPSET s_rgRowsetPropSets[] =
{
&DBPROPSET_ROWSET,                  NUMELEM(s_rgdbPropRowset),          s_rgdbPropRowset,       0,
&DBPROPSET_MSIDXS_ROWSET_EXT,       NUMELEM(s_rgdbPropMSIDXSExt),       s_rgdbPropMSIDXSExt,    0,
&DBPROPSET_QUERY_EXT,               NUMELEM(s_rgdbPropQueryExt),        s_rgdbPropQueryExt,     0,
};

//
//  CMRowsetProps methods
//

//+---------------------------------------------------------------------------
//
//  Method:     CMRowsetProps::CMRowsetProps, public
//
//  Synopsis:   Constructor
//
//  History:    11-12-97    danleg      Created from Monarch
//
//----------------------------------------------------------------------------

CMRowsetProps::CMRowsetProps
    (
    LCID            lcidInit
    ) 
    :   CUtlProps(ARGCHK_PROPERTIESINERROR),
        _dwBooleanOptions ( 0)
{
    if ( lcidInit )
        _lcidInit = lcidInit;
    else
        _lcidInit = GetSystemDefaultLCID();

    FInit();
}


//+---------------------------------------------------------------------------
//
//  Method:     CMRowsetProps::CMRowsetProps, public
//
//  Synopsis:   Copy Constructor
//
//  History:    11-12-97    danleg      Created from Monarch
//
//----------------------------------------------------------------------------

CMRowsetProps::CMRowsetProps
    (
    const CMRowsetProps & propSrc
    ) 
    : CUtlProps(ARGCHK_PROPERTIESINERROR) 
{
    FInit( (CUtlProps*) &propSrc );
    _lcidInit = propSrc._lcidInit;
    _dwBooleanOptions = propSrc._dwBooleanOptions;
}

//+---------------------------------------------------------------------------
//
//  Method:     CMRowsetProps::SetChaptered, public
//
//  Arguments:  [fSet]  - set or unset this property
//
//  Synopsis:   
//
//  History:    02-20-98    danleg      Created
//
//----------------------------------------------------------------------------

DWORD CMRowsetProps::SetChaptered( BOOL fSet )
{
    SetValBool( CMRowsetProps::eid_DBPROPSET_ROWSET,
                CMRowsetProps::eid_PROPVAL_IChapteredRowset,
                fSet ? VARIANT_TRUE : VARIANT_FALSE );

    if ( fSet )
        _dwBooleanOptions |= eChaptered;
    else
        _dwBooleanOptions &= ~eChaptered;

    return _dwBooleanOptions;
}

//+---------------------------------------------------------------------------
//
//  Method:     CMRowsetProps::SetFirstRows, public
//
//  Arguments:  [ulFirstRows] - value of first rows
//
//  Synopsis:   Sets the FirstRows property
//
//  History:    07-11-2000    KitmanH      Created
//
//----------------------------------------------------------------------------

void CMRowsetProps::SetFirstRows( ULONG ulFirstRows )
{
    SetValLong( CMRowsetProps::eid_DBPROPSET_ROWSET,
                CMRowsetProps::eid_PROPVAL_FIRSTROWS,
                ulFirstRows );

    _dwBooleanOptions |= eFirstRows;
}

//+---------------------------------------------------------------------------
//
//  Method:     CMRowsetProps::SetImpliedProperties, public
//
//  Arguments:  [riidRowset]  - iid requested
//              [cRowsets]    - indication on whethere this is a chaptered 
//                              rowset
//  Synopsis: This routine does not set any properties in the property table.
//
//  History:    02-20-98    danleg      Created
//
//----------------------------------------------------------------------------

DWORD CMRowsetProps::SetImpliedProperties
    (
    REFIID riidRowset,
    ULONG cRowsets 
    )
{
    SPropDescription const * pPropDesc =  FindInterfaceDescription( riidRowset );

    if ( pPropDesc == 0 )
        THROW( CException(E_NOINTERFACE) );

    if ( pPropDesc->fSettable )
    {
        Win4Assert( pPropDesc->dwIndicator >= eSequential &&
                    pPropDesc->dwIndicator <= eWatchable );
        _dwBooleanOptions |= pPropDesc->dwIndicator;

        // make sure that the eid_ in aPropDescriptions is in the range

        Win4Assert( pPropDesc->uIndex < eid_PROPVAL_ROWSET_NUM );

        //
        // Set this property in the CMRowsetProps cache so we can later return it.
        //
        SetValBool( eid_DBPROPSET_ROWSET, pPropDesc->uIndex, VARIANT_TRUE );
    }
    else if ( pPropDesc->dwIndicator != eDefaultTrue &&
              !(pPropDesc->dwIndicator & _dwBooleanOptions) )
    {
        THROW( CException(E_NOINTERFACE) );
    }
    else
    {
        Win4Assert( pPropDesc->dwProp == DBPROP_IRowset ||
                    riidRowset == IID_IRowsetIdentity ||
                    riidRowset == IID_IRowsetInfo ||
                    riidRowset == IID_IColumnsInfo ||
                    riidRowset == IID_IConvertType ||
                    riidRowset == IID_IAccessor ||
                    riidRowset == IID_IConnectionPointContainer );
        _dwBooleanOptions |= eSequential;
    }

    if ( cRowsets > 1 )
        _dwBooleanOptions |= eChaptered;

    //
    //  Interface indicators are arranged in a hierarchy from most general
    //  to most specialized.  Arrange that all more general interfaces are
    //  included in the properties.
    //
    for ( unsigned i = eWatchable; i > eSequential; 
          i = (i >> 1) )
    {
        if ( _dwBooleanOptions & i )
            _dwBooleanOptions |= (i >> 1);
    }

    Win4Assert( _dwBooleanOptions & eSequential );
 
    //
    // Scrollable
    // IRowsetScroll or IRowsetExactScroll were set.  IRowsetLocate is implied.
    //
    if ( _dwBooleanOptions & eScrollable )
    {
        // IRowsetScroll is user settable.  Make sure that it wasn't explicitly unset.
        if ( DBPROPOPTIONS_REQUIRED != GetPropOption( eid_DBPROPSET_ROWSET, eid_PROPVAL_IRowsetScroll) ) 
        {
            SetValBool( eid_DBPROPSET_ROWSET, eid_PROPVAL_IRowsetScroll, VARIANT_TRUE );
            SetPropOption( eid_DBPROPSET_ROWSET, eid_PROPVAL_IRowsetScroll, DBPROPOPTIONS_REQUIRED );
        }

        // IRowsetLocate is settable.  Make sure it wasn't explicitly unset.
        if ( DBPROPOPTIONS_REQUIRED != GetPropOption( eid_DBPROPSET_ROWSET, eid_PROPVAL_IRowsetLocate) )
        {
            DWORD dwOption = GetPropOption( eid_DBPROPSET_ROWSET, eid_PROPVAL_IRowsetScroll);
            SetValBool( eid_DBPROPSET_ROWSET, eid_PROPVAL_IRowsetLocate, VARIANT_TRUE );
            SetPropOption( eid_DBPROPSET_ROWSET, eid_PROPVAL_IRowsetLocate, dwOption );
        }
    }

    //
    // Locatable 
    //
    if ( _dwBooleanOptions & eLocatable )
    {
        // these are not user settable
        SetValBool( eid_DBPROPSET_ROWSET, eid_PROPVAL_CANFETCHBACKWARDS, VARIANT_TRUE );
        SetValBool( eid_DBPROPSET_ROWSET, eid_PROPVAL_CANSCROLLBACKWARDS, VARIANT_TRUE );
        SetValBool( eid_DBPROPSET_ROWSET, eid_PROPVAL_LITERALIDENTITY, VARIANT_TRUE );
        SetValBool( eid_DBPROPSET_ROWSET, eid_PROPVAL_ORDEREDBOOKMARKS, VARIANT_TRUE );
        SetValBool( eid_DBPROPSET_ROWSET, eid_PROPVAL_QUICKRESTART, VARIANT_TRUE );
        SetValBool( eid_DBPROPSET_ROWSET, eid_PROPVAL_STRONGIDENTITY, VARIANT_TRUE );

        // eLocateable (IRowsetLocate or IRowsetIdentity are set).  IRowsetLocate implies BOOKMARKS
        if ( VARIANT_TRUE == GetValBool(eid_DBPROPSET_ROWSET, eid_PROPVAL_IRowsetLocate) )
        {
            // BOOKMARKs is settable.  Make sure it hasn't already been set to FALSE/REQUIRED
            if ( DBPROPOPTIONS_REQUIRED != GetPropOption( eid_DBPROPSET_ROWSET, eid_PROPVAL_BOOKMARKS) )
            {
                DWORD dwOption = GetPropOption( eid_DBPROPSET_ROWSET, eid_PROPVAL_IRowsetLocate );
                SetValBool( eid_DBPROPSET_ROWSET, eid_PROPVAL_BOOKMARKS, VARIANT_TRUE );
                SetPropOption( eid_DBPROPSET_ROWSET, eid_PROPVAL_BOOKMARKS, dwOption );
            }
        }
    }
    else
    {
        SetValBool( eid_DBPROPSET_ROWSET, eid_PROPVAL_CANFETCHBACKWARDS, VARIANT_FALSE );
        SetValBool( eid_DBPROPSET_ROWSET, eid_PROPVAL_CANSCROLLBACKWARDS, VARIANT_FALSE );
        SetValBool( eid_DBPROPSET_ROWSET, eid_PROPVAL_LITERALIDENTITY, VARIANT_FALSE );
        SetValBool( eid_DBPROPSET_ROWSET, eid_PROPVAL_ORDEREDBOOKMARKS, VARIANT_FALSE );
        SetValBool( eid_DBPROPSET_ROWSET, eid_PROPVAL_QUICKRESTART, VARIANT_FALSE );
        SetValBool( eid_DBPROPSET_ROWSET, eid_PROPVAL_STRONGIDENTITY, VARIANT_FALSE );
    }

    //
    // Asynchronous
    //
    if ( _dwBooleanOptions & eAsynchronous )
    {
        SetValBool( eid_DBPROPSET_ROWSET, eid_PROPVAL_OTHERINSERT, VARIANT_TRUE );
        SetValBool( eid_DBPROPSET_ROWSET, eid_PROPVAL_OTHERUPDATEDELETE, VARIANT_TRUE );
    }
    else
    {
        SetValBool( eid_DBPROPSET_ROWSET, eid_PROPVAL_OTHERINSERT, VARIANT_FALSE );
        SetValBool( eid_DBPROPSET_ROWSET, eid_PROPVAL_OTHERUPDATEDELETE, VARIANT_FALSE );
    }

    return _dwBooleanOptions;
}


//+---------------------------------------------------------------------------
//
//  Method:     CMRowsetProps::FindPropertyDescription, private
//
//  Synopsis:   Return description of a propery.
//
//  Arguments:  [rgPropDesc]  - array of property descriptions for propset
//              [cPropDesc]   - count of property descriptions in rgPropDesc
//              [dwPropId]    - ID of the property description desired
//
//  Returns:    pointer to SPropDescription or NULL
//
//  History:    19 Nov 95   AlanW       Created
//
//----------------------------------------------------------------------------

SPropDescription const *  CMRowsetProps::FindPropertyDescription(
    SPropDescription const * rgPropDesc,
    unsigned cPropDesc,
    DBPROPID dwPropId )
{
    SPropDescription const * pPropDesc = rgPropDesc;

    for (unsigned i=0; i < cPropDesc; i++, pPropDesc++)
    {
        if (pPropDesc->dwProp == dwPropId)
            return pPropDesc;
    }
    return 0;
}


const struct SIidLookup {
    const GUID * riid;
    DBPROPID dwPropId;
} aIidLookup[] =  {
    { &IID_IAccessor, DBPROP_IAccessor },
    { &IID_IColumnsInfo, DBPROP_IColumnsInfo },
    { &IID_IColumnsRowset, DBPROP_IColumnsRowset },
    { &IID_IConnectionPointContainer, DBPROP_IConnectionPointContainer },
    { &IID_IConvertType, DBPROP_IConvertType },
//    { &IID_ICopyColumn, DBPROP_ICopyColumn },
    { &IID_IRowset, DBPROP_IRowset },
    { &IID_IRowsetIdentity, DBPROP_IRowsetIdentity },
    { &IID_IRowsetInfo, DBPROP_IRowsetInfo },
    { &IID_IRowsetLocate, DBPROP_IRowsetLocate },
    { &IID_IRowsetScroll, DBPROP_IRowsetScroll },
    { &IID_IRowsetExactScroll, DBPROP_IRowsetExactScroll }, // deprecated
    { &IID_IDBAsynchStatus, DBPROP_IDBAsynchStatus },
    { &IID_IRowsetAsynch, DBPROP_IRowsetAsynch },        // deprecated
    { &IID_IRowsetWatchAll, DBPROP_IRowsetWatchAll },
    { &IID_IRowsetWatchRegion, DBPROP_IRowsetWatchRegion },
    { &IID_IUnknown, DBPROP_IRowset },
    { &IID_NULL, DBPROP_IRowset },
};

const unsigned cIidLookup = sizeof aIidLookup / sizeof aIidLookup[0];

//+---------------------------------------------------------------------------
//
//  Method:     CMRowsetProps::FindInterfaceDescription, private
//
//  Synopsis:   Return property description corresponding to an interface
//
//  Arguments:  [riid]  - REFIID of interface to be looked up
//
//  Returns:    pointer to SPropDescription or NULL
//
//  History:    26 Sep 96   AlanW       Created
//
//----------------------------------------------------------------------------

SPropDescription const *  CMRowsetProps::FindInterfaceDescription(
    REFIID riid )
{
    for (unsigned i=0; i < cIidLookup; i++)
    {
        if (riid == *aIidLookup[i].riid)
            return FindPropertyDescription( aPropDescriptions,
                                            cPropDescriptions,
                                            aIidLookup[i].dwPropId );
    }
    return 0;
}

//+---------------------------------------------------------------------------
//
//  Method:     CMRowsetProps::UpdateBooleanOptions, private
//
//  Synopsis:   Update _dwBooleanOptions to reflect newly set properties.
//              Look for conflicting properties and mark them as such.
//
//  History:    03-02-98    danleg      Created
//
//----------------------------------------------------------------------------

void CMRowsetProps::UpdateBooleanOptions
    (
    const ULONG cPropertySets, 
    const DBPROPSET rgPropertySets[] 
    )
{
    SCODE sc = S_OK;

    DWORD dwSetOptions = 0;
    DWORD dwUnsetOptions = 0;
    DWORD dwOption = 0;

    // 
    // table for boolean options
    //
    for ( unsigned i=0; i<cPropertySets; i++ )
    {
        SPropDescription const * pPropDesc = 0;
        unsigned cPropDesc = 0;

        unsigned cProp = rgPropertySets[i].cProperties;
        DBPROP * pProp = rgPropertySets[i].rgProperties;

        if ( DBPROPSET_ROWSET == rgPropertySets[i].guidPropertySet )
        {
            pPropDesc = aPropDescriptions;
            cPropDesc = cPropDescriptions;
        }
        else if ( DBPROPSET_QUERY_EXT == rgPropertySets[i].guidPropertySet )
        {
            pPropDesc = aQueryExtPropDescriptions;
            cPropDesc = cQueryExtPropDescriptions;
        }
        else
        {
            // no properties here of interest to boolean options
            continue;
        }

        for ( unsigned j=0; j<cProp; j++, pProp++ )
        {
            if ( DBPROPSTATUS_OK == pProp->dwStatus )
            {
                //
                // determine the flag to set for this property
                //
                SPropDescription const * pFoundDesc =
                    FindPropertyDescription ( pPropDesc,
                                              cPropDesc,
                                              pProp->dwPropertyID );
                if ( 0 != pFoundDesc )
                {
                    // Setting read-only props to their default value succeeds
                    if ( !pFoundDesc->fSettable )
                        continue;

                    dwOption = pFoundDesc->dwIndicator;

                    //
                    // Settable properties with special option flags
                    //
                    switch ( pProp->dwPropertyID )
                    {
                        case DBPROP_COMMANDTIMEOUT:
                        case DBPROP_MAXROWS:
                        case DBPROP_MEMORYUSAGE:
                            continue;
                            
                        case DBPROP_FIRSTROWS:
                            dwOption = eFirstRows;
                            break;

                        case DBPROP_ROWSET_ASYNCH:
                            dwOption = eAsynchronous;
                            break;
                            
                        default:
                            // no other settable props that need special handling
                            break;
                    }

                    //
                    // determine if the property was set or unset
                    //
                    switch ( V_VT(&(pProp->vValue)) )
                    {
                        case VT_BOOL:
                            if ( VARIANT_FALSE == V_BOOL(&(pProp->vValue)) )
                                dwUnsetOptions |= dwOption;
                            else
                                dwSetOptions |= dwOption;
                            break;

                        case VT_I4:
                            if ( DBPROPSET_ROWSET == rgPropertySets[i].guidPropertySet  &&
                                 ( DBPROP_ROWSET_ASYNCH == pProp->dwPropertyID ||
                                   DBPROP_FIRSTROWS == pProp->dwPropertyID ) )
                            {
                                if ( 0 == V_I4(&(pProp->vValue)) )
                                    dwUnsetOptions |= dwOption;
                                else
                                    dwSetOptions |= dwOption;
                            }
                            break;

                        case VT_EMPTY:
                            // assume to mean unset
                            dwUnsetOptions |= dwOption;
                            break;

                        default:
                            break;
                    }
                }
                else
                {
                    // This should never get hit since the property was set successfully.
                    Win4Assert( ! "_rgdbPropRowset and aPropDescriptions are out of sync." );
                }
            }
        }
    }

    Win4Assert( (dwSetOptions & dwUnsetOptions) == 0 );
    if ( dwSetOptions & eScrollable )
    {
        dwUnsetOptions |= eSequential;
    }
    else if ( dwSetOptions & eSequential )
    {
        dwUnsetOptions |= eScrollable;
    }

    //
    // If IRowsetLocate and/or BOOKMARKS were explicitly set, and
    // IRowsetIdentity is being unset, don't take of the eLocatable bit
    //
    if ( dwUnsetOptions & eLocatable )
    {
        if ( VARIANT_TRUE == GetValBool(eid_DBPROPSET_ROWSET, eid_PROPVAL_IRowsetLocate) ||
             VARIANT_TRUE == GetValBool(eid_DBPROPSET_ROWSET, eid_PROPVAL_BOOKMARKS) )
            dwUnsetOptions &= ~eLocatable;
    }

    _dwBooleanOptions &= ~dwUnsetOptions;
    _dwBooleanOptions |= dwSetOptions;
}

//+---------------------------------------------------------------------------
//
//  Method:     CMRowsetProps::SetProperties, public
//
//  Synopsis:   
//
//  History:    02-15-98    danleg      Created
//
//----------------------------------------------------------------------------

SCODE CMRowsetProps::SetProperties
    ( 
    const ULONG cPropertySets, 
    const DBPROPSET rgPropertySets[] 
    )
{
    SCODE sc        = S_OK;
    ULONG cPropSets = cPropertySets;

    sc = CUtlProps::SetProperties( cPropertySets, rgPropertySets );

    if ( FAILED(sc) )
        return sc;

    //
    // Some or all of the properties were set successfully.  
    // Update _dwBooleanOptions.
    //
    UpdateBooleanOptions( cPropertySets, rgPropertySets );

    return sc;
}

//+---------------------------------------------------------------------------
//
//  Method:     CMRowsetProps::ArePropsInError, public
//
//  Synopsis:   Update _dwBooleanOptions to reflect newly set properties.
//              Look for conflicting properties and mark them as such.
//
//  History:    03-02-98    danleg      Created
//
//----------------------------------------------------------------------------

SCODE CMRowsetProps::ArePropsInError
    (
    CMRowsetProps & rProps
    )
{
    unsigned cErrors = 0;

    //
    // DBPROP_IRowsetScroll --> DBPROP_IRowsetLocate
    //
    if( VARIANT_TRUE == GetValBool(eid_DBPROPSET_ROWSET,eid_PROPVAL_IRowsetScroll) &&
        DBPROPOPTIONS_REQUIRED == GetPropOption(eid_DBPROPSET_ROWSET, eid_PROPVAL_IRowsetScroll) )
    {
        // IRowsetLocate should also be set to TRUE/REQUIRED
        if ( VARIANT_FALSE == GetValBool(eid_DBPROPSET_ROWSET, eid_PROPVAL_IRowsetLocate) &&
             DBPROPOPTIONS_REQUIRED == GetPropOption(eid_DBPROPSET_ROWSET, eid_PROPVAL_IRowsetLocate) )
        {
            rProps.SetPropertyInError( eid_DBPROPSET_ROWSET, eid_PROP_IRowsetScroll );
            rProps.SetPropertyInError( eid_DBPROPSET_ROWSET, eid_PROP_IRowsetLocate );
            cErrors++;
        }

        // BOOKMARKS should also be set to TRUE/REQUIRED
        if ( VARIANT_FALSE == GetValBool(eid_DBPROPSET_ROWSET, eid_PROPVAL_BOOKMARKS) &&
             DBPROPOPTIONS_REQUIRED == GetPropOption(eid_DBPROPSET_ROWSET, eid_PROPVAL_BOOKMARKS) )
        {
            rProps.SetPropertyInError( eid_DBPROPSET_ROWSET, eid_PROP_BOOKMARKS );
            rProps.SetPropertyInError( eid_DBPROPSET_ROWSET, eid_PROP_IRowsetScroll );
            cErrors++;
        }
    }

    //
    // DBPROP_IRowsteLocate --> DBPROP_BOOKMARKS
    //
    if( VARIANT_TRUE == GetValBool(eid_DBPROPSET_ROWSET,eid_PROPVAL_IRowsetLocate) &&
        DBPROPOPTIONS_REQUIRED == GetPropOption(eid_DBPROPSET_ROWSET, eid_PROPVAL_IRowsetLocate) )
    {
        // BOOKMARKS should also be set to TRUE/REQUIRED
        if ( VARIANT_FALSE == GetValBool(eid_DBPROPSET_ROWSET, eid_PROPVAL_BOOKMARKS) &&
             DBPROPOPTIONS_REQUIRED == GetPropOption(eid_DBPROPSET_ROWSET, eid_PROPVAL_BOOKMARKS) )
        {
            rProps.SetPropertyInError( eid_DBPROPSET_ROWSET, eid_PROP_BOOKMARKS );
            rProps.SetPropertyInError( eid_DBPROPSET_ROWSET, eid_PROP_IRowsetLocate );
            cErrors++;
        }
    }

    return ( cErrors ) ? DB_E_ERRORSOCCURRED 
                       : S_OK;
}

//+---------------------------------------------------------------------------
//
//  Method:     CMRowsetProps::InitAvailUPropsets, private
//
//  Synopsis:   Provide property set information to the base class
//
//  History:    11-12-97    danleg      Created from Monarch
//
//----------------------------------------------------------------------------

SCODE CMRowsetProps::InitAvailUPropSets
    (
    ULONG*          pcUPropSet, 
    UPROPSET**      ppUPropSet,
    ULONG*          pcElemPerSupported
    )
{
    Win4Assert( pcUPropSet && ppUPropSet);
    Win4Assert( NUMELEM(s_rgdbPropRowset) == eid_ROWSET_PROPS_NUM );
    Win4Assert( NUMELEM(s_rgdbPropQueryExt) == eid_QUERYEXT_PROPS_NUM );
    Win4Assert( NUMELEM(s_rgdbPropMSIDXSExt) == eid_MSIDXS_PROPS_NUM );

    *pcUPropSet = NUMELEM(s_rgRowsetPropSets);
    *ppUPropSet = (UPROPSET*)s_rgRowsetPropSets;
    *pcElemPerSupported = DWORDSNEEDEDPERSET; 

    return S_OK;
}


//+---------------------------------------------------------------------------
//
//  Method:     CMRowsetProps::InitUPropSetsSupported, private
//
//  Synopsis:   Build the required supported property bitmask for the property
//              set supported by this class
//
//  History:    11-12-97    danleg      Created from Monarch
//
//----------------------------------------------------------------------------

SCODE CMRowsetProps::InitUPropSetsSupported
    (
    DWORD* rgdwSupported
    )
{
    Win4Assert( rgdwSupported );

    // Initialize the bitmask to indicate all properties are supported
    RtlFillMemory( rgdwSupported, 
                   DWORDSNEEDEDPERSET * NUMELEM(s_rgRowsetPropSets) * sizeof(DWORD), 
                   0xFF ); 

    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Method:     CMRowsetProps::GetDefaultValue, private
//
//  Synopsis:   Retrieve the initial value for a propid.
//              DEVNOTE:  Using the index from 0 to (GetCountofAvailPropSets-1)
//                        and an index of 0 to (GetCountofAvailPropidsInPropset-1)
//                        within that propertyset, return the correct information.
//                        NOTE: pVar should be initialized prior to this routine.
//
//  History:    11-12-97    danleg      Created from Monarch
//
//----------------------------------------------------------------------------

SCODE CMRowsetProps::GetDefaultValue
    (
    ULONG       iCurSet,
    DBPROPID    dwPropId,
    DWORD*      pdwOption,
    VARIANT*    pvValue
    )
{
    Win4Assert( V_VT(pvValue) == VT_EMPTY );

    switch( iCurSet )
    {
        case eid_DBPROPSET_ROWSET:
            *pdwOption = DBPROPOPTIONS_REQUIRED;
            switch ( dwPropId )
            {
                // default TRUE values, non-writable
                case DBPROP_IAccessor:
                case DBPROP_IColumnsInfo:
                case DBPROP_IConnectionPointContainer:
                case DBPROP_IConvertType:
                case DBPROP_IRowset:
                case DBPROP_IRowsetInfo:
                case DBPROP_ISupportErrorInfo:
                case DBPROP_REMOVEDELETED:
                case DBPROP_ROWRESTRICT:
                case DBPROP_SERVERCURSOR:
                    V_VT( pvValue )     = VT_BOOL;
                    V_BOOL( pvValue )   = VARIANT_TRUE;
                    break;

                case DBPROP_IChapteredRowset:
                    V_VT( pvValue )     = VT_BOOL;
                    V_BOOL( pvValue )   = VARIANT_FALSE;
                    break;
                // default FALSE non-writable
                case DBPROP_BLOCKINGSTORAGEOBJECTS:
                case DBPROP_BOOKMARKSKIPPED:
                case DBPROP_CANFETCHBACKWARDS:
                case DBPROP_CANSCROLLBACKWARDS:
                case DBPROP_COLUMNRESTRICT:
                case DBPROP_LITERALBOOKMARKS:
                case DBPROP_LITERALIDENTITY:
                case DBPROP_ORDEREDBOOKMARKS:
                case DBPROP_OTHERINSERT:
                case DBPROP_OTHERUPDATEDELETE:
                case DBPROP_REENTRANTEVENTS:
                case DBPROP_STRONGIDENTITY:
                case DBPROP_QUICKRESTART:
                    V_VT( pvValue )     = VT_BOOL;
                    V_BOOL( pvValue )   = VARIANT_FALSE;
                    break;

                // default FALSE, writable
                case DBPROP_BOOKMARKS:
                case DBPROP_CANHOLDROWS:
                case DBPROP_IDBAsynchStatus:
                case DBPROP_IRowsetAsynch:
                case DBPROP_IRowsetExactScroll:
                case DBPROP_IRowsetIdentity:
                case DBPROP_IRowsetScroll:
                case DBPROP_IRowsetWatchAll:
                case DBPROP_IRowsetWatchRegion:
                case DBPROP_IRowsetLocate:
                    *pdwOption          = DBPROPOPTIONS_OPTIONAL;
                    V_VT( pvValue )     = VT_BOOL;
                    V_BOOL( pvValue )   = VARIANT_FALSE;
                    break;

                case DBPROP_BOOKMARKTYPE:
                    V_VT( pvValue )     = VT_I4;
                    V_I4( pvValue )     = DBPROPVAL_BMK_NUMERIC;
                    break;

                case DBPROP_COMMANDTIMEOUT:
                case DBPROP_MAXOPENROWS:
                case DBPROP_MAXROWS:
                case DBPROP_FIRSTROWS:
                case DBPROP_MEMORYUSAGE:
                case DBPROP_ROWSET_ASYNCH:
                case DBPROP_UPDATABILITY:
                    V_VT( pvValue )     = VT_I4;
                    V_I4( pvValue )     = 0;        
                    break;

                case DBPROP_ROWTHREADMODEL:
                    V_VT( pvValue )     = VT_I4;
                    V_I4( pvValue )     = DBPROPVAL_RT_FREETHREAD;
                    break;

                case DBPROP_NOTIFICATIONPHASES:
                    V_VT( pvValue )     = VT_I4;
                    V_I4( pvValue )     = DBPROPVAL_NP_OKTODO |
                                          DBPROPVAL_NP_ABOUTTODO |
                                          DBPROPVAL_NP_FAILEDTODO |
                                          DBPROPVAL_NP_DIDEVENT;
                    break;

                case DBPROP_NOTIFYROWSETRELEASE:
                    V_VT( pvValue )     = VT_I4;
                    V_I4( pvValue )     = 0;
                    break;

                case DBPROP_NOTIFYROWSETFETCHPOSITIONCHANGE:
                    V_VT( pvValue )     = VT_I4;
                    V_I4( pvValue )     = DBPROPVAL_NP_OKTODO |
                                          DBPROPVAL_NP_ABOUTTODO;
                    break;

                case DBPROP_CACHEDEFERRED:
                case DBPROP_DEFERRED:
                default:
                    // one of the unsupported properties
                    VariantClear( pvValue );
                    break;

            }
            break;

        case eid_DBPROPSET_QUERY_EXT:
            *pdwOption          = DBPROPOPTIONS_REQUIRED;

            // 
            // All three properties under this property set are BOOL/FALSE by default
            //
            V_VT( pvValue )     = VT_BOOL;
            V_BOOL( pvValue )   = VARIANT_FALSE;
            break;

        case eid_DBPROPSET_MSIDXS_ROWSET_EXT:
            *pdwOption = DBPROPOPTIONS_REQUIRED;
            switch( dwPropId )
            {
                case MSIDXSPROP_ROWSETQUERYSTATUS:
                    V_VT(pvValue)   = VT_I4;
                    V_I4(pvValue)   = 0;
                    break;
                case MSIDXSPROP_COMMAND_LOCALE_STRING:
                    *pdwOption = DBPROPOPTIONS_OPTIONAL;
                    V_VT(pvValue)   = VT_BSTR;
                    WCHAR awcLocale[100];

                    GetStringFromLCID(_lcidInit, awcLocale );
                    V_BSTR(pvValue) = SysAllocString( awcLocale );

                    if ( 0 == V_BSTR(pvValue) )
                        return E_OUTOFMEMORY;
                    break;
                case MSIDXSPROP_QUERY_RESTRICTION:
                    V_VT(pvValue)   = VT_BSTR;
                    V_BSTR(pvValue) = SysAllocString(L"");
                    if ( 0 == V_BSTR(pvValue) )
                        return E_OUTOFMEMORY;
                    break;
                default:
                    //Indicate that value is unknown
                    VariantClear(pvValue);
                    break;
            }
            break;

        default:
            // Invalid Property Set
            Win4Assert( ! "Invalid property set in GetDefaultValue.");
            return E_FAIL;
    }

    return S_OK;
}


//+---------------------------------------------------------------------------
//
//  Method:     CMRowsetProps::IsValidValue, private
//
//  Synopsis:   Validate that the variant contains legal values for its 
//              particular type and for the particular PROPID in this propset.
//              Devnote: This routine has to apply to writable properties only.
//
//  History:    11-12-97    danleg      Created from Monarch
//              02-01-98    danleg      Added support for DBPROPSET_ROWSET
//                                      and DBPROPSET_QUERYEXT
//
//----------------------------------------------------------------------------

SCODE CMRowsetProps::IsValidValue
    (
    ULONG       iCurSet,
    DBPROP*     pDBProp
    )
{
    switch ( V_VT(&(pDBProp->vValue)) )
    {
        case VT_BOOL:
            if ( !( VARIANT_TRUE  == V_BOOL(&(pDBProp->vValue)) ||
                    VARIANT_FALSE == V_BOOL(&(pDBProp->vValue)) ) )
                return S_FALSE;
            break;

        case VT_I4:
            switch ( iCurSet )
            {
                case eid_DBPROPSET_ROWSET:
                    switch ( pDBProp->dwPropertyID )
                    {
                        case DBPROP_BOOKMARKTYPE:
                            if ( !(DBPROPVAL_BMK_NUMERIC == V_I4(&(pDBProp->vValue)) ||
                                   DBPROPVAL_BMK_KEY     == V_I4(&(pDBProp->vValue)) ) )
                                return S_FALSE;
                            break;

                        case DBPROP_ROWSET_ASYNCH:
                            switch ( V_I4(&(pDBProp->vValue)) )
                            {
                                case ( DBPROPVAL_ASYNCH_SEQUENTIALPOPULATION |
                                       DBPROPVAL_ASYNCH_RANDOMPOPULATION ):
                                case DBPROPVAL_ASYNCH_RANDOMPOPULATION:
                                case 0:  // means sequential init and population
                                    break;

                                case DBPROPVAL_ASYNCH_INITIALIZE:
                                case DBPROPVAL_ASYNCH_SEQUENTIALPOPULATION:
                                default:
                                    return S_FALSE;

                            }
                            break;

                        case DBPROP_ROWTHREADMODEL:
                            // this is a r/o property, set to FREETHREAD by default.
                            switch ( V_I4(&(pDBProp->vValue)) )
                            {
                                case DBPROPVAL_RT_FREETHREAD:
                                case DBPROPVAL_RT_APTMTTHREAD:
                                case DBPROPVAL_RT_SINGLETHREAD:
                                    break;

                                default:
                                    return S_FALSE;
                            }
                            break;

                        case DBPROP_MEMORYUSAGE:
                            if ( 0  > V_I4(&(pDBProp->vValue)) ||
                                 99 < V_I4(&(pDBProp->vValue)) )
                                 return S_FALSE;
                            break;

                        case DBPROP_COMMANDTIMEOUT:
                        case DBPROP_MAXROWS:
                        case DBPROP_FIRSTROWS:
                            if ( 0 > V_I4(&(pDBProp->vValue)) )
                                return S_FALSE;
                            break;

                        case DBPROP_UPDATABILITY:
                            // this is the only other supported VT_I4 property
                            break;

                        default:
                            //  no other VT_I4 properties in DBPROPSET_ROWSET
                            return S_FALSE;
                    }
                    break;

                case eid_DBPROPSET_MSIDXS_ROWSET_EXT:
                    if ( MSIDXSPROP_ROWSETQUERYSTATUS != pDBProp->dwPropertyID )
                        return S_FALSE;
                    break;

                default:
                    return S_FALSE;
            }
            break; // VT_I4

        case VT_BSTR:
            switch ( iCurSet )
            {
                case eid_DBPROPSET_MSIDXS_ROWSET_EXT:
                    switch ( pDBProp->dwPropertyID )
                    {
                        case MSIDXSPROP_COMMAND_LOCALE_STRING:
                            if ( 0 == V_BSTR(&(pDBProp->vValue)) ||
                                 InvalidLCID == GetLCIDFromString(V_BSTR(&(pDBProp->vValue))) )
                                return S_FALSE;
                            break;

                        case MSIDXSPROP_QUERY_RESTRICTION:
                            // any bstr is valid
                            break;

                        default:
                            // there are no other bstr properties in this property set
                            return S_FALSE;
                    }
                    break;

                default:
                    // the other two prop sets don't have any VT_BSTR properties
                    return S_FALSE;
            }
            break;

        case VT_EMPTY:
            // always valid
            break;

        default:
            // no other types are supported
            return S_FALSE;
    } 

    return S_OK;    // Is valid
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\icommand\queryunk.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       QueryUnk.cxx
//
//  Contents:   Controlling IUnknown interface for IQuery/IRowset
//
//  History:    18 Jul 1995    AlanW     Created
//
//--------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include <rowset.hxx>

#include "queryunk.hxx"

//+-------------------------------------------------------------------------
//
//  Member:     CQueryUnknown::QueryInterface, public
//
//  Arguments:  [ifid]  -- Interface id
//              [ppiuk] -- Interface return pointer
//
//  Returns:    Error.  No rebind from this class is supported.
//
//  History:    18 Jul 1995    AlanW     Created
//
//--------------------------------------------------------------------------

STDMETHODIMP CQueryUnknown::QueryInterface( REFIID ifid, void ** ppiuk )
{
    *ppiuk = 0;
    return E_NOINTERFACE;
}


//+-------------------------------------------------------------------------
//
//  Member:     CQueryUnknown::AddRef, public
//
//  Synopsis:   Reference the virtual table.
//
//  History:    18 Jul 1995    AlanW     Created
//
//--------------------------------------------------------------------------

STDMETHODIMP_(ULONG) CQueryUnknown::AddRef(void)
{
    return InterlockedIncrement( (long *)&_ref );
}

//+-------------------------------------------------------------------------
//
//  Member:     CQueryUnknown::Release, public
//
//  Synopsis:   De-Reference the virtual table.
//
//  Effects:    If the ref count goes to 0 then the table is deleted.
//
//  History:    18 Jul 1995    AlanW     Created
//
//--------------------------------------------------------------------------

STDMETHODIMP_(ULONG) CQueryUnknown::Release(void)
{
    long l = InterlockedDecrement( (long *)&_ref );

    if ( l <= 0 )
    {
        // delete the rowsets allocated (if any)

        ReInit();
        _rUnk.Release();    // final reference, drop the owner's refcount

        return 0;
    }

    return l;
}


//+-------------------------------------------------------------------------
//
//  Member:     CQueryUnknown::ReInit, public
//
//  Synopsis:   Prepares for execution of a new query
//
//  Arguments:  [cRowsets]    -- # of rowsets in ppRowsets
//              [ppRowsets]   -- Array of CRowset pointers
//
//  History:    18 Jul 1995    AlanW     Created
//
//--------------------------------------------------------------------------

void CQueryUnknown::ReInit( ULONG              cRowsets,
                            CRowset **         ppRowsets )
{
    for (unsigned i = 0; i < _cRowsets; i++)
        delete _apRowsets[i];

    delete [] _apRowsets;
    Win4Assert(_ref == 0 || _ref == cRowsets);
    if (cRowsets == 0)
        _ref = 0;

    _cRowsets = cRowsets;
    _apRowsets = ppRowsets;

    if (cRowsets > 0)
        _rUnk.AddRef();
}


//+-------------------------------------------------------------------------
//
//  Member:     CQueryUnknown::~CQueryUnknown, private
//
//  Synopsis:   Clean up
//
//  History:    18-Jun-93 KyleP     Created
//
//--------------------------------------------------------------------------

CQueryUnknown::~CQueryUnknown()
{
    ReInit();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\icommand\propinfr.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft OLE DB
//  Copyright (C) Microsoft Corporation, 1994 - 2000
//
// @doc
//
// @module PROPINFR.MC | Messages.
// 
// @rev 1 | 08-04-97  | danleg   | Created.
//-----------------------------------------------------------------------------


#ifndef __PROPINFR_H__
#define __PROPINFR_H__

//----------------------------------------------------------------------------
//Language-dependent resources (localize)
//----------------------------------------------------------------------------


// DATASOURCE

#define	DESC_DBPROP_CURRENTCATALOG  	L"Current Catalog"

#define	DESC_DBPROP_RESETDATASOURCE	L"Reset Datasource"

// DATASOURCEINFO

#define	DESC_DBPROP_ACTIVESESSIONS  	L"Active Sessions"

#define	DESC_DBPROP_BYREFACCESSORS  	L"Pass By Ref Accessors"

#define	DESC_DBPROP_CATALOGLOCATION 	L"Catalog Location"

#define	DESC_DBPROP_CATALOGTERM 	L"Catalog Term"

#define	DESC_DBPROP_CATALOGUSAGE    	L"Catalog Usage"

#define	DESC_DBPROP_COLUMNDEFINITION	L"Column Definition"

#define	DESC_DBPROP_DATASOURCEREADONLY 	L"Read-Only Data Source"

#define	DESC_DBPROP_DBMSNAME    	L"DBMS Name"

#define	DESC_DBPROP_DBMSVER 		L"DBMS Version"

#define	DESC_DBPROP_GROUPBY 		L"GROUP BY Support"

#define	DESC_DBPROP_HETEROGENEOUSTABLES 	L"Heterogeneous Table Support"

#define	DESC_DBPROP_MAXOPENCHAPTERS 	L"Maximum Open Chapters"

#define	DESC_DBPROP_MAXROWSIZE  	L"Maximum Row Size"

#define	DESC_DBPROP_MAXTABLESINSELECT  	L"Maximum Tables in SELECT"

#define	DESC_DBPROP_MULTIPLESTORAGEOBJECTS  	L"Multiple Storage Objects"

#define	DESC_DBPROP_NULLCOLLATION   	L"NULL Collation Order"

#define	DESC_DBPROP_OLEOBJECTS  	L"OLE Object Support"

#define	DESC_DBPROP_ORDERBYCOLUMNSINSELECT  	L"ORDER BY Columns in Select List"

#define	DESC_DBPROP_PROVIDEROLEDBVER   	L"OLE DB Version"

#define	DESC_DBPROP_PROVIDERFRIENDLYNAME	L"Provider Friendly Name"

#define	DESC_DBPROP_PROVIDERNAME    	L"Provider Name"

#define	DESC_DBPROP_PROVIDERVER 	L"Provider Version"

#define	DESC_DBPROP_SQLSUPPORT  	L"SQL Support"

#define	DESC_DBPROP_STRUCTUREDSTORAGE  	L"Structured Storage"

#define	DESC_DBPROP_SUBQUERIES  	L"Subquery Support"

#define	DESC_DBPROP_SUPPORTEDTXNISOLEVELS   	L"Isolation Levels"

#define	DESC_DBPROP_SUPPORTEDTXNISORETAIN   	L"Isolation Retention"

#define	DESC_DBPROP_SUPPORTEDTXNDDL 	L"Transaction DDL"

#define	DESC_DBPROP_DSOTHREADMODEL  	L"Data Source Object Threading Model"

#define	DESC_DBPROP_MULTIPLEPARAMSETS  	L"Multiple Parameter Sets"

#define	DESC_DBPROP_OUTPUTPARAMETERAVAILABILITY	L"Output Parameter Availability"

#define	DESC_DBPROP_PERSISTENTIDTYPE   	L"Persistent ID Type"

#define	DESC_DBPROP_ROWSETCONVERSIONSONCOMMAND 	L"Rowset Conversions on Command"

#define	DESC_DBPROP_MULTIPLERESULTS 	L"Multiple Results"

// ROWSET

#define	DESC_DBPROP_BLOCKINGSTORAGEOBJECTS  	L"Blocking Storage Objects"

#define	DESC_DBPROP_BOOKMARKS   	L"Use Bookmarks"

#define	DESC_DBPROP_BOOKMARKSKIPPED 	L"Skip Deleted Bookmarks"

#define	DESC_DBPROP_BOOKMARKTYPE    	L"Bookmark Type"

#define	DESC_DBPROP_CANFETCHBACKWARDS  	L"Fetch Backwards"

#define	DESC_DBPROP_CANHOLDROWS 	L"Hold Rows"

#define	DESC_DBPROP_CANSCROLLBACKWARDS 	L"Scroll Backwards"

#define	DESC_DBPROP_COLUMNRESTRICT  	L"Column Privileges"

#define	DESC_DBPROP_COMMANDTIMEOUT  	L"Command Time Out"

#define	DESC_DBPROP_FIRSTROWS 	L"First Rows"

#define	DESC_DBPROP_LITERALBOOKMARKS   	L"Literal Bookmarks"

#define	DESC_DBPROP_LITERALIDENTITY 	L"Literal Row Identity"

#define	DESC_DBPROP_MAXOPENROWS 	L"Maximum Open Rows"

#define	DESC_DBPROP_MAXROWS 	L"Maximum Rows"

#define	DESC_DBPROP_MEMORYUSAGE 	L"Memory Usage"

#define	DESC_DBPROP_NOTIFICATIONPHASES	L"Notification Phases"

#define	DESC_DBPROP_NOTIFYROWSETRELEASE	L"Rowset Release Notification"

#define	DESC_DBPROP_NOTIFYROWSETFETCHPOSITIONCHANGE	L"Rowset Fetch Position Change Notification"

#define	DESC_DBPROP_ORDEREDBOOKMARKS   	L"Bookmarks Ordered"

#define	DESC_DBPROP_OTHERINSERT 	L"Others' Inserts Visible"

#define	DESC_DBPROP_OTHERUPDATEDELETE  	L"Others' Changes Visible"

#define	DESC_DBPROP_QUICKRESTART    	L"Quick Restart"

#define	DESC_DBPROP_REENTRANTEVENTS 	L"Reentrant Events"

#define	DESC_DBPROP_REMOVEDELETED   	L"Remove Deleted Rows"

#define	DESC_DBPROP_ROWRESTRICT 	L"Row Privileges"

#define	DESC_DBPROP_ROWTHREADMODEL  	L"Row Threading Model"

#define	DESC_DBPROP_SERVERCURSOR    	L"Server Cursor"

#define	DESC_DBPROP_UPDATABILITY    	L"Updatability"

#define	DESC_DBPROP_STRONGIDENTITY  	L"Strong Row Identity"

#define	DESC_DBPROP_IAccessor   	L"IAccessor"

#define	DESC_DBPROP_IColumnsInfo    	L"IColumnsInfo"

#define	DESC_DBPROP_IConnectionPointContainer   	L"IConnectionPointContainer"

#define	DESC_DBPROP_IDBAsynchStatus 	L"IDBAsynchStatus"

#define	DESC_DBPROP_IRowset 	L"IRowset"

#define	DESC_DBPROP_IRowsetIdentity 	L"IRowsetIdentity"

#define	DESC_DBPROP_IRowsetInfo 	L"IRowsetInfo"

#define	DESC_DBPROP_IRowsetLocate   	L"IRowsetLocate"

#define	DESC_DBPROP_IRowsetScroll   	L"IRowsetScroll"

#define	DESC_DBPROP_ISupportErrorInfo  	L"ISupportErrorInfo"

#define	DESC_DBPROP_IConvertType    	L"IConvertType"

#define	DESC_DBPROP_IRowsetAsynch   	L"IRowsetAsynch"

#define	DESC_DBPROP_IRowsetWatchAll 	L"IRowsetWatchAll"

#define	DESC_DBPROP_IRowsetWatchRegion 	L"IRowsetWatchRegion"

#define	DESC_DBPROP_IRowsetExactScroll 	L"IRowsetExactScroll"

#define	DESC_DBPROP_ROWSET_ASYNCH   	L"Asynchronous Rowset Processing"

#define	DESC_DBPROP_IChapteredRowset   	L"IChapteredRowset"

// Initialize

#define	DESC_DBPROP_INIT_DATASOURCE 	L"Data Source"

#define	DESC_DBPROP_INIT_LOCATION   	L"Location"

#define	DESC_DBPROP_INIT_LCID   	L"Locale Identifier"

#define	DESC_DBPROP_INIT_HWND   	L"Window Handle"

#define	DESC_DBPROP_INIT_PROMPT 	L"Prompt"

#define	DESC_DBPROP_INIT_OLEDBSERVICES	L"OLE DB Services"


// DBPROP_PROVIDER specific

#define	DESC_DBPROP_USECONTENTINDEX 	L"Always use content index"

#define	DESC_DBPROP_DEFERNONINDEXEDTRIMMING 	L"Defer scope and security testing"

#define	DESC_DBPROP_USEEXTENDEDDBTYPES 	L"Return PROPVARIANTs in variant binding"

#define	DESC_MSIDXSPROP_ROWSETQUERYSTATUS  	L"Rowset Query Status"

#define	DESC_MSIDXSPROP_COMMAND_LOCALE_STRING 	L"SQL Content Query Locale String"

#define	DESC_MSIDXSPROP_QUERY_RESTRICTION  	L"Query Restriction"

// Session Properties

#define	DESC_DBPROP_SESS_AUTOCOMMITISOLEVELS   	L"Autocommit Isolation Levels"

// Grammar Properties

#define	DESC_DBPROP_AGGREGATE_FUNCTIONS 	L"Aggregated Functions"

#define	DESC_DBPROP_COLUMN_ALIAS    	L"Support Column Alias"

#define	DESC_DBPROP_CORRELATION_NAME   	L"Table Correlation Name"

#define	DESC_DBPROP_CREATE_VIEW 	L"Create View Clauses"

#define	DESC_DBPROP_DATETIME_LITERALS  	L"SQL92 Date Time Literals"

#define	DESC_DBPROP_DROP_VIEW   	L"Drop View Clauses"

#define	DESC_DBPROP_EXPRESSIONS_IN_ORDERBY  	L"Expressions in ORDER BY"

#define	DESC_DBPROP_IDENTIFIER_QUOTE_CHAR  	L"Delimiter of quoted identifiers"

#define	DESC_DBPROP_MAX_IDENTIFIER_LEN 	L"Maximum Identifier Length"

#define	DESC_DBPROP_OJ_CAPABILITIES 	L"Our Join Capabilities"

#define	DESC_DBPROP_SQL_CONFORMANCE 	L"SQL92 Conformance Level"

#define	DESC_DBPROP_SQL92_DATETIME_FUNCTIONS    	L"SQL92 Date Time Functions"

#define	DESC_DBPROP_SQL92_PREDICATES   	L"SQL92 Predicates"

#define	DESC_DBPROP_SQL92_RELATIONAL_JOIN_OPERATORS 	L"SQL92 Relation Join Operators"

#define	DESC_DBPROP_UNION	   	L"Union Clause"

#define	DESC_DBPROP_AUTH_INTEGRATED 	L"Integrated Security ."

#endif //__PROPINFR_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\icommand\qryspec.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1995 - 2000.
//
//  File:       qryspec.cxx
//
//  Contents:   ICommandTree implementation for OFS file stores
//
//  Classes:    CRootQuerySpec
//
//  Functions:  CheckForErrors
//              CheckForPriorTree
//
//  History:    30 Jun 1995   AlanW     Created
//              10-31-97      danleg    Added ICommandText & ICommandPrepare
//
//----------------------------------------------------------------------------

#include "pch.cxx"
#pragma hdrstop

#include <colinfo.hxx>
#include <parstree.hxx>
#include <hraccess.hxx>
#include <mparser.h>
#include <propglob.hxx>
#include <doquery.hxx>
#include "qryspec.hxx"

// Command object Interfaces that support Ole DB error objects
static const IID * apCommandErrorIFs[] =
{
        &IID_IAccessor,
        &IID_IColumnsInfo,
        &IID_ICommand,
        &IID_ICommandProperties,
        &IID_ICommandText,
        &IID_IConvertType,
        //&IID_IColumnsRowset,
        &IID_ICommandPrepare,
        &IID_ICommandTree,
        //&IID_ICommandWithParameters,
        &IID_IQuery,
        //&IID_ISupportErrorInfo,
        &IID_IServiceProperties
};
static const ULONG cCommandErrorIFs  = sizeof(apCommandErrorIFs)/sizeof(apCommandErrorIFs[0]);

// SQL defining global views.  These views are defined at the datasrc level, if one is present,
// or at the command level otherwise.
extern const LPWSTR s_pwszPredefinedViews =
    L"SET GLOBAL ON; "
    L"CREATE VIEW FILEINFO "
    L"       AS SELECT PATH, FILENAME, SIZE, WRITE, ATTRIB FROM SCOPE(); "
    L"CREATE VIEW FILEINFO_ABSTRACT     "
    L"       AS SELECT PATH, FILENAME, SIZE, WRITE, ATTRIB, CHARACTERIZATION FROM SCOPE(); "
    L"CREATE VIEW EXTENDED_FILEINFO     "
    L"       AS SELECT PATH, FILENAME, SIZE, WRITE, ATTRIB, DOCTITLE, DOCAUTHOR, DOCSUBJECT, DOCKEYWORDS, CHARACTERIZATION FROM SCOPE(); "
    L"CREATE VIEW WEBINFO "
    L"       AS SELECT VPATH, PATH, FILENAME, SIZE, WRITE, ATTRIB, CHARACTERIZATION, DOCTITLE FROM SCOPE(); "
    L"CREATE VIEW EXTENDED_WEBINFO "
    L"       AS SELECT VPATH, PATH, FILENAME, SIZE, CHARACTERIZATION, WRITE, DOCAUTHOR, DOCSUBJECT, DOCKEYWORDS, DOCTITLE FROM SCOPE(); "
    L"CREATE VIEW SSWebInfo "
    L"       AS SELECT URL, DOCTITLE, RANK, SIZE, WRITE FROM SCOPE(); "
    L"CREATE VIEW SSExtended_WebInfo "
    L"       AS SELECT URL, DOCTITLE, RANK, HITCOUNT, DOCAUTHOR, CHARACTERIZATION, SIZE, WRITE FROM SCOPE()";

//+-------------------------------------------------------------------------
//
//  Member:     CRootQuerySpec::CRootQuerySpec, public
//
//  Synopsis:   Constructor of a CRootQuerySpec
//
//  Arguments:  [pOuterUnk] - Outer unknown
//              [ppMyUnk]   - OUT:  filled in with pointer to non-delegated
//                            IUnknown on return
//
//  History:    08-Feb-96   KyleP    Added support for virtual paths
//
//--------------------------------------------------------------------------

CRootQuerySpec::CRootQuerySpec (IUnknown *          pOuterUnk,
                                IUnknown **         ppMyUnk,
                                CDBSession *        pSession)
        : _dwDepth(QUERY_SHALLOW),
          _pInternalQuery(0),
          _pQueryTree(0),
          _pColumnsInfo(0),
#pragma warning(disable : 4355) // 'this' in a constructor
         _impIUnknown(this),
         _aAccessors( (IUnknown *) (ICommand *)this ),
         _DBErrorObj( * ((IUnknown *) (ICommand *) this), _mtxCmd ),
#pragma warning(default : 4355)    // 'this' in a constructor
          _dwStatus(0),
          _guidCmdDialect(DBGUID_SQL),
          _fGenByOpenRowset(FALSE),
          _pwszSQLText(0),
          _RowsetProps( pSession ?
                        pSession->GetDataSrcPtr()->GetDSPropsPtr()->
                            GetValLong( CMDSProps::eid_DBPROPSET_DBINIT,
                                    CMDSProps::eid_DBPROPVAL_INIT_LCID ) :
                        0 ),
          _PropInfo()

{
    if (pOuterUnk)
        _pControllingUnknown = pOuterUnk;
    else
        _pControllingUnknown = (IUnknown * )&_impIUnknown;

    _DBErrorObj.SetInterfaceArray(cCommandErrorIFs, apCommandErrorIFs);

    if ( pSession )
    {
        _xSession.Set( pSession );
        _xSession->AddRef();

        _xpIPSession.Set( pSession->GetParserSession() );

        //
        // The above Set() doesn't AddRef. This will balance the XInterface<>
        // dtor Release
        //
        _xpIPSession->AddRef();
    }

    *ppMyUnk = ((IUnknown *)&_impIUnknown);
    (*ppMyUnk)->AddRef();
}

//+---------------------------------------------------------------------------
//
//  Method:     CRootQuerySpec::CRootQuerySpec, public
//
//  Synopsis:   Copy constructor
//
//  Arguments:  [src] -- Source query spec
//
//  History:    27 Jun 95   AlanW       Created
//              10 Jan 98   danleg      Replaced body with Assert
//
//----------------------------------------------------------------------------

CRootQuerySpec::CRootQuerySpec( CRootQuerySpec & src )
        : _dwDepth( src._dwDepth ),
          _pInternalQuery(0),
          _pQueryTree(0),
          _pColumnsInfo(0),
#pragma warning(disable : 4355) // 'this' in a constructor
         _impIUnknown(this),
         _aAccessors( (IUnknown *) (ICommand *)this ),
         _DBErrorObj( * ((IUnknown *) (ICommand *) this), _mtxCmd ),
#pragma warning(default : 4355)    // 'this' in a constructor
          _dwStatus(src._dwStatus),
          _guidCmdDialect(src._guidCmdDialect),
          _fGenByOpenRowset(src._fGenByOpenRowset),
          _pwszSQLText(0),
          _RowsetProps( src._RowsetProps ),
          _PropInfo()
{
    Win4Assert( !"CRootQuerySpec copy constructor not implemented.");
}

//+-------------------------------------------------------------------------
//
//  Member:     CRootQuerySpec::~CRootQuerySpec, private
//
//  Synopsis:   Destructor of a CRootQuerySpec
//
//--------------------------------------------------------------------------

CRootQuerySpec::~CRootQuerySpec()
{
    ReleaseInternalQuery();

    delete    _pColumnsInfo;
    delete    _pQueryTree;
    delete [] _pwszSQLText;
}


//+-------------------------------------------------------------------------
//
//  Member:     CRootQuerySpec::RealQueryInterface, public
//
//  Synopsis:   Get a reference to another interface on the cursor.  AddRef
//              is done in CImpIUnknown::QueryInterface
//
//  History:    10-31-97    danleg      Added ICommandText& ICommandPrepare
//
//--------------------------------------------------------------------------

//
// Hack #214: IID_ICommandProperties is intercepted by service layers, which
//            don't like us passing in the magic code to fetch hidden scope
//            properties.  But the controlling unknown doesn't recognize
//            IID_IKyleProp and sends it right to us.  Implementation is
//            identical to ICommandProperties.
//

extern GUID IID_IKyleProp;

SCODE CRootQuerySpec::RealQueryInterface(
    REFIID ifid,
    void * *ppiuk )
{
    SCODE sc = S_OK;

    TRY
    {
        // validate the param before any addrefs
        *ppiuk = 0;

        // note -- IID_IUnknown covered in QueryInterface

        if ( IID_ICommand == ifid )
        {
            *ppiuk = (void *) ((ICommand *) this);
        }
        else if (IID_ISupportErrorInfo == ifid)
        {
            *ppiuk = (void *) ((IUnknown *) (ISupportErrorInfo *) &_DBErrorObj);
        }
        else if ( IID_IAccessor == ifid )
        {
            *ppiuk = (void *) (IAccessor *) this;
        }
        else if ( IID_IColumnsInfo == ifid )
        {
           *ppiuk = (void *) (IColumnsInfo *) GetColumnsInfo();
        }
    // NTRAID#DB-NTBUG9-84306-2000/07/31-dlee OLE-DB spec variance in Indexing Service, some interfaces not implemented
    #if 0  
        else if ( IID_IRowsetInfo == ifid )
        {
            *ppiuk = (void *) (IRowsetInfo *) this;
        }
    #endif // 0
        else if ( IID_ICommandTree == ifid )
        {
            *ppiuk = (void *) (ICommandTree *) this;
        }
    // NTRAID#DB-NTBUG9-84306-2000/07/31-dlee OLE-DB spec variance in Indexing Service, some interfaces not implemented
    #if 0 
        else if ( IID_ICommandValidate == ifid )
        {
            *ppiuk = (void *) (ICommandValidate *) this;
        }
    #endif // 0
        else if ( IID_IQuery == ifid )
        {
            *ppiuk = (void *) (IQuery *) this;
        }
        else if ( IID_ICommandProperties == ifid || IID_IKyleProp == ifid )
        {
            *ppiuk = (void *) (ICommandProperties *) this;
        }
        else if ( IID_IServiceProperties == ifid )
        {
            *ppiuk = (void *) (IServiceProperties *) this;
        }
        else if ( IID_IConvertType == ifid )
        {
            *ppiuk = (void *) (IConvertType *) this;
        }
        else if ( IID_ICommandText == ifid )
        {
            // Create parser sesson object if deferred during construction
            if ( _xpIPSession.IsNull() )
                CreateParser();

            *ppiuk = (void *) (ICommandText *) this;
        }
        else if ( IID_ICommandPrepare == ifid )
        {
            *ppiuk = (void *) (ICommandPrepare *) this;
        }

        else
        {
            *ppiuk = 0;
            sc = E_NOINTERFACE;
        }
    }
    CATCH( CException, e )
    {
        vqDebugOut(( DEB_ERROR, "Exception %08x while doing QueryInterface \n",
                     e.GetErrorCode() ));
        sc = GetOleError(e);
    }
    END_CATCH

    return sc;
}

//+---------------------------------------------------------------------------
//
//  Method:     CRootQuerySpec::FindErrorNodes, public
//
//  Synopsis:   Find error nodes in a command tree
//
//  Arguments:  [pRoot]         -- DBCOMMANDTREE node at root of tree
//              [pcErrorNodes]  -- pointer where count of error nodes is ret'd
//
//  History:    27 Jun 95   AlanW       Created
//
//----------------------------------------------------------------------------

BOOL CheckForErrors( const CDbCmdTreeNode *pNode )
{
    if (pNode->GetError() != S_OK)
        return TRUE;
    else
        return FALSE;
}


SCODE CRootQuerySpec::FindErrorNodes(
    const DBCOMMANDTREE *  pRoot,
    ULONG *                pcErrorNodes,
    DBCOMMANDTREE ***      prgErrorNodes)
{
    SCODE sc = S_OK;

    ULONG cErrors = 0;
    XArrayOLE<DBCOMMANDTREE *> pErrorNodes;

    TRANSLATE_EXCEPTIONS;
    TRY
    {
        _FindTreeNodes( CDbCmdTreeNode::CastFromStruct(pRoot),
                        cErrors,
                        pErrorNodes,
                        CheckForErrors );

        *pcErrorNodes = cErrors;
        *prgErrorNodes = pErrorNodes.GetPointer();
        pErrorNodes.Acquire();
    }
    CATCH( CException, e )
    {
        sc = _DBErrorObj.PostHResult( e, IID_ICommandTree );
    }
    END_CATCH;
    UNTRANSLATE_EXCEPTIONS;

    return sc;
}


//+---------------------------------------------------------------------------
//
//  Method:     CRootQuerySpec::_FindTreeNodes, private
//
//  Synopsis:   Find nodes in a command tree meeting some condition
//
//  Arguments:  [pRoot]         -- DBCOMMANDTREE node at root of tree
//              [rcMatchingNodes]  -- count of matching nodes returned
//              [prgMatchingNodes] -- pointer to array of nodes returned
//              [pfnCheckNode]  -- function which returns true if a tree
//                                 node matches desired condition.
//              [iDepth]        -- depth of tree; for detecting cycles
//
//  Notes:      In order to avoid looping endlessly over a tree with cycles,
//              this routine will bail out if the tree depth is greater
//              than 1000 or if the tree width is greater than 100,000.
//
//              We don't expect this routine to be called in situations
//              where it will return very large numbers of tree nodes,
//              so we grow the returned array only one element at a time.
//
//  History:    27 Jun 95   AlanW       Created
//
//----------------------------------------------------------------------------

const unsigned MAX_TREE_DEPTH = 1000;   // max tree depth
const unsigned MAX_TREE_WIDTH = 100000; // max tree width


void CRootQuerySpec::_FindTreeNodes(
    const CDbCmdTreeNode * pRoot,
    ULONG &                rcMatchingNodes,
    XArrayOLE<DBCOMMANDTREE *> & rpMatchingNodes,
    PFNCHECKTREENODE       pfnCheckNode,
    unsigned               iDepth)
{
    if (iDepth > MAX_TREE_DEPTH)
        THROW(CException(E_FAIL));

    unsigned iWidth = 0;

    while (pRoot)
    {
        if (pRoot->GetFirstChild())
            _FindTreeNodes( pRoot->GetFirstChild(),
                            rcMatchingNodes,
                            rpMatchingNodes,
                            pfnCheckNode,
                            iDepth+1);

        if (iWidth > MAX_TREE_WIDTH)
            THROW(CException(E_FAIL));

        if ((pfnCheckNode)(pRoot))
        {
            XArrayOLE<DBCOMMANDTREE *> pMatchTemp( rcMatchingNodes+1 );
            if (0 == pMatchTemp.GetPointer())
                THROW(CException(E_OUTOFMEMORY));

            if (rcMatchingNodes > 0)
            {
                Win4Assert(rpMatchingNodes.GetPointer() != 0);
                RtlCopyMemory(pMatchTemp.GetPointer(),
                              rpMatchingNodes.GetPointer(),
                              sizeof (DBCOMMANDTREE*) * rcMatchingNodes);
                CoTaskMemFree(rpMatchingNodes.Acquire());
            }
            (pMatchTemp.GetPointer())[rcMatchingNodes] = pRoot->CastToStruct();
            rcMatchingNodes++;

            rpMatchingNodes.Set( rcMatchingNodes, pMatchTemp.Acquire() );
        }

        pRoot = pRoot->GetNextSibling();
        iWidth++;
    }
    return;
}


//+---------------------------------------------------------------------------
//
//  Method:     CRootQuerySpec::FreeCommandTree, public
//
//  Synopsis:   Free a command tree
//
//  Arguments:  [ppRoot]   -- DBCOMMANDTREE node at root of tree to be freed
//
//  History:    27 Jun 95   AlanW       Created
//
//----------------------------------------------------------------------------

SCODE CRootQuerySpec::FreeCommandTree(
    DBCOMMANDTREE * *     ppRoot)
{
    SCODE sc = S_OK;

    if ( 0 == ppRoot )
        return E_INVALIDARG;

    TRANSLATE_EXCEPTIONS;
    TRY
    {
        CDbCmdTreeNode * pCmdTree = (CDbCmdTreeNode *)
                          CDbCmdTreeNode::CastFromStruct(*ppRoot);

        //
        //  If the user tries to delete our query tree, zero our pointer to it.
        //
        //  NOTE: Nothing prevents the user from freeing a subtree of
        //        our tree if they called SetCommandTree with fCopy FALSE.
        //

        // There is a proposed spec change on this.  According to the current spec,
        // if fCopy was FALSE we need to return DB_E_CANNOTFREE  here. (MDAC BUGG# 6386)
        if ( _dwStatus & CMD_OWNS_TREE )
        {
            THROW( CException(DB_E_CANNOTFREE) );
        }
        else
        {
            if ( pCmdTree == _pQueryTree )
            _pQueryTree = 0;

            delete pCmdTree;
            *ppRoot = 0;
        }
    }
    CATCH( CException, e )
    {
        sc = _DBErrorObj.PostHResult( e, IID_ICommandTree );
    }
    END_CATCH;
    UNTRANSLATE_EXCEPTIONS;

    return sc;
}


//+---------------------------------------------------------------------------
//
//  Method:     CRootQuerySpec::GetCommandTree, public
//
//  Synopsis:   Get a copy of the command tree.
//
//  Arguments:  [ppRoot]  -- pointer to where DBCOMMANDTREE is returned
//
//  History:    27 Jun 95   AlanW       Created
//
//----------------------------------------------------------------------------

SCODE CRootQuerySpec::GetCommandTree(
    DBCOMMANDTREE * *     ppRoot)
{
    if ( 0 == ppRoot )
        return _DBErrorObj.PostHResult( E_INVALIDARG, IID_ICommandTree );

    SCODE sc = S_OK;

    TRANSLATE_EXCEPTIONS;
    TRY
    {
        //
        // Initialize return parameter
        //
        *ppRoot = 0;

        if ( 0 == _pQueryTree )
        {
            //
            // Build it if we have a command text
            //
            if ( IsCommandSet() )
            {
                sc = BuildTree( );

                // SET PROPERTYNAME ... query
                if ( DB_S_NORESULT == sc )
                    return S_OK;

                _dwStatus |= CMD_TREE_BUILT;
            }

            //
            // The command text didn't generate a tree  (i.e. it was
            // either a CREATE VIEW or SET PROPERTYNAME ) or a
            // command text wasn't set
            //
            if ( 0 == _pQueryTree )
            {
                return S_OK;
            }
        }

        XPtr<CDbCmdTreeNode> TreeCopy( _pQueryTree->Clone(TRUE) );
        if (0 == TreeCopy.GetPointer())
            THROW(CException(E_OUTOFMEMORY));

        *ppRoot = TreeCopy.GetPointer()->CastToStruct();
        TreeCopy.Acquire();
    }
    CATCH( CException, e )
    {
        sc = _DBErrorObj.PostHResult( e, IID_ICommandTree );
    }
    END_CATCH;
    UNTRANSLATE_EXCEPTIONS;

    return sc;
}


//+---------------------------------------------------------------------------
//
//  Method:     CRootQuerySpec::SetCommandTree, public
//
//  Synopsis:   Set the command tree.
//
//  Arguments:  [ppRoot]   -- pointer to DBCOMMANDTREE to be set in command obj
//              [dwCommandReuse] -- indicates whether state is retained.
//              [fCopy]   -- if TRUE, a copy of ppRoot is made.  Otherwise,
//                           ownership of the command tree passes to the
//                           command object.
//
//  History:    27 Jun 95   AlanW       Created
//
//----------------------------------------------------------------------------

SCODE CRootQuerySpec::SetCommandTree(
    DBCOMMANDTREE * *       ppRoot,
    DBCOMMANDREUSE          dwCommandReuse,
    BOOL                    fCopy)
{
    if ( HaveQuery() && _pInternalQuery->IsQueryActive() )
        return DB_E_OBJECTOPEN;

    if ( 0 == ppRoot )
        return E_INVALIDARG;

    SCODE sc = S_OK;

    TRANSLATE_EXCEPTIONS;
    TRY
    {
        _CheckRootNode( *ppRoot );

        if ( 0 != _pQueryTree )
        {
            delete _pQueryTree;
            _pQueryTree = 0;
        }

        CDbCmdTreeNode const * pCmdTree = CDbCmdTreeNode::CastFromStruct(*ppRoot);

        if ( FALSE == fCopy )
        {
            _dwStatus |= CMD_OWNS_TREE;
            _pQueryTree = (CDbCmdTreeNode *)pCmdTree;
            *ppRoot = 0;
        }
        else
        {
            _pQueryTree = pCmdTree->Clone();

            //
            // If Clone() fails it cleans up after itself and returns 0
            //

            if ( 0 == _pQueryTree )
                THROW( CException( E_OUTOFMEMORY ) );
        }

        _dwStatus &= ~CMD_COLINFO_NOTPREPARED;

        if ( _pColumnsInfo )
            InitColumns();

        //
        // If this is not being called internally (from BuildTree) remove the
        // the command text
        //
        if ( _dwStatus & CMD_TEXT_TOTREE )
        {
            _dwStatus &= ~CMD_TEXT_TOTREE;
        }
        else
        {
            delete [] _pwszSQLText;
            _pwszSQLText     = 0;
            _guidCmdDialect  = DBGUID_SQL;
            _dwStatus       &= ~CMD_TEXT_SET;
        }
    }
    CATCH( CException, e )
    {
        sc = _DBErrorObj.PostHResult( e, IID_ICommandTree );
    }
    END_CATCH;
    UNTRANSLATE_EXCEPTIONS;

    return sc;
}

//+---------------------------------------------------------------------------
//
//  Method:     CRootQuerySpec::Execute, public
//
//  Synopsis:   Execute the command; create rowsets for the query resu.
//
//  Arguments:  [pOuterUnk]    -- controlling IUnknown for the rowset
//              [riid]         -- interface IID requested for the rowset
//              [pParams]      -- parameters for the query
//              [pcRowsAffected] -- returned count of affected rows
//              [ppRowset]     -- returned rowset
//
//  History:    27 Jun 95   AlanW       Created
//              11-20-97    danleg      Added ICommandText & ICommandPrepare
//
//----------------------------------------------------------------------------

SCODE CRootQuerySpec::Execute(
    IUnknown *             pOuterUnk,
    REFIID                 riid,
    DBPARAMS *             pParams,
    DBROWCOUNT *           pcRowsAffected,
    IUnknown * *           ppRowset)
{

    _DBErrorObj.ClearErrorInfo();

    //
    // Called from OpenRowset?
    //
    GUID guidPost = (_fGenByOpenRowset) ? IID_IOpenRowset : IID_ICommand;

    if (0 == ppRowset && IID_NULL != riid )
        return _DBErrorObj.PostHResult( E_INVALIDARG, guidPost );

    if (0 != pOuterUnk && riid != IID_IUnknown)
        return _DBErrorObj.PostHResult( DB_E_NOAGGREGATION, guidPost );

    CLock lck( _mtxCmd );

    SCODE       scResult = S_OK;
    IRowset *   pIRowset = 0;

    _dwStatus &= ~(CMD_EXEC_RUNNING);

    TRANSLATE_EXCEPTIONS;
    TRY
    {
        if ( ppRowset )
            *ppRowset = 0;

        // Impersonate the session logon user
        
        HANDLE hToken = INVALID_HANDLE_VALUE;
        
        if ( !_xSession.IsNull() )
             hToken = _xSession->GetLogonToken();

        CImpersonateSessionUser imp( hToken );

        // Either SetCommandTree or SetCommandText should have already been called

        if ( 0 == _pQueryTree )
        {
            if ( IsCommandSet() )
            {
                //
                // No query tree.  Build one from the command text if one has been set.
                //
                scResult = BuildTree( );

                if ( DB_S_NORESULT == scResult )
                    return scResult;

                _dwStatus |= CMD_TREE_BUILT;
            }
            else
                THROW( CException(DB_E_NOCOMMAND) );
        }

        _dwStatus |= CMD_EXEC_RUNNING;

        //
        // Convert the tree into restriction, etc.
        // The pParams should probably be passed to the ctor of
        // the parser (when we do parameterized queries).
        //
        CParseCommandTree   Parse;
        Parse.ParseTree( _pQueryTree );

        XGrowable<const WCHAR *,SCOPE_COUNT_GROWSIZE> xaScopes( SCOPE_COUNT_GROWSIZE );
        XGrowable<ULONG,SCOPE_COUNT_GROWSIZE>         xaFlags( SCOPE_COUNT_GROWSIZE );
        XGrowable<const WCHAR *,SCOPE_COUNT_GROWSIZE> xaCatalogs( SCOPE_COUNT_GROWSIZE );
        XGrowable<const WCHAR *,SCOPE_COUNT_GROWSIZE> xaMachines( SCOPE_COUNT_GROWSIZE );
        unsigned cScopes = 0;

        Parse.GetScopes( cScopes, xaScopes, xaFlags, xaCatalogs, xaMachines );
        
        // If the tree had a DBOP_tree node instead of a DBOP_content_table, we can't
        // parse scope information from the tree. The client is responsible for 
        // setting scope properties.  Currently, this means the Tripolish parser
        if ( 0 < cScopes )
        {
            SetScopeProperties( this,
                                cScopes,
                                xaScopes.Get(),
                                xaFlags.Get(),
                                xaCatalogs.Get(),
                                xaMachines.Get() );
        }

        CRestriction * pCrst = Parse.GetRestriction();
        CCategorizationSet & categ = Parse.GetCategorization();

        unsigned cRowsets = 1;
        if ( 0 != categ.Count() )
            cRowsets += categ.Count();

        if (Parse.GetOutputColumns().Count() == 0)
            THROW( CException(DB_E_ERRORSINCOMMAND) );

        XArray<IUnknown *> Unknowns( cRowsets );

        //
        // If it appears the server went down between the time we made
        // the connection and did the execute, attempt once to
        // re-establish the connection.
        //

        int cTries = 1;
        XPtr<CMRowsetProps> xProps;

        do
        {
            //
            // Use a copy of the properties so the command object isn't
            // affected by the implied properties.  xProps may be acquired
            // in a failed loop if the server disconnects just before the
            // setbindings call.
            //

            if ( xProps.IsNull() )
            {
                xProps.Set( new CMRowsetProps( _RowsetProps ) );
        
                xProps->SetImpliedProperties( riid, cRowsets );
        
                //
                // Check if there are any properties in error. If properties are found
                // to be in error, indicate this on _RowsetProps.
                //
                scResult = xProps->ArePropsInError( _RowsetProps );
        
                if ( S_OK != scResult )
                    return scResult;
        
                if ( Parse.GetMaxResults() > 0 )
                    xProps->SetValLong( CMRowsetProps::eid_DBPROPSET_ROWSET,
                                        CMRowsetProps::eid_PROPVAL_MAXROWS,
                                        Parse.GetMaxResults() );
                
                if ( Parse.GetFirstRows() > 0 )
                    xProps->SetFirstRows( Parse.GetFirstRows() );
            }

            if ( !HaveQuery() )
                _pInternalQuery = QueryInternalQuery();

            SCODE scEx = S_OK;

            TRY
            {
                //
                // Used for GetSpecification on the rowset
                //
                IUnknown * pCreatorUnk = 0;
                if ( IsGenByOpenRowset() )
                {
                    Win4Assert( !_xSession.IsNull() );
                    pCreatorUnk = _xSession->GetOuterUnk();
                }
                else
                {
                    pCreatorUnk = (IUnknown *) _pControllingUnknown;
                }

                Win4Assert( 0 != xProps.GetPointer() );

                _pInternalQuery->Execute( pOuterUnk,
                                          pCrst ? pCrst->CastToStruct() : 0,  // Restrictions
                                          Parse.GetPidmap(),
                                          Parse.GetOutputColumns(), // Output columns
                                          Parse.GetSortColumns(),   // Sort Order
                                          xProps,
                                          categ,                    // Categorization
                                          cRowsets,
                                          Unknowns.GetPointer(),    // Return interfaces
                                          _aAccessors,
                                          pCreatorUnk);
            }
            CATCH( CException, e )
            {
                scEx = e.GetErrorCode();
                if ( ( STATUS_CONNECTION_DISCONNECTED != scEx ) ||
                     ( cTries > 1 ) )
                    RETHROW();
            }
            END_CATCH;

            if ( STATUS_CONNECTION_DISCONNECTED == scEx )
            {
                Win4Assert( 1 == cTries );
                cTries++;
                ReleaseInternalQuery();
                continue;
            }
            else
            {
                Win4Assert( S_OK == scEx );
                break;
            }
        }
        while ( TRUE );

        // release these categorized rowsets -- they are addref'ed when the
        // client does a getreferencedrowset

        for ( unsigned x = 1; x < cRowsets; x++ )
            Unknowns[ x ]->Release();

        XInterface<IUnknown> xUnknown( Unknowns[0] );

        if (IID_IUnknown == riid)
        {
            *ppRowset = xUnknown.GetPointer();
            xUnknown.Acquire();
        }
        else
        {
            if (IID_NULL != riid)
                scResult = xUnknown->QueryInterface( riid, (void **)ppRowset );

            Win4Assert( S_OK == scResult );     // should have failed earlier
            if (FAILED(scResult))
                THROW( CException(scResult) );
        }

        _dwStatus &= ~(CMD_EXEC_RUNNING);

        imp.Revert();
    }
    CATCH( CException, e )
    {
        //
        // Can't use PostHResult( e...) here because the final SCODE may get translated
        //
        scResult = e.GetErrorCode();

        vqDebugOut(( DEB_ERROR, "Exception %08x while creating query\n", scResult ));

        if ( QUERY_E_INVALIDRESTRICTION == scResult )
            scResult = DB_E_ERRORSINCOMMAND;

        //
        // In the case of OpenRowset, don't want to Post DB_E_ERRORSINCOMMAND
        //
        if ( _fGenByOpenRowset )
        {
            if( scResult == DB_E_ERRORSINCOMMAND )
                scResult = DB_E_NOTABLE;
        }

       _DBErrorObj.PostHResult( scResult, guidPost );
    }
    END_CATCH;
    UNTRANSLATE_EXCEPTIONS;

    #if CIDBG == 1
        if ( ( S_OK == scResult ) && ( IID_NULL != riid ) )
            Win4Assert( 0 != *ppRowset );
    #endif

    return scResult;
}

//+---------------------------------------------------------------------------
//
//  Method:     CRootQuerySpec::Cancel, public
//
//  Synopsis:   The consumer can allocate a secondary thread in which to cancel
//              the currently executing thread.  This cancel will only succeed
//              if the result set is still being generated.  If the rowset
//              object is being created, then it will be to late to cancel.
//
//  History:    11-20-97    danleg      Created
//----------------------------------------------------------------------------

SCODE CRootQuerySpec::Cancel( void )
{
    _DBErrorObj.ClearErrorInfo();

    if( 0 == (_dwStatus & CMD_EXEC_RUNNING) )
        return S_OK;

    return _DBErrorObj.PostHResult(DB_E_CANTCANCEL, IID_ICommand);
}


#if 0 // ICommandValidate not yet implemented
//
//  ICommandValidate methods
//
SCODE CRootQuerySpec::ValidateCompletely( void )
{
    _DBErrorObj.ClearErrorInfo();
    vqDebugOut(( DEB_WARN, "CRootQuerySpec::ValidateCompletely not implemented\n" ));
    return PostHResult(E_NOTIMPL, IID_ICommandValidate);
}

SCODE CRootQuerySpec::ValidateSyntax( void )
{
    _DBErrorObj.ClearErrorInfo();
    vqDebugOut(( DEB_WARN, "CRootQuerySpec::ValidateSyntax not implemented\n" ));
    return PostHResult(E_NOTIMPL, IID_ICommandValidate);
}
#endif // 0


//+---------------------------------------------------------------------------
//
//  Method:     CRootQuerySpec::GetDBSession, public
//
//  Synopsis:   Return the session object associated with this command
//
//  Arguments:  [riid]      -- IID of the desired interface
//              [ppSession] -- pointer to where to return interface pointer
//
//  History:    11-20-97    danleg      Created
//----------------------------------------------------------------------------

SCODE CRootQuerySpec::GetDBSession(
    REFIID      riid,
    IUnknown ** ppSession )
{
    _DBErrorObj.ClearErrorInfo();

    if (0 == ppSession)
        return _DBErrorObj.PostHResult(E_INVALIDARG, IID_ICommand);

    SCODE   sc = S_OK;

    if ( !_xSession.IsNull() )
    {
        sc = (_xSession->GetOuterUnk())->QueryInterface( riid, (void **) ppSession );
    }
    else  // there was no session object
    {
        *ppSession = 0;
        sc = S_FALSE;
    }

    return sc;
}

//
// ICommandText methods
//

//+---------------------------------------------------------------------------
//
//  Method:     CRootQuerySpec::GetCommandText, public
//
//  Synopsis:   Echos the current command as text, including all
//              post-processing operations added.
//
//  Arguments:  [pguidDialect] -- Guid denoting the dialect of SQL
//              [ppwszCommand] -- Pointer to mem where to return command text
//
//  History:    10-01-97   danleg       Created from Monarch
//
//----------------------------------------------------------------------------

STDMETHODIMP CRootQuerySpec::GetCommandText
    (
    GUID *      pguidDialect,       //@parm INOUT | Guid denoting the dialect of sql
    LPOLESTR *  ppwszCommand        //@parm OUT | Pointer for the command text
    )
{
    SCODE       sc = S_OK;
    BOOL        fpguidNULL = FALSE;
    GUID        guidDialect;

    _DBErrorObj.ClearErrorInfo();

    CLock lck( _mtxCmd );

    TRANSLATE_EXCEPTIONS;
    TRY
    {
        if( 0 == ppwszCommand )
        {
            THROW( CException(E_INVALIDARG) );
        }
        else
        {
            *ppwszCommand = 0;

            // Substitute a correct GUID for a NULL pguidDialect
            if( !pguidDialect )
            {
                guidDialect = DBGUID_SQL;
                pguidDialect = &guidDialect;

                // Don't return DB_S_DIALECTIGNORED in this case...
                fpguidNULL = TRUE;
            }

            // If the command has not been set, make sure the buffer
            // contains an empty string to return to the consumer
            if( !IsCommandSet() )
            {
                THROW( CException(DB_E_NOCOMMAND) );

            }
            else
            {
                // Allocate memory for the string we're going to return to the caller
                XArrayOLE<WCHAR> xwszCommand( wcslen(_pwszSQLText) + 1 ) ;

                // Copy our saved text into the newly allocated string
                wcscpy(xwszCommand.GetPointer(), _pwszSQLText);

                // If the text we're giving back is a different dialect than was
                // requested, let the caller know what dialect the text is in
                if( !fpguidNULL && _guidCmdDialect != *pguidDialect )
                {
                    *pguidDialect = _guidCmdDialect;
                    sc = DB_S_DIALECTIGNORED;
                }
                *ppwszCommand = xwszCommand.Acquire();
            }
        }
    }
    CATCH( CException, e )
    {
        sc  = _DBErrorObj.PostHResult( e, IID_ICommandText );
        if( pguidDialect )
            RtlZeroMemory( pguidDialect, sizeof(GUID) );
    }
    END_CATCH;
    UNTRANSLATE_EXCEPTIONS;

    return sc;
}


//+---------------------------------------------------------------------------
//
//  Method:     CRootQuerySpec::SetCommandText, public
//
//  Synopsis:   Sets the current command text..
//
//  Arguments:  [rguidDialect] -- Guid denoting the dialect of SQL
//              [pwszCommand]  -- Command Text
//
//  History:    10-01-97   danleg       Created from Monarch
//
//----------------------------------------------------------------------------

STDMETHODIMP CRootQuerySpec::SetCommandText
    (
    REFGUID     rguidDialect,
    LPCOLESTR   pwszCommand
    )
{
    SCODE sc = S_OK;

    // Clear previous Error Object for this thread
    _DBErrorObj.ClearErrorInfo();

    CLock lck( _mtxCmd );

    TRANSLATE_EXCEPTIONS;
    TRY
    {
        // Don't allow text to be set if we've got a rowset open
        if( !IsRowsetOpen() )
        {
            // Check Dialect
            if( rguidDialect == DBGUID_SQL || rguidDialect == DBGUID_DEFAULT )
            {
                //
                // Delete existing SQL text
                //
                delete [] _pwszSQLText;
                _pwszSQLText = 0;

                //
                // Delete Command Tree
                //
                delete _pQueryTree;
                _pQueryTree = 0;

                if( (0 == pwszCommand) || (L'\0' == *pwszCommand) )
                {
                    _guidCmdDialect  = DBGUID_SQL;
                    _dwStatus       &= ~CMD_TEXT_SET;
                    _dwStatus       &= ~CMD_COLINFO_NOTPREPARED;
                }
                else
                {
                    //
                    // Save the text and dialect
                    //
                    XArray<WCHAR> xwszSQLText( wcslen(pwszCommand) + 1 );
                    wcscpy(xwszSQLText.GetPointer(), pwszCommand);
                    _pwszSQLText = xwszSQLText.Acquire();

                    _guidCmdDialect = rguidDialect;

                    // Set status flag that we have set text
                    _dwStatus      |= CMD_TEXT_SET;
                    _dwStatus      |= CMD_COLINFO_NOTPREPARED;
                }

                if ( _pColumnsInfo )
                    InitColumns( );

                _dwStatus &= ~CMD_TEXT_PREPARED;
                _dwStatus &= ~CMD_TREE_BUILT;

                // Whenever new text is set on the Command Object,
                // the value for QUERY_RESTRICTION should be set to
                // an empty string

                _RowsetProps.SetValString(
                    CMRowsetProps::eid_DBPROPSET_MSIDXS_ROWSET_EXT,
                    CMRowsetProps::eid_MSIDXSPROPVAL_QUERY_RESTRICTION,
                    L"");
            }
            else
            {
                THROW( CException(DB_E_DIALECTNOTSUPPORTED) );
            }
        }
        else
        {
            THROW( CException(DB_E_OBJECTOPEN) );
        }
    }
    CATCH( CException, e )
    {
        sc  = _DBErrorObj.PostHResult( e, IID_ICommandText );
    }
    END_CATCH;
    UNTRANSLATE_EXCEPTIONS;

    return sc;
}

//
// ICommandPrepare methods
//
//+---------------------------------------------------------------------------
//
//  Method:     CRootQuerySpec::Prepare, public
//
//  Synopsis:   Given that a SQL text has been set, prepare the statement
//
//  History:    10-31-97   danleg       Created from Monarch
//
//----------------------------------------------------------------------------

STDMETHODIMP CRootQuerySpec::Prepare
    (
    ULONG     cExpectedRuns
    )
{
    SCODE sc = S_OK;

    // Clear previous Error Object for this thread
    _DBErrorObj.ClearErrorInfo();

    CLock lck( _mtxCmd );

    TRANSLATE_EXCEPTIONS;
    TRY
    {
        // Don't allow a new prepare with an open rowset
        if( !IsRowsetOpen() )
        {
            if( IsCommandSet() )
            {
                //
                // Don't build the tree again if it was built as a result of
                // GetCommandTree or Execute, and we haven't done a SetCommandText
                // since.
                //
                if ( !(_dwStatus & CMD_TREE_BUILT) )
                {
                    // Impersonate the session logon user

                    HANDLE hToken = INVALID_HANDLE_VALUE;

                    if ( !_xSession.IsNull() )
                         hToken = _xSession->GetLogonToken();

                    CImpersonateSessionUser imp( hToken );

                    sc = BuildTree( );

                    if ( DB_S_NORESULT == sc )
                        return sc;

                    _dwStatus |= CMD_TEXT_PREPARED;

                    if ( _pColumnsInfo )
                        InitColumns();

                    imp.Revert();
                }

            }
            else
                sc = DB_E_NOCOMMAND;
        }
        else
        {
            sc = DB_E_OBJECTOPEN;
        }
    }
    CATCH( CException, e )
    {
        sc = _DBErrorObj.PostHResult( e, IID_ICommandText );
    }
    END_CATCH;
    UNTRANSLATE_EXCEPTIONS;

    return sc;
}

//+---------------------------------------------------------------------------
//
//  Method:     CRootQuerySpec::Unprepare, public
//
//  Synopsis:   Unprepare the current prepared command plan, if there is one.
//
//  History:    10-31-97   danleg       Created from Monarch
//
//----------------------------------------------------------------------------
STDMETHODIMP CRootQuerySpec::Unprepare
    (
    )
{
    SCODE sc = S_OK;

    // Clear previous Error Object for this thread
    _DBErrorObj.ClearErrorInfo();

    CLock lck( _mtxCmd );

    TRANSLATE_EXCEPTIONS;
    TRY
    {
        if( !IsRowsetOpen() )
        {
            _dwStatus &= ~CMD_TEXT_PREPARED;
            _dwStatus |= CMD_COLINFO_NOTPREPARED;

            if ( _pColumnsInfo )
                InitColumns( );
        }
        else
            THROW( CException(DB_E_OBJECTOPEN) );
    }
    CATCH( CException, e )
    {
        sc = _DBErrorObj.PostHResult( e, IID_ICommandPrepare );
    }
    END_CATCH;
    UNTRANSLATE_EXCEPTIONS;

    return sc;
}


//
//  IQuery methods
//

//+---------------------------------------------------------------------------
//
//  Method:     CRootQuerySpec::AddPostProcessing, public
//
//  Synopsis:   Add to the top of a command tree
//
//  Arguments:  [ppRoot] -- DBCOMMANDTREE node at root of tree
//              [fCopy]  - TRUE if command tree should be copied
//
//  History:    29 Jun 95   AlanW       Created
//
//----------------------------------------------------------------------------

BOOL CheckForPriorTree( const CDbCmdTreeNode *pNode )
{
    return pNode->GetCommandType() == DBOP_prior_command_tree;
}

SCODE CRootQuerySpec::AddPostProcessing(
    DBCOMMANDTREE * *      ppRoot,
    BOOL                   fCopy)
{
    _DBErrorObj.ClearErrorInfo();

    // OLEDB spec. bug #????; fCopy is non-sensical
    if (0 == ppRoot || FALSE == fCopy)
        return _DBErrorObj.PostHResult(E_INVALIDARG, IID_IQuery);

    SCODE sc = S_OK;

    TRANSLATE_EXCEPTIONS;
    TRY
    {
        _CheckRootNode( *ppRoot );

        XPtr<CDbCmdTreeNode> TreeCopy( CDbCmdTreeNode::CastFromStruct(*ppRoot)->Clone() );
        if (0 == TreeCopy.GetPointer())
            THROW(CException(E_OUTOFMEMORY));

        ULONG cNodes = 0;
        XArrayOLE<DBCOMMANDTREE *> pNodes;

        _FindTreeNodes( TreeCopy.GetPointer(),
                        cNodes,
                        pNodes,
                        CheckForPriorTree );

        if (cNodes != 1)
        {
            vqDebugOut((DEB_WARN, "CRootQuerySpec::AddPostProcessing - "
                                   "%d references to prior tree found\n",
                                cNodes));
            THROW(CException(E_INVALIDARG));    // DB_E_BADCOMMANDTREE???
        }

        //
        //  The command tree node with DBOP_prior_command_tree can have
        //  siblings, but it must not have any children.
        //  Likewise, the original command tree can have children, but it
        //  must not have any siblings.
        //  Splice the trees together by copying the root node of the
        //  original tree onto the DBOP_prior_command_tree node, then
        //  freeing the orginal root node.
        //
        if (pNodes[0]->pctFirstChild != 0 ||
            pNodes[0]->wKind != DBVALUEKIND_EMPTY)
            THROW(CException(E_INVALIDARG));    // DB_E_BADCOMMANDTREE???

        // Perhaps we should just substitute a DBOP_table_identifier
        // node with default table in this case.

        if (0 == _pQueryTree)
            THROW(CException(E_INVALIDARG));    // DB_E_NOCOMMANDTREE???

        //
        //  Transfer the pointers and values from the root node
        //  to the prior_command_tree node.
        //

        _pQueryTree->TransferNode( CDbCmdTreeNode::CastFromStruct(pNodes[0]) );
        Win4Assert(0 == _pQueryTree->GetFirstChild() &&
                   0 == _pQueryTree->GetNextSibling() &&
                   DBVALUEKIND_EMPTY == _pQueryTree->GetValueType());

        delete _pQueryTree;
        _pQueryTree = TreeCopy.Acquire();
    }
    CATCH( CException, e )
    {
        sc = _DBErrorObj.PostHResult( e, IID_IQuery );
    }
    END_CATCH;
    UNTRANSLATE_EXCEPTIONS;

    return sc;
}

//+---------------------------------------------------------------------------
//
//  Method:     CRootQuerySpec::GetCardinalityEstimate, public
//
//  Synopsis:   Get estimated cardinality of the query tree
//
//  Arguments:  [pulCardinality] -- Pointer to memory to hold cardinality
//
//  History:    29 Jun 95   AlanW       Created
//              2 May  97   KrishnaN    Added this header block
//
//----------------------------------------------------------------------------

SCODE CRootQuerySpec::GetCardinalityEstimate(
    DBORDINAL *       pulCardinality)
{
    _DBErrorObj.ClearErrorInfo();
    vqDebugOut(( DEB_WARN, "CRootQuerySpec::GetCardinalityEstimate not implemented\n" ));
    return _DBErrorObj.PostHResult(S_FALSE, IID_IQuery);
}

//
//  ICommandProperties methods
//

//+---------------------------------------------------------------------------
//
//  Method:     DetermineScodeIndex
//
//  Synopsis:   Returns an index into a static array of SCODEs
//
//              NOTE: This function will go away once CRowsetProperties and
//                    CMRowsetProps are merged completely.
//
//  Arguments:  [sc]    - SCODE for which an index is returned
//
//  History:     01-05-98       danleg      Created
//
//----------------------------------------------------------------------------

inline ULONG DetermineScodeIndex
    (
    SCODE sc
    )
{
    switch( sc )
    {
        case S_OK:                  return 0;
        case DB_S_ERRORSOCCURRED:   return 1;
        case E_FAIL:
        default:                    return 2;
        case E_INVALIDARG:          return 3;
        case E_OUTOFMEMORY:         return 4;
        case DB_E_ERRORSOCCURRED:   return 5;
    }
}

//+---------------------------------------------------------------------------
//
//  Method:     DetermineNewSCODE
//
//  Synopsis:   Given two SCODEs returned by the two property handling
//              mechanisms used, returned a resultant SCODE to return from
//              Get/SetProperties.
//
//              NOTE: This function will go away once CRowsetProperties and
//                    CMRowsetProps are merged completely.
//
//  Arguments:
//
//  History:     01-05-98       danleg      Created
//
//----------------------------------------------------------------------------

SCODE DetermineNewSCODE
    (
    SCODE   sc1,
    SCODE   sc2
    )
{
    ULONG   isc1 = DetermineScodeIndex(sc1),
            isc2 = DetermineScodeIndex(sc2);

static const SCODE  s_rgPropHresultMap[6][6] =
    {
        {S_OK,                  DB_S_ERRORSOCCURRED,    E_FAIL, E_INVALIDARG,   E_OUTOFMEMORY,  DB_S_ERRORSOCCURRED},
        {DB_S_ERRORSOCCURRED,   DB_S_ERRORSOCCURRED,    E_FAIL, E_INVALIDARG,   E_OUTOFMEMORY,  DB_S_ERRORSOCCURRED},
        {E_FAIL,                E_FAIL,                 E_FAIL, E_FAIL,         E_FAIL,         E_FAIL},
        {E_INVALIDARG,          E_INVALIDARG,           E_FAIL, E_INVALIDARG,   E_INVALIDARG,   E_INVALIDARG},
        {E_OUTOFMEMORY,         E_OUTOFMEMORY,          E_FAIL, E_OUTOFMEMORY,  E_OUTOFMEMORY,  E_OUTOFMEMORY},
        {DB_S_ERRORSOCCURRED,   DB_S_ERRORSOCCURRED,    E_FAIL, E_INVALIDARG,   E_OUTOFMEMORY,  DB_E_ERRORSOCCURRED},
    };

    return s_rgPropHresultMap[isc1][isc2];
}

//+---------------------------------------------------------------------------
//
//  Method:     CRootQuerySpec::GetProperties, public
//
//  Synopsis:   Get rowset properties
//
//  Arguments:  [cPropertySetIDs]    - number of desired properties or 0
//              [rgPropertySetIDs]   - array of desired properties or NULL
//              [pcPropertySets]     - number of property sets returned
//              [prgPropertySets]    - array of returned property sets
//
//  History:     16 Nov 95   AlanW       Created
//               02-22-98    danleg      Changed to use CMRowsetProps
//
//----------------------------------------------------------------------------

SCODE CRootQuerySpec::GetProperties(
    const ULONG       cPropertySetIDs,
    const DBPROPIDSET rgPropertySetIDs[],
    ULONG *           pcPropertySets,
    DBPROPSET **      prgPropertySets)
{
    _DBErrorObj.ClearErrorInfo();

    SCODE sc = S_OK;

    TRANSLATE_EXCEPTIONS;
    TRY
    {
        _RowsetProps.GetPropertiesArgChk( cPropertySetIDs,
                                          rgPropertySetIDs,
                                          pcPropertySets,
                                          prgPropertySets );

        sc = _RowsetProps.GetProperties( cPropertySetIDs,
                                         rgPropertySetIDs,
                                         pcPropertySets,
                                         prgPropertySets );
    }
    CATCH( CException, e )
    {
        //
        // Don't PostHResult here.  Let the caller do the posting.
        //
        sc = _DBErrorObj.PostHResult( e, IID_ICommandProperties );
    }
    END_CATCH;
    UNTRANSLATE_EXCEPTIONS;

    return sc;
} //GetProperties

//+---------------------------------------------------------------------------
//
//  Method:     CRootQuerySpec::SetProperties, public
//
//  Synopsis:   Set rowset properties
//
//  Arguments:  [cPropertySets]  - number of property sets
//              [rgProperties]   - array of property sets to be set
//
//  History:     16 Nov 95   AlanW       Created
//
//----------------------------------------------------------------------------

SCODE CRootQuerySpec::SetProperties(
    ULONG                  cPropertySets,
    DBPROPSET              rgPropertySets[])
{
    _DBErrorObj.ClearErrorInfo();

    if ( HaveQuery() && _pInternalQuery->IsQueryActive() )
        return _DBErrorObj.PostHResult(DB_E_OBJECTOPEN, IID_ICommandProperties);

    //
    // Quick return
    //
    if( cPropertySets == 0 )
        return S_OK;

    SCODE sc = S_OK;

    TRANSLATE_EXCEPTIONS;
    TRY
    {

        CUtlProps::SetPropertiesArgChk( cPropertySets, rgPropertySets );

        if ( IsRowsetOpen() )
            THROW( CException(DB_E_OBJECTOPEN) );

        DWORD dwPropFlags = _RowsetProps.GetPropertyFlags();

        sc = _RowsetProps.SetProperties( cPropertySets, rgPropertySets );

        if ( SUCCEEDED( sc ) )
        {
            if ( _pColumnsInfo &&
                 _RowsetProps.GetPropertyFlags() != dwPropFlags )
                InitColumns();
        }
    }
    CATCH( CException, e )
    {
        //
        // Don't PostHResult here.  Let the caller do the posting.
        //

        sc = e.GetErrorCode();
    }
    END_CATCH;
    UNTRANSLATE_EXCEPTIONS;

    return sc;
}

//
//  IServiceProperties methods
//

//+---------------------------------------------------------------------------
//
//  Method:     CRootQuerySpec::GetPropertyInfo, public
//
//  Synopsis:   Get rowset properties
//
//  Arguments:  [cPropertySetIDs]    - number of desired properties or 0
//              [rgPropertySetIDs]   - array of desired properties or NULL
//              [pcPropertySets]     - number of property sets returned
//              [prgPropertySets]    - array of returned property sets
//              [ppwszDesc]          - if non-zero, property descriptions are
//                                     returneed
//
//  History:     16 Nov 95   AlanW       Created
//
//----------------------------------------------------------------------------

SCODE CRootQuerySpec::GetPropertyInfo(
    const ULONG            cPropertySetIDs,
    const DBPROPIDSET      rgPropertySetIDs[],
    ULONG *                pcPropertySets,
    DBPROPINFOSET **       prgPropertySets,
    WCHAR **               ppwszDesc)
{
    if ( (0 != cPropertySetIDs && 0 == rgPropertySetIDs) ||
          0 == pcPropertySets ||
          0 == prgPropertySets )
    {
        if (pcPropertySets)
           *pcPropertySets = 0;
        if (prgPropertySets)
           *prgPropertySets = 0;
        return _DBErrorObj.PostHResult(E_INVALIDARG, IID_IServiceProperties);
    }

    SCODE sc = S_OK;
    *pcPropertySets = 0;
    *prgPropertySets = 0;
    if (ppwszDesc)
       *ppwszDesc = 0;


    TRANSLATE_EXCEPTIONS;
    TRY
    {
        sc = _PropInfo.GetPropertyInfo( cPropertySetIDs,
                                        rgPropertySetIDs,
                                        pcPropertySets,
                                        prgPropertySets,
                                        ppwszDesc );

        // Don't PostHResult here -- it's a good chance it's a scope
        // property that we're expecting to fail.  Spare the expense.
        // The child object will post the error for us.
    }
    CATCH( CException, e )
    {
        _DBErrorObj.PostHResult(e.GetErrorCode(), IID_IServiceProperties);
        sc = GetOleError(e);

    }
    END_CATCH;
    UNTRANSLATE_EXCEPTIONS;

    return sc;
}

//+---------------------------------------------------------------------------
//
//  Method:     CRootQuerySpec::SetRequestedProperties, public
//
//  Synopsis:   Set rowset properties
//
//  Arguments:  [cPropertySets]  - number of property sets
//              [rgProperties]   - array of property sets to be set
//
//  History:    16 Nov 95   AlanW       Created
//
//----------------------------------------------------------------------------

SCODE CRootQuerySpec::SetRequestedProperties(
    ULONG                  cPropertySets,
    DBPROPSET              rgPropertySets[])
{
    if ( HaveQuery() && _pInternalQuery->IsQueryActive() )
        return _DBErrorObj.PostHResult(DB_E_OBJECTOPEN, IID_IServiceProperties);

    if ( 0 != cPropertySets && 0 == rgPropertySets)
        return _DBErrorObj.PostHResult(E_INVALIDARG, IID_IServiceProperties);

    SCODE sc = S_OK;

    TRANSLATE_EXCEPTIONS;
    TRY
    {
        sc = _RowsetProps.SetProperties( cPropertySets,
                                         rgPropertySets );

        // Don't PostHResult here -- it's a good chance it's a scope
        // property that we're expecting to fail.  Spare the expense.
        // The child object will post the error for us.
    }
    CATCH( CException, e )
    {
        _DBErrorObj.PostHResult(e.GetErrorCode(), IID_IServiceProperties);
        sc = GetOleError(e);
    }
    END_CATCH;
    UNTRANSLATE_EXCEPTIONS;

    return sc;
}

//+---------------------------------------------------------------------------
//
//  Method:     CRootQuerySpec::SetSuppliedProperties, public
//
//  Synopsis:   Set rowset properties
//
//  Arguments:  [cPropertySets]  - number of property sets
//              [rgProperties]   - array of property sets to be set
//
//  History:     16 Nov 95   AlanW       Created
//
//----------------------------------------------------------------------------

SCODE CRootQuerySpec::SetSuppliedProperties(
    ULONG                  cPropertySets,
    DBPROPSET              rgPropertySets[])
{
    if ( HaveQuery() && _pInternalQuery->IsQueryActive() )
        return _DBErrorObj.PostHResult(DB_E_OBJECTOPEN, IID_IServiceProperties);

    if ( 0 != cPropertySets && 0 == rgPropertySets)
        return _DBErrorObj.PostHResult(E_INVALIDARG, IID_IServiceProperties);

    SCODE sc = S_OK;

    TRANSLATE_EXCEPTIONS;
    TRY
    {
        sc = _RowsetProps.SetProperties( cPropertySets,
                                         rgPropertySets );

        // Don't PostHResult here -- it's a good chance it's a scope
        // property that we're expecting to fail.  Spare the expense.
        // The child object will post the error for us.
    }
    CATCH( CException, e )
    {
        _DBErrorObj.PostHResult(e.GetErrorCode(), IID_IServiceProperties);
        sc = GetOleError(e);
    }
    END_CATCH;
    UNTRANSLATE_EXCEPTIONS;

    return sc;
}


//+---------------------------------------------------------------------------
//
//  Method:     CRootQuerySpec::_CheckRootNode, private
//
//  Synopsis:   Check a client's root node for validity
//
//  Arguments:  [pRoot] -- DBCOMMANDTREE node at root of tree
//
//  Notes:      A command tree root node may have children, but it
//              may not have siblings.
//
//  History:    29 Jun 95   AlanW       Created
//
//----------------------------------------------------------------------------

void CRootQuerySpec::_CheckRootNode(
    const DBCOMMANDTREE *  pRoot)
{
    if (pRoot->pctNextSibling)
        THROW(CException(E_INVALIDARG)); 
}


//+---------------------------------------------------------------------------
//
//  Method:     CRootQuerySpec::GetColumnsInfo, private
//
//  Synopsis:   Create an IColumnsInfo* for the columns in the query tree
//
//  Arguments:  -none-
//
//  Returns:    CColumnsInfo* - a pointer to a CColumnsInfo that implements
//                              IColumnsInfo.
//
//----------------------------------------------------------------------------

static GUID guidBmk = DBBMKGUID;

CColumnsInfo * CRootQuerySpec::GetColumnsInfo()
{
    if ( 0 == _pColumnsInfo )
    {
        _pColumnsInfo = new CColumnsInfo( *((IUnknown *) (ICommand *) this),
                                          _DBErrorObj, FALSE );

        InitColumns( );
    }

    return _pColumnsInfo;
}


//+---------------------------------------------------------------------------
//
//  Method:     CRootQuerySpec::InitColumns, private
//
//  Synopsis:   Reinitialize the columns associated with the CColumnsInfo
//
//  Arguments:  -none-
//
//----------------------------------------------------------------------------

void CRootQuerySpec::InitColumns( )
{
    if ( _pQueryTree && !(_dwStatus & CMD_COLINFO_NOTPREPARED) )
    {
        BOOL fSequential = TRUE;        // need to know for CColumnsInfo ctor
        //
        // Fault-in columnsinfo.
        //
        CParseCommandTree   Parse;
        Parse.ParseTree( _pQueryTree );

        CCategorizationSet & rCateg = Parse.GetCategorization();
        CPidMapperWithNames & pidmap = Parse.GetPidmap();
        CColumnSet const * pColSet = &Parse.GetOutputColumns();

        if ( 0 != rCateg.Count() )
        {
            //
            // Ole-db spec says that for categorization, we must use the
            // top-level columns only.
            //
            pColSet = &(rCateg.Get(0)->GetColumnSet());
        }

        for ( unsigned i = 0; i < pColSet->Count(); i++ )
        {
            CFullPropSpec const * pPropSpec = pidmap.PidToName( pColSet->Get(i));
            if (pPropSpec->IsPropertyPropid() &&
                pPropSpec->GetPropertyPropid() == PROPID_DBBMK_BOOKMARK &&
                pPropSpec->GetPropSet() == guidBmk)
               fSequential = FALSE;
        }

        if ( _RowsetProps.GetPropertyFlags() &
             ( eLocatable | eScrollable ) )
            fSequential = FALSE;

        _pColumnsInfo->InitColumns( *pColSet,
                                    pidmap,
                                    fSequential );
    }
    else
    {
        _pColumnsInfo->InitColumns( (_dwStatus & CMD_COLINFO_NOTPREPARED) );
    }
}


//+---------------------------------------------------------------------------
//
//  Member:     CRootQuerySpec::CreateAccessor
//
//  Synopsis:   Makes an accessor that a client can use to get data.
//
//  Arguments:  [dwAccessorFlags]  -- read/write access requested
//              [cBindings]    -- # of bindings in rgBindings
//              [rgBindings]   -- array of bindings for the accessor to support
//              [cbRowSize]    -- ignored for IRowset
//              [phAccessor]   -- returns created accessor if all is ok
//              [rgBindStatus] -- array of binding statuses
//
//  Returns:    SCODE error code
//
//  History:    11-07-95   srikants   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

STDMETHODIMP CRootQuerySpec::CreateAccessor(
    DBACCESSORFLAGS     dwAccessorFlags,
    DBCOUNTITEM         cBindings,
    const DBBINDING     rgBindings[],
    DBLENGTH            cbRowSize,
    HACCESSOR *         phAccessor,
    DBBINDSTATUS        rgBindStatus[])
{
    _DBErrorObj.ClearErrorInfo();

    SCODE sc = S_OK;

    if (0 == phAccessor || (0 != cBindings && 0 == rgBindings))
        return _DBErrorObj.PostHResult(E_INVALIDARG, IID_IAccessor);

    // Make sure pointer is good while zeroing in case of a later error

    *phAccessor = 0;


    TRANSLATE_EXCEPTIONS;
    TRY
    {
        CColumnsInfo * pColumnsInfo = 0;

        XPtr<CRowDataAccessor> Accessor(new CRowDataAccessor(dwAccessorFlags,
                                                             cBindings,
                                                             rgBindings,
                                                             rgBindStatus,
                                   (_RowsetProps.GetPropertyFlags() & eExtendedTypes) != 0,
                                                             (IUnknown *) (ICommand *) this,
                                                             pColumnsInfo
                                                             ));
        CLock lck( _mtxCmd );

        _aAccessors.Add( Accessor.GetPointer() );

        *phAccessor = (Accessor.Acquire())->Cast();
    }
    CATCH(CException, e)
    {
        sc = _DBErrorObj.PostHResult( e, IID_IAccessor );
        _DBErrorObj.PostHResult( sc, IID_IAccessor );
    }
    END_CATCH;
    UNTRANSLATE_EXCEPTIONS;

    return sc;
}

//+---------------------------------------------------------------------------
//
//  Member:     CRootQuerySpec::GetBindings, private
//
//  Synopsis:   Returns an accessor's bindings
//
//  Arguments:  [hAccessor]   -- accessor being queried
//              [dwAccessorFlags] -- returns read/write access of accessor
//              [pcBindings]  -- returns # of bindings in rgBindings
//              [prgBindings] -- returns array of bindings
//
//  Returns:    SCODE error code
//
//  History:    14 Dec 94       dlee   Created
//
//----------------------------------------------------------------------------

STDMETHODIMP CRootQuerySpec::GetBindings(
    HACCESSOR         hAccessor,
    DBACCESSORFLAGS * pdwAccessorFlags,
    DBCOUNTITEM *     pcBindings,
    DBBINDING * *     prgBindings) /*const*/
{
    _DBErrorObj.ClearErrorInfo();

    SCODE sc = S_OK;

    if (0 == pdwAccessorFlags ||
        0 == pcBindings ||
        0 == prgBindings)
    {
        // fill in error values where possible
        if (pdwAccessorFlags)
           *pdwAccessorFlags = DBACCESSOR_INVALID;
        if (pcBindings)
           *pcBindings = 0;
        if (prgBindings)
           *prgBindings = 0;

        return _DBErrorObj.PostHResult(E_INVALIDARG, IID_IAccessor);
    }

    *pdwAccessorFlags = DBACCESSOR_INVALID;
    *pcBindings = 0;
    *prgBindings = 0;

    TRANSLATE_EXCEPTIONS;
    TRY
    {
        CLock lck( _mtxCmd );
        CAccessor * pAccessor = (CAccessor *)_aAccessors.Convert( hAccessor );
        pAccessor->GetBindings(pdwAccessorFlags, pcBindings, prgBindings);
    }
    CATCH(CException, e)
    {
        sc = _DBErrorObj.PostHResult( e, IID_IAccessor );
        _DBErrorObj.PostHResult( sc, IID_IAccessor );
    }
    END_CATCH;
    UNTRANSLATE_EXCEPTIONS;


    return sc;
}

//+---------------------------------------------------------------------------
//
//  Member:     CRootQuerySpec::AddRefAccessor, private
//
//  Synopsis:   Frees an accessor
//
//  Arguments:  [hAccessor]   -- accessor being freed
//              [pcRefCount]  -- pointer to residual refcount (optional)
//
//  Returns:    SCODE error code
//
//  History:    14 Dec 94       dlee   Created
//
//----------------------------------------------------------------------------

STDMETHODIMP CRootQuerySpec::AddRefAccessor(
    HACCESSOR   hAccessor,
    ULONG *     pcRefCount )
{
    _DBErrorObj.ClearErrorInfo();

    SCODE sc = S_OK;

    TRANSLATE_EXCEPTIONS;
    TRY
    {
        CLock lck( _mtxCmd );
        _aAccessors.AddRef( hAccessor, pcRefCount );
    }
    CATCH(CException, e)
    {
        sc = _DBErrorObj.PostHResult( e, IID_IAccessor );
        _DBErrorObj.PostHResult(sc, IID_IAccessor);
    }
    END_CATCH;
    UNTRANSLATE_EXCEPTIONS;

    return sc;
}

//+---------------------------------------------------------------------------
//
//  Member:     CRootQuerySpec::ReleaseAccessor, private
//
//  Synopsis:   Frees an accessor
//
//  Arguments:  [hAccessor]   -- accessor being freed
//              [pcRefCount]  -- pointer to residual refcount (optional)
//
//  Returns:    SCODE error code
//
//  History:    14 Dec 94       dlee   Created
//
//----------------------------------------------------------------------------

STDMETHODIMP CRootQuerySpec::ReleaseAccessor(
    HACCESSOR   hAccessor,
    ULONG *     pcRefCount )
{
    _DBErrorObj.ClearErrorInfo();

    SCODE sc = S_OK;

    TRANSLATE_EXCEPTIONS;
    TRY
    {
        CLock lck( _mtxCmd );
        _aAccessors.Release( hAccessor, pcRefCount );
    }
    CATCH(CException, e)
    {
        sc = _DBErrorObj.PostHResult( e, IID_IAccessor );
        _DBErrorObj.PostHResult(sc, IID_IAccessor);
    }
    END_CATCH;
    UNTRANSLATE_EXCEPTIONS;

    return sc;
}

//+---------------------------------------------------------------------------
//
//  Member:     CRootQuerySpec::CanConvert, public
//
//  Synopsis:   Indicate whether a type conversion is valid.
//
//  Arguments:  [wFromType]      -- source type
//              [wToType]        -- destination type
//              [dwConvertFlags] -- read/write access requested
//
//  Returns:    S_OK if the conversion is available, S_FALSE otherwise.
//              E_FAIL, E_INVALIDARG or DB_E_BADCONVERTFLAG on errors.
//
//  History:    20 Nov 96      AlanW    Created
//              14 Jan 98      VikasMan Passed IDataConvert(OLE-DB data conv.
//                                      interface) to CanConvertType
//
//----------------------------------------------------------------------------

STDMETHODIMP CRootQuerySpec::CanConvert( DBTYPE wFromType, DBTYPE wToType, DBCONVERTFLAGS dwConvertFlags )
{
    _DBErrorObj.ClearErrorInfo();

    SCODE sc = S_OK;

    TRANSLATE_EXCEPTIONS;
    TRY
    {
        if (((dwConvertFlags & DBCONVERTFLAGS_COLUMN) &&
             (dwConvertFlags & DBCONVERTFLAGS_PARAMETER)) ||
            (dwConvertFlags & ~(DBCONVERTFLAGS_COLUMN |
                                DBCONVERTFLAGS_PARAMETER |
                                DBCONVERTFLAGS_ISFIXEDLENGTH |
                                DBCONVERTFLAGS_ISLONG |
                                DBCONVERTFLAGS_FROMVARIANT)))
        {
            sc = DB_E_BADCONVERTFLAG;
        }
        else if ( ( dwConvertFlags & DBCONVERTFLAGS_FROMVARIANT ) &&
                  !IsValidFromVariantType(wFromType) )
        {
            sc = DB_E_BADTYPE;
        }
        else
        {
            // Allocate this on the stack
            XInterface<IDataConvert> xDataConvert;

            BOOL fOk = CAccessor::CanConvertType( wFromType,
                                                  wToType,
                                   (_RowsetProps.GetPropertyFlags() & eExtendedTypes) != 0,
                                    xDataConvert );
            sc = fOk ? S_OK : S_FALSE;
        }
        if (FAILED(sc))
            _DBErrorObj.PostHResult(sc, IID_IConvertType);
    }
    CATCH(CException, e)
    {
        sc = _DBErrorObj.PostHResult( e, IID_IConvertType );
        _DBErrorObj.PostHResult( sc, IID_IConvertType );
    }
    END_CATCH;
    UNTRANSLATE_EXCEPTIONS;

    return sc;
}

//+---------------------------------------------------------------------------
//
//  Member:     CRootQuerySpec::BuildTree, public
//
//  Synopsis:   Takes a cached SQL Text and translates it into a Query Tree
//              Called from Execute(), Prepare() and GetCommandTree().
//
//  Arguments:  [pIID]      -  IID of interface calling this function
//
//
//  Returns:    [S_OK]          - a command tree was built successfully
//              [DB_S_NORESULT] - the command didn't generate a tree
//                                (e.g SET PROPERTYNAME...)
//              All error codes are thrown.
//
//
//  History:    10-31-97        danleg      Created
//              01-01-98        danleg      Moved global views to CreateParser
//
//----------------------------------------------------------------------------

SCODE CRootQuerySpec::BuildTree( )
{
    SCODE sc = S_OK;

    DBCOMMANDTREE * pDBCOMMANDTREE = 0;

    XInterface<IParserTreeProperties> xIPTProperties;

    LCID lcidContent =   GetLCIDFromString((LPWSTR)_RowsetProps.GetValString(
                                    CMRowsetProps::eid_DBPROPSET_MSIDXS_ROWSET_EXT,
                                    CMRowsetProps::eid_MSIDXSPROPVAL_COMMAND_LOCALE_STRING));

    //
    // Synch IParserSession's catalog cache with DBPROP_CURRENTCATALOG.  If no session,
    // catalogs are specified using the catalog..scope() syntax anyway.
    //
    if ( !_xSession.IsNull() )
    {
        LPCWSTR pwszCatalog = ((_xSession->GetDataSrcPtr())->GetDSPropsPtr())->GetValString(
                                    CMDSProps::eid_DBPROPSET_DATASOURCE,
                                    CMDSProps::eid_DBPROPVAL_CURRENTCATALOG );

        _xpIPSession->SetCatalog( pwszCatalog );
    }

    // NOTE: For CREATE VIEW and SET PROPERTYNAME calls, ToTree will return DB_S_NORESULT
    sc = _xpIPSession->ToTree( lcidContent,
                               _pwszSQLText,
                               &pDBCOMMANDTREE,
                               xIPTProperties.GetPPointer() );

    if( S_OK == sc )
    {
        //
        // Set flag to indicate that BuildTree is calling SetCommandTree
        //
        _dwStatus |= CMD_TEXT_TOTREE;

        // Set the command tree
        sc = SetCommandTree( &pDBCOMMANDTREE, DBCOMMANDREUSE_NONE, FALSE );
        if ( SUCCEEDED(sc) )
        {
            VARIANT vVal;
            VariantInit( &vVal );

            // We need to set the QUERY_RESTRICTION so it can be cloned into
            // the rowset properties object
            if( SUCCEEDED( xIPTProperties->GetProperties(PTPROPS_CIRESTRICTION,
                                                         &vVal)) )
            {
                _RowsetProps.SetValString(
                    CMRowsetProps::eid_DBPROPSET_MSIDXS_ROWSET_EXT,
                    CMRowsetProps::eid_MSIDXSPROPVAL_QUERY_RESTRICTION,
                    (LPCWSTR)V_BSTR(&vVal) );
            }
            VariantClear( &vVal );
        }
    }
    else if( FAILED(sc) && !xIPTProperties.IsNull() )
    {
        // Retrieve Error Information
        SCODE           sc2 = S_OK;
        DISPPARAMS *    pDispParams = NULL;
        VARIANT         vVal[3];
        ULONG           ul;

        for(ul=0; ul<NUMELEM(vVal); ul++)
            VariantInit(&vVal[ul]);

        if( SUCCEEDED(sc2 = xIPTProperties->GetProperties(
                                            PTPROPS_ERR_IDS, &vVal[0])) )
        {
            if( (V_I4(&vVal[0]) > 0) && SUCCEEDED(sc2 = xIPTProperties->GetProperties(
                                                PTPROPS_ERR_HR, &vVal[1])) )
            {
                if( SUCCEEDED(sc2 = xIPTProperties->GetProperties(
                                                    PTPROPS_ERR_DISPPARAM, &vVal[2])) )
                {
                    // Change safearray into DISPPARMS
                    SAFEARRAY* psa = V_ARRAY(&vVal[2]);
                    if( psa && psa->rgsabound[0].cElements)
                    {
                        pDispParams = (DISPPARAMS*)CoTaskMemAlloc(sizeof(DISPPARAMS));
                        if( pDispParams )
                        {
                            pDispParams->cNamedArgs = 0;
                            pDispParams->rgdispidNamedArgs = NULL;
                            pDispParams->cArgs = psa->rgsabound[0].cElements;
                            pDispParams->rgvarg =
                                (VARIANT*)CoTaskMemAlloc(sizeof(VARIANTARG) * psa->rgsabound[0].cElements);
                            if( pDispParams->rgvarg )
                            {
                                for (ULONG i=0; i<psa->rgsabound[0].cElements; i++)
                                {
                                    VariantInit(&(pDispParams->rgvarg[i]));
                                    V_VT(&(pDispParams->rgvarg[i])) = VT_BSTR;
                                    V_BSTR(&(pDispParams->rgvarg[i])) = ((BSTR*)psa->pvData)[i];
                                    ((BSTR*)psa->pvData)[i] = NULL;
                                }
                            }
                        }
                    }

                    // Post a parser error
                    _DBErrorObj.PostParserError( V_I4(&vVal[1]),
                                                 V_I4(&vVal[0]),
                                                 &pDispParams );

                    // This is the SCODE of the error just posted.
                    sc2 = V_I4(&vVal[1]);
                    if ( FAILED(sc2) )
                        sc = sc2;

                    Win4Assert( pDispParams == NULL ); // Should be null after post
                }
            }
        }

        for ( ul=0; ul<NUMELEM(vVal); ul++ )
            VariantClear( &vVal[ul] );
    }

    if( pDBCOMMANDTREE )
        FreeCommandTree( &pDBCOMMANDTREE );

    if ( FAILED(sc) )
        THROW( CException(sc) );

    return sc;
}

//+---------------------------------------------------------------------------
//
//  Member:     CRootQuerySpec::CreateParser, private
//
//  Synopsis:   Creates a parser object if one was not passed through a session
//
//  History:    11-25-97    danleg      Created
//
//----------------------------------------------------------------------------

void CRootQuerySpec::CreateParser()
{
    SCODE sc = S_OK;

    CLock lck( _mtxCmd );

    sc = MakeIParser( _xIParser.GetPPointer() );
    if ( FAILED(sc) )
    {
        Win4Assert( sc != E_INVALIDARG );
        THROW( CException(sc) );
    }

    XInterface<IColumnMapperCreator> xColMapCreator;

    XInterface<CImpIParserVerify> xIPVerify(new CImpIParserVerify());

    //
    // Create an IParserSession object
    //
    xIPVerify->GetColMapCreator( ((IColumnMapperCreator**)xColMapCreator.GetQIPointer()) );

    sc = _xIParser->CreateSession( &DBGUID_MSSQLTEXT,
                                   DEFAULT_MACHINE,
                                   xIPVerify.GetPointer(),
                                   xColMapCreator.GetPointer(),
                                   (IParserSession**)_xpIPSession.GetQIPointer() );
    if ( FAILED(sc) )
        THROW( CException(sc) );

    //
    // Set default catalog in the parser session object
    //
    _xpwszCatalog.Init( MAX_PATH );
    ULONG cOut;
    sc = xIPVerify->GetDefaultCatalog( _xpwszCatalog.GetPointer(),
                                       _xpwszCatalog.Count(),
                                       &cOut);

    //
    // _xpwszCatalog isn't long enough
    //
    Win4Assert( E_INVALIDARG != sc );
    if ( FAILED(sc) )
        THROW( CException(sc) );

    sc = _xpIPSession->SetCatalog( _xpwszCatalog.GetPointer() );
    if( FAILED(sc) )
        THROW( CException(sc) );


    DBCOMMANDTREE * pDBCOMMANDTREE = 0;
    XInterface<IParserTreeProperties> xIPTProperties;

    LCID lcidContent =   GetLCIDFromString((LPWSTR)_RowsetProps.GetValString(
                                    CMRowsetProps::eid_DBPROPSET_MSIDXS_ROWSET_EXT,
                                    CMRowsetProps::eid_MSIDXSPROPVAL_COMMAND_LOCALE_STRING));

    //
    // Predefined views
    //
    sc = _xpIPSession->ToTree( lcidContent,
                               s_pwszPredefinedViews,
                               &pDBCOMMANDTREE,
                               xIPTProperties.GetPPointer() );
    if ( FAILED(sc) )
        THROW( CException(sc) );
} //CreateParser
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\icommand\proputl.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 2000.
//
//  File:       proputl.cxx
//
//  Contents:   Utility object for sharing property information between
//              the commandobject and the rowset object
//
//  Classes:    CMRowsetProps   : public CUtlProps
//              CMDSProps       : public CUtlProps
//              CMSessProps     : public CUtlProps
//              CMDSPropInfo    : public CUtlPropInfo
//
//  History:    10-28-97        danleg    Created from monarch utlprop.cpp
//
//----------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include <propglob.hxx>
#include <ntverp.h>
#include <proputl.hxx>
#include <proprst.hxx>
#include "propinfr.h"
#include "proptbl.hxx"

//-----------------------------------------------------------------------------
// Constants
//-----------------------------------------------------------------------------
#define __L(x)            L ## x
#define _L(x)              __L(x)   // Lx
#define __Q(x)                #x
#define _Q(x)              __Q(x)   // "x"
#define _LQ(x)          _L(_Q(x))   // L"x"

// Returns string of the form L"0"L"0"L"."L"0"L"0" L"." L"0000"
// The version should be of the format ##.##.####.
#define MakeProvVerString(x, y, z) _LQ(0)_LQ(x) L"." _LQ(y) L"." _LQ(z)

static const LPWSTR pwszProviderOLEDBVer    = L"02.00";
static const LPWSTR pwszProviderVersion     = MakeProvVerString(VER_PRODUCTMAJORVERSION, VER_PRODUCTMINORVERSION, VER_PRODUCTBUILD);
//static const LPWSTR pwszProviderVersion     = MakeProvVerString(VER_PRODUCTVERSION_STRING, VER_PRODUCTBUILD);
static const LCID   lcidNeutral             = MAKELCID(MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),SORT_DEFAULT);
static const LPWSTR pwszNeutral             = L"NEUTRAL";
static const LCID   InvalidLCID             = 0xFFFFFFFF;
static const LPWSTR s_wszCATALOG            = L"catalog";
static const LPWSTR s_wszIndexServer        = L"Indexing Service";
static const LPWSTR s_wszIndexServerVer     = L"03.00.0000";
static const LPWSTR s_wszProviderFileName   = L"query.dll";

//-----------------------------------------------------------------------------
// Constants and structures for file read/write.
//-----------------------------------------------------------------------------

//
// Note that this must match up with the enum CMDSProps::EID.
// We don't support all the properties listed in the spec.
//
static const UPROPINFO s_rgdbPropInit[] =
{
//PM_(AUTH_CACHE_AUTHINFO),             VT_BOOL,    PF_(DBINIT) | PF_(READ) | PF_(WRITE),
//PM_(AUTH_ENCRYPT_PASSWORD),           VT_BOOL,    PF_(DBINIT) | PF_(READ) | PF_(WRITE),
PM_(AUTH_INTEGRATED),                   VT_BSTR,    PF_(DBINIT) | PF_(READ) | PF_(WRITE),
//PM_(AUTH_MASK_PASSWORD),              VT_BOOL,    PF_(DBINIT) | PF_(READ) | PF_(WRITE),
//PM_(AUTH_PASSWORD),                   VT_BSTR,    PF_(DBINIT) | PF_(READ) | PF_(WRITE),
//PM_(AUTH_PERSIST_ENCRYPTED),          VT_BOOL,    PF_(DBINIT) | PF_(READ) | PF_(WRITE),
//PM_(AUTH_PERSIST_SENSITIVE_AUTHINFO), VT_BOOL,    PF_(DBINIT) | PF_(READ) | PF_(WRITE),
//PM_(AUTH_USERID),                     VT_BSTR,    PF_(DBINIT) | PF_(READ) | PF_(WRITE),
//PM_(INIT_ASYNCH),                     VT_I4,      PF_(DBINIT) | PF_(READ),
//--PM_(INIT_CATALOG),                  VT_BSTR,    PF_(DBINIT) | PF_(READ) | PF_(WRITE),
PM_(INIT_DATASOURCE),                   VT_BSTR,    PF_(DBINIT) | PF_(READ) | PF_(WRITE),
PM_(INIT_HWND),                         VT_I4,      PF_(DBINIT) | PF_(READ) | PF_(WRITE),
//PM_(INIT_IMPERSONATION_LEVEL),          VT_I4,      PF_(DBINIT) | PF_(READ) | PF_(WRITE),
PM_(INIT_LCID),                         VT_I4,      PF_(DBINIT) | PF_(READ) | PF_(WRITE),
PM_(INIT_LOCATION),                     VT_BSTR,    PF_(DBINIT) | PF_(READ) | PF_(CHANGE),
//PM_(INIT_MODE),                       VT_I4,      PF_(DBINIT) | PF_(READ) | PF_(WRITE),
PM_(INIT_OLEDBSERVICES),                VT_I4,      PF_(DBINIT) | PF_(READ) | PF_(WRITE),
PM_(INIT_PROMPT),                       VT_I2,      PF_(DBINIT) | PF_(READ) | PF_(WRITE),
//PM_(INIT_PROTECTION_LEVEL),           VT_I4,      PF_(DBINIT) | PF_(READ) | PF_(WRITE),
//PM_(INIT_PROVIDERSTRING),             VT_BSTR,    PF_(DBINIT) | PF_(READ) | PF_(WRITE),
//PM_(INIT_TIMEOUT),                    VT_I4,      PF_(DBINIT) | PF_(READ) | PF_(WRITE),
};

static const UPROPINFO s_rgdbPropDS[] =
{
PM_(CURRENTCATALOG),                VT_BSTR,    PF_(DATASOURCE) | PF_(READ) | PF_(WRITE),
PM_(RESETDATASOURCE),               VT_I4,      PF_(DATASOURCE) | PF_(READ) | PF_(WRITE),
};

static const UPROPINFO s_rgdbPropSESS[] =
{
PM_(SESS_AUTOCOMMITISOLEVELS),      VT_I4,      PF_(SESSION) | PF_(READ),
};

//
// DataSource. Must match with the enumerator in header of CMDSProps
//
static const UPROPINFO s_rgdbPropDSInfo[] =
{
PM_(ACTIVESESSIONS),                VT_I4,      PF_(DATASOURCEINFO) | PF_(READ),
//NEVER: PM_(ASYNCTXNABORT),        VT_BOOL,    PF_(DATASOURCEINFO) | PF_(READ),
//NEVER: PM_(ASYNCTXNCOMMIT),       VT_BOOL,    PF_(DATASOURCEINFO) | PF_(READ),
PM_(BYREFACCESSORS),                VT_BOOL,    PF_(DATASOURCEINFO) | PF_(READ),
PM_(CATALOGLOCATION),               VT_I4,      PF_(DATASOURCEINFO) | PF_(READ),
PM_(CATALOGTERM),                   VT_BSTR,    PF_(DATASOURCEINFO) | PF_(READ),
PM_(CATALOGUSAGE),                  VT_I4,      PF_(DATASOURCEINFO) | PF_(READ),
PM_(COLUMNDEFINITION),              VT_I4,      PF_(DATASOURCEINFO) | PF_(READ),
//NEVER: PM_(CONCATNULLBEHAVIOR),   VT_I4,      PF_(DATASOURCEINFO) | PF_(READ),
//NEVER: PM_(DATASOURCENAME),       VT_BSTR,    PF_(DATASOURCEINFO) | PF_(READ),
PM_(DATASOURCEREADONLY),            VT_BOOL,    PF_(DATASOURCEINFO) | PF_(READ),
PM_(DBMSNAME),                      VT_BSTR,    PF_(DATASOURCEINFO) | PF_(READ),
PM_(DBMSVER),                       VT_BSTR,    PF_(DATASOURCEINFO) | PF_(READ),
PM_(DSOTHREADMODEL),                VT_I4,      PF_(DATASOURCEINFO) | PF_(READ),
PM_(GROUPBY),                       VT_I4,      PF_(DATASOURCEINFO) | PF_(READ),
PM_(HETEROGENEOUSTABLES),           VT_I4,      PF_(DATASOURCEINFO) | PF_(READ),
//NEVER: PM_(IDENTIFIERCASE),       VT_I4,      PF_(DATASOURCEINFO) | PF_(READ),
PM_(MAXOPENCHAPTERS),               VT_I4,      PF_(DATASOURCEINFO) | PF_(READ),
//NEVER: PM_(MAXINDEXSIZE),         VT_I4,      PF_(DATASOURCEINFO) | PF_(READ),
PM_(MAXROWSIZE),                    VT_I4,      PF_(DATASOURCEINFO) | PF_(READ),
//NEVER: PM_(MAXROWSIZEINCLUDESBLOB),VT_BOOL,   PF_(DATASOURCEINFO) | PF_(READ),
PM_(MAXTABLESINSELECT),             VT_I4,      PF_(DATASOURCEINFO) | PF_(READ),
PM_(MULTIPLEPARAMSETS),             VT_BOOL,    PF_(DATASOURCEINFO) | PF_(READ),
PM_(MULTIPLERESULTS),               VT_I4,      PF_(DATASOURCEINFO) | PF_(READ),
PM_(MULTIPLESTORAGEOBJECTS),        VT_BOOL,    PF_(DATASOURCEINFO) | PF_(READ),
//NEVER: PM_(MULTITABLEUPDATE),     VT_BOOL,    PF_(DATASOURCEINFO) | PF_(READ),
PM_(NULLCOLLATION),                 VT_I4,      PF_(DATASOURCEINFO) | PF_(READ),
PM_(OLEOBJECTS),                    VT_I4,      PF_(DATASOURCEINFO) | PF_(READ),
PM_(ORDERBYCOLUMNSINSELECT),        VT_BOOL,    PF_(DATASOURCEINFO) | PF_(READ),
PM_(OUTPUTPARAMETERAVAILABILITY),   VT_I4,      PF_(DATASOURCEINFO) | PF_(READ),
PM_(PERSISTENTIDTYPE),              VT_I4,      PF_(DATASOURCEINFO) | PF_(READ),
//NEVER: PM_(PREPAREABORTBEHAVIOR), VT_I4,      PF_(DATASOURCEINFO) | PF_(READ),
//NEVER: PM_(PREPARECOMMITBEHAVIOR),VT_I4,      PF_(DATASOURCEINFO) | PF_(READ),
//NEVER: PM_(PROCEDURETERM),        VT_BSTR,    PF_(DATASOURCEINFO) | PF_(READ),
PM_(PROVIDERFRIENDLYNAME),          VT_BSTR,    PF_(DATASOURCEINFO) | PF_(READ),
PM_(PROVIDERNAME),                  VT_BSTR,    PF_(DATASOURCEINFO) | PF_(READ),
PM_(PROVIDEROLEDBVER),              VT_BSTR,    PF_(DATASOURCEINFO) | PF_(READ),
PM_(PROVIDERVER),                   VT_BSTR,    PF_(DATASOURCEINFO) | PF_(READ),
//NEVER: PM_(QUOTEDIDENTIFIERCASE), VT_I4,      PF_(DATASOURCEINFO) | PF_(READ),
PM_(ROWSETCONVERSIONSONCOMMAND),    VT_BOOL,    PF_(DATASOURCEINFO) | PF_(READ),
//NEVER: PM_(SCHEMATERM),           VT_BSTR,    PF_(DATASOURCEINFO) | PF_(READ),
//NEVER: PM_(SCHEMAUSAGE),          VT_I4,      PF_(DATASOURCEINFO) | PF_(READ),
PM_(SQLSUPPORT),                    VT_I4,      PF_(DATASOURCEINFO) | PF_(READ),
PM_(STRUCTUREDSTORAGE),             VT_I4,      PF_(DATASOURCEINFO) | PF_(READ),
PM_(SUBQUERIES),                    VT_I4,      PF_(DATASOURCEINFO) | PF_(READ),
PM_(SUPPORTEDTXNDDL),               VT_I4,      PF_(DATASOURCEINFO) | PF_(READ),
PM_(SUPPORTEDTXNISOLEVELS),         VT_I4,      PF_(DATASOURCEINFO) | PF_(READ),
PM_(SUPPORTEDTXNISORETAIN),         VT_I4,      PF_(DATASOURCEINFO) | PF_(READ),
//NEVER: PM_(TABLETERM),            VT_BSTR,    PF_(DATASOURCEINFO) | PF_(READ),
//NEVER: PM_(USERNAME),             VT_BSTR,    PF_(DATASOURCEINFO) | PF_(READ),
//--PM_(CONNECTIONSTATUS),          VT_I4,      PF_(DATASOURCEINFO) | PF_(READ),
//--PM_(SERVERNAME),                VT_BSTR     PF_(DATASOURCEINFO) | PF_(READ),
};

//
// This is used by CMDSProps, CMDSPropInfo
//
static const UPROPSET s_rgIDXPropertySets[] =
{
&DBPROPSET_DBINIT,              NUMELEM(s_rgdbPropInit),            s_rgdbPropInit,         0,
&DBPROPSET_DATASOURCEINFO,      NUMELEM(s_rgdbPropDSInfo),          s_rgdbPropDSInfo,       0,
&DBPROPSET_DATASOURCE,          NUMELEM(s_rgdbPropDS),              s_rgdbPropDS,           0,
&DBPROPSET_SESSION,             NUMELEM(s_rgdbPropSESS),            s_rgdbPropSESS,         0,
&DBPROPSET_ROWSET,              NUMELEM(s_rgdbPropRowset),          s_rgdbPropRowset,       0,
&DBPROPSET_MSIDXS_ROWSET_EXT,   NUMELEM(s_rgdbPropMSIDXSExt),       s_rgdbPropMSIDXSExt,    0,
&DBPROPSET_QUERY_EXT,           NUMELEM(s_rgdbPropQueryExt),        s_rgdbPropQueryExt,     0,
};

//
// Note: There is an enum for these offsets in utlprop.h (eid_DBPOPSET_xx).
// This is used by CMDSProps.
//
static const UPROPSET s_rgDSPropSets[] =
{
&DBPROPSET_DBINIT,                  NUMELEM(s_rgdbPropInit),        s_rgdbPropInit, 0,
&DBPROPSET_DATASOURCEINFO,          NUMELEM(s_rgdbPropDSInfo),      s_rgdbPropDSInfo, 0,
&DBPROPSET_DATASOURCE,              NUMELEM(s_rgdbPropDS),          s_rgdbPropDS, 0,
};
//
//////////////////////////////////////////////////////////////////

//
// This is used by CMSessProps.
//
static const UPROPSET s_rgSessPropSets[] =
{
&DBPROPSET_SESSION,                 NUMELEM(s_rgdbPropSESS),        s_rgdbPropSESS, 0,
};


// module handle for query.dll
extern HANDLE g_hCurrentDll;


//
//  CMDSProps methods
//

//+---------------------------------------------------------------------------
//
//  Method:     CMDSProps::CMDSProps, public
//
//  Synopsis:   Constructor
//
//  History:    11-12-97    danleg      Created from Monarch
//
//----------------------------------------------------------------------------

CMDSProps::CMDSProps(CImpIParserVerify* pIPVerify)
        : CUtlProps(ARGCHK_PROPERTIESINERROR)
{
    _xIPVerify.Set(pIPVerify);
    _xIPVerify->AddRef();

    FInit();
}


//+---------------------------------------------------------------------------
//
//  Method:     CMDSProps::ValidateCatalog, public
//
//  Synopsis:   Validate the catalog values
//
//  Returns:    S_OK    - valid
//              S_FALSE - invalid
//
//  History:    11-12-97    danleg      Created from Monarch
//
//----------------------------------------------------------------------------

SCODE CMDSProps::ValidateCatalog
    (
    VARIANT* pvValue
    )
{
    SCODE   sc = S_OK;

    if ( 0 != (V_VT(pvValue) == VT_BSTR) && (V_BSTR(pvValue)) )
    {
        _xIPVerify->VerifyCatalog( 0, V_BSTR(pvValue) );
    }
    else
        sc = S_FALSE;

    return sc;
}


//+---------------------------------------------------------------------------
//
//  Method:     CMDSProps::ValidateLocale, public
//
//  Synopsis:   Verifies the validity of the LCID given in *pVariant.  Done by
//              checking a list of valid LCID's
//
//  Returns:    S_OK    - valid LCID
//              S_FALSE - invalid LCID
//
//  History:    11-12-97    danleg      Created from Monarch
//              01-06-99    danleg      Use IsValidLocale to validate LCID
//
//----------------------------------------------------------------------------

SCODE CMDSProps::ValidateLocale(VARIANT *pVariant)
{
    BOOL fValidLCID = FALSE;

    if ( V_VT(pVariant) != VT_I4 )
        return S_FALSE;

    fValidLCID = IsValidLocale( V_I4(pVariant), LCID_SUPPORTED );

    return fValidLCID ? S_OK : S_FALSE;
}

//+---------------------------------------------------------------------------
//
//  Method:     CMDSProps::ExposeMinimalSets, public
//
//  Synopsis:   Minimize the number of propertysets exposed.  Done in response
//              to IDBInitialize::Uninitialize
//
//  History:    11-12-97    danleg      Created from Monarch
//
//----------------------------------------------------------------------------

void CMDSProps::ExposeMinimalSets()
{
    // Temporarily trick ourselves into thinking we only have
    // the first propset.
    SetUPropSetCount(eid_DBPROPSET_DBINIT+1);
}

//+---------------------------------------------------------------------------
//
//  Method:     CMDSProps::ExposeMaximalSets, public
//
//  Synopsis:   Maximize the number of property sets we expose.  New ones are
//              initialized.  Done in response to IDBInitialize::Initialize
//
//  History:    11-12-97    danleg      Created from Monarch
//
//----------------------------------------------------------------------------

SCODE CMDSProps::ExposeMaximalSets
    (
    )
{
    ULONG       iPropSet;
    SCODE       sc = S_OK;

    // Expose the non-init propsets.
    // They might have values left over, so re-initialize.

    SetUPropSetCount(eid_DBPROPSET_NUM);
    for (iPropSet=eid_DBPROPSET_DBINIT+1; iPropSet < GetUPropSetCount(); iPropSet++)
    {
        sc = FillDefaultValues( iPropSet );
        if ( FAILED(sc) )
            return sc;
    }
    return S_OK;
};

//+---------------------------------------------------------------------------
//
//  Method:     CMDSProps::GetDefaultValue, private
//
//  Synopsis:   Retrieve the initial value for a propid.
//              DEVNOTE:  Using the index from 0 to (GetCountofAvailPropSets-1)
//                        and an index of 0 to (GetCountofAvailPropidsInPropset-1)
//                        within that propertyset, return the correct information.
//                        NOTE: pVar shoudl be initialized prior to this routine.
//
//  History:    11-12-97    danleg      Created from Monarch
//
//----------------------------------------------------------------------------

SCODE CMDSProps::GetDefaultValue
    (
    ULONG       iCurSet,
    DBPROPID    dwPropId,
    DWORD*      pdwOption,
    VARIANT*    pvValue
    )
{
    WCHAR*  pwszValue;
    LPCWSTR pwszCatalog;

    Win4Assert( V_VT(pvValue) == VT_EMPTY );

    switch( iCurSet )
    {
        case eid_DBPROPSET_DATASOURCEINFO:
            *pdwOption = DBPROPOPTIONS_REQUIRED;
            switch( dwPropId )
            {
                case DBPROP_BYREFACCESSORS:
                case DBPROP_MULTIPLEPARAMSETS:
                case DBPROP_MULTIPLESTORAGEOBJECTS:
                case DBPROP_ORDERBYCOLUMNSINSELECT:
                    V_VT(pvValue)   = VT_BOOL;
                    V_BOOL(pvValue) = VARIANT_FALSE;
                    break;

                case DBPROP_DATASOURCEREADONLY:
                case DBPROP_ROWSETCONVERSIONSONCOMMAND:
                    V_VT(pvValue)   = VT_BOOL;
                    V_BOOL(pvValue) = VARIANT_TRUE;
                    break;

                case DBPROP_CATALOGLOCATION:
                    V_VT(pvValue) = VT_I4;
                    V_I4(pvValue) = DBPROPVAL_CL_START;
                    break;

                case DBPROP_CATALOGUSAGE:
                    V_VT(pvValue) = VT_I4;
                    V_I4(pvValue) = DBPROPVAL_CU_DML_STATEMENTS;
                    break;

                case DBPROP_NULLCOLLATION:
                    V_VT(pvValue) = VT_I4;
                    V_I4(pvValue) = DBPROPVAL_NC_LOW;
                    break;

                case DBPROP_OUTPUTPARAMETERAVAILABILITY:
                    V_VT(pvValue) = VT_I4;
                    V_I4(pvValue) = DBPROPVAL_OA_NOTSUPPORTED;
                    break;

                case DBPROP_MULTIPLERESULTS:
                    V_VT(pvValue) = VT_I4;
                    V_I4(pvValue) = DBPROPVAL_MR_NOTSUPPORTED;
                    break;

                case DBPROP_DSOTHREADMODEL:
                    V_VT(pvValue) = VT_I4;
                    V_I4(pvValue) = DBPROPVAL_RT_FREETHREAD;
                    break;

                case DBPROP_SQLSUPPORT:
                    pvValue->vt = VT_I4;
                    V_I4(pvValue) = DBPROPVAL_SQL_ODBC_MINIMUM;
                    break;

                case DBPROP_MAXTABLESINSELECT:
                    V_VT(pvValue)       = VT_I4;
                    V_I4(pvValue)       = 1;
                    break;

                case DBPROP_ACTIVESESSIONS:
                case DBPROP_COLUMNDEFINITION:
                case DBPROP_HETEROGENEOUSTABLES:
                case DBPROP_MAXROWSIZE:
                case DBPROP_OLEOBJECTS:
                case DBPROP_STRUCTUREDSTORAGE:
                case DBPROP_SUBQUERIES:
                case DBPROP_SUPPORTEDTXNISORETAIN:
                case DBPROP_GROUPBY:
                case DBPROP_MAXOPENCHAPTERS:
                    V_VT(pvValue)       = VT_I4;
                    V_I4(pvValue)       = 0;
                    break;

                case DBPROP_SUPPORTEDTXNISOLEVELS:
                    V_VT(pvValue)   = VT_I4;
                    V_I4(pvValue)   = DBPROPVAL_TI_BROWSE;
                    break;

                case DBPROP_SUPPORTEDTXNDDL:
                    V_VT(pvValue)       = VT_I4;
                    V_I4(pvValue)       = DBPROPVAL_TC_NONE;
                    break;

                case DBPROP_PERSISTENTIDTYPE:
                    V_VT(pvValue) = VT_I4;
                    V_I4(pvValue) =  DBPROPVAL_PT_GUID_PROPID;
                    break;

                // The following are static value, so just allocate the bstr buffer
                // and return the value
                case DBPROP_DBMSNAME:
                case DBPROP_DBMSVER:
                case DBPROP_PROVIDEROLEDBVER:
                case DBPROP_PROVIDERFRIENDLYNAME:
                case DBPROP_PROVIDERNAME:
                case DBPROP_PROVIDERVER:
                case DBPROP_CATALOGTERM:
                    switch( dwPropId )
                    {
                        case DBPROP_CATALOGTERM:
                            pwszValue = s_wszCATALOG;
                            break;
                        case DBPROP_DBMSNAME:
                            pwszValue = s_wszIndexServer;
                            break;
                        case DBPROP_DBMSVER:
                            pwszValue = s_wszIndexServerVer;
                            break;
                        case DBPROP_PROVIDERNAME:
                            pwszValue = s_wszProviderFileName;  // query.dll
                            break;
                        case DBPROP_PROVIDERFRIENDLYNAME:
                            pwszValue = g_wszProviderName;      // Microsoft OLE DB Provider for Indexing Service
                            break;
                        case DBPROP_PROVIDERVER:
                            pwszValue = (PWSTR)&(pwszProviderVersion[0]);
                            break;
                        case DBPROP_PROVIDEROLEDBVER:
                            pwszValue = (PWSTR)&(pwszProviderOLEDBVer[0]);
                            break;
                        default:
                            Win4Assert( !"Every inner case value match an outer case value" );
                            break;
                    }
                    V_VT(pvValue)       = VT_BSTR;
                    V_BSTR(pvValue)     = SysAllocString(pwszValue);
                    if ( 0 == V_BSTR(pvValue) )
                    {
                        V_VT(pvValue) = VT_EMPTY;
                    }
                    break;

                default:
                    //Indicate that value is unknown
                    VariantClear(pvValue);
                break;

            }

            break;

        case eid_DBPROPSET_DATASOURCE:
            *pdwOption = DBPROPOPTIONS_OPTIONAL;
            switch( dwPropId)
            {
                case DBPROP_CURRENTCATALOG:
                    pwszCatalog = GetValString(eid_DBPROPSET_DBINIT,eid_DBPROPVAL_INIT_DATASOURCE);
                    V_VT(pvValue)       = VT_BSTR;
                    V_BSTR(pvValue)     = SysAllocString(pwszCatalog);
                    break;

                case DBPROP_RESETDATASOURCE:
                    V_VT(pvValue)       = VT_I4;
                    V_I4(pvValue)       = 0;
                    break;

                default:
                    Win4Assert(!"A property in DBPROPSET_DATASOURCE was requested that does not have a default");
                    break;
            }
            break;

        case eid_DBPROPSET_DBINIT:
            *pdwOption = DBPROPOPTIONS_OPTIONAL;
            switch( dwPropId )
            {
                case DBPROP_AUTH_INTEGRATED:
                    V_VT(pvValue)       = VT_BSTR;
                    V_BSTR(pvValue)     = 0;
                    break;

                case DBPROP_INIT_DATASOURCE:
                    HandleCatalog( pvValue );
                    break;

                case DBPROP_INIT_LOCATION:
                    V_VT(pvValue)       = VT_BSTR;
                    V_BSTR(pvValue)     = SysAllocString( DEFAULT_MACHINE );
                    break;

                case DBPROP_INIT_LCID:
                    V_VT(pvValue)       = VT_I4;
                    V_I4(pvValue)       = GetUserDefaultLCID();
                    break;

                case DBPROP_INIT_OLEDBSERVICES:
                    V_VT(pvValue)       = VT_I4;
                    V_I4(pvValue)       = DBPROPVAL_OS_ENABLEALL;
                    break;

/*
                case DBPROP_INIT_ASYNCH:
                    V_VT(pvValue)       = VT_I4;
                    V_BSTR(pvValue)     = 0;
                    break;

                case DBPROP_INIT_PROVIDERSTRING:
                    V_VT(pvValue)       = VT_BSTR;
                    if ( IsMonarch() )
                        V_BSTR(pvValue) = SysAllocString(L"msidxs");
                    else
                        V_BSTR(pvValue) = SysAllocString(L"msidxsnl");

                    break;
*/
                case DBPROP_INIT_PROMPT:
                    // For this, we have a known value.
                    // Note that NOPROMPT is safer for server usage.
                    // (Otherwise a hidden window is presented, and we will appear to hang.)
                    pvValue->vt = VT_I2;
                    V_I2(pvValue) = DBPROMPT_NOPROMPT;
                    break;

                case DBPROP_INIT_HWND:
                default:
                    // For these, we don't have a value (empty).
                    VariantClear(pvValue);
                    break;
            }
            break;

        default:
            // Invalid Property Set
            Win4Assert( ! "Invalid property set in GetDefaultValue.");
            return E_FAIL;
    }

    return S_OK;
}


//+---------------------------------------------------------------------------
//
//  Method:     CMDSProps::IsValidValue, private
//
//  Synopsis:   Validate that the variant contains legal values for its
//              particular type and for the particular PROPID in this propset.
//              DEVNOTE: This routine has to apply to writable properties only.
//
//  History:    11-12-97    danleg      Created from Monarch
//
//----------------------------------------------------------------------------

SCODE CMDSProps::IsValidValue
    (
    ULONG       iCurSet,
    DBPROP*     pDBProp
    )
{
    // Check BOOLEAN values
    if ( (pDBProp->vValue.vt == VT_BOOL) &&
        !((V_BOOL(&(pDBProp->vValue)) == VARIANT_TRUE) ||
          (V_BOOL(&(pDBProp->vValue)) == VARIANT_FALSE)) )
        return S_FALSE;

    switch(iCurSet)
    {
        case eid_DBPROPSET_DATASOURCEINFO:
        default:
            return S_FALSE;
        case eid_DBPROPSET_DATASOURCE:
            switch( pDBProp->dwPropertyID )
            {
                case DBPROP_CURRENTCATALOG:
                    return ValidateCatalog(&(pDBProp->vValue));
                    break;

                case DBPROP_RESETDATASOURCE:
                    if ( VT_I4 != V_VT(&(pDBProp->vValue)) ||
                         !(DBPROPVAL_RD_RESETALL == V_I4(&(pDBProp->vValue)) ||
                                               0 == V_I4(&(pDBProp->vValue))) )
                        return S_FALSE;
                    break;

                default:
                    return S_FALSE;
            }
            break;

        case eid_DBPROPSET_DBINIT:
            switch( pDBProp->dwPropertyID )
            {
                case DBPROP_AUTH_INTEGRATED:
                    //          VariantCopy() translates a NULL BSTR ptr to 
                    //          an empty BSTR.  Check for both.
                    if ( VT_BSTR != V_VT(&(pDBProp->vValue)) ||
                         (0 != V_BSTR(&pDBProp->vValue) &&
                          L'\0' != V_BSTR(&pDBProp->vValue)[0]) )
                        return S_FALSE;
                    break;

                case DBPROP_INIT_DATASOURCE:
                    return ValidateCatalog(&(pDBProp->vValue));
                    break;

                case DBPROP_INIT_PROMPT:
                    // These are the only values we support (from spec).
                    if ( pDBProp->vValue.vt != VT_I2
                    || ! ( V_I2(&pDBProp->vValue) == DBPROMPT_PROMPT
                        || V_I2(&pDBProp->vValue) == DBPROMPT_COMPLETE
                        || V_I2(&pDBProp->vValue) == DBPROMPT_COMPLETEREQUIRED
                        || V_I2(&pDBProp->vValue) == DBPROMPT_NOPROMPT))
                        return S_FALSE;
                    break;

                case DBPROP_INIT_LOCATION:
                case DBPROP_INIT_HWND:
                case DBPROP_INIT_PROVIDERSTRING:
                case DBPROP_INIT_OLEDBSERVICES:   
                    break;

                case DBPROP_INIT_LCID:
                    return ValidateLocale(&(pDBProp->vValue));
                    // We support these, with any value.
                    break;

                default:
                    // Anything else, we don't support.
                    // Note that an alternative would be to allow setting
                    // to EMPTY or to FALSE.
                    return S_FALSE;
                    break;
            }
            break;
    }

    return S_OK;    // Is valid
}


//+---------------------------------------------------------------------------
//
//  Method:     CMDSProps::InitAvailUPropSets, private
//
//  Synopsis:   Provide property set information to the base class
//
//  History:    11-12-97    danleg      Created from Monarch
//
//----------------------------------------------------------------------------

SCODE CMDSProps::InitAvailUPropSets
    (
    ULONG*          pcUPropSet,
    UPROPSET**      ppUPropSet,
    ULONG*          pcElemPerSupported
    )
{
    Win4Assert( pcUPropSet && ppUPropSet );
    Win4Assert( NUMELEM(s_rgdbPropInit) == eid_INIT_PROPS_NUM );
    Win4Assert( NUMELEM(s_rgdbPropDSInfo) == eid_DSINFO_PROPS_NUM );
    Win4Assert( NUMELEM(s_rgdbPropDS) == eid_DS_PROPS_NUM );

    *pcUPropSet = NUMELEM(s_rgDSPropSets);
    *ppUPropSet = (UPROPSET*)s_rgDSPropSets;
    *pcElemPerSupported = DWORDSNEEDEDPERSET;

    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Method:     CMDSProps::InitUPropSetsSupported, private
//
//  Synopsis:   Build the required supported property bitmask for the property
//              set supported by this class.
//
//  History:    11-12-97    danleg      Created from Monarch
//
//----------------------------------------------------------------------------

SCODE CMDSProps::InitUPropSetsSupported
    (
    DWORD* rgdwSupported
    )
{
    Win4Assert( rgdwSupported );

    // Initialize the bitmask to indicate all properties are supported
    RtlFillMemory( rgdwSupported,
                   DWORDSNEEDEDPERSET * NUMELEM(s_rgDSPropSets) * sizeof(DWORD),
                   0xFF);

    // The following assert is to gaurentee that the PROPSET described
    // at index 1 is always DBPROPSET_DATASOURCEINFO.
    Win4Assert( *(s_rgIDXPropertySets[1].pPropSet) == DBPROPSET_DATASOURCEINFO );

    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Method:     CMDSProps::HandleCatalog, private
//
//  Synopsis:   Retrieve the initial value for the catalog values
//
//  History:    11-12-97    danleg      Created from Monarch
//
//----------------------------------------------------------------------------

void CMDSProps::HandleCatalog
    (
    VARIANT *pvValue
    )
{
    WCHAR wszCatalog[256] = L"";
    ULONG cOut;

    _xIPVerify->GetDefaultCatalog( wszCatalog, NUMELEM(wszCatalog), &cOut );

    V_VT(pvValue)       = VT_BSTR;
    V_BSTR(pvValue)     = SysAllocString(wszCatalog);
}


//
//  CMSessProps methods
//

//+---------------------------------------------------------------------------
//
//  Method:     CMSessProps::GetDefaultValue, private
//
//  Synopsis:   Retrieve the initial value for a propid.
//              DEVNOTE:  Using the index from 0 to (GetCountofAvailPropSets-1)
//                        and an index of 0 to (GetCountofAvailPropidsInPropset-1)
//                        within that propertyset, return the correct information.
//                        NOTE: pVar shoudl be initialized prior to this routine.
//
//
//  History:    11-12-97    danleg      Created from Monarch
//
//----------------------------------------------------------------------------

// ---------------------------------------------------------------------------
// CMSessProps::GetDefaultValue
// @mfunc Retrieve the initial value for the propids.
//
// @devnote Using the index from 0 to (GetCountofAvailPropSets - 1) and a index
// of 0 to (GetCountofAvailPropidsInPropSet - 1) within that property set return
// the correct information. NOTE: pVar should be initialized prior to this
// routine
//
// @rdesc SCODE indicating status
//
SCODE CMSessProps::GetDefaultValue
    (
    ULONG       iCurSet,
    DBPROPID    dwPropId,
    DWORD*      pdwOption,
    VARIANT*    pvValue
    )
{
    Win4Assert( V_VT(pvValue) == VT_EMPTY );

    switch( iCurSet )
    {
        case eid_DBPROPSET_SESSION:
            switch( dwPropId )
            {
                case DBPROP_SESS_AUTOCOMMITISOLEVELS:
                    *pdwOption = DBPROPOPTIONS_REQUIRED;
                    V_VT(pvValue)   = VT_I4;
                    V_I4(pvValue)   = DBPROPVAL_TI_BROWSE;
                    break;
                default:
                    //Indicate that value is unknown
                    VariantClear(pvValue);
                break;

            }

            break;
        default:
            // Invalid Property Set
            Win4Assert( ! "Invalid property set in GetDefaultValue.");
            return E_FAIL;
    }

    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Method:     CMSessProps::IsValidValue, private
//
//  Synopsis:   Validate that the variant contains legal values for its
//              particular type and for the particular PROPID in this propset
//
//  History:    11-12-97    danleg      Created from Monarch
//
//----------------------------------------------------------------------------

SCODE CMSessProps::IsValidValue
    (
    ULONG       iCurSet,
    DBPROP*     pDBProp
    )
{
    switch(iCurSet)
    {
    case eid_SESS_AUTOCOMMITISOLEVELS:
        switch( pDBProp->dwPropertyID )
        {
            case DBPROP_SESS_AUTOCOMMITISOLEVELS:
                break;
            default:
                return S_FALSE;
        }
        break;
    default:
        return S_FALSE;
    }

    return S_OK;    // Is valid
}

//+---------------------------------------------------------------------------
//
//  Method:     CMSessProps::InitAvailUPropSets, private
//
//  Synopsis:   Provide property set information to the base class
//
//  History:    11-12-97    danleg      Created from Monarch
//
//----------------------------------------------------------------------------

SCODE CMSessProps::InitAvailUPropSets
    (
    ULONG*          pcUPropSet,
    UPROPSET**      ppUPropSet,
    ULONG*          pcElemPerSupported
    )
{
    Win4Assert( pcUPropSet && ppUPropSet);
    Win4Assert( NUMELEM(s_rgdbPropSESS) == eid_SESS_PROPS_NUM );

    *pcUPropSet = NUMELEM(s_rgSessPropSets);
    *ppUPropSet = (UPROPSET*)s_rgSessPropSets;
    *pcElemPerSupported = DWORDSNEEDEDPERSET;

    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Method:     CMSessProps::InitUPropSetsSupported, private
//
//  Synopsis:   Build the required supported property bitmask for the property
//              set supported by this class
//
//  History:    11-12-97    danleg      Created from Monarch
//
//----------------------------------------------------------------------------

SCODE CMSessProps::InitUPropSetsSupported
    (
    DWORD* rgdwSupported
    )
{
    Win4Assert( rgdwSupported );

    // Initialize the bitmask to indicate all properties are supported
    RtlFillMemory ( rgdwSupported,
                    DWORDSNEEDEDPERSET * NUMELEM(s_rgSessPropSets) * sizeof(DWORD),
                    0xFF);

    return S_OK;
}




//
// CMDSPropInfo methods
//

//+---------------------------------------------------------------------------
//
//  Method:     CMDSPropInfo::InitAvailUPropSets, private
//
//  Synopsis:   Provide property set information to the base class
//
//  History:    11-12-97    danleg      Created from Monarch
//
//----------------------------------------------------------------------------

SCODE CMDSPropInfo::InitAvailUPropSets
    (
    ULONG*          pcUPropSet,
    UPROPSET**      ppUPropSet,
    ULONG*          pcElemPerSupported
    )
{
    Win4Assert( pcUPropSet && ppUPropSet);

    // The datasource info properties array should always match the DBPROP enum.
    Win4Assert( NUMELEM(s_rgdbPropDSInfo) == eid_DSINFO_PROPS_NUM );

    *pcUPropSet = NUMELEM(s_rgIDXPropertySets);
    *ppUPropSet = (UPROPSET*)s_rgIDXPropertySets;
    *pcElemPerSupported = DWORDSNEEDEDPERSET;

    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Method:     CMDSPropInfo::InitUPropSetsSupported, private
//
//  Synopsis:   Build the required supported property bitmask for the property
//              set supported by this class
//
//  History:    11-12-97    danleg      Created from Monarch
//
//----------------------------------------------------------------------------

SCODE CMDSPropInfo::InitUPropSetsSupported
    (
    DWORD* rgdwSupported
    )
{
    Win4Assert( rgdwSupported );

    // Initialize the bitmask to indicate all properties are supported
    RtlFillMemory ( rgdwSupported,
                    DWORDSNEEDEDPERSET * NUMELEM(s_rgIDXPropertySets) * sizeof(DWORD),
                    0xFF );
    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Method:     CMDSPropInfo::LoadDescription, private
//
//  Synopsis:   Load a property description string into a buffer.
//
//  Returns:    ULONG - Count of characters returned in the buffer
//
//  Notes:      Property descriptions are used in ADO programming.  They
//              should not be localized strings.
//
//  History:    11-12-97    danleg      Created from Monarch
//
//----------------------------------------------------------------------------

ULONG CMDSPropInfo::LoadDescription
    (
    LPCWSTR pwszDesc,   //@parm IN | Description String
    PWSTR   pwszBuff,   //@parm OUT | Temporary buffer
    ULONG   cchBuff     //@parm IN | Count of characters buffer can hold
    )
{
    Win4Assert( pwszDesc && pwszBuff && cchBuff );

    ULONG cchDesc = wcslen(pwszDesc);

    if (cchDesc < cchBuff)
    {
        wcscpy(pwszBuff, pwszDesc);
    }
    else
    {
        pwszBuff[0] = L'\0';
        cchDesc = 0;
    }

    return cchDesc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\icommand\stdqspec.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1998.
//
//  File:       StdQSpec.cxx
//
//  Contents:   IQuery for file-based queries
//
//  Classes:    CQuerySpec
//
//  History:    30 Jun 1995   AlanW   Created
//
//----------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

extern long gulcInstances;

#include <cidbprop.hxx>
#include <cmdprutl.hxx>
#include <dbprputl.hxx>
#include <datasrc.hxx>
#include <session.hxx>
#include <dsocf.hxx>
#include <lgplist.hxx>
#include <propglob.hxx>

#include "stdqspec.hxx"


//+-------------------------------------------------------------------------
//
//  Member:     CQuerySpec::QueryInternalQuery, protected
//
//  Synopsis:   Instantiates internal query, using current parameters.
//
//  Returns:    Pointer to internal query object.
//
//  History:    03-Mar-1997   KyleP    Created
//              14-May-1997   mohamedn hidden core/fs property sets
//
//--------------------------------------------------------------------------

PIInternalQuery * CQuerySpec::QueryInternalQuery()
{
    //
    // get a pointer to the PIInternalQuery interface
    //

    XInterface<CDbProperties> xIDbProps(new CDbProperties);
    if ( xIDbProps.IsNull() )
        THROW( CException( E_OUTOFMEMORY ) );

    CGetCmdProps getCmdProps( (ICommand *)this);
    SCODE sc;
    PIInternalQuery * pQuery;

    ULONG cardinality = getCmdProps.GetCardinality();

    if ( cardinality <= 1 )
    {
        getCmdProps.PopulateDbProps( xIDbProps.GetPointer() );

        sc = EvalQuery( &pQuery,
                        xIDbProps.GetReference(),
                        _xDocStore.GetPointer());
    }
    else
    {
        Win4Assert( !_xDocStore.GetPointer() );

        sc = EvalDistributedQuery( &pQuery, getCmdProps );
    }

    if ( FAILED( sc ) )
        QUIETTHROW( CException( sc ) );

    Win4Assert( 0 != pQuery );

    return pQuery;
} //QueryInternalQuery

//+-------------------------------------------------------------------------
//
//  Member:     CQuerySpec::CQuerySpec, public
//
//  Synopsis:   Constructor of a CQuerySpec
//
//  Arguments:  [pOuterUnk] - Outer unknown
//              [ppMyUnk]   - OUT:  filled in with pointer to non-delegated
//                            IUnknown on return
//              [pDocStore] - Known DocStore
//
//  History:    22-Apr-97   KrishnaN    Created
//
//--------------------------------------------------------------------------

CQuerySpec::CQuerySpec ( IUnknown * pOuterUnk, IUnknown ** ppMyUnk, ICiCDocStore * pDocStore )
        : CRootQuerySpec(pOuterUnk, ppMyUnk)
{
    //
    // Squirrel away DocStore.
    //

    pDocStore->AddRef();
    _xDocStore.Set(pDocStore);

    InitScopePropertySets();
} //CQuerySpec

//+-------------------------------------------------------------------------
//
//  Member:     CQuerySpec::InitScopePropertySets, private
//
//  Synopsis:   Initializes internal data structs
//
//  Arguments:  none
//
//  History:    06-04-97   mohamedn    Created
//
//--------------------------------------------------------------------------

void CQuerySpec::InitScopePropertySets()
{
    RtlZeroMemory( _aPropSet, sizeof (_aPropSet) );

    _aCoreProps.Init    ( INITIAL_PROPERTIES_COUNT );
    _aFsClientProps.Init( INITIAL_PROPERTIES_COUNT );

    _aPropSet[0].guidPropertySet = DBPROPSET_CIFRMWRKCOREEXT;
    _aPropSet[0].rgProperties    = _aCoreProps.GetPointer();

    _aPropSet[1].guidPropertySet = DBPROPSET_FSCIFRMWRKEXT;
    _aPropSet[1].rgProperties    = _aFsClientProps.GetPointer();
} //InitScopePropertySets

//+---------------------------------------------------------------------------
//
//  Method:     CQuerySpec::SetProperties, public
//
//  Synopsis:   Set rowset scope properties
//
//  Arguments:  [cPropertySets]   - number of property sets
//              [rgPropertySets]  - array of property sets
//
//  Returns:    SCODE - result code indicating error return status.  One of
//                      S_OK, DB_S_ERRORSOCCURRED or DB_E_ERRORSOCCURRED.  Any
//                      other errors are thrown.
//
//  History:    01-Mar-97   KyleP       Created
//              14-May-97   mohamedn    hidden core/fs property set details
//              12-Dec-97   danleg      ReleaseInternalQuery if setting scope props
//
//----------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE CQuerySpec::SetProperties( ULONG     cPropertySets,
                                                   DBPROPSET rgPropertySets[] )
{

    _DBErrorObj.ClearErrorInfo();

    //
    // First, get parent properties.
    //
    SCODE scParent = CRootQuerySpec::SetProperties( cPropertySets, rgPropertySets );

    //
    // Any non-understood error is a bail. Return the error/successes from the parent.
    //
    if ( scParent != DB_S_ERRORSOCCURRED && scParent != DB_E_ERRORSOCCURRED )
        return scParent;


    BOOL  fFoundErrors = FALSE;
    SCODE sc = S_OK;

    //
    //  Set properties not handled by parent
    //

    TRANSLATE_EXCEPTIONS;
    TRY
    {
        DBPROPSET *pDbPropset    = rgPropertySets;
        BOOL       fScopeProps   = FALSE;

        for ( unsigned i = 0; i < cPropertySets; i++, pDbPropset++ )
        {
            if ( DBPROPSET_FSCIFRMWRKEXT   == pDbPropset->guidPropertySet ||
                 DBPROPSET_CIFRMWRKCOREEXT == pDbPropset->guidPropertySet )
            {
                 SetPropertyset( pDbPropset );
                 fScopeProps = TRUE;
            }
            else
            {
                //
                // keep track of any errors occured in base class.
                //
                DBPROP * pProp  = pDbPropset->rgProperties;
                ULONG    cProps = pDbPropset->cProperties;

                for ( unsigned j = 0; j < cProps; j++ )
                {
                    if ( DBPROPSTATUS_OK != pProp[j].dwStatus )
                        fFoundErrors = TRUE;
                }
            }
        }

        //
        // If we found any scope properties, release the
        // internal query object.
        //
        if ( fScopeProps )
        {
            ReleaseInternalQuery();
        }
    }
    CATCH( CException, e )
    {
        scParent = GetOleError( e );

        fFoundErrors = TRUE;
    }
    END_CATCH;
    UNTRANSLATE_EXCEPTIONS;

    if ( fFoundErrors )
    {
        if ( S_OK != scParent )
        {
            _DBErrorObj.PostHResult( scParent, IID_ICommandProperties );
            return scParent;

        }
        else
        {
            _DBErrorObj.PostHResult( DB_S_ERRORSOCCURRED, IID_ICommandProperties );
            return DB_S_ERRORSOCCURRED;
        }
    }
    else
        return S_OK;
} //SetProperties

//+---------------------------------------------------------------------------
//
//  Method:     CQuerySpec::SetPropertyset, private
//
//  Synopsis:   Sets non-rowset properties
//
//  Arguments:  [pPropertyset]  - pointer to property set (to be set).
//
//  Returns:    none - THROWS upon failure.
//
//  History:    05-14-97    mohamedn    created
//
//----------------------------------------------------------------------------

void CQuerySpec::SetPropertyset( DBPROPSET *pPropertySet )
{

    DBPROP * pProp = pPropertySet->rgProperties;
    ULONG    cProps= pPropertySet->cProperties;

    //
    // un-error property dwStatus set by parent
    //

    for ( unsigned j = 0; j < cProps; j++ )
    {
        switch ( pProp[j].dwStatus )
        {
        case DBPROPSTATUS_NOTSUPPORTED:

             pProp[j].dwStatus = DBPROPSTATUS_OK;

             break;

        case DBPROPSTATUS_OK:

             break;

        default:
             vqDebugOut(( DEB_ERROR, "Unexpected pProp[j].dwStatus: j=%x, dwStatus=%x \n",j,pProp[j].dwStatus ));
        }
    }

    //
    // identify destination propset
    //
    for ( unsigned k = 0; k < SCOPE_PROPSET_COUNT; k++ )
    {
       if ( _aPropSet[k].guidPropertySet == pPropertySet->guidPropertySet )
          break;
    }

    if ( k == SCOPE_PROPSET_COUNT )
    {
        Win4Assert( !"Should never be hit" );
        THROW( CException(DB_E_ERRORSOCCURRED));
    }

    //
    // update property set
    //
    UpdatePropertySet( _aPropSet[k], *pPropertySet );
} //SetPropertyset

//+---------------------------------------------------------------------------
//
//  Method:     CQuerySpec::UpdatePropertySet, private
//
//  Synopsis:   Sets non-rowset properties
//
//  Arguments:  [destPropSet]      - destination property set
//              [srcPropSet]       - source property set
//
//  Returns:    none - THROWS upon failure.
//
//  History:    06-04-97    mohamedn    created
//
//----------------------------------------------------------------------------

void CQuerySpec::UpdatePropertySet(DBPROPSET &destPropSet, DBPROPSET &srcPropSet )
{
    CDbProp * pDestProp = (CDbProp *)destPropSet.rgProperties;
    CDbProp * pSrcProp  = (CDbProp *)srcPropSet.rgProperties;
    ULONG     cErrors   = 0;

    for ( unsigned i = 0; i < srcPropSet.cProperties; i++ )
    {
        for ( unsigned j = 0; j < destPropSet.cProperties; j++ )
        {
            if ( pDestProp[j].dwPropertyID == pSrcProp[i].dwPropertyID )
            {
                if ( !pDestProp[j].Copy(pSrcProp[i]) )
                    THROW( CException(E_OUTOFMEMORY) );

                break;
            }
        }

        if ( j == destPropSet.cProperties )
        {
            //
            // new PropID
            //
            if (  destPropSet.guidPropertySet == DBPROPSET_CIFRMWRKCOREEXT &&
                  j >= _aCoreProps.Count() )
            {
                  _aCoreProps.GrowToSize( srcPropSet.cProperties );

                  _aPropSet[0].rgProperties = _aCoreProps.GetPointer();

                  pDestProp = (CDbProp *)destPropSet.rgProperties;
            }
            else if ( destPropSet.guidPropertySet == DBPROPSET_FSCIFRMWRKEXT &&
                      j >= _aFsClientProps.Count() )
            {
                  _aFsClientProps.GrowToSize( srcPropSet.cProperties );

                  _aPropSet[1].rgProperties = _aFsClientProps.GetPointer();

                  pDestProp = (CDbProp *)destPropSet.rgProperties;
            }

            Win4Assert( pDestProp[j].dwPropertyID == 0 );
            Win4Assert( pDestProp[j].dwStatus     == 0 );

            if ( !pDestProp[j].Copy(pSrcProp[i]) )
                THROW( CException(E_OUTOFMEMORY) );

            destPropSet.cProperties++;
        }
    }

    if ( cErrors == srcPropSet.cProperties )
        THROW (CException( DB_E_ERRORSOCCURRED ) );

    if ( cErrors > 0 )
        THROW (CException( DB_S_ERRORSOCCURRED ) );
} //UpdatePropertySet

//+---------------------------------------------------------------------------
//
//  Method:     CQuerySpec::GetProperties, public
//
//  Synopsis:   Get rowset properties
//
//  Arguments:  [cPropertySetIDs]  - number of desired property set IDs or 0
//              [rgPropertySetIDs] - array of desired property set IDs or NULL
//              [pcPropertySets]   - number of property sets returned
//              [prgPropertySets]  - array of returned property sets
//
//  Returns:    SCODE - result code indicating error return status.  One of
//                      S_OK, DB_S_ERRORSOCCURRED or DB_E_ERRORSOCCURRED.  Any
//                      other errors are thrown.
//
//  History:    01-Mar-97   KyleP       Created
//              14-May-97   mohamedn    hidden core/fs property set details
//
//----------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE CQuerySpec::GetProperties(
    ULONG        const   cPropertySetIDs,
    DBPROPIDSET  const   rgPropertySetIDs[],
    ULONG *              pcPropertySets,
    DBPROPSET **         prgPropertySets)
{
    _DBErrorObj.ClearErrorInfo();

    BOOL fAddScopeProperties = FALSE;
    ULONG cPropSetIDs = cPropertySetIDs;

    XArray<CDbPropIDSet> aPropIDSets;
    CDbPropIDSet * pPropIDSet = (CDbPropIDSet *)rgPropertySetIDs;
    ULONG cAllocPropSets = cPropertySetIDs;

    //
    //  Don't give back the scope properties for "all properties".  If the
    //  magic number 3141592653 is given in, all properties including the
    //  scope properties are returned.
    //

    if ( 3141592653 == cPropertySetIDs )
    {
        fAddScopeProperties = TRUE;
        cPropSetIDs = 0;

        //
        // We want all properties, including scope properties.  The base
        // implementation doesn't know about scope properties
        //

        SCODE sc = S_OK;

        TRY
        {
            aPropIDSets.Init( 5 );
        }
        CATCH( CException, e )
        {
            sc = e.GetErrorCode();
        }
        END_CATCH;

        if ( FAILED( sc ) )
            return sc;

        aPropIDSets[0].guidPropertySet = DBPROPSET_ROWSET;
        aPropIDSets[0].cPropertyIDs = 0;
        aPropIDSets[1].guidPropertySet = DBPROPSET_MSIDXS_ROWSET_EXT;
        aPropIDSets[1].cPropertyIDs = 0;
        aPropIDSets[2].guidPropertySet = DBPROPSET_QUERY_EXT;
        aPropIDSets[2].cPropertyIDs = 0;
        aPropIDSets[3].guidPropertySet = DBPROPSET_CIFRMWRKCOREEXT;
        aPropIDSets[3].cPropertyIDs = 0;
        aPropIDSets[4].guidPropertySet = DBPROPSET_FSCIFRMWRKEXT;
        aPropIDSets[4].cPropertyIDs = 0;

        cAllocPropSets = aPropIDSets.Count();
        pPropIDSet = aPropIDSets.GetPointer();
    }

    SCODE scParent = CRootQuerySpec::GetProperties( cAllocPropSets,
                                                    pPropIDSet,
                                                    pcPropertySets,
                                                    prgPropertySets );

    //
    // Any non-understood error is a bail. S_OK here means all properties were
    // handled by parent.  Just return unless *all* props were requested.
    //

    if ( scParent != DB_S_ERRORSOCCURRED && scParent != DB_E_ERRORSOCCURRED )
    {
        if ( scParent != S_OK || 0 != cPropSetIDs )
            return scParent;
    }

    SCODE sc           = S_OK;
    BOOL  fFoundErrors = FALSE;

    TRANSLATE_EXCEPTIONS;
    TRY
    {
        //
        // Find query properties.
        //

        if ( 0 == cPropSetIDs && fAddScopeProperties )
        {
            //
            // Case 1: All properties were requested.  Append scope onto
            //         appropriate property set.
            //

            for ( unsigned i = 0; i < SCOPE_PROPSET_COUNT; i++ )
            {
                DBPROPIDSET dbPropIdSet;

                ZeroMemory((void *) &dbPropIdSet, sizeof DBPROPIDSET );
                dbPropIdSet.guidPropertySet = _aPropSet[i].guidPropertySet;

                //
                // scan dest array of propsets (set by base) for matching guid.
                //

                for ( unsigned j = 0; j < *pcPropertySets; j++ )
                {
                    if ( dbPropIdSet.guidPropertySet ==
                         (*prgPropertySets)[j].guidPropertySet )
                    {
                        GetPropValues( dbPropIdSet,
                                       (*prgPropertySets)[j],
                                       fFoundErrors );
                        break;
                    }
                }

                //
                // PropSet not found
                //

                if ( j == *pcPropertySets )
                {
                    fFoundErrors = TRUE;
                    Win4Assert( !"CRowsetProperties doesn't support requested propset." );
                    Win4Assert( !"base & derived classes are out of sync!");
                }
            }
        }
        else
        {
            //
            // Case 2: Specific properties were requested.
            //

            for ( unsigned i = 0; i < cPropSetIDs; i++ )
            {
                //
                // scan dest array of propsets (set by base) for matching guid.
                //
 
                for ( unsigned j = 0; j < *pcPropertySets; j++ )
                {
                    if ( (*prgPropertySets)[j].guidPropertySet ==
                         rgPropertySetIDs[i].guidPropertySet )
                    {
                        GetPropValues( rgPropertySetIDs[i],
                                       (*prgPropertySets)[j],
                                       fFoundErrors );
                        break;
                    }
                }
 
                //
                // PropSet not found
                //
 
                if ( j == *pcPropertySets )
                {
                    fFoundErrors = TRUE;
                    Win4Assert( !"Unexpected PropertySet requested" );
                }
            }
        }
    }
    CATCH( CException, e )
    {
        sc = e.GetErrorCode();
    }
    END_CATCH
    UNTRANSLATE_EXCEPTIONS;

    if ( FAILED(sc) && sc != DB_E_ERRORSOCCURRED )
    {
        for ( unsigned i = 0; i < *pcPropertySets; i++ )
        {
            DBPROP * rgProperties = (*prgPropertySets)[i].rgProperties;
            unsigned cProperties = (*prgPropertySets)[i].cProperties;

            for ( unsigned j = 0; j < cProperties; j++ )
                VariantClear( &(rgProperties[j].vValue) );

            CoTaskMemFree( rgProperties );
        }

        CoTaskMemFree( *prgPropertySets );
        *prgPropertySets = 0;
    }

    if ( fFoundErrors )
    {
        if ( scParent != S_OK )
        {
            _DBErrorObj.PostHResult( scParent, IID_ICommandProperties );
            return scParent;
        }
        else
        {
            _DBErrorObj.PostHResult( DB_S_ERRORSOCCURRED, IID_ICommandProperties );
            return DB_S_ERRORSOCCURRED;
        }
    }

    return sc;
} //GetProperties

//+-------------------------------------------------------------------------
//
//  Member:     CQuerySpec::GetPropValues, private
//
//  Synopsis:   Gets values of properties in a property set.
//
//  Arguments:  [rgPropertySetIDs] [in]   - array of propIDs to get
//              [rgPropertySet]    [out]  - reference to property set to fill
//              [fFoundErrors]     [out]  - TRUE if any errors are found, but not thrown.
//
//  Returns:    Throws in case of failure
//
//  History:    04-15-97    mohamedn    created
//
//--------------------------------------------------------------------------

void CQuerySpec::GetPropValues( DBPROPIDSET const & rgPropertySetIDs,
                                DBPROPSET         & rgPropertySet,
                                BOOL              & fFoundErrors)
{
    Win4Assert( rgPropertySet.guidPropertySet == rgPropertySetIDs.guidPropertySet );

    //
    // Locate private property set source
    //

    for ( unsigned i = 0; i < SCOPE_PROPSET_COUNT; i++ )
    {
        if ( rgPropertySet.guidPropertySet == _aPropSet[i].guidPropertySet )
        {
            break;  // found source property set
        }
    }

    //
    // If not one of the scope propsets, return
    //

    if ( SCOPE_PROPSET_COUNT == i )
    {
        fFoundErrors = TRUE;
        return;
    }

    DBPROPSET & srcPropSet = _aPropSet[i];
    DBPROP    * psrcDbProp = srcPropSet.rgProperties;
    ULONG       cPropsFound= 0;
    ULONG       cDbProps   = rgPropertySetIDs.cPropertyIDs ?
                             rgPropertySetIDs.cPropertyIDs :
                             srcPropSet.cProperties;

    XArrayOLEInPlace<CDbProp> aDbProps( cDbProps );

    //
    // scan private property set for reqeusted propId values
    //

    if ( 0 == rgPropertySetIDs.cPropertyIDs )
    {
        //
        // return all properties
        //

        for ( i = 0; i < srcPropSet.cProperties; i++ )
        {
            if ( !aDbProps[i].Copy( psrcDbProp[i] ) )
                THROW( CException(E_OUTOFMEMORY) );

            Win4Assert( aDbProps[i].dwStatus == DBPROPSTATUS_OK );
        }

        cPropsFound = i;
    }
    else
    {
        //
        // specific properties within this prop set are requested
        //

        for ( unsigned iPropsRequested = 0; iPropsRequested < rgPropertySetIDs.cPropertyIDs; iPropsRequested++ )
        {
            for ( unsigned iPropSrc = 0; iPropSrc < srcPropSet.cProperties; iPropSrc++ )
            {
                if ( rgPropertySetIDs.rgPropertyIDs[iPropsRequested] == psrcDbProp[iPropSrc].dwPropertyID )
                {
                    if ( !aDbProps[iPropsRequested].Copy( psrcDbProp[iPropSrc] ) )
                        THROW( CException(E_OUTOFMEMORY) );

                    Win4Assert( aDbProps[iPropsRequested].dwStatus == DBPROPSTATUS_OK );

                    break;
                }
            }

            //
            // if requested propID not found
            //

            if ( iPropSrc == srcPropSet.cProperties )
            {
                //
                // Property ID not set
                //

                aDbProps[iPropsRequested].dwPropertyID = rgPropertySetIDs.rgPropertyIDs[iPropsRequested];
                aDbProps[iPropsRequested].dwStatus = DBPROPSTATUS_NOTSET;
                fFoundErrors = TRUE;
            }
        }

        cPropsFound = iPropsRequested;
    }

    //
    // free rgProperties allocated by base class, assign new one.
    //

    CoTaskMemFree( rgPropertySet.rgProperties );
    rgPropertySet.rgProperties = aDbProps.Acquire();
    rgPropertySet.cProperties  = cPropsFound;
} //GetPropValues
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\isearch\appcur.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1995 - 2000.
//
//  File:       appcur.cxx
//
//  Contents:   
//
//  History:    
//
//--------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include <curstk.hxx>
#include <isearch.hxx>

#include "appcur.hxx"

//
// Note: Don't enforce cMaxNodes as this is a client-side operation over a
// single file.  The denial of service problem doesn't exist.
//

COccCursor * CAppQueriable::QueryCursor( const CKey * pKey, BOOL isRange, ULONG & cMaxNodes )
{
    ciDebugOut(( DEB_CURSOR,
                   "CAppQueriable::QueryCursor. Key %.*ws\n isRange=%s, cMaxNodes=%d\n",
                    pKey->StrLen(), pKey->GetStr(),
                    isRange ? "TRUE" : "FALSE",
                    cMaxNodes ));


    int iPos = _recog.FindDet ( isRange? DetPrefix: DetSingleKey, pKey, 0 );
    Win4Assert ( 0 <= iPos );
    CRegionList& regList = _recog.GetRegionList (iPos);
    return new CAppCursor( regList, _hitSink );
}

COccCursor * CAppQueriable::QueryRangeCursor( const CKey * pKeyBegin,
                                              const CKey * pKeyEnd,
                                              ULONG & cMaxNodes )
{

    ciDebugOut(( DEB_CURSOR,
                   "CAppQueriable::QueryRangeCursor. KeyBegin:: %.*ws\n KeyEnd:: %.*ws\n cMaxNodes=%d\n",
                    pKeyBegin->StrLen(), pKeyBegin->GetStr(),
                    pKeyEnd->StrLen(),   pKeyEnd->GetStr(),
                    cMaxNodes ));

    int iPos = _recog.FindDet ( DetRange, pKeyBegin, pKeyEnd );
    Win4Assert ( 0 <= iPos );
    CRegionList& regList = _recog.GetRegionList (iPos);
    return new CAppCursor( regList, _hitSink );
}

COccCursor * CAppQueriable::QuerySynCursor( CKeyArray & keyArr,
                                            BOOL isRange,
                                            ULONG & cMaxNodes )
{
    COccCurStack curStk;
    COccCursor *pCur;

    int keyCount = keyArr.Count();

    ciDebugOut(( DEB_CURSOR,
                 "CAppQueriable::QuerySynCursor. isRange=%s keyCount=%d cMaxNodes=%d\n",
                 isRange ? "TRUE" : "FALSE",
                 keyCount,
                 cMaxNodes ));

    for (int i = 0; i < keyCount; i++)
    {
        CKey& key = keyArr.Get(i);

        ciDebugOut(( DEB_CURSOR,
                     "CAppQueriable::QuerySynCursor. Key %.*ws\n",
                    key.StrLen(), key.GetStr() ));

        int iPos = _recog.FindDet ( isRange? DetPrefix: DetSingleKey, &key, 0 );
        Win4Assert ( 0 <= iPos );
        CRegionList& regList = _recog.GetRegionList (iPos);
        pCur = new CAppCursor ( regList, _hitSink );

        curStk.Push(pCur);
    }

    pCur = curStk.QuerySynCursor(10);
    return pCur;
}

// Initialize private data and start the search.

CAppCursor::CAppCursor ( CRegionList& regList, CHitSink& hitSink )
: _occ(1), _regList(regList), _regIter (regList), _hitSink(hitSink),
  _fWidInvalid(FALSE)
{
    LoadPosition();
}

// pure virtual overrides for CCursor

WORKID CAppCursor::WorkId()
{
    ciDebugOut(( DEB_CURSOR, "CAppCursor::WorkId\n" ));

    if ( IsEmpty() || _fWidInvalid )
        return widInvalid;
    else
        return 1;
}

WORKID CAppCursor::NextWorkId()
{
    _fWidInvalid = TRUE;
    return widInvalid;
}

ULONG CAppCursor::HitCount()
{
    return _hitSink.Count();
}

ULONG CAppCursor::OccurrenceCount()
{
    // Win4Assert(!"CAppCursor::OccurrenceCount");
    // return max(1,_hitSink.Count());

    return 1;
}

ULONG CAppCursor::WorkIdCount()
{
    return 1;
}

LONG CAppCursor::Rank() { return MAX_QUERY_RANK; }


OCCURRENCE CAppCursor::Occurrence()
{
    return _occ;
}

OCCURRENCE CAppCursor::NextOccurrence()
{
    if (OCC_INVALID != _occ)
    {
        Advance ();
    }
    return _occ;
}

// record the hit in TheHitSink

LONG CAppCursor::Hit()
{
    ciDebugOut(( DEB_CURSOR, "CAppCursor::Hit\n" ));

    if ( _occ != OCC_INVALID )
    {
        _hitSink.AddPosition ( _regIter.GetRegionHit()->Region() );
        return MAX_QUERY_RANK;
    }
    else
    {
        return rankInvalid;
    }
}

void CAppCursor::Advance ()
{
    Win4Assert (!_regList.AtEnd(_regIter));
    _regList.Advance(_regIter);
    LoadPosition ();
}

void CAppCursor::LoadPosition ()
{
    ciDebugOut(( DEB_CURSOR, "CAppCursor::LoadPosition\n" ));

    if (_regList.AtEnd(_regIter))
    {
        _occ = OCC_INVALID;
    }
    else
    {
        _occ = _regIter.GetRegionHit()->Occurrence();
    }
}

LONG CAppCursor::NextHit()
{
    ciDebugOut(( DEB_CURSOR, "CAppCursor::NextHit\n" ));

    NextOccurrence ();
    return Hit();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\isearch\isearch.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1998
//
//  File:       isearch.cxx
//
//  Contents:   The interface specific methods of CSearch
//
//  History:    05-Dec-94   Created     BartoszM
//
//--------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include <isearch.hxx>

//+-------------------------------------------------------------------------
//
//  Method:     CSearch::QueryInterface
//
//  Synopsis:   Rebind to other interface
//
//  Arguments:  [riid]      -- IID of new interface
//              [ppvObject] -- New interface * returned here
//
//  Returns:    S_OK if bind succeeded, E_NOINTERFACE if bind failed
//
//  History:    05-Dec-1994     BartoszM     Created
//
//--------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE CSearch::QueryInterface( REFIID riid,
                                                 void  ** ppvObject)
{
    if ( 0 == ppvObject )
        return E_INVALIDARG;

    if ( IID_ISearchQueryHits == riid )
        *ppvObject = (IUnknown *)(ISearchQueryHits *)this;
    else if ( IID_IUnknown == riid )
        *ppvObject = (IUnknown *) this;
    else
    {
        *ppvObject = 0;
        return E_NOINTERFACE;
    }

    AddRef();
    return S_OK;
} //QueryInterface

//+-------------------------------------------------------------------------
//
//  Method:     CSearch::AddRef
//
//  Synopsis:   Increments refcount
//
//  History:    05-Dec-1994     BartoszM     Created
//
//--------------------------------------------------------------------------

ULONG STDMETHODCALLTYPE CSearch::AddRef()
{
    return InterlockedIncrement( &_cRefs );
}

//+-------------------------------------------------------------------------
//
//  Method:     CSearch::Release
//
//  Synopsis:   Decrement refcount.  Delete if necessary.
//
//  History:    05-Dec-1994     BartoszM     Created
//
//--------------------------------------------------------------------------

ULONG STDMETHODCALLTYPE CSearch::Release()
{
    unsigned long uTmp = InterlockedDecrement( &_cRefs );

    if ( 0 == uTmp )
        delete this;

    return uTmp;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\icommand\vquery.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1991 - 2000.
//
//  File:       VQuery.Cxx
//
//  Contents:   Query interface functions
//
//  Functions:  ProxyErrorToCIError
//              EvalQuery
//              EvalMetadataQuery
//              ForceMasterMerge
//              AbortMerges
//              CiState
//              AddScopeToCI
//              RemoveScopeFromCI
//              BeginCacheTransaction
//              SetupCacheEx
//              SetupCache
//              EndCacheTransaction
//              DumpWorkId
//              SetCatalogState
//
//  History:    18-Aug-91   KyleP       Created.
//              16-Sep-96   dlee        made it work with cisvc
//
//----------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include "svcquery.hxx"

#include <isearch.hxx>
#include <svccatpx.hxx>
#include <cidbprop.hxx>
#include <dbprputl.hxx>
#include <fsciclnt.h>
#include <ciframe.hxx>
#include <fsci.hxx>
#include <cifwexp.hxx>
#include <ciregkey.hxx>
#include <fsciexps.hxx>



typedef SCODE (* T_FsCiShutdown)(void);

static GUID clsidStorageDocStoreLocator = CLSID_StorageDocStoreLocator;
static XLibHandle gxCiFrmWrk;
static T_MakeGenericQueryForDocStore gprocMakeGenericQuery = 0;

extern CStaticMutexSem g_mtxCommandCreator;


void SetIDbProperties( IDBProperties * pIDbProp,
                       WCHAR const * pwcCatalog,
                       WCHAR const * pwcMachine,
                       GUID  &       clientGuid,
                       WCHAR const * pwcScope = 0,
                       CiMetaData eType = CiAdminOp);

//+-------------------------------------------------------------------------
//
//  Function:   ProxyErrorToCIError, public
//
//  Synopsis:   Attempt to translate an error code from the proxy into
//              a CI error code.
//
//  Arguments:  [sc]  -- source error
//
//  Returns:    The translated or original error
//
//  History:    06-Jan-98   dlee    Created
//
//--------------------------------------------------------------------------

SCODE ProxyErrorToCIError( CException & e )
{
    SCODE sc = GetScodeError( e );

    if ( HRESULT_FROM_WIN32( ERROR_FILE_NOT_FOUND ) == sc )
        sc = CI_E_NOT_RUNNING;
    else if ( STATUS_NOT_FOUND == sc )
        sc = CI_E_NOT_FOUND;
    else if ( sc == HRESULT_FROM_WIN32( ERROR_SEM_TIMEOUT ) ||
              sc == HRESULT_FROM_WIN32( ERROR_PIPE_BUSY ) )
        sc = CI_E_TIMEOUT;

    return sc;
} //ProxyErrorToCIError

//+---------------------------------------------------------------------------
//
//  Function:   CreateDbProperties
//
//  Synopsis:   Helper function to create an IDBProperties and set the
//              given parameters as DBPROPS in the IDBProperties.
//
//  Arguments:  [pwcCatalog]      - Name or location of the catalog.
//              [pwcMachine]      - Name of the machine to connect to.
//              [pwcScopes ]      - (first scope) directory.
//              [eType]           - query type
//
//  Returns:    Pointer to an initilized IDBProperties interface.
//
//  History:    1-15-97   srikants   Created
//              5-14-97   mohamedn   use SetIDbProperties
//
//----------------------------------------------------------------------------

IDBProperties * CreateDbProperties( WCHAR const * pwcCatalog,
                                    WCHAR const * pwcMachine,
                                    WCHAR const * pwcScopes = 0,
                                    CiMetaData eType = CiAdminOp )
{
    XInterface<IDBProperties> xdbp( new CDbProperties );
    if ( xdbp.IsNull() )
        THROW( CException( E_OUTOFMEMORY ) );

    SetIDbProperties( xdbp.GetPointer(),
                      pwcCatalog,
                      pwcMachine,
                      clsidStorageDocStoreLocator,
                      pwcScopes,
                      eType );

    return xdbp.Acquire();
}


//+-------------------------------------------------------------------------
//
//  Function:   LoadCiFrmWrkLibrary, private
//
//  Synopsis:   Loads the appropriate framework library
//
//  Arguments:  None
//
//  Returns:    Handle to library
//
//  History:    22-Apr-97 KrishnaN     Created
//              02-Jun-97 KrishnaN     Decide between olympus/ci version
//                                     based on registry entry.
//
//--------------------------------------------------------------------------

inline HINSTANCE LoadCiFrmWrkLibrary()
{
    HINSTANCE hLib;
    WCHAR awszLibName[MAX_PATH];

        //
        // We want to be able to load the right version of the framework dll.
        // The olympus and ci versions are for the most part similar, but not
        // identical. So when Olympus is installed, we should lookup in the
        // registry to find out what dll to use. If that registry entry is
        // not found, we default to query.dll.
        //

    wcscpy(awszLibName, L"QUERY.DLL");

    HKEY hKey;

    long sc = RegOpenKeyEx(HKEY_LOCAL_MACHINE,    // Root
                           wcsRegCommonAdminSubKey, // key
                           0,                    // Reserved
                           KEY_READ,             // Access
                           &hKey);               // Handle

    // For a smoother transition, if we don't find it in the
    // newly defined commonadminsubkey, look for it in the old place
    if (ERROR_SUCCESS != sc)
        sc = RegOpenKeyEx(HKEY_LOCAL_MACHINE,    // Root
                          L"Software\\Microsoft\\Site Server\\3.0\\Search\\CiFramework",
                          0,                    // Reserved
                          KEY_READ,             // Access
                          &hKey);               // Handle

    if (ERROR_SUCCESS == sc)
    {
        DWORD dwType = REG_SZ;
        DWORD dwSize = MAX_PATH * sizeof(WCHAR);
        // If we successfully read the value, the full path name will be read in
        sc = RegQueryValueEx(hKey,
                             L"CiFrmWrkDll",
                             0,
                             &dwType,
                             (LPBYTE)awszLibName,
                             &dwSize
                             );
        RegCloseKey(hKey);
    }

    hLib = LoadLibraryW(awszLibName);

    if ( 0 == hLib )
    {
       ciDebugOut(( DEB_ERROR, "Error %d occurred in LoadLibrary on %ws\n",
                    GetLastError(), awszLibName ));
       THROW(CException( E_UNEXPECTED ));
    }

    gprocMakeGenericQuery = (T_MakeGenericQueryForDocStore)
                                          GetProcAddress( hLib, "MakeGenericQueryForDocStore" );
    if (0 == gprocMakeGenericQuery)
    {
        ciDebugOut((DEB_ERROR, "Failed to locate MakeGenericQueryForDocStore"
                               " in the framework dll\n"));
        THROW(CException( E_UNEXPECTED ));
    }

    return hLib;
}

//+-------------------------------------------------------------------------
//
//  Function:   EvalQuery, public
//
//  Synopsis:   Simulates bind to to ci object store
//
//  Arguments:  [ppQuery]       -- returns the PIInternalQuery
//              [idbProps]      -- object exposing IDBProperties
//              [pDocStore]     -- doc store interface pointer
//
//  Returns:    SCODE result
//
//  History:    12 Dec 95    AlanW     Created
//              08-Feb-96    KyleP     Add virtual path support
//              01-Nov-96    dlee      Add multi-scope support, return scode
//              14-May-97    mohamedn  hidden fs/core property set details.
//
//--------------------------------------------------------------------------

SCODE EvalQuery(
    PIInternalQuery ** ppQuery,
    CDbProperties   &  idbProps,
    ICiCDocStore    *  pDocStore)
{
    SCODE sc = S_OK;
    PIInternalQuery * pQuery = 0;

    CTranslateSystemExceptions xlate;
    TRY
    {
        if ( pDocStore )
        {
            //
            // If the framework library is not loaded, load it and get the
            // generic query
            //

            if ( 0 == gxCiFrmWrk.Get() )
            {
                //
                // we don't want to go through this crit sect for each
                // invocation of EvalQuery. So first check for the handle
                // to be null, and then take a lock.
                // Multiple threads running simultaeneously could get past
                // the check for null handle, but only the first one that gets
                // the lock will have the chance to set the gxCiFrmWrk variable.
                // The remaining will find that the second check for null
                // handle doesn't hold and will do nothing.
                //

                CLock lock(g_mtxCommandCreator);
                if (0 == gxCiFrmWrk.Get())
                {
                    Win4Assert( 0 == gprocMakeGenericQuery);
                    gxCiFrmWrk.Set(LoadCiFrmWrkLibrary());
                }
            }

            sc = gprocMakeGenericQuery( &idbProps, pDocStore, &pQuery);
        }
        else
        {
            CGetDbProps dbProp;

            dbProp.GetProperties( &idbProps , CGetDbProps::eMachine );

            WCHAR const *pwcMachine = dbProp.GetMachine();

            if ( 0 != pwcMachine )
            {
                pQuery = new CSvcQuery( pwcMachine,
                                        &idbProps );
            }
            else
            {
                THROW( CException(E_INVALIDARG) );
            }
        }
    }
    CATCH( CException, e )
    {
        vqDebugOut(( DEB_ERROR,
                     "Catastrophic error 0x%x in EvalQuery\n",
                     e.GetErrorCode() ));
        pQuery = 0;

        //
        // NOTE: Fix for bug 86178. This is a lower level routine and it should
        // propogate errors untranslated to the upper layer (ICommand::Execute).
        //

        sc = e.GetErrorCode();
    }
    END_CATCH;

    *ppQuery = pQuery;
    return sc;
} //EvalQuery

//+-------------------------------------------------------------------------
//
//  Function:   EvalMetadataQuery, public
//
//  Synopsis:   Simulates bind to PIInternalQuery for ci object store
//
//  Arguments:  [ppQuery]     - returns the PIInternalQuery
//              [eType]       - Type of metadata
//              [wcsCat]      - Catalog location
//              [pwcsMachine] - Machine on which catalog resides
//
//  Returns:    SCODE result
//
//  History:    12 Dec 95    AlanW     Created
//              08-Feb-96    KyleP     Add virtual path support
//
//--------------------------------------------------------------------------

SCODE EvalMetadataQuery(
    PIInternalQuery ** ppQuery,
    CiMetaData         eType,
    WCHAR const *      wcsCat,
    WCHAR const *      wcsMachine )
{
    *ppQuery = 0;
    PIInternalQuery * pQuery = 0;
    SCODE sc = S_OK;

    CTranslateSystemExceptions xlate;
    TRY
    {
        XInterface<IDBProperties> xDbProps( CreateDbProperties( wcsCat,
                                                                wcsMachine,
                                                                0,
                                                                eType ) );
        Win4Assert( 0 != wcsMachine );
        pQuery = new CSvcQuery( wcsMachine, xDbProps.GetPointer() );
    }
    CATCH( CException, e )
    {
        vqDebugOut(( DEB_ERROR,
                     "Catastrophic error 0x%x in EvalMetadataQuery\n",
                     e.GetErrorCode() ));
        pQuery = 0;

        //
        // NOTE: Fix for bug 86178. This is a lower level routine and it should
        // propogate errors untranslated to the upper layer (ICommand::Execute).
        //

        sc = e.GetErrorCode();
    }
    END_CATCH;

    *ppQuery = pQuery;
    return sc;
} //EvalMetadataQuery


//+-------------------------------------------------------------------------
//
//  Function:   ForceMasterMerge, public
//
//  Synopsis:   Forces a master merge on the partition ID specified
//
//  Arguments:  [wcsDrive]    - Drive to force merge on
//              [pwcsCat]     - Catalog name
//              [pwcsMachine] - Machine on which catalog resides
//              [partId]      - PartitionID to force merge on
//
//  History:    01-Nov-95   DwightKr    Created
//
//--------------------------------------------------------------------------

SCODE ForceMasterMerge(
    WCHAR const * wcsDrive,
    WCHAR const * pwcsCat,
    WCHAR const * pwcsMachine,
    ULONG         partId )
{
    SCODE status = S_OK;

    //
    //  Verify that we have legal parameters
    //

    if ( (0==wcsDrive) || (1!=partId) )
        return E_INVALIDARG;

    CTranslateSystemExceptions xlate;
    TRY
    {
        XInterface<IDBProperties> xDbProps( CreateDbProperties( pwcsCat,
                                                                pwcsMachine,
                                                                wcsDrive ) );

        Win4Assert( 0 != pwcsMachine );
        CSvcCatProxy cat( pwcsMachine, xDbProps.GetPointer() );
        cat.ForceMerge( partId );
    }
    CATCH( CException, e )
    {
        status = ProxyErrorToCIError( e );
    }
    END_CATCH

    return status;
} //ForceMasterMerge


//+-------------------------------------------------------------------------
//
//  Function:   AbortMerges, public
//
//  Synopsis:   Aborts any merge in progress in the specified partid.
//
//  Arguments:  [wcsDrive] -- Drive to force merge on
//              [partId]   -- PartitionID to force merge on
//
//  History:    01-Nov-95   DwightKr    Created
//
//--------------------------------------------------------------------------

SCODE AbortMerges(
    WCHAR const * wcsDrive,
    WCHAR const * pwcsCat,
    WCHAR const * pwcsMachine,
    ULONG         partId )
{
    SCODE status = S_OK;

    //
    //  Verify that we have legal parameters
    //

    if ( (0==wcsDrive) || (1!=partId) )
        return E_INVALIDARG;

    CTranslateSystemExceptions xlate;
    TRY
    {
        XInterface<IDBProperties> xDbProps( CreateDbProperties( pwcsCat,
                                                                pwcsMachine,
                                                                wcsDrive ) );
        Win4Assert( 0 != pwcsMachine );
        CSvcCatProxy cat( pwcsMachine, xDbProps.GetPointer() );
        cat.AbortMerge( partId );
    }
    CATCH( CException, e )
    {
        status = ProxyErrorToCIError( e );
    }
    END_CATCH

    return status;
} //AbortMerges


//+-------------------------------------------------------------------------
//
//  Function:   CIState, public
//
//  Synopsis:   Returns the state of the CI for the drive specified.
//
//  Arguments:  [pwcsCat]     -- Catalog
//              [pwcsMachine] -- Machine name
//              [pCiState]    -- Current state of the CI
//
//  History:    01-Nov-95   DwightKr    Created
//
//--------------------------------------------------------------------------

SCODE CIState( WCHAR const * pwcsCat,
               WCHAR const * pwcsMachine,
               CI_STATE *    pCiState )
{
    //  Verify that we have legal parameters

    if ( 0 == pCiState ||
         0 == pwcsCat ||
         pCiState->cbStruct < sizeof pCiState->cbStruct )
        return E_INVALIDARG;

    if ( 0 == pwcsMachine )
        pwcsMachine = L".";

    SCODE status = S_OK;

    CTranslateSystemExceptions xlate;
    TRY
    {
        XInterface<IDBProperties> xDbProps( CreateDbProperties( pwcsCat, pwcsMachine ) );

        CSvcCatProxy cat( pwcsMachine, xDbProps.GetPointer() );
        cat.CiState( *pCiState );
    }
    CATCH( CException, e )
    {
        status = ProxyErrorToCIError( e );
    }
    END_CATCH

    return status;
} //CiState

//+-------------------------------------------------------------------------
//
//  Function:   UpdateContentIndex, public
//
//  Synopsis:   Registers documents for indexing.
//
//  Arguments:  [wcsRoot] -- Root of scope to scan for updates
//              [wcsCat]  -- Override for catalog location
//
//  Returns:
//
//  History:    23-Jun-93 KyleP     Added header
//
//--------------------------------------------------------------------------

ULONG UpdateContentIndex(
    WCHAR const * wcsRoot,
    WCHAR const * wcsCat,
    WCHAR const * wcsMachine,
    BOOL          fFull )
{
    SCODE status = S_OK;

    CTranslateSystemExceptions xlate;
    TRY
    {
        IDBProperties * pDbProps = CreateDbProperties( wcsCat, wcsMachine );
        XInterface<IDBProperties>   xProps( pDbProps );

        CSvcCatProxy cat( wcsMachine, pDbProps );
        cat.UpdateDocuments( wcsRoot, fFull ? UPD_FULL : UPD_INCREM );
    }
    CATCH( CException, e )
    {
        status = ProxyErrorToCIError( e );
    }
    END_CATCH

    return (ULONG) status;
} //UpdateContentIndex

//+---------------------------------------------------------------------------
//
//  Member:     AddScopeToCI
//
//  Synopsis:   Adds a scope for down level ContentIndex. All documents in
//              the specified scope will be indexed.
//
//  Arguments:  [wcsRoot]    - Scope to add
//              [wcsCat]     - Alternate location for catalog
//              [wcsMachine] - Machine on which catalog resides, L"." for
//                             the local machine
//
//  Returns:    Status code
//
//  History:    1-21-96   srikants   Created
//
//----------------------------------------------------------------------------

SCODE AddScopeToCI (
    WCHAR const * wcsRoot,
    WCHAR const * wcsCat,
    WCHAR const * wcsMachine )
{
    SCODE sc = S_OK;

    CTranslateSystemExceptions xlate;
    TRY
    {
        IDBProperties * pDbProps = CreateDbProperties( wcsCat, wcsMachine );
        XInterface<IDBProperties>   xProps( pDbProps );

        CSvcCatProxy cat( wcsMachine, pDbProps );
        cat.AddScopeToCI( wcsRoot );
    }
    CATCH( CException, e )
    {
        sc = GetOleError( e );
    }
    END_CATCH

    return sc;
} //AddScopeToCI

//+---------------------------------------------------------------------------
//
//  Member:     RemoveScopeFromCI
//
//  Synopsis:   Removes a scope for down level ContentIndex. All documents in
//              the specified scope will be deleted.
//
//  Arguments:  [wcsRoot]    - Scope to remove
//              [wcsCat]     - Alternate location for catalog
//              [wcsMachine] - Machine on which catalog resides, L"." for
//                             the local machine
//
//  Returns:    Status code
//
//  History:    1-21-96   srikants   Created
//
//----------------------------------------------------------------------------

SCODE RemoveScopeFromCI(
    WCHAR const * wcsRoot,
    WCHAR const * wcsCat,
    WCHAR const * wcsMachine )
{
    SCODE sc = S_OK;

    CTranslateSystemExceptions xlate;
    TRY
    {
        IDBProperties * pDbProps = CreateDbProperties( wcsCat, wcsMachine );
        XInterface<IDBProperties>   xProps( pDbProps );

        CSvcCatProxy cat( wcsMachine, pDbProps );
        cat.RemoveScopeFromCI( wcsRoot );
    }
    CATCH( CException, e )
    {
        sc = GetOleError( e );
    }
    END_CATCH

    return sc;
} //RemoveScopeFromCI

//+---------------------------------------------------------------------------
//
//  Function:   BeginCacheTransaction, public
//
//  Synopsis:   Begin a cache update session.
//
//  Arguments:  [pulToken]   - Token representing transaction returned here.
//              [wcsRoot]    - Root of scope to scan for updates
//              [wcsCat]     - Override for catalog location
//              [wcsMachine] - Machine on which catalog resides, L"." for
//                             the local machine
//
//  History:    20-Jun-96   KyleP       Created.
//
//----------------------------------------------------------------------------

SCODE BeginCacheTransaction(
    ULONG_PTR   * pulToken,
    WCHAR const * wcsRoot,
    WCHAR const * wcsCat,
    WCHAR const * wcsMachine )
{
    SCODE sc = S_OK;

    CTranslateSystemExceptions xlate;
    TRY
    {
        XInterface<IDBProperties> xDbProps( CreateDbProperties( wcsCat,
                                                                wcsMachine ) );

        CSvcCatProxy cat( wcsMachine, xDbProps.GetPointer() );
        *pulToken = 0; // Catch access violation
        *pulToken = cat.BeginCacheTransaction();
    }
    CATCH( CException, e )
    {
        sc = ProxyErrorToCIError( e );
    }
    END_CATCH

    return sc;
} //BeginCacheTransaction

//+---------------------------------------------------------------------------
//
//  Function:   SetupCacheEx, public
//
//  Synopsis:   Modify cache to store (or not store) property.
//
//  Arguments:  [ps]         - Property to cache.
//              [vt]         - Datatype of property.  VT_VARIANT if unknown.
//              [cbMaxLen]   - Soft-maximum length for variable length
//                             properties.  This much space is pre-allocated
//                             in original record.  A length of 0 will remove
//                             property from cache.
//              [ulToken]    - Token indentifying open transaction
//              [fModifiable]- Is meta info modifiable?
//              [dwLevel]    - Primary or secondary store?
//              [wcsRoot]    - Root of scope to scan for updates
//              [wcsCat]     - Override for catalog location
//              [wcsMachine] - Machine on which catalog resides, L"." for
//                             the local machine
//
//  History:    18-Nov-97   KrishnaN       Created.
//
//----------------------------------------------------------------------------

SCODE SetupCacheEx(
    FULLPROPSPEC const * ps,
    ULONG                vt,
    ULONG                cbMaxLen,
    ULONG_PTR            ulToken,
    BOOL                 fModifiable,
    DWORD                dwStoreLevel,
    WCHAR const *        wcsRoot,
    WCHAR const *        wcsCat,
    WCHAR const *        wcsMachine )
{
    Win4Assert(PRIMARY_STORE == dwStoreLevel ||
               SECONDARY_STORE == dwStoreLevel);

    SCODE sc = S_OK;

    CTranslateSystemExceptions xlate;
    TRY
    {
        XInterface<IDBProperties> xDbProps( CreateDbProperties( wcsCat,
                                                                wcsMachine ) );
        CSvcCatProxy cat( wcsMachine, xDbProps.GetPointer() );
        cat.SetupCache( *(CFullPropSpec const *)(ULONG_PTR)ps,
                        vt,
                        cbMaxLen,
                        ulToken,
                        fModifiable,
                        dwStoreLevel );
    }
    CATCH( CException, e )
    {
        sc = ProxyErrorToCIError( e );
    }
    END_CATCH

    return sc;
} //SetupCacheEx

//+---------------------------------------------------------------------------
//
//  Function:   SetupCache, public
//
//  Synopsis:   Modify cache to store (or not store) property.
//
//  Arguments:  [ps]         - Property to cache.
//              [vt]         - Datatype of property.  VT_VARIANT if unknown.
//              [cbMaxLen]   - Soft-maximum length for variable length
//                             properties.  This much space is pre-allocated
//                             in original record.  A length of 0 will remove
//                             property from cache.
//              [ulToken]    - Token indentifying open transaction
//              [wcsRoot]    - Root of scope to scan for updates
//              [wcsCat]     - Override for catalog location
//              [wcsMachine] - Machine on which catalog resides, L"." for
//                             the local machine
//
//  History:    20-Jun-96   KyleP       Created.
//              18-Nov-97   KrishnaN    Used SetupCacheEx.
//
//----------------------------------------------------------------------------

SCODE SetupCache(
    FULLPROPSPEC const * ps,
    ULONG                vt,
    ULONG                cbMaxLen,
    ULONG_PTR            ulToken,
    WCHAR const *        wcsRoot,
    WCHAR const *        wcsCat,
    WCHAR const *        wcsMachine )
{
    // Default fModifiable = TRUE and storeLevel = PRIMARY
    return SetupCacheEx(ps, vt, cbMaxLen, ulToken, TRUE,
                        PRIMARY_STORE, wcsRoot, wcsCat, wcsMachine);
} //SetupCache

//+---------------------------------------------------------------------------
//
//  Function:   EndCacheTransaction, public
//
//  Synopsis:   Ends a cache update session.
//
//  Arguments:  [ulToken]    - Token representing transaction.
//              [fCommit]    - TRUE if transaction should be commited.
//              [wcsRoot]    - Root of scope to scan for updates
//              [wcsCat]     - Override for catalog location
//              [wcsMachine] - Machine on which catalog resides, L"." for
//                             the local machine
//
//  History:    20-Jun-96   KyleP       Created.
//
//----------------------------------------------------------------------------

SCODE EndCacheTransaction(
    ULONG_PTR     ulToken,
    BOOL          fCommit,
    WCHAR const * wcsRoot,
    WCHAR const * wcsCat,
    WCHAR const * wcsMachine )
{
    SCODE sc = S_OK;

    CTranslateSystemExceptions xlate;
    TRY
    {
        XInterface<IDBProperties> xDbProps( CreateDbProperties( wcsCat,
                                                                wcsMachine ) );
        CSvcCatProxy cat( wcsMachine, xDbProps.GetPointer() );
        cat.EndCacheTransaction( ulToken, fCommit );
    }
    CATCH( CException, e )
    {
        sc = ProxyErrorToCIError( e );
    }
    END_CATCH

    return sc;
} //EndCacheTransaction

//+-------------------------------------------------------------------------
//
//  Function:   DumpWorkId, public
//
//  Synopsis:   Dump all data for a particular workid
//
//  Arguments:  [wcsDrive]   - Drive to query
//              [wid]        - Wid to search for
//              [pb]         - Buffer provided for writing results
//              [cb]         - Size of [pb]
//              [pwcsCat]    - Override for catalog location
//              [wcsMachine] - Machine on which catalog resides, L"." for
//                             the local machine
//
//  History:    03-Apr-95   KyleP       Created
//
//--------------------------------------------------------------------------

SCODE DumpWorkId(
    WCHAR const * wcsDrive,
    ULONG         wid,
    BYTE *        pb,
    ULONG &       cb,
    WCHAR const * pwcsCat,
    WCHAR const * pwcsMachine,
    ULONG         iid )
{

#if 0

#if CIDBG == 1
    SCODE status = S_OK;

    BYTE * pbStart = pb;

    CTranslateSystemExceptions xlate;
    TRY
    {
        PCatalog * pCat = GetOne( wcsDrive, pwcsCat );

        if ( 0 != pCat )
        {
            ULONG UNALIGNED * pul = (ULONG *)pb;
            pul += 2;
            *pul = 0; // Initial bookmark of zero

            unsigned const cbBuffer = 1024 * 32;

            while ( cb >= cbBuffer )
            {
                pCat->DumpWorkId( wid, iid, pb, cbBuffer );

                //
                // Find end of buffer.
                //

                for ( char * psz = (char *)pb; *psz; psz++ )
                    continue;

                //
                // Check for null ulong
                //

                psz++;
                pul = (ULONG UNALIGNED *)psz;
                if ( *pul == 0 )
                {
                    pb = (BYTE *)psz;
                    break;
                }
                else
                {
                    psz--;
                    unsigned const cbBookmark = sizeof(ULONG) + sizeof(WORKID) + sizeof(CKeyBuf);
                    memmove( psz, psz+1, cbBookmark );

                    cb -= (BYTE *)psz - pb;;
                    pb = (BYTE *)psz;
                }
            }
        }
        else
        {
            status = STATUS_NOT_FOUND;
        }
    }
    CATCH( CException, e )
    {
        status = e.GetErrorCode();
    }
    END_CATCH

    cb = pb - pbStart;

    return( status );
#else  // CIDBG == 1
    return( STATUS_NOT_IMPLEMENTED );
#endif // CIDBG == 1

#endif  // 0

    return STATUS_NOT_IMPLEMENTED;

} //DumpWorkId

//+---------------------------------------------------------------------------
//
//  Member:     CIShutdown
//
//  Synopsis:   Calls through to FsCiShutdown
//
//  History:    3-06-97   srikants   Created
//
//----------------------------------------------------------------------------

void CIShutdown()
{
    FsCiShutdown();
} //CIShutdown

//+---------------------------------------------------------------------------
//
//  Function:   SetIDbProperties
//
//  Synopsis:   Sets scope properties on IDBProperties
//
//  Arguments:  [pIDbProp]   -- IDBProperties interface to set scope props on.
//              [pwcCatalog] -- catalog name
//              [pwcMachine] -- machine name
//              [clientGuid] -- client guid
//              [pwcScope]   -- scope path
//              [eType]      -- query type
//
//  History:    14-May-97    mohamedn   created
//
//----------------------------------------------------------------------------

void SetIDbProperties( IDBProperties * pIDbProp,
                       WCHAR const * pwcCatalog,
                       WCHAR const * pwcMachine,
                       CLSID       & clientGuid,
                       WCHAR const * pwcScope,
                       CiMetaData eType )
{
    const unsigned cElements = 1;

    XBStr   pxMachines[cElements];
    XBStr   pxCatalogs[cElements];
    XBStr   pxScopes  [cElements];
    DWORD   aDepths   [cElements];

    //
    // set machine name in a BSTR
    //

    if ( 0 != pwcMachine )
        pxMachines[0].SetText( (WCHAR *)pwcMachine);
    else
        pxMachines[0].SetText(L".");

    //
    // set catalog name in a BSTR
    //
    if ( pwcCatalog )
    {
        pxCatalogs[0].SetText( (WCHAR *)pwcCatalog);
    }
    else
    {
        Win4Assert( !"No-Catalog set. Fatal Error" );
        THROW ( CException(E_INVALIDARG) );
    }

    //
    // set scope name in a BSTR
    //
    if ( pwcScope )
        pxScopes[0].SetText( (WCHAR *)pwcScope );
    else
        pxScopes[0].SetText( L"\\" );

    //
    // set client guid
    //
    WCHAR awcClientGuid[ 40 ]; // 39 is all we need

    int cb = StringFromGUID2( clientGuid,
                              awcClientGuid,
                              sizeof awcClientGuid / sizeof WCHAR );
    Win4Assert( 0 != cb );

    XBStr xbstrClientGuid;
    xbstrClientGuid.SetText( awcClientGuid );

    //
    // set query type and defualt Depth
    //

    aDepths[0] = QUERY_DEEP;

    //
    // assemble safe arrays of the properties to set
    //
    SAFEARRAY saScope = { 1,                      // Dimension
                          FADF_AUTO | FADF_BSTR,  // Flags: on stack, contains BSTRs
                          sizeof(BSTR),           // Size of an element
                          1,                      // Lock count.  1 for safety.
                          (void *)pxScopes,       // The data
                          { cElements, 0 } };     // Bounds (element count, low bound)

    SAFEARRAY saDepth = { 1,                      // Dimension
                          FADF_AUTO,              // Flags: on stack
                          sizeof(LONG),           // Size of an element
                          1,                      // Lock count.  1 for safety.
                          (void *)aDepths,        // The data
                          { cElements, 0 } };     // Bounds (element count, low bound)

    SAFEARRAY saCatalog = { 1,                    // Dimension
                            FADF_AUTO | FADF_BSTR,// Flags: on stack, contains BSTRs
                            sizeof(BSTR),         // Size of an element
                            1,                    // Lock count.  1 for safety.
                            (void *)pxCatalogs,   // The data
                            { cElements, 0 } };   // Bounds (element count, low bound)

    SAFEARRAY saMachine = { 1,                    // Dimension
                            FADF_AUTO | FADF_BSTR,// Flags: on stack, contains BSTRs
                            sizeof(BSTR),         // Size of an element
                            1,                    // Lock count.  1 for safety.
                            (void *)pxMachines,   // The data
                            { cElements, 0 } };   // Bounds (element count, low bound)

    SAFEARRAY saClientGuid = { 1,                    // Dimension
                               FADF_AUTO | FADF_BSTR,// Flags: on stack, contains BSTRs
                               sizeof(BSTR),         // Size of an element
                               1,                    // Lock count.  1 for safety.
                               (void *)&xbstrClientGuid,   // The data
                               { 1, 0 } };   // Bounds (element count, low bound)
    //
    // assemble property sets
    //

    DBPROP    aQueryProps[4] = { { DBPROP_CI_INCLUDE_SCOPES,   0, DBPROPSTATUS_OK, {0, 0, 0}, { VT_BSTR | VT_ARRAY, 0, 0, 0, (ULONG_PTR)&saScope } },
                                 { DBPROP_CI_DEPTHS        ,   0, DBPROPSTATUS_OK, {0, 0, 0}, { VT_I4   | VT_ARRAY, 0, 0, 0, (ULONG_PTR)&saDepth } },
                                 { DBPROP_CI_CATALOG_NAME  ,   0, DBPROPSTATUS_OK, {0, 0, 0}, { VT_BSTR | VT_ARRAY, 0, 0, 0, (ULONG_PTR)&saCatalog } },
                                 { DBPROP_CI_QUERY_TYPE    ,   0, DBPROPSTATUS_OK, {0, 0, 0}, {        VT_I4      , 0, 0, 0, eType } } };

    DBPROP    aCoreProps[2]  = { { DBPROP_MACHINE          ,   0, DBPROPSTATUS_OK, {0, 0, 0}, { VT_BSTR | VT_ARRAY, 0, 0, 0, (ULONG_PTR)&saMachine } },
                                 { DBPROP_CLIENT_CLSID     ,   0, DBPROPSTATUS_OK, {0, 0, 0}, { VT_BSTR | VT_ARRAY, 0, 0, 0, (ULONG_PTR)&saClientGuid } } };

    DBPROPSET aAllPropsets[2] = {  {aQueryProps, 4, DBPROPSET_FSCIFRMWRK_EXT   } ,
                                   {aCoreProps , 2, DBPROPSET_CIFRMWRKCORE_EXT } };

    //
    // set property sets
    //
    SCODE sc = pIDbProp->SetProperties( 2, aAllPropsets );

    if ( FAILED( sc ) )
        THROW( CException( sc ) );
} //SetIDbProperties

//+-------------------------------------------------------------------------
//
//  Function:   SetCatalogState, public
//
//  Synopsis:   Change the catalog's state on the partition ID specified
//
//  Arguments:  [pwcsCat]     - passed in as ADMINISTRATOR for connection
//                              without docstore assocication
//              [pwcsMachine] - Machine on which catalog resides
//              [dwNewState]  - The state which catalog's going to be
//                              changed into
//              [pdwOldState] - Output, catalog's original state
//
//  History:    06-May-98   KitmanH    Created
//
//--------------------------------------------------------------------------

SCODE SetCatalogState( WCHAR const * pwcsCat,
                       WCHAR const * pwcsMachine,
                       DWORD dwNewState,
                       DWORD * pdwOldState )
{
    SCODE status = S_OK;

    if ( 0 == pdwOldState )
        return E_INVALIDARG;

    if ( 0 == pwcsMachine )
        pwcsMachine = L".";

    //
    //  Verify that we have legal parameters
    //

    CTranslateSystemExceptions xlate;
    TRY
    {
        XInterface<IDBProperties> xDbProps( CreateDbProperties( CIADMIN,
                                                                pwcsMachine ) );
        CSvcCatProxy cat( pwcsMachine, xDbProps.GetPointer() );

        cat.SetCatState( 1, pwcsCat, dwNewState, pdwOldState );
    }
    CATCH( CException, e )
    {
        status = ProxyErrorToCIError( e );
    }
    END_CATCH

    return status;
} //SetCatalogState
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\isearch\isrchcf.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997 - 1998.
//
//  File:       isrchcf.cxx
//
//  Contents:   Contains the implementation of ICiControl interface.
//
//  History:    1-17-97   srikants   Created
//
//----------------------------------------------------------------------------

#include <pch.cxx>
#pragma  hdrstop

#include <isrchcf.hxx>
#include <isearch.hxx>

const GUID clsidISearchCreator = CLSID_ISearchCreator;

extern long gulcInstances;

//+---------------------------------------------------------------------------
//
//  Member:     CCiISearchCreator::QueryInterface
//
//  Synopsis:   Returns interfaces to IID_IUknown, IID_ICiControl
//
//  History:    01-17-97   srikants   Created
//
//----------------------------------------------------------------------------

STDMETHODIMP CCiISearchCreator::QueryInterface(
    REFIID riid,
    void **ppvObject)
{
    Win4Assert( 0 != ppvObject );

    if ( IID_ICiISearchCreator == riid )
        *ppvObject = (void *)((ICiISearchCreator *)this);
    else if ( IID_IUnknown == riid )
        *ppvObject = (void *)((IUnknown *) (ICiISearchCreator *) this);
    else
    {
        *ppvObject = 0;
        return E_NOINTERFACE;
    }

    AddRef();
    return S_OK;
} //QueryInterface

//+---------------------------------------------------------------------------
//
//  Member:     CCiISearchCreator::AddRef
//
//  History:    01-17-97   srikants   Created
//
//----------------------------------------------------------------------------

STDMETHODIMP_(ULONG) CCiISearchCreator::AddRef()
{
    return InterlockedIncrement(&_refCount);
} //AddRef

//+---------------------------------------------------------------------------
//
//  Member:     CCiISearchCreator::Release
//
//  History:    01-17-97   srikants   Created
//
//----------------------------------------------------------------------------

STDMETHODIMP_(ULONG) CCiISearchCreator::Release()
{
    Win4Assert( _refCount > 0 );

    LONG refCount = InterlockedDecrement(&_refCount);

    if (  refCount <= 0 )
        delete this;

    return refCount;
} //Release

//+---------------------------------------------------------------------------
//
//  Member:     CCiISearchCreator::CreateISearch
//
//  Synopsis:   Creates an object and returns its ISearch interface.
//
//  Arguments:  [pRst]        - [in]  The Restriction
//              [pILangRes]   - [in]  Language resources to use
//              [pIOpenedDoc] - [in]  The "opened document" 
//              [ppISearch]   - [out] If successful, the ISearch interface
//
//  Returns:    S_OK if successful; Error code otherwise.
//
//  History:    2-26-97   srikants   Created
//
//----------------------------------------------------------------------------

STDMETHODIMP CCiISearchCreator::CreateISearch(
        DBCOMMANDTREE * pRst,
        ICiCLangRes * pILangRes,
        ICiCOpenedDoc * pIOpenedDoc,
        ISearchQueryHits ** ppISearch )
{
    if ( 0 == pRst || 0 == pILangRes || 0 == ppISearch )
        return E_INVALIDARG;    

    *ppISearch = 0;

    SCODE sc = S_OK;

    TRY
    {
        CSearch * pSearch = new CSearch( pRst, pILangRes, pIOpenedDoc );
        *ppISearch = pSearch;
    }
    CATCH( CException, e )
    {
        ciDebugOut(( DEB_ERROR, "Failed to create CCiManager. Error (0x%X)\n",
                     e.GetErrorCode() ));

        sc = e.GetErrorCode();
    }
    END_CATCH

    return sc;
}

//+---------------------------------------------------------------------------
//
//  Construction and destruction
//
//----------------------------------------------------------------------------

//+-------------------------------------------------------------------------
//
//  Method:     CCiISearchCreatorCF::CCiISearchCreatorCF
//
//  Synopsis:   Storage Filter Object class factory constructor
//
//  History:    17-Jan-1997  Srikants   Created
//
//+-------------------------------------------------------------------------

CCiISearchCreatorCF::CCiISearchCreatorCF()
    : _RefCount( 1 )
{
    InterlockedIncrement( &gulcInstances );
}

//+-------------------------------------------------------------------------
//
//  Method:     CCiISearchCreatorCF::~CCiISearchCreatorCF
//
//  Synopsis:   Storage Filter Object class factory destructor
//
//  History:    6-Jan-1997  Srikants   Created
//
//--------------------------------------------------------------------------

CCiISearchCreatorCF::~CCiISearchCreatorCF()
{
    Win4Assert( _RefCount == 0);
    Win4Assert( gulcInstances != 0 );
    
    InterlockedDecrement( &gulcInstances );
}

//+---------------------------------------------------------------------------
//
//  IUnknown method implementations
//
//----------------------------------------------------------------------------

//+-------------------------------------------------------------------------
//
//  Method:     CCiISearchCreatorCF::AddRef
//
//  Synopsis:   Increments refcount
//
//  History:    17-Jan-1997  Srikants   Created
//
//--------------------------------------------------------------------------

ULONG STDMETHODCALLTYPE CCiISearchCreatorCF::AddRef()
{
    return InterlockedIncrement( &_RefCount );
}

//+-------------------------------------------------------------------------
//
//  Method:     CCiISearchCreatorCF::Release
//
//  Synopsis:   Decrement refcount.  Delete if necessary.
//
//  History:    6-Jan-1997  Srikants   Created
//
//--------------------------------------------------------------------------

ULONG STDMETHODCALLTYPE CCiISearchCreatorCF::Release()
{
    Win4Assert( _RefCount != 0 );

    LONG RefCount = InterlockedDecrement( &_RefCount );

    if (  RefCount <= 0 )
        delete this;

    return (ULONG) RefCount;
}   //  Release

//+-------------------------------------------------------------------------
//
//  Method:     CCiISearchCreatorCF::QueryInterface
//
//  Synopsis:   Rebind to other interface
//
//  Arguments:  [riid]      -- IID of new interface
//              [ppvObject] -- New interface * returned here
//
//  Returns:    S_OK if bind succeeded, E_NOINTERFACE if bind failed
//
//  History:    17-Jan-1997  Srikants   Created
//
//--------------------------------------------------------------------------

STDMETHODIMP CCiISearchCreatorCF::QueryInterface( 
    REFIID riid,
    PVOID* ppvObject )
{
    Win4Assert( 0 != ppvObject );
    *ppvObject = 0;
    
    if ( IID_IUnknown == riid )
        *ppvObject = (PVOID) ((IUnknown *) this );
    else if ( IID_IClassFactory == riid)
        *ppvObject = (PVOID) ((IClassFactory *) this );
    else
        return E_NOINTERFACE;

    AddRef( );
    return S_OK;
}

//+-------------------------------------------------------------------------
//
//  Method:     CCiISearchCreatorCF::CreateInstance
//
//  Synopsis:   Create new CStorageFilterObject instance
//
//  Arguments:  [pUnkOuter] -- 'Outer' IUnknown; IGNORED
//              [riid]      -- Interface to bind
//              [ppvObject] -- Interface returned here
//
//  History:    17-Jan-1997  Srikants   Created
//
//--------------------------------------------------------------------------

STDMETHODIMP CCiISearchCreatorCF::CreateInstance( 
    IUnknown * pUnkOuter,
    REFIID riid,
    PVOID * ppvObject )
{
    if ( 0 != pUnkOuter )
        return ResultFromScode( CLASS_E_NOAGGREGATION );    

    CCiISearchCreator * pObject = 0;
    SCODE sc = S_OK;

    TRANSLATE_EXCEPTIONS;

    TRY
    {
        //
        //  Create the new object
        //
        
        pObject = new CCiISearchCreator;

        //
        //  Obtain the new interface
        //
        
        sc = pObject->QueryInterface( riid , ppvObject );

        //
        //  Regardless of whether the QueryInterface succeeded, we
        //  release the object.
        //
        
        pObject->Release();  
    }
    CATCH(CException, e)
    {
        Win4Assert( 0 == pObject );

        switch( e.GetErrorCode() )
        {
        case E_OUTOFMEMORY:
            sc = (E_OUTOFMEMORY);
            break;
        default:
            sc = (E_UNEXPECTED);
        }
    }
    END_CATCH;

    UNTRANSLATE_EXCEPTIONS;

    return sc;
}

//+-------------------------------------------------------------------------
//
//  Method:     CCiISearchCreatorCF::LockServer
//
//  Synopsis:   Force class factory to remain loaded
//
//  Arguments:  [fLock] -- TRUE if locking, FALSE if unlocking
//
//  Returns:    S_OK
//
//  History:    17-Jan-1997  Srikants   Created
//
//--------------------------------------------------------------------------

STDMETHODIMP CCiISearchCreatorCF::LockServer( BOOL fLock )
{
    if (fLock)
        InterlockedIncrement( &gulcInstances );
    else
        InterlockedDecrement( &gulcInstances );

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\isearch\mapper.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1991 - 1992.
//
//  File:   MAPPER.CXX
//
//  Contents:   Search Key Repository
//
//  Classes:    CSourceMapper
//
//  History:    23-Sep-94    BartoszM   Created.
//
//----------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include <mapper.hxx>


//+---------------------------------------------------------------------------
//
//  Member:     CSourceMapper::Advance
//
//  Synopsis:   Advance the mapper after processing ccDelta characters
//
//  History:    30-Sep-94    BartoszM   Created.
//
//----------------------------------------------------------------------------

void CSourceMapper::Advance ( ULONG ccProcessed )
{
    _offInChunk += ccProcessed;
    if (_offSplit != 0)
    {
        // split buffer situation (two current chunks)
        if (ccProcessed >= _offSplit)
        {
            // got rid of leftover chunk
            _offInChunk = ccProcessed - _offSplit;
            _offSplit = 0;
            _idChunk = _idNewChunk;
        }
        else
            _offSplit -= ccProcessed;
    }
}

void CSourceMapper::NewChunk ( ULONG idChunk, ULONG ccBegin )
{
    if (ccBegin != 0)
    {
        _offSplit = ccBegin;
        _idNewChunk = idChunk;
    }
    else
    {
        _offSplit = 0;
        _idChunk = idChunk;
        _offInChunk = 0;
    }
    _ccLen = 0;
}

void CSourceMapper::NewDerivedChunk ( ULONG idChunkSource, ULONG ccBeginSource, ULONG ccLen )
{
    _idChunk = idChunkSource;
    _offInChunk = ccBeginSource;
    _offSplit = 0;
    _ccLen = ccLen;
}
//+---------------------------------------------------------------------------
//
//  Member:     CSourceMapper::GetSrcRegion
//
//  Synopsis:   Returns source filter region for current position
//
//  History:    23-Sep-94    BartoszM   Created.
//
//----------------------------------------------------------------------------

void CSourceMapper::GetSrcRegion ( FILTERREGION& region, ULONG len, ULONG ccOffsetInBuf )
{
    if (_offSplit == 0 || ccOffsetInBuf < _offSplit)
    {
        region.idChunk = _idChunk;
        if (_ccLen == 0)  // direct mapping
        {
            region.cwcStart = _offInChunk + ccOffsetInBuf;
            region.cwcExtent = len;
        }
        else  // map to whole region
        {
            region.cwcStart = _offInChunk;
            region.cwcExtent = _ccLen;
        }
    }
    else
    {
        region.idChunk = _idNewChunk;
        region.cwcStart = ccOffsetInBuf - _offSplit;
        region.cwcExtent = len;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\icommand\svcquery.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 2000.
//
//  File:       SvcQuery.cxx
//
//  Contents:   IInternalQuery interface for cisvc
//
//  History:    13-Sep-96 dlee     Created
//
//--------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include <restrict.hxx>
#include <rowset.hxx>
#include <query.hxx>
#include <pidmap.hxx>
#include <coldesc.hxx>
#include <lang.hxx>
#include <rstprop.hxx>
#include <proprst.hxx>

#include "svcquery.hxx"

//+-------------------------------------------------------------------------
//
//  Member:     CSvcQuery::QueryInterface, public
//
//  Arguments:  [ifid]  -- Interface id
//              [ppiuk] -- Interface return pointer
//
//  Returns:    Error.  No rebind from this class is supported.
//
//  History:    13-Sep-96 dlee     Created
//
//--------------------------------------------------------------------------

STDMETHODIMP CSvcQuery::QueryInterface(
    REFIID  ifid,
    void ** ppiuk )
{
    if ( IID_IUnknown == ifid )
    {
        AddRef();
        *ppiuk = (void *)((IUnknown *)this);
        return S_OK;
    }
    else
    {
        *ppiuk = 0;
        return E_NOINTERFACE;
    }
} //QueryInterface

//+-------------------------------------------------------------------------
//
//  Member:     CSvcQuery::AddRef, public
//
//  Synopsis:   Reference the virtual table.
//
//  History:    13-Sep-96 dlee     Created
//
//--------------------------------------------------------------------------

STDMETHODIMP_(ULONG) CSvcQuery::AddRef()
{
    return InterlockedIncrement( (long *) &_ref );
} //AddRef

//+-------------------------------------------------------------------------
//
//  Member:     CSvcQuery::Release, public
//
//  Synopsis:   De-Reference the virtual table.
//
//  Effects:    If the ref count goes to 0 then the table is deleted.
//
//  History:    13-Sep-96 dlee     Created
//
//--------------------------------------------------------------------------

STDMETHODIMP_(ULONG) CSvcQuery::Release()
{
    long l = InterlockedDecrement( (long *) &_ref );

    if ( l <= 0 )
    {
        // delete self

        vqDebugOut(( DEB_ITRACE,
                     "Svc IInternalQuery unreferenced.  Deleting.\n" ));
        delete this;
        return 0;
    }

    return l;
} //Release

//+-------------------------------------------------------------------------
//
//  Class:      CCursorArray
//
//  Synopsis:   Smart container of query cursors
//
//  History:    16-Feb-97 dlee     Created
//
//--------------------------------------------------------------------------

class CCursorArray
{
public:
    CCursorArray( ULONG *          pCursors,
                  ULONG            cCursors,
                  CSvcQueryProxy & Query ) :
        _pCursors( pCursors ),
        _cCursors( cCursors ),
        _Query( Query )
    {
    }

    void Acquire( ULONG iElement )
    {
        _pCursors[ iElement ] = 0;
    }

    ~CCursorArray()
    {
        // FreeCursor can fail if the pipe is stale, in which
        // case don't bother with freeing the rest of the cursors.

        TRY
        {
            for ( ULONG x = 0; x < _cCursors; x++ )
            {
                if ( 0 != _pCursors[ x ] )
                    _Query.FreeCursor( _pCursors[ x ] );
            }
        }
        CATCH( CException, e )
        {
        }
        END_CATCH
    }

private:
    ULONG *          _pCursors;
    ULONG            _cCursors;
    CSvcQueryProxy & _Query;
};

//+-------------------------------------------------------------------------
//
//  Member:     CSvcQuery::Execute, public
//
//  Synopsis:   Executes a query.  Helper for ICommand::Execute.
//
//  Arguments:  [pUnkOuter]    -- Outer unknown
//              [pRestriction] -- Query restriction
//              [pidmap]       -- pid mapper for output, sort, category columns
//              [rColumns]     -- Output columns in IRowset
//              [rSort]        -- Initial sort
//              [xProps]       -- Rowset properties (query flags)
//              [rCateg]       -- Categorization specification
//              [cRowsets]     -- # of rowsets
//              [ppUnknowns]    -- IUnknowns returned here
//              [aAccessors]   -- Bag of accessors which rowsets need to inherit
//
//  Returns:    Throws on error
//
//  History:    26 Nov 1995    AlanW     Created
//              13-Sep-96      dlee      Make it support cisvc
//
//--------------------------------------------------------------------------

void CSvcQuery::Execute( IUnknown *            pUnkOuter,
                         RESTRICTION *         pRestriction,
                         CPidMapperWithNames & pidmap,
                         CColumnSet &          rColumns,
                         CSortSet &            rSort,
                         XPtr<CMRowsetProps> & xProps,
                         CCategorizationSet &  rCateg,
                         ULONG                 cRowsets,
                         IUnknown **           ppUnknowns,
                         CAccessorBag &        aAccessors,
                         IUnknown *            pUnkCreator )
{
    if (0 == ppUnknowns)
        THROW(CException( E_INVALIDARG));

    if ( cRowsets != 1 + (rCateg.Count() ? rCateg.Count() : 0) )
        THROW( CException( E_INVALIDARG ));

    if (_QueryUnknown.IsQueryActive())
    {
        vqDebugOut(( DEB_ERROR,
                     "CSvcQuery: Query already active.\n" ));

        // NTRAID#DB-NTBUG9-84330-2000/07/31-dlee OLE-DB spec variance in Indexing Service when reexecuting queries

        // spec variance: only if query changed

        THROW( CException( DB_E_OBJECTOPEN ));
    }

    // Construct table
    *ppUnknowns = 0;           // in case of error or exception

    XArray<ULONG> aCursors( cRowsets );

    // Construct a CRowsetProperties
    CRowsetProperties Prop;
    Prop.SetDefaults( xProps->GetPropertyFlags(),
                      xProps->GetMaxOpenRows(),
                      xProps->GetMemoryUsage(),
                      xProps->GetMaxResults(),
                      xProps->GetCommandTimeout(),
                      xProps->GetFirstRows() );

    XInterface<CSvcQueryProxy> xQuery(new
                               CSvcQueryProxy( _client,
                                               rColumns,
                                               (CRestriction&) (*pRestriction),
                                               rSort.Count() ? &rSort : 0,
                                               rCateg.Count() ? &rCateg : 0,
                                               Prop, 
                                               pidmap,
                                               cRowsets,
                                               aCursors.GetPointer()
                                                ));

    // Make rowsets for each level in the hierarchy (usually 1).
    // Rowset 0 is the top of the hierarchy.

    CCursorArray cursorArray( aCursors.GetPointer(),
                              cRowsets,
                              xQuery.GetReference() );

    _QueryUnknown.ReInit();
    CRowsetArray apRowsets( cRowsets );
    XArray<IUnknown *> xapUnknown( cRowsets );

    CMRowsetProps & OrigProps = xProps.GetReference();
    
    for ( unsigned r = 0; r < cRowsets; r++ )
    {
        // First rowset is not chaptered, even if others are.

        XPtr<CMRowsetProps> xTmp;

        if ( 0 != r )
        {
            xTmp.Set( new CMRowsetProps( OrigProps ) );
            xTmp->SetChaptered( TRUE );
        }

        if ( 1 != cRowsets && 0 == r )
            xProps->SetChaptered( FALSE );
    
        apRowsets[r] = new CRowset( pUnkOuter,
                                    &xapUnknown[r],
                                    (r == (cRowsets - 1)) ?
                                        rColumns :
                                        rCateg.Get(r)->GetColumnSet(),
                                    pidmap,
                                    xQuery.GetReference(),
                                    (IUnknown &) _QueryUnknown,
                                    0 != r,
                                    ( 0 == r ) ? xProps : xTmp,
                                    aCursors[r],
                                    aAccessors,
                                    pUnkCreator );

        // the cursor is acquired

        cursorArray.Acquire( r );
    }
    
    for (r = 0; r < cRowsets; r++)
    {
        if (r < cRowsets-1)
            apRowsets[r]->SetRelatedRowset( apRowsets[r+1] );

        ppUnknowns[r] = xapUnknown[r];
    }
    
    // xQuery goes out of scope, which does a Release() on it.
    // Each rowset above has done an AddRef() on it and they own it.

    // ReInit can't fail

    _QueryUnknown.ReInit( cRowsets, apRowsets.Acquire() );
} //Execute

//+-------------------------------------------------------------------------
//
//  Member:     CSvcQuery::CSvcQuery, public
//
//  Synopsis:   saves the query scope, machine, and catalog
//
//  Arguments:  [cScopes]    - # of entries in the scope arrays
//              [aDepths]    - array of scope depths
//              [aScopes]    - array of paths to roots of scopes
//              [pwcCatalog] - catalog override name or path
//              [pwcMachine] - Machine name for catalog
//
//  History:    13-Sep-96 dlee      Updated from FAT for svc
//
//--------------------------------------------------------------------------

CSvcQuery::CSvcQuery(
    WCHAR const *         pwcMachine,
    IDBProperties *       pDbProperties ) :
#pragma warning(disable : 4355) // 'this' in a constructor
          _QueryUnknown( * ((IUnknown *) this) ),
#pragma warning(default : 4355)    // 'this' in a constructor
          PIInternalQuery( 0 ),
          _client( pwcMachine, pDbProperties )
{
    AddRef();
} //CSvcQuery
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\isearch\addprop.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 2000.
//
//  File:       addprop.cxx
//
//  Contents:   A class to add properties from a document to the search
//              data repository.
//
//  History:    7-23-96   srikants   Created
//
//----------------------------------------------------------------------------


#include <pch.cxx>
#pragma hdrstop

#include <ciole.hxx>
#include <drep.hxx>
#include <propspec.hxx>
#include <propfilt.hxx>

#include "addprop.hxx"

static GUID guidNull = { 0x00000000,
                         0x0000,
                         0x0000,
                         { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 } };


static CFullPropSpec psPath( guidStorage, PID_STG_PATH);


//+---------------------------------------------------------------------------
//
//  Member:     CSearchAddProp::DoIt
//
//  Synopsis:   Adds properties to the data repository by iterating over
//              the properties.
//
//  History:    7-23-96   srikants   Created
//
//----------------------------------------------------------------------------

void CSearchAddProp::DoIt()
{
    //
    //  Add Stat properties.  Do so for both directories and files.
    //

    {
        CDocStatPropertyEnum CPEProp( &_openedDoc);
        AddProperties( CPEProp );
    }

    //
    // If there are ole properties, we must add the ole properties also.
    //

    if ( _fAddOleProps )
    {
        COLEPropertyEnum oleProp( &_openedDoc );
        AddProperties( oleProp );
    }
}

//+---------------------------------------------------------------------------
//
//  Method:   CSearchAddProp::AddProperty
//
//  Arguments:
//      [var]     -- Property value
//      [ps]      -- Property ID
//      [drep]    -- Data repository for filtered information
//
//  History:    21-Oct-93   DwightKr       Created.
//              23-Jul-96   SrikantS       Adapted for search needs
//
//----------------------------------------------------------------------------

void CSearchAddProp::AddProperty(
    CStorageVariant const & var,
    CFullPropSpec &         ps,
    CDataRepository &       drep )
{
    //
    //  Don't filter paths
    //
    if ( ps != psPath )
    {
        vqDebugOut(( DEB_FILTER, "Filter property 0x%x: ", ps.GetPropertyPropid() ));

#if CIDBG == 1
        var.DisplayVariant(DEB_FILTER | DEB_NOCOMPNAME, 0);
#endif  // CIDBG == 1

        vqDebugOut(( DEB_FILTER | DEB_NOCOMPNAME, "\n" ));

        // output the property to the data repository
        drep.PutPropName( ps );
        drep.PutValue( var );

        // store all property values in the property cache, though
        // only some are actually stored

        drep.StoreValue( ps, var );
    }
}

//+---------------------------------------------------------------------------
//
//  Method:   CSearchAddProp::AddProperties
//
//  Arguments:
//      [propEnum]        -- iterator for properties in a file
//
//  History:    27-Nov-93   DwightKr       Created.
//              23-Jul-96   SrikantS       Adapted for search needs
//
//----------------------------------------------------------------------------

void CSearchAddProp::AddProperties(
    CPropertyEnum &        propEnum )
{

    CFullPropSpec ps;

    for ( CStorageVariant const * pvar = propEnum.Next( ps );
          pvar != 0;
          pvar = propEnum.Next( ps ) )
    {
        AddProperty( *pvar, ps, _drep );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\isearch\search.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 2000.
//
//  File:       search.cxx
//
//  Contents:   The implementation specific methods of CSearch
//
//  History:    05-Dec-94   Created     BartoszM
//
//--------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include <curstk.hxx>
#include <convert.hxx>
#include <coldesc.hxx>
#include <pidremap.hxx>
#include <parstree.hxx>
#include <drep.hxx>
#include <mapper.hxx>
#include <qsplit.hxx>
#include <pidmap.hxx>
#include <tsource.hxx>
#include <pidmap.hxx>
#include <propspec.hxx>
#include <ciregkey.hxx>
#include <regacc.hxx>
#include <isearch.hxx>
#include <recogniz.hxx>

#include "skrep.hxx"
#include "addprop.hxx"
#include "appcur.hxx"

//+-------------------------------------------------------------------------
//
//  Member:     CHitSink::AddPosition, public
//
//  Synopsis:   Add position to the current query hit
//
//  History:    29-Sep-94   BartoszM       Created.
//
//--------------------------------------------------------------------------

void CHitSink::AddPosition ( const FILTERREGION& region )
{
    // insert into sorted list

    unsigned count = _nFound;
    for ( unsigned i = 0; i < count; i++ )
    {
        if (Compare(region, _aRegion.Get(i)) > 0)
            break;
    }

    _aRegion.Insert ( region, i );

    _nFound++;
}

extern long gulcInstances;

//+-------------------------------------------------------------------------
//
//  Member:     CSearch::CSearch, public
//
//  Synopsis:   Initialize search
//
//  Arguments:  [pRst] -- a DBCOMMANDTREE giving the expression to be
//                        searched for.
//
//  History:    29-Sep-94   BartoszM       Created.
//
//--------------------------------------------------------------------------

CSearch::CSearch ( DBCOMMANDTREE * pRst,
                   ICiCLangRes * pICiCLangRes,
                   ICiCOpenedDoc * pIOpenedDoc )
  : _cRefs(1),
    _pCursor(0),
    _pKeyRep (0),
    _iCurHit (0),
    _aHit(),
    _pidcvt( &_propMapper ),
    _pidmap( &_pidcvt ),
    _langList(pICiCLangRes)
{
    CDbRestriction * pDbRst = (CDbRestriction *) (void *) pRst;

    InterlockedIncrement( &gulcInstances );

    CRestriction * pCRest = 0;

    if ( 0 != pDbRst )
    {
        CParseCommandTree   parseTree;
        pCRest = parseTree.ParseExpression( pDbRst );
    }

    ParseAndSplitQuery( pCRest, _pidmap, _xRst, _langList );
    CRestriction* pSplitRst = _xRst.GetPointer();

    delete pCRest;

    if ( pIOpenedDoc )
    {
        pIOpenedDoc->AddRef();
        _xOpenedDoc.Set( pIOpenedDoc );
    }
}

//+-------------------------------------------------------------------------
//
//  Member:     CSearch::~CSearch, public
//
//  Synopsis:   Free resources
//
//  History:    29-Sep-94   BartoszM       Created.
//
//--------------------------------------------------------------------------

CSearch::~CSearch ()
{
    _aHit.Clear();

    Reset();
    InterlockedDecrement( &gulcInstances );
}


//+-------------------------------------------------------------------------
//
//  Member:     CSearch::Reset, public
//
//  Synopsis:   Free resources
//
//  History:    29-Sep-94   BartoszM       Created.
//
//--------------------------------------------------------------------------

void CSearch::Reset ()
{
    _iCurHit = 0;
    _aHit.Clear();
    delete _pCursor;
    _pCursor = 0;
}

//+-------------------------------------------------------------------------
//
//  Member:     CSearch::Init, public
//
//  Synopsis:   Do the search using the filter
//
//  History:    29-Sep-94   BartoszM       Created.
//
//--------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE CSearch::Init (
    IFilter * pFilter,
    ULONG     ulFlags )
{
    //
    // pFilter == 0 --> Release last filter.  However, this implementation
    // doesn't hold onto pFilter after Init.
    //

    if ( 0 == pFilter )
        return S_OK;

    //
    // A null [content] restriction --> No possible hits.
    //

    if ( _xRst.IsNull() )
        return S_OK;

    Reset ();

    SCODE sc = S_OK;

    TRY
    {
        // Initialize the key recognizer
        // by scanning the restriction and
        // creating detectors for all the keys

        CRecognizer recog;
        recog.MakeDetectors(_xRst.GetPointer());

        // Create the filtering pipeline
        // that breaks text into keys and
        // deposits them in the key repository

        CSearchKeyRepository keyRep ( recog );

        CDataRepository dataRep ( keyRep, 0, FALSE, 0, _pidmap, _langList );

        // Using filter as the source of text, run it through
        // the filtering pipeline. The pipeline produces keys that
        // are put in the key repository which contains the recognizer.
        // The recognizer stores the filter positions of ALL the matched keys

        STAT_CHUNK statChunk;
        sc = pFilter->GetChunk( &statChunk );
        while ( SUCCEEDED(sc)
                || FILTER_E_LINK_UNAVAILABLE == sc
                || FILTER_E_EMBEDDING_UNAVAILABLE == sc
                || FILTER_E_NO_TEXT == sc )
        {

            if ( SUCCEEDED( sc ) )
            {
                //
                // Skip over unknown chunks.
                //

                if ( 0 == (statChunk.flags & (CHUNK_TEXT | CHUNK_VALUE)) )
                {
                    ciDebugOut(( DEB_WARN,
                                 "Filtering of document for ISearch produced bogus chunk (not text or value)\n" ));
                    sc = pFilter->GetChunk( &statChunk );
                    continue;
                }

                if ( (statChunk.flags & CHUNK_VALUE) )
                {
                    PROPVARIANT * pvar = 0;

                    sc = pFilter->GetValue( &pvar );

                    if ( SUCCEEDED(sc) )
                    {
                        XPtr<CStorageVariant> xvar( (CStorageVariant *)(ULONG_PTR)pvar );

                        CSourceMapper mapper;
                        mapper.NewChunk( statChunk.idChunk, 0 );
                        keyRep.NextChunk ( mapper );

                        if ( dataRep.PutLanguage( statChunk.locale ) &&
                             dataRep.PutPropName( *((CFullPropSpec *)&statChunk.attribute) ) )
                        {
                            dataRep.PutValue( xvar.GetReference() );
                        }
                    }

                    //
                    // Only fetch next if we're done with this chunk.
                    //

                    if ( 0 == (statChunk.flags & CHUNK_TEXT) || !SUCCEEDED(sc) )
                    {
                        sc = pFilter->GetChunk( &statChunk );
                        continue;
                    }
                }

                if ( (statChunk.flags & CHUNK_TEXT) && SUCCEEDED(sc) )
                {
                    if ( dataRep.PutLanguage( statChunk.locale ) &&
                         dataRep.PutPropName( *((CFullPropSpec *)&statChunk.attribute )) )
                    {
                        // Maps position in tsource into FILTERREGION
                        CSourceMapper mapper;
                        // Text Source will reload statChunk when
                        // data repository pulls it dry
                        CTextSource tsource( pFilter, statChunk, &mapper );
                        // prepare key repository for a new chunk
                        keyRep.NextChunk ( mapper );
                        // Do It!
                        dataRep.PutStream( &tsource );

                        sc = tsource.GetStatus();

                        //
                        // The text source may go a chunk too far if it
                        // encounters a value chunk.
                        //
                        if ( sc == FILTER_E_NO_TEXT &&
                             (statChunk.flags & CHUNK_VALUE) )
                            sc = S_OK;
                    }
                    else
                    {
                        // skip chunk: reload statChunk explicitly
                        sc = pFilter->GetChunk( &statChunk );
                    }
                }

            }
            else
            {
                // Filter for embedding could not be found - try next chunk
                sc = pFilter->GetChunk( &statChunk );
            }
        }

        if ( FAILED( sc ) &&
             ( ( FILTER_E_END_OF_CHUNKS > sc ) ||
               ( FILTER_E_UNKNOWNFORMAT < sc ) ) )
            THROW( CException( sc ) );

        //
        // Add the properties.
        //

        if ( !_xOpenedDoc.IsNull() )
        {
            CSourceMapper mapper;
            mapper.NewChunk( statChunk.idChunk+1, 0 );

            keyRep.NextChunk ( mapper );

            BOOL fFilterOleProperties = (( ulFlags & IFILTER_FLAGS_OLE_PROPERTIES ) != 0);

            CSearchAddProp  addProp( dataRep,
                                     _xOpenedDoc.GetReference(),
                                     fFilterOleProperties );
            addProp.DoIt();
        }

        sc = S_OK;

        // Create a cursor tree corresponding to the restriction
        // The leaves of the tree have access to the recognizer
        // which is now filled with key positions

        CAppQueriable queriable (recog, _hitSink);

        CRegAccess reg( RTL_REGISTRY_CONTROL, wcsRegAdmin );
        ULONG maxNodes = reg.Read( wcsMaxRestrictionNodes,
                                   CI_MAX_RESTRICTION_NODES_DEFAULT,
                                   CI_MAX_RESTRICTION_NODES_MIN,
                                   CI_MAX_RESTRICTION_NODES_MAX );

        CConverter convert( &queriable, maxNodes );

        _pCursor = convert.QueryCursor( _xRst.GetPointer() );

        if (_pCursor == 0)
            sc = E_UNEXPECTED;

        if ( convert.TooManyNodes() )
            sc = E_UNEXPECTED;

        //
        //  Exhaust cursor of hits, ordering the hits
        //  primarily by rank and secondarily by position.
        //

        if ( sc == S_OK && widInvalid != _pCursor->WorkId() )
        {
                // Deposit positions in the hit sink
                ULONG rank = _pCursor->Hit();
                if ( rank != rankInvalid )
                {
                    do
                    {
                        // retrieve positions from the hit sink
                        // and store them as a hit in a sorted
                        // array of hits
                        ConvertPositionsToHit( rank );
                        // prepare for next hit
                        _hitSink.Reset();
                        // Deposit positions in the hit sink
                        rank = _pCursor->NextHit();
                    }
                    while ( rank != rankInvalid );
                }
        }

    }
    CATCH (CException, e)
    {
        sc = GetOleError( e );
    }
    END_CATCH

    // empty the sink
    _hitSink.Reset();
    delete _pCursor;
    _pCursor = 0;
    return sc;
}

//+-------------------------------------------------------------------------
//
//  Member:     CSearch::NextHitOffset, public
//
//  Synopsis:   Return the region of the next hit
//
//  History:    29-Sep-94   BartoszM       Created.
//
//--------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE CSearch::NextHitOffset (
                               ULONG* pcRegion,
                               FILTERREGION ** paRegion )
{
    if ( _xRst.IsNull() )
        return( S_FALSE );

    if (_iCurHit == _aHit.Count())
    {
        *paRegion = 0;
        *pcRegion = 0;
        return S_FALSE;
    }

    CSearchHit* pHit = _aHit.Get(_iCurHit);

    *pcRegion = pHit->Count();
    // this array is allocated using CoTaskMemAlloc
    *paRegion = pHit->AcqHit ();

    _iCurHit++;
    return S_OK;
}

//+-------------------------------------------------------------------------
//
//  Member:     CSearch::ConvertPositionToHit, public
//
//  History:    29-Sep-94   BartoszM       Created.
//
//--------------------------------------------------------------------------

void CSearch::ConvertPositionsToHit( LONG rank )
{
    //
    //  Take the positions in the current list and convert
    //  them into a single hit and put them in the ordered hit array
    //
    unsigned count = _hitSink.Count ();
    // These arrays will be returned across the interface
    FILTERREGION* aRegion = (FILTERREGION*) CoTaskMemAlloc ( count * sizeof(FILTERREGION));
    if (aRegion == 0)
    {
        THROW (CException(E_OUTOFMEMORY));
    }

    for (unsigned k = 0; k < count; k++)
    {
        aRegion [k] = _hitSink.GetRegion (k);
    }

    CSearchHit * pNewHit = new CSearchHit( rank, count, aRegion );

    //
    //  Order Hits primarily by rank and secondarily by
    //  position
    //

    for ( unsigned i = 0; i < _aHit.Count(); i++ )
    {
        CSearchHit* pHit = _aHit.Get(i);

        if ( pHit->Rank() < rank
          || pHit->Rank() == rank && Compare (pHit->FirstRegion(), aRegion[0]) > 0 )
        {
            break;
        }
    }

    _aHit.Insert(pNewHit, i);

}

SCODE STDMETHODCALLTYPE  CSearch::NextHitMoniker(
    ULONG * pcMnk,
    IMoniker *** papMnk )
{
    return E_NOTIMPL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\kbyacc\error.c ===
/* routines for printing error messages  */

#include "defs.h"


#if defined(KYLEP_CHANGE)
void
#endif
fatal(msg)
char *msg;
{
    fprintf(stderr, "%s: f - %s\n", myname, msg);
    done(2);
}


#if defined(KYLEP_CHANGE)
void
#endif
no_space()
{
    fprintf(stderr, "%s: f - out of space\n", myname);
    done(2);
}


#if defined(KYLEP_CHANGE)
void
#endif
open_error(filename)
char *filename;
{
    fprintf(stderr, "%s: f - cannot open \"%s\"\n", myname, filename);
    done(2);
}


#if defined(KYLEP_CHANGE)
void
#endif
unexpected_EOF()
{
    fprintf(stderr, "%s: e - line %d of \"%s\", unexpected end-of-file\n",
            myname, lineno, input_file_name);
    done(1);
}

#if defined(KYLEP_CHANGE)
void
#endif
print_pos(st_line, st_cptr)
char *st_line;
char *st_cptr;
{
    register char *s;

    if (st_line == 0) return;
    for (s = st_line; *s != '\n'; ++s)
    {
        if (isprint(*s) || *s == '\t')
            putc(*s, stderr);
        else
            putc('?', stderr);
    }
    putc('\n', stderr);
    for (s = st_line; s < st_cptr; ++s)
    {
        if (*s == '\t')
            putc('\t', stderr);
        else
            putc(' ', stderr);
    }
    putc('^', stderr);
    putc('\n', stderr);
}


#if defined(KYLEP_CHANGE)
void
#endif
syntax_error(st_lineno, st_line, st_cptr)
int st_lineno;
char *st_line;
char *st_cptr;
{
    fprintf(stderr, "%s: e - line %d of \"%s\", syntax error\n",
            myname, st_lineno, input_file_name);
    print_pos(st_line, st_cptr);
    done(1);
}


#if defined(KYLEP_CHANGE)
void
#endif
unterminated_comment(c_lineno, c_line, c_cptr)
int c_lineno;
char *c_line;
char *c_cptr;
{
    fprintf(stderr, "%s: e - line %d of \"%s\", unmatched /*\n",
            myname, c_lineno, input_file_name);
    print_pos(c_line, c_cptr);
    done(1);
}


#if defined(KYLEP_CHANGE)
void
#endif
unterminated_string(s_lineno, s_line, s_cptr)
int s_lineno;
char *s_line;
char *s_cptr;
{
    fprintf(stderr, "%s: e - line %d of \"%s\", unterminated string\n",
            myname, s_lineno, input_file_name);
    print_pos(s_line, s_cptr);
    done(1);
}


#if defined(KYLEP_CHANGE)
void
#endif
unterminated_text(t_lineno, t_line, t_cptr)
int t_lineno;
char *t_line;
char *t_cptr;
{
    fprintf(stderr, "%s: e - line %d of \"%s\", unmatched %%{\n",
            myname, t_lineno, input_file_name);
    print_pos(t_line, t_cptr);
    done(1);
}


#if defined(KYLEP_CHANGE)
void
#endif
unterminated_union(u_lineno, u_line, u_cptr)
int u_lineno;
char *u_line;
char *u_cptr;
{
    fprintf(stderr, "%s: e - line %d of \"%s\", unterminated %%union \
declaration\n", myname, u_lineno, input_file_name);
    print_pos(u_line, u_cptr);
    done(1);
}


#if defined(KYLEP_CHANGE)
void
#endif
over_unionized(u_cptr)
char *u_cptr;
{
    fprintf(stderr, "%s: e - line %d of \"%s\", too many %%union \
declarations\n", myname, lineno, input_file_name);
    print_pos(line, u_cptr);
    done(1);
}


#if defined(KYLEP_CHANGE)
void
#endif
illegal_tag(t_lineno, t_line, t_cptr)
int t_lineno;
char *t_line;
char *t_cptr;
{
    fprintf(stderr, "%s: e - line %d of \"%s\", illegal tag\n",
            myname, t_lineno, input_file_name);
    print_pos(t_line, t_cptr);
    done(1);
}


#if defined(KYLEP_CHANGE)
void
#endif
illegal_character(c_cptr)
char *c_cptr;
{
    fprintf(stderr, "%s: e - line %d of \"%s\", illegal character\n",
            myname, lineno, input_file_name);
    print_pos(line, c_cptr);
    done(1);
}


#if defined(KYLEP_CHANGE)
void
#endif
used_reserved(s)
char *s;
{
    fprintf(stderr, "%s: e - line %d of \"%s\", illegal use of reserved symbol \
%s\n", myname, lineno, input_file_name, s);
    done(1);
}


#if defined(KYLEP_CHANGE)
void
#endif
tokenized_start(s)
char *s;
{
     fprintf(stderr, "%s: e - line %d of \"%s\", the start symbol %s cannot be \
declared to be a token\n", myname, lineno, input_file_name, s);
     done(1);
}


#if defined(KYLEP_CHANGE)
void
#endif
retyped_warning(s)
char *s;
{
    fprintf(stderr, "%s: w - line %d of \"%s\", the type of %s has been \
redeclared\n", myname, lineno, input_file_name, s);
}


#if defined(KYLEP_CHANGE)
void
#endif
reprec_warning(s)
char *s;
{
    fprintf(stderr, "%s: w - line %d of \"%s\", the precedence of %s has been \
redeclared\n", myname, lineno, input_file_name, s);
}


#if defined(KYLEP_CHANGE)
void
#endif
revalued_warning(s)
char *s;
{
    fprintf(stderr, "%s: w - line %d of \"%s\", the value of %s has been \
redeclared\n", myname, lineno, input_file_name, s);
}


#if defined(KYLEP_CHANGE)
void
#endif
terminal_start(s)
char *s;
{
    fprintf(stderr, "%s: e - line %d of \"%s\", the start symbol %s is a \
token\n", myname, lineno, input_file_name, s);
    done(1);
}


#if defined(KYLEP_CHANGE)
void
#endif
restarted_warning()
{
    fprintf(stderr, "%s: w - line %d of \"%s\", the start symbol has been \
redeclared\n", myname, lineno, input_file_name);
}


#if defined(KYLEP_CHANGE)
void
#endif
no_grammar()
{
    fprintf(stderr, "%s: e - line %d of \"%s\", no grammar has been \
specified\n", myname, lineno, input_file_name);
    done(1);
}


#if defined(KYLEP_CHANGE)
void
#endif
terminal_lhs(s_lineno)
int s_lineno;
{
    fprintf(stderr, "%s: e - line %d of \"%s\", a token appears on the lhs \
of a production\n", myname, s_lineno, input_file_name);
    done(1);
}


#if defined(KYLEP_CHANGE)
void
#endif
prec_redeclared()
{
    fprintf(stderr, "%s: w - line %d of  \"%s\", conflicting %%prec \
specifiers\n", myname, lineno, input_file_name);
}


#if defined(KYLEP_CHANGE)
void
#endif
unterminated_action(a_lineno, a_line, a_cptr)
int a_lineno;
char *a_line;
char *a_cptr;
{
    fprintf(stderr, "%s: e - line %d of \"%s\", unterminated action\n",
            myname, a_lineno, input_file_name);
    print_pos(a_line, a_cptr);
    done(1);
}


#if defined(KYLEP_CHANGE)
void
#endif
dollar_warning(a_lineno, i)
int a_lineno;
int i;
{
    fprintf(stderr, "%s: w - line %d of \"%s\", $%d references beyond the \
end of the current rule\n", myname, a_lineno, input_file_name, i);
}


#if defined(KYLEP_CHANGE)
void
#endif
dollar_error(a_lineno, a_line, a_cptr)
int a_lineno;
char *a_line;
char *a_cptr;
{
    fprintf(stderr, "%s: e - line %d of \"%s\", illegal $-name\n",
            myname, a_lineno, input_file_name);
    print_pos(a_line, a_cptr);
    done(1);
}


#if defined(KYLEP_CHANGE)
void
#endif
untyped_lhs()
{
    fprintf(stderr, "%s: e - line %d of \"%s\", $$ is untyped\n",
            myname, lineno, input_file_name);
    done(1);
}


#if defined(KYLEP_CHANGE)
void
#endif
untyped_rhs(i, s)
int i;
char *s;
{
    fprintf(stderr, "%s: e - line %d of \"%s\", $%d (%s) is untyped\n",
            myname, lineno, input_file_name, i, s);
    done(1);
}


#if defined(KYLEP_CHANGE)
void
#endif
unknown_rhs(i)
int i;
{
    fprintf(stderr, "%s: e - line %d of \"%s\", $%d is untyped\n",
            myname, lineno, input_file_name, i);
    done(1);
}


#if defined(KYLEP_CHANGE)
void
#endif
default_action_warning()
{
    fprintf(stderr, "%s: w - line %d of \"%s\", the default action assigns an \
undefined value to $$\n", myname, lineno, input_file_name);
}


#if defined(KYLEP_CHANGE)
void
#endif
undefined_goal(s)
char *s;
{
    fprintf(stderr, "%s: e - the start symbol %s is undefined\n", myname, s);
    done(1);
}


#if defined(KYLEP_CHANGE)
void
#endif
undefined_symbol_warning(s)
char *s;
{
    fprintf(stderr, "%s: w - the symbol %s is undefined\n", myname, s);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\isearch\recogniz.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1991 - 1999.
//
//  File:       RECOGNIZ.CXX
//
//  Contents:   Scan restriction for keys and create recognizers for them
//
//  Classes:    CScanRst
//
//  History:    30-Sep-94   BartoszM      Created
//
//----------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include <recogniz.hxx>

BOOL CKeyDetector::Match ( const CKeyBuf& key ) const
{
    return _key.MatchPid (key) && _key.CompareStr (key) == 0;
}

DetectorType CKeyDetector::Type () const
{
    return DetSingleKey;
}

BOOL CKeyRangeDetector::Match ( const CKeyBuf& key ) const
{
    return _key.MatchPid (key)    && _key.CompareStr (key) <= 0
        && _keyEnd.MatchPid (key) && _keyEnd.CompareStr (key) > 0;
}

DetectorType CKeyRangeDetector::Type () const
{
    return DetRange;
}

BOOL CKeyPrefixDetector::Match ( const CKeyBuf& key ) const
{
    return _key.MatchPid (key)    && _key.CompareStr (key) <= 0
        && _keyEnd.MatchPid (key) && _keyEnd.CompareStr (key) > 0;
}

DetectorType CKeyPrefixDetector::Type () const
{
    return DetPrefix;
}


CRecognizer::CRecognizer ()
: _iDet(-1), _aRegionList(0)
{
}

CRecognizer::~CRecognizer ()
{
    delete []_aRegionList;
}

void CRecognizer::MakeDetectors ( const CRestriction* pRst )
{
    if (pRst)
    {
        // find all keys and create detectors for them
        ScanRst (pRst);
        // prepare the array to hold matched key positions
        _aRegionList = new CRegionList [Count()];
    }
}

void CRecognizer::ScanRst ( const CRestriction* pRst )
{
    if (pRst->IsLeaf())
    {
        ScanLeaf (pRst);
    }
    else
    {
        switch (pRst->Type())
        {
        case RTPhrase:
        case RTProximity:
        case RTVector:
        case RTAnd:
        case RTOr:
            ScanNode (pRst->CastToNode());
            break;
        case RTNot:
            ScanRst ( ((CNotRestriction *)pRst)->GetChild() );
            break;
        default:
            Win4Assert ( !"Bad Restriction Type" );
            THROW (CException(QUERY_E_INVALIDRESTRICTION));
        }
    }
}

void CRecognizer::ScanNode (const CNodeRestriction * pNode)
{
    unsigned cChild = pNode->Count();
    for (unsigned i = 0; i < cChild; i++)
    {
        ScanRst (pNode->GetChild(i));
    }
}

void CRecognizer::ScanLeaf (const CRestriction* pRst )
{
    switch (pRst->Type())
    {
    case RTWord:
    {
        CWordRestriction* wordRst = (CWordRestriction*) pRst;
        const CKey* pKey = wordRst->GetKey();

        if ( wordRst->IsRange() )
            AddPrefix (pKey);
        else
            AddKey (pKey);
        break;
    }
    case RTSynonym:
    {
        CSynRestriction* pSynRst = (CSynRestriction*) pRst;
        CKeyArray& keyArray = pSynRst->GetKeys();
        AddKeyArray ( keyArray, pSynRst->IsRange() );
        break;
    }
    case RTRange:
    {
        CRangeRestriction* pRangRst = (CRangeRestriction*) pRst;
        AddRange ( pRangRst->GetStartKey(), pRangRst->GetEndKey () );
        break;
    }
    case RTNone:
    {
        // Noise words from vector queries come in as RTNone.  Ignore them.

        break;
    }
    default:
        Win4Assert ( !"Bad Restriction Type" );
        THROW (CException(QUERY_E_INVALIDRESTRICTION));
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CRecognizer::AddKey, public
//
//  Synopsis:   Add a key detector
//
//  History:    01-Oct-94   BartoszM      Created
//
//----------------------------------------------------------------------------
void CRecognizer::AddKey ( const CKey* pKey )
{
    int i = FindDet ( DetSingleKey, pKey );
    if (i == -1)
    {
        _aDetector.Push ( new CKeyDetector (*pKey) );
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CRecognizer::AddPrefix, public
//
//  Synopsis:   Add a prefix detector
//
//  History:    01-Oct-94   BartoszM      Created
//
//----------------------------------------------------------------------------
void CRecognizer::AddPrefix ( const CKey* pKey )
{
    int i = FindDet ( DetPrefix, pKey );
    if (i == -1)
    {
        _aDetector.Push ( new CKeyPrefixDetector (*pKey) );
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CRecognizer::AddRange, public
//
//  Synopsis:   Add a range detector
//
//  History:    01-Oct-94   BartoszM      Created
//
//----------------------------------------------------------------------------
void CRecognizer::AddRange ( const CKey* pKeyStart, const CKey* pKeyEnd )
{
    int i = FindDet ( DetRange, pKeyStart, pKeyEnd );
    if (i == -1)
    {
        _aDetector.Push ( new CKeyRangeDetector (*pKeyStart, *pKeyEnd) );
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CRecognizer::AddKeyArray, public
//
//  Synopsis:   Add key detectors
//
//  History:    01-Oct-94   BartoszM      Created
//
//----------------------------------------------------------------------------
void CRecognizer::AddKeyArray ( const CKeyArray& keyArray, BOOL isRange )
{
    if (isRange)
    {
        for (int i = 0; i < keyArray.Count(); i++ )
        {
            int j = FindDet (DetPrefix, &keyArray.Get(i));
            if (j == -1)
            {
                _aDetector.Push ( new CKeyPrefixDetector (keyArray.Get(i)) );
            }
        }
    }
    else
    {
        for ( int i = 0; i < keyArray.Count(); i++ )
        {
            int j = FindDet (DetSingleKey, &keyArray.Get(i));
            if (j == -1)
            {
                _aDetector.Push ( new CKeyDetector (keyArray.Get(i)) );
            }
        }
    }
}

int CRecognizer::FindDet (DetectorType type, const CKey* pKey1, const CKey* pKey2) const
{
    Win4Assert ( 0 != pKey1 );
    for (unsigned i = 0; i < _aDetector.Count(); i++)
    {
        const CDetector* pDet = _aDetector.Get (i);
        if ( pDet->Type() == type && pKey1->IsExactMatch (*pDet->GetKey()) )
        {
            switch (type)
            {
            case DetSingleKey:
            case DetPrefix:
                Win4Assert ( 0 == pKey2 );
                return i;
                break;
            case DetRange:
                Win4Assert ( 0 != pKey2 );
                if (pKey2->IsExactMatch (*pDet->GetSecondKey()))
                {
                    return i;
                }
                break;
            }
        }
    }
    return -1;
}

//+---------------------------------------------------------------------------
//
//  Member:     CRecognizer::Match, public
//
//  History:    05-Oct-94   BartoszM      Created
//
//  Synopsis:   It is a sort of an iterator.
//              If Match returns TRUE, you should Record the hit,
//              after which Match should be called again with the same key
//              and so on, until Match returns FALSE
//
//----------------------------------------------------------------------------
BOOL CRecognizer::Match ( const CKeyBuf& key )
{
    // start just after the last match
    for (unsigned i = _iDet + 1; i < _aDetector.Count(); i++)
    {
        if ( _aDetector.Get(i)->Match (key) )
        {
            _iDet = i;  // leave it in this state
            return TRUE;
        }
    }
    _iDet = -1; // reset the state
    return FALSE;
}

//+---------------------------------------------------------------------------
//
//  Member:     CRecognizer::Record, public
//
//  History:    05-Oct-94   BartoszM      Created
//
//  Synopsis:   Records the filter region position of a matched key
//
//----------------------------------------------------------------------------
void CRecognizer::Record ( const FILTERREGION& region, OCCURRENCE occ)
{
    Win4Assert ( -1 != _iDet );
    CRegionHit* pReg = new CRegionHit ( region, occ );

    _aRegionList[_iDet].Insert ( pReg );
}

//  Foo* CFooList::Insert ( CFoo* pFoo )
//  {
//      for ( CBackFooIter it(*this); !AtEnd(it); BackUp(it) )
//      {
//          if ( it->Size() <= pFoo->Size() ) // overloaded operator ->
//          {
//              pFoo->InsertAfter(it.GetFoo());
//              return;
//          }
//      }
//      // end of list
//      Push(pFoo);
//  }
//

void CRegionList::Insert (CRegionHit* pHit)
{
    for (CRegionBackIter it(*this); !AtEnd(it); BackUp(it))
    {
        if ( it.GetRegionHit()->Occurrence() <= pHit->Occurrence() )
        {
            pHit->InsertAfter (it.GetRegionHit());
            return;
        }
    }
    _Push(pHit);
}

CRegionList::~CRegionList ()
{
    CRegionHit* pHit;
    while ( (pHit = (CRegionHit*) _Pop ()) != 0 )
    {
        delete pHit;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\isearch\skrep.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1991 - 1992.
//
//  File:   SKREP.CXX
//
//  Contents:   Search Key Repository
//
//  Classes:    CSearchKeyRepository
//
//  History:    23-Sep-94    BartoszM   Created.
//
//----------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include <mapper.hxx>
#include <recogniz.hxx>

#include "skrep.hxx"

//+---------------------------------------------------------------------------
//
//  Member:     CSearchKeyRepository::CSearchKeyRepository
//
//  Synopsis:   Creates a key repository
//
//  History:    23-Sep-94    BartoszM   Created.
//----------------------------------------------------------------------------
CSearchKeyRepository::CSearchKeyRepository( CRecognizer& recog )
: _recog(recog)
{
}

//+---------------------------------------------------------------------------
//
//  Member:     CSearchKeyRepository::PutKey
//
//  Synopsis:   Puts a key
//
//  Arguments:  cNoiseWordsSkipped -- ignored (used by CQueryKeyRepository::PutKey )
//
//  History:    23-Sep-94    BartoszM   Created.
//
//
//----------------------------------------------------------------------------

void    CSearchKeyRepository::PutKey ( ULONG cNoiseWordsSkipped )
{

    ciDebugOut(( DEB_WORDS," PutKey:: %.*ws\n",
                _key.StrLen(), _key.GetStr() ));

    if ( _recog.Match (_key) )
    {
        FILTERREGION region;
        _pMapper->GetSrcRegion ( region, _srcLen, _srcPos );
        // there could be more detectors that match this key
        do
            _recog.Record ( region, _occ );
        while ( _recog.Match (_key) );
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CSearchKeyRepository::GetBuffers
//
//  Synopsis:   Returns address of repository's input buffers
//
//  Arguments:  [ppcbInBuf] -- pointer to pointer to size of input buffer
//              [ppbInBuf] -- pointer to pointer to recieve address of buffer
//              [ppocc] -- pointer to pointer to recieve address of occurrences
//
//  History:    23-Sep-94    BartoszM   Created.
//
//----------------------------------------------------------------------------

void    CSearchKeyRepository::GetBuffers(
    UINT** ppcbWordBuf, BYTE** ppbWordBuf, OCCURRENCE** ppocc )
{
    _key.SetCount(MAXKEYSIZE);
    *ppcbWordBuf = _key.GetCountAddress();
    *ppbWordBuf = _key.GetWritableBuf();
    *ppocc = &_occ;
}

void CSearchKeyRepository::GetSourcePosBuffers( ULONG** ppSrcPos, ULONG** ppSrcLen)
{
    *ppSrcPos = &_srcPos;
    *ppSrcLen = &_srcLen;
}

void CSearchKeyRepository::GetFlags ( BOOL** ppRange, CI_RANK** ppRank )
{
    *ppRange = 0;
    *ppRank = 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\kbyacc\closure.c ===
#include "defs.h"

short *itemset;
short *itemsetend;
unsigned *ruleset;

static unsigned *first_derives;
static unsigned *EFF;


set_EFF()
{
    register unsigned *row;
    register int symbol;
    register short *sp;
    register int rowsize;
    register int i;
    register int rule;

    rowsize = WORDSIZE(nvars);
    EFF = NEW2(nvars * rowsize, unsigned);

    row = EFF;
    for (i = start_symbol; i < nsyms; i++)
    {
        sp = derives[i];
        for (rule = *sp; rule > 0; rule = *++sp)
        {
            symbol = ritem[rrhs[rule]];
            if (ISVAR(symbol))
            {
                symbol -= start_symbol;
                SETBIT(row, symbol);
            }
        }
        row += rowsize;
    }

    reflexive_transitive_closure(EFF, nvars);

#ifdef  DEBUG
    print_EFF();
#endif
}


#if defined(KYLEP_CHANGE)
void
#endif
set_first_derives()
{
    register unsigned *rrow;
    register unsigned *vrow;
    register int j;
    register unsigned k;
    register unsigned cword;
    register short *rp;

    int rule;
    int i;
    int rulesetsize;
    int varsetsize;

    rulesetsize = WORDSIZE(nrules);
    varsetsize = WORDSIZE(nvars);
    first_derives = NEW2(nvars * rulesetsize, unsigned) - ntokens * rulesetsize;

    set_EFF();

    rrow = first_derives + ntokens * rulesetsize;
    for (i = start_symbol; i < nsyms; i++)
    {
        vrow = EFF + ((i - ntokens) * varsetsize);
        k = BITS_PER_WORD;
        for (j = start_symbol; j < nsyms; k++, j++)
        {
            if (k >= BITS_PER_WORD)
            {
                cword = *vrow++;
                k = 0;
            }

            if (cword & (1 << k))
            {
                rp = derives[j];
                while ((rule = *rp++) >= 0)
                {
                    SETBIT(rrow, rule);
                }
            }
        }

        vrow += varsetsize;
        rrow += rulesetsize;
    }

#ifdef  DEBUG
    print_first_derives();
#endif

    FREE(EFF);
}


#if defined(KYLEP_CHANGE)
void
#endif
closure(nucleus, n)
short *nucleus;
int n;
{
    register int ruleno;
    register unsigned word;
    register unsigned i;
    register short *csp;
    register unsigned *dsp;
    register unsigned *rsp;
    register int rulesetsize;

    short *csend;
    unsigned *rsend;
    int symbol;
    int itemno;

    rulesetsize = WORDSIZE(nrules);
    rsp = ruleset;
    rsend = ruleset + rulesetsize;
    for (rsp = ruleset; rsp < rsend; rsp++)
        *rsp = 0;

    csend = nucleus + n;
    for (csp = nucleus; csp < csend; ++csp)
    {
        symbol = ritem[*csp];
        if (ISVAR(symbol))
        {
            dsp = first_derives + symbol * rulesetsize;
            rsp = ruleset;
            while (rsp < rsend)
                *rsp++ |= *dsp++;
        }
    }

    ruleno = 0;
    itemsetend = itemset;
    csp = nucleus;
    for (rsp = ruleset; rsp < rsend; ++rsp)
    {
        word = *rsp;
        if (word)
        {
            for (i = 0; i < BITS_PER_WORD; ++i)
            {
                if (word & (1 << i))
                {
                    itemno = rrhs[ruleno+i];
                    while (csp < csend && *csp < itemno)
                        #if defined(KYLEP_CHANGE)
                        *itemsetend++ = (short)*csp++;
                        *itemsetend++ = (short)itemno;
                        #else
                        *itemsetend++ = *csp++;
                        *itemsetend++ = itemno;
                        #endif // KYLEP_CHANGE
                    while (csp < csend && *csp == itemno)
                        ++csp;
                }
            }
        }
        ruleno += BITS_PER_WORD;
    }

    while (csp < csend)
        *itemsetend++ = *csp++;

#ifdef  DEBUG
  print_closure(n);
#endif
}



#if defined(KYLEP_CHANGE)
void
#endif
finalize_closure()
{
  FREE(itemset);
  FREE(ruleset);
  FREE(first_derives + ntokens * WORDSIZE(nrules));
}


#ifdef  DEBUG

print_closure(n)
int n;
{
  register short *isp;

  printf("\n\nn = %d\n\n", n);
  for (isp = itemset; isp < itemsetend; isp++)
    printf("   %d\n", *isp);
}


print_EFF()
{
    register int i, j;
    register unsigned *rowp;
    register unsigned word;
    register unsigned k;

    printf("\n\nEpsilon Free Firsts\n");

    for (i = start_symbol; i < nsyms; i++)
    {
        printf("\n%s", symbol_name[i]);
        rowp = EFF + ((i - start_symbol) * WORDSIZE(nvars));
        word = *rowp++;

        k = BITS_PER_WORD;
        for (j = 0; j < nvars; k++, j++)
        {
            if (k >= BITS_PER_WORD)
            {
                word = *rowp++;
                k = 0;
            }

            if (word & (1 << k))
                printf("  %s", symbol_name[start_symbol + j]);
        }
    }
}


print_first_derives()
{
    register int i;
    register int j;
    register unsigned *rp;
    register unsigned cword;
    register unsigned k;

    printf("\n\n\nFirst Derives\n");

    for (i = start_symbol; i < nsyms; i++)
    {
        printf("\n%s derives\n", symbol_name[i]);
        rp = first_derives + i * WORDSIZE(nrules);
        k = BITS_PER_WORD;
        for (j = 0; j <= nrules; k++, j++)
        {
          if (k >= BITS_PER_WORD)
          {
              cword = *rp++;
              k = 0;
          }

          if (cword & (1 << k))
            printf("   %d\n", j);
        }
    }

  fflush(stdout);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\kbyacc\defs.h ===
#include <assert.h>
#include <ctype.h>
#include <stdio.h>


/*  machine-dependent definitions                       */
/*  the following definitions are for the Tahoe         */
/*  they might have to be changed for other machines    */

/*  MAXCHAR is the largest unsigned character value     */
/*  MAXSHORT is the largest value of a C short          */
/*  MINSHORT is the most negative value of a C short    */
/*  MAXTABLE is the maximum table size                  */
/*  BITS_PER_WORD is the number of bits in a C unsigned */
/*  WORDSIZE computes the number of words needed to     */
/*      store n bits                                    */
/*  BIT returns the value of the n-th bit starting      */
/*      from r (0-indexed)                              */
/*  SETBIT sets the n-th bit starting from r            */

#define MAXCHAR         255
#define MAXSHORT        32767
#define MINSHORT        -32768
#define MAXTABLE        32500
#define BITS_PER_WORD   32
#define WORDSIZE(n)     (((n)+(BITS_PER_WORD-1))/BITS_PER_WORD)
#define BIT(r, n)       ((((r)[(n)>>5])>>((n)&31))&1)
#define SETBIT(r, n)    ((r)[(n)>>5]|=((unsigned)1<<((n)&31)))


/*  character names  */

#define NUL             '\0'    /*  the null character  */
#define NEWLINE         '\n'    /*  line feed  */
#define SP              ' '     /*  space  */
#define BS              '\b'    /*  backspace  */
#define HT              '\t'    /*  horizontal tab  */
#define VT              '\013'  /*  vertical tab  */
#define CR              '\r'    /*  carriage return  */
#define FF              '\f'    /*  form feed  */
#define QUOTE           '\''    /*  single quote  */
#define DOUBLE_QUOTE    '\"'    /*  double quote  */
#define BACKSLASH       '\\'    /*  backslash  */


/* defines for constructing filenames */

#define CODE_SUFFIX     ".code.c"
#define DEFINES_SUFFIX  ".tab.h"
#define OUTPUT_SUFFIX   ".tab.c"
#define VERBOSE_SUFFIX  ".output"


/* keyword codes */

#define TOKEN 0
#define LEFT 1
#define RIGHT 2
#define NONASSOC 3
#define MARK 4
#define TEXT 5
#define TYPE 6
#define START 7
#define UNION 8
#define IDENT 9


/*  symbol classes  */

#define UNKNOWN 0
#define TERM 1
#define NONTERM 2


/*  the undefined value  */

#define UNDEFINED (-1)


/*  action codes  */

#define SHIFT 1
#define REDUCE 2


/*  character macros  */

#define IS_IDENT(c)     (isalnum(c) || (c) == '_' || (c) == '.' || (c) == '$')
#define IS_OCTAL(c)     ((c) >= '0' && (c) <= '7')
#define NUMERIC_VALUE(c)        ((c) - '0')


/*  symbol macros  */

#define ISTOKEN(s)      ((s) < start_symbol)
#define ISVAR(s)        ((s) >= start_symbol)


/*  storage allocation macros  */

#define CALLOC(k,n)     (calloc((unsigned)(k),(unsigned)(n)))
#define FREE(x)         (free((char*)(x)))
#define MALLOC(n)       (malloc((unsigned)(n)))
#define NEW(t)          ((t*)allocate(sizeof(t)))
#define NEW2(n,t)       ((t*)allocate((unsigned)((n)*sizeof(t))))
#define REALLOC(p,n)    (realloc((char*)(p),(unsigned)(n)))


/*  the structure of a symbol table entry  */

typedef struct bucket bucket;
struct bucket
{
    struct bucket *link;
    struct bucket *next;
    char *name;
    char *tag;
    short value;
    short index;
    short prec;
    char class;
    char assoc;
};


/*  the structure of the LR(0) state machine  */

typedef struct core core;
struct core
{
    struct core *next;
    struct core *link;
    short number;
    short accessing_symbol;
    short nitems;
    short items[1];
};


/*  the structure used to record shifts  */

typedef struct shifts shifts;
struct shifts
{
    struct shifts *next;
    short number;
    short nshifts;
    short shift[1];
};


/*  the structure used to store reductions  */

typedef struct reductions reductions;
struct reductions
{
    struct reductions *next;
    short number;
    short nreds;
    short rules[1];
};


/*  the structure used to represent parser actions  */

typedef struct action action;
struct action
{
    struct action *next;
    short symbol;
    short number;
    short prec;
    char action_code;
    char assoc;
    char suppressed;
};


/* global variables */

extern char dflag;
extern char lflag;
extern char rflag;
extern char tflag;
extern char vflag;
extern char *symbol_prefix;

extern char *myname;
extern char *cptr;
extern char *line;
extern int lineno;
extern int outline;

extern char *banner[];
extern char *tables[];
#if defined (TRIPLISH)
extern char *includefiles[];
#endif
#if defined(KYLEP_CHANGE)
extern char *header1[];
extern char *header2[];
extern char *header3[];
#if defined (TRIPLISH)
extern char *header4[];
#endif
#else
extern char *header[];
#endif 
extern char *body[];
extern char *trailer[];
#if defined (TRIPLISH)
extern char *TriplishBody[];
extern char *TriplishTrailer[];
#endif

extern char *action_file_name;
extern char *code_file_name;
extern char *defines_file_name;
extern char *input_file_name;
extern char *output_file_name;
extern char *text_file_name;
extern char *union_file_name;
extern char *verbose_file_name;

extern FILE *action_file;
extern FILE *code_file;
extern FILE *defines_file;
extern FILE *input_file;
extern FILE *output_file;
extern FILE *text_file;
extern FILE *union_file;
extern FILE *verbose_file;

extern int nitems;
extern int nrules;
extern int nsyms;
extern int ntokens;
extern int nvars;
extern int ntags;

extern char unionized;
extern char line_format[];

extern int   start_symbol;
extern char  **symbol_name;
extern short *symbol_value;
extern short *symbol_prec;
extern char  *symbol_assoc;

extern short *ritem;
extern short *rlhs;
extern short *rrhs;
extern short *rprec;
extern char  *rassoc;

extern short **derives;
extern char *nullable;

extern bucket *first_symbol;
extern bucket *last_symbol;

extern int nstates;
extern core *first_state;
extern shifts *first_shift;
extern reductions *first_reduction;
extern short *accessing_symbol;
extern core **state_table;
extern shifts **shift_table;
extern reductions **reduction_table;
extern unsigned *LA;
extern short *LAruleno;
extern short *lookaheads;
extern short *goto_map;
extern short *from_state;
extern short *to_state;

extern action **parser;
extern int SRtotal;
extern int RRtotal;
extern short *SRconflicts;
extern short *RRconflicts;
extern short *defred;
extern short *rules_used;
extern short nunused;
extern short final_state;

/* global functions */

extern char *allocate();
extern bucket *lookup();
extern bucket *make_bucket();


/* system variables */

extern int errno;


/* system functions */
#if defined(KYLEP_CHANGE)
 #include <stdlib.h>
 #include <string.h>
 #include <io.h>

 #define mktemp _mktemp
 #define unlink _unlink
#else
 extern void free();
 extern char *calloc();
 extern char *malloc();
 extern char *realloc();
 extern char *strcpy();
#endif // KYLEP_CHANGE

#if defined(KYLEP_CHANGE)

extern char *baseclass;
extern char *ctorargs;

/* BYACC prototypes, with type safety */
void reflexive_transitive_closure( unsigned * R, int n );
void set_first_derives();
void closure( short * nucleus, int n );
void finalize_closure();

/* From main.c */
int done( int k );

/* From error.c */
void no_space();
void fatal( char * msg );
void open_error( char * filename );
void unterminated_comment( int c_lineno, char * c_line, char * c_cptr );
void unterminated_string( int s_lineno, char * s_line, char * s_cptr );
void unterminated_text( int t_lineno, char * t_line, char * t_cptr );
void unterminated_union( int u_lineno, char * u_line, char * u_cptr );
void syntax_error( int st_lineno, char * st_line, char * st_cptr );
void unexpected_EOF();
void over_unionized( char * u_cptr );
void illegal_character( char * c_cptr );
void used_reserved( char * s );
void illegal_tag( int t_lineno, char * t_line, char * t_cptr );
void tokenized_start( char * s );
void retyped_warning( char * s );
void reprec_warning( char * s );
void revalued_warning( char * s );
void terminal_start( char * s );
void restarted_warning();
void no_grammar();
void terminal_lhs( int s_lineno );
void default_action_warning();
void dollar_warning( int a_lineno, int i );
void dollar_error( int a_lineno, char * a_line, char * a_cptr );
void untyped_lhs();
void unknown_rhs( int i );
void untyped_rhs( int i, char * s );
void unterminated_action( int a_lineno, char * a_line, char * a_cptr );
void prec_redeclared();
void undefined_goal( char * s );
void undefined_symbol_warning( char * s );

/* From reader.c */
void reader();

/* From lr0.c */
void lr0();

/* From lalr.c */
void lalr();

/* From mkpar.c */
void make_parser();
void free_parser();

/* From verbose.c */
void verbose();

/* From output.c */
void output();

/* From skeleton.c */
void write_section( char * section[], FILE * f );

/* From symtab.c */
void create_symbol_table();
void free_symbol_table();
void free_symbols();

#if defined (TRIPLISH)
enum eParser
{
    eSQLParser,
    eTriplishParser
};
#endif

#endif //KYLEP_CHANGE
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\kbyacc\lalr.c ===
#include "defs.h"

#if defined(KYLEP_CHANGE)
/* BYACC prototypes, with type safety */

void set_state_table();
void set_accessing_symbol();
void set_shift_table();
void set_reduction_table();
void set_maxrhs();
void initialize_LA();
void set_goto_map();
void initialize_F();
void build_relations();
void compute_FOLLOWS();
void compute_lookaheads();
void digraph( short **relation );
void add_lookback_edge( int stateno, int ruleno, int gotono );
void traverse( int i );
#endif // KYLEP_CHANGE

typedef
  struct shorts
    {
      struct shorts *next;
      short value;
    }
  shorts;

int tokensetsize;
short *lookaheads;
short *LAruleno;
unsigned *LA;
short *accessing_symbol;
core **state_table;
shifts **shift_table;
reductions **reduction_table;
short *goto_map;
short *from_state;
short *to_state;

short **transpose();

static int infinity;
static int maxrhs;
#if defined(KYLEP_CHANGE)
static short ngotos;
#else
static int ngotos;
#endif // KYLEP_CHANGE
static unsigned *F;
static short **includes;
static shorts **lookback;
static short **R;
static short *INDEX;
static short *VERTICES;
static int top;


#if defined(KYLEP_CHANGE)
void
#endif
lalr()
{
    tokensetsize = WORDSIZE(ntokens);

    set_state_table();
    set_accessing_symbol();
    set_shift_table();
    set_reduction_table();
    set_maxrhs();
    initialize_LA();
    set_goto_map();
    initialize_F();
    build_relations();
    compute_FOLLOWS();
    compute_lookaheads();
}



#if defined(KYLEP_CHANGE)
void
#endif
set_state_table()
{
    register core *sp;

    state_table = NEW2(nstates, core *);
    for (sp = first_state; sp; sp = sp->next)
        state_table[sp->number] = sp;
}



#if defined(KYLEP_CHANGE)
void
#endif
set_accessing_symbol()
{
    register core *sp;

    accessing_symbol = NEW2(nstates, short);
    for (sp = first_state; sp; sp = sp->next)
        accessing_symbol[sp->number] = sp->accessing_symbol;
}



#if defined(KYLEP_CHANGE)
void
#endif
set_shift_table()
{
    register shifts *sp;

    shift_table = NEW2(nstates, shifts *);
    for (sp = first_shift; sp; sp = sp->next)
        shift_table[sp->number] = sp;
}



#if defined(KYLEP_CHANGE)
void
#endif
set_reduction_table()
{
    register reductions *rp;

    reduction_table = NEW2(nstates, reductions *);
    for (rp = first_reduction; rp; rp = rp->next)
        reduction_table[rp->number] = rp;
}



#if defined(KYLEP_CHANGE)
void
#endif
set_maxrhs()
{
  register short *itemp;
  register short *item_end;
  register int length;
  register int max;

  length = 0;
  max = 0;
  item_end = ritem + nitems;
  for (itemp = ritem; itemp < item_end; itemp++)
    {
      if (*itemp >= 0)
        {
          length++;
        }
      else
        {
          if (length > max) max = length;
          length = 0;
        }
    }

  maxrhs = max;
}



#if defined(KYLEP_CHANGE)
void
#endif
initialize_LA()
{
  #if defined(KYLEP_CHANGE)
  register short i, j, k;
  #else
  register int i, j, k;
  #endif // KYLEP_CHANGE

  register reductions *rp;

  lookaheads = NEW2(nstates + 1, short);

  k = 0;
  for (i = 0; i < nstates; i++)
    {
      lookaheads[i] = k;
      rp = reduction_table[i];
      if (rp)
        k += rp->nreds;
    }
  lookaheads[nstates] = k;

  LA = NEW2(k * tokensetsize, unsigned);
  LAruleno = NEW2(k, short);
  lookback = NEW2(k, shorts *);

  k = 0;
  for (i = 0; i < nstates; i++)
    {
      rp = reduction_table[i];
      if (rp)
        {
          for (j = 0; j < rp->nreds; j++)
            {
              LAruleno[k] = rp->rules[j];
              k++;
            }
        }
    }
}


#if defined(KYLEP_CHANGE)
void
#endif
set_goto_map()
{
  register shifts *sp;
  register int i;
  register int symbol;
  #if defined(KYLEP_CHANGE)
  register short k;
  #else
  register int k;
  #endif // KYLEP_CHANGE
  register short *temp_map;
  register int state2;
  register int state1;

  goto_map = NEW2(nvars + 1, short) - ntokens;
  temp_map = NEW2(nvars + 1, short) - ntokens;

  ngotos = 0;
  for (sp = first_shift; sp; sp = sp->next)
    {
      for (i = sp->nshifts - 1; i >= 0; i--)
        {
          symbol = accessing_symbol[sp->shift[i]];

          if (ISTOKEN(symbol)) break;

          if (ngotos == MAXSHORT)
            fatal("too many gotos");

          ngotos++;
          goto_map[symbol]++;
        }
    }

  k = 0;
  for (i = ntokens; i < nsyms; i++)
    {
      temp_map[i] = k;
      k += goto_map[i];
    }

  for (i = ntokens; i < nsyms; i++)
    goto_map[i] = temp_map[i];

  goto_map[nsyms] = ngotos;
  temp_map[nsyms] = ngotos;

  from_state = NEW2(ngotos, short);
  to_state = NEW2(ngotos, short);

  for (sp = first_shift; sp; sp = sp->next)
    {
      state1 = sp->number;
      for (i = sp->nshifts - 1; i >= 0; i--)
        {
          state2 = sp->shift[i];
          symbol = accessing_symbol[state2];

          if (ISTOKEN(symbol)) break;

          k = temp_map[symbol]++;
          #if defined(KYLEP_CHANGE)
          from_state[k] = (short) state1;
          to_state[k] = (short) state2;
          #else
          from_state[k] = state1;
          to_state[k] = state2;
          #endif // KYLEP_CHANGE
        }
    }

  FREE(temp_map + ntokens);
}



/*  Map_goto maps a state/symbol pair into its numeric representation.  */

int
map_goto(state, symbol)
int state;
int symbol;
{
    register int high;
    register int low;
    register int middle;
    register int s;

    low = goto_map[symbol];
    high = goto_map[symbol + 1];

    for (;;)
    {
        assert(low <= high);
        middle = (low + high) >> 1;
        s = from_state[middle];
        if (s == state)
            return (middle);
        else if (s < state)
            low = middle + 1;
        else
            high = middle - 1;
    }
}



#if defined(KYLEP_CHANGE)
void
#endif
initialize_F()
{
  register int i;
  register int j;
  register int k;
  register shifts *sp;
  register short *edge;
  register unsigned *rowp;
  register short *rp;
  register short **reads;
  register int nedges;
  register int stateno;
  register int symbol;
  register int nwords;

  nwords = ngotos * tokensetsize;
  F = NEW2(nwords, unsigned);

  reads = NEW2(ngotos, short *);
  edge = NEW2(ngotos + 1, short);
  nedges = 0;

  rowp = F;
  for (i = 0; i < ngotos; i++)
    {
      stateno = to_state[i];
      sp = shift_table[stateno];

      if (sp)
        {
          k = sp->nshifts;

          for (j = 0; j < k; j++)
            {
              symbol = accessing_symbol[sp->shift[j]];
              if (ISVAR(symbol))
                break;
              SETBIT(rowp, symbol);
            }

          for (; j < k; j++)
            {
              #if defined(KYLEP_CHANGE)
              symbol = (short) accessing_symbol[sp->shift[j]];
              #else              
              symbol = accessing_symbol[sp->shift[j]];
              #endif // KYLEP_CHANGE             
              if (nullable[symbol])
                #if defined(KYLEP_CHANGE)
                edge[nedges++] = (short) map_goto(stateno, symbol);
                #else                
                edge[nedges++] = map_goto(stateno, symbol);
                #endif // KYLEP_CHANGE               
            }

          if (nedges)
            {
              reads[i] = rp = NEW2(nedges + 1, short);

              for (j = 0; j < nedges; j++)
                rp[j] = edge[j];

              rp[nedges] = -1;
              nedges = 0;
            }
        }

      rowp += tokensetsize;
    }

  SETBIT(F, 0);
  digraph(reads);

  for (i = 0; i < ngotos; i++)
    {
      if (reads[i])
        FREE(reads[i]);
    }

  FREE(reads);
  FREE(edge);
}



#if defined(KYLEP_CHANGE)
void
#endif
build_relations()
{
  register int i;
  register int j;
  register int k;
  register short *rulep;
  register short *rp;
  register shifts *sp;
  register int length;
  register int nedges;
  register int done;
  register int state1;
  register int stateno;
  register int symbol1;
  register int symbol2;
  register short *shortp;
  register short *edge;
  register short *states;
  register short **new_includes;

  includes = NEW2(ngotos, short *);
  edge = NEW2(ngotos + 1, short);
  states = NEW2(maxrhs + 1, short);

  for (i = 0; i < ngotos; i++)
    {
      nedges = 0;
      state1 = from_state[i];
      symbol1 = accessing_symbol[to_state[i]];

      for (rulep = derives[symbol1]; *rulep >= 0; rulep++)
        {
          length = 1;
          #if defined(KYLEP_CHANGE)
          states[0] = (short) state1;
          #else          
          states[0] = state1;
          #endif // KYLEP_CHANGE
          stateno = state1;

          for (rp = ritem + rrhs[*rulep]; *rp >= 0; rp++)
            {
              symbol2 = *rp;
              sp = shift_table[stateno];
              k = sp->nshifts;

              for (j = 0; j < k; j++)
                {
                  stateno = sp->shift[j];
                  if (accessing_symbol[stateno] == symbol2) break;
                }

              #if defined(KYLEP_CHANGE)
              states[length++] = (short) stateno;
              #else              
              states[length++] = stateno;
              #endif // KYLEP_CHANGE             
            }

          add_lookback_edge(stateno, *rulep, i);

          length--;
          done = 0;
          while (!done)
            {
              done = 1;
              rp--;
              if (ISVAR(*rp))
                {
                  stateno = states[--length];
                  #if defined(KYLEP_CHANGE)
                  edge[nedges++] = (short) map_goto(stateno, *rp);
                  #else                  
                  edge[nedges++] = map_goto(stateno, *rp);
                  #endif // KYLEP_CHANGE                 
                  if (nullable[*rp] && length > 0) done = 0;
                }
            }
        }

      if (nedges)
        {
          includes[i] = shortp = NEW2(nedges + 1, short);
          for (j = 0; j < nedges; j++)
            shortp[j] = edge[j];
          shortp[nedges] = -1;
        }
    }

  new_includes = transpose(includes, ngotos);

  for (i = 0; i < ngotos; i++)
    if (includes[i])
      FREE(includes[i]);

  FREE(includes);

  includes = new_includes;

  FREE(edge);
  FREE(states);
}


#if defined(KYLEP_CHANGE)
void
#endif
add_lookback_edge(stateno, ruleno, gotono)
int stateno, ruleno, gotono;
{
    register int i, k;
    register int found;
    register shorts *sp;

    i = lookaheads[stateno];
    k = lookaheads[stateno + 1];
    found = 0;
    while (!found && i < k)
    {
        if (LAruleno[i] == ruleno)
            found = 1;
        else
            ++i;
    }
    assert(found);

    sp = NEW(shorts);
    sp->next = lookback[i];
    #if defined(KYLEP_CHANGE)
    sp->value = (short) gotono;
    #else    
    sp->value = gotono;
    #endif // KYLEP_CHANGE
    lookback[i] = sp;
}



short **
transpose(R, n)
short **R;
int n;
{
  register short **new_R;
  register short **temp_R;
  register short *nedges;
  register short *sp;
  register int i;
  register int k;

  nedges = NEW2(n, short);

  for (i = 0; i < n; i++)
    {
      sp = R[i];
      if (sp)
        {
          while (*sp >= 0)
            nedges[*sp++]++;
        }
    }

  new_R = NEW2(n, short *);
  temp_R = NEW2(n, short *);

  for (i = 0; i < n; i++)
    {
      k = nedges[i];
      if (k > 0)
        {
          sp = NEW2(k + 1, short);
          new_R[i] = sp;
          temp_R[i] = sp;
          sp[k] = -1;
        }
    }

  FREE(nedges);

  for (i = 0; i < n; i++)
    {
      sp = R[i];
      if (sp)
        {
          while (*sp >= 0)
            #if defined(KYLEP_CHANGE)
            *temp_R[*sp++]++ = (short) i;
            #else            
            *temp_R[*sp++]++ = i;
            #endif // KYLEP_CHANGE
        }
    }

  FREE(temp_R);

  return (new_R);
}



#if defined(KYLEP_CHANGE)
void
#endif
compute_FOLLOWS()
{
  digraph(includes);
}


#if defined(KYLEP_CHANGE)
void
#endif
compute_lookaheads()
{
  register int i, n;
  register unsigned *fp1, *fp2, *fp3;
  register shorts *sp, *next;
  register unsigned *rowp;

  rowp = LA;
  n = lookaheads[nstates];
  for (i = 0; i < n; i++)
    {
      fp3 = rowp + tokensetsize;
      for (sp = lookback[i]; sp; sp = sp->next)
        {
          fp1 = rowp;
          fp2 = F + tokensetsize * sp->value;
          while (fp1 < fp3)
            *fp1++ |= *fp2++;
        }
      rowp = fp3;
    }

  for (i = 0; i < n; i++)
    for (sp = lookback[i]; sp; sp = next)
      {
        next = sp->next;
        FREE(sp);
      }

  FREE(lookback);
  FREE(F);
}


#if defined(KYLEP_CHANGE)
void
#endif
digraph(relation)
short **relation;
{
  register int i;

  infinity = ngotos + 2;
  INDEX = NEW2(ngotos + 1, short);
  VERTICES = NEW2(ngotos + 1, short);
  top = 0;

  R = relation;

  for (i = 0; i < ngotos; i++)
    INDEX[i] = 0;

  for (i = 0; i < ngotos; i++)
    {
      if (INDEX[i] == 0 && R[i])
        traverse(i);
    }

  FREE(INDEX);
  FREE(VERTICES);
}



#if defined(KYLEP_CHANGE)
void
#endif
traverse(i)
register int i;
{
  register unsigned *fp1;
  register unsigned *fp2;
  register unsigned *fp3;
  register int j;
  register short *rp;

  int height;
  unsigned *base;

  #if defined(KYLEP_CHANGE)
  VERTICES[++top] = (short) i;
  #else  
  VERTICES[++top] = i;
  #endif // KYLEP_CHANGE
  INDEX[i] = height = top;

  base = F + i * tokensetsize;
  fp3 = base + tokensetsize;

  rp = R[i];
  if (rp)
    {
      while ((j = *rp++) >= 0)
        {
          if (INDEX[j] == 0)
            traverse(j);

          if (INDEX[i] > INDEX[j])
            INDEX[i] = INDEX[j];

          fp1 = base;
          fp2 = F + j * tokensetsize;

          while (fp1 < fp3)
            *fp1++ |= *fp2++;
        }
    }

  if (INDEX[i] == height)
    {
      for (;;)
        {
          j = VERTICES[top--];
          #if defined(KYLEP_CHANGE)
          INDEX[j] = (short) infinity;
          #else          
          INDEX[j] = infinity;
          #endif // KYLEP_CHANGE         

          if (i == j)
            break;

          fp1 = base;
          fp2 = F + j * tokensetsize;

          while (fp1 < fp3)
            *fp2++ = *fp1++;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\kbyacc\lr0.c ===
#include "defs.h"

#if defined(KYLEP_CHANGE)
/* BYACC prototypes, with type safety */

void initialize_states();
void save_reductions();
void new_itemsets();
void save_shifts();
#endif // KYLEP_CHANGE

extern short *itemset;
extern short *itemsetend;
extern unsigned *ruleset;

int nstates;
core *first_state;
shifts *first_shift;
reductions *first_reduction;

int get_state();
core *new_state();

static core **state_set;
static core *this_state;
static core *last_state;
static shifts *last_shift;
static reductions *last_reduction;

static int nshifts;
static short *shift_symbol;

static short *redset;
static short *shiftset;

static short **kernel_base;
static short **kernel_end;
static short *kernel_items;


allocate_itemsets()
{
    register short *itemp;
    register short *item_end;
    register int symbol;
    register int i;
    register int count;
    register int max;
    register short *symbol_count;

    count = 0;
    symbol_count = NEW2(nsyms, short);

    item_end = ritem + nitems;
    for (itemp = ritem; itemp < item_end; itemp++)
    {
        symbol = *itemp;
        if (symbol >= 0)
        {
            count++;
            symbol_count[symbol]++;
        }
    }

    kernel_base = NEW2(nsyms, short *);
    kernel_items = NEW2(count, short);

    count = 0;
    max = 0;
    for (i = 0; i < nsyms; i++)
    {
        kernel_base[i] = kernel_items + count;
        count += symbol_count[i];
        if (max < symbol_count[i])
            max = symbol_count[i];
    }

    shift_symbol = symbol_count;
    kernel_end = NEW2(nsyms, short *);
}


allocate_storage()
{
    allocate_itemsets();
    shiftset = NEW2(nsyms, short);
    redset = NEW2(nrules + 1, short);
    state_set = NEW2(nitems, core *);
}


append_states()
{
    register int i;
    register int j;
    register int symbol;

#ifdef  TRACE
    fprintf(stderr, "Entering append_states()\n");
#endif
    for (i = 1; i < nshifts; i++)
    {
        symbol = shift_symbol[i];
        j = i;
        while (j > 0 && shift_symbol[j - 1] > symbol)
        {
            shift_symbol[j] = shift_symbol[j - 1];
            j--;
        }
        #if defined(KYLEP_CHANGE)                                         
        shift_symbol[j] = (short) symbol;
        #else
        shift_symbol[j] = symbol;
        #endif // KYLEP_CHANGE
    }

    for (i = 0; i < nshifts; i++)
    {
        symbol = shift_symbol[i];
        #if defined(KYLEP_CHANGE)                                         
        shiftset[i] = (short) get_state(symbol);
        #else
        shiftset[i] = get_state(symbol);
        #endif // KYLEP_CHANGE
    }
}


free_storage()
{
    FREE(shift_symbol);
    FREE(redset);
    FREE(shiftset);
    FREE(kernel_base);
    FREE(kernel_end);
    FREE(kernel_items);
    FREE(state_set);
}



generate_states()
{
    allocate_storage();
    itemset = NEW2(nitems, short);
    ruleset = NEW2(WORDSIZE(nrules), unsigned);
    set_first_derives();
    initialize_states();

    while (this_state)
    {
        closure(this_state->items, this_state->nitems);
        save_reductions();
        new_itemsets();
        append_states();

        if (nshifts > 0)
            save_shifts();

        this_state = this_state->next;
    }

    finalize_closure();
    free_storage();
}



int
get_state(symbol)
int symbol;
{
    register int key;
    register short *isp1;
    register short *isp2;
    register short *iend;
    register core *sp;
    register int found;
    register int n;

#ifdef  TRACE
    fprintf(stderr, "Entering get_state(%d)\n", symbol);
#endif

    isp1 = kernel_base[symbol];
    iend = kernel_end[symbol];
#if defined(KYLEP_CHANGE)
    n = (int) (iend - isp1);
#else
    n = iend - isp1;
#endif

    key = *isp1;
    assert(0 <= key && key < nitems);
    sp = state_set[key];
    if (sp)
    {
        found = 0;
        while (!found)
        {
            if (sp->nitems == n)
            {
                found = 1;
                isp1 = kernel_base[symbol];
                isp2 = sp->items;

                while (found && isp1 < iend)
                {
                    if (*isp1++ != *isp2++)
                        found = 0;
                }
            }

            if (!found)
            {
                if (sp->link)
                {
                    sp = sp->link;
                }
                else
                {
                    sp = sp->link = new_state(symbol);
                    found = 1;
                }
            }
        }
    }
    else
    {
        state_set[key] = sp = new_state(symbol);
    }

    return (sp->number);
}



#if defined(KYLEP_CHANGE)
void
#endif
initialize_states()
{
    register int i;
    register short *start_derives;
    register core *p;

    start_derives = derives[start_symbol];
    for (i = 0; start_derives[i] >= 0; ++i)
        continue;

    p = (core *) MALLOC(sizeof(core) + i*sizeof(short));
    if (p == 0) no_space();

    p->next = 0;
    p->link = 0;
    p->number = 0;
    p->accessing_symbol = 0;
    #if defined(KYLEP_CHANGE)                                             
    p->nitems = (short) i;
    #else
    p->nitems = i;
    #endif // KYLEP_CHANGE

    for (i = 0;  start_derives[i] >= 0; ++i)
        p->items[i] = rrhs[start_derives[i]];

    first_state = last_state = this_state = p;
    nstates = 1;
}


#if defined(KYLEP_CHANGE)
void
#endif
new_itemsets()
{
    register int i;
    register int shiftcount;
    register short *isp;
    register short *ksp;
    register int symbol;

    for (i = 0; i < nsyms; i++)
        kernel_end[i] = 0;

    shiftcount = 0;
    isp = itemset;
    while (isp < itemsetend)
    {
        i = *isp++;
        symbol = ritem[i];
        if (symbol > 0)
        {
            ksp = kernel_end[symbol];
            if (!ksp)
            {
                #if defined(KYLEP_CHANGE)                                 
                shift_symbol[shiftcount++] = (short) symbol;
                #else
                shift_symbol[shiftcount++] = symbol;
                #endif // KYLEP_CHANGE
                ksp = kernel_base[symbol];
            }

            *ksp++ = i + 1;
            kernel_end[symbol] = ksp;
        }
    }

    nshifts = shiftcount;
}



core *
new_state(symbol)
int symbol;
{
    register int n;
    register core *p;
    register short *isp1;
    register short *isp2;
    register short *iend;

#ifdef  TRACE
    fprintf(stderr, "Entering new_state(%d)\n", symbol);
#endif

    if (nstates >= MAXSHORT)
        fatal("too many states");

    isp1 = kernel_base[symbol];
    iend = kernel_end[symbol];
#if defined(KYLEP_CHANGE)
    n = (int) (iend - isp1);
#else
    n = iend - isp1;
#endif

    p = (core *) allocate((unsigned) (sizeof(core) + (n - 1) * sizeof(short)));
    #if defined(KYLEP_CHANGE)                                             
    p->accessing_symbol = (short) symbol;
    p->number = (short) nstates;
    p->nitems = (short) n;
    #else
    p->accessing_symbol = symbol;
    p->number = nstates;
    p->nitems = n;
    #endif // KYLEP_CHANGE

    isp2 = p->items;
    while (isp1 < iend)
        *isp2++ = *isp1++;

    last_state->next = p;
    last_state = p;

    nstates++;

    return (p);
}


/* show_cores is used for debugging */

show_cores()
{
    core *p;
    int i, j, k, n;
    int itemno;

    k = 0;
    for (p = first_state; p; ++k, p = p->next)
    {
        if (k) printf("\n");
        printf("state %d, number = %d, accessing symbol = %s\n",
                k, p->number, symbol_name[p->accessing_symbol]);
        n = p->nitems;
        for (i = 0; i < n; ++i)
        {
            itemno = p->items[i];
            printf("%4d  ", itemno);
            j = itemno;
            while (ritem[j] >= 0) ++j;
            printf("%s :", symbol_name[rlhs[-ritem[j]]]);
            j = rrhs[-ritem[j]];
            while (j < itemno)
                printf(" %s", symbol_name[ritem[j++]]);
            printf(" .");
            while (ritem[j] >= 0)
                printf(" %s", symbol_name[ritem[j++]]);
            printf("\n");
            fflush(stdout);
        }
    }
}


/* show_ritems is used for debugging */

show_ritems()
{
    int i;

    for (i = 0; i < nitems; ++i)
        printf("ritem[%d] = %d\n", i, ritem[i]);
}


/* show_rrhs is used for debugging */
show_rrhs()
{
    int i;

    for (i = 0; i < nrules; ++i)
        printf("rrhs[%d] = %d\n", i, rrhs[i]);
}


/* show_shifts is used for debugging */

show_shifts()
{
    shifts *p;
    int i, j, k;

    k = 0;
    for (p = first_shift; p; ++k, p = p->next)
    {
        if (k) printf("\n");
        printf("shift %d, number = %d, nshifts = %d\n", k, p->number,
                p->nshifts);
        j = p->nshifts;
        for (i = 0; i < j; ++i)
            printf("\t%d\n", p->shift[i]);
    }
}


#if defined(KYLEP_CHANGE)
void
#endif
save_shifts()
{
    register shifts *p;
    register short *sp1;
    register short *sp2;
    register short *send;

    p = (shifts *) allocate((unsigned) (sizeof(shifts) +
                        (nshifts - 1) * sizeof(short)));

    p->number = this_state->number;
    #if defined(KYLEP_CHANGE)                                             
    p->nshifts = (short) nshifts;
    #else
    p->nshifts = nshifts;
    #endif // KYLEP_CHANGE

    sp1 = shiftset;
    sp2 = p->shift;
    send = shiftset + nshifts;

    while (sp1 < send)
        *sp2++ = *sp1++;

    if (last_shift)
    {
        last_shift->next = p;
        last_shift = p;
    }
    else
    {
        first_shift = p;
        last_shift = p;
    }
}



#if defined(KYLEP_CHANGE)
void
#endif
save_reductions()
{
    register short *isp;
    register short *rp1;
    register short *rp2;
    register int item;
    register int count;
    register reductions *p;
    register short *rend;

    count = 0;
    for (isp = itemset; isp < itemsetend; isp++)
    {
        item = ritem[*isp];
        if (item < 0)
        {
            redset[count++] = -item;
        }
    }

    if (count)
    {
        p = (reductions *) allocate((unsigned) (sizeof(reductions) +
                                        (count - 1) * sizeof(short)));

        p->number = this_state->number;
        #if defined(KYLEP_CHANGE)                                         
        p->nreds = (short) count;
        #else
        p->nreds = count;
        #endif // KYLEP_CHANGE

        rp1 = redset;
        rp2 = p->rules;
        rend = rp1 + count;

        while (rp1 < rend)
            *rp2++ = *rp1++;

        if (last_reduction)
        {
            last_reduction->next = p;
            last_reduction = p;
        }
        else
        {
            first_reduction = p;
            last_reduction = p;
        }
    }
}


set_derives()
{
    register int i, k;
    register int lhs;
    register short *rules;

    derives = NEW2(nsyms, short *);
    rules = NEW2(nvars + nrules, short);

    k = 0;
    for (lhs = start_symbol; lhs < nsyms; lhs++)
    {
        derives[lhs] = rules + k;
        for (i = 0; i < nrules; i++)
        {
            if (rlhs[i] == lhs)
            {
                #if defined(KYLEP_CHANGE)                                 
                rules[k] = (short) i;
                #else
                rules[k] = i;
                #endif // KYLEP_CHANGE
                k++;
            }
        }
        rules[k] = -1;
        k++;
    }

#ifdef  DEBUG
    print_derives();
#endif
}

free_derives()
{
    FREE(derives[start_symbol]);
    FREE(derives);
}

#ifdef  DEBUG
print_derives()
{
    register int i;
    register short *sp;

    printf("\nDERIVES\n\n");

    for (i = start_symbol; i < nsyms; i++)
    {
        printf("%s derives ", symbol_name[i]);
        for (sp = derives[i]; *sp >= 0; sp++)
        {
            printf("  %d", *sp);
        }
        putchar('\n');
    }

    putchar('\n');
}
#endif


set_nullable()
{
    register int i, j;
    register int empty;
    int done;

    nullable = MALLOC(nsyms);
    if (nullable == 0) no_space();

    for (i = 0; i < nsyms; ++i)
        nullable[i] = 0;

    done = 0;
    while (!done)
    {
        done = 1;
        for (i = 1; i < nitems; i++)
        {
            empty = 1;
            while ((j = ritem[i]) >= 0)
            {
                if (!nullable[j])
                    empty = 0;
                ++i;
            }
            if (empty)
            {
                j = rlhs[-j];
                if (!nullable[j])
                {
                    nullable[j] = 1;
                    done = 0;
                }
            }
        }
    }

#ifdef DEBUG
    for (i = 0; i < nsyms; i++)
    {
        if (nullable[i])
            printf("%s is nullable\n", symbol_name[i]);
        else
            printf("%s is not nullable\n", symbol_name[i]);
    }
#endif
}


free_nullable()
{
    FREE(nullable);
}


#if defined(KYLEP_CHANGE)
void
#endif
lr0()
{
    set_derives();
    set_nullable();
    generate_states();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\kbyacc\output.c ===
#include "defs.h"

#if defined(KYLEP_CHANGE)
/* BYACC prototypes, with type safety */

void free_itemsets();
void free_shifts();
void free_reductions();

void output_stored_text();
void output_prefix();
void output_rule_data();
void output_yydefred();
void output_base();
void output_table();
void output_defines();
void output_check();
void output_debug();
void output_stype();
void output_class();
void output_ctor();
void output_ctor_body();
void token_actions();
void goto_actions();
void sort_actions();
void output_actions();
void output_trailing_text();
void output_semantic_actions();

void pack_table();
int default_goto( int symbol );
void save_column( int symbol, int default_state );
int matching_vector( int vector );
int pack_vector( int vector );
#endif // KYLEP_CHANGE

static int nvectors;
static int nentries;
static short **froms;
static short **tos;
static short *tally;
static short *width;
static short *state_count;
static short *order;
static short *base;
static short *pos;
static int maxtable;
static short *table;
static short *check;
static int lowzero;
static int high;

#if defined (TRIPLISH)
extern int ParserChoice;
#endif

#if defined(KYLEP_CHANGE)
void
#endif
output()
{
    free_itemsets();
    free_shifts();
    free_reductions();
    output_prefix();
    output_stored_text();
    output_defines();
    output_rule_data();
    output_yydefred();
    output_actions();
    free_parser();
    output_debug();
    output_stype();
    if (rflag) write_section(tables, code_file);
#if defined(KYLEP_CHANGE)
    write_section(header1, defines_file);
    output_class();
    write_section(header2, defines_file);
    output_ctor();
    #if defined(TRIPLISH)
    if ( eTriplishParser == ParserChoice )
        write_section(header4, defines_file);
    else
        write_section(header3, defines_file);
    #else
    write_section(header3, defines_file);
    #endif // TRIPLISH
#else    
    write_section(header, defines_file);
#endif // KYLEP_CHANGE
    output_trailing_text();
#if defined(KYLEP_CHANGE)
    output_ctor_body();
#endif // KYLEP_CHANGE

#if defined(TRIPLISH)
    if ( eTriplishParser == ParserChoice )
        write_section(TriplishBody, code_file);
    else
        write_section(body, code_file);
#else
    write_section(body, code_file);
#endif // TRIPLISH
    
    output_semantic_actions();
#if defined(TRIPLISH)
    if ( eTriplishParser == ParserChoice )
        write_section(TriplishTrailer, code_file);
    else
        write_section(trailer, code_file);
#else
    write_section(trailer, code_file);
#endif // TRIPLISH
}


#if defined(KYLEP_CHANGE)
void
#endif
output_prefix()
{
    if (symbol_prefix == NULL)
        symbol_prefix = "yy";
    else
    {
        ++outline;
        fprintf(code_file, "#define yyparse %sparse\n", symbol_prefix);
        ++outline;
        fprintf(code_file, "#define yylex %slex\n", symbol_prefix);
        ++outline;
        fprintf(code_file, "#define yyerror %serror\n", symbol_prefix);
        ++outline;
        fprintf(code_file, "#define yychar %schar\n", symbol_prefix);
        ++outline;
        fprintf(code_file, "#define yyval %sval\n", symbol_prefix);
        ++outline;
        fprintf(code_file, "#define yylval %slval\n", symbol_prefix);
        ++outline;
        fprintf(code_file, "#define yydebug %sdebug\n", symbol_prefix);
        ++outline;
        fprintf(code_file, "#define yynerrs %snerrs\n", symbol_prefix);
        ++outline;
        fprintf(code_file, "#define yyerrflag %serrflag\n", symbol_prefix);
        ++outline;
        fprintf(code_file, "#define yyss %sss\n", symbol_prefix);
        ++outline;
        fprintf(code_file, "#define yyssp %sssp\n", symbol_prefix);
        ++outline;
        fprintf(code_file, "#define yyvs %svs\n", symbol_prefix);
        ++outline;
        fprintf(code_file, "#define yyvsp %svsp\n", symbol_prefix);
        ++outline;
        fprintf(code_file, "#define yylhs %slhs\n", symbol_prefix);
        ++outline;
        fprintf(code_file, "#define yylen %slen\n", symbol_prefix);
        ++outline;
        fprintf(code_file, "#define yydefred %sdefred\n", symbol_prefix);
        ++outline;
        fprintf(code_file, "#define yydgoto %sdgoto\n", symbol_prefix);
        ++outline;
        fprintf(code_file, "#define yysindex %ssindex\n", symbol_prefix);
        ++outline;
        fprintf(code_file, "#define yyrindex %srindex\n", symbol_prefix);
        ++outline;
        fprintf(code_file, "#define yygindex %sgindex\n", symbol_prefix);
        ++outline;
        fprintf(code_file, "#define yytable %stable\n", symbol_prefix);
        ++outline;
        fprintf(code_file, "#define yycheck %scheck\n", symbol_prefix);
        ++outline;
        fprintf(code_file, "#define yyname %sname\n", symbol_prefix);
        ++outline;
        fprintf(code_file, "#define yyrule %srule\n", symbol_prefix);
    }
    ++outline;
    fprintf(code_file, "#define YYPREFIX \"%s\"\n", symbol_prefix);
}


#if defined(KYLEP_CHANGE)
void
#endif
output_rule_data()
{
    register int i;
    register int j;


    fprintf(output_file, "short %slhs[] = {%42d,", symbol_prefix,
            symbol_value[start_symbol]);

    j = 10;
    for (i = 3; i < nrules; i++)
    {
        if (j >= 10)
        {
            if (!rflag) ++outline;
            putc('\n', output_file);
            j = 1;
        }
        else
            ++j;

        fprintf(output_file, "%5d,", symbol_value[rlhs[i]]);
    }
    if (!rflag) outline += 2;
    fprintf(output_file, "\n};\n");

    fprintf(output_file, "short %slen[] = {%42d,", symbol_prefix, 2);

    j = 10;
    for (i = 3; i < nrules; i++)
    {
        if (j >= 10)
        {
            if (!rflag) ++outline;
            putc('\n', output_file);
            j = 1;
        }
        else
          j++;

        fprintf(output_file, "%5d,", rrhs[i + 1] - rrhs[i] - 1);
    }
    if (!rflag) outline += 2;
    fprintf(output_file, "\n};\n");
}


#if defined(KYLEP_CHANGE)
void
#endif
output_yydefred()
{
    register int i, j;

    fprintf(output_file, "short %sdefred[] = {%39d,", symbol_prefix,
            (defred[0] ? defred[0] - 2 : 0));

    j = 10;
    for (i = 1; i < nstates; i++)
    {
        if (j < 10)
            ++j;
        else
        {
            if (!rflag) ++outline;
            putc('\n', output_file);
            j = 1;
        }

        fprintf(output_file, "%5d,", (defred[i] ? defred[i] - 2 : 0));
    }

    if (!rflag) outline += 2;
    fprintf(output_file, "\n};\n");
}


#if defined(KYLEP_CHANGE)
void
#endif
output_actions()
{
    nvectors = 2*nstates + nvars;

    froms = NEW2(nvectors, short *);
    tos = NEW2(nvectors, short *);
    tally = NEW2(nvectors, short);
    width = NEW2(nvectors, short);

    token_actions();
    FREE(lookaheads);
    FREE(LA);
    FREE(LAruleno);
    FREE(accessing_symbol);

    goto_actions();
    FREE(goto_map + ntokens);
    FREE(from_state);
    FREE(to_state);

    sort_actions();
    pack_table();
    output_base();
    output_table();
    output_check();
}


#if defined(KYLEP_CHANGE)
void
#endif
token_actions()
{
    register int i, j;
    register int shiftcount, reducecount;
    register int max, min;
    register short *actionrow, *r, *s;
    register action *p;

    actionrow = NEW2(2*ntokens, short);
    for (i = 0; i < nstates; ++i)
    {
        if (parser[i])
        {
            for (j = 0; j < 2*ntokens; ++j)
            actionrow[j] = 0;

            shiftcount = 0;
            reducecount = 0;
            for (p = parser[i]; p; p = p->next)
            {
                if (p->suppressed == 0)
                {
                    if (p->action_code == SHIFT)
                    {
                        ++shiftcount;
                        actionrow[p->symbol] = p->number;
                    }
                    else if (p->action_code == REDUCE && p->number != defred[i])
                    {
                        ++reducecount;
                        actionrow[p->symbol + ntokens] = p->number;
                    }
                }
            }

            #if defined(KYLEP_CHANGE)                                     
            tally[i] = (short) shiftcount;
            tally[nstates+i] = (short) reducecount;
            #else
            tally[i] = shiftcount;
            tally[nstates+i] = reducecount;
            #endif // KYLEP_CHANGE
            width[i] = 0;
            width[nstates+i] = 0;
            if (shiftcount > 0)
            {
                froms[i] = r = NEW2(shiftcount, short);
                tos[i] = s = NEW2(shiftcount, short);
                min = MAXSHORT;
                max = 0;
                for (j = 0; j < ntokens; ++j)
                {
                    if (actionrow[j])
                    {
                        if (min > symbol_value[j])
                            min = symbol_value[j];
                        if (max < symbol_value[j])
                            max = symbol_value[j];
                        *r++ = symbol_value[j];
                        *s++ = actionrow[j];
                    }
                }
                width[i] = max - min + 1;
            }
            if (reducecount > 0)
            {
                froms[nstates+i] = r = NEW2(reducecount, short);
                tos[nstates+i] = s = NEW2(reducecount, short);
                min = MAXSHORT;
                max = 0;
                for (j = 0; j < ntokens; ++j)
                {
                    if (actionrow[ntokens+j])
                    {
                        if (min > symbol_value[j])
                            min = symbol_value[j];
                        if (max < symbol_value[j])
                            max = symbol_value[j];
                        *r++ = symbol_value[j];
                        *s++ = actionrow[ntokens+j] - 2;
                    }
                }
                width[nstates+i] = max - min + 1;
            }
        }
    }
    FREE(actionrow);
}

#if defined(KYLEP_CHANGE)
void
#endif
goto_actions()
{
    register int i, j, k;

    state_count = NEW2(nstates, short);

    k = default_goto(start_symbol + 1);
    fprintf(output_file, "short %sdgoto[] = {%40d,", symbol_prefix, k);
    save_column(start_symbol + 1, k);

    j = 10;
    for (i = start_symbol + 2; i < nsyms; i++)
    {
        if (j >= 10)
        {
            if (!rflag) ++outline;
            putc('\n', output_file);
            j = 1;
        }
        else
            ++j;

        k = default_goto(i);
        fprintf(output_file, "%5d,", k);
        save_column(i, k);
    }

    if (!rflag) outline += 2;
    fprintf(output_file, "\n};\n");
    FREE(state_count);
}

int
default_goto(symbol)
int symbol;
{
    register int i;
    register int m;
    register int n;
    register int default_state;
    register int max;

    m = goto_map[symbol];
    n = goto_map[symbol + 1];

    if (m == n) return (0);

    for (i = 0; i < nstates; i++)
        state_count[i] = 0;

    for (i = m; i < n; i++)
        state_count[to_state[i]]++;

    max = 0;
    default_state = 0;
    for (i = 0; i < nstates; i++)
    {
        if (state_count[i] > max)
        {
            max = state_count[i];
            default_state = i;
        }
    }

    return (default_state);
}


#if defined(KYLEP_CHANGE)
void
#endif
save_column(symbol, default_state)
int symbol;
int default_state;
{
    register int i;
    register int m;
    register int n;
    register short *sp;
    register short *sp1;
    register short *sp2;
    register int count;
    register int symno;

    m = goto_map[symbol];
    n = goto_map[symbol + 1];

    count = 0;
    for (i = m; i < n; i++)
    {
        if (to_state[i] != default_state)
            ++count;
    }
    if (count == 0) return;

    symno = symbol_value[symbol] + 2*nstates;

    froms[symno] = sp1 = sp = NEW2(count, short);
    tos[symno] = sp2 = NEW2(count, short);

    for (i = m; i < n; i++)
    {
        if (to_state[i] != default_state)
        {
            *sp1++ = from_state[i];
            *sp2++ = to_state[i];
        }
    }

    #if defined(KYLEP_CHANGE)                                             
    tally[symno] = (short) count;
    #else
    tally[symno] = count;
    #endif // KYLEP_CHANGE
    width[symno] = sp1[-1] - sp[0] + 1;
}

#if defined(KYLEP_CHANGE)
void
#endif
sort_actions()
{
  register int i;
  register int j;
  register int k;
  register int t;
  register int w;

  order = NEW2(nvectors, short);
  nentries = 0;

  for (i = 0; i < nvectors; i++)
    {
      if (tally[i] > 0)
        {
          t = tally[i];
          w = width[i];
          j = nentries - 1;

          while (j >= 0 && (width[order[j]] < w))
            j--;

          while (j >= 0 && (width[order[j]] == w) && (tally[order[j]] < t))
            j--;

          for (k = nentries - 1; k > j; k--)
            order[k + 1] = order[k];

          #if defined(KYLEP_CHANGE)                                       
          order[j + 1] = (short) i;
          #else
          order[j + 1] = i;
          #endif // KYLEP_CHANGE
          nentries++;
        }
    }
}


#if defined(KYLEP_CHANGE)
void
#endif
pack_table()
{
    register int i;
    register int place;
    register int state;

    base = NEW2(nvectors, short);
    pos = NEW2(nentries, short);

    maxtable = 1000;
    table = NEW2(maxtable, short);
    check = NEW2(maxtable, short);

    lowzero = 0;
    high = 0;

    for (i = 0; i < maxtable; i++)
        check[i] = -1;

    for (i = 0; i < nentries; i++)
    {
        state = matching_vector(i);

        if (state < 0)
            place = pack_vector(i);
        else
            place = base[state];

        #if defined(KYLEP_CHANGE)                                         
        pos[i] = (short) place;
        base[order[i]] = (short) place;
        #else
        pos[i] = place;
        base[order[i]] = place;
        #endif // KYLEP_CHANGE
    }

    for (i = 0; i < nvectors; i++)
    {
        if (froms[i])
            FREE(froms[i]);
        if (tos[i])
            FREE(tos[i]);
    }

    FREE(froms);
    FREE(tos);
    FREE(pos);
}


/*  The function matching_vector determines if the vector specified by  */
/*  the input parameter matches a previously considered vector.  The    */
/*  test at the start of the function checks if the vector represents   */
/*  a row of shifts over terminal symbols or a row of reductions, or a  */
/*  column of shifts over a nonterminal symbol.  Berkeley Yacc does not */
/*  check if a column of shifts over a nonterminal symbols matches a    */
/*  previously considered vector.  Because of the nature of LR parsing  */
/*  tables, no two columns can match.  Therefore, the only possible     */
/*  match would be between a row and a column.  Such matches are        */
/*  unlikely.  Therefore, to save time, no attempt is made to see if a  */
/*  column matches a previously considered vector.                      */
/*                                                                      */
/*  Matching_vector is poorly designed.  The test could easily be made  */
/*  faster.  Also, it depends on the vectors being in a specific        */
/*  order.                                                              */

int
matching_vector(vector)
int vector;
{
    register int i;
    register int j;
    register int k;
    register int t;
    register int w;
    register int match;
    register int prev;

    i = order[vector];
    if (i >= 2*nstates)
        return (-1);

    t = tally[i];
    w = width[i];

    for (prev = vector - 1; prev >= 0; prev--)
    {
        j = order[prev];
        if (width[j] != w || tally[j] != t)
            return (-1);

        match = 1;
        for (k = 0; match && k < t; k++)
        {
            if (tos[j][k] != tos[i][k] || froms[j][k] != froms[i][k])
                match = 0;
        }

        if (match)
            return (j);
    }

    return (-1);
}



int
pack_vector(vector)
int vector;
{
    register int i, j, k, l;
    register int t;
    register int loc;
    register int ok;
    register short *from;
    register short *to;
    int newmax;

    i = order[vector];
    t = tally[i];
    assert(t);

    from = froms[i];
    to = tos[i];

    j = lowzero - from[0];
    for (k = 1; k < t; ++k)
        if (lowzero - from[k] > j)
            j = lowzero - from[k];
    for (;; ++j)
    {
        if (j == 0)
            continue;
        ok = 1;
        for (k = 0; ok && k < t; k++)
        {
            loc = j + from[k];
            if (loc >= maxtable)
            {
                if (loc >= MAXTABLE)
                    fatal("maximum table size exceeded");

                newmax = maxtable;
                do { newmax += 200; } while (newmax <= loc);
                table = (short *) REALLOC(table, newmax*sizeof(short));
                if (table == 0) no_space();
                check = (short *) REALLOC(check, newmax*sizeof(short));
                if (check == 0) no_space();
                for (l  = maxtable; l < newmax; ++l)
                {
                    table[l] = 0;
                    check[l] = -1;
                }
                maxtable = newmax;
            }

            if (check[loc] != -1)
                ok = 0;
        }
        for (k = 0; ok && k < vector; k++)
        {
            if (pos[k] == j)
                ok = 0;
        }
        if (ok)
        {
            for (k = 0; k < t; k++)
            {
                loc = j + from[k];
                table[loc] = to[k];
                check[loc] = from[k];
                if (loc > high) high = loc;
            }

#if defined(KYLEP_CHANGE)
            while ( lowzero < maxtable && check[lowzero] != -1 )
                ++lowzero;
#else
            while (check[lowzero] != -1)
                ++lowzero;
#endif
            return (j);
        }
    }
}



#if defined(KYLEP_CHANGE)
void
#endif
output_base()
{
    register int i, j;

    fprintf(output_file, "short %ssindex[] = {%39d,", symbol_prefix, base[0]);

    j = 10;
    for (i = 1; i < nstates; i++)
    {
        if (j >= 10)
        {
            if (!rflag) ++outline;
            putc('\n', output_file);
            j = 1;
        }
        else
            ++j;

        fprintf(output_file, "%5d,", base[i]);
    }

    if (!rflag) outline += 2;
    fprintf(output_file, "\n};\nshort %srindex[] = {%39d,", symbol_prefix,
            base[nstates]);

    j = 10;
    for (i = nstates + 1; i < 2*nstates; i++)
    {
        if (j >= 10)
        {
            if (!rflag) ++outline;
            putc('\n', output_file);
            j = 1;
        }
        else
            ++j;

        fprintf(output_file, "%5d,", base[i]);
    }

    if (!rflag) outline += 2;
    fprintf(output_file, "\n};\nshort %sgindex[] = {%39d,", symbol_prefix,
            base[2*nstates]);

    j = 10;
    for (i = 2*nstates + 1; i < nvectors - 1; i++)
    {
        if (j >= 10)
        {
            if (!rflag) ++outline;
            putc('\n', output_file);
            j = 1;
        }
        else
            ++j;

        fprintf(output_file, "%5d,", base[i]);
    }

    if (!rflag) outline += 2;
    fprintf(output_file, "\n};\n");
    FREE(base);
}



#if defined(KYLEP_CHANGE)
void
#endif
output_table()
{
    register int i;
    register int j;

    ++outline;
    fprintf(code_file, "#define YYTABLESIZE %d\n", high);
    fprintf(output_file, "short %stable[] = {%40d,", symbol_prefix,
            table[0]);

    j = 10;
    for (i = 1; i <= high; i++)
    {
        if (j >= 10)
        {
            if (!rflag) ++outline;
            putc('\n', output_file);
            j = 1;
        }
        else
            ++j;

        fprintf(output_file, "%5d,", table[i]);
    }

    if (!rflag) outline += 2;
    fprintf(output_file, "\n};\n");
    FREE(table);
}



#if defined(KYLEP_CHANGE)
void
#endif
output_check()
{
    register int i;
    register int j;

    fprintf(output_file, "short %scheck[] = {%40d,", symbol_prefix,
            check[0]);

    j = 10;
    for (i = 1; i <= high; i++)
    {
        if (j >= 10)
        {
            if (!rflag) ++outline;
            putc('\n', output_file);
            j = 1;
        }
        else
            ++j;

        fprintf(output_file, "%5d,", check[i]);
    }

    if (!rflag) outline += 2;
    fprintf(output_file, "\n};\n");
    FREE(check);
}


int
is_C_identifier(name)
char *name;
{
    register char *s;
    register int c;

    s = name;
    c = *s;
    if (c == '"')
    {
        c = *++s;
        if (!isalpha(c) && c != '_' && c != '$')
            return (0);
        while ((c = *++s) != '"')
        {
            if (!isalnum(c) && c != '_' && c != '$')
                return (0);
        }
        return (1);
    }

    if (!isalpha(c) && c != '_' && c != '$')
        return (0);
    while (c = *++s)
    {
        if (!isalnum(c) && c != '_' && c != '$')
            return (0);
    }
    return (1);
}


#if defined(KYLEP_CHANGE)
void
#endif
output_defines()
{
    register int c, i;
    register char *s;

    for (i = 2; i < ntokens; ++i)
    {
        s = symbol_name[i];
        if (is_C_identifier(s))
        {
            fprintf(code_file, "#define ");
            if (dflag) fprintf(defines_file, "#define ");
            c = *s;
            if (c == '"')
            {
                while ((c = *++s) != '"')
                {
                    putc(c, code_file);
                    if (dflag) putc(c, defines_file);
                }
            }
            else
            {
                do
                {
                    putc(c, code_file);
                    if (dflag) putc(c, defines_file);
                }
                while (c = *++s);
            }
            ++outline;
            fprintf(code_file, " %d\n", symbol_value[i]);
            if (dflag) fprintf(defines_file, " %d\n", symbol_value[i]);
        }
    }

    ++outline;
    fprintf(code_file, "#define YYERRCODE %d\n", symbol_value[1]);

    if (dflag && unionized)
    {
        fclose(union_file);
        union_file = fopen(union_file_name, "r");
        if (union_file == NULL) open_error(union_file_name);
        while ((c = getc(union_file)) != EOF)
            putc(c, defines_file);
        fprintf(defines_file, " YYSTYPE;\nextern YYSTYPE %slval;\n",
                symbol_prefix);
    }
}

#if defined(KYLEP_CHANGE)
void
#endif
output_stored_text()
{
    register int c;
    register FILE *in, *out;

    fclose(text_file);
    text_file = fopen(text_file_name, "r");
    if (text_file == NULL)
        open_error(text_file_name);
    in = text_file;
    if ((c = getc(in)) == EOF)
        return;
    out = code_file;
    if (c ==  '\n')
        ++outline;
    putc(c, out);
    while ((c = getc(in)) != EOF)
    {
        if (c == '\n')
            ++outline;
        putc(c, out);
    }
    if (!lflag)
        fprintf(out, line_format, ++outline + 1, code_file_name);
}


#if defined(KYLEP_CHANGE)
void
#endif
output_debug()
{
    register int i, j, k, max;
    char **symnam, *s;

    ++outline;
    fprintf(code_file, "#define YYFINAL %d\n", final_state);
    outline += 3;
    fprintf(code_file, "#ifndef YYDEBUG\n#define YYDEBUG %d\n#endif\n",
            tflag);
    if (rflag)
        fprintf(output_file, "#ifndef YYDEBUG\n#define YYDEBUG %d\n#endif\n",
                tflag);

    max = 0;
    for (i = 2; i < ntokens; ++i)
        if (symbol_value[i] > max)
            max = symbol_value[i];
    ++outline;
    fprintf(code_file, "#define YYMAXTOKEN %d\n", max);

    symnam = (char **) MALLOC((max+1)*sizeof(char *));
    if (symnam == 0) no_space();

    /* Note that it is  not necessary to initialize the element         */
    /* symnam[max].                                                     */
    for (i = 0; i < max; ++i)
        symnam[i] = 0;
    for (i = ntokens - 1; i >= 2; --i)
        symnam[symbol_value[i]] = symbol_name[i];
    symnam[0] = "end-of-file";

    if (!rflag) ++outline;
    
    #if defined(KYLEP_CHANGE)
    fprintf(output_file, "#if YYDEBUG != 0 || defined (YYERROR_VERBOSE)\nchar *%sname[] = {", symbol_prefix);
    #else
    fprintf(output_file, "#if YYDEBUG\nchar *%sname[] = {", symbol_prefix);
    #endif
    j = 80;
    for (i = 0; i <= max; ++i)
    {
        if (s = symnam[i])
        {
            if (s[0] == '"')
            {
                k = 7;
                while (*++s != '"')
                {
                    ++k;
                    if (*s == '\\')
                    {
                        k += 2;
                        if (*++s == '\\')
                            ++k;
                    }
                }
                j += k;
                if (j > 80)
                {
                    if (!rflag) ++outline;
                    putc('\n', output_file);
                    j = k;
                }
                fprintf(output_file, "\"\\\"");
                s = symnam[i];
                while (*++s != '"')
                {
                    if (*s == '\\')
                    {
                        fprintf(output_file, "\\\\");
                        if (*++s == '\\')
                            fprintf(output_file, "\\\\");
                        else
                            putc(*s, output_file);
                    }
                    else
                        putc(*s, output_file);
                }
                fprintf(output_file, "\\\"\",");
            }
            else if (s[0] == '\'')
            {
                if (s[1] == '"')
                {
                    j += 7;
                    if (j > 80)
                    {
                        if (!rflag) ++outline;
                        putc('\n', output_file);
                        j = 7;
                    }
                    fprintf(output_file, "\"'\\\"'\",");
                }
                else
                {
                    k = 5;
                    while (*++s != '\'')
                    {
                        ++k;
                        if (*s == '\\')
                        {
                            k += 2;
                            if (*++s == '\\')
                                ++k;
                        }
                    }
                    j += k;
                    if (j > 80)
                    {
                        if (!rflag) ++outline;
                        putc('\n', output_file);
                        j = k;
                    }
                    fprintf(output_file, "\"'");
                    s = symnam[i];
                    while (*++s != '\'')
                    {
                        if (*s == '\\')
                        {
                            fprintf(output_file, "\\\\");
                            if (*++s == '\\')
                                fprintf(output_file, "\\\\");
                            else
                                putc(*s, output_file);
                        }
                        else
                            putc(*s, output_file);
                    }
                    fprintf(output_file, "'\",");
                }
            }
            else
            {
                k = strlen(s) + 3;
                j += k;
                if (j > 80)
                {
                    if (!rflag) ++outline;
                    putc('\n', output_file);
                    j = k;
                }
                putc('"', output_file);
                do { putc(*s, output_file); } while (*++s);
                fprintf(output_file, "\",");
            }
        }
        else
        {
            j += 2;
            if (j > 80)
            {
                if (!rflag) ++outline;
                putc('\n', output_file);
                j = 2;
            }
            fprintf(output_file, "0,");
        }
    }
    if (!rflag) outline += 2;
    fprintf(output_file, "\n};\n");
    FREE(symnam);

    if (!rflag) ++outline;
    fprintf(output_file, "char *%srule[] = {\n", symbol_prefix);
    for (i = 2; i < nrules; ++i)
    {
        fprintf(output_file, "\"%s :", symbol_name[rlhs[i]]);
        for (j = rrhs[i]; ritem[j] > 0; ++j)
        {
            s = symbol_name[ritem[j]];
            if (s[0] == '"')
            {
                fprintf(output_file, " \\\"");
                while (*++s != '"')
                {
                    if (*s == '\\')
                    {
                        if (s[1] == '\\')
                            fprintf(output_file, "\\\\\\\\");
                        else
                            fprintf(output_file, "\\\\%c", s[1]);
                        ++s;
                    }
                    else
                        putc(*s, output_file);
                }
                fprintf(output_file, "\\\"");
            }
            else if (s[0] == '\'')
            {
                if (s[1] == '"')
                    fprintf(output_file, " '\\\"'");
                else if (s[1] == '\\')
                {
                    if (s[2] == '\\')
                        fprintf(output_file, " '\\\\\\\\");
                    else
                        fprintf(output_file, " '\\\\%c", s[2]);
                    s += 2;
                    while (*++s != '\'')
                        putc(*s, output_file);
                    putc('\'', output_file);
                }
                else
                    fprintf(output_file, " '%c'", s[1]);
            }
            else
                fprintf(output_file, " %s", s);
        }
        if (!rflag) ++outline;
        fprintf(output_file, "\",\n");
    }

    if (!rflag) outline += 2;
    fprintf(output_file, "};\n#endif\n");
}


#if defined(KYLEP_CHANGE)
void
#endif
output_stype()
{
    if (!unionized && ntags == 0)
    {
        outline += 3;
        fprintf(code_file, "#ifndef YYSTYPE\ntypedef int YYSTYPE;\n#endif\n");
    }
}


#if defined(KYLEP_CHANGE)
void
#endif
output_trailing_text()
{
    register int c, last;
    register FILE *in, *out;

    if (line == 0)
        return;

    in = input_file;
    out = code_file;
    c = *cptr;
    if (c == '\n')
    {
        ++lineno;
        if ((c = getc(in)) == EOF)
            return;
        if (!lflag)
        {
            ++outline;
            fprintf(out, line_format, lineno, input_file_name);
        }
        if (c == '\n')
            ++outline;
        putc(c, out);
        last = c;
    }
    else
    {
        if (!lflag)
        {
            ++outline;
            fprintf(out, line_format, lineno, input_file_name);
        }
        do { putc(c, out); } while ((c = *++cptr) != '\n');
        ++outline;
        putc('\n', out);
        last = '\n';
    }

    while ((c = getc(in)) != EOF)
    {
        if (c == '\n')
            ++outline;
        putc(c, out);
        last = c;
    }

    if (last != '\n')
    {
        ++outline;
        putc('\n', out);
    }
    if (!lflag)
        fprintf(out, line_format, ++outline + 1, code_file_name);
}


#if defined(KYLEP_CHANGE)
void
#endif
output_semantic_actions()
{
    register int c, last;
    register FILE *out;

    fclose(action_file);
    action_file = fopen(action_file_name, "r");
    if (action_file == NULL)
        open_error(action_file_name);

    if ((c = getc(action_file)) == EOF)
        return;

    out = code_file;
    last = c;
    if (c == '\n')
        ++outline;
    putc(c, out);
    while ((c = getc(action_file)) != EOF)
    {
        if (c == '\n')
            ++outline;
        putc(c, out);
        last = c;
    }

    if (last != '\n')
    {
        ++outline;
        putc('\n', out);
    }

    if (!lflag)
        fprintf(out, line_format, ++outline + 1, code_file_name);
}


#if defined(KYLEP_CHANGE)
void
#endif
free_itemsets()
{
    register core *cp, *next;

    FREE(state_table);
    for (cp = first_state; cp; cp = next)
    {
        next = cp->next;
        FREE(cp);
    }
}


#if defined(KYLEP_CHANGE)
void
#endif
free_shifts()
{
    register shifts *sp, *next;

    FREE(shift_table);
    for (sp = first_shift; sp; sp = next)
    {
        next = sp->next;
        FREE(sp);
    }
}



#if defined(KYLEP_CHANGE)
void
#endif
free_reductions()
{
    register reductions *rp, *next;

    FREE(reduction_table);
    for (rp = first_reduction; rp; rp = next)
    {
        next = rp->next;
        FREE(rp);
    }
}

#if defined(KYLEP_CHANGE)
void output_class()
{
    if ( 0 == baseclass )
        fprintf(defines_file, "class YYPARSER\n");
    else
        fprintf(defines_file, "class YYPARSER : public %s\n", baseclass);
}

void output_ctor()
{
    if ( 0 != ctorargs )
        fprintf(defines_file, "    YYPARSER%s;\n", ctorargs);
}

void output_ctor_body()
{
    char * p = ctorargs+1;
    char * pAlpha = 0;
    int cArgs = 0;

    if ( 0 != ctorargs && 0 != baseclass)
    {
        fprintf(code_file, "YYPARSER::YYPARSER%s\n", ctorargs);
        fprintf(code_file, "        : %s( ", baseclass);

        /* Look through the arguments for the variables and pass them to base class as args. */

        while ( 0 != *p )
        {
            if ( isalpha(*p) || '_' == *p || '$' == *p )
            {
                if ( 0 == pAlpha )
                    pAlpha = p;  /* Start of variable? */
            }
            else if ( ',' == *p || ')' == *p )
            {
                if ( 0 != pAlpha )
                {
                    if ( 0 != cArgs )
                        fprintf( code_file, ", " );

                    *p = 0;
                    fprintf( code_file, "%s", pAlpha );
                    pAlpha = 0;
                    cArgs++;
                }
            }
            else if ( ' ' != *p && !isalnum(*p) )
            {
                pAlpha = 0;
            }

            p++;
        }

        fprintf(code_file, " ) {\n");
        fprintf(code_file, "    xyyvs.SetSize(INITSTACKSIZE);\n" );
#ifdef TRIPLISH
        fprintf(code_file, "    yydebug = 0;\n");
#endif
        fprintf(code_file, "}\n");
    }
}
#endif // KYLEP_CHANGE
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\kbyacc\mkpar.c ===
#include "defs.h"

#if defined(KYLEP_CHANGE)
/* BYACC prototypes, with type safety */

void find_final_state();
void remove_conflicts();
void unused_rules();
void total_conflicts();
void defreds();
#endif // KYLEP_CHANGE

action **parser;
int SRtotal;
int RRtotal;
short *SRconflicts;
short *RRconflicts;
short *defred;
short *rules_used;
short nunused;
short final_state;

static int SRcount;
static int RRcount;

extern action *parse_actions();
extern action *get_shifts();
extern action *add_reductions();
extern action *add_reduce();


#if defined(KYLEP_CHANGE)
void
#endif
make_parser()
{
    register int i;

    parser = NEW2(nstates, action *);
    for (i = 0; i < nstates; i++)
        parser[i] = parse_actions(i);

    find_final_state();
    remove_conflicts();
    unused_rules();
    if (SRtotal + RRtotal > 0) total_conflicts();
    defreds();
}


action *
parse_actions(stateno)
register int stateno;
{
    register action *actions;

    actions = get_shifts(stateno);
    actions = add_reductions(stateno, actions);
    return (actions);
}


action *
get_shifts(stateno)
int stateno;
{
    register action *actions, *temp;
    register shifts *sp;
    register short *to_state;
    register int i, k;
    register int symbol;

    actions = 0;
    sp = shift_table[stateno];
    if (sp)
    {
        to_state = sp->shift;
        for (i = sp->nshifts - 1; i >= 0; i--)
        {
            k = to_state[i];
            symbol = accessing_symbol[k];
            if (ISTOKEN(symbol))
            {
                temp = NEW(action);
                temp->next = actions;
                #if defined(KYLEP_CHANGE)                                 
                temp->symbol = (short) symbol;
                temp->number = (short) k;
                #else
                temp->symbol = symbol;
                temp->number = k;
                #endif // KYLEP_CHANGE
                
                temp->prec = symbol_prec[symbol];
                temp->action_code = SHIFT;
                temp->assoc = symbol_assoc[symbol];
                actions = temp;
            }
        }
    }
    return (actions);
}

action *
add_reductions(stateno, actions)
int stateno;
register action *actions;
{
    register int i, j, m, n;
    register int ruleno, tokensetsize;
    register unsigned *rowp;

    tokensetsize = WORDSIZE(ntokens);
    m = lookaheads[stateno];
    n = lookaheads[stateno + 1];
    for (i = m; i < n; i++)
    {
        ruleno = LAruleno[i];
        rowp = LA + i * tokensetsize;
        for (j = ntokens - 1; j >= 0; j--)
        {
            if (BIT(rowp, j))
                actions = add_reduce(actions, ruleno, j);
        }
    }
    return (actions);
}


action *
add_reduce(actions, ruleno, symbol)
register action *actions;
register int ruleno, symbol;
{
    register action *temp, *prev, *next;

    prev = 0;
    for (next = actions; next && next->symbol < symbol; next = next->next)
        prev = next;

    while (next && next->symbol == symbol && next->action_code == SHIFT)
    {
        prev = next;
        next = next->next;
    }

    while (next && next->symbol == symbol &&
            next->action_code == REDUCE && next->number < ruleno)
    {
        prev = next;
        next = next->next;
    }

    temp = NEW(action);
    temp->next = next;
    #if defined(KYLEP_CHANGE)                                             
    temp->symbol = (short) symbol;
    temp->number = (short) ruleno;
    #else
    temp->symbol = symbol;
    temp->number = ruleno;
    #endif // KYLEP_CHANGE
    temp->prec = rprec[ruleno];
    temp->action_code = REDUCE;
    temp->assoc = rassoc[ruleno];

    if (prev)
        prev->next = temp;
    else
        actions = temp;

    return (actions);
}


#if defined(KYLEP_CHANGE)
void
#endif
find_final_state()
{
    register int goal, i;
    register short *to_state;
    register shifts *p;

    p = shift_table[0];
    to_state = p->shift;
    goal = ritem[1];
    for (i = p->nshifts - 1; i >= 0; --i)
    {
        final_state = to_state[i];
        if (accessing_symbol[final_state] == goal) break;
    }
}


#if defined(KYLEP_CHANGE)
void
#endif
unused_rules()
{
    register int i;
    register action *p;

    rules_used = (short *) MALLOC(nrules*sizeof(short));
    if (rules_used == 0) no_space();

    for (i = 0; i < nrules; ++i)
        rules_used[i] = 0;

    for (i = 0; i < nstates; ++i)
    {
        for (p = parser[i]; p; p = p->next)
        {
            if (p->action_code == REDUCE && p->suppressed == 0)
                rules_used[p->number] = 1;
        }
    }

    nunused = 0;
    for (i = 3; i < nrules; ++i)
        if (!rules_used[i]) ++nunused;

    if (nunused)
        if (nunused == 1)
            fprintf(stderr, "%s: 1 rule never reduced\n", myname);
        else
            fprintf(stderr, "%s: %d rules never reduced\n", myname, nunused);
}


#if defined(KYLEP_CHANGE)
void
#endif
remove_conflicts()
{
    register int i;
    register int symbol;
    register action *p, *pref;

    SRtotal = 0;
    RRtotal = 0;
    SRconflicts = NEW2(nstates, short);
    RRconflicts = NEW2(nstates, short);
    for (i = 0; i < nstates; i++)
    {
        SRcount = 0;
        RRcount = 0;
        symbol = -1;
        for (p = parser[i]; p; p = p->next)
        {
            if (p->symbol != symbol)
            {
                pref = p;
                symbol = p->symbol;
            }
            else if (i == final_state && symbol == 0)
            {
                SRcount++;
                p->suppressed = 1;
            }
            else if (pref->action_code == SHIFT)
            {
                if (pref->prec > 0 && p->prec > 0)
                {
                    if (pref->prec < p->prec)
                    {
                        pref->suppressed = 2;
                        pref = p;
                    }
                    else if (pref->prec > p->prec)
                    {
                        p->suppressed = 2;
                    }
                    else if (pref->assoc == LEFT)
                    {
                        pref->suppressed = 2;
                        pref = p;
                    }
                    else if (pref->assoc == RIGHT)
                    {
                        p->suppressed = 2;
                    }
                    else
                    {
                        pref->suppressed = 2;
                        p->suppressed = 2;
                    }
                }
                else
                {
                    SRcount++;
                    p->suppressed = 1;
                }
            }
            else
            {
                RRcount++;
                p->suppressed = 1;
            }
        }
        SRtotal += SRcount;
        RRtotal += RRcount;
        #if defined(KYLEP_CHANGE)                                         
        SRconflicts[i] = (short) SRcount;
        RRconflicts[i] = (short) RRcount;
        #else
        SRconflicts[i] = SRcount;
        RRconflicts[i] = RRcount;
        #endif // KYLEP_CHANGE
    }
}


#if defined(KYLEP_CHANGE)
void
#endif
total_conflicts()
{
    fprintf(stderr, "%s: ", myname);
    if (SRtotal == 1)
        fprintf(stderr, "1 shift/reduce conflict");
    else if (SRtotal > 1)
        fprintf(stderr, "%d shift/reduce conflicts", SRtotal);

    if (SRtotal && RRtotal)
        fprintf(stderr, ", ");

    if (RRtotal == 1)
        fprintf(stderr, "1 reduce/reduce conflict");
    else if (RRtotal > 1)
        fprintf(stderr, "%d reduce/reduce conflicts", RRtotal);

    fprintf(stderr, ".\n");
}


int
sole_reduction(stateno)
int stateno;
{
    register int count, ruleno;
    register action *p;

    count = 0;
    ruleno = 0;
    for (p = parser[stateno]; p; p = p->next)
    {
        if (p->action_code == SHIFT && p->suppressed == 0)
            return (0);
        else if (p->action_code == REDUCE && p->suppressed == 0)
        {
            if (ruleno > 0 && p->number != ruleno)
                return (0);
            if (p->symbol != 1)
                ++count;
            ruleno = p->number;
        }
    }

    if (count == 0)
        return (0);
    return (ruleno);
}


#if defined(KYLEP_CHANGE)
void
#endif
defreds()
{
    register int i;

    defred = NEW2(nstates, short);
    for (i = 0; i < nstates; i++)
        #if defined(KYLEP_CHANGE)                                         
        defred[i] = (short) sole_reduction(i);
        #else
        defred[i] = sole_reduction(i);
        #endif // KYLEP_CHANGE
}

free_action_row(p)
register action *p;
{
  register action *q;

  while (p)
    {
      q = p->next;
      FREE(p);
      p = q;
    }
}

#if defined(KYLEP_CHANGE)
void
#endif
free_parser()
{
  register int i;

  for (i = 0; i < nstates; i++)
    free_action_row(parser[i]);

  FREE(parser);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\kbyacc\main.c ===
#include <signal.h>
#include "defs.h"

char dflag;
char lflag;
char rflag;
char tflag;
char vflag;

char *symbol_prefix;
char *file_prefix = "y";
char *myname = "yacc";
char *temp_form = "yacc.XXXXXXX";
#ifdef TRIPLISH
char *parser_name = "sql";
int ParserChoice = eSQLParser;
#endif

#if defined(KYLEP_CHANGE)
char *baseclass = 0;
char *ctorargs = 0;
#endif // KYLEP_CHANGE

int lineno;
int outline;

char *action_file_name;
char *code_file_name;
char *defines_file_name;
char *input_file_name = "";
char *output_file_name;
char *text_file_name;
char *union_file_name;
char *verbose_file_name;

FILE *action_file;      /*  a temp file, used to save actions associated    */
                        /*  with rules until the parser is written          */
FILE *code_file;        /*  y.code.c (used when the -r option is specified) */
FILE *defines_file;     /*  y.tab.h                                         */
FILE *input_file;       /*  the input file                                  */
FILE *output_file;      /*  y.tab.c                                         */
FILE *text_file;        /*  a temp file, used to save text until all        */
                        /*  symbols have been defined                       */
FILE *union_file;       /*  a temp file, used to save the union             */
                        /*  definition until all symbol have been           */
                        /*  defined                                         */
FILE *verbose_file;     /*  y.output                                        */

int nitems;
int nrules;
int nsyms;
int ntokens;
int nvars;

int   start_symbol;
char  **symbol_name;
short *symbol_value;
short *symbol_prec;
char  *symbol_assoc;

short *ritem;
short *rlhs;
short *rrhs;
short *rprec;
char  *rassoc;
short **derives;
char *nullable;

#if !defined(KYLEP_CHANGE)
extern char *mktemp();
extern char *getenv();
#endif


done(k)
int k;
{
    if (action_file) { fclose(action_file); unlink(action_file_name); }
    if (text_file) { fclose(text_file); unlink(text_file_name); }
    if (union_file) { fclose(union_file); unlink(union_file_name); }
    exit(k);
}

#if defined(KYLEP_CHANGE)
// without this declaration compilation fails
void __cdecl onintr(int);
#endif


#if defined(KYLEP_CHANGE)
void __cdecl
onintr(k)
int k;
#else
onintr()
#endif // KYLEP_CHANGE
{
    done(1);
}


set_signals()
{
#ifdef SIGINT
    if (signal(SIGINT, SIG_IGN) != SIG_IGN)
        signal(SIGINT, onintr);
#endif
#ifdef SIGTERM
    if (signal(SIGTERM, SIG_IGN) != SIG_IGN)
        signal(SIGTERM, onintr);
#endif
#ifdef SIGHUP
    if (signal(SIGHUP, SIG_IGN) != SIG_IGN)
        signal(SIGHUP, onintr);
#endif
}


usage()
{
#ifdef TRIPLISH
    fprintf(stderr, "usage: %s [-f sql/triplish] [-dlrtv] [-b file_prefix] [-p symbol_prefix] [-c baseclass <args>] filename\n", myname);
#else
    fprintf(stderr, "usage: %s [-dlrtv] [-b file_prefix] [-p symbol_prefix] [-c baseclass <args>] filename\n", myname);
#endif
    exit(1);
}


#if defined(KYLEP_CHANGE)
void
#endif 
getargs(argc, argv)
int argc;
char *argv[];
{
    register int i;
    register char *s;

    if (argc > 0) myname = argv[0];

    for (i = 1; i < argc; ++i)
    {
        s = argv[i];
        if (*s != '-') break;
        switch (*++s)
        {
        case '\0':
            input_file = stdin;
            if (i + 1 < argc) usage();
            return;

        case '-':
            ++i;
            goto no_more_options;

#ifdef TRIPLISH
        case 'f':
            if (*++s)
                parser_name = s;
            else if (++i < argc)
                parser_name = argv[i];
            else
                usage();

            if ( 0 == _stricmp( "sql", parser_name ) )
                ParserChoice = eSQLParser;
            else if ( 0 == _stricmp( "triplish", parser_name ) )
                ParserChoice = eTriplishParser;
            else 
                usage();

            continue;
#endif
        case 'b':
            if (*++s)
                 file_prefix = s;
            else if (++i < argc)
                file_prefix = argv[i];
            else
                usage();
            continue;

        #if defined(KYLEP_CHANGE)
        case 'c':
            if ( ++i < argc )
            {
                baseclass = argv[i];

                if ( ++i < argc )
                    ctorargs = argv[i];
                else
                    usage();
            }
            else
                usage();
            break;
        #endif

        case 'd':
            dflag = 1;
            break;

        case 'l':
            lflag = 1;
            break;

        case 'p':
            if (*++s)
                symbol_prefix = s;
            else if (++i < argc)
                symbol_prefix = argv[i];
            else
                usage();
            continue;

        case 'r':
            rflag = 1;
            break;

        case 't':
            tflag = 1;
            break;

        case 'v':
            vflag = 1;
            break;

        default:
            usage();
        }

        for (;;)
        {
            switch (*++s)
            {
            case '\0':
                goto end_of_option;

            case 'd':
                dflag = 1;
                break;

            case 'l':
                lflag = 1;
                break;

            case 'r':
                rflag = 1;
                break;

            case 't':
                tflag = 1;
                break;

            case 'v':
                vflag = 1;
                break;

            default:
                usage();
            }
        }
end_of_option:;
    }

no_more_options:;
    if (i + 1 != argc) usage();
    input_file_name = argv[i];
}


char *
allocate(n)
unsigned n;
{
    register char *p;

    p = NULL;
    if (n)
    {
        p = CALLOC(1, n);
        if (!p) no_space();
    }
    return (p);
}


create_file_names()
{
    int i, len;
    char *tmpdir;

    #if defined(KYLEP_CHANGE)
    tmpdir = getenv("TMPDIR");
    if (tmpdir == 0) tmpdir = getenv("TEMP");
    if (tmpdir == 0) tmpdir = "/tmp";
    #else
    tmpdir = getenv("TMPDIR");
    if (tmpdir == 0) tmpdir = "/tmp";
    #endif

    len = strlen(tmpdir);
    i = len + 13;
    if (len && tmpdir[len-1] != '/')
        ++i;

    action_file_name = MALLOC(i);
    if (action_file_name == 0) no_space();
    text_file_name = MALLOC(i);
    if (text_file_name == 0) no_space();
    union_file_name = MALLOC(i);
    if (union_file_name == 0) no_space();

    strcpy(action_file_name, tmpdir);
    strcpy(text_file_name, tmpdir);
    strcpy(union_file_name, tmpdir);

    if (len && tmpdir[len - 1] != '/')
    {
        action_file_name[len] = '/';
        text_file_name[len] = '/';
        union_file_name[len] = '/';
        ++len;
    }

    strcpy(action_file_name + len, temp_form);
    strcpy(text_file_name + len, temp_form);
    strcpy(union_file_name + len, temp_form);

    action_file_name[len + 5] = 'a';
    text_file_name[len + 5] = 't';
    union_file_name[len + 5] = 'u';

    mktemp(action_file_name);
    mktemp(text_file_name);
    mktemp(union_file_name);

    len = strlen(file_prefix);

    output_file_name = MALLOC(len + 7);
    if (output_file_name == 0)
        no_space();
    strcpy(output_file_name, file_prefix);
    strcpy(output_file_name + len, OUTPUT_SUFFIX);

    if (rflag)
    {
        code_file_name = MALLOC(len + 8);
        if (code_file_name == 0)
            no_space();
        strcpy(code_file_name, file_prefix);
        strcpy(code_file_name + len, CODE_SUFFIX);
    }
    else
        code_file_name = output_file_name;

    if (dflag)
    {
        defines_file_name = MALLOC(len + 7);
        if (defines_file_name == 0)
            no_space();
        strcpy(defines_file_name, file_prefix);
        strcpy(defines_file_name + len, DEFINES_SUFFIX);
    }

    if (vflag)
    {
        verbose_file_name = MALLOC(len + 8);
        if (verbose_file_name == 0)
            no_space();
        strcpy(verbose_file_name, file_prefix);
        strcpy(verbose_file_name + len, VERBOSE_SUFFIX);
    }
}


open_files()
{
    create_file_names();

    if (input_file == 0)
    {
        input_file = fopen(input_file_name, "r");
        if (input_file == 0)
            open_error(input_file_name);
    }

    action_file = fopen(action_file_name, "w");
    if (action_file == 0)
        open_error(action_file_name);

    text_file = fopen(text_file_name, "w");
    if (text_file == 0)
        open_error(text_file_name);

    if (vflag)
    {
        verbose_file = fopen(verbose_file_name, "w");
        if (verbose_file == 0)
            open_error(verbose_file_name);
    }

    if (dflag)
    {
        defines_file = fopen(defines_file_name, "w");
        if (defines_file == 0)
            open_error(defines_file_name);
        union_file = fopen(union_file_name, "w");
        if (union_file ==  0)
            open_error(union_file_name);
    }

    output_file = fopen(output_file_name, "w");
    if (output_file == 0)
        open_error(output_file_name);

    if (rflag)
    {
        code_file = fopen(code_file_name, "w");
        if (code_file == 0)
            open_error(code_file_name);
    }
    else
        code_file = output_file;
}


int 
#if defined(KYLEP_CHANGE)
__cdecl
#endif
main(argc, argv)
int argc;
char *argv[];
{
    set_signals();
    getargs(argc, argv);
    open_files();
    reader();
    lr0();
    lalr();
    make_parser();
    verbose();
    output();
    done(0);
    /*NOTREACHED*/
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\kbyacc\reader.c ===
#include "defs.h"

/*  The line size must be a positive integer.  One hundred was chosen   */
/*  because few lines in Yacc input grammars exceed 100 characters.     */
/*  Note that if a line exceeds LINESIZE characters, the line buffer    */
/*  will be expanded to accomodate it.                                  */

#define LINESIZE 100

char *cache;
int cinc, cache_size;

int ntags, tagmax;
char **tag_table;

char saw_eof, unionized;
char *cptr, *line;
int linesize;

bucket *goal;
int prec;
int gensym;
char last_was_action;

int maxitems;
bucket **pitem;

int maxrules;
bucket **plhs;

int name_pool_size;
char *name_pool;

char line_format[] = "#line %d \"%s\"\n";

#if defined(TRIPLISH)
extern int ParserChoice;
#endif

#if defined(KYLEP_CHANGE)
/* BYACC prototypes, with type safety */

void start_rule( register bucket * bp, int s_lineno );
#endif // KYLEP_CHANGE

cachec(c)
int c;
{
    assert(cinc >= 0);
    if (cinc >= cache_size)
    {
        cache_size += 256;
        cache = REALLOC(cache, cache_size);
        if (cache == 0) no_space();
    }
    #if defined(KYLEP_CHANGE)
    cache[cinc] = (char) c;
    #else
    cache[cinc] = c;
    #endif
    ++cinc;
}

#if defined(KYLEP_CHANGE)
void
#endif
get_line()
{
    register FILE *f = input_file;
    register int c;
    register int i;

    if (saw_eof || (c = getc(f)) == EOF)
    {
        if (line) { FREE(line); line = 0; }
        cptr = 0;
        saw_eof = 1;
        return;
    }

    if (line == 0 || linesize != (LINESIZE + 1))
    {
        if (line) FREE(line);
        linesize = LINESIZE + 1;
        line = MALLOC(linesize);
        if (line == 0) no_space();
    }

    i = 0;
    ++lineno;
    for (;;)
    {
        #if defined(KYLEP_CHANGE)
        line[i]  =  (char) c;
        #else
        line[i]  =  c;
        #endif
        if (c == '\n') { cptr = line; return; }
        if (++i >= linesize)
        {
            linesize += LINESIZE;
            line = REALLOC(line, linesize);
            if (line ==  0) no_space();
        }
        c = getc(f);
        if (c ==  EOF)
        {
            line[i] = '\n';
            saw_eof = 1;
            cptr = line;
            return;
        }
    }
}


char *
dup_line()
{
    register char *p, *s, *t;

    if (line == 0) return (0);
    s = line;
    while (*s != '\n') ++s;
    p = MALLOC(s - line + 1);
    if (p == 0) no_space();

    s = line;
    t = p;
    while ((*t++ = *s++) != '\n') continue;
    return (p);
}

#if defined(KYLEP_CHANGE)
void
#endif
skip_comment()
{
    register char *s;

    int st_lineno = lineno;
    char *st_line = dup_line();
    char *st_cptr = st_line + (cptr - line);

    s = cptr + 2;
    for (;;)
    {
        if (*s == '*' && s[1] == '/')
        {
            cptr = s + 2;
            FREE(st_line);
            return;
        }
        if (*s == '\n')
        {
            get_line();
            if (line == 0)
                unterminated_comment(st_lineno, st_line, st_cptr);
            s = cptr;
        }
        else
            ++s;
    }
}


int
nextc()
{
    register char *s;

    if (line == 0)
    {
        get_line();
        if (line == 0)
            return (EOF);
    }

    s = cptr;
    for (;;)
    {
        switch (*s)
        {
        case '\n':
            get_line();
            if (line == 0) return (EOF);
            s = cptr;
            break;

        case ' ':
        case '\t':
        case '\f':
        case '\r':
        case '\v':
        case ',':
        case ';':
            ++s;
            break;

        case '\\':
            cptr = s;
            return ('%');

        case '/':
            if (s[1] == '*')
            {
                cptr = s;
                skip_comment();
                s = cptr;
                break;
            }
            else if (s[1] == '/')
            {
                get_line();
                if (line == 0) return (EOF);
                s = cptr;
                break;
            }
            /* fall through */

        default:
            cptr = s;
            return (*s);
        }
    }
}


int
keyword()
{
    register int c;
    char *t_cptr = cptr;

    c = *++cptr;
    if (isalpha(c))
    {
        cinc = 0;
        for (;;)
        {
            if (isalpha(c))
            {
                if (isupper(c)) c = tolower(c);
                cachec(c);
            }
            else if (isdigit(c) || c == '_' || c == '.' || c == '$')
                cachec(c);
            else
                break;
            c = *++cptr;
        }
        cachec(NUL);

        if (strcmp(cache, "token") == 0 || strcmp(cache, "term") == 0)
            return (TOKEN);
        if (strcmp(cache, "type") == 0)
            return (TYPE);
        if (strcmp(cache, "left") == 0)
            return (LEFT);
        if (strcmp(cache, "right") == 0)
            return (RIGHT);
        if (strcmp(cache, "nonassoc") == 0 || strcmp(cache, "binary") == 0)
            return (NONASSOC);
        if (strcmp(cache, "start") == 0)
            return (START);
        if (strcmp(cache, "union") == 0)
            return (UNION);
        if (strcmp(cache, "ident") == 0)
            return (IDENT);
    }
    else
    {
        ++cptr;
        if (c == '{')
            return (TEXT);
        if (c == '%' || c == '\\')
            return (MARK);
        if (c == '<')
            return (LEFT);
        if (c == '>')
            return (RIGHT);
        if (c == '0')
            return (TOKEN);
        if (c == '2')
            return (NONASSOC);
    }
    syntax_error(lineno, line, t_cptr);
    /*NOTREACHED*/
    #if defined(KYLEP_CHANGE)
    return (NONASSOC);
    #endif
}

#if defined(KYLEP_CHANGE)
void
#endif
copy_ident()
{
    register int c;
    register FILE *f = output_file;

    c = nextc();
    if (c == EOF) unexpected_EOF();
    if (c != '"') syntax_error(lineno, line, cptr);
    ++outline;
    fprintf(f, "#ident \"");
    for (;;)
    {
        c = *++cptr;
        if (c == '\n')
        {
            fprintf(f, "\"\n");
            return;
        }
        putc(c, f);
        if (c == '"')
        {
            putc('\n', f);
            ++cptr;
            return;
        }
    }
}

#if defined(KYLEP_CHANGE)
void
#endif
copy_text()
{
    register int c;
    int quote;
    register FILE *f = text_file;
    int need_newline = 0;
    int t_lineno = lineno;
    char *t_line = dup_line();
    char *t_cptr = t_line + (cptr - line - 2);

    if (*cptr == '\n')
    {
        get_line();
        if (line == 0)
            unterminated_text(t_lineno, t_line, t_cptr);
    }
    if (!lflag) fprintf(f, line_format, lineno, input_file_name);

loop:
    c = *cptr++;
    switch (c)
    {
    case '\n':
    next_line:
        putc('\n', f);
        need_newline = 0;
        get_line();
        if (line) goto loop;
        unterminated_text(t_lineno, t_line, t_cptr);

    case '\'':
    case '"':
        {
            int s_lineno = lineno;
            char *s_line = dup_line();
            char *s_cptr = s_line + (cptr - line - 1);

            quote = c;
            putc(c, f);
            for (;;)
            {
                c = *cptr++;
                putc(c, f);
                if (c == quote)
                {
                    need_newline = 1;
                    FREE(s_line);
                    goto loop;
                }
                if (c == '\n')
                    unterminated_string(s_lineno, s_line, s_cptr);
                if (c == '\\')
                {
                    c = *cptr++;
                    putc(c, f);
                    if (c == '\n')
                    {
                        get_line();
                        if (line == 0)
                            unterminated_string(s_lineno, s_line, s_cptr);
                    }
                }
            }
        }

    case '/':
        putc(c, f);
        need_newline = 1;
        c = *cptr;
        if (c == '/')
        {
            #if defined(KYLEP_CHANGE)
            putc('/', f);
            while ((c = *++cptr) != '\n')
            {
                putc(c, f);
            }
            #else
            putc('*', f);
            while ((c = *++cptr) != '\n')
            {
                if (c == '*' && cptr[1] == '/')
                    fprintf(f, "* ");
                else
                    putc(c, f);
            }
            fprintf(f, "*/");
            #endif // KYLEP_CHANGE
            goto next_line;
        }
        if (c == '*')
        {
            int c_lineno = lineno;
            char *c_line = dup_line();
            char *c_cptr = c_line + (cptr - line - 1);

            putc('*', f);
            ++cptr;
            for (;;)
            {
                c = *cptr++;
                putc(c, f);
                if (c == '*' && *cptr == '/')
                {
                    putc('/', f);
                    ++cptr;
                    FREE(c_line);
                    goto loop;
                }
                if (c == '\n')
                {
                    get_line();
                    if (line == 0)
                        unterminated_comment(c_lineno, c_line, c_cptr);
                }
            }
        }
        need_newline = 1;
        goto loop;

    case '%':
    case '\\':
        if (*cptr == '}')
        {
            if (need_newline) putc('\n', f);
            ++cptr;
            FREE(t_line);
            return;
        }
        /* fall through */

    default:
        putc(c, f);
        need_newline = 1;
        goto loop;
    }
}

#if defined(KYLEP_CHANGE)
void
#endif
copy_union()
{
    register int c;
    int quote;
    int depth;
    int u_lineno = lineno;
    char *u_line = dup_line();
    char *u_cptr = u_line + (cptr - line - 6);

    if (unionized) over_unionized(cptr - 6);
    unionized = 1;

    if (!lflag)
        fprintf(text_file, line_format, lineno, input_file_name);

    fprintf(text_file, "typedef union");
    if (dflag) fprintf(union_file, "typedef union");

    depth = 0;
loop:
    c = *cptr++;
    putc(c, text_file);
    if (dflag) putc(c, union_file);
    switch (c)
    {
    case '\n':
    next_line:
        get_line();
        if (line == 0) unterminated_union(u_lineno, u_line, u_cptr);
        goto loop;

    case '{':
        ++depth;
        goto loop;

    case '}':
        if (--depth == 0)
        {
            fprintf(text_file, " YYSTYPE;\n");
            FREE(u_line);
            return;
        }
        goto loop;

    case '\'':
    case '"':
        {
            int s_lineno = lineno;
            char *s_line = dup_line();
            char *s_cptr = s_line + (cptr - line - 1);

            quote = c;
            for (;;)
            {
                c = *cptr++;
                putc(c, text_file);
                if (dflag) putc(c, union_file);
                if (c == quote)
                {
                    FREE(s_line);
                    goto loop;
                }
                if (c == '\n')
                    unterminated_string(s_lineno, s_line, s_cptr);
                if (c == '\\')
                {
                    c = *cptr++;
                    putc(c, text_file);
                    if (dflag) putc(c, union_file);
                    if (c == '\n')
                    {
                        get_line();
                        if (line == 0)
                            unterminated_string(s_lineno, s_line, s_cptr);
                    }
                }
            }
        }

    case '/':
        c = *cptr;
        if (c == '/')
        {
            #if defined(KYLEP_CHANGE)
            putc('/', text_file);
            if (dflag) putc('/', union_file);
            while ((c = *++cptr) != '\n')
            {
                putc(c, text_file);
                if (dflag) putc(c, union_file);
            }
            #else
            putc('*', text_file);
            if (dflag) putc('*', union_file);
            while ((c = *++cptr) != '\n')
            {
                if (c == '*' && cptr[1] == '/')
                {
                    fprintf(text_file, "* ");
                    if (dflag) fprintf(union_file, "* ");
                }
                else
                {
                    putc(c, text_file);
                    if (dflag) putc(c, union_file);
                }
            }
            fprintf(text_file, "*/\n");
            if (dflag) fprintf(union_file, "*/\n");
            #endif // KYLEP_CHANGE
            goto next_line;
        }
        if (c == '*')
        {
            int c_lineno = lineno;
            char *c_line = dup_line();
            char *c_cptr = c_line + (cptr - line - 1);

            putc('*', text_file);
            if (dflag) putc('*', union_file);
            ++cptr;
            for (;;)
            {
                c = *cptr++;
                putc(c, text_file);
                if (dflag) putc(c, union_file);
                if (c == '*' && *cptr == '/')
                {
                    putc('/', text_file);
                    if (dflag) putc('/', union_file);
                    ++cptr;
                    FREE(c_line);
                    goto loop;
                }
                if (c == '\n')
                {
                    get_line();
                    if (line == 0)
                        unterminated_comment(c_lineno, c_line, c_cptr);
                }
            }
        }
        goto loop;

    default:
        goto loop;
    }
}


int
hexval(c)
int c;
{
    if (c >= '0' && c <= '9')
        return (c - '0');
    if (c >= 'A' && c <= 'F')
        return (c - 'A' + 10);
    if (c >= 'a' && c <= 'f')
        return (c - 'a' + 10);
    return (-1);
}


bucket *
get_literal()
{
    register int c, quote;
    register int i;
    register int n;
    register char *s;
    register bucket *bp;
    int s_lineno = lineno;
    char *s_line = dup_line();
    char *s_cptr = s_line + (cptr - line);

    quote = *cptr++;
    cinc = 0;
    for (;;)
    {
        c = *cptr++;
        if (c == quote) break;
        if (c == '\n') unterminated_string(s_lineno, s_line, s_cptr);
        if (c == '\\')
        {
            char *c_cptr = cptr - 1;

            c = *cptr++;
            switch (c)
            {
            case '\n':
                get_line();
                if (line == 0) unterminated_string(s_lineno, s_line, s_cptr);
                continue;

            case '0': case '1': case '2': case '3':
            case '4': case '5': case '6': case '7':
                n = c - '0';
                c = *cptr;
                if (IS_OCTAL(c))
                {
                    n = (n << 3) + (c - '0');
                    c = *++cptr;
                    if (IS_OCTAL(c))
                    {
                        n = (n << 3) + (c - '0');
                        ++cptr;
                    }
                }
                if (n > MAXCHAR) illegal_character(c_cptr);
                c = n;
                break;

            case 'x':
                c = *cptr++;
                n = hexval(c);
                if (n < 0 || n >= 16)
                    illegal_character(c_cptr);
                for (;;)
                {
                    c = *cptr;
                    i = hexval(c);
                    if (i < 0 || i >= 16) break;
                    ++cptr;
                    n = (n << 4) + i;
                    if (n > MAXCHAR) illegal_character(c_cptr);
                }
                c = n;
                break;

            case 'a': c = 7; break;
            case 'b': c = '\b'; break;
            case 'f': c = '\f'; break;
            case 'n': c = '\n'; break;
            case 'r': c = '\r'; break;
            case 't': c = '\t'; break;
            case 'v': c = '\v'; break;
            }
        }
        cachec(c);
    }
    FREE(s_line);

    n = cinc;
    s = MALLOC(n);
    if (s == 0) no_space();

    for (i = 0; i < n; ++i)
        s[i] = cache[i];

    cinc = 0;
    if (n == 1)
        cachec('\'');
    else
        cachec('"');

    for (i = 0; i < n; ++i)
    {
        c = ((unsigned char *)s)[i];
        if (c == '\\' || c == cache[0])
        {
            cachec('\\');
            cachec(c);
        }
        else if (isprint(c))
            cachec(c);
        else
        {
            cachec('\\');
            switch (c)
            {
            case 7: cachec('a'); break;
            case '\b': cachec('b'); break;
            case '\f': cachec('f'); break;
            case '\n': cachec('n'); break;
            case '\r': cachec('r'); break;
            case '\t': cachec('t'); break;
            case '\v': cachec('v'); break;
            default:
                cachec(((c >> 6) & 7) + '0');
                cachec(((c >> 3) & 7) + '0');
                cachec((c & 7) + '0');
                break;
            }
        }
    }

    if (n == 1)
        cachec('\'');
    else
        cachec('"');

    cachec(NUL);
    bp = lookup(cache);
    bp->class = TERM;
    if (n == 1 && bp->value == UNDEFINED)
        bp->value = *(unsigned char *)s;
    FREE(s);

    return (bp);
}


int
is_reserved(name)
char *name;
{
    char *s;

    if (strcmp(name, ".") == 0 ||
            strcmp(name, "$accept") == 0 ||
            strcmp(name, "$end") == 0)
        return (1);

    if (name[0] == '$' && name[1] == '$' && isdigit(name[2]))
    {
        s = name + 3;
        while (isdigit(*s)) ++s;
        if (*s == NUL) return (1);
    }

    return (0);
}


bucket *
get_name()
{
    register int c;

    cinc = 0;
    for (c = *cptr; IS_IDENT(c); c = *++cptr)
        cachec(c);
    cachec(NUL);

    if (is_reserved(cache)) used_reserved(cache);

    return (lookup(cache));
}


int
get_number()
{
    register int c;
    register int n;

    n = 0;
    for (c = *cptr; isdigit(c); c = *++cptr)
        n = 10*n + (c - '0');

    return (n);
}


char *
get_tag()
{
    register int c;
    register int i;
    register char *s;
    int t_lineno = lineno;
    char *t_line = dup_line();
    char *t_cptr = t_line + (cptr - line);

    ++cptr;
    c = nextc();
    if (c == EOF) unexpected_EOF();
    if (!isalpha(c) && c != '_' && c != '$')
        illegal_tag(t_lineno, t_line, t_cptr);

    cinc = 0;
    do { cachec(c); c = *++cptr; } while (IS_IDENT(c));
    cachec(NUL);

    c = nextc();
    if (c == EOF) unexpected_EOF();
    if (c != '>')
        illegal_tag(t_lineno, t_line, t_cptr);
    ++cptr;

    for (i = 0; i < ntags; ++i)
    {
        if (strcmp(cache, tag_table[i]) == 0)
            return (tag_table[i]);
    }

    if (ntags >= tagmax)
    {
        tagmax += 16;
        tag_table = (char **)
                        (tag_table ? REALLOC(tag_table, tagmax*sizeof(char *))
                                   : MALLOC(tagmax*sizeof(char *)));
        if (tag_table == 0) no_space();
    }

    s = MALLOC(cinc);
    if  (s == 0) no_space();
    strcpy(s, cache);
    tag_table[ntags] = s;
    ++ntags;
    FREE(t_line);
    return (s);
}

#if defined(KYLEP_CHANGE)
void
#endif
declare_tokens(assoc)
int assoc;
{
    register int c;
    register bucket *bp;
    int value;
    char *tag = 0;

    if (assoc != TOKEN) ++prec;

    c = nextc();
    if (c == EOF) unexpected_EOF();
    if (c == '<')
    {
        tag = get_tag();
        c = nextc();
        if (c == EOF) unexpected_EOF();
    }

    for (;;)
    {
        if (isalpha(c) || c == '_' || c == '.' || c == '$')
            bp = get_name();
        else if (c == '\'' || c == '"')
            bp = get_literal();
        else
            return;

        if (bp == goal) tokenized_start(bp->name);
        bp->class = TERM;

        if (tag)
        {
            if (bp->tag && tag != bp->tag)
                retyped_warning(bp->name);
            bp->tag = tag;
        }

        if (assoc != TOKEN)
        {
            if (bp->prec && prec != bp->prec)
                reprec_warning(bp->name);
            #if defined(KYLEP_CHANGE)                                     
            bp->assoc = (char) assoc;
            bp->prec = (short) prec;
            #else
            bp->assoc = assoc;
            bp->prec = prec;
            #endif // KYLEP_CHANGE
        }

        c = nextc();
        if (c == EOF) unexpected_EOF();
        value = UNDEFINED;
        if (isdigit(c))
        {
            value = get_number();
            if (bp->value != UNDEFINED && value != bp->value)
                revalued_warning(bp->name);
            #if defined(KYLEP_CHANGE)                                     
            bp->value = (short) value;
            #else
            bp->value = value;
            #endif // KYLEP_CHANGE
            c = nextc();
            if (c == EOF) unexpected_EOF();
        }
    }
}

#if defined(KYLEP_CHANGE)
void
#endif
declare_types()
{
    register int c;
    register bucket *bp;
    char *tag;

    c = nextc();
    if (c == EOF) unexpected_EOF();
    if (c != '<') syntax_error(lineno, line, cptr);
    tag = get_tag();

    for (;;)
    {
        c = nextc();
        if (isalpha(c) || c == '_' || c == '.' || c == '$')
            bp = get_name();
        else if (c == '\'' || c == '"')
            bp = get_literal();
        else
            return;

        if (bp->tag && tag != bp->tag)
            retyped_warning(bp->name);
        bp->tag = tag;
    }
}


declare_start()
{
    register int c;
    register bucket *bp;

    c = nextc();
    if (c == EOF) unexpected_EOF();
    if (!isalpha(c) && c != '_' && c != '.' && c != '$')
        syntax_error(lineno, line, cptr);
    bp = get_name();
    if (bp->class == TERM)
        terminal_start(bp->name);
    if (goal && goal != bp)
        restarted_warning();
    goal = bp;
}


#if defined(KYLEP_CHANGE)
void
#endif
read_declarations()
{
    register int c, k;

    cache_size = 256;
    cache = MALLOC(cache_size);
    if (cache == 0) no_space();

    for (;;)
    {
        c = nextc();
        if (c == EOF) unexpected_EOF();
        if (c != '%') syntax_error(lineno, line, cptr);
        switch (k = keyword())
        {
        case MARK:
            return;

        case IDENT:
            copy_ident();
            break;

        case TEXT:
            copy_text();
            break;

        case UNION:
            copy_union();
            break;

        case TOKEN:
        case LEFT:
        case RIGHT:
        case NONASSOC:
            declare_tokens(k);
            break;

        case TYPE:
            declare_types();
            break;

        case START:
            declare_start();
            break;
        }
    }
}


initialize_grammar()
{
    nitems = 4;
    maxitems = 300;
    pitem = (bucket **) MALLOC(maxitems*sizeof(bucket *));
    if (pitem == 0) no_space();
    pitem[0] = 0;
    pitem[1] = 0;
    pitem[2] = 0;
    pitem[3] = 0;

    nrules = 3;
    maxrules = 100;
    plhs = (bucket **) MALLOC(maxrules*sizeof(bucket *));
    if (plhs == 0) no_space();
    plhs[0] = 0;
    plhs[1] = 0;
    plhs[2] = 0;
    rprec = (short *) MALLOC(maxrules*sizeof(short));
    if (rprec == 0) no_space();
    rprec[0] = 0;
    rprec[1] = 0;
    rprec[2] = 0;
    rassoc = (char *) MALLOC(maxrules*sizeof(char));
    if (rassoc == 0) no_space();
    rassoc[0] = TOKEN;
    rassoc[1] = TOKEN;
    rassoc[2] = TOKEN;
}


expand_items()
{
    maxitems += 300;
    pitem = (bucket **) REALLOC(pitem, maxitems*sizeof(bucket *));
    if (pitem == 0) no_space();
}


expand_rules()
{
    maxrules += 100;
    plhs = (bucket **) REALLOC(plhs, maxrules*sizeof(bucket *));
    if (plhs == 0) no_space();
    rprec = (short *) REALLOC(rprec, maxrules*sizeof(short));
    if (rprec == 0) no_space();
    rassoc = (char *) REALLOC(rassoc, maxrules*sizeof(char));
    if (rassoc == 0) no_space();
}


advance_to_start()
{
    register int c;
    register bucket *bp;
    char *s_cptr;
    int s_lineno;

    for (;;)
    {
        c = nextc();
        if (c != '%') break;
        s_cptr = cptr;
        switch (keyword())
        {
        case MARK:
            no_grammar();

        case TEXT:
            copy_text();
            break;

        case START:
            declare_start();
            break;

        default:
            syntax_error(lineno, line, s_cptr);
        }
    }

    c = nextc();
    if (!isalpha(c) && c != '_' && c != '.' && c != '_')
        syntax_error(lineno, line, cptr);
    bp = get_name();
    if (goal == 0)
    {
        if (bp->class == TERM)
            terminal_start(bp->name);
        goal = bp;
    }

    s_lineno = lineno;
    c = nextc();
    if (c == EOF) unexpected_EOF();
    if (c != ':') syntax_error(lineno, line, cptr);
    start_rule(bp, s_lineno);
    ++cptr;
}


#if defined(KYLEP_CHANGE)
void
#endif
start_rule(bp, s_lineno)
register bucket *bp;
int s_lineno;
{
    if (bp->class == TERM)
        terminal_lhs(s_lineno);
    bp->class = NONTERM;
    if (nrules >= maxrules)
        expand_rules();
    plhs[nrules] = bp;
    rprec[nrules] = UNDEFINED;
    rassoc[nrules] = TOKEN;
}


end_rule()
{
    register int i;

    if (!last_was_action && plhs[nrules]->tag)
    {
        for (i = nitems - 1; pitem[i]; --i) continue;
        if (pitem[i+1] == 0 || pitem[i+1]->tag != plhs[nrules]->tag)
            default_action_warning();
    }

    last_was_action = 0;
    if (nitems >= maxitems) expand_items();
    pitem[nitems] = 0;
    ++nitems;
    ++nrules;
}


insert_empty_rule()
{
    register bucket *bp, **bpp;

    assert(cache);
    sprintf(cache, "$$%d", ++gensym);
    bp = make_bucket(cache);
    last_symbol->next = bp;
    last_symbol = bp;
    bp->tag = plhs[nrules]->tag;
    bp->class = NONTERM;

    if ((nitems += 2) > maxitems)
        expand_items();
    bpp = pitem + nitems - 1;
    *bpp-- = bp;
    while (bpp[0] = bpp[-1]) --bpp;

    if (++nrules >= maxrules)
        expand_rules();
    plhs[nrules] = plhs[nrules-1];
    plhs[nrules-1] = bp;
    rprec[nrules] = rprec[nrules-1];
    rprec[nrules-1] = 0;
    rassoc[nrules] = rassoc[nrules-1];
    rassoc[nrules-1] = TOKEN;
}


#if defined(KYLEP_CHANGE)
void
#endif
add_symbol()
{
    register int c;
    register bucket *bp;
    int s_lineno = lineno;

    c = *cptr;
    if (c == '\'' || c == '"')
        bp = get_literal();
    else
        bp = get_name();

    c = nextc();
    if (c == ':')
    {
        end_rule();
        start_rule(bp, s_lineno);
        ++cptr;
        return;
    }

    if (last_was_action)
        insert_empty_rule();
    last_was_action = 0;

    if (++nitems > maxitems)
        expand_items();
    pitem[nitems-1] = bp;
}


#if defined(KYLEP_CHANGE)
void
#endif
copy_action()
{
    register int c;
    register int i, n;
    int depth;
    int quote;
    char *tag;
    register FILE *f = action_file;
    int a_lineno = lineno;
    char *a_line = dup_line();
    char *a_cptr = a_line + (cptr - line);

    if (last_was_action)
        insert_empty_rule();
    last_was_action = 1;

    fprintf(f, "case %d:\n", nrules - 2);
    if (!lflag)
        fprintf(f, line_format, lineno, input_file_name);
    if (*cptr == '=') ++cptr;

    n = 0;
    for (i = nitems - 1; pitem[i]; --i) ++n;

    depth = 0;
loop:
    c = *cptr;
    if (c == '$')
    {
        if (cptr[1] == '<')
        {
            int d_lineno = lineno;
            char *d_line = dup_line();
            char *d_cptr = d_line + (cptr - line);

            ++cptr;
            tag = get_tag();
            c = *cptr;
            if (c == '$')
            {
                fprintf(f, "yyval.%s", tag);
                ++cptr;
                FREE(d_line);
                goto loop;
            }
            else if (isdigit(c))
            {
                i = get_number();
                if (i > n) dollar_warning(d_lineno, i);
                fprintf(f, "yyvsp[%d].%s", i - n, tag);
                FREE(d_line);
                goto loop;
            }
            else if (c == '-' && isdigit(cptr[1]))
            {
                ++cptr;
                i = -get_number() - n;
                fprintf(f, "yyvsp[%d].%s", i, tag);
                FREE(d_line);
                goto loop;
            }
            else
                dollar_error(d_lineno, d_line, d_cptr);
        }
        else if (cptr[1] == '$')
        {
            if (ntags)
            {
                tag = plhs[nrules]->tag;
                if (tag == 0) untyped_lhs();
                fprintf(f, "yyval.%s", tag);
            }
            else
                fprintf(f, "yyval");
            cptr += 2;
            goto loop;
        }
        else if (isdigit(cptr[1]))
        {
            ++cptr;
            i = get_number();
            if (ntags)
            {
                if (i <= 0 || i > n)
                    unknown_rhs(i);
                tag = pitem[nitems + i - n - 1]->tag;
                if (tag == 0) untyped_rhs(i, pitem[nitems + i - n - 1]->name);
                fprintf(f, "yyvsp[%d].%s", i - n, tag);
            }
            else
            {
                if (i > n)
                    dollar_warning(lineno, i);
                fprintf(f, "yyvsp[%d]", i - n);
            }
            goto loop;
        }
        else if (cptr[1] == '-')
        {
            cptr += 2;
            i = get_number();
            if (ntags)
                unknown_rhs(-i);
            fprintf(f, "yyvsp[%d]", -i - n);
            goto loop;
        }
    }
    if (isalpha(c) || c == '_' || c == '$')
    {
        do
        {
            putc(c, f);
            c = *++cptr;
        } while (isalnum(c) || c == '_' || c == '$');
        goto loop;
    }
    putc(c, f);
    ++cptr;
    switch (c)
    {
    case '\n':
    next_line:
        get_line();
        if (line) goto loop;
        unterminated_action(a_lineno, a_line, a_cptr);

    case ';':
        if (depth > 0) goto loop;
        fprintf(f, "\nbreak;\n");
        return;

    case '{':
        ++depth;
        goto loop;

    case '}':
        if (--depth > 0) goto loop;
        fprintf(f, "\nbreak;\n");
        return;

    case '\'':
    case '"':
        {
            int s_lineno = lineno;
            char *s_line = dup_line();
            char *s_cptr = s_line + (cptr - line - 1);

            quote = c;
            for (;;)
            {
                c = *cptr++;
                putc(c, f);
                if (c == quote)
                {
                    FREE(s_line);
                    goto loop;
                }
                if (c == '\n')
                    unterminated_string(s_lineno, s_line, s_cptr);
                if (c == '\\')
                {
                    c = *cptr++;
                    putc(c, f);
                    if (c == '\n')
                    {
                        get_line();
                        if (line == 0)
                            unterminated_string(s_lineno, s_line, s_cptr);
                    }
                }
            }
        }

    case '/':
        c = *cptr;
        if (c == '/')
        {
            #if defined(KYLEP_CHANGED)
            putc('/', f);
            while ((c = *++cptr) != '\n')
            {
                putc(c, f);
            }
            #else
            putc('*', f);
            while ((c = *++cptr) != '\n')
            {
                if (c == '*' && cptr[1] == '/')
                    fprintf(f, "* ");
                else
                    putc(c, f);
            }
            fprintf(f, "*/\n");
            #endif // KYLEP_CHANGE
            goto next_line;
        }
        if (c == '*')
        {
            int c_lineno = lineno;
            char *c_line = dup_line();
            char *c_cptr = c_line + (cptr - line - 1);

            putc('*', f);
            ++cptr;
            for (;;)
            {
                c = *cptr++;
                putc(c, f);
                if (c == '*' && *cptr == '/')
                {
                    putc('/', f);
                    ++cptr;
                    FREE(c_line);
                    goto loop;
                }
                if (c == '\n')
                {
                    get_line();
                    if (line == 0)
                        unterminated_comment(c_lineno, c_line, c_cptr);
                }
            }
        }
        goto loop;

    default:
        goto loop;
    }
}


int
mark_symbol()
{
    register int c;
    register bucket *bp;

    c = cptr[1];
    if (c == '%' || c == '\\')
    {
        cptr += 2;
        return (1);
    }

    if (c == '=')
        cptr += 2;
    else if ((c == 'p' || c == 'P') &&
             ((c = cptr[2]) == 'r' || c == 'R') &&
             ((c = cptr[3]) == 'e' || c == 'E') &&
             ((c = cptr[4]) == 'c' || c == 'C') &&
             ((c = cptr[5], !IS_IDENT(c))))
        cptr += 5;
    else
        syntax_error(lineno, line, cptr);

    c = nextc();
    if (isalpha(c) || c == '_' || c == '.' || c == '$')
        bp = get_name();
    else if (c == '\'' || c == '"')
        bp = get_literal();
    else
    {
        syntax_error(lineno, line, cptr);
        /*NOTREACHED*/
    }

    if (rprec[nrules] != UNDEFINED && bp->prec != rprec[nrules])
        prec_redeclared();

    rprec[nrules] = bp->prec;
    rassoc[nrules] = bp->assoc;
    return (0);
}


read_grammar()
{
    register int c;

    initialize_grammar();
    advance_to_start();

    for (;;)
    {
        c = nextc();
        if (c == EOF) break;
        if (isalpha(c) || c == '_' || c == '.' || c == '$' || c == '\'' ||
                c == '"')
            add_symbol();
        else if (c == '{' || c == '=')
            copy_action();
        else if (c == '|')
        {
            end_rule();
            start_rule(plhs[nrules-1], 0);
            ++cptr;
        }
        else if (c == '%')
        {
            if (mark_symbol()) break;
        }
        else
            syntax_error(lineno, line, cptr);
    }
    end_rule();
}


#if defined(KYLEP_CHANGE)
void
#endif
free_tags()
{
    register int i;

    if (tag_table == 0) return;

    for (i = 0; i < ntags; ++i)
    {
        assert(tag_table[i]);
        FREE(tag_table[i]);
    }
    FREE(tag_table);
}


pack_names()
{
    register bucket *bp;
    register char *p, *s, *t;

    name_pool_size = 13;  /* 13 == sizeof("$end") + sizeof("$accept") */
    for (bp = first_symbol; bp; bp = bp->next)
        name_pool_size += strlen(bp->name) + 1;
    name_pool = MALLOC(name_pool_size);
    if (name_pool == 0) no_space();

    strcpy(name_pool, "$accept");
    strcpy(name_pool+8, "$end");
    t = name_pool + 13;
    for (bp = first_symbol; bp; bp = bp->next)
    {
        p = t;
        s = bp->name;
        while (*t++ = *s++) continue;
        FREE(bp->name);
        bp->name = p;
    }
}


check_symbols()
{
    register bucket *bp;

    if (goal->class == UNKNOWN)
        undefined_goal(goal->name);

    for (bp = first_symbol; bp; bp = bp->next)
    {
        if (bp->class == UNKNOWN)
        {
            undefined_symbol_warning(bp->name);
            bp->class = TERM;
        }
    }
}


pack_symbols()
{
    register bucket *bp;
    register bucket **v;
    register int i, j, k, n;

    nsyms = 2;
    ntokens = 1;
    for (bp = first_symbol; bp; bp = bp->next)
    {
        ++nsyms;
        if (bp->class == TERM) ++ntokens;
    }
    start_symbol = ntokens;
    nvars = nsyms - ntokens;

    symbol_name = (char **) MALLOC(nsyms*sizeof(char *));
    if (symbol_name == 0) no_space();
    symbol_value = (short *) MALLOC(nsyms*sizeof(short));
    if (symbol_value == 0) no_space();
    symbol_prec = (short *) MALLOC(nsyms*sizeof(short));
    if (symbol_prec == 0) no_space();
    symbol_assoc = MALLOC(nsyms);
    if (symbol_assoc == 0) no_space();

    v = (bucket **) MALLOC(nsyms*sizeof(bucket *));
    if (v == 0) no_space();

    v[0] = 0;
    v[start_symbol] = 0;

    i = 1;
    j = start_symbol + 1;
    for (bp = first_symbol; bp; bp = bp->next)
    {
        if (bp->class == TERM)
            v[i++] = bp;
        else
            v[j++] = bp;
    }
    assert(i == ntokens && j == nsyms);

    for (i = 1; i < ntokens; ++i)
        #if defined(KYLEP_CHANGE)                                         
        v[i]->index = (short) i;
        #else
        v[i]->index = i;
        #endif // KYLEP_CHANGE

    goal->index = start_symbol + 1;
    k = start_symbol + 2;
    while (++i < nsyms)
        if (v[i] != goal)
        {
            #if defined(KYLEP_CHANGE)                                     
            v[i]->index = (short) k;
            #else
            v[i]->index = k;
            #endif // KYLEP_CHANGE
            ++k;
        }

    goal->value = 0;
    k = 1;
    for (i = start_symbol + 1; i < nsyms; ++i)
    {
        if (v[i] != goal)
        {
            #if defined(KYLEP_CHANGE)                                     
            v[i]->value = (short) k;
            #else
            v[i]->value = k;
            #endif // KYLEP_CHANGE
            ++k;
        }
    }

    k = 0;
    for (i = 1; i < ntokens; ++i)
    {
        n = v[i]->value;
        if (n > 256)
        {
            for (j = k++; j > 0 && symbol_value[j-1] > n; --j)
                symbol_value[j] = symbol_value[j-1];
            #if defined(KYLEP_CHANGE)                                     
            symbol_value[j] = (short) n;
            #else
            symbol_value[j] = n;
            #endif // KYLEP_CHANGE
        }
    }

    if (v[1]->value == UNDEFINED)
        v[1]->value = 256;

    j = 0;
    n = 257;
    for (i = 2; i < ntokens; ++i)
    {
        if (v[i]->value == UNDEFINED)
        {
            while (j < k && n == symbol_value[j])
            {
                while (++j < k && n == symbol_value[j]) continue;
                ++n;
            }
            #if defined(KYLEP_CHANGE)                                     
            v[i]->value = (short) n;
            #else
            v[i]->value = n;
            #endif // KYLEP_CHANGE
            ++n;
        }
    }

    symbol_name[0] = name_pool + 8;
    symbol_value[0] = 0;
    symbol_prec[0] = 0;
    symbol_assoc[0] = TOKEN;
    for (i = 1; i < ntokens; ++i)
    {
        symbol_name[i] = v[i]->name;
        symbol_value[i] = v[i]->value;
        symbol_prec[i] = v[i]->prec;
        symbol_assoc[i] = v[i]->assoc;
    }
    symbol_name[start_symbol] = name_pool;
    symbol_value[start_symbol] = -1;
    symbol_prec[start_symbol] = 0;
    symbol_assoc[start_symbol] = TOKEN;
    for (++i; i < nsyms; ++i)
    {
        k = v[i]->index;
        symbol_name[k] = v[i]->name;
        symbol_value[k] = v[i]->value;
        symbol_prec[k] = v[i]->prec;
        symbol_assoc[k] = v[i]->assoc;
    }

    FREE(v);
}


pack_grammar()
{
    register int i, j;
    int assoc, prec;

    ritem = (short *) MALLOC(nitems*sizeof(short));
    if (ritem == 0) no_space();
    rlhs = (short *) MALLOC(nrules*sizeof(short));
    if (rlhs == 0) no_space();
    rrhs = (short *) MALLOC((nrules+1)*sizeof(short));
    if (rrhs == 0) no_space();
    rprec = (short *) REALLOC(rprec, nrules*sizeof(short));
    if (rprec == 0) no_space();
    rassoc = REALLOC(rassoc, nrules);
    if (rassoc == 0) no_space();

    ritem[0] = -1;
    ritem[1] = goal->index;
    ritem[2] = 0;
    ritem[3] = -2;
    rlhs[0] = 0;
    rlhs[1] = 0;
    #if defined(KYLEP_CHANGE)                                             
    rlhs[2] = (short) start_symbol;
    #else
    rlhs[2] = start_symbol;
    #endif // KYLEP_CHANGE
    rrhs[0] = 0;
    rrhs[1] = 0;
    rrhs[2] = 1;

    j = 4;
    for (i = 3; i < nrules; ++i)
    {
        rlhs[i] = plhs[i]->index;
        #if defined(KYLEP_CHANGE)                                         
        rrhs[i] = (short) j;
        #else
        rrhs[i] = j;
        #endif // KYLEP_CHANGE
        assoc = TOKEN;
        prec = 0;
        while (pitem[j])
        {
            ritem[j] = pitem[j]->index;
            if (pitem[j]->class == TERM)
            {
                prec = pitem[j]->prec;
                assoc = pitem[j]->assoc;
            }
            ++j;
        }
        ritem[j] = -i;
        ++j;
        if (rprec[i] == UNDEFINED)
        {
            #if defined(KYLEP_CHANGE)                                     
            rprec[i] = (short) prec;
            rassoc[i] = (char) assoc;
            #else
            rprec[i] = prec;
            rassoc[i] = assoc;
            #endif // KYLEP_CHANGE
        }
    }
    #if defined(KYLEP_CHANGE)                                             
    rrhs[i] = (short) j;
    #else
    rrhs[i] = j;
    #endif // KYLEP_CHANGE

    FREE(plhs);
    FREE(pitem);
}


#if defined(KYLEP_CHANGE)
void
#endif
print_grammar()
{
    register int i, j, k;
    int spacing;
    register FILE *f = verbose_file;

    if (!vflag) return;

    k = 1;
    for (i = 2; i < nrules; ++i)
    {
        if (rlhs[i] != rlhs[i-1])
        {
            if (i != 2) fprintf(f, "\n");
            fprintf(f, "%4d  %s :", i - 2, symbol_name[rlhs[i]]);
            spacing = strlen(symbol_name[rlhs[i]]) + 1;
        }
        else
        {
            fprintf(f, "%4d  ", i - 2);
            j = spacing;
            while (--j >= 0) putc(' ', f);
            putc('|', f);
        }

        while (ritem[k] >= 0)
        {
            fprintf(f, " %s", symbol_name[ritem[k]]);
            ++k;
        }
        ++k;
        putc('\n', f);
    }
}


#if defined(KYLEP_CHANGE)
void
#endif
reader()
{
    write_section(banner, defines_file);
    write_section(banner, code_file);
#if defined(TRIPLISH)
    if ( eTriplishParser == ParserChoice )
        write_section(includefiles, code_file);
#endif
    create_symbol_table();
    read_declarations();
    read_grammar();
    free_symbol_table();
    free_tags();
    pack_names();
    check_symbols();
    pack_symbols();
    pack_grammar();
    free_symbols();
    print_grammar();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\kbyacc\skeleton.c ===
#include "defs.h"

/*  The definition of yysccsid in the banner should be replaced with    */
/*  a #pragma ident directive if the target C compiler supports         */
/*  #pragma ident directives.                                           */
/*                                                                      */
/*  If the skeleton is changed, the banner should be changed so that    */
/*  the altered version can be easily distinguished from the original.  */
/*                                                                      */
/*  The #defines included with the banner are there because they are    */
/*  useful in subsequent code.  The macros #defined in the header or    */
/*  the body either are not useful outside of semantic actions or       */
/*  are conditional.                                                    */

char *banner[] =
{
    "#ifndef lint",
    "static char yysccsid[] = \"@(#)yaccpar     1.9 (Berkeley) 02/21/93\";",
    "#endif",
    "#define YYBYACC 1",
    "#define YYMAJOR 1",
    "#define YYMINOR 9",
    "#define yyclearin (yychar=(-1))",
    "#define yyerrok (yyerrflag=0)",
    "#define YYRECOVERING (yyerrflag!=0)",
    0
};

#if defined(TRIPLISH)
char *includefiles[] =
{
    "#include <pch.cxx>",
    "#pragma hdrstop",
    0
};
#endif // TRIPLISH

char *tables[] =
{
    "extern short yylhs[];",
    "extern short yylen[];",
    "extern short yydefred[];",
    "extern short yydgoto[];",
    "extern short yysindex[];",
    "extern short yyrindex[];",
    "extern short yygindex[];",
    "extern short yytable[];",
    "extern short yycheck[];",
    "#if YYDEBUG",
    "extern char *yyname[];",
    "extern char *yyrule[];",
    "#endif",
    0
};

#if defined(KYLEP_CHANGE)
char *header1[] =
{
    "#ifdef YYSTACKSIZE",
    "#undef YYMAXDEPTH",
    "#define YYMAXDEPTH YYSTACKSIZE",
    "#else",
    "#ifdef YYMAXDEPTH",
    "#define YYSTACKSIZE YYMAXDEPTH",
    "#else",
    "#define YYSTACKSIZE 500",
    "#define YYMAXDEPTH 500",
    "#endif",
    "#endif",
    "#define INITSTACKSIZE 30",
    0
};

char *header2[] =
{
    "{",
    "    friend class YYLEXER;",
    "public:",
    "",
    0
};

char *header3[] = 
{
    "",
    "    ~YYPARSER() {}",
    "",
    "    void ResetParser();             // Use to possibly restart parser",
    "    int  Parse();",
    "",
    "#ifdef YYAPI_VALUETYPE",
    "    YYAPI_VALUETYPE GetParseTree()      // Get result of parse",
    "                    {",
    "                        return yyval;",
    "                    }",
    "#endif",
    "",
    "    void EmptyValueStack( YYAPI_VALUETYPE yylval );",
    "    void PopVs();",
    "",
    "private:",
    "",
    "    int yydebug;",
    "    int yynerrs;",
    "    int yyerrflag;",
    "    int yychar;",
    "    short *yyssp;",
    "    YYSTYPE *yyvsp;",
    "    YYSTYPE yyval;",
    "    YYSTYPE yylval;",
    "    XGrowable<short, INITSTACKSIZE> xyyss;",
    "    CDynArrayInPlace<YYSTYPE> xyyvs;",
    "};",
    "#define yystacksize YYSTACKSIZE",
    0
};

#if defined(TRIPLISH)
char *header4[] = 
{
    "",
    "    ~YYPARSER() {}",
    "",
    "    int  Parse();",
    "",
    "#ifdef YYAPI_VALUETYPE",
    "    CDbRestriction* GetParseTree()          // Get result of parse",
    "    {",
    "        CDbRestriction* pRst = ((YYAPI_VALUETYPE)yyval).pRest;",
    "        _setRst.Remove( pRst );",
    "        Win4Assert( 0 == _setRst.Count() );",
    "        Win4Assert( 0 == _setStgVar.Count() );",
    "        Win4Assert( 0 == _setValueParser.Count() );",
    "        return pRst;",
    "    };",
    "#endif",
    "",
    "    void SetDebug() { yydebug = 1; }",
    "    void EmptyValueStack(YYAPI_VALUETYPE yylval) {}",
    "    void PopVs() { yyvsp--; }",
    "",
    "private:",
    "",
    "    int yydebug;",
    "    int yynerrs;",
    "    int yyerrflag;",
    "    int yychar;",
    "    short *yyssp;",
    "    YYSTYPE *yyvsp;",
    "    YYSTYPE yyval;",
    "    YYSTYPE yylval;",
    "    XGrowable<short, INITSTACKSIZE> xyyss;",
    "    CDynArrayInPlace<YYSTYPE> xyyvs;",
    "};",
    "#define yystacksize YYSTACKSIZE",
    0
};
#endif // TRIPLISH

#else // KYLEP_CHANGE
char *header[] =
{
    "#ifdef YYSTACKSIZE",
    "#undef YYMAXDEPTH",
    "#define YYMAXDEPTH YYSTACKSIZE",
    "#else",
    "#ifdef YYMAXDEPTH",
    "#define YYSTACKSIZE YYMAXDEPTH",
    "#else",
    "#define YYSTACKSIZE 500",
    "#define YYMAXDEPTH 500",
    "#endif",
    "#endif",
    "int yydebug;",
    "int yynerrs;",
    "int yyerrflag;",
    "int yychar;",
    "short *yyssp;",
    "YYSTYPE *yyvsp;",
    "YYSTYPE yyval;",
    "YYSTYPE yylval;",
    "short yyss[YYSTACKSIZE];",
    "YYSTYPE yyvs[YYSTACKSIZE];",
    "#define yystacksize YYSTACKSIZE",
    0
};
#endif // KYLEP_CHANGE

char *body[] =
{
#if defined(KYLEP_CHANGE)
    "#define YYABORT(sc) { EmptyValueStack( yylval ); return ResultFromScode(sc); }",
    "#define YYFATAL QPARSE_E_INVALID_QUERY",
    "#define YYSUCCESS S_OK",
#else
    "#define YYABORT goto yyabort",
#endif // KYLEP_CHANGE
    "#define YYREJECT goto yyabort",
    "#define YYACCEPT goto yyaccept",
#if !defined(KYLEP_CHANGE) // YYERROR is not being used
    "#define YYERROR goto yyerrlab",
#endif
#if defined(KYLEP_CHANGE)
    "int mystrlen(char * str)",
    "{",
    "    Win4Assert( 0 != str );",
    "    int i = 0;",
    "    while ( 0 != str[i] )",
    "        i++;",
    "    return i;        ",
    "}",
    "void YYPARSER::ResetParser()",
    "{",
    "     yynerrs = 0;",
    "    yyerrflag = 0;",
    "    yychar = (-1);",
    "",
    "yyssp = xyyss.Get();",
    "yyvsp = xyyvs.Get();",
    "    *yyssp = 0;",
    "}",
    "",
    "void YYPARSER::PopVs()",
    "{",
    "    if ( NULL != *yyvsp ) ",
    "        DeleteDBQT(*yyvsp);",
    "    yyvsp--;",
    "}",
    "",
    "void YYPARSER::EmptyValueStack( YYAPI_VALUETYPE yylval )",
    "{",
    "    if ( yyvsp != NULL ) ",
    "    {",
    "        if ((*yyvsp != yylval) && (NULL != yylval))",
    "            DeleteDBQT(yylval);",
    "",
    "        unsigned cCount = (unsigned)ULONG_PTR(yyvsp - xyyvs.Get());",
    "        for ( unsigned i=0; i < cCount; i++ )",
    "        {",
    "            if (NULL != xyyvs[i] )",
    "                DeleteDBQT(xyyvs[i]);",
    "        }",
    "    }",
    "",
    "   //@TODO RE-ACTIVATE",
    "   // note:  This was only done to empty any scope arrays",
    "   //      m_pIPSession->SetScopeProperties(m_pICommand);",
    "",
    "        m_pIPTProperties->SetContainsColumn(NULL);",
    "}",
    "",
#endif // KYLEP_CHANGE
#if defined(KYLEP_CHANGE)
    "int YYPARSER::Parse()",
#else
    "int",
    "yyparse()",
#endif // KYLEP_CHANGE
    "{",
    "    register int yym, yyn, yystate;",
    "#if YYDEBUG",
    "    register char *yys;",
    #if !defined(KYLEP_CHANGE)
    "    extern char *getenv();",
    #endif
    "",
    "    if (yys = getenv(\"YYDEBUG\"))",
    "    {",
    "        yyn = *yys;",
    "        if (yyn >= '0' && yyn <= '9')",
    "            yydebug = yyn - '0';",
    "    }",
    "#endif",
    "",
    "    yynerrs = 0;",
    "    yyerrflag = 0;",
    "    yychar = (-1);",
    "",
#if defined(KYLEP_CHANGE)
    "yyssp = xyyss.Get();",
    "yyvsp = xyyvs.Get();",
#else    
    "    yyssp = yyss;",
    "    yyvsp = yyvs;",
#endif    
    "    *yyssp = yystate = 0;",
    "",
    "yyloop:",
    "    if (yyn = yydefred[yystate]) goto yyreduce;",
    "    if (yychar < 0)",
    "    {",
#if defined(KYLEP_CHANGE)
    "        YYAPI_VALUENAME = NULL;",
    "        try",
    "        {",
    "            if ( (yychar = YYLEX(&YYAPI_VALUENAME)) < 0 ) ",
    "                yychar = 0;",
    "        }",
    "        catch (HRESULT hr)",
    "        {",
    "            switch(hr)",
    "            {",
    "            case E_OUTOFMEMORY:",
    "                m_pIPTProperties->SetErrorHResult(DB_E_ERRORSINCOMMAND, MONSQL_OUT_OF_MEMORY);",
    "                YYABORT(E_OUTOFMEMORY);",
    "                break;",
    "",
    "            default:",
    "                YYABORT(QPARSE_E_INVALID_QUERY);",
    "                break;",
    "            }",
    "        }",
#else
    "        if ((yychar = yylex()) < 0) yychar = 0;",
#endif // KYLEP_CHANGE
    "#if YYDEBUG",
    "        if (yydebug)",
    "        {",
    "            yys = 0;",
    "            if (yychar <= YYMAXTOKEN) yys = yyname[yychar];",
    "            if (!yys) yys = \"illegal-symbol\";",
    "            printf(\"%sdebug: state %d, reading %d (%s)\\n\",",
    "                    YYPREFIX, yystate, yychar, yys);",
    "        }",
    "#endif",
    "    }",
    "    if ((yyn = yysindex[yystate]) && (yyn += yychar) >= 0 &&",
    "            yyn <= YYTABLESIZE && yycheck[yyn] == yychar)",
    "    {",
    "#if YYDEBUG",
    "        if (yydebug)",
    "            printf(\"%sdebug: state %d, shifting to state %d\\n\",",
    "                    YYPREFIX, yystate, yytable[yyn]);",
    "#endif",
    #if defined(KYLEP_CHANGE) 
    "        if ( yyssp >= xyyss.Get() + xyyss.Count() - 1 )",
    "        {",
    "            int yysspLoc = (int) ( yyssp - xyyss.Get() );",
    "            xyyss.SetSize((unsigned) (yyssp-xyyss.Get())+2);",
    "            yyssp = xyyss.Get() + yysspLoc;",
    "        }",
    "        if ( yyvsp >= xyyvs.Get() + xyyvs.Size() - 1 )",
    "        {",
    "            int yyvspLoc = (int) ( yyvsp - xyyvs.Get() );",
    "            xyyvs.SetSize((unsigned) (yyvsp-xyyvs.Get())+2); ",
    "            yyvsp = xyyvs.Get() + yyvspLoc;",
    "        }",
    #else        
    "        if (yyssp >= yyss + yystacksize - 1)",
    "        {",
    "            goto yyoverflow;",
    "        }",
    #endif
    "        *++yyssp = yystate = yytable[yyn];",
    "        *++yyvsp = yylval;",
    "        yychar = (-1);",
    "        if (yyerrflag > 0)  --yyerrflag;",
    "        goto yyloop;",
    "    }",
    "    if ((yyn = yyrindex[yystate]) && (yyn += yychar) >= 0 &&",
    "            yyn <= YYTABLESIZE && yycheck[yyn] == yychar)",
    "    {",
    "        yyn = yytable[yyn];",
    "        goto yyreduce;",
    "    }",
    #if defined(KYLEP_CHANGE) 
    "#ifdef YYERROR_VERBOSE",
    "// error reporting; done before the goto error recovery",
    "{",
    "",
    "    // must be first - cleans m_pIPTProperties",
    "    m_pIPTProperties->SetErrorHResult(DB_E_ERRORSINCOMMAND, MONSQL_PARSE_ERROR);",
    "",
    "    int size = 0, totSize = 0;",
    "    int curr_yychar;",
    "    XGrowable<WCHAR> xMsg;",
    "    for ( curr_yychar =0; curr_yychar<=YYMAXTOKEN; curr_yychar++)",
    "    {",
    "    ",
    "        if ( ( yycheck[yysindex[yystate] + curr_yychar] == curr_yychar ) ||",
    "             ( yycheck[yyrindex[yystate] + curr_yychar] == curr_yychar ) )",
    "        {          ",
    "         ",
    "            char * token_name = yyname[curr_yychar];",
    "            if ( 0 != token_name )",
    "            {",
    "               if ( '_' == token_name[0] )",
    "                   token_name++;",
    "               size = mystrlen(token_name) + 1 ;",
    "               xMsg.SetSize(totSize+size+2); // +2 for \", \"",
    "               if (0 == MultiByteToWideChar(CP_ACP, 0, token_name, size,",
    "                                            xMsg.Get()+totSize, size))",
    "               {",
    "                    break;",
    "               }",
    "               totSize += size-1;",
    "               wcscpy( xMsg.Get()+totSize, L\", \" );",
    "               totSize+=2;",
    "            }",
    "        }",    
    "    }",
    "    // get rid of last comma",
    "    if ( totSize >= 2 ) ",
    "        (xMsg.Get())[totSize-2] = 0;",
    "",
    "    if ( wcslen((YY_CHAR*)m_yylex.YYText()) )",
    "         m_pIPTProperties->SetErrorToken( (YY_CHAR*)m_yylex.YYText() );",
    "    else",
    "         m_pIPTProperties->SetErrorToken(L\"<end of input>\");",
    "    ",
    "    m_pIPTProperties->SetErrorToken(xMsg.Get());",
    "}",
    "#endif //YYERROR_VERBOSE",
    #endif // KYLEP_CHANGE
    "    if (yyerrflag) goto yyinrecovery;",
    #if defined(KYLEP_CHANGE)
    "    yyerror(\"syntax error\");",
    "    ++yynerrs;",
    #else
    "#ifdef lint",
    "    goto yynewerror;",
    "#endif",
    "yynewerror:",
    "    yyerror(\"syntax error\");",
    "#ifdef lint",
    "    goto yyerrlab;",
    "#endif",
    "yyerrlab:",
    "    ++yynerrs;",
    #endif
    "yyinrecovery:",
    "    if (yyerrflag < 3)",
    "    {",
    "        yyerrflag = 3;",
    "        for (;;)",
    "        {",
    "            if ((yyn = yysindex[*yyssp]) && (yyn += YYERRCODE) >= 0 &&",
    "                    yyn <= YYTABLESIZE && yycheck[yyn] == YYERRCODE)",
    "            {",
    "#if YYDEBUG",
    "                if (yydebug)",
    "                    printf(\"%sdebug: state %d, error recovery shifting\\",
    " to state %d\\n\", YYPREFIX, *yyssp, yytable[yyn]);",
    "#endif",
    #if defined(KYLEP_CHANGE)
    "                if ( yyssp >= xyyss.Get() + xyyss.Count() - 1 )",
    "                {",
    "                    int yysspLoc = (int) ( yyssp - xyyss.Get() );",
    "                    xyyss.SetSize((unsigned) (yyssp-xyyss.Get())+2);",
    "                    yyssp = xyyss.Get() + yysspLoc;",
    "                }",
    "                if ( yyvsp >= xyyvs.Get() + xyyvs.Size() - 1 )",
    "                {",
    "                    int yyvspLoc = (int) ( yyvsp - xyyvs.Get() );",
    "                    xyyvs.SetSize((unsigned) (yyvsp-xyyvs.Get())+2); ",
    "                    yyvsp = xyyvs.Get() + yyvspLoc;",
    "                }",
    #else
    "                if (yyssp >= yyss + yystacksize - 1)",
    "                {",
    "                    goto yyoverflow;",
    "                }",
    #endif
    "                *++yyssp = yystate = yytable[yyn];",
    "                *++yyvsp = yylval;",
    "                goto yyloop;",
    "            }",
    "            else",
    "            {",
    "#if YYDEBUG",
    "                if (yydebug)",
    "                    printf(\"%sdebug: error recovery discarding state %d\\\n\",",
    "                            YYPREFIX, *yyssp);",
    "#endif",
    #if defined(KYLEP_CHANGE)
    "                if (yyssp <= xyyss.Get()) goto yyabort;",
    #else
    "                if (yyssp <= yyss) goto yyabort;",
    #endif
    "                PopVs();",
    "                --yyssp;",
    "            }",
    "        }",
    "    }",
    "    else",
    "    {",
    "        if (yychar == 0) goto yyabort;",
    "#if YYDEBUG",
    "        if (yydebug)",
    "        {",
    "            yys = 0;",
    "            if (yychar <= YYMAXTOKEN) yys = yyname[yychar];",
    "            if (!yys) yys = \"illegal-symbol\";",
    "            printf(\"%sdebug: state %d, error recovery discards token %d\
 (%s)\\n\",",
    "                    YYPREFIX, yystate, yychar, yys);",
    "        }",
    "#endif",
    "        yychar = (-1);",
    "        goto yyloop;",
    "    }",
    "yyreduce:",
    "#if YYDEBUG",
    "    if (yydebug)",
    "        printf(\"%sdebug: state %d, reducing by rule %d (%s)\\n\",",
    "                YYPREFIX, yystate, yyn, yyrule[yyn]);",
    "#endif",
    "    yym = yylen[yyn];",
    "    yyval = yyvsp[1-yym];",
    "    switch (yyn)",
    "    {",
    0
};

char *TriplishBody[] =
{
#if defined(KYLEP_CHANGE)
    "#define YYABORT(sc) { return ResultFromScode(sc); }",
    "#define YYFATAL   E_FAIL",
    "#define YYSUCCESS S_OK",
#else
    "#define YYABORT goto yyabort",
#endif // KYLEP_CHANGE
    "#define YYREJECT goto yyabort",
    "#define YYACCEPT goto yyaccept",
#if !defined(KYLEP_CHANGE) // YYERROR is not being used
    "#define YYERROR goto yyerrlab",
#endif
#if defined(KYLEP_CHANGE)
    "int YYPARSER::Parse()",
#else
    "int",
    "yyparse()",
#endif // KYLEP_CHANGE
    "{",
    "    register int yym, yyn, yystate;",
    "#if YYDEBUG",
    "    register char *yys;",
    #if !defined(KYLEP_CHANGE)
    "    extern char *getenv();",
    #endif
    "",
    "    if (yys = getenv(\"YYDEBUG\"))",
    "    {",
    "        yyn = *yys;",
    "        if (yyn >= '0' && yyn <= '9')",
    "            yydebug = yyn - '0';",
    "    }",
    "#endif",
    "",
    "    yynerrs = 0;",
    "    yyerrflag = 0;",
    "    yychar = (-1);",
    "",
#if defined(KYLEP_CHANGE)
    "yyssp = xyyss.Get();",
    "yyvsp = xyyvs.Get();",
#else    
    "    yyssp = yyss;",
    "    yyvsp = yyvs;",
#endif    
    "    *yyssp = yystate = 0;",
    "",
    "yyloop:",
    "    if (yyn = yydefred[yystate]) goto yyreduce;",
    "    if (yychar < 0)",
    "    {",
#if defined(KYLEP_CHANGE)
    "        try",
    "        {",
    "            if ( (yychar = YYLEX(&YYAPI_VALUENAME)) < 0 ) ",
    "                yychar = 0;",
    "        }",
    "        catch (HRESULT hr)",
    "        {",
    "            switch(hr)",
    "            {",
    "            case E_OUTOFMEMORY:",
    "                YYABORT(E_OUTOFMEMORY);",
    "                break;",
    "",
    "            default:",
    "                YYABORT(E_FAIL);",
    "                break;",
    "            }",
    "        }",
#else
    "        if ((yychar = yylex()) < 0) yychar = 0;",
#endif // KYLEP_CHANGE
    "#if YYDEBUG",
    "        if (yydebug)",
    "        {",
    "            yys = 0;",
    "            if (yychar <= YYMAXTOKEN) yys = yyname[yychar];",
    "            if (!yys) yys = \"illegal-symbol\";",
    "            printf(\"%sdebug: state %d, reading %d (%s)\\n\",",
    "                    YYPREFIX, yystate, yychar, yys);",
    "        }",
    "#endif",
    "    }",
    "    if ((yyn = yysindex[yystate]) && (yyn += yychar) >= 0 &&",
    "            yyn <= YYTABLESIZE && yycheck[yyn] == yychar)",
    "    {",
    "#if YYDEBUG",
    "        if (yydebug)",
    "            printf(\"%sdebug: state %d, shifting to state %d\\n\",",
    "                    YYPREFIX, yystate, yytable[yyn]);",
    "#endif",
    #if defined(KYLEP_CHANGE) 
    "        if ( yyssp >= xyyss.Get() + xyyss.Count() - 1 )",
    "        {",
    "            int yysspLoc = (int) ( yyssp - xyyss.Get() );",
    "            xyyss.SetSize((unsigned) (yyssp-xyyss.Get())+2);",
    "            yyssp = xyyss.Get() + yysspLoc;",
    "        }",
    "        if ( yyvsp >= xyyvs.Get() + xyyvs.Size() - 1 )",
    "        {",
    "            int yyvspLoc = (int) ( yyvsp - xyyvs.Get() );",
    "            xyyvs.SetSize((unsigned) (yyvsp-xyyvs.Get())+2);",
    "            yyvsp = xyyvs.Get() + yyvspLoc;",
    "        }",
    #else        
    "        if (yyssp >= yyss + yystacksize - 1)",
    "        {",
    "            goto yyoverflow;",
    "        }",
    #endif
    "        *++yyssp = yystate = yytable[yyn];",
    "        *++yyvsp = yylval;",
    "        yychar = (-1);",
    "        if (yyerrflag > 0)  --yyerrflag;",
    "        goto yyloop;",
    "    }",
    "    if ((yyn = yyrindex[yystate]) && (yyn += yychar) >= 0 &&",
    "            yyn <= YYTABLESIZE && yycheck[yyn] == yychar)",
    "    {",
    "        yyn = yytable[yyn];",
    "        goto yyreduce;",
    "    }",
    "    if (yyerrflag) goto yyinrecovery;",
    #if defined(KYLEP_CHANGE)
    "    yyerror(\"syntax error\");",
    "    ++yynerrs;",
    #else
    "#ifdef lint",
    "    goto yynewerror;",
    "#endif",
    "yynewerror:",
    "    yyerror(\"syntax error\");",
    "#ifdef lint",
    "    goto yyerrlab;",
    "#endif",
    "yyerrlab:",
    "    ++yynerrs;",
    #endif
    "yyinrecovery:",
    "    if (yyerrflag < 3)",
    "    {",
    "        yyerrflag = 3;",
    "        for (;;)",
    "        {",
    "            if ((yyn = yysindex[*yyssp]) && (yyn += YYERRCODE) >= 0 &&",
    "                    yyn <= YYTABLESIZE && yycheck[yyn] == YYERRCODE)",
    "            {",
    "#if YYDEBUG",
    "                if (yydebug)",
    "                    printf(\"%sdebug: state %d, error recovery shifting\\",
    " to state %d\\n\", YYPREFIX, *yyssp, yytable[yyn]);",
    "#endif",
    #if defined(KYLEP_CHANGE)
    "                if ( yyssp >= xyyss.Get() + xyyss.Count() - 1 )",
    "                {",
    "                    int yysspLoc = (int) ( yyssp - xyyss.Get() );",
    "                    xyyss.SetSize((unsigned) (yyssp-xyyss.Get())+2);",
    "                    yyssp = xyyss.Get() + yysspLoc;",
    "                }",
    "                if ( yyvsp >= xyyvs.Get() + xyyvs.Size() - 1 )",
    "                {",
    "                    int yyvspLoc = (int) ( yyvsp - xyyvs.Get() );",
    "                    xyyvs.SetSize((unsigned) (yyvsp-xyyvs.Get())+2);",
    "                    yyvsp = xyyvs.Get() + yyvspLoc;",
    "                }",
    #else
    "                if (yyssp >= yyss + yystacksize - 1)",
    "                {",
    "                    goto yyoverflow;",
    "                }",
    #endif
    "                *++yyssp = yystate = yytable[yyn];",
    "                *++yyvsp = yylval;",
    "                goto yyloop;",
    "            }",
    "            else",
    "            {",
    "#if YYDEBUG",
    "                if (yydebug)",
    "                    printf(\"%sdebug: error recovery discarding state %d\\n\",",
    "                            YYPREFIX, *yyssp);",
    "#endif",
    #if defined(KYLEP_CHANGE)
    "                if (yyssp <= xyyss.Get()) goto yyabort;",
    #else
    "                if (yyssp <= yyss) goto yyabort;",
    #endif
    "                --yyssp;",
    "                PopVs();",
    "            }",
    "        }",
    "    }",
    "    else",
    "    {",
    "        if (yychar == 0) goto yyabort;",
    "#if YYDEBUG",
    "        if (yydebug)",
    "        {",
    "            yys = 0;",
    "            if (yychar <= YYMAXTOKEN) yys = yyname[yychar];",
    "            if (!yys) yys = \"illegal-symbol\";",
    "            printf(\"%sdebug: state %d, error recovery discards token %d\
 (%s)\\n\",",
    "                    YYPREFIX, yystate, yychar, yys);",
    "        }",
    "#endif",
    "        yychar = (-1);",
    "        goto yyloop;",
    "    }",
    "yyreduce:",
    "#if YYDEBUG",
    "    if (yydebug)",
    "        printf(\"%sdebug: state %d, reducing by rule %d (%s)\\n\",",
    "                YYPREFIX, yystate, yyn, yyrule[yyn]);",
    "#endif",
    "    yym = yylen[yyn];",
    "    yyval = yyvsp[1-yym];",
    "    switch (yyn)",
    "    {",
    0
};

char *trailer[] =
{
    "    }",
    "    yyssp -= yym;",
    "    yystate = *yyssp;",
    "    yyvsp -= yym;",
    "    yym = yylhs[yyn];",
    "    if (yystate == 0 && yym == 0)",
    "    {",
    "#if YYDEBUG",
    "        if (yydebug)",
    "            printf(\"%sdebug: after reduction, shifting from state 0 to\\",
    " state %d\\n\", YYPREFIX, YYFINAL);",
    "#endif",
    "        yystate = YYFINAL;",
    "        *++yyssp = YYFINAL;",
    "        *++yyvsp = yyval;",
    "        if (yychar < 0)",
    "        {",
#if defined(KYLEP_CHANGE)
    "            YYAPI_VALUENAME = NULL;",
    "            try",
    "            {",
    "                if ( (yychar = YYLEX(&YYAPI_VALUENAME)) < 0 ) ",
    "                    yychar = 0;",
    "            }",
    "            catch (HRESULT hr)",
    "            {",
    "                switch(hr)",
    "                {",
    "                case E_OUTOFMEMORY:",
    "                    m_pIPTProperties->SetErrorHResult(DB_E_ERRORSINCOMMAND, MONSQL_OUT_OF_MEMORY);",
    "                    YYABORT(E_OUTOFMEMORY);",
    "                    break;",
    "",
    "                default:",
    "                    YYABORT(QPARSE_E_INVALID_QUERY);",
    "                    break;",
    "                }",
    "            }",
#else
    "            if ((yychar = yylex()) < 0) yychar = 0;",
#endif // KYLEP_CHANGE
    "#if YYDEBUG",
    "            if (yydebug)",
    "            {",
    "                yys = 0;",
    "                if (yychar <= YYMAXTOKEN) yys = yyname[yychar];",
    "                if (!yys) yys = \"illegal-symbol\";",
    "                printf(\"%sdebug: state %d, reading %d (%s)\\n\",",
    "                        YYPREFIX, YYFINAL, yychar, yys);",
    "            }",
    "#endif",
    "        }",
    "        if (yychar == 0) goto yyaccept;",
    "        goto yyloop;",
    "    }",
    "    if ((yyn = yygindex[yym]) && (yyn += yystate) >= 0 &&",
    "            yyn <= YYTABLESIZE && yycheck[yyn] == yystate)",
    "        yystate = yytable[yyn];",
    "    else",
    "        yystate = yydgoto[yym];",
    "#if YYDEBUG",
    "    if (yydebug)",
    "        printf(\"%sdebug: after reduction, shifting from state %d \\",
    "to state %d\\n\", YYPREFIX, *yyssp, yystate);",
    "#endif",
    #if defined(KYLEP_CHANGE)
    "    if ( yyssp >= xyyss.Get() + xyyss.Count() - 1 )",
    "    {",
    "        int yysspLoc = (int) ( yyssp - xyyss.Get() );",
    "        xyyss.SetSize((unsigned) ( yyssp-xyyss.Get())+2);",
    "        yyssp = xyyss.Get() + yysspLoc;",
    "    }",
    "    if ( yyvsp >= xyyvs.Get() + xyyvs.Size() - 1 )",
    "    {",
    "        int yyvspLoc = (int) ( yyvsp - xyyvs.Get() );",
    "        xyyvs.SetSize((unsigned) ( yyvsp-xyyvs.Get())+2);",
    "        yyvsp = xyyvs.Get() + yyvspLoc;",
    "    }",
    "    *++yyssp = (short) yystate;",
    #else
    "    if (yyssp >= yyss + yystacksize - 1)",
    "    {",
    "        goto yyoverflow;",
    "    }",
    "    *++yyssp = yystate;",
    #endif
    "    *++yyvsp = yyval;",
    "    goto yyloop;",
    #if !defined(KYLEP_CHANGE)
    "yyoverflow:",
    "    yyerror(\"yacc stack overflow\");",
    #endif
    "yyabort:",
    #if defined(KYLEP_CHANGE)
    "    EmptyValueStack(yylval);",
    "    return YYFATAL;",
    #else
    "    return (1);",
    #endif // KYLEP_CHANGE
    "yyaccept:",
    #if defined(KYLEP_CHANGE)
    "    return YYSUCCESS;",
    #else
    "    return (0);",
    #endif // KYLEP_CHANGE
    "}",
    0
};

char *TriplishTrailer[] =
{
    "    }",
    "    yyssp -= yym;",
    "    yystate = *yyssp;",
    "    yyvsp -= yym;",
    "    yym = yylhs[yyn];",
    "    if (yystate == 0 && yym == 0)",
    "    {",
    "#if YYDEBUG",
    "        if (yydebug)",
    "            printf(\"%sdebug: after reduction, shifting from state 0 to\\",
    " state %d\\n\", YYPREFIX, YYFINAL);",
    "#endif",
    "        yystate = YYFINAL;",
    "        *++yyssp = YYFINAL;",
    "        *++yyvsp = yyval;",
    "        if (yychar < 0)",
    "        {",
#if defined(KYLEP_CHANGE)
    "            try",
    "            {",
    "                if ( (yychar = YYLEX(&YYAPI_VALUENAME)) < 0 ) ",
    "                    yychar = 0;",
    "            }",
    "            catch (HRESULT hr)",
    "            {",
    "                switch(hr)",
    "                {",
    "                case E_OUTOFMEMORY:",
    "                    YYABORT(E_OUTOFMEMORY);",
    "                    break;",
    "",
    "                default:",
    "                    YYABORT(E_FAIL);",
    "                    break;",
    "                }",
    "            }",
#else
    "            if ((yychar = yylex()) < 0) yychar = 0;",
#endif // KYLEP_CHANGE
    "#if YYDEBUG",
    "            if (yydebug)",
    "            {",
    "                yys = 0;",
    "                if (yychar <= YYMAXTOKEN) yys = yyname[yychar];",
    "                if (!yys) yys = \"illegal-symbol\";",
    "                printf(\"%sdebug: state %d, reading %d (%s)\\n\",",
    "                        YYPREFIX, YYFINAL, yychar, yys);",
    "            }",
    "#endif",
    "        }",
    "        if (yychar == 0) goto yyaccept;",
    "        goto yyloop;",
    "    }",
    "    if ((yyn = yygindex[yym]) && (yyn += yystate) >= 0 &&",
    "            yyn <= YYTABLESIZE && yycheck[yyn] == yystate)",
    "        yystate = yytable[yyn];",
    "    else",
    "        yystate = yydgoto[yym];",
    "#if YYDEBUG",
    "    if (yydebug)",
    "        printf(\"%sdebug: after reduction, shifting from state %d \\",
    "to state %d\\n\", YYPREFIX, *yyssp, yystate);",
    "#endif",
    #if defined(KYLEP_CHANGE)
    "    if ( yyssp >= xyyss.Get() + xyyss.Count() - 1 )",
    "    {",
    "        int yysspLoc = (int) ( yyssp - xyyss.Get() );",
    "        xyyss.SetSize((unsigned) ( yyssp-xyyss.Get())+2);",
    "        yyssp = xyyss.Get() + yysspLoc;",
    "    }",
    "    if ( yyvsp >= xyyvs.Get() + xyyvs.Size() - 1 )",
    "    {",
    "        int yyvspLoc = (int) ( yyssp - xyyss.Get() );",
    "        xyyvs.SetSize((unsigned) ( yyvsp-xyyvs.Get())+2);",
    "        yyvsp = xyyvs.Get() + yyvspLoc;",
    "    }",
    "    *++yyssp = (short) yystate;",
    #else
    "    if (yyssp >= yyss + yystacksize - 1)",
    "    {",
    "        goto yyoverflow;",
    "    }",
    "    *++yyssp = yystate;",
    #endif
    "    *++yyvsp = yyval;",
    "    goto yyloop;",
    #if !defined(KYLEP_CHANGE)
    "yyoverflow:",
    "    yyerror(\"yacc stack overflow\");",
    #endif
    "yyabort:",
    #if defined(KYLEP_CHANGE)
    "   EmptyValueStack(yylval);",
    "    return YYFATAL;",
    #else
    "    return (1);",
    #endif // KYLEP_CHANGE
    "yyaccept:",
    #if defined(KYLEP_CHANGE)
    "    return YYSUCCESS;",
    #else
    "    return (0);",
    #endif // KYLEP_CHANGE
    "}",
    0
};

#if defined(KYLEP_CHANGE)
void write_section(section,f)
char *section[];
FILE *f;
#else
write_section(section)
char *section[];
#endif // KYLEP_CHANGE
{
    register int c;
    register int i;
    register char *s;
    #if !defined(KYLEP_CHANGE)
    register FILE *f;

    f = code_file;
    #endif // !KYLEP_CHANGE
    for (i = 0; s = section[i]; ++i)
    {
        ++outline;
        while (c = *s)
        {
            putc(c, f);
            ++s;
        }
        putc('\n', f);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\kbyacc\verbose.c ===
#include "defs.h"

#if defined(KYLEP_CHANGE)
/* BYACC prototypes, with type safety */

void print_state( int state );
void log_unused();
void log_conflicts();
void print_conflicts( int state );
void print_core( int state );
void print_nulls( int state );
void print_actions( int stateno );
void print_shifts( register action *p );
void print_reductions( register action *p, register int defred );
void print_gotos( int stateno );
#endif // KYLEP_CHANGE

static short *null_rules;

#if defined(KYLEP_CHANGE)
void
#endif
verbose()
{
    register int i;

    if (!vflag) return;

    null_rules = (short *) MALLOC(nrules*sizeof(short));
    if (null_rules == 0) no_space();
    fprintf(verbose_file, "\f\n");
    for (i = 0; i < nstates; i++)
        print_state(i);
    FREE(null_rules);

    if (nunused)
        log_unused();
    if (SRtotal || RRtotal)
        log_conflicts();

    fprintf(verbose_file, "\n\n%d terminals, %d nonterminals\n", ntokens,
            nvars);
    fprintf(verbose_file, "%d grammar rules, %d states\n", nrules - 2, nstates);
}


#if defined(KYLEP_CHANGE)
void
#endif
log_unused()
{
    register int i;
    register short *p;

    fprintf(verbose_file, "\n\nRules never reduced:\n");
    for (i = 3; i < nrules; ++i)
    {
        if (!rules_used[i])
        {
            fprintf(verbose_file, "\t%s :", symbol_name[rlhs[i]]);
            for (p = ritem + rrhs[i]; *p >= 0; ++p)
                fprintf(verbose_file, " %s", symbol_name[*p]);
            fprintf(verbose_file, "  (%d)\n", i - 2);
        }
    }
}


#if defined(KYLEP_CHANGE)
void
#endif
log_conflicts()
{
    register int i;

    fprintf(verbose_file, "\n\n");
    for (i = 0; i < nstates; i++)
    {
        if (SRconflicts[i] || RRconflicts[i])
        {
            fprintf(verbose_file, "State %d contains ", i);
            if (SRconflicts[i] == 1)
                fprintf(verbose_file, "1 shift/reduce conflict");
            else if (SRconflicts[i] > 1)
                fprintf(verbose_file, "%d shift/reduce conflicts",
                        SRconflicts[i]);
            if (SRconflicts[i] && RRconflicts[i])
                fprintf(verbose_file, ", ");
            if (RRconflicts[i] == 1)
                fprintf(verbose_file, "1 reduce/reduce conflict");
            else if (RRconflicts[i] > 1)
                fprintf(verbose_file, "%d reduce/reduce conflicts",
                        RRconflicts[i]);
            fprintf(verbose_file, ".\n");
        }
    }
}


#if defined(KYLEP_CHANGE)
void
#endif
print_state(state)
int state;
{
    if (state)
        fprintf(verbose_file, "\n\n");
    if (SRconflicts[state] || RRconflicts[state])
        print_conflicts(state);
    fprintf(verbose_file, "state %d\n", state);
    print_core(state);
    print_nulls(state);
    print_actions(state);
}


#if defined(KYLEP_CHANGE)
void
#endif
print_conflicts(state)
int state;
{
    register int symbol, act, number;
    register action *p;

    symbol = -1;
    for (p = parser[state]; p; p = p->next)
    {
        if (p->suppressed == 2)
            continue;

        if (p->symbol != symbol)
        {
            symbol = p->symbol;
            number = p->number;
            if (p->action_code == SHIFT)
                act = SHIFT;
            else
                act = REDUCE;
        }
        else if (p->suppressed == 1)
        {
            if (state == final_state && symbol == 0)
            {
                fprintf(verbose_file, "%d: shift/reduce conflict \
(accept, reduce %d) on $end\n", state, p->number - 2);
            }
            else
            {
                if (act == SHIFT)
                {
                    fprintf(verbose_file, "%d: shift/reduce conflict \
(shift %d, reduce %d) on %s\n", state, number, p->number - 2,
                            symbol_name[symbol]);
                }
                else
                {
                    fprintf(verbose_file, "%d: reduce/reduce conflict \
(reduce %d, reduce %d) on %s\n", state, number - 2, p->number - 2,
                            symbol_name[symbol]);
                }
            }
        }
    }
}


#if defined(KYLEP_CHANGE)
void
#endif
print_core(state)
int state;
{
    register int i;
    register int k;
    register int rule;
    register core *statep;
    register short *sp;
    register short *sp1;

    statep = state_table[state];
    k = statep->nitems;

    for (i = 0; i < k; i++)
    {
        sp1 = sp = ritem + statep->items[i];

        while (*sp >= 0) ++sp;
        rule = -(*sp);
        fprintf(verbose_file, "\t%s : ", symbol_name[rlhs[rule]]);

        for (sp = ritem + rrhs[rule]; sp < sp1; sp++)
            fprintf(verbose_file, "%s ", symbol_name[*sp]);

        putc('.', verbose_file);

        while (*sp >= 0)
        {
            fprintf(verbose_file, " %s", symbol_name[*sp]);
            sp++;
        }
        fprintf(verbose_file, "  (%d)\n", -2 - *sp);
    }
}


#if defined(KYLEP_CHANGE)
void
#endif
print_nulls(state)
int state;
{
    register action *p;
    register int i, j, k, nnulls;

    nnulls = 0;
    for (p = parser[state]; p; p = p->next)
    {
        if (p->action_code == REDUCE &&
                (p->suppressed == 0 || p->suppressed == 1))
        {
            i = p->number;
            if (rrhs[i] + 1 == rrhs[i+1])
            {
                for (j = 0; j < nnulls && i > null_rules[j]; ++j)
                    continue;

                if (j == nnulls)
                {
                    ++nnulls;
                    #if defined(KYLEP_CHANGE)                             
                    null_rules[j] = (short) i;
                    #else
                    null_rules[j] = i;
                    #endif // KYLEP_CHANGE
                }
                else if (i != null_rules[j])
                {
                    ++nnulls;
                    for (k = nnulls - 1; k > j; --k)
                        null_rules[k] = null_rules[k-1];
                    #if defined(KYLEP_CHANGE)                             
                    null_rules[j] = (short) i;
                    #else
                    null_rules[j] = i;
                    #endif // KYLEP_CHANGE
                }
            }
        }
    }

    for (i = 0; i < nnulls; ++i)
    {
        j = null_rules[i];
        fprintf(verbose_file, "\t%s : .  (%d)\n", symbol_name[rlhs[j]],
                j - 2);
    }
    fprintf(verbose_file, "\n");
}


#if defined(KYLEP_CHANGE)
void
#endif
print_actions(stateno)
int stateno;
{
    register action *p;
    register shifts *sp;
    register int as;

    if (stateno == final_state)
        fprintf(verbose_file, "\t$end  accept\n");

    p = parser[stateno];
    if (p)
    {
        print_shifts(p);
        print_reductions(p, defred[stateno]);
    }

    sp = shift_table[stateno];
    if (sp && sp->nshifts > 0)
    {
        as = accessing_symbol[sp->shift[sp->nshifts - 1]];
        if (ISVAR(as))
            print_gotos(stateno);
    }
}


#if defined(KYLEP_CHANGE)
void
#endif
print_shifts(p)
register action *p;
{
    register int count;
    register action *q;

    count = 0;
    for (q = p; q; q = q->next)
    {
        if (q->suppressed < 2 && q->action_code == SHIFT)
            ++count;
    }

    if (count > 0)
    {
        for (; p; p = p->next)
        {
            if (p->action_code == SHIFT && p->suppressed == 0)
                fprintf(verbose_file, "\t%s  shift %d\n",
                            symbol_name[p->symbol], p->number);
        }
    }
}


#if defined(KYLEP_CHANGE)
void
#endif
print_reductions(p, defred)
register action *p;
register int defred;
{
    register int k, anyreds;
    register action *q;

    anyreds = 0;
    for (q = p; q ; q = q->next)
    {
        if (q->action_code == REDUCE && q->suppressed < 2)
        {
            anyreds = 1;
            break;
        }
    }

    if (anyreds == 0)
        fprintf(verbose_file, "\t.  error\n");
    else
    {
        for (; p; p = p->next)
        {
            if (p->action_code == REDUCE && p->number != defred)
            {
                k = p->number - 2;
                if (p->suppressed == 0)
                    fprintf(verbose_file, "\t%s  reduce %d\n",
                            symbol_name[p->symbol], k);
            }
        }

        if (defred > 0)
            fprintf(verbose_file, "\t.  reduce %d\n", defred - 2);
    }
}


#if defined(KYLEP_CHANGE)
void
#endif
print_gotos(stateno)
int stateno;
{
    register int i, k;
    register int as;
    register short *to_state;
    register shifts *sp;

    putc('\n', verbose_file);
    sp = shift_table[stateno];
    to_state = sp->shift;
    for (i = 0; i < sp->nshifts; ++i)
    {
        k = to_state[i];
        as = accessing_symbol[k];
        if (ISVAR(as))
            fprintf(verbose_file, "\t%s  goto %d\n", symbol_name[as], k);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\kbyacc\symtab.c ===
#include "defs.h"


/* TABLE_SIZE is the number of entries in the symbol table. */
/* TABLE_SIZE must be a power of two.			    */

#define	TABLE_SIZE 1024


bucket **symbol_table;
bucket *first_symbol;
bucket *last_symbol;


int
hash(name)
char *name;
{
    register char *s;
    register int c, k;

    assert(name && *name);
    s = name;
    k = *s;
    while (c = *++s)
	k = (31*k + c) & (TABLE_SIZE - 1);

    return (k);
}


bucket *
make_bucket(name)
char *name;
{
    register bucket *bp;

    assert(name);
    bp = (bucket *) MALLOC(sizeof(bucket));
    if (bp == 0) no_space();
    bp->link = 0;
    bp->next = 0;
    bp->name = MALLOC(strlen(name) + 1);
    if (bp->name == 0) no_space();
    bp->tag = 0;
    bp->value = UNDEFINED;
    bp->index = 0;
    bp->prec = 0;
    bp-> class = UNKNOWN;
    bp->assoc = TOKEN;

    if (bp->name == 0) no_space();
    strcpy(bp->name, name);

    return (bp);
}


bucket *
lookup(name)
char *name;
{
    register bucket *bp, **bpp;

    bpp = symbol_table + hash(name);
    bp = *bpp;

    while (bp)
    {
	if (strcmp(name, bp->name) == 0) return (bp);
	bpp = &bp->link;
	bp = *bpp;
    }

    *bpp = bp = make_bucket(name);
    last_symbol->next = bp;
    last_symbol = bp;

    return (bp);
}


#if defined(KYLEP_CHANGE)
void
#endif
create_symbol_table()
{
    register int i;
    register bucket *bp;

    symbol_table = (bucket **) MALLOC(TABLE_SIZE*sizeof(bucket *));
    if (symbol_table == 0) no_space();
    for (i = 0; i < TABLE_SIZE; i++)
	symbol_table[i] = 0;

    bp = make_bucket("error");
    bp->index = 1;
    bp->class = TERM;

    first_symbol = bp;
    last_symbol = bp;
    symbol_table[hash("error")] = bp;
}


#if defined(KYLEP_CHANGE)
void
#endif
free_symbol_table()
{
    FREE(symbol_table);
    symbol_table = 0;
}


#if defined(KYLEP_CHANGE)
void
#endif
free_symbols()
{
    register bucket *p, *q;

    for (p = first_symbol; p; p = q)
    {
	q = p->next;
	FREE(p);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\keysmith\keymak.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1991 - 2000
//
//  File:       KEYMAK.CXX
//
//  Contents:   Key maker
//
//  Classes:    CKeyMaker
//
//  History:    31-Jan-92   BartoszM    Created
//              24-Apr-95   SitaramR    Removed US/Fake stemmer and added
//                                      Infosoft stemmer
//
//  Notes:      The filtering pipeline is hidden in the Data Repository
//              object which serves as a sink for the filter.
//              The sink for the Data Repository is the Key Repository.
//              The language dependent part of the pipeline
//              is obtained from the Language List object and is called
//              Language Dependent Key Maker. It consists of:
//
//                  Word Breaker
//                  Stemmer (optional)
//                  Normalizer
//                  Noise List
//
//              Each object serves as a sink for its predecessor,
//              Key Repository is the final sink.
//
//----------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include <lang.hxx>
#include <keymak.hxx>
#include <noise.hxx>
#include <norm.hxx>
#include <stemsink.hxx>

//+---------------------------------------------------------------------------
//
//  Member:     CKeyMaker::CKeyMaker
//
//  Synopsis:   Constructs a language-dependant key maker object
//
//  Effects:    Creates a noiselist, normalizer and borrows a wordbreaker, stemmer
//
//  Arguments:  [locale] -- language locale
//              [krep] -- key repository to place completed keys in
//              [pPhraseSink] -- sink for collecting phrases
//              [fQuery] -- true if this is during querying
//              [ulFuzzy] -- fuzzy level of query
//
//  History:    05-June-91  t-WadeR     Created.
//              12-Oct-92   AmyA        Added Unicode support
//
//----------------------------------------------------------------------------

CKeyMaker::CKeyMaker( LCID locale,
                      PROPID pid,
                      PKeyRepository& krep,
                      IPhraseSink *pPhraseSink,
                      BOOL fQuery,
                      ULONG ulFuzzy,
                      CLangList & langList )
           : _pPhraseSink(pPhraseSink),
             _fQuery( fQuery ),
             _sLang( locale, pid, &langList, fQuery ? LANG_LOAD_ALL : LANG_LOAD_NO_STEMMER ),
             _lcid( locale ),
             _pid( pid )
{
    krep.GetSourcePosBuffers (&_pcwcSrcPos, &_pcwcSrcLen );

    CStringTable* noiseTable;

    //
    // Don't remove noise words if we're doing prefix matching.  The noise
    // *word* is potentially only a prefix for a non-noise word.
    //

    if (GENERATE_METHOD_PREFIX == ulFuzzy )
        noiseTable = 0;
    else
        noiseTable = _sLang->GetNoiseTable();

    if ( noiseTable != 0 )
        _xNoiseList.Set( new CNoiseList( *noiseTable, krep ) );
    else
        _xNoiseList.Set( new CNoiseListEmpty( krep, ulFuzzy ) );

    _xWordRep.Set( new CNormalizer( _xNoiseList.GetReference() ) );

    // Get Normalizer's buffer length
    _cwcMaxNormBuf = _xWordRep->GetMaxBufferLen();

    // get stemmer (optional)
    if ( ulFuzzy == GENERATE_METHOD_STEMMED )
    {
        IStemmer *pStemmer = _sLang->GetStemmer();

        if ( pStemmer )
        {
            BOOL fCopyright;
            SCODE sc = pStemmer->Init( _cwcMaxNormBuf, &fCopyright );

            if ( FAILED(sc) )
            {
                ciDebugOut(( DEB_ERROR, "IStemmer::Init returned 0x%x\n", sc ));
                THROW( CException( sc ) );
            }

            if ( fCopyright )
            {
                WCHAR const * pLicense;
                sc = pStemmer->GetLicenseToUse( &pLicense );

                if ( SUCCEEDED(sc) )
                {
                    ciDebugOut(( DEB_WORDS, "%ws\n", pLicense ));
                }
                else
                {
                    ciDebugOut(( DEB_ERROR, "IStemmer::GetLicenseToUse returned 0x%x\n", sc ));
                    THROW( CException( sc ) );
                }
            }

            _xWordRep2.Set( _xWordRep.Acquire() );
            _xWordRep.Set( new CStemmerSink( pStemmer, _xWordRep2.GetReference() ) );
        }
        else
        {
            ciDebugOut(( DEB_ERROR,
                         "Fuzzy2 query, but no stemmer available for locale 0x%x\n",
                         locale ));
        }
    }

    //
    // Initialize word breaker
    //
    _pWBreak = _sLang->GetWordBreaker();

    Win4Assert( _pWBreak );

    BOOL fCopyright;
    SCODE sc = _pWBreak->Init( fQuery, _cwcMaxNormBuf, &fCopyright );

    if ( FAILED(sc) )
    {
        ciDebugOut(( DEB_ERROR, "IWordBreaker::Init returned 0x%x\n", sc ));
        THROW( CException( sc ) );
    }

    if ( fCopyright )
    {
        WCHAR const * pLicense;
        sc = _pWBreak->GetLicenseToUse( &pLicense );

        if ( SUCCEEDED(sc) )
        {
            ciDebugOut(( DEB_WORDS, "%ws\n", pLicense ));
        }
        else
        {
            ciDebugOut(( DEB_ERROR, "IWordBreaker::GetLicenseToUse returned 0x%x\n", sc ));
            THROW( CException( sc ) );
        }
    }
} //CKeyMaker

//+---------------------------------------------------------------------------
//
//  Member:     CKeyMaker::CKeyMaker
//
//  Synopsis:   Constructs key maker for noise word list initialization.
//
//  Arguments:  [pWBreak] -- word breaker
//              [Noise] -- noise word list
//
//  History:    05-June-91  t-WadeR     Created.
//              12-Oct-92   AmyA        Added Unicode support
//
//----------------------------------------------------------------------------

CKeyMaker::CKeyMaker( IWordBreaker * pWBreak, PNoiseList & Noise )
        : _pWBreak( pWBreak ),
          _pPhraseSink(0),
          _fQuery(FALSE)
{
    _xWordRep.Set( new CNormalizer( Noise ) );

    // Get Normalizer's buffer length
    _cwcMaxNormBuf = _xWordRep->GetMaxBufferLen();

    _pcwcSrcPos = 0;    // We don't use them!
    _pcwcSrcLen = 0;

    //
    // Initialize word breaker
    //
    Win4Assert( _pWBreak );

    BOOL fCopyright;
    SCODE sc = _pWBreak->Init( FALSE, _cwcMaxNormBuf, &fCopyright );

    if ( FAILED(sc) )
    {
        ciDebugOut(( DEB_ERROR, "IWordBreaker::Init returned 0x%x\n", sc ));
        THROW( CException( sc ) );
    }

    if ( fCopyright )
    {
        WCHAR const * pLicense;
        sc = _pWBreak->GetLicenseToUse( &pLicense );

        if ( SUCCEEDED(sc) )
        {
            ciDebugOut(( DEB_WORDS, "%ws\n", pLicense ));
        }
        else
        {
            ciDebugOut(( DEB_ERROR, "IWordBreaker::GetLicenseToUse returned 0x%x\n", sc ));
            THROW( CException( sc ) );
        }
    }
} //CKeyMaker

//+---------------------------------------------------------------------------
//
//  Member:     CKeyMaker::~CKeyMaker
//
//  Synopsis:   destroys a key maker object
//
//  History:    05-June-91   t-WadeR     Created.
//
//----------------------------------------------------------------------------
CKeyMaker::~CKeyMaker()
{
}

//
// The following are needed to make midl happy.  There are no other interfaces
// to bind to.  Inheritance from IUnknown is unnecessary.
//

SCODE STDMETHODCALLTYPE CKeyMaker::QueryInterface(REFIID riid, void  * * ppvObject)
{
    *ppvObject = 0;
    return( E_NOTIMPL );
}

ULONG STDMETHODCALLTYPE CKeyMaker::AddRef()
{
    return( 1 );
}

ULONG STDMETHODCALLTYPE CKeyMaker::Release()
{
    return( 1 );
}

//+-------------------------------------------------------------------------
//
//  Method:     CKeyMaker::PutWord
//
//  Synopsis:   Store word in word repository
//
//  Arguments:  [cwc]      -- Count of characters in [pwcInBuf]
//              [pwcInBuf] -- Word
//              [cwcSrcLen] -- count of characters in pTextSource buffer (see IWordBreaker::BreakText)
//              [cwcSrcPos] -- position of word in pTextSource buffer
//
//  History:    19-Apr-1994   KyleP     Created
//
//--------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE CKeyMaker::PutWord( ULONG cwc,
                                            WCHAR const *pwcInBuf,
                                            ULONG cwcSrcLen,
                                            ULONG cwcSrcPos )
{
    SCODE sc = S_OK;

    // validate PutWord call
    if ( !_altWordsEnforcer.IsPutWordOk() )
    {
        Win4Assert( !"CKeyMaker::PutWord - invalid state" );
        ciDebugOut(( DEB_ITRACE, "PutWord: %.*ws\n", cwc, pwcInBuf ));

        return E_FAIL;
    }

    CTranslateSystemExceptions translate;

    TRY
    {
        if ( cwc > _cwcMaxNormBuf )
        {
            sc = LANGUAGE_S_LARGE_WORD;
            cwc = _cwcMaxNormBuf;
        }
    
        if ( cwc > 0 )
        {
            #if CIDBG == 1
                if ( ciInfoLevel & DEB_WORDS )
                {
                    //
                    // Check for 'printable' characters.
                    //
        
                    BOOL fOk = TRUE;
        
                    for ( unsigned i = 0; i < cwc; i++ )
                    {
                        if ( pwcInBuf[i] > 0xFF )
                        {
                            fOk = FALSE;
                            break;
                        }
                    }
        
                    if ( fOk )
                        ciDebugOut(( DEB_WORDS,
                                     "PutWord: \"%.*ws\"  Occ = %d cwcSrcLen = %d, cwcSrcPos = %d\n",
                                     cwc, pwcInBuf, _xWordRep->GetOccurrence(), cwcSrcLen, cwcSrcPos ));
                    else
                    {
                        ciDebugOut(( DEB_WORDS, "PutWord:" ));
        
                        for ( i = 0; i < cwc; i++ )
                            ciDebugOut(( DEB_WORDS | DEB_NOCOMPNAME, " %04X", pwcInBuf[i] ));
        
                        ciDebugOut(( DEB_WORDS | DEB_NOCOMPNAME,
                                     "  Occ = %d cwcSrcLen = %d, cwcSrcPos = %d\n",
                                     _xWordRep->GetOccurrence(), cwcSrcLen, cwcSrcPos ));
                    }
                }
            #endif // CIDBG
    
            //
            // No internal call to PutAltWord for performance reasons.
            //
    
            if (0 != _pcwcSrcPos)
            {
                Win4Assert ( 0 != _pcwcSrcLen );
                *_pcwcSrcLen = cwcSrcLen;
                *_pcwcSrcPos = cwcSrcPos;
            }
    
            _xWordRep->ProcessWord( pwcInBuf, cwc );
        }
    }
    CATCH( CException, e )
    {
        sc = e.GetErrorCode();
    }
    END_CATCH;

    return sc;
} //PutWord

//+-------------------------------------------------------------------------
//
//  Method:     CKeyMaker::PutAltWord
//
//  Synopsis:   Store alternate word in word repository.
//
//  Effects:    Identical to PutWord except occurrence count is not
//              incremented.
//
//  Arguments:  [cwc]      -- Count of characters in [pwcInBuf]
//              [pwcInBuf] -- Word
//              [cwcSrcLen] -- count of characters in pTextSource buffer (see IWordBreaker::BreakText)
//              [cwcSrcPos] -- position of word in pTextSource buffer
//
//  History:    19-Apr-1994  KyleP      Created
//
//--------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE CKeyMaker::PutAltWord( ULONG cwc,
                                               WCHAR const *pwcInBuf,
                                               ULONG cwcSrcLen,
                                               ULONG cwcSrcPos )
{
    SCODE sc = S_OK;

    // validate PutWord call

    if ( !_altWordsEnforcer.IsPutAltWordOk() )
    {
        Win4Assert( !"CKeyMaker::PutAltWord - invalid state" );
        ciDebugOut(( DEB_ITRACE, "PutAltWord: %.*ws\n", cwc, pwcInBuf ));

        return E_FAIL;
    }

    CTranslateSystemExceptions translate;

    TRY
    {
        //
        // What is to be done if two large, alternate words end up with the
        // same (truncated) prefix after truncation ?
        // This is fixed in Babylon and isn't a problem here.
        //
        if ( cwc > _cwcMaxNormBuf )
        {
            sc = LANGUAGE_S_LARGE_WORD;
            cwc = _cwcMaxNormBuf;
        }
    
        if ( cwc > 0 )
        {
            ciDebugOut(( DEB_WORDS,
                         "PutAltWord: \"%.*ws\"  Occ = %d cwcSrcLen = %d, cwcSrcPos = %d\n",
                         cwc, pwcInBuf, _xWordRep->GetOccurrence(), cwcSrcLen, cwcSrcPos ));
    
            if (0 != _pcwcSrcPos)
            {
                Win4Assert ( 0 != _pcwcSrcLen );
                *_pcwcSrcLen = cwcSrcLen;
                *_pcwcSrcPos = cwcSrcPos;
            }
    
            _xWordRep->ProcessAltWord( pwcInBuf, cwc );
        }
    }
    CATCH( CException, e )
    {
        sc = e.GetErrorCode();
    }
    END_CATCH;

    return sc;
} //PutAltWord

//+-------------------------------------------------------------------------
//
//  Method:     CKeyMaker::StartAltPhrase
//
//  Synopsis:   Pass on StartAltPhrase to word repository
//
//  History:    24-Apr-1994   KyleP      Created
//
//--------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE CKeyMaker::StartAltPhrase()
{
    SCODE sc = S_OK;

    CTranslateSystemExceptions translate;

    TRY
    {
        if ( _fQuery )
        {
            // validate StartAltPhrase call
            if ( !_altWordsEnforcer.IsStartAltPhraseOk() || !_altPhrasesEnforcer.IsStartAltPhraseOk() )
            {
                Win4Assert( !"CKeyMaker::StartAltPhrase - invalid state" );
    
                THROW( CException( E_FAIL ) );
            }
    
            _xWordRep->StartAltPhrase();
        }
        else
            sc = WBREAK_E_QUERY_ONLY;
    }
    CATCH( CException, e )
    {
        sc = e.GetErrorCode();
    }
    END_CATCH;

    return sc;
} //StartAltPhrase

//+-------------------------------------------------------------------------
//
//  Method:     CKeyMaker::EndAltPhrase
//
//  Synopsis:   Pass on EndAltPhrase to word repository
//
//  History:    24-Apr-1994   KyleP      Created
//
//--------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE CKeyMaker::EndAltPhrase()
{
    SCODE sc = S_OK;

    CTranslateSystemExceptions translate;

    TRY
    {
        if ( _fQuery )
        {
            // validate EndAltPhrase call
            if ( !_altWordsEnforcer.IsEndAltPhraseOk() || !_altPhrasesEnforcer.IsEndAltPhraseOk() )
            {
                Win4Assert( !"CKeyMaker::EndAltPhrase - invalid state" );
    
                THROW( CException( E_FAIL ) );
            }
    
            _xWordRep->EndAltPhrase();
        }
        else
            sc = WBREAK_E_QUERY_ONLY;
    }
    CATCH( CException, e )
    {
        sc = e.GetErrorCode();
    }
    END_CATCH;

    return sc;
} //EndAltPhrase

//+-------------------------------------------------------------------------
//
//  Method:     CKeyMaker::PutBreak
//
//  Synopsis:   Increment the occurrence count appropriately
//
//  History:    24-Apr-1994   KyleP      Created
//
//--------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE CKeyMaker::PutBreak( WORDREP_BREAK_TYPE breakType )
{
    // We are modeling PutBreak by a skip of the appropriate number of noise words

    switch ( breakType )
    {
    case WORDREP_BREAK_EOW:
        _xWordRep->SkipNoiseWords( 1 );
        break;

    case WORDREP_BREAK_EOS:
        _xWordRep->SkipNoiseWords( 8 );
        break;

    case WORDREP_BREAK_EOP:
        _xWordRep->SkipNoiseWords( 128 );
        break;

    case WORDREP_BREAK_EOC:
        _xWordRep->SkipNoiseWords( 1024 );
        break;

    default:
        ciDebugOut(( DEB_ERROR,
                     "CKeyMaker::PutBreak -- Bad break type %d\n",
                     breakType ));
        return( E_FAIL );
    }

    return( S_OK );
} //PutBreak

//+-------------------------------------------------------------------------
//
//  Method:     CKeyMaker::Supports
//
//  Synopsis:   Checks if the pid/lang are supported by the language object
//
//  Arguments:  [pid]  -- The property ID
//              [lcid] -- The locale
//
//  Returns:    TRUE if it is supported
//
//  History:    24-Apr-1994   KyleP      Created
//
//--------------------------------------------------------------------------

BOOL CKeyMaker::Supports( PROPID pid, LCID lcid )
{
    if ( (lcid == _lcid) && (pid == _pid) )
        return TRUE;
    else
        return _sLang.Supports( pid, lcid );
} //Supports

//+---------------------------------------------------------------------------
//
//  Member:     CKeyMaker::NormalizeWStr - Public
//
//  Synopsis:   Normalizes a UniCode string
//
//  Arguments:  [pwcInBuf] -- input buffer
//              [cwcInBuf] -- count of chars in pwcInBuf
//              [pbOutBuf] -- output buffer.
//              [pcbOutBuf] - pointer to output count of bytes.
//
//  History:    10-Feb-2000     KitmanH    Created
//
//----------------------------------------------------------------------------

void CKeyMaker::NormalizeWStr( WCHAR const *pwcInBuf,
                               ULONG cwcInBuf,
                               BYTE *pbOutBuf,
                               unsigned *pcbOutBuf )
{
    _xWordRep->NormalizeWStr( pwcInBuf,
                              cwcInBuf,
                              pbOutBuf,
                              pcbOutBuf );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\keysmith\stemsink.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1991 - 2000
//
//  File:       stemsink.cxx
//
//  Contents:   IWordformSink implementation
//
//  History:    03-May-95   SitaramR    Created
//
//----------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include <norm.hxx>
#include <stemsink.hxx>

//+---------------------------------------------------------------------------
//
//  Member:     CStemmerSink::CStemmerSink
//
//  Synopsis:   Constructor
//
//  Arguments:  [pStemmer] -- stemmer
//              [wordRep] -- normalizer, which is the next stage in filtering
//                           pipeline
//
//  History:    03-May-95    SitaramR    Created
//
//----------------------------------------------------------------------------

CStemmerSink::CStemmerSink( IStemmer *pStemmer, PWordRepository& wordRep )
        : _pStemmer(pStemmer),
          _wordRep(wordRep),
          _fWBreakAltWord(FALSE)
{
    _cwcMaxNormBuf = wordRep.GetMaxBufferLen();
}

//+---------------------------------------------------------------------------
//
//  Member:     CStemmerSink::GetFlags
//
//  Synopsis:   Returns address of ranking and range flags
//
//  Arguments:  [ppRange] -- range flag
//              [ppRank] -- rank flag
//
//  History:    03-May-95   SitaramR     Created.
//
//----------------------------------------------------------------------------

void CStemmerSink::GetFlags ( BOOL** ppRange, CI_RANK** ppRank )
{
    _wordRep.GetFlags ( ppRange, ppRank );
}

//+---------------------------------------------------------------------------
//
//  Member:     CStemmerSink::ProcessWord
//
//  Synopsis:   Stems word
//
//  Arguments:  [pwcInBuf] -- input buffer
//              [cwc] -- count of words in pwcInBuf
//
//  History:    03-May-95    SitaramR    Created
//
//----------------------------------------------------------------------------

void CStemmerSink::ProcessWord( WCHAR const *pwcInBuf, ULONG cwc )
{
    _fWBreakAltWord = FALSE;

    _pStemmer->GenerateWordForms( pwcInBuf, cwc, this );
}

//+---------------------------------------------------------------------------
//
//  Member:     CStemmerSink::ProcessAltWord
//
//  Synopsis:   Stems alternate word
//
//  Arguments:  [pwcInBuf] -- input buffer
//              [cwc] -- count of words in pwcInBuf
//
//  History:    03-May-95    SitaramR    Created
//
//----------------------------------------------------------------------------

void CStemmerSink::ProcessAltWord( WCHAR const *pwcInBuf, ULONG cwc )
{
    _fWBreakAltWord = TRUE;

    _pStemmer->GenerateWordForms( pwcInBuf, cwc,  this );
}

//+-------------------------------------------------------------------------
//
//  Method:     CStemmerSink::PutWord
//
//  Synopsis:   pass stemmed word to normalizer
//
//  Arguments:  [pwcInBuf] -- Word
//              [cwc] -- Count of characters in [pwcInBuf]
//
//  History:    03-May-1995   SitaramR      Created
//
//--------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE CStemmerSink::PutWord( WCHAR const *pwcInBuf, ULONG cwc )
{
    // IWordBreaker::PutAltWord overrides IStemmer::PutWord
    return ( PutStemmedWord( pwcInBuf, cwc, _fWBreakAltWord ) );
}


//+-------------------------------------------------------------------------
//
//  Method:     CStemmerSink::PutAltWord
//
//  Synopsis:   pass stemmed word to normalizer
//
//  Arguments:  [pwcInBuf] -- Word
//              [cwc] -- Count of characters in [pwcInBuf]
//
//  History:    03-May-1995   SitaramR      Created
//
//--------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE CStemmerSink::PutAltWord( WCHAR const *pwcInBuf, ULONG cwc )
{
    return ( PutStemmedWord( pwcInBuf, cwc, TRUE ) );
}



//+-------------------------------------------------------------------------
//
//  Method:     CStemmerSink::PutStemmedWord
//
//  Synopsis:   actual implementation of stemmer sink methods; it puts a word
//              into the word repository
//
//  Arguments:  [pwcInBuf] -- Word
//              [cwc] -- Count of characters in [pwcInBuf]
//              [fAltWord] -- Is this an alternate word ? Determining whether
//                            this word is an alternate word or not is complicated
//                            by the fact that IWBreaker::PutAltWord overrides the
//                            IStemmer::PutWord.
//
//  History:    03-May-1995   SitaramR      Created
//
//--------------------------------------------------------------------------

SCODE CStemmerSink::PutStemmedWord( WCHAR const *pwcInBuf, ULONG cwc, BOOL fAltWord )
{
    SCODE sc = S_OK;

    CTranslateSystemExceptions translate;

    TRY
    {
        if ( cwc > _cwcMaxNormBuf )
        {
            sc = LANGUAGE_S_LARGE_WORD;
            cwc = _cwcMaxNormBuf;
        }
    
        if ( cwc > 0 )
        {
    
            #if CIDBG == 1
                if ( fAltWord )
                    ciDebugOut(( DEB_WORDS,
                                 "PutAltWord(IWordFormSink): \"%.*ws\"  Occ = %d\n",
                                 cwc, pwcInBuf, _wordRep.GetOccurrence() ));
                else
                    ciDebugOut(( DEB_WORDS,
                                 "PutWord(IWordFormSink): \"%.*ws\"  Occ = %d\n",
                                 cwc, pwcInBuf, _wordRep.GetOccurrence() ));
            #endif
        
            if ( fAltWord )
                _wordRep.ProcessAltWord( pwcInBuf, cwc );
            else
                _wordRep.ProcessWord( pwcInBuf, cwc );
        }
    }
    CATCH( CException, e )
    {
        sc = e.GetErrorCode();
    }
    END_CATCH;

    return sc;
} //PutStemmedWord

//
// The following are needed to make midl happy.  There are no other interfaces
// to bind to.  Inheritance from IUnknown is unnecessary.
//

SCODE STDMETHODCALLTYPE CStemmerSink::QueryInterface(REFIID riid, void  * * ppvObject)
{
    *ppvObject = 0;
    return( E_NOTIMPL );
}

ULONG STDMETHODCALLTYPE CStemmerSink::AddRef()
{
    return( 1 );
}

ULONG STDMETHODCALLTYPE CStemmerSink::Release()
{
    return( 1 );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\kbyacc\warshall.c ===
#include "defs.h"

transitive_closure(R, n)
unsigned *R;
int n;
{
    register int rowsize;
    register unsigned i;
    register unsigned *rowj;
    register unsigned *rp;
    register unsigned *rend;
    register unsigned *ccol;
    register unsigned *relend;
    register unsigned *cword;
    register unsigned *rowi;

    rowsize = WORDSIZE(n);
    relend = R + n*rowsize;

    cword = R;
    i = 0;
    rowi = R;
    while (rowi < relend)
    {
	ccol = cword;
	rowj = R;

	while (rowj < relend)
	{
	    if (*ccol & (1 << i))
	    {
		rp = rowi;
		rend = rowj + rowsize;
		while (rowj < rend)
		    *rowj++ |= *rp++;
	    }
	    else
	    {
		rowj += rowsize;
	    }

	    ccol += rowsize;
	}

	if (++i >= BITS_PER_WORD)
	{
	    i = 0;
	    cword++;
	}

	rowi += rowsize;
    }
}

#if defined(KYLEP_CHANGE)
void
#endif
reflexive_transitive_closure(R, n)
unsigned *R;
int n;
{
    register int rowsize;
    register unsigned i;
    register unsigned *rp;
    register unsigned *relend;

    transitive_closure(R, n);

    rowsize = WORDSIZE(n);
    relend = R + n*rowsize;

    i = 0;
    rp = R;
    while (rp < relend)
    {
	*rp |= (1 << i);
	if (++i >= BITS_PER_WORD)
	{
	    i = 0;
	    rp++;
	}

	rp += rowsize;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\keysmith\drep.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1991 - 2001.
//
//  File:       DREP.CXX
//
//  Contents:   Data Repository
//
//  Classes:    CDataRepository
//
//  History:    18-Apr-91   BartoszM    Created
//              03-June-91  t-WadeR     Added PutStream, PutPhrase, PutWord
//              01-July-91  t-WadeR     Ignores data with invalid property.
//
//----------------------------------------------------------------------------


#include <pch.cxx>
#pragma hdrstop

#include <propvar.h>
#include <drep.hxx>
#include <lang.hxx>
#include <streams.hxx>
#include <pfilter.hxx>
#include <keymak.hxx>
#include <pidmap.hxx>
#include <codepage.hxx>

#include "psource.hxx"

#if CIDBG == 1

CCumulTimer::~CCumulTimer()
{
   if (_count)
   {
      ciDebugOut (( DEB_ITRACE, "%ws:\n", _szActivity ));
      ciDebugOut (( DEB_ITRACE, "\taverage %d ms, count %d, total time %d ms\n",
     _totalTime/_count, _count, _totalTime ));
   }
}

#endif //CIDBG

//+---------------------------------------------------------------------------
//
//  Member:     CDataRepository::CDataRepository
//
//  Arguments:  [krep] - the key repository
//              [langlist] - the language list
//              [langId] - language
//              [fuzzy] - the fuzzy flag
//
//  History:    18-Apr-91   BartoszM    Created
//              08-May-91   t-WadeR     Added default language
//              03-June-91  t-WadeR     rewritten for input-driven pipeline
//              14-Sep-92   AmyA        Added pCat
//
//----------------------------------------------------------------------------
CDataRepository::CDataRepository (
      PKeyRepository& krep, IPhraseSink *pPhraseSink,
      BOOL fQuery, ULONG fuzzy, CPidMapper  & pidMap,
      CLangList &  langList )
      : _krep (krep),
        _valueNorm (krep),
        _fQuery(fQuery),
        _ulGenerateMethod(fuzzy),
        _pPhraseSink(pPhraseSink),
        _pidMap(pidMap),
        _lcidSystemDefault( GetSystemDefaultLCID() ),
        _langList(langList),
        _pid( pidInvalid ),
        _lcid( lcidInvalid ),
        _prevPid( 0 ),   // Different than _pid
        _prevLcid( 0 ),  // Different than _lcid
        _cwcFoldedPhrase( 0 )
#if CIDBG == 1
        , timerBind ( L"Binding" )
        , timerNoBind ( L"Creating filter without binding" )
        , timerFilter ( L"Filtering" )
#endif
{
}

//+---------------------------------------------------------------------------
//
//  Member:     CDataRepository::PutStream
//
//  Synopsis:   Passes stream to key maker to be added to key repository
//
//  History:    03-June-91  t-WadeR     Created
//              18-Nov-92   AmyA        Overloaded
//
//----------------------------------------------------------------------------
void    CDataRepository::PutStream ( TEXT_SOURCE * stm )
{
    if ( LoadKeyMaker() )
    {
        Win4Assert( !_xKeyMaker.IsNull() );
        _xKeyMaker->PutStream ( _occArray.Get(_pid), stm );
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CDataRepository::PutPhrase
//
//  Synopsis:   Passes ASCII string of words to key maker to be added to
//              key repository
//
//  History:    23-Sept-92  AmyA        Created
//
//----------------------------------------------------------------------------
void CDataRepository::PutPhrase ( const char* str, unsigned cc )
{
    ULONG cwcOut = cc * 2 + 2;
    WCHAR *pwcOut = new WCHAR[cwcOut];

    ULONG cwcActual = 0;
    do
    {
        cwcActual = MultiByteToWideChar( _ulCodePage,
                                         0,
                                         str,
                                         cc,
                                         pwcOut,
                                         cwcOut );
        if ( cwcActual == 0 )
        {
            delete[] pwcOut;
            pwcOut = 0;

            if ( GetLastError() == ERROR_INSUFFICIENT_BUFFER )
            {
                cwcOut *= 2;
                pwcOut = new WCHAR[cwcOut];
            }
            else
                THROW( CException() );
        }
    } while ( cwcActual == 0 );

    XArray<WCHAR> xOut;
    xOut.Set( cwcOut, pwcOut );

    PutPhrase( pwcOut, cwcActual );
}

//+---------------------------------------------------------------------------
//
//  Member:     CDataRepository::PutPhrase
//
//  Synopsis:   Passes unicode string of words to key maker to be added to
//              key repository
//
//  History:    23-Sept-92  AmyA        Created
//
//----------------------------------------------------------------------------

void CDataRepository::PutPhrase ( const WCHAR* str, unsigned cwc )
{
    if ( 0 != str && cwc > 0 && LoadKeyMaker() )
    {
        //
        // Normalize to precomposed Unicode
        //
        _xwcsFoldedPhrase.ReSize( cwc );

        ULONG cwcFolded = FoldStringW( MAP_PRECOMPOSED,
                                       str,
                                       cwc,
                                       _xwcsFoldedPhrase.Get(),
                                       cwc );
        if ( cwcFolded == 0 )
        {
            Win4Assert( GetLastError() != ERROR_INSUFFICIENT_BUFFER );

            THROW( CException() );
        }

        _cwcFoldedPhrase = cwcFolded;

        CPhraseSource s( _xwcsFoldedPhrase.GetPointer(), cwcFolded );
        Win4Assert( !_xKeyMaker.IsNull() );
        _xKeyMaker->PutStream ( _occArray.Get(_pid), &s );
    }
}



//+---------------------------------------------------------------------------
//
//  Member:     CDataRepository::PutPropName
//
//  Arguments:  [strProp] -- name of the property
//
//  History:    18-Apr-91   BartoszM    Created
//              01-June-91  t-WadeR     Ignores data with invalid property
//              21-Feb-95   DwightKr    Added fake property id mapping
//
//----------------------------------------------------------------------------
BOOL CDataRepository::PutPropName ( CFullPropSpec const & Prop )
{
    //
    // Find the pid
    //

    PROPID fakePid = _pidMap.NameToPid( Prop );

    return PutPropId( fakePid );
}

//+---------------------------------------------------------------------------
//----------------------------------------------------------------------------
BOOL CDataRepository::PutPropId ( PROPID fakePid )
{
    _prevPid = _pid;

    if ( fakePid == pidInvalid )
    {
        _pid = pidInvalid;
    }
    else
    {
        _pid = _pidMap.PidToRealPid( fakePid );

        if ( !_krep.PutPropId( _pid ) )
        {
            ciDebugOut(( DEB_WARN, "Key repository didn't accept pid %u\n", _pid ));
            _pid = pidInvalid;
        }
    }

    return (pidInvalid != _pid);
}


//+---------------------------------------------------------------------------
//
//  Member:     CDataRepository::PutLanguage
//
//  Synopsis:   if the lcid is different, it frees the current lang. dependent
//                    key maker, and gets a new one
//
//  Arguments:  [lcid] -- language descriptor
//
//  History:    18-Apr-91   BartoszM    Created
//              03-June-91  t-WadeR     Changed to use CLangDepKeyMaker pool.
//
//----------------------------------------------------------------------------

BOOL CDataRepository::PutLanguage ( LCID lcid )
{
    _prevLcid = _lcid;

    //
    // Special cases for language: system default and user default.
    //

    if ( lcid == LOCALE_SYSTEM_DEFAULT )
        _lcid = GetSystemDefaultLCID();
    else if ( lcid == LOCALE_USER_DEFAULT )
        _lcid = GetUserDefaultLCID();
    else
        _lcid = lcid;

    //
    // Set codepage, for conversion of narrow strings.
    //

    if ( _prevLcid != _lcid )
    {
        _ulCodePage = LocaleToCodepage( _lcid );
    }

    return TRUE;
}

//+---------------------------------------------------------------------------
//
//  Member:     CDataRepository::PutValue
//
//  Synopsis:   Store a property value.
//
//  Arguments:  [var] -- Value
//
//  History:    08-Feb-94   KyleP       Added header
//
//----------------------------------------------------------------------------

void CDataRepository::PutValue( CStorageVariant const & var )
{
    //
    // Textual values are special.  They are treated as contents, and
    // thus need language identification and word breaking.  Unlike contents,
    // we do not provide support for choosing the language.
    //

    switch ( var.Type() )
    {
    case VT_LPWSTR:
    {
        unsigned cwc = 0;

        if ( 0 != var.GetLPWSTR() )
        {
            cwc = wcslen( var.GetLPWSTR() );
        }

        if (cwc > 0)
            PutPhrase( var.GetLPWSTR(), cwc + 1);

        break;
    }

    case VT_LPSTR:
    {
        unsigned cb = 0;

        if ( 0 != var.GetLPSTR() )
        {
            cb = strlen( var.GetLPSTR() );
        }
        if (cb > 0)
            PutPhrase( var.GetLPSTR(), cb + 1);

        break;
    }

    case VT_BSTR :
    {
        if ( ( 0 != var.GetBSTR() ) &&
             ( 0 != BSTRLEN( var.GetBSTR() ) ) )
        {
            PutPhrase( var.GetBSTR(),
                       1 + ( BSTRLEN( var.GetBSTR() ) / sizeof WCHAR ) );

        }
        break;
    }

    case VT_VECTOR | VT_LPWSTR:
    {
         for ( ULONG j = 0; j < var.Count(); j++ )
         {
             unsigned cb = 0;

             if ( 0 != var.GetLPWSTR(j) )
             {
                 cb = wcslen( var.GetLPWSTR(j) );
             }
             if (cb > 0)
             {
                 PutPhrase( var.GetLPWSTR(j), cb + 1);
             }
         }
        break;
    }

    case VT_VECTOR | VT_BSTR:
    {
         for ( ULONG j = 0; j < var.Count(); j++ )
         {
             if ( ( 0 != var.GetBSTR(j) ) &&
                  ( 0 != BSTRLEN( var.GetBSTR(j) ) ) )
             {
                 PutPhrase( var.GetBSTR(j),
                            1 + ( BSTRLEN( var.GetBSTR(j) ) / sizeof WCHAR ) );
             }
         }
        break;
    }


    case VT_VECTOR | VT_LPSTR:
    {
         for ( ULONG j = 0; j < var.Count(); j++ )
         {
             unsigned cb = 0;

             if ( 0 != var.GetLPSTR(j) )
             {
                 cb = strlen( var.GetLPSTR(j) );
             }
             if (cb > 0)
             {
                 PutPhrase( var.GetLPSTR(j), cb + 1);
             }
         }
        break;
    }

    case VT_VECTOR | VT_VARIANT :
    {
        for ( ULONG j=0; j < var.Count(); j++ )
        {
            ciDebugOut (( DEB_ITRACE, "Filtering vector variant[%d] of type 0x%x\n",
                                       j, (ULONG) var.GetVARIANT(j).Type() ));
            PutValue( (CStorageVariant const &)var.GetVARIANT(j) );
        }

        break;
    }

    default:
        _valueNorm.PutValue( _pid, _occArray.Get(_pid), var );
        break;
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CDataRepository::ContainedNoiseWords
//
//  Returns:    TRUE if any text sent to repository had a noise word in it.
//
//  History:    03-Oct-95   KyleP       Created
//
//----------------------------------------------------------------------------

BOOL CDataRepository::ContainedNoiseWords()
{
    if ( _xKeyMaker.IsNull() )
        return FALSE;

    return _xKeyMaker->ContainedNoiseWords();
}

//+---------------------------------------------------------------------------
//
//  Member:     CDataRepository::LoadKeyMaker, private
//
//  Synopsis:   Loads new key maker, if necessary
//
//  Returns:    TRUE if an appropriate key maker was located (and loaded).
//
//  History:    05-Jan-98   KyleP       Created
//
//----------------------------------------------------------------------------

BOOL CDataRepository::LoadKeyMaker()
{
    if ( pidInvalid == _pid || lcidInvalid == _lcid )
        return FALSE;

    if ( _pid == _prevPid && _lcid == _prevLcid )
    {
        Win4Assert( !_xKeyMaker.IsNull() );
        return TRUE;
    }

    //
    // Locate an appropriate Key Maker
    //

    if ( _xKeyMaker.IsNull() || !_xKeyMaker->Supports( _pid, _lcid ) )
    {
        delete _xKeyMaker.Acquire();
        _xKeyMaker.Set( new CKeyMaker( _lcid, _pid, _krep, _pPhraseSink, _fQuery, _ulGenerateMethod, _langList ) );
    }

    return TRUE;
}

//+---------------------------------------------------------------------------
//
//  Member:     CDataRepository::NormalizeWStr - Public
//
//  Synopsis:   Normalizes a UniCode string
//
//  Arguments:  [pbOutBuf] -- output buffer.
//              [pcbOutBuf] - pointer to output count of bytes.
//
//  History:    10-Feb-2000     KitmanH    Created
//
//----------------------------------------------------------------------------

void CDataRepository::NormalizeWStr( BYTE *pbOutBuf, unsigned *pcbOutBuf )
{
    // Chop off the trailing null character
    if ( 0 == _xwcsFoldedPhrase[_cwcFoldedPhrase-1] )
        _cwcFoldedPhrase--;

    Win4Assert( _cwcFoldedPhrase > 0 );

    ciDebugOut(( DEB_ITRACE, "CDdataRepository::NormailizeWStr: %ws, %d\n",
                 _xwcsFoldedPhrase.Get(),
                 _cwcFoldedPhrase ));

    _xKeyMaker->NormalizeWStr( _xwcsFoldedPhrase.Get(),
                               _cwcFoldedPhrase,
                               pbOutBuf,
                               pcbOutBuf );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\keysmith\psource.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1991 - 1994.
//
//  File:       PSource.cxx
//
//  Contents:   TEXT_SOURCE implementation for a phrase
//
//  Classes:    CTextSource
//
//  History:    20-Apr-94   KyleP       Created
//
//----------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include "psource.hxx"

//+-------------------------------------------------------------------------
//
//  Member:     CPhraseSource::CPhraseSource, public
//
//  Synopsis:   Constructor
//
//  Arguments:  [pwcPhrase] -- Phrase
//              [cwcPhrase] -- Count of characters in phrase
//
//  History:    20-Apr-94 KyleP     Created
//
//--------------------------------------------------------------------------

CPhraseSource::CPhraseSource( WCHAR const * pwcPhrase, unsigned cwcPhrase )
{
    iEnd = cwcPhrase;
    iCur = 0;
    awcBuffer = pwcPhrase;
    pfnFillTextBuffer = CPhraseSource::FillBuf;
}

//+-------------------------------------------------------------------------
//
//  Member:     CPhraseSource::FillBuf, public
//
//  Synopsis:   'Fills' buffer
//
//  History:    20-Apr-94 KyleP      Created
//
//--------------------------------------------------------------------------

SCODE CPhraseSource::FillBuf( TEXT_SOURCE * pTextSource )
{
    return( WBREAK_E_END_OF_TEXT );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\ntciutil\cidir.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1991 - 1999.
//
//  File:       CIDIR.CXX
//
//  Contents:   Persistent directory
//
//  Classes:    CiDirectory
//
//  History:    3-Apr-91    BartoszM    Created stub.
//              3-May-96    dlee        Don't read it in -- map on-disk data
//              4-Nov-97    dlee        Support merge shrink from front
//
//  Notes:      File format is two initial ULONGs with the count of level 1
//              and count of level 2 keys, then the actual level 1 and level
//              2 keys.
//
//----------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include <mmstrm.hxx>
#include <cidir.hxx>
#include <cistore.hxx>
#include <eventlog.hxx>

//+---------------------------------------------------------------------------
//
//  Member:     CiDirectory::CiDirectory, public
//
//  Synopsis:   Open existing or create empty directory
//
//  Arguments:  [storage]  -- Through which streams are opened
//              [objectId] -- Wid to open
//              [mode]     -- Mode to open the stream
//
//  History:    13-Jun-91   BartoszM       Created.
//
//----------------------------------------------------------------------------

CiDirectory::CiDirectory(
    CiStorage &         storage,
    WORKID              objectId,
    PStorage::EOpenMode mode ) :
  _storage( storage ),
  _objectId( objectId ),
  _cKeys( 0 ),
  _cLevel2Keys( 0 ),
  _pbCurrent( 0 ),
  _pcKeys( 0 ),
  _fReadOnly( PStorage::eOpenForRead == mode )
{
    // If opening for create, don't try reading in existing data if the file
    // exists since we want to blow it all away later anyway.

    if ( PStorage::eCreate != mode )
        ReadIn( !_fReadOnly );
} //CiDirectory

//+---------------------------------------------------------------------------
//
//  Member:     CiDirectory::DoSeekForKeyBuf
//
//  Synopsis:   Find the key in the array of keys.
//
//  Arguments:  [key]      -- search key
//              [aKeys]    -- array of keys to search
//              [low]      -- the index of the lower bound of the search
//              [cKeys]    -- # of keys over which the search happens
//
//  Returns:    index of the greatest key <= the search key
//
//  History:    5-May-96   dlee    Created
//
//----------------------------------------------------------------------------

inline ULONG CiDirectory::DoSeekForKeyBuf(
    const CKeyBuf &  key,
    CDirectoryKey ** aKeys,
    ULONG            low,
    ULONG            cKeys )
{
    #if CIDBG == 1
        Win4Assert( 0 != cKeys );
        ULONG cArray = cKeys;
    #endif // CIDBG == 1

    ULONG iHi = low + cKeys - 1;
    ULONG iLo = low;

    // do a binary search looking for the key

    do
    {
        ULONG cHalf = cKeys / 2;

        if ( 0 != cHalf )
        {
            ULONG cTmp = cHalf - 1 + ( cKeys & 1 );
            ULONG iMid = iLo + cTmp;

            Win4Assert( iMid < ( low + cArray ) );

            if ( aKeys[ iMid ]->IsGreaterThanKeyBuf( key ) )
            {
                iHi = iMid - 1;
                cKeys = cTmp;
            }
            else if ( ! aKeys[ iMid + 1 ]->IsGreaterThanKeyBuf( key ) )
            {
                iLo = iMid + 1;
                cKeys = cHalf;
            }
            else
            {
                return iMid;
            }
        }
        else if ( cKeys > 1 )
        {
            Win4Assert( ( iLo + 1 ) < ( low + cArray ) );

            if ( aKeys[ iLo + 1 ]->IsGreaterThanKeyBuf( key ) )
                return iLo;
            else
                return iLo + 1;
        }
        else return iLo;
    }
    while ( TRUE );

    Win4Assert(( ! "Invalid doseek function exit point" ));
    return 0;
} //DoSeekForKeyBuf

//+---------------------------------------------------------------------------
//
//  Member:     CiDirectory::Seek
//
//  Synopsis:   Find bit offset and key of the greatest key less than or
//              equal to search key.
//              If none is found <= the search key, return the first item.
//
//  Arguments:  [key]      -- search key
//              [pKeyInit] -- key found: less or equal to search key.
//                            only returned if non-zero
//              [off]      -- bit offset of keyInit
//
//  History:    22-Apr-92   BartoszM    Created
//
//----------------------------------------------------------------------------

void CiDirectory::Seek(
    const CKeyBuf & key,
    CKeyBuf *       pKeyInit,
    BitOffset &     off )
{
    // If a master merge failed, the stream may not be mapped.  Map it.

    ReMapIfNeeded();

    ULONG iKey;

    if ( ! key.IsMinKey() )
    {
        //
        // Check if there is no level 2 (ie the dir is being created)
        // In the case where there is no level 2, there is no max key
        // at the end of the array.  That's ok because queries will go
        // to the old index for keys greater than the last key in this
        // directory.
        //

        if ( 0 == _cLevel2Keys )
        {
            iKey = DoSeekForKeyBuf( key, _aKeys.GetPointer(), 0, _cKeys );
            Win4Assert( iKey < _cKeys );
            Win4Assert( ( iKey == ( _cKeys - 1 ) ) ||
                        ( _aKeys[ iKey + 1 ]->IsGreaterThanKeyBuf( key ) ) );
        }
        else
        {
            iKey = DoSeekForKeyBuf( key, _aLevel2Keys.GetPointer(), 0, _cLevel2Keys );
            iKey *= eDirectoryFanOut;
            Win4Assert( iKey < _cKeys );
            unsigned cKeys = __min( eDirectoryFanOut, _cKeys - iKey );
            iKey = DoSeekForKeyBuf( key, _aKeys.GetPointer(), iKey, cKeys );
            Win4Assert( ( 1 == _cKeys ) ||
                        ( iKey < ( _cKeys - 1 ) ) );
            Win4Assert( ( 1 == _cKeys) ||
                        ( _aKeys[ iKey + 1 ]->IsGreaterThanKeyBuf( key ) ) );
        }

        Win4Assert( 0 == iKey ||
                    !_aKeys[ iKey ]->IsGreaterThanKeyBuf( key ) );

        // If the search key is <= the first key, return the min key

        if ( ( 0 == iKey ) &&
             ( ( 0 == _cKeys ) ||
               ( _aKeys[ 0 ]->IsGreaterThanKeyBuf( key ) ) ) )
        {
            // the key is less than the first key, return minkey

            if ( 0 != pKeyInit )
                pKeyInit->FillMin();

            off.Init( 0, 0 );

            return;
        }
    }
    else
    {
        iKey = 0;
    }

    _aKeys[ iKey ]->Offset( off );

    if ( 0 != pKeyInit )
        _aKeys[ iKey ]->MakeKeyBuf( *pKeyInit );
} //Seek

//+---------------------------------------------------------------------------
//
//  Member:     CiDirectory::Seek
//
//  Synopsis:   Find bit offset and key of the greatest key less than or
//              equal to search key.
//              If none is found <= the search key, return the first item.
//
//  Arguments:  [key]      -- search key
//              [pKeyInit] -- key found: less or equal to search key.
//                            only returned if non-zero
//              [off]      -- bit offset of keyInit
//
//  History:    22-Apr-92   BartoszM    Created
//
//----------------------------------------------------------------------------

void CiDirectory::Seek(
    const CKey & key,
    CKeyBuf *    pKeyInit,
    BitOffset &  off )
{
    CKeyBuf keyBuf;
    keyBuf = key;

    Seek( keyBuf, pKeyInit, off );
} //Seek

//+---------------------------------------------------------------------------
//
//  Member:     CiDirectory::SeekNext
//
//  Synopsis:   Find the first key in the next page
//
//  Arguments:  [key] -- the search key in this page
//              [off] -- the offset of the first key
//
//  History:    8-Mar-94    t-joshh     Created
//
//----------------------------------------------------------------------------

void CiDirectory::SeekNext (
    const CKeyBuf & key,
    CKeyBuf *       pKeyInit,
    BitOffset &     off )
{
    ULONG iKey;

    if ( _cKeys > 0 && ! key.IsMinKey() )
    {
        if ( 0 == _cLevel2Keys )
        {
            iKey = DoSeekForKeyBuf( key, _aKeys.GetPointer(), 0, _cKeys );
        }
        else
        {
            iKey = DoSeekForKeyBuf( key, _aLevel2Keys.GetPointer(), 0, _cLevel2Keys );
            iKey *= eDirectoryFanOut;
            Win4Assert( iKey < _cKeys );
            unsigned cKeys = __min( eDirectoryFanOut, _cKeys - iKey );
            iKey = DoSeekForKeyBuf( key, _aKeys.GetPointer(), iKey, cKeys );
        }

        // this IS a seek next
        iKey++;
    }
    else
    {
        iKey = 0;
    }

    Win4Assert ( iKey < _cKeys );

    _aKeys[ iKey ]->Offset( off );

    if ( 0 != pKeyInit )
        _aKeys[ iKey ]->MakeKeyBuf( *pKeyInit );

    #if CIDBG == 1
        _aKeys[ iKey ]->MakeKeyBuf( _keyLast );
    #endif // CIDBG == 1
} //SeekNext

//+---------------------------------------------------------------------------
//
//  Member:     CiDirectory::Add
//
//  Synopsis:   Adds entry to directory
//
//  Arguments:  [posKey]  -- offset of key in file
//              [key]     -- key to add
//
//  History:    22-Apr-92   BartoszM    Created
//
//----------------------------------------------------------------------------

void CiDirectory::Add(
    BitOffset &     posKey,
    const CKeyBuf & key )
{
    Win4Assert( !_fReadOnly );
    Win4Assert( &key != 0 );

    ciDebugOut(( DEB_PDIR,
                 "PDir::Add %.*ws at %d:%d\n",
                 key.StrLen(),
                 key.GetStr(),
                 posKey.Page(),
                 posKey.Offset() ));

    LokWriteKey( key, posKey );

    #if CIDBG==1
        _bitOffLastAdded = posKey;
    #endif  // CIDBG
} //Add

//+---------------------------------------------------------------------------
//
//  Member:     CiDirectory::ReMapIfNeeded, private
//
//  Synopsis:   ReMaps the directory stream if it isn't mapped due to a
//              failure to extend or map the directory stream during a
//              shrink from front master merge.
//
//  History:    6-Aug-98   dlee   Created
//
//----------------------------------------------------------------------------

void CiDirectory::ReMapIfNeeded()
{
    // If it's already mapped, we're set

    if ( 0 != _streamBuf.Get() )
        return;

    Win4Assert( !_fReadOnly );

    // Map the file

    _stream->MapAll( _streamBuf );

    // Rebase pointers if the new stream pointer is different

    if ( 0 == _cKeys )
    {
        _pcKeys = (ULONG *) _streamBuf.Get();
        _pbCurrent = (BYTE *) ( _pcKeys + 2 );
    }
    else if ( _pcKeys != (ULONG *) _streamBuf.Get() )
    {
        BYTE *pbOldBase = (BYTE *) _pcKeys;
        BYTE *pbNewBase = (BYTE *) _streamBuf.Get();
        UINT_PTR cb = _pbCurrent - pbOldBase;

        for ( unsigned i = 0; i < _cKeys; i++ )
        {
            BYTE * p = (BYTE *) _aKeys[ i ];
            p = p - pbOldBase + pbNewBase;
            _aKeys[ i ] = (CDirectoryKey *) p;
        }

        _pcKeys = (ULONG *) _streamBuf.Get();
        _pbCurrent = pbNewBase + cb;
    }
} //ReMapIfNeeded

#if CIDBG == 1 // for testing failure path
BOOL g_fFailDirectoryMergeExtend = FALSE;
#endif // CIDBG == 1

//+---------------------------------------------------------------------------
//
//  Member:     CiDirectory::GrowIfNeeded, private
//
//  Synopsis:   Grows the file if necessary and maps the new section
//
//  Arguments:  [cbToGrow]  -- # of bytes to append to the file
//
//  History:    8-May-96   dlee    Created
//
//----------------------------------------------------------------------------

void CiDirectory::GrowIfNeeded(
    unsigned cbToGrow )
{
    if ( ( _pbCurrent + cbToGrow ) >=
         ( (BYTE *) _streamBuf.Get() + _streamBuf.Size() ) )
    {
        BYTE * pbOldBase = (BYTE *) _streamBuf.Get();
        unsigned cbOld = (unsigned)(_pbCurrent - (BYTE *) _streamBuf.Get());

        _stream->Unmap( _streamBuf );
        ULONG sizeNew = CommonPageRound( cbOld + cbToGrow );
        _stream->SetSize( _storage, sizeNew );

        #if CIDBG == 1
            // For testing failure at this point...

            if ( g_fFailDirectoryMergeExtend )
            {
                g_fFailDirectoryMergeExtend = FALSE;
                THROW( CException( E_OUTOFMEMORY ) );
            }
        #endif // CIDBG == 1

        _stream->MapAll( _streamBuf );
        _pcKeys = (ULONG *) _streamBuf.Get();
        _pbCurrent = (BYTE*) _streamBuf.Get() + cbOld;

        //
        // Rebase all the pointers in the key array if the new base
        // address of the mapping is different than the old one.
        //

        BYTE * pbNewBase = (BYTE *) _streamBuf.Get();

        if ( pbOldBase != pbNewBase )
        {
            for ( unsigned i = 0; i < _cKeys; i++ )
            {
                BYTE * p = (BYTE *) _aKeys[ i ];
                p = p - pbOldBase + pbNewBase;
                _aKeys[ i ] = (CDirectoryKey *) p;
            }
        }
        else
        {
            ciDebugOut(( DEB_ITRACE, "no cidir rebasing needed\n" ));
        }

        // Toss the .dir file pages out of the working set

        _streamBuf.PurgeFromWorkingSet( -1, -1 );
    }
} //GrowIfNeeded

//+---------------------------------------------------------------------------
//
//  Member:     CiDirectory::LokWriteKey, private
//
//  Synopsis:   Adds entry to directory
//
//  Arguments:  [key]        -- key to add
//              [bitOffset]  -- offset of key in file
//
//  History:    02-May-94   DwightKr    Created
//
//  Notes:      Writes a single key to the mapped buffer.
//
//----------------------------------------------------------------------------
inline void CiDirectory::LokWriteKey(
    const CKeyBuf & key,
    BitOffset &     bitOffset )
{
    // If this is the first key, open the stream for writing

    if ( 0 == _cKeys )
    {
        // Close any existing stream from a failed merge

        LokClose();

        _stream.Set( _storage.QueryExistingDirStream ( _objectId, TRUE ) );

        if ( 0 == _stream.GetPointer() || !_stream->Ok() )
        {
            _stream.Free();
            _stream.Set( _storage.QueryNewDirStream ( _objectId ) );
        }

        if ( ( 0 == _stream.GetPointer() ) || !_stream->Ok() )
            THROW( CException ( STATUS_NO_MEMORY ) );

        _stream->SetSize( _storage, COMMON_PAGE_SIZE );
        _stream->MapAll( _streamBuf );

        _pcKeys = (ULONG *) _streamBuf.Get();
        _pbCurrent = (BYTE*) ( _pcKeys + 2 );

        // Make sure the stream is in good shape in case we stop and restart
        // the merge.

        _pcKeys[0] = 0;
        _pcKeys[1] = 0;
        _stream->Flush( _streamBuf, 2 * sizeof ULONG, TRUE );
    }

    Win4Assert( key.Count() <= 0xff );
    BYTE count = (BYTE)key.Count();

    unsigned size = CDirectoryKey::ComputeSize( count, key.Pid() );
    GrowIfNeeded( size );

    CDirectoryKey *pkey = new( _pbCurrent ) CDirectoryKey;

    // write the key

    pkey->Write( count, bitOffset, key.Pid(), key.GetBuf() );

    if ( _cKeys >= _aKeys.Count() )
        _aKeys.ReSize( __max( 32, _cKeys * 2 + 1 ) );

    _aKeys[ _cKeys ] = pkey;

    _pbCurrent += size;

    _cKeys++;
} //LokWriteKey

//+---------------------------------------------------------------------------
//
//  Member:     CiDirectory::LokBuildDir, public
//
//  Synopsis:   Builds the directory tree correspdong to the leaf pages
//
//  Arguments:  [maxKey]     -- largest key to add to directory
//
//  History:    ??-???-??   ????????    Created
//              02-May-94   DwightKr    Added maxKey argument
//
//  Notes:      Writes keys from the beginning of the array up to and including
//              maxKey (which is usually the splitKey).  This will result in
//              a directory that contains entries upto and including maxKey.
//              It is certainly possible that the key array has keys past
//              maxKey, but we don't want to add them to the directory since
//              maxKey represents the largest key that has persistently
//              written to disk during a master merge.
//
//              The above would matter if downlevel master merges were
//              atomic throughout.  If they ever become atomic, we
//              need to truncate the file after this key.
//
//----------------------------------------------------------------------------
void CiDirectory::LokBuildDir(
    const CKeyBuf & maxKey )
{
    ciDebugOut(( DEB_PDIR, "PDir::LokBuildDir %d\n", _cKeys ));

    CKeyBuf maxKeyValue;
    maxKeyValue.FillMax();

    //
    //  Write out a maximum key at the end.
    //  The offset for the maximum key is not actually used my anyone,
    //  since the directory is structured to find a key <= the desired
    //  key.  If someone generates a query for maxKey then everything
    //  will be returned.  The offset of maxKey is therefore arbitrary.
    //

    BitOffset maxBitOffset;
    maxBitOffset.Init( 0, 0 );
    LokWriteKey( maxKeyValue, maxBitOffset );

    //
    // Write the keys in the level 2 tree.
    // Write every DirectoryFanOut'th, so we can do a search on this Level2
    // first, and reduce the working set.
    //

    _cLevel2Keys = 0;

    CDirectoryKey *pkey = _aKeys[ 0 ];

    for ( unsigned x = 0; x < _cKeys; x++ )
    {
        if ( 0 == ( x & ( eDirectoryFanOut - 1 ) ) )
        {
            unsigned cb = pkey->Size();
            unsigned oKey = (unsigned)((BYTE *) pkey - (BYTE *) _streamBuf.Get());
            GrowIfNeeded( cb );
            pkey = (CDirectoryKey *) ( (BYTE *) _streamBuf.Get() + oKey );
            RtlCopyMemory( _pbCurrent, pkey, cb );
            _pbCurrent += cb;
            _cLevel2Keys++;
        }

        pkey = pkey->NextKey();
    }

    //
    // Write another max-key at the end.  Decrement the # of keys since it
    // is incorrectly incremented in LokWriteKey()
    //

    LokWriteKey( maxKeyValue, maxBitOffset );
    _cLevel2Keys++;
    _cKeys--;

    // write the # of keys in the file and the # of keys in level 2.

    _pcKeys[0] = _cKeys;
    _pcKeys[1] = _cLevel2Keys;

    // remember the size of the file used and release the mapping

    unsigned cbFile = (unsigned)(_pbCurrent - (BYTE *) _streamBuf.Get());

    _stream->Flush( _streamBuf, cbFile, TRUE );
    _stream->Unmap( _streamBuf );

    // truncate and close the file

    _stream->SetSize( _storage, cbFile );
    _stream->Close();
    _stream.Free();

    _cKeys = 0;

    // read the directory back in, in read-only mode

    ReadIn( FALSE );
} //LokBuildDir

//+-------------------------------------------------------------------------
//
//  Method:     CiDirectory::ReadIn
//
//  Synopsis:   Load directory from storage
//
//  Arguments:  [fWrite] -- If TRUE, we're recovering from a stopped master
//                          merge, either clean or dirty.  This can be TRUE
//                          even on read only catalogs if a MM is paused.
//
//  History:    17-Feb-1994     KyleP   Added header
//
//--------------------------------------------------------------------------

void CiDirectory::ReadIn( BOOL fWrite )
{
    _stream.Set( _storage.QueryExistingDirStream( _objectId, fWrite ) );

    if ( ( 0 == _stream.GetPointer() ) || !_stream->Ok() )
    {
        if ( fWrite )
        {
            // New index; it'll be created later

            _stream.Free();
            return;
        }
        else
        {
            Win4Assert( !"Corrupt directory" );
            _storage.ReportCorruptComponent( L"IndexDirectory1" );
            THROW( CException( CI_CORRUPT_DATABASE ) );
        }
    }

    _stream->MapAll( _streamBuf );

    BYTE * pbBuf = (BYTE *) _streamBuf.Get();
    BYTE * pbEnd = pbBuf + _streamBuf.Size();

    if ( _streamBuf.Size() <= ( 2 * sizeof ULONG ) )
    {
        Win4Assert( !"Corrupt directory" );
        _storage.ReportCorruptComponent( L"IndexDirectory2" );
        THROW( CException( CI_CORRUPT_DATABASE ) );
    }

    // The count of keys is stored in the first 4 bytes
    // The count of level 2 keys is stored in the next 4 bytes
    // There can be 0 level 2 keys if we stopped during the middle
    // of a master merge.
    // An empty index has a directory with 1 level 1 max key and 2 level
    // 2 max keys.

    _pcKeys = (ULONG *) pbBuf;
    _cKeys = _pcKeys[0];
    _cLevel2Keys = _pcKeys[1];

    if ( ( !fWrite && 0 == _cKeys ) ||
         ( _cLevel2Keys > ( _cKeys + 1 ) ) ||
         ( !fWrite && ( 0 == _cLevel2Keys ) ) )
    {
        Win4Assert( !"Corrupt directory" );
        _storage.ReportCorruptComponent( L"IndexDirectory3" );
        THROW( CException( CI_CORRUPT_DATABASE ) );
    }

    pbBuf += ( 2 * sizeof ULONG );

    // Store pointers to each of the keys

    _aKeys.Free();
    _aKeys.Init( _cKeys );

    CDirectoryKey *pkey = new( pbBuf ) CDirectoryKey;

    for ( unsigned x = 0; x < _cKeys; x++ )
    {
        if ( (BYTE *) pkey >= pbEnd )
        {
            Win4Assert( !"Corrupt directory" );
            _storage.ReportCorruptComponent( L"IndexDirectory5" );
            THROW( CException( CI_CORRUPT_DATABASE ) );
        }

        _aKeys[ x ] = pkey;
        pkey = pkey->NextKey();
    }

    _aLevel2Keys.Free();

    //
    // Level2 keys can exist when fWrite is TRUE if we failed a master
    // merge after building the level2 directory.  It's likely the failure
    // is in recording the transaction that the merge completed.
    //

    if ( fWrite )
        _cLevel2Keys = 0;
    else if ( 0 != _cLevel2Keys )
    {
        _aLevel2Keys.Init( _cLevel2Keys );

        for ( x = 0; x < _cLevel2Keys; x++ )
        {
            if ( (BYTE *) pkey >= pbEnd )
            {
                Win4Assert( !"Corrupt directory" );
                _storage.ReportCorruptComponent( L"IndexDirectory6" );
                THROW( CException( CI_CORRUPT_DATABASE ) );
            }

            _aLevel2Keys[ x ] = pkey;
            pkey = pkey->NextKey();
        }

        // If we didn't read as many keys as expected, the file is corrupt.
        // This is only true if the directory has level 2 keys, since the
        // file may have bogus data at the end if we are in the middle of
        // a master merge.

        if ( (BYTE *) pkey != pbEnd )
        {
            ciDebugOut(( DEB_WARN, "pkey, pbEnd: 0x%x, 0x%x\n", pkey, pbEnd ));
            Win4Assert( !"Corrupt directory" );
            _storage.ReportCorruptComponent( L"IndexDirectory4" );
            THROW( CException( CI_CORRUPT_DATABASE ) );
        }
    }

    // Initialize _pbCurrent, so we can restart a failed master merge

    if ( fWrite )
        _pbCurrent = (BYTE *) pkey;

    // Toss the .dir file pages out of the working set

    _streamBuf.PurgeFromWorkingSet( -1, -1 );

    // toss the level1 directory from the working set

    VirtualUnlock( _aKeys.GetPointer(), _aKeys.SizeOf() );

    _fReadOnly = !fWrite;
} //ReadIn

//+-------------------------------------------------------------------------
//
//  Member:     CiDirectory::Close, public
//
//  Effects:    Closes the directory.  Usually called when a merge fails.
//
//  History:    21-Apr-92 BartoszM    Created
//
//--------------------------------------------------------------------------

void CiDirectory::Close()
{
    LokClose();
} //Close

//+-------------------------------------------------------------------------
//
//  Member:     CiDirectory::LokClose, public
//
//  Effects:    Closes the directory.  Usually called when a merge fails.
//
//  History:    18-Nov-97 dlee    Created
//
//--------------------------------------------------------------------------

void CiDirectory::LokClose()
{
    if ( !_stream.IsNull() )
    {
        // The _stream object can exist but not have a file open at this
        // point if a merge failed, so only unmap what is mapped.

        if ( ( _stream->Ok() ) && ( 0 != _streamBuf.Get() ) )
            _stream->Unmap( _streamBuf );

        _stream.Free();
    }
} //LokClose

//+---------------------------------------------------------------------------
//
//  Function:   DeleteKeysAfter
//
//  Synopsis:   Deletes all keys in the tree after the specified key.
//
//  Arguments:  [key] - The key after which all keys in the tree must be
//                      deleted.
//
//  History:    13-Nov-97   dlee   Created
//
//  Notes:      Note that "key" is NOT deleted - only keys after "key" are
//              deleted.
//
//----------------------------------------------------------------------------

void CiDirectory::DeleteKeysAfter( const CKeyBuf & key )
{
    //
    // If we're restarting a failed master merge after LokBuildDir
    // succeeded, we have to close re-open the stream for write.
    //

    if ( _fReadOnly )
    {
        LokClose();
        ReadIn( TRUE );
    }
    else if ( 0 != _cKeys )
        ReMapIfNeeded();

    // Now, wipe the level 2, since we're still building level 1

    _cLevel2Keys = 0;
    _aLevel2Keys.Free();

    // Truncate level 1 at keys <= key

    if ( 0 != _cKeys )
    {
        // use the tree to find the greatest key <= key

        ULONG iKey = DoSeekForKeyBuf( key, _aKeys.GetPointer(), 0, _cKeys );

        //
        // Move to the next key which must be > the seek key, but may be
        // beyond the # of keys in the directory.
        //

        iKey++;

        if ( iKey < _cKeys )
        {
            Win4Assert( _aKeys[ iKey ]->IsGreaterThanKeyBuf( key ) );
            _cKeys = iKey;
            _pbCurrent = (BYTE *) _aKeys[iKey];
        }
    }
} //DeleteKeysAfter

//+---------------------------------------------------------------------------
//
//  Function:   LokFlushDir
//
//  Synopsis:   Flushes the current state of the directory, up to and
//              including the key specified.  Called at checkpoints during
//              a master merge.  There may be some keys after the key
//              specified.  Leave them in the file, but don't include them
//              in the count of keys.
//
//  Arguments:  [key] - The key before which and including is flushed
//
//  History:    10-Aug-98   dlee   Created
//
//----------------------------------------------------------------------------

void CiDirectory::LokFlushDir( const CKeyBuf & key )
{
    Win4Assert( !_fReadOnly );
    Win4Assert( 0 == _cLevel2Keys );

    // Truncate level 1 at keys <= key

    if ( 0 != _cKeys )
    {
        ReMapIfNeeded();

        // use the tree to find the greatest key <= key

        ULONG iKey = DoSeekForKeyBuf( key, _aKeys.GetPointer(), 0, _cKeys );

        _pcKeys[0] = iKey + 1;
        _pcKeys[1] = 0;
        _streamBuf.Flush( TRUE );
    }
} //LokFlushDir

//+---------------------------------------------------------------------------
//
//  Member:     CiDirectory::MakeBackupCopy
//
//  Synopsis:   Creates a backup of the persistent directory using the
//              storage provided.
//
//  Arguments:  [storage]         - Destination storage
//              [progressTracker] - Track progress and aborts.
//
//  History:    3-18-97   srikants   Created
//
//----------------------------------------------------------------------------

void CiDirectory::MakeBackupCopy( PStorage & storage,
                                  PSaveProgressTracker & progressTracker )
{
    CiStorage & dstStorage = *((CiStorage *)&storage);

    XPtr<PMmStream> dstStream;
    CMmStreamBuf dstStreamBuf;

    dstStream.Set( dstStorage.QueryExistingDirStream( _objectId, TRUE ) );

    if ( 0 == dstStream.GetPointer() || !dstStream->Ok() )
    {
        dstStream.Free();
        dstStream.Set( dstStorage.QueryNewDirStream( _objectId ) );
    }

    Win4Assert( 0 != _stream.GetPointer() );

    ULONG cb = _streamBuf.Size();

    dstStream->SetSize( dstStorage, cb );
    dstStream->MapAll( dstStreamBuf );

    RtlCopyMemory( dstStreamBuf.Get(), _streamBuf.Get(), cb );

    dstStream->Flush( dstStreamBuf, cb );
    dstStream->Unmap( dstStreamBuf );
} //MakeBackupCopy
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\ntciutil\cimbmgr.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997 - 2000.
//
//  File:       cimbmgr.cxx
//
//  Contents:   Content Index Meta Base Manager
//
//  Classes:    CMetaDataMgr
//
//  History:    07-Feb-1997   dlee    Created
//              24-Apr-1997   dlee    Converted to new Unicode interface
//
//----------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include <cimbmgr.hxx>

#define MYDEFINE_GUID(name, l, w1, w2, b1, b2, b3, b4, b5, b6, b7, b8) \
    EXTERN_C const GUID name \
    = { l, w1, w2, { b1, b2,  b3,  b4,  b5,  b6,  b7,  b8 } }

MYDEFINE_GUID(CLSID_MSAdminBase_W, 0xa9e69610, 0xb80d, 0x11d0, 0xb9, 0xb9, 0x0, 0xa0, 0xc9, 0x22, 0xe7, 0x50);
MYDEFINE_GUID(IID_IMSAdminBase_W, 0x70b51430, 0xb6ca, 0x11d0, 0xb9, 0xb9, 0x0, 0xa0, 0xc9, 0x22, 0xe7, 0x50);
MYDEFINE_GUID(CLSID_MSAdminBaseExe_W, 0xa9e69611, 0xb80d, 0x11d0, 0xb9, 0xb9, 0x0, 0xa0, 0xc9, 0x22, 0xe7, 0x50);
MYDEFINE_GUID(IID_IMSAdminBaseSink_W, 0xa9e69612, 0xb80d, 0x11d0, 0xb9, 0xb9, 0x0, 0xa0, 0xc9, 0x22, 0xe7, 0x50);

//+-------------------------------------------------------------------------
//
//  Member:     CMetaDataMgr::CMetaDataMgr, public
//
//  Synopsis:   Creates an object for talking to the IIS metabase.
//
//  Arguments:  [fTopLevel]  - TRUE for the top level, FALSE for a
//                             vserver instance
//              [dwInstance] - instance # of the server
//              [eType]      - type of vroot provider -- W3, NNTP, or IMAP
//              [pwcMachine] - the machine to open, L"." for local machine
//
//  History:    07-Feb-1997   dlee    Created
//
//--------------------------------------------------------------------------

CMetaDataMgr::CMetaDataMgr(
    BOOL            fTopLevel,
    CiVRootTypeEnum eType,
    DWORD           dwInstance,
    WCHAR const *   pwcMachine ) :
        _fNotifyEnabled( FALSE ),
        _fTopLevel( fTopLevel )
{
    // -1 is a valid instance number, so this is a bogus assert, but it'll
    // never be hit unless something else is broken or someone hacked the
    // registry.

    #if CIDBG == 1

        if ( fTopLevel )
            Win4Assert( 0xffffffff == dwInstance );
        else
            Win4Assert( 0xffffffff != dwInstance );

    #endif // CIDBG == 1

    if ( fTopLevel )
        swprintf( _awcInstance, L"/lm/%ws", GetVRootService( eType ) );
    else
        swprintf( _awcInstance,
                  L"/lm/%ws/%d",
                  GetVRootService( eType ),
                  dwInstance );

    IMSAdminBase * pcAdmCom;

    if ( !_wcsicmp( pwcMachine, L"." ) )
    {
        SCODE sc = CoCreateInstance( GETAdminBaseCLSID(TRUE),
                                     NULL,
                                     CLSCTX_ALL,
                                     IID_IMSAdminBase,
                                     (void **) &pcAdmCom );
        if ( FAILED(sc) )
        {
            ciDebugOut(( DEB_WARN, "CMetaDataMgr can't CoCreateInstance: %x\n", sc ));
            THROW( CException(sc) );
        }
    }
    else
    {
        COSERVERINFO info;
        RtlZeroMemory( &info, sizeof info );
        info.pwszName = (WCHAR *) pwcMachine;

        XInterface<IClassFactory> xFactory;
        SCODE sc = CoGetClassObject( GETAdminBaseCLSID(TRUE),
                                     CLSCTX_SERVER,
                                     &info,
                                     IID_IClassFactory,
                                     xFactory.GetQIPointer() );

        if ( FAILED(sc) )
        {
            ciDebugOut(( DEB_WARN, "CMetaDataMgr can't CoGetClassObject: %x\n", sc ));
            THROW( CException(sc) );
        }

        sc = xFactory->CreateInstance( 0, IID_IMSAdminBase, (void**) &pcAdmCom );

        if ( FAILED(sc) )
        {
            ciDebugOut(( DEB_WARN, "CMetaDataMgr can't CreateInstance: %x\n", sc ));
            THROW( CException(sc) );
        }
    }

    _xAdminBase.Set( pcAdmCom );
} //CMetaDataMgr

//+-------------------------------------------------------------------------
//
//  Member:     CMetaDataMgr::~CMetaDataMgr, public
//
//  Synopsis:   Destroys an object for talking to the IIS metabase
//
//  History:    07-Feb-1997   dlee    Created
//
//--------------------------------------------------------------------------

CMetaDataMgr::~CMetaDataMgr()
{
    if ( !_xAdminBase.IsNull() )
    {
        // just in case we are still connected

        DisableVPathNotify();
    }
} //~CMetaDataMgr

//+-------------------------------------------------------------------------
//
//  Member:     CMetaDataMgr::IsIISAdminUp, public/static
//
//  Synopsis:   Returns TRUE if iisadmin svc is up
//
//  Arguments:  [fIISAdminInstalled] - returns TRUE if it's installed,
//                                     FALSE otherwise
//
//  History:    07-Feb-1997   dlee    Created
//
//--------------------------------------------------------------------------

BOOL CMetaDataMgr::IsIISAdminUp(
    BOOL & fIISAdminInstalled )
{
    fIISAdminInstalled = TRUE;
    BOOL fIsUp = TRUE;

    TRY
    {
        // The constructor will throw if the iisadmin svc is unavailable.

        CMetaDataMgr( TRUE, W3VRoot );
    }
    CATCH( CException, e )
    {
        fIsUp = FALSE;

        if ( REGDB_E_CLASSNOTREG == e.GetErrorCode() )
            fIISAdminInstalled = FALSE;
    }
    END_CATCH

    return fIsUp;
} //IsIISAdminUp

//+-------------------------------------------------------------------------
//
//  Member:     CMetaDataMgr::EnumVPaths, public
//
//  Synopsis:   Enumerates vpaths by calling the callback
//
//  Arguments:  [callBack] - called for each vpath
//
//  History:    07-Feb-1997   dlee    Created
//
//--------------------------------------------------------------------------

void CMetaDataMgr::EnumVPaths(
    CMetaDataCallBack & callBack )
{
    Win4Assert( !_fTopLevel );

    CMetaDataHandle mdRoot( _xAdminBase, _awcInstance );

    CVRootStack vrootStack;

    Enum( vrootStack, callBack, mdRoot, L"" );
} //EnumVPaths

//+-------------------------------------------------------------------------
//
//  Member:     CMetaDataMgr::AddVRoot, public
//
//  Synopsis:   Adds a VRoot to the metabase
//
//  Arguments:  [pwcVRoot]  - name of the vroot, e.g.: /here
//              [pwcPRoot]  - physical path of the vroot, e.g.: x:\here
//              [dwAccess]  - access rights to the vroot
//
//  History:    07-Feb-1997   dlee    Created
//
//--------------------------------------------------------------------------

void CMetaDataMgr::AddVRoot(
    WCHAR const * pwcVRoot,
    WCHAR const * pwcPRoot,
    DWORD         dwAccess )
{
    Win4Assert( !_fTopLevel );

    // blow it away if it currently exists

    RemoveVRoot( pwcVRoot );

    {
        unsigned cwc = wcslen( _awcInstance ) + wcslen( L"/Root" );
        if ( cwc >= METADATA_MAX_NAME_LEN )
            THROW( CException( E_INVALIDARG ) );

        WCHAR awc[ METADATA_MAX_NAME_LEN ];
        wcscpy( awc, _awcInstance );
        wcscat( awc, L"/Root" );
        CMetaDataHandle mdRoot( _xAdminBase, awc, TRUE );

        _xAdminBase->AddKey( mdRoot.Get(), pwcVRoot );
    }

    WCHAR awcVRootPath[ METADATA_MAX_NAME_LEN ];

    unsigned cwc = wcslen( _awcInstance ) + wcslen( L"/Root" ) + wcslen( pwcVRoot );

    if ( cwc >= METADATA_MAX_NAME_LEN )
        THROW( CException( E_INVALIDARG ) );

    wcscpy( awcVRootPath, _awcInstance );
    wcscat( awcVRootPath, L"/Root" );
    wcscat( awcVRootPath, pwcVRoot );

    CMetaDataHandle mdVRoot( _xAdminBase, awcVRootPath, TRUE );

    {
        METADATA_RECORD mdr;
        RtlZeroMemory( &mdr, sizeof mdr );
        mdr.dwMDIdentifier = MD_VR_PATH;
        mdr.dwMDAttributes = METADATA_INHERIT;
        mdr.dwMDUserType = IIS_MD_UT_FILE;
        mdr.dwMDDataType = STRING_METADATA;
        mdr.pbMDData = (BYTE *) pwcPRoot;
        mdr.dwMDDataLen = sizeof WCHAR * ( 1 + wcslen( pwcPRoot ) );

        DWORD cbRequired = 0;
        SCODE sc = _xAdminBase->SetData( mdVRoot.Get(),
                                         L"",
                                         &mdr );

        if ( FAILED( sc ) )
        {
            ciDebugOut(( DEB_WARN, "SetData PRoot failed: 0x%x\n", sc ));
            THROW( CException( sc ) );
        }
    }
    {
        // must set a null username to enforce metadata consistency

        METADATA_RECORD mdr;
        RtlZeroMemory( &mdr, sizeof mdr );
        mdr.dwMDIdentifier = MD_VR_USERNAME;
        mdr.dwMDAttributes = METADATA_INHERIT;
        mdr.dwMDUserType = IIS_MD_UT_SERVER;
        mdr.dwMDDataType = STRING_METADATA;
        mdr.pbMDData = (BYTE *) L"";
        mdr.dwMDDataLen = sizeof WCHAR;

        DWORD cbRequired = 0;
        SCODE sc = _xAdminBase->SetData( mdVRoot.Get(),
                                         L"",
                                         &mdr );

        if ( FAILED( sc ) )
        {
            ciDebugOut(( DEB_WARN, "SetData user failed: 0x%x\n", sc ));
            THROW( CException( sc ) );
        }
    }
    {
        METADATA_RECORD mdr;
        RtlZeroMemory( &mdr, sizeof mdr );
        mdr.dwMDIdentifier = MD_ACCESS_PERM;
        mdr.dwMDAttributes = METADATA_INHERIT;
        mdr.dwMDUserType = IIS_MD_UT_FILE;
        mdr.dwMDDataType = DWORD_METADATA;
        mdr.pbMDData = (BYTE *) &dwAccess;
        mdr.dwMDDataLen = sizeof dwAccess;

        DWORD cbRequired = 0;
        SCODE sc = _xAdminBase->SetData( mdVRoot.Get(),
                                         L"",
                                         &mdr );

        if ( FAILED( sc ) )
        {
            ciDebugOut(( DEB_WARN, "SetData accessperm failed: 0x%x\n", sc ));
            THROW( CException( sc ) );
        }
    }
} //AddVRoot

//+-------------------------------------------------------------------------
//
//  Member:     CMetaDataMgr::Flush, public
//
//  Synopsis:   Flushes the metabase, since it's not robust.
//
//  History:    4-Dec-1998   dlee    Created
//
//--------------------------------------------------------------------------

void CMetaDataMgr::Flush()
{
    SCODE sc = _xAdminBase->SaveData();

    if ( FAILED( sc ) )
    {
        ciDebugOut(( DEB_WARN, "CMetaDataMgr::Flush failed: %#x\n", sc ));
        THROW( CException( sc ) );
    }
} //Flush

//+-------------------------------------------------------------------------
//
//  Member:     CMetaDataMgr::RemoveVRoot, public
//
//  Synopsis:   Removes a VRoot from the metabase
//
//  Arguments:  [pwcVRoot]   - name of the vroot. e.g.: /scripts
//
//  Notes:      Doesn't throw on failure to remove the root.
//
//  History:    07-Feb-1997   dlee    Created
//
//--------------------------------------------------------------------------

SCODE CMetaDataMgr::RemoveVRoot(
    WCHAR const * pwcVRoot )
{
    Win4Assert( !_fTopLevel );

    unsigned cwc = wcslen( _awcInstance ) + wcslen( L"/Root" );

    if ( cwc >= METADATA_MAX_NAME_LEN )
        THROW( CException( E_INVALIDARG ) );

    WCHAR awcRoot[ METADATA_MAX_NAME_LEN ];
    wcscpy( awcRoot, _awcInstance );
    wcscat( awcRoot, L"/Root" );

    CMetaDataHandle mdRoot( _xAdminBase, awcRoot, TRUE );

    // don't throw on error deleting vroot -- the root may not exist

    return _xAdminBase->DeleteKey( mdRoot.Get(), pwcVRoot );
} //RemoveVRoot

//+-------------------------------------------------------------------------
//
//  Member:     CMetaDataMgr::WriteRootValue, private
//
//  Synopsis:   Retrieves data for the key and identifier
//
//  Arguments:  [mdRoot] - Metabase key where data reside
//              [mdr]    - Scratch pad for the record.  On output, can be
//                         used to write the data, since all the
//                         fields are initialized properly.
//              [xData]  - Where data is written
//              [dwIdentifier] - The metabase id
//
//  History:    24-Feb-1998   dlee    Created
//
//--------------------------------------------------------------------------

void CMetaDataMgr::ReadRootValue(
    CMetaDataHandle &  mdRoot,
    METADATA_RECORD &  mdr,
    XGrowable<WCHAR> & xData,
    DWORD              dwIdentifier )
{
    RtlZeroMemory( &mdr, sizeof mdr );
    mdr.dwMDIdentifier = dwIdentifier;

    // script maps, etc. can be enormous due to bugs in ISV apps

    do
    {
        mdr.pbMDData = (BYTE *) xData.Get();
        mdr.dwMDDataLen = xData.SizeOf();

        DWORD cbRequired = 0;
        SCODE sc = _xAdminBase->GetData( mdRoot.Get(),
                                         L"",
                                         &mdr,
                                         &cbRequired );

        if ( HRESULT_FROM_WIN32( ERROR_INSUFFICIENT_BUFFER ) == sc )
        {
            xData.SetSizeInBytes( cbRequired );
            continue;
        }
        else if ( FAILED( sc ) )
        {
            ciDebugOut(( DEB_WARN, "GetData root value failed: 0x%x\n", sc ));
            THROW( CException( sc ) );
        }

        break;
    } while ( TRUE );
} //ReadRootValue

//+-------------------------------------------------------------------------
//
//  Member:     CMetaDataMgr::WriteRootValue, private
//
//  Synopsis:   Writes data to the key
//
//  Arguments:  [mdRoot]  - Metabase key where data resides
//              [mdr]     - Metadata record suitable for writing data
//              [pwcData] - Multi-sz string with data
//              [cwcData] - Total length including all terminating nulls
//
//  History:    24-Feb-1998   dlee    Created
//
//--------------------------------------------------------------------------

void CMetaDataMgr::WriteRootValue(
    CMetaDataHandle & mdRoot,
    METADATA_RECORD & mdr,
    WCHAR const *     pwcData,
    unsigned          cwcData )
{
    // note: the other fields in mdr were initialized properly by a call
    //       to ReadRootValue.

    mdr.dwMDDataLen = sizeof WCHAR * cwcData;
    mdr.pbMDData = (BYTE *) pwcData;

    SCODE sc = _xAdminBase->SetData( mdRoot.Get(),
                                     L"",
                                     &mdr );

    if ( FAILED( sc ) )
    {
        ciDebugOut(( DEB_WARN, "SetData root value failed: 0x%x\n", sc ));
        THROW( CException( sc ) );
    }
} //WriteRootValue

//+-------------------------------------------------------------------------
//
//  Member:     CMetaDataMgr::AddApplicationDependency, public
//
//  Synopsis:   Adds an entry to the application dependency list
//
//  Arguments:  [pwcApp]  - The entry to add, like this:
//                          "Indexing Service;IndexingService"
//
//  History:    01-Jun-2002   dlee    Created
//
//--------------------------------------------------------------------------

void CMetaDataMgr::AddApplicationDependency( WCHAR const * pwcApp )
{
    CMetaDataHandle mdRoot( _xAdminBase, L"/lm/w3svc", TRUE );
    XGrowable<WCHAR> xApps;
    METADATA_RECORD mdr;

    ReadRootValue( mdRoot, mdr, xApps, MD_APP_DEPENDENCIES );

    // add the new entry to the existing ones

    XGrowable<WCHAR> xTemp;
    xTemp.SetSize( xApps.Count() + wcslen( pwcApp ) + 1 );
    WCHAR *pwcTemp = xTemp.Get();
    wcscpy( pwcTemp, pwcApp );
    pwcTemp += ( 1 + wcslen( pwcTemp ) );

    WCHAR * pwcOldApps = xApps.Get();
    while ( 0 != *pwcOldApps )
    {
        wcscpy( pwcTemp, pwcOldApps );
        int x = 1 + wcslen( pwcOldApps );
        pwcTemp += x;
        pwcOldApps += x;
    }

    *pwcTemp++ = 0;

    // write the new set of apps

    WriteRootValue( mdRoot, mdr, xTemp.Get(), (UINT)( pwcTemp - xTemp.Get() ) );
} //AddApplicationDependency

//+-------------------------------------------------------------------------
//
//  Member:     CMetaDataMgr::AddRestrictionList, public
//
//  Synopsis:   Adds an entry to the restriction list.
//
//  Arguments:  [pwcRestriction]  - The entry to add, like this:
//                     "0,c:\windows\system32\webhits.dll,0,IndexingService,Indexing Service"
//
//  History:    01-Jun-2002   dlee    Created
//
//--------------------------------------------------------------------------

void CMetaDataMgr::AddRestrictionList( WCHAR const * pwcRestriction )
{
    CMetaDataHandle mdRoot( _xAdminBase, L"/lm/w3svc", TRUE );
    XGrowable<WCHAR> xList;
    METADATA_RECORD mdr;

    ReadRootValue( mdRoot, mdr, xList, MD_WEB_SVC_EXT_RESTRICTION_LIST );

    // add the new entry to the existing ones

    XGrowable<WCHAR> xTemp;
    xTemp.SetSize( xList.Count() + wcslen( pwcRestriction ) + 1 );
    WCHAR *pwcTemp = xTemp.Get();
    wcscpy( pwcTemp, pwcRestriction );
    pwcTemp += ( 1 + wcslen( pwcTemp ) );

    WCHAR * pwcOldEntries = xList.Get();
    while ( 0 != *pwcOldEntries )
    {
        wcscpy( pwcTemp, pwcOldEntries );
        int x = 1 + wcslen( pwcOldEntries );
        pwcTemp += x;
        pwcOldEntries += x;
    }

    *pwcTemp++ = 0;

    // write the new set of restrictions

    WriteRootValue( mdRoot, mdr, xTemp.Get(), (UINT)( pwcTemp - xTemp.Get() ) );
} //AddRestrictionList

//+-------------------------------------------------------------------------
//
//  Member:     CMetaDataMgr::RemoveApplicationDependency, public
//
//  Synopsis:   Removes an entry from the application dependency list
//
//  Arguments:  [pwcKey]  - Name of the key. e.g.
//                              "IndexingService"
//                          for entry like this one:
//                              "Indexing Service;IndexingService"
//
//  History:    01-Jun-2002   dlee    Created
//
//--------------------------------------------------------------------------

void CMetaDataMgr::RemoveApplicationDependency( WCHAR const * pwcKey )
{
    // retrieve the existing apps

    CMetaDataHandle mdRoot( _xAdminBase, L"/lm/w3svc", TRUE );
    XGrowable<WCHAR> xApps;
    METADATA_RECORD mdr;

    ReadRootValue( mdRoot, mdr, xApps, MD_APP_DEPENDENCIES );

    // awcApps is a multi-sz string

    XGrowable<WCHAR> xNew( xApps.Count() );
    WCHAR *pwcNew = xNew.Get();
    pwcNew[0] = 0;
    BOOL fFound = FALSE;

    // re-add all Apps other than those containing pwcKey

    WCHAR const *pwcCur = xApps.Get();
    while ( 0 != *pwcCur )
    {
        // if we didn't find the key, copy what we did find.

        WCHAR const * pwcSemi = wcschr( pwcCur, L';' );

        if ( ( 0 == pwcSemi ) ||
             ( 0 != wcscmp( pwcSemi + 1, pwcKey ) ) )
        {
            wcscpy( pwcNew, pwcCur );
            pwcNew += ( 1 + wcslen( pwcNew ) );
        }
        else
        {
            fFound = TRUE;
        }

        int cwc = wcslen( pwcCur );
        pwcCur += ( cwc + 1 );
    }

    // If the key wasn't found, don't do the write

    if ( !fFound )
        return;

    *pwcNew++ = 0;

    // got the string, now pound it in the metabase

    WriteRootValue( mdRoot, mdr, xNew.Get(), (UINT)(pwcNew - xNew.Get()) );
} //RemoveApplicationDependency

//+-------------------------------------------------------------------------
//
//  Member:     CMetaDataMgr::RemoveRestrictionList, public
//
//  Synopsis:   Removes entries from the restriction list that references
//              the application specified.
//
//  Arguments:  [pwcKey]  - Name of the key. e.g.
//                              "IndexingService"
//                          for entries like:
//                              "0,c:\windows\system32\idq.dll,0,IndexingService,Indexing Service"
//                              "0,c:\windows\system32\webhits.dll,0,IndexingService,Indexing Service"
//
//  History:    01-Jun-2002   dlee    Created
//
//--------------------------------------------------------------------------

void CMetaDataMgr::RemoveRestrictionList( WCHAR const * pwcKey )
{
    // retrieve the existing apps

    CMetaDataHandle mdRoot( _xAdminBase, L"/lm/w3svc", TRUE );
    XGrowable<WCHAR> xList;
    METADATA_RECORD mdr;

    ReadRootValue( mdRoot, mdr, xList, MD_WEB_SVC_EXT_RESTRICTION_LIST );

    // awcApps is a multi-sz string

    XGrowable<WCHAR> xNew( xList.Count() );
    WCHAR *pwcNew = xNew.Get();
    pwcNew[0] = 0;
    int cwcKey = wcslen( pwcKey );
    BOOL fFound = FALSE;

    // re-add all Entries other than those containing pwcKey

    WCHAR const *pwcCur = xList.Get();
    while ( 0 != *pwcCur )
    {
        // if we didn't find the key, then copy the entry

        WCHAR const * pwcFound = wcsstr( pwcCur, pwcKey );

        if ( ( 0 == pwcFound ) ||
             ( pwcFound == pwcCur ) ||
             ( L',' != * ( pwcFound - 1 ) ) ||
             ( L',' != pwcFound[ cwcKey ] ) )
        {
            wcscpy( pwcNew, pwcCur );
            pwcNew += ( 1 + wcslen( pwcNew ) );
        }
        else
        {
            fFound = TRUE;
        }

        int cwc = wcslen( pwcCur );
        pwcCur += ( cwc + 1 );
    }

    // If the key wasn't found, don't do the write

    if ( !fFound )
        return;

    *pwcNew++ = 0;

    // got the string, now pound it in the metabase

    WriteRootValue( mdRoot, mdr, xNew.Get(), (UINT)(pwcNew - xNew.Get()) );
} //RemoveRestrictionList

//+-------------------------------------------------------------------------
//
//  Member:     CMetaDataMgr::AddScriptMap, public
//
//  Synopsis:   Adds a script map to the metabase
//
//  Arguments:  [pwcMap]  - script map of the form:
//                          L".idq,d:\\winnt\\system32\\idq.dll,0"
//
//  History:    07-Feb-1997   dlee    Created
//
//--------------------------------------------------------------------------

void CMetaDataMgr::AddScriptMap(
    WCHAR const * pwcMap )
{
    // remove the existing script map if it exists.  have to get the
    // extension first.

    if ( wcslen( pwcMap ) > MAX_PATH )
        THROW( CException( HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER ) ) );

    WCHAR awcExt[ MAX_PATH ];
    wcscpy( awcExt, pwcMap );
    WCHAR *pwc = wcschr( awcExt, L',' );
    if ( !pwc )
        THROW( CException( HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER ) ) );
    *pwc = 0;

    RemoveScriptMap( awcExt );

    CMetaDataHandle mdRoot( _xAdminBase, L"/lm/w3svc", TRUE );
    XGrowable<WCHAR> xMaps;
    METADATA_RECORD mdr;

    ReadRootValue( mdRoot, mdr, xMaps, MD_SCRIPT_MAPS );

    // add the new script map to the existing ones

    XGrowable<WCHAR> xTemp;
    xTemp.SetSize( xMaps.Count() + wcslen( pwcMap ) + 1 );
    WCHAR *pwcTemp = xTemp.Get();
    wcscpy( pwcTemp, pwcMap );
    pwcTemp += ( 1 + wcslen( pwcTemp ) );

    WCHAR * pwcOldMaps = xMaps.Get();
    while ( 0 != *pwcOldMaps )
    {
        wcscpy( pwcTemp, pwcOldMaps );
        int x = 1 + wcslen( pwcOldMaps );
        pwcTemp += x;
        pwcOldMaps += x;
    }

    *pwcTemp++ = 0;

    // write the new set of script maps

    WriteRootValue( mdRoot, mdr, xTemp.Get(), (UINT)( pwcTemp - xTemp.Get() ) );
} //AddScriptMap

//+-------------------------------------------------------------------------
//
//  Member:     CMetaDataMgr::RemoveScriptMap, public
//
//  Synopsis:   Removes a script map from the metabase
//
//  Arguments:  [pwcExt]     - extension of map to remove:  L".idq"
//
//  History:    07-Feb-1997   dlee    Created
//
//--------------------------------------------------------------------------

void CMetaDataMgr::RemoveScriptMap(
    WCHAR const * pwcExt )
{
    // retrieve the existing script maps

    CMetaDataHandle mdRoot( _xAdminBase, L"/lm/w3svc", TRUE );
    XGrowable<WCHAR> xMaps;
    METADATA_RECORD mdr;

    ReadRootValue( mdRoot, mdr, xMaps, MD_SCRIPT_MAPS );

    // awcMaps is a multi-sz string

    XGrowable<WCHAR> xNew( xMaps.Count() );
    WCHAR *pwcNew = xNew.Get();
    pwcNew[0] = 0;
    int cwcExt = wcslen( pwcExt );
    BOOL fFound = FALSE;

    // re-add all mappings other than pwcExt

    WCHAR const *pwcCur = xMaps.Get();
    while ( 0 != *pwcCur )
    {
        if ( _wcsnicmp( pwcCur, pwcExt, cwcExt ) ||
             L',' != pwcCur[cwcExt] )
        {
            wcscpy( pwcNew, pwcCur );
            pwcNew += ( 1 + wcslen( pwcNew ) );
        }
        else
        {
            fFound = TRUE;
        }

        int cwc = wcslen( pwcCur );
        pwcCur += ( cwc + 1 );
    }

    // If the script map wasn't found, don't do the write

    if ( !fFound )
        return;

    *pwcNew++ = 0;

    // got the string, now pound it in the metabase

    WriteRootValue( mdRoot, mdr, xNew.Get(), (UINT)(pwcNew - xNew.Get()) );
} //RemoveScriptMap

//+-------------------------------------------------------------------------
//
//  Member:     CMetaDataMgr::ExtensionHasScriptMap, public
//
//  Synopsis:   Finds a script map in the metabase
//
//  Arguments:  [pwcExt]     - extension of map to lookup:  L".idq"
//
//  Returns:    TRUE if the extension has a script map association
//              FALSE otherwise
//
//  History:    10-Jul-1997   dlee    Created
//
//--------------------------------------------------------------------------

BOOL CMetaDataMgr::ExtensionHasScriptMap(
    WCHAR const * pwcExt )
{
    CMetaDataHandle mdRoot( _xAdminBase, L"/lm/w3svc", FALSE );
    XGrowable<WCHAR> xMaps;
    METADATA_RECORD mdr;

    ReadRootValue( mdRoot, mdr, xMaps, MD_SCRIPT_MAPS );

    // xMaps is a multi-sz string, look for pwcExt

    int cwcExt = wcslen( pwcExt );
    WCHAR *pwcCur = xMaps.Get();

    while ( 0 != *pwcCur )
    {
        if ( !_wcsnicmp( pwcCur, pwcExt, cwcExt ) &&
             L',' == pwcCur[cwcExt] )
            return TRUE;

        int cwc = wcslen( pwcCur );
        pwcCur += ( cwc + 1 );
    }

    return FALSE;
} //ExtensionHasScriptMap

//+-------------------------------------------------------------------------
//
//  Member:     CMetaDataMgr::ExtensionHasTargetScriptMap, public
//
//  Synopsis:   Sees if a scriptmap is pointing at a given dll
//
//  Arguments:  [pwcExt]     - extension of map to lookup:  L".idq"
//              [pwcDll]     - DLL to check, e.g. L"idq.dll"
//
//  Returns:    TRUE if the extension has a script map association
//              FALSE otherwise
//
//  History:    10-Jul-1997   dlee    Created
//
//  Note:       scriptmaps look like ".idq,c:\\windows\\system32\\idq.dll,3,GET,HEAD,POST"
//                  
//--------------------------------------------------------------------------

BOOL CMetaDataMgr::ExtensionHasTargetScriptMap(
    WCHAR const * pwcExt,
    WCHAR const * pwcDll )
{
    CMetaDataHandle mdRoot( _xAdminBase, L"/lm/w3svc", FALSE );
    XGrowable<WCHAR> xMaps;
    METADATA_RECORD mdr;

    ReadRootValue( mdRoot, mdr, xMaps, MD_SCRIPT_MAPS );

    // xMaps is a multi-sz string, look for pwcExt

    int cwcExt = wcslen( pwcExt );
    WCHAR *pwcCur = xMaps.Get();
    int cwcDll = wcslen( pwcDll );

    while ( 0 != *pwcCur )
    {
        if ( !_wcsnicmp( pwcCur, pwcExt, cwcExt ) &&
             L',' == pwcCur[cwcExt] )
        {
            // Skip to the end of the full path and check the dll name

            WCHAR const * pwcSlash = wcsrchr( pwcCur, L'\\' );

            if ( 0 != pwcSlash )
            {
                if ( !_wcsnicmp( pwcSlash + 1, pwcDll, cwcDll ) )
                    return TRUE;
            }
        }

        int cwc = wcslen( pwcCur );
        pwcCur += ( cwc + 1 );
    }

    return FALSE;
} //ExtensionHasTargetScriptMap

//+-------------------------------------------------------------------------
//
//  Member:     CMetaDataMgr::AddInProcessApp, public
//
//  Synopsis:   Adds an app to the list of in-process apps
//
//  Arguments:  [pwcApp] - App in the form "d:\\winnt\\system32\\idq.dll"
//
//  History:    09-Dec-1998   dlee    Created
//
//--------------------------------------------------------------------------

void CMetaDataMgr::AddInProcessIsapiApp( WCHAR const * pwcApp )
{
    //
    // Read the existing multi-sz value
    //

    CMetaDataHandle mdRoot( _xAdminBase, L"/lm/w3svc", TRUE );
    XGrowable<WCHAR> xApps;
    METADATA_RECORD mdr;
    ReadRootValue( mdRoot, mdr, xApps, MD_IN_PROCESS_ISAPI_APPS );
    WCHAR *pwcCur = xApps.Get();

    //
    // Look for an existing entry so a duplicate isn't added
    //

    while ( 0 != *pwcCur )
    {
        //
        // If it's already there, leave it alone
        //

        if ( !_wcsicmp( pwcCur, pwcApp ) )
            return;

        int cwc = wcslen( pwcCur );
        pwcCur += ( cwc + 1 );
    }

    unsigned cwcOld = 1 + (unsigned) ( pwcCur - xApps.Get() );

    //
    // It wasn't found, so add it
    //

    unsigned cwc = wcslen( pwcApp ) + 1;
    XGrowable<WCHAR> xNew( cwcOld + cwc );

    RtlCopyMemory( xNew.Get(), pwcApp, cwc * sizeof WCHAR );
    RtlCopyMemory( xNew.Get() + cwc, xApps.Get(), cwcOld * sizeof WCHAR );

    WriteRootValue( mdRoot, mdr, xNew.Get(), cwcOld + cwc );
} //AddInProcessIsapiApp

//+-------------------------------------------------------------------------
//
//  Member:     CMetaDataMgr::EnableVPathNotify, public
//
//  Synopsis:   Enables notification of vpaths
//
//  Arguments:  [pCallBack] - called on a change to any vpaths
//
//  History:    07-Feb-1997   dlee    Created
//
//--------------------------------------------------------------------------

void CMetaDataMgr::EnableVPathNotify(
    CMetaDataVPathChangeCallBack *pCallBack )
{
    Win4Assert( !_fTopLevel );
    Win4Assert( !_fNotifyEnabled );

    if ( _fNotifyEnabled )
        THROW( CException( HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER ) ) );

    ciDebugOut(( DEB_WARN,
                 "enabling vpath notifications on '%ws'\n",
                 _awcInstance ));

    Win4Assert( _xSink.IsNull() );

    //
    // NOTE: This new will be reported as a leak if iisamin dies or fails
    //       to call Release() on the sink the right number of times.
    //

    XInterface<CMetaDataComSink> xSink( new CMetaDataComSink() );

    xSink->SetCallBack( pCallBack );
    xSink->SetInstance( _awcInstance );

    XInterface< IConnectionPointContainer > xCPC;
    SCODE sc = _xAdminBase->QueryInterface( IID_IConnectionPointContainer,
                                            xCPC.GetQIPointer() );

    if ( FAILED( sc ) )
    {
        ciDebugOut(( DEB_WARN, "could not get cpc: 0x%x\n", sc ));
        THROW( CException( sc ) );
    }

    XInterface< IConnectionPoint> xCP;
    sc = xCPC->FindConnectionPoint( IID_IMSAdminBaseSink, xCP.GetPPointer() );

    if ( FAILED( sc ) )
    {
        ciDebugOut(( DEB_WARN, "could not get cp: 0x%x\n", sc ));
        THROW( CException( sc ) );
    }

    //
    // Tell COM to impersonate at IMPERSONATE level instead of the default
    // IDENTITY level.  This is to work-around a change made in IIS in
    // Windows 2000 SP1.
    //

    sc = CoSetProxyBlanket( xCP.GetPointer(),
                            RPC_C_AUTHN_WINNT,      // use NT default security
                            RPC_C_AUTHZ_NONE,       // use NT default authentication
                            NULL,                   // must be null if default
                            RPC_C_AUTHN_LEVEL_CALL, // call
                            RPC_C_IMP_LEVEL_IMPERSONATE,
                            NULL,                   // use process token
                            EOAC_STATIC_CLOAKING );    
    if ( FAILED( sc ) )
    {
        ciDebugOut(( DEB_WARN, "could not set proxy blanket: %#x\n", sc ));
        THROW( CException( sc ) );
    }

    sc = xCP->Advise( xSink.GetPointer(), &_dwCookie);

    if ( FAILED( sc ) )
    {
        ciDebugOut(( DEB_WARN, "could not advise cp: 0x%x\n", sc ));
        THROW( CException( sc ) );
    }

    _xCP.Set( xCP.Acquire() );
    _xSink.Set( xSink.Acquire() );

    _fNotifyEnabled = TRUE;
} //EnableVPathNotify

//+-------------------------------------------------------------------------
//
//  Member:     CMetaDataMgr::DisableVPathNotify, public
//
//  Synopsis:   Disables notification on VPaths
//
//  History:    07-Feb-1997   dlee    Created
//
//--------------------------------------------------------------------------

void CMetaDataMgr::DisableVPathNotify()
{
    if ( _fNotifyEnabled )
    {
        SCODE sc = _xCP->Unadvise( _dwCookie );
        ciDebugOut(( DEB_ITRACE, "result of unadvise: 0x%x\n", sc ));
        _fNotifyEnabled = FALSE;

        //
        // Note: The sink may still have a refcount after the free if
        //       iisadmin has a bug or their process died.  We can't just
        //       delete it here because CoUninitialize() will realize
        //       iisadmin messed up and try to help by calling Release()
        //       for iisadmin.
        //

        _xSink.Free();
        _xCP.Free();
    }
} //DisableVPathNotify

//+-------------------------------------------------------------------------
//
//  Member:     CMetaDataMgr::ReportVPath, private
//
//  Synopsis:   Helper method for reporting a vpath via callback
//
//  Arguments:  [vrootStack]  - stack of vroots for depth-first search
//              [mdRoot]      - handle to the root of the enumeration
//              [callBack]    - callback to call for vpath
//              [pwcRelative] - relative path in metabase
//
//  Returns:    TRUE if the vpath is a vroot and was pushed on vrootStack
//
//  History:    07-Feb-1997   dlee    Created
//
//--------------------------------------------------------------------------

BOOL CMetaDataMgr::ReportVPath(
    CVRootStack &       vrootStack,
    CMetaDataCallBack & callBack,
    CMetaDataHandle &   mdRoot,
    WCHAR const *       pwcRelative )
{
    Win4Assert( !_fTopLevel );

    // read the path, username, access permissions, and password

    WCHAR awcPPath[ METADATA_MAX_NAME_LEN ];
    awcPPath[0] = 0;
    WCHAR awcUser[ METADATA_MAX_NAME_LEN ];
    awcUser[0] = 0;
    DWORD dwAccess = 0;
    WCHAR awcPassword[ METADATA_MAX_NAME_LEN ];
    awcPassword[0] = 0;
    BOOL fIsIndexed = TRUE;
    BOOL fVRoot = TRUE;

    // Get the metabase access permission mask

    {
        METADATA_RECORD mdr;
        RtlZeroMemory( &mdr, sizeof mdr );
        mdr.dwMDIdentifier = MD_ACCESS_PERM;
        mdr.dwMDAttributes = METADATA_INHERIT;
        mdr.pbMDData = (BYTE *) &dwAccess;
        mdr.dwMDDataLen = sizeof dwAccess;

        DWORD cbRequired = 0;
        SCODE sc = _xAdminBase->GetData( mdRoot.Get(),
                                         pwcRelative,
                                         &mdr,
                                         &cbRequired );

        if ( ( FAILED( sc ) ) &&
             ( (MD_ERROR_DATA_NOT_FOUND) != sc ) )
        {
            ciDebugOut(( DEB_WARN, "GetData awccessperm failed: 0x%x\n", sc ));
            THROW( CException( sc ) );
        }
    }

    // Get the physical path if one exists

    {
        METADATA_RECORD mdr;
        RtlZeroMemory( &mdr, sizeof mdr );
        mdr.dwMDIdentifier = MD_VR_PATH;
        mdr.pbMDData = (BYTE *) awcPPath;
        mdr.dwMDDataLen = sizeof awcPPath;

        DWORD cbRequired = 0;
        SCODE sc = _xAdminBase->GetData( mdRoot.Get(),
                                         pwcRelative,
                                         &mdr,
                                         &cbRequired );

        if ( ( FAILED( sc ) ) &&
             ( (MD_ERROR_DATA_NOT_FOUND) != sc ) )
        {
            ciDebugOut(( DEB_WARN, "GetData PRoot failed: 0x%x\n", sc ));
            THROW( CException( sc ) );
        }
    }

    //
    // Only look for a username/access/password if there is a physical path,
    // since it can only be a virtual root if it has a physical path.
    //

    if ( 0 != awcPPath[0] )
    {
        // Trim any trailing backslash from the physical path

        unsigned cwcPRoot = wcslen( awcPPath );
        Win4Assert( 0 != cwcPRoot );

        if ( L'\\' == awcPPath[ cwcPRoot - 1 ] )
            awcPPath[ cwcPRoot - 1 ] = 0;


        {
            METADATA_RECORD mdr;
            RtlZeroMemory( &mdr, sizeof mdr );
            mdr.dwMDIdentifier = MD_VR_USERNAME;
            mdr.pbMDData = (BYTE *) awcUser;
            mdr.dwMDDataLen = sizeof awcUser;

            DWORD cbRequired = 0;
            SCODE sc = _xAdminBase->GetData( mdRoot.Get(),
                                             pwcRelative,
                                             &mdr,
                                             &cbRequired );

            if ( ( FAILED( sc ) ) &&
                 ( (MD_ERROR_DATA_NOT_FOUND) != sc ) )
            {
                ciDebugOut(( DEB_WARN, "GetData user failed: 0x%x\n", sc ));
                THROW( CException( sc ) );
            }
        }
        {
            METADATA_RECORD mdr;
            RtlZeroMemory( &mdr, sizeof mdr );
            mdr.dwMDIdentifier = MD_VR_PASSWORD;
            mdr.pbMDData = (BYTE *) awcPassword;
            mdr.dwMDDataLen = sizeof awcPassword;

            DWORD cbRequired = 0;
            SCODE sc = _xAdminBase->GetData( mdRoot.Get(),
                                             pwcRelative,
                                             &mdr,
                                             &cbRequired );

            if ( ( FAILED( sc ) ) &&
                 ( (MD_ERROR_DATA_NOT_FOUND) != sc ) )
            {
                ciDebugOut(( DEB_WARN, "GetData password failed: 0x%x\n", sc ));
                THROW( CException( sc ) );
            }
        }
    }

    {
        METADATA_RECORD mdr;
        RtlZeroMemory( &mdr, sizeof mdr );
        mdr.dwMDIdentifier = MD_IS_CONTENT_INDEXED;
        mdr.dwMDAttributes = METADATA_INHERIT;
        mdr.pbMDData = (BYTE *) &fIsIndexed;
        mdr.dwMDDataLen = sizeof fIsIndexed;

        DWORD cbRequired = 0;
        SCODE sc = _xAdminBase->GetData( mdRoot.Get(),
                                         pwcRelative,
                                         &mdr,
                                         &cbRequired );

        if ( MD_ERROR_DATA_NOT_FOUND == sc )
        {
            fIsIndexed = FALSE;
        }
        else if ( FAILED( sc ) )
        {
            ciDebugOut(( DEB_WARN, "GetData isindexed failed: 0x%x\n", sc ));
            THROW( CException( sc ) );
        }
    }
    WCHAR awcVPath[METADATA_MAX_NAME_LEN];
    wcscpy( awcVPath, pwcRelative );
    WCHAR *pwcVPath = awcVPath;

    // Important: The metabase names root "/Root" the rest of the world
    //            names root "/".

    if ( !_wcsicmp( awcVPath, L"/Root" ) )
        awcVPath[1] = 0;
    else if ( !_wcsnicmp( awcVPath, L"/Root", 5 ) )
    {
        Win4Assert( L'/' == awcVPath[5] );
        pwcVPath = awcVPath + 5;
    }

    if ( 0 == awcPPath[0] )
    {
        // if there isn't a physical path, it isn't a virtual root.

        fVRoot = FALSE;

        if ( vrootStack.IsEmpty() )
        {
            awcPPath[0] = 0;
        }
        else
        {
            // generate a physical path based on the virtual path and
            // the most recent vroot parent on the stack

            ciDebugOut(( DEB_ITRACE,
                         "making vpath from vroot '%ws' proot '%ws' vpath '%ws'\n",
                         vrootStack.PeekTopVRoot(),
                         vrootStack.PeekTopPRoot(),
                         pwcVPath  ));

            wcscpy( awcPPath, vrootStack.PeekTopPRoot() );

            unsigned cwcVRoot = wcslen( vrootStack.PeekTopVRoot() );
            unsigned cwcPRoot = wcslen( vrootStack.PeekTopPRoot() );

            // The metabase can contain trailing backslashes in physical paths

            if ( L'\\' == awcPPath[ cwcPRoot - 1 ] )
                cwcPRoot--;

            wcscpy( awcPPath + cwcPRoot,
                    pwcVPath + ( ( 1 == cwcVRoot ) ? 0 : cwcVRoot ) );

            for ( WCHAR *pwc = awcPPath + cwcPRoot;
                  0 != *pwc;
                  pwc++ )
            {
                if ( L'/' == *pwc )
                    *pwc = L'\\';
            }

            ciDebugOut(( DEB_ITRACE, "resulting ppath: '%ws'\n", awcPPath ));
        }
    }

    // now we can finally call the callback

    if ( 0 != awcPPath[0] )
        callBack.CallBack( pwcVPath,
                           awcPPath,
                           fIsIndexed,
                           dwAccess,
                           awcUser,
                           awcPassword,
                           fVRoot );

    if ( fVRoot )
        vrootStack.Push( pwcVPath, awcPPath, dwAccess );

    return fVRoot;
} //ReportVPath

//+-------------------------------------------------------------------------
//
//  Member:     CMetaDataMgr::EnumVServers, public
//
//  Synopsis:   Enumerates virtual servers by calling the callback
//
//  Arguments:  [callBack] - called for each vroot
//
//  History:    07-Feb-1997   dlee    Created
//
//--------------------------------------------------------------------------

void CMetaDataMgr::EnumVServers( CMetaDataVirtualServerCallBack & callBack )
{
    Win4Assert( _fTopLevel );

    CMetaDataHandle mdRoot( _xAdminBase, _awcInstance );

    Enum( callBack, mdRoot, L"" );
} //EnumVRoots

//+-------------------------------------------------------------------------
//
//  Member:     CMetaDataMgr::ReportVirtualServer, private
//
//  Synopsis:   Helper method for reporting a virtual server via callback
//
//  Arguments:  [callBack]    - callback to call for virtual server
//              [pwcRelative] - relative path in metabase
//
//  History:    07-Feb-1997   dlee    Created
//
//--------------------------------------------------------------------------

void CMetaDataMgr::ReportVirtualServer(
    CMetaDataVirtualServerCallBack & callBack,
    CMetaDataHandle &                mdRoot,
    WCHAR const *                    pwcRelative )
{
    Win4Assert( _fTopLevel );

    // read the comment

    WCHAR awcComment[ METADATA_MAX_NAME_LEN ];
    awcComment[0] = 0;

    {
        METADATA_RECORD mdr;
        RtlZeroMemory( &mdr, sizeof mdr );
        mdr.dwMDIdentifier = MD_SERVER_COMMENT;
        mdr.pbMDData = (BYTE *) awcComment;
        mdr.dwMDDataLen = sizeof awcComment;

        DWORD cbRequired = 0;
        SCODE sc = _xAdminBase->GetData( mdRoot.Get(),
                                         pwcRelative,
                                         &mdr,
                                         &cbRequired );

        if ( ( FAILED( sc ) ) &&
             ( (MD_ERROR_DATA_NOT_FOUND) != sc ) )
        {
            ciDebugOut(( DEB_WARN, "GetData virtual server failed: 0x%x\n", sc ));
            THROW( CException( sc ) );
        }
    }

    //
    // Convert ID to integer
    //

    DWORD iInstance = wcstoul( pwcRelative, 0, 10 );

    // now we can finally call the callback

    callBack.CallBack( iInstance, awcComment );
} //ReportVirtualServer

//+-------------------------------------------------------------------------
//
//  Member:     CMetaDataMgr::Enum, private
//
//  Synopsis:   Helper method for enumerating vpaths
//
//  Arguments:  [vrootStack]  - stack of vroots for depth-first search
//              [callBack]    - callback to call when a vpath is found
//              [mdRoot]      - root of the enumeration
//              [pwcRelative] - relative location in enumeration
//
//  History:    07-Feb-1997   dlee    Created
//
//--------------------------------------------------------------------------

void CMetaDataMgr::Enum(
    CVRootStack &       vrootStack,
    CMetaDataCallBack & callBack,
    CMetaDataHandle &   mdRoot,
    WCHAR const *       pwcRelative )
{
    // enumerate looking for vpaths

    int c = wcslen( pwcRelative );
    WCHAR awcNewRelPath[ METADATA_MAX_NAME_LEN ];
    RtlCopyMemory( awcNewRelPath, pwcRelative, (c + 1) * sizeof WCHAR );

    if ( 0 == c ||
         L'/' != pwcRelative[c-1] )
    {
        wcscpy( awcNewRelPath + c, L"/" );
        c++;
    }

    for ( int i = 0; ; i++ )
    {
        WCHAR NameBuf[METADATA_MAX_NAME_LEN];
        SCODE sc =_xAdminBase->EnumKeys( mdRoot.Get(),
                                         pwcRelative,
                                         NameBuf,
                                         i );

        if ( RETURNCODETOHRESULT(ERROR_NO_MORE_ITEMS) == sc )
            break;

        if ( FAILED( sc ) )
        {
            ciDebugOut(( DEB_WARN, "EnumKeys error 0x%x\n", sc ));
            THROW( CException( sc ) );
        }

        Win4Assert( 0 != NameBuf[0] );

        Win4Assert( ( c + wcslen( NameBuf ) ) < METADATA_MAX_NAME_LEN );

        wcscpy( awcNewRelPath + c, NameBuf );

        BOOL fVRoot = ReportVPath( vrootStack,
                                   callBack,
                                   mdRoot,
                                   awcNewRelPath );

        Enum( vrootStack, callBack, mdRoot, awcNewRelPath );

        if ( fVRoot )
            vrootStack.Pop();
    }
} //Enum

//+-------------------------------------------------------------------------
//
//  Member:     CMetaDataMgr::Enum, private
//
//  Synopsis:   Helper method for enumerating virtual servers
//
//  Arguments:  [callBack]    - callback to call when a vserver is found
//              [mdRoot]      - root of the enumeration
//              [pwcRelative] - relative location in enumeration
//
//  History:    07-Feb-1997   dlee    Created
//
//--------------------------------------------------------------------------

void CMetaDataMgr::Enum(
    CMetaDataVirtualServerCallBack & callBack,
    CMetaDataHandle &                mdRoot,
    WCHAR const *                    pwcRelative )
{
    // enumerate looking for virtual servers

    for ( int i = 0; ; i++ )
    {
        WCHAR NameBuf[METADATA_MAX_NAME_LEN];
        SCODE sc =_xAdminBase->EnumKeys( mdRoot.Get(),
                                         pwcRelative,
                                         NameBuf,
                                         i );

        if ( RETURNCODETOHRESULT(ERROR_NO_MORE_ITEMS) == sc )
            break;

        if ( FAILED( sc ) )
        {
            ciDebugOut(( DEB_WARN, "EnumKeys error 0x%x\n", sc ));
            THROW( CException( sc ) );
        }

        ciDebugOut(( DEB_WARN, "Key: %ws\n", NameBuf ));

        //
        // Ignore things that don't look like virtual servers.
        //

        if ( !isdigit( NameBuf[0] ) )
            continue;

        //
        // Assume we just got a virtual server.
        //

        ReportVirtualServer( callBack, mdRoot, NameBuf );
    }
} //Enum

//+-------------------------------------------------------------------------
//
//  Member:     CMetaDataMgr::GetVRoot, public
//
//  Synopsis:   Returns the physical root corresponding to a virtual root
//
//  Arguments:  [pwcVRoot]  - VRoot to lookup
//              [pwcPRoot]  - where pwcVRoot's physical root is returned
//
//  History:    07-Feb-1997   dlee    Created
//
//--------------------------------------------------------------------------

void CMetaDataMgr::GetVRoot(
    WCHAR const * pwcVRoot,
    WCHAR *       pwcPRoot )
{
    Win4Assert( !_fTopLevel );

    unsigned cwc = wcslen( _awcInstance ) + wcslen( L"/Root" ) + wcslen( pwcVRoot );

    if ( cwc >= METADATA_MAX_NAME_LEN )
        THROW( CException( E_INVALIDARG ) );

    WCHAR awcVRootPath[ METADATA_MAX_NAME_LEN ];
    wcscpy( awcVRootPath, _awcInstance );
    wcscat( awcVRootPath, L"/Root" );
    wcscat( awcVRootPath, pwcVRoot );

    CMetaDataHandle mdVRoot( _xAdminBase, awcVRootPath, FALSE );

    *pwcPRoot = 0;

    {
        METADATA_RECORD mdr;
        RtlZeroMemory( &mdr, sizeof mdr );
        mdr.dwMDIdentifier = MD_VR_PATH;
        mdr.pbMDData = (BYTE *) pwcPRoot;
        mdr.dwMDDataLen = METADATA_MAX_NAME_LEN * sizeof WCHAR;

        DWORD cbRequired = 0;
        SCODE sc = _xAdminBase->GetData( mdVRoot.Get(),
                                         L"",
                                         &mdr,
                                         &cbRequired );

        if ( FAILED( sc ) )
        {
            ciDebugOut(( DEB_WARN, "GetData PRoot failed: 0x%x\n", sc ));
            THROW( CException( sc ) );
        }
    }
} //GetVRoot

//+-------------------------------------------------------------------------
//
//  Member:     CMetaDataMgr::GetVRootPW, public
//
//  Synopsis:   Returns the physical root corresponding to a virtual root
//
//  Arguments:  [pwcVRoot]  - VRoot to lookup
//              [pwcPRoot]  - where pwcVRoot's physical root is returned
//
//  History:    07-Feb-1997   dlee    Created
//
//--------------------------------------------------------------------------

void CMetaDataMgr::GetVRootPW(
    WCHAR const * pwcVRoot,
    WCHAR *       pwcPW )
{
    Win4Assert( !_fTopLevel );

    unsigned cwc = wcslen( _awcInstance ) + wcslen( L"/Root" ) + wcslen( pwcVRoot );

    if ( cwc >= METADATA_MAX_NAME_LEN )
        THROW( CException( E_INVALIDARG ) );

    WCHAR awcVRootPath[ METADATA_MAX_NAME_LEN ];
    wcscpy( awcVRootPath, _awcInstance );
    wcscat( awcVRootPath, L"/Root" );
    wcscat( awcVRootPath, pwcVRoot );

    CMetaDataHandle mdVRoot( _xAdminBase, awcVRootPath, FALSE );

    *pwcPW = 0;

    {
        METADATA_RECORD mdr;
        RtlZeroMemory( &mdr, sizeof mdr );
        mdr.dwMDIdentifier = MD_VR_PASSWORD;
        mdr.pbMDData = (BYTE *) pwcPW;
        mdr.dwMDDataLen = METADATA_MAX_NAME_LEN * sizeof WCHAR;

        DWORD cbRequired = 0;
        SCODE sc = _xAdminBase->GetData( mdVRoot.Get(),
                                         L"",
                                         &mdr,
                                         &cbRequired );

        //char ac[ 1000 ];
        //sprintf( ac, "result: 0x%x, cbResult: 0x%x, string: '%ws', char 1: 0x%x\n",
        //         sc, mdr.dwMDDataLen, pwcPW, (ULONG) *pwcPW );
        //DbgPrint( ac );

        if ( FAILED( sc ) )
        {
            ciDebugOut(( DEB_WARN, "GetData PRoot failed: 0x%x\n", sc ));
            THROW( CException( sc ) );
        }
    }
} //GetVRootPW

//+-------------------------------------------------------------------------
//
//  Member:     CMetaDataMgr::SetIsIndexed, public
//
//  Synopsis:   Sets the indexed state of a virtual path
//
//  Arguments:  [pwcPath]    - Virtual path (optionally a vroot) to set
//              [fIsIndexed] - if TRUE, path is indexed, if FALSE it isn't
//
//  History:    19-Mar-1997   dlee    Created
//
//--------------------------------------------------------------------------

void CMetaDataMgr::SetIsIndexed(
    WCHAR const * pwcVPath,
    BOOL          fIsIndexed )
{
    // Add the key if it doesn't exist yet

    {
        unsigned cwc = wcslen( _awcInstance ) + wcslen( L"/Root" );

        if ( cwc >= METADATA_MAX_NAME_LEN )
            THROW( CException( E_INVALIDARG ) );

        WCHAR awc[ METADATA_MAX_NAME_LEN ];
        wcscpy( awc, _awcInstance );
        wcscat( awc, L"/Root" );

        CMetaDataHandle mdRoot( _xAdminBase, awc, TRUE );

        _xAdminBase->AddKey( mdRoot.Get(), pwcVPath );
    }

    unsigned cwc = wcslen( _awcInstance ) + wcslen( L"/Root" ) + wcslen( pwcVPath );

    if ( cwc >= METADATA_MAX_NAME_LEN )
        THROW( CException( E_INVALIDARG ) );

    WCHAR awcCompleteVPath[ METADATA_MAX_NAME_LEN ];
    wcscpy( awcCompleteVPath, _awcInstance );
    wcscat( awcCompleteVPath, L"/Root" );
    wcscat( awcCompleteVPath, pwcVPath );

    CMetaDataHandle mdVRoot( _xAdminBase, awcCompleteVPath, TRUE );

    {
        METADATA_RECORD mdr;
        RtlZeroMemory( &mdr, sizeof mdr );
        mdr.dwMDIdentifier = MD_IS_CONTENT_INDEXED;
        mdr.dwMDAttributes = METADATA_INHERIT;
        mdr.dwMDUserType = IIS_MD_UT_FILE;
        mdr.dwMDDataType = DWORD_METADATA;
        mdr.pbMDData = (BYTE *) &fIsIndexed;
        mdr.dwMDDataLen = sizeof fIsIndexed;

        DWORD cbRequired = 0;
        SCODE sc = _xAdminBase->SetData( mdVRoot.Get(),
                                         L"",
                                         &mdr );

        if ( FAILED( sc ) )
        {
            ciDebugOut(( DEB_WARN, "SetData isindexed failed: 0x%x\n", sc ));
            THROW( CException( sc ) );
        }
    }
} //SetIsIndexed

//+-------------------------------------------------------------------------
//
//  Member:     CMetaDataMgr::IsIndexed, public
//
//  Synopsis:   Checks the path to return the state of the IsIndexed flag.
//              The default for no value is TRUE.  No checking is made to
//              if a parent directory is indexed or not.
//
//  Arguments:  [pwcVPath]  - Virtual path (optionally a vroot) to check
//
//  History:    19-Mar-1997   dlee    Created
//
//--------------------------------------------------------------------------

BOOL CMetaDataMgr::IsIndexed(
    WCHAR const * pwcVPath )
{
    BOOL fIsIndexed = TRUE;

    unsigned cwc = wcslen( _awcInstance ) + wcslen( L"/Root" ) + wcslen( pwcVPath );

    if ( cwc >= METADATA_MAX_NAME_LEN )
        THROW( CException( E_INVALIDARG ) );

    WCHAR awcCompletePath[ METADATA_MAX_NAME_LEN ];
    wcscpy( awcCompletePath, _awcInstance );
    wcscat( awcCompletePath, L"/Root" );
    wcscat( awcCompletePath, pwcVPath );

    TRY
    {
        CMetaDataHandle mdVRoot( _xAdminBase, awcCompletePath, FALSE );

        {
            METADATA_RECORD mdr;
            RtlZeroMemory( &mdr, sizeof mdr );
            mdr.dwMDIdentifier = MD_IS_CONTENT_INDEXED;
            mdr.dwMDAttributes = METADATA_INHERIT;
            mdr.pbMDData = (BYTE *) &fIsIndexed;
            mdr.dwMDDataLen = sizeof fIsIndexed;

            DWORD cbRequired = 0;
            SCODE sc = _xAdminBase->GetData( mdVRoot.Get(),
                                             L"",
                                             &mdr,
                                             &cbRequired );

            if ( MD_ERROR_DATA_NOT_FOUND == sc )
            {
                fIsIndexed = FALSE;
            }
            else if ( FAILED( sc ) )
            {
                ciDebugOut(( DEB_WARN, "GetData isindexed failed: 0x%x\n", sc ));
                THROW( CException( sc ) );
            }
        }
    }
    CATCH( CException, e )
    {
        // ignore -- assume IsIndexed
    }
    END_CATCH;

    return fIsIndexed;
} //IsIndexed

//+-------------------------------------------------------------------------
//
//  Member:     CMetaDataMgr::GetVPathFlags, public
//
//  Synopsis:   Returns flag settings on a virtual path
//
//  Arguments:  [pwcVPath]  - Virtual path (optionally a vroot) to check
//              [mdID]      - MD_x constant for the data
//              [ulDefault] - Default if no value is in the metabase
//
//  History:    18-Aug-1997   dlee    Created
//
//--------------------------------------------------------------------------

ULONG CMetaDataMgr::GetVPathFlags(
    WCHAR const * pwcVPath,
    ULONG         mdID,
    ULONG         ulDefault )
{
    unsigned cwc = wcslen( _awcInstance ) + wcslen( L"/Root" ) + wcslen( pwcVPath );

    if ( cwc >= METADATA_MAX_NAME_LEN )
        THROW( CException( E_INVALIDARG ) );

    WCHAR awcCompletePath[ METADATA_MAX_NAME_LEN ];
    wcscpy( awcCompletePath, _awcInstance );
    wcscat( awcCompletePath, L"/Root" );
    wcscat( awcCompletePath, pwcVPath );

    DWORD dwFlags = ulDefault;

    // Keep removing path components on the right of the path until
    // either out of path or the metabase recognizes the path.

    METADATA_HANDLE h;

    do
    {
        SCODE sc = _xAdminBase->OpenKey( METADATA_MASTER_ROOT_HANDLE,
                                         awcCompletePath,
                                         METADATA_PERMISSION_READ,
                                         cmsCIMetabaseTimeout,
                                         &h );

        if ( S_OK == sc )
        {
            break;
        }
        else if ( HRESULT_FROM_WIN32( ERROR_PATH_NOT_FOUND ) == sc )
        {
            WCHAR * pwc = wcsrchr( awcCompletePath, L'/' );
            if ( 0 == pwc )
                THROW( CException( sc ) );
            *pwc = 0;
        }
        else
            THROW( CException( sc ) );
    } while ( TRUE );

    CMetaDataHandle mdVRoot( _xAdminBase, h );

    {
        METADATA_RECORD mdr;
        RtlZeroMemory( &mdr, sizeof mdr );
        mdr.dwMDIdentifier = mdID;
        mdr.dwMDAttributes = METADATA_INHERIT;
        mdr.pbMDData = (BYTE *) &dwFlags;
        mdr.dwMDDataLen = sizeof dwFlags;

        DWORD cbRequired = 0;
        SCODE sc = _xAdminBase->GetData( mdVRoot.Get(),
                                         L"",
                                         &mdr,
                                         &cbRequired );

        if ( MD_ERROR_DATA_NOT_FOUND == sc )
        {
            // no value specified for this flag; use default

            dwFlags = ulDefault;
        }
        else if ( FAILED( sc ) )
        {
            ciDebugOut(( DEB_WARN, "GetData mdid %d failed: 0x%x on '%ws'\n",
                         mdID, sc, awcCompletePath ));
            THROW( CException( sc ) );
        }
    }

    return dwFlags;
} //GetVPathFlags

//+-------------------------------------------------------------------------
//
//  Member:     CMetaDataMgr::GetVPathAccess, public
//
//  Synopsis:   Returns access permission settings on a virtual path
//
//  Arguments:  [pwcVPath]  - Virtual path (optionally a vroot) to check
//
//  History:    18-Aug-1997   dlee    Created
//
//--------------------------------------------------------------------------

ULONG CMetaDataMgr::GetVPathAccess(
    WCHAR const * pwcVPath )
{
    // note: the default of 0 is from IIS' metabase guru

    return GetVPathFlags( pwcVPath, MD_ACCESS_PERM, 0 );
} //GetVPathAccess

//+-------------------------------------------------------------------------
//
//  Member:     CMetaDataMgr::GetVPathSSLAccess, public
//
//  Synopsis:   Returns SSL access permission settings on a virtual path
//
//  Arguments:  [pwcVPath]  - Virtual path (optionally a vroot) to check
//
//  History:    18-Aug-1997   dlee    Created
//
//--------------------------------------------------------------------------

ULONG CMetaDataMgr::GetVPathSSLAccess(
    WCHAR const * pwcVPath )
{
    // note: the default of 0 is from IIS' metabase guru

    return GetVPathFlags( pwcVPath, MD_SSL_ACCESS_PERM, 0 );
} //GetVPathSSLAccess

//+-------------------------------------------------------------------------
//
//  Member:     CMetaDataMgr::GetVPathAuthorization, public
//
//  Synopsis:   Returns authorization on a virtual path
//
//  Arguments:  [pwcVPath]  - Virtual path (optionally a vroot) to check
//
//  History:    18-Aug-1997   dlee    Created
//
//--------------------------------------------------------------------------

ULONG CMetaDataMgr::GetVPathAuthorization(
    WCHAR const * pwcVPath )
{
    // note: the default of MD_AUTH_ANONYMOUS is from IIS' metabase guru

    return GetVPathFlags( pwcVPath, MD_AUTHORIZATION, MD_AUTH_ANONYMOUS );
} //GetVPathAuthorization

//+-------------------------------------------------------------------------
//
//  Member:     CMetaDataComSink::SinkNotify, public
//
//  Synopsis:   Called for any metadata change
//
//  Arguments:  [cChanges]      - # of changes in pcoChangeList
//              [pcoChangeList] - list of changes
//
//  History:    07-Feb-1997   dlee    Created
//
//--------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE CMetaDataComSink::SinkNotify(
    DWORD            cChanges,
    MD_CHANGE_OBJECT pcoChangeList[] )
{
    // This is called by an RPC worker thread -- assimilate it

    TRANSLATE_EXCEPTIONS;
    TRY
    {
        int cwcInstance = wcslen( _awcInstance );
        BOOL fInterestingChange = FALSE;

        ciDebugOut(( DEB_WARN, "iis sinknotify '%ws', cchanges: %d\n",
                     _awcInstance, cChanges ));

        for ( DWORD i = 0; !fInterestingChange && i < cChanges; i++ )
        {
            MD_CHANGE_OBJECT & co = pcoChangeList[i];

            // we only care about notifications to our instance

            if ( _wcsnicmp( co.pszMDPath, _awcInstance, cwcInstance ) != 0 ||
                 ( L'/' != co.pszMDPath[cwcInstance] &&
                   L'\0' != co.pszMDPath[cwcInstance] ) )
                continue;

            // Ignore adds of vroots -- we'll get a set_data for its
            // parameters and trigger on that.

            if ( ( MD_CHANGE_TYPE_DELETE_OBJECT & co.dwMDChangeType ) ||
                 ( MD_CHANGE_TYPE_RENAME_OBJECT & co.dwMDChangeType ) )
            {
                // guess that the deletion was a vroot

                fInterestingChange = TRUE;
            }
            else if ( ( MD_CHANGE_TYPE_SET_DATA & co.dwMDChangeType ) ||
                      ( MD_CHANGE_TYPE_DELETE_DATA & co.dwMDChangeType ) )
            {
                for ( DWORD x = 0; x < co.dwMDNumDataIDs; x++ )
                {
                    DWORD id = co.pdwMDDataIDs[x];

                    if ( MD_VR_PATH            == id ||
                         MD_VR_USERNAME        == id ||
                         MD_VR_PASSWORD        == id ||
                         MD_ACCESS_PERM        == id ||
                         MD_IS_CONTENT_INDEXED == id )
                    {
                        fInterestingChange = TRUE;
                        break;
                    }
                }
            }
        }

        if ( fInterestingChange && ( 0 != _pCallBack ) )
            _pCallBack->CallBack( FALSE );
    }
    CATCH (CException, e)
    {
        ciDebugOut(( DEB_WARN,
                     "SinkNotify caught 0x%x\n",
                     e.GetErrorCode() ));
    }
    END_CATCH
    UNTRANSLATE_EXCEPTIONS;

    return S_OK;
} //SinkNotify

//+-------------------------------------------------------------------------
//
//  Member:     CMetaDataComSink::ShutdownNotify, public
//
//  Synopsis:   Called when iisadmin is going down cleanly
//
//  History:    07-Feb-1997   dlee    Created
//
//--------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE CMetaDataComSink::ShutdownNotify()
{
    // This is called by an RPC worker thread -- assimilate it

    TRANSLATE_EXCEPTIONS;
    TRY
    {
        ciDebugOut(( DEB_WARN, "iis shutdownnotify '%ws'\n", _awcInstance ));

        // in case we get more random notifications, ignore them

        CMetaDataVPathChangeCallBack * pCallBack = _pCallBack;
        _pCallBack = 0;

        pCallBack->CallBack( TRUE );
    }
    CATCH (CException, e)
    {
        ciDebugOut(( DEB_WARN,
                     "ShutdownNotify caught 0x%x\n",
                     e.GetErrorCode() ));
    }
    END_CATCH
    UNTRANSLATE_EXCEPTIONS;

    return S_OK;
} //ShutdownNotify
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\ntciutil\circstob.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1991 - 2000.
//
//  File:       CIRCSTOB.CXX
//
//  Contents:   Down-Level Recoverable Storage Object
//
//  Classes:    CiRcovStorageObj
//
//  History:    04-Feb-1994     SrikantS    Created
//
//----------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include <circstob.hxx>
#include <eventlog.hxx>

//+---------------------------------------------------------------------------
//
//  Function:   CiRcovStorageObj::CiRcovStorageObj
//
//  Synopsis:   Constructor for CiRcovStorageObj.
//
//  Effects:    Results in the initialization of the header information
//              of the recoverable storage object.
//
//  Arguments:  [storage]            --  Storage object for content index.
//              [wcsHdr]             --  Full path name of the header file.
//              [wcsCopy1]           --  Full path name of the copy 1.
//              [wcsCopy2]           --  Full path name of the copy 2.
//              [cbDiskSpaceToLeave] --  Megabytes to leave on disk
//              [fReadOnly]          --  Read only?
//
//  Modifies:
//
//  Algorithm:
//
//  History:    2-05-94   srikants   Created
//              11-30-94  srikants   Modified to deal with version
//                                   initialization.
//              02-12-98  kitmanh    Adding a readOnly parameter to the
//                                   constructor and changes to deal with
//                                   read-only catalogs
//              03-18-98  kitmanh    Init the embedded CMmStream with 
//                                   value of _fIsReadOnly 
//              27-Oct-98 KLam       Added cbDiskSpaceToLeave
//
//
//  Notes:      The constructor initializes the header information but
//              does not open the copy 1 or copy 2. That is does in the
//              QueryMmStream() method.
//
//----------------------------------------------------------------------------

CiRcovStorageObj::CiRcovStorageObj( CiStorage & storage, 
                                    WCHAR * wcsHdr,
                                    WCHAR * wcsCopy1,
                                    WCHAR * wcsCopy2,
                                    ULONG cbDiskSpaceToLeave,
                                    BOOL fReadOnly)
    : PRcovStorageObj( storage ),
      _storage(storage),
      _wcsCopy1(NULL),
      _wcsCopy2(NULL),
      _cbDiskSpaceToLeave(cbDiskSpaceToLeave),
      _hdrStrm(cbDiskSpaceToLeave),
      _fIsReadOnly(fReadOnly)
{
    

    Win4Assert( wcsHdr );
    Win4Assert( wcsCopy1 );
    Win4Assert( wcsCopy2 );

    _apMmStrm[0] = _apMmStrm[1] = NULL;

    //
    // Initialize the header stream (to reset value of CMmStrem::_fIsReadOnly) 
    //
    InithdrStrm(); 
    
    //
    // Open the header stream.
    //

    _hdrStrm.OpenExclusive( wcsHdr, _fIsReadOnly );

    if ( !_hdrStrm.Ok() )
    {
        THROW( CException() );
    }

    //
    // Check if this is the first time the recoverable object is being
    // constructed.
    //
    BOOL fVirgin = _hdrStrm.SizeLow() == 0 && _hdrStrm.SizeHigh() == 0;
    if ( fVirgin )
    {
        if ( !fReadOnly )
        {
            //
            // There is no data on disk.
            //
            _hdrStrm.SetSize( _storage, sizeof(CRcovStorageHdr), 0 );
            _hdrStrm.MapAll( _hdrSbuf );

            //
            // Make sure the new header makes it to disk.
            //

            WriteHeader();
        }
    }
    else
    {
        //
        // By default, the size of the mm stream is always set to the large
        // page. Here, we don't need it to be that big.
        //
        _hdrStrm.MapAll( _hdrSbuf );
        const BYTE * pbuf = (const BYTE *)_hdrSbuf.Get();
        _hdr.Init( (const void *) pbuf, sizeof(CRcovStorageHdr) );

        if ( _hdr.GetVersion() != _storage.GetStorageVersion() )
        {
            ciDebugOut(( DEB_ERROR,
                "Ci Version Mismatch - OnDisk 0x%X Binaries 0x%X\n",
                _hdr.GetVersion(), _storage.GetStorageVersion() ));

#if 0
            //
            // Disabled because general NT user does not want to be bothered by
            // the version change assert.
            //
            Win4Assert( !"The on disk catalog version and that of the binaries"
                         " are different\n. Catalog will be reindexed. Hit OK." );
#endif



            _storage.ReportCorruptComponent( L"CI-RcovStorageObj1" );

            THROW( CException( CI_INCORRECT_VERSION ) );
        }
    }

    Win4Assert( _hdr.GetVersion() == _storage.GetStorageVersion() );

    TRY
    {
        _wcsCopy1 = new WCHAR [wcslen(wcsCopy1)+1];
        _wcsCopy2 = new WCHAR [wcslen(wcsCopy2)+1];

        wcscpy( _wcsCopy1, wcsCopy1 );
        wcscpy( _wcsCopy2, wcsCopy2 );

        VerifyConsistency();
    }
    CATCH( CException, e )
    {
        delete [] _wcsCopy1;
        delete [] _wcsCopy2;
        RETHROW();
    }
    END_CATCH
}

CiRcovStorageObj::~CiRcovStorageObj()
{
    //
    // If the header stream is still mapped, then unmap it.
    //
    if ( _hdrSbuf.Get() ) {
        _hdrStrm.Unmap( _hdrSbuf );
    }
    _hdrStrm.Close();

    delete [] _wcsCopy1;
    delete [] _wcsCopy2;

    Close( CRcovStorageHdr::idxOne );
    Close( CRcovStorageHdr::idxTwo );

}

//+---------------------------------------------------------------------------
//
//  Function:   Open
//
//  Synopsis:   Opens the specified stream with the specified access.
//
//  Arguments:  [n]      --   Stream copy to open.
//              [fWrite] --   Flag indicating if open in write mode.
//
//  History:    2-05-94   srikants   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

void CiRcovStorageObj::Open( CRcovStorageHdr::DataCopyNum n, BOOL fWrite )
{
    AssertValidIndex(n);
    Win4Assert( !IsOpen(n) );

    //
    // Create the memory mapped stream with the specified open mode.
    //
    _apMmStrm[n] = QueryMmStream( n, fWrite );

}

//+---------------------------------------------------------------------------
//
//  Function:   Close
//
//  Synopsis:   Closes the specified stream if it is open. Also, if the
//              stream buffer associated with this stream is mapped, it
//              will be unmapped before closing.
//
//  Arguments:  [n] -- the stream copy to close.
//
//  History:    2-05-94   srikants   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

void CiRcovStorageObj::Close( CRcovStorageHdr::DataCopyNum n )
{

    AssertValidIndex(n);

    if ( IsOpen(n) )
    {

        //
        // If the stream is still mapped, then it must be
        // unmapped first.
        //
        if ( IsMapped(n) )
        {
            _apMmStrm[n]->Unmap( GetMmStreamBuf( n ) );
        }

        //
        // Closing the stream automatically flushes the contents.
        //
        _apMmStrm[n]->Close();
        delete _apMmStrm[n];
        _apMmStrm[n] = NULL;
    }

}

void CiRcovStorageObj::ReadHeader()
{
    const BYTE * pbHdr;

    Win4Assert( _hdrStrm.SizeLow() >= sizeof(CRcovStorageHdr) );

    pbHdr = (const BYTE *) _hdrSbuf.Get();
    Win4Assert( pbHdr );

    memcpy( &_hdr, pbHdr, sizeof(CRcovStorageHdr) );

}

void CiRcovStorageObj::WriteHeader()
{
    BYTE * pbHdr;

    Win4Assert( _hdrStrm.SizeLow() >= sizeof(CRcovStorageHdr) );
    Win4Assert( _hdrStrm.isWritable() );

    pbHdr = (BYTE *) _hdrSbuf.Get();
    Win4Assert( pbHdr );

    memcpy( pbHdr, &_hdr , sizeof(CRcovStorageHdr) );
    _hdrStrm.Flush( _hdrSbuf, sizeof(CRcovStorageHdr) );
}

//+---------------------------------------------------------------------------
//
//  Function:   QueryMmStream
//
//  Synopsis:   Creates a Memory Mapped Stream for the specified copy.
//              If one doesn't exist already, a new one will be created.
//
//  Arguments:  [n]         -- Copy number of the stream.
//              [fWritable] -- Set to TRUE if the stream is writable.
//
//  Returns:    Pointer to the memory mapped stream.
//
//  History:    2-05-94   srikants   Created
//              3-03-98   kitmanh    Added code to deal with read-only catalogs
//              27-Oct-98 KLam       Pass _cbDiskSpaceToLeave to CMmStream
//
//  Notes:      It is upto the caller to free up the object created.
//
//----------------------------------------------------------------------------

PMmStream *
CiRcovStorageObj::QueryMmStream( CRcovStorageHdr::DataCopyNum n,
                                 BOOL fWritable )
{
    WCHAR * wcsName = ( n == CRcovStorageHdr::idxOne ) ? _wcsCopy1 :
                        _wcsCopy2;

    CMmStream * pMmStrm = new CMmStream( _cbDiskSpaceToLeave, _fIsReadOnly );

    ULONG modeShare = 0;                // No sharing
    ULONG modeCreate = _fIsReadOnly ? OPEN_EXISTING : OPEN_ALWAYS;
    ULONG modeAccess = GENERIC_READ;

    if ( fWritable && !_fIsReadOnly )
    {
        modeAccess |= GENERIC_WRITE;
    }

    //
    // A Safe Pointer is needed because the open can fail.
    //
    XPtr<PMmStream>   sMmStrm( pMmStrm );
    pMmStrm->Open( wcsName,
                   modeAccess,
                   modeShare,
                   modeCreate,
                   FILE_ATTRIBUTE_NORMAL | FILE_ATTRIBUTE_NOT_CONTENT_INDEXED );
    if ( !pMmStrm->Ok() )
    {
        ciDebugOut(( DEB_ERROR, "querymmstrm failed due to %#x\n",
                     pMmStrm->GetStatus() ));
        THROW( CException(STATUS_OBJECT_PATH_INVALID) );
    }
    sMmStrm.Acquire();

    return pMmStrm;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\ntciutil\eventlog.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1994.
//
//  File:       eventlog.cxx
//
//  Contents:   CEventLog class
//
//  History:    07-Jun-94   DwightKr    Created
//
//--------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include <ciregkey.hxx>
#include <cievtmsg.h>

#include <pstore.hxx>
#include <eventlog.hxx>
#include <alocdbg.hxx>

//+-------------------------------------------------------------------------
//
//  Member:     CEventItem::CEventItem
//
//  Synopsis:   consturcts a CEventItem object.
//
//  Arguments:  [fType  ]   - Type of event
//              [fCategory] - Event Category
//              [eventId]   - Message file event identifier
//              [cArgs]     - Number of substitution arguments to be added
//              [cbData ]   - number of bytes in supplemental raw data.
//              [data   ]   - pointer to block of supplemental data.
//              
//  History:    12-30-96   mohamedn   raw data
//--------------------------------------------------------------------------
CEventItem::CEventItem( WORD   fType,
                        WORD   fCategory,
                        DWORD  eventId,
                        WORD   cArgs,
                        DWORD  dataSize, 
                        const void * data ) :
                        _fType(fType), 
                        _fCategory(fCategory),
                        _eventId(eventId),
                        _cArgsTotal(cArgs),
                        _pwcsData(0),
                        _cArgsUsed(0),
                        _dataSize(dataSize),
                        _data(data)
{
    _pwcsData = new WCHAR *[_cArgsTotal];
    memset( _pwcsData, 0, sizeof(WCHAR *) * _cArgsTotal );

    END_CONSTRUCTION(CEventItem);
}

//+-------------------------------------------------------------------------
//
//--------------------------------------------------------------------------
CEventItem::~CEventItem()
{
    for (WORD i=0; i<_cArgsTotal; i++)
        delete [] _pwcsData[i];

    delete [] _pwcsData;
}

//+-------------------------------------------------------------------------
//
//--------------------------------------------------------------------------
void CEventItem::AddArg( const WCHAR * wcsString )
{
    Win4Assert( _cArgsUsed < _cArgsTotal );
    Win4Assert( 0 != wcsString );

    _pwcsData[_cArgsUsed] = new WCHAR[wcslen(wcsString) + 1];
    wcscpy( _pwcsData[_cArgsUsed], wcsString );

    _cArgsUsed++;
}

//+-------------------------------------------------------------------------
//
//--------------------------------------------------------------------------
void CEventItem::AddArg( const ULONG ulValue )
{
    WCHAR wcsBuffer[20];
    _ultow( ulValue, wcsBuffer, 10 );

    AddArg(wcsBuffer);
}

//+---------------------------------------------------------------------------
//
//  Member:     CEventItem::AddError
//
//  Synopsis:   Adds the given error either as a HEX value or a decimal
//              value depending upon whether it is an NT error or WIN32 error.
//
//  Arguments:  [ulValue] - The error code to add.
//
//  History:    5-27-96   srikants   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

void CEventItem::AddError( ULONG ulValue )
{
    if ( !NT_SUCCESS(ulValue) )
    {
        WCHAR wszTemp[20];
        swprintf( wszTemp, L"0x%X", ulValue );
        AddArg( wszTemp );
    }
    else
    {
        AddArg( ulValue );
    }
}

//+-------------------------------------------------------------------------
//
//  Method:     CEventLog::CEventLog, public
//
//  Purpose:    Constructor
//
//  History:    07-Jun-94   DwightKr    Created
//
//--------------------------------------------------------------------------
CEventLog::CEventLog( const WCHAR * wcsUNCServer, const WCHAR * wcsSource) : _hEventLog(0)
{
    _hEventLog = RegisterEventSource( wcsUNCServer, wcsSource );

    if ( _hEventLog == NULL )
    {
        ciDebugOut( (DEB_ITRACE, "CEventLog: Could not register event source, rc=0x%x\n", GetLastError() ));
        THROW( CException() );
    }

    END_CONSTRUCTION( CEventLog );
}


//+-------------------------------------------------------------------------
//
//  Method:     CEventLog::~CEventLog, public
//
//  Purpose:    Destructor
//
//  History:    07-Jun-94   DwightKr    Created
//
//--------------------------------------------------------------------------
CEventLog::~CEventLog()
{
    DeregisterEventSource( _hEventLog );
}


//+-------------------------------------------------------------------------
//
//  Method:     CEventLog::ReportEvent
//
//  Purpose:    Allows writing records to event log
//
//  History:    07-Jun-94   DwightKr    Created
//              31-Dec-96   mohamedn    Added support for raw data in ReportEvent
//
//--------------------------------------------------------------------------
void CEventLog::ReportEvent( CEventItem & event )
{
    Win4Assert( event._cArgsTotal == event._cArgsUsed );

    //
    // No need to throw if ReportEvent returns an error because logging
    // is a low priority operation
    //
    if ( !::ReportEvent( _hEventLog,
                          event._fType,
                          event._fCategory,
                          event._eventId,
                          NULL,                    // Sid
                          event._cArgsUsed,
                          event._dataSize,         // Sizeof RAW data
                          (const WCHAR **) event._pwcsData,
                          (void *)event._data ))   // RAW data
    {
         ciDebugOut(( DEB_ERROR, "Error 0x%X while writing to eventlog\n",
                      GetLastError() ));

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\ntciutil\dynstrm.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1991 - 2000.
//
//  File:       DYNSTRM.CXX
//
//  Contents:   Dynamic Stream
//
//  History:    17-May-1993   BartoszM    Created
//              07-Dec-1993   DwightKr    Added Shrink() method
//              28-Jul-97     SitaramR    Added sequential read/write
//
//----------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include <dynstrm.hxx>

CDynStream::CDynStream()
        : _pStream(0)
{
}

CDynStream::CDynStream( PMmStream* stream)
: _pStream(stream)
{
}

CDynStream::~CDynStream()
{
    if ( 0 != _pStream )
    {
        _pStream->Unmap( _bufStream );

        delete _pStream;
    }
} //~CDynStream

//+---------------------------------------------------------------------------
//
//  Member:     CDynStream::Flush
//
//  Synopsis:   Marks a stream clean and flushes it to disk
//
//  History:    5-Oct-98   dlee     Created
//
//----------------------------------------------------------------------------

void CDynStream::Flush()
{
    if ( 0 != _pStream && _pStream->Ok() && _pStream->isWritable() )
    {
        MarkClean();
        _pStream->Flush( _bufStream, _bufStream.Size() );
    }
} //Flush

BOOL CDynStream::CheckVersion ( PStorage& storage, ULONG version, BOOL fIsReadOnly )
{
    if (!_pStream->Ok())
    {
        Win4Assert( !"Catalog corruption" );
        THROW( CException( CI_CORRUPT_DATABASE ));
    }
    if (_pStream->isEmpty() )
    {
        if ( !fIsReadOnly )
        {
            _pStream->SetSize( storage, CommonPageRound(HEADER_SIZE));
            _pStream->MapAll ( _bufStream );
            SetVersion(version);
            SetCount(0);
            SetDataSize(0);
            Flush();
        }
        else
            return FALSE;
    }
    else
        _pStream->MapAll ( _bufStream );

    if ( version != Version() )
        return FALSE;
    else
        return TRUE;
}

BOOL CDynStream::MarkDirty()
{
    BOOL fDirty = IsDirty();

    *((ULONG *) _bufStream.Get() + HEADER_DIRTY) = TRUE;
    _pStream->Flush( _bufStream, _bufStream.Size() );

    return fDirty;
}

void CDynStream::Grow ( PStorage& storage, ULONG newAvailSize )
{
    if (newAvailSize > _pStream->SizeLow() - HEADER_SIZE )
    {
        _pStream->SetSize ( storage,
            CommonPageRound(newAvailSize + HEADER_SIZE) );
        _pStream->Unmap(_bufStream);
        _pStream->MapAll ( _bufStream );
    }
    Win4Assert ( _pStream->SizeHigh() == 0 );
}


void CDynStream::Shrink ( PStorage& storage, ULONG newAvailSize )
{
    if (newAvailSize < _pStream->SizeLow() - HEADER_SIZE )
    {
        _pStream->Unmap(_bufStream);
        _pStream->SetSize ( storage,
                            CommonPageRound(newAvailSize + HEADER_SIZE) );
        _pStream->MapAll ( _bufStream );
    }
    Win4Assert ( _pStream->SizeHigh() == 0 );
}


//+---------------------------------------------------------------------------
//
//  Member:     CDynStream::InitializeForRead
//
//  Synopsis:   Prepare for reading in from disk
//
//  History:    28-Jul-97     SitaramR       Created
//
//----------------------------------------------------------------------------

void CDynStream::InitializeForRead()
{
    _ulDataSize = DataSize();
    _pStartPos = Get();
    _pCurPos = _pStartPos;
}


//+---------------------------------------------------------------------------
//
//  Member:     CDynStream::InitializeForWrite
//
//  Synopsis:   Prepare for writing to disk
//
//  Arguments:  [cbSize]  -- Total file size after writing
//
//  History:    28-Jul-97     SitaramR       Created
//
//----------------------------------------------------------------------------

void CDynStream::InitializeForWrite( ULONG cbSize )
{
    PStorage * pStorage = 0;
    Grow( *pStorage, cbSize );

    _ulDataSize = cbSize;
    SetCount( 0 );
    SetDataSize( _ulDataSize );
    _pStartPos = Get();
    _pCurPos = _pStartPos;
}


//+---------------------------------------------------------------------------
//
//  Member:     CDynStream::Read
//
//  Synopsis:   Sequential read
//
//  Arguments:  [pBuf]     -- Buffer to read into
//              [cbToRead] -- # bytes to read
//
//  History:    28-Jul-97     SitaramR       Created
//
//  Notes:      Call InitializeForRead before reading sequentially
//
//----------------------------------------------------------------------------

ULONG CDynStream::Read( void *pBuf, ULONG cbToRead )
{
    ULONG cbRead = 0;
    if ( _pCurPos + cbToRead < _pStartPos + _ulDataSize )
    {
        BYTE *pbDest = (BYTE *) pBuf;
        RtlCopyMemory( pbDest, _pCurPos, cbToRead );
        cbRead = cbToRead;
        _pCurPos += cbRead;
    }

    return cbRead;
}


//+---------------------------------------------------------------------------
//
//  Member:     CDynStream::Write
//
//  Synopsis:   Sequential write
//
//  Arguments:  [pBuf]      -- Buffer to write from
//              [cbToWrite] -- # bytes to write
//
//  History:    28-Jul-97     SitaramR       Created
//
//  Notes:      Call InitializeForWrite before writing sequentially
//
//----------------------------------------------------------------------------

void CDynStream::Write( void *pBuf, ULONG cbToWrite )
{
    if ( _pCurPos + cbToWrite > _pStartPos + _ulDataSize )
    {
        Win4Assert( _pCurPos + cbToWrite <= _pStartPos + _ulDataSize );
        THROW( CException( E_INVALIDARG ) );
    }

    BYTE *pSrc = (BYTE *)pBuf;
    RtlCopyMemory( _pCurPos, pSrc, cbToWrite );
    _pCurPos += cbToWrite;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\ntciutil\ntopen.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1991 - 1998.
//
//  File:       NtOpen.cxx
//
//  Contents:   Helper routines over Nt I/O API
//
//  History:    09-Dec-97   Kyle        Added header
//
//----------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include <ntopen.hxx>

//+---------------------------------------------------------------------------
//
//  Function:   CiNtOpenNoThrow
//
//  Synopsis:   Opens a file using NtOpenFile
//
//  Arguments:  [h]             -- Returns the handle
//              [pwcsPath]      -- Path of the file to open
//              [DesiredAccess] -- Access mask
//              [ShareAccess]   -- Sharing allowed
//              [OpenOptions]   -- NT open options
//
//  Returns:    The NTSTATUS result
//
//  History:    09-Dec-97   KyleP       Created.
//
//----------------------------------------------------------------------------

NTSTATUS CiNtOpenNoThrow(
    HANDLE & h,
    WCHAR const * pwcsPath,
    ACCESS_MASK DesiredAccess,
    ULONG ShareAccess,
    ULONG OpenOptions )
{
    h = INVALID_HANDLE_VALUE;
    UNICODE_STRING uScope;

    if ( !RtlDosPathNameToNtPathName_U( pwcsPath,
                                       &uScope,
                                        0,
                                        0 ) )
    {
        ciDebugOut(( DEB_ERROR, "Error converting %ws to Nt path\n", pwcsPath ));
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Open scope.
    //

    IO_STATUS_BLOCK IoStatus;
    OBJECT_ATTRIBUTES ObjectAttr;

    InitializeObjectAttributes( &ObjectAttr,          // Structure
                                &uScope,              // Name
                                OBJ_CASE_INSENSITIVE, // Attributes
                                0,                    // Root
                                0 );                  // Security

    NTSTATUS Status = NtOpenFile( &h,                 // Handle
                                  DesiredAccess,      // Access
                                  &ObjectAttr,        // Object Attributes
                                  &IoStatus,          // I/O Status block
                                  ShareAccess,        // Shared access
                                  OpenOptions );      // Flags

    RtlFreeHeap( RtlProcessHeap(), 0, uScope.Buffer );

    if ( NT_ERROR( Status ) )
    {
        vqDebugOut(( DEB_IERROR, "NtOpenFile( %ws ) returned 0x%lx\n",
                     pwcsPath, Status ));
        return Status;
    }

    return STATUS_SUCCESS;
} //CiNtOpenNoThrow

//+---------------------------------------------------------------------------
//
//  Function:   CiNtOpenNoThrow
//
//  Synopsis:   Opens a file using NtOpenFile
//
//  Arguments:  [pwcsPath]      -- Path of the file to open
//              [DesiredAccess] -- Access mask
//              [ShareAccess]   -- Sharing allowed
//              [OpenOptions]   -- NT open options
//
//  Returns:    The Handle of the opened file, throws on failure
//
//  History:    09-Dec-97   KyleP       Created.
//
//----------------------------------------------------------------------------

HANDLE CiNtOpen( WCHAR const * pwcsPath,
                 ACCESS_MASK DesiredAccess,
                 ULONG ShareAccess,
                 ULONG OpenOptions )
{
    HANDLE h;

    NTSTATUS Status = CiNtOpenNoThrow( h,
                                       pwcsPath,
                                       DesiredAccess,
                                       ShareAccess,
                                       OpenOptions );

    if ( STATUS_SUCCESS != Status )
        QUIETTHROW( CException( Status ) );

    return h;
} //CiNtOpen

#if 0 // no longer needed now that cnss does the right thing

//+---------------------------------------------------------------------------
//
//  Function:   CiNtFileSize, public
//
//  Synopsis:   Adds up size of all streams to report 'true' file size.
//
//  Arguments:  [h] -- Handle to file
//
//  Returns:    The total size of all streams or -1 if the volume does
//              not support streams (like FAT).
//
//  History:    09-Dec-97   KyleP       Created.
//              08-May-98   KLam        NtQueryInformationFile was incorrectly
//                                      checking for STATUS_BUFFER_TOO_SMALL
//
//----------------------------------------------------------------------------

LONGLONG CiNtFileSize( HANDLE h )
{

    XGrowable<FILE_STREAM_INFORMATION, 16> aStreamInfo;

    //
    // Zero first entry, in case there are none (e.g. directories).
    //

    RtlZeroMemory( aStreamInfo.Get(), sizeof(FILE_STREAM_INFORMATION) );

    NTSTATUS Status;

    do
    {
        IO_STATUS_BLOCK ioStatus;

        Status = NtQueryInformationFile( h,
                                         &ioStatus,
                                         (void *)aStreamInfo.Get(),
                                         aStreamInfo.Count() * sizeof(FILE_STREAM_INFORMATION),
                                         FileStreamInformation );

        //
        // fat volumes don't support multiple streams, so fail gracefully
        //

        if ( STATUS_INVALID_PARAMETER == Status )
            return -1;

        if ( STATUS_BUFFER_OVERFLOW == Status )
            aStreamInfo.SetSize( aStreamInfo.Count() * 2 );
        else
            break;

    } while ( TRUE );

    if ( !NT_SUCCESS(Status) )
    {
        ciDebugOut(( DEB_ERROR, "Error 0x%x from NtQueryInformationFile(FileStreamInformation)\n", Status ));
        THROW( CException( Status ) );
    }

    //
    // Iterate through the streams, adding up the sizes.
    //

    FILE_STREAM_INFORMATION * pStreamInfo = aStreamInfo.Get();
    LONGLONG cbSize = pStreamInfo->StreamSize.QuadPart;

    for ( ;
          0 != pStreamInfo->NextEntryOffset;
          pStreamInfo = (FILE_STREAM_INFORMATION *)(((BYTE *)pStreamInfo) + pStreamInfo->NextEntryOffset),
              cbSize += pStreamInfo->StreamSize.QuadPart )
    {
        continue; // Null body
    }

    return cbSize;
}

#endif // 0
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\ntciutil\idxtab.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1991 - 2000.
//
//  File:   IDXTAB.CXX
//
//  Contents:   Index Manager
//
//  Classes:    CIndexTable
//
//  History:    22-Mar-91   BartoszM    Created.
//              12-Feb-92   AmyA        Hacked all methods for FAT.
//              01-Jul-93   BartoszM    Rewrote to use memory mapped file
//
//----------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include <cistore.hxx>
#include <idxtab.hxx>
#include <eventlog.hxx>
#include <imprsnat.hxx>

//+---------------------------------------------------------------------------
//----------------------------------------------------------------------------
CWriteIndexFile::CWriteIndexFile ( PRcovStorageObj & rcovObj ) :
    _rcovObj(rcovObj),
    _xact(rcovObj),
    _iter(_xact, sizeof(CIndexRecord)),
    _xactPtr(0)
{
}


//+---------------------------------------------------------------------------
//----------------------------------------------------------------------------
void CWriteIndexFile::BackUp()
{
    ciAssert(_xactPtr > 0);

    _xactPtr--;
    _iter.Seek( _xactPtr );
}


//+---------------------------------------------------------------------------
//----------------------------------------------------------------------------
BOOL CWriteIndexFile::ReadRecord ( CIndexRecord * pRecord )
{
    ULONG ulRecCnt = _rcovObj.GetHeader().GetCount(_rcovObj.GetHeader().GetBackup());

    if (_xactPtr >= ulRecCnt)
        return(FALSE);

    _iter.GetRec( pRecord );
    _xactPtr++;

    return(TRUE);
}


//+---------------------------------------------------------------------------
//----------------------------------------------------------------------------
void CWriteIndexFile::WriteRecord ( CIndexRecord* pRecord )
{
    _iter.SetRec( pRecord );
    _xactPtr++;

    ULONG ulRecCnt = _rcovObj.GetHeader().GetCount(_rcovObj.GetHeader().GetBackup());

    if (ulRecCnt < _xactPtr)
        _rcovObj.GetHeader().SetCount(_rcovObj.GetHeader().GetBackup(), _xactPtr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CWriteIndexFile::IncrMMergeSeqNum
//
//  Synopsis:   Increments the master merge sequence number in the header.
//
//  History:    3-21-97   srikants   Created
//
//----------------------------------------------------------------------------

void CWriteIndexFile::IncrMMergeSeqNum()
{

    CRcovStorageHdr & storageHdr =  _rcovObj.GetHeader();

    CRcovUserHdr usrHdr;
    CIndexTableUsrHdr * pIdxUsrHdr = (CIndexTableUsrHdr *) &usrHdr;

    storageHdr.GetUserHdr( storageHdr.GetPrimary(), usrHdr );
    ciDebugOut(( DEB_ITRACE, "Current MMerge Seq Num = %d \n",
                 pIdxUsrHdr->GetMMergeSeqNum() ));

    pIdxUsrHdr->IncrMMergeSeqNum();

    ciDebugOut(( DEB_ITRACE, "New MMerge Seq Num = %d \n",
                 pIdxUsrHdr->GetMMergeSeqNum() ));

    storageHdr.SetUserHdr( storageHdr.GetBackup(), usrHdr );
}


//+---------------------------------------------------------------------------
//----------------------------------------------------------------------------
CReadIndexFile::CReadIndexFile ( PRcovStorageObj & rcovObj ) :
    _rcovObj(rcovObj),
    _xact(rcovObj),
    _iter(_xact, sizeof(CIndexRecord)),
    _xactPtr(0)
{
}


//+---------------------------------------------------------------------------
//----------------------------------------------------------------------------
void CReadIndexFile::BackUp()
{
    ciAssert(_xactPtr > 0);

    _xactPtr--;
    _iter.Seek( _xactPtr );
}


//+---------------------------------------------------------------------------
//----------------------------------------------------------------------------
BOOL CReadIndexFile::ReadRecord ( CIndexRecord * pRecord )
{
    ULONG ulRecCnt = _rcovObj.GetHeader().GetCount(_rcovObj.GetHeader().GetPrimary());

    if (_xactPtr >= ulRecCnt)
        return(FALSE);

    _iter.GetRec( pRecord );
    _xactPtr++;

    return(TRUE);
}


//+---------------------------------------------------------------------------
//
//  Member:     CAddReplaceIndexRecord::CAddReplaceIndexRecord, public
//
//  Synopsis:   Rewinds the file pointer indFile, then reads in IndexRecords until
//              either a record with INDEXID iid is found or EOF is reached.
//
//  Notes:      Whether or not a record with INDEXID iid is found can be
//              determined by calling Found().
//
//  History:    16-Mar-92   AmyA           Created.
//
//----------------------------------------------------------------------------

CAddReplaceIndexRecord::CAddReplaceIndexRecord ( CWriteIndexFile & indFile,
                                         INDEXID iid )
                                         : _indFile( indFile )

{
    _indFile.Rewind();

    do
    {
        _found = _indFile.ReadRecord ( this );
    } while (_found && Iid() != iid);
}


//+---------------------------------------------------------------------------
//
//  Member:     CAddReplaceIndexRecord::Write()
//
//  Synopsis:   Writes the information from CIndexRecord out to the file--
//              either replacing the record that was found in the constructor
//              (if there was one found) or appending to the end of the file
//              indicated by _indFile.
//
//  History:    28-Feb-95   DwightKr       Created.
//
//----------------------------------------------------------------------------

inline void CAddReplaceIndexRecord::WriteRecord()
{
    if ( Found() )
    {
        _indFile.BackUp();
    }

    _indFile.WriteRecord( this );
}

//+---------------------------------------------------------------------------
//
//  Member:     CIndexTable::CIndexTable, public
//
//  Synopsis:   Constructor.
//
//  History:    28-Mar-91   BartoszM       Created.
//
//----------------------------------------------------------------------------

CIndexTable::CIndexTable ( CiStorage& storage, CTransaction& xact )
: _storage(storage), _pRcovObj(0)
{
    _pRcovObj = _storage.QueryIdxTableObject();
    Win4Assert( 0 != _pRcovObj );
}

//+---------------------------------------------------------------------------
//
//  Member:     CIndexTable::~CIndexTable, public
//
//  Synopsis:   Destructor.
//
//  History:    28-May-92   BartoszM       Created.
//
//----------------------------------------------------------------------------

CIndexTable::~CIndexTable ()
{
    delete _pRcovObj;
}


//+---------------------------------------------------------------------------
//
//  Member:     CIndexTableIter::CIndexTableIter
//
//  Synopsis:   Constructor.
//
//  History:    28-May-92   BartoszM       Created.
//
//----------------------------------------------------------------------------

CIndexTabIter::CIndexTabIter ( CIndexTable& idxTable )
        : _idxTable(idxTable),
          _indFile( idxTable.GetIndexTableObj() )
{
}


//+---------------------------------------------------------------------------
//
//  Member:     CIndexTabIter::Begin, public
//
//  Synopsis:   Position cursor at the beginning of table
//
//  History:    28-Mar-91   BartoszM       Created.
//
//----------------------------------------------------------------------------

BOOL CIndexTabIter::Begin ()
{
    CNextIndexRecord rec(_indFile);

    if (!rec.Found())
        return FALSE;

    _indFile.Rewind();

    return TRUE;
}


//+---------------------------------------------------------------------------
//
//  Member:     CIndexTabIter::NextRecord, public
//
//  Synopsis:   Called during startup. Reads next record
//
//  Arguments:  [indexRecord] -- record to be filled
//
//  History:    28-Mar-91   BartoszM       Created.
//
//----------------------------------------------------------------------------

BOOL CIndexTabIter::NextRecord ( CIndexRecord& indexRecord )
{
    CNextIndexRecord rec(_indFile);

    if (!rec.Found())
        return(FALSE);

    if ( rec.VersionStamp() < _idxTable._storage.GetStorageVersion() )
    {
        Win4Assert ( !"Corrupt index table" );

        PStorage & storage = GetStorage();

        storage.ReportCorruptComponent ( L"IndexTable1" );

        THROW( CException ( STATUS_INTERNAL_DB_CORRUPTION ));
    }
    else if ( rec.VersionStamp() > _idxTable._storage.GetStorageVersion() )
    {
        ciAssert ( !"Unknown index format: upgrade index software" );

        PStorage & storage = GetStorage();

        storage.ReportCorruptComponent ( L"IndexTable2" );

        THROW( CException ( STATUS_INTERNAL_DB_CORRUPTION ));
    }

    indexRecord._objectId = rec.ObjectId();
    indexRecord._iid = rec.Iid();
    indexRecord._type = rec.Type();
    indexRecord._maxWorkId = rec.MaxWorkId();

    return TRUE;
}

//+---------------------------------------------------------------------------
//
//  Member:     CIndexTabIter::~CIndexTabIter, public
//
//  Synopsis:   Iteration finished
//
//  History:    28-Mar-91   BartoszM       Created.
//
//----------------------------------------------------------------------------

CIndexTabIter::~CIndexTabIter()
{
}

//+---------------------------------------------------------------------------
//
//  Member:     CIndexTable::SwapIndexes, public
//
//  Synopsis:   Replaces old indexes with a new one after merge
//
//  Arguments:  [pIndexNew] -- new index
//              [cIndexOld] -- count of old indexes to be removed
//              [aIidOld] -- array of old index id's
//
//  Notes:      ResMan LOCKED
//
//  History:    02-May-91   BartoszM       Created.
//
//----------------------------------------------------------------------------

void CIndexTable::SwapIndexes ( CShadowMergeSwapInfo & info )
{
    CIndexRecord & record = info._recNewIndex;

    ciDebugOut (( DEB_ITRACE, "IndexManager: Adding index %lx, maxWid %ld\n",
        record.Iid(), record.MaxWorkId() ));

    CWriteIndexFile indFile( GetIndexTableObj() );

    // Mark old indexes deleted

    for ( unsigned i = 0; i < info._cIndexOld; i++ )
    {
        CIndexId idFull = info._aIidOld[i];
        if ( idFull.IsPersistent())
        {
            CAddReplaceIndexRecord rec(indFile, info._aIidOld[i]);
            if (!rec.Found())                   
            {
                //
                //  We have a persistent index which was not found in the
                //  index list.  This must be an index corruption.
                //

                ciDebugOut(( DEB_ERROR, "Can't find index 0x%lx\n",
                        info._aIidOld[i] ));
                Win4Assert( !"Corrupt index table" );
                _storage.ReportCorruptComponent( L"IndexTable3" );

                THROW( CException ( CI_CORRUPT_DATABASE ));
            }
            rec.SetType(itZombie);                      // And one more....
            rec.WriteRecord();
        }
    }

    //
    // Add record for the new index.
    //

    if ( widInvalid != record.ObjectId() )
        AddRecord ( indFile,
                    record.Iid(),
                    record.Type(),
                    record.MaxWorkId(),
                    record.ObjectId() );

    //
    // Replace the old fresh test entry with the new fresh test entry.
    //
    DeleteObject( indFile, partidDefault, itFreshLog, info._widOldFreshLog );
    AddRecord( indFile, CIndexId( 0, partidDefault ), itFreshLog,
               0, info._widNewFreshLog );

    indFile.Commit();
}

//+---------------------------------------------------------------------------
//
//  Function:   SwapIndexes
//
//  Synopsis:   This method marks the old indexes as "zombie" in the index
//              table, deletes the MMLog, MMFreshLog and NewMasterIndex
//              entries. It then adds an entry making the NewMaster the
//              current master.
//
//              This is done as a single TRANSACTION - either the entire
//              step succeeds or the previous state is retained.
//
//  Effects:    All the indexes that participated in the master merge will
//              be deleted from the index list and the new master will be
//              made the only master index.
//
//  Arguments:  [partid]       --  Partition Id where the master merge just
//              completed.
//              [cIndexOld]    --  Count of the indexes in aIidOld.
//              [aIidOld]      --  Array of index ids to be marked zombie.
//              [recNewMaster] --  CIndexRecord for the new master index.
//              [widMMLog]     --  WorkId of the MMLog object.
//
//  History:    4-04-94   srikants   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
void CIndexTable::SwapIndexes ( CMasterMergeSwapInfo & info )
{
    CIndexRecord & recNewMaster = info._recNewIndex;
    CIndexRecord & recNewKeyList = info._recNewKeyList;

    ciDebugOut (( DEB_ITRACE, "Master Merge Completed\n"));

    CWriteIndexFile indFile( GetIndexTableObj() );

    //
    // Mark old indexes as "Zombie".
    //
    for ( unsigned i = 0; i < info._cIndexOld; i++ )
    {
        CIndexId idFull = info._aIidOld[i];
        Win4Assert( idFull.IsPersistent() );
        Win4Assert( idFull.PartId() == info._partid );

        CAddReplaceIndexRecord rec(indFile, info._aIidOld[i]);

        if (!rec.Found())
        {
            //
            //  We have a persistent index which was not found in the
            //  index list.  This must be an index corruption.
            //

            ciDebugOut(( DEB_ERROR, "Can't find index 0x%lx\n",
                    info._aIidOld[i] ));
            Win4Assert( !"Corrupt index table" );
            _storage.ReportCorruptComponent( L"IndexTable4" );

            THROW( CException ( CI_CORRUPT_DATABASE ));
        }
        rec.SetType(itZombie);                      // And one more....
        rec.WriteRecord();
    }

    //
    // Delete the MMLog entry.
    //
    DeleteObject( indFile, info._partid, itMMLog, info._widMMLog );

    //
    // Delete the itMMKeyList entry.
    //
    DeleteObject( indFile, partidKeyList, itMMKeyList,
                  recNewKeyList.ObjectId() );

    //
    // Delete the old itKeyList entry and add an entry for the new
    // key list.
    //
    {
        //
        // DeleteRecord assumes that the record is found. When we create
        // the key list for the first time, it may not be present.
        //
        CAddReplaceIndexRecord rec( indFile, info._iidOldKeyList );
        if ( rec.Found() )
        {
            rec.SetIid( CIndexId(iidInvalid,partidInvalid) );
            rec.WriteRecord();
        }
    }

    AddRecord( indFile, recNewKeyList.Iid(),
               recNewKeyList.Type(),
               recNewKeyList.MaxWorkId(),
               recNewKeyList.ObjectId()
             );
    //
    // Delete the entry for the new master index and make it the
    // current master index.
    //
    DeleteRecord( indFile, recNewMaster.Iid() );
    AddRecord (
        indFile,
        recNewMaster.Iid(),
        itMaster,       // Note the change from itNewMaster to itMaster
        recNewMaster.MaxWorkId(),
        recNewMaster.ObjectId());

    //
    // Replace the old fresh test entry with the new fresh test entry.
    //
    DeleteObject( indFile, partidDefault, itFreshLog, info._widOldFreshLog );
    AddRecord( indFile, CIndexId( 0, partidDefault ), itFreshLog, 0,
               info._widNewFreshLog );

    //
    // Increment the master merge sequence number.
    //
    indFile.IncrMMergeSeqNum();
    indFile.Commit();
}

PIndexTabIter* CIndexTable::QueryIterator()
{
    return new CIndexTabIter ( *this );
}

PStorage& CIndexTable::GetStorage()
{
    return(_storage);
}

//+---------------------------------------------------------------------------
//
//  Member:     CIndexTable::RemoveIndex, public
//
//  Synopsis:   Removes index from table
//
//  Arguments:  [iid] -- index id
//
//  Notes:      ResMan LOCKED
//
//  History:    02-May-91   BartoszM       Created.
//
//----------------------------------------------------------------------------

#pragma optimize( "", off )
void CIndexTable::RemoveIndex ( INDEXID iid )
{
    CImpersonateSystem impersonate;

    CWriteIndexFile indFile( GetIndexTableObj() );

    DeleteRecord( indFile, iid );

    indFile.Commit();
}
#pragma optimize( "", on )


//+---------------------------------------------------------------------------
//
//  Function:   AddObject
//
//  Synopsis:   Appends a record for the specified object to the
//              index table.
//
//  Arguments:  [partid] -- Id of the partition to which the object
//              belongs.
//              [it]     -- Index type of the object.
//              [wid]    -- WorkId of the object.
//
//  History:    2-18-94   srikants   Created
//
//----------------------------------------------------------------------------

void CIndexTable::AddObject( PARTITIONID partid, IndexType it, WORKID wid )
{
    CWriteIndexFile indFile( GetIndexTableObj() );

    AddRecord ( indFile, CIndexId ( 0, partid ), it, 0, wid );

    indFile.Commit();
}

//+---------------------------------------------------------------------------
//
//  Function:   AddMMergeObjects
//
//  Synopsis:   This method adds records for the NewMaster Index,
//              and MasterMerge Log to the index table.
//
//  Arguments:  [partid]       --  Partition id of the partition in which
//              master merge is being done.
//              [recNewMaster] --  The index record for the new master index.
//              [widMMLog]     --  WorkId of the MasterMerge Log.
//              [deletedIndex] --  Index id for the current index
//
//  History:    4-04-94   srikants   Created
//
//  Notes:      The recNewMaster must be fully initialized with the correct
//              indexType, WorkId and MaxWorkId.
//
//----------------------------------------------------------------------------

void CIndexTable::AddMMergeObjects( PARTITIONID partid,
                           CIndexRecord & recNewMaster,
                           WORKID  widMMLog,
                           WORKID  widMMKeyList,
                           INDEXID iidDelOld,
                           INDEXID iidDelNew )
{

    CWriteIndexFile indFile( GetIndexTableObj() );

    Win4Assert( recNewMaster.Type() == itNewMaster );
    Win4Assert( iidDeleted1 == iidDelOld && iidDeleted2 == iidDelNew ||
                iidDeleted2 == iidDelOld && iidDeleted1 == iidDelNew );

#if CIDBG == 1
    CIndexId iid( recNewMaster.Iid() );
    Win4Assert( iid.PartId() == partid );
#endif  // CIDBG == 1

    AddRecord( indFile, recNewMaster.Iid(), itNewMaster,
               recNewMaster.MaxWorkId(), recNewMaster.ObjectId() );
    AddRecord( indFile, CIndexId( 0, partid ), itMMLog, 0,widMMLog );
    AddRecord( indFile, CIndexId( 0, partidKeyList ), itMMKeyList, 0, widMMKeyList );

    DeleteRecord( indFile, iidDelOld );
    AddRecord( indFile, iidDelNew, itDeleted, 0, 0 );

    indFile.Commit();
}


inline BOOL IsMatched( const CIndexRecord & rec,
                       INDEXID iid, IndexType it, WORKID wid )
{
    return rec.Type() == (ULONG) it && rec.Iid() == iid && rec.ObjectId() == wid ;
}

//+---------------------------------------------------------------------------
//
//  Function:   DeleteObject
//
//  Synopsis:   Deletes the record for the specified object by marking
//              it as "iidInvalid". The record will be deleted only
//              if there is an exact match with the partid, it and wid.
//
//  Arguments:  [partid] --  Partition Id.
//              [it]     --  Index type of the object.
//              [wid]    --  Work Id to match on.
//
//  History:    2-18-94   srikants   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
void CIndexTable::DeleteObject( PARTITIONID partid, IndexType it, WORKID wid )
{
    CWriteIndexFile indFile( GetIndexTableObj() );
    DeleteObject( indFile, partid, it, wid );
    indFile.Commit();
}

void CIndexTable::DeleteObject( CWriteIndexFile & indFile,
            PARTITIONID partid, IndexType it, WORKID wid )
{
    CIndexRecord    rec;
    BOOL found;
    indFile.Rewind();
    do
    {
        found = indFile.ReadRecord ( &rec );
    }
    while ( found && !IsMatched( rec, CIndexId(0, partid), it, wid) );

    if ( found ) {
        indFile.BackUp();
        rec._iid = (INDEXID) CIndexId(iidInvalid, partidInvalid);
        rec._objectId =  widInvalid;
        indFile.WriteRecord( &rec );
    }
}


//+---------------------------------------------------------------------------
//
//  Member:     CIndexTable::AddRecord, private
//
//  Synopsis:   Adds new record to table
//
//  Arguments:  [iid] -- index id
//              [type] -- type of record
//              [maxWorkId] -- max work id in the index
//              [objectId] -- id of the index object
//
//  Notes:      ResMan LOCKED
//
//  History:    02-May-91   BartoszM       Created.
//
//----------------------------------------------------------------------------

void CIndexTable::AddRecord( CWriteIndexFile & indFile,
                               INDEXID iid,
                               ULONG type,
                               WORKID maxWorkId,
                               WORKID objectId )
{
    ciDebugOut (( DEB_ITRACE, "Indexes: AddRecord %lx, %ld %s\n",
        iid, maxWorkId, (type == itMaster)? "master": "not-master" ));

    CAddReplaceIndexRecord rec(indFile, CIndexId(iidInvalid,partidInvalid) );

    rec.SetIid(iid);
    rec.SetType(type);
    rec.SetWid(maxWorkId);
    rec.SetObjectId ( objectId );
    rec.WriteRecord();
}



//+---------------------------------------------------------------------------
//
//  Member:     CIndexTable::AddIndex, public
//
//  Synopsis:   Adds new index to table
//
//  Arguments:  [iid] -- index id
//              [type] -- type of record
//              [maxWorkId] -- max work id in the index
//              [objectId] -- id of the index object
//
//  Notes:      ResMan LOCKED
//
//  History:    14-Jul-94   DwightKr       Created.
//
//----------------------------------------------------------------------------
void CIndexTable::AddIndex( INDEXID iid,
                            IndexType type,
                            WORKID maxWorkId,
                            WORKID objectId )
{
    CWriteIndexFile indFile( GetIndexTableObj() );
    AddRecord( indFile, iid, type, maxWorkId, objectId );
    indFile.Commit();
}


//+---------------------------------------------------------------------------
//
//  Member:     CIndexTable::LokEmpty, public
//
//  Synopsis:   Deleted everything from the index table
//
//  Notes:      ResMan LOCKED
//
//  History:    16-Aug-94   DwightKr    Created
//
//----------------------------------------------------------------------------
void CIndexTable::LokEmpty()
{

    PRcovStorageObj & rcovObj = GetIndexTableObj();
    CRcovStrmWriteTrans xact( rcovObj );

    rcovObj.GetHeader().SetCount( rcovObj.GetHeader().GetBackup(), 0 );
    xact.Empty();
    xact.Seek(0);

    xact.Commit();
}

//+---------------------------------------------------------------------------
//
//  Member:     CIndexTable::LokMakeBackupCopy
//
//  Synopsis:   Makes a backup copy of the index table.
//
//  Arguments:  [storage]         - Storage to use for creation of the
//              destination index table.
//              [fFullSave]       - Set to TRUE if a full save is being performed.
//              [progressTracker] - Progress tracker.
//
//  History:    3-18-97   srikants   Created
//
//----------------------------------------------------------------------------

void CIndexTable::LokMakeBackupCopy( PStorage & storage,
                                     BOOL fFullSave,
                                     PSaveProgressTracker & progressTracker )
{

    //
    // Create a new index table object using the storage provided.
    //
    PRcovStorageObj * pDstObj = storage.QueryIdxTableObject();
    XPtr<PRcovStorageObj> xDstObj( pDstObj );

    PRcovStorageObj & srcObj = GetIndexTableObj();

    //
    // Copy the contents of source to destination.
    //
    CCopyRcovObject copier( *pDstObj, srcObj );
    NTSTATUS status = copier.DoIt();

    if ( STATUS_SUCCESS != status )
    {
        THROW(CException(status) );
    }

    //
    // Set the Full/Partial Save bit appropriately.
    //
    CRcovStrmAppendTrans    xact( *pDstObj );

    CRcovStorageHdr & storageHdr = pDstObj->GetHeader();

    CRcovUserHdr usrHdr;
    CIndexTableUsrHdr * pIdxUsrHdr = (CIndexTableUsrHdr *) &usrHdr;

    storageHdr.GetUserHdr( storageHdr.GetBackup(), usrHdr );

    if ( fFullSave )
        pIdxUsrHdr->SetFullSave();
    else pIdxUsrHdr->ClearFullSave();

    storageHdr.SetUserHdr( storageHdr.GetBackup(), usrHdr );

    xact.Commit();

}

//+---------------------------------------------------------------------------
//
//  Member:     CIndexTable::GetUserHdrInfo
//
//  Synopsis:   Retrieves the information in the user header.
//
//  Arguments:  [mMergeSeqNum] - Master Merge sequence number.
//              [fFullSave]    - Set to TRUE if a full save was performed.
//
//  History:    3-21-97   srikants   Created
//
//----------------------------------------------------------------------------

void CIndexTable::GetUserHdrInfo( unsigned & mMergeSeqNum, BOOL & fFullSave )
{
    PRcovStorageObj & obj = GetIndexTableObj();

    CRcovUserHdr usrHdr;
    CIndexTableUsrHdr * pIdxUsrHdr = (CIndexTableUsrHdr *) &usrHdr;

    CRcovStorageHdr & storageHdr =  obj.GetHeader();

    storageHdr.GetUserHdr( storageHdr.GetPrimary(), usrHdr );
    ciDebugOut(( DEB_ERROR, "Current MMerge Seq Num = %d \n",
                 pIdxUsrHdr->GetMMergeSeqNum() ));

    mMergeSeqNum = pIdxUsrHdr->GetMMergeSeqNum();
    fFullSave = pIdxUsrHdr->IsFullSave();

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\ntciutil\cistore.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1993 - 2002.
//
//  File:       cistore.cxx
//
//  Contents:   CI physical storage
//
//  Classes:    CiStorage
//
//  History:    07-Jul-93   BartoszM    Separated from physidx.cxx
//              20-Nov-98   KLam        Moved IsVolumeWriteProtected to CDriveInfo
//
//----------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include <mmstrm.hxx>
#include <cidir.hxx>
#include <cistore.hxx>
#include <idxtab.hxx>
#include <circstob.hxx>
#include <fullpath.hxx>
#include <enumstr.hxx>
#include <pathpars.hxx>
#include <propbkp.hxx>
#include <ntopen.hxx>

#define CAT_TESTLOG_HDR     L"\\CiTstLog.000"
#define CAT_TESTLOG_CP1     L"\\CiTstLog.001"
#define CAT_TESTLOG_CP2     L"\\CiTstLog.002"

#define CAT_IDXTABLE_HDR    L"\\INDEX.000"
#define CAT_IDXTABLE_CP1    L"\\INDEX.001"
#define CAT_IDXTABLE_CP2    L"\\INDEX.002"

#define MMLOG_PREFIX            L"\\CiML"
#define PROPSTORE_PREFIX        L"\\CiPS"
#define PROPSTORE1_PREFIX       L"\\CiP1"
#define PROPSTORE2_PREFIX       L"\\CiP2"
#define PRI_CHANGELOG_PREFIX    L"\\CiCL"
#define SEC_CHANGELOG_PREFIX    L"\\CiSL"
#define FRESHLOG_PREFIX         L"\\CiFL"
#define PIDTABLE_PREFIX         L"\\CiPT"
#define SCOPELIST_PREFIX        L"\\CiSP"
#define SECSTORE_PREFIX         L"\\CiST"
#define VSCOPELIST_PREFIX       L"\\CiVP"

// constant definitions moved here from cicat.cxx
const WCHAR CAT_FILEID_MAP_FILE[] = L"\\cicat.fid";         // File id map table
const WCHAR CAT_HASH_FILE[]       = L"\\cicat.hsh";         // Strings table

//+-------------------------------------------------------------------------
//--------------------------------------------------------------------------
SStorage::SStorage(PStorage * pObj ) : _pObj(pObj)
{
}


//+-------------------------------------------------------------------------
//--------------------------------------------------------------------------
SStorage::~SStorage()
{
    delete _pObj;
}

//+-------------------------------------------------------------------------
//--------------------------------------------------------------------------
PStorageObject::PStorageObject()
{
}


//+-------------------------------------------------------------------------
//--------------------------------------------------------------------------
inline CiStorageObject& CI_OBJ ( PStorageObject& obj )
{
    return( (CiStorageObject&)obj );
}

//+-------------------------------------------------------------------------
//--------------------------------------------------------------------------
CiStorageObject::CiStorageObject(WORKID objectId)
: _objectId(objectId)
{
}

//+-------------------------------------------------------------------------
//--------------------------------------------------------------------------
CiStorageObject::~CiStorageObject()
{
}

//+-------------------------------------------------------------------------
//--------------------------------------------------------------------------
SStorageObject::SStorageObject ( PStorageObject* pObj )
: _pObj(pObj)
{
}

//+-------------------------------------------------------------------------
//--------------------------------------------------------------------------
SStorageObject::~SStorageObject()
{
    delete _pObj;
}

//+-------------------------------------------------------------------------
//
//  Function:   DoesVolumeSupportShrinkFromFront
//
//  Synopsis:   Checks if the volume supports SFF, like NTFS5
//
//  Arguments:  [pwcPath] -- Path to physical storage.
//
//  Returns:    TRUE if the file system supports sparse files
//              FALSE otherwise
//
//  History:    5-Nov-97 dlee     Created
//
//--------------------------------------------------------------------------

BOOL DoesVolumeSupportShrinkFromFront( WCHAR const * pwcPath )
{
    SHandle xDir( CiNtOpen( pwcPath,
                            FILE_READ_DATA | SYNCHRONIZE,
                            FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                            FILE_DIRECTORY_FILE | FILE_SYNCHRONOUS_IO_NONALERT ) );

    BYTE aInfo[ sizeof FILE_FS_ATTRIBUTE_INFORMATION +
                MAX_PATH * sizeof WCHAR ];

    FILE_FS_ATTRIBUTE_INFORMATION *pAttributeInfo = (FILE_FS_ATTRIBUTE_INFORMATION *) aInfo;
    
    IO_STATUS_BLOCK IoStatus;

    NTSTATUS Status = NtQueryVolumeInformationFile( xDir.Get(),
                                                    &IoStatus,
                                                    pAttributeInfo,
                                                    sizeof aInfo,
                                                    FileFsAttributeInformation );

    if ( FAILED( Status ) )
    {
        ciDebugOut(( DEB_WARN, "can't get volume info %#x on '%ws'\n",
                     Status, pwcPath ));
        THROW( CException( Status ) );
    }

    return 0 != ( FILE_SUPPORTS_SPARSE_FILES &
                  pAttributeInfo->FileSystemAttributes );
} //DoesVolumeSupportShrinkFromFront

//+-------------------------------------------------------------------------
//
//  Member:     IsDirectoryWritable
//
//  Synopsis:   Checks if the directory is writable by trying to open
//              file "cicat.hsh" for write
//
//  Arguments:  [pwcPath] -- Path to physical storage.
//
//  Returns:    TRUE if the directory is writable
//              FALSE otherwise
//
//  History:    17-Mar-98 KitmanH   Created
//              10-Jun-98 KitmanH   Changed to only retrive file
//                                  attributes
//
//  Note:       Assume writable, if the file does not exist, caller needs 
//              to check if the volume is writable
//              
//--------------------------------------------------------------------------
BOOL IsDirectoryWritable( WCHAR const * pwcPath )
{
    WCHAR wcsPath [ MAX_PATH ];
    wcsncpy( wcsPath, pwcPath, sizeof wcsPath / sizeof WCHAR );
    wcsPath[ (sizeof wcsPath / sizeof WCHAR) - 1 ] = 0;
    wcsncat(wcsPath, CAT_HASH_FILE, (sizeof wcsPath / sizeof WCHAR) - wcslen(wcsPath) );

    ciDebugOut(( DEB_ITRACE, "wcsPath == %ws\n", wcsPath ));

    DWORD dwFileAttribute = GetFileAttributes( wcsPath );
    if ( 0xFFFFFFFF != dwFileAttribute) 
    {
        Win4Assert( !(FILE_ATTRIBUTE_DIRECTORY & dwFileAttribute) );
        ciDebugOut(( DEB_ITRACE, "dwFileAttribute is %#x\n", dwFileAttribute ));
        if ( dwFileAttribute & FILE_ATTRIBUTE_READONLY ) 
            return FALSE;
        else 
            return TRUE;
    }
    else
        return TRUE;

} //IsDirectoryWritable

//+-------------------------------------------------------------------------
//
//  Member:     CiStorage::CiStorage, public
//
//  Effects:    Saves path to physical storage.
//
//  Arguments:  [wcsPath]               -- Path to physical storage.
//              [adviseStatus]          -- advise status object
//              [cMegToLeaveOnDisk]     -- number of megabytes to leave on disk
//              [ulVer]                 -- version [default: CURRENT_VERSION_STAMP]
//              [fReadOnly]             -- is storage read-only [default: FALSE]
//
//  History:    07-Mar-92 KyleP     Created
//              16-Feb-98 KitmanH   Added fReadOnly argument
//              20-Mar-98 KitmanH   _fReadOnly is determined by both
//                                  IsDirectoryWritable() and 
//                                  IsVolumeWriteProtected()
//              27-Oct-98 KLam      Added disk space to leave
//              20-Nov-98 KLam      Initialize _driveInfo
//  
//  Note:       _fIsReadOnly value is set according whether the registry 
//              value "IsReadOnly" is set OR the volume is WriteProtected
//              OR the directory is not writable    
//--------------------------------------------------------------------------

CiStorage::CiStorage( WCHAR const * wcsPath,
                      ICiCAdviseStatus & adviseStatus,
                      ULONG cMegToLeaveOnDisk,
                      ULONG ulVer,
                      BOOL fReadOnly )
:_widFreshLog( widInvalid ),
 _adviseStatus( adviseStatus ),
 _fCorruptionReported(FALSE),
 _ulVer( ulVer ),
 _fSupportsShrinkFromFront( FALSE ),
 _fIsReadOnly( fReadOnly ),
 _fFavorReadAhead( FALSE ), // optimize for queries, not merges
 _cMegToLeaveOnDisk ( cMegToLeaveOnDisk ),
 _driveInfo ( wcsPath, cMegToLeaveOnDisk )
{
    // The constructor is extended to take a  version parameter
    // to set the FSCI versioning apart from framework CI versioning.
    // When the content framework version changes, all framework clients should reindex.
    // However, if only the FSCI version changes, only FSCI should reindex.
    // The default value for the property store is the content index version.
    //

    // ulVer defaults to the framework's version stamp, so when FSCI alone changes,
    // others don't have to change (unless they are using a feature of FSCI.) 

    CIndexId iid( itFreshLog, partidFresh2 );
    _widFreshLog = iid;

    //
    // Squirrel away the path.
    //

    _xPath.Set( new WCHAR [ wcslen( wcsPath ) + 1 ] );
    wcscpy( _xPath.GetPointer(), wcsPath );
    ciDebugOut(( DEB_ITRACE, "Content index physical storage: %ws\n", wcsPath ));

    // Is the volume writable?

    BOOL fAbsolutelyUnWritable  = ( _driveInfo.IsWriteProtected() ) || !( IsDirectoryWritable( wcsPath ) );
    ciDebugOut(( DEB_ITRACE, "CiStorage::CiStorage.. fAbsolutelyUnWritable == %d\n", fAbsolutelyUnWritable ));

    _fIsReadOnly = fReadOnly || fAbsolutelyUnWritable;

    //
    // Determine whether this volume supports shrink from front (ntfs5)
    //
    _fSupportsShrinkFromFront = DoesVolumeSupportShrinkFromFront( wcsPath );
    ciDebugOut(( DEB_ITRACE, "supports SFF: %d\n", _fSupportsShrinkFromFront ));
} //CiStorage

//+-------------------------------------------------------------------------
//
//  Member:     CiStorage::~CiStorage, public
//
//  Synopsis:   Destroys physical storage.
//
//  Effects:    Has *no* effect on open indexes.
//
//  History:    07-Mar-92 KyleP     Created
//
//--------------------------------------------------------------------------

CiStorage::~CiStorage()
{
}

const WCHAR CiStorage::_aHexDigit[] = L"0123456789ABCDEF";

//+-------------------------------------------------------------------------
//
//  Member:     CiStorage::MakePath, private
//
//  Synopsis:   Creates an index, dir, hash or prop path.
//
//  Arguments:  [type]     -- Index, dir, etc.
//              [iid]      -- Index ID.
//              [wcsIndex] -- Output path
//
//  History:    07-Mar-92 KyleP     Created
//              28-Dec-95 KyleP     Collapsed four routines into one
//
//--------------------------------------------------------------------------

void CiStorage::MakePath( CiStorage::EPathType type, WORKID iid, WCHAR * wcsIndex )
{
    //
    // Construct a path for the new index.
    //

    wcscpy( wcsIndex, _xPath.GetPointer() );
    int len = wcslen( wcsIndex );
    wcsIndex[len++] = L'\\';

    for ( int i = 7; i >= 0; i-- )
    {
        wcsIndex[len++] = _aHexDigit[ (iid >> (4 * i)) & 0xF ];
    }

    wcsIndex[len] = 0;

    Win4Assert( len < MAX_PATH );

    switch ( type )
    {
    case CiStorage::eIndexPath:
        wcscat( wcsIndex, L".ci" );
        break;

    case CiStorage::eHashPath:
        wcscat( wcsIndex, L".hsh" );
        break;

    case CiStorage::ePrimaryPropPath:
        wcscat( wcsIndex, L".ps1" );
        break;

    case CiStorage::eSecondaryPropPath:
        wcscat( wcsIndex, L".ps2" );
        break;

    case CiStorage::eDirPath:
        wcscat( wcsIndex, L".dir" );
        break;
    }

    ciDebugOut(( DEB_ITRACE, "Physical index name: %ws\n", wcsIndex ));
}


PStorageObject* CiStorage::QueryObject( WORKID objectId )
{
    return new CiStorageObject(objectId);
}

//+---------------------------------------------------------------------------
//
//  Function:   QueryIdxTableObject
//
//  Synopsis:   Returns an "Index Table" as a "Recoverable Storage Object"
//
//  Returns:    Pointer to a recoverable storage object allocated from the
//              heap. It is the responsibiity of the caller to destroy the
//              object.
//
//  History:    2-25-94   srikants   Created
//              27-Oct-98 KLam       Pass cMegToLeaveOnDisk to CiRcovStorageObj
//
//----------------------------------------------------------------------------

PRcovStorageObj * CiStorage::QueryIdxTableObject()
{
    WCHAR   wcsHdr[MAX_PATH];
    WCHAR   wcsCopy1[MAX_PATH];
    WCHAR   wcsCopy2[MAX_PATH];

    MakeLogPath( CAT_IDXTABLE_HDR, wcsHdr );
    MakeLogPath( CAT_IDXTABLE_CP1, wcsCopy1 );
    MakeLogPath( CAT_IDXTABLE_CP2, wcsCopy2 );

    return new CiRcovStorageObj( *this, 
                                 wcsHdr,
                                 wcsCopy1,
                                 wcsCopy2,
                                 _cMegToLeaveOnDisk,
                                 _fIsReadOnly);
}


//+-------------------------------------------------------------------------
//--------------------------------------------------------------------------
PIndexTable* CiStorage::QueryIndexTable ( CTransaction& xact )
{
    return new CIndexTable ( *this, xact );
}

//+-------------------------------------------------------------------------
//--------------------------------------------------------------------------
PMmStream* CiStorage::QueryNewIndexStream( PStorageObject& obj,
                                           BOOL isSparse )
{
    WCHAR wcsIndex [ MAX_PATH ];
    MakePath( eIndexPath, CI_OBJ(obj).ObjectId(), wcsIndex );
    XPtr<PMmStream> xStream;

    //
    // If it's a master index and the storage supports sparse streams, make
    // the stream sparse.
    //

    BOOL fSparse = ( isSparse && _fSupportsShrinkFromFront );

    ciDebugOut(( DEB_ITRACE, "opening new %s stream '%ws'\n",
                 isSparse ? "master" : "shadow",
                 wcsIndex ));

    if ( fSparse )
    {
        CLockingMmStream * pLockingMmStream = new CLockingMmStream( _cMegToLeaveOnDisk );
        xStream.Set( pLockingMmStream );

        pLockingMmStream->Open( wcsIndex,
                                GENERIC_READ | GENERIC_WRITE,
                                FILE_SHARE_READ|FILE_SHARE_WRITE,
                                CREATE_NEW,  // File cannot already exist.
                                FILE_ATTRIBUTE_NORMAL,
                                TRUE ); // sparse file
    }
    else
    {
        CMmStream * pMmStream = new CMmStream( _cMegToLeaveOnDisk, _fIsReadOnly );
        xStream.Set( pMmStream );
        pMmStream->Open( wcsIndex,
                         GENERIC_READ | GENERIC_WRITE,
                         FILE_SHARE_READ|FILE_SHARE_WRITE,
                         CREATE_NEW,      // File cannot already exist.
                         FILE_ATTRIBUTE_NORMAL,
                         FALSE ); // non-sparse file
    }

    return xStream.Acquire();
}

//+---------------------------------------------------------------------------
//
//  Function:   QueryExistingIndexStream
//
//  Synopsis:   Returns an "existing" index stream as a memory mapped
//              stream.
//
//  Arguments:  [obj]   --  The storage object associated with the main
//                          object containing the stream.
//              [mode]  --  The open mode: read/write
//
//  History:    4-20-94   srikants  Added fWrite parameter.
//              2-18-98   kitmanh   Ignore fWrite for readOnly catalogs
//
//  Notes:     The fWrite parameter was used for supporting a restartable
//             master merge for which an existing index stream must be
//             opened for write access. Otherwise, all existing streams are
//             normally opened for read access only.
//
//----------------------------------------------------------------------------

PMmStream* CiStorage::QueryExistingIndexStream ( PStorageObject& obj,
                                                 PStorage::EOpenMode mode )
{
    WCHAR wcsIndex [ MAX_PATH ];
    MakePath( eIndexPath, CI_OBJ(obj).ObjectId(), wcsIndex );

    BOOL fWrite = _fIsReadOnly ? FALSE : (PStorage::eOpenForWrite == mode);
    DWORD dwAccess = fWrite ? (GENERIC_READ | GENERIC_WRITE) : (GENERIC_READ);
    
    ciDebugOut(( DEB_ITRACE, "opening existing %s stream '%ws'\n",
                 fWrite ? "write" : "read",
                 wcsIndex ));

    XPtr<PMmStream> xStream;

    if ( fWrite )
    {

        CLockingMmStream * pLockingMmStream = new CLockingMmStream( _cMegToLeaveOnDisk );
        xStream.Set( pLockingMmStream );

        pLockingMmStream->Open( wcsIndex,
                                dwAccess,      // Access flags
                                FILE_SHARE_READ | FILE_SHARE_WRITE,
                                OPEN_EXISTING, // File must already exist.
                                FILE_ATTRIBUTE_NORMAL,
                                fWrite && _fSupportsShrinkFromFront ); // sparse
    }
    else
    {
        dwAccess = _fIsReadOnly ? GENERIC_READ : dwAccess;

        CMmStream * pMmStream = new CMmStream( _cMegToLeaveOnDisk, _fIsReadOnly );
        xStream.Set( pMmStream );

        pMmStream->Open( wcsIndex,
                         dwAccess,      // Access flags
                         FILE_SHARE_READ | FILE_SHARE_WRITE,
                         OPEN_EXISTING, // File must already exist.
                         FILE_ATTRIBUTE_NORMAL,
                         FALSE ); // sparse
    }

    return xStream.Acquire();
}

//+-------------------------------------------------------------------------
//--------------------------------------------------------------------------
PMmStream * CiStorage::DupExistingIndexStream( PStorageObject& obj,
                                               PMmStream & mmStream,
                                               EOpenMode mode )
{
    return new CDupStream( (CLockingMmStream &) mmStream );
}

//+-------------------------------------------------------------------------
//
//  Method:     CiStorage::QueryNewHashStream
//
//  Synopsis:   Creates hash stream
//
//  Arguments:  [obj] -- Object holding stream
//
//  Returns:    Stream
//
//  History:    17-Feb-1994     KyleP   Created
//
//--------------------------------------------------------------------------

PMmStream* CiStorage::QueryNewHashStream ( PStorageObject& obj )
{
    WCHAR wcsIndex [ MAX_PATH ];
    MakePath( eHashPath, CI_OBJ(obj).ObjectId(), wcsIndex );
    XPtr<CMmStream> xStream( new CMmStream( _cMegToLeaveOnDisk, _fIsReadOnly ) );

    xStream->Open( wcsIndex,
                   GENERIC_READ | GENERIC_WRITE,    // Access flags
                   0,                // Sharing flags
                   CREATE_NEW,      // File cannot already exist.
                   FILE_ATTRIBUTE_NORMAL );
    return xStream.Acquire();
}

//+-------------------------------------------------------------------------
//
//  Method:     CiStorage::QueryExistingHashStream
//
//  Synopsis:   Opens existing hash stream
//
//  Arguments:  [obj]    -- Object holding stream
//              [fWrite] -- Flag indicating if the stream must be opened
//                          for write access; set to TRUE during a restarted
//                          master merge.
//
//  Returns:    Stream
//
//  History:    17-Feb-1994     KyleP   Created
//
//--------------------------------------------------------------------------

PMmStream* CiStorage::QueryExistingHashStream ( PStorageObject& obj,
                                                PStorage::EOpenMode mode )
{

    WCHAR wcsIndex [ MAX_PATH ];
    MakePath( eHashPath, CI_OBJ(obj).ObjectId(), wcsIndex );
    XPtr<CMmStream> xStream( new CMmStream( _cMegToLeaveOnDisk, _fIsReadOnly ) );

    BOOL fWrite = PStorage::eOpenForWrite == mode;
    DWORD dwAccess = fWrite ? GENERIC_READ | GENERIC_WRITE : GENERIC_READ;

    xStream->Open( wcsIndex,
                   dwAccess,     // Access flags
                   FILE_SHARE_READ | FILE_SHARE_WRITE,  // Sharing flags
                   OPEN_EXISTING );   // File must already exist.
    return xStream.Acquire();
}

//+-------------------------------------------------------------------------
//
//  Method:     CiStorage::QueryNewPropStream
//
//  Synopsis:   Creates prop stream
//
//  Arguments:  [obj] -- Object holding stream
//
//  Returns:    Stream
//
//  History:    17-Feb-1994     KyleP   Created
//
//--------------------------------------------------------------------------

PMmStream* CiStorage::QueryNewPropStream ( PStorageObject& obj, DWORD dwStoreLevel )
{
    WCHAR wcsIndex [ MAX_PATH ];

    Win4Assert(PRIMARY_STORE == dwStoreLevel || SECONDARY_STORE == dwStoreLevel);
    MakePath( (PRIMARY_STORE == dwStoreLevel) ? ePrimaryPropPath : eSecondaryPropPath,
              CI_OBJ(obj).ObjectId(), wcsIndex );

    XPtr<CMmStream> xStream( new CMmStream( _cMegToLeaveOnDisk, _fIsReadOnly ) );

    xStream->Open ( wcsIndex,
                    GENERIC_READ | GENERIC_WRITE,       // Access flags
                    FILE_SHARE_READ | FILE_SHARE_WRITE, // Sharing flags
                    CREATE_NEW,                        // File cannot already exist.
                    FILE_ATTRIBUTE_NORMAL );
    return xStream.Acquire();
}

//+-------------------------------------------------------------------------
//
//  Method:     CiStorage::QueryExistingPropStream
//
//  Synopsis:   Opens existing prop stream
//
//  Arguments:  [obj]    -- Object holding stream
//              [fWrite] -- Flag indicating if the stream must be opened
//                          for write access; set to TRUE during a restarted
//                          master merge.
//
//  Returns:    Stream
//
//  History:    17-Feb-1994     KyleP   Created
//
//--------------------------------------------------------------------------

PMmStream* CiStorage::QueryExistingPropStream ( PStorageObject& obj,
                                                PStorage::EOpenMode mode,
                                                DWORD dwStoreLevel )
{
    WCHAR wcsIndex [ MAX_PATH ];

    Win4Assert(PRIMARY_STORE == dwStoreLevel || SECONDARY_STORE == dwStoreLevel);
    MakePath( (PRIMARY_STORE == dwStoreLevel) ? ePrimaryPropPath : eSecondaryPropPath,
              CI_OBJ(obj).ObjectId(), wcsIndex );
    XPtr<CMmStream> xStream( new CMmStream( _cMegToLeaveOnDisk, _fIsReadOnly ) );

    BOOL fWrite = PStorage::eOpenForWrite == mode;
    DWORD dwAccess = fWrite ? GENERIC_READ | GENERIC_WRITE : GENERIC_READ;

    xStream->Open ( wcsIndex,
                    dwAccess,     // Access flags
                    FILE_SHARE_READ | FILE_SHARE_WRITE,  // Sharing flags
                    OPEN_EXISTING);   // File must already exist.
    return xStream.Acquire();
}

//+-------------------------------------------------------------------------
//
//  Method:     CiStorage::QueryNewPSBkpStream, public
//
//  Synopsis:   Creates property store backup stream.
//
//  Arguments:  [obj]        -- Object holding stream
//              [ulMaxPages] -- Max pages to backup
//
//  Returns:    Property store backup stream
//
//  History:    30-May-97     KrishnaN   Created
//              29-Oct-98     KLam       Pass _cMegToLeaveOnDisk to
//                                       CPropStoreBackupStream
//
//  Notes: This method can be called either to create a backup file when a
//         catalog is being created for the first time or when a catalog is
//         being opened at CI startup. In the latter case it will be called
//         after the existing backup file is already used, if necessary. Once
//         the backup file is used, it can be run over.
//
//--------------------------------------------------------------------------

CPropStoreBackupStream* CiStorage::QueryNewPSBkpStream( PStorageObject& obj,
                                                        ULONG ulMaxPages,
                                                        DWORD dwStoreLevel )
{
    Win4Assert( wcslen( PROP_BKP_FILE1 ) == wcslen( PROP_BKP_FILE2 ) );

    unsigned cwc = wcslen( _xPath.GetPointer() ) + wcslen( PROP_BKP_FILE1 );

    if ( cwc >= MAX_PATH )
        THROW( CException( STATUS_INVALID_PARAMETER ) );

    WCHAR wcsIndex [ MAX_PATH ];
    wcscpy(wcsIndex, _xPath.GetPointer() );

    Win4Assert(PRIMARY_STORE == dwStoreLevel || SECONDARY_STORE == dwStoreLevel);

    wcscat(wcsIndex, (PRIMARY_STORE == dwStoreLevel) ? PROP_BKP_FILE1 : PROP_BKP_FILE2 );

    XPtr<CPropStoreBackupStream> xStream( new CPropStoreBackupStream( _cMegToLeaveOnDisk ) );

    xStream->OpenForBackup ( wcsIndex,
                             FILE_SHARE_READ | FILE_SHARE_WRITE, // Sharing flags
                             CREATE_ALWAYS, // File may already exist, but we'll run over it.
                             ulMaxPages);
    Win4Assert(xStream.GetPointer());
    return xStream.Acquire();
}

//+-------------------------------------------------------------------------
//
//  Method:     CiStorage::OpenExistingPSBkpStreamForRecovery, public
//
//  Synopsis:   Opens existing property store backup stream for recovery.
//
//  Arguments:  [obj]    -- Object holding stream
//
//  Returns:    Property store backup stream
//
//  History:    30-May-97     KrishnaN   Created
//              29-Oct-98     KLam       Pass _cMegToLeaveOnDisk to
//                                       CPropStoreBackupStream
//
//--------------------------------------------------------------------------

CPropStoreBackupStream* CiStorage::OpenExistingPSBkpStreamForRecovery(PStorageObject& obj,
                                                                      DWORD dwStoreLevel)
{
    Win4Assert( wcslen( PROP_BKP_FILE1 ) == wcslen( PROP_BKP_FILE2 ) );
    unsigned cwc = wcslen( _xPath.GetPointer() ) + wcslen( PROP_BKP_FILE1 );

    if ( cwc >= MAX_PATH )
        THROW( CException( STATUS_INVALID_PARAMETER ) );

    WCHAR wcsIndex [ MAX_PATH ];

    wcscpy(wcsIndex, _xPath.GetPointer() );

    Win4Assert(PRIMARY_STORE == dwStoreLevel || SECONDARY_STORE == dwStoreLevel);

    wcscat(wcsIndex, (PRIMARY_STORE == dwStoreLevel) ? PROP_BKP_FILE1 : PROP_BKP_FILE2 );

    XPtr<CPropStoreBackupStream> xStream( new CPropStoreBackupStream( _cMegToLeaveOnDisk ) );

    xStream->OpenForRecovery( wcsIndex, FILE_SHARE_READ);  // Sharing flags

    Win4Assert(xStream.GetPointer());
    return xStream.Acquire();
}


//+-------------------------------------------------------------------------
//--------------------------------------------------------------------------
PDirectory* CiStorage::QueryNewDirectory( PStorageObject& obj )
{
    return new CiDirectory( *this,
                            CI_OBJ(obj).ObjectId(),
                            PStorage::eCreate );
}

//+---------------------------------------------------------------------------
//
//  Function:   QueryExistingDirectory
//
//  Synopsis:   Returns an existing directory stream for an index.
//
//  Arguments:  [obj]    -- Storage object.
//              [fWrite] -- Flag indicating if the stream must be opened
//              for write access or for read access.
//
//  History:    4-20-94   srikants   Added fWrite parameter
//
//  Notes:      fWrite parameter was added to support restartable master
//              merge.
//
//----------------------------------------------------------------------------

PDirectory* CiStorage::QueryExistingDirectory( PStorageObject& obj,
                       PStorage::EOpenMode mode )
{
    return new CiDirectory ( *this, CI_OBJ(obj).ObjectId(), mode );
}

//+-------------------------------------------------------------------------
//--------------------------------------------------------------------------
PMmStream* CiStorage::QueryNewDirStream ( WORKID iid )
{
    WCHAR wcsDir [ MAX_PATH ];
    MakePath( eDirPath, iid, wcsDir );
    XPtr<CMmStream> xStream( new CMmStream( _cMegToLeaveOnDisk, _fIsReadOnly ) );
    xStream->Open ( wcsDir,
                    GENERIC_READ | GENERIC_WRITE,     // Access flags
                    FILE_SHARE_READ,  // Sharing flags
                    CREATE_NEW,   // File cannot already exist.
                    FILE_ATTRIBUTE_NORMAL );
    return xStream.Acquire();
}

//+-------------------------------------------------------------------------
//--------------------------------------------------------------------------
PMmStream* CiStorage::QueryExistingDirStream ( WORKID iid, BOOL fWrite )
{
    WCHAR wcsDir [ MAX_PATH ];
    MakePath( eDirPath, iid, wcsDir );
    XPtr<CMmStream> xStream( new CMmStream( _cMegToLeaveOnDisk, _fIsReadOnly ) );

    if ( _fIsReadOnly )
        fWrite = FALSE;

    DWORD dwAccess = fWrite ? (GENERIC_READ | GENERIC_WRITE) : GENERIC_READ;

    xStream->Open( wcsDir,
                   dwAccess,     // Access flags
                   FILE_SHARE_READ | FILE_SHARE_WRITE,  // Sharing flags
                   OPEN_EXISTING );   // File must already exist.
    return xStream.Acquire();
}

//+-------------------------------------------------------------------------
//--------------------------------------------------------------------------
BOOL CiStorage::RemoveObject( WORKID iid )
{
    WCHAR wcsIndex [ MAX_PATH ];

    //
    // Delete index
    //

    MakePath( eIndexPath, iid, wcsIndex );
    BOOL fSuccess = DeleteFile( wcsIndex );

    //
    // and directory
    //

    MakePath( eDirPath, iid, wcsIndex );
    fSuccess = fSuccess && DeleteFile( wcsIndex );

    //
    // and maybe hash
    //

    MakePath( eHashPath, iid, wcsIndex );
    if ( !DeleteFile( wcsIndex ) )
        fSuccess = fSuccess && (GetLastError() == ERROR_FILE_NOT_FOUND);

    //
    // and maybe prop
    //

    MakePath( ePrimaryPropPath, iid, wcsIndex );
    if ( !DeleteFile( wcsIndex ) )
        fSuccess = fSuccess && (GetLastError() == ERROR_FILE_NOT_FOUND);

    MakePath( eSecondaryPropPath, iid, wcsIndex );
    if ( !DeleteFile( wcsIndex ) )
        fSuccess = fSuccess && (GetLastError() == ERROR_FILE_NOT_FOUND);

    return fSuccess;
}

//+-------------------------------------------------------------------------
//
//  Member:     CiStorage::MakeLogPath,  private
//
//  Synopsis:   Create a fully qualified path for which to store the
//              persistent log.
//
//  Arguments:  [wcsName]   -- name of logfile to append to path
//              [wcsPath]   -- (out) resulting fully qualified name
//
//  Notes:      It is assumed that wcsPath is large enough to hold the
//              name + path
//
//  History:    18-Nov-93 DwightKr     Created
//
//--------------------------------------------------------------------------
void CiStorage::MakeLogPath(WCHAR * wcsName, WCHAR * wcsPath)
{
    wcscpy(wcsPath, _xPath.GetPointer());
    wcscat(wcsPath, wcsName);

    Win4Assert( wcslen(wcsPath) < MAX_PATH );
}


//+-------------------------------------------------------------------------
//
//  Member:     CiStorage::QueryFreshLog, public
//
//  Synopsis:   Builds a new persistent freshlog, using the specified name
//
//  Arguments:  [wcsName]  -- name to use for new stream
//
//  Returns:    a new CPersStream * object
//
//  History:    19-Nov-93 DwightKr     Created
//              27-Oct-98 KLam         Pass _cMegToLeaveOnDisk to CiRcovStorageObj
//
//--------------------------------------------------------------------------

PRcovStorageObj * CiStorage::QueryFreshLog(WORKID wid)
{
    WCHAR   wcsHdr[MAX_PATH];
    WCHAR   wcsCopy1[MAX_PATH];
    WCHAR   wcsCopy2[MAX_PATH];

    FormRcovObjNames( wid, FRESHLOG_PREFIX, wcsHdr, wcsCopy1, wcsCopy2 );

    return new CiRcovStorageObj( *this,
                                 wcsHdr,
                                 wcsCopy1,
                                 wcsCopy2,
                                 _cMegToLeaveOnDisk,
                                 _fIsReadOnly);
}

//+---------------------------------------------------------------------------
//----------------------------------------------------------------------------
BOOL CiStorage::RemoveFreshLog(WORKID wid)
{

    WCHAR   wcsHdr[MAX_PATH];
    WCHAR   wcsCopy1[MAX_PATH];
    WCHAR   wcsCopy2[MAX_PATH];

    FormRcovObjNames( wid, FRESHLOG_PREFIX, wcsHdr, wcsCopy1, wcsCopy2 );

    DeleteFile( wcsHdr );
    DeleteFile( wcsCopy1 );
    DeleteFile( wcsCopy2 );

    return(TRUE);
}

//+---------------------------------------------------------------------------
//
//  Function:   QueryChangeLog
//
//  Synopsis:   Creates a recoverable storage object for testing.
//
//  History:    2-08-94   DwightKr   Created
//              4-20-94   SrikantS   Modified to use the common
//                                   FormRcovObjNames method.
//              27-Oct-98 KLam       Pass _cMegToLeaveOnDisk to CiRcovStorageObj
//
//  Notes:      For down level storage, the WID is really the partition ID.
//
//----------------------------------------------------------------------------

PRcovStorageObj * CiStorage::QueryChangeLog( WORKID wid, EChangeLogType type )
{

    WCHAR   wcsHdr[MAX_PATH];
    WCHAR   wcsCopy1[MAX_PATH];
    WCHAR   wcsCopy2[MAX_PATH];

    if ( ePrimChangeLog == type  )
    {
        FormRcovObjNames( wid, PRI_CHANGELOG_PREFIX, wcsHdr, wcsCopy1, wcsCopy2 );
    }
    else
    {
        FormRcovObjNames( wid, SEC_CHANGELOG_PREFIX, wcsHdr, wcsCopy1, wcsCopy2 );
    }

    return new CiRcovStorageObj( *this,
                                 wcsHdr,
                                 wcsCopy1,
                                 wcsCopy2,
                                 _cMegToLeaveOnDisk,
                                 _fIsReadOnly );
}

//+-------------------------------------------------------------------------
//--------------------------------------------------------------------------
PRcovStorageObj * CiStorage::QueryRecoverableLog(WORKID wid)
{
    Win4Assert(!"QueryRecoverableLog() not supported in class CiStorage");

    PRcovStorageObj *a = 0;

    return a;
}


//+-------------------------------------------------------------------------
//
//  Member:     CiStorage::QueryPidLookupTable, public
//
//  Synopsis:   Builds a new persistent storage object for PID mapping.
//
//  Arguments:  [wid]       --   WorkId of the object. For downlevel, only
//                 the upper 4 bytes are used as the "partition id" that the
//                 object belongs to.  It is assumed that the upper 4 bytes of
//                 the wid contain the partition id.
//
//  Returns:    a new CPersStream * object
//
//  History:    05 Jan 1996   Alanw    Created
//              27 Oct 1998   KLam     Pass _cMegToLeaveOnDisk to CiRcovStorageObj
//
//--------------------------------------------------------------------------
PRcovStorageObj * CiStorage::QueryPidLookupTable(WORKID wid)
{
    WCHAR   wcsHdr[MAX_PATH];
    WCHAR   wcsCopy1[MAX_PATH];
    WCHAR   wcsCopy2[MAX_PATH];

    FormRcovObjNames( wid, PIDTABLE_PREFIX, wcsHdr, wcsCopy1, wcsCopy2 );

    return new CiRcovStorageObj( *this,
                                 wcsHdr,
                                 wcsCopy1,
                                 wcsCopy2,
                                 _cMegToLeaveOnDisk,
                                 _fIsReadOnly );
}

//+-------------------------------------------------------------------------
//
//  Member:     CiStorage::QuerySdidLookupTable, public
//
//  Synopsis:   Builds a new persistent storage object for SDID mapping.
//
//  Arguments:  [wid]       --   WorkId of the object. For downlevel, only
//                 the upper 4 bytes are used as the "partition id" that the
//                 object belongs to.  It is assumed that the upper 4 bytes of
//                 the wid contain the partition id.
//
//  Returns:    a new CPersStream * object
//
//  History:    29 Jan 1996   Alanw    Created
//              27 Oct 1998   KLam     Pass _cMegToLeaveOnDisk to CiRcovStorageObj
//
//--------------------------------------------------------------------------
PRcovStorageObj * CiStorage::QuerySdidLookupTable(WORKID wid)
{
    WCHAR   wcsHdr[MAX_PATH];
    WCHAR   wcsCopy1[MAX_PATH];
    WCHAR   wcsCopy2[MAX_PATH];

    FormRcovObjNames( wid, SECSTORE_PREFIX, wcsHdr, wcsCopy1, wcsCopy2 );

    return new CiRcovStorageObj( *this,
                                 wcsHdr,
                                 wcsCopy1,
                                 wcsCopy2,
                                 _cMegToLeaveOnDisk,
                                 _fIsReadOnly );
}


//+---------------------------------------------------------------------------
//
//  Function:   FormRcovObjNames
//
//  Synopsis:   Forms the down-level names for the three streams that make up
//              a recoverable object. This method can be used for creating
//              names for objects that exist on a "per partition" basis.
//
//  Arguments:  [wid]       --   WorkId of the object. For downlevel, only
//              the upper 4 bytes are used as the "partition id" that the
//              object belongs to.  It is assumed that the upper 4 bytes of
//              the wid contain the partition id.
//              [wcsPrefix] --   A 5 character prefix for the object name.
//              Must begin with a "\\". (That will leave 4 chars for name.)
//              [wcsHdr]    --   On output will contain the file name for the
//                               atomic header.
//              [wcsCopy1]  --   On output will contain the name of the first
//                               copy.
//              [wcsCopy2]  --   On output, will contain the name of the
//                               second copy.
//
//  History:    4-20-94   srikants   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

void CiStorage::FormRcovObjNames( WORKID wid, WCHAR * wcsPrefix,
                                  WCHAR * wcsHdr, WCHAR * wcsCopy1,
                                  WCHAR * wcsCopy2 )
{
    Win4Assert( wcslen(wcsPrefix) == 5 ); // extra char is for "\\"

    WCHAR    wcsTemp[_MAX_FNAME+1];
    CIndexId iid(wid);

    Win4Assert( iid.PartId() <= 0x0000FFFF );

    swprintf(wcsTemp, L"%5s%4.4x.000", wcsPrefix, iid.PartId() );
    MakeLogPath( wcsTemp, wcsHdr );

    swprintf(wcsTemp, L"%5s%4.4x.001", wcsPrefix, iid.PartId() );
    MakeLogPath( wcsTemp, wcsCopy1 );

    swprintf(wcsTemp, L"%5s%4.4x.002", wcsPrefix, iid.PartId() );
    MakeLogPath( wcsTemp, wcsCopy2 );
}

//+---------------------------------------------------------------------------
//
//  Function:   QueryMMergeLog
//
//  Synopsis:   Returns a Master Merge Log object created on the heap.
//
//  Arguments:  [wid] --  WorkId of the master merge log. Only the upper
//                        4 bytes are used as the partition id.
//
//  History:    4-20-94   srikants   Created
//              27-Oct-98 KLam       Pass _cMegToLeaveOnDisk to CiRcovStorageObj
//
//  Notes:
//
//----------------------------------------------------------------------------

PRcovStorageObj * CiStorage::QueryMMergeLog( WORKID wid )
{
    WCHAR   wcsHdr[MAX_PATH];
    WCHAR   wcsCopy1[MAX_PATH];
    WCHAR   wcsCopy2[MAX_PATH];

    FormRcovObjNames( wid, MMLOG_PREFIX, wcsHdr, wcsCopy1, wcsCopy2 );
    return new CiRcovStorageObj( *this,
                                 wcsHdr,
                                 wcsCopy1,
                                 wcsCopy2,
                                 _cMegToLeaveOnDisk,
                                 _fIsReadOnly );
}

//+---------------------------------------------------------------------------
//
//  Function:   QueryPropStore
//
//  Synopsis:   Returns a property store table
//
//  Arguments:  [wid] --  WorkId of the property store table. Only the upper
//                        4 bytes are used as the partition id.
//
//  History:    27-Dec-94   KyleP      Created
//              27-Oct-98   KLam       Pass _cMegToLeaveOnDisk to CiRcovStorageObj
//
//----------------------------------------------------------------------------

PRcovStorageObj * CiStorage::QueryPropStore( WORKID wid, DWORD dwStoreLevel )
{
    WCHAR   wcsHdr[MAX_PATH];
    WCHAR   wcsCopy1[MAX_PATH];
    WCHAR   wcsCopy2[MAX_PATH];

    Win4Assert(PRIMARY_STORE == dwStoreLevel || SECONDARY_STORE == dwStoreLevel);

    FormRcovObjNames( wid,
                      (PRIMARY_STORE == dwStoreLevel) ? PROPSTORE1_PREFIX : PROPSTORE2_PREFIX,
                      wcsHdr, wcsCopy1, wcsCopy2 );

    return new CiRcovStorageObj( *this,
                                 wcsHdr,
                                 wcsCopy1,
                                 wcsCopy2,
                                 _cMegToLeaveOnDisk,
                                 _fIsReadOnly );
}

//+---------------------------------------------------------------------------
//
//  Member:     CiStorage::RemovePropStore
//
//  Synopsis:   Removes the PropStore header files.
//
//  Arguments:  [wid] --  WorkId of the property store table. Only the upper
//                        4 bytes are used as the partition id.
//
//  History:    3-26-97   srikants   Created
//
//----------------------------------------------------------------------------


void CiStorage::RemovePropStore( WORKID wid, DWORD dwStoreLevel )
{
    WCHAR   wcsHdr[MAX_PATH];
    WCHAR   wcsCopy1[MAX_PATH];
    WCHAR   wcsCopy2[MAX_PATH];

    Win4Assert(PRIMARY_STORE == dwStoreLevel || SECONDARY_STORE == dwStoreLevel);

    FormRcovObjNames( wid,
                      (PRIMARY_STORE == dwStoreLevel) ? PROPSTORE1_PREFIX : PROPSTORE2_PREFIX,
                      wcsHdr, wcsCopy1, wcsCopy2 );
    DeleteFile( wcsHdr );
    DeleteFile( wcsCopy1);
    DeleteFile( wcsCopy2 );
}

//+---------------------------------------------------------------------------
//
//  Member:     CiStorage::RemoveSecStore
//
//  Synopsis:   Removes the security store files.
//
//  Arguments:  [wid] -- Workid of the security store table.
//
//  History:    7-14-97   srikants   Created
//
//----------------------------------------------------------------------------

void CiStorage::RemoveSecStore( WORKID wid )
{
    WCHAR   wcsHdr[MAX_PATH];
    WCHAR   wcsCopy1[MAX_PATH];
    WCHAR   wcsCopy2[MAX_PATH];

    FormRcovObjNames( wid, SECSTORE_PREFIX, wcsHdr, wcsCopy1, wcsCopy2 );

    DeleteFile( wcsHdr );
    DeleteFile( wcsCopy1);
    DeleteFile( wcsCopy2 );
}

//+---------------------------------------------------------------------------
//
//  Member:     CiStorage::QueryScopeList
//
//  Synopsis:   Returns CI scopes list table
//
//  Arguments:  [wid] -  Workid of the scopes list table.
//
//  History:    1-19-96   srikants   Created
//              27-Oct-98 KLam       Pass _cMegToLeaveOnDisk to CiRcovStorageObj
//
//  Notes:
//
//----------------------------------------------------------------------------

PRcovStorageObj * CiStorage::QueryScopeList( WORKID wid )
{
    WCHAR   wcsHdr[MAX_PATH];
    WCHAR   wcsCopy1[MAX_PATH];
    WCHAR   wcsCopy2[MAX_PATH];

    FormRcovObjNames( wid, SCOPELIST_PREFIX, wcsHdr, wcsCopy1, wcsCopy2 );

    return new CiRcovStorageObj( *this,
                                 wcsHdr,
                                 wcsCopy1,
                                 wcsCopy2,
                                 _cMegToLeaveOnDisk,
                                 _fIsReadOnly );
}

//+---------------------------------------------------------------------------
//
//  Member:     CiStorage::QueryVirtualScopeList
//
//  Synopsis:   Returns CI virtual scopes list table
//
//  Arguments:  [wid] -  Workid of the virtual scopes list table.
//
//  History:    2-05-96   KyleP      Created
//              27-Oct-98 KLam       Pass _cMegToLeaveOnDisk to CiRcovStorageObj
//
//----------------------------------------------------------------------------

PRcovStorageObj * CiStorage::QueryVirtualScopeList( WORKID wid )
{
    WCHAR   wcsHdr[MAX_PATH];
    WCHAR   wcsCopy1[MAX_PATH];
    WCHAR   wcsCopy2[MAX_PATH];

    FormRcovObjNames( wid, VSCOPELIST_PREFIX, wcsHdr, wcsCopy1, wcsCopy2 );

    return new CiRcovStorageObj( *this,
                                 wcsHdr,
                                 wcsCopy1,
                                 wcsCopy2,
                                 _cMegToLeaveOnDisk,
                                 _fIsReadOnly );
}

//+---------------------------------------------------------------------------
//
//  Function:   RemoveMMLog
//
//  Synopsis:   Deletes the specified master log object.
//
//  Arguments:  [wid] --  WorkId of the master merge log. Only the upper
//                        4 bytes are used as the partition id.
//
//  History:    4-20-94   srikants   Created
//
//----------------------------------------------------------------------------

BOOL CiStorage::RemoveMMLog( WORKID wid )
{
    WCHAR   wcsHdr[MAX_PATH];
    WCHAR   wcsCopy1[MAX_PATH];
    WCHAR   wcsCopy2[MAX_PATH];

    FormRcovObjNames( wid, MMLOG_PREFIX, wcsHdr, wcsCopy1, wcsCopy2 );

    DeleteFile( wcsHdr );
    DeleteFile( wcsCopy1 );
    DeleteFile( wcsCopy2 );

    return(TRUE);

}

//+---------------------------------------------------------------------------
//
//  Function:   QueryTestLog
//
//  Synopsis:   Creates a recoverable storage object for testing.
//
//  History:    2-08-94   srikants   Created
//              27-Oct-98 KLam       Pass _cMegToLeaveOnDisk to CiRcovStorageObj
//
//----------------------------------------------------------------------------

PRcovStorageObj * CiStorage::QueryTestLog()
{
    WCHAR   wcsHdr[MAX_PATH];
    WCHAR   wcsCopy1[MAX_PATH];
    WCHAR   wcsCopy2[MAX_PATH];

    MakeLogPath( CAT_TESTLOG_HDR, wcsHdr );
    MakeLogPath( CAT_TESTLOG_CP1, wcsCopy1 );
    MakeLogPath( CAT_TESTLOG_CP2, wcsCopy2 );

    return new CiRcovStorageObj( *this,
                                 wcsHdr,
                                 wcsCopy1,
                                 wcsCopy2,
                                 _cMegToLeaveOnDisk,
                                 _fIsReadOnly );
}


//+---------------------------------------------------------------------------
//
//  Function:   GetDiskSpace
//
//  Synopsis:   Returns the disk size & space remaining, in bytes
//              Takes into consideration the space to leave on disk
//
//  History:    31-Jul-94   DwightKr   Created
//              27-Oct-98   KLam       Compensates for DiskSpaceToLeave
//                                     Forwards call to drive info 
//
//----------------------------------------------------------------------------
void CiStorage::GetDiskSpace( __int64 & diskTotal,
                              __int64 & diskRemaining )
{
    _driveInfo.GetDiskSpace ( diskTotal, diskRemaining );
}

//+---------------------------------------------------------------------------
//
//  Member:     CiStorage::ReportCorruptComponent, public
//
//  Synopsis:   Generates meaningful error message on storage corruption.
//
//  Arguments:  [pwszString] -- Error message
//
//  History:    21-Jul-97   KyleP   Move from header
//
//----------------------------------------------------------------------------

void CiStorage::ReportCorruptComponent( WCHAR const * pwszString )
{
     if ( !_fCorruptionReported )
     {
           CFwCorruptionEvent   event( GetVolumeName(), pwszString, _adviseStatus );
           _fCorruptionReported = TRUE;
     }
}

//+---------------------------------------------------------------------------
//
//  Function:   GetNewObjectIdForFreshLog
//
//  Synopsis:   Forms a new object id for the fresh log. It uses a pool of
//              two ids and returns the one that is currently not in use.
//
//  Returns:    ObjectId for a new fresh log.
//
//  History:    10-05-94   srikants   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

WORKID CiStorage::GetNewObjectIdForFreshLog()
{
    CIndexId iidCurr( _widFreshLog );
    PARTITIONID partIdNew = partidFresh1 == iidCurr.PartId() ?
                            partidFresh2 : partidFresh1;

    CIndexId iidNew( itFreshLog, partIdNew );
    return( CreateObjectId( iidNew, PStorage::eRcovHdr ) );
}

//+---------------------------------------------------------------------------
//
//  Function:   SetSpecialItObjectId
//
//  Synopsis:   Sets the object id of the special index type.
//
//  Arguments:  [it]  -- Index Type
//              [wid] -- WorkId for this index type.
//
//  History:    10-05-94   srikants   Created
//
//  Notes:      As of now, only the itFreshLog is of interest to CiStorage.
//
//----------------------------------------------------------------------------

void CiStorage::SetSpecialItObjectId( IndexType it, WORKID wid )
{
    switch ( it )
    {
        case itFreshLog:
#if CIDBG==1
            CIndexId iid( wid );
            Win4Assert( it == iid.PersId() );
            Win4Assert( partidFresh1 == iid.PartId() ||
                        partidFresh2 == iid.PartId()    );
#endif  // CIDBG
            _widFreshLog = wid;
            break;
    }

    return;
}

//+---------------------------------------------------------------------------
//
//  Function:   GetSpecialItObjectId
//
//  Synopsis:   Returns the current object id of a special index type.
//
//  Arguments:  [it] -- Index Type
//
//  History:    10-05-94   srikants   Created
//
//  Notes:      As of now, only the itFreshLog is of interest.
//
//----------------------------------------------------------------------------

WORKID CiStorage::GetSpecialItObjectId( IndexType it ) const
{
    switch ( it )
    {
        case itFreshLog:
            return(_widFreshLog);

        default:
            return(0);
    }
}


//+---------------------------------------------------------------------------
//
//  Function:   DeleteObject, public
//
//  Synopsis:   Deletes the file specified
//
//  Arguments:  [objectId] -- Object to delete
//
//  History:    Nov-16-94   DwightKr    Added this header
//
//----------------------------------------------------------------------------
void CiStorage::DeleteObject( WORKID objectId )
{
    RemoveObject( objectId );
}


//+---------------------------------------------------------------------------
//
//  Function:   EmptyIndexList, public
//
//  Synopsis:   Empties the index list
//
//  History:    Nov-16-94   DwightKr    Created
//
//----------------------------------------------------------------------------
void CiStorage::EmptyIndexList()
{
    WCHAR   wcsHdr[MAX_PATH];
    WCHAR   wcsCopy1[MAX_PATH];
    WCHAR   wcsCopy2[MAX_PATH];

    MakeLogPath( CAT_IDXTABLE_HDR, wcsHdr );
    MakeLogPath( CAT_IDXTABLE_CP1, wcsCopy1 );
    MakeLogPath( CAT_IDXTABLE_CP2, wcsCopy2 );

    HANDLE hFile = CreateFile( wcsHdr, GENERIC_WRITE, 0,
                               NULL, TRUNCATE_EXISTING,
                               FILE_ATTRIBUTE_NORMAL,
                               NULL );
    if ( INVALID_HANDLE_VALUE != hFile )
        CloseHandle( hFile );

    hFile = CreateFile( wcsCopy1, GENERIC_WRITE, 0,
                        NULL, TRUNCATE_EXISTING,
                        FILE_ATTRIBUTE_NORMAL,
                        NULL );
    if ( INVALID_HANDLE_VALUE != hFile )
        CloseHandle( hFile );

    hFile = CreateFile( wcsCopy2, GENERIC_WRITE, 0,
                        NULL, TRUNCATE_EXISTING,
                        FILE_ATTRIBUTE_NORMAL,
                        NULL );
    if ( INVALID_HANDLE_VALUE != hFile )
        CloseHandle( hFile );
}

//+---------------------------------------------------------------------------
//
//  Member:     CiStorage::ListPropStoreFileNames, public
//
//  Synopsis:   Lists property store related files in the ci directory.
//
//  Arguments:  [enumStr] - String enumerator to which to add filenames to.
//              [wid]     - WORKID of the property store.
//
//  History:    11-Apr-97   KrishnaN   Created
//              30-May-97   KrishnaN   Enumerate the backup file
//              24-Oct-97   KyleP      Backup file is ephemeral and thus not
//                                     part of the list.
//
//----------------------------------------------------------------------------

void CiStorage::ListPropStoreFileNames( CEnumString & enumStr, WORKID wid,
                                        DWORD dwStoreLevel )
{
    WCHAR   wcsHdr[MAX_PATH];
    WCHAR   wcsCopy1[MAX_PATH];
    WCHAR   wcsCopy2[MAX_PATH];

    //
    // Get the recoverable storage object files
    //


    Win4Assert(PRIMARY_STORE == dwStoreLevel || SECONDARY_STORE == dwStoreLevel);

    FormRcovObjNames( wid,
                      (PRIMARY_STORE == dwStoreLevel) ? PROPSTORE1_PREFIX:PROPSTORE2_PREFIX,
                      wcsHdr, wcsCopy1, wcsCopy2 );
    enumStr.Append(wcsHdr);
    enumStr.Append(wcsCopy1);
    enumStr.Append(wcsCopy2);

    //
    // Get the property store and prop store backup file names
    //

    // Reuse wcsCopy1
    PStorageObject *pObj = QueryObject(wid);
    XPtr<PStorageObject>    xObj(pObj);

    MakePath( (PRIMARY_STORE == dwStoreLevel) ? ePrimaryPropPath:eSecondaryPropPath,
               CI_OBJ(*pObj).ObjectId(), wcsCopy1);
    enumStr.Append(wcsCopy1);
}

//+---------------------------------------------------------------------------
//
//  Member:     CiStorage::ListSecStoreFileNames
//
//  Synopsis:   Lists the names of the files that constitute the recoverable
//              stoage object for the security store.
//
//  Arguments:  [enumStr] -- Output object to append the names of the
//                          security store.
//              [wid]     -- Workid
//
//  History:    7-14-97   srikants   Created
//
//----------------------------------------------------------------------------

void CiStorage::ListSecStoreFileNames( CEnumString & enumStr, WORKID wid )
{
    WCHAR   wcsHdr[MAX_PATH];
    WCHAR   wcsCopy1[MAX_PATH];
    WCHAR   wcsCopy2[MAX_PATH];

    //
    // Get the recoverable storage object files
    //
    FormRcovObjNames( wid, SECSTORE_PREFIX, wcsHdr, wcsCopy1, wcsCopy2 );

    enumStr.Append(wcsHdr);
    enumStr.Append(wcsCopy1);
    enumStr.Append(wcsCopy2);

}

//+---------------------------------------------------------------------------
//
//  Member:     CiStorage::DeleteFilesInCiDir
//
//  Synopsis:   Deletes files in the ci directory which match the given
//              pattern.
//
//  Arguments:  [pwszPattern] - Pattern of files to search.
//
//  History:    1-31-97   srikants   Created
//
//----------------------------------------------------------------------------

void CiStorage::DeleteFilesInCiDir( WCHAR const * pwszPattern )
{
    CFullPath   fullPath( _xPath.GetPointer() );

    WCHAR wszFullPattern[MAX_PATH];

    swprintf( wszFullPattern, L"%s%s", fullPath.GetBuf(), pwszPattern );

    WIN32_FIND_DATA fileData;

    HANDLE hFile = FindFirstFile( wszFullPattern, &fileData );

    if ( INVALID_HANDLE_VALUE == hFile )
    {
        ciDebugOut(( DEB_ITRACE, "Did not find files for (%ws)\n",
                     wszFullPattern ));
        return;
    }

    do
    {
        if ( !(fileData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) )
        {
            fullPath.MakePath( fileData.cFileName );
            BOOL fSuccess = DeleteFile( fullPath.GetBuf() );
            if ( !fSuccess )
            {
                DWORD dwError = GetLastError();
                ciDebugOut(( DEB_ITRACE,
                    "Failed to delete file (%ws) due to error (%d)\n",
                    fullPath.GetBuf(), dwError ));
            }
            else
            {
                ciDebugOut(( DEB_ITRACE,
                            "Deleted file (%ws)\n", fullPath.GetBuf() ));
            }
        }
        else
        {
            ciDebugOut(( DEB_ITRACE,
                         "Not deleting directory (%ws) \n", fullPath.GetBuf() ));

        }

    }
    while ( FindNextFile( hFile, &fileData ) );

    FindClose( hFile );
}

//+---------------------------------------------------------------------------
//
//  Member:     CiStorage::DeleteAllFiles
//
//  Synopsis:   Deletes all the files in the Ci directory.
//
//  History:    3-21-97   srikants   Created
//
//----------------------------------------------------------------------------

void CiStorage::DeleteAllFiles()
{
    WCHAR wszPattern[32];

    swprintf( wszPattern, L"*.*" );
    DeleteFilesInCiDir( wszPattern );

}

//+---------------------------------------------------------------------------
//
//  Member:     CiStorage::DeleteAllCiFiles
//
//  Synopsis:   Deletes files that belong to the CI engine.
//
//  History:    1-31-97   srikants   Created
//
//----------------------------------------------------------------------------

void CiStorage::DeleteAllCiFiles()
{
    //
    // Delete the following types of files.
    //
    WCHAR wszPattern[32];

    swprintf( wszPattern, L"*.ci" );
    DeleteFilesInCiDir( wszPattern );

    swprintf( wszPattern, L"*.dir" );
    DeleteFilesInCiDir( wszPattern );

    swprintf( wszPattern, L"%s*", MMLOG_PREFIX );
    DeleteFilesInCiDir( wszPattern );

    swprintf( wszPattern, L"%s*", PRI_CHANGELOG_PREFIX );
    DeleteFilesInCiDir( wszPattern );

    swprintf( wszPattern, L"%s*", SEC_CHANGELOG_PREFIX );
    DeleteFilesInCiDir( wszPattern );

    swprintf( wszPattern, L"%s*", FRESHLOG_PREFIX );
    DeleteFilesInCiDir( wszPattern );

    swprintf( wszPattern, L"INDEX.*" );
    DeleteFilesInCiDir( wszPattern );

}

//+---------------------------------------------------------------------------
//
//  Member:     CiStorage::DeleteAllPersistentIndexes
//
//  Synopsis:   Deletes all the persistent indexes in the ci directory.
//
//  History:    3-25-97   srikants   Created
//
//----------------------------------------------------------------------------

void CiStorage::DeleteAllPersIndexes()
{
    //
    // Delete the following types of files.
    //
    WCHAR wszPattern[32];

    swprintf( wszPattern, L"*.ci" );
    DeleteFilesInCiDir( wszPattern );

    swprintf( wszPattern, L"*.dir" );
    DeleteFilesInCiDir( wszPattern );
}

//+---------------------------------------------------------------------------
//
//  Member:     CiStorage::DeleteUnUsedPersIndexes
//
//  Synopsis:   Deletes any .ci and .dir files that are not referenced in
//              the given iid list.
//
//  Arguments:  [iidStk] - List of in-use iids.
//
//  History:    3-25-97   srikants   Created
//
//----------------------------------------------------------------------------

void CiStorage::DeleteUnUsedPersIndexes( BOOL fIsCi,
                                         CIndexIdList const & iidsInUse )
{
    WCHAR wszPattern[32];

    if ( fIsCi )
        swprintf( wszPattern, L"*.ci" );
    else
        swprintf( wszPattern, L"*.dir" );

    CFullPath   fullPath( _xPath.GetPointer() );

    WCHAR wszFullPattern[MAX_PATH];

    swprintf( wszFullPattern, L"%s%s", fullPath.GetBuf(), wszPattern );

    WIN32_FIND_DATA fileData;

    HANDLE hFile = FindFirstFile( wszFullPattern, &fileData );

    if ( INVALID_HANDLE_VALUE == hFile )
    {
        ciDebugOut(( DEB_ITRACE, "Did not find files for (%ws)\n",
                     wszFullPattern ));
        return;
    }

    do
    {
        if ( !(fileData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) )
        {
            if ( !IsInUse( fileData.cFileName, iidsInUse ) )
            {
                fullPath.MakePath( fileData.cFileName );

                ciDebugOut(( DEB_ITRACE, "Deleting UnUsed Index (%ws) \n",
                             fullPath.GetBuf() ));
                BOOL fSuccess = DeleteFile( fullPath.GetBuf() );
                if ( !fSuccess )
                {
                    DWORD dwError = GetLastError();
                    ciDebugOut(( DEB_ITRACE,
                        "Failed to delete file (%ws) due to error (%d)\n",
                        fullPath.GetBuf(), dwError ));
                }
                else
                {
                    ciDebugOut(( DEB_ITRACE,
                                "Deleted file (%ws)\n", fullPath.GetBuf() ));
                }
            }
        }
        else
        {
            ciDebugOut(( DEB_ITRACE,
                         "Not deleting directory (%ws) \n", fullPath.GetBuf() ));

        }

    }
    while ( FindNextFile( hFile, &fileData ) );

    FindClose( hFile );

}

//+---------------------------------------------------------------------------
//
//  Member:     CiStorage::IsInUse
//
//  Synopsis:   Tests if the given file is in use.
//
//  Arguments:  [pwszFile] -
//              [iidStk]   -
//
//  Returns:    TRUE if it is in use. FALSE o/w
//
//  History:    3-25-97   srikants   Created
//
//----------------------------------------------------------------------------

BOOL CiStorage::IsInUse( WCHAR const * pwszFile,
                         CIndexIdList const & iidsInUse ) const
{
    //
    // Determine the iid and see if it is in the list.
    //
    WCHAR * pwszEnd;
    INDEXID iid = (INDEXID) wcstol( pwszFile, &pwszEnd, 16 );

    for ( ULONG i = 0; i < iidsInUse.Count(); i++ )
    {
        if ( iid == iidsInUse.Get(i) )
            return TRUE;
    }

    return FALSE;
}

//+---------------------------------------------------------------------------
//
//  Member:     CiStorage::DeleteUnUsedPersIndexes
//
//  Synopsis:   Deletes the persistent .ci and .dir files that are not
//              in the list of in-use iids.
//
//  Arguments:  [iidStk] - The list of in-use iids.
//
//  History:    3-25-97   srikants   Created
//
//----------------------------------------------------------------------------

void CiStorage::DeleteUnUsedPersIndexes( CIndexIdList const & iidsInUse )
{

    DeleteUnUsedPersIndexes( TRUE, iidsInUse );    // delete the unused .ci files
    DeleteUnUsedPersIndexes( FALSE, iidsInUse );   // delete the unused .dir files
}


//+---------------------------------------------------------------------------
//
//  Member:     CiStorage::DeleteAllFsCiFiles
//
//  Synopsis:   Deletes all the files belonging to the FileSystem CI client.
//
//  History:    2-10-97   srikants   Created
//
//----------------------------------------------------------------------------

void CiStorage::DeleteAllFsCiFiles()
{
    //
    // Delete the following types of files.
    //
    WCHAR wszPattern[32];

    swprintf( wszPattern, L"cicat.hsh" );
    DeleteFilesInCiDir( wszPattern );

    swprintf( wszPattern, L"cicat.fid" );
    DeleteFilesInCiDir( wszPattern );

    swprintf( wszPattern, L"deletion.log" );
    DeleteFilesInCiDir( wszPattern );

    swprintf( wszPattern, PROP_BKP_FILE);
    DeleteFilesInCiDir( wszPattern );

    swprintf( wszPattern, PROP_BKP_FILE1);
    DeleteFilesInCiDir( wszPattern );

    swprintf( wszPattern, PROP_BKP_FILE2);
    DeleteFilesInCiDir( wszPattern );

    swprintf( wszPattern, L"*.prp" );
    DeleteFilesInCiDir( wszPattern );

    swprintf( wszPattern, L"*.ps1" );
    DeleteFilesInCiDir( wszPattern );

    swprintf( wszPattern, L"*.ps2" );
    DeleteFilesInCiDir( wszPattern );

    swprintf( wszPattern, L"%s*", PIDTABLE_PREFIX );
    DeleteFilesInCiDir( wszPattern );

    swprintf( wszPattern, L"%s*", SCOPELIST_PREFIX );
    DeleteFilesInCiDir( wszPattern );

    swprintf( wszPattern, L"%s*", SECSTORE_PREFIX );
    DeleteFilesInCiDir( wszPattern );

    swprintf( wszPattern, L"%s*", PROPSTORE_PREFIX );
    DeleteFilesInCiDir( wszPattern );

    swprintf( wszPattern, L"%s*", PROPSTORE1_PREFIX );
    DeleteFilesInCiDir( wszPattern );

    swprintf( wszPattern, L"%s*", PROPSTORE2_PREFIX );
    DeleteFilesInCiDir( wszPattern );

    swprintf( wszPattern, L"%s*", VSCOPELIST_PREFIX );
    DeleteFilesInCiDir( wszPattern );
}

//+---------------------------------------------------------------------------
//
//  Function:   EnumerateFilesInDir
//
//  Synopsis:   Enumerates files in a directory. Does not include directories
//              and there is no recursive traversal.
//
//  Arguments:  [pwszDir] - Directory to enumerate.
//              [enumStr] - Place to add the enumerated files.
//
//  History:    3-19-97   srikants   Created
//
//----------------------------------------------------------------------------

void CiStorage::EnumerateFilesInDir( WCHAR const * pwszDir,
                                     CEnumString & enumStr  )
{
    CFullPath   fullPath( (WCHAR *) pwszDir );

    fullPath.MakePath( L"*.*" );

    WIN32_FIND_DATA fileData;

    HANDLE hFile = FindFirstFile( fullPath.GetBuf(), &fileData );

    if ( INVALID_HANDLE_VALUE == hFile )
    {
        ciDebugOut(( DEB_ITRACE, "Did not find files for (%ws)\n",
                     fullPath.GetBuf() ));
        return;
    }

    do
    {
        if ( !(fileData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) )
        {
            fullPath.MakePath( fileData.cFileName );
            enumStr.Append( fullPath.GetBuf() );

            ciDebugOut(( DEB_ITRACE,
                         "EnumerateFiles - Adding File (%ws) \n", fullPath.GetBuf() ));

        }
        else
        {
            ciDebugOut(( DEB_ITRACE,
                         "EnumerateFiles - Skipping directory (%ws) \n", fileData.cFileName ));

        }
    }
    while ( FindNextFile( hFile, &fileData ) );

    FindClose( hFile );
}

//+---------------------------------------------------------------------------
//
//  Function:   IsValidFile
//
//  Synopsis:   Verifies that the given file is a valid file.
//
//  Arguments:  [pwszFile] - File name
//
//  History:    3-21-97   srikants   Created
//
//----------------------------------------------------------------------------

BOOL CiStorage::IsValidFile( WCHAR const * pwszFile )
{
    DWORD dwFileAttributes = GetFileAttributes( pwszFile );

    if ( 0xFFFFFFFF == dwFileAttributes )
    {
        DWORD dwError = GetLastError();

        ciDebugOut(( DEB_ITRACE, "GetFileAttributes failed with error %d\n", dwError ));
        return FALSE;
    }

    return  0 == (dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) ;
}

//+---------------------------------------------------------------------------
//
//  Function:   CheckHasIndexTable
//
//  Synopsis:   Verifies that the given directory is a valid one. Also checks
//              that files INDEX.000, INDEX.001, INDEX.002 are present in the
//              directory.
//
//  Arguments:  [pwszPath] - Path of the directory.
//
//  Returns:    TRUE if valid; FALSE o/w
//
//  History:    3-21-97   srikants   Created
//
//----------------------------------------------------------------------------

BOOL CiStorage::CheckHasIndexTable( WCHAR const * pwszPath )
{
    CFullPath   fullPath( pwszPath );

    fullPath.MakePath( CAT_IDXTABLE_HDR );
    if ( !IsValidFile( fullPath.GetBuf() ) )
        return FALSE;

    fullPath.MakePath( CAT_IDXTABLE_CP1 );
    if ( !IsValidFile( fullPath.GetBuf() ) )
        return FALSE;

    fullPath.MakePath( CAT_IDXTABLE_CP2 );
    if ( !IsValidFile( fullPath.GetBuf() ) )
        return FALSE;

    return TRUE;
}

//+---------------------------------------------------------------------------
//
//  Function:   DetermineDriveType
//
//  Synopsis:   Determines the type of drive on which the given path is.
//
//  Arguments:  [pwszPath] - Path of the file.
//
//  Returns:    WIN32 drive type ( values returned by GetDriveType() )
//
//  History:    3-24-97   srikants   Created
//
//----------------------------------------------------------------------------

UINT CiStorage::DetermineDriveType( WCHAR const * pwszPath )
{
    CPathParser pathParser( pwszPath );
    if ( pathParser.IsUNCName() )
        return DRIVE_REMOTE;

    WCHAR wDrive[MAX_PATH];
    ULONG cc=sizeof(wDrive)/sizeof(WCHAR);
    pathParser.GetFileName( wDrive, cc );

    UINT uType = GetDriveType( wDrive );
    return uType;
}

//+-------------------------------------------------------------------------
//
//  Method:     CiStorage::QueryStream, Private
//
//  Synopsis:   Opens a mmstream of name specified
//
//  Arguments:  [wcsFileName] - Name of the file. 
//
//  Returns:    CMmStream
//
//  History:    17-Mar-1998     KitmanH         Created
//
//--------------------------------------------------------------------------

PMmStream* CiStorage::QueryStream (WCHAR const * wcsFileName)
{

   XPtr<CMmStream> xStrm( new CMmStream( _cMegToLeaveOnDisk, _fIsReadOnly ) );

   DWORD dwAccess = _fIsReadOnly ? GENERIC_READ : ( GENERIC_READ | GENERIC_WRITE );

   DWORD sharing = _fIsReadOnly ? ( FILE_SHARE_READ | FILE_SHARE_WRITE ) : FILE_SHARE_READ;

   DWORD openMode = _fIsReadOnly ? OPEN_EXISTING : OPEN_ALWAYS;

   WCHAR  wcsFilePath[MAX_PATH];

   if ( ( wcslen( _xPath.GetPointer() ) + wcslen( wcsFileName ) ) >= MAX_PATH )
       THROW( CException( STATUS_INVALID_PARAMETER ) );

   wcscpy( wcsFilePath, _xPath.GetPointer() );
   wcscat( wcsFilePath, wcsFileName );

   xStrm->Open( wcsFilePath,
                dwAccess,      // Access flags
                sharing,
                openMode,
                FILE_ATTRIBUTE_NORMAL,
                FALSE );

   return xStrm.Acquire();
}

//+-------------------------------------------------------------------------
//
//  Method:     CiStorage::QueryStringHash
//
//  Synopsis:   Opens a mmstream by calling private function QueryStream
//              with the appropriate filename
//
//  Arguments:  [wcsFileName] - Name of the file. 
//
//  Returns:    CMmStream
//
//  History:    17-Mar-1998     KitmanH         Created
//
//--------------------------------------------------------------------------
PMmStream* CiStorage::QueryStringHash() 
{
    return QueryStream( CAT_HASH_FILE );
}

//+-------------------------------------------------------------------------
//
//  Method:     CiStorage::QueryFileIdMap
//
//  Synopsis:   Opens a mmstream by calling private function QueryStream
//              with the appropriate filename
//
//  Arguments:  [wcsFileName] - Name of the file. 
//
//  Returns:    CMmStream
//
//  History:    17-Mar-1998     KitmanH         Created
//
//--------------------------------------------------------------------------
PMmStream* CiStorage::QueryFileIdMap() 
{
    return QueryStream( CAT_FILEID_MAP_FILE );
}
    
//+-------------------------------------------------------------------------
//
//  Method:     CiStorage::QueryDeletionLog
//
//  Synopsis:   Opens a mmstream by calling private function QueryStream
//              with the appropriate filename
//
//  Arguments:  [wcsFileName] - Name of the file. 
//
//  Returns:    CMmStream
//
//  History:    17-Mar-1998     KitmanH         Created
//
//--------------------------------------------------------------------------
PMmStream* CiStorage::QueryDeletionLog() 
{
    Win4Assert( FALSE );
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\ntciutil\oleprop.cxx ===
//+------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1995-2000.
//
// File:        oleprop.cxx
//
// Contents:    OLE Property Manager.
//
// Classes:     COLEPropManager
//
// History:     13-Dec-95       dlee   Created from KyleP's FCB Manager
//
//-------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include <shlobj.h>
#include <nserror.h>

#include <propstm.hxx>
#include <oleprop.hxx>
#include <propvar.h>
#include <pmalloc.hxx>

//+---------------------------------------------------------------------------
//
//  Function:   FunnyToNormalPath
//
//  Synopsis:   Gets an interface over a file using the shell
//
//  Arguments:  [pwcPath] -- Path of the file to be opened
//              [riid]    -- Interface being requested
//              [ppv]     -- Where the interface is returned
//
//  Returns:    SCODE result of the open
//
//  History:    1-Feb-01       dlee   Created
//
//----------------------------------------------------------------------------

void FunnyToNormalPath( const CFunnyPath & funnyPath,
                        WCHAR * awcPath )
{
    WCHAR const * pwcPath = funnyPath.GetPath();

    #if CIDBG == 1

        unsigned cwc = wcslen( pwcPath );

        Win4Assert( cwc <= MAX_PATH );

    #endif // CIDBG

    // The shell doesn't understand the \\?\ syntax
    // Local:  \\?\c:\foo
    // Remote: \\?\UNC\server\share
    
    if ( !wcsncmp( pwcPath, L"\\\\?\\", 4 ) )
    {
        pwcPath += 4;

        if ( !wcsncmp( pwcPath, L"UNC\\", 4 ) )
            pwcPath += 2;
    }

    wcscpy( awcPath, pwcPath );

    if ( awcPath[1] == L'\\' )
        awcPath[0] = L'\\';
} //FunnyToNormalPath

//+---------------------------------------------------------------------------
//
//  Function:   ShellBindToItemByName
//
//  Synopsis:   Gets an interface over a file using the shell
//
//  Arguments:  [pwcPath] -- Path of the file to be opened
//              [riid]    -- Interface being requested
//              [ppv]     -- Where the interface is returned
//
//  Returns:    SCODE result of the open
//
//  History:    1-Feb-01       dlee   Created
//
//----------------------------------------------------------------------------

SCODE ShellBindToItemByName(
    WCHAR const * pwcPath,
    REFIID        riid,
    void **       ppv )
{
    Win4Assert( wcsncmp( pwcPath, L"\\\\?\\", 4 ) );

    XInterface<IShellFolder> xDesktop;
    SCODE sc = SHGetDesktopFolder( xDesktop.GetPPointer() );

    if ( SUCCEEDED( sc ) )
    {
        XInterface<IBindCtx> xBindCtx;

        sc = CreateBindCtx( 0, xBindCtx.GetPPointer() );
        if ( FAILED( sc ) )
            return sc;

        BIND_OPTS bo = {sizeof(bo), 0};
        bo.grfFlags = BIND_JUSTTESTEXISTENCE;   // skip all junctions

        sc = xBindCtx->SetBindOptions( &bo );

        if ( FAILED( sc ) )
            return sc;

        LPITEMIDLIST pidl;

        // cast needed for bad interface def
    
        sc = xDesktop->ParseDisplayName( 0,
                                         xBindCtx.GetPointer(),
                                         (LPWSTR) pwcPath,
                                         0,
                                         &pidl,
                                         0 );
        if ( SUCCEEDED( sc ) )
        {
            XInterface<IShellFolder> xSF;
            LPCITEMIDLIST pidlChild;

            // Note: apparently pidlChild isn't leaked here
    
            sc = SHBindToParent( pidl,
                                 IID_IShellFolder,
                                 xSF.GetQIPointer(),
                                 &pidlChild );
            if (SUCCEEDED(sc))
                sc = xSF->BindToObject( pidlChild, 0, riid, ppv );
    
            CoTaskMemFree( pidl );
        }
    }

    return sc;
} //ShellBindToItemByName

//+---------------------------------------------------------------------------
//
//  Member:     COLEPropManager::Open, public
//
//  Synopsis:   Open object corresponding to a path.
//
//  Arguments:  [pwcPath] - path of the file to be opened
//
//  Returns:    TRUE if failed due to sharing violation, FALSE otherwise
//
//  History:    13-Dec-95       dlee   Created
//
//----------------------------------------------------------------------------

BOOL COLEPropManager::Open( const CFunnyPath & funnyPath )
{
    Win4Assert( 0 == _ppsstg );

    // if we've tried to open this file before, don't try again.

    if ( _fStgOpenAttempted )
        return _fSharingViolation;

    _fStgOpenAttempted = TRUE;

    // NTRAID#DB-NTBUG9-84131-2000/07/31-dlee Indexing Service contains workarounds for StgOpenStorage AV on > MAX_PATH paths

    if ( funnyPath.GetLength() >= MAX_PATH )
    {
        ciDebugOut(( DEB_WARN, "Not calling StgOpenStorage in COLEPropManager::Open for paths > MAX_PATH: \n(%ws)\n",
                               funnyPath.GetPath() ));
        return FALSE;
    }

    //
    // Make sure the file isn't offline.
    //

    ULONG ulAttributes = GetFileAttributes( funnyPath.GetPath() );

    SCODE sc;

    if ( 0 == (ulAttributes & FILE_ATTRIBUTE_OFFLINE) )  // Note: attrib is also *on* in the error return
    {
        //
        // Get an IPropertSetStorage.
        //

#if 0

        sc = StgOpenStorageEx( funnyPath.GetPath(),     // Path
                               STGM_DIRECT |
                                 STGM_READ |
                                 STGM_SHARE_DENY_WRITE, // Flags (BChapman said use these)
                               STGFMT_ANY,              // Format
                               0,                       // Reserved
                               0,                       // Reserved
                               0,                       // Reserved
                               IID_IPropertySetStorage, // IID
                               (void **)&_ppsstg );

#else

        //
        // Note: Because of the above MAX_PATH check, we can copy into a fixed-length buffer
        // We need to hold onto the path because the shell open function expects the path to
        // remain valid for the life of the IPropertySetStorage we get back.
        //

        FunnyToNormalPath( funnyPath, _awcPath );

        // Use the shell's open to get additional properties from .mp3 files and others

        sc = ShellBindToItemByName( _awcPath,
                                    IID_IPropertySetStorage,
                                    (void **) &_ppsstg );

#endif

    }
    else
        sc = HRESULT_FROM_WIN32(ERROR_FILE_OFFLINE);

    if ( FAILED( sc ) )
    {
        vqDebugOut(( DEB_IWARN, "StgOpenStorage %ws returned 0x%x\n",
                     funnyPath.GetPath(), sc ));

        // For these nonfatal errors, fail silently.
        // Assuming STG_E_INVALIDNAME means the file didn't exist, but
        // even if it means the string is malformed it's ok to ignore.

        if ( STG_E_LOCKVIOLATION == sc ||
             STG_E_SHAREVIOLATION == sc )
        {
            _fSharingViolation = TRUE;
            return TRUE;
        }

        if ( STG_E_INVALIDFUNCTION == sc ||       // Common StgOpenStorageEx error (FAT volumes)
             STG_E_FILEALREADYEXISTS == sc ||     // Common StgOpenStorage error (FAT volumes)
             STG_E_ACCESSDENIED == sc ||
             STG_E_OLDFORMAT == sc ||
             STG_E_OLDDLL == sc ||
             STG_E_PATHNOTFOUND == sc ||
             STG_E_FILENOTFOUND == sc ||
             STG_E_INVALIDHEADER == sc ||
             STG_E_INVALIDNAME == sc ||
             HRESULT_FROM_WIN32(ERROR_FILE_OFFLINE) == sc )
            return FALSE;

        // these errors would mean a CI coding bug

        Win4Assert( STG_E_INVALIDPOINTER != sc );
        Win4Assert( STG_E_INVALIDFLAG != sc );

        // Almost any error code can be returned from StgOpenStorage.
        // The doc has little relation to the set of return codes.
        // This assert is just here so we know when we hit it whether
        // to put the new error in the ignore list (above) or the throw
        // list (here).

        Win4Assert( E_UNEXPECTED == sc ||
                    E_OUTOFMEMORY == sc ||
                    ERROR_NO_SYSTEM_RESOURCES ||
                    STG_E_TOOMANYOPENFILES == sc ||
                    STG_E_INSUFFICIENTMEMORY == sc ||
                    ( HRESULT_FROM_WIN32( ERROR_NOT_READY ) == sc ) );

        THROW( CException( sc ) );
    }

    return FALSE;
} //Open

//+---------------------------------------------------------------------------
//
//  Member:     COLEPropManager::PropSetToOrdinal, public
//
//  Synopsis:   Find property set for specified GUID.
//
//  Arguments:  [guidPS] -- GUID of property set.
//
//  Returns:    Ordinal of property set.
//
//  History:    13-Dec-95       dlee   Created
//
//----------------------------------------------------------------------------

unsigned COLEPropManager::PropSetToOrdinal(
    GUID const & guidPS )
{
    //
    // This is likely to be a very small array.  Just go for a linear search.
    //

    for ( unsigned i = 0; i < _aPropSets.Count(); i++ )
    {
        if ( _aPropSets[ i ].GetGuid() == guidPS )
            return i;
    }

    //
    // New property set.  Need to add entry.
    //

    _aPropSets[ i ] = COLEPropManager::CPropSetMap( guidPS );
    return i;
} //PropSetToOrdinal

//+---------------------------------------------------------------------------
//
//  Function:   IsNullPointerVariant
//
//  Synopsis:   Determines if a variant looks like it should have a
//              pointer but doesn't.
//
//  Arguments:  [ppv] -- the variant to test
//
//  Returns:    TRUE if a variant with a 0 pointer, FALSE otherwise
//
//  History:    04-Mar-96       dlee   Created
//
//----------------------------------------------------------------------------

BOOL IsNullPointerVariant(
    PROPVARIANT *ppv )
{
    if ( (VT_VECTOR & ppv->vt) &&
         0 != ppv->cal.cElems &&
         0 == ppv->cal.pElems )
        return TRUE;

    switch (ppv->vt)
    {
        case VT_CLSID:
            return ( 0 == ppv->puuid );

        case VT_BLOB:
        case VT_BLOB_OBJECT:
            return ( ( 0 != ppv->blob.cbSize ) &&
                     ( 0 == ppv->blob.pBlobData ) );

        case VT_CF:
            return ( ( 0 == ppv->pclipdata ) ||
                     ( 0 == ppv->pclipdata->pClipData ) );

        case VT_BSTR:
        case VT_LPSTR:
        case VT_LPWSTR:
            return ( 0 == ppv->pszVal );

        case VT_VECTOR | VT_BSTR:
        case VT_VECTOR | VT_LPSTR:
        case VT_VECTOR | VT_LPWSTR:
        {
            for (unsigned i = 0; i < ppv->calpstr.cElems; i++)
            {
                if ( 0 == ppv->calpstr.pElems[i] )
                    return TRUE;
            }
            break;
        }
        case VT_VECTOR | VT_VARIANT:
        {
            for (unsigned i = 0; i < ppv->capropvar.cElems; i++)
            {
                if ( IsNullPointerVariant( & (ppv->capropvar.pElems[i]) ) )
                    return TRUE;
            }
            break;
        }
    }

    return FALSE;
} //IsNullPointerVariant

//+---------------------------------------------------------------------------
//
//  Member:     COLEPropManager::FetchProperty, public
//
//  Synopsis:   Retrieve a property from a property set.
//
//  Arguments:  [guidPS]     -- property set to read from
//              [psProperty] -- PROPSPEC for property.
//              [pbData]     -- Property stored here.
//              [pcb]        -- Size in bytes of [pbData].  On output, size
//                              actually required.  An output <= input
//                              implies property successfully retrieved.
//
//  History:    13-Dec-95       dlee   Created
//              27-Aug-97       kylep  Convert Ole summary info to Unicode
//
//----------------------------------------------------------------------------

inline BYTE * PastHeader(
    PROPVARIANT * ppv )
{
    return( (BYTE *)ppv + sizeof( PROPVARIANT ) );
}

#define VCASE( vvar, type )                                             \
    cb += var[0].vvar.cElems * sizeof(var[0].vvar.pElems[0]);           \
    if ( cb <= *pcb )                                                   \
    {                                                                   \
        pbData->vvar.pElems = (type *)PastHeader(pbData);               \
        memcpy( pbData->vvar.pElems,                                    \
                var[0].vvar.pElems,                                     \
                var[0].vvar.cElems * sizeof(var[0].vvar.pElems[0]) );   \
    }

void COLEPropManager::FetchProperty(
    GUID const &     guidPS,
    PROPSPEC const & psProperty,
    PROPVARIANT *    pbData,
    unsigned *       pcb )
{
    if ( 0 == _ppsstg )
    {
        pbData->vt = VT_EMPTY;
        *pcb = sizeof( *pbData );
        return;
    }

    //
    //  The Office custom property set may not be opened when any other
    //  property set is opened, so treat this as a special case.
    //  Close all other property sets when opening it, and close it
    //  when opening any other property set.
    //

    if ( FMTID_UserDefinedProperties == guidPS )
    {
        if ( !_fOfficeCustomPropsetOpen )
        {
            _aPropSets.Clear();
            _fOfficeCustomPropsetOpen = TRUE;
        }
    }
    else if ( _fOfficeCustomPropsetOpen )
    {
        _aPropSets.Clear();
        _fOfficeCustomPropsetOpen = FALSE;
    }

    unsigned iPropSet = PropSetToOrdinal( guidPS );

    Win4Assert( iPropSet < _aPropSets.Count() );

    COLEPropManager::CPropSetMap & sm = _aPropSets[ iPropSet ];

    //
    //  May have to open the set.
    //

    if ( !sm.isOpen( _ppsstg ) )
    {
        pbData->vt = VT_EMPTY;
        *pcb = sizeof( *pbData );
        return;
    }

    PROPVARIANT var[2];
    PropVariantInit( &var[0] );
    PropVariantInit( &var[1] );

    PROPSPEC aps[2];
    aps[0] = psProperty;
    aps[1].ulKind = PRSPEC_PROPID;
    aps[1].propid = PID_CODEPAGE;
    SCODE sc = sm.GetPS().ReadMultiple( 2,
                                        aps,
                                        var );

    // A few specific failures should throw and and cause the
    // entire query to fail.

    if ( E_OUTOFMEMORY == sc ||
         STG_E_INSUFFICIENTMEMORY == sc ||
         E_UNEXPECTED == sc )
        THROW( CException( sc ) );

    if ( FAILED( sc ) )
    {
        // the first three would be due to invalid parameters, which
        // would be a programming bug.

        Win4Assert( STG_E_INVALIDPARAMETER != sc );
        Win4Assert( STG_E_INVALIDPOINTER != sc );
        Win4Assert( HRESULT_FROM_WIN32(ERROR_NO_UNICODE_TRANSLATION) != sc );

        // access-denied is the only legal error that maps to VT_EMPTY

        Win4Assert( STG_E_ACCESSDENIED == sc );

        pbData->vt = VT_EMPTY;
        *pcb = sizeof( *pbData );
        return;
    }

    // The rest of the query code doesn't understand variants that
    // require a pointer but don't have one.  Such variants are legal,
    // but we map them to VT_EMPTY.

    if ( IsNullPointerVariant( &var[0] ) )
    {
        FreePropVariantArray( 1, &var[0] );

        pbData->vt = VT_EMPTY;
        *pcb = sizeof( *pbData );
        return;
    }

    //
    // Maybe we didn't get a codepage?
    //

    DWORD dwCodepage = ( var[1].vt == VT_I2 && CP_WINUNICODE != var[1].iVal ) ?
                       (unsigned short) var[1].iVal :
                       CP_ACP;

    *pbData = var[0];

    unsigned cb = sizeof PROPVARIANT;

    //
    // Deal with variable length portion.
    //

    switch ( var[0].vt )
    {
    case VT_EMPTY:
    case VT_NULL:
    case VT_I1:
    case VT_UI1:
    case VT_I2:
    case VT_UI2:
    case VT_I4:
    case VT_UI4:
    case VT_INT:
    case VT_UINT:
    case VT_DECIMAL:
    case VT_I8:
    case VT_UI8:
    case VT_R4:
    case VT_R8:
    case VT_BOOL:
    case VT_ILLEGAL:
    case VT_ERROR:
    case VT_CY:
    case VT_DATE:
    case VT_FILETIME:
        break;                  // fixed length types -- nothing to do

    case VT_BSTR:
        cb += BSTRLEN( var[0].bstrVal ) + sizeof(OLECHAR) + sizeof(DWORD);
        if (cb <= *pcb)
        {
            BSTR bstr = (BSTR) PastHeader(pbData);

            memcpy( bstr, &BSTRLEN(var[0].bstrVal), cb - sizeof(PROPVARIANT) );
            pbData->bstrVal = (BSTR) (((DWORD *)bstr) + 1);
        }
        break;

    case VT_LPSTR:
        //
        // HACK #274: Translate the Ole summary information LPSTR in LPWSTR
        //            Makes these properties compatible with HTML filter
        //            equivalents.
        //

        if ( FMTID_SummaryInformation == guidPS )
        {
            unsigned cc = strlen( var[0].pszVal ) + 1;

            unsigned ccT = MultiByteToWideChar( dwCodepage,
                                                0, // precomposed used if the codepage supports it
                                                var[0].pszVal,
                                                cc,
                                                (WCHAR *)PastHeader(pbData),
                                                (*pcb - sizeof(PROPVARIANT)) / sizeof(WCHAR) );

            if ( 0 == ccT )
            {
                if ( ERROR_INSUFFICIENT_BUFFER == GetLastError() )
                {
                        unsigned ccNeeded = MultiByteToWideChar( dwCodepage,
                                                                 0, // precomposed used if the codepage supports it
                                                                 var[0].pszVal,
                                                                 cc,
                                                                 0,
                                                                 0 );
                        Win4Assert( ccNeeded > 0 );

                        cb += ccNeeded * sizeof(WCHAR);
                }
                else
                {
                    ciDebugOut(( DEB_ERROR, "Error %d converting \"%s\" to codepage 0x%x\n",
                                 GetLastError(), var[0].pszVal, dwCodepage ));

                    cb += strlen( var[0].pszVal ) + 1;
                    if (cb <= *pcb)
                    {
                        pbData->pszVal = (char *)PastHeader(pbData);
                        memcpy( pbData->pszVal, var[0].pszVal, cb - sizeof(PROPVARIANT) );
                    }
                }
            }

            if ( ccT != 0 )
            {
                pbData->vt = VT_LPWSTR;
                pbData->pwszVal = (WCHAR *)PastHeader(pbData);
                cb += ccT * sizeof(WCHAR);
            }
        }
        else
        {
            cb += strlen( var[0].pszVal ) + 1;
            if (cb <= *pcb)
            {
                pbData->pszVal = (char *)PastHeader(pbData);
                memcpy( pbData->pszVal, var[0].pszVal, cb - sizeof(PROPVARIANT) );
            }
        }
        break;

    case VT_LPWSTR:
        cb += (wcslen( var[0].pwszVal ) + 1) * sizeof(WCHAR);
        if (cb <= *pcb)
        {
            pbData->pwszVal = (WCHAR *)PastHeader(pbData);
            memcpy( pbData->pwszVal, var[0].pwszVal, cb - sizeof(PROPVARIANT) );
        }
        break;

    case VT_CLSID:
        cb += sizeof(GUID);
        if (cb <= *pcb)
        {
            pbData->puuid = (GUID *)PastHeader(pbData);
            memcpy( pbData->puuid, var[0].puuid, cb - sizeof(PROPVARIANT) );
        }
        break;

    case VT_BLOB:
        cb += var[0].blob.cbSize;
        if (cb <= *pcb)
        {
            pbData->blob.pBlobData = PastHeader(pbData);
            memcpy( pbData->blob.pBlobData, var[0].blob.pBlobData, cb - sizeof(PROPVARIANT) );
        }
        break;

    case VT_CF:
        cb += sizeof(*(var[0].pclipdata)) + CBPCLIPDATA(*var[0].pclipdata);
        if ( cb <= *pcb )
        {
            pbData->pclipdata = (CLIPDATA *)PastHeader(pbData);
            memcpy( pbData->pclipdata, var[0].pclipdata, sizeof(*(var[0].pclipdata)) );

            pbData->pclipdata->pClipData = PastHeader(pbData) + sizeof(*(var[0].pclipdata));
            memcpy( pbData->pclipdata->pClipData,
                    var[0].pclipdata->pClipData,
                    CBPCLIPDATA(*var[0].pclipdata) );
        }
        break;

    //
    // Vectors (ugh!)
    //

    case VT_I1|VT_VECTOR:
    case VT_UI1|VT_VECTOR:
        VCASE( caub, BYTE );
        break;

    case VT_I2|VT_VECTOR:
        VCASE( cai, short );
        break;

    case VT_UI2|VT_VECTOR:
        VCASE( caui, USHORT );
        break;

    case VT_BOOL|VT_VECTOR:
        VCASE( cabool, VARIANT_BOOL );
        break;

    case VT_I4|VT_VECTOR:
    case VT_INT|VT_VECTOR:
        VCASE( cal, long );
        break;

    case VT_UI4|VT_VECTOR:
    case VT_UINT|VT_VECTOR:
        VCASE( caul, ULONG );
        break;

    case VT_R4|VT_VECTOR:
        VCASE( caflt, float );
        break;

    case VT_ERROR|VT_VECTOR:
        VCASE( cascode, SCODE );
        break;

    case VT_I8|VT_VECTOR:
        VCASE( cah, LARGE_INTEGER );
        break;

    case VT_UI8|VT_VECTOR:
        VCASE( cauh, ULARGE_INTEGER );
        break;

    case VT_R8|VT_VECTOR:
        VCASE( cadbl, double );
        break;

    case VT_CY|VT_VECTOR:
        VCASE( cacy, CY );
        break;

    case VT_DATE|VT_VECTOR:
        VCASE( cadate, DATE );
        break;

    case VT_FILETIME|VT_VECTOR:
        VCASE( cafiletime, FILETIME );
        break;

    case VT_CLSID|VT_VECTOR:
        VCASE( cauuid, CLSID );
        break;

    case VT_CF|VT_VECTOR:
    {
        cb += var[0].caclipdata.cElems * sizeof(var[0].caclipdata.pElems[0]);

        for ( unsigned i = 0; i < var[0].caclipdata.cElems; i++ )
        {
            cb += CBPCLIPDATA(var[0].caclipdata.pElems[i]);
        }

        if ( cb <= *pcb )
        {
            pbData->caclipdata.pElems = (CLIPDATA *)PastHeader(pbData);
            memcpy( pbData->caclipdata.pElems,
                    var[0].caclipdata.pElems,
                    var[0].caclipdata.cElems * sizeof(var[0].caclipdata.pElems[0]) );

            BYTE * pb = PastHeader(pbData) + var[0].caclipdata.cElems * sizeof(var[0].caclipdata.pElems[0]);

            for ( i = 0; i < var[0].caclipdata.cElems; i++ )
            {
                pbData->caclipdata.pElems[i].pClipData = pb;
                memcpy( pbData->caclipdata.pElems[i].pClipData,
                        var[0].caclipdata.pElems[i].pClipData,
                        CBPCLIPDATA(var[0].caclipdata.pElems[i]) );
                pb += CBPCLIPDATA(var[0].caclipdata.pElems[i]);
            }

        }

        break;
    }

    case VT_LPSTR|VT_VECTOR:
    {
        cb += var[0].calpstr.cElems * sizeof( var[0].calpstr.pElems[0] );

        for ( unsigned i = 0; i < var[0].calpstr.cElems; i++ )
        {
            cb += strlen( var[0].calpstr.pElems[i] ) + 1;
        }

        if ( cb <= *pcb )
        {
            pbData->calpstr.pElems = (char **)PastHeader(pbData);

            char * pc = (char *)PastHeader(pbData) +
                        var[0].calpstr.cElems * sizeof( var[0].calpstr.pElems[0] );

            for ( i = 0; i < var[0].calpstr.cElems; i++ )
            {
                pbData->calpstr.pElems[i] = pc;
                unsigned cc = strlen( var[0].calpstr.pElems[i] ) + 1;

                memcpy( pbData->calpstr.pElems[i],
                        var[0].calpstr.pElems[i],
                        cc );

                pc += cc;
            }
        }
        break;
    }

    case VT_LPWSTR|VT_VECTOR:
    {
        cb += var[0].calpwstr.cElems * sizeof( var[0].calpwstr.pElems[0] );

        for ( unsigned i = 0; i < var[0].calpwstr.cElems; i++ )
        {
            cb += (wcslen( var[0].calpwstr.pElems[i] ) + 1) * sizeof(WCHAR);
        }

        if ( cb <= *pcb )
        {
            pbData->calpwstr.pElems = (WCHAR **)PastHeader(pbData);

            WCHAR * pwc = (WCHAR *)(PastHeader(pbData) +
                          var[0].calpwstr.cElems * sizeof( var[0].calpwstr.pElems[0] ));

            for ( i = 0; i < var[0].calpwstr.cElems; i++ )
            {
                pbData->calpwstr.pElems[i] = pwc;
                unsigned cc = wcslen( var[0].calpwstr.pElems[i] ) + 1;

                memcpy( pbData->calpwstr.pElems[i],
                        var[0].calpwstr.pElems[i],
                        cc * sizeof(WCHAR) );

                pwc += cc;
            }
        }
        break;
    }

    case VT_BSTR|VT_VECTOR:
    {
        cb += var[0].cabstr.cElems * sizeof( var[0].cabstr.pElems[0] );

        for ( unsigned i = 0; i < var[0].cabstr.cElems; i++ )
        {
            cb += AlignBlock( BSTRLEN( var[0].cabstr.pElems[i] ) +
                              sizeof OLECHAR + sizeof DWORD,
                              sizeof DWORD );
        }

        if ( cb <= *pcb )
        {
            pbData->cabstr.pElems = (BSTR *)PastHeader(pbData);

            BSTR pwc = (BSTR)(PastHeader(pbData) +
                          var[0].cabstr.cElems * sizeof( var[0].cabstr.pElems[0] ));

            for ( i = 0; i < var[0].cabstr.cElems; i++ )
            {
                pbData->cabstr.pElems[i] = (BSTR) (((DWORD *) pwc) + 1);
                unsigned cbbstr = BSTRLEN( var[0].cabstr.pElems[i] ) +
                              sizeof(OLECHAR) + sizeof (DWORD);

                memcpy( pwc,
                        &BSTRLEN(var[0].cabstr.pElems[i]),
                        cbbstr);

                pwc += AlignBlock( cbbstr, sizeof DWORD ) / sizeof OLECHAR;
            }
        }
        break;
    }

    case VT_ARRAY | VT_I4:
    case VT_ARRAY | VT_UI1:
    case VT_ARRAY | VT_I2:
    case VT_ARRAY | VT_R4:
    case VT_ARRAY | VT_R8:
    case VT_ARRAY | VT_BOOL:
    case VT_ARRAY | VT_ERROR:
    case VT_ARRAY | VT_CY:
    case VT_ARRAY | VT_DATE:
    case VT_ARRAY | VT_I1:
    case VT_ARRAY | VT_UI2:
    case VT_ARRAY | VT_UI4:
    case VT_ARRAY | VT_INT:
    case VT_ARRAY | VT_UINT:
    case VT_ARRAY | VT_DECIMAL:
    case VT_ARRAY | VT_BSTR:
    case VT_ARRAY | VT_VARIANT:
    {
        SAFEARRAY * pSaSrc  = var[0].parray;
        SAFEARRAY * pSaDest = 0;

        cb += SaComputeSize( var[0].vt & ~VT_ARRAY, *pSaSrc );

        ciDebugOut(( DEB_ITRACE, "fetch safearray, *pcb, cb: %d, %d\n", *pcb, cb ));

        if ( cb <= *pcb )
        {
            CNonAlignAllocator ma( *pcb - sizeof (PROPVARIANT), PastHeader(pbData) );

            if ( SaCreateAndCopy( ma, pSaSrc, &pSaDest ) &&
                 SaCreateDataUsingMA( ma,
                                      var[0].vt & ~VT_ARRAY,
                                      *pSaSrc,
                                      *pSaDest,
                                      TRUE) )
            {
                pbData->parray = pSaDest;
                ciDebugOut(( DEB_ITRACE, "  pSaDest: %#x\n", pSaDest ));
            }
            else
            {
                // We've been guaranteed by SaComputeSize and *pcb that there
                // is sufficient memory to copy the array.  There must be a
                // bug if we can't.

                ciDebugOut(( DEB_ERROR,
                             "  can't copy SA %#x using %d bytes\n",
                             pSaSrc, cb ));
                Win4Assert( !"can't copy safearray" );
            }
        }

        break;
    }

    case VT_VARIANT|VT_VECTOR:
    {
        vqDebugOut(( DEB_WARN,
                     "COLEPropManager::FetchProperty - variant vector fetch %x\n",
                     &var[0] ));
        //Win4Assert( !"Fetch of variant vector not yet implemented" );

        pbData->vt = VT_EMPTY;
        *pcb = sizeof( *pbData );

        break;
    }

    case VT_STREAM:
    case VT_STREAMED_OBJECT:
    case VT_STORED_OBJECT:
    case VT_BLOB_OBJECT:
    {
        //
        // We don't support these datatypes.  Some make since to support
        // some day, but users can always retrieve the path and load the
        // values themselves.  Performance-wise it makes no since for us
        // to remote the values from our process.
        //

        pbData->vt = VT_EMPTY;
        cb = sizeof( *pbData );
        break;
    }

    default:
        Win4Assert( !"Unhandled variant type!" );
    }

    //
    // Cleanup
    //

    FreePropVariantArray( 1, &var[0] );

    *pcb = cb;
} //FetchProperty

//+---------------------------------------------------------------------------
//
//  Member:     COLEPropManager::CPropSetMap::isOpen, public
//
//  Synopsis:   Opens a property storage if it isn't already open
//
//  Arguments:  [ppsstg]     - property set storage from which property
//                             storage is opened.
//
//  History:     13-Dec-95       dlee   Created
//
//----------------------------------------------------------------------------

BOOL COLEPropManager::CPropSetMap::isOpen(
    IPropertySetStorage * ppsstg )
{
    if ( 0 != _pstg )
        return TRUE;

    if ( _fOpenAttempted )
        return FALSE;

    _fOpenAttempted = TRUE;

    SCODE sc = ppsstg->Open( _guid,
                             STGM_READ | STGM_SHARE_EXCLUSIVE, // BChapman said to use these
                             & _pstg );

    if ( FAILED( sc ) )
    {
        // don't fail the entire query if the property set doesn't
        // exist or if access is not allowed for this user, or if the
        // file was reverted after being opened.

        if ( STG_E_FILENOTFOUND != sc &&
             STG_E_ACCESSDENIED != sc &&
             NS_E_UNRECOGNIZED_STREAM_TYPE != sc && // The Shell enumeration routines do this
             NS_E_INVALID_DATA != sc &&             // 
             NS_E_FILE_INIT_FAILED != sc &&         // ""
             NS_E_FILE_OPEN_FAILED != sc &&         // ""
             E_FAIL != sc &&                        // ""
             STG_E_REVERTED != sc )
        {
            vqDebugOut(( DEB_WARN, "psstg->open failed: 0x%x\n", sc ));

            // this would be a coding bug in CI

            Win4Assert( STG_E_INVALIDPARAMETER != sc );

            Win4Assert( E_UNEXPECTED == sc ||
                        E_OUTOFMEMORY == sc ||
                        STG_E_INSUFFICIENTMEMORY == sc ||
                        STG_E_INVALIDHEADER == sc ||
                        STG_E_DOCFILECORRUPT == sc ||
                        ( HRESULT_FROM_WIN32( ERROR_NOT_READY ) == sc ) );

            THROW( CException( sc ) );
        }
    }

    return SUCCEEDED( sc );
} //isOpen

//+---------------------------------------------------------------------------
//
//  Member:     COLEPropManager::CPropSetMap::Close, public
//
//  Synopsis:   Closes a property storage
//
//  History:     13-Dec-95       dlee   Created
//
//----------------------------------------------------------------------------

void COLEPropManager::CPropSetMap::Close()
{
    if ( 0 != _pstg )
    {
        _pstg->Release();
        _pstg = 0;
    }

    _fOpenAttempted = FALSE;
} //Close

//+---------------------------------------------------------------------------
//
//  Member:     COLEPropManager::ReadProperty, public
//
//  Synopsis:   Reads an OLE property value using CoTaskMem memory
//
//  Arguments:  [ps]  -- property spec to read
//              [Var] -- where to put the value
//
//  Returns:    TRUE if a value found, FALSE otherwise, or throws on error
//
//  History:    18-Dec-97       dlee   Created
//
//----------------------------------------------------------------------------

BOOL COLEPropManager::ReadProperty(
    CFullPropSpec const & ps,
    PROPVARIANT &         Var )
{
    Var.vt = VT_EMPTY;

    if ( 0 == _ppsstg )
        return FALSE;

    //
    // Open the property storage for the given guid
    //

    IPropertyStorage * pPropStg;
    SCODE sc = _ppsstg->Open( ps.GetPropSet(), // guid
                              STGM_READ | STGM_SHARE_EXCLUSIVE, // BChapman said to use these...
                              &pPropStg );

    if ( SUCCEEDED(sc) )
    {
        XInterface<IPropertyStorage> xPropStg( pPropStg );

        //
        // Read the value
        //

        //
        // HACK #274: Translate the Ole summary information LPSTR in LPWSTR
        //            Makes these properties compatible with HTML filter
        //            equivalents.
        //

        if ( ps.GetPropSet() == FMTID_SummaryInformation )
        {
            PROPVARIANT var[2];
            PropVariantInit( &var[0] );
            PropVariantInit( &var[1] );

            PROPSPEC aps[2];
            aps[0] = ps.GetPropSpec();
            aps[1].ulKind = PRSPEC_PROPID;
            aps[1].propid = PID_CODEPAGE;

            sc = xPropStg->ReadMultiple( 2,
                                         aps,
                                         var );

            if ( FAILED(sc) )
                return DBSTATUS_S_ISNULL;

            //
            // Did we get a codepage?
            //

            DWORD dwCodepage = ( var[1].vt == VT_I2 && CP_WINUNICODE != var[1].iVal ) ?
                               (unsigned short) var[1].iVal :
                               CP_ACP;

            if ( VT_LPWSTR == var[0].vt )
            {
                //
                // Convert to Unicode
                //

                unsigned cc = strlen( var[0].pszVal ) + 1;
                XGrowable<WCHAR> xwcsProp( cc + (cc * 10 / 100) );  // 10% fluff
                unsigned ccT = 0;

                while ( 0 == ccT )
                {
                    ccT = MultiByteToWideChar( dwCodepage,
                                               0, // precomposed implied if the codepage supports it
                                               var[0].pszVal,
                                               cc,
                                               xwcsProp.Get(),
                                               xwcsProp.Count() );

                    if ( 0 == ccT )
                    {
                        if ( ERROR_INSUFFICIENT_BUFFER == GetLastError() )
                        {
                            unsigned ccNeeded = MultiByteToWideChar( dwCodepage,
                                                                     0, // precomposed implied if the codepage supports it
                                                                     var[0].pszVal,
                                                                     cc,
                                                                     0,
                                                                     0 );
                            Win4Assert( ccNeeded > 0 );
                            xwcsProp.SetSize( ccNeeded );
                        }
                        else
                        {
                            vqDebugOut(( DEB_ERROR, "Error %d converting %s to codepage 0x%x\n",
                                         GetLastError(), var[0].pszVal, dwCodepage ));
                            ccT = 0;
                            break;
                        }
                    }
                }

                if ( ccT != 0 )
                {
                    Var.vt = VT_LPWSTR;
                    Var.pwszVal = (WCHAR *)CoTaskMemAlloc( ccT * sizeof(WCHAR) );

                    if ( 0 == Var.pwszVal )
                    {
                        FreePropVariantArray( 2, var );
                        THROW( CException( E_OUTOFMEMORY ) );
                    }

                    RtlCopyMemory( Var.pwszVal, xwcsProp.Get(), ccT * sizeof(WCHAR) );

                    FreePropVariantArray( 2, var );
                }
                else
                    Var = var[0];
            }
            else
                Var = var[0];
        }
        else
        {
            sc = xPropStg->ReadMultiple( 1,  // 1 value to retrieve
                                         &ps.GetPropSpec(),
                                         &Var );
        }
    }

    if ( STG_E_FILENOTFOUND == sc ||
         STG_E_ACCESSDENIED == sc )
        return FALSE;

    if ( FAILED( sc ) )
        THROW( CException( sc ) );

    return TRUE;
} //ReadProperty
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\ntciutil\pathpars.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1994.
//
//  File:       pathpars.cxx
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    2-10-96   srikants   Created
//
//----------------------------------------------------------------------------


#include <pch.cxx>
#pragma hdrstop

#include <pathpars.hxx>

//+---------------------------------------------------------------------------
//
//  Member:     CPathParser::_SkipToNextBackSlash
//
//  Synopsis:   Increments _iNext to position at the next backslash.
//
//  History:    2-11-96   srikants   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

void CPathParser::_SkipToNextBackSlash()
{
    for ( ; _iNext < _len ; _iNext++ )
    {
        if ( wBackSlash == _pwszPath[_iNext] )
            break;
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CPathParser::_IsDriveName
//
//  Synopsis:   Checks if the first component of the path is a drive name.
//
//
//  Returns:    TRUE  if it has a drive name.
//              FALSE o/w
//
//  History:    2-11-96   srikants   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

BOOL CPathParser::_IsDriveName() const
{
    if ( _len < cMinDriveName )
        return FALSE;

    if ( wColon == _pwszPath[1] && iswalpha(_pwszPath[0]) )
        return TRUE;

    return FALSE;
}

//+---------------------------------------------------------------------------
//
//  Member:     CPathParser::_IsUNCName
//
//  Synopsis:   Tests if the given path is a UNC name.
//
//  History:    2-11-96   srikants   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

BOOL CPathParser::_IsUNCName()
{
    if ( _len < cMinUNC  )
        return FALSE;

    //
    // Check if the first two chars are "\\"
    //
    if ( wBackSlash != _pwszPath[0] || _pwszPath[1] != wBackSlash )
        return FALSE;

    //
    // Now look for a back slash from the third character.
    //
    _iNext = 3;
    _SkipToNextBackSlash();
    if ( _iNext < _len )
    {
        Win4Assert( wBackSlash == _pwszPath[_iNext] );
        return TRUE;
    }

    return FALSE;
}

//+---------------------------------------------------------------------------
//
//  Member:     CPathParser::_SkipToNext
//
//  Synopsis:   Positions _iNext beyond the next backslash.
//
//  History:    2-11-96   srikants   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

void CPathParser::_SkipToNext()
{
//   Win4Assert( _iNext < _len && !_IsAtBackSlash() );

    _SkipToNextBackSlash();
    if ( _iNext < _len )
    {
        Win4Assert( _IsAtBackSlash() );
        _iNext++;
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CPathParser::_SkipUNC
//
//  Synopsis:   Skips the UNC part of the name.
//
//  History:    2-11-96   srikants   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

void CPathParser::_SkipUNC()
{
    Win4Assert( wBackSlash == _pwszPath[_iNext] );

    _iNext++;
    //
    // Locate the next backslash or EOS
    //
    _SkipToNext();
}

//+---------------------------------------------------------------------------
//
//  Member:     CPathParser::_SkipDrive
//
//  Synopsis:   Skips the "drive" part of the path.
//
//  History:    2-11-96   srikants   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

void CPathParser::_SkipDrive()
{
    if ( _len > cMinDriveName && wBackSlash == _pwszPath[cMinDriveName] )
        _iNext = cMinDriveName+1;
    else
        _iNext = _len;
}


//+---------------------------------------------------------------------------
//
//  Member:     CPathParser::Init
//
//  Synopsis:   Initializes the member variables for the given path.
//
//  Arguments:  [pwszPath] -
//              [len]      -
//
//  History:    2-11-96   srikants   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

void CPathParser::Init( WCHAR const * pwszPath, ULONG len )
{
    _pwszPath = pwszPath;
    _pCurr = pwszPath;

    Win4Assert( 0 != pwszPath );

    if ( 0 == len )
        _len = wcslen( pwszPath );
    else
        _len = len;

    _iNext = _len;

    Win4Assert( wBackSlash != pwszPath[0] || _IsUNCName() );

    if ( _IsUNCName() )
    {
        _type = eUNC;
        _SkipUNC();
    }
    else if ( _IsDriveName() )
    {
        _type = eDrivePath;
        _SkipDrive();
    }
    else
    {
        _iNext = 0;
        _SkipToNext();
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     ~ctor of CPathParser - initializes the member variables.
//
//  Arguments:  [pwszPath] -
//              [len]      -
//
//  History:    2-11-96   srikants   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

CPathParser::CPathParser( WCHAR const * pwszPath, ULONG len  )
: _pwszPath(0),
  _pCurr(0),
  _type(eRelative)
{
    Init( pwszPath, len );
}

//+---------------------------------------------------------------------------
//
//  Member:     CPathParser::GetFileName
//
//  Synopsis:   Fetches the current "filename" component. Note that the full
//              path is NOT returned.
//
//  Arguments:  [wszBuf] -  Buffer to copy the current component into.
//              [cc]     -  On input, the max WCHARS in buffer. On output, the
//                          length of the string in WCHARS.
//
//  Returns:    TRUE if the buffer is sufficient. No data is copied to wszBuf.
//              FALSE if the buffer is too small. cc gives the number of
//              characters in the string.
//
//  History:    2-11-96   srikants   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

BOOL CPathParser::GetFileName( WCHAR * wszBuf, ULONG & cc ) const
{
    Win4Assert( _pCurr >= _pwszPath );
    Win4Assert( _iNext <= _len );

    ULONG len = _iNext - (ULONG)(_pCurr - _pwszPath);
    if ( cc <= len )
    {
        cc = len;
        return FALSE;
    }

    RtlCopyMemory( wszBuf, _pCurr, len*sizeof(WCHAR) );
    wszBuf[len] = 0;
    cc = len;
    return TRUE;
}

//+---------------------------------------------------------------------------
//
//  Member:     CPathParser::GetFilePath
//
//  Synopsis:   Same as GetFileName but returns the full path upto the current
//              component.
//
//  Arguments:  [wszBuf] -
//              [cc]     -
//
//  History:    2-11-96   srikants   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

BOOL CPathParser::GetFilePath( WCHAR * wszBuf, ULONG & cc ) const
{
    Win4Assert( _pCurr >= _pwszPath );
    Win4Assert( _iNext <= _len );

    ULONG len = _iNext;

    if ( cc <= len )
    {
        cc = len;
        return FALSE;
    }

    RtlCopyMemory( wszBuf, _pwszPath, len*sizeof(WCHAR) );
    wszBuf[len] = 0;
    cc = len;
    return TRUE;
}

//+---------------------------------------------------------------------------
//
//  Member:     CPathParser::Next
//
//  Synopsis:   Positions the iterator over the next component.
//
//  History:    2-11-96   srikants   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

void CPathParser::Next()
{
    Win4Assert( !IsLastComp() );
    _pCurr = _pwszPath + _iNext;
    _iNext++;
    _SkipToNext();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\ntciutil\params.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1998.
//
//  File:       params.cxx
//
//  Contents:   CCiRegParams class
//
//  History:    29-Jul-94   DwightKr    Created
//              14-Api-96   DwightKr    Added default Isapi catalog directory
//              11-Oct-96   dlee        collapsed kernel+user, added override
//
//--------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include <ciregkey.hxx>
#include <regacc.hxx>
#include <ciintf.h>
#include <cifrmcom.hxx>


const WCHAR * IS_DEFAULT_CATALOG_DIRECTORY = L"C:\\";


//+-------------------------------------------------------------------------
//
//  Member:     CCiRegParams::CCiRegParams, public
//
//  Synopsis:   Constructor for registry param object
//
//  Arguments:  [pwcName]    - 0 or name of the catalog from the registry
//
//  History:    12-Oct-96 dlee  Created
//
//--------------------------------------------------------------------------

CCiRegParams::CCiRegParams( const WCHAR * pwcName )
{
    _CheckNamedValues();

    SetDefault();

    // If a name isn't passed, then the catalog wasn't listed in the registry
    // to begin with, so we can't override the registry params.

    if ( 0 != pwcName )
    {
        _xOverrideName.Init( wcslen( pwcName ) + 1 );
        RtlCopyMemory( _xOverrideName.Get(),
                       pwcName,
                       _xOverrideName.SizeOf() );
    }

    Refresh( );
} //CCiRegParams

//+-------------------------------------------------------------------------
//
//  Member:     CCiRegParams::_OverrideForCatalog, private
//
//  Synopsis:   Overrides registry parameters with those for a given catalog
//
//  History:    12-Oct-96 dlee  Created
//
//--------------------------------------------------------------------------

void CCiRegParams::_OverrideForCatalog()
{
    // override values under ContentIndex with those for this catalog

    if ( 0 != _xOverrideName.Get() )
    {
        unsigned cwcNeeded = wcslen( wcsRegJustCatalogsSubKey );
        cwcNeeded += 2; // "\\" + null termination
        cwcNeeded += wcslen( _xOverrideName.Get() );

        XArray<WCHAR> xKey( cwcNeeded );
        wcscpy( xKey.Get(), wcsRegJustCatalogsSubKey );
        wcscat( xKey.Get(), L"\\" );
        wcscat( xKey.Get(), _xOverrideName.Get() );

        ciDebugOut(( DEB_ITRACE, "overriding for catalog key '%ws'\n",
                     xKey.Get() ));

        CRegAccess reg( RTL_REGISTRY_CONTROL, xKey.Get() );

        ciDebugOut(( DEB_ITRACE, "before: generate 0x%x, index w3 0x%x\n",
                     _maxCharacterization, _fIsIndexingW3Roots ));

        _ReadAndOverrideValues( reg );

        ciDebugOut(( DEB_ITRACE, "after: generate 0x%x, index w3 0x%x\n",
                     _maxCharacterization, _fIsIndexingW3Roots ));
    }
} //_OverrideForCatalog

//+-------------------------------------------------------------------------
//
//  Member:     CCiRegVars::SetDefault, public
//
//  Synopsis:   Sets default values for registry params
//
//  History:    12-Oct-96 dlee  Added header
//              04-Feb-98 kitmanh Added entry for _fIsReadOnly
//
//--------------------------------------------------------------------------

void CCiRegVars::SetDefault()
{
    _useOle = TRUE;
    _filterContents = FALSE;
    _filterDelayInterval = CI_FILTER_DELAY_INTERVAL_DEFAULT;
    _filterRemainingThreshold = CI_FILTER_REMAINING_THRESHOLD_DEFAULT;
    _maxFilesizeFiltered = CI_MAX_FILESIZE_FILTERED_DEFAULT;
    _masterMergeTime = CI_MASTER_MERGE_TIME_DEFAULT;
    _maxFilesizeMultiplier = CI_MAX_FILESIZE_MULTIPLIER_DEFAULT;
    _threadPriorityFilter = CI_THREAD_PRIORITY_FILTER_DEFAULT;
    _threadClassFilter = CI_THREAD_CLASS_FILTER_DEFAULT;
    _daemonResponseTimeout = CI_DAEMON_RESPONSE_TIMEOUT_DEFAULT;
    _maxCharacterization = CI_MAX_CHARACTERIZATION_DEFAULT;
    _fIsAutoAlias = CI_IS_AUTO_ALIAS_DEFAULT;
    _maxAutoAliasRefresh = CI_MAX_AUTO_ALIAS_REFRESH_DEFAULT;
    _fIsIndexingW3Roots = CI_IS_INDEXING_W3_ROOTS_DEFAULT;
    _fIsIndexingNNTPRoots = CI_IS_INDEXING_NNTP_ROOTS_DEFAULT;
    _fIsIndexingIMAPRoots = CI_IS_INDEXING_IMAP_ROOTS_DEFAULT;
    _fIsReadOnly = CI_IS_READ_ONLY_DEFAULT;              //default is "not" READ_ONLY
    _fIsEnumAllowed = CI_IS_ENUM_ALLOWED_DEFAULT ;
    _fFilterDirectories = CI_FILTER_DIRECTORIES_DEFAULT;
    _fFilterFilesWithUnknownExtensions = CI_FILTER_FILES_WITH_UNKNOWN_EXTENSIONS_DEFAULT;
    _fCatalogInactive = CI_CATALOG_INACTIVE_DEFAULT;
    _fForcePathAlias = CI_FORCE_PATH_ALIAS_DEFAULT;
    _maxPropertyStoreMappedCache = CI_PROPERTY_STORE_MAPPED_CACHE_DEFAULT;
    _maxPropertyStoreBackupSize = CI_PROPERTY_STORE_BACKUP_SIZE_DEFAULT;
    _maxSecPropertyStoreMappedCache = CI_PROPERTY_STORE_MAPPED_CACHE_DEFAULT;
    _maxSecPropertyStoreBackupSize = CI_PROPERTY_STORE_BACKUP_SIZE_DEFAULT;
    _forcedNetPathScanInterval = CI_FORCED_NETPATH_SCAN_DEFAULT;

    _maxMergeInterval = CI_MAX_MERGE_INTERVAL_DEFAULT;
    _threadPriorityMerge = CI_THREAD_PRIORITY_MERGE_DEFAULT;
    _maxUpdates = CI_MAX_UPDATES_DEFAULT;
    _maxWordlists = CI_MAX_WORDLISTS_DEFAULT;
    _minSizeMergeWordlist = CI_MIN_SIZE_MERGE_WORDLISTS_DEFAULT;
    _maxWordlistSize = CI_MAX_WORDLIST_SIZE_DEFAULT;
    _minWordlistMemory = CI_MIN_WORDLIST_MEMORY_DEFAULT;
    _maxWordlistIo = CI_MAX_WORDLIST_IO_DEFAULT;
    _maxWordlistIoDiskPerf = CI_MAX_WORDLIST_IO_DISKPERF_DEFAULT;
    _minWordlistBattery = CI_MIN_WORDLIST_BATTERY_DEFAULT;
    _ResourceCheckInterval = CI_WORDLIST_RESOURCE_CHECK_INTERVAL_DEFAULT;
    _maxFreshDeletes = CI_MAX_FRESH_DELETES_DEFAULT;
    _lowResourceSleep = CI_LOW_RESOURCE_SLEEP_DEFAULT;
    _maxWordlistMemoryLoad = CI_MAX_WORDLIST_MEMORY_LOAD_DEFAULT;
    _maxFreshCount = CI_MAX_FRESHCOUNT_DEFAULT;
    _maxQueueChunks = CI_MAX_QUEUE_CHUNKS_DEFAULT;
    _masterMergeCheckpointInterval = CI_MASTER_MERGE_CHECKPOINT_INTERVAL_DEFAULT;
    _filterBufferSize = CI_FILTER_BUFFER_SIZE_DEFAULT;
    _filterRetries = CI_FILTER_RETRIES_DEFAULT;
    _filterRetryInterval = CI_FILTER_RETRY_INTERVAL_DEFAULT;
    _maxShadowIndexSize = CI_MAX_SHADOW_INDEX_SIZE_DEFAULT;
    _minDiskFreeForceMerge = CI_MIN_DISKFREE_FORCE_MERGE_DEFAULT;
    _maxShadowFreeForceMerge = CI_MAX_SHADOW_FREE_FORCE_MERGE_DEFAULT;
    _maxIndexes = CI_MAX_INDEXES_DEFAULT;
    _maxIdealIndexes = CI_MAX_IDEAL_INDEXES_DEFAULT;
    _minMergeIdleTime = CI_MIN_MERGE_IDLE_TIME_DEFAULT;
    _maxPendingDocuments = CI_MAX_PENDING_DOCUMENTS_DEFAULT;
    _minIdleQueryThreads = CI_MIN_IDLE_QUERY_THREADS_DEFAULT;
    _maxActiveQueryThreads = CI_MAX_ACTIVE_QUERY_THREADS_DEFAULT;
    _maxQueryTimeslice = CI_MAX_QUERY_TIMESLICE_DEFAULT;
    _maxQueryExecutionTime = CI_MAX_QUERY_EXECUTION_TIME_DEFAULT;
    _maxRestrictionNodes = CI_MAX_RESTRICTION_NODES_DEFAULT;
    _minIdleRequestThreads = CI_MIN_IDLE_REQUEST_THREADS_DEFAULT;
    _minClientIdleTime     = CI_MIN_CLIENT_IDLE_TIME;
    _maxActiveRequestThreads = CI_MAX_ACTIVE_REQUEST_THREADS_DEFAULT;
    _maxSimultaneousRequests = CI_MAX_SIMULTANEOUS_REQUESTS_DEFAULT;
    _maxCachedPipes = CI_MAX_CACHED_PIPES_DEFAULT;
    _requestTimeout = CI_REQUEST_TIMEOUT_DEFAULT;
    _W3SvcInstance = CI_W3SVC_INSTANCE_DEFAULT;
    _NNTPSvcInstance = CI_NNTPSVC_INSTANCE_DEFAULT;
    _IMAPSvcInstance = CI_IMAPSVC_INSTANCE_DEFAULT;
    _fMinimizeWorkingSet = CI_MINIMIZE_WORKINGSET_DEFAULT;

    _evtLogFlags = CI_EVTLOG_FLAGS_DEFAULT;
    _miscCiFlags = CI_MISC_FLAGS_DEFAULT;
    _ciCatalogFlags = CI_FLAGS_DEFAULT;
    _maxUsnLogSize = CI_MAX_USN_LOG_SIZE_DEFAULT;
    _usnLogAllocationDelta = CI_USN_LOG_ALLOCATION_DELTA_DEFAULT;
    _ulScanBackoff = CI_SCAN_BACKOFF_DEFAULT;
    _ulStartupDelay = CI_STARTUP_DELAY_DEFAULT;
    _ulUsnReadTimeout = CI_USN_READ_TIMEOUT_DEFAULT;
    _ulUsnReadMinSize = CI_USN_READ_MIN_SIZE_DEFAULT;
    _fDelayUsnReadOnLowResource = CI_DELAY_USN_READ_ON_LOW_RESOURCE_DEFAULT;
    _maxDaemonVmUse = CI_MAX_DAEMON_VM_USE_DEFAULT;
    _secQFilterRetries = CI_SECQ_FILTER_RETRIES_DEFAULT;
    _ulStompLastAccessDelay = CI_STOMP_LAST_ACCESS_DELAY_DEFAULT;
    _WordlistUserIdle = CI_WORDLIST_USER_IDLE_DEFAULT;
    _minDiskSpaceToLeave = CI_MIN_DISK_SPACE_TO_LEAVE_DEFAULT;
} //SetDefault

//+-------------------------------------------------------------------------
//
//  Member:     CCiRegParams::_ReadAndOverrideValues, private
//
//  Synopsis:   Attempts to read values, with the default being the current
//              value.
//
//  History:    12-Oct-96 dlee  created
//              04-Feb-98 kitmanh  added entry for _fIsReadOnly
//
//--------------------------------------------------------------------------

void CCiRegParams::_ReadAndOverrideValues( CRegAccess & reg )
{
    CCiRegVars newVals;

    newVals._useOle                     = reg.Read(wcsUseOle, _useOle );
    newVals._filterContents             = reg.Read(wcsFilterContents, _filterContents );
    newVals._filterDelayInterval        = reg.Read(wcsFilterDelayInterval, _filterDelayInterval );
    newVals._filterRemainingThreshold   = reg.Read(wcsFilterRemainingThreshold, _filterRemainingThreshold );
    newVals._maxFilesizeFiltered        = reg.Read(wcsMaxFilesizeFiltered, (ULONG) _maxFilesizeFiltered);
    newVals._masterMergeTime            = reg.Read(wcsMasterMergeTime, _masterMergeTime );
    newVals._maxFilesizeMultiplier      = reg.Read(wcsMaxFilesizeMultiplier, _maxFilesizeMultiplier );
    newVals._threadClassFilter          = reg.Read(wcsThreadClassFilter, _threadClassFilter );
    newVals._threadPriorityFilter       = reg.Read(wcsThreadPriorityFilter, _threadPriorityFilter );
    newVals._daemonResponseTimeout      = reg.Read(wcsDaemonResponseTimeout, _daemonResponseTimeout );
    newVals._maxCharacterization        = reg.Read(wcsMaxCharacterization, _maxCharacterization );

    //
    // Allow old behavior.
    //

    ULONG ulgenerateCharacterization    = reg.Read(wcsGenerateCharacterization, GetGenerateCharacterization() ? 1 : 0 );

    if ( 0 == ulgenerateCharacterization )
        newVals._maxCharacterization = 0;

    newVals._fIsAutoAlias                  = reg.Read(wcsIsAutoAlias, _fIsAutoAlias );
    newVals._maxAutoAliasRefresh           = reg.Read(wcsMaxAutoAliasRefresh, _maxAutoAliasRefresh );
    newVals._fIsIndexingW3Roots            = reg.Read(wcsIsIndexingW3Roots, _fIsIndexingW3Roots );
    newVals._fIsIndexingNNTPRoots          = reg.Read(wcsIsIndexingNNTPRoots, _fIsIndexingNNTPRoots );
    newVals._fIsIndexingIMAPRoots          = reg.Read(wcsIsIndexingIMAPRoots, _fIsIndexingIMAPRoots );
    newVals._fIsReadOnly                   = reg.Read(wcsIsReadOnly, _fIsReadOnly );
    newVals._fIsEnumAllowed                = reg.Read(wcsIsEnumAllowed, _fIsEnumAllowed);
    newVals._fFilterDirectories            = reg.Read(wcsFilterDirectories, _fFilterDirectories );
    newVals._fFilterFilesWithUnknownExtensions = reg.Read(wcsFilterFilesWithUnknownExtensions, _fFilterFilesWithUnknownExtensions );
    newVals._fCatalogInactive              = reg.Read(wcsCatalogInactive, _fCatalogInactive );
    newVals._fForcePathAlias               = reg.Read(wcsForcePathAlias, _fForcePathAlias );
    newVals._maxPropertyStoreMappedCache   = reg.Read(wcsPrimaryStoreMappedCache, _maxPropertyStoreMappedCache );
    newVals._maxPropertyStoreBackupSize    = reg.Read(wcsPrimaryStoreBackupSize, _maxPropertyStoreBackupSize);
    newVals._maxSecPropertyStoreMappedCache= reg.Read(wcsSecondaryStoreMappedCache, _maxSecPropertyStoreMappedCache );
    newVals._maxSecPropertyStoreBackupSize = reg.Read(wcsSecondaryStoreBackupSize, _maxSecPropertyStoreBackupSize);
    newVals._forcedNetPathScanInterval     = reg.Read(wcsForcedNetPathScanInterval, _forcedNetPathScanInterval );

    newVals._maxMergeInterval      = reg.Read(wcsMaxMergeInterval, _maxMergeInterval );
    newVals._threadPriorityMerge   = reg.Read(wcsThreadPriorityMerge, _threadPriorityMerge );
    newVals._maxUpdates            = reg.Read(wcsMaxUpdates, _maxUpdates );
    newVals._maxWordlists          = reg.Read(wcsMaxWordLists, _maxWordlists );
    newVals._minSizeMergeWordlist  = reg.Read(wcsMinSizeMergeWordlists, _minSizeMergeWordlist );
    newVals._maxWordlistSize       = reg.Read(wcsMaxWordlistSize, _maxWordlistSize );
    newVals._minWordlistMemory     = reg.Read(wcsMinWordlistMemory, _minWordlistMemory );
    newVals._maxWordlistIo         = reg.Read(wcsMaxWordlistIo, _maxWordlistIo );
    newVals._maxWordlistIoDiskPerf = reg.Read(wcsMaxWordlistIoDiskPerf, _maxWordlistIoDiskPerf );
    newVals._minWordlistBattery    = reg.Read(wcsMinWordlistBattery, _minWordlistBattery );
    newVals._ResourceCheckInterval = reg.Read(wcsResourceCheckInterval, _ResourceCheckInterval );
    newVals._maxFreshDeletes       = reg.Read(wcsMaxFreshDeletes, _maxFreshDeletes );
    newVals._lowResourceSleep      = reg.Read(wcsLowResourceSleep, _lowResourceSleep );
    newVals._maxWordlistMemoryLoad = reg.Read(wcsMaxWordlistMemoryLoad, _maxWordlistMemoryLoad );
    newVals._maxFreshCount         = reg.Read(wcsMaxFreshCount, _maxFreshCount );
    newVals._maxQueueChunks        = reg.Read(wcsMaxQueueChunks, _maxQueueChunks );
    newVals._masterMergeCheckpointInterval = reg.Read(wcsMasterMergeCheckpointInterval, _masterMergeCheckpointInterval );
    newVals._filterBufferSize      = reg.Read(wcsFilterBufferSize, _filterBufferSize );
    newVals._filterRetries         = reg.Read(wcsFilterRetries, _filterRetries );
    newVals._filterRetryInterval   = reg.Read(wcsFilterRetryInterval, _filterRetryInterval );
    newVals._maxShadowIndexSize    = reg.Read(wcsMaxShadowIndexSize, _maxShadowIndexSize );
    newVals._minDiskFreeForceMerge = reg.Read(wcsMinDiskFreeForceMerge, _minDiskFreeForceMerge );
    newVals._maxShadowFreeForceMerge = reg.Read(wcsMaxShadowFreeForceMerge, _maxShadowFreeForceMerge );
    newVals._maxIndexes            = reg.Read(wcsMaxIndexes, _maxIndexes );
    newVals._maxIdealIndexes       = reg.Read(wcsMaxIdealIndexes, _maxIdealIndexes );
    newVals._minMergeIdleTime      = reg.Read(wcsMinMergeIdleTime, _minMergeIdleTime );
    newVals._maxPendingDocuments   = reg.Read(wcsMaxPendingDocuments, _maxPendingDocuments );
    newVals._minIdleQueryThreads   = reg.Read(wcsMinIdleQueryThreads, _minIdleQueryThreads );
    newVals._maxActiveQueryThreads = reg.Read(wcsMaxActiveQueryThreads, _maxActiveQueryThreads );
    newVals._maxQueryTimeslice     = reg.Read(wcsMaxQueryTimeslice, _maxQueryTimeslice );
    newVals._maxQueryExecutionTime = reg.Read(wcsMaxQueryExecutionTime, _maxQueryExecutionTime );
    newVals._minIdleRequestThreads = reg.Read(wcsMinIdleRequestThreads, _minIdleRequestThreads );
    newVals._minClientIdleTime     = reg.Read(wcsMinClientIdleTime, _minClientIdleTime );
    newVals._maxActiveRequestThreads = reg.Read(wcsMaxActiveRequestThreads, _maxActiveRequestThreads );
    newVals._maxSimultaneousRequests = reg.Read(wcsMaxSimultaneousRequests, _maxSimultaneousRequests );
    newVals._maxCachedPipes        = reg.Read(wcsMaxCachedPipes, _maxCachedPipes );
    newVals._WordlistUserIdle      = reg.Read(wcsWordlistUserIdle, _WordlistUserIdle );
    newVals._requestTimeout = reg.Read(wcsRequestTimeout, _requestTimeout );
    newVals._W3SvcInstance = reg.Read(wcsW3SvcInstance, _W3SvcInstance );
    newVals._NNTPSvcInstance = reg.Read(wcsNNTPSvcInstance, _NNTPSvcInstance );
    newVals._IMAPSvcInstance = reg.Read(wcsIMAPSvcInstance, _IMAPSvcInstance );
    newVals._fMinimizeWorkingSet = reg.Read(wcsMinimizeWorkingSet, _fMinimizeWorkingSet );

    newVals._evtLogFlags           = reg.Read(wcsEventLogFlags, _evtLogFlags );
    newVals._miscCiFlags           = reg.Read(wcsMiscFlags, _miscCiFlags );
    newVals._ciCatalogFlags        = reg.Read(wcsCiCatalogFlags, _ciCatalogFlags );

    newVals._maxRestrictionNodes = reg.Read(wcsMaxRestrictionNodes, _maxRestrictionNodes );
    newVals._maxUsnLogSize  = reg.Read( wcsMaxUsnLogSize, _maxUsnLogSize );
    newVals._usnLogAllocationDelta = reg.Read( wcsUsnLogAllocationDelta, _usnLogAllocationDelta );
    newVals._ulScanBackoff         = reg.Read( wcsScanBackoff, _ulScanBackoff );
    newVals._ulStartupDelay        = reg.Read( wcsStartupDelay, _ulStartupDelay );
    newVals._ulUsnReadTimeout      = reg.Read( wcsUsnReadTimeout, _ulUsnReadTimeout );
    newVals._ulUsnReadMinSize      = reg.Read( wcsUsnReadMinSize, _ulUsnReadMinSize );
    newVals._fDelayUsnReadOnLowResource = reg.Read( wcsDelayUsnReadOnLowResource, _fDelayUsnReadOnLowResource );
    newVals._maxDaemonVmUse        = reg.Read( wcsMaxDaemonVmUse, _maxDaemonVmUse );
    newVals._secQFilterRetries     = reg.Read(wcsSecQFilterRetries, _secQFilterRetries );
    newVals._ulStompLastAccessDelay = reg.Read(wcsStompLastAccessDelay, _ulStompLastAccessDelay );

    newVals._minDiskSpaceToLeave    = reg.Read( wcsMinDiskSpaceToLeave, _minDiskSpaceToLeave );

    _StoreNewValues( newVals );
} //_ReadAndOverrideValues

//+-------------------------------------------------------------------------
//
//  Member:     CCiRegParams::_ReadValues, private
//
//  Synopsis:   Reads values for variables
//
//  History:    12-Oct-96 dlee  Added header
//              04-Feb-98 kitmanh Added entry for _fIsReadOnly
//
//--------------------------------------------------------------------------

void CCiRegParams::_ReadValues(
    CRegAccess & reg,
    CCiRegVars & vars )
{
    vars._useOle                     = reg.Read(wcsUseOle, (ULONG) FALSE);
    vars._filterContents             = reg.Read(wcsFilterContents, (ULONG) TRUE );
    vars._filterDelayInterval        = reg.Read(wcsFilterDelayInterval, CI_FILTER_DELAY_INTERVAL_DEFAULT);
    vars._filterRemainingThreshold   = reg.Read(wcsFilterRemainingThreshold, CI_FILTER_REMAINING_THRESHOLD_DEFAULT);
    vars._maxFilesizeFiltered        = reg.Read(wcsMaxFilesizeFiltered, CI_MAX_FILESIZE_FILTERED_DEFAULT );
    vars._masterMergeTime            = reg.Read(wcsMasterMergeTime, CI_MASTER_MERGE_TIME_DEFAULT);
    vars._maxFilesizeMultiplier      = reg.Read(wcsMaxFilesizeMultiplier, CI_MAX_FILESIZE_MULTIPLIER_DEFAULT);
    vars._threadClassFilter          = reg.Read(wcsThreadClassFilter, CI_THREAD_CLASS_FILTER_DEFAULT);
    vars._threadPriorityFilter       = reg.Read(wcsThreadPriorityFilter, CI_THREAD_PRIORITY_FILTER_DEFAULT);
    vars._daemonResponseTimeout      = reg.Read(wcsDaemonResponseTimeout, CI_DAEMON_RESPONSE_TIMEOUT_DEFAULT );
    vars._maxCharacterization        = reg.Read(wcsMaxCharacterization, CI_MAX_CHARACTERIZATION_DEFAULT );

    //
    // Allow old behavior.
    //

    ULONG ulgenerateCharacterization = reg.Read(wcsGenerateCharacterization, 1 );

    if ( 0 == ulgenerateCharacterization )
        vars._maxCharacterization = 0;

    vars._fIsAutoAlias                  = reg.Read(wcsIsAutoAlias, CI_IS_AUTO_ALIAS_DEFAULT );
    vars._maxAutoAliasRefresh           = reg.Read(wcsMaxAutoAliasRefresh, CI_MAX_AUTO_ALIAS_REFRESH_DEFAULT );
    vars._fIsIndexingW3Roots            = reg.Read(wcsIsIndexingW3Roots, CI_IS_INDEXING_W3_ROOTS_DEFAULT );
    vars._fIsIndexingNNTPRoots          = reg.Read(wcsIsIndexingNNTPRoots, CI_IS_INDEXING_NNTP_ROOTS_DEFAULT );
    vars._fIsIndexingIMAPRoots          = reg.Read(wcsIsIndexingIMAPRoots, CI_IS_INDEXING_IMAP_ROOTS_DEFAULT );
    vars._fIsReadOnly                   = reg.Read(wcsIsReadOnly, (DWORD)CI_IS_READ_ONLY_DEFAULT );
    vars._fIsEnumAllowed                = reg.Read(wcsIsEnumAllowed, (ULONG)CI_IS_ENUM_ALLOWED_DEFAULT);
    vars._fFilterDirectories            = reg.Read(wcsFilterDirectories, CI_FILTER_DIRECTORIES_DEFAULT);
    vars._fFilterFilesWithUnknownExtensions = reg.Read(wcsFilterFilesWithUnknownExtensions, CI_FILTER_FILES_WITH_UNKNOWN_EXTENSIONS_DEFAULT );
    vars._fCatalogInactive              = reg.Read(wcsCatalogInactive, CI_CATALOG_INACTIVE_DEFAULT );
    vars._fForcePathAlias               = reg.Read(wcsForcePathAlias, CI_FORCE_PATH_ALIAS_DEFAULT );
    vars._maxPropertyStoreMappedCache   = reg.Read(wcsPrimaryStoreMappedCache, CI_PROPERTY_STORE_MAPPED_CACHE_DEFAULT);
    vars._maxPropertyStoreBackupSize    = reg.Read(wcsPrimaryStoreBackupSize, CI_PROPERTY_STORE_BACKUP_SIZE_DEFAULT);
    vars._maxSecPropertyStoreMappedCache= reg.Read(wcsSecondaryStoreMappedCache, CI_PROPERTY_STORE_MAPPED_CACHE_DEFAULT);
    vars._maxSecPropertyStoreBackupSize = reg.Read(wcsSecondaryStoreBackupSize, CI_PROPERTY_STORE_BACKUP_SIZE_DEFAULT);
    vars._forcedNetPathScanInterval     = reg.Read(wcsForcedNetPathScanInterval, CI_FORCED_NETPATH_SCAN_DEFAULT );

    vars._maxMergeInterval      = reg.Read(wcsMaxMergeInterval, CI_MAX_MERGE_INTERVAL_DEFAULT);
    vars._threadPriorityMerge   = reg.Read(wcsThreadPriorityMerge, CI_THREAD_PRIORITY_MERGE_DEFAULT);
    vars._maxUpdates            = reg.Read(wcsMaxUpdates, CI_MAX_UPDATES_DEFAULT);
    vars._maxWordlists          = reg.Read(wcsMaxWordLists, CI_MAX_WORDLISTS_DEFAULT);
    vars._minSizeMergeWordlist  = reg.Read(wcsMinSizeMergeWordlists, CI_MIN_SIZE_MERGE_WORDLISTS_DEFAULT);
    vars._maxWordlistSize       = reg.Read(wcsMaxWordlistSize, CI_MAX_WORDLIST_SIZE_DEFAULT);
    vars._minWordlistMemory     = reg.Read(wcsMinWordlistMemory, CI_MIN_WORDLIST_MEMORY_DEFAULT);
    vars._maxWordlistIo         = reg.Read(wcsMaxWordlistIo, CI_MAX_WORDLIST_IO_DEFAULT );
    vars._maxWordlistIoDiskPerf = reg.Read(wcsMaxWordlistIoDiskPerf, CI_MAX_WORDLIST_IO_DISKPERF_DEFAULT );
    vars._minWordlistBattery    = reg.Read(wcsMinWordlistBattery, CI_MIN_WORDLIST_BATTERY_DEFAULT );
    vars._ResourceCheckInterval = reg.Read(wcsResourceCheckInterval, CI_WORDLIST_RESOURCE_CHECK_INTERVAL_DEFAULT );
    vars._maxFreshDeletes       = reg.Read(wcsMaxFreshDeletes, CI_MAX_FRESH_DELETES_DEFAULT );
    vars._lowResourceSleep      = reg.Read(wcsLowResourceSleep, CI_LOW_RESOURCE_SLEEP_DEFAULT);
    vars._maxWordlistMemoryLoad = reg.Read(wcsMaxWordlistMemoryLoad, CI_MAX_WORDLIST_MEMORY_LOAD_DEFAULT);
    vars._maxFreshCount         = reg.Read(wcsMaxFreshCount, CI_MAX_FRESHCOUNT_DEFAULT);
    vars._maxQueueChunks        = reg.Read(wcsMaxQueueChunks, CI_MAX_QUEUE_CHUNKS_DEFAULT);
    vars._masterMergeCheckpointInterval = reg.Read(wcsMasterMergeCheckpointInterval, CI_MASTER_MERGE_CHECKPOINT_INTERVAL_DEFAULT);
    vars._filterBufferSize      = reg.Read(wcsFilterBufferSize, CI_FILTER_BUFFER_SIZE_DEFAULT);
    vars._filterRetries         = reg.Read(wcsFilterRetries, CI_FILTER_RETRIES_DEFAULT);
    vars._filterRetryInterval   = reg.Read(wcsFilterRetryInterval, CI_FILTER_RETRY_INTERVAL_DEFAULT);
    vars._maxShadowIndexSize    = reg.Read(wcsMaxShadowIndexSize, CI_MAX_SHADOW_INDEX_SIZE_DEFAULT);
    vars._minDiskFreeForceMerge = reg.Read(wcsMinDiskFreeForceMerge, CI_MIN_DISKFREE_FORCE_MERGE_DEFAULT);
    vars._maxShadowFreeForceMerge = reg.Read(wcsMaxShadowFreeForceMerge, CI_MAX_SHADOW_FREE_FORCE_MERGE_DEFAULT);
    vars._maxIndexes            = reg.Read(wcsMaxIndexes, CI_MAX_INDEXES_DEFAULT);
    vars._maxIdealIndexes       = reg.Read(wcsMaxIdealIndexes, CI_MAX_IDEAL_INDEXES_DEFAULT);
    vars._minMergeIdleTime      = reg.Read(wcsMinMergeIdleTime, CI_MIN_MERGE_IDLE_TIME_DEFAULT);
    vars._maxPendingDocuments   = reg.Read(wcsMaxPendingDocuments, CI_MAX_PENDING_DOCUMENTS_DEFAULT);
    vars._minIdleQueryThreads   = reg.Read(wcsMinIdleQueryThreads, CI_MIN_IDLE_QUERY_THREADS_DEFAULT);
    vars._maxActiveQueryThreads = reg.Read(wcsMaxActiveQueryThreads, CI_MAX_ACTIVE_QUERY_THREADS_DEFAULT);
    vars._maxQueryTimeslice     = reg.Read(wcsMaxQueryTimeslice, CI_MAX_QUERY_TIMESLICE_DEFAULT);
    vars._maxQueryExecutionTime = reg.Read(wcsMaxQueryExecutionTime, CI_MAX_QUERY_EXECUTION_TIME_DEFAULT);
    vars._minIdleRequestThreads   = reg.Read(wcsMinIdleRequestThreads, CI_MIN_IDLE_REQUEST_THREADS_DEFAULT);
    vars._maxActiveRequestThreads = reg.Read(wcsMaxActiveRequestThreads, CI_MAX_ACTIVE_REQUEST_THREADS_DEFAULT);
    vars._maxSimultaneousRequests = reg.Read(wcsMaxSimultaneousRequests, CI_MAX_SIMULTANEOUS_REQUESTS_DEFAULT);
    vars._maxCachedPipes          = reg.Read(wcsMaxCachedPipes, CI_MAX_CACHED_PIPES_DEFAULT);
    vars._requestTimeout = reg.Read(wcsRequestTimeout, CI_REQUEST_TIMEOUT_DEFAULT);
    vars._W3SvcInstance = reg.Read(wcsW3SvcInstance, CI_W3SVC_INSTANCE_DEFAULT );
    vars._NNTPSvcInstance = reg.Read(wcsNNTPSvcInstance, CI_NNTPSVC_INSTANCE_DEFAULT );
    vars._IMAPSvcInstance = reg.Read(wcsIMAPSvcInstance, CI_IMAPSVC_INSTANCE_DEFAULT );
    vars._fMinimizeWorkingSet = reg.Read(wcsMinimizeWorkingSet, (DWORD)CI_MINIMIZE_WORKINGSET_DEFAULT );

    vars._evtLogFlags           = reg.Read(wcsEventLogFlags, CI_EVTLOG_FLAGS_DEFAULT);
    vars._miscCiFlags           = reg.Read(wcsMiscFlags, CI_MISC_FLAGS_DEFAULT);
    vars._ciCatalogFlags        = reg.Read(wcsCiCatalogFlags, CI_FLAGS_DEFAULT);
    vars._maxUsnLogSize         = reg.Read( wcsMaxUsnLogSize, CI_MAX_USN_LOG_SIZE_DEFAULT );
    vars._usnLogAllocationDelta = reg.Read( wcsUsnLogAllocationDelta, CI_USN_LOG_ALLOCATION_DELTA_DEFAULT );
    vars._ulScanBackoff         = reg.Read( wcsScanBackoff, CI_SCAN_BACKOFF_DEFAULT );
    vars._ulStartupDelay        = reg.Read( wcsStartupDelay, CI_STARTUP_DELAY_DEFAULT );
    vars._ulUsnReadTimeout      = reg.Read( wcsUsnReadTimeout, CI_USN_READ_TIMEOUT_DEFAULT );
    vars._ulUsnReadMinSize      = reg.Read( wcsUsnReadMinSize, CI_USN_READ_MIN_SIZE_DEFAULT );
    vars._fDelayUsnReadOnLowResource = reg.Read( wcsDelayUsnReadOnLowResource, CI_DELAY_USN_READ_ON_LOW_RESOURCE_DEFAULT );
    vars._maxDaemonVmUse        = reg.Read( wcsMaxDaemonVmUse, CI_MAX_DAEMON_VM_USE_DEFAULT );
    vars._secQFilterRetries     = reg.Read(wcsSecQFilterRetries, CI_SECQ_FILTER_RETRIES_DEFAULT);

    vars._maxRestrictionNodes = reg.Read(wcsMaxRestrictionNodes, CI_MAX_RESTRICTION_NODES_DEFAULT );
    vars._ulStompLastAccessDelay = reg.Read(wcsStompLastAccessDelay, CI_STOMP_LAST_ACCESS_DELAY_DEFAULT );

    vars._WordlistUserIdle    = reg.Read(wcsWordlistUserIdle, CI_WORDLIST_USER_IDLE_DEFAULT );
    vars._minDiskSpaceToLeave   = reg.Read( wcsMinDiskSpaceToLeave, CI_MIN_DISK_SPACE_TO_LEAVE_DEFAULT );

    #if DBG == 1 || CIDBG == 1
        ULONG ulLevel = reg.Read( wcsWin4AssertLevel, 0xFFFFFFFF );
        if (ulLevel != 0xFFFFFFFF )
            SetWin4AssertLevel( ulLevel );
    #endif // DBG == 1 || CIDBG == 1
} //_ReadValues

//+-------------------------------------------------------------------------
//
//  Member:     CCiRegParams::_StoreCIValues, private
//
//  Synopsis:   Packs all CI parameters in an array of CStorageVariants,
//              and sets CI by invoking ICiAdminParams::SetValues()
//
//  History:    1-24-97         mohamedn        created
//
//  Notes:
//
//--------------------------------------------------------------------------

void CCiRegParams::_StoreCIValues(CCiRegVars & vars, ICiAdminParams * pICiAdminParams )
{

    if ( pICiAdminParams )
    {

        CStorageVariant       aParamVals[CI_AP_MAX_VAL];

        aParamVals[CI_AP_MERGE_INTERVAL]                =  vars._maxMergeInterval;
        aParamVals[CI_AP_MAX_UPDATES]                   =  vars._maxUpdates;
        aParamVals[CI_AP_MAX_WORDLISTS]                 =  vars._maxWordlists;
        aParamVals[CI_AP_MIN_SIZE_MERGE_WORDLISTS]      =  vars._minSizeMergeWordlist;

        aParamVals[CI_AP_MAX_WORDLIST_SIZE]             =  vars._maxWordlistSize;
        aParamVals[CI_AP_MIN_WORDLIST_MEMORY]           =  vars._minWordlistMemory;
        aParamVals[CI_AP_LOW_RESOURCE_SLEEP]            =  vars._lowResourceSleep;
        aParamVals[CI_AP_MAX_WORDLIST_MEMORY_LOAD]      =  vars._maxWordlistMemoryLoad;
        aParamVals[CI_AP_MAX_WORDLIST_IO]               =  vars._maxWordlistIo;
        aParamVals[CI_AP_WORDLIST_RESOURCE_CHECK_INTERVAL] =  vars._ResourceCheckInterval;
        aParamVals[CI_AP_STARTUP_DELAY]                 =   vars._ulStartupDelay;

        // Note: we don't really use this -- it's just for Olympus.
        // It's always TRUE for CI (even though if the size is 0 they
        // won't be generated.

        aParamVals[CI_AP_GENERATE_CHARACTERIZATION]     =   CI_GENERATE_CHARACTERIZATION_DEFAULT;

        aParamVals[CI_AP_MAX_FRESH_COUNT]               =  vars._maxFreshCount;
        aParamVals[CI_AP_MAX_SHADOW_INDEX_SIZE]         =  vars._maxShadowIndexSize;
        aParamVals[CI_AP_MIN_DISK_FREE_FORCE_MERGE]     =  vars._minDiskFreeForceMerge;
        aParamVals[CI_AP_MAX_SHADOW_FREE_FORCE_MERGE]   =  vars._maxShadowFreeForceMerge;

        aParamVals[CI_AP_MAX_INDEXES]                   =  vars._maxIndexes;
        aParamVals[CI_AP_MAX_IDEAL_INDEXES]             =  vars._maxIdealIndexes;
        aParamVals[CI_AP_MIN_MERGE_IDLE_TIME]           =  vars._minMergeIdleTime;
        aParamVals[CI_AP_MAX_PENDING_DOCUMENTS]         =  vars._maxPendingDocuments;

        aParamVals[CI_AP_MASTER_MERGE_TIME]             =  vars._masterMergeTime;
        aParamVals[CI_AP_MAX_QUEUE_CHUNKS]              =  vars._maxQueueChunks;
        aParamVals[CI_AP_MASTER_MERGE_CHECKPOINT_INTERVAL] =   vars._masterMergeCheckpointInterval;
        aParamVals[CI_AP_FILTER_BUFFER_SIZE]            =  vars._filterBufferSize;

        aParamVals[CI_AP_FILTER_RETRIES]                =  vars._filterRetries;
        aParamVals[CI_AP_FILTER_RETRY_INTERVAL]         =  vars._filterRetryInterval;
        aParamVals[CI_AP_MIN_IDLE_QUERY_THREADS]        =  vars._minIdleQueryThreads;
        aParamVals[CI_AP_MAX_ACTIVE_QUERY_THREADS]      =  vars._maxActiveQueryThreads;

        aParamVals[CI_AP_MAX_QUERY_TIMESLICE]           =  vars._maxQueryTimeslice;
        aParamVals[CI_AP_MAX_QUERY_EXECUTION_TIME]      =  vars._maxQueryExecutionTime;
        aParamVals[CI_AP_MAX_RESTRICTION_NODES]         =  vars._maxRestrictionNodes;
        aParamVals[CI_AP_CLUSTERINGTIME]                =  (ULONG)0; // not supported yet.

        aParamVals[CI_AP_MAX_FILESIZE_MULTIPLIER]       =   vars._maxFilesizeMultiplier;
        aParamVals[CI_AP_DAEMON_RESPONSE_TIMEOUT]       =   vars._daemonResponseTimeout;
        aParamVals[CI_AP_FILTER_DELAY_INTERVAL]         =   vars._filterDelayInterval;
        aParamVals[CI_AP_FILTER_REMAINING_THRESHOLD]    =   vars._filterRemainingThreshold;

        aParamVals[CI_AP_MAX_CHARACTERIZATION]          =   vars._maxCharacterization;
        aParamVals[CI_AP_MIN_WORDLIST_BATTERY]          =   vars._minWordlistBattery;
        aParamVals[CI_AP_THREAD_PRIORITY_MERGE]         =   (ULONG)vars._threadPriorityMerge;
        aParamVals[CI_AP_THREAD_PRIORITY_FILTER]        =   (ULONG)vars._threadPriorityFilter;

        aParamVals[CI_AP_THREAD_CLASS_FILTER]           =   (ULONG)vars._threadClassFilter;
        aParamVals[CI_AP_EVTLOG_FLAGS]                  =   vars._evtLogFlags;
        aParamVals[CI_AP_MISC_FLAGS]                    =   vars._miscCiFlags;
        aParamVals[CI_AP_GENERATE_RELEVANT_WORDS]       =   (ULONG)0; // not supported yet.

        aParamVals[CI_AP_FFILTER_FILES_WITH_UNKNOWN_EXTENSIONS]  = (ULONG)vars._fFilterFilesWithUnknownExtensions;
        aParamVals[CI_AP_FILTER_DIRECTORIES]            =   (ULONG)vars._fFilterDirectories;
        aParamVals[CI_AP_FILTER_CONTENTS]               =   (ULONG)vars._filterContents;
        aParamVals[CI_AP_MAX_FILESIZE_FILTERED]         =   (ULONG)vars._maxFilesizeFiltered;

        aParamVals[CI_AP_MAX_FRESH_DELETES]             =   vars._maxFreshDeletes;
        aParamVals[CI_AP_MIN_CLIENT_IDLE_TIME]          =   vars._minClientIdleTime;
        aParamVals[CI_AP_MAX_DAEMON_VM_USE]             =   vars._maxDaemonVmUse;
        aParamVals[CI_AP_SECQ_FILTER_RETRIES]           =   vars._secQFilterRetries;
        aParamVals[CI_AP_WORDLIST_USER_IDLE]            =   vars._WordlistUserIdle;
        aParamVals[CI_AP_IS_ENUM_ALLOWED]               =   (ULONG)vars._fIsEnumAllowed;
        aParamVals[CI_AP_MIN_DISK_SPACE_TO_LEAVE]       =   vars._minDiskSpaceToLeave;

        aParamVals[CI_AP_MAX_DWORD_VAL]                 =   (ULONG)0; // place holder to mark end of values that fit in DWORD.

        #if CIDBG == 1

            for ( int i = 0; i < CI_AP_MAX_VAL; i++ )
                Win4Assert( VT_EMPTY != aParamVals[i].Type() );

        #endif // CIDBG == 1

        // both aParamVal and _aParamNames arrays have the same size - CI_AP_MAX_VAL in this case.

        SCODE sc = pICiAdminParams->SetValues( CI_AP_MAX_VAL , aParamVals, _aParamNames );

        if (sc != S_OK)
        {
            ciDebugOut(( DEB_ERROR,"pICiAdminParams->SetValues() failed: %x",sc));
        }
    }

}       //_StoreCIValues



//+-------------------------------------------------------------------------
//
//  Member:     CCiRegVars::_StoreNewValues, private
//
//  Synopsis:   Transfers range-checked values
//
//  History:    12-Oct-96 dlee  Added header
//              04-Feb-98 kitmanh  Added entry for _fIsReadOnly
//
//--------------------------------------------------------------------------

void CCiRegParams::_StoreNewValues(CCiRegVars & vars )
{

    InterlockedExchange( (long *) &_useOle, vars._useOle != 0 );
    InterlockedExchange( (long *) &_filterContents, vars._filterContents != 0 );
    InterlockedExchange( (long *) &_filterDelayInterval, Range( vars._filterDelayInterval, CI_FILTER_DELAY_INTERVAL_MIN, CI_FILTER_DELAY_INTERVAL_MAX ) );
    InterlockedExchange( (long *) &_filterRemainingThreshold, Range( vars._filterRemainingThreshold, CI_FILTER_REMAINING_THRESHOLD_MIN, CI_FILTER_REMAINING_THRESHOLD_MAX ) );
    InterlockedExchange( (long *) &_maxFilesizeFiltered, vars._maxFilesizeFiltered );
    InterlockedExchange( (long *) &_masterMergeTime, Range( vars._masterMergeTime, CI_MASTER_MERGE_TIME_MIN, CI_MASTER_MERGE_TIME_MAX ) );
    InterlockedExchange( (long *) &_maxFilesizeMultiplier, Range( vars._maxFilesizeMultiplier, CI_MAX_FILESIZE_MULTIPLIER_MIN, CI_MAX_FILESIZE_MULTIPLIER_MAX ) );
    InterlockedExchange( (long *) &_threadClassFilter, Range( vars._threadClassFilter, CI_THREAD_CLASS_FILTER_MIN, CI_THREAD_CLASS_FILTER_MAX ) );
    InterlockedExchange( (long *) &_threadPriorityFilter, Range( vars._threadPriorityFilter, THREAD_BASE_PRIORITY_MIN, THREAD_BASE_PRIORITY_MAX ) );
    InterlockedExchange( (long *) &_daemonResponseTimeout, Range( vars._daemonResponseTimeout, CI_DAEMON_RESPONSE_TIMEOUT_MIN, CI_DAEMON_RESPONSE_TIMEOUT_MAX ) );
    InterlockedExchange( (long *) &_maxCharacterization, Range( vars._maxCharacterization, CI_MAX_CHARACTERIZATION_MIN, CI_MAX_CHARACTERIZATION_MAX ) );
    InterlockedExchange( (long *) &_fIsAutoAlias, vars._fIsAutoAlias != 0 );
    InterlockedExchange( (long *) &_maxAutoAliasRefresh, Range( vars._maxAutoAliasRefresh, CI_MAX_AUTO_ALIAS_REFRESH_MIN, CI_MAX_AUTO_ALIAS_REFRESH_MAX ) );
    InterlockedExchange( (long *) &_fIsIndexingW3Roots, vars._fIsIndexingW3Roots != 0 );
    InterlockedExchange( (long *) &_fIsIndexingNNTPRoots, vars._fIsIndexingNNTPRoots != 0 );
    InterlockedExchange( (long *) &_fIsIndexingIMAPRoots, vars._fIsIndexingIMAPRoots != 0 );
    InterlockedExchange( (long *) &_fIsReadOnly, vars._fIsReadOnly != 0 );
    InterlockedExchange( (long *) &_fIsEnumAllowed, vars._fIsEnumAllowed != 0 );
    InterlockedExchange( (long *) &_fFilterDirectories, vars._fFilterDirectories != 0 );
    InterlockedExchange( (long *) &_fFilterFilesWithUnknownExtensions, vars._fFilterFilesWithUnknownExtensions != 0 );
    InterlockedExchange( (long *) &_fCatalogInactive, vars._fCatalogInactive != 0 );
    InterlockedExchange( (long *) &_fForcePathAlias, vars._fForcePathAlias != 0 );
    InterlockedExchange( (long *) &_maxPropertyStoreMappedCache, Range( vars._maxPropertyStoreMappedCache, CI_PROPERTY_STORE_MAPPED_CACHE_MIN, CI_PROPERTY_STORE_MAPPED_CACHE_MAX ) );
    InterlockedExchange( (long *) &_maxPropertyStoreBackupSize, Range( vars._maxPropertyStoreBackupSize, CI_PROPERTY_STORE_BACKUP_SIZE_MIN, CI_PROPERTY_STORE_BACKUP_SIZE_MAX ) );
    InterlockedExchange( (long *) &_maxSecPropertyStoreMappedCache, Range( vars._maxSecPropertyStoreMappedCache, CI_PROPERTY_STORE_MAPPED_CACHE_MIN, CI_PROPERTY_STORE_MAPPED_CACHE_MAX ) );
    InterlockedExchange( (long *) &_maxSecPropertyStoreBackupSize, Range( vars._maxSecPropertyStoreBackupSize, CI_PROPERTY_STORE_BACKUP_SIZE_MIN, CI_PROPERTY_STORE_BACKUP_SIZE_MAX ) );
    InterlockedExchange( (long *) &_forcedNetPathScanInterval, Range( vars._forcedNetPathScanInterval, CI_FORCED_NETPATH_SCAN_MIN, CI_FORCED_NETPATH_SCAN_MAX ) );

    InterlockedExchange( (long *) &_maxMergeInterval, Range( vars._maxMergeInterval, CI_MAX_MERGE_INTERVAL_MIN, CI_MAX_MERGE_INTERVAL_MAX ) );
    InterlockedExchange( (long *) &_threadPriorityMerge, Range( vars._threadPriorityMerge,  THREAD_BASE_PRIORITY_MIN, THREAD_BASE_PRIORITY_MAX ) );
    InterlockedExchange( (long *) &_maxUpdates, Range( vars._maxUpdates, CI_MAX_UPDATES_MIN, CI_MAX_UPDATES_MAX ) );
    InterlockedExchange( (long *) &_maxWordlists, Range( vars._maxWordlists, CI_MAX_WORDLISTS_MIN, CI_MAX_WORDLISTS_MAX ) );
    InterlockedExchange( (long *) &_minSizeMergeWordlist, Range( vars._minSizeMergeWordlist, CI_MIN_SIZE_MERGE_WORDLISTS_MIN, CI_MIN_SIZE_MERGE_WORDLISTS_MAX ) );
    InterlockedExchange( (long *) &_maxWordlistSize, Range( vars._maxWordlistSize, CI_MAX_WORDLIST_SIZE_MIN, CI_MAX_WORDLIST_SIZE_MAX ) );
    InterlockedExchange( (long *) &_minWordlistMemory, Range( vars._minWordlistMemory, CI_MIN_WORDLIST_MEMORY_MIN, CI_MIN_WORDLIST_MEMORY_MAX ) );
    InterlockedExchange( (long *) &_maxWordlistIo, Range( vars._maxWordlistIo, CI_MAX_WORDLIST_IO_MIN, CI_MAX_WORDLIST_IO_MAX ) );
    InterlockedExchange( (long *) &_maxWordlistIoDiskPerf, Range( vars._maxWordlistIoDiskPerf, CI_MAX_WORDLIST_IO_DISKPERF_MIN, CI_MAX_WORDLIST_IO_DISKPERF_MAX ) );
    InterlockedExchange( (long *) &_minWordlistBattery, Range( vars._minWordlistBattery, CI_MIN_WORDLIST_BATTERY_MIN, CI_MIN_WORDLIST_BATTERY_MAX ) );
    InterlockedExchange( (long *) &_ResourceCheckInterval, Range( vars._ResourceCheckInterval, CI_WORDLIST_RESOURCE_CHECK_INTERVAL_MIN, CI_WORDLIST_RESOURCE_CHECK_INTERVAL_MAX ) );
    InterlockedExchange( (long *) &_maxFreshDeletes, Range( vars._maxFreshDeletes, CI_MAX_FRESH_DELETES_MIN, CI_MAX_FRESH_DELETES_MAX ) );
    InterlockedExchange( (long *) &_lowResourceSleep, Range( vars._lowResourceSleep, CI_LOW_RESOURCE_SLEEP_MIN, CI_LOW_RESOURCE_SLEEP_MAX ) );
    InterlockedExchange( (long *) &_maxWordlistMemoryLoad, Range( vars._maxWordlistMemoryLoad, CI_MAX_WORDLIST_MEMORY_LOAD_MIN, CI_MAX_WORDLIST_MEMORY_LOAD_MAX ) );
    InterlockedExchange( (long *) &_maxFreshCount, Range( vars._maxFreshCount, CI_MAX_FRESHCOUNT_MIN, CI_MAX_FRESHCOUNT_MAX ) );
    InterlockedExchange( (long *) &_maxQueueChunks, Range( vars._maxQueueChunks, CI_MAX_QUEUE_CHUNKS_MIN, CI_MAX_QUEUE_CHUNKS_MAX ) );
    InterlockedExchange( (long *) &_masterMergeCheckpointInterval,
                         Range( vars._masterMergeCheckpointInterval, CI_MASTER_MERGE_CHECKPOINT_INTERVAL_MIN, CI_MASTER_MERGE_CHECKPOINT_INTERVAL_MAX ) );
    InterlockedExchange( (long *) &_filterBufferSize, Range( vars._filterBufferSize, CI_FILTER_BUFFER_SIZE_MIN, CI_FILTER_BUFFER_SIZE_MAX ) );
    InterlockedExchange( (long *) &_filterRetries, Range( vars._filterRetries, CI_FILTER_RETRIES_MIN, CI_FILTER_RETRIES_MAX ) );
    InterlockedExchange( (long *) &_filterRetryInterval, Range( vars._filterRetryInterval, CI_FILTER_RETRY_INTERVAL_MIN, CI_FILTER_RETRY_INTERVAL_MAX ) );
    InterlockedExchange( (long *) &_maxShadowIndexSize, Range( vars._maxShadowIndexSize, CI_MAX_SHADOW_INDEX_SIZE_MIN, CI_MAX_SHADOW_INDEX_SIZE_MAX ) );
    InterlockedExchange( (long *) &_minDiskFreeForceMerge, Range( vars._minDiskFreeForceMerge, CI_MIN_DISKFREE_FORCE_MERGE_MIN, CI_MIN_DISKFREE_FORCE_MERGE_MAX ) );
    InterlockedExchange( (long *) &_maxShadowFreeForceMerge, Range( vars._maxShadowFreeForceMerge, CI_MAX_SHADOW_FREE_FORCE_MERGE_MIN, CI_MAX_SHADOW_FREE_FORCE_MERGE_MAX ) );
    InterlockedExchange( (long *) &_maxIndexes, Range( vars._maxIndexes, CI_MAX_INDEXES_MIN, CI_MAX_INDEXES_MAX ) );
    InterlockedExchange( (long *) &_maxIdealIndexes, Range( vars._maxIdealIndexes, CI_MAX_IDEAL_INDEXES_MIN, CI_MAX_IDEAL_INDEXES_MAX ) );
    InterlockedExchange( (long *) &_minMergeIdleTime, Range( vars._minMergeIdleTime, CI_MIN_MERGE_IDLE_TIME_MIN, CI_MIN_MERGE_IDLE_TIME_MAX ) );
    InterlockedExchange( (long *) &_maxPendingDocuments, Range( vars._maxPendingDocuments, CI_MAX_PENDING_DOCUMENTS_MIN, CI_MAX_PENDING_DOCUMENTS_MAX ) );
    InterlockedExchange( (long *) &_minIdleQueryThreads, Range( vars._minIdleQueryThreads, CI_MIN_IDLE_QUERY_THREADS_MIN, CI_MIN_IDLE_QUERY_THREADS_MAX ) );
    InterlockedExchange( (long *) &_maxActiveQueryThreads, Range( vars._maxActiveQueryThreads, CI_MAX_ACTIVE_QUERY_THREADS_MIN, CI_MAX_ACTIVE_QUERY_THREADS_MAX ) );
    InterlockedExchange( (long *) &_maxQueryTimeslice, Range( vars._maxQueryTimeslice, CI_MAX_QUERY_TIMESLICE_MIN, CI_MAX_QUERY_TIMESLICE_MAX ) );
    InterlockedExchange( (long *) &_maxQueryExecutionTime, Range( vars._maxQueryExecutionTime, CI_MAX_QUERY_EXECUTION_TIME_MIN, CI_MAX_QUERY_EXECUTION_TIME_MAX ) );
    InterlockedExchange( (long *) &_maxRestrictionNodes, Range( vars._maxRestrictionNodes, CI_MAX_RESTRICTION_NODES_MIN, CI_MAX_RESTRICTION_NODES_MAX ) );
    InterlockedExchange( (long *) &_minIdleRequestThreads, Range( vars._minIdleRequestThreads, CI_MIN_IDLE_REQUEST_THREADS_MIN, CI_MIN_IDLE_REQUEST_THREADS_MAX ) );
    InterlockedExchange( (long *) &_minClientIdleTime, Range( vars._minClientIdleTime, CI_MIN_CLIENT_IDLE_TIME, CI_MIN_CLIENT_IDLE_TIME ) );
    InterlockedExchange( (long *) &_maxActiveRequestThreads, Range( vars._maxActiveRequestThreads, CI_MAX_ACTIVE_REQUEST_THREADS_MIN, CI_MAX_ACTIVE_REQUEST_THREADS_MAX ) );
    InterlockedExchange( (long *) &_maxSimultaneousRequests, Range( vars._maxSimultaneousRequests, CI_MAX_SIMULTANEOUS_REQUESTS_MIN, CI_MAX_SIMULTANEOUS_REQUESTS_MAX ) );
    InterlockedExchange( (long *) &_maxCachedPipes, Range( vars._maxCachedPipes, CI_MAX_CACHED_PIPES_MIN, CI_MAX_CACHED_PIPES_MAX ) );
    InterlockedExchange( (long *) &_requestTimeout, Range( vars._requestTimeout, CI_REQUEST_TIMEOUT_MIN, CI_REQUEST_TIMEOUT_MAX ) );
    InterlockedExchange( (long *) &_W3SvcInstance, Range( vars._W3SvcInstance, CI_W3SVC_INSTANCE_MIN, CI_W3SVC_INSTANCE_MAX ) );
    InterlockedExchange( (long *) &_NNTPSvcInstance, Range( vars._NNTPSvcInstance, CI_NNTPSVC_INSTANCE_MIN, CI_NNTPSVC_INSTANCE_MAX ) );
    InterlockedExchange( (long *) &_IMAPSvcInstance, Range( vars._IMAPSvcInstance, CI_IMAPSVC_INSTANCE_MIN, CI_IMAPSVC_INSTANCE_MAX ) );
    InterlockedExchange( (long *) &_ulScanBackoff, Range( vars._ulScanBackoff, CI_SCAN_BACKOFF_MIN, CI_SCAN_BACKOFF_MAX ) );
    InterlockedExchange( (long *) &_ulStartupDelay, Range( vars._ulStartupDelay, CI_STARTUP_DELAY_MIN, CI_STARTUP_DELAY_MAX ) );
    InterlockedExchange( (long *) &_ulUsnReadTimeout, Range( vars._ulUsnReadTimeout, CI_USN_READ_TIMEOUT_MIN, CI_USN_READ_TIMEOUT_MAX ) );
    InterlockedExchange( (long *) &_ulUsnReadMinSize, Range( vars._ulUsnReadMinSize, CI_USN_READ_MIN_SIZE_MIN, CI_USN_READ_MIN_SIZE_MAX ) );
    InterlockedExchange( (long *) &_fDelayUsnReadOnLowResource, vars._fDelayUsnReadOnLowResource != 0 );
    InterlockedExchange( (long *) &_maxDaemonVmUse, Range( vars._maxDaemonVmUse, CI_MAX_DAEMON_VM_USE_MIN, CI_MAX_DAEMON_VM_USE_MAX ) );
    InterlockedExchange( (long *) &_secQFilterRetries, Range( vars._secQFilterRetries, CI_SECQ_FILTER_RETRIES_MIN, CI_SECQ_FILTER_RETRIES_MAX ) );
    InterlockedExchange( (long *) &_fMinimizeWorkingSet, vars._fMinimizeWorkingSet );

    InterlockedExchange( (long *) &_WordlistUserIdle, Range( vars._WordlistUserIdle, CI_WORDLIST_USER_IDLE_MIN, CI_WORDLIST_USER_IDLE_MAX ) );

    InterlockedExchange( (long *) &_evtLogFlags, vars._evtLogFlags );
    InterlockedExchange( (long *) &_miscCiFlags, vars._miscCiFlags );
    InterlockedExchange( (long *) &_ciCatalogFlags, vars._ciCatalogFlags );
    InterlockedExchange( (long *) &_maxUsnLogSize, vars._maxUsnLogSize );
    InterlockedExchange( (long *) &_usnLogAllocationDelta, vars._usnLogAllocationDelta );
    InterlockedExchange( (long *) &_ulStompLastAccessDelay, Range( vars._ulStompLastAccessDelay, CI_STOMP_LAST_ACCESS_DELAY_MIN, CI_STOMP_LAST_ACCESS_DELAY_MAX ) );
    InterlockedExchange( (long *) &_minDiskSpaceToLeave, Range( vars._minDiskSpaceToLeave, CI_MIN_DISK_SPACE_TO_LEAVE_MIN, CI_MIN_DISK_SPACE_TO_LEAVE_MAX ) );

} //_StoreNewValues


//+-------------------------------------------------------------------------
//
//  Member:     CCiRegParams::Refresh, public
//
//  Synopsis:   Reads the values from the registry
//
//  History:    12-Oct-96 dlee  Added header, reorganized
//
//--------------------------------------------------------------------------

void CCiRegParams::Refresh(
    ICiAdminParams * pICiAdminParams,
    BOOL             fUseDefaultsOnFailure )
{
    // Grab the lock so no other writers try to update at the same time

    CCiRegVars newVals;
    CLock lock( _mutex );

    TRY
    {
        //  Query the registry.

        CRegAccess regAdmin( RTL_REGISTRY_CONTROL, wcsRegAdmin );

        _ReadValues( regAdmin, newVals );
        _StoreNewValues( newVals );

        // if there is a catalog override, use it

        _OverrideForCatalog();

        _StoreCIValues( *this,  pICiAdminParams );
    }
    CATCH (CException, e)
    {
        // Only store defaults when told to do so -- the params
        // are still in good shape at this point and are more
        // accurate than the default settings.

        if ( fUseDefaultsOnFailure )
        {
            newVals.SetDefault();
            _StoreNewValues( newVals );
            _StoreCIValues ( newVals, pICiAdminParams );
        }
    }
    END_CATCH

} //Refresh

//+-------------------------------------------------------------------------
//
//  Function:   BuildRegistryScopesKey
//
//  Synopsis:   Builds a registry key for scopes for a given catalog.  This
//              is needed in a couple of places.
//
//  Arguments:  [xKey]    -- Returns the registry key
//              [pwcName] -- Name of the catalog for which key is built
//
//  History:    4-Nov-96 dlee  created
//
//--------------------------------------------------------------------------

void BuildRegistryScopesKey(
    XArray<WCHAR> & xKey,
    WCHAR const *   pwcName )
{
    unsigned cwc = wcslen( L"\\Registry\\Machine\\" );
    cwc += wcslen( wcsRegCatalogsSubKey );
    cwc += 3;
    cwc += wcslen( pwcName );
    cwc += wcslen( wcsCatalogScopes );

    xKey.Init( cwc );

    wcscpy( xKey.Get(), L"\\Registry\\Machine\\" );
    wcscat( xKey.Get(), wcsRegCatalogsSubKey );
    wcscat( xKey.Get(), L"\\" );
    wcscat( xKey.Get(), pwcName );
    wcscat( xKey.Get(), L"\\" );
    wcscat( xKey.Get(), wcsCatalogScopes );
} //BuildRegistryScopesKey

//+-------------------------------------------------------------------------
//
//  Function:   BuildRegistryPropertiesKey
//
//  Synopsis:   Builds a registry key for properties for a given catalog.
//
//  Arguments:  [xKey]    -- Returns the registry key
//              [pwcName] -- Name of the catalog for which key is built
//
//  History:    11-Nov-97 KyleP  Stole from BuildRegistryScopesKey
//
//--------------------------------------------------------------------------

void BuildRegistryPropertiesKey( XArray<WCHAR> & xKey,
                                 WCHAR const *   pwcName )
{
    unsigned cwc = wcslen( L"\\Registry\\Machine\\" );
    cwc += wcslen( wcsRegCatalogsSubKey );
    cwc += 3;
    cwc += wcslen( pwcName );
    cwc += wcslen( wcsCatalogProperties );

    xKey.Init( cwc );

    wcscpy( xKey.Get(), L"\\Registry\\Machine\\" );
    wcscat( xKey.Get(), wcsRegCatalogsSubKey );
    wcscat( xKey.Get(), L"\\" );
    wcscat( xKey.Get(), pwcName );
    wcscat( xKey.Get(), L"\\" );
    wcscat( xKey.Get(), wcsCatalogProperties );
} //BuildRegistryPropertiesKey

//+---------------------------------------------------------------------------
//
//  Member:     CCiRegParams::CheckNamedValues
//
//  Synopsis:   Asserts that each of the named values matches
//              the assumption about it's definition in ciintf.idl
//
//  Notes:      if any of the assertions here pop up,
//
//  History:    1-30-97     mohamedn    created
//
//----------------------------------------------------------------------------
void CCiRegParams::_CheckNamedValues()
{

    Win4Assert ( 0  == CI_AP_MERGE_INTERVAL );
    Win4Assert ( 1  == CI_AP_MAX_UPDATES);
    Win4Assert ( 2  == CI_AP_MAX_WORDLISTS);
    Win4Assert ( 3  == CI_AP_MIN_SIZE_MERGE_WORDLISTS);

    Win4Assert ( 4  == CI_AP_MAX_WORDLIST_SIZE);
    Win4Assert ( 5  == CI_AP_MIN_WORDLIST_MEMORY);
    Win4Assert ( 6  == CI_AP_LOW_RESOURCE_SLEEP);
    Win4Assert ( 7  == CI_AP_MAX_WORDLIST_MEMORY_LOAD);

    Win4Assert ( 8  == CI_AP_MAX_FRESH_COUNT);
    Win4Assert ( 9  == CI_AP_MAX_SHADOW_INDEX_SIZE);
    Win4Assert ( 10 == CI_AP_MIN_DISK_FREE_FORCE_MERGE);
    Win4Assert ( 11 == CI_AP_MAX_SHADOW_FREE_FORCE_MERGE);

    Win4Assert ( 12 == CI_AP_MAX_INDEXES);
    Win4Assert ( 13 == CI_AP_MAX_IDEAL_INDEXES);
    Win4Assert ( 14 == CI_AP_MIN_MERGE_IDLE_TIME);
    Win4Assert ( 15 == CI_AP_MAX_PENDING_DOCUMENTS);

    Win4Assert ( 16 == CI_AP_MASTER_MERGE_TIME);
    Win4Assert ( 17 == CI_AP_MAX_QUEUE_CHUNKS);
    Win4Assert ( 18 == CI_AP_MASTER_MERGE_CHECKPOINT_INTERVAL);
    Win4Assert ( 19 == CI_AP_FILTER_BUFFER_SIZE);

    Win4Assert ( 20 == CI_AP_FILTER_RETRIES);
    Win4Assert ( 21 == CI_AP_FILTER_RETRY_INTERVAL);
    Win4Assert ( 22 == CI_AP_MIN_IDLE_QUERY_THREADS);
    Win4Assert ( 23 == CI_AP_MAX_ACTIVE_QUERY_THREADS);

    Win4Assert ( 24 == CI_AP_MAX_QUERY_TIMESLICE);
    Win4Assert ( 25 == CI_AP_MAX_QUERY_EXECUTION_TIME);
    Win4Assert ( 26 == CI_AP_MAX_RESTRICTION_NODES);
    Win4Assert ( 27 == CI_AP_CLUSTERINGTIME);

    Win4Assert ( 28 == CI_AP_MAX_FILESIZE_MULTIPLIER);
    Win4Assert ( 29 == CI_AP_DAEMON_RESPONSE_TIMEOUT);
    Win4Assert ( 30 == CI_AP_FILTER_DELAY_INTERVAL);
    Win4Assert ( 31 == CI_AP_FILTER_REMAINING_THRESHOLD);

    Win4Assert ( 32 == CI_AP_MAX_CHARACTERIZATION);
    Win4Assert ( 33 == CI_AP_MAX_FRESH_DELETES );
    Win4Assert ( 34 == CI_AP_MAX_WORDLIST_IO );
    Win4Assert ( 35 == CI_AP_WORDLIST_RESOURCE_CHECK_INTERVAL );

    Win4Assert ( 36 == CI_AP_STARTUP_DELAY );
    Win4Assert ( 37 == CI_AP_GENERATE_CHARACTERIZATION );
    Win4Assert ( 38 == CI_AP_MIN_WORDLIST_BATTERY );
    Win4Assert ( 39 == CI_AP_THREAD_PRIORITY_MERGE);

    Win4Assert ( 40 == CI_AP_THREAD_PRIORITY_FILTER);
    Win4Assert ( 41 == CI_AP_THREAD_CLASS_FILTER);
    Win4Assert ( 42 == CI_AP_EVTLOG_FLAGS);
    Win4Assert ( 43 == CI_AP_MISC_FLAGS);

    Win4Assert ( 44 == CI_AP_GENERATE_RELEVANT_WORDS);
    Win4Assert ( 45 == CI_AP_FFILTER_FILES_WITH_UNKNOWN_EXTENSIONS);
    Win4Assert ( 46 == CI_AP_FILTER_DIRECTORIES);
    Win4Assert ( 47 == CI_AP_FILTER_CONTENTS);

    Win4Assert ( 48 == CI_AP_MAX_FILESIZE_FILTERED);
    Win4Assert ( 49 == CI_AP_MIN_CLIENT_IDLE_TIME);
    Win4Assert ( 50 == CI_AP_MAX_DAEMON_VM_USE);
    Win4Assert ( 51 == CI_AP_SECQ_FILTER_RETRIES);

    Win4Assert ( 52 == CI_AP_WORDLIST_USER_IDLE);
    Win4Assert ( 53 == CI_AP_IS_ENUM_ALLOWED);
    Win4Assert ( 54 == CI_AP_MIN_DISK_SPACE_TO_LEAVE);

    //
    // Place holder to mark end of values that fit in DWORD,
    //

    Win4Assert ( 55 == CI_AP_MAX_DWORD_VAL);

    // CI_AP_MAX_VAL                // mark end of params.
}


// ---------------------------------------------------------------------------
// Array of enumerated/named Ci admin. parameters, used to index
// into the array of parameters to set/get parameter values.
// ---------------------------------------------------------------------------

const CI_ADMIN_PARAMS CCiRegParams::_aParamNames[ CI_AP_MAX_VAL ] =
{
    CI_AP_MERGE_INTERVAL,
    CI_AP_MAX_UPDATES,
    CI_AP_MAX_WORDLISTS,
    CI_AP_MIN_SIZE_MERGE_WORDLISTS,

    CI_AP_MAX_WORDLIST_SIZE,
    CI_AP_MIN_WORDLIST_MEMORY,
    CI_AP_LOW_RESOURCE_SLEEP,
    CI_AP_MAX_WORDLIST_MEMORY_LOAD,

    CI_AP_MAX_FRESH_COUNT,
    CI_AP_MAX_SHADOW_INDEX_SIZE,
    CI_AP_MIN_DISK_FREE_FORCE_MERGE,
    CI_AP_MAX_SHADOW_FREE_FORCE_MERGE,

    CI_AP_MAX_INDEXES,
    CI_AP_MAX_IDEAL_INDEXES,
    CI_AP_MIN_MERGE_IDLE_TIME,
    CI_AP_MAX_PENDING_DOCUMENTS,

    CI_AP_MASTER_MERGE_TIME,
    CI_AP_MAX_QUEUE_CHUNKS,
    CI_AP_MASTER_MERGE_CHECKPOINT_INTERVAL,
    CI_AP_FILTER_BUFFER_SIZE,

    CI_AP_FILTER_RETRIES,
    CI_AP_FILTER_RETRY_INTERVAL,
    CI_AP_MIN_IDLE_QUERY_THREADS,
    CI_AP_MAX_ACTIVE_QUERY_THREADS,

    CI_AP_MAX_QUERY_TIMESLICE,
    CI_AP_MAX_QUERY_EXECUTION_TIME,
    CI_AP_MAX_RESTRICTION_NODES,
    CI_AP_CLUSTERINGTIME,

    CI_AP_MAX_FILESIZE_MULTIPLIER,
    CI_AP_DAEMON_RESPONSE_TIMEOUT,
    CI_AP_FILTER_DELAY_INTERVAL,
    CI_AP_FILTER_REMAINING_THRESHOLD,

    CI_AP_MAX_CHARACTERIZATION,
    CI_AP_MAX_FRESH_DELETES,
    CI_AP_MAX_WORDLIST_IO,
    CI_AP_WORDLIST_RESOURCE_CHECK_INTERVAL,

    CI_AP_STARTUP_DELAY,
    CI_AP_GENERATE_CHARACTERIZATION,
    CI_AP_MIN_WORDLIST_BATTERY,
    CI_AP_THREAD_PRIORITY_MERGE,

    CI_AP_THREAD_PRIORITY_FILTER,
    CI_AP_THREAD_CLASS_FILTER,
    CI_AP_EVTLOG_FLAGS,
    CI_AP_MISC_FLAGS,

    CI_AP_GENERATE_RELEVANT_WORDS,
    CI_AP_FFILTER_FILES_WITH_UNKNOWN_EXTENSIONS,
    CI_AP_FILTER_DIRECTORIES,
    CI_AP_FILTER_CONTENTS,

    CI_AP_MAX_FILESIZE_FILTERED,
    CI_AP_MIN_CLIENT_IDLE_TIME,
    CI_AP_MAX_DAEMON_VM_USE,
    CI_AP_SECQ_FILTER_RETRIES,

    CI_AP_WORDLIST_USER_IDLE,
    CI_AP_IS_ENUM_ALLOWED,
    CI_AP_MIN_DISK_SPACE_TO_LEAVE,

    //
    // Place holder to mark end of values that fit in DWORD,
    //

    CI_AP_MAX_DWORD_VAL,

    // CI_AP_MAX_VAL                // mark end of params.
};

//+---------------------------------------------------------------------------
//
//  Function:   GetMaxCatalogs
//
//  Synopsis:   Retrieves the global max count of catalogs
//
//  History:    May-5-99     dlee    created
//
//----------------------------------------------------------------------------

ULONG GetMaxCatalogs()
{
    //
    // Make sure we only read this value once.  Force a restart of the
    // service to read it again.
    //

    static ULONG cMaxCatalogs = 0xffffffff;

    if ( 0xffffffff == cMaxCatalogs )
    {
        CRegAccess reg( RTL_REGISTRY_CONTROL, wcsRegAdmin );

        DWORD cCat = reg.Read( wcsMaxCatalogs, CI_MAX_CATALOGS_DEFAULT);
        cMaxCatalogs = Range( cCat, CI_MAX_CATALOGS_MIN, CI_MAX_CATALOGS_MAX );
    }

    return cMaxCatalogs;
} //GetMaxCatalogs
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\ntciutil\phystr.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Corporation
//  Copyright (C) Microsoft Corporation, 1992 - 1998.
//
//  File:       PhysIdx.CXX
//
//  Contents:   FAT Buffer/Index package
//
//  Classes:    CPhysBuffer -- Buffer
//
//  History:    05-Mar-92   KyleP       Created
//              07-Aug-92   KyleP       Kernel implementation
//              21-Apr-93   BartoszM    Rewrote to use memory mapped files
//
//----------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include <pstore.hxx>
#include <phystr.hxx>
#include <eventlog.hxx>
#include <psavtrak.hxx>

//+-------------------------------------------------------------------------
//
//  Function:   PageToLow
//
//  Returns:    Low part of byte count in cPage pages
//
//  History:    21-Apr-93       BartoszM        Created
//
//--------------------------------------------------------------------------

inline ULONG PageToLow(ULONG cPage)
{
    return(cPage << CI_PAGE_SHIFT);
}

//+-------------------------------------------------------------------------
//
//  Function:   PageToHigh
//
//  Returns:    High part of byte count in cPage pages
//
//  History:    21-Apr-93       BartoszM        Created
//
//--------------------------------------------------------------------------

inline ULONG PageToHigh(ULONG cPage)
{
    return(cPage >> (ULONG_BITS - CI_PAGE_SHIFT));
}

//+-------------------------------------------------------------------------
//
//  Function:   ToPages
//
//  Returns:    Number of pages equivalent to (cbLow, cbHigh) bytes
//
//  History:    21-Apr-93       BartoszM        Created
//
//--------------------------------------------------------------------------

inline ULONG ToPages ( ULONG cbLow, ULONG cbHigh )
{
    Win4Assert ( cbHigh >> CI_PAGE_SHIFT == 0 );
    return (cbLow >> CI_PAGE_SHIFT) + (cbHigh << (ULONG_BITS - CI_PAGE_SHIFT));
}

//+-------------------------------------------------------------------------
//
//  Function:   PgCommonPgTrunc
//
//  Returns:    Number of pages truncated to multiple of largest common page
//
//  History:    21-Apr-93       BartoszM        Created
//
//--------------------------------------------------------------------------

inline ULONG PgCommonPgTrunc(ULONG nPage)
{
    return nPage & ~(PAGES_PER_COMMON_PAGE - 1);
}

inline ULONGLONG MAKEULONGLONG( ULONG l, ULONG h )
{
    return ( (ULONGLONG) l | ( (ULONGLONG) h << 32 ) );
}

//+-------------------------------------------------------------------------
//
//  Function:   PgCommonPgRound
//
//  Returns:    Number of pages rounded to multiple of largest common page
//
//  History:    21-Apr-93       BartoszM        Created
//
//--------------------------------------------------------------------------

inline ULONG PgCommonPgRound(ULONG nPage)
{
    return (nPage + PAGES_PER_COMMON_PAGE - 1) & ~(PAGES_PER_COMMON_PAGE - 1);
}

//+-------------------------------------------------------------------------
//
//  Member:     CPhysBuffer::~CPhysBuffer
//
//  History:    07-Dec-93   BartoszM    Created
//
//--------------------------------------------------------------------------

CPhysBuffer::~CPhysBuffer()
{
    Win4Assert( !_fNeedToFlush );

#if CIDBG == 1
    Flush( FALSE );
#endif
}

//+-------------------------------------------------------------------------
//
//  Member:     CPhysBuffer::CPhysBuffer, public
//
//  Synopsis:   Allocates virtual memory
//
//  Arguments:  [stream]         -- stream to use
//              [PageNo]         -- page number
//              [fWrite]         -- for writable memory
//              [fIntentToWrite] -- When fWrite is TRUE, whether the
//                                  client intends to write to the memory so
//                                  it needs to be flushed.
//
//  History:    10-Mar-92 KyleP     Created
//              21-Apr-93 BartoszM  Rewrote to use memory mapped files
//
//--------------------------------------------------------------------------

CPhysBuffer::CPhysBuffer(
    PMmStream& stream,
    ULONG      PageNo,
    BOOL       fWrite,
    BOOL       fIntentToWrite,
    BOOL       fMap ) :
    _cRef( 0 ),
    _pphysNext( 0 ),
    _fNeedToFlush( fIntentToWrite ),
    _fWrite( fWrite ),
    _fMap( fMap ),
    _stream( stream )
{
    _PageNo = PgCommonPgTrunc( PageNo );

    if ( _fMap )
        stream.Map( _strmBuf,
                    COMMON_PAGE_SIZE,
                    PageToLow( _PageNo ),
                    PageToHigh( _PageNo ),
                    fWrite );
    else
    {
        DWORD cbRead;

        _xBuffer.Init( COMMON_PAGE_SIZE );
        _stream.Read( _xBuffer.Get(),
                      MAKEULONGLONG( PageToLow( _PageNo ),
                                     PageToHigh( _PageNo ) ),
                      COMMON_PAGE_SIZE,
                      cbRead );
    }
} //CPhysBuffer

//+-------------------------------------------------------------------------
//
//  Member:     CPhysBuffer::Flush, public
//
//  Synopsis:   Flushes the buffer to disk
//
//  Arguments:  [fFailFlush]     -- If TRUE and flush fails, an exception is
//                                  raised.  Otherwise failures to flush are
//                                  ignored.
//
//  History:    10/30/98    dlee    Moved out of header
//
//--------------------------------------------------------------------------

void CPhysBuffer::Flush( BOOL fFailFlush )
{
    if ( _fNeedToFlush )
    {
        Win4Assert( _fWrite );

        //
        // Reset the flag first, so subsequent attempts to flush won't
        // fail if first attempt fails.  This is so we don't throw
        // in destructors.  If we can't tolerate failures to flush, don't
        // even bother trying to write the data if we can't fail.
        //

        _fNeedToFlush = FALSE;

        if ( fFailFlush )
        {
            if ( _fMap )
            {
                // Flush the buffer and metadata in one call

                _strmBuf.Flush( TRUE );
            }
            else
            {
                _stream.Write( _xBuffer.Get(),
                               MAKEULONGLONG( PageToLow( _PageNo ),
                                              PageToHigh( _PageNo ) ),
                               COMMON_PAGE_SIZE );
            }
        }
        else
        {
            ciDebugOut(( DEB_WARN, "not flushing at %#p, in failure path?\n",
                         this ));
        }
    }

#if CIDBG == 1

    //
    // Make sure the bits on disk are the same as those in memory, since
    // the buffer is marked as not needing to be flushed.  Only do this if
    // using read/write instead of mapping.
    //

    else if ( !_fMap && fFailFlush )
    {
        TRY
        {
            XArrayVirtual<BYTE> xTmp( COMMON_PAGE_SIZE );
    
            DWORD cbRead;
            _stream.Read( xTmp.Get(),
                          MAKEULONGLONG( PageToLow( _PageNo ),
                                         PageToHigh( _PageNo ) ),
                          COMMON_PAGE_SIZE,
                          cbRead );
    
            if ( 0 != memcmp( xTmp.Get(), _xBuffer.Get(), COMMON_PAGE_SIZE ) )
            {
                ciDebugOut(( DEB_ERROR, "read: %p, have: %p\n",
                             xTmp.Get(), _xBuffer.Get() ));
                Win4Assert( !"writable non-flushed buffer was modified!" );
            }
        }
        CATCH( CException, e )
        {
            // Ignore -- it's just an assert.
        }
        END_CATCH;
    }
#endif // CIDBG == 1

} //Flush
    
//+-------------------------------------------------------------------------
//
//  Member:     CBufferCacheIter::CBufferCacheIter, public
//
//  Synopsis:   Constructor
//
//  History:    18-Mar-93 BartoszM     Created
//
//--------------------------------------------------------------------------

CBufferCacheIter::CBufferCacheIter ( CBufferCache& cache )
: _pPhysBuf(cache._aPhysBuf.GetPointer()), _idx(0), _cHash( cache._cHash )
{
    do
    {
        _pBuf = _pPhysBuf[_idx];
        if (_pBuf != 0)
            break;
        _idx++;
    } while ( _idx < _cHash );
} //CBufferCacheIter

//+-------------------------------------------------------------------------
//
//  Member:     CBufferCacheIter::operator++, public
//
//  Synopsis:   Increments the iterator
//
//  History:    18-Mar-93 BartoszM     Created
//
//--------------------------------------------------------------------------

void CBufferCacheIter::operator++()
{
    Win4Assert(_pBuf != 0);
    _pBuf = _pBuf->Next();
    while (_pBuf == 0 && ++_idx < _cHash )
        _pBuf = _pPhysBuf[_idx];
}

//+-------------------------------------------------------------------------
//
//  Member:     CBufferCache::CBufferCache, public
//
//  Synopsis:   Constructor
//
//  History:    18-Mar-93 BartoszM     Created
//
//--------------------------------------------------------------------------

CBufferCache::CBufferCache( unsigned cHash )
    : _cBuffers( 0 ),
      _cHash( cHash ),
      _aPhysBuf( cHash )
    #if CIDBG == 1
        , _cCacheHits( 0 ), _cCacheMisses( 0 )
    #endif

{
    RtlZeroMemory( _aPhysBuf.GetPointer(), _aPhysBuf.SizeOf() );
}

//+-------------------------------------------------------------------------
//
//  Member:     CBufferCache::~CBufferCache, public
//
//  Synopsis:   Destructor
//
//  History:    18-Mar-93 BartoszM     Created
//
//--------------------------------------------------------------------------

CBufferCache::~CBufferCache()
{
    Free( FALSE );
}

//+-------------------------------------------------------------------------
//
//  Member:     CBufferCache::Free, public
//
//  Synopsis:   Deletes all buffers
//
//  Arguments:  [fFailFlush]  -- If TRUE, this method will THROW if the flush
//                               fails.  If FALSE, flush failures are
//                               ignored.
//
//  History:    18-Mar-93 BartoszM     Created
//
//--------------------------------------------------------------------------

void CBufferCache::Free( BOOL fFailFlush )
{
    if ( 0 != _cBuffers )
    {
        for ( unsigned i = 0; i < _cHash; i++ )
        {
            // Keep the cache consistent in case we fail flushing.

            while ( 0 != _aPhysBuf[i] )
            {
                CPhysBuffer * pTemp = _aPhysBuf[i];

                pTemp->Flush( fFailFlush );

#if CIDBG == 1
                if ( pTemp->IsReferenced() )
                    ciDebugOut(( DEB_WARN,
                                 "Buffer for page %ld still referenced.\n",
                                 pTemp->PageNumber() ));
#endif // CIDBG == 1

                _aPhysBuf[i] = pTemp->Next();
                delete pTemp;
                _cBuffers--;
            }

            Win4Assert( 0 == _aPhysBuf[i] );
        }

        Win4Assert( 0 == _cBuffers );
    }
} //Free

//+-------------------------------------------------------------------------
//
//  Member:     CBufferCache::TryToRemoveBuffers, public
//
//  Synopsis:   Tries to remove unreferenced buffers from the cache.
//              If one is not found, it's not a problem.
//
//  Arguments:  [cMax] -- Recommended maximum in the cache
//
//  History:    15-March-96 dlee     Created
//
//--------------------------------------------------------------------------

void CBufferCache::TryToRemoveBuffers( unsigned cMax )
{
    for ( unsigned i = 0; i < 3 && ( Count() > cMax ); i++ )
    {
        // find an unreferenced page with the lowest (oldest) usn.
    
        ULONG ulPage = ULONG_MAX;
        ULONG ulUSN = ULONG_MAX;
    
        for ( CBufferCacheIter iter(*this); !iter.AtEnd(); ++iter )
        {
            CPhysBuffer * pPhys = iter.Get();
    
            Win4Assert( 0 != pPhys );
    
            if ( ( ulUSN > pPhys->GetUSN() ) &&
                 ( !pPhys->IsReferenced() ) )
            {
                ulUSN = pPhys->GetUSN();
                ulPage = pPhys->PageNumber();
            }
        }
    
        if ( ULONG_MAX == ulPage )
            break;
        else
            Destroy( ulPage );
    }
} //TryToRemoveBuffers

//+-------------------------------------------------------------------------
//
//  Member:     CBufferCache::Search, public
//
//  Synopsis:   Searches the buffer hash for the requested buffer.
//
//  Arguments:  [ulPage] -- Page number of page to be found.
//
//  Returns:    0 if page not currently buffered, or the pointer
//              to the (physical) buffer.
//
//  History:    09-Mar-92 KyleP     Created
//              17-Mar-93 BartoszM  Rewrote
//
//--------------------------------------------------------------------------

CPhysBuffer * CBufferCache::Search(
    ULONG hash,
    ULONG commonPage )
{
    // ciDebugOut (( DEB_ITRACE, "CBufferCache::Search %d\n", ulPage ));

    for ( CPhysBuffer *pPhys = _aPhysBuf[ hash ];
          0 != pPhys;
          pPhys = pPhys->Next() )
    {
        if ( pPhys->PageNumber() == commonPage )
            break;
    }

    #if DBG==1 || CIDBG==1
        if ( 0 == pPhys )
            _cCacheMisses++;
        else
            _cCacheHits++;
    #endif // DBG==1 || CIDBG==1

    return pPhys;
} //Search

//+---------------------------------------------------------------------------
//
//  Function:   Flush
//
//  Synopsis:   Flushes all cached pages upto and including the specified
//              page to disk.
//
//  Arguments:  [nHighPage] -- The "CI" page number below which all pages
//              must be flushed to disk.
//
//  History:    4-20-94   srikants   Created
//
//  Notes:      nHighPage is in units of "CI" page (4K bytes) and not
//              CommonPage which is 64K.
//
//----------------------------------------------------------------------------

void CBufferCache::Flush( ULONG nHighPage, BOOL fLeaveFlushFlagAlone )
{
    nHighPage = PgCommonPgTrunc(nHighPage);
    ciDebugOut(( DEB_ITRACE, "CBufferCache : Flushing All Pages <= 0x%x\n",
                 nHighPage ));

    if ( 0 == _cBuffers )
        return;

    //
    // We Must Flush All pages <= the given page number.
    //

    for ( CBufferCacheIter iter(*this); !iter.AtEnd(); ++iter )
    {
        CPhysBuffer * pPhys = iter.Get();

        Win4Assert( 0 != pPhys );

        if ( pPhys->PageNumber() <= nHighPage )
        {
            // Call flush even if not required to get assertions checked

            BOOL fRequiresFlush = pPhys->RequiresFlush();

            pPhys->Flush( TRUE );

            if ( fLeaveFlushFlagAlone && fRequiresFlush )
                pPhys->SetIntentToWrite();
        }
    }
} //Flush

//+-------------------------------------------------------------------------
//
//  Member:     CBufferCache::Destroy, public
//
//  Synopsis:   Deletes a buffer.
//
//  Arguments:  [ulPage] -- page number to be deleted
//
//  History:    18-Mar-93 BartoszM     Created
//
//--------------------------------------------------------------------------

void CBufferCache::Destroy( ULONG ulPage, BOOL fFailFlush )
{
    ulPage = PgCommonPgTrunc(ulPage);

    ULONG iHash = hash( ulPage );

    CPhysBuffer * pPhys = _aPhysBuf[ iHash ];
    Win4Assert( 0 != pPhys );

    // Find the page.  Don't remove from the list until it is flushed.
    // Is it first? (common case)

    if (pPhys->PageNumber() == ulPage)
    {
        // This should be flushed before being unmapped. Fix for bug 132655

        pPhys->Flush( fFailFlush );

        _aPhysBuf[iHash] = pPhys->Next();
    }
    else
    {
        // Search linked list

        CPhysBuffer * pPhysPrev;
        do
        {
            pPhysPrev = pPhys;
            pPhys = pPhys->Next();
            Win4Assert( 0 != pPhys );
        }
        while (pPhys->PageNumber() != ulPage );

        // This should be flushed before being unmapped. Fix for bug 132655

        pPhys->Flush( fFailFlush );

        // delete from the linked list

        pPhysPrev->Link( pPhys->Next() );
        Win4Assert ( !pPhys->IsReferenced() );
    }

    _cBuffers--;
    delete pPhys;
} //Destroy

//+-------------------------------------------------------------------------
//
//  Member:     CBufferCache::Add, public
//
//  Synopsis:   Adds a buffer to the buffer hash.
//
//  Arguments:  [pPhysBuf] -- Buffer to add.
//
//  History:    09-Mar-92 KyleP     Created
//
//--------------------------------------------------------------------------

void CBufferCache::Add( CPhysBuffer * pPhysBuf, ULONG hash )
{
    _cBuffers++;

    pPhysBuf->Reference();

    pPhysBuf->Link( _aPhysBuf[ hash ] );

    _aPhysBuf[ hash ] = pPhysBuf;
} //Add

//+-------------------------------------------------------------------------
//
//  Member:     CBufferCache::MinPageInUse, public
//
//  Synopsis:   Finds the smallest page in use within the cache
//
//  Returns :   TRUE if any page is in the cache; FALSE o/w
//              If TRUE is returned, then minPageInUse will contain the
//              minimum page that is present in the cache.
//
//  Arguments:  minPageInUse    (out) Will be set to the minimum page in
//              the cache if the return value is TRUE.
//
//  History:    02-May-94   DwightKr    Created
//              08-Dec-94   SrikantS    Fixed to return the correct value for
//                                      empty cache.
//
//--------------------------------------------------------------------------
BOOL CBufferCache::MinPageInUse(ULONG &minPageInUse)
{
    ULONG minPage = 0xFFFFFFFF;

    for (CBufferCacheIter iter(*this); !iter.AtEnd(); ++iter)
    {
        minPage = min(minPage, iter.Get()->PageNumber() );
    }

    if ( minPage == 0xFFFFFFFF )
    {
        return FALSE;
    }
    else
    {
        minPageInUse = minPage;
        return TRUE;
    }
} //MinPageInUse

//+-------------------------------------------------------------------------
//
//  Member:     CPhysStorage::CPhysStorage, public
//
//  Effects:    Creates a new index.
//
//  Arguments:  [storage]   -- physical storage to create index in
//              [obj]          -- Storage object
//              [objectId]  -- Index ID
//              [cPageReqSize] --
//              [stream]       -- Memory mapped stream
//              [fThrowCorruptErrorOnFailures  -- If true, then errors during
//                                                opening will be marked as
//                                                catalog corruption
//              [cCachedItems] -- # of non-referenced pages to cache
//              [fAllowReadAhead] -- if TRUE, non-mapped IO will be used
//                                   when the physical storage says it's ok.
//
//  Signals:    Cannot create.
//
//  Modifies:   A new index (file) is created on the disk.
//
//  History:    07-Mar-92 KyleP    Created
//
//--------------------------------------------------------------------------

CPhysStorage::CPhysStorage( PStorage & storage,
                            PStorageObject& obj,
                            WORKID objectId,
                            UINT cpageReqSize,
                            PMmStream * stream,
                            BOOL fThrowCorruptErrorOnFailures,
                            unsigned cCachedItems,
                            BOOL fAllowReadAhead )
        : _sigPhysStorage(eSigPhysStorage),
          _fWritable( TRUE ),
          _objectId( objectId ),
          _obj ( obj),
          _cpageUsedFileSize( 0 ),
          _storage(storage),
          _stream(stream),
          _iFirstNonShrunkPage( 0 ),
          _fThrowCorruptErrorOnFailures(fThrowCorruptErrorOnFailures),
          _cpageGrowth(1),
          _cMaxCachedBuffers( cCachedItems ),
          _cache( __max( 17, ( cCachedItems & 1 ) ? cCachedItems :
                                                    cCachedItems + 1 ) ),
          _usnGen( 0 ),
          _fAllowReadAhead( fAllowReadAhead )
{
    //
    // Use different locking schemes depending on usage
    //

    if ( 0 == _cMaxCachedBuffers )
        _xMutex.Set( new CMutexSem() );
    else
        _xRWAccess.Set( new CReadWriteAccess() );

    if ( _stream.IsNull() || !_stream->Ok() )
    {
        ciDebugOut((DEB_ERROR, "Index Creation failed %08x\n", objectId ));

        if ( _fThrowCorruptErrorOnFailures || _stream->FStatusFileNotFound() )
        {
           //
           // We don't have code to handle such failures, hence mark
           // catalog as corrupt; otherwise throw e_fail
           //
           Win4Assert( !"Corrupt catalog" );
           _storage.ReportCorruptComponent( L"PhysStorage1" );
           THROW( CException( CI_CORRUPT_DATABASE ));
        }
        else
           THROW( CException( E_FAIL ));
    }

    if (cpageReqSize == 0)
        cpageReqSize = 1;

    TRY
    {
        _GrowFile( cpageReqSize );
    }
    CATCH( CException, e )
    {
        //
        // There may not be enough space on the disk to allocate the
        // requested size.  If not enough space, do the best that we
        // can and hope space gets freed.
        //

        _GrowFile( 1 );
    }
    END_CATCH

    ciDebugOut(( DEB_ITRACE, "Physical index %08x created.\n", _objectId ));
}

//+-------------------------------------------------------------------------
//
//  Member:     CPhysStorage::CPhysStorage, public
//
//  Effects:    Opens an existing index.
//
//  Arguments:  [storage]   -- physical storage to open index in
//              [obj]       -- Storage object
//              [objectId]  -- Index ID.
//              [stream]    -- Memory mapped stream
//              [mode]      -- Open mode
//              [fThrowCorruptErrorOnFailures  -- If true, then errors during
//                                                opening will be marked as
//                                                catalog corruption
//              [cCachedItems] -- # of non-referenced pages to cache
//              [fAllowReadAhead] -- if TRUE, non-mapped IO will be used
//                                   when the physical storage says it's ok.
//
//  History:    07-Mar-92 KyleP    Created
//
//--------------------------------------------------------------------------

CPhysStorage::CPhysStorage( PStorage & storage,
                            PStorageObject& obj,
                            WORKID objectId,
                            PMmStream * stream,
                            PStorage::EOpenMode mode,
                            BOOL fThrowCorruptErrorOnFailures,
                            unsigned cCachedItems,
                            BOOL fAllowReadAhead )
        : _sigPhysStorage(eSigPhysStorage),
          _fWritable( PStorage::eOpenForWrite == mode ),
          _objectId( objectId ),
          _obj ( obj ),
          _cpageUsedFileSize( 0 ),
          _storage(storage),
          _stream(stream),
          _fThrowCorruptErrorOnFailures(fThrowCorruptErrorOnFailures),
          _cpageGrowth(1),
          _iFirstNonShrunkPage( 0 ),
          _cMaxCachedBuffers( cCachedItems ),
          _cache( __max( 17, ( cCachedItems & 1 ) ? cCachedItems :
                                                    cCachedItems + 1 ) ),
          _usnGen( 0 ),
          _fAllowReadAhead( fAllowReadAhead )
{
    //
    // Use different locking schemes depending on usage
    //

    if ( 0 == _cMaxCachedBuffers )
        _xMutex.Set( new CMutexSem() );
    else
        _xRWAccess.Set( new CReadWriteAccess() );

    if ( _stream.IsNull() || !_stream->Ok() )
    {
        ciDebugOut(( DEB_ERROR, "Open of index %08x failed\n", objectId ));

        if ( _fThrowCorruptErrorOnFailures || _stream->FStatusFileNotFound() )
        {
           //
           // We don't have code to handle such failures, hence mark
           // catalog as corrupt; otherwise throw e_fail
           //
           Win4Assert( !"Corrupt catalog" );
           _storage.ReportCorruptComponent( L"PhysStorage2" );
           THROW( CException( CI_CORRUPT_DATABASE ));
        }
        else
           THROW( CException( E_FAIL ));
    }

    _cpageFileSize = ToPages(_stream->SizeLow(), _stream->SizeHigh());

    ciDebugOut(( DEB_ITRACE, "Physical index %08x (%d pages) opened.\n",
            _objectId, _cpageFileSize ));
}


//+---------------------------------------------------------------------------
//
//  Member:     CPhysStorage::MakeBackupCopy
//
//  Synopsis:   Makes a backup copy of the current storage using the
//              destination storage.
//
//  Arguments:  [dst]             - Destination storage.
//              [progressTracker] - Progress tracking
//
//  History:    3-18-97   srikants   Created
//
//----------------------------------------------------------------------------

void CPhysStorage::MakeBackupCopy( CPhysStorage & dst,
                                   PSaveProgressTracker & progressTracker )
{
    //
    // Copy one page at a time.
    //
    ULONG * pSrcNext = 0;
    ULONG * pDstNext = 0;

    unsigned iCurrBorrow = 0; // always has the current buffers borrowed.

    SCODE sc = S_OK;

    TRY
    {
        //
        // Grow the destination to be as big as the current one.
        //
        dst._GrowFile( _cpageFileSize );

        if ( _cpageFileSize > 0 )
        {
            iCurrBorrow = 0;

            pSrcNext = BorrowBuffer(iCurrBorrow, FALSE );
            pDstNext = dst.BorrowNewBuffer(iCurrBorrow);

            const unsigned iLastPage = _cpageFileSize-1;

            for ( unsigned j = 0; j < _cpageFileSize; j++ )
            {
                ULONG * pSrc = pSrcNext;
                ULONG * pDst = pDstNext;

                Win4Assert( 0 != pSrc && 0 != pDst );

                RtlCopyMemory( pDst, pSrc, CI_PAGE_SIZE );

                //
                // Before returning buffers, grab the next ones to prevent
                // the large page from being taken out of cache.
                //

                if ( j != iLastPage )
                {
                    iCurrBorrow = j+1;
                    pSrcNext = BorrowBuffer(iCurrBorrow, FALSE );
                    pDstNext = dst.BorrowNewBuffer(iCurrBorrow);
                }
                else
                {
                    pSrcNext = pDstNext = 0;
                }

                ReturnBuffer( j );
                dst.ReturnBuffer( j, TRUE );

                if ( progressTracker.IsAbort() )
                    THROW( CException( STATUS_TOO_LATE ) );

                //
                // Update the progress every 64 K.
                //
                if ( (j % PAGES_PER_COMMON_PAGE) == (PAGES_PER_COMMON_PAGE-1) )
                    progressTracker.UpdateCopyProgress( (ULONG) j, _cpageFileSize );
            }
        }

        dst.Flush();
    }
    CATCH( CException, e )
    {
        if ( pSrcNext )
            ReturnBuffer( iCurrBorrow );

        if ( pDstNext )
            dst.ReturnBuffer(iCurrBorrow);

        sc = e.GetErrorCode();
    }
    END_CATCH

    if ( S_OK != sc )
    {
        //
        // _GrowFile throws CI_CORRUPT_DATABASE if it cannot create
        // the file that big. We don't want to consider that a
        // corruption.
        //
        if ( CI_CORRUPT_DATABASE == sc )
            sc = E_FAIL;

        THROW( CException( sc ) );
    }

    //
    // Consider 100% of the copy work is done.
    //
    progressTracker.UpdateCopyProgress( 1,1 );
}


//+-------------------------------------------------------------------------
//
//  Member:     CPhysStorage::~CPhysStorage, public
//
//  Synopsis:   closes index.
//
//  History:    09-Mar-92 KyleP     Created
//
//  Notes:      Don't write back pages. This is either a read only
//              index or we are aborting a merge. Pages are written
//              back after a successful merge using Reopen().
//
//--------------------------------------------------------------------------

CPhysStorage::~CPhysStorage()
{
    ciDebugOut(( DEB_ITRACE, "Physical index %lx closed.\n", _objectId ));

    _cache.Free( FALSE );
}

//+-------------------------------------------------------------------------
//
//  Member:     CPhysStorage::Close, public
//
//  Effects:    Closes the stream.
//
//  History:    07-Mar-92 KyleP    Created
//
//--------------------------------------------------------------------------

void CPhysStorage::Close()
{
    _cache.Free();
    _stream.Free();
}

//+---------------------------------------------------------------------------
//
//  Function:   Flush
//
//  Synopsis:   Flushes all the pages that were unmapped since the last
//              flush.
//
//  History:    4-29-94   srikants   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

void CPhysStorage::Flush( BOOL fLeaveFlushFlagAlone )
{
    Win4Assert( _fWritable );

    // Grab the lock to make sure the pages aren't deleted while
    // they are being flushed.

    if ( 0 == _cMaxCachedBuffers )
    {
        CLock lock( _xMutex.GetReference() );

        _cache.Flush( ULONG_MAX, fLeaveFlushFlagAlone );
    }
    else
    {
        CReadAccess readLock( _xRWAccess.GetReference() );

        _cache.Flush( ULONG_MAX, fLeaveFlushFlagAlone );
    }
} //Flush

//+---------------------------------------------------------------------------
//
//  Function:   ShrinkToFit
//
//  Synopsis:   Reduces the size of the stream by giving up pages in the end
//              which are not needed.
//
//  Arguments:  (none)
//
//  History:    9-08-94   srikants   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

void CPhysStorage::ShrinkToFit()
{
    _cache.Free();
    _stream->SetSize( _storage,
                      PageToLow(_cpageUsedFileSize),
                      PageToHigh(_cpageUsedFileSize) );
    _cpageFileSize = _cpageUsedFileSize;
}

//+-------------------------------------------------------------------------
//
//  Member:     CPhysStorage::Reopen, public
//
//  Synopsis:   Flushes, closes, and reopens for reading.
//
//  History:    09-Mar-92 KyleP     Created
//              26-Aug-92 BartoszM  Separated from destructor
//              06-May-94 Srikants  Add fSetSize as a parameter to truncate
//                                  the stream optionally.
//
//--------------------------------------------------------------------------
void CPhysStorage::Reopen( BOOL fWritable )
{
    // No need to lock.

    _cache.Free(); // will flush all buffers

    if ( _fWritable && !_stream.IsNull() )
    {
        //
        // Give it an accurate used length.
        //

        _stream->SetSize( _storage,
                          PageToLow(_cpageUsedFileSize),
                          PageToHigh(_cpageUsedFileSize) );

        _cpageFileSize = _cpageUsedFileSize;

        _stream.Free();

        //
        // reopen shadow indexes as read and master indexes as write to
        // support shrink from front.
        //

        _fWritable = fWritable;
    }

    //
    // reopen it with the new mode
    //

    ReOpenStream();

    if ( _stream.IsNull() || !_stream->Ok() )
    {
        ciDebugOut(( DEB_ERROR, "Re-Open file of index %08x failed\n",
                     _objectId ));

        if ( _fThrowCorruptErrorOnFailures || _stream->FStatusFileNotFound() )
        {
           //
           // We don't have code to handle such failures, hence mark
           // catalog as corrupt; otherwise throw e_fail
           //
           Win4Assert( !"Corrupt catalog" );
           _storage.ReportCorruptComponent( L"PhysStorage3" );
           THROW( CException( CI_CORRUPT_DATABASE ));
        }
        else
           THROW( CException( E_FAIL ));
    }

    _cpageFileSize = ToPages(_stream->SizeLow(), _stream->SizeHigh());

    ciDebugOut(( DEB_ITRACE, "Physical index %08x opened.\n", _objectId ));
} //Reopen

//+-------------------------------------------------------------------------
//
//  Member:     CPhysStorage::LokBorrowNewBuffer, public
//
//  Arguments:  [hash]        -- hash value for doing the lookup
//              [commonPage]] -- the common page of nPage
//              [nPage]       -- page number
//
//  Returns:    A buffer for a new (unused) page.
//
//  History:    03-Mar-98 dlee    Created from existing BorrowNewBuffer
//
//  Notes:      On creation, the buffer is filled with zeros.
//
//--------------------------------------------------------------------------

ULONG * CPhysStorage::LokBorrowNewBuffer(
    ULONG hash,
    ULONG commonPage,
    ULONG nPage )
{
    CPhysBuffer* pBuf = _cache.Search( hash, commonPage );

    if (pBuf)
    {
        pBuf->Reference();
        Win4Assert( nPage < _cpageFileSize );

        // fIntentToWrite should be TRUE

        pBuf->SetIntentToWrite();
    }
    else
    {
        // If we've moved beyond the previous end of file, set the new
        // size of file.

        if ( nPage >= _cpageFileSize )
            _GrowFile( nPage + _cpageGrowth );

        // First try to release unreferenced buffers if the cache is full.

        _cache.TryToRemoveBuffers( _cMaxCachedBuffers );

        pBuf = new CPhysBuffer( _stream.GetReference(),
                                nPage,
                                TRUE,          // writable
                                TRUE,          // intent to write
                                ! ( _fAllowReadAhead &&
                                    _storage.FavorReadAhead() ) );
        _cache.Add( pBuf, hash );
    }

    Win4Assert( nPage + 1 > _cpageUsedFileSize );

    _cpageUsedFileSize = nPage + 1;
    Win4Assert( _cpageUsedFileSize <= _cpageFileSize );

    RtlZeroMemory( pBuf->GetPage( nPage ), CI_PAGE_SIZE );

    return pBuf->GetPage( nPage );
} //LokBorrowNewBuffer

//+-------------------------------------------------------------------------
//
//  Member:     CPhysStorage::BorrowNewBuffer, public
//
//  Arguments:  [nPage] -- page number
//
//  Returns:    A buffer for a new (unused) page.
//
//  Signals:    No more disk space.
//
//  History:    09-Mar-92 KyleP     Created
//
//  Notes:      On creation, the buffer is filled with zeros.
//
//--------------------------------------------------------------------------

ULONG * CPhysStorage::BorrowNewBuffer( ULONG nPage )
{
    Win4Assert( _fWritable );

    ULONG commonPage = PgCommonPgTrunc( nPage );
    ULONG hash = _cache.hash( commonPage );

    // Use appropriate locking based on whether any pages are in the cache.

    if ( 0 == _cMaxCachedBuffers )
    {
        CLock lock( _xMutex.GetReference() );

        return LokBorrowNewBuffer( hash, commonPage, nPage );
    }
    else
    {
        CWriteAccess writeLock( _xRWAccess.GetReference() );

        return LokBorrowNewBuffer( hash, commonPage, nPage );
    }
} //BorrowNewBuffer

//+-------------------------------------------------------------------------
//
//  Member:     CPhysStorage::LokBorrowOrAddBuffer, public
//
//  Arguments:  [hash]           -- hash value for doing the lookup
//              [commonPage]]    -- the common page of nPage
//              [nPage]          -- page number
//              [fAdd]           -- if TRUE, create the page if not found
//                                  if FALSE and not found, return 0
//              [fWritable]      -- if TRUE, the page is writable
//              [fIntentToWrite] -- TRUE if the caller intends to write
//
//  Returns:    A buffer loaded with page [nPage]
//
//  History:    09-Mar-92 KyleP     Created
//
//--------------------------------------------------------------------------

ULONG * CPhysStorage::LokBorrowOrAddBuffer(
    ULONG hash,
    ULONG commonPage,
    ULONG nPage,
    BOOL  fAdd,
    BOOL  fWritable,
    BOOL  fIntentToWrite )
{
    // First, look in the cache.  Either we haven't looked yet (if no
    // caching) or another thread may have added it between the time the
    // read lock was released and the write lock taken.

    Win4Assert( commonPage >= _iFirstNonShrunkPage );
    CPhysBuffer * pbuf = _cache.Search( hash, commonPage );

    if ( 0 != pbuf )
    {
        Win4Assert( !fWritable || pbuf->IsWritable() );

        pbuf->Reference();
        if ( fIntentToWrite )
            pbuf->SetIntentToWrite();

        return pbuf->GetPage( nPage );
    }

    ULONG * pulRet = 0;

    if ( fAdd )
    {
        pbuf = new CPhysBuffer( _stream.GetReference(),
                                nPage,
                                fWritable,
                                fIntentToWrite,
                                ! ( _fAllowReadAhead &&
                                    _storage.FavorReadAhead() ) );
    
        _cache.Add( pbuf, hash );
        pulRet = pbuf->GetPage( nPage );
    
        // Try to release unreferenced buffers if the cache is full.
    
        _cache.TryToRemoveBuffers( _cMaxCachedBuffers );
    }

    return pulRet;
} //LokBorrowOrAddBuffer

//+-------------------------------------------------------------------------
//
//  Member:     CPhysStorage::BorrowBuffer, public
//
//  Arguments:  [nPage] -- Page number of buffer to find.
//
//  Returns:    A buffer loaded with page [nPage]
//
//  Signals:    Out of memory?  Buffer not found?
//
//  History:    09-Mar-92 KyleP     Created
//
//--------------------------------------------------------------------------

ULONG * CPhysStorage::BorrowBuffer(
    ULONG nPage,
    BOOL  fWritable,
    BOOL  fIntentToWrite )
{
    ULONG commonPage = PgCommonPgTrunc( nPage );
    ULONG hash = _cache.hash( commonPage );

    Win4Assert( fWritable || !fIntentToWrite );

    // Make sure we didn't walk off the end.

    if ( nPage >= _cpageFileSize )
    {
        ciDebugOut(( DEB_WARN, "Asking for page %d, file size %d pages\n",
                     nPage, _cpageFileSize ));
        Win4Assert( !"BorrowBuffer walked off end of file" );

        _storage.ReportCorruptComponent( L"PhysStorage4" );

        THROW( CException( CI_CORRUPT_DATABASE ) );
    }

    // If caching, try finding it in the cache first under a read lock
    // This is the fast path for when the entire property cache is in memory.

    if ( 0 != _cMaxCachedBuffers )
    {
        CReadAccess readLock( _xRWAccess.GetReference() );

        ULONG * p = LokBorrowOrAddBuffer( hash, commonPage, nPage, FALSE,
                                          fWritable, fIntentToWrite );
        if ( 0 != p )
            return p;
    }

    // Ok, maybe we have to add it.

    if ( 0 == _cMaxCachedBuffers )
    {
        CLock lock( _xMutex.GetReference() );

        return LokBorrowOrAddBuffer( hash, commonPage, nPage, TRUE,
                                     fWritable, fIntentToWrite );
    }
    else
    {
        CWriteAccess writeLock( _xRWAccess.GetReference() );

        return LokBorrowOrAddBuffer( hash, commonPage, nPage, TRUE,
                                     fWritable, fIntentToWrite );
    }
} //BorrowBuffer

//+-------------------------------------------------------------------------
//
//  Member:     CPhysStorage::ReturnBuffer, public
//
//  Synopsis:   Dereference and return the buffer to the pool.
//
//  Arguments:  [nPage]  -- Page number of buffer being returned.
//              [fFlush] -- TRUE if the buffer should be flushed if this
//                          is the last reference to the buffer.
//              [fFailFlush] -- TRUE if an exception should be raised if
//                              the flush fails.  Note that even if fFlush
//                              is FALSE, the buffer may still be flushed
//                              because previously it was borrowed with
//                              intent to write.
//
//  Notes:      If flush throws, this call doesn't return the buffer.
//
//  History:    16-Mar-93       BartoszM     Created
//
//--------------------------------------------------------------------------

void CPhysStorage::ReturnBuffer(
    ULONG nPage,
    BOOL  fFlush,
    BOOL  fFailFlush )
{
    ULONG commonPage = PgCommonPgTrunc( nPage );
    ULONG hash = _cache.hash( commonPage );

    // if caching is off, grab the write lock, else the read lock

    if ( 0 == _cMaxCachedBuffers )
    {
        CLock lock( _xMutex.GetReference() );

        Win4Assert( commonPage >= _iFirstNonShrunkPage );
        CPhysBuffer *pbuf = _cache.Search( hash, commonPage );

        Win4Assert( 0 != pbuf );
        Win4Assert( pbuf->IsReferenced() );

        // If the refcount is 1, it's about to be destroyed.  Do the Flush
        // now, in case it fails, before mucking with any data structures.

        BOOL fDestroy = pbuf->IsRefCountOne();

        if ( fDestroy && fFlush )
        {
            Win4Assert( pbuf->IsWritable() );
            pbuf->Flush( fFailFlush );
        }

        pbuf->DeReference( _usnGen++ );

        if ( fDestroy )
        {
            Win4Assert( !pbuf->IsReferenced() );

            _cache.Destroy( nPage, fFailFlush );
            Win4Assert( !_cache.Search( hash, commonPage ) );
        }
    }
    else
    {
        CReadAccess readLock( _xRWAccess.GetReference() );

        Win4Assert( commonPage >= _iFirstNonShrunkPage );
        CPhysBuffer *pbuf = _cache.Search( hash, commonPage );

        Win4Assert( 0 != pbuf );
        Win4Assert( pbuf->IsReferenced() );

        if ( fFlush )
        {
            Win4Assert( pbuf->IsWritable() );

            if ( pbuf->IsRefCountOne() )
                pbuf->Flush( fFailFlush );
        }

        pbuf->DeReference( _usnGen++ );

        // leave it in the cache -- it'll be cleared out by BorrowBuffer
    }
} //ReturnBuffer

//+-------------------------------------------------------------------------
//
//  Member:     CPhysStorage::RequiresFlush, public
//
//  Synopsis:   Determines if the page is scheduled for flushing
//
//  Arguments:  [nPage]  -- Page number to check
//
//  Returns:    TRUE if the buffer will be flushed if Flush or Destroy is
//              called.
//
//  History:    3-Nov-98       dlee     Created
//
//--------------------------------------------------------------------------

BOOL CPhysStorage::RequiresFlush( ULONG nPage )
{
    ULONG commonPage = PgCommonPgTrunc( nPage );
    ULONG hash = _cache.hash( commonPage );

    // if caching is off, grab the write lock, else the read lock

    if ( 0 == _cMaxCachedBuffers )
    {
        CLock lock( _xMutex.GetReference() );

        Win4Assert( commonPage >= _iFirstNonShrunkPage );
        CPhysBuffer *pbuf = _cache.Search( hash, commonPage );

        Win4Assert( 0 != pbuf );
        Win4Assert( pbuf->IsReferenced() );

        return pbuf->RequiresFlush();
    }
    else
    {
        CReadAccess readLock( _xRWAccess.GetReference() );

        Win4Assert( commonPage >= _iFirstNonShrunkPage );
        CPhysBuffer *pbuf = _cache.Search( hash, commonPage );

        Win4Assert( 0 != pbuf );
        Win4Assert( pbuf->IsReferenced() );

        return pbuf->RequiresFlush();
    }
} //RequiresFlush

//+-------------------------------------------------------------------------
//
//  Member:     CPhysStorage::_GrowFile, private
//
//  Synopsis:   Increases the physical (disk) size of the file.
//
//  Arguments:  [cpageSize] -- New file size, in pages.
//
//  Signals:    Out of space.
//
//  History:    09-Mar-92 KyleP     Created
//
//--------------------------------------------------------------------------

void CPhysStorage::_GrowFile( ULONG cpageSize )
{
    Win4Assert( cpageSize > 0 );

    cpageSize = PgCommonPgRound(cpageSize);

    ciDebugOut(( DEB_ITRACE, "  Growing Index to %d pages\n", cpageSize ));

    _stream->SetSize( _storage,
                      PageToLow(cpageSize),
                      PageToHigh(cpageSize) );

    if (!_stream->Ok())
    {
        ciDebugOut(( DEB_ERROR, "GrowFile of index %08x failed: %d\n",
                     _objectId ));

        if ( _fThrowCorruptErrorOnFailures )
        {
           //
           // We don't have code to handle such failures, hence mark
           // catalog as corrupt; otherwise throw e_fail
           //
           Win4Assert( !"Corrupt catalog" );
           _storage.ReportCorruptComponent( L"PhysStorage5" );
           THROW( CException( CI_CORRUPT_DATABASE ) );
        }
        else
           THROW( CException( E_FAIL ) );
    }

    _cpageFileSize = cpageSize;
} //_GrowFile

//+-------------------------------------------------------------------------
//
//  Member:     CPhysStorage::ShrinkFromFront, public
//
//  Synopsis:   Makes the front part of a file sparse
//
//  Arguments:  [iFirstPage] -- first 4k page -- 64k granular
//              [cPages]     -- number of 4k pages
//
//  Returns:    The # of 4k pages actually shrunk, maybe 0
//
//  History:    09-Jan-97 dlee     Moved from .hxx
//
//--------------------------------------------------------------------------

ULONG CPhysStorage::ShrinkFromFront(
    ULONG iFirstPage,
    ULONG cPages )
{
    ULONG cShrunk = 0;

    if ( _storage.SupportsShrinkFromFront() )
    {
        //
        // Make sure the caller isn't leaving any gaps and was paying
        // attention to the return value from previous calls.
        //

        Win4Assert( iFirstPage == _iFirstNonShrunkPage );

        //
        // We must shrink on common page boundaries since we borrow on
        // common pages (even though the api is page granular)
        //

        ULONG cPagesToShrink = PgCommonPgTrunc( cPages );

        if ( 0 == cPagesToShrink )
            return 0;

        Win4Assert( _iFirstNonShrunkPage ==
                    PgCommonPgTrunc( _iFirstNonShrunkPage ) );
        Win4Assert( iFirstPage == PgCommonPgTrunc( iFirstPage ) );

        // Take a lock so no one else tries to borrow or free any pages

        Win4Assert ( 0 == _cMaxCachedBuffers );

        CLock lock( _xMutex.GetReference() );

        cShrunk = _stream->ShrinkFromFront( iFirstPage, cPagesToShrink );
        Win4Assert( cShrunk == PgCommonPgTrunc( cShrunk ) );

        _iFirstNonShrunkPage += cShrunk;
    }

    return cShrunk;
} //ShrinkFromFront

//+-------------------------------------------------------------------------
//
//  Member:     CPhysStorage::MinPageInUse, public
//
//  Synopsis:   Finds the smallest page in use within the cache
//
//  Arguments:  [minPage] -- returns the result
//
//  Returns :   TRUE if any page is in the cache; FALSE o/w
//              If TRUE is returned, then minPage will contain the
//              minimum page that is present in the cache.
//
//  History:    26-Mar-98 dlee     Moved from .hxx
//
//--------------------------------------------------------------------------

BOOL CPhysStorage::MinPageInUse( ULONG &minPage )
{
    if ( 0 == _cMaxCachedBuffers )
    {
        CLock lock( _xMutex.GetReference() );

        return _cache.MinPageInUse(minPage);
    }
    else
    {
        CReadAccess readLock( _xRWAccess.GetReference() );

        return _cache.MinPageInUse(minPage);
    }
} //MinPageInUse
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\ntciutil\perfobj.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1993 - 1999.
//
//  File:       perfobj.cxx
//
//  Contents:   Performance Data Object
//
//  Classes :   CPerfMon
//
//  History:    23-March-94     t-joshh    Created
//              14-Jan-98       dlee       Cleanup
//              10-May-99       dlee       More cleanup
//
//----------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include <smem.hxx>
#include <mutex.hxx>
#include <perfci.hxx>
#include <perfobj.hxx>
#include <ciregkey.hxx>

DECLARE_INFOLEVEL(Perf)

//
// Total size occupied by the filter and CI counters
//

//+---------------------------------------------------------------------------
//
//  Function :  ComputeCIPerfmonVars
//
//  Purpose :   Computes sizes of various data structures that deal with
//              CI perfmon counters.
//
//  Arguments : [cMaxCats]      -- Returns the maximum number of catalogs
//                                 that can be open at once.
//              [cbCatBitfield] -- Returns the count of bytes needed for
//                                 the bitfield used to keep track of
//                                 the slots in the shared memory allocated
//                                 for each catalog's perfmon info.  There
//                                 is one slot per catalog.
//              [cbPerfHeader]  -- Returns the count of bytes at the start
//                                 of the shared memory used for header info.
//                                 After the header comes the catalog slots.
//              [cbSharedMem]   -- Returns the count of bytes of the shared
//                                 memory buffer.
//
//  History :   5-April-99     dlee     Created
//
//----------------------------------------------------------------------------

void ComputeCIPerfmonVars(
    ULONG & cMaxCats,
    ULONG & cbCatBitfield,
    ULONG & cbPerfHeader,
    ULONG & cbSharedMem )
{
    cMaxCats = GetMaxCatalogs();

    //
    // The bitfield must be large enough to hold 1 bit per catalog, rounded
    // up to the closest byte.
    //

    cbCatBitfield = AlignBlock( cMaxCats, cBitsPerByte ) / cBitsPerByte;
    cbCatBitfield = AlignBlock( cbCatBitfield, sizeof DWORD );

    //
    // The header includes the # of instances, the bitfield, and 2 sequence
    // number integers.
    //

    cbPerfHeader = ( 3 * sizeof( int ) ) + cbCatBitfield;

    //
    // The shared memory must be large enough for the header and 1 slot for
    // each catalog.  Each slot consists of an int header, the actual
    // counters, and the name of the catalog.
    //

    cbSharedMem = cbPerfHeader + ( cMaxCats * cbPerfCatalogSlot );

    ciDebugOut(( DEB_ITRACE, "header: %d, each %d\n", cbPerfHeader, cbPerfCatalogSlot ));

    ciDebugOut(( DEB_ITRACE, "cbSharedMem: %#x\n", cbSharedMem ));

    // Round the shared memory up to a page size

    SYSTEM_INFO si;
    GetSystemInfo( &si );
    cbSharedMem = AlignBlock( cbSharedMem, si.dwPageSize );

    ciDebugOut(( DEB_ITRACE, "cbSharedMem: after %#x\n", cbSharedMem ));
} //ComputeCIPerfmonVars

//+---------------------------------------------------------------------------
//
//  Function :  CPerfMon::CPerfMon
//
//  Purpose :   Constructor
//
//  Arguments : [wszInstanceName] -- name of the performance object
//
//  History :   23-March-94     t-joshh     Created
//
//----------------------------------------------------------------------------

CPerfMon::CPerfMon (
   const WCHAR * wszInstanceName ) :
   _cCounters( FILTER_TOTAL_NUM_COUNTERS + CI_TOTAL_NUM_COUNTERS ),
   _pdwSharedMemory( 0 ),
   _pcCount( 0 ),
   _pbBitfield( 0 ),
   _pSeqNo(0),
   _iWhichSlot( 0 ),
   _piNumberAttach( 0 )
{
    ULONG cMaxCats, cbCatBitfield, cbPerfHeader, cbSharedMem;

    ComputeCIPerfmonVars( cMaxCats, cbCatBitfield, cbPerfHeader, cbSharedMem );

    // Open the performance object

    _SharedMemObj.CreateForWriteFromRegKey( CI_PERF_MEM_NAME,
                                            cbSharedMem,
                                            wcsContentIndexPerfKey );

    if ( !_SharedMemObj.Ok() )
        THROW( CException( E_OUTOFMEMORY ) );

    _xPerfMutex.Set( new CNamedMutex() );

     _xPerfMutex->Init( CI_PERF_MUTEX_NAME );

    CNamedMutexLock lock( _xPerfMutex.GetReference() );

    // Fill in the number of instances

    _pcCount = (int *) _SharedMemObj.Get();
    _pbBitfield = ((BYTE *)_SharedMemObj.Get() + sizeof(int));
    _pSeqNo = (UINT *) ( _pbBitfield + cbCatBitfield );

    //
    // First, check whether there already exist a block in the memory assigned to
    // the specified object. If existed, just assign the existing block.
    // If not, assign a non-occupied block.
    //

    int iFirstEmpty = -1;
    int iTmpCount = *_pcCount;

    //
    // Copy the instance (catalog) name or just the prefix that fits
    //

    unsigned cwc = wcslen( wszInstanceName );
    cwc = __min( cwc, CI_PERF_MAX_CATALOG_LEN - 1 );
    WCHAR awcName[ CI_PERF_MAX_CATALOG_LEN ];
    RtlCopyMemory( awcName, wszInstanceName, cwc * sizeof WCHAR );
    awcName[ cwc ] = 0;

    CBitfield bits( _pbBitfield );

    for ( int i = 0;
          i < (int) cMaxCats && (iTmpCount > 0 || iFirstEmpty == -1);
          i++ )
    {
        if ( !bits.IsBitSet( i ) )
        {
            if (iFirstEmpty == -1)
                iFirstEmpty = i;
        }
        else
        {
            ULONG ulByte = cbPerfHeader + (i * cbPerfCatalogSlot) + sizeof(int);

            if ( 0 == wcscmp( (WCHAR *) ((BYTE *)_SharedMemObj.Get() + ulByte), awcName ) )
            {
                _iWhichSlot = i;
                break;
            }

            iTmpCount--;
        }
    }

    if ( iTmpCount <= 0 )
    {
        _iWhichSlot = iFirstEmpty;
        bits.SetBit( _iWhichSlot );
        *_pcCount += 1;
    }

    //
    // The catarray protects us agains opening too many catalogs, but the
    // user can change MaxCatalogs in the registry at any time...
    //

    if ( -1 == _iWhichSlot )
    {
        Win4Assert( !"too many catalogs open!" );
        THROW( CException( E_INVALIDARG ) );
    }

    //
    // Update the sequence number
    //

    *_pSeqNo += 1;

    PerfDebugOut(( DEB_ITRACE, "@@@ Writer : Sequence Number %d \n", *_pSeqNo ));
    PerfDebugOut(( DEB_ITRACE, "@@@ Writer : Chosen Block %d No. of Instance %d\n", _iWhichSlot, *_pcCount));

    ULONG ulByteToSkip = cbPerfHeader + ( _iWhichSlot * cbPerfCatalogSlot );

    //
    // Increment the number of PerfMon object attached to this slot by 1
    //

    _piNumberAttach = (int *) ((BYTE *)_SharedMemObj.Get() + ulByteToSkip);
    PerfDebugOut(( DEB_ITRACE, "@@@ Writer : Number of Object Attached : %d\n", *_piNumberAttach));
    *_piNumberAttach += 1;

    ulByteToSkip += sizeof(int);

    //
    // Fill the name of the instance into the shared memory
    //
    wcscpy( (WCHAR *)((BYTE *)_SharedMemObj.Get() + ulByteToSkip), awcName );

    //
    // Assign a block of memory space for each instance
    //

    _pdwSharedMemory = ((DWORD *) ( (BYTE *)_SharedMemObj.Get()
                                    + ulByteToSkip
                                    + ( CI_PERF_MAX_CATALOG_LEN * sizeof WCHAR ) ) );

    PerfDebugOut(( DEB_ITRACE, "@@@ Writer : Done with Initialize CPerfMon \n"));
} //CPerfMon

//+---------------------------------------------------------------------------
//
//  Function :  CPerfMon::~CPerfMon
//
//  Purpose :   Destructor
//
//  Arguments : none
//
//  History :   23-March-94     t-joshh     Created
//
//----------------------------------------------------------------------------

CPerfMon::~CPerfMon()
{
    CNamedMutexLock lock( _xPerfMutex.GetReference() );

    if ( 1 == *_piNumberAttach )
    {
        //
        // Since the current CPerfMon is the last one using the slot, the
        // slot will be cleaned up and the number of instances reduce by 1
        //

        *_pcCount -= 1;
        PerfDebugOut(( DEB_ITRACE, "~CPerfMon : No. of Instance become %d\n", *_pcCount));

        CBitfield bits( _pbBitfield );

        bits.ClearBit( _iWhichSlot );
        RtlZeroMemory( (void *)_piNumberAttach, cbPerfCatalogSlot );

        *_pSeqNo += 1; // Update the sequence number
        PerfDebugOut(( DEB_ITRACE, "~CPerfMon : Update SeqNo %d\n", *_pSeqNo ));
    }
    else
    {
        //
        // There are still some other CPerfMon object attached to this slot
        //

        *_piNumberAttach -= 1;
        PerfDebugOut(( DEB_ITRACE, " ~CPerfMon : Still have %d object attached\n", *_piNumberAttach));
    }
} //~CPerfMon
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\ntciutil\prcstob.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1991 - 2000.
//
//  File:       PRCSTOB.CXX
//
//  Contents:   Recoverable Storage Object
//
//  Classes:    PRcovStorageObj
//
//  History:    04-Feb-1994     SrikantS    Created
//
//----------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include <prcstob.hxx>
#include <eventlog.hxx>

//+---------------------------------------------------------------------------
//
//  Member:     PRcovStorageObj::VerifyConsistency
//
//  Synopsis:   This method checks the consistency of the recoverable storage
//              object by comparing the length of the primary stream with that
//              stored in the header.
//
//              Normally an inconsistency should never be there but this is for
//              those situations when something happened causing the inconsistency.
//
//  Effects:    If there is an inconsistency, the streams will be emptied out.
//
//  Arguments:  (none)
//
//  History:    3-22-94   srikants   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
void PRcovStorageObj::VerifyConsistency()
{
    Win4Assert( !IsOpen( CRcovStorageHdr::idxOne ) );
    Win4Assert( !IsOpen( CRcovStorageHdr::idxTwo ) );

    //
    // Verify the validity of signatures in the header.
    //
    if ( !_hdr.IsValid(_storage.GetStorageVersion()) )
    {
        PStorage  & storage = GetStorage();
        Win4Assert( !"Corrupt recoverable object" );
        storage.ReportCorruptComponent( L"RcovStorageObj1" );

        THROW( CException( CI_CORRUPT_DATABASE ) );
    }

    CRcovStorageHdr::DataCopyNum iPrim, iBack;
    iPrim = _hdr.GetPrimary();
    iBack = _hdr.GetBackup();

    //
    // First open the primary stream in a read-only mode and check
    // consistency.
    //
    Open( iPrim, FALSE );
    PMmStream & mmStrmPrim = GetMmStream( iPrim );

    LONGLONG llcbPrimary = _hdr.GetCbToSkip(iPrim) +
                           _hdr.GetUserDataSize(iPrim);

    LONGLONG cbPrimaryStream = mmStrmPrim.Size();

    BOOL fIsConsistent = llcbPrimary <= cbPrimaryStream;
    Close( iPrim );

    if ( !fIsConsistent )
    {
        ciDebugOut(( DEB_ERROR,
                     "PRcovStorageObj - this=0x%X Primary is not consistent\n",
                     this ));
        PStorage  & storage = GetStorage();

        // Don't assert as this can happen when you kill cisvc while
        // creating a catalog.  Current tests do this.

        //Win4Assert( !"Corrupt recoverable object" );

        ciDebugOut(( DEB_ERROR,
                     "llcbPrimary %#I64d, primary size %#I64d\n",
                     llcbPrimary, 
                     cbPrimaryStream ));

        storage.ReportCorruptComponent( L"RcovStorageObj2" );

        THROW( CException( CI_CORRUPT_DATABASE ) );
    }

    //
    // If the recoverable object is clean, the backup is excpected to be
    // consistent also.
    //
    if ( _hdr.IsBackupClean() )
    {
        //
        // Check the consistency of the backup stream also.
        //
        Open( iBack, FALSE );
        PMmStream & mmStrmBack = GetMmStream( iBack );

        LONGLONG llcbBackup = _hdr.GetCbToSkip(iBack) +
                              _hdr.GetUserDataSize(iBack);

        LONGLONG cbBackupStream = mmStrmBack.Size();

        fIsConsistent = llcbBackup <= cbBackupStream;

        Close( iBack );

        if ( !fIsConsistent )
        {
            ciDebugOut(( DEB_ERROR,
                "PRcovStorageObj - this=0x%X Backup is not consistent\n",
                this ));

            PStorage  & storage = GetStorage();
            Win4Assert( !"Corrupt recoverable object" );

            ciDebugOut(( DEB_ERROR,
                         "llcbBackup %#I64d, backup size %#I64d\n",
                         llcbBackup,
                         cbBackupStream ));

            storage.ReportCorruptComponent( L"RcovStorageObj3" );

            THROW( CException( CI_CORRUPT_DATABASE ) );
        }

        if ( llcbBackup != llcbPrimary )
        {
            ciDebugOut(( DEB_ERROR,
                         "PRcovStorageObj - this=0x%X Lengths not equal\n",
                         this ));
        }
    }
} //VerifyConsistency
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\ntciutil\pidtable.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996 - 2000.
//
//  File:       pidtable.cxx
//
//  Contents:   Property to PROPID mapping table
//
//  History:    02 Jan 1996   AlanW    Created
//
//----------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include <rcstxact.hxx>
#include <rcstrmit.hxx>
#include <pidtable.hxx>
#include <imprsnat.hxx>


const ULONG PIDTAB_INIT_HASH_SIZE = 17;
const ULONG MEASURE_OF_SLACK = 4;               // 80% full maximum

//
//  cchNamePart - number of WCHARs that will fit into a CPidLookupEntry
//
const unsigned cchNamePart = sizeof (CPidLookupEntry) / sizeof (WCHAR);



//+-------------------------------------------------------------------------
//
//  Method:     CPidLookupTable::CPidLookupTable, public
//
//  Synopsis:   Constructor of a CPidLookupTable
//
//  Arguments:  -NONE-
//
//  Returns:    Nothing
//
//--------------------------------------------------------------------------

CPidLookupTable::CPidLookupTable( )
    : _pTable( 0 ),
      _pchStringBase( 0 ),
      _cbStrings( 0 ),
      _cbStringUsed( 0 ),
#if !defined(UNIT_TEST)
      _xrsoPidTable( 0 ),
#endif // !defined(UNIT_TEST)
      _mutex()
{
#if  (DBG == 1)
    _iFillFactor = (100 * MEASURE_OF_SLACK) / (MEASURE_OF_SLACK + 1);
#endif // (DBG == 1)
}


void CPidLookupTable::Empty()
{
    delete [] _pTable; _pTable = 0;

    delete [] _pchStringBase;  _pchStringBase = 0;
    _cbStrings = _cbStringUsed = 0;

#if !defined(UNIT_TEST)
    delete _xrsoPidTable.Acquire();
#endif  // UNIT_TEST

}

CPidLookupTable::~CPidLookupTable( )
{
    delete [] _pchStringBase;
    delete [] _pTable;
}


//+-------------------------------------------------------------------------
//
//  Method:     CPidLookupTable::Init, public
//
//  Synopsis:   Initialize a CPidLookupTable
//
//  Arguments:  [cHash] - number of hash buckets to allocate
//
//  Returns:    Nothing
//
//--------------------------------------------------------------------------

void CPidLookupTable::Init( ULONG cHash )
{
    Win4Assert( _pTable == 0 );

    if ( cHash == 0 )
    {
        RtlCopyMemory( _Header.Signature, "PIDTABLE", sizeof _Header.Signature );
        _Header.cbRecord = sizeof (CPidLookupEntry);
        _Header.NextPropid = INIT_DOWNLEVEL_PID;
        cHash = PIDTAB_INIT_HASH_SIZE;
    }

    _pTable = new CPidLookupEntry [ cHash ];

    RtlZeroMemory( _pTable, cHash * sizeof (CPidLookupEntry) );

    _Header.cHash = cHash;
    _Header.cEntries = 0;

#if  (DBG == 1)
    Win4Assert( _iFillFactor > 10 && _iFillFactor <= 95);

    _maxEntries = (Size() * _iFillFactor) / 100;

    _cMaxChainLen = 0;
    _cTotalSearches = 0;
    _cTotalLength = 0;
#else  // (DBG != 1)
    _maxEntries = (Size() * MEASURE_OF_SLACK) / (MEASURE_OF_SLACK + 1);

#endif // (DBG == 1)

    Win4Assert(_maxEntries >= 5 && _maxEntries < Size());
}


#if !defined(UNIT_TEST)

//+---------------------------------------------------------------------------
//
//  Member:     CPidLookupTable::Init, public
//
//  Synopsis:   Loads metadata from persistent location into memory.
//
//  Arguments:  [pobj] -- Stream(s) in which metadata is stored.
//
//  History:    27-Dec-95   KyleP       Created.
//
//----------------------------------------------------------------------------

BOOL CPidLookupTable::Init( PRcovStorageObj * pObj )
{
    CLock lock ( _mutex );

    _xrsoPidTable.Set( pObj );

    //
    // Load header
    //

    CRcovStorageHdr & hdr = _xrsoPidTable->GetHeader();
    struct CRcovUserHdr data;
    hdr.GetUserHdr( hdr.GetPrimary(), data );

    RtlCopyMemory( &_Header, &data._abHdr, sizeof(_Header) );

    ciDebugOut(( DEB_PIDTABLE, "PIDTABLE: Record size = %d bytes\n", _Header.cbRecord ));
    ciDebugOut(( DEB_PIDTABLE, "PIDTABLE: %d properties stored\n", _Header.cEntries ));
    ciDebugOut(( DEB_PIDTABLE, "PIDTABLE: Hash size = %u\n", _Header.cHash ));
    ciDebugOut(( DEB_PIDTABLE, "PIDTABLE: Next Propid = %u\n", _Header.NextPropid ));

    if (_Header.cbRecord != 0)
    {
        Win4Assert( RtlEqualMemory( _Header.Signature, "PIDTABLE",
                                    sizeof _Header.Signature) &&
                    _Header.cbRecord == sizeof (CPidLookupEntry) &&
                    Entries() < Size() );
        if ( !RtlEqualMemory( _Header.Signature, "PIDTABLE",
                              sizeof _Header.Signature) ||
             _Header.cbRecord != sizeof (CPidLookupEntry) ||
             Entries() >= Size()
            )
           return FALSE;
    }
    else
    {
        Win4Assert( 0 == Entries() && 0 == Size() );
    }

    //
    // Load properties
    //

    ULONG cEntriesFromFile = Entries();
    Init( _Header.cHash );

    CRcovStrmReadTrans xact( _xrsoPidTable.GetReference() );
    CRcovStrmReadIter  iter( xact, sizeof( CPidLookupEntry ) );

    CPidLookupEntry temp;

    while ( !iter.AtEnd() )
    {
        iter.GetRec( &temp );

        if ( temp.IsPropertyName() )
        {
            temp.SetPropertyNameOffset( _cbStringUsed / sizeof (WCHAR) );

            Win4Assert( !iter.AtEnd() );

            BYTE* pPropName;
            ULONG cbName = iter.GetVariableRecSize();

            if ( _cbStringUsed + cbName > _cbStrings )
                GrowStringSpace( cbName );

            iter.GetVariableRecData( (void*)&_pchStringBase[_cbStringUsed / sizeof (WCHAR)],
                                     cbName );

            _cbStringUsed += cbName;

            ciDebugOut(( DEB_PIDTABLE,
                         "PIDTABLE: Named property\tpid = 0x%x, %ws\n",
                         temp.Pid(),
                         temp.GetPropertyNameOffset() + _pchStringBase ));

            if (cbName == 0 || cbName > MAX_PROPERTY_NAME_LEN)
            {
                ciDebugOut(( DEB_WARN,
                            "PIDTABLE: Invalid named property\tpid = 0x%x, %ws\n",
                             temp.Pid(),
                             temp.GetPropertyNameOffset() + _pchStringBase ));
                return FALSE;
            }
        }
        else
        {
            ciDebugOut(( DEB_PIDTABLE,
                         "PIDTABLE: Numbered property\tpid = 0x%x, propid = %u\n",
                         temp.Pid(),
                         temp.GetPropertyPropid() ));

            Win4Assert ( temp.IsPropertyPropid() );
            if ( ! temp.IsPropertyPropid() )
                return FALSE;
        }

        if ( temp.Pid() < INIT_DOWNLEVEL_PID )
        {
            ciDebugOut(( DEB_WARN,
                        "PIDTABLE: Invalid propid\tpid = 0x%x\n",
                         temp.Pid() ));
            return FALSE;
        }

        StoreInTable(temp);
    }

    Win4Assert( Entries() == cEntriesFromFile );

    return TRUE;
}

#endif // !defined(UNIT_TEST)

//+---------------------------------------------------------------------------
//
//  Member:     CPidLookupTable::MakeBackupCopy
//
//  Synopsis:   Makes a backup copy of the persistent pid table.
//
//  Arguments:  [dstObj]  - Destination object.
//              [tracker] - Save progress tracker.
//
//  History:    3-20-97   srikants   Created
//
//----------------------------------------------------------------------------

void CPidLookupTable::MakeBackupCopy( PRcovStorageObj & dstObj,
                                      PSaveProgressTracker & tracker )
{
    Win4Assert(  !_xrsoPidTable.IsNull() );
    CCopyRcovObject copier( dstObj, _xrsoPidTable.GetReference() );
    copier.DoIt();
}

//+-------------------------------------------------------------------------
//
//  Method:     CPidLookupTable::Hash, private
//
//  Synopsis:   Hash a CFullPropSpec value for use in a hash table.
//
//  Arguments:  [rProp] - a reference to the CFullPropSpec to be hashed
//
//  Returns:    ULONG - Hash value for the input CFullPropSpec
//
//  Notes:      The hash function xors only a few selected fields out
//              of the GUID structure.  It is intended to work well for
//              both generated GUIDs (from UuidCreate) and administratively
//              assigned GUIDs.
//
//--------------------------------------------------------------------------

ULONG CPidLookupTable::Hash(
    const CFullPropSpec & rProp )
{
    const GUID & rGuid = rProp.GetPropSet();

    ULONG ulHash =  (rGuid.Data1 ^
                     (rGuid.Data4[0] << 16) ^
                     (rGuid.Data4[6] << 8) ^
                     (rGuid.Data4[7]));

    if (rProp.IsPropertyPropid())
    {
        ulHash ^= (1 << 24) | rProp.GetPropertyPropid();
    }
    else
    {
        ulHash ^= HashString(rProp.GetPropertyName());
    }
    return ulHash;
}


//+-------------------------------------------------------------------------
//
//  Method:     CPidLookupTable::Hash, private
//
//  Synopsis:   Hash a CPidLookupEntry value (for rehashing)
//
//  Arguments:  [rProp] - a reference to the CPidLookupEntry to be hashed
//
//  Returns:    ULONG - Hash value for the input CPidLookupEntry
//
//  Notes:      The hash function xors only a few selected fields out
//              of the GUID structure.  It is intended to work well for
//              both generated GUIDs (from UuidCreate) and administratively
//              assigned GUIDs.
//
//--------------------------------------------------------------------------

ULONG CPidLookupTable::Hash(
    const CPidLookupEntry & rProp )
{
    const GUID & rGuid = rProp.GetPropSet();

    ULONG ulHash =  (rGuid.Data1 ^
                     (rGuid.Data4[0] << 16) ^
                     (rGuid.Data4[6] << 8) ^
                     (rGuid.Data4[7]));

    if (rProp.IsPropertyPropid())
    {
        ulHash ^= (1 << 24) | rProp.GetPropertyPropid();
    }
    else
    {
        const WCHAR * pwszStr = rProp.GetPropertyNameOffset() +
                                _pchStringBase;

        ulHash ^= HashString(pwszStr);
    }
    return ulHash;
}


//+-------------------------------------------------------------------------
//
//  Method:     CPidLookupTable::HashString, private
//
//  Synopsis:   Hash a string from a property name.
//
//  Arguments:  [pwszStr] - the string to be hashed
//
//  Returns:    ULONG - Hash value for the input string
//
//  Notes:      Property names are assumed to be mapped to lower case.
//
//--------------------------------------------------------------------------

ULONG CPidLookupTable::HashString( const WCHAR * pwszStr )
{
    ULONG ulStrHash = 0;

    while ( *pwszStr != L'\0' )
    {
       ulStrHash = (ulStrHash << 1) ^ (*pwszStr++);
    }

    return ulStrHash;
}


//+---------------------------------------------------------------------------
//
//  Method:     CPidLookupTable::LookUp, private
//
//  Synopsis:   Looks up a property in the hash table.
//
//  Arguments:  [Prop]    - Property to look up.
//              [riTable] - (output) Will contain the index in the hash
//                          table of the entry if found.
//
//  Returns:    TRUE if found; FALSE o/w
//
//  History:    02 Jan 1996   Alanw   Created
//
//  Notes:      On failure, riTable will point to an empty entry.
//
//----------------------------------------------------------------------------

BOOL CPidLookupTable::LookUp( const CFullPropSpec & Prop, ULONG &riTable )
{
    Win4Assert( 0 != Size() );
    Win4Assert( !IsFull() );

    ULONG   iCur = Hash( Prop ) % Size();
    ULONG   iStart = iCur;
    ULONG   iDelta = iCur;

#if DBG==1
    ULONG   cSearchLen = 1;
#endif  // DBG==1

    BOOL fFound = FALSE;
    while ( !fFound && ! _pTable[iCur].IsFree() )
    {

        if ( _pTable[iCur].IsEqual( Prop, _pchStringBase ) )
        {
            fFound = TRUE;
        }
        else
        {
            iCur = (iCur + iDelta) % Size();
            if ( iCur == iStart )     // wrapped around
            {
                if ( 1 != iDelta )
                {
                    iDelta = 1;
                    iCur = (iCur + 1) % Size();
                }
                else
                {
                    Win4Assert( ! "Failed to find empty hash table entry" );
                    break;
                }
            }

#if DBG==1
        cSearchLen++;
#endif  // DBG==1

        }
    }

#if DBG==1
    _cTotalSearches++;
    _cTotalLength += cSearchLen;
    if (cSearchLen > _cMaxChainLen)
        _cMaxChainLen = cSearchLen;
#endif  // DBG==1

    riTable = iCur;

    if (!fFound)
    {
        Win4Assert( _pTable[iCur].IsFree() );
    }
    return fFound;
}


//+---------------------------------------------------------------------------
//
//  Method:     CPidLookupTable::StoreInTable, private
//
//  Synopsis:   Stores a CPidLookupEntry in the hash table.
//
//  Arguments:  [Prop]    - Property to store; must not be in the table
//
//  Returns:    NOTHING
//
//  History:    02 Jan 1996   Alanw   Created
//
//  Notes:      This function is used in rehashing and the initial load of
//              the table.  It is not expected to find the property, but it
//              returns the slot in which the entry should be placed.
//
//----------------------------------------------------------------------------

void CPidLookupTable::StoreInTable( const CPidLookupEntry & Prop )
{
    Win4Assert( 0 != Size() );
    Win4Assert( !IsFull() );

    ULONG   iCur = Hash( Prop ) % Size();
    ULONG   iStart = iCur;
    ULONG   iDelta = iCur;

#if DBG==1
    ULONG   cSearchLen = 1;
#endif  // DBG==1

    while ( ! _pTable[iCur].IsFree() )
    {

#if DBG==1
        if (Prop.IsPropertyPropid())
        {
            Win4Assert( !_pTable[iCur].IsPropertyPropid() ||
                   Prop.GetPropertyPropid() != _pTable[iCur].GetPropertyPropid() ||
                   Prop.GetPropSet() != _pTable[iCur].GetPropSet());
        }
        else
        {
            Win4Assert( !_pTable[iCur].IsPropertyName() ||
                   Prop.GetPropSet() != _pTable[iCur].GetPropSet() ||
                   _wcsicmp( Prop.GetPropertyNameOffset() +
                                  _pchStringBase,
                            _pTable[iCur].GetPropertyNameOffset() +
                                  _pchStringBase) != 0);
        }
#endif  // DBG==1

        iCur = (iCur + iDelta) % Size();
        if ( iCur == iStart )     // wrapped around
        {
            if ( 1 != iDelta )
            {
                iDelta = 1;
                iCur = (iCur + 1) % Size();
            }
            else
            {
                Win4Assert( ! "Failed to find empty hash table entry" );
                break;
            }
        }

#if DBG==1
        cSearchLen++;
#endif  // DBG==1

    }

#if DBG==1
    if (cSearchLen > _cMaxChainLen)
        _cMaxChainLen = cSearchLen;
#endif  // DBG==1

    _pTable[iCur] = Prop;
    _Header.cEntries++;
}


//+---------------------------------------------------------------------------
//
//  Method:     CPidLookupTable::GrowSize, private
//
//  Synopsis:   For a given valid hash table entries, this routine figures
//              out the next valid size (close approximation to a prime).
//
//  Arguments:  - NONE -
//
//  Returns:    The size of the hash table for the given number of valid
//              entries.
//
//  History:    1-09-95   srikants   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

ULONG CPidLookupTable::GrowSize ( void ) const
{
    ULONG size = Size() + 2;

    for (unsigned i = 0; i < g_cPrimes && g_aPrimes[i] < size; i++)
        ;

    if (i < g_cPrimes)
        return g_aPrimes[i];

    // make it power of two - 1
    // a good approximation of a prime

    for ( unsigned sizeInit = 1; sizeInit < size; sizeInit *= 2 )
        continue;

    return (sizeInit - 1);
} //GrowSize


//+---------------------------------------------------------------------------
//
//  Method:     CPidLookupTable::AddEntry, private
//
//  Synopsis:   Adds a property entry in the hash table.
//
//  Arguments:  [Prop]    - Property to Add
//
//  Returns:    ULONG - the index of the entry used to store the property
//
//  History:    02 Jan 1996   Alanw   Created
//
//  Notes:      It is assumed that the entry does not already exist in the
//              table.  The input property spec has already been normalized
//              and checked for error.
//
//----------------------------------------------------------------------------

ULONG CPidLookupTable::AddEntry( const CFullPropSpec & Prop )
{
    if (Size() == 0 ||
        Entries() >= _maxEntries)
    {
        GrowAndRehash( GrowSize() );
    }

    ULONG cbNameLength = 0;

    if (Prop.IsPropertyName())
    {
        cbNameLength = ( wcslen(Prop.GetPropertyName()) + 1) * sizeof (WCHAR);

        //
        //  Check for a bogus null property name
        //
        Win4Assert( cbNameLength > sizeof (WCHAR) );
        Win4Assert( cbNameLength <= MAX_PROPERTY_NAME_LEN );

        if (_cbStringUsed + cbNameLength > _cbStrings)
        {
            GrowStringSpace( cbNameLength );
        }
    }

    ULONG iEntry = ~0u;
    BOOL fFound = LookUp( Prop, iEntry );

    Win4Assert( fFound == FALSE && iEntry < Size() &&
                _pTable[iEntry].IsFree() );

    _pTable[iEntry].SetPropSet( Prop.GetPropSet() );
    if ( Prop.IsPropertyPropid() )
    {
        _pTable[iEntry].SetPropertyPropid( Prop.GetPropertyPropid() );
    }
    else
    {
        WCHAR * pchName = _pchStringBase + (_cbStringUsed / sizeof (WCHAR));
        RtlCopyMemory( pchName, Prop.GetPropertyName(), cbNameLength );
        _cbStringUsed += cbNameLength;
        _pTable[iEntry].SetPropertyNameOffset( (ULONG)(pchName - _pchStringBase) );

        Win4Assert( _cbStringUsed <= _cbStrings );
    }
    _pTable[iEntry].SetPid( NextPropid() );

    _Header.NextPropid++;
    _Header.cEntries++;

#if !defined(UNIT_TEST)
    //
    //  Write new mapping to the recoverable storage
    //

    CRcovStorageHdr & hdr = _xrsoPidTable->GetHeader();
    CRcovStrmAppendTrans xact( _xrsoPidTable.GetReference() );
    CRcovStrmAppendIter  iter( xact, sizeof (CPidLookupEntry) );

    iter.AppendRec( &_pTable[iEntry] );

    ULONG cRecordsWritten = 1;

    if (cbNameLength)
    {
        iter.AppendVariableRec( Prop.GetPropertyName(), cbNameLength );
        cRecordsWritten++;

    }

    struct CRcovUserHdr data;
    RtlCopyMemory( &data._abHdr, &_Header, sizeof(_Header) );

    Win4Assert( hdr.GetCount(hdr.GetBackup()) == hdr.GetCount(hdr.GetPrimary()) + cRecordsWritten);
    hdr.SetUserHdr( hdr.GetBackup(), data );
    xact.Commit();
#endif // !defined(UNIT_TEST)

    return iEntry;
}


//+-------------------------------------------------------------------------
//
//  Method:     CPidLookupTable::GrowAndRehash, private
//
//  Synopsis:   Grow the hash table in a CPidLookupTable
//
//  Arguments:  [cNewHash] - number of hash buckets to allocate
//
//  Returns:    Nothing
//
//--------------------------------------------------------------------------

void CPidLookupTable::GrowAndRehash( ULONG cNewHash )
{
    Win4Assert( cNewHash > Size() );

    ULONG cOldSize = Size();
    ULONG cOldEntries = Entries();

    XPtr<CPidLookupEntry> pOldTable( _pTable );
    _pTable = 0;

    Init( cNewHash );

    for (unsigned i = 0; i < cOldSize; i++)
    {
        if ((pOldTable.GetPointer() + i)->IsFree())
            continue;

        StoreInTable( *(pOldTable.GetPointer() + i) );
    }

    Win4Assert( Entries() < Size() && Entries() < _maxEntries );
    Win4Assert( Entries() == cOldEntries );
}


//+-------------------------------------------------------------------------
//
//  Method:     CPidLookupTable::GrowStringSpace, private
//
//  Synopsis:   Grow the string space in a CPidLookupTable
//
//  Arguments:  [cbNewString] - size (in bytes) to reserve for new string
//
//  Returns:    Nothing
//
//--------------------------------------------------------------------------

void CPidLookupTable::GrowStringSpace( ULONG cbNewString )
{
    ULONG cbNew = _cbStringUsed + 2*cbNewString;
    Win4Assert( cbNew > _cbStrings );

    WCHAR * pchNew = new WCHAR[ cbNew/sizeof (WCHAR) ];

    if ( 0 != _cbStringUsed )
    {
        RtlCopyMemory( pchNew, _pchStringBase, _cbStringUsed );
        delete [] _pchStringBase;
    }
    _pchStringBase = pchNew;
    _cbStrings = cbNew;
}


//+---------------------------------------------------------------------------
//
//  Method:     CPidLookupTable::FindPropid, public
//
//  Synopsis:   Looks up a property entry in the hash table.
//
//  Arguments:  [Prop]    - Property to lookup
//              [rPid]    - Propid found
//              [fAddToTable] - If TRUE, add Prop to table if it was not
//                           found.
//
//  Returns:    BOOL - TRUE if Prop was found or successfully added.
//
//  History:    02 Jan 1996   Alanw   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

BOOL CPidLookupTable::FindPropid( const CFullPropSpec & InputProp,
                                  PROPID & rPid,
                                  BOOL fAddToTable )
{
    rPid = pidInvalid;

    ULONG cbNameLength = 0;
    CFullPropSpec Prop;

    if (InputProp.IsPropertyPropid())
    {
        Win4Assert( InputProp.GetPropertyPropid() != PID_DICTIONARY &&
                    InputProp.GetPropertyPropid() != PID_CODEPAGE );
        if (InputProp.GetPropertyPropid() <= PID_CODEPAGE )
            return FALSE;

        Prop = InputProp;
    }
    else
    {
        // map the input property name to lower case
        Win4Assert( InputProp.IsPropertyName() );

        if ( InputProp.GetPropertyName() == 0 ||
             *InputProp.GetPropertyName() == L'\0' )
        {
             Win4Assert( !"CPidLookupTable - bad named property!" );
             return FALSE;
        }

        CLowcaseBuf wcsBuf( InputProp.GetPropertyName() );

        cbNameLength = (wcsBuf.Length() + 1) * sizeof (WCHAR);

        if ( cbNameLength >= MAX_PROPERTY_NAME_LEN )
        {
            ciDebugOut(( DEB_WARN,
                        "PIDTABLE: long named property truncated\t%ws\n",
                            InputProp.GetPropertyName() ));

            // Truncate the property name if it's too long.
            cbNameLength = MAX_PROPERTY_NAME_LEN;
            (wcsBuf.GetWriteable())[(cbNameLength/sizeof(WCHAR))-1] = L'\0';
        }

        //
        //  It would be nice if we could just use the lower-cased string
        //  from the CLowcaseBuf directly, but it's about to go out of scope.
        //
        Prop.SetPropSet( InputProp.GetPropSet() );
        Prop.SetProperty( wcsBuf.Get( ) );

        if ( !Prop.IsValid() )
            THROW( CException( E_OUTOFMEMORY ) );
    }

    if ( !Prop.IsValid() )
        return FALSE;

    CLock lock ( _mutex );

    ULONG iEntry = ~0u;
    BOOL fFound = LookUp( Prop, iEntry );

    if ( ! fFound && fAddToTable )
    {
        CImpersonateSystem impersonate;

        iEntry = AddEntry( Prop );
        fFound = TRUE;
    }

    if (fFound)
    {
        rPid = _pTable[iEntry].Pid();
        Win4Assert( iEntry < Size() && ! _pTable[iEntry].IsFree() );
    }

    return fFound;
} //FindPropid

//+---------------------------------------------------------------------------
//
//  Method:     CPidLookupTable::EnumerateProperty, public
//
//  Synopsis:   Enumerate properties in the property list
//
//  Arguments:  [ps]   -- Full PropSpec returned here
//              [iBmk] -- Bookmark. Initialized to 0 before first call.
//
//  Returns:    BOOL equivalent: PROPID, 0 if at the end of the enumeration.
//
//  History:    20-Jun-1996   KyleP   Created
//
//----------------------------------------------------------------------------

BOOL CPidLookupTable::EnumerateProperty( CFullPropSpec & ps, unsigned & iBmk )
{
    for ( ; iBmk < Size() && _pTable[iBmk].IsFree(); iBmk++ )
        continue;

    PROPID pid = 0;

    if ( iBmk >= Size() )
        return 0;

    ps.SetPropSet( _pTable[iBmk].GetPropSet() );

    if ( _pTable[iBmk].IsPropertyPropid() )
        ps.SetProperty( _pTable[iBmk].GetPropertyPropid() );
    else
    {
        ps.SetProperty( _pTable[iBmk].GetPropertyNameOffset() + _pchStringBase );
        if ( !ps.IsValid() )
            THROW( CException( E_OUTOFMEMORY ) );
    }

    pid = _pTable[iBmk].Pid();

    iBmk++;
    return pid;
} //EnumerateProperty
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\ntciutil\propbkp.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997 - 2000.
//
//  File:       propbkp.cxx
//
//  Contents:   Property store backup
//
//  Classes:    CPropStoreBackupStream
//
//  History:    31-May-97   KrishnaN    Created
//
//----------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include <cistore.hxx>
#include <propbkp.hxx>

// CPropStoreBackupStream class implementation

//+---------------------------------------------------------------------------
//
//  Function:   CPropStoreBackupStream, private
//
//  Synopsis:   Constructor.
//
//  Arguments:  [cMegToLeaveOnDisk] --  Number of megabytes not to write to
//
//  Returns:    None
//
//  History:    30-May-97   KrishnaN   Created
//              20-Nov-98   KLam       Added cMegToLeaveOnDisk
//
//----------------------------------------------------------------------------

CPropStoreBackupStream::CPropStoreBackupStream( ULONG cMegToLeaveOnDisk ) :
        _hFile( INVALID_HANDLE_VALUE ),
        _cPages( 0 ),
        _pSector( 0 ),
        _ulCurrentSector( invalidSector ),
        _cFileSizeInBytes( 0 ),
        _fOpenForRecovery( FALSE ),
        _pBigBuffer( 0 ),
        _cMegToLeaveOnDisk ( cMegToLeaveOnDisk ),
#if CIDBG
        _cPagesBackedUp( 0 ),
        _cPagesCommited( 0 ),
        _cFlushes( 0 ),
        _cFieldsCommited( 0 ),
#endif // CIDBG
        _pageTable( CI_PROPERTY_STORE_BACKUP_SIZE_DEFAULT )
{
    RtlZeroMemory(&_header, sizeof(SHeader));
    _header.cMaxPages = CI_PROPERTY_STORE_BACKUP_SIZE_DEFAULT;
}

//+---------------------------------------------------------------------------
//
//  Function:   ~CPropStoreBackupStream, public
//
//  Synopsis:   Desctructor.
//
//  Arguments:  None
//
//  Returns:    None
//
//  History:    30-May-97   KrishnaN   Created
//
//----------------------------------------------------------------------------

CPropStoreBackupStream::~CPropStoreBackupStream()
{
    Close();
    delete[] _pBigBuffer;
}


//+---------------------------------------------------------------------------
//
//  Function:   OpenForBackup, public
//
//  Synopsis:   Opens the backup stream for backup (write).
//
//  Arguments:  [path] - file path
//              [modeShare] -- sharing mode
//              [modeCreate] -- create mode
//              [ulMaxPages] -- Max # of pages to backup
//
//  Returns:    None
//
//  History:    30-May-97   KrishnaN   Created
//              18-Nov-98   KLam       Instantiate volume information
//
//  Notes:  This file should be opened with FILE_FLAG_NO_BUFFERING because
//          everything written to it should be immediately written to disk.
//          We don't need to read this file often, so we don't need any
//          read caching (so we don't use FILE_FLAGWrite_THROUGH).
//
//          Files opened with FILE_FLAG_NO_BUFFERING should always
//          write in increments of the volume sector size and should always
//          start writing on sector boundaries.
//
//----------------------------------------------------------------------------

void CPropStoreBackupStream::OpenForBackup( const WCHAR* wcsPath,
                                            ULONG modeShare,
                                            ULONG modeCreate,
                                            ULONG ulMaxPages)
{
    Win4Assert(!IsOpen());
    Win4Assert ( _xDriveInfo.IsNull() );

    _xDriveInfo.Set ( new CDriveInfo ( wcsPath, _cMegToLeaveOnDisk ));

    _hFile = CreateFile(wcsPath,
                        GENERIC_READ | GENERIC_WRITE,
                        modeShare,
                        NULL,
                        modeCreate,
                        FILE_FLAG_NO_BUFFERING | FILE_ATTRIBUTE_NOT_CONTENT_INDEXED,
                        NULL);

    if (INVALID_HANDLE_VALUE == _hFile)
    {
        ciDebugOut(( DEB_ERROR,
                      "CPropStoreBackupStream::OpenForBackup -- CreateFile on %ws returned %d\n",
                      wcsPath, GetLastError() ));
        THROW( CException() );
    }

    _fOpenForRecovery = FALSE;

    GetSystemParams();

    Win4Assert(0 == _pSector && invalidSector == _ulCurrentSector);
    _pBigBuffer = new BYTE[2*_header.ulSectorSize];
    // get a buffer that starts at sector size aligned address
    _pSector = (PBYTE)( (((ULONG_PTR)_pBigBuffer + _header.ulSectorSize) / _header.ulSectorSize) * _header.ulSectorSize);
    Win4Assert( ((ULONG_PTR)_pSector % _header.ulSectorSize) == 0);

    //
    // If this file is being created from scratch, we should claim all
    // the space we need to backup _header.cMaxPages number of pages.
    //

    if (CREATE_ALWAYS == modeCreate || CREATE_NEW == modeCreate ||
        OPEN_ALWAYS == modeCreate || TRUNCATE_EXISTING == modeCreate)
        Reset(ulMaxPages);
    else
    {
        ReadSector(0, _pSector);
        RtlCopyMemory(&_header, _pSector, sizeof(SHeader));
    }

    ciDebugOut((DEB_PROPSTORE, "Successfully created/opened backup file.\n"
                                "Sector size: %d, Page size: %d, Max pages: %d\n",
                                _header.ulSectorSize, _header.ulPageSize, _header.cMaxPages));
}


//+---------------------------------------------------------------------------
//
//  Function:   OpenForRecovery, public
//
//  Synopsis:   Opens the backup stream for recovery (read).
//
//  Arguments:  [path] - file path
//              [modeShare] -- sharing mode
//
//  Returns:    None
//
//  History:    30-May-97   KrishnaN   Created
//              18-Nov-98   KLam       Instantiate volume info
//
//  Notes:  This file is opened for reading and should be opened with page
//          caching enabled (normal behavior) so we can read arbitrary lengths
//          of data starting at arbitrary points in the backup stream.
//
//          This file could have been copied from a different architecture,
//          so we cannot assume that the page size hard coded in this file
//          will be the same as the page size used by the architecture. Get
//          the page size from the directory section and use that to restore
//          the corresponding sections of the property store.
//
//----------------------------------------------------------------------------

void CPropStoreBackupStream::OpenForRecovery ( const WCHAR* wcsPath,
                                               ULONG modeShare)
{
    Win4Assert(!IsOpen());
    Win4Assert ( _xDriveInfo.IsNull() );

    _xDriveInfo.Set ( new CDriveInfo ( wcsPath, _cMegToLeaveOnDisk ));

    _hFile = CreateFile(wcsPath,
                        GENERIC_READ,
                        modeShare,
                        NULL,
                        OPEN_EXISTING,
                        FILE_ATTRIBUTE_NORMAL,
                        NULL);

    if (INVALID_HANDLE_VALUE == _hFile)
    {
        ciDebugOut(( DEB_ERROR,
             "CPropStoreBackupStream::OpenForRecovery -- CreateFile on %ws returned %d\n",
              wcsPath, GetLastError() ));
        THROW( CException() );
    }
    _fOpenForRecovery = TRUE;

    if (IsCorrupt())
    {
        ciDebugOut(( DEB_ERROR,
             "CPropStoreBackupStream::OpenForRecovery -- Propstore backup file is corrupt\n"));
        THROW( CException(CI_CORRUPT_DATABASE) );
    }

    ReadFromFile(0, sizeof(SHeader), &_header);

    Win4Assert(0 == _pSector && invalidSector == _ulCurrentSector);
    _pBigBuffer = new BYTE[2*_header.ulSectorSize];
    // get a buffer that starts at sector size aligned address
    _pSector = (PBYTE)( (((ULONG_PTR)_pBigBuffer + _header.ulSectorSize) / _header.ulSectorSize) * _header.ulSectorSize);

    Win4Assert( ((ULONG_PTR)_pSector % _header.ulSectorSize) == 0);

    _cPages = CountPages();

    ciDebugOut((DEB_PROPSTORE, "Successfully opened backup file for recovery.\n"
                                "Sector size: %d, Page size: %d, Max pages: %d, pages: %d\n",
                                _header.ulSectorSize, _header.ulPageSize,
                                _header.cMaxPages, _cPages));
}

//+---------------------------------------------------------------------------
//
//  Function:   Close, public
//
//  Synopsis:   Closes the backup stream.
//
//  Arguments:  None
//
//  Returns:    None
//
//  History:    30-May-97   KrishnaN   Created
//              18-Nov-98   KLam       Freed volume info
//
//----------------------------------------------------------------------------

void CPropStoreBackupStream::Close()
{
    //CLock lock(_mtxWrite);

    if (IsOpen())
    {
        CloseHandle(_hFile);
        _hFile = INVALID_HANDLE_VALUE;
        _xDriveInfo.Free();
    }

#if CIDBG
    ciDebugOut((DEB_PSBACKUP, "Close: Closed backup. Pages backed up = %d, committed = %d, "
                              "fields commited = %d, and backup flushed %d times.\n"
                          "Percentage of times backed up pages were committed = %d.\n",
            _cPagesBackedUp, _cPagesCommited, _cFieldsCommited, _cFlushes,
            _cPagesCommited*100/(_cPagesBackedUp?_cPagesBackedUp:1)));
    _cPagesBackedUp = _cPagesCommited = _cFlushes = 0;
#endif // CIDBG

}

//+---------------------------------------------------------------------------
//
//  Function:   Reset, public
//
//  Synopsis:   Resets the backup stream. Typically called after the property
//              store is flushed.
//
//  Arguments:  None
//
//  Returns:    None
//
//  History:    30-May-97   KrishnaN   Created
//              29-Oct-98   KLam       Check for disk space before extending file
//
//----------------------------------------------------------------------------

void CPropStoreBackupStream::Reset(ULONG cMaxPages)
{
    //CLock lock(_mtxWrite);

    Win4Assert(IsOpen() && !IsOpenForRecovery());

    ciDebugOut((DEB_PSBACKUP, "Reset: Pages backed up = %d, committed = %d, "
                              "fields commited = %d, and backup flushed %d times.\n"
                              "Percentage of times backed up pages were committed = %d.\n",
                _cPagesBackedUp, _cPagesCommited, _cFieldsCommited, ++_cFlushes,
                _cPagesCommited*100/(_cPagesBackedUp?_cPagesBackedUp:1)));

    //
    // Compute the total size of the backup file. It is the sum of
    // space needed for directory section and the data section.
    // Directory section contains the header, SHeader, followed by
    // _header.cMaxPages slots (ULONG). All structures are sector
    // aligned. The header is treated as multiple slots.
    //

    // Enforce ranges
    if (cMaxPages < CI_PROPERTY_STORE_BACKUP_SIZE_MIN)
        _header.cMaxPages = CI_PROPERTY_STORE_BACKUP_SIZE_MIN;
    else if (cMaxPages > CI_PROPERTY_STORE_BACKUP_SIZE_MAX)
        _header.cMaxPages = CI_PROPERTY_STORE_BACKUP_SIZE_MAX;
    else
        _header.cMaxPages = cMaxPages;

    _header.ulDataOffset = _header.ulSectorSize *
                           roundup(ComputePageDescriptorOffset(_header.ulSectorSize, _header.cMaxPages),
                                   _header.ulSectorSize);
    ULONG cbNewFileSize = _header.ulDataOffset + _header.cMaxPages*_header.ulPageSize;
    
    //
    // If the file is growing, make sure there is enough space on disk
    //
    if ( cbNewFileSize > _cFileSizeInBytes )
    {
        Win4Assert ( !_xDriveInfo.IsNull() );
        __int64 cbTotal, cbRemaining;
        _xDriveInfo->GetDiskSpace( cbTotal, cbRemaining );
        if ( cbRemaining < ( cbNewFileSize - _cFileSizeInBytes ) )
        {
            ciDebugOut(( DEB_ERROR,
                         "CPropStoreBackupStream::Reset -- Not enough disk space, need %d more bytes\n",
                         (cbNewFileSize - _cFileSizeInBytes) - cbRemaining ));
            THROW( CException( CI_E_CONFIG_DISK_FULL ) );
        }
    }

    _cFileSizeInBytes = cbNewFileSize;

    if ( SetFilePointer ( _hFile,
                          _cFileSizeInBytes,
                          0,
                          FILE_BEGIN ) == 0xFFFFFFFF  &&
         GetLastError() != NO_ERROR )
    {
        ciDebugOut(( DEB_ERROR,
                     "CPropStoreBackupStream::Reset -- SetFilePointer returned %d\n",
                     GetLastError() ));
        THROW( CException() );
    }

    if ( !SetEndOfFile( _hFile ) )
    {
        ciDebugOut(( DEB_ERROR,
                     "CPropStoreBackupStream::Reset -- SetEndOfFile returned %d\n",
                     GetLastError() ));
        THROW( CException() );
    }

    ciDebugOut(( DEB_PSBACKUP, "Reset: Backup has %d maxpages, is %d bytes, and data page begins at offset %d (0x%x)\n",
                         _header.cMaxPages, _cFileSizeInBytes, _header.ulDataOffset, _header.ulDataOffset));

    // clear the hash table of all pages and init page count to 0
    _pageTable.DeleteAllEntries();
    _cPages = 0;

    Init();
}

//+---------------------------------------------------------------------------
//
//  Function:   ReadPage, public
//
//  Synopsis:   Read the i-th page. The page buffer is assumed to be the
//              size of the operating system page.
//
//  Arguments:  [ulPage] -- i-th page (0 based index) in backup to be read.
//              [pulLoc] -- Buffer to return the page's loc in prop store.
//              [pbPage] -- buffer to copy the page to. Contents undefined
//                          if FALSE is returned.
//
//  Returns:    TRUE if the page was successfully read.
//              FALSE otherwise.
//
//  History:    30-May-97   KrishnaN   Created
//
//  Notes: This function is not re-entrant. It will only be called for recovery
//         and one page will be read at a time. To make this re-entrant
//         allocate the buffer used for the sector on the stack.
//
//----------------------------------------------------------------------------

BOOL CPropStoreBackupStream::ReadPage(ULONG ulPage, ULONG *pulLoc, void *pbPage)
{
    Win4Assert(pbPage && pulLoc);

    // Copy the ulPage of the slot to pulLoc.
    *pulLoc = GetPageLocation(ulPage);
    if (invalidPage == *pulLoc)
        return FALSE;

    // Go to the data page and read it into pbPage
    ReadFromFile(_header.ulDataOffset + ulPage*_header.ulPageSize,
                  _header.ulPageSize,
                  pbPage);

    ciDebugOut(( DEB_PSBACKUP, "ReadPage: Successfully read page %d (page %d in backup) into address 0x%x\n",
                         *pulLoc, ulPage, pbPage));

    return TRUE;
}

//+---------------------------------------------------------------------------
//
//  Function:   GetPageLocation, public
//
//  Synopsis:   Get the location of the i-th page.
//
//  Arguments:  [nPage] -- i-th page (0 based index) to be read.
//
//  Returns:    The i-th page's location in property store. invalidPage if there is
//              no i-th page..
//
//  History:    30-May-97   KrishnaN   Created
//
//  Notes: This function is not re-entrant. It will only be called for recovery
//         and one page will be read at a time. To make this re-entrant
//         allocate the buffer used for the sector into a stack variable.
//
//+---------------------------------------------------------------------------

ULONG CPropStoreBackupStream::GetPageLocation(ULONG nPage)
{
    Win4Assert(IsOpen() && IsOpenForRecovery() && _pSector && nPage < _cPages);

    if (nPage >= _cPages)
        return invalidPage;

    // Get sector containing the page's descriptor and read it in.
    ULONG ulSlotOffset = ComputePageDescriptorOffset(_header.ulSectorSize, nPage);
    ULONG ulSector = ulSlotOffset/_header.ulSectorSize;
    if (_ulCurrentSector != ulSector)
    {
        ReadSector(ulSector, _pSector);
        _ulCurrentSector = ulSector;
    }

    // Return the page location
    ulSlotOffset %= _header.ulSectorSize;
    return *(ULONG *)(_pSector+ulSlotOffset);
}


//+---------------------------------------------------------------------------
//
//  Function:   CommitPages, public
//
//  Synopsis:   Check if there is space to add
//
//  Arguments:  [cPages]       -- Number of pages.
//              [pSlots]       -- Array of page descriptors.
//              [ppvPages]     -- Array of page pointers to backup.
//
//  Returns:    TRUE if all pages could be committed. FALSE otherwise.
//
//  Notes: For efficiency, call this only to commit multiple pages.
//
//  History:    09-Jun-97   KrishnaN   Created
//
//----------------------------------------------------------------------------

BOOL CPropStoreBackupStream::CommitPages(ULONG cPages,
                                         ULONG const *pSlots,
                                         void const * const * ppvPages)
{
    // Count pages not in the page table. Ignore duplicates.
    ULONG cMissingPages = 0;
    THashTable<ULONG> missingPageTable(cPages);  // to detect duplicates
    ULONG ulPos;

    for (ULONG i = 0; i < cPages; i++)
    {
        // if it is not in the page table and if it has not already
        // been counted, count it.
        if (!_pageTable.LookUp(pSlots[i], ulPos) && !missingPageTable.LookUp(pSlots[i]))
        {
            missingPageTable.AddEntry(pSlots[i]);
            cMissingPages++;
        }
    }

    if (0 == cMissingPages)
        return TRUE;    // nothing to do

    // do we have enough space to accomodate the missing pages?
    if (cMissingPages > (MaxPages() - Pages()))
        return FALSE;   // not enough space

    // Commit only pages not already committed
    BOOL fSuccessful = TRUE;
    for (i = 0; i < cPages && fSuccessful; i++)
    {
        // Attempt to commit only pages known to be missing from the page table
        // This saves us some cycles that would otherwise be spent by CommitPage
        // which would have to lookup in a larger hash table to figure out if
        // this page exists.

        if (missingPageTable.LookUp(pSlots[i]))
            fSuccessful = fSuccessful && CommitPage(pSlots[i], ppvPages[i]);
    }

    return fSuccessful;
}

//+---------------------------------------------------------------------------
//
//  Function:   CommitPage, public
//
//  Synopsis:   Append a page at the end of the stream. The page buffer is
//              assumed to be the size of the operating system page. If the
//              page already exists, overwrite it in place.
//
//  Arguments:  [slot]          -- Page descriptor for the page.
//              [pbPage]        -- Buffer containing contents of the page.
//
//  Returns:    TRUE if the page could be committed, FALSE if it couldn't be.
//
//  Notes: Call this for single page commits.
//
//  History:    30-May-97   KrishnaN   Created
//
//----------------------------------------------------------------------------

BOOL CPropStoreBackupStream::CommitPage(ULONG slot, void const *pbPage)
{
    //CLock lock(_mtxWrite);

    Win4Assert(IsOpen() && !IsOpenForRecovery() && _pSector);
    Win4Assert(++_cPagesBackedUp);

    ULONG ulPos;

    // Does it already exist in the backup?
    if (_pageTable.LookUp(slot, ulPos))
        return TRUE;    // no need to commit again


    ciDebugOut(( DEB_PSBACKUP, "CommitPage: Commiting page %d, address 0x%x\n", slot, pbPage));

    // First write the page to disk.
    BOOL fSuccessful = WriteToFile(_header.ulDataOffset + _cPages*_header.ulPageSize,
                                   _header.ulPageSize, pbPage);
    if (fSuccessful)
    {
        // Get sector containing the page's descriptor and read it in.
        ULONG ulSlotOffset = ComputePageDescriptorOffset(_header.ulSectorSize, _cPages);
        ULONG ulSector = ulSlotOffset/_header.ulSectorSize;
        if (_ulCurrentSector != ulSector)
        {
            ReadSector(ulSector, _pSector);
            _ulCurrentSector = ulSector;
        }

        // Copy the page descriptor into the sector and commit it.
        RtlCopyMemory(_pSector + ulSlotOffset%_header.ulSectorSize, &slot, sizeof(ULONG));
        fSuccessful = CommitSector(_ulCurrentSector, _pSector);
        Win4Assert(fSuccessful);
        _pageTable.AddEntry(slot, _cPages);

        // Now we are truly done commiting the page
        _cPages++;

        Win4Assert(++_cPagesCommited);
    }

    return fSuccessful;
}

//+---------------------------------------------------------------------------
//
//  Function:   CommitField, public
//
//  Synopsis:   Modify a field in place, sector by sector. This is faster than
//              modifying an entire page.
//
//  Arguments:  [ulPage]      -- The page to modify
//              [ulOffset]    -- Offset in page where modification should begin.
//              [cSize]       -- Size, in bytes, of the field to be modified.
//              [pvBuffer]    -- Buffer containing the new data to write.
//
//  Returns:    TRUE if the page could be committed, FALSE if it couldn't be.
//
//  History:    30-May-97   KrishnaN   Created
//
//----------------------------------------------------------------------------

BOOL CPropStoreBackupStream::CommitField(ULONG ulPage,
                                         ULONG ulOffset,
                                         ULONG cSize,
                                         void const *pvBuffer)
{
    ULONG ulPos = 0xFFFFFFFF;
    _pageTable.LookUp(ulPage, ulPos);
    Win4Assert(IsOpen() && !IsOpenForRecovery() && _pSector && _pageTable.LookUp(ulPage, ulPos));
    Win4Assert((ulOffset+cSize) <= _header.ulPageSize && pvBuffer);
    Win4Assert(++_cFieldsCommited);

    Win4Assert(ulPos < _cPages);


    //
    // Figure out which sector(s) the field spans and modify them in place
    //

    ULONG ulSector = ComputeFirstSectorOfPage(ulPos) + ulOffset/_header.ulSectorSize;
    ULONG ulOffsetInSector = ulOffset%_header.ulSectorSize;

    //
    // The way we backup right now, we cannot have multiple sector writes, so assert
    // that we are acutally writing only one sector. The code to support multiple
    // sector writes, of course, will always be there and doing its job.
    //
    Win4Assert((ulOffsetInSector + cSize) <= _header.ulSectorSize);

    for (ULONG cBytesCommited = 0; cBytesCommited < cSize; ulSector++)
    {
        _ulCurrentSector = ulSector;
        ReadSector(_ulCurrentSector, _pSector);
        RtlCopyMemory(_pSector + ulOffsetInSector,
                      ((PBYTE)pvBuffer + cBytesCommited),
                      min(cSize-cBytesCommited, _header.ulSectorSize));
        CommitSector(ulSector, _pSector);
        cBytesCommited += min(cSize-cBytesCommited, _header.ulSectorSize);

        // After the first time, the offset of field in the sector is always 0
        ulOffsetInSector = 0;
    }


    return TRUE;
 }

//+---------------------------------------------------------------------------
//
//  Function:   Init, private
//
//  Synopsis:   Initialize the header and directory section of the file.
//
//  Arguments:  None
//
//  Returns:    None
//
//  History:    04-Jun-97   KrishnaN   Created
//
//----------------------------------------------------------------------------

void CPropStoreBackupStream::Init()
{
    //CLock lock(_mtxWrite);

    Win4Assert(sizeof(SHeader) <= _header.ulSectorSize && _pSector);
    Win4Assert(_pSector);

    //
    // prepare the header portion of sector 0
    //

    _ulCurrentSector = 0;
    RtlCopyMemory(_pSector, &_header, sizeof(SHeader));
    ULONG ulNextSlotPtr = ComputePageDescriptorOffset(_header.ulSectorSize, 0);  // write next slot here

    //
    // Prepare the sectors and write them to disk
    //

    for (ULONG cSlotsWritten = 0; cSlotsWritten < _header.cMaxPages; )
    {
        // Fill up the current sector
        for (; (ulNextSlotPtr + sizeof(ULONG)) <= _header.ulSectorSize &&
                cSlotsWritten < _header.cMaxPages;
                ulNextSlotPtr += sizeof(ULONG), cSlotsWritten++)
        {
            RtlCopyMemory(_pSector+ulNextSlotPtr, &invalidPage, sizeof(ULONG));
        }

        // Anything to write in the current sector?
        if (ulNextSlotPtr > 0)
        {
            CommitSector(_ulCurrentSector, _pSector);

            // move to the next sector
            _ulCurrentSector++;
            ulNextSlotPtr = 0;
        }
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   CommitSector, private
//
//  Synopsis:   Commits ulSector - th sector of the data section to disk.
//
//  Arguments:  [ulSector] -- Sector to commit.
//              [pbBuffer] -- Buffer with sector's data to commit.
//
//  Returns:    None
//
//  History:    04-Jun-97   KrishnaN   Created
//
//----------------------------------------------------------------------------

BOOL CPropStoreBackupStream::CommitSector(ULONG ulSector, void const *pbBuffer)
{
    Win4Assert(IsOpen() &&
               !IsOpenForRecovery() &&
               pbBuffer);
    ciDebugOut(( DEB_PSBACKUP, "CommitSector: About to commit sector %d\n", ulSector));

    if ( 0 == pbBuffer )
    {
        ciDebugOut(( DEB_ERROR,
                     "CPropStoreBackupStream::CommitSector attempting to write an invalid sector (sector %d, address: %0x8x)\n",
                      ulSector, pbBuffer ));
        return FALSE;
    }

    return WriteToFile(ulSector*_header.ulSectorSize, _header.ulSectorSize, pbBuffer);
} //CommitSector

//+---------------------------------------------------------------------------
//
//  Function:   WriteToFile, private
//
//  Synopsis:   Commits a buffer to disk.
//
//  Arguments:  [ulStartLoc] -- Starting location, relative to beginning of file.
//              [ulNumBytes] -- Number of bytes to commit.
//              [pbBuffer]   -- Buffer containing data to commit.
//
//  Returns:    None
//
//  History:    04-Jun-97   KrishnaN   Created
//
//----------------------------------------------------------------------------

BOOL CPropStoreBackupStream::WriteToFile(ULONG ulStartLoc, ULONG ulNumBytes,
                                          void const *pbBuffer)
{
    Win4Assert(IsOpen() && !IsOpenForRecovery());
    // The buffer should also begin on a sector boundary
    Win4Assert( ((ULONG_PTR)pbBuffer % _header.ulSectorSize) == 0);
    // All writes to this file should begin and end on sector boundaries
    Win4Assert(ulStartLoc%_header.ulSectorSize == 0 && ulNumBytes%_header.ulSectorSize == 0);

    DWORD dwNumWritten = 0;
    dwNumWritten = SetFilePointer(_hFile, ulStartLoc, 0, FILE_BEGIN);
    if (0xFFFFFFFF == dwNumWritten)
    {
        ciDebugOut(( DEB_ERROR,
                     "CPropStoreBackupStream::WriteToFile -- SetFilePointer returned %d\n",
                      GetLastError() ));
        return FALSE;
    }
    Win4Assert(ulStartLoc == dwNumWritten);

    if (!WriteFile(_hFile, pbBuffer, ulNumBytes, &dwNumWritten, NULL))
    {
        ciDebugOut(( DEB_ERROR,
                     "CPropStoreBackupStream::WriteToFile -- WriteFile returned %d\n",
                      GetLastError() ));
        return FALSE;
    }
    Win4Assert(ulNumBytes == dwNumWritten);

    return TRUE;
} //WriteToFile

//+---------------------------------------------------------------------------
//
//  Function:   ReadSector, private
//
//  Synopsis:   Reads specified sector of the data section from disk.
//
//  Arguments:  [ulSector] -- i-th sector of data section to read.
//              [pbBuffer] -- Buffer to hold the sector
//
//  Returns:    None
//
//  History:    04-Jun-97   KrishnaN   Created
//
//----------------------------------------------------------------------------

inline void CPropStoreBackupStream::ReadSector(ULONG ulSector, PBYTE pbBuffer)
{
    Win4Assert(IsOpen() && pbBuffer);

    ReadFromFile(ulSector*_header.ulSectorSize, _header.ulSectorSize, pbBuffer);
}

//+---------------------------------------------------------------------------
//
//  Function:   ReadFromFile, private
//
//  Synopsis:   Reads specified data from file.
//
//  Arguments:  [ulStartLoc] -- starting location of data to read.
//              [ulNumBytes] -- number of bytes to read.
//              [pbBuffer]   -- Buffer to hold the read data.
//
//  Returns:    None
//
//  History:    04-Jun-97   KrishnaN   Created
//
//----------------------------------------------------------------------------

void CPropStoreBackupStream::ReadFromFile(ULONG ulStartLoc, ULONG ulNumBytes,
                                           void *pbBuffer)
{
    Win4Assert(IsOpen());

    DWORD dwNumRead = 0;
    dwNumRead = SetFilePointer(_hFile, ulStartLoc, 0, FILE_BEGIN);
    if (0xFFFFFFFF == dwNumRead)
    {
        ciDebugOut(( DEB_ERROR,
                     "CPropStoreBackupStream::ReadFromFile -- SetFilePointer returned %d\n",
                      GetLastError() ));
        THROW( CException() );
    }
    Win4Assert(ulStartLoc == dwNumRead);

    if (!ReadFile(_hFile, pbBuffer, ulNumBytes, &dwNumRead, NULL))
    {
        ciDebugOut(( DEB_ERROR,
                     "CPropStoreBackupStream::ReadFromFile -- ReadFile returned %d\n",
                      GetLastError() ));
        THROW( CException() );
    }
    Win4Assert(ulNumBytes == dwNumRead);
}

//+---------------------------------------------------------------------------
//
//  Function:   CountPages, private
//
//  Synopsis:   Counts the pages backed up.
//
//  Arguments:  None
//
//  Returns:    Number of pages in the backup file.
//
//  History:    04-Jun-97   KrishnaN   Created
//
//  Notes: Assumes that the file is not corrupt. It is the job of IsCorrupt()
//         to detect corruption.
//
//----------------------------------------------------------------------------

ULONG CPropStoreBackupStream::CountPages()
{
    Win4Assert(IsOpen() && IsOpenForRecovery() && !IsCorrupt());

    //
    // Read in a page descriptor at a time until the first "free" page descriptor
    // slot is found OR until you reach the end of the directory section.
    //

    ULONG cPages;
    ULONG ulNextSlotPtr = ComputePageDescriptorOffset(_header.ulSectorSize, 0);  // read next slot here
    ULONG slot;

    for (cPages = 0; cPages < _header.cMaxPages; cPages++)
    {
        ReadFromFile(ulNextSlotPtr, sizeof(ULONG), &slot);
        if (invalidPage == slot)
            break;

        ulNextSlotPtr += sizeof(ULONG);
    }

    ciDebugOut((DEB_PSBACKUP, "Found %u data pages in property store backup.\n", cPages));

    return cPages;
}

//+---------------------------------------------------------------------------
//
//  Function:   IsCorrupt, private
//
//  Synopsis:   Checks for corruption.
//
//  Arguments:  None
//
//  Returns:    TRUE or FALSE.
//
//  History:    04-Jun-97   KrishnaN   Created
//
//  Notes: This can only verify the directory section. It cannot
//         validate the contents of the data section.
//
//----------------------------------------------------------------------------


BOOL CPropStoreBackupStream::IsCorrupt()
{
    Win4Assert(IsOpen() && IsOpenForRecovery());

    SHeader header;
    ReadFromFile(0, sizeof(SHeader), &header);

    //
    // Remember that the file may have just been copied from a different architecture,
    // so we can't verify against values provided by system calls. They should be
    // powers of 2, so that would be a good check. The page size should also be an
    // integral of sector size. So that would be another good check.
    //

    if (header.ulPageSize % header.ulSectorSize != 0)
    {
        ciDebugOut((DEB_PSBACKUP, "Page size (%d) in not an integral multiple of sector size (%d).\n",
                    header.ulPageSize, header.ulSectorSize));
        return TRUE;
    }

    if (!IsPowerOf2(header.ulPageSize) || !IsPowerOf2(header.ulSectorSize))
    {
        ciDebugOut((DEB_PSBACKUP, "Page size (%d) in not an integral multiple of sector size (%d).\n",
                    header.ulPageSize, header.ulSectorSize));
        return TRUE;
    }

    // Verify that cMaxPages looks "reasonable"
    if (header.cMaxPages < CI_PROPERTY_STORE_BACKUP_SIZE_MIN || header.cMaxPages > CI_PROPERTY_STORE_BACKUP_SIZE_MAX)
    {
        ciDebugOut((DEB_PSBACKUP, "Max pages in backup file is %d. Should be between %d and %d\n",
                    header.cMaxPages, CI_PROPERTY_STORE_BACKUP_SIZE_MIN, CI_PROPERTY_STORE_BACKUP_SIZE_MAX));
        return TRUE;
    }

    // Verify that ulDataOffset is valid.
    ULONG ulDataOffset = header.ulSectorSize *
                         roundup(ComputePageDescriptorOffset(header.ulSectorSize, header.cMaxPages),
                                 header.ulSectorSize);
    if (header.ulDataOffset != ulDataOffset)
    {
        ciDebugOut((DEB_ERROR, "Data section of backup file should begin at offset %d."
                    " Instead, it is %d \n",
                    ulDataOffset, header.ulDataOffset));
        return TRUE;
    }

    //
    // Read in a page descriptor at a time until you reach the end of the
    // directory section. Verify that each slot is free or has "reasonable"
    // values. Once a free slot is found, all subsequent slots should also
    // be free.
    //

    ULONG cPages;
    ULONG ulNextSlotPtr = ComputePageDescriptorOffset(header.ulSectorSize, 0);  // read next slot here
    ULONG slot;

    for (cPages = 0; cPages < header.cMaxPages; cPages++)
    {
        ReadFromFile(ulNextSlotPtr, sizeof(ULONG), &slot);
        if (invalidPage == slot)
            break;

        // How to validate ulPage of ULONG?

        ulNextSlotPtr += sizeof(ULONG);
    }

    // Verify that the remaining slots are free
    for (ulNextSlotPtr += sizeof(ULONG); cPages < header.cMaxPages; cPages++)
    {
        ReadFromFile(ulNextSlotPtr, sizeof(ULONG), &slot);
        if (invalidPage != slot)
        {
            ciDebugOut((DEB_PSBACKUP, "Found an invalid page descriptor in backup file "
                        "where a free slot is expected.\n"));
            return TRUE;
        }
    }

    return FALSE;
}

//+---------------------------------------------------------------------------
//
//  Function:   GetSystemParams, private
//
//  Synopsis:   Gets the volume sector size and page size.
//
//  Returns:    None.
//
//  History:    04-Jun-97   KrishnaN   Created
//              18-Nov-98   KLam       Removed path parameter, used volume info
//
//----------------------------------------------------------------------------


void CPropStoreBackupStream::GetSystemParams()
{
    Win4Assert ( !_xDriveInfo.IsNull() );
    _header.ulSectorSize = _xDriveInfo->GetSectorSize();

    SYSTEM_INFO systemInfo;
    GetSystemInfo(&systemInfo);
    _header.ulPageSize = systemInfo.dwPageSize;

    if (_header.ulPageSize % _header.ulSectorSize != 0)
    {
        ciDebugOut((DEB_ERROR, "CPropStoreBackupStream::GetSystemParams: Page size (%d) in not an integral multiple of sector size (%d).\n",
                    _header.ulPageSize, _header.ulSectorSize));
        THROW( CException(CI_E_STRANGE_PAGEORSECTOR_SIZE) );
    }

    ciDebugOut(( DEB_PSBACKUP, "GetSystemParams: Volume sector size is %d bytes and system page size is %d (0x%x)",
                         _header.ulSectorSize, _header.ulPageSize, _header.ulPageSize));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\ntciutil\propiter.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1991 - 1992.
//
//  File:       PropIter.cxx
//
//  Contents:   Iterator for property store.
//
//  Classes:    CPropertyStoreWids
//
//  History:    27-Dec-19   KyleP       Created
//
//----------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include <prpstmgr.hxx>
#include <propobj.hxx>
#include <propiter.hxx>

//+---------------------------------------------------------------------------
//
//  Member:     CPropertyStoreWids::CPropertyStoreWids, public
//
//  Synopsis:   Constructor
//
//  Arguments:  [propstore] -- Property store manager.
//
//  History:    04-Jan-96   KyleP       Created.
//              22-Oct-97   KrishnaN    Modified to take the propstore mgr
//                                      and iterate through its primary store.
//
//----------------------------------------------------------------------------

CPropertyStoreWids::CPropertyStoreWids( CPropStoreManager & propstoremgr )
         : _propstore( propstoremgr.GetPrimaryStore() ),
           _Borrowed( propstoremgr.GetPrimaryStore()._xPhysStore.GetReference(),
                      propstoremgr.GetPrimaryStore()._PropStoreInfo.RecordsPerPage(),
                      propstoremgr.GetPrimaryStore()._PropStoreInfo.RecordSize() )
{
    Init(propstoremgr.GetPrimaryStore());
}

//+---------------------------------------------------------------------------
//
//  Member:     CPropertyStoreWids::CPropertyStoreWids, public
//
//  Synopsis:   Constructor
//
//  Arguments:  [propstore] -- Property store.
//
//  History:    04-Jan-96   KyleP       Created.
//              22-Oct-97   KrishnaN    Modified to take the propstore mgr
//                                      and iterate through its primary store.
//
//----------------------------------------------------------------------------

CPropertyStoreWids::CPropertyStoreWids( CPropertyStore & propstore )
        : _propstore( propstore ),
          _Borrowed( propstore._xPhysStore.GetReference(),
                     propstore._PropStoreInfo.RecordsPerPage(),
                     propstore._PropStoreInfo.RecordSize() )
{
    Init(propstore);
}

//+---------------------------------------------------------------------------
//
//  Member:     CPropertyStoreWids::Init, private
//
//  Synopsis:   Constructor helper.
//
//  Arguments:  [propstore] -- Property store.
//
//  History:    20-Nov-97   KrishnaN    Created.
//
//----------------------------------------------------------------------------

void CPropertyStoreWids::Init(CPropertyStore& propstore)
{
    if ( _propstore.MaxWorkId() > 0 )
    {
        _Borrowed.Set( 1 );
        _wid = 1;

        _cRecPerPage = _propstore.RecordsPerPage();

        if ( !_Borrowed.Get()->IsTopLevel() )
            _wid = NextWorkId();
    }
    else
        _wid = widInvalid;
}

//+---------------------------------------------------------------------------
//
//  Member:     CPropertyStoreWids::~CPropertyStoreWids, public
//
//  Synopsis:   Destructor
//
//  History:    04-Jan-96   KyleP       Created.
//
//----------------------------------------------------------------------------

CPropertyStoreWids::~CPropertyStoreWids()
{
}

//+---------------------------------------------------------------------------
//
//  Member:     CPropertyStoreWids::NextWorkId, public
//
//  Synopsis:   Advances iterator to next in-use workid.
//
//  Returns:    Next workid, or widInvalid if at end.
//
//  History:    04-Jan-96   KyleP       Created.
//
//----------------------------------------------------------------------------

WORKID CPropertyStoreWids::NextWorkId()
{
    CReadAccess lock( _propstore.GetReadWriteAccess() );

    return LokNextWorkId();
}

//+---------------------------------------------------------------------------
//
//  Member:     CPropertyStoreWids::LokNextWorkId, public
//
//  Synopsis:   Advances iterator to next in-use workid, assumes at least
//              a read lock is already grabbed.
//
//  Returns:    Next workid, or widInvalid if at end.
//
//  History:    23-Feb-96   dlee        created from NextWorkId
//
//----------------------------------------------------------------------------

WORKID CPropertyStoreWids::LokNextWorkId()
{
    Win4Assert( _wid != widInvalid );

    while ( TRUE )
    {
        COnDiskPropertyRecord const * pRec = _Borrowed.Get();

        if ( pRec->IsValidType() && pRec->IsValidLength(_wid, _cRecPerPage) )
        {
            _wid = _wid + _Borrowed.Get()->CountRecords();
        }
        else
        {
            ciDebugOut(( DEB_ERROR, "Wid (0x%X) pRec (0x%X) has bad length (%d)\n",
                                    _wid, pRec, pRec->CountRecords() ));
            Win4Assert( !"Corruption in PropertyStore" );
            // Try to find the next valid top level record.
            _wid++;
        }

        if ( _wid > _propstore.MaxWorkId() )
        {
            _Borrowed.Release();
            _wid = widInvalid;
            break;
        }

        //
        // Make sure we acquire new buffer before releasing old.  Keeps us from
        // unmapping page.
        //

        CBorrowed temp( _Borrowed );

        _Borrowed.Set( _wid );
        if ( _Borrowed.Get()->IsTopLevel() )
            break;
    }

    return _wid;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\ntciutil\rcstrmhd.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1991 - 1992.
//
//  File:       RCSTRMHD.CXX
//
//  Contents:   Header information for the Recoverable Storage Object.
//
//  Classes:    CRcovStorageHdr
//
//
//  History:    07-Feb-1994     SrikantS    Created
//
//----------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include <rcstrmhd.hxx>

void CRcovStorageHdr::Init(ULONG ulVer)
{
    Win4Assert( FIELD_OFFSET( CRcovStorageHdr, _version ) == 0 );
    _version  = ulVer;
    _flags = 0;
    _iPrimary = idxOne;
    _opCurr = opNone;
    _sigHdr1 = SIGHDR1;
    _sigHdr2 = SIGHDR2;

    memset( &_ahdrStrm, 0, sizeof(_ahdrStrm) );
    memset( &_ahdrUser, 0, sizeof(_ahdrUser) );

    Win4Assert( IsValid(ulVer) );
}

//+---------------------------------------------------------------------------
//
//  Function:   IsValid
//
//  Synopsis:   Checks the validity of the header data.
//
//  History:    12-12-94   srikants   Created
//
//  Notes:      
//
//----------------------------------------------------------------------------

BOOL CRcovStorageHdr::IsValid(ULONG ulExpectedVer) const
{
    if ( ulExpectedVer != _version)
    {
        return FALSE;
    }

    if ((SIGHDR1 != _sigHdr1) || (SIGHDR2 != _sigHdr2))
    {
        return FALSE;
    }

    if ( _iPrimary != idxOne && _iPrimary != idxTwo )
    {
        return FALSE;
    }

    if ( _opCurr < opNone || _opCurr > opDirty )
    {
        return FALSE;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\ntciutil\propmap.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1998.
//
//  File:       propmap.cxx
//
//  Contents:   
//
//  Classes:    
//
//  Functions:  
//
//  History:    12-11-96   srikants   Created
//
//----------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include <propmap.hxx>
#include <pidtable.hxx>

CFwPropertyMapper::~CFwPropertyMapper()
{
    if ( _fOwned )
        delete _pPidTable;    

    delete _papsShortLived;
}

//+---------------------------------------------------------------------------
//
//  Member:     CFwPropertyMapper::QueryInterface
//
//  Synopsis:   Supports IID_IUnknown and IID_IPropertyMapper.
//
//  History:    11-27-96   srikants   Created
//
//----------------------------------------------------------------------------

STDMETHODIMP CFwPropertyMapper::QueryInterface(
    REFIID riid,
    void **ppvObject)
{
    Win4Assert( 0 != ppvObject );

    if ( IID_IPropertyMapper == riid )
        *ppvObject = (void *)((IPropertyMapper *)this);
    else if ( IID_IUnknown == riid )
        *ppvObject = (void *)((IUnknown *) (IPropertyMapper *) this);
    else
    {
        *ppvObject = 0;
        return E_NOINTERFACE;
    }

    AddRef();
    return S_OK;
} //QueryInterface

//+---------------------------------------------------------------------------
//
//  Member:     CFwPropertyMapper::AddRef
//
//  History:    11-22-96   srikants   Created
//
//----------------------------------------------------------------------------

STDMETHODIMP_(ULONG) CFwPropertyMapper::AddRef()
{
    return InterlockedIncrement(&_refCount);
} //AddRef

//+---------------------------------------------------------------------------
//
//  Member:     CFwPropertyMapper::Release
//
//  History:    11-22-96   srikants   Created
//
//----------------------------------------------------------------------------

STDMETHODIMP_(ULONG) CFwPropertyMapper::Release()
{
    Win4Assert( _refCount > 0 );

    LONG refCount = InterlockedDecrement(&_refCount);

    if (  refCount <= 0 )
        delete this;

    return (ULONG) refCount;
}  //Release

//+---------------------------------------------------------------------------
//
//  Member:     CFwPropertyMapper::PropertyToPropid
//
//  Synopsis:   Maps a FULLPROPSPEC into a 32bit PropertyId.
//
//  Arguments:  [fps]     - FULLPROPSPEC of the property to be converted
//              [fCreate] - If set to TRUE, the pid will be created if the
//              property is a new one.
//              [pPropId] - On output, will have the pid.
//
//  Returns:    S_OK if successful, other error code as appropriate.
//
//  History:    12-11-96   srikants   Created
//
//----------------------------------------------------------------------------

STDMETHODIMP CFwPropertyMapper::PropertyToPropid(
    FULLPROPSPEC const * fps,
    BOOL fCreate,
    PROPID * pPropId )
{
    Win4Assert( fps );
    Win4Assert( pPropId );

    CFullPropSpec const * ps = (CFullPropSpec *) fps;

    PROPID pid = _propMapper.StandardPropertyToPropId( *ps );

    if ( pidInvalid != pid )
    {
        *pPropId = pid;
        return S_OK;
    }

    SCODE sc = S_OK;

    TRY
    {
        //
        // Since a null catalog didn't have an opportunity
        // to enter properties into the prop store, we have to
        // let it enter them into a in memory table whose
        // lifetime is that of the null catalog.
        //
            
        if (_fMapStdOnly)
            *pPropId = LocateOrAddProperty(*ps);
        else
            _pPidTable->FindPropid( *ps, *pPropId, fCreate );
    }
    CATCH( CException,e )
    {
        sc = e.GetErrorCode();        
    }
    END_CATCH

    return sc;
}

//+-------------------------------------------------------------------------
//
//  Method:     CFwPropertyMapper::LocateOrAddProperty, private
//
//  Synopsis:   Lookup property and enter if it doesn't exist.
//
//  Arguments:  [ps] -- Property specification (name)
//
//  Returns:    The pid of [ps].
//
//  History:    23-July-1997     KrishnaN    Created
//
//--------------------------------------------------------------------------

PROPID CFwPropertyMapper::LocateOrAddProperty(CFullPropSpec const & ps)
{
    PROPID pid = pidInvalid;
    
    //
    // Create pid good only for life of catalog.
    //

    //
    // Have we seen this property before?  Use linear search since
    // we shouldn't have too many of these.
    //
    
    for ( unsigned i = 0; i < _cps; i++ )
    {
        if ( ps == _papsShortLived->Get(i)->PS() )
            break;
    }

    if ( i < _cps )
    {
        pid = _papsShortLived->Get(i)->Pid();
    }
    else
    {
        pid = _pidNextAvailable++;
        CPropSpecPidMap * ppm = new CPropSpecPidMap( ps, pid );

        _papsShortLived->Add( ppm, _cps );
        _cps++;
    }

    return pid;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\ntciutil\proprec.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1995 - 2000
//
//  File:       PropRec.cxx
//
//  Contents:   Record format for persistent property store
//
//  Classes:    CPropertyRecord
//
//  History:    28-Dec-19   KyleP       Created
//
//----------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include <stgvar.hxx>
#include <propvar.h>
#include <propstm.hxx>
#include <proprec.hxx>
#include <eventlog.hxx>
#include <pmalloc.hxx>


//+---------------------------------------------------------------------------
//
//  Member:     COnDiskPropertyRecord::ReadFixed, public
//
//  Synopsis:   Read fixed-length property
//
//  Arguments:  [Ordinal]  -- Ordinal of property to locate.
//              [mask]     -- Bitmask of ordinal.  Pre-computed for efficiency.
//              [oStart]   -- Offset to start of specific fixed property.
//              [cTotal]   -- Total number of properties in record.
//              [Type]     -- Data type of value
//              [var]      -- Value returned here.
//              [pbExtra]  -- Indirect data stored here
//              [pcbExtra] -- On input, size of [pbExtra].  On output,
//                            amount used.
//
//  History:    27-Dec-95   KyleP       Created.
//
//----------------------------------------------------------------------------

void COnDiskPropertyRecord::ReadFixed( ULONG Ordinal,
                                       ULONG Mask,
                                       ULONG oStart,
                                       ULONG cTotal,
                                       ULONG Type,
                                       PROPVARIANT & var,
                                       BYTE * pbExtra,
                                       unsigned * pcbExtra,
                                       PStorage & storage )
{
    if ( !IsStored( Ordinal, Mask ) )
    {
        var.vt = VT_EMPTY;
        *pcbExtra = 0;
    }
    else
    {
        var.vt = (USHORT)Type;

        //
        // Start is after existance bitmap
        //

        ULONG const * pulStart = 0;
        if (IsLeanRecord())
            pulStart = &((SLeanRecord *)&Data)->_aul[ (cTotal-1) / 16 + 1 + oStart];
        else
            pulStart = &((SNormalRecord *)&Data)->_aul[ (cTotal-1) / 16 + 1 + oStart];

        switch ( Type )
        {
        case VT_I1:
        case VT_UI1:
            var.bVal = *(BYTE *)pulStart;
            *pcbExtra = 0;
            break;

        case VT_I2:
        case VT_UI2:
        case VT_BOOL:
            var.uiVal = *(USHORT *)pulStart;
            *pcbExtra = 0;
            break;

        case VT_I4:
        case VT_UI4:
        case VT_R4:
        case VT_ERROR:
            var.ulVal = *pulStart;
            *pcbExtra = 0;
            break;

        case VT_I8:
        case VT_UI8:
        case VT_R8:
        case VT_CY:
        case VT_DATE:
        case VT_FILETIME:
            RtlCopyMemory( &var.hVal, pulStart, sizeof(var.hVal) );
            *pcbExtra = 0;
            break;

        case VT_CLSID:
            if ( *pcbExtra < sizeof(CLSID) )
            {
                *pcbExtra = sizeof(CLSID);
                return;
            }

            if ( *pcbExtra == 0xFFFFFFFF )
            {
                var.puuid = (CLSID *)CoTaskMemAlloc( sizeof(CLSID) );
                if ( 0 == var.puuid )
                    THROW( CException( E_OUTOFMEMORY ) );
            }
            else
            {
                *pcbExtra = sizeof(CLSID);
                var.puuid = (CLSID *)pbExtra;
            }
            RtlCopyMemory( var.puuid, pulStart, sizeof(CLSID) );
            break;

        default:
            ciDebugOut(( DEB_ERROR, "PROPSTORE: Reading invalid fixed type %d.\n", Type ));
            Win4Assert( !"Corrupt property store" );

            storage.ReportCorruptComponent( L"PropertyRecord1" );

            THROW( CException( CI_CORRUPT_CATALOG ) );
            break;
        }
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     COnDiskPropertyRecord::ReadVariable, public
//
//  Synopsis:   Read variable-length property
//
//  Arguments:  [Ordinal]  -- Ordinal of property to locate.
//              [mask]     -- Bitmask of ordinal.  Pre-computed for efficiency.
//              [oStart]   -- Offset to start of variable storage area.
//              [cTotal]   -- Total number of properties in record.
//              [cFixed]   -- Count of fixed length properties
//              [var]      -- Value returned here.
//              [pbExtra]  -- Indirect data stored here
//              [pcbExtra] -- On input, size of [pbExtra].  On output,
//                            amount used.
//
//  Returns:    FALSE if value must be stored in overflow record.
//
//  History:    27-Dec-95   KyleP       Created.
//              14-Mar-2000 KLam        Check results of memory allocation
//
//----------------------------------------------------------------------------

BOOL COnDiskPropertyRecord::ReadVariable( ULONG Ordinal,
                                          ULONG Mask,
                                          ULONG oStart,
                                          ULONG cTotal,
                                          ULONG cFixed,
                                          PROPVARIANT & var,
                                          BYTE * pbExtra,
                                          unsigned * pcbExtra )
{
    if ( !IsStored( Ordinal, Mask ) )
    {
        var.vt = VT_EMPTY;
        *pcbExtra = 0;
    }
    else
    {
        //
        // Check for overflow.
        //

        if ( IsStoredOnOverflow( Ordinal, Mask ) )
            return FALSE;

        //
        // Start is after existance bitmap and fixed properties.
        //

        ULONG * pulStart = FindVariableProp( Ordinal, cFixed, cTotal, oStart );

        Win4Assert( !IsOverflow( *pulStart ) );

        //
        // Compute the length of the property.
        //

        ULONG cbProp = UsedSize( *pulStart ) * 4;
        pulStart++;  // Skip size field.

        ciDebugOut(( DEB_PROPSTORE,
                     "Reading variable prop, ordinal %d at offset 0x%x (%d) in record. Size = %d bytes.\n",
                     Ordinal,
                     (ULONG)((ULONG_PTR)pulStart - (ULONG_PTR)this),
                     (ULONG)((ULONG_PTR)pulStart - (ULONG_PTR)this),
                     cbProp ));

        ULONG cb;
        BOOL fUnicodeSpecial = IsUnicodeSpecial( (SERIALIZEDPROPERTYVALUE *)pulStart,
                                                 cb );

        if ( !fUnicodeSpecial )
            cb = StgPropertyLengthAsVariant( (SERIALIZEDPROPERTYVALUE *)pulStart,
                                             cbProp,
                                             CP_WINUNICODE,
                                             0 );

        if ( cb <= *pcbExtra )
        {
            if ( *pcbExtra == 0xFFFFFFFF )
            {
                //
                // Unmarshall the property.  Use the OLE allocator for extra mem
                //

                if ( fUnicodeSpecial )
                {
                    ReadUnicodeSpecialCTMA( (SERIALIZEDPROPERTYVALUE *)pulStart,
                                            var );
                }
                else
                {
                    CCoTaskMemAllocator BufferMgr;

                    StgConvertPropertyToVariant( (SERIALIZEDPROPERTYVALUE *)pulStart,
                                                 CP_WINUNICODE,
                                                 &var,
                                                 &BufferMgr );
                }

                #if CIDBG==1
                    if ( (var.vt&0x0fff) > VT_CLSID )
                    {
                        ciDebugOut(( DEB_ERROR, "Bad Variant Type 0x%X\n", var.vt ));
                        Win4Assert( !"Call KyleP" );
                    }
                #endif  // CIDBG==1
            }
            else
            {
                //
                // Unmarshall the property into a buffer.
                //

                if ( fUnicodeSpecial )
                {
                    ReadUnicodeSpecial( (SERIALIZEDPROPERTYVALUE *)pulStart,
                                        var,
                                        pbExtra );
                }
                else
                {
                    CNonAlignAllocator BufferMgr( *pcbExtra, pbExtra );

                    StgConvertPropertyToVariant( (SERIALIZEDPROPERTYVALUE *)pulStart,
                                                 CP_WINUNICODE,
                                                 &var,
                                                 &BufferMgr );

                    // StgConverPropertyToVariant uses SafeArrayCreateEx for
                    // VT_ARRAY allocation, even when an allocator is passed in!

                    if ((var.vt & VT_ARRAY) == VT_ARRAY)
                    {
                        ciDebugOut(( DEB_ERROR, "Array Variant Type 0x%X\n", var.vt ));
                        Win4Assert(BufferMgr.GetFreeSize() == *pcbExtra);

                        SAFEARRAY * pSaSrc  = var.parray;
                        SAFEARRAY * pSaDest = 0;

                        if ( SaCreateAndCopy( BufferMgr, pSaSrc, &pSaDest ) &&
                             SaCreateDataUsingMA( BufferMgr,
                                                  var.vt & ~VT_ARRAY,
                                                  *pSaSrc,
                                                  *pSaDest,
                                                  TRUE ) )
                        {
                            SafeArrayDestroy(var.parray);
                            var.parray = pSaDest;
                        }
                        else
                        {
                            Win4Assert( !"SafeArray copy failed!" );
                        }
                    }
                    else if ((var.vt & ~(VT_VECTOR|VT_ARRAY)) == VT_BSTR)
                    {
                        //
                        // StgConverPropertyToVariant uses SysAllocString for
                        // BSTR allocation, even when an allocator is passed in!
                        //
                        unsigned cbBstr;
                        switch ( var.vt )
                        {
                        case VT_BSTR:
                        {
                            Win4Assert(BufferMgr.GetFreeSize() == *pcbExtra);

                            cbBstr = BSTRLEN( var.bstrVal ) + sizeof(OLECHAR) + sizeof(DWORD);
                            BSTR bstr = (BSTR) BufferMgr.Allocate(cbBstr);

                            if ( 0 == bstr )
                            {
                                THROW ( CException ( E_OUTOFMEMORY ) );
                            }

                            RtlCopyMemory( bstr, &BSTRLEN(var.bstrVal), cbBstr );
                            SysFreeString( var.bstrVal );
                            var.bstrVal = (BSTR) (((DWORD *)bstr) + 1);
                            break;
                        }

                        case VT_BSTR|VT_VECTOR:
                        {
                            //
                            // The vector pointer storage is allocated
                            // using our allocator, but the bstrs are
                            // allocated using SysAllocString.
                            //

                            for ( unsigned i = 0; i < var.cabstr.cElems; i++ )
                            {
                                cbBstr = BSTRLEN( var.cabstr.pElems[i] ) +
                                         sizeof(OLECHAR) + sizeof (DWORD);

                                BSTR bstr = (BSTR) BufferMgr.Allocate(cbBstr);

                                if ( 0 == bstr )
                                {
                                    THROW ( CException ( E_OUTOFMEMORY ) );
                                }

                                RtlCopyMemory( bstr,
                                               &BSTRLEN(var.cabstr.pElems[i]),
                                               cbBstr);

                                SysFreeString(var.cabstr.pElems[i]);
                                var.cabstr.pElems[i] = (BSTR) (((DWORD *) bstr) + 1);
                            }
                            break;
                        }
                        }
                    }
                    else if (var.vt == (VT_VECTOR|VT_VARIANT))
                    {
                        ciDebugOut(( DEB_ERROR, "ReadVariable - Variant Vector Type\n" ));
                    }
                }
                #if CIDBG==1
                    if ( (var.vt&0x0fff) > VT_CLSID )
                    {
                        ciDebugOut(( DEB_ERROR, "Bad Variant Type 0x%X\n", var.vt ));
                        Win4Assert( !"Call KyleP" );
                    }
                #endif  // CIDBG==1
            }
        }
        *pcbExtra = cb;
    }

    return TRUE;
}

//+---------------------------------------------------------------------------
//
//  Member:     COnDiskPropertyRecord::WriteFixed, public
//
//  Synopsis:   Write fixed-length property
//
//  Arguments:  [Ordinal]  -- Ordinal of property to locate.
//              [mask]     -- Bitmask of ordinal.  Pre-computed for efficiency.
//              [oStart]   -- Offset to start of specific property.
//              [Type]     -- Expected data type (for type checking)
//              [cTotal]   -- Total number of properties in record.
//              [var]      -- Value to store.
//
//  History:    27-Dec-95   KyleP       Created.
//
//----------------------------------------------------------------------------

void COnDiskPropertyRecord::WriteFixed( ULONG Ordinal,
                                        ULONG Mask,
                                        ULONG oStart,
                                        ULONG Type,
                                        ULONG cTotal,
                                        CStorageVariant const & var )
{
    if ( var.Type() != (VARENUM)Type )
    {
#       if CIDBG == 1
            if ( var.Type() != VT_EMPTY )
                ciDebugOut(( DEB_WARN, "Type mismatch (%d vs. %d) writing fixed property\n",
                             var.Type(), Type ));
#       endif

        ClearStored( Ordinal, Mask );
        return;
    }

    //
    // Start is after existance bitmap
    //

    ULONG * pulStart = 0;
    if (IsLeanRecord())
        pulStart = &((SLeanRecord *)&Data)->_aul[ (cTotal-1) / 16 + 1 + oStart];
    else
        pulStart = &((SNormalRecord *)&Data)->_aul[ (cTotal-1) / 16 + 1 + oStart];

    ciDebugOut(( DEB_PROPSTORE,
                 "Writing fixed prop, ordinal %d (type %d) at offset 0x%x (%d) in record.\n",
                 Ordinal,
                 var.Type(),
                 (ULONG)((ULONG_PTR)pulStart - (ULONG_PTR)this),
                 (ULONG)((ULONG_PTR)pulStart - (ULONG_PTR)this) ));

    switch ( var.Type() )
    {
    case VT_I1:
    case VT_UI1:
        {
            ULONG ul = var.GetUI1();
            *pulStart = ul;
        }
        break;

    case VT_I2:
    case VT_UI2:
    case VT_BOOL:
        {
            ULONG ul = var.GetUI2();
            *pulStart = ul;
        }
        break;

    case VT_I4:
    case VT_UI4:
    case VT_R4:
    case VT_ERROR:
        *pulStart = var.GetUI4();
        break;

    case VT_I8:
    case VT_UI8:
    case VT_R8:
    case VT_CY:
    case VT_DATE:
    case VT_FILETIME:
        {
            ULARGE_INTEGER uli = var.GetUI8();
            RtlCopyMemory( pulStart, &uli, sizeof(uli) );
        }
        break;

    case VT_CLSID:
        RtlCopyMemory( pulStart, var.GetCLSID(), sizeof(CLSID) );
        break;

    default:
        Win4Assert( !"How did I get here?" );
        ClearStored( Ordinal, Mask );
        break;
    }

    SetStored( Ordinal, Mask );
}

//+---------------------------------------------------------------------------
//
//  Member:     COnDiskPropertyRecord::WriteVariable, public
//
//  Synopsis:   Write variable-length property
//
//  Arguments:  [Ordinal]  -- Ordinal of property to locate.
//              [mask]     -- Bitmask of ordinal.  Pre-computed for efficiency.
//              [oStart]   -- Offset to start of variable length area.
//              [cTotal]   -- Total number of properties in record.
//              [cFixed]   -- Count of fixed length properties
//              [culRec]   -- Size (in dwords) of record
//              [var]      -- Value to store.
//
//  Returns:    FALSE if record must be stored in overflow record.
//
//  History:    27-Dec-95   KyleP       Created.
//
//----------------------------------------------------------------------------

BOOL COnDiskPropertyRecord::WriteVariable( ULONG Ordinal,
                                           ULONG Mask,
                                           ULONG oStart,
                                           ULONG cTotal,
                                           ULONG cFixed,
                                           ULONG culRec,
                                           CStorageVariant const & var,
                                           PStorage & storage )
{
    Win4Assert(!IsLeanRecord());

    ULONG * pulStart = FindVariableProp( Ordinal, cFixed, cTotal, oStart );

    //
    // Are we freeing this property?
    //

    if ( var.Type() == VT_EMPTY )
    {
        ClearStored( Ordinal, Mask );
        ClearStoredOnOverflow( Ordinal, Mask );

        //
        // Overflow case: We need to fake the overflow to clean up linked records.
        //

        if ( IsOverflow( *pulStart ) )
        {
            SetUsedSize( pulStart, 0 );
            return FALSE;
        }
        else
        {
            //
            // Adjust size field, and total variable space for record.
            //

            Win4Assert( VariableUsed() >= UsedSize( *pulStart ) );
            SetVariableUsed(VariableUsed() - UsedSize( *pulStart ));

            SetUsedSize( pulStart, 0 );

            return TRUE;
        }
    }

    //
    // No matter what happens, we want to indicate the property was stored.
    //

    SetStored( Ordinal, Mask );
    ClearStoredOnOverflow( Ordinal, Mask );


    //
    // Compute the length of the property.
    //

    ULONG cul = 0;
    BOOL fUnicodeSpecial = IsUnicodeSpecial( var, cul );

    if ( !fUnicodeSpecial )
    {
        StgConvertVariantToProperty( (PROPVARIANT *)(ULONG_PTR)&var,
                                     CP_WINUNICODE,
                                     0,
                                     &cul,
                                     pidInvalid,
                                     FALSE,
                                     0 );

        Win4Assert( cul > 0 );
        cul = (cul - 1) / sizeof(ULONG) + 1;
    }

    ULONG culPrevUsed = UsedSize( *pulStart );

    //
    // Do we fit?
    //

    if ( cul > AllocatedSize( *pulStart ) )
    {
        //
        // Can we fit?
        //

        if ( cul >
             UsedSize( *pulStart ) + FreeVariableSpace( cTotal, cFixed, oStart, culRec ) )
        {
            ciDebugOut(( DEB_PROPSTORE, "Need overflow buffer for ordinal %u\n", Ordinal ));

            //
            // If we had a previous value, adjust total variable space for record.
            //

            if ( !IsOverflow( *pulStart ) )
            {
                Win4Assert( VariableUsed() >= UsedSize( *pulStart ) );
                SetVariableUsed(VariableUsed() - UsedSize( *pulStart ));
            }

            MarkOverflow( pulStart );
            SetStoredOnOverflow( Ordinal, Mask );
            return FALSE;
        }

        //
        // Need to move properties, but there *is* room in record for the shift.
        //

        //
        // First, compress previous properties.
        //

        #if CIDBG
            ULONG * pulOldStart = pulStart;
        #endif

        pulStart = LeftCompress( FindVariableProp( cFixed, cFixed, cTotal, oStart ),
                                 0,
                                 pulStart );

        ciDebugOut(( DEB_PROPSTORE,
                     "Freeing up %d bytes for variable prop %d via left compression\n",
                     (pulOldStart - pulStart) * 4,
                     Ordinal ));

        //
        // Then, if needed, push additional properties farther out.
        //

        if ( cul > AllocatedSize( *pulStart ) )
        {
            ULONG * pulNext = pulStart + AllocatedSize(*pulStart) + 1;
            ULONG   culDelta = cul - AllocatedSize(*pulStart);

            ciDebugOut(( DEB_PROPSTORE,
                         "Freeing up %d bytes for variable prop %d, starting at offset 0x%x (%d) via right compression\n",
                         culDelta * 4,
                         Ordinal,
                         (ULONG)((ULONG_PTR)pulNext - (ULONG_PTR)this),
                         (ULONG)((ULONG_PTR)pulNext - (ULONG_PTR)this) ));

            Win4Assert( Ordinal < cTotal );

            RightCompress( pulNext,                  // Next property
                           culDelta,                 // Amount to shift
                           cTotal - Ordinal - 1 );   // # props left in record

            SetAllocatedSize( pulStart, cul );
        }

        Win4Assert( cul <= AllocatedSize( *pulStart ) );
    }

    //
    // Adjust size field, and total variable space for record.
    //

    SetVariableUsed(VariableUsed() + cul - culPrevUsed);

    SetUsedSize( pulStart, cul );
    pulStart++;  // Skip size field

    Win4Assert( AllocatedSize( *(pulStart - 1)) >= UsedSize( *(pulStart - 1) ) );
    ciDebugOut(( DEB_PROPSTORE,
                 "Writing variable prop, ordinal %d at offset 0x%x (%d) in record. Size = %d bytes.\n",
                 Ordinal,
                 (ULONG)((ULONG_PTR)pulStart - (ULONG_PTR)this),
                 (ULONG)((ULONG_PTR)pulStart - (ULONG_PTR)this),
                 UsedSize(*(pulStart - 1)) * 4 ));

    if ( fUnicodeSpecial )
    {
        WriteUnicodeSpecial( var, (SERIALIZEDPROPERTYVALUE *)pulStart );
    }
    else
    {
        cul *= 4;
        if ( 0 == StgConvertVariantToProperty( (PROPVARIANT *)(ULONG_PTR)&var,
                                               CP_WINUNICODE,
                                               (SERIALIZEDPROPERTYVALUE *)pulStart,
                                               &cul,
                                               pidInvalid,
                                               FALSE,
                                               0 ) )
        {
            ciDebugOut(( DEB_ERROR, "Error marshalling property!\n" ));
            Win4Assert( !"Corrupt property store" );
            storage.ReportCorruptComponent( L"PropertyRecord2" );

            THROW( CException( CI_CORRUPT_CATALOG ) );
        }
    }

    return TRUE;
}

//+---------------------------------------------------------------------------
//
//  Member:     COnDiskPropertyRecord::CountNormalRecordsToStore, public
//
//  Synopsis:   Compute size of value
//
//  Arguments:  [cTotal]   -- Total number of properties in record.
//              [culRec]   -- Size (in dwords) of record
//              [var]      -- Value to store.
//
//  Returns:    Size in records needed to store property.
//
//  History:    27-Dec-95   KyleP       Created.
//
//----------------------------------------------------------------------------

ULONG COnDiskPropertyRecord::CountNormalRecordsToStore( ULONG cTotal,
                                                        ULONG culRec,
                                                        CStorageVariant const & var )
{
    //
    // Compute the length of the property.
    //

    ULONG cul = 0;
    BOOL fUnicodeSpecial = IsUnicodeSpecial( var, cul );

    if ( !fUnicodeSpecial )
    {
        StgConvertVariantToProperty( (PROPVARIANT *)(ULONG_PTR)&var,
                                     CP_WINUNICODE,
                                     0,
                                     &cul,
                                     pidInvalid,
                                     FALSE,
                                     0 );

        Win4Assert( cul > 0 );
        cul = (cul - 1) / sizeof(ULONG) + 1;
    }

    //
    // Add on the fixed overhead. We are computing cul to determine the number
    // of records to use as a single overflow record. Since we will end up with
    // a record of length >= culRec, we are assured that the overflow record has
    // enough space for free list mgmt. Hence we don't need to account for space
    // required for free list mgmt when computing cul.
    //
    cul += MinimalOverheadNormal() +       // Minimal overhead for normal records
           (cTotal - 1) / 16 + 1 + // Existence bitmap
           cTotal;                 // Used/Alloc sizes

    return (cul - 1) / culRec + 1;
}

//+---------------------------------------------------------------------------
//
//  Member:     COnDiskPropertyRecord::RightCompress, public
//
//  Synopsis:   Moves data from [pul], [cul] dwords up.
//
//  Arguments:  [pul]        -- Start of area to move.
//              [cul]        -- Count of dwords to move
//              [cRemaining] -- Count of values remaining in buffer.  Needed
//                              because it is impossible to distinguish
//                              used/alloc blocks from empty space.
//
//  History:    27-Dec-95   KyleP       Created.
//
//----------------------------------------------------------------------------

void COnDiskPropertyRecord::RightCompress( ULONG * pul, ULONG cul, ULONG cRemaining )
{
    //
    // Termination condition for recursion: We've scanned all variable
    // properties in this record.  Any remaining space in record is
    // guaranteed to be free.
    //

    if ( 0 == cRemaining )
        return;

    ULONG FreeSpace = AllocatedSize(*pul) - UsedSize(*pul);
    if ( FreeSpace >= cul )
    {
        SetAllocatedSize( pul, AllocatedSize(*pul) - cul );
    }
    else
    {
        RightCompress( pul + AllocatedSize(*pul) + 1, cul - FreeSpace, cRemaining - 1 );
        SetAllocatedSize( pul, UsedSize(*pul) );
    }
    RtlMoveMemory( pul + cul, pul, (UsedSize(*pul) + 1) * 4 );
}

//+---------------------------------------------------------------------------
//
//  Member:     COnDiskPropertyRecord::LeftCompress, public
//
//  Synopsis:   Moves data from [pul], [cul] dwords down.
//
//  Arguments:  [pul]    -- Start of area to move.
//              [cul]    -- Count of dwords to move
//              [pulEnd] -- Terminating property.  This property will have
//                          it's allocated size increased with all the slack
//                          from previous properties and have its used size
//                          set to 0.
//
//  Returns:    New pointer to pulEnd (which moved down by [cul] bytes).
//
//  History:    27-Dec-95   KyleP       Created.
//
//----------------------------------------------------------------------------

ULONG * COnDiskPropertyRecord::LeftCompress( ULONG * pul, ULONG cul, ULONG * pulEnd )
{
    //
    // Terminating recursion? Just copy the allocated info.  Used size is
    // zero, because data isn't copied.
    //

    if ( pul == pulEnd )
    {
        pul -= cul;

        SetAllocatedSize( pul, AllocatedSize(*pulEnd) + cul );
        SetUsedSize( pul, 0 );

        return pul;
    }

    //
    // First, move current record.
    //

    if ( cul > 0 )
    {
        RtlMoveMemory( pul - cul, pul, (UsedSize(*pul) + 1) * 4 );
        pul -= cul;
    }

    //
    // Adjust allocation size.
    //

    cul += ( AllocatedSize(*pul) - UsedSize(*pul) );
    SetAllocatedSize( pul, UsedSize(*pul) );

    return LeftCompress( pul + cul + UsedSize(*pul) + 1, cul, pulEnd );
}

//+---------------------------------------------------------------------------
//
//  Member:     COnDiskPropertyRecord::IsUnicodeSpecial, private
//
//  Synopsis:   Determines if variant is Unicode string with all 0 high bytes.
//
//  Arguments:  [var] -- Variant to check
//              [cul] -- On TRUE, returns count of DWORDs needed to store
//
//  Returns:    TRUE if [var] is a Unicode string with all 0 high bytes.
//
//  History:    17-Jul-97   KyleP   Created
//
//----------------------------------------------------------------------------

BOOL COnDiskPropertyRecord::IsUnicodeSpecial( CStorageVariant const & var,
                                              ULONG & cul )
{
    if ( VT_LPWSTR != var.Type() )
        return FALSE;

    //
    // Loop through string, looking for non-null high bytes.
    //

    for ( WCHAR const * pwc = var.GetLPWSTR();
          0 != *pwc && 0 == (*pwc & 0xFF00 );
          pwc++ )
    {
        continue;   // Null body
    }

    cul = 1 +                                 // Type (VT_ILLEGAL)
          1 +                                 // Size
          (ULONG)(pwc - var.GetLPWSTR() + 3) / sizeof(ULONG);    // Characters

    return (0 == *pwc);
}

//+---------------------------------------------------------------------------
//
//  Member:     COnDiskPropertyRecord::IsUnicodeSpecial, private
//
//  Synopsis:   Determines if serialized property is stored in special
//              compressed Unicode format.
//
//  Arguments:  [pProp] -- Serialized buffer to check.
//              [cb]    -- On TRUE, returns size in bytes of deserialized
//                         string.
//
//  Returns:    TRUE if [pProp] contains Unicode string serialized in special
//              format.
//
//  History:    17-Jul-97   KyleP   Created
//
//----------------------------------------------------------------------------

BOOL COnDiskPropertyRecord::IsUnicodeSpecial( SERIALIZEDPROPERTYVALUE const * pProp,
                                              ULONG & cb )
{
    if ( VT_ILLEGAL != pProp->dwType )
        return FALSE;

    cb = ((*(ULONG *)pProp->rgb) + 1) * sizeof(WCHAR);

    return TRUE;
}

//+---------------------------------------------------------------------------
//
//  Member:     COnDiskPropertyRecord::WriteUnicodeSpecial, private
//
//  Synopsis:   Serializes 'Special' Unicode string to buffer.
//
//  Arguments:  [var]   -- Contains Unicode string
//              [pProp] -- Serialize to here
//
//  History:    17-Jul-97   KyleP   Created
//
//----------------------------------------------------------------------------

void COnDiskPropertyRecord::WriteUnicodeSpecial( CStorageVariant const & var,
                                                 SERIALIZEDPROPERTYVALUE * pProp )
{
    Win4Assert( VT_LPWSTR == var.Type() );

    pProp->dwType = VT_ILLEGAL;

    WCHAR const * pwcIn = var.GetLPWSTR();

    for ( unsigned i = 0; 0 != *pwcIn; i++, pwcIn++ )
    {
        Win4Assert( 0 == (*pwcIn & 0xFF00) );

        pProp->rgb[4 + i] = (BYTE)(*pwcIn);
    }

    *(ULONG *)pProp->rgb = i;
}

//+---------------------------------------------------------------------------
//
//  Member:     COnDiskPropertyRecord::ReadUnicodeSpecial, private
//
//  Synopsis:   Deserializes Unicode string stored in 'Special' format.
//
//  Arguments:  [pProp]   -- Serialized buffer
//              [var]     -- Variant written here
//              [pbExtra] -- Memory to use for string itself
//
//  History:    17-Jul-97   KyleP   Created
//
//----------------------------------------------------------------------------

void COnDiskPropertyRecord::ReadUnicodeSpecial( SERIALIZEDPROPERTYVALUE const * pProp,
                                                PROPVARIANT & var,
                                                BYTE * pbExtra )
{
    Win4Assert( VT_ILLEGAL == pProp->dwType );
    var.vt = VT_LPWSTR;

    ULONG cc = *(ULONG *)pProp->rgb;
    var.pwszVal = (WCHAR *)pbExtra;

    for ( unsigned i = 0; i < cc; i++ )
    {
        var.pwszVal[i] = pProp->rgb[4+i];
    }

    var.pwszVal[i] = 0;
}

//+---------------------------------------------------------------------------
//
//  Member:     COnDiskPropertyRecord::ReadUnicodeSpecial, private
//
//  Synopsis:   Deserializes Unicode string stored in 'Special' format. This
//              version uses CoTaskMemAlloc for additional memory.
//
//  Arguments:  [pProp]   -- Serialized buffer
//              [var]     -- Variant written here
//
//  History:    17-Jul-97   KyleP   Created
//
//----------------------------------------------------------------------------

void COnDiskPropertyRecord::ReadUnicodeSpecialCTMA( SERIALIZEDPROPERTYVALUE const * pProp,
                                                    PROPVARIANT & var )
{
    Win4Assert( VT_ILLEGAL == pProp->dwType );
    var.vt = VT_LPWSTR;

    ULONG cc = *(ULONG *)pProp->rgb;

    var.pwszVal = (WCHAR *)CoTaskMemAlloc( (cc + 1)*sizeof(WCHAR) );

    if ( 0 == var.pwszVal )
    {
        THROW( CException( E_OUTOFMEMORY ) );
    }

    for ( unsigned i = 0; i < cc; i++ )
    {
        var.pwszVal[i] = pProp->rgb[4+i];
    }

    var.pwszVal[i] = 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\ntciutil\secstore.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996 - 2002.
//
//  File:       secstore.cxx
//
//  Contents:   SDID to security descriptor mapping table
//
//  History:    29 Jan 1996   AlanW    Created
//
//----------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include <cistore.hxx>
#include <rcstxact.hxx>
#include <rcstrmit.hxx>
#include <catalog.hxx>

#include <secstore.hxx>



//+-------------------------------------------------------------------------
//
//  Method:     CSdidLookupTable::CSdidLookupTable, public
//
//  Synopsis:   Constructor of a CSdidLookupTable
//
//  Arguments:  -NONE-
//
//  Returns:    Nothing
//
//--------------------------------------------------------------------------

CSdidLookupTable::CSdidLookupTable( )
    : _pTable( 0 ),
      _xrsoSdidTable( 0 ),
      _mutex(),
      _cache()
{
}

void CSdidLookupTable::Empty()
{
    CLock lock ( _mutex );

    delete [] _pTable; _pTable = 0;
    _xrsoSdidTable.Free();
    _cache.Empty();
}

CSdidLookupTable::~CSdidLookupTable( )
{
    Empty();
}

//+---------------------------------------------------------------------------
//
//  Member:     CSdidLookupTable::Init, public
//
//  Synopsis:   Loads metadata from persistent location into memory.
//
//  Arguments:  [pobj] -- Stream(s) in which metadata is stored.
//
//  History:    27-Dec-95   KyleP       Created.
//
//----------------------------------------------------------------------------

BOOL CSdidLookupTable::Init( CiStorage * pobj )
{
    CLock lock ( _mutex );

    _xrsoSdidTable.Set( pobj->QuerySdidLookupTable( eSecStoreWid ) );

    //
    // Load header
    //

    CRcovStorageHdr & hdr = _xrsoSdidTable->GetHeader();
    struct CRcovUserHdr data;
    hdr.GetUserHdr( hdr.GetPrimary(), data );

    RtlCopyMemory( &_Header, &data._abHdr, sizeof(_Header) );

    ciDebugOut(( DEB_SECSTORE, "SECSTORE: Record size = %d bytes\n", _Header.cbRecord ));
    ciDebugOut(( DEB_SECSTORE, "SECSTORE: %d file records\n", _Header.cRecords ));
    ciDebugOut(( DEB_SECSTORE, "SECSTORE: Hash size = %u\n", _Header.cHash ));

    if ( _Header.cHash == 0 )
    {
        Win4Assert( 0 == Records() && _Header.cbRecord == 0 );
        RtlCopyMemory( _Header.Signature, "SECSTORE", sizeof _Header.Signature );
        Win4Assert( (sizeof (SSdHeaderRecord) + SECURITY_DESCRIPTOR_MIN_LENGTH)
                    < SECSTORE_REC_SIZE );

        _Header.cbRecord = SECSTORE_REC_SIZE;
        _Header.cHash = SECSTORE_HASH_SIZE;
        _Header.cRecords = 0;
    }
    else
    {
        Win4Assert( RtlEqualMemory( _Header.Signature, "SECSTORE",
                                    sizeof _Header.Signature) &&
                    _Header.cbRecord == SECSTORE_REC_SIZE &&
                    _Header.cHash == SECSTORE_HASH_SIZE );

        if ( ! RtlEqualMemory( _Header.Signature, "SECSTORE",
                               sizeof _Header.Signature) ||
             _Header.cbRecord != SECSTORE_REC_SIZE ||
             _Header.cHash != SECSTORE_HASH_SIZE )
            return FALSE;
    }

    //
    // Load hash table
    //

    ULONG cRecordsFromFile = Records();
    ULONG iRecord = 1;

    _pTable = new SDID [ _Header.cHash ];
    RtlZeroMemory( _pTable, _Header.cHash * sizeof (SDID) );

    _Header.cRecords = 0;

#if  (DBG == 1)
    _cMaxChainLen = 0;
    _cTotalSearches = 0;
    _cTotalLength = 0;
#endif // (DBG == 1)


    CRcovStrmReadTrans xact( _xrsoSdidTable.GetReference() );
    CRcovStrmReadIter  iter( xact, SECSTORE_REC_SIZE );

    BYTE temp[ SECSTORE_REC_SIZE ];

    while ( iter.GetRec( &temp, iRecord-1 ) )
    {
        SSdHeaderRecord SdHdr = *(SSdHeaderRecord *)temp;

        Win4Assert( SdHdr.cbSD >= SECURITY_DESCRIPTOR_MIN_LENGTH &&
                    SdHdr.cbSD < 256 * 1024 &&
                    _pTable[ SdHdr.ulHash % SECSTORE_HASH_SIZE ] ==
                      SdHdr.iHashChain );

        if ( SdHdr.cbSD < SECURITY_DESCRIPTOR_MIN_LENGTH ||
             SdHdr.cbSD >= 256 * 1024 ||
             _pTable[ SdHdr.ulHash % SECSTORE_HASH_SIZE ] != SdHdr.iHashChain )
            return FALSE;

        _pTable[ SdHdr.ulHash % SECSTORE_HASH_SIZE ] = iRecord;

        ciDebugOut(( DEB_SECSTORE,
                     "SECSTORE: SD record\tSDID = %d, cb = %d, hash = %08x, chain = %d\n",
                     iRecord, SdHdr.cbSD, SdHdr.ulHash, SdHdr.iHashChain ));

#ifdef UNIT_TEST

        // much below is debug code; don't need to allocate
        // the SD here; just seek to the start of each record
        // and read the record header.

        XArray<BYTE> pbSD ( SdHdr.cbSD );
        BYTE * pbDst = pbSD.GetPointer();
        BYTE * pbSrc = &temp[0] + sizeof (SSdHeaderRecord);
        ULONG cb = SdHdr.cbSD;

        ULONG cbPart = SECSTORE_REC_SIZE - sizeof (SSdHeaderRecord);

        if (cb < cbPart)
           cbPart = cb;

        RtlCopyMemory( pbDst, pbSrc, cbPart );

        pbDst += cbPart;
        cb -= cbPart;
        pbSrc = &temp[0];

        while( 0 != cb )
        {
            iter.GetRec( temp );
            cbPart = (cb > SECSTORE_REC_SIZE) ? SECSTORE_REC_SIZE : cb;
            RtlCopyMemory( pbDst, pbSrc, cbPart );

            pbDst += cbPart;
            cb -= cbPart;
            pbSrc = &temp[0];
            iRecord++;
        }

        PSECURITY_DESCRIPTOR pSD = pbSD.GetPointer();
        Win4Assert( SdHdr.cbSD == GetSecurityDescriptorLength( pSD ) &&
                    SdHdr.ulHash == Hash( pSD, SdHdr.cbSD ) );
        iRecord++;
#else
        iRecord += (SdHdr.cbSD + (sizeof SdHdr) + SECSTORE_REC_SIZE - 1) /
                    SECSTORE_REC_SIZE;
#endif
        _Header.cRecords = iRecord - 1;
    }

    Win4Assert( Records() == cRecordsFromFile );

    return TRUE;
}


//+-------------------------------------------------------------------------
//
//  Method:     CSdidLookupTable::Hash, public
//
//  Synopsis:   Generate a hash value for the passed SECURITY_DESCRIPTOR
//
//  Arguments:  [pSD] -- pointer to SECURITY_DESCRIPTOR
//              [cb] -- length of SECURITY_DESCRIPTOR in bytes
//
//  Returns:    ULONG - Hash value for the input SECURITY_DESCRIPTOR
//
//--------------------------------------------------------------------------

ULONG CSdidLookupTable::Hash(const PSECURITY_DESCRIPTOR pSD, unsigned cb)
{
    ULONG ulHash = 0;
    BYTE * pb = (BYTE *) pSD;

    while (cb-- != 0)
    {
        if (ulHash & 0x80000000)
        {
            ulHash = (ulHash << 1) | 1;
        }
        else
        {
            ulHash <<= 1;
        }
        ulHash ^= *pb++;
    }
    return(ulHash);
}


//+---------------------------------------------------------------------------
//
//  Method:     CSdidLookupTable::Lookup, private
//
//  Synopsis:   Looks up a security descriptor in the table.
//
//  Arguments:  [sdid]    - SDID to look up.
//
//  Returns:    CSdidLookupEntry* - pointer to entry for SDID
//
//  History:    29 Jan 1996   Alanw   Created
//
//  Notes:      The security descriptor entry will be owned by
//              the caller after the call.
//
//----------------------------------------------------------------------------

CSdidLookupEntry * CSdidLookupTable::Lookup( SDID sdid )
{
    Win4Assert( sdid <= Records() );
    Win4Assert( !_xrsoSdidTable.IsNull() );

    if ( sdid > Records() )
    {
        return 0;
    }

    CSdidLookupEntry * pEntry = 0;

    CLock lock ( _mutex );

    //
    //  First see if the desired item is in the cache
    //
    for ( CSdidCacheIter listiter( _cache );
          !_cache.AtEnd( listiter );
          _cache.Advance( listiter ) )
    {
        if ( listiter.GetEntry()->Sdid() == sdid )
        {
            pEntry = listiter.GetEntry();
            _cache.RemoveFromList( pEntry );
            return pEntry;
        }
    }

    XPtr<CSdidLookupEntry> xEntry;

    //
    //  The entry was not in the cache.  Read it from storage.
    //
    TRY
    {
        // Corrupt?
        if (_xrsoSdidTable.IsNull())
            THROW(CException(CI_CORRUPT_DATABASE));

        xEntry.Set( new CSdidLookupEntry(sdid) );

        CRcovStrmReadTrans xact( _xrsoSdidTable.GetReference() );
        CRcovStrmReadIter  iter( xact, SECSTORE_REC_SIZE );

        LoadTableEntry( iter, xEntry.GetReference(), sdid );
    }
    CATCH(CException, e)
    {
        ciDebugOut(( DEB_WARN, "CSdidLookupTable::Lookup - exception %x\n",
                     e.GetErrorCode() ));
        if (e.GetErrorCode() != STATUS_ACCESS_VIOLATION)
            RETHROW();
    }
    END_CATCH

    return xEntry.Acquire();
}


//+---------------------------------------------------------------------------
//
//  Method:     CSdidLookupTable::LookUpSDID, public
//
//  Synopsis:   Looks up a security descriptor's ID in the table.
//              Add the SD to the table if not found.
//
//  Arguments:  [pSD]    - SD to look up.
//              [cbSD]   - size of security descriptor
//
//  Returns:    SDID - ID of security descriptor input
//
//  History:    29 Jan 1996   Alanw   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

SDID CSdidLookupTable::LookupSDID( PSECURITY_DESCRIPTOR pSD, ULONG cbSD )
{
    Win4Assert( (((SECURITY_DESCRIPTOR *)pSD)->Control & SE_SELF_RELATIVE) &&
                GetSecurityDescriptorLength( pSD ) == cbSD );
    Win4Assert( !_xrsoSdidTable.IsNull() );

    SDID iSdid = 0;
    BOOL fFound = FALSE;
#if  (DBG == 1)
    ULONG cSearchLen = 0;
#endif // (DBG == 1)

    ULONG ulHash = Hash( pSD, cbSD );

    CLock lock ( _mutex );

    //
    //  First see if a matching item is in the cache
    //
    for ( CSdidCacheIter listiter( _cache );
          !_cache.AtEnd( listiter );
          _cache.Advance( listiter ) )
    {
        if ( listiter.GetEntry()->IsEqual( pSD, cbSD, ulHash ) )
        {
            Win4Assert( listiter.GetEntry()->Sdid() > 0 );
            return listiter.GetEntry()->Sdid();
        }
    }

    //
    //  The SD was not found in the cache.  Try looking in storage.
    //
    TRY
    {
        SDID iNext = _pTable[ ulHash % HashSize() ];
        if (iNext != 0)
        {
            CRcovStrmReadTrans xact( _xrsoSdidTable.GetReference() );
            CRcovStrmReadIter  iter( xact, SECSTORE_REC_SIZE );

            BYTE temp[ SECSTORE_REC_SIZE ];

            while (iNext != 0)
            {
#if  (DBG == 1)
                cSearchLen++;
#endif // (DBG == 1)
                iter.GetRec( &temp, iNext-1 );
                SSdHeaderRecord * pSdHdr = (SSdHeaderRecord *)temp;

                Win4Assert( pSdHdr->cbSD >= SECURITY_DESCRIPTOR_MIN_LENGTH &&
                            pSdHdr->iHashChain < iNext );

                if (pSdHdr->cbSD == cbSD && pSdHdr->ulHash == ulHash)
                {
                    // The byte count and hash value match.  Fetch the rest of
                    // the SD to compare it byte-for-byte.

                    XPtr<CSdidLookupEntry> xEntry( new CSdidLookupEntry( iNext ) );

                    LoadTableEntry( iter, xEntry.GetReference(), iNext );

                    if (RtlEqualMemory( pSD, xEntry->GetSD(), cbSD))
                    {
                       fFound = TRUE;
                       iSdid = iNext;
                       _cache.Add( xEntry.Acquire() );
                    }
                }

                iNext = pSdHdr->iHashChain;
            }
        }

        if (! fFound)
        {
            //
            //  The SD was not found.
            //  Write new mapping to the recoverable storage.
            //

            iSdid = Records() + 1;

            CRcovStorageHdr & hdr = _xrsoSdidTable->GetHeader();
            CRcovStrmAppendTrans xact( _xrsoSdidTable.GetReference() );
            CRcovStrmAppendIter  iter( xact, SECSTORE_REC_SIZE );

            BYTE temp[ SECSTORE_REC_SIZE ];
            SSdHeaderRecord * pSdHdr = (SSdHeaderRecord *)temp;

            pSdHdr->cbSD = cbSD;
            pSdHdr->ulHash = ulHash;
            pSdHdr->iHashChain = _pTable[ ulHash % HashSize() ];

            BYTE * pbDst = &temp[0] + sizeof (SSdHeaderRecord);
            BYTE * pbSrc = (BYTE *)pSD;
            ULONG cb = cbSD;

            ULONG cbPart = SECSTORE_REC_SIZE - sizeof (SSdHeaderRecord);

            if (cb < cbPart)
               cbPart = cb;

            RtlCopyMemory( pbDst, pbSrc, cbPart );

            pbSrc += cbPart;
            cb -= cbPart;

            iter.AppendRec( temp );
            ULONG cRecordsWritten = 1;

            while( 0 != cb )
            {
                if (cb >= SECSTORE_REC_SIZE)
                {
                    iter.AppendRec( pbSrc );
                    cbPart = SECSTORE_REC_SIZE;
                }
                else
                {
                    cbPart = (cb > SECSTORE_REC_SIZE) ? SECSTORE_REC_SIZE : cb;
                    RtlCopyMemory( temp, pbSrc, cbPart );
                    RtlZeroMemory( &temp[cbPart], SECSTORE_REC_SIZE - cbPart );
                    iter.AppendRec( temp );
                }
                pbSrc += cbPart;
                cb -= cbPart;
                cRecordsWritten++;
            }

            ciDebugOut(( DEB_SECSTORE,
                         "SECSTORE: new SD record\tSDID = %d, cb = %d, hash = %08x, chain = %d\n",
                         iSdid, cbSD, ulHash, _pTable[ ulHash % SECSTORE_HASH_SIZE ] ));

            _pTable[ ulHash % SECSTORE_HASH_SIZE ] = iSdid;
            _Header.cRecords += cRecordsWritten;

            struct CRcovUserHdr data;
            RtlCopyMemory( &data._abHdr, &_Header, sizeof(_Header) );

            Win4Assert( hdr.GetCount(hdr.GetBackup()) == hdr.GetCount(hdr.GetPrimary()) + cRecordsWritten);
            hdr.SetUserHdr( hdr.GetBackup(), data );
            xact.Commit();
        }
    }
    CATCH(CException, e)
    {
        ciDebugOut(( DEB_WARN, "CSdidLookupTable::LookupSDID - exception %x\n",
                     e.GetErrorCode() ));
        if (e.GetErrorCode() == STATUS_ACCESS_VIOLATION)
        {
            Win4Assert( !"Access violation in CSdidLookupTable::LookupSDID - "
                "Are you running two queries on the same downlevel catalog?" );
        }
        RETHROW();
    }
    END_CATCH

#if  (DBG == 1)
    // Update search statistics

    _cTotalSearches++;
    if (fFound)
    {
        _cTotalLength += cSearchLen;
    }
    else
    {
        if (cSearchLen >= _cMaxChainLen)
            _cMaxChainLen = cSearchLen + 1;
    }
#endif // (DBG == 1)
    return iSdid;
}


//+---------------------------------------------------------------------------
//
//  Method:     CSdidLookupTable::LoadTableEntry, private
//
//  Synopsis:   Loads a table entry for some SDID from the table.
//
//  Arguments:  [Iter]    - CRcovStrmReadIter for access to the stream
//              [Entry]   - CSdidTableEntry to be filled in
//              [iSdid]   - SDID to be looked up.
//
//  Returns:    Nothing
//
//  History:    29 Jan 1996   Alanw   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

void CSdidLookupTable::LoadTableEntry(
    CRcovStrmReadIter & iter,
    CSdidLookupEntry & Entry,
    SDID iSdid )
{
    Win4Assert( iSdid <= Records() );

    BYTE temp[ SECSTORE_REC_SIZE ];

    iter.GetRec( &temp, iSdid-1 );

    Entry._hdr = *(SSdHeaderRecord *)temp;

    Win4Assert( Entry._hdr.cbSD >= SECURITY_DESCRIPTOR_MIN_LENGTH &&
                Entry._hdr.cbSD < 256 * 1024 );

    ciDebugOut(( DEB_SECSTORE,
                 "SECSTORE: SD record\tSDID = %d, cb = %d, hash = %08x, chain = %d\n",
                 iSdid, Entry._hdr.cbSD, Entry._hdr.ulHash, Entry._hdr.iHashChain ));

    XArray<BYTE> pbSD ( Entry._hdr.cbSD );
    BYTE * pbDst = pbSD.GetPointer();
    BYTE * pbSrc = &temp[0] + sizeof (SSdHeaderRecord);
    ULONG cb = Entry._hdr.cbSD;

    ULONG cbPart = SECSTORE_REC_SIZE - sizeof (SSdHeaderRecord);

    if (cb < cbPart)
       cbPart = cb;

    RtlCopyMemory( pbDst, pbSrc, cbPart );

    pbDst += cbPart;
    cb -= cbPart;
    pbSrc = &temp[0];

    while( 0 != cb )
    {
        if (cb >= SECSTORE_REC_SIZE)
        {
            iter.GetRec( pbDst );
            cbPart = SECSTORE_REC_SIZE;
        }
        else
        {
            iter.GetRec( temp );
            cbPart = (cb > SECSTORE_REC_SIZE) ? SECSTORE_REC_SIZE : cb;
            RtlCopyMemory( pbDst, pbSrc, cbPart );
        }

        pbDst += cbPart;
        cb -= cbPart;
        pbSrc = &temp[0];
    }

    Win4Assert( Entry._hdr.cbSD == GetSecurityDescriptorLength( pbSD.GetPointer() ) &&
                Entry._hdr.ulHash == Hash( pbSD.GetPointer(), Entry._hdr.cbSD ) );

    Entry._pSD = pbSD.Acquire();
}


//+---------------------------------------------------------------------------
//
//  Method:     CSdidLookupTable::AccessCheck, public
//
//  Synopsis:   Performs an access check for some SDID, access mask combination
//
//  Arguments:  [sdid]     - SDID of file to be checked
//              [hToken]   - security token to be checked against
//              [am]       - access mode to be checked against
//              [fGranted] - TRUE is access is granted, FALSE otherwise
//
//  Returns:    BOOL - TRUE if access check was successful
//
//  History:    05 Feb 1996   Alanw   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

GENERIC_MAPPING gmFile = {
    FILE_GENERIC_READ,
    FILE_GENERIC_WRITE,
    FILE_GENERIC_EXECUTE,
    FILE_ALL_ACCESS
};

BOOL CSdidLookupTable::AccessCheck(
    SDID   sdid,
    HANDLE hToken,
    ACCESS_MASK am,
    BOOL & fGranted )
{
    Win4Assert( sdidInvalid != sdid && sdidNull != sdid );

    CSdidLookupEntry * pSD = Lookup( sdid );

    fGranted = FALSE;
    if ( 0 == pSD )
        return FALSE;

    PRIVILEGE_SET ps;
    ULONG ulPrivSize = sizeof ps;
    ACCESS_MASK GrantedAccess;

    BOOL fResult = ::AccessCheck( pSD->GetSD(),
                                  hToken,
                                  am,
                                  &gmFile,
                                  &ps,
                                  &ulPrivSize,
                                  &GrantedAccess,
                                  &fGranted);
    {
        CLock lock ( _mutex );
        _cache.Add( pSD );
    }

    return fResult;
}


//+---------------------------------------------------------------------------
//
//  Member:     CSdidLookupTable::GetSecurityDescriptor
//
//  Synopsis:   Retrieves the security descriptor for the given SDID.
//
//  Arguments:  [sdid]   - SDID to lookup
//              [pbData] - Pointer to the buffer to write the desc.
//              [cbIn]   - Size of the pSD buffer
//              [cbOut]  - Size of the security descriptor; if cbIn < cbOut,
//              then the buffer is not big enough to copy the data.
//
//  Returns:    S_OK              if successfully returned.
//              S_FALSE           if the buffer is not big enough to hold
//              the data. In this case cbOut will have the actual buffer
//              needed.
//              CI_E_NOT_FOUND    the sdid is not valid.
//
//  History:    7-18-97   srikants   Created
//
//----------------------------------------------------------------------------


HRESULT
CSdidLookupTable::GetSecurityDescriptor(
    SDID   sdid,
    PSECURITY_DESCRIPTOR pbData,
    ULONG cbIn,
    ULONG & cbOut )
{

    Win4Assert( sdidInvalid != sdid && sdidNull != sdid );

    CSdidLookupEntry * pSD = Lookup( sdid );

    if ( 0 == pSD )
        return CI_E_NOT_FOUND;

    cbOut = pSD->Size();

    if ( cbOut > cbIn )
        return S_FALSE;

    RtlCopyMemory( pbData, pSD->GetSD(), cbOut );
    return S_OK;
}


//+---------------------------------------------------------------------------
//
//  Member:     CSdidLookupTable::Save
//
//  Synopsis:   Makes a copy of the current security table using the
//              destination storage object.
//
//  Arguments:  [pIProgressNotify] - Progress notification.
//              [fAbort]           - Flag set to TRUE if the copy must
//              be aborted in the middle.
//              [dstStorage]       - Destination storage object to use
//              for creating the bakcup.
//              [ppFileList]       - List of files that constitute the
//              the security store.
//
//  History:    7-14-97   srikants   Created
//
//----------------------------------------------------------------------------

void CSdidLookupTable::Save( IProgressNotify * pIProgressNotify,
                             BOOL & fAbort,
                             CiStorage & dstStorage,
                             IEnumString **ppFileList )
{
    dstStorage.RemoveSecStore( eSecStoreWid );

    XPtr<PRcovStorageObj> xObj( dstStorage.QuerySdidLookupTable( eSecStoreWid ) );

    // ===============================================================
    CLock lock ( _mutex );

    //
    // Make a copy of the security table.
    //
    Win4Assert( !_xrsoSdidTable.IsNull() );
    CCopyRcovObject copyRcov( xObj.GetReference(),
                              _xrsoSdidTable.GetReference()  );
    copyRcov.DoIt();

    //
    // Retrive the names of the files that constitute the security store.
    //
    CEnumString * pEnumString = new CEnumString();
    XInterface<IEnumString> xEnumStr(pEnumString);

    dstStorage.ListSecStoreFileNames( *pEnumString, 0 );
    *ppFileList = xEnumStr.Acquire();
    // ===============================================================
}

//+---------------------------------------------------------------------------
//
//  Method:     CSdidCache::Add, public
//
//  Synopsis:   Add an SDID record to the lookaside cache
//
//  Arguments:  [pEntry]   - the item to be added to the cache
//
//  Returns:    Nothing
//
//  History:    18 Apr 1996   Alanw   Created
//
//  Notes:      The cache must be locked when this method is called.
//
//----------------------------------------------------------------------------

void CSdidCache::Add( CSdidLookupEntry * pEntry )
{

    //
    //  If the cache is full, check to see if the item is in the cache.  Another
    //  copy may have been added while we were using this one.
    //  If there is space in the cache, allow multiple copies of the same SDID.
    //

    if ( Count() >= _maxEntries )
    {
        for ( CSdidCacheIter iter( *this );
              !AtEnd( iter );
              Advance( iter ) )
        {
            if ( iter.GetEntry()->Sdid() == pEntry->Sdid() )
            {
                MoveToFront( iter.GetEntry() );
                delete pEntry;
                return;
            }
        }
    }

    //
    //  Add the entry to the front of the list.  If there are too many
    //  items in the cache, delete the last entry.
    //
    Push( pEntry );
    if ( Count() > _maxEntries )
    {
        delete RemoveLast();
    }
}


//+---------------------------------------------------------------------------
//
//  Method:     CSdidCache::Empty, public
//
//  Synopsis:   Clean out the lookaside cache
//
//  Arguments:  NONE
//
//  Returns:    Nothing
//
//  History:    18 Apr 1996   Alanw   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

void CSdidCache::Empty( )
{
    CSdidLookupEntry * pEntry = 0;
    while ( pEntry = Pop() )
        delete pEntry;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\ntciutil\rcstxact.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1991 - 2000.
//
//  File:       RCSTXACT.CXX
//
//  Contents:   RecoverableStream Transactions
//
//  Classes:    CRcovStrmTrans,
//              CRcovStrmReadTrans,
//              CRcovStrmWriteTrans,
//              CRcovStrmAppendTrans,
//              CRcovStrmMDTrans
//
//
//  History:    28-Jan-1994     SrikantS    Created
//
//----------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include <rcstxact.hxx>
#include <cifailte.hxx>
#include <eventlog.hxx>

#ifndef FACB_MAPPING_GRANULARITY
#define VACB_MAPPING_GRANULARITY 262144
#endif

#define  CI_PAGES_IN_CACHE_PAGE (VACB_MAPPING_GRANULARITY/CI_PAGE_SIZE)
#define  CACHE_PAGE_TO_CI_PAGE_SHIFT 6  // 64

//+---------------------------------------------------------------------------
//
//  Function:   CiPagesFromCachePages
//
//  Synopsis:   Given a number in "cache" page units, it converts into
//              "ci" pages. A cache page is 256K in size and a ci page is
//              4K in size.
//
//  Arguments:  [cachePage] - A number in cache page units
//
//  History:    10-17-95   srikants   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

inline LONGLONG CiPagesFromCachePages( const LONGLONG & cachePage )
{
    Win4Assert( (1 << CACHE_PAGE_TO_CI_PAGE_SHIFT) ==  CI_PAGES_IN_CACHE_PAGE );
    return cachePage << CACHE_PAGE_TO_CI_PAGE_SHIFT;
}

inline
ULONG PgCachePgTrunc(ULONG x)
{
    return x & ~(VACB_MAPPING_GRANULARITY - 1);
}

inline BOOL IsHighBitSet( ULONG ul )
{
    return ul & 0x80000000;
}

//+---------------------------------------------------------------------------
//
//  Member:     CRcovStrmTrans::CRcovStrmTrans
//
//  Synopsis:
//
//  Arguments:  [obj] -
//              [op]  -
//
//  Returns:
//
//  Modifies:
//
//  History:    1-28-94   srikants   Created
//              3-13-98   kitmanh    Don't Open backup mmstreams if catalog
//                                   is read-only
//
//  Notes:
//
//----------------------------------------------------------------------------

CRcovStrmTrans::CRcovStrmTrans( PRcovStorageObj &obj,
                                RcovOpType op
                              ) : _obj(obj),
                                  _hdr(obj.GetHeader()),
                                  _sObj(_obj)
{
    Win4Assert( opNone != op );

    //
    // Read the header from the disk.
    //
    _obj.ReadHeader();

    _iPrim = _hdr.GetPrimary();
    _iBack = _hdr.GetBackup();
    _iCurr = _iBack;

    //
    // Check if the backup is clean or not.
    //
    if ( !_hdr.IsBackupClean() )
    {
        ciDebugOut(( DEB_WARN, "CRcovStrmTrans::Cleaning up a Failed Previous Trans\n" ));

        //
        // Open the streams and create memory mapped streams for
        // accessing the backup in write mode and the primary in
        // read mode.
        //

        _obj.Open( _hdr.GetPrimary(), FALSE );

        // We can't cleanup if the catalog is read only, so just fail

        if ( obj.IsReadOnly() )
        {
            PStorage & storage = _obj.GetStorage();
            storage.ReportCorruptComponent( L"RcovStorageTrans2" );
            THROW (CException( CI_CORRUPT_DATABASE ) );
        }

        _obj.Open( _hdr.GetBackup(), TRUE );

        //
        // There is an assumption here that the primary stream
        // is as big as the header says but it was not true in a corrupt
        // shutdown.
        //
        PMmStream & primStrm = _obj.GetMmStream( _iPrim );
        LONGLONG llcbMinimum = _hdr.GetCbToSkip(_iPrim) +
                               _hdr.GetUserDataSize(_iPrim);

        if ( llcbMinimum > primStrm.Size() )
        {
            ciDebugOut((DEB_ERROR, "**** CI MAY HAVE LOST IMPORTANT INFO ***\n" ));
            ciDebugOut((DEB_ERROR, "**** EMPTYING CI RCOV OBJECT ***** \n" ));

            PStorage & storage = _obj.GetStorage();
            Win4Assert( !"Corrupt catalog" );

            storage.ReportCorruptComponent( L"RcovStorageTrans1" );

            Win4Assert( !"Recoverable object corrupt" );
            THROW (CException( CI_CORRUPT_DATABASE ) );
        }

        CleanupAndSynchronize();
    }

    Win4Assert( _hdr.IsBackupClean() );
    Win4Assert( _hdr.GetCbToSkip(_iPrim) == _hdr.GetCbToSkip(_iBack) );
    Win4Assert( _hdr.IsBackupClean() );

    _hdr.SetRcovOp( op );

    //
    // Open the stream(s) for read/write access as needed.
    //

    if ( opRead == op )
    {
        _obj.Open( _hdr.GetPrimary(), FALSE );
        _iCurr = _iPrim;
    }
    else
    {
        // Win4Assert( !obj.IsReadOnly() );
        // We can get here if adding a property to the property map when
        // the catalog is read-only by issuing a query on a property we
        // haven't seen before.

        if ( obj.IsReadOnly() )
            THROW( CException( E_ACCESSDENIED ) );

        _obj.Open( _hdr.GetBackup(), TRUE );
        _obj.WriteHeader();
    }

    Win4Assert( _obj.IsOpen(_iCurr) );
    Seek( 0 );

    END_CONSTRUCTION( CRcovStrmTrans );
}

//+---------------------------------------------------------------------------
//
//  Member:     CRcovStrmTrans::CleanupAndSynchronize
//
//  Synopsis:
//
//  Returns:
//
//  Modifies:
//
//  History:    9-12-95   srikants   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

void CRcovStrmTrans::CleanupAndSynchronize()
{
    Win4Assert( !_hdr.IsBackupClean() );

    if ( 0 != _hdr.GetCbToSkip(_iBack) )
    {
        //
        // Get rid of the bytes to be skipped in the front.
        //
        EmptyBackupStream();
    }

    Win4Assert( 0 == _hdr.GetCbToSkip(_iBack) );

    SetStrmSize( _iBack, _hdr.GetUserDataSize(_iPrim) );
    _hdr.SetUserDataSize( _iBack, _hdr.GetUserDataSize(_iPrim) );
    _hdr.SetCount( _iBack, _hdr.GetCount(_iPrim) );
    CopyToBack( 0, 0, _hdr.GetUserDataSize(_iPrim) );

    if ( _hdr.GetCbToSkip(_iPrim) != _hdr.GetCbToSkip(_iBack) )
    {
        Unmap( _iPrim );
        _obj.Close( _iPrim );

        CommitPh1();
        Win4Assert( 0 != _hdr.GetCbToSkip(_iBack) );
        EmptyBackupStream();

        SetStrmSize( _iBack, _hdr.GetUserDataSize(_iPrim) );
        _hdr.SetUserDataSize( _iBack, _hdr.GetUserDataSize(_iPrim) );
        CopyToBack( 0, 0, _hdr.GetUserDataSize(_iPrim) );
    }

    Win4Assert( _hdr.GetCbToSkip(_iBack) == _hdr.GetCbToSkip(_iBack) );
    Win4Assert( 0 == _hdr.GetCbToSkip(_iBack) );

    CommitPh2();
}

inline LONGLONG llCommonPageTrunc ( LONGLONG cb )
{
    return (cb & ~(COMMON_PAGE_SIZE-1));
}

inline LONGLONG llCommonPageRound ( LONGLONG cb )
{
    return ( cb + (COMMON_PAGE_SIZE-1) ) & ~(COMMON_PAGE_SIZE-1);
}

//+---------------------------------------------------------------------------
//
//  Member:     CRcovStrmTrans::Seek
//
//  Synopsis:   Seeks to the specified offset. This is an exported function
//              the offset is the offset visible to the user, ie, offset
//              after the "bytes to skip" in the front of the stream.
//
//  Arguments:  [offset] - offset into the stream. If offset is ENDOFSTRM,
//              it will be positioned after the last "user" byte.
//
//  Returns:    BOOL - FALSE if seek is to beyond end of data, TRUE otherwise
//
//  History:    9-19-95   srikants   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

BOOL CRcovStrmTrans::Seek( ULONG offset )
{
    PMmStream & mmStrm = _obj.GetMmStream( _iCurr );

    //
    // Compute the length of the committed part of the stream.
    // (Excluding the hole in the front).
    //
    Win4Assert( mmStrm.Size() >= _hdr.GetCbToSkip(_iCurr) );

    ULONG cbStrmMax = _GetCommittedStrmSize(_iCurr);

    if ( ENDOFSTRM == offset )
    {
        offset = _hdr.GetUserDataSize(_iCurr);
    }
    else if ( offset >= _hdr.GetUserDataSize(_iCurr) )
    {
        Win4Assert( 0 == offset ||
                    _hdr.GetUserDataSize(_iCurr) == offset );
        return FALSE;
    }

    //
    // Add the offset of the starting of user data from the beginning
    // of the "present but invisible to user" range of bytes.
    //
    offset += _hdr.GetUserDataStart(_iCurr);

    _Seek( offset );
    return TRUE;
}

//+---------------------------------------------------------------------------
//
//  Function:   _Seek
//
//  Synopsis:   Seeks the current stream to the specified offset.
//              If the offset specified is ENDOFSTRM, it will  be
//              positioned after the last valid byte.
//
//  Effects:    As long as the current offset is < the full size
//              of the stream ( not the valid size in the header but
//              the actual size of the strm ), it will be mapped.
//
//  Arguments:  [offset] --  byte offset from the beginning of the
//              "hole".
//
//  History:    2-02-94   srikants   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

void CRcovStrmTrans::_Seek( ULONG offset )
{

    Win4Assert( ENDOFSTRM != offset );
    Win4Assert( offset >= _hdr.GetUserDataStart(_iCurr) );
    Win4Assert( offset <= _hdr.GetFullSize(_iCurr) );

    CStrmInfo & si = _aStrmInfo[_iCurr];
    PMmStream & mmStrm = _obj.GetMmStream( _iCurr );

    //
    // Compute the length of the committed part of the stream.
    // (Excluding the hole in the front).
    //
    Win4Assert( mmStrm.Size() >= _hdr.GetCbToSkip(_iCurr) );

    si._oCurrent = offset;

    if ( IsMapped(si._oCurrent) ||
        _GetCommittedStrmSize( mmStrm, _iCurr) <= si._oCurrent )
    {
        return;
    }

    Win4Assert( _GetCommittedStrmSize( mmStrm, _iCurr) > si._oCurrent );

    //
    // Since the current offset is within the valid range of bytes
    // and it is not mapped, we have to unmap the currently mapped
    // range (if any) and map the new range.
    //
    CMmStreamBuf & sbuf = _obj.GetMmStreamBuf( _iCurr );
    if ( sbuf.Get() )
    {
        mmStrm.Flush( sbuf, sbuf.Size() );
        mmStrm.Unmap( sbuf );
    }

    //
    // We always map on page boundaries.
    //
    si._oMapLow = CommonPageTrunc( si._oCurrent );
    si._oMapHigh = si._oMapLow + (COMMON_PAGE_SIZE-1);


    LONGLONG llOffset = _hdr.GetHoleLength(_iCurr) + si._oMapLow;

    mmStrm.Map( sbuf, COMMON_PAGE_SIZE,
                lltoLowPart(llOffset),
                (ULONG) lltoHighPart(llOffset),
                mmStrm.isWritable()     // Map for writing only if the stream
                                        // is writable.
              );

#if CIDBG==1
    LONGLONG llHighMap = llOffset+COMMON_PAGE_SIZE-1;
    Win4Assert( llHighMap < mmStrm.Size() );
#endif  // CIDBG==1

    Win4Assert( IsMapped( si._oCurrent ) );
}

//+---------------------------------------------------------------------------
//
//  Function:   Advance
//
//  Synopsis:   Advances the current offset by the specified number of
//              bytes.
//
//  Arguments:  [cb] --  Number of bytes by which to increment the
//              current position.
//
//  History:    2-02-94   srikants   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

void CRcovStrmTrans::Advance( ULONG cb )
{

    CStrmInfo & si = _aStrmInfo[_iCurr];

    Win4Assert( !IsHighBitSet(si._oCurrent) );

    ULONG  offset = si._oCurrent + cb;
    _Seek( offset  );
}

//+---------------------------------------------------------------------------
//
//  Function:   Read
//
//  Synopsis:   Reads the specified number of bytes from the current
//              stream into the given buffer.
//
//  Effects:    The current pointer will be advanced by the number of
//              bytes read.
//
//  Arguments:  [pvBuf]    --  Buffer to read the data into.
//              [cbToRead] --  Number of bytes to read.
//
//  Returns:    The number of bytes read. It will not read beyond the
//              end of valid bytes (end of stream).
//
//  History:    2-02-94   srikants   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

ULONG CRcovStrmTrans::Read( void *pvBuf, ULONG cbToRead )
{

    CStrmInfo & si = _aStrmInfo[_iCurr];
    ULONG   cbRead = 0;
    BYTE *  pbDst = (BYTE *) pvBuf;

    while ( (cbToRead > 0) && (si._oCurrent < _hdr.GetFullSize(_iCurr)) )
    {

        _Seek( si._oCurrent );

        ULONG   cbMapped = si._oMapHigh - si._oCurrent + 1;
        ULONG   cbCopy = min ( cbToRead, cbMapped );
        Win4Assert( cbMapped && cbCopy );

        ULONG   oStart = si._oCurrent - si._oMapLow;
        CMmStreamBuf & sbuf = _obj.GetMmStreamBuf( _iCurr );
        BYTE *  pbSrc = (BYTE *)sbuf.Get() + oStart;

        memcpy( pbDst, pbSrc, cbCopy );

        pbDst += cbCopy;
        cbToRead -= cbCopy;
        cbRead += cbCopy;
        si._oCurrent += cbCopy;
    }

    return cbRead;
}


//+---------------------------------------------------------------------------
//
//  Function:   Write
//
//  Synopsis:   Writes the given bytes to the current backup stream
//
//  Effects:    The current pointer will be advanced by the number
//              of bytes written. If necessary, the stream will be
//              grown to accommodate the given bytes.
//
//  Arguments:  [pvBuf]     --   Buffer containing the data.
//              [cbToWrite] --   Number of bytes to write.
//
//  History:    2-02-94   srikants   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

void CRcovStrmTrans::Write( const void *pvBuf, ULONG cbToWrite )
{
    Win4Assert( cbToWrite && pvBuf || !cbToWrite );
    Win4Assert( _iCurr == _iBack );

    CStrmInfo & si = _aStrmInfo[_iCurr];
    if ( si._oCurrent+ cbToWrite > _hdr.GetFullSize(_iCurr) )
    {
        //
        // Grow the stream for writing the given bytes.
        //
        ULONG cbDelta = (si._oCurrent + cbToWrite) -
                                                _hdr.GetFullSize(_iCurr);
        Grow( _iCurr, cbDelta );
    }

    BYTE *  pbSrc = (BYTE *) pvBuf;
    while (cbToWrite > 0)
    {

        Win4Assert( si._oCurrent < _hdr.GetFullSize( _iCurr ) );
        _Seek( si._oCurrent );

        ULONG cbMapped = si._oMapHigh - si._oCurrent + 1;

        ULONG   cbCopy = min ( cbToWrite, cbMapped );
        Win4Assert( cbCopy && cbMapped );

        ULONG   oStart = si._oCurrent - si._oMapLow;
        CMmStreamBuf & sbuf = _obj.GetMmStreamBuf( _iCurr );
        BYTE *  pbDst = (BYTE *)sbuf.Get() + oStart;

        memcpy( pbDst, pbSrc, cbCopy );

        pbSrc += cbCopy;
        si._oCurrent += cbCopy;
        cbToWrite -= cbCopy;
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   Unmap
//
//  Synopsis:   Unmaps the currently mapped region of the specified
//              stream.
//
//  Effects:    _aStrmInfo[nCopy] will be updated to indicate  that
//              nothing is mapped.
//
//  Arguments:  [nCopy] -- Stream to unmap.
//
//  History:    2-02-94   srikants   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

void CRcovStrmTrans::Unmap( CRcovStorageHdr::DataCopyNum nCopy )
{
    CStrmInfo & si = _aStrmInfo[nCopy];

    if ( ENDOFSTRM == si._oMapLow )
    {
        Win4Assert( ENDOFSTRM == si._oMapHigh );
        return;
    }

    PMmStream & mmStrm = _obj.GetMmStream( nCopy );
    CMmStreamBuf & sbuf = _obj.GetMmStreamBuf( nCopy );

    if ( sbuf.Get() )
    {
        mmStrm.Flush( sbuf, sbuf.Size() );
        mmStrm.Unmap( sbuf );
    }

    //
    // Reset the high and low end points of the mapping info.
    //
    si.Reset();

    return;
}

//+---------------------------------------------------------------------------
//
//  Function:   Grow
//
//  Synopsis:   Grows the current stream to accommodate "cbDelta" more
//              bytes in the stream.
//
//  Effects:    The valid size entry in the header for the current
//              stream will be updated to indicate the new size.
//
//  Arguments:  [nCopy]   -- The stream which needs to be grown.
//              [cbDelta] --  Number of bytes to grow by.
//
//  History:    2-02-94   srikants   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

inline void CRcovStrmTrans::Grow(
        CRcovStorageHdr::DataCopyNum nCopy, ULONG cbDelta )
{


    //
    // We don't want to do overflow checking or use 64bit arithmetic.
    // 2GB for a changelog is huge enough!
    //
    Win4Assert( !IsHighBitSet( _hdr.GetUserDataSize(nCopy) ) );
    ULONG   cbNew = _hdr.GetUserDataSize(nCopy) + cbDelta;

    PMmStream & mmStrm = _obj.GetMmStream(nCopy);

    Win4Assert( mmStrm.Size() >= _hdr.GetCbToSkip(nCopy) );

    ULONG ulCommittedSize = lltoul( mmStrm.Size() - _hdr.GetCbToSkip(nCopy) );

    //
    // Check if the stream is big enough to accommodate the additional
    // bytes.
    //
    if ( ulCommittedSize >= cbNew )
    {
        _hdr.SetUserDataSize(nCopy, cbNew);
        return;
    }

    //
    // We have to grow the stream also.
    //
    SetStrmSize( nCopy, cbNew );
   _hdr.SetUserDataSize(nCopy, cbNew );

}

//+---------------------------------------------------------------------------
//
//  Function:   SetStrmSize
//
//  Synopsis:   Sets the size of the given stream to be the specified
//              number of bytes. The size will be rounded up to the
//              nearest COMMON_PAGE_SIZE. However, the stream will
//              never be reduced below COMMON_PAGE_SIZE, ie, the minimum
//              size of the stream will be adjusted to be COMMON_PAGE_SIZE.
//
//  Effects:    The stream will be unmapped after this operation.
//
//  Arguments:  [nCopy] --  The stream whose size must be set.
//              [cbNew] --  New size of the stream.
//
//  History:    2-03-94   srikants   Created
//
//  Notes:      This is an internal function and it is assumed that the
//              necessary transaction protocol is being followed. Also
//              note that the size in the header is NOT set by this
//              method.
//
//----------------------------------------------------------------------------

void CRcovStrmTrans::SetStrmSize(
            CRcovStorageHdr::DataCopyNum nCopy, ULONG cbNew )
{
    PMmStream & mmStrm = _obj.GetMmStream( nCopy );

    //
    // Size must be atleast one OFS page in size.
    //
    if ( 0 == cbNew )
        cbNew = COMMON_PAGE_SIZE;

    Unmap( nCopy );

    LONGLONG llTotalLen = cbNew + _hdr.GetCbToSkip(nCopy);
    llTotalLen = llCommonPageRound( llTotalLen );

    if ( mmStrm.Size() != llTotalLen )     // optimization.
    {
        mmStrm.SetSize( _obj.GetStorage(),
                        lltoLowPart(llTotalLen),
                        (ULONG) lltoHighPart(llTotalLen) );
    }
}


//+---------------------------------------------------------------------------
//
//  Function:   EmptyBackupStream
//
//  Synopsis:   Empties the contents of the backup stream by setting its
//              size to "0" (in user space to COMMON_PAGE_SIZE).
//
//  History:    10-18-95   srikants   Created
//
//  Notes:      When there is a hole in a sparse stream, we have to first
//              set its size to 0 to remove the sparseness completely.
//              Otherwise, we will try writing/reading into decommitted
//              space.
//
//              For example, if there is a 256K hole in a 1M stream, setting
//              the size of the stream to 64K will leave a 64K hole in the
//              front. To avoid this, we first set the size to 0 and then
//              set size to 64K to get committed 64K stream.
//
//----------------------------------------------------------------------------

void CRcovStrmTrans::EmptyBackupStream()
{

    ciDebugOut(( DEB_ITRACE, "Emptying contents of backup stream\n" ));

    PMmStream & mmStrm = _obj.GetMmStream( _iBack );
    Unmap( _iBack );

    //
    // In use space we cannot have a 0 length stream because mapping
    // of a zero length stream fails. Also, there are no "holes" in
    // user space.
    //

    ULONG cbLow = COMMON_PAGE_SIZE;

    mmStrm.SetSize( _obj.GetStorage(),
                    cbLow,
                    0 );

    _hdr.SetUserDataSize(_iBack,0);
    _hdr.SetCbToSkip(_iBack,0);
    _obj.WriteHeader();
}

//+---------------------------------------------------------------------------
//
//  Function:   CopyToBack
//
//  Synopsis:   Copies the specified number of bytes from the current
//              primary stream to the backup stream.
//
//  Effects:
//
//  Arguments:  [oSrc]     --  Starting byte offset in the primary where
//              to start the copying from (Offset from the beginning of the
//              user data).
//              [oDst]     --  Starting byte offset in the backup where
//              to copy the data to. (Offset from the beginning of the user
//              data.)
//              [cbToCopy] --  Number of bytes to copy.
//
//  History:    2-03-94   srikants   Created
//
//  Notes:      This does not modify the "valid size" of the backup
//              stream - it is upto the caller to change it. Also, it
//              is assumed that the backup stream is big enough to
//              hold all the data and the primary data is big enough
//              to give the data.
//
//----------------------------------------------------------------------------

void CRcovStrmTrans::CopyToBack( ULONG oSrc, ULONG oDst, ULONG cbToCopy )
{

    //
    // Transform the offsets to the offset from the beginning of the
    // hole.
    //
    Win4Assert( oSrc != ENDOFSTRM );
    Win4Assert( oDst != ENDOFSTRM );

    oSrc += _hdr.GetUserDataStart(_iPrim);
    oDst += _hdr.GetUserDataStart(_iBack);

    ULONG   cbLeft = cbToCopy;
    const CRcovStorageHdr::DataCopyNum iStartCurr = _iCurr;

    CStrmInfo & siPrim = _aStrmInfo[_iPrim];
    CStrmInfo & siBack = _aStrmInfo[_iBack];

    while ( cbLeft > 0 )
    {

        SetCurrentStrm( _iPrim );
        _Seek(  oSrc );
        Win4Assert( IsMapped( oSrc ) );

        SetCurrentStrm( _iBack );
        _Seek( oDst );
        Win4Assert( IsMapped( oDst ) );

        PMmStream & mmPrimStrm = _obj.GetMmStream( _iPrim );
        PMmStream & mmBackStrm = _obj.GetMmStream( _iBack );

        CMmStreamBuf & sPrimBuf = _obj.GetMmStreamBuf( _iPrim );
        CMmStreamBuf & sBackBuf = _obj.GetMmStreamBuf( _iBack );

        const BYTE *pbSrc = (const BYTE *) sPrimBuf.Get();
        pbSrc += ( oSrc - siPrim._oMapLow);

        BYTE * pbDst = (BYTE *) sBackBuf.Get();
        pbDst += ( oDst - siBack._oMapLow);

        ULONG cbMapRead  = siPrim._oMapHigh -  oSrc + 1;
        ULONG cbMapWrite = siBack._oMapHigh -  oDst + 1;

        Win4Assert( cbMapRead && cbMapWrite );

        ULONG cbCopy = min( cbLeft, min(cbMapRead, cbMapWrite) );
        Win4Assert( cbCopy );

        memcpy( pbDst, pbSrc, cbCopy );

        oSrc += cbCopy;
        oDst += cbCopy;
        cbLeft -= cbCopy;
    }

    //
    // Restore the current index stream to be the same as the
    // original.
    //
    _iCurr = iStartCurr;

}

//+---------------------------------------------------------------------------
//
//  Function:   CommitPh1
//
//  Synopsis:   Commits the changes to the current backup stream and
//              makes it the primary. It also opens the new backup
//              stream in a write mode for making changes to the new backup
//              stream in the phase 2 of the commit process.
//
//  Effects:    The backup stream gets flushed to the disk.
//
//  Arguments:  (none)
//
//  History:    2-05-94   srikants   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

void CRcovStrmTrans::CommitPh1()
{

    //
    // Flush the backup stream.
    //
    PMmStream & mmStrm = _obj.GetMmStream( _iBack );
    CMmStreamBuf & sbuf = _obj.GetMmStreamBuf( _iBack );
    Unmap( _iBack );    // Should unmap before flushing.

    //
    // Swap the primary and backup in the header and write
    // out the header.
    //
    _hdr.SwitchPrimary();
    _obj.WriteHeader();

    Win4Assert( _iPrim == _hdr.GetBackup() );

    //
    // Swap the primary and backup streams and make
    // _iCurr the new backup. This is to prepare for
    // the phase 2 of the commit process.
    //
    _iCurr = _iPrim;
    _iPrim = _iBack;
    _iBack = _iCurr;

    //
    // Now open the current backup stream for writing.
    //
    _obj.Open( _iBack, TRUE );

}


//+---------------------------------------------------------------------------
//
//  Function:   CommitPh2
//
//  Synopsis:   Commits the phase 2 of the transaction. It writes out
//              the changes to the backup stream. Upon successful
//              completion, it marks that both streams are clean in
//              the header and closes the streams.
//
//  Effects:    After this returns, the streams are no longer accessible
//              as they are closed. They should be re-opened for another
//              transaction.
//
//  Arguments:  (none)
//
//  History:    2-10-94   srikants   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

void CRcovStrmTrans::CommitPh2()
{
    //
    // Close the primary stream and mark that it has been unmapped.
    //
    _obj.Close( _iPrim );       // close automatically unmaps if it is
                                // mapped.
    _aStrmInfo[_iPrim].Reset();

     //
     // Now Flush the backup and close it.
     //
    PMmStream & mmStrm = _obj.GetMmStream( _iBack );
    CMmStreamBuf & sbuf = _obj.GetMmStreamBuf( _iBack );
    Unmap( _iBack );        // Must unmap before flushing.

    _obj.Close( _iBack );

    //
    // Update the header that the object is now clean.
    //
    _hdr.SyncBackup();
    _obj.WriteHeader();
}

#if 0
void CRcovStrmTrans::Compare()
{
    #if CIDBG == 1

    Win4Assert( !_obj.IsOpen( _hdr.GetPrimary() ) );
    Win4Assert( !_obj.IsOpen( _hdr.GetBackup() ) );

    if( _hdr.GetUserDataSize( _hdr.GetPrimary() ) != _hdr.GetUserDataSize( _hdr.GetBackup() ) )
    {
        ciDebugOut(( DEB_ERROR, "Primary (%u) = 0x%x, Secondary (%u) = 0x%x\n",
                     _hdr.GetPrimary(), _hdr.GetUserDataSize( _hdr.GetPrimary() ),
                     _hdr.GetBackup(), _hdr.GetUserDataSize( _hdr.GetBackup() ) ));
        Win4Assert( _hdr.GetUserDataSize( _hdr.GetPrimary() ) == _hdr.GetUserDataSize( _hdr.GetBackup() ) );
    }

    _obj.Open( _hdr.GetPrimary(), FALSE );
    _obj.Open( _hdr.GetBackup(), FALSE );

    ULONG oSrc = _hdr.GetUserDataStart( _hdr.GetPrimary() );
    ULONG oDst = _hdr.GetUserDataStart( _hdr.GetBackup() );

    if ( oSrc != oDst )
    {
        ciDebugOut(( DEB_ERROR, "Primary (%u) = 0x%x, Secondary (%u) = 0x%x\n",
                     _hdr.GetPrimary(), oSrc,
                     _hdr.GetBackup(), oDst ));

        Win4Assert( oSrc == oDst );
    }

    if ( _hdr.GetUserDataSize( _hdr.GetPrimary() ) != _hdr.GetUserDataSize( _hdr.GetBackup() ) )
    {
        ciDebugOut(( DEB_ERROR, "Primary (%u) = 0x%x, Secondary (%u) = 0x%x\n",
                     _hdr.GetPrimary(), _hdr.GetUserDataSize( _hdr.GetPrimary() ),
                     _hdr.GetBackup(), _hdr.GetUserDataSize( _hdr.GetBackup() ) ));

        Win4Assert( _hdr.GetUserDataSize( _hdr.GetPrimary() ) == _hdr.GetUserDataSize( _hdr.GetBackup() ) );
    }

    ULONG cbLeft = _hdr.GetUserDataSize( _hdr.GetPrimary() );

    CStrmInfo & siPrim = _aStrmInfo[_hdr.GetPrimary()];
    CStrmInfo & siBack = _aStrmInfo[_hdr.GetBackup()];

    while ( cbLeft > 0 )
    {

        SetCurrentStrm( _hdr.GetPrimary() );
        _Seek(  oSrc );
        Win4Assert( IsMapped( oSrc ) );

        SetCurrentStrm( _hdr.GetBackup() );
        _Seek( oDst );
        Win4Assert( IsMapped( oDst ) );

        PMmStream & mmPrimStrm = _obj.GetMmStream( _hdr.GetPrimary() );
        PMmStream & mmBackStrm = _obj.GetMmStream( _hdr.GetBackup() );

        CMmStreamBuf & sPrimBuf = _obj.GetMmStreamBuf( _hdr.GetPrimary() );
        CMmStreamBuf & sBackBuf = _obj.GetMmStreamBuf( _hdr.GetBackup() );

        const BYTE *pbSrc = (const BYTE *) sPrimBuf.Get();
        pbSrc += ( oSrc - siPrim._oMapLow);

        BYTE * pbDst = (BYTE *) sBackBuf.Get();
        pbDst += ( oDst - siBack._oMapLow);

        ULONG cbMapRead  = siPrim._oMapHigh -  oSrc + 1;
        ULONG cbMapWrite = siBack._oMapHigh -  oDst + 1;

        Win4Assert( cbMapRead && cbMapWrite );

        ULONG cbCopy = min( cbLeft, min(cbMapRead, cbMapWrite) );
        Win4Assert( cbCopy );

        if ( 0 != memcmp( pbDst, pbSrc, cbCopy ) )
        {
            ciDebugOut(( DEB_ERROR, "CRcovStrmTrans::Compare -- mismatch\n" ));
            ciDebugOut(( DEB_ERROR | DEB_NOCOMPNAME, "  Primary (%u) offset 0x%x, pb = 0x%x\n",
                         _hdr.GetPrimary(), oSrc, pbSrc ));
            ciDebugOut(( DEB_ERROR | DEB_NOCOMPNAME, "  Backup (%u) offset 0x%x, pb = 0x%x\n",
                         _hdr.GetBackup(), oDst, pbDst ));
            Win4Assert( !"CRcovStrmTrans::Compare -- mismatch" );
        }

        oSrc += cbCopy;
        oDst += cbCopy;
        cbLeft -= cbCopy;
    }

    _obj.Close( _hdr.GetPrimary() );
    _obj.Close( _hdr.GetBackup() );

    #endif // CIDBG
}
#endif

void CRcovStrmWriteTrans::Commit()
{
    Win4Assert( XActAbort == CTransaction::GetStatus() );

    CommitPh1();

    //
    // After phase1 is successfully committed, the transaction will be
    // completed by making "forward progress". So, we should not throw
    // now even if the phase2 fails. Even if phase2 fails now, it will
    // be eventually completed later when a new transaction is created
    // for this object.
    //
    TRY
    {
        //
        // Copy the entire contents from the new primary to the
        // new backup.
        //
        SetStrmSize( _iBack, GetStorageHdr().GetUserDataSize(_iPrim) );
        GetStorageHdr().SetUserDataSize( _iBack,
                                GetStorageHdr().GetUserDataSize(_iPrim) );

        CopyToBack( 0, 0, GetStorageHdr().GetUserDataSize(_iPrim));

        CommitPh2();
        Win4Assert( GetStorageHdr().IsBackupClean() );
    }
    CATCH( CException, e )
    {
        GetRcovObj().Close( _iPrim );
        GetRcovObj().Close( _iBack );

        ciDebugOut(( DEB_ERROR, "Phase2 of CRcomStrmWriteTrans failed 0x%X\n",
                     e.GetErrorCode() ));
    }
    END_CATCH

    CRcovStrmTrans::Commit();

}

void CRcovStrmWriteTrans::Empty()
{
    Win4Assert( _iCurr == _iBack );
    SetStrmSize( _iBack, 0 );
    GetStorageHdr().SetUserDataSize( _iBack, 0 );
    Seek(0);
}

CRcovStrmAppendTrans::CRcovStrmAppendTrans( PRcovStorageObj & obj )
    : CRcovStrmTrans( obj, opAppend )
{
    //
    // Seek to end of file.
    //
    Seek( ENDOFSTRM );

    END_CONSTRUCTION( CRcovStrmAppendTrans );
}

#if CIDBG==1
#if (defined(_M_IA64) && (_MSC_FULL_VER == 13009286))
#pragma optimize("",off)
#endif
#endif

void CRcovStrmAppendTrans::Commit()
{
    Win4Assert( XActAbort == CTransaction::GetStatus() );

    Win4Assert( GetStorageHdr().GetUserDataSize(_iPrim) <=
                GetStorageHdr().GetUserDataSize(_iBack) );

    CTransaction::_status = XActAbort;
    CommitPh1();
    //
    // After phase1 is successfully committed, the transaction will be
    // completed by making "forward progress". So, we should not throw
    // now even if the phase2 fails. Even if phase2 fails now, it will
    // be eventually completed later when a new transaction is created
    // for this object.
    //
    TRY
    {
        //
        // Now copy the contents of the primary to the backup
        // from the point where append started.
        //
        ULONG cbToCopy = GetStorageHdr().GetUserDataSize(_iPrim) -
                                    GetStorageHdr().GetUserDataSize(_iBack);
        ULONG offset = GetStorageHdr().GetUserDataSize(_iBack);

        ciFAILTEST( STATUS_DISK_FULL );

        Grow(_iBack, cbToCopy);

        ciFAILTEST( STATUS_DISK_FULL );

        CopyToBack( offset, offset, cbToCopy );

        ciFAILTEST( STATUS_DISK_FULL );

        CommitPh2();

        ciFAILTEST( STATUS_DISK_FULL );

    }
    CATCH ( CException, e )
    {
        GetRcovObj().Close( _iPrim );
        GetRcovObj().Close( _iBack );

        ciDebugOut(( DEB_ERROR, "Phase2 of CRcomStrmAppendTrans failed 0x%X\n",
                     e.GetErrorCode() ));
    }
    END_CATCH

    CRcovStrmTrans::Commit();
}

#if CIDBG==1
#if (defined(_M_IA64) && (_MSC_FULL_VER == 13009286))
#pragma optimize("",on)
#endif
#endif

CRcovStrmMDTrans::CRcovStrmMDTrans( PRcovStorageObj & obj,
                                    MDOp op, ULONG cb )
    : CRcovStrmTrans( obj, opMetaData ),
      _op(op), _cbOp(cb)
{

    END_CONSTRUCTION( CRcovStrmMDTrans );
}

void CRcovStrmMDTrans::Commit()
{
    Win4Assert( XActAbort == CTransaction::GetStatus() );

    switch ( _op )
    {

        case mdopSetSize:
            SetSize( _cbOp );
            break;

        case mdopGrow:
            Grow( _cbOp );
            break;

        case mdopFrontShrink:
            ShrinkFromFront( _cbOp );
            break;

        case mdopBackCompact:
            CompactFromEnd( _cbOp );
            break;

        default:
            Win4Assert( ! "Control Should Not Come Here" );
            break;
    }

    CRcovStrmTrans::Commit();
}

void CRcovStrmMDTrans::SetSize( ULONG cbNew )
{

    //
    // set the size on the backup first.
    //
    Win4Assert( _iCurr == _iBack );
    CRcovStrmTrans::SetStrmSize( _iBack, cbNew );
    GetStorageHdr().SetUserDataSize( _iBack, cbNew );

    //
    // Do the phase1 commit now.
    //
    CommitPh1();

    //
    // After phase1 is successfully committed, the transaction will be
    // completed by making "forward progress". So, we should not throw
    // now even if the phase2 fails. Even if phase2 fails now, it will
    // be eventually completed later when a new transaction is created
    // for this object.
    //
    TRY
    {
        //
        // Apply the same operation on the new backup.
        //
        Win4Assert( _iCurr == _iBack );
        CRcovStrmTrans::SetStrmSize( _iBack, cbNew );
        CommitPh2();

        Win4Assert( GetStorageHdr().IsBackupClean() );
    }
    CATCH( CException,e )
    {
        GetRcovObj().Close( _iPrim );
        GetRcovObj().Close( _iBack );

        ciDebugOut(( DEB_ERROR, "Phase2 of CRcovStrmMDTrans failed 0x%X\n",
                     e.GetErrorCode() ));
    }
    END_CATCH
}

void CRcovStrmMDTrans::Grow( ULONG cbDelta )
{
    const ULONG cbNew = GetStorageHdr().GetUserDataSize(_iCurr)+cbDelta;
    CRcovStrmMDTrans::SetSize( cbNew );
}

void CRcovStrmMDTrans::CompactFromEnd( ULONG cbDelta )
{
    Win4Assert( cbDelta <= GetStorageHdr().GetUserDataSize( _iCurr ) );
    Win4Assert( _iCurr == _iBack );

    cbDelta = min (cbDelta, GetStorageHdr().GetUserDataSize( _iCurr ));
    const ULONG cbNew = GetStorageHdr().GetUserDataSize(_iCurr) - cbDelta;

    CRcovStrmMDTrans::SetSize( cbNew );

}

//+---------------------------------------------------------------------------
//
//  Member:     CRcovStrmMDTrans::IncreaseBytesToSkip
//
//  Synopsis:   Increases the number of bytes to be "skipped" in the front
//              by the specified amount.
//
//  Arguments:  [cbDelta] - Number of additional bytes to skip.
//
//  History:    9-19-95   srikants   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

void CRcovStrmMDTrans::IncreaseBytesToSkip( ULONG cbDelta )
{
    CRcovStorageHdr & hdr = GetStorageHdr();

    //
    // Update the hole length and the valid data length.
    //
    Win4Assert( hdr.GetUserDataSize(_iBack) >= cbDelta );
    const ULONG cbNewValid = hdr.GetUserDataSize(_iPrim) - cbDelta;
    hdr.SetUserDataSize( _iBack, cbNewValid );

    Win4Assert( hdr.GetCbToSkip(_iPrim) == hdr.GetCbToSkip(_iBack) );
    const LONGLONG llcbNewSkip = hdr.GetCbToSkip(_iBack)+cbDelta;
    hdr.SetCbToSkip( _iBack, llcbNewSkip );

    // Phase1 complete - just set the values for the backup.
    hdr.SwitchPrimary();
    Win4Assert( _iPrim == hdr.GetBackup() );

    _iCurr = _iPrim;
    _iPrim = _iBack;
    _iBack = _iCurr;

    // phase 2 complete. Commit the changes
    hdr.SyncBackup();

    GetRcovObj().WriteHeader();
}

//+---------------------------------------------------------------------------
//
//  Member:     CRcovStrmMDTrans::CopyShrinkFromFront
//
//  Synopsis:   Implements a shrink from front by copying bytes.
//
//  Arguments:  [cbNew]   -  Number of bytes that will be in the stream after
//              doing a shrink from front.
//              [cbDelta] -  Number of bytes to shrink in the front.
//
//  History:    10-02-95   srikants   Created ( Moved from ShrinkFromFront()
//                                    methoed )
//
//  Notes:
//
//----------------------------------------------------------------------------

void CRcovStrmMDTrans::CopyShrinkFromFront( ULONG cbNew,
                                            ULONG cbDelta )
{

    CRcovStorageHdr & hdr = GetStorageHdr();

    ULONG oDst = 0;
    ULONG oSrc = cbDelta;

    // this check is an optimization
    if ( hdr.GetHoleLength(_iBack) > SHRINK_FROM_FRONT_PAGE_SIZE )
    {
        //
        // If the hole in front is <= SHRINK_FROM_FRONT_PAGE_SIZE, then
        // this there is no "sparseness" in the front.
        //
        EmptyBackupStream();
    }

    //
    // Open the Primary in a read-only mode and close it before
    // calling CommitPh1().
    // Copy the contents from oSrc in the primary to oDst in the
    // backup stream.
    //
    hdr.SetCbToSkip(_iBack,0);
    CRcovStrmTrans::SetStrmSize( _iBack, cbNew );
    hdr.SetUserDataSize( _iBack, cbNew );

    GetRcovObj().Open( _iPrim, FALSE );
    CopyToBack( oSrc, oDst, cbNew );
    Unmap( _iPrim );
    GetRcovObj().Close( _iPrim );

    //
    // Commit the phase1 changes now.
    //
    CommitPh1();

    //
    // After phase1 is successfully committed, the transaction will be
    // completed by making "forward progress". So, we should not throw
    // now even if the phase2 fails. Even if phase2 fails now, it will
    // be eventually completed later when a new transaction is created
    // for this object.
    //
    TRY
    {
        //
        // We have to synchronize the new backup with the new primary.
        //
        Win4Assert( _iCurr == _iBack );

        // this check is an optimization
        if ( hdr.GetHoleLength(_iBack) > SHRINK_FROM_FRONT_PAGE_SIZE )
        {
            //
            // If the hole in front is <= SHRINK_FROM_FRONT_PAGE_SIZE, then
            // this there is no "sparseness" in the front.
            //
            EmptyBackupStream();
        }

        hdr.SetCbToSkip(_iBack,0);
        CRcovStrmTrans::SetStrmSize( _iBack, cbNew );

        CopyToBack( 0, 0, cbNew );

        hdr.SetUserDataSize( _iBack, cbNew );
        CommitPh2();

        Win4Assert( hdr.IsBackupClean() );
    }
    CATCH( CException, e )
    {
        GetRcovObj().Close( _iPrim );
        GetRcovObj().Close( _iBack );

        ciDebugOut(( DEB_ERROR, "Phase2 of ShrinkFromFront() failed 0x%X\n",
                     e.GetErrorCode() ));
    }
    END_CATCH
}

void CRcovStrmMDTrans::ShrinkFromFront( ULONG cbDelta )
{

    CRcovStorageHdr & hdr = GetStorageHdr();

    Win4Assert( cbDelta <= hdr.GetUserDataSize( _iCurr ) );
    Win4Assert( _iCurr == _iBack );

    cbDelta = min (cbDelta, hdr.GetUserDataSize( _iCurr ));

    Win4Assert( hdr.GetCbToSkip(_iCurr) >= hdr.GetHoleLength(_iCurr) );

    const ULONG cbCommittedSkip = lltoul( hdr.GetCbToSkip(_iCurr) - hdr.GetHoleLength(_iCurr) );

    //
    // If the total number of bytes "present but invisible" to user is
    // < the threshold, don't do any copying or shrinking. Just increment
    // the bytest to skip and return.
    //
    if ( cbCommittedSkip + cbDelta < SHRINK_FROM_FRONT_PAGE_SIZE )
    {
        IncreaseBytesToSkip( cbDelta );
        return;
    }

    const ULONG cbNew  = hdr.GetUserDataSize(_iCurr) - cbDelta;

    CopyShrinkFromFront( cbNew, cbDelta );
}



//+---------------------------------------------------------------------------
//
//  Member:     CCopyRcovObject::_SetDstSize
//
//  Synopsis:   Sets the size of the destination object to be same as
//              the source object.
//
//  History:    3-17-97   srikants   Created
//
//----------------------------------------------------------------------------

void CCopyRcovObject::_SetDstSize()
{
    CRcovStrmMDTrans trans( _dst, CRcovStrmMDTrans::mdopSetSize, _cbSrc );
    trans.Commit();
}

//+---------------------------------------------------------------------------
//
//  Member:     CCopyRcovObject::_CopyData
//
//  Synopsis:   Copies the data from the source object to the destination
//              object.
//
//  History:    3-17-97   srikants   Created
//
//----------------------------------------------------------------------------

void CCopyRcovObject::_CopyData()
{

    const cbPageSize = 4096;    // Read and write 4k at a time.
    XArray<BYTE>  xByte( cbPageSize );

    //
    // Start a read transaction on the source object
    //
    CRcovStrmReadTrans  srcTrans( _src );

    //
    // Start a write transaction on the destination.
    //
    CRcovStrmWriteTrans dstTrans( _dst );

    dstTrans.Empty();
    dstTrans.Seek(0);

    ULONG cbRemaining = _cbSrc;

    while ( cbRemaining > 0 )
    {
        ULONG cbToCopy = min( cbRemaining, cbPageSize );
        srcTrans.Read( xByte.GetPointer(), cbToCopy );
        dstTrans.Write( xByte.GetPointer(), cbToCopy );

        cbRemaining -= cbToCopy;
    }

    //
    // Set the user header.
    //
    CRcovUserHdr  usrHdr;
    _srcHdr.GetUserHdr( _srcHdr.GetPrimary(), usrHdr );
    _dstHdr.SetUserHdr( _dstHdr.GetBackup(), usrHdr );

    //
    // Set the number of records.
    //
    ULONG nRec = _srcHdr.GetCount( _srcHdr.GetPrimary() );
    _dstHdr.SetCount( _dstHdr.GetBackup(), nRec );

    //
    // Commit the transaction.
    //
    dstTrans.Commit();
}

//+---------------------------------------------------------------------------
//
//  Member:     CCopyRcovObject::DoIt
//
//  Synopsis:   Copies the contents of one object to another object.
//
//  Returns:    STATUS_SUCCESS if successful;
//              Other error code if there is an error.
//
//  History:    3-17-97   srikants   Created
//
//----------------------------------------------------------------------------

NTSTATUS CCopyRcovObject::DoIt()
{

    NTSTATUS  status = STATUS_SUCCESS;

    TRY
    {
        _SetDstSize();
        _CopyData();
    }
    CATCH( CException, e )
    {
        status = e.GetErrorCode();
        ciDebugOut(( DEB_ERROR, "CCopyRcovObject::DoIt. Error 0x%X\n", status ));
    }
    END_CATCH

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\ntciutil\prpstmgr.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1991 - 2002.
//
//  File:       PrpStMgr.cxx
//
//  Contents:   A two-level property store.
//
//  Classes:    CPropStoreManager
//
//  History:    24-Oct-1997   KrishnaN       Created
//
//----------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include <prpstmgr.hxx>
#include <propobj.hxx>
#include <eventlog.hxx>
#include <catalog.hxx>
#include <imprsnat.hxx>
#include <propiter.hxx>

//+---------------------------------------------------------------------------
//
//  Member:     CPropStoreManager::CPropStoreManager, public
//
//  Synopsis:   Constructs the class.
//
//  History:    24-Oct-97   KrishnaN       Created.
//              01-Nov-98   KLam           Added cMegToLeaveOnDisk to constructor
//
//----------------------------------------------------------------------------

CPropStoreManager::CPropStoreManager( ULONG cMegToLeaveOnDisk )
        : _pStorage( 0 ),
          _xPrimaryStore( 0 ),
          _xSecondaryStore( 0 ),
          _dwXctionStoreLevel( INVALID_STORE_LEVEL ),
          _cMegToLeaveOnDisk( cMegToLeaveOnDisk )
{
    _xPrimaryStore.Set(new CPropertyStore(*this, PRIMARY_STORE));
    _xSecondaryStore.Set(new CPropertyStore(*this, SECONDARY_STORE));
}

//+---------------------------------------------------------------------------
//
//  Member:     CPropStoreManager::CPropStoreManager, public
//
//  Synopsis:   Constructs the class.
//
//  History:    24-Oct-97   KrishnaN       Created.
//              01-Nov-98   KLam           Added cMegToLeaveOnDisk to constructor
//
//----------------------------------------------------------------------------

CPropStoreManager::CPropStoreManager(CiStorage * pStorage,
                                     CPropertyStore *pPrimaryStore,
                                     CPropertyStore *pSecondaryStore,
                                     ULONG cMegToLeaveOnDisk )
        : _pStorage( pStorage ),
          _dwXctionStoreLevel( INVALID_STORE_LEVEL ),
          _cMegToLeaveOnDisk( cMegToLeaveOnDisk )
{
    _xPrimaryStore.Set( pPrimaryStore );
    _xSecondaryStore.Set( pSecondaryStore );
}

//+---------------------------------------------------------------------------
//
//  Member:     CPropStoreManager::~CPropStoreManager, public
//
//  Synopsis:   Destructs the class.
//
//  History:    24-Oct-97   KrishnaN       Created.
//
//----------------------------------------------------------------------------

CPropStoreManager::~CPropStoreManager()
{
    if ( !_xpsNew.IsNull() )
    {
        //
        // The property stores in xpsnew are owned by the property stores
        // in this instance (the one being destructed) of the property
        // stores.  They're in smart pointers but you can't delete them.
        //

        _xpsNew->_xPrimaryStore.Acquire();
        _xpsNew->_xSecondaryStore.Acquire();
        _xpsNew.Free();
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CPropStoreManager::Empty
//
//  Synopsis:   Empties out the intitialized members and prepares for a
//              re-init.
//
//  History:    22-Oct-97       KrishnaN   Created
//
//----------------------------------------------------------------------------

void CPropStoreManager::Empty()
{
    _xPrimaryStore->Empty();
    _xSecondaryStore->Empty();
    _pStorage = 0;
}

//+---------------------------------------------------------------------------
//
//  Member:     CPropStoreManager::FastInit, public
//
//  Synopsis:   Initialize property store (two-phase construction)
//
//  Arguments:  [pStorage] -- Storage object.
//
//  History:    22-Oct-97    KrishnaN    Created
//
//----------------------------------------------------------------------------

void CPropStoreManager::FastInit( CiStorage * pStorage )
{
    _pStorage = pStorage;
    _xPrimaryStore->FastInit(pStorage);
    _xSecondaryStore->FastInit(pStorage);
}


//+---------------------------------------------------------------------------
//
//  Member:     CPropStoreManager::LongInit
//
//  Synopsis:   If the propstore was dirty when shut down, run the recovery
//              operation.
//
//  Arguments:  [fWasDirty]        -- dirty flag is returned here
//              [cInconsistencies] -- returns number of inconsistencies found
//              [pfnUpdateCallback]-- Callback to be called to update docs during
//                                    recovery. the prop store has no knowledge of
//                                    doc store, so this callback is needed.
//              [pUserData]        -- will be echoed back through callback.
//
//  Returns:
//
//  History:    22-Oct-97     KrishnaN   Created
//
//  Notes:      The propstore is locked for write during recovery, but
//              reads are still permitted.
//
//----------------------------------------------------------------------------

void CPropStoreManager::LongInit( BOOL & fWasDirty, ULONG & cInconsistencies,
                               T_UpdateDoc pfnUpdateCallback, void const *pUserData )
{
    //
    // If at least one of the two stores is dirty, consider both to be dirty
    // and recover from both.
    //

    ciDebugOut(( DEB_ITRACE, "is primary dirty: %d, is secondary dirty %d\n",
                 _xPrimaryStore->IsDirty(), _xSecondaryStore->IsDirty() ));

    ciDebugOut(( DEB_ITRACE, "is backedup mode: %d\n", IsBackedUpMode() ));

    if (IsDirty())
    {
        _xPrimaryStore->_PropStoreInfo.MarkDirty();
        _xSecondaryStore->_PropStoreInfo.MarkDirty();
    }

    //
    // If at least one of them recovered with inconsistencies, both should be
    // considered to be corrupt!
    //

    _xPrimaryStore->LongInit(fWasDirty, cInconsistencies, pfnUpdateCallback, pUserData);

    ciDebugOut(( DEB_ITRACE, "fWas, cIncon: %d, %d\n", fWasDirty, cInconsistencies ));

    if (fWasDirty && cInconsistencies)
    {
        // Propstore is considered corrupt. No point attempting recovery on
        // secondary.

        return;
    }

    _xSecondaryStore->LongInit(fWasDirty, cInconsistencies, pfnUpdateCallback, pUserData);

    ciDebugOut(( DEB_ITRACE, "2nd: fWas, cIncon: %d, %d\n", fWasDirty, cInconsistencies ));

    if (fWasDirty && cInconsistencies)
    {
        // Propstore is still corrupt.
        return;
    }

    // Are both the stores in sync

    // First line defense
    if (_xPrimaryStore->CountRecordsInUse() != _xSecondaryStore->CountRecordsInUse())
    {
        Win4Assert(fWasDirty);
        cInconsistencies = abs((LONG)_xPrimaryStore->CountRecordsInUse() -
                               (LONG)_xSecondaryStore->CountRecordsInUse());
        return;
    }

    // We have done our best to recover from a dirty shutdown. However, in at least one
    // case (bug 132655), it was detected that there was an inconsistency between the
    // two stores. Ensure that we catch such inconsistencies.

    if (IsDirty())
    {
        CPropertyStoreWids iter(*this);

        ULONG iRec = 0;
        const ULONG cTotal = _xPrimaryStore->CountRecordsInUse();

        for ( WORKID wid = iter.WorkId();
              !cInconsistencies && wid != widInvalid;
              wid = iter.LokNextWorkId() )
        {
           iRec++;
           // get the physical store pointed to by the primary top-level record
           CBorrowed BorrowedTopLevel( *(_xSecondaryStore->PhysStore()),
                                       GetSecondaryTopLevelWid(wid),
                                       _xSecondaryStore->RecordsPerPage(),
                                       _xSecondaryStore->RecordSize() );

           COnDiskPropertyRecord * prec = BorrowedTopLevel.Get();
           if (!prec->IsInUse())
               cInconsistencies++;
        }

        if (cInconsistencies)
            return;
    }

    #if 0 // this is really expensive... CIDBG == 1

    else
    {
        ULONG iRec = 0;
        const ULONG cTotal = _xPrimaryStore->CountRecordsInUse();

        CPropertyStoreWids iter(*this);

        for ( WORKID wid = iter.WorkId(); wid != widInvalid; wid = iter.LokNextWorkId() )
        {
           iRec++;
           // get the physical store pointed to by the primary top-level record
           CBorrowed BorrowedTopLevel( *(_xSecondaryStore->PhysStore()),
                                       GetSecondaryTopLevelWid(wid),
                                       _xSecondaryStore->RecordsPerPage(),
                                       _xSecondaryStore->RecordSize() );

           COnDiskPropertyRecord * prec = BorrowedTopLevel.Get();
           Win4Assert(prec->IsInUse());
        }
    }

    #endif // CIDBG

    // All is well. Flush and get on with the business of indexing and searching
    Flush();
} //LongInit

//+---------------------------------------------------------------------------
//
//  Member:     CPropStoreManager::BeginTransaction, public
//
//  Synopsis:   Begins a schema transaction. Any existing transaction will be
//              aborted.
//
//  Returns:    Token representing transaction.
//
//  History:    24-Oct-97      KrishnaN       Created.
//              02-Nov-98      KLam           Passed _cMegToLeaveOnDisk to 
//                                            CPropStoreManager
//
//----------------------------------------------------------------------------

ULONG_PTR CPropStoreManager::BeginTransaction()
{
    CLock lock( _mtxWrite );

    // we are not committing, so the fixed pids are ignored.
    if ( !_xpsNew.IsNull() )
        EndTransaction( (ULONG_PTR)_xpsNew.Acquire(), FALSE, pidInvalid, pidInvalid);

    ULONG_PTR ulPrimaryXctionToken = _xPrimaryStore->BeginTransaction();
    ULONG_PTR ulSecondaryXctionToken = _xSecondaryStore->BeginTransaction();

    _xpsNew.Set( new CPropStoreManager( _pStorage,
                                        (CPropertyStore *)ulPrimaryXctionToken,
                                        (CPropertyStore *)ulSecondaryXctionToken,
                                        _cMegToLeaveOnDisk ) );

    // init storelevel used in transaction to unknown.
    _dwXctionStoreLevel = INVALID_STORE_LEVEL;
    return (ULONG_PTR)_xpsNew.GetPointer();
}

//+---------------------------------------------------------------------------
//
//  Member:     CPropStoreManager::Setup, public
//
//  Synopsis:   Setup a property description.  Property may already exist
//              in the cache.
//
//  Arguments:  [pid]        -- Propid
//              [vt]         -- Datatype of property.  VT_VARIANT if unknown.
//              [cbMaxLen]   -- Soft-maximum length for variable length
//                              properties.  This much space is pre-allocated
//                              in original record.
//              [ulToken]    -- Token of transaction
//              [fCanBeModified]-- Can the prop meta info be modified once set?
//
//  History:    22-Oct-97         KrishnaN       Created.
//
//----------------------------------------------------------------------------

void CPropStoreManager::Setup( PROPID pid,
                            ULONG vt,
                            DWORD cbMaxLen,
                            ULONG_PTR ulToken,
                            BOOL fCanBeModified,
                            DWORD dwStoreLevel )
{
    if ( ulToken != (ULONG_PTR)_xpsNew.GetPointer() )
    {
        ciDebugOut(( DEB_ERROR, "Transaction mismatch: 0x%x vs. 0x%x\n", ulToken, _xpsNew.GetPointer() ));
        THROW( CException( STATUS_TRANSACTION_NO_MATCH ) );
    }

    //
    // Currently we only allow operations on one store during a transaction.
    // Remember that or enforce that, as appropriate.
    //

    if (INVALID_STORE_LEVEL == _dwXctionStoreLevel)
        _dwXctionStoreLevel = dwStoreLevel;
    else
    {
        Win4Assert(PRIMARY_STORE == dwStoreLevel || SECONDARY_STORE == dwStoreLevel);

        // should be primary or secondary
        if (PRIMARY_STORE != dwStoreLevel && SECONDARY_STORE != dwStoreLevel)
        {
            THROW( CException( STATUS_TRANSACTION_INVALID_TYPE ) );
        }

        // should be the same as the first store used in the transaction
        if (_dwXctionStoreLevel != dwStoreLevel)
        {
            THROW( CException( STATUS_TRANSACTION_NO_MATCH ) );
        }
    }

    // Before placing the pid in a store, assert that it doesn't
    // exist in the other store.

    CLock lock( _mtxWrite );

    CPropStoreManager *pStoreMgr = (CPropStoreManager *)ulToken;

    if (PRIMARY_STORE == dwStoreLevel)
    {
        Win4Assert(_xSecondaryStore->CanStore(pid) == FALSE);

        if (_xSecondaryStore->CanStore(pid))
        {
            THROW( CException( STATUS_TRANSACTION_NO_MATCH ) );
        }

        _xPrimaryStore->Setup(pid, vt, cbMaxLen,
                              (ULONG_PTR)pStoreMgr->_xPrimaryStore.GetPointer(),
                              fCanBeModified);
    }
    else
    {
       Win4Assert(_xPrimaryStore->CanStore(pid) == FALSE);

       if (_xPrimaryStore->CanStore(pid))
       {
           THROW( CException( STATUS_TRANSACTION_NO_MATCH ) );
       }

       _xSecondaryStore->Setup(pid, vt, cbMaxLen,
                               (ULONG_PTR)pStoreMgr->_xSecondaryStore.GetPointer(),
                               fCanBeModified);
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CPropStoreManager::EndTransaction, public
//
//  Synopsis:   End property transaction, and maybe commit changes.
//
//  Arguments:  [ulToken] -- Token of transaction
//              [fCommit] -- TRUE --> Commit transaction
//              [pidFixedPrimary]   -- Every workid with this pid will move to the
//                                     same workid in the new property cache.
//              [pidFixedSecondary] -- Every workid with this pid will move to the
//                                     same workid in the new property cache.
//
//  History:    22-Oct-97     KrishnaN       Created.
//
//----------------------------------------------------------------------------

void CPropStoreManager::EndTransaction( ULONG_PTR ulToken, BOOL fCommit,
                                        PROPID pidFixedPrimary,
                                        PROPID pidFixedSecondary )
{
    Win4Assert(ulToken);

    CLock lock( _mtxWrite );

    if ( ulToken != (ULONG_PTR)_xpsNew.GetPointer() )
    {
        ciDebugOut(( DEB_ERROR,
                     "PropStMgr: Transaction mismatch: 0x%x vs. 0x%x\n",
                     ulToken, _xpsNew.GetPointer() ));
        THROW( CException( STATUS_TRANSACTION_NO_MATCH ) );
    }

    _xPrimaryStore->EndTransaction((ULONG_PTR)_xpsNew->_xPrimaryStore.GetPointer(),
                                   fCommit, pidFixedPrimary);
    _xSecondaryStore->EndTransaction((ULONG_PTR)_xpsNew->_xSecondaryStore.GetPointer(),
                                     fCommit, pidFixedSecondary);

    // The primary and secondary ptrs are already deleted in EndTransaction
    // calls. Cleanup to reflect them prior to deleting _xpsNew.

    _xpsNew->_xPrimaryStore.Acquire();
    _xpsNew->_xSecondaryStore.Acquire();

    _xpsNew.Free();
} //EndTransaction

//+---------------------------------------------------------------------------
//
//  Member:     CPropStoreManager::MakeBackupCopy
//
//  Synopsis:   Makes a backup copy of the property storage. It makes a
//              full copy if the pIEnumWorkids is NULL. Otherwise, it makes
//              a copy of only the changed workids.
//
//  Arguments:  [pIProgressEnum] - Progress indication
//              [pfAbort]        - Caller initiated abort flag
//              [dstStorage]     - Destination storage to use
//              [pIEnumWorkids]  - List of workids to copy. If null, all the
//              workids are copied.
//              [ppFileList]     - List of propstore files copied.
//
//  History:    22-Oct-97    KrishnaN   Created
//
//  Notes:      Incremental not implemented yet
//
//----------------------------------------------------------------------------


void CPropStoreManager::MakeBackupCopy( IProgressNotify * pIProgressEnum,
                                     BOOL & fAbort,
                                     CiStorage & dstStorage,
                                     ICiEnumWorkids * pIEnumWorkids,
                                     IEnumString **ppFileList )
{
    CLock lock( _mtxWrite );

    Flush();

    // fill in an array of sizes to pass into CCompositeProgressNotifier
    DWORD *pdwStoreSizes = new DWORD[2];
    pdwStoreSizes[0] = _xPrimaryStore->GetTotalSizeInKB();
    pdwStoreSizes[1] = _xSecondaryStore->GetTotalSizeInKB();

    CCompositeProgressNotifier ProgressNotifier( pIProgressEnum, pdwStoreSizes );

    _xPrimaryStore->MakeBackupCopy(&ProgressNotifier, fAbort, dstStorage,
                                   pIEnumWorkids, ppFileList);
    ProgressNotifier.IncrementFinishedComponents();

    ICiEnumWorkids *pIEnumSecondaryWorkids = pIEnumWorkids;

    _xSecondaryStore->MakeBackupCopy(&ProgressNotifier, fAbort, dstStorage,
                                     pIEnumSecondaryWorkids, ppFileList);
}

//+---------------------------------------------------------------------------
//
//  Member:     CPropStoreManager::WriteProperty, public
//
//  Synopsis:   Write a property to the cache.
//
//  Arguments:  [wid] -- Workid
//              [pid] -- Propid
//              [var] -- Value
//
//  Returns:    Scode propagated from underlying store.
//
//  History:    24-Oct-97      KrishnaN       Created.
//
//----------------------------------------------------------------------------

SCODE CPropStoreManager::WriteProperty( WORKID wid,
                                        PROPID pid,
                                        CStorageVariant const & var )
{
    if ( _xPrimaryStore->CanStore( pid ) )
    {
        return WritePrimaryProperty( wid, pid, var );
    }
    else
    {
        CCompositePropRecordForWrites PropRecord( wid, *this, _mtxWrite );

        return _xSecondaryStore->WriteProperty( PropRecord.GetSecondaryPropRecord(),
                                                pid,
                                                var,
                                                IsBackedUpMode() );
    }
} //WriteProperty

//+---------------------------------------------------------------------------
//
//  Member:     CPropStoreManager::WriteProperty, public
//
//  Synopsis:   Write a property to the specified cache.
//
//  Arguments:  [dwStoreLevle] -- level of the property store to write to 
//              [PropRecord]   -- Previously opened property record.
//              [pid]          -- Propid
//              [var]          -- Value
//
//  Returns:    SCODE propagated from underlying store.
//
//  History:    23-Oct-2000      KitmanH       Created.
//
//----------------------------------------------------------------------------

SCODE CPropStoreManager::WriteProperty( DWORD dwStoreLevel,
                                        CCompositePropRecordForWrites & PropRecord,
                                        PROPID pid,
                                        CStorageVariant const & var )
{
    Win4Assert( PRIMARY_STORE == dwStoreLevel || SECONDARY_STORE == dwStoreLevel );
    
    if ( PRIMARY_STORE == dwStoreLevel )
    {
        if ( _xPrimaryStore->CanStore( pid ) )
            return WritePrimaryProperty( PropRecord, pid, var );
    }
    else
    {
        if ( _xSecondaryStore->CanStore( pid ) )
            return WriteSecondaryProperty( PropRecord, pid, var );
    }

    return E_INVALIDARG;
    
} //WriteProperty

//+---------------------------------------------------------------------------
//
//  Member:     CPropStoreManager::WritePrimaryProperty, public
//
//  Synopsis:   Write a property from the cache.  Triggers CoTaskMemAlloc
//
//  Arguments:  [wid] -- Workid
//              [pid] -- Propid
//              [var] -- Place to return the value
//
//  History:    22-Oct-97   KrishnaN       Created.
//
//----------------------------------------------------------------------------

SCODE CPropStoreManager::WritePrimaryProperty( WORKID wid,
                                               PROPID pid,
                                               CStorageVariant const & var )
{
    CPrimaryPropRecordForWrites PropRecord( wid, *this, _mtxWrite );

    return WritePrimaryProperty( PropRecord, pid, var );
}


//+---------------------------------------------------------------------------
//
//  Member:     CPropStoreManager::WriteProperty, public
//
//  Synopsis:   Write a property to the cache.
//
//  Arguments:  [PropRecord] -- Previously opened property record.
//              [pid] -- Propid
//              [var] -- Value
//
//  Returns:    Scode propagated from underlying store.
//
//  History:    24-Oct-97      KrishnaN       Created.
//
//----------------------------------------------------------------------------

SCODE CPropStoreManager::WriteProperty( CCompositePropRecordForWrites & PropRecord,
                                        PROPID pid, CStorageVariant const & var )
{
    ciDebugOut(( DEB_PROPSTORE, "WRITE: proprecord = 0x%x, pid = 0x%x, type = %d\n", &PropRecord, pid, var.Type() ));

    if (_xPrimaryStore->CanStore(pid))
        return _xPrimaryStore->WriteProperty(PropRecord.GetPrimaryPropRecord(), pid, var, IsBackedUpMode() );
    else
        return _xSecondaryStore->WriteProperty(PropRecord.GetSecondaryPropRecord(), pid, var, IsBackedUpMode() );
}

//+---------------------------------------------------------------------------
//
//  Member:     CPropStoreManager::WritePrimaryProperty, public
//
//  Synopsis:   Write a property from the cache.  Triggers CoTaskMemAlloc
//
//  Arguments:  [PropRecord] -- Previously opened property record
//              [pid] -- Propid
//              [var] -- Place to return the value
//
//  History:    17-Mar-98   KrishnaN       Created.
//
//----------------------------------------------------------------------------

SCODE CPropStoreManager::WritePrimaryProperty( CCompositePropRecordForWrites & PropRecord,
                                               PROPID pid, CStorageVariant const & var )
{
    // Has to be used only to Write pids in the primary store.
    Win4Assert(_xPrimaryStore->CanStore(pid) == TRUE);

    return _xPrimaryStore->WriteProperty( PropRecord.GetPrimaryPropRecord(), pid, var, IsBackedUpMode() );
}

//+---------------------------------------------------------------------------
//
//  Member:     CPropStoreManager::WritePrimaryProperty, public
//
//  Synopsis:   Write a property from the cache.  Triggers CoTaskMemAlloc
//
//  Arguments:  [PropRecord] -- Previously opened property record
//              [pid] -- Propid
//              [var] -- Place to return the value
//
//  History:    17-Mar-98   KrishnaN       Created.
//
//----------------------------------------------------------------------------

SCODE CPropStoreManager::WritePrimaryProperty( CPrimaryPropRecordForWrites & PropRecord,
                                               PROPID pid,
                                               CStorageVariant const & var )
{
    // Has to be used only to Write pids in the primary store.
    Win4Assert(_xPrimaryStore->CanStore(pid) == TRUE);

    return _xPrimaryStore->WriteProperty( PropRecord.GetPrimaryPropRecord(), pid, var, IsBackedUpMode() );
}

//+---------------------------------------------------------------------------
//
//  Member:     CPropStoreManager::WriteSecondaryProperty, public
//
//  Synopsis:   Write a property from the cache. Triggers CoTaskMemAlloc
//
//  Arguments:  [PropRecord] -- Previously opened property record
//              [pid] -- Propid
//              [var] -- Place to return the value
//
//  History:    23-Oct-2000   KitmanH       Created.
//
//----------------------------------------------------------------------------

SCODE CPropStoreManager::WriteSecondaryProperty( CCompositePropRecordForWrites & PropRecord,
                                                 PROPID pid, CStorageVariant const & var )
{
    Win4Assert(_xSecondaryStore->CanStore(pid) == TRUE);

    return _xSecondaryStore->WriteProperty( PropRecord.GetSecondaryPropRecord(), pid, var, IsBackedUpMode() );
}

//+---------------------------------------------------------------------------
//
//  Member:     CPropStoreManager::ReadProperty, public
//
//  Synopsis:   Read a property from the cache.
//
//  Arguments:  [wid]    -- Workid
//              [pid]    -- Propid
//              [pbData] -- Place to return the value
//              [pcb]    -- On input, the maximum number of bytes to
//                          write at pbData.  On output, the number of
//                          bytes written if the call was successful,
//                          else the number of bytes required.
//
//  History:    22-Oct-97     KrishnaN       Created.
//
//----------------------------------------------------------------------------

BOOL CPropStoreManager::ReadProperty( WORKID wid, PROPID pid,
                                      PROPVARIANT * pbData, unsigned * pcb )
{
    unsigned cb = *pcb - sizeof (PROPVARIANT);
    BOOL fOk = ReadProperty( wid, pid, *pbData, (BYTE *)(pbData + 1), &cb );
    *pcb = cb + sizeof (PROPVARIANT);

    return fOk;
}

//+---------------------------------------------------------------------------
//
//  Member:     CPropStoreManager::ReadProperty, public
//
//  Synopsis:   Read a property from the cache.  Version which uses property
//              record.
//
//  Arguments:  [PropRec] -- Pre-opened property record
//              [pid]     -- Propid
//              [pbData]  -- Place to return the value
//              [pcb]     -- On input, the maximum number of bytes to
//                           write at pbData.  On output, the number of
//                           bytes written if the call was successful,
//                           else the number of bytes required.
//
//  History:    22-Oct-97   KrishnaN       Created.
//
//----------------------------------------------------------------------------

BOOL CPropStoreManager::ReadProperty( CCompositePropRecord & PropRec,
                                      PROPID pid,
                                      PROPVARIANT * pbData,
                                      unsigned * pcb )
{
    unsigned cb = *pcb - sizeof (PROPVARIANT);
    BOOL fOk = ReadProperty( PropRec, pid, *pbData, (BYTE *)(pbData + 1), &cb );
    *pcb = cb + sizeof (PROPVARIANT);

    return fOk;
}

//+---------------------------------------------------------------------------
//
//  Member:     CPropStoreManager::ReadProperty, public
//
//  Synopsis:   Read a property from the cache.  Version which uses property
//              record.
//
//  Arguments:  [PropRec] -- Pre-opened property record
//              [pid]     -- Propid
//              [var] -- Place to return the value
//
//  History:    19-Dec-97   dlee      Created.
//
//----------------------------------------------------------------------------

BOOL CPropStoreManager::ReadProperty(
    CCompositePropRecord & PropRec,
    PROPID                 pid,
    PROPVARIANT &          var )
{
    unsigned cb = 0xFFFFFFFF;
    return ReadProperty( PropRec, pid, var, 0, &cb );
}

//+---------------------------------------------------------------------------
//
//  Member:     CPropStoreManager::ReadProperty, public
//
//  Synopsis:   Read a property from the cache.  Version which uses property
//              record.
//
//  Arguments:  [PropRec] -- Pre-opened property record
//              [pid]     -- Propid
//              [var] -- Place to return the value
//
//  History:    19-Dec-97   dlee      Created.
//
//----------------------------------------------------------------------------

BOOL CPropStoreManager::ReadProperty(
    CPrimaryPropRecord & PropRec,
    PROPID               pid,
    PROPVARIANT &        var )
{
    unsigned cb = 0xFFFFFFFF;
    return ReadProperty( PropRec, pid, var, 0, &cb );
}

//+---------------------------------------------------------------------------
//
//  Member:     CPropStoreManager::ReadProperty, public
//
//  Synopsis:   Read a property from the cache.  Triggers CoTaskMemAlloc
//
//  Arguments:  [wid] -- Workid
//              [pid] -- Propid
//              [var] -- Place to return the value
//
//  History:    22-Oct-97   KrishnaN       Created.
//
//----------------------------------------------------------------------------

BOOL CPropStoreManager::ReadProperty(
    WORKID        wid,
    PROPID        pid,
    PROPVARIANT & var )
{
    unsigned cb = 0xFFFFFFFF;
    return ReadProperty( wid, pid, var, 0, &cb );
}


//+---------------------------------------------------------------------------
//
//  Member:     CPropStoreManager::ReadProperty, public
//
//  Synopsis:   Read a property from the cache.  Triggers CoTaskMemAlloc
//
//  Arguments:  [wid] -- Workid
//              [pid] -- Propid
//              [var] -- Place to return the value
//
//  History:    22-Oct-97   KrishnaN       Created.
//
//----------------------------------------------------------------------------

BOOL CPropStoreManager::ReadPrimaryProperty( WORKID wid, PROPID pid, PROPVARIANT & var )
{
    // Has to be used only to read pids in the primary store.
    Win4Assert(_xPrimaryStore->CanStore(pid) == TRUE);

    unsigned cb = 0xFFFFFFFF;
    BOOL fOk = _xPrimaryStore->ReadProperty( wid, pid, var, 0, &cb );

    return fOk;
}

//+---------------------------------------------------------------------------
//
//  Member:     CPropStoreManager::ReadProperty, public
//
//  Synopsis:   Read a property from the cache.  Separate variable buffer.
//
//  Arguments:  [wid]      -- Workid
//              [pid]      -- Propid
//              [var]      -- Variant written here
//              [pbExtra]  -- Place to store additional pointer(s).
//              [pcbExtra] -- On input, the maximum number of bytes to
//                            write at pbExtra.  On output, the number of
//                            bytes written if the call was successful,
//                            else the number of bytes required.
//
//  History:    24-Oct-97      KrishnaN       Created.
//
//----------------------------------------------------------------------------

BOOL CPropStoreManager::ReadProperty( WORKID wid,
                                      PROPID pid,
                                      PROPVARIANT & var,
                                      BYTE * pbExtra,
                                      unsigned * pcbExtra )
{
    if ( _xPrimaryStore->CanStore( pid ) )
    {
        CPrimaryPropRecord PropRecord( wid, *this );
        return ReadProperty( PropRecord, pid, var, pbExtra, pcbExtra );
    }
    else
    {
        // the constructor seeds the constituent proprecords
        // with the right wid, based on the wid we pass in.

        CCompositePropRecord PropRecord( wid, *this );

        return _xSecondaryStore->ReadProperty( PropRecord.GetSecondaryPropRecord(),
                                              pid, var, pbExtra, pcbExtra);
    }
} //ReadProperty

//+---------------------------------------------------------------------------
//
//  Member:     CPropStoreManager::ReadProperty, public
//
//  Synopsis:   Read a property from the cache.  Separate variable buffer.
//              Uses pre-opened property record.
//
//  Arguments:  [PropRec]  -- Pre-opened property record.
//              [pid]      -- Propid
//              [var]      -- Variant written here
//              [pbExtra]  -- Place to store additional pointer(s).
//              [pcbExtra] -- On input, the maximum number of bytes to
//                            write at pbExtra.  On output, the number of
//                            bytes written if the call was successful,
//                            else the number of bytes required.
//
//  History:    03-Apr-96   KyleP       Created.
//
//----------------------------------------------------------------------------

BOOL CPropStoreManager::ReadProperty( CCompositePropRecord & PropRecord,
                                   PROPID pid,
                                   PROPVARIANT & var,
                                   BYTE * pbExtra,
                                   unsigned * pcbExtra )
{
    if (_xPrimaryStore->CanStore(pid))
    {
        return _xPrimaryStore->ReadProperty(PropRecord.GetPrimaryPropRecord(),
                                            pid, var, pbExtra, pcbExtra);
    }
    else
    {
        return _xSecondaryStore->ReadProperty(PropRecord.GetSecondaryPropRecord(),
                                              pid, var, pbExtra, pcbExtra);
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CPropStoreManager::ReadProperty, public
//
//  Synopsis:   Read a property from the cache.  Separate variable buffer.
//              Uses pre-opened property record.
//
//  Arguments:  [PropRec]  -- Pre-opened property record.
//              [pid]      -- Propid
//              [var]      -- Variant written here
//              [pbExtra]  -- Place to store additional pointer(s).
//              [pcbExtra] -- On input, the maximum number of bytes to
//                            write at pbExtra.  On output, the number of
//                            bytes written if the call was successful,
//                            else the number of bytes required.
//
//  History:    03-Apr-96   KyleP       Created.
//
//----------------------------------------------------------------------------

BOOL CPropStoreManager::ReadProperty( CPrimaryPropRecord & PropRecord,
                                      PROPID pid,
                                      PROPVARIANT & var,
                                      BYTE * pbExtra,
                                      unsigned * pcbExtra )
{
    Win4Assert( _xPrimaryStore->CanStore(pid) );
    return _xPrimaryStore->ReadProperty(PropRecord.GetPrimaryPropRecord(),
                                        pid, var, pbExtra, pcbExtra);
}

//+---------------------------------------------------------------------------
//
//  Member:     CPropStoreManager::OpenRecord, public
//
//  Synopsis:   Opens record (for multiple reads)
//
//  Arguments:  [wid] -- Workid
//              [pb]  -- Storage for record
//
//  Returns:    Pointer to open property record.  Owned by caller.
//
//  History:    03-Apr-96   KyleP       Created.
//
//----------------------------------------------------------------------------

CCompositePropRecord * CPropStoreManager::OpenRecord( WORKID wid, BYTE * pb )
{
    Win4Assert( sizeof(CCompositePropRecord) <= sizeof_CCompositePropRecord );
    return new( pb ) CCompositePropRecord( wid, *this );
}

//+---------------------------------------------------------------------------
//
//  Member:     CPropStoreManager::CloseRecord, public
//
//  Synopsis:   Closes record.
//
//  Arguments:  [pRec] -- Property record
//
//  History:    03-Apr-96   KyleP       Created.
//
//----------------------------------------------------------------------------

void CPropStoreManager::CloseRecord( CCompositePropRecord * pRec )
{
    delete pRec;
}

//+---------------------------------------------------------------------------
//
//  Member:     CPropStoreManager::OpenPrimaryRecord, public
//
//  Synopsis:   Opens record (for multiple reads)
//
//  Arguments:  [wid] -- Workid
//              [pb]  -- Storage for record
//
//  Returns:    Pointer to open property record.  Owned by caller.
//
//  History:    03-Apr-96   KyleP       Created.
//
//----------------------------------------------------------------------------

CPrimaryPropRecord * CPropStoreManager::OpenPrimaryRecord( WORKID wid, BYTE * pb )
{
    Win4Assert( sizeof(CPrimaryPropRecord) <= sizeof_CPropRecord );
    return new( pb ) CPrimaryPropRecord( wid, *this );
}

//+---------------------------------------------------------------------------
//
//  Member:     CPropStoreManager::CloseRecord, public
//
//  Synopsis:   Closes record.
//
//  Arguments:  [pRec] -- Property record
//
//  History:    03-Apr-96   KyleP       Created.
//
//----------------------------------------------------------------------------

void CPropStoreManager::CloseRecord( CPrimaryPropRecord * pRec )
{
    delete pRec;
}

//+---------------------------------------------------------------------------
//
//  Member:     CPropStoreManager::OpenRecordForWrites, public
//
//  Synopsis:   Opens record (for multiple writes)
//
//  Arguments:  [wid] -- Workid
//              [pb]  -- Storage for record
//
//  Returns:    Pointer to open property record.  Owned by caller.
//
//  History:    17-Mar-98   KrishnaN       Created.
//
//----------------------------------------------------------------------------

CCompositePropRecordForWrites * CPropStoreManager::OpenRecordForWrites( WORKID wid, BYTE * pb )
{
    Win4Assert( sizeof(CCompositePropRecordForWrites) <= sizeof_CCompositePropRecord );
    return new( pb ) CCompositePropRecordForWrites( wid, *this, _mtxWrite );
}

//+---------------------------------------------------------------------------
//
//  Member:     CPropStoreManager::OpenPrimaryRecordForWrites, public
//
//  Synopsis:   Opens record (for multiple writes)
//
//  Arguments:  [wid] -- Workid
//              [pb]  -- Storage for record
//
//  Returns:    Pointer to open property record.  Owned by caller.
//
//  History:    17-Mar-98   KrishnaN       Created.
//
//----------------------------------------------------------------------------

CPrimaryPropRecordForWrites * CPropStoreManager::OpenPrimaryRecordForWrites( WORKID wid, BYTE * pb )
{
    Win4Assert( sizeof(CPrimaryPropRecordForWrites) <= sizeof_CPropRecord );
    return new( pb ) CPrimaryPropRecordForWrites( wid, *this, _mtxWrite );
}

//+---------------------------------------------------------------------------
//
//  Member:     CPropStoreManager::CloseRecord, public
//
//  Synopsis:   Closes record.
//
//  Arguments:  [pRec] -- Property record
//
//  History:    17-Mar-98   KrishnaN       Created.
//
//----------------------------------------------------------------------------

void CPropStoreManager::CloseRecord( CCompositePropRecordForWrites * pRec )
{
    delete pRec;
}

//+---------------------------------------------------------------------------
//
//  Member:     CPropStoreManager::CloseRecord, public
//
//  Synopsis:   Closes record.
//
//  Arguments:  [pRec] -- Property record
//
//  History:    17-Mar-98   KrishnaN       Created.
//
//----------------------------------------------------------------------------

void CPropStoreManager::CloseRecord( CPrimaryPropRecordForWrites * pRec )
{
    delete pRec;
}

//+---------------------------------------------------------------------------
//
//  Member:     CPropStoreManager::DeleteRecord, public
//
//  Synopsis:   Free a record and any records chained off it.
//
//  Arguments:  [wid] -- Workid
//
//  History:    24-Oct-97      KrishnaN       Created.
//
//----------------------------------------------------------------------------

void CPropStoreManager::DeleteRecord( WORKID wid )
{
    CLock   lock( _mtxWrite );

    ciDebugOut(( DEB_PROPSTORE, "DELETE: wid = 0x%x\n", wid ));

    //
    // Get the secondary store's top-level wid before getting rid
    // of the wid in the primary store.
    //

    //
    // The secondary wid can certainly be bogus if we couldn't write
    // it to the primary store after allocating it when creating the
    // records.
    //

    WORKID widSec = GetSecondaryTopLevelWid(wid);

    if ( widInvalid != widSec && 0 != widSec )
        _xSecondaryStore->DeleteRecord( widSec,
                                        IsBackedUpMode() );

    _xPrimaryStore->DeleteRecord( wid, IsBackedUpMode() );
}

//+---------------------------------------------------------------------------
//
//  Member:     CPropStoreManager::Flush
//
//  Synopsis:   Flushes the data in the property store and marks it clean.
//
//  History:    3-20-96   srikants   Created
//
//----------------------------------------------------------------------------

void CPropStoreManager::Flush()
{
    CLock mtxLock( _mtxWrite );

    // Flush both the stores. Only when both are successful
    // do we consider the entire flush to be successful.
    // Don't reset the backup streams until the flush is
    // completely successful.

    BOOL fFlushOK = _xPrimaryStore->Flush();
    if (fFlushOK)
        fFlushOK = _xSecondaryStore->Flush();

    // Reset the primary and the secondary backup stores
    if (fFlushOK)
    {
        if (_xPrimaryStore->BackupStream())
            _xPrimaryStore->BackupStream()->Reset(_xPrimaryStore->GetDesiredBackupSize());

        if (_xSecondaryStore->BackupStream())
            _xSecondaryStore->BackupStream()->Reset(_xSecondaryStore->GetDesiredBackupSize());
    }
}


//+---------------------------------------------------------------------------
//
//  Member:     CPropStoreManager::WritePropertyInNewRecord, public
//
//  Synopsis:   Like WriteProperty, but also allocates record.
//
//  Arguments:  [pid] -- Propid to write.
//              [var] -- Property value
//
//  Returns:    Workid of new record.
//
//  History:    22-Oct-97   KrishnaN       Created.
//
//----------------------------------------------------------------------------

WORKID CPropStoreManager::WritePropertyInNewRecord( PROPID pid,
                                                    CStorageVariant const & var )
{
    CLock lock( _mtxWrite );

    //
    // Get new wids from the primary and the secondary store.
    // Write the property.
    // Increment records in use for both the stores.
    //

    WORKID widPrimary = widInvalid;
    WORKID widSecondary = widInvalid;

    TRY
    {
        widPrimary = _xPrimaryStore->NewWorkId( 1, IsBackedUpMode() );
        widSecondary = _xSecondaryStore->NewWorkId( 1, IsBackedUpMode() );
    }
    CATCH(CException, e)
    {
        // cleanup if widSecondary is invalid
        if (widInvalid == widSecondary && widInvalid != widPrimary)
            _xPrimaryStore->DeleteRecord( widPrimary, IsBackedUpMode() );

        // Let the caller do what it normally does to handle exceptions
        RETHROW();
    }
    END_CATCH

    ciDebugOut(( DEB_PROPSTORE, "New record at primary: %d, secondary: %d\n",
                 widPrimary, widSecondary ));

    //
    // The primary's top-level record has a pointer to the
    // top-level record in the secondary store. Fill that now!
    //

    VARIANT newVar;
    newVar.vt = VT_UI4;
    newVar.ulVal = widSecondary;
    CStorageVariant *pVar = CastToStorageVariant(newVar);
    SCODE sc;

    sc = WritePrimaryProperty( widPrimary, pidSecondaryStorage, *pVar );
    if (FAILED(sc))
        THROW(CException(sc));

    sc = WriteProperty( widPrimary, pid, var );

    //
    // DLee add this assert to find out why this is failing sometimes.
    // Did the caller pass a bogus variant?
    //

    Win4Assert( HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER ) != sc );

    if (FAILED(sc))
        THROW(CException(sc));

    _xPrimaryStore->IncRecordsInUse();
    _xSecondaryStore->IncRecordsInUse();

    // To the outside world, the primary wid is the one that matters.
    return widPrimary;
}

//
// get and set parameters
// If incorrect parameter, default to the primary store.
//

//+---------------------------------------------------------------------------
//
//  Member:     CPropStoreManager::SetBackupSize, public
//
//  Synopsis:   Sets backup size for a given property store.
//
//  Arguments:  [ulBackupSizeInPages] -- Size of the backup file.
//              [dwStoreLevel] -- Primary or secondary store?
//
//  History:    22-Oct-97   KrishnaN       Created.
//
//----------------------------------------------------------------------------

void CPropStoreManager::SetBackupSize(ULONG ulBackupSizeInPages,
                                      DWORD dwStoreLevel)
{
    if (SECONDARY_STORE == dwStoreLevel)
        _xSecondaryStore->SetBackupSize(ulBackupSizeInPages);
    else
    {
        Win4Assert(PRIMARY_STORE == dwStoreLevel);
        _xPrimaryStore->SetBackupSize(ulBackupSizeInPages);
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CPropStoreManager::GetBackupSize, public
//
//  Synopsis:   Gets backup size of a given property store.
//
//  Arguments:  [dwStoreLevel] -- Primary or secondary store?
//
//  History:    22-Oct-97   KrishnaN       Created.
//
//----------------------------------------------------------------------------

ULONG CPropStoreManager::GetBackupSize(DWORD dwStoreLevel)
{
    if ( SECONDARY_STORE == dwStoreLevel)
        return _xSecondaryStore->GetActualBackupSize();
    else
    {
        Win4Assert( PRIMARY_STORE == dwStoreLevel);
        return _xPrimaryStore->GetActualBackupSize();
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CPropStoreManager::SetMappedCacheSize, public
//
//  Synopsis:   Gets backup size of a given property store.
//
//  Arguments:  [dwStoreLevel] -- Primary or secondary store?
//
//  History:    22-Oct-97   KrishnaN       Created.
//
//----------------------------------------------------------------------------

void CPropStoreManager::SetMappedCacheSize(ULONG ulPSMappedCache,
                                               DWORD dwStoreLevel)
{
    if ( SECONDARY_STORE == dwStoreLevel)
        _xSecondaryStore->SetMappedCacheSize(ulPSMappedCache);
    else
    {
        Win4Assert( PRIMARY_STORE== dwStoreLevel);
        _xPrimaryStore->SetMappedCacheSize(ulPSMappedCache);
    }
}


//+---------------------------------------------------------------------------
//
//  Member:     CPropStoreManager::GetMappedCacheSize, public
//
//  Synopsis:   Gets mapped cache size of a given property store.
//
//  Arguments:  [dwStoreLevel] -- Primary or secondary store?
//
//  History:    22-Oct-97   KrishnaN       Created.
//
//----------------------------------------------------------------------------

ULONG CPropStoreManager::GetMappedCacheSize(DWORD dwStoreLevel)
{
    if (SECONDARY_STORE == dwStoreLevel)
        return _xSecondaryStore->GetMappedCacheSize();
    else
    {
        Win4Assert(PRIMARY_STORE == dwStoreLevel);
        return _xPrimaryStore->GetMappedCacheSize();
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CPropStoreManager::GetTotalSizeInKB, public
//
//  Synopsis:   Gets total size of the property store.
//
//  Arguments:
//
//  History:    22-Oct-97   KrishnaN       Created.
//
//----------------------------------------------------------------------------

ULONG CPropStoreManager::GetTotalSizeInKB()
{
    return _xPrimaryStore->GetTotalSizeInKB() +
           _xSecondaryStore->GetTotalSizeInKB();
}

PStorage& CPropStoreManager::GetStorage(DWORD dwStoreLevel)
{
    Win4Assert(&(_xPrimaryStore->GetStorage()) == _pStorage);
    Win4Assert(&(_xSecondaryStore->GetStorage()) == _pStorage);

    return *_pStorage;
}

void CPropStoreManager::Shutdown()
{
    Flush();
    _xPrimaryStore->Shutdown();
    _xSecondaryStore->Shutdown();
}

void CPropStoreManager::ClearNonStorageProperties( CCompositePropRecordForWrites & rec )
{
    _xPrimaryStore->ClearNonStorageProperties( rec );
    _xSecondaryStore->ClearNonStorageProperties( rec );
}

// CSvcQuery methods

//+-------------------------------------------------------------------------
//
//  Member:     CCompositeProgressNotifier::QueryInterface, public
//
//  Arguments:  [ifid]  -- Interface id
//              [ppiuk] -- Interface return pointer
//
//  Returns:    Error.  No rebind from this class is supported.
//
//  History:    Nov-14-97    KrishnaN     Created
//
//--------------------------------------------------------------------------

STDMETHODIMP CCompositeProgressNotifier::QueryInterface(
    REFIID  ifid,
    void ** ppiuk )
{
    if ( IID_IUnknown == ifid )
    {
        AddRef();
        *ppiuk = (void *)((IUnknown *)this);
        return S_OK;
    }
    else
    {
        *ppiuk = 0;
        return E_NOINTERFACE;
    }
} //QueryInterface

//+-------------------------------------------------------------------------
//
//  Member:     CCompositeProgressNotifier::AddRef, public
//
//  Synopsis:   Reference the virtual table.
//
//  History:    Nov-14-97    KrishnaN     Created
//
//--------------------------------------------------------------------------

STDMETHODIMP_(ULONG) CCompositeProgressNotifier::AddRef()
{
    InterlockedIncrement( &_ref );
    return (ULONG)_ref;
} //AddRef

//+-------------------------------------------------------------------------
//
//  Member:     CCompositeProgressNotifier::Release, public
//
//  Synopsis:   De-Reference the virtual table.
//
//  Effects:    If the ref count goes to 0 then the table is deleted.
//
//  History:    Nov-14-97    KrishnaN     Created
//
//--------------------------------------------------------------------------

STDMETHODIMP_(ULONG) CCompositeProgressNotifier::Release()
{
    unsigned long uTmp = InterlockedDecrement( &_ref );

    if ( 0 == uTmp )
        delete this;

    return(uTmp);
} //Release



//+-------------------------------------------------------------------------
//
//  Member:     CCompositeProgressNotifier::OnProgress, public
//
//  Synopsis:   Report progress.
//
//  Effects:    Progress reporting accounts for the presence of multiple
//              independently operating constituents in the property store.
//
//  History:    Nov-14-97    KrishnaN     Created
//
//--------------------------------------------------------------------------

STDMETHODIMP CCompositeProgressNotifier::OnProgress
                (
                 DWORD dwProgressCurrent,
                 DWORD dwProgressMaximum,
                 BOOL fAccurate,
                 BOOL fOwner
                )
{
    if (0 == _xComponentProgressNotifier.GetPointer())
        return S_OK;

    Win4Assert(_cFinishedComponents < _cComponents);
    Win4Assert(dwProgressMaximum == _aulMaxSizes[_cFinishedComponents]);

    //
    // Present a unified view of progress reports. The composite progress
    // report is 100% done only when all components are 100% done.
    //

    return _xComponentProgressNotifier->OnProgress
                 (dwProgressCurrent*1000/dwProgressMaximum + _dwCumMaxSize,
                  _dwTotalMaxSize,
                  fAccurate,
                  fOwner);

} //OnProgress
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\ntciutil\propstor.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1991 - 2000.
//
//  File:       PropStor.cxx
//
//  Contents:   Persistent property store (external to docfile)
//
//  Classes:    CPropertyStore
//
//  History:    27-Dec-1995   KyleP       Created
//
//----------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include <cistore.hxx>
#include <rcstrmit.hxx>

#include <proprec.hxx>
#include <propstor.hxx>
#include <propiter.hxx>
#include <borrow.hxx>
#include <propobj.hxx>
#include <eventlog.hxx>
#include <psavtrak.hxx>

#include <catalog.hxx>
#include <imprsnat.hxx>
#include <mmstrm.hxx>
#include <cievtmsg.h>

unsigned const MAX_DIRECT = 10;
const ULONG lowDiskWaterMark = 3 * 512 * 1024; // 1.5 MB

//+---------------------------------------------------------------------------
//
//  Member:     CPropStoreInfo::CPropStoreInfo, public
//
//  Synopsis:   Required for C++ EH.
//
//  History:    27-Dec-95   KyleP       Created.
//
//----------------------------------------------------------------------------

CPropStoreInfo::CPropStoreInfo(DWORD dwStoreLevel)
    : _fOwned(FALSE)
{
    _info.dwStoreLevel = dwStoreLevel;
    _info.fDirty = 0;

    //
    // We intend to have a lean primary property store and a normal secondary
    // property store. Whatever is set here can be changed later as new info
    // becomes available.
    //
    _info.eRecordFormat = (PRIMARY_STORE == dwStoreLevel) ? eLean : eNormal;

    SYSTEM_INFO si;
    GetSystemInfo(&si);
    _ulOSPageSize = si.dwPageSize;
    Win4Assert(0 == COMMON_PAGE_SIZE%_ulOSPageSize);
    _cOSPagesPerLargePage = COMMON_PAGE_SIZE/_ulOSPageSize;
}

//+---------------------------------------------------------------------------
//
//  Member:     CPropStoreInfo::CPropStoreInfo, public
//
//  Synopsis:   Copy constructor
//
//  Arguments:  [psi] -- Source
//
//  History:    16-Jan-96   KyleP       Created.
//
//----------------------------------------------------------------------------

CPropStoreInfo::CPropStoreInfo( CPropStoreInfo const & psi )
{
    _cRecPerPage = psi._cRecPerPage;
    _info = psi._info;

    _info.fDirty = fDirtyPropStore;
    _info.widMax = 0;
    _info.widFreeHead = 0;
    _info.widFreeTail = 0;
    _info.widStream = widInvalid;
    _info.cTopLevel = 0;
    _info.dwStoreLevel = psi._info.dwStoreLevel;
    _info.eRecordFormat = psi._info.eRecordFormat;

    _fOwned = FALSE;

    _aProp.Init( psi._aProp );
    _cOSPagesPerLargePage = psi._cOSPagesPerLargePage;
    _ulOSPageSize = psi._ulOSPageSize;
}

//+---------------------------------------------------------------------------
//
//  Member:     CPropStoreInfo::Empty
//
//  Synopsis:   Empties the contents. This method is called due to a failed
//              initialization of CI. After cleanup, another call to Init
//              may be made.
//
//  History:    3-18-96   srikants   Created
//
//----------------------------------------------------------------------------

void CPropStoreInfo::Empty()
{
    delete [] _aProp.Acquire();
    if ( _fOwned )
        _xrsoPropStore.Free();
    else
        _xrsoPropStore.Acquire();
}

//+---------------------------------------------------------------------------
//
//  Member:     CPropStoreInfo::FastTransfer
//
//  Synopsis:   Companion call to CPropertyStore::FastTransfer. Adjusts
//              metadata assuming CPropertyStore::FastTransfer has just
//              been called.
//
//  History:    10-Oct-1997   KyleP   Created
//
//----------------------------------------------------------------------------

void CPropStoreInfo::FastTransfer( CPropStoreInfo const & psi )
{
    _info.widMax = psi._info.widMax;
    _info.widFreeHead = psi._info.widFreeHead;
    _info.widFreeTail = psi._info.widFreeTail;
    _info.cTopLevel = psi._info.cTopLevel;
}

//+---------------------------------------------------------------------------
//
//  Member:     CPropStoreInfo::Init, public
//
//  Synopsis:   Loads metadata from persistent location into memory.
//
//  Arguments:  [pobj] -- Stream(s) in which metadata is stored.
//
//  History:    27-Dec-95   KyleP       Created.
//
//----------------------------------------------------------------------------

void CPropStoreInfo::Init( XPtr<PRcovStorageObj> & xobj,
                           DWORD dwStoreLevel )
{
    _xrsoPropStore.Set( xobj.Acquire() );
    _fOwned = TRUE;

    //
    // Load header
    //

    CRcovStorageHdr & hdr = _xrsoPropStore->GetHeader();
    struct CRcovUserHdr data;
    hdr.GetUserHdr( hdr.GetPrimary(), data );

    RtlCopyMemory( &_info, &data._abHdr, sizeof(_info) );
    _info.dwStoreLevel = dwStoreLevel;

    //
    // If we only have no properties, set the record format based on
    // storage type. Else, assert that we have the expected format type.
    //

    if ( 0 == CountProps() )
    {
        _info.eRecordFormat = (PRIMARY_STORE == dwStoreLevel) ? eLean : eNormal;
    }
#if CIDBG == 1
    else
    {
        if ( CountFixedProps() == CountProps() )
            Win4Assert( eLean == GetRecordFormat() );
        else
            Win4Assert( eNormal == GetRecordFormat() );
    }
#endif // CIDBG

    //
    // For consistency...
    //

    if ( 0 == _info.widStream )
        _info.widStream = widInvalid;

    if ( 0 == _info.culRecord )
        _info.culRecord = (eLean == GetRecordFormat()) ?
                               COnDiskPropertyRecord::FixedOverheadLean() :
                               COnDiskPropertyRecord::FixedOverheadNormal();

    _cRecPerPage = COMMON_PAGE_SIZE / (_info.culRecord * sizeof(ULONG));

    ciDebugOut(( DEB_PROPSTORE, "PROPSTORE: %s Store.\n",
                 (dwStoreLevel == PRIMARY_STORE) ? "Primary" : "Secondary"));
    ciDebugOut(( DEB_PROPSTORE, "PROPSTORE: Version = 0x%x\n", _info.Version ));
    ciDebugOut(( DEB_PROPSTORE, "PROPSTORE: Record size = %d bytes\n", _info.culRecord * sizeof(ULONG) ));
    ciDebugOut(( DEB_PROPSTORE, "PROPSTORE: Fixed record size = %d bytes\n", _info.culFixed * sizeof(ULONG) ));
    ciDebugOut(( DEB_PROPSTORE, "PROPSTORE: Store is %s\n", (_info.fDirty & fDirtyPropStore) ? "dirty" : "clean" ));
    ciDebugOut(( DEB_PROPSTORE, "PROPSTORE: Is NOT bacup mode: %d\n", 0 != (_info.fDirty & fNotBackedUp) ));
    ciDebugOut(( DEB_PROPSTORE, "PROPSTORE: %d properties stored\n", _info.cTotal ));
    ciDebugOut(( DEB_PROPSTORE, "PROPSTORE: %d fixed properties stored\n", _info.cFixed ));
    ciDebugOut(( DEB_PROPSTORE, "PROPSTORE: %s record format.\n",
                 (eLean == GetRecordFormat()) ? "Lean" : "Normal (not-lean)"));
    ciDebugOut(( DEB_PROPSTORE, "PROPSTORE: Hash size = %u\n", _info.cHash ));
    ciDebugOut(( DEB_PROPSTORE, "PROPSTORE: Max workid = %u\n", _info.widMax ));
    ciDebugOut(( DEB_PROPSTORE, "PROPSTORE: %d records per %dK page\n", _cRecPerPage, COMMON_PAGE_SIZE / 1024 ));

    //
    // Load properties
    //

    _aProp.Init( _info.cHash );

    CRcovStrmReadTrans xact( _xrsoPropStore.GetReference() );
    CRcovStrmReadIter  iter( xact, sizeof( CPropDesc ) );

    CPropDesc temp;

    while ( !iter.AtEnd() )
    {
        iter.GetRec( &temp );

        if ( temp.IsFixedSize() )
            ciDebugOut(( DEB_PROPSTORE,
                         "PROPSTORE: pid = 0x%x, ordinal = %u, size = %u, offset = %u, fixed\n",
                         temp.Pid(),
                         temp.Ordinal(),
                         temp.Size(),
                         temp.Offset() ));
        else
            ciDebugOut(( DEB_PROPSTORE,
                         "PROPSTORE: pid = 0x%x, ordinal = %u, cbMax = %d, vt = 0x%x variable\n",
                         temp.Pid(),
                         temp.Ordinal(),
                         temp.Size(),
                         temp.Type() ));

        _aProp[Lookup(temp.Pid())] = temp;
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CPropStoreInfo::Commit
//
//  Synopsis:   Commits the transaction on disk and then in-memory.
//
//  Arguments:  [psi]  - The new property store information.
//              [xact] - The persistent transaction to be committed.
//
//  History:    3-26-96   srikants   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

void CPropStoreInfo::Commit( CPropStoreInfo & psi, CRcovStrmWriteTrans & xact )
{
    //
    // Copy the in-memory structure to disk.
    //

    CRcovStorageHdr & hdr = _xrsoPropStore->GetHeader();
    CRcovStrmWriteIter  iter( xact, sizeof(CPropDesc) );

    hdr.SetUserDataSize( hdr.GetBackup(), iter.UserDataSize( psi._info.cTotal ) );

    unsigned iRec = 0;

    for ( unsigned i = 0; i < psi._aProp.Count(); i++ )
    {
        ciDebugOut(( DEB_ITRACE, "_aProp[%d], Pid 0x%x Size %d Type 0x%x\n",
                     i,
                     psi._aProp[i].Pid(),
                     psi._aProp[i].Size(),
                     psi._aProp[i].Type() ));

        if ( !psi._aProp[i].IsFree() )
        {
            psi._aProp[i].SetRecord( iRec );

            iter.SetRec( &psi._aProp[i], iRec );

            ciDebugOut(( DEB_ITRACE, "Pid 0x%x --> Slot %d\n", psi._aProp[i].Pid(), iRec ));

            iRec++;
        }
    }

    Win4Assert( iRec == psi._info.cTotal );

    struct CRcovUserHdr data;
    RtlCopyMemory( &data._abHdr, &psi._info, sizeof(_info) );

    hdr.SetCount(hdr.GetBackup(), psi._info.cTotal );
    hdr.SetUserHdr( hdr.GetBackup(), data );

    //
    // First commit the on-disk transaction.
    //

    xact.Commit();

    //
    // NO FAILURES AFTER THIS
    //

    //
    // Copy the data from the new property store info.
    //
    _cRecPerPage = psi._cRecPerPage;
    _info = psi._info;
    Win4Assert( psi._xrsoPropStore.IsNull() );
    Win4Assert( _fOwned && !psi._fOwned );

    //
    // Update the property array.
    //
    delete [] _aProp.Acquire();
    unsigned count = psi._aProp.Count();

    _aProp.Set( count, psi._aProp.Acquire() );
}

//+---------------------------------------------------------------------------
//
//  Member:     CPropStoreInfo::NextWorkId
//
//  Synopsis:   Changes the workid for the stream to be the next logical
//              one.
//
//  Returns:    The new work id.
//
//  History:    3-26-96   srikants   Created
//
//----------------------------------------------------------------------------

WORKID CPropStoreInfo::NextWorkId(CiStorage & storage)
{
    _info.Version++;
    _info.widStream = storage.CreateObjectId( CIndexId( _info.Version % (1 << 16), 0 ),
                                                  PStorage::eNonSparseIndex );

    return _info.widStream;
}

//+---------------------------------------------------------------------------
//
//  Member:     CPropStoreInfo::InitWorkId
//
//  Synopsis:   Initializes the workid from the version number.
//
//  Arguments:  [storage] - Destination storage
//
//  Returns:    The WorkId generated for the property store stream
//
//  History:    3-28-97   srikants   Created
//
//  Notes:      When we add a property, we have to bump up the version # but
//              in case we are creating a backup, we should use the same
//              version #.
//
//----------------------------------------------------------------------------


WORKID CPropStoreInfo::InitWorkId(CiStorage & storage)
{
    _info.widStream = storage.CreateObjectId( CIndexId( _info.Version % (1 << 16), 0 ),
                                                  PStorage::eNonSparseIndex );

    return _info.widStream;
}

//+---------------------------------------------------------------------------
//
//  Member:     CPropStoreInfo::Add, public
//
//  Synopsis:   Add a new property to set of cached properties.
//
//  Arguments:  [pid]      -- Propid
//              [vt]       -- Datatype
//              [cbMaxLen] -- Soft-maximum length.  Used to compute default
//                            size of record.
//              [fCanBeModified]
//                         -- Indicates if the property can be modified once set.
//              [storage]  -- Storage object (for object creation).
//
//  Returns:    TRUE if a change was made to metadata
//
//  History:    27-Dec-95   KyleP       Created.
//              05-Jun-96   KyleP       Moved on-disk transaction to higher level
//              13-Nov-97   KrishnaN    Modifiable?
//              19-Dec-97   KrishnaN    Lean record support.
//
//----------------------------------------------------------------------------

BOOL CPropStoreInfo::Add( PROPID pid,
                          ULONG vt,
                          unsigned cbMaxLen,
                          BOOL fCanBeModified,
                          CiStorage & storage )
{
    //
    // Check for exact duplicate.
    //

    CPropDesc const * pdesc = GetDescription( pid );

    if ( 0 != pdesc )
    {
        if ( !pdesc->Modifiable() )
        {
            ciDebugOut(( DEB_ITRACE, "Pid 0x%x: Exists in cache and marked UNModifiable!\n",
                         pid ));
            return FALSE;
        }

        if ( vt == pdesc->Type() && cbMaxLen == pdesc->Size() )
        {
            ciDebugOut(( DEB_ITRACE, "Pid 0x%x: Type %d, Size %d already in cache.\n",
                         pid, vt, cbMaxLen ));
            return FALSE;
        }

        ciDebugOut(( DEB_ITRACE, "Pid 0x%x: Type (%d, %d), Size (%d, %d)\n",
                     pid, pdesc->Type(), vt, pdesc->Size(), cbMaxLen ));
    }
    else
        ciDebugOut(( DEB_ITRACE, "Can't find pid 0x%x in cache.\n", pid ));

    //
    // Compute size and position (ordinal) of property.
    //

    BOOL fFixed;

    switch ( vt )
    {
    case VT_I1:
    case VT_UI1:
        fFixed = TRUE;
        cbMaxLen = 1;
        break;

    case VT_I2:
    case VT_UI2:
    case VT_BOOL:
        fFixed = TRUE;
        cbMaxLen = 2;
        break;

    case VT_I4:
    case VT_UI4:
    case VT_R4:
    case VT_ERROR:
        fFixed = TRUE;
        cbMaxLen = 4;
        break;

    case VT_I8:
    case VT_UI8:
    case VT_R8:
    case VT_CY:
    case VT_DATE:
    case VT_FILETIME:
        fFixed = TRUE;
        cbMaxLen = 8;
        break;

    case VT_CLSID:
        fFixed = TRUE;
        cbMaxLen = sizeof(GUID);
        break;

    default:
        fFixed = FALSE;
        break;
    }

    // Ensure we don't exceed the max possible size of a single record.
    // The trick to the check is the assumption that the maximum impact
    // on the size of the record is the size of the largest fixed prop.
    // Currently it is sizeof(GUID), so we just check that there is
    // enough space for it. And if there is, we are fine!
    // Fix for bug 119508.

    // If this assert doesn't hold, then change it to whatever size is the
    // maximum fixed size and change the (_info.culFixed*4 + sizeof(GUID))
    // portion of the following if statement to reflect that!
    Win4Assert(!fFixed || (fFixed && cbMaxLen <= sizeof(GUID)));

    if ((_info.culFixed*4 + sizeof(GUID)) >= COMMON_PAGE_SIZE)
    {
        ciDebugOut(( DEB_ITRACE, "Total fixed size (in bytes) %d exceeds"
                                 " max record size of %d\n",
                     _info.culFixed*4 + cbMaxLen, COMMON_PAGE_SIZE ));
        return FALSE;
    }

    BOOL fDidDeletion = Delete( pid, storage );

    //
    // Hash table size will have to change if:
    //   a) pid > MAX_DIRECT and we're in direct hash mode, or
    //   b) hash table is over 3/4 full, or
    //

    if ( (pid > MAX_DIRECT && _info.cHash == MAX_DIRECT) ||
        // (hdr.GetCount(hdr.GetPrimary()) * 3 + 1 > _info.cHash * sizeof(ULONG)) )
         (_info.cTotal * sizeof(ULONG) + 1 > _info.cHash * 3) )
    {
        XArray<CPropDesc> xold( _aProp );

        _info.cHash *= 2;
        if ( 0 == _info.cHash )
            _info.cHash = MAX_DIRECT;

        ciDebugOut(( DEB_PROPSTORE, "growing _aProp size from %d to %d\n",
                     xold.Count(), _info.cHash ));

        _aProp.Init( _info.cHash );

        for ( unsigned i = 0; i < xold.Count(); i++ )
        {
            if ( !xold[i].IsFree() )
            {
                ciDebugOut(( DEB_PROPSTORE,
                             "re-adding pid %d from [%d] to [%d]\n",
                             i,
                             LookupNew(xold[i].Pid()) ));
                _aProp[LookupNew(xold[i].Pid())] = xold[i];
            }
        }
    }

    //
    // Ordinal and starting offset are computed differently for fixed and
    // variable properties.  A new fixed property goes at the end of the
    // fixed section, and a new variable property goes at the end.
    //

    DWORD oStart;
    DWORD ordinal;

    if ( fFixed )
    {
        ordinal = _info.cFixed;
        oStart = _info.culFixed;
        _info.cFixed++;
        _info.culFixed += (cbMaxLen - 1) / sizeof(ULONG) + 1;

        //
        // Since we just added an ordinal in the middle, we now need to go through and
        // find the first variable length property and move it to the end.
        //

        for ( unsigned i = 0; i < _aProp.Count(); i++ )
        {
            if ( !_aProp[i].IsFree() && _aProp[i].Ordinal() == ordinal )
            {
                #if DBG == 1 || CIDBG == 1
                    ULONG ordinal2 = _aProp[i].Ordinal();
                #endif
                _aProp[i].SetOrdinal( _info.cTotal );

                ciDebugOut(( DEB_PROPSTORE,
                             "PROPSTORE: pid = 0x%x moved from ordinal = %u to ordinal %u\n",
                             _aProp[i].Pid(),
                             ordinal2,
                             _aProp[i].Ordinal() ));
                break;
            }
        }
    }
    else
    {
        ordinal = _info.cTotal;
        oStart = 0xFFFFFFFF;
    }

    //
    // Add new record to in-memory and on-disk structures.
    //

    ciDebugOut(( DEB_PROPSTORE,
                 "PROPSTORE: pid = 0x%x added at _aProp[%d], vt: 0x%x, old pid: 0x%x\n",
                 pid,
                 LookupNew(pid),
                 vt,
                 _aProp[LookupNew(pid)].Pid() ));
    _aProp[LookupNew(pid)].Init( pid,        // Propid
                                 vt,         // Data type
                                 oStart,     // Starting offset
                                 cbMaxLen,   // Length estimate
                                 ordinal,    // Ordinal (position) of property
                                 0,          // Record number (filled in later)
                                 fCanBeModified);   // Can this metadata be modified later?

    _info.cTotal++;

    //
    // Adjust size. We preallocated _aul[PREV], _aul[NEXT] and _aul[FREEBLOCKSIZE] to serve as
    // free list ptrs. So we should avoid allocating these ULONGs again. Watch the
    // allocation of dword for existence bits and space for first property. Since
    // all properties are allocated on sizeof(ULONG)-byte boundaries, we can monitor the allocation
    // of space for the first property and be sure that aul[1]'s preallocation gets
    // accounted for.
    //
    // The first time a property is added, it will cause a _aul[PREV] to be allocated
    // for existence bits. Since we preallocated that, we won't increase the
    // record length for the first set of 16 existence bits.

    if ( _info.cTotal > 1 && (_info.cTotal % 16) == 1 )
        _info.culRecord += 1;                 // New dword of existence bits

    _info.culRecord += (cbMaxLen-1) / sizeof(ULONG) + 1;  // The property itself
    // account for the preallocation of _aul[NEXT] (when space for first prop is allocated)
    // and _aul[FREEBLOCKSIZE] (when space for second prop is allocated). If we only have one prop allocated,
    // we will run with an overhead of 1 DWORD, but we know that we have many more than 2 properties!
    if ( _info.cTotal <= 2 )
        _info.culRecord -= 1;

    if ( !fFixed )
        _info.culRecord += 1;                 // Variable size dword

    _cRecPerPage = COMMON_PAGE_SIZE / (_info.culRecord * sizeof(ULONG));

    ciDebugOut(( DEB_PROPSTORE, "New record size: %d bytes.  %d records per %dK page\n",
                 _info.culRecord * sizeof(ULONG),
                 _cRecPerPage,
                 COMMON_PAGE_SIZE / 1024 ));

    Win4Assert( _cRecPerPage > 0 );

    if ( _cRecPerPage == 0 )
    {
        ciDebugOut(( DEB_ERROR, "Record size > %u bytes!\n", COMMON_PAGE_SIZE ));
        THROW( CException( STATUS_INVALID_PARAMETER ) );
    }

    #if CIDBG == 1
        for ( unsigned i = 0; i < _aProp.Count(); i++ )
        {
            ciDebugOut(( DEB_PROPSTORE, "_aProp[%d].pid: 0x%x\n",
                         i, _aProp[i].Pid() ));
        }
    #endif // CIDBG == 1


    return TRUE;
}

//+---------------------------------------------------------------------------
//
//  Member:     CPropStoreInfo::DetectFormat, public
//
//  Synopsis:   Detect the type of records to be used and change according to that.
//
//  History:    31-Dec-97   KrishnaN       Created.
//
//----------------------------------------------------------------------------

void CPropStoreInfo::DetectFormat()
{
    // In CPropStoreInfo::Init() we initialized record length based on the
    // assumption that primary is lean and secondary is normal. That could have
    // changed, so account for that.
    LONG lOldOverhead = (eLean == GetRecordFormat()) ?
                               COnDiskPropertyRecord::FixedOverheadLean() :
                               COnDiskPropertyRecord::FixedOverheadNormal();

    // Determine the format of the records in the target property store.
    SetRecordFormat( CountFixedProps() == CountProps() ? eLean : eNormal);
    LONG lNewOverhead = (eLean == GetRecordFormat()) ?
                               COnDiskPropertyRecord::FixedOverheadLean() :
                               COnDiskPropertyRecord::FixedOverheadNormal();
    // Adjust the overhead
    _info.culRecord += (lNewOverhead - lOldOverhead);

    _cRecPerPage = COMMON_PAGE_SIZE / (_info.culRecord * sizeof(ULONG));

    ciDebugOut(( DEB_PROPSTORE, "Incorporated props from registry. "
                 "New record size: %d bytes.  %d records per %dK page\n",
                 _info.culRecord * sizeof(ULONG),
                 _cRecPerPage,
                 COMMON_PAGE_SIZE / 1024 ));
}

//+---------------------------------------------------------------------------
//
//  Member:     CPropStoreInfo::Delete, public
//
//  Synopsis:   Deletes a property from set of cached properties.
//
//  Arguments:  [pid]      -- Propid
//              [storage]  -- Storage object (for object creation).
//
//  Returns:    TRUE if a change was made to metadata
//
//  History:    27-Dec-95   KyleP       Created.
//              05-Jun-96   KyleP       Moved on-disk transaction to higher level
//
//----------------------------------------------------------------------------

BOOL CPropStoreInfo::Delete( PROPID pid, CiStorage & storage )
{
    //
    // Is there anything to get rid of?
    //

    CPropDesc const * pdesc = GetDescription( pid );

    if ( 0 == pdesc )
        return FALSE;

    if (!pdesc->Modifiable())
    {
        ciDebugOut(( DEB_ITRACE, "Pid 0x%x: Cannot be deleted. Marked UNModifiable!\n",
                     pid ));
        return FALSE;
    }

    if ( pdesc->IsFixedSize() )
    {
        _info.cFixed--;
        _info.culFixed -= (pdesc->Size() - 1) / sizeof(ULONG) + 1;
    }

    for ( unsigned i = 0; i < _aProp.Count(); i++ )
    {
        if ( _aProp[i].Pid() != pidInvalid && _aProp[i].Ordinal() > pdesc->Ordinal() )
        {
            if ( pdesc->IsFixedSize() && _aProp[i].IsFixedSize() )
                _aProp[i].SetOffset( _aProp[i].Offset() - ((pdesc->Size() - 1) / sizeof(ULONG) + 1) );

            _aProp[i].SetOrdinal( _aProp[i].Ordinal() - 1 );
        }
    }

    //
    // Global bookeeping
    //

    _info.cTotal--;

    //
    // Adjust size
    //

    _info.culRecord -= (pdesc->Size()-1) / sizeof(ULONG) + 1;  // The property itself

    if ( !pdesc->IsFixedSize() )
        _info.culRecord -= 1;                      // Variable size dword

    if ( ((_info.cTotal) % 16) == 0 )
        _info.culRecord -= 1;                      // New dword of existence bits

    _cRecPerPage = COMMON_PAGE_SIZE / (_info.culRecord * sizeof(ULONG));

    ciDebugOut(( DEB_PROPSTORE, "New record size: %d bytes.  %d records per %dK page\n",
                 _info.culRecord * sizeof(ULONG),
                 _cRecPerPage,
                 COMMON_PAGE_SIZE / 1024 ));

    Win4Assert( _cRecPerPage > 0 );

    if ( _cRecPerPage == 0 )
    {
        ciDebugOut(( DEB_ERROR, "Record size > %u bytes!\n", COMMON_PAGE_SIZE ));
        THROW( CException( STATUS_INVALID_PARAMETER ) );
    }

    // Ensure that we have space for _aul[PREV], _aul[NEXT], and _aul[FREEBLOCKSIZE] We will have that as
    // long as we have at least two properties.

    ULONG ulOverhead = (eLean == GetRecordFormat()) ?
                          COnDiskPropertyRecord::FixedOverheadLean() :
                          COnDiskPropertyRecord::FixedOverheadNormal();

    if ( _info.culRecord < ulOverhead )
    {
        // As long as we have 2 or more properties, we wouldn't go under the
        // fixed overhead. Assert that!
        Win4Assert(_info.cTotal <= 1);
        _info.culRecord = ulOverhead;
    }

    //
    // Free record.
    //

    _aProp[Lookup(pid)].Free();

    return TRUE;
}

//+---------------------------------------------------------------------------
//
//  Member:     CPropStoreInfo::ChangeDirty, public
//
//  Synopsis:   Persistently change state of dirty bitfield
//
//  Arguments:  [fDirty] -- New state for dirty bitfield.
//
//  History:    16-Jan-96   KyleP       Created.
//
//----------------------------------------------------------------------------

void CPropStoreInfo::ChangeDirty( int fDirty )
{
    // In some error cases this can be null.

    if ( _xrsoPropStore.IsNull() )
        return;

    _info.fDirty = fDirty;

    //
    // Atomically write dirty bit.
    //

    CRcovStorageHdr & hdr = _xrsoPropStore->GetHeader();
    CRcovStrmWriteTrans xact( _xrsoPropStore.GetReference() );

    struct CRcovUserHdr data;
    RtlCopyMemory( &data._abHdr, &_info, sizeof(_info) );

    hdr.SetCount(hdr.GetBackup(), hdr.GetCount(hdr.GetPrimary()) );
    hdr.SetUserHdr( hdr.GetBackup(), data );

    xact.Commit();
}

//+---------------------------------------------------------------------------
//
//  Member:     CPropStoreInfo::Lookup, public
//
//  Synopsis:   Looks up pid in hash table.
//
//  Arguments:  [pid]      -- Propid
//
//  Returns:    Index into hash table (_aProp) of pid, or first unused
//              entry on chain if pid doesn't exist.
//
//  History:    27-Dec-95   KyleP       Created.
//
//----------------------------------------------------------------------------

unsigned CPropStoreInfo::Lookup( PROPID pid )
{
    unsigned hash = pid % _info.cHash;

    // short-path for common case

    if ( pid == _aProp[hash].Pid() && _aProp[hash].IsInUse() )
        return hash;

    unsigned start = hash;
    unsigned probe = hash;

    while ( pid != _aProp[hash].Pid() && _aProp[hash].IsInUse() )
    {
        //ciDebugOut(( DEB_ERROR, "Hash: %u, Probe: %u, pid 0x%x != table 0x%x\n",
        //             hash, probe, pid, _aProp[hash].Pid() ));

        hash = (hash + probe) % _info.cHash;

        if ( start == hash )
        {
            Win4Assert( probe != 1 );
            probe = 1;
            hash = (hash + probe) % _info.cHash;
        }
    }

    return hash;
}

//+---------------------------------------------------------------------------
//
//  Member:     CPropStoreInfo::LookupNew, public
//
//  Synopsis:   Looks up pid in hash table, treats nulled entries as empty.
//
//  Arguments:  [pid]      -- Propid
//
//  Returns:    Index into hash table (_aProp) of pid, or first unused
//              entry on chain if pid doesn't exist.
//
//  History:    27-Dec-95   KyleP       Created.
//
//----------------------------------------------------------------------------

unsigned CPropStoreInfo::LookupNew( PROPID pid )
{
    unsigned hash = pid % _info.cHash;
    unsigned start = hash;
    unsigned probe = hash;

    while ( pid != _aProp[hash].Pid() && !_aProp[hash].IsFree() )
    {
        hash = (hash + probe) % _info.cHash;

        if ( start == hash )
        {
            Win4Assert( probe != 1 );
            probe = 1;
            hash = (hash + probe) % _info.cHash;
        }
    }

    return hash;
}

void CPhysPropertyStore::ReOpenStream()
{
    Win4Assert( _stream.IsNull() );
    Win4Assert( !"Don't call CPhysPropertyStore::ReOpenStream" );
    //_stream = _storage.QueryExistingPropStream ( _obj, PStorage::eOpenForWrite );
}

//+---------------------------------------------------------------------------
//
//  Member:     CPropertyStore::CPropertyStore, public
//
//  Synopsis:   Required for C++ EH.
//
//  History:    27-Dec-95   KyleP       Created.
//
//----------------------------------------------------------------------------

CPropertyStore::CPropertyStore(CPropStoreManager& propStoreMgr, DWORD dwStoreLevel)
        : _pStorage( 0 ),
          _aFreeBlocks( 0 ),
          _fAbort(FALSE),
          _fIsConsistent(TRUE),
          _ppsNew( 0 ),
          _fNew( FALSE ),
          _ulBackupSizeInPages( CI_PROPERTY_STORE_BACKUP_SIZE_DEFAULT ),
          _ulPSMappedCache( CI_PROPERTY_STORE_MAPPED_CACHE_DEFAULT ),
          _PropStoreInfo( dwStoreLevel ),
          _propStoreMgr( propStoreMgr ),
          _dwStoreLevel( dwStoreLevel )
{
    #if CIDBG == 1
        _sigPSDebug = 0x2047554245445350i64;  // PSDEBUG
        _tidReadSet = _tidReadReset = _tidWriteSet = _tidWriteReset = 0xFFFFFFFF;

        _xPerThreadReadCounts.Init( cTrackThreads );
        _xPerThreadWriteCounts.Init( cTrackThreads );

        RtlZeroMemory( _xPerThreadReadCounts.GetPointer(), 
                       cTrackThreads * sizeof(_xPerThreadReadCounts[0]) );
        RtlZeroMemory( _xPerThreadWriteCounts.GetPointer(), 
                       cTrackThreads * sizeof(_xPerThreadWriteCounts[0]) );
    #endif

    Win4Assert(PRIMARY_STORE == dwStoreLevel || SECONDARY_STORE == dwStoreLevel);

    #if CIDBG == 1

    // Allocate an array to track what records are currently locked.
    // To be used to acquire all write locks.
    _pbRecordLockTracker = new BYTE[LockMgr().UniqueRecordCount()];
    RtlZeroMemory(_pbRecordLockTracker, sizeof(BYTE)*LockMgr().UniqueRecordCount());

    #endif // CIDBG
}

//+---------------------------------------------------------------------------
//
//  Member:     CPropertyStore::~CPropertyStore, public
//
//  Synopsis:   Closes/flushes property cache.
//
//  History:    27-Dec-95   KyleP       Created.
//
//----------------------------------------------------------------------------

CPropertyStore::~CPropertyStore()
{
    delete _ppsNew;
    delete _aFreeBlocks;

    #if CIDBG == 1
        delete [] _pbRecordLockTracker;
    #endif
}


//+---------------------------------------------------------------------------
//
//  Member:     CPropertyStore::Empty
//
//  Synopsis:   Empties out the intitialized members and prepares for a
//              re-init.
//
//  History:    3-18-96   srikants   Created
//
//----------------------------------------------------------------------------

void CPropertyStore::Empty()
{
    _PropStoreInfo.Empty();
    delete _xPhysStore.Acquire();

    _pStorage = 0;
}

//+---------------------------------------------------------------------------
//
//  Member:     CPropertyStore::FastInit, public
//
//  Synopsis:   Initialize property store (two-phase construction)
//
//  Arguments:  [pStorage] -- Storage object.
//
//  History:    27-Dec-95   KyleP       Created.
//              06-Mar-96   SrikantS    Split into FastInit and LongInit
//              23-Feb-98   KitmanH     Code added to deal with read-only
//                                      catalogs
//
//----------------------------------------------------------------------------

void CPropertyStore::FastInit( CiStorage * pStorage)
{
    Win4Assert( 0 != _ulPSMappedCache );

    _pStorage = pStorage;
    XPtr<PRcovStorageObj> xObj( _pStorage->QueryPropStore( 0, _dwStoreLevel ) );
    _PropStoreInfo.Init( xObj, _dwStoreLevel );

    Win4Assert(GetStoreLevel() == _dwStoreLevel);

    WORKID wid = _PropStoreInfo.WorkId();

    if ( widInvalid != wid )
    {
        SStorageObject xobj( _pStorage->QueryObject( wid ) );


        PStorage::EOpenMode mode = _pStorage->IsReadOnly() ? PStorage::eOpenForRead : PStorage::eOpenForWrite;

        XPtr<PMmStream> xmmstrm ( _pStorage->QueryExistingPropStream( xobj.GetObj(),
                                                                      mode,
                                                                      GetStoreLevel() ));

        Win4Assert( !xmmstrm.IsNull() );

        if ( !xmmstrm->Ok() )
        {
            ciDebugOut(( DEB_ERROR, "Open of index %08x failed\n", wid ));

            NTSTATUS status = xmmstrm->GetStatus();
            
            if ( STATUS_DISK_FULL == status || 
                 HRESULT_FROM_WIN32(ERROR_DISK_FULL) == status || 
                 STATUS_INSUFFICIENT_RESOURCES == status ||
                 CI_E_CONFIG_DISK_FULL == status )
            {
                 CEventLog eventLog( NULL, wcsCiEventSource );
                 CEventItem item( EVENTLOG_WARNING_TYPE,
                                  CI_SERVICE_CATEGORY,
                                  MSG_CI_LOW_DISK_SPACE,
                                  2 );

                 item.AddArg( _pStorage->GetVolumeName() );
                 item.AddArg( lowDiskWaterMark );
                 eventLog.ReportEvent( item );
                 THROW( CException( CI_E_CONFIG_DISK_FULL ) );
            }
            else if ( xmmstrm->FStatusFileNotFound() )
            {
                //
                // We don't have code to handle such failures, hence mark
                // catalog as corrupt; otherwise throw e_fail
                //
     
                ciDebugOut(( DEB_ERROR, "Stream %08x not found\n", wid ));
                Win4Assert( !"Stream not found\n" );
                _pStorage->ReportCorruptComponent( L"PhysStorage2" );
                THROW( CException( CI_CORRUPT_DATABASE ));
            }

            __int64 sizeRemaining, sizeTotal;
            _pStorage->GetDiskSpace ( sizeTotal, sizeRemaining );

            if ( sizeRemaining < lowDiskWaterMark )
            {
                CEventLog eventLog( NULL, wcsCiEventSource );
                CEventItem item( EVENTLOG_WARNING_TYPE,
                                 CI_SERVICE_CATEGORY,
                                 MSG_CI_LOW_DISK_SPACE,
                                 2 );

                item.AddArg( _pStorage->GetVolumeName() );
                item.AddArg( lowDiskWaterMark );
                eventLog.ReportEvent( item );
                THROW( CException( CI_E_CONFIG_DISK_FULL ) );
            }
            else
                THROW( CException( status ));
                
        }

        //
        // mmstrm ownership is transferred regardless of whether the
        // constructor succeeds.
        //

        _xPhysStore.Set( new CPhysPropertyStore( *_pStorage,
                                                  xobj.GetObj(),
                                                  wid,
                                                  xmmstrm.Acquire(),
                                                  mode,
                                                  _ulPSMappedCache ) );

        // grow the file 2 meg at a time

        _xPhysStore->SetPageGrowth( 32 * COMMON_PAGE_SIZE / CI_PAGE_SIZE );
    }
}


//+---------------------------------------------------------------------------
//
//  Member:     CPropertyStore::LongInit
//
//  Synopsis:   If the propstore was dirty when shut down, run the recovery
//              operation.
//
//  Arguments:  [fWasDirty]        -- dirty flag is returned here
//              [cInconsistencies] -- returns number of inconsistencies found
//              [pfnUpdateCallback]-- Callback to be called to update docs during
//                                    recovery. the prop store has no knowledge of
//                                    doc store, so this callback is needed.
//              [pUserData]        -- will be echoed back through callback.
//
//  Returns:
//
//  History:    3-06-96   srikants   Created
//
//  Notes:      The propstore is locked for write during recovery, but
//              reads are still permitted.
//
//----------------------------------------------------------------------------

void CPropertyStore::LongInit( BOOL & fWasDirty, ULONG & cInconsistencies,
                               T_UpdateDoc pfnUpdateCallback, void const *pUserData )
{
    //
    // Close the existing prop store backup stream
    //

    _xPSBkpStrm.Free();

    //
    // Recover from dirty shutdown.
    //
    if ( _PropStoreInfo.IsDirty() )
    {
        ciDebugOut(( DEB_WARN, "Property store shut down dirty.  Restoring...\n" ));
        fWasDirty = TRUE;
        CPropertyStoreRecovery  recover(*this, pfnUpdateCallback, pUserData);

        recover.DoRecovery();
        cInconsistencies = recover.GetInconsistencyCount();
    }
    else
    {
        fWasDirty = FALSE;
        cInconsistencies = 0;
        InitFreeList();
    }

    WORKID wid = _PropStoreInfo.WorkId();
    Win4Assert( widInvalid != wid );
    SStorageObject xobj( _pStorage->QueryObject( wid ) );

    //
    // At this point we have no use for any existing property store backup file.
    // Create a new backup file so it will be initialized correctly based on the
    // volume's sector size and architecture's page size and user specified number
    // of pages to be backed up.
    //

    _xPSBkpStrm.Set(_pStorage->QueryNewPSBkpStream( xobj.GetObj(),
                    _ulBackupSizeInPages, GetStoreLevel() ));
}


//+---------------------------------------------------------------------------
//
//  Member:     CPropertyStore::BeginTransaction, public
//
//  Synopsis:   Begins a schema transaction. Any existing transaction will be
//              aborted.
//
//  Returns:    Token representing transaction.
//
//  History:    27-Dec-95   KyleP       Created.
//
//----------------------------------------------------------------------------

ULONG_PTR CPropertyStore::BeginTransaction()
{
    //
    // Do we already have pending changes?
    //

    if ( 0 != _ppsNew )
        EndTransaction( (ULONG_PTR)_ppsNew, FALSE, pidSecurity );

    _fNew = FALSE;
    _ppsNew = new CPropertyStore( *this, _pStorage );

    return (ULONG_PTR)_ppsNew;
}

//+---------------------------------------------------------------------------
//
//  Member:     CPropertyStore::Setup, public
//
//  Synopsis:   Setup a property description.  Property may already exist
//              in the cache.
//
//  Arguments:  [pid]        -- Propid
//              [vt]         -- Datatype of property.  VT_VARIANT if unknown.
//              [cbMaxLen]   -- Soft-maximum length for variable length
//                              properties.  This much space is pre-allocated
//                              in original record.
//              [ulToken]    -- Token of transaction
//              [fCanBeModified] - Can the prop meta info be modified once set?
//
//  Returns:    TRUE if meta info has changed. FALSE otherwise.
//
//  History:    27-Dec-95   KyleP       Created.
//
//----------------------------------------------------------------------------

void CPropertyStore::Setup( PROPID pid,
                            ULONG vt,
                            DWORD cbMaxLen,
                            ULONG_PTR ulToken,
                            BOOL fCanBeModified )
{
    if ( ulToken != (ULONG_PTR)_ppsNew )
    {
        ciDebugOut(( DEB_ERROR, "Transaction mismatch: 0x%x vs. 0x%x\n", ulToken, _ppsNew ));
        THROW( CException( STATUS_TRANSACTION_NO_MATCH ) );
    }

    TRY
    {
        //
        // Make the change.  NOTE: "|| _fNew" must be after call, or Add/Delete may not be called.
        //

        if ( 0 == cbMaxLen )
            _fNew = _ppsNew->_PropStoreInfo.Delete( pid, *_pStorage ) || _fNew;
        else
            _fNew = _ppsNew->_PropStoreInfo.Add( pid, vt, cbMaxLen, fCanBeModified, *_pStorage ) || _fNew;
    }
    CATCH( CException, e )
    {
        ciDebugOut(( DEB_ERROR, "Error 0x%X while setting up property 0x%X\n",
                                e.GetErrorCode(), pid ));

        delete _ppsNew;
        _ppsNew = 0;
        _fNew = FALSE;

        RETHROW();
    }
    END_CATCH
}

//+---------------------------------------------------------------------------
//
//  Member:     CPropertyStore::EndTransaction, public
//
//  Synopsis:   End property transaction, and maybe commit changes.
//
//  Arguments:  [ulToken] -- Token of transaction
//              [fCommit] -- TRUE --> Commit transaction
//              [pidFixed] -- Every workid with this pid will move to the
//                            same workid in the new property cache.
//                            Usually pidPath.
//
//  History:    27-Dec-95   KyleP       Created.
//
//----------------------------------------------------------------------------

void CPropertyStore::EndTransaction( ULONG_PTR ulToken, BOOL fCommit, PROPID pidFixed )
{
    if ( ulToken != (ULONG_PTR)_ppsNew )
    {
        ciDebugOut(( DEB_ERROR,
                     "PropertyStore: Transaction mismatch: 0x%x vs. 0x%x\n",
                     ulToken, _ppsNew ));
        THROW( CException( STATUS_TRANSACTION_NO_MATCH ) );
    }

    //
    // Squirrel away previous store.
    //

    WORKID widOld = _PropStoreInfo.WorkId();
    WORKID widNew = widInvalid;

    TRY
    {
        if ( fCommit && _fNew )
        {
            ciDebugOut(( DEB_ITRACE, "Committing changes to property metadata.\n" ));

            CRcovStrmWriteTrans xact( *_PropStoreInfo.GetRcovObj() );

            _ppsNew->_PropStoreInfo.DetectFormat();
            _ppsNew->CreateStorage( widInvalid ); // use next workid
            _ppsNew->InitFreeList();

            widNew = _ppsNew->_PropStoreInfo.WorkId();

            // Transfer existing data to new.

            BOOL fAbort = FALSE;
            if ( widOld != widInvalid )
                Transfer( *_ppsNew, pidFixed, fAbort );

            //
            // Prevent any readers from coming in until we commit the transaction.
            // Lock down the source so no readers will be able to read and no writers
            // will be able to write.
            //

            CWriteAccess writeLock( _rwAccess );
            CLockAllRecordsForWrite lockAll(*this);

            _PropStoreInfo.Commit( _ppsNew->_PropStoreInfo, xact );

            //
            // Transfer the property store information from the new to current
            //

            delete _xPhysStore.Acquire();
            _xPhysStore.Set( _ppsNew->_xPhysStore.Acquire() );

            delete _aFreeBlocks;
            _aFreeBlocks = _ppsNew->_aFreeBlocks;
            _ppsNew->_aFreeBlocks = 0;

            _PropStoreInfo.MarkClean();
        }
        else
            ciDebugOut(( DEB_ITRACE, "No changes to property metadata.  Rolling back transaction.\n" ));

        delete _ppsNew;
        _ppsNew = 0;
        _fNew = FALSE;
    }
    CATCH( CException, e )
    {
        ciDebugOut(( DEB_ERROR, "Error 0x%X while commiting transaction.\n", e.GetErrorCode() ));

        delete _ppsNew;
        _ppsNew = 0;

        _fNew = FALSE;

        //
        // Delete the newly created property store from disk
        //

        if ( widInvalid != widNew )
            _pStorage->DeleteObject( widNew );

        RETHROW();
    }
    END_CATCH

    if ( widOld != widInvalid )
        _pStorage->DeleteObject( widOld );
}


//+---------------------------------------------------------------------------
//
//  Member:     CPropertyStore::MakeBackupCopy
//
//  Synopsis:   Makes a backup copy of the property storage. It makes a
//              full copy if the pIEnumWorkids is NULL. Otherwise, it makes
//              a copy of only the changed workids.
//
//  Arguments:  [pIProgressEnum] - Progress indication
//              [pfAbort]        - Caller initiated abort flag
//              [dstStorage]     - Destination storage to use
//              [pIEnumWorkids]  - List of workids to copy. If null, all the
//              workids are copied.
//              [pidFixed]       - Which is the fixed pid ?
//              [ppFileList]     - List of propstore files copied.
//
//  History:    3-26-97   srikants   Created
//
//  Notes:      Incremental not implemented yet
//
//----------------------------------------------------------------------------

void CPropertyStore::MakeBackupCopy( IProgressNotify * pIProgressEnum,
                                     BOOL & fAbort,
                                     CiStorage & dstStorage,
                                     ICiEnumWorkids * pIEnumWorkids,
                                     IEnumString **ppFileList )
{
    #if CIDBG == 1

    if (pIEnumWorkids)
    {
        Win4Assert(!"For secondary level store, are you translating wids? Look in CPropStoreManager::MakeBackupCopy.");
    }

    #endif // CIDBG

    //
    // Create a backup copy of the property store.
    //

    //
    // For a FULL backup, it is possible to just make a copy of the streams
    // but if there are any problems with the data in this property store, they
    // will get carried over. Also, doing a "Transfer" may defrag the target
    // property store.
    //

    //
    // Delete any existing PropertyStore meta data info.
    //
    dstStorage.RemovePropStore(0, GetStoreLevel());


    TRY
    {
        //
        // Make a backup copy of the PropStoreInfo.
        //

        XPtr<PRcovStorageObj> xObj( dstStorage.QueryPropStore( 0, GetStoreLevel() ) );
        CCopyRcovObject copyRcov( xObj.GetReference(), *_PropStoreInfo.GetRcovObj() );
        copyRcov.DoIt();

        XPtr<CPropertyStore> xPropStore( new CPropertyStore( *this, &dstStorage ) );
        xPropStore->_PropStoreInfo.InitWorkId( dstStorage );

        xPropStore->CreateStorage( _PropStoreInfo.WorkId() ); // use same workid
        xPropStore->InitFreeList();
        xPropStore->_PropStoreInfo.Accept( xObj );

        FastTransfer( xPropStore.GetReference(), fAbort, pIProgressEnum );
        xPropStore->_PropStoreInfo.FastTransfer( _PropStoreInfo );

        //
        // return a list of file names only on demand
        //

        _propStoreMgr.Flush();

        if (0 != ppFileList)
        {
            Win4Assert( 0 != _pStorage );

            CEnumString * pEnumString = new CEnumString();
            XInterface<IEnumString> xEnumStr(pEnumString);

            dstStorage.ListPropStoreFileNames( *pEnumString,
                                              _PropStoreInfo.WorkId(),
                                              GetStoreLevel() );
            *ppFileList = xEnumStr.Acquire();
        }

    }
    CATCH( CException, e )
    {
        dstStorage.RemovePropStore(0, GetStoreLevel());
        dstStorage.DeleteObject( _PropStoreInfo.WorkId() );

        RETHROW();
    }
    END_CATCH

}

//+---------------------------------------------------------------------------
//
//  Member:     CPropertyStore::WriteProperty, public
//
//  Synopsis:   Write a property to the cache.
//
//  Arguments:  [PropRecord] -- Previously opened property record.
//              [pid] -- Propid
//              [var] -- Value
//              [fBackup] -- Backup?
//
//  Returns:    S_OK if everything went well.
//              S_FALSE if specified pid is not in store.
//              Error code if an error occurred.
//
//  History:    27-Dec-95   KyleP       Created.
//              30-Dec-97   KrishnaN    Improved error handling/reporting.
//              27-Jan-2000 KLam        Extended assert to handle out of
//                                      memory condition.
//
//----------------------------------------------------------------------------

SCODE CPropertyStore::WriteProperty( CPropRecordForWrites &PropRecord,
                                     PROPID pid,
                                     CStorageVariant const & var,
                                     BOOL fBackup)
{
    Win4Assert( sizeof(CPropRecordForWrites) <= sizeof_CPropRecord );

    WORKID wid = PropRecord._wid;
    ciDebugOut(( DEB_PROPSTORE, "WRITE: wid = 0x%x, pid = 0x%x, type = %d\n", wid, pid, var.Type() ));

    CPropDesc const * pdesc = _PropStoreInfo.GetDescription( pid );

    if ( 0 != pdesc )
    {
        COnDiskPropertyRecord * prec = PropRecord._prec;

        // If CPropRecord was passed in widInvalid, prec would be 0. So Write should fail!
        if (0 == prec)
            return E_INVALIDARG;

        if ( !prec->IsTopLevel() )
        {
            ciDebugOut(( DEB_IWARN, "Trying to write to non-toplevel wid 0x%X\n",
                         wid ));
            return E_INVALIDARG;
        }

        SCODE sc = S_OK;

        TRY
        {
            if (fBackup)
            {
                CBackupWid backupTopLevel(this, wid, prec->CountRecords());
                _PropStoreInfo.MarkDirty();
            }

            _PropStoreInfo.MarkDirty();

            if ( pdesc->IsFixedSize() )
            {
                #if CIDBG == 1
                    if ( ( pidSize == pid ) &&
                         ( VT_I8 == var.vt ) )
                        Win4Assert( 0xdddddddddddddddd != var.hVal.QuadPart );

                    if ( ( pidAttrib == pid ) &&
                         ( VT_UI4 == var.vt ) )
                        Win4Assert( 0xdddddddd != var.ulVal );
                #endif // CIDBG == 1

                prec->WriteFixed( pdesc->Ordinal(),
                                  pdesc->Mask(),
                                  pdesc->Offset(),
                                  pdesc->Type(),
                                  _PropStoreInfo.CountProps(),
                                  var );
            }
            else
            {
                Win4Assert(!prec->IsLeanRecord());
                Win4Assert( 0 != _pStorage );

                BOOL fOk = prec->WriteVariable( pdesc->Ordinal(),
                                                pdesc->Mask(),
                                                _PropStoreInfo.FixedRecordSize(),
                                                _PropStoreInfo.CountProps(),
                                                _PropStoreInfo.CountFixedProps(),
                                                _PropStoreInfo.RecordSize(),
                                                var,
                                                *_pStorage );
                //
                // Did we fit?
                //
                CBorrowed BorrowedOverflow( _xPhysStore.GetReference(),
                                            _PropStoreInfo.RecordsPerPage(),
                                            _PropStoreInfo.RecordSize() );

                while ( !fOk )
                {
                    //
                    // Check for existing overflow block.
                    //

                    WORKID widOverflow = prec->OverflowBlock();
                    BOOL fNewBlock = FALSE;
                    ULONG cWid = 1;

                    //
                    // Need new overflow block.
                    //

                    if ( 0 == widOverflow )
                    {
                        Win4Assert(!prec->IsLeanRecord());

                        fNewBlock = TRUE;

                        cWid = COnDiskPropertyRecord::CountNormalRecordsToStore(
                                _PropStoreInfo.CountProps() - _PropStoreInfo.CountFixedProps(),
                                _PropStoreInfo.RecordSize(),
                                var );

                        // We cannot have a single record greater than COMMON_PAGE_SIZE.
                        // Throw if we get into that situation. Fix for bug 119508.

                        if (cWid > RecordsPerPage())
                            THROW(CException(CI_E_PROPERTY_TOOLARGE));

                        widOverflow = LokNewWorkId( cWid, FALSE, fBackup );
                        prec->SetOverflowBlock( widOverflow );
                        PropRecord._prec->IncrementOverflowChainLength();
                    }

                    BorrowedOverflow.Release();
                    BorrowedOverflow.Set( widOverflow );

                    prec = BorrowedOverflow.Get();

                    if ( fNewBlock )
                    {
    #                   if CIDBG == 1
                            if ( prec->HasProperties( _PropStoreInfo.CountProps() ) )
                            {
                                ciDebugOut(( DEB_ERROR, "New long record at %d, size = %d, p = 0x%x has stored properties!\n",
                                             widOverflow, cWid, prec ));
                            }
                            if ( !prec->IsNormalEmpty( _PropStoreInfo.RecordSize() ) )
                            {
                                ciDebugOut(( DEB_ERROR, "New long record at %d, size = %d, p = 0x%x is not empty!\n",
                                             widOverflow, cWid, prec ));
                            }

    //                        Win4Assert( !prec->HasProperties(_PropStoreInfo.CountProps()) &&
    //                                     prec->IsEmpty( _PropStoreInfo.RecordSize() ) );
    #                   endif // CIDBG == 1
                        ciDebugOut(( DEB_PROPSTORE, "New long record at %d, size = %d\n", widOverflow, cWid ));

                        prec->MakeLongRecord( cWid );
                        prec->SetOverflowBlock( 0 );
                        prec->SetToplevelBlock( wid );
                    }
                    else
                    {
                        //
                        // Every record in the chain gets backed up because of
                        // this. That is the way it should be because we are
                        // writing to every record in the chain as part of
                        // overflow handling. If there is not sufficient space
                        // in the overflow records, we will be creating a new
                        // record and chaining it to the last one in the
                        // existing chain. The backed up records will have no
                        // evidence of the link made to the new record and that
                        // is the way it should be.
                        //
                        if (fBackup)
                        {
                            CBackupWid backupOverflow(this, widOverflow, prec->CountRecords());
                            _PropStoreInfo.MarkDirty();
                        }

                        //
                        // NTRAID#DB-NTBUG9-84451-2000/07/31-dlee Indexing Service Property Store doesn't handle values in records that grow out of the record
                        // Consider the case where a property was *in* a long record.
                        // and then no longer fit in that long record...
                        //

                        Win4Assert( prec->ToplevelBlock() == wid );
                    }

                    ULONG Ordinal = pdesc->Ordinal() - _PropStoreInfo.CountFixedProps();
                    DWORD Mask = (1 << ((Ordinal % 16) * 2));

                    Win4Assert( 0 != _pStorage );


                    fOk = prec->WriteVariable( Ordinal,  // Ordinal (assuming 0 fixed)
                                               Mask,     // Mask (assuming 0 fixed)
                                               0,        // Fixed properties
                                               _PropStoreInfo.CountProps() - _PropStoreInfo.CountFixedProps(),
                                               0,        // Count of fixed properties
                                               _PropStoreInfo.RecordSize(),
                                               var,
                                               *_pStorage );

                    Win4Assert( fOk || !fNewBlock );     // Property *must* fit in a fresh block!
                }
            }

        #if CIDBG == 1
            // Assert that we have a dirty property store and that something
            // was written to the backup file (if fBackup is enabled)
            Win4Assert(_PropStoreInfo.IsDirty());
            if (fBackup)
            {
                Win4Assert(BackupStream()->Pages() > 0);
            }
        #endif // CIDBG
        }
        CATCH( CException, e )
        {
            sc = e.GetErrorCode();

            ciDebugOut(( DEB_ERROR, "Exception 0x%x caught writing pid %d in wid %d. prec = 0x%x\n",
                         sc, pid, wid, prec ));
        }
        END_CATCH

        return sc;
    }

    return S_FALSE;
} //WriteProperty

//+---------------------------------------------------------------------------
//
//  Member:     CPropertyStore::WriteProperty, public
//
//  Synopsis:   Write a property to the cache.
//
//  Arguments:  [wid] -- Workid
//              [pid] -- Propid
//              [var] -- Value
//              [fBackup] -- Backup?
//
//  Returns:    S_OK if everything went well.
//              S_FALSE if specified pid is not in store.
//              Error code if an error occurred.
//
//  History:    27-Dec-95   KyleP       Created.
//              30-Dec-97   KrishnaN    Improved error handling/reporting.
//
//----------------------------------------------------------------------------

SCODE CPropertyStore::WriteProperty( WORKID wid,
                                     PROPID pid,
                                     CStorageVariant const & var,
                                     BOOL fBackup )
{
    CPropRecordForWrites PropRecord( wid, *this );
    return WriteProperty( PropRecord, pid, var, fBackup );
}

//+---------------------------------------------------------------------------
//
//  Member:     CPropertyStore::ReadProperty, public
//
//  Synopsis:   Read a property from the cache.  Version which uses property
//              record.
//
//  Arguments:  [PropRec] -- Pre-opened property record
//              [pid]     -- Propid
//              [pbData]  -- Place to return the value
//              [pcb]     -- On input, the maximum number of bytes to
//                           write at pbData.  On output, the number of
//                           bytes written if the call was successful,
//                           else the number of bytes required.
//
//  History:    03-Apr-96   KyleP       Created.
//
//----------------------------------------------------------------------------

BOOL CPropertyStore::ReadProperty( CPropRecordNoLock & PropRec, PROPID pid, PROPVARIANT * pbData, unsigned * pcb )
{
    *pcb -= sizeof(PROPVARIANT);
    BOOL fOk = ReadProperty( PropRec, pid, *pbData, (BYTE *)(pbData + 1), pcb );
    *pcb += sizeof(PROPVARIANT);

    return fOk;
}

//+---------------------------------------------------------------------------
//
//  Member:     CPropertyStore::ReadProperty, public
//
//  Synopsis:   Read a property from the cache.  Triggers CoTaskMemAlloc
//
//  Arguments:  [wid] -- Workid
//              [pid] -- Propid
//              [var] -- Place to return the value
//
//  History:    27-Dec-95   KyleP       Created.
//
//----------------------------------------------------------------------------

BOOL CPropertyStore::ReadProperty( WORKID wid, PROPID pid, PROPVARIANT & var )
{
    unsigned cb = 0xFFFFFFFF;
    return ReadProperty( wid, pid, var, 0, &cb );
}

//+---------------------------------------------------------------------------
//
//  Member:     CPropertyStore::ReadProperty, public
//
//  Synopsis:   Read a property from the cache.  Separate variable buffer.
//
//  Arguments:  [wid]      -- Workid
//              [pid]      -- Propid
//              [var]      -- Variant written here
//              [pbExtra]  -- Place to store additional pointer(s).
//              [pcbExtra] -- On input, the maximum number of bytes to
//                            write at pbExtra.  On output, the number of
//                            bytes written if the call was successful,
//                            else the number of bytes required.
//
//  History:    27-Dec-95   KyleP       Created.
//
//----------------------------------------------------------------------------

BOOL CPropertyStore::ReadProperty( WORKID wid,
                                   PROPID pid,
                                   PROPVARIANT & var,
                                   BYTE * pbExtra,
                                   unsigned * pcbExtra )
{
    CPropRecord PropRecord( wid, *this );

    return ReadProperty( PropRecord, pid, var, pbExtra, pcbExtra );
}

//+---------------------------------------------------------------------------
//
//  Member:     CPropertyStore::ReadProperty, public
//
//  Synopsis:   Read a property from the cache.  Separate variable buffer.
//              Uses pre-opened property record.
//
//  Arguments:  [PropRec]  -- Pre-opened property record.
//              [pid]      -- Propid
//              [var]      -- Variant written here
//              [pbExtra]  -- Place to store additional pointer(s).
//              [pcbExtra] -- On input, the maximum number of bytes to
//                            write at pbExtra.  On output, the number of
//                            bytes written if the call was successful,
//                            else the number of bytes required.
//
//  History:    03-Apr-96   KyleP       Created.
//
//----------------------------------------------------------------------------

BOOL CPropertyStore::ReadProperty( CPropRecordNoLock & PropRecord,
                                   PROPID pid,
                                   PROPVARIANT & var,
                                   BYTE * pbExtra,
                                   unsigned * pcbExtra )
{
    ciDebugOut(( DEB_PROPSTORE, "READ: PropRec = 0x%x, pid = 0x%x\n", &PropRecord, pid ));

    if (!PropRecord.IsValid())
        return FALSE;

    COnDiskPropertyRecord * prec = PropRecord._prec;

    return ReadProperty(prec, pid, var, pbExtra, pcbExtra);
}

//+---------------------------------------------------------------------------
//
//  Member:     CPropertyStore::ReadProperty, public
//
//  Synopsis:   Read a property from the cache.  Separate variable buffer.
//              Uses pre-opened property record.
//
//  Arguments:  [prec]     -- Ptr to preopened property record.
//              [pid]      -- Propid
//              [var]      -- Variant written here
//              [pbExtra]  -- Place to store additional pointer(s).
//              [pcbExtra] -- On input, the maximum number of bytes to
//                            write at pbExtra.  On output, the number of
//                            bytes written if the call was successful,
//                            else the number of bytes required.
//
//  History:    17-Mar-1998   KrishnaN       Created.
//              15-Mar-2000   KLam           Add STATUS_INSUFFICIENT_RESOURCES to assert
//
//----------------------------------------------------------------------------

BOOL CPropertyStore::ReadProperty( COnDiskPropertyRecord *prec,
                                   PROPID pid,
                                   PROPVARIANT & var,
                                   BYTE * pbExtra,
                                   unsigned * pcbExtra )
{
    CPropDesc const * pdesc = _PropStoreInfo.GetDescription( pid );

    //
    // Is the property cached?
    //

    if ( 0 == pdesc )
        return FALSE;

    // If CPropRecord was passed in widInvalid, prec would be 0. So Read should fail!
    if (0 == prec)
        return FALSE;

    if ( !prec->IsInUse() )
    {
        ciDebugOut(( DEB_IWARN,
                     "Trying to read from a deleted wid in prec = 0x%X\n",
                     prec ));
        return FALSE;
    }

    if ( !prec->IsTopLevel() )
    {
        ciDebugOut(( DEB_IWARN,
                     "Trying to start read from a non-toplevel prec = 0x%X\n",
                     prec ));
        return FALSE;
    }

    TRY
    {
    if ( pdesc->IsFixedSize() )
    {
        Win4Assert( 0 != _pStorage );

        prec->ReadFixed( pdesc->Ordinal(),
                         pdesc->Mask(),
                         pdesc->Offset(),
                         _PropStoreInfo.CountProps(),
                         pdesc->Type(),
                         var,
                         pbExtra,
                         pcbExtra,
                         *_pStorage );
    }
    else
    {
        BOOL fOk = prec->ReadVariable( pdesc->Ordinal(),
                                       pdesc->Mask(),
                                       _PropStoreInfo.FixedRecordSize(),
                                       _PropStoreInfo.CountProps(),
                                       _PropStoreInfo.CountFixedProps(),
                                       var,
                                       pbExtra,
                                       pcbExtra );

        if (! fOk )
        {
            CBorrowed BorrowedOverflow( _xPhysStore.GetReference(),
                                        _PropStoreInfo.RecordsPerPage(),
                                        _PropStoreInfo.RecordSize() );

            do
            {
                //
                // Check for existing overflow block.
                //

                WORKID widOverflow = prec->OverflowBlock();

                //
                // Need new overflow block.
                //

                if ( 0 == widOverflow )
                    return FALSE;

                Win4Assert( _xPhysStore->PageSize() * CI_PAGE_SIZE >=
                            COnDiskPropertyRecord::MinStreamSize( widOverflow, _PropStoreInfo.RecordSize() ) );

                BorrowedOverflow.Release();
                BorrowedOverflow.Set( widOverflow, FALSE );
                prec = BorrowedOverflow.Get();

                ULONG Ordinal = pdesc->Ordinal() - _PropStoreInfo.CountFixedProps();
                DWORD Mask = (1 << ((Ordinal % 16) * 2) );

                fOk = prec->ReadVariable( Ordinal,  // Ordinal (assuming 0 fixed)
                                          Mask,     // Mask (assuming 0 fixed)
                                          0,        // Fixed properties
                                          _PropStoreInfo.CountProps() - _PropStoreInfo.CountFixedProps(),
                                          0,        // Count of fixed properties
                                          var,
                                          pbExtra,
                                          pcbExtra );
            } while ( !fOk );
        }
    }
    }
    CATCH( CException, e )
    {
        ciDebugOut(( DEB_ERROR, "Exception 0x%x caught reading pid %d in prec = 0x%x\n",
                     e.GetErrorCode(), pid, prec ));
        // assert if the error is other than out of memory

        Win4Assert( ( e.GetErrorCode() == E_OUTOFMEMORY || 
                      e.GetErrorCode() == HRESULT_FROM_WIN32(STATUS_SHARING_VIOLATION) ||
                      e.GetErrorCode() == HRESULT_FROM_WIN32(STATUS_INSUFFICIENT_RESOURCES) )
                     && "Exception reading property" );

        RETHROW();
    }
    END_CATCH

    return TRUE;
}

//+---------------------------------------------------------------------------
//
//  Member:     CPropertyStore::DeleteRecord, public
//
//  Synopsis:   Free a record and any records chained off it.
//
//  Arguments:  [wid] -- Workid
//
//  History:    27-Dec-95   KyleP       Created.
//
//----------------------------------------------------------------------------

void CPropertyStore::DeleteRecord( WORKID wid, BOOL fBackup )
{
    Win4Assert(wid != widInvalid && wid != 0);
    ciDebugOut(( DEB_PROPSTORE, "DELETE: wid = 0x%x\n", wid ));

    ULONG cbStream = COnDiskPropertyRecord::MinStreamSize( wid, _PropStoreInfo.RecordSize() );

    if ( _xPhysStore->PageSize() * CI_PAGE_SIZE < cbStream )
        return;

    CBorrowed BorrowedTopLevel( _xPhysStore.GetReference(),
                                wid,
                               _PropStoreInfo.RecordsPerPage(),
                               _PropStoreInfo.RecordSize() );

    CLockRecordForWrite wlock( *this, wid );

    WORKID widStart = wid;

    COnDiskPropertyRecord * pRecTopLevel = BorrowedTopLevel.Get();
    // Return if we have nothing to delete.
    if (0 == pRecTopLevel)
        return;

    BOOL fIsConsistent = TRUE;

    if ( !pRecTopLevel->IsTopLevel() )
    {
        ciDebugOut(( DEB_ERROR, "Delete wid (0x%X) prec (0x%X) is not top level\n",
                     wid, pRecTopLevel ));
        Win4Assert( !"Corruption detected in PropertyStore" );
        fIsConsistent = FALSE;
    }

    ULONG cRemainingBlocks = 1; // won't change for a lean record
    if (eNormal == GetRecordFormat())
        cRemainingBlocks = pRecTopLevel->GetOverflowChainLength()+1;

    while ( wid != 0 && wid <= _PropStoreInfo.MaxWorkId() )
    {
        if ( 0 == cRemainingBlocks )
        {
            //
            // We are either in some kind of corruption or loop. In either,
            // case, we have freed up as many as are probably safe. Just
            // get out of here.
            //
            ciDebugOut(( DEB_ERROR,
                         "Delete wid (0x%X) overflow chain is corrupt\n",
                         wid ));
            Win4Assert( !"Corruption detected in PropertyStore" );
            fIsConsistent = FALSE;
            break;
        }

        CBorrowed Borrowed( _xPhysStore.GetReference(),
                            wid,
                            _PropStoreInfo.RecordsPerPage(),
                            _PropStoreInfo.RecordSize() );

        COnDiskPropertyRecord * prec = Borrowed.Get();

        WORKID widNext = 0; // causes loop termination for lean records
        if (eNormal == GetRecordFormat())
        {
            widNext = prec->OverflowBlock();

            if ( (wid != widStart) && !prec->IsOverflow() )
            {
                ciDebugOut(( DEB_ERROR,
                             "Wid (0x%x) - prec (0x%x). Not in use record to be deleted\n",
                             wid, prec ));

                Win4Assert( !"Corruption detected in PropertyStore" );
                fIsConsistent = FALSE;
                break;
            }
        }

        LokFreeRecord( wid, prec->CountRecords(), prec, fBackup );
        wid = widNext;
        cRemainingBlocks--;
    }

    _PropStoreInfo.DecRecordsInUse();

    if ( !fIsConsistent )
    {
        _fIsConsistent = FALSE;
        THROW( CException( CI_PROPSTORE_INCONSISTENCY ) );
    }

#if CIDBG == 1

    // Assert that we have a dirty property store and that something was written to
    // the backup file (if fBackup is enabled)
    Win4Assert(_PropStoreInfo.IsDirty());

    if (fBackup)
    {
        Win4Assert(BackupStream()->Pages() > 0);
    }

#endif // CIDBG
}


//+---------------------------------------------------------------------------
//
//  Member:     CPropertyStore::InitFreeList
//
//  Synopsis:   Initialize the free list block pointer array.
//
//  Returns:    Nothing
//
//  History:    07 May 96   AlanW    Created
//
//  Notes:      The free list block pointer array speeds allocation and
//              deallocation of records by storing the starting record number
//              of free records of a particular size.  The free list is
//              sorted by the size of the record.
//
//----------------------------------------------------------------------------

void CPropertyStore::InitFreeList( )
{
    if ( 0 != _aFreeBlocks )
    {
        delete _aFreeBlocks;
        _aFreeBlocks = 0;
    }

    _aFreeBlocks = new WORKID[ _PropStoreInfo.RecordsPerPage() + 1 ];
    RtlZeroMemory( _aFreeBlocks,
                   (_PropStoreInfo.RecordsPerPage()+1) * sizeof (WORKID) );

    WORKID wid = _PropStoreInfo.FreeListHead();

    ciDebugOut(( DEB_PROPSTORE, "Scanning free list starting with wid %u\n", wid ));

    if (0 != wid)
    {
        CBorrowed Borrowed( _xPhysStore.GetReference(),
                            wid,
                            _PropStoreInfo.RecordsPerPage(),
                            _PropStoreInfo.RecordSize() );
        COnDiskPropertyRecord * prec = Borrowed.Get();

        if ( prec->GetNextFreeRecord() != 0)
        {
            CBorrowed BorrowedNext( _xPhysStore.GetReference(),
                                    prec->GetNextFreeRecord(),
                                    _PropStoreInfo.RecordsPerPage(),
                                    _PropStoreInfo.RecordSize() );
            COnDiskPropertyRecord * precNext = BorrowedNext.Get();

            if ( precNext->GetPreviousFreeRecord() != wid ||
                 precNext->CountRecords() != prec->GetNextFreeSize() )
            {
                //  Old-style free list

                Win4Assert( FALSE );
                return;
            }
        }

        if ( prec->GetPreviousFreeRecord() != 0 )
        {
            //
            //  Minor inconsistency in the first free record.  Fix it.
            //
            ciDebugOut(( DEB_WARN, "PROPSTORE: Repair free list previous pointer(0x%X)\n", wid ));
            prec->SetPreviousFreeRecord( 0 );
        }
        if ( prec->GetNextFreeRecord() == 0  &&
             _PropStoreInfo.FreeListTail( ) != wid )
        {
            //
            //  Minor inconsistency in a single free record.  Fix it.
            //
            ciDebugOut(( DEB_WARN, "PROPSTORE: Repair free list tail pointer(0x%X)\n", wid ));
            prec->SetNextFree( 0, 0 );
            _PropStoreInfo.SetFreeListTail( wid );
        }
    }
    else if ( _PropStoreInfo.FreeListTail() != 0 )
    {
        //
        // Free list tail not set correctly for an empty list.  Fix it.
        //
        _PropStoreInfo.SetFreeListTail( 0 );
    }

    CBorrowed Borrowed( _xPhysStore.GetReference(),
                        _PropStoreInfo.RecordsPerPage(),
                        _PropStoreInfo.RecordSize() );

#if CIDBG == 1
    WORKID widPrev = 0;
    ULONG cRecPrev = 0;
#endif // CIDBG == 1

    while ( 0 != wid )
    {
        Borrowed.Set(wid);

        COnDiskPropertyRecord * prec = Borrowed.Get();

        Win4Assert( prec->IsFreeRecord() &&
                    prec->GetPreviousFreeRecord() == widPrev );
        Win4Assert( cRecPrev == 0 ||
                    prec->CountRecords() == cRecPrev );

        if (_aFreeBlocks[prec->CountRecords()] == 0)
        {
            _aFreeBlocks[prec->CountRecords()] = wid;
            ciDebugOut(( DEB_PROPSTORE,
                         "  _aFreeBlocks[%03d] = 0x%X\n",
                         prec->CountRecords(), wid ));
        }

        if (prec->CountRecords() == 1)
            break;

#if CIDBG == 1
        widPrev = wid;
        cRecPrev = prec->GetNextFreeSize();
#endif // CIDBG == 1
        wid = prec->GetNextFreeRecord();

        Borrowed.Release();
    }
}


//+---------------------------------------------------------------------------
//
//  Member:     CPropertyStore::LokFreeRecord, private
//
//  Synopsis:   Add a free record to the free list.
//
//  Arguments:  [widFree]  -- Workid of record to free
//              [cFree]    -- Number of records in freed chunk
//              [precFree] -- On-disk Property record
//              [fBackup]  -- Backup record?
//
//  Notes:      The free list is maintained in decreasing order of free
//              block size.  The _aFreeBlocks array is updated.
//
//  History:    01 May 96   AlanW       Created.
//
//----------------------------------------------------------------------------

void CPropertyStore::LokFreeRecord( WORKID widFree,
                                    ULONG cFree,
                                    COnDiskPropertyRecord * precFree,
                                    BOOL fBackup )
{

    CImpersonateSystem impersonate;

    if (fBackup)
    {
        CBackupWid backup(this, widFree, cFree);
        _PropStoreInfo.MarkDirty();
    }

    WORKID widListHead = _PropStoreInfo.FreeListHead();

    ciDebugOut(( DEB_PROPSTORE,
                 " free wid 0x%X, size = %d\n", widFree, cFree ));

    _PropStoreInfo.MarkDirty();

    for (unsigned i = cFree; i <= _PropStoreInfo.RecordsPerPage(); i++)
        if (_aFreeBlocks[i] != 0)
            break;

    if ( 0 == widListHead ||
         i > _PropStoreInfo.RecordsPerPage() ||
         (i == cFree && widListHead == _aFreeBlocks[i]) )
    {
        //
        //  The block will go at the head of the list
        //
        WORKID widNext = widListHead;
        ULONG cFreeNext = 0;

        if ( 0 != widNext )
        {
            CBorrowed BorrowedNext( _xPhysStore.GetReference(),
                                    widNext,
                                    _PropStoreInfo.RecordsPerPage(),
                                    _PropStoreInfo.RecordSize() );
            COnDiskPropertyRecord * precNext = BorrowedNext.Get();

            if (fBackup)
            {
                CBackupWid backup(this, widNext, 1);
                _PropStoreInfo.MarkDirty();
            }
            precNext->SetPreviousFreeRecord( widFree );
            cFreeNext = precNext->CountRecords();
        }
        else
        {
            _PropStoreInfo.SetFreeListTail( widFree );
        }

        if (precFree->IsLeanRecord())
            precFree->MakeLeanFreeRecord( cFree,
                                          widNext,
                                          cFreeNext,
                                          _PropStoreInfo.RecordSize() );
        else
            precFree->MakeNormalFreeRecord( cFree,
                                            widNext,
                                            cFreeNext,
                                            _PropStoreInfo.RecordSize() );

        precFree->SetPreviousFreeRecord( 0 );

        Win4Assert( _aFreeBlocks[ cFree ] == 0 || i == cFree );
        _aFreeBlocks[cFree] = widFree;
        _PropStoreInfo.SetFreeListHead( widFree );

        return;
    }

    if ( i != cFree )
    {
        //
        //  A block of this size doesn't exist; find the next smaller
        //  size and insert before it.
        //
        for ( i = cFree; i > 0; i-- )
            if (_aFreeBlocks[i] != 0)
                break;
    }

    if ( i > 0 )
    {
        //
        //  Insert the block into the list
        //
        WORKID widNext = _aFreeBlocks[i];
        ULONG cFreeNext = i;

        CBorrowed BorrowedNext( _xPhysStore.GetReference(),
                                widNext,
                                _PropStoreInfo.RecordsPerPage(),
                                _PropStoreInfo.RecordSize() );
        COnDiskPropertyRecord * precNext = BorrowedNext.Get();

        WORKID widPrev = precNext->GetPreviousFreeRecord();
        precNext->SetPreviousFreeRecord( widFree );

        Win4Assert( cFreeNext == precNext->CountRecords() );

        if (precFree->IsLeanRecord())
            precFree->MakeLeanFreeRecord( cFree,
                                      widNext,
                                      cFreeNext,
                                      _PropStoreInfo.RecordSize() );
        else
            precFree->MakeNormalFreeRecord( cFree,
                                      widNext,
                                      cFreeNext,
                                      _PropStoreInfo.RecordSize() );

        precFree->SetPreviousFreeRecord( widPrev );

        // Insertion at list head is handled above...
        Win4Assert( widPrev != 0 );
        if (widPrev != 0)
        {
            CBorrowed BorrowedPrev( _xPhysStore.GetReference(),
                                    widPrev,
                                    _PropStoreInfo.RecordsPerPage(),
                                    _PropStoreInfo.RecordSize() );
            COnDiskPropertyRecord * precPrev = BorrowedPrev.Get();

            precPrev->SetNextFree( widFree, cFree );
        }

        _aFreeBlocks[cFree] = widFree;

        return;
    }

    //
    //  No blocks of this size or smaller found.  Append to list
    //
    WORKID widPrev = _PropStoreInfo.FreeListTail();
    Win4Assert( widPrev != 0 );

    CBorrowed BorrowedPrev( _xPhysStore.GetReference(),
                            widPrev,
                            _PropStoreInfo.RecordsPerPage(),
                            _PropStoreInfo.RecordSize() );
    COnDiskPropertyRecord * precPrev = BorrowedPrev.Get();

    precPrev->SetNextFree( widFree, cFree );

    if (precFree->IsLeanRecord())
        precFree->MakeLeanFreeRecord( cFree,
                                  0,
                                  0,
                                  _PropStoreInfo.RecordSize() );
    else
        precFree->MakeNormalFreeRecord( cFree,
                                        0,
                                        0,
                                        _PropStoreInfo.RecordSize() );
    precFree->SetPreviousFreeRecord( widPrev );

    _PropStoreInfo.SetFreeListTail( widFree );

    Win4Assert( _aFreeBlocks[cFree] == 0 );
    _aFreeBlocks[cFree] = widFree;

    return;
}


//+---------------------------------------------------------------------------
//
//  Member:     CPropertyStore::LokAllocRecord, private
//
//  Synopsis:   Allocate a record from the free list
//
//  Arguments:  [cFree]    -- Number of contiguous records required
//
//  Returns:    WORKID - the work ID of the record allocated.  0 if none of
//                       sufficient size could be found.
//
//  History:    09 May 96   AlanW       Created.
//
//----------------------------------------------------------------------------

WORKID CPropertyStore::LokAllocRecord( ULONG cFree )
{

    CImpersonateSystem impersonate;

    _PropStoreInfo.MarkDirty();

    for (unsigned i = cFree; i <= _PropStoreInfo.RecordsPerPage(); i++)
        if (_aFreeBlocks[i] != 0)
            break;

    if ( i > _PropStoreInfo.RecordsPerPage() )
        return 0;

    WORKID widFree = _aFreeBlocks[i];

    CBorrowed Borrowed( _xPhysStore.GetReference(),
                        widFree,
                        _PropStoreInfo.RecordsPerPage(),
                        _PropStoreInfo.RecordSize() );
    COnDiskPropertyRecord * prec = Borrowed.Get();

    WORKID widNext = prec->GetNextFreeRecord();
    WORKID widPrev = prec->GetPreviousFreeRecord();

    if ( prec->CountRecords() != prec->GetNextFreeSize() )
        _aFreeBlocks[i] = 0;
    else
        _aFreeBlocks[i] = prec->GetNextFreeRecord();


    if ( widNext != 0 )
    {
        CBorrowed BorrowedNext( _xPhysStore.GetReference(),
                                widNext,
                                _PropStoreInfo.RecordsPerPage(),
                                _PropStoreInfo.RecordSize() );
        COnDiskPropertyRecord * precNext = BorrowedNext.Get();

        Win4Assert( precNext->IsFreeRecord() );
        Win4Assert( prec->GetNextFreeSize() == precNext->CountRecords() );
        precNext->SetPreviousFreeRecord( widPrev );
    }
    else
    {
        Win4Assert( _PropStoreInfo.FreeListTail() == widFree );
        _PropStoreInfo.SetFreeListTail( widPrev );
    }

    if ( widPrev != 0 )
    {
        CBorrowed BorrowedPrev( _xPhysStore.GetReference(),
                                widPrev,
                                _PropStoreInfo.RecordsPerPage(),
                                _PropStoreInfo.RecordSize() );
        COnDiskPropertyRecord * precPrev = BorrowedPrev.Get();

        Win4Assert( precPrev->IsFreeRecord() );
        precPrev->SetNextFree( widNext, prec->GetNextFreeSize() );
    }
    else
    {
        Win4Assert( _PropStoreInfo.FreeListHead() == widFree );
        _PropStoreInfo.SetFreeListHead( widNext );
    }

    ciDebugOut(( DEB_PROPSTORE,
                 " alloc wid 0x%X, size = %d\n", widFree, cFree ));

    return widFree;
}

//+---------------------------------------------------------------------------
//
//  Member:     CPropertyStore::CPropertyStore, private
//
//  Synopsis:   Copy constructor
//
//  Arguments:  [rhs]        -- Source metadata
//
//  History:    03-Jan-96   KyleP       Created.
//              26-Mar-96   SrikantS    Modifed for better recovery.
//
//----------------------------------------------------------------------------

CPropertyStore::CPropertyStore( CPropertyStore & rhs, CiStorage * pStorage )
        : _pStorage(0),
          _PropStoreInfo( rhs._PropStoreInfo ),
          _aFreeBlocks(0),
          _fAbort(FALSE),
          _ppsNew( 0 ),
          _fNew( FALSE ),
          _ulBackupSizeInPages( rhs._ulBackupSizeInPages ),
          _ulPSMappedCache( rhs._ulPSMappedCache ),
          _propStoreMgr( rhs._propStoreMgr )
{
    #if CIDBG == 1
        _sigPSDebug = 0x2047554245445350i64;  // PSDEBUG
        _tidReadSet = _tidReadReset = _tidWriteSet = _tidWriteReset = 0xFFFFFFFF;

        _xPerThreadReadCounts.Init( cTrackThreads );
        _xPerThreadWriteCounts.Init( cTrackThreads );

        RtlZeroMemory( _xPerThreadReadCounts.GetPointer(), 
                       cTrackThreads * sizeof(_xPerThreadReadCounts[0]) );
        RtlZeroMemory( _xPerThreadWriteCounts.GetPointer(), 
                       cTrackThreads * sizeof(_xPerThreadWriteCounts[0]) );
    #endif

    _pStorage = pStorage;

    #if CIDBG == 1

    // Allocate an array to track what records are currently locked.
    // To be used to acquire all write locks.
    _pbRecordLockTracker = new BYTE[LockMgr().UniqueRecordCount()];
    RtlZeroMemory(_pbRecordLockTracker, sizeof(BYTE)*LockMgr().UniqueRecordCount());

    #endif // CIDBG
}

//+---------------------------------------------------------------------------
//
//  Member:     CPropertyStore::CreateStorage, private
//
//  Synopsis:   Creates property store storage.
//
//  Arguments:  [rhs]        -- Source metadata
//
//  Returns:    WorkId of new storage
//
//  History:    03-Jun-96   KyleP       Created.
//
//----------------------------------------------------------------------------

WORKID CPropertyStore::CreateStorage( WORKID widGiven )
{
    WORKID wid = widInvalid == widGiven  ?
                    _PropStoreInfo.NextWorkId(*_pStorage) : widGiven;


    SStorageObject xobj( _pStorage->QueryObject( wid ) );
    XPtr<PMmStream> xmmstrm ( _pStorage->QueryNewPropStream( xobj.GetObj(),
                                                             _PropStoreInfo.GetStoreLevel() ));

    _xPhysStore.Set(
        new CPhysPropertyStore( *_pStorage,
                                xobj.GetObj(),
                                _PropStoreInfo.WorkId(),
                                xmmstrm.Acquire(),
                                PStorage::eOpenForWrite,
                                _ulPSMappedCache ) );

    // grow the file 2 meg at a time

    _xPhysStore->SetPageGrowth( 32 * COMMON_PAGE_SIZE / CI_PAGE_SIZE );

    // create a prop store backup stream
    _xPSBkpStrm.Set(_pStorage->QueryNewPSBkpStream( xobj.GetObj(),
                                                    _ulBackupSizeInPages,
                                                    GetStoreLevel() ));
    return wid;
}

//+---------------------------------------------------------------------------
//
//  Member:     CPropertyStore::WritePropertyInSpecificNewRecord, private
//
//  Synopsis:   Write a property to the cache.  Allocate specified wid
//              for property.
//
//  Arguments:  [wid] -- Workid.  Must be > MaxWorkId.
//              [pid] -- Propid
//              [var] -- Value
//              [fBackup] -- Backup?
//
//  History:    27-Dec-95   KyleP       Created.
//
//----------------------------------------------------------------------------

void CPropertyStore::WritePropertyInSpecificNewRecord( WORKID wid,
                                                       PROPID pid,
                                                       CStorageVariant const & var,
                                                       BOOL fBackup)
{
    //
    // Note: We don't need to lock here, because this method is used before
    //       a property store comes on-line.
    //

    //
    // Since wid must be larger than current max, then we need to adjust the
    // maximum and store the records in-between on the free list.
    //

    Win4Assert( wid > _PropStoreInfo.MaxWorkId() );

    WORKID widFree = _PropStoreInfo.MaxWorkId() + 1;

    while ( widFree < wid )
    {
        WORKID widInRec = widFree % _PropStoreInfo.RecordsPerPage();

        //
        // Build as long a record as possible for the in-between free records.
        // Don't span large page boundaries.
        //

        ULONG cWid = wid - widFree;

        if ( widInRec + cWid - 1 >= _PropStoreInfo.RecordsPerPage() )
            cWid = _PropStoreInfo.RecordsPerPage() - widInRec;

        CBorrowed Borrowed( _xPhysStore.GetReference(),
                            _PropStoreInfo.RecordsPerPage(),
                            _PropStoreInfo.RecordSize() );

        Borrowed.SetMaybeNew( widFree );
        COnDiskPropertyRecord * prec = Borrowed.Get();

        ciDebugOut(( DEB_PROPSTORE, "Putting records 0x%x - 0x%x on free list.\n", widFree, widFree + cWid - 1 ));

        // Backup the records before freeing them. Back them up as one long
        // record because that is how they are being added to the free list.
        // For recovery purposes it doesn't matter if they are backed up
        // one by one or all together, but we prefer the latter for efficiency.

        // The free block is at most one large page. Assert that the backup is large
        // enough to hold the max size of the free block.
        Win4Assert(COMMON_PAGE_SIZE <= _PropStoreInfo.OSPageSize()*_xPSBkpStrm->MaxPages());

        LokFreeRecord( widFree, cWid, prec, fBackup );
        widFree += cWid;
    }

    //
    // Are we on a fresh large page?
    //

    CBorrowed Borrowed( _xPhysStore.GetReference(),
                        _PropStoreInfo.RecordsPerPage(),
                        _PropStoreInfo.RecordSize() );
    Borrowed.SetMaybeNew( wid );

    COnDiskPropertyRecord * prec = Borrowed.Get();

    // Tracking assert for bug 125604. Ensure that what we are overwriting
    // is indeed a free or a virgin record.

    Win4Assert(prec->IsFreeOrVirginRecord());

    // IMPORTANT: This is a new block, so it is going to overwrite an
    // existing free record. Write the toplevel wid in the TopLevel field
    // of the record to be written over when the page is written to backup.
    // Note that if we are backing up a "lean record", we don't need to remember
    // the top-level of the displacing wid in the displaced wid. Because all
    // "in use" lean records will always be only "one-record" long, we know that
    // the displaced record was displaced by the same wid.

    if (eLean == GetRecordFormat())
    {
        Win4Assert(1 == prec->CountRecords());

        // Save the "to be displaced" record before actually displacing it.
        if (fBackup)
        {
            CBackupWid backupNewWid(this, wid, prec->CountRecords());
            _PropStoreInfo.MarkDirty();
        }
        prec->MakeNewLeanTopLevel();
    }
    else
    {
        Win4Assert(eNormal == GetRecordFormat());

        // Save the "to be displaced" record before actually displacing it.
        if (fBackup)
        {
            CBackupWid backupNewWid(this, wid, prec->CountRecords(), eTopLevelField,
                                    (ULONG)wid, prec);
            _PropStoreInfo.MarkDirty();
        }
        prec->MakeNewNormalTopLevel();
    }

    _PropStoreInfo.SetMaxWorkId( wid );

    SCODE scWrite = WriteProperty( wid, pid, var, fBackup );
    if (FAILED(scWrite))
        THROW(CException(scWrite));

    _PropStoreInfo.IncRecordsInUse();


#if CIDBG == 1

    // Assert that we have a dirty property store and that something was written to
    // the backup file (if fBackup is enabled)
    Win4Assert(_PropStoreInfo.IsDirty());
    if (fBackup)
    {
        Win4Assert(BackupStream()->Pages() > 0);
    }

#endif // CIDBG
}

//+---------------------------------------------------------------------------
//
//  Member:     CPropertyStore::InitNewRecord, private inline
//
//  Synopsis:   Initializes a new property record
//
//  Arguments:  [wid]       -- WORKID of the new wid
//              [cWid]      -- Count of contiguous workids (records) needed.
//              [prec]      -- pointer to the on-disk record
//              [fTopLevel] -- true if the new wid is a top-level wid
//
//  History:    27-Feb-96   dlee       Created from code in LokNewWorkId
//              13-Jun-97   KrishnaN   Backup support.
//
//----------------------------------------------------------------------------

inline void CPropertyStore::InitNewRecord(
    WORKID      wid,
    ULONG       cWid,
    COnDiskPropertyRecord * prec,
    BOOL        fTopLevel,
    BOOL        fBackup)
{
    // Tracking assert for bug 125604. Ensure that what we are overwriting
    // is indeed a free or a virgin record.

    Win4Assert(prec->IsFreeOrVirginRecord());


    // This is the only exception to the rule "backup before touching".
    // As a result of this exception, the backup file contains a free or virgin
    // record that is cWid long. During restore from backup, this length field
    // helps to identify the entire block as a free block, so processing can be
    // a little more efficient. Otherwise, we will have to work with cWid individual
    // free or virgin records.
    prec->MakeLongRecord(cWid);

    // Backup the record before touching it.

    if ( fTopLevel )
    {
        // Record the top-level wid of the occupying record
        // in the backup as part of the occupied free record.
        // Note that if we are backing up a "lean record", we don't need to remember
        // the top-level of the displacing wid in the displaced wid. Because all
        // "in use" lean records will always be only "one-record" long, we know that
        // the displaced record was displaced by the same wid.

        if (eLean == GetRecordFormat())
        {
            Win4Assert(1 == prec->CountRecords());

            // Save the "to be displaced" record before actually displacing it.
            if (fBackup)
            {
                CBackupWid backupNewWid(this, wid, prec->CountRecords());
                _PropStoreInfo.MarkDirty();
            }
            prec->MakeNewLeanTopLevel();
        }
        else
        {
            Win4Assert(eNormal == GetRecordFormat());

            // Save the "to be displaced" record before actually displacing it.
            if (fBackup)
            {
                CBackupWid backupNewWid(this, wid, prec->CountRecords(), eTopLevelField,
                                        (ULONG)wid, prec);
                _PropStoreInfo.MarkDirty();
            }
            prec->MakeNewNormalTopLevel();
        }
    }
    else
    {
        Win4Assert(!prec->IsLeanRecord());
        Win4Assert(eNormal == GetRecordFormat());

        if (fBackup)
        {
            CBackupWid backupWid(this, wid, prec->CountRecords());
            _PropStoreInfo.MarkDirty();
        }
        prec->MakeNewOverflow();
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CPropertyStore::LokNewWorkId, private
//
//  Synopsis:   Find next available workid
//
//  Arguments:  [cWid]      -- Count of contiguous workids (records) needed.
//              [fTopLevel] -- true if the new wid is a top-level wid
//
//  Returns:    Next available workid.
//
//  History:    03-Jan-96   KyleP       Created.
//
//----------------------------------------------------------------------------

WORKID CPropertyStore::LokNewWorkId( ULONG cWid, BOOL fTopLevel, BOOL fBackup )
{
    //
    //  First, try to find a free block of the appropriate size.
    //  Search for the best-fit, scanning the list until an exact
    //  match or the first smaller block is found.
    //

    COnDiskPropertyRecord * prec = 0;
    COnDiskPropertyRecord * precPrev = 0;

    CBorrowed Borrowed( _xPhysStore.GetReference(),
                        _PropStoreInfo.RecordsPerPage(),
                        _PropStoreInfo.RecordSize() );


    ciDebugOut(( DEB_PROPSTORE, "Looking for free record of size %u\n", cWid ));

    WORKID wid = LokAllocRecord( cWid );

    if (wid != 0)
    {
        Borrowed.Set( wid );
        prec = Borrowed.Get();

        ciDebugOut(( DEB_PROPSTORE,
                     "  Free wid 0x%x, size = %u\n",
                     wid, prec->CountRecords() ));

        //
        // Is it big enough?
        //

        Win4Assert ( prec->CountRecords() >= cWid );

        //
        // Adjust size, and put extra back on free list.
        //

        if ( prec->CountRecords() > cWid )
        {
            CBorrowed BorrowedRemainder( _xPhysStore.GetReference(),
                                         wid + cWid,
                                         _PropStoreInfo.RecordsPerPage(),
                                         _PropStoreInfo.RecordSize() );
            COnDiskPropertyRecord * precRemainder = BorrowedRemainder.Get();
            LokFreeRecord( wid+cWid,
                           prec->CountRecords() - cWid,
                           precRemainder,
                           fBackup );
        }

        InitNewRecord( wid, cWid, prec, fTopLevel, fBackup );
    }
    else
    {
        Win4Assert( cWid <= _PropStoreInfo.RecordsPerPage() );

        wid = _PropStoreInfo.MaxWorkId() + 1;

        //
        // Do we need a fresh page?
        //

        WORKID widInRec = wid % _PropStoreInfo.RecordsPerPage();

        if ( widInRec + cWid - 1 >= _PropStoreInfo.RecordsPerPage() )
        {
            ciDebugOut(( DEB_PROPSTORE, "Aligning for Multi-workid request...\n" ));

            CBorrowed Borrowed( _xPhysStore.GetReference(),
                                wid,
                                _PropStoreInfo.RecordsPerPage(),
                                _PropStoreInfo.RecordSize() );

            COnDiskPropertyRecord * prec = Borrowed.Get();

            #if CIDBG == 1

            if (eLean == GetRecordFormat())
                Win4Assert( prec->IsLeanEmpty(_PropStoreInfo.RecordSize()) );
            else
                Win4Assert( prec->IsNormalEmpty( _PropStoreInfo.RecordSize() ) );

            #endif // CIDBG

            ULONG cFree = _PropStoreInfo.RecordsPerPage() - widInRec;
            LokFreeRecord( wid, cFree, prec, fBackup );
            wid += cFree;

            Win4Assert( (wid % _PropStoreInfo.RecordsPerPage() ) == 0 );
        }

        if ( cWid > 1 )
        {
            ciDebugOut(( DEB_PROPSTORE, "New max workid = %d\n", _PropStoreInfo.MaxWorkId() ));
        }

        CBorrowed Borrowed( _xPhysStore.GetReference(),
                            _PropStoreInfo.RecordsPerPage(),
                            _PropStoreInfo.RecordSize() );

        Borrowed.SetMaybeNew( wid );
        COnDiskPropertyRecord * prec = Borrowed.Get();

        _PropStoreInfo.SetMaxWorkId( wid + cWid - 1 );

#if CIDBG==1
        if ( prec->IsInUse() )
        {
            ciDebugOut(( DEB_ERROR, "Wid (0x%X) pRec (0x%X) is in use.\n",
                         wid, prec ));
//          Win4Assert( !"InUse bit must not be set here" );
        }

        if ( prec->IsTopLevel() )
        {
            ciDebugOut(( DEB_ERROR, "Wid (0x%X) pRec (0x%X) is top level record.\n",
                         wid, prec ));
//          Win4Assert( !prec->IsTopLevel() );
        }
#endif // CIDBG==1

        InitNewRecord( wid, cWid, prec, fTopLevel, fBackup );
    }

    return wid;
}


//+---------------------------------------------------------------------------
//
//  Member:     CPropertyStore::Transfer, private
//
//  Synopsis:   Transfer complete contents to new store.
//
//  Arguments:  [Target]    -- Target property store.
//              [pid]       -- Property to transfer first.  Must be on every
//                             record.
//              [fAbort]    -- Set this variable to TRUE to abort transfer.
//              [pProgress] -- Progress reported here.
//
//  History:    16-Jan-96   KyleP       Created.
//              19-Sep-97   KrishnaN    Disabled record transfer during backup.
//
//  Notes:      For progress notification, we are assuming that copying the
//              top level takes about 50% of the time and the remaining 50%
//              is for the properties other than the first property.
//
//----------------------------------------------------------------------------

void CPropertyStore::Transfer( CPropertyStore & Target, PROPID pid,
                               BOOL & fAbort,
                               IProgressNotify * pProgress )
{

    //
    // Make Sure that the pid specified is a valid pid and is of fixed
    // length. If it is of variable length, that property may overflow
    // the top level records. If that happens, we cannot guarantee retaining
    // the same top level wid number in the new propstore.
    //
    CPropDesc const * pdesc = _PropStoreInfo.GetDescription( pid );
    if ( !pdesc || !pdesc->IsFixedSize() )
    {
        ciDebugOut(( DEB_ERROR, "PropId 0x%X is not of fixed size.\n", pid ));
        THROW( CException( E_INVALIDARG ) );
    }

    //
    // Copy data from old to new.
    //

    CPropertyStoreWids iter( *this );

    PROPVARIANT  var;
    XArray<BYTE> abExtra( COMMON_PAGE_SIZE );

    //
    // Transfer special property first.  This gives same top-level workids as
    // previous situation.  Assumption: Property will *not* overflow record.
    //

    ULONG iRec = 0;
    const ULONG cTotal = _PropStoreInfo.CountRecordsInUse();
    const cUpdInterval = 500;   // every 500 records

    for ( WORKID wid = iter.WorkId(); wid != widInvalid; wid = iter.LokNextWorkId() )
    {

        if ( _fAbort || fAbort )
        {
            ciDebugOut(( DEB_WARN,"Stopping Transfer because of abort\n" ));
            THROW( CException(STATUS_TOO_LATE) );
        }

        unsigned cb = abExtra.Count();

        BOOL fOk = ReadProperty( wid, pid, var, abExtra.GetPointer(), &cb );

        Win4Assert( fOk );
        // Win4Assert( var.vt != VT_EMPTY );

        if ( fOk )
        {
            Target.WritePropertyInSpecificNewRecord( wid, pid,
                                                     *(CStorageVariant *)(ULONG_PTR)&var,
                                                     FALSE);
        }

        iRec++;
        if ( pProgress )
        {
            if ( (iRec % cUpdInterval) == 0 )
            {
                pProgress->OnProgress(
                                (DWORD) iRec,
                                (DWORD) 2*cTotal, // We are copying only the top level now
                                FALSE,  // Not accurate
                                FALSE   // Ownership of Blocking Behavior
                               );
            }
        }
    }

    Win4Assert( iRec == cTotal );

    //
    // Transfer remaining properties.
    //
    CPropertyStoreWids iter2( *this );

    iRec = 0;

    for ( wid = iter2.WorkId(); wid != widInvalid; wid = iter2.LokNextWorkId() )
    {
        if ( _fAbort || fAbort )
        {
            ciDebugOut(( DEB_WARN,"Stopping Transfer2 because of abort\n" ));
            THROW( CException(STATUS_TOO_LATE) );
        }

        for ( unsigned i = 0; i < _PropStoreInfo.CountProps(); i++ )
        {
            CPropDesc const * pdesc = _PropStoreInfo.GetDescriptionByOrdinal( i );

            if ( 0 != pdesc && pdesc->Pid() != pid )
            {
                unsigned cb = abExtra.Count();

                if ( ReadProperty( wid, pdesc->Pid(), var, abExtra.GetPointer(), &cb ) &&
                     var.vt != VT_EMPTY )
                {
                    Target.WriteProperty( wid, pdesc->Pid(),
                                          *(CStorageVariant *)(ULONG_PTR)&var,
                                          FALSE);
                }
            }
        }

        iRec++;

        if ( pProgress )
        {
            if ( (iRec++ % cUpdInterval) == 0 )
            {
                pProgress->OnProgress(
                                (DWORD) (iRec+cTotal),
                                (DWORD) 2*cTotal, // We are copying only the top level now
                                FALSE,  // Not accurate
                                FALSE   // Ownership of Blocking Behavior
                               );
            }
        }

    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CPropertyStore::FastTransfer, private
//
//  Synopsis:   Transfer complete contents to new store, without changes.
//
//  Arguments:  [Target]    -- Target property store.
//              [fAbort]    -- Set this variable to TRUE to abort transfer.
//              [pProgress] -- Progress reported here.
//
//  History:    16-Oct-97   KyleP       Created (based on ::Transfer)
//
//----------------------------------------------------------------------------

void CPropertyStore::FastTransfer( CPropertyStore & Target,
                                   BOOL & fAbort,
                                   IProgressNotify * pProgress )
{
    //
    // Just transfer the storage in bulk.  There's no modification to the
    // property store here, thus no reason to iterate by record.
    //

    CProgressTracker Tracker;

    Tracker.LokStartTracking( pProgress, &fAbort );

    _xPhysStore->MakeBackupCopy( Target._xPhysStore.GetReference(),
                                 Tracker );

    Tracker.LokStopTracking();
}

//+---------------------------------------------------------------------------
//
//  Member:     CPropertyStore::Flush
//
//  Synopsis:   Flushes the data in the property store and marks it clean.
//
//  Returns:    TRUE if the store is clean. FALSE otherwise.
//
//  History:    3-20-96   srikants   Created
//
//----------------------------------------------------------------------------

BOOL CPropertyStore::Flush()
{
    CImpersonateSystem impersonate;

    //
    // Don't reset the backup stream here.
    // That will happen in the manager.
    //

    if ( _xPhysStore.GetPointer() )
    {
        if ( !_pStorage->IsReadOnly() )
            _xPhysStore->Flush();

        if ( _fIsConsistent )
            _PropStoreInfo.MarkClean();
        else
            _PropStoreInfo.MarkDirty();
    }
    return !IsDirty();
}

//+---------------------------------------------------------------------------
//
//  Member:     CPropertyStore::AcquireRead, private
//
//  Synopsis:   Acquires read lock for a record
//
//  Arguments:  [record] -- Record
//
//  History:    19-Jan-96   KyleP       Created.
//
//----------------------------------------------------------------------------

void CPropertyStore::AcquireRead( CReadWriteLockRecord & record )
{
    #if CIDBG == 1
        DWORD tid = GetCurrentThreadId();

        if ( tid < cTrackThreads )
        {
            Win4Assert( _xPerThreadReadCounts[tid] == 0 );  // Double-read
            Win4Assert( _xPerThreadWriteCounts[tid] == 0 ); // Write before Read
        }
    #endif

    do
    {
        if ( record.isBeingWritten() )
            SyncRead( record );

        record.AddReader();

        if ( !record.isBeingWritten() )
            break;
        else
            SyncReadDecrement( record );
    } while ( TRUE );

    #if CIDBG == 1
        if ( tid < cTrackThreads )
            _xPerThreadReadCounts[tid]++;
    #endif
} //AcquireRead

//+---------------------------------------------------------------------------
//
//  Member:     CPropertyStore::SyncRead, private
//
//  Synopsis:   Helper for AcquireRead
//
//  Arguments:  [record] -- Record
//
//  History:    19-Jan-96   KyleP       Created.
//
//----------------------------------------------------------------------------

void CPropertyStore::SyncRead(
    CReadWriteLockRecord & record )
{
    do
    {
        BOOL fNeedToWait = FALSE;

        {
            CLock lock( _mtxRW );

            if ( record.isBeingWritten() )
            {
                ciDebugOut(( DEB_PROPSTORE, "READ.RESET\n" ));
                _ReSetReadTid();
                _evtRead.Reset();
                fNeedToWait = TRUE;
            }
        }

        if ( fNeedToWait )
        {
            ciDebugOut(( DEB_PROPSTORE, "READ.WAIT\n" ));
            _evtRead.Wait();
        }
    } while ( record.isBeingWritten() );
} //SyncRead

//+---------------------------------------------------------------------------
//
//  Member:     CPropertyStore::SyncReadDecrement, private
//
//  Synopsis:   Helper for AcquireRead
//
//  Arguments:  [record] -- Record
//
//  History:    19-Jan-96   KyleP       Created.
//              21-Feb-97   dlee        Rearranged to be more like
//                                      readwrit.hxx, for consistency
//
//  Notes:      The *very* important invariant of this method is that the
//              read count will be decremented once and only once.
//              The lack of this invarariant may very
//              well be the last Tripoli 1.0 bug.
//
//----------------------------------------------------------------------------

void CPropertyStore::SyncReadDecrement(
    CReadWriteLockRecord & record )
{
    BOOL fDecrementRead = TRUE;

    do
    {
        BOOL fNeedToWait = FALSE;

        {
            CLock lock( _mtxRW );

            if ( record.isBeingWritten() )
            {
                if ( fDecrementRead )
                {
                    record.RemoveReader();

                    if ( !record.isBeingRead() )
                    {
                        ciDebugOut(( DEB_PROPSTORE, "WRITE.SET\n" ));
                        _SetWriteTid();
                        _evtWrite.Set();
                    }
                }

                ciDebugOut(( DEB_PROPSTORE, "READ.RESET\n" ));
                _ReSetReadTid();
                _evtRead.Reset();
                fNeedToWait = TRUE;
            }
            else
            {
                if ( fDecrementRead )
                    record.RemoveReader();
            }

            fDecrementRead = FALSE;
        }

        if ( fNeedToWait )
        {
            ciDebugOut(( DEB_PROPSTORE, "READ.WAIT\n" ));
            _evtRead.Wait();
        }
    } while ( record.isBeingWritten() );

    Win4Assert( !fDecrementRead );
} //SyncReadDecrement

//+---------------------------------------------------------------------------
//
//  Member:     CPropertyStore::ReleaseRead, private
//
//  Synopsis:   Releases read lock for a record
//
//  Arguments:  [record] -- Record
//
//  History:    19-Jan-96   KyleP       Created.
//
//----------------------------------------------------------------------------

void CPropertyStore::ReleaseRead( CReadWriteLockRecord & record )
{
    if ( record.isBeingWritten() )
    {
        CLock lock( _mtxRW );

        record.RemoveReader();

        if ( !record.isBeingRead() )
        {
            ciDebugOut(( DEB_PROPSTORE, "WRITE.SET\n" ));
            _SetWriteTid();
            _evtWrite.Set();
        }
    }
    else
    {
        record.RemoveReader();

        if ( record.isBeingWritten() )
        {
            CLock lock( _mtxRW );

            if ( !record.isBeingRead() )
            {
                ciDebugOut(( DEB_PROPSTORE, "WRITE.SET\n" ));
                _SetWriteTid();
                _evtWrite.Set();
            }
        }
    }

    #if CIDBG == 1
        DWORD tid = GetCurrentThreadId();

        if ( tid < cTrackThreads )
            _xPerThreadReadCounts[tid]--;
    #endif
} //ReleaseRead

//+---------------------------------------------------------------------------
//
//  Member:     CPropertyStore::AcquireWrite, private
//
//  Synopsis:   Acquires write lock for a record
//
//  Arguments:  [record] -- Record
//
//  History:    19-Jan-96   KyleP       Created.
//              20-Nov-97   KrishnaN    Code reorg, but no functionality change.
//
//----------------------------------------------------------------------------

void CPropertyStore::AcquireWrite( CReadWriteLockRecord & record )
{
    #if CIDBG == 1
        DWORD tid = GetCurrentThreadId();

        if ( tid < cTrackThreads )
        {
            Win4Assert( _xPerThreadReadCounts[tid] == 0 );  // Read before Write
            Win4Assert( _xPerThreadWriteCounts[tid] == 0 ); // Double-write
        }
    #endif

    AcquireWrite2(record);

    #if CIDBG == 1
        if ( tid < cTrackThreads )
            _xPerThreadWriteCounts[tid]++;
    #endif
} //AcquireWrite

//+---------------------------------------------------------------------------
//
//  Member:     CPropertyStore::AcquireWrite2, private
//
//  Synopsis:   Acquires write lock for a record. There are no per thread
//              checks to ensure that a thread is only writing once. The
//              caller will check that.
//
//  Arguments:  [record] -- Record
//
//  History:    20-Nov-97     KrishnaN       Created.
//
//----------------------------------------------------------------------------

void CPropertyStore::AcquireWrite2( CReadWriteLockRecord & record )
{
    record.AddWriter();

    BOOL fNeedToWait = FALSE;

    {
        CLock lock( _mtxRW );

        Win4Assert( !record.LokIsBeingWrittenTwice() );

        if ( record.isBeingRead() )
        {
            ciDebugOut(( DEB_PROPSTORE, "WRITE.RESET\n" ));
            _ReSetWriteTid();
            _evtWrite.Reset();
            fNeedToWait = TRUE;
        }
    }

    if ( fNeedToWait )
    {
        ciDebugOut(( DEB_PROPSTORE, "WRITE.WAIT\n" ));
        _evtWrite.Wait();
    }

} //AcquireWrite2

//+---------------------------------------------------------------------------
//
//  Member:     CPropertyStore::ReleaseWrite, private
//
//  Synopsis:   Release write lock for a record
//
//  Arguments:  [record] -- Record
//
//  History:    19-Jan-96   KyleP       Created.
//
//----------------------------------------------------------------------------

void CPropertyStore::ReleaseWrite( CReadWriteLockRecord & record )
{
    ReleaseWrite2(record);

    #if CIDBG == 1
        DWORD tid = GetCurrentThreadId();

        if ( tid < cTrackThreads )
            _xPerThreadWriteCounts[tid]--;
    #endif
} //ReleaseWrite


//+---------------------------------------------------------------------------
//
//  Member:     CPropertyStore::ReleaseWrite2, private
//
//  Synopsis:   Release write lock for a record. No per thread tracking. The
//              caller will do that.
//
//  Arguments:  [record] -- Record
//
//  History:    20-Nov-97     KrishnaN       Created.
//
//----------------------------------------------------------------------------

void CPropertyStore::ReleaseWrite2( CReadWriteLockRecord & record )
{
    CLock lock( _mtxRW );

    record.RemoveWriter();

    ciDebugOut(( DEB_PROPSTORE, "READ.SET\n" ));
    _SetReadTid();
    _evtRead.Set();
} //ReleaseWrite2


//+---------------------------------------------------------------------------
//
//  Member:     CPropertyStore::AcquireWriteOnAllRecords, private
//
//  Synopsis:   Lock out all readers.
//
//  History:    18-Nov-97   KrishnaN       Created.
//
//----------------------------------------------------------------------------

void CPropertyStore::AcquireWriteOnAllRecords()
{
    ULONG cRecs = LockMgr().UniqueRecordCount();

    // lock down each record, one by one
    for (ULONG i = 0; i < cRecs; i++)
    {
        Win4Assert(0 == _pbRecordLockTracker[i]);

        AcquireWrite2( LockMgr().GetRecord( (WORKID) i) );

        #if CIDBG == 1
        _pbRecordLockTracker[i]++;
        #endif // CIDBG
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CPropertyStore::ReleaseWriteOnAllRecords, private
//
//  Synopsis:   Release all write locked records.
//
//  History:    18-Nov-97   KrishnaN       Created.
//
//----------------------------------------------------------------------------

void CPropertyStore::ReleaseWriteOnAllRecords()
{
    ULONG cRecs = LockMgr().UniqueRecordCount();
    for (ULONG i = 0; i < cRecs; i++)
    {
        Win4Assert( 1 == _pbRecordLockTracker[i] );
        ReleaseWrite2(LockMgr().GetRecord((WORKID)i));
    }

    #if CIDBG == 1
    RtlZeroMemory(_pbRecordLockTracker, sizeof(BYTE)*LockMgr().UniqueRecordCount());
    #endif // CIDBG
}

//+---------------------------------------------------------------------------
//
//  Member:     CPropertyStore::GetTotalSizeInKB, public
//
//  Synopsis:   Compute the size of the property store, including the backup file.
//
//  Return:     The size in KiloBytes.
//
//  History:    19-Jan-96   KyleP       Created.
//
//----------------------------------------------------------------------------

ULONG CPropertyStore::GetTotalSizeInKB()
{
    // primary store size

    ULONG cSizeInKB = 0;

    if ( !_xPhysStore.IsNull() )
        cSizeInKB += CI_PAGE_SIZE*_xPhysStore->PageSize()/1024;

    if (!_xPSBkpStrm.IsNull())
    {
        // backup store size
        cSizeInKB += roundup(_xPSBkpStrm->GetSizeInBytes(), 1024);
    }

    return cSizeInKB;
} //GetTotalSizeInKB

//+-------------------------------------------------------------------------
//
//  Member:     CiCat::ClearNonStorageProperties, public
//
//  Synopsis:   write VT_EMPTY into the properties in the PropertyStore ( 
//              except the non-modifiable ones) 
//
//  Arguments:  [rec] -- Property record for writes
//
//  History:    06-Oct-2000    KitmanH     Created
//
//--------------------------------------------------------------------------

void CPropertyStore::ClearNonStorageProperties( CCompositePropRecordForWrites & rec )
{
    CPropDesc const * pDesc = 0;
    CStorageVariant  var;
    var.SetEMPTY();

    for ( unsigned i = 0; i < _PropStoreInfo.CountDescription(); i++ )
    {
        pDesc = _PropStoreInfo.GetDescription(i);
        
        if ( 0 != pDesc && pDesc->Modifiable() )
        {
            ciDebugOut(( DEB_ITRACE, "ClearNonStorageProperties: CPropertyStore %d: about to overwrite pid %d\n", 
                         GetStoreLevel(),
                         pDesc->Pid() ));

            _propStoreMgr.WriteProperty( GetStoreLevel(),
                                         rec,
                                         pDesc->Pid(),
                                         var );
        }
#if CIDBG
        else
        {
            if ( 0 != pDesc )
                ciDebugOut(( DEB_ITRACE, "ClearNonStorageProperties: CPropertyStore %d: pid %d is !MODIFIABLE\n", 
                             GetStoreLevel(), 
                             pDesc->Pid() ));
            else
                ciDebugOut(( DEB_ITRACE, "CPropertyStore::ClearNonStorageProperties: pDesc is 0\n" ));
        }
#endif
    }
}

// CBackupWid methods

//+---------------------------------------------------------------------------
//
//  Function:   CBackupWid::BackupWid method
//
//  Synopsis:   Backup the page(s) containing the wid. If necessary, write
//              the top-level wid in the free record.
//
//  Arguments:  [wid]           -- Wid to backup.
//              [cRecsInWid]    -- Length of the wid in physical records.
//              [FieldToCommit] -- Field to commit to disk.
//              [ulValue]       -- When valid, this is the field value to
//                                 be written as part of the wid in the backup's
//                                 copy.
//              [pRec]          -- Address of the record being modified.
//
//  Returns:    Nothing.
//
//  History:    09-June-97   KrishnaN   Created
//              27-Jan-2000  KLam       Removed bogus fBackedUp asserts
//
//----------------------------------------------------------------------------


void CBackupWid::BackupWid(WORKID wid,
                           ULONG cRecsInWid,
                           EField FieldToCommit,
                           ULONG ulValue,
                           COnDiskPropertyRecord const *pRec)
{
    Win4Assert( _pPropStor );
    Win4Assert( _pPropStor->BackupStream() );

    ULONG cPages = TryDescribeWidInAPage(wid, cRecsInWid);
    cPages++;    // actual number of pages
    ULONG dSlot = _ulFirstPage;

    ciDebugOut(( DEB_PSBACKUP, "BackupWid: wid = %d (0x%x), %d recs long, FieldToCommit = %d, "
                                "Value to commit = 0x%x, pRec = 0x%x, pages needed = %d\n",
                                wid, wid, cRecsInWid, FieldToCommit, ulValue, pRec, cPages));

    //
    // If we need more than one page to describe this wid, allocate
    // space for the data structures and describe them.
    //

    BOOL fBackedUp = FALSE;
    ULONG ulOffset = 0xFFFFFFFF;

    if (1 == cPages)
    {
        fBackedUp = BackupPages(1, &_ulFirstPage, (void **)&_pbFirstPage);
        if (eFieldNone != FieldToCommit)
            DescribeField(FieldToCommit, pRec, 1, (void **)&_pbFirstPage, ulOffset);
    }
    else
    {
        CDynArrayInPlace<ULONG> adSlots(cPages);
        CDynArrayInPlace<void *> aPagePtrs(cPages);
        void const * const* paPagePtrs = aPagePtrs.GetPointer();
        DescribeWid(wid, cRecsInWid, adSlots, aPagePtrs);
        fBackedUp = BackupPages(cPages, adSlots.GetPointer(), paPagePtrs);

        // reuse dSlot
        if (eFieldNone != FieldToCommit)
            dSlot = adSlots[DescribeField(FieldToCommit, pRec, cPages, paPagePtrs, ulOffset)];
    }

    //
    // commit the widTopLevel to top-level field of free record to disk
    // At this point the page has already been commited to backup, so it should be there.
    //

    if (fBackedUp && eFieldNone != FieldToCommit)
        fBackedUp = _pPropStor->BackupStream()->CommitField(dSlot, ulOffset, sizeof(WORKID), &ulValue);

    // Throw the error that caused file i/o to fail!
    if (!fBackedUp)
    {
        ciDebugOut(( DEB_ERROR, "Unexpected error writing a page to the backup file!"));
        THROW( CException() );
    }
 }

//+---------------------------------------------------------------------------
//
//  Member:     CBackupWid::TryDescribeWidInAPage, public
//
//  Synopsis:   Determine the OS pages containing the wids and the location of
//              the first wid in each OS page.
//
//  Arguments:  [wid]        -- Wid to describe.
//              [cRecsInWid] -- Number of records in wid.
//
//  Returns:    The number of additional OS pages needed for the wid. The caller
//              should use DescribeWids if the return value is > 0.
//
//  History:    09-Jun-97   KrishnaN       Created.
//
//----------------------------------------------------------------------------

inline ULONG CBackupWid::TryDescribeWidInAPage(WORKID wid,
                                               ULONG cRecsInWid)
{
    Win4Assert(widInvalid != wid );

    // Determine the first and last OS pages, relative to start of property store file, which contain wid
    ComputeOSPageLocations(wid, cRecsInWid, &_ulFirstPage, &_ulLastPage);
    _nLargePage = _ulFirstPage/_pPropStor->OSPagesPerPage();
    // this wid should be within a large page. Assert that.
    Win4Assert(_nLargePage == _ulLastPage/_pPropStor->OSPagesPerPage());
    _pbFirstPage = GetOSPagePointer(_ulFirstPage);

    return (_ulLastPage - _ulFirstPage);
}

//+---------------------------------------------------------------------------
//
//  Member:     CBackupWid::DescribeWids, public
//
//  Synopsis:   Determine the OS pages containing the wids.
//
//  Arguments:  [Wid]        -- Wid to describe.
//              [cRecsInWid] -- Count of records in wid.
//              [pcPages]    -- Number of pages.
//              [pulPages]   -- Dynamic array of page descriptors.
//              [ppvPages]   -- Dynamic array of page pointers to be backedup.
//
//  Returns:    Index into hash table (_aProp) of pid, or first unused
//              entry on chain if pid doesn't exist.
//
//  Notes:   Using this requires at least two dynamic allocations on the heap.
//           If that is deemed expensive, we can attempt to describe only one
//           wid at a time using TryDescribeWibInAPage.
//
//  History:    09-Jun-97   KrishnaN       Created.
//
//----------------------------------------------------------------------------

inline void CBackupWid::DescribeWid( WORKID wid,
                                     ULONG cRecsInWid,
                                     CDynArrayInPlace<ULONG> &pulPages,
                                     CDynArrayInPlace<void *> &ppvPages)
{
    Win4Assert(widInvalid != wid );
    // First and last page and the first page ptr should have already
    // been computed by calling TryDescribeWidInAPage
    Win4Assert(_ulFirstPage != 0xFFFFFFFF && _ulLastPage != 0xFFFFFFFF);
    Win4Assert(_pbFirstPage);
    Win4Assert(_ulLastPage > _ulFirstPage);

    ULONG cPages, page;
    for (page = _ulFirstPage, cPages = 0;
         page <= _ulLastPage;
         page++, cPages++)
    {
        pulPages[cPages] = page;
        ppvPages[cPages] = _pbFirstPage + cPages*_pPropStor->OSPageSize();
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   CBackupWid::BackupPages, public
//
//  Synopsis:   Backup pages. If space is not available for backup,
//
//  Arguments:  [cPages]   -- Number of pages to backup.
//              [pSlots]   -- Array of page descriptors.
//              [ppbPages] -- Array of page pointers to backup.
//
//  Returns:    TRUE if the pages were successfully backed up.
//              FALSE otherwise.
//
//  History:    09-June-97   KrishnaN   Created
//
//----------------------------------------------------------------------------

BOOL CBackupWid::BackupPages(ULONG cPages,
                             ULONG const *pulPages,
                             void const * const * ppvPages)
{
    Win4Assert(cPages && ppvPages && pulPages);
    Win4Assert( _pPropStor->BackupStream() );

    ciDebugOut(( DEB_PSBACKUP, "BackupPages: About to backup %2d pages: ", cPages));
#if CIDBG
        // We should have no more than 16 pages to backup because that is the max
        // a property can straddle (a prop is limited to a 64K common page size). On
        // alpha the max is only 8.
        Win4Assert(cPages <= 16);

        WCHAR szBuff[2048];
        szBuff[0] = 0;

        for (ULONG j = 0; j < cPages; j++)
        {
            WCHAR szPage[100];
            swprintf(szPage, L"%10d, 0x%x; ", pulPages[j], ppvPages[j]);
            wcscat(szBuff, szPage);
        }

        ciDebugOut((DEB_PSBACKUP, "%ws\n", szBuff));
#endif // CIDBG

    // Commit pages.
    BOOL fOK;
    if (1 == cPages)
        fOK = _pPropStor->BackupStream()->CommitPage(pulPages[0], ppvPages[0]);
    else
        fOK = _pPropStor->BackupStream()->CommitPages(cPages, pulPages, ppvPages);

    if (fOK)
        return TRUE;

    // Not enough space to commit pages. Flush the property store
    // and try again.
    ciDebugOut((DEB_PSBACKUP, "Flushing the property store to make space for pages.\n"));

    _pPropStor->_propStoreMgr.Flush();

    if (1 == cPages)
        return _pPropStor->BackupStream()->CommitPage(pulPages[0], ppvPages[0]);
    else
        return _pPropStor->BackupStream()->CommitPages(cPages, pulPages, ppvPages);
}

//+---------------------------------------------------------------------------
//
//  Function:   CBackupWid::GetOSPagePointer, private
//
//  Synopsis:   Get the OS page pointer for the given page.
//
//  Arguments:  [ulPage]   -- i-th OS page (0-based index) of prop store.
//
//  Returns:    A memory pointer to the specified page.
//
//  History:    09-June-97   KrishnaN   Created
//
//  Notes: This will be returning read-only pages.
//
//----------------------------------------------------------------------------

inline BYTE * CBackupWid::GetOSPagePointer(ULONG ulPage)
{
    PBYTE pLargePage = (PBYTE)_pPropStor->PhysStore()->BorrowLargeBuffer(
                                                     ulPage/_pPropStor->OSPagesPerPage(),
                                                     FALSE,
                                                     FALSE );
    return (pLargePage + _pPropStor->OSPageSize()*(ulPage%_pPropStor->OSPagesPerPage()));
}

//+---------------------------------------------------------------------------
//
//  Function:   CBackupWid::ComputeOSPageLocations, private
//
//  Synopsis:   Compute the os pages containing the given wid..
//
//  Arguments:  [wid]        -- wid in question
//              [cRecsInWid] -- # of records in wid
//              [pFirstPage] -- Ptr where first page's loc should be stored
//              [pLastLage]  -- Ptr where last page's loc should be stored
//
//  Returns:    A memory pointer to the specified page.
//
//  History:    09-June-97   KrishnaN   Created
//
//  Notes: This will be returning read-only pages.
//
//----------------------------------------------------------------------------

inline void CBackupWid::ComputeOSPageLocations(WORKID wid, ULONG cRecsInWid,
                                               ULONG *pFirstPage, ULONG *pLastPage)
{
    // Determine the i-th large page and the position of wid in the large page
    ULONG nLargePage = wid / _pPropStor->RecordsPerPage();
    ULONG widInLargePage = wid % _pPropStor->RecordsPerPage();

    *pFirstPage =  nLargePage*_pPropStor->OSPagesPerPage() +
                   (widInLargePage * _pPropStor->RecordSize() * sizeof(ULONG))/_pPropStor->OSPageSize();
    *pLastPage  =  nLargePage*_pPropStor->OSPagesPerPage() +
                   ((widInLargePage+cRecsInWid)*_pPropStor->RecordSize()*4 - 1)/_pPropStor->OSPageSize();
}

//+---------------------------------------------------------------------------
//
//  Function:   CBackupWid::DescribeField, private
//
//  Synopsis:   Obtain the location of the top-level field in the list of pages.
//
//  Arguments:  [FieldToCommit] -- Field to commit. Should not be eFieldNone.
//              [pRec]          -- Address of the record being modified.
//              [cPages]        -- Number of pages in the list of pages.
//              [ppvPages]      -- List of pages.
//              [pulOffset]     -- Ptr to location containing offset of field.
//
//  Returns:    i-th page in the ppvPages array that has the field.
//
//  History:    09-June-97   KrishnaN   Created
//
//----------------------------------------------------------------------------

ULONG CBackupWid::DescribeField( EField FieldToCommit,
                                 COnDiskPropertyRecord const *pRec,
                                 ULONG cPages,
                                 void const * const* ppvPages,
                                 ULONG &ulOffset)
{
    Win4Assert(eFieldNone != FieldToCommit);
    Win4Assert(!pRec->IsLeanRecord());  // no need to do this for lean records!
    ulOffset = 0xFFFFFFFF;

    void const *pvFieldLoc = 0;

    switch (FieldToCommit)
    {
        case eTopLevelField:
            pvFieldLoc = pRec->GetTopLevelFieldAddress();
            break;

        case eFieldNone:
        default:
            Win4Assert(!"Invalid field to describe!");
            return 0xFFFFFFFF;
    }

    // We have the pointer to the wid field. Now identify the page it belongs to,

    for (ULONG i = 0; i < cPages; i++)
        if (pvFieldLoc >= ppvPages[i] &&
            pvFieldLoc < (PVOID)(PBYTE(ppvPages[i]) + _pPropStor->OSPageSize()))
            break;

    Win4Assert( i < cPages );

    ulOffset = (ULONG) ((PBYTE)pvFieldLoc - (PBYTE)ppvPages[i]);
    return i;
}

//+---------------------------------------------------------------------------
//
//  Member:     Constructor for the CPropertyStoreRecovery method
//
//  Arguments:  [propStore] -
//
//  History:    4-10-96   srikants   Created
//
//----------------------------------------------------------------------------

CPropertyStoreRecovery::CPropertyStoreRecovery( CPropertyStore & propStore,
                                                T_UpdateDoc pfnUpdateCallback,
                                                void const *pUserData)
: _propStore(propStore),
  _PropStoreInfo(propStore._PropStoreInfo),
  _wid(1),
  _pRec(0),
  _cRec(0),
  _widMax(0),
  _cTopLevel(0),
  _cInconsistencies(0),
  _cForceFreed(0),
  _pageTable( 10 ),
  _fnUpdateCallback( pfnUpdateCallback ),
  _pUserData( pUserData )
{
    _pPhysStore = propStore._xPhysStore.GetPointer();
    _cRecPerPage = _PropStoreInfo.RecordsPerPage();
    _aFreeBlocks = new WORKID[ _PropStoreInfo.RecordsPerPage() + 1 ];
    RtlZeroMemory( _aFreeBlocks,
                   (_PropStoreInfo.RecordsPerPage()+1) * sizeof (WORKID) );

    // Open the backup stream in read mode for recovery

    WORKID wid = _PropStoreInfo.WorkId();
    if (widInvalid != wid)
    {
        SStorageObject xobj( _propStore.GetStorage().QueryObject( wid ) );
        _xPSBkpStrm.Set(_propStore.GetCiStorage().OpenExistingPSBkpStreamForRecovery(
                                          xobj.GetObj(), propStore.GetStoreLevel() ));
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CPropertyStoreRecovery::~CPropertyStoreRecovery, public
//
//  Synopsis:   Destructor of the CPropertyStoreRecovery.
//
//  Notes:      In a successful recovery, the _aFreeBlocks will be transferred
//              to the CPropertyStore class.
//
//  History:    10 May 96   AlanW       Created.
//
//----------------------------------------------------------------------------

CPropertyStoreRecovery::~CPropertyStoreRecovery()
{
    delete _aFreeBlocks;
}


//+---------------------------------------------------------------------------
//
//  Member:     CPropertyStoreRecovery::AddToFreeList, private
//
//  Synopsis:   Add a free record to a free list.
//
//  Arguments:  [widFree]     -- Workid of record to free
//              [cFree]       -- Number of records in freed chunk
//              [precFree]    -- On-disk Property record
//              [widListHead] -- Start of free list
//
//  Returns:    WORKID - new start of list
//
//  Notes:      All blocks in the free list passed are assumed to be of
//              the same length.
//
//  History:    01 May 96   AlanW       Created.
//
//----------------------------------------------------------------------------

WORKID CPropertyStoreRecovery::AddToFreeList( WORKID widFree,
                                              ULONG cFree,
                                              COnDiskPropertyRecord * precFree,
                                              WORKID widListHead )
{
    if ( widListHead != 0 )
    {
        CBorrowed Borrowed( *_pPhysStore,
                            widListHead,
                            _PropStoreInfo.RecordsPerPage(),
                            _PropStoreInfo.RecordSize() );
        COnDiskPropertyRecord * prec = Borrowed.Get();

        Win4Assert( prec->CountRecords() == cFree );
        Win4Assert( prec->GetNextFreeRecord() == 0 ||
                    prec->GetNextFreeSize() == cFree );

        prec->SetPreviousFreeRecord( widFree );
    }

    //
    //  Insert new record at beginning of list
    //

    if (eLean == _PropStoreInfo.GetRecordFormat())
        precFree->MakeLeanFreeRecord( cFree,
                                      widListHead,
                                      widListHead==0? 0 : cFree,
                                      _PropStoreInfo.RecordSize() );
    else
        precFree->MakeNormalFreeRecord( cFree,
                                        widListHead,
                                        widListHead==0? 0 : cFree,
                                        _PropStoreInfo.RecordSize() );

    return widFree;
}


//+---------------------------------------------------------------------------
//
//  Member:     CPropertyStoreRecovery::SetFree
//
//  Synopsis:   Marks the current record as free for _cRec length of
//              records.
//
//  History:    4-10-96   srikants   Created
//
//----------------------------------------------------------------------------

void CPropertyStoreRecovery::SetFree()
{
    Win4Assert( _pRec );
    Win4Assert( _cRec <= _PropStoreInfo.RecordsPerPage() );

    _aFreeBlocks[_cRec] = AddToFreeList( _wid,
                                         _cRec,
                                         _pRec,
                                         _aFreeBlocks[_cRec] );
}

//+---------------------------------------------------------------------------
//
//  Member:     CPropertyStoreRecovery::CheckOverflowChain
//
//  Synopsis:   Verify and fix the forward length links.
//
//  History:    4-10-96   srikants   Created
//
//----------------------------------------------------------------------------

BOOL CPropertyStoreRecovery::CheckOverflowChain()
{
    Win4Assert( _pRec->IsNormalTopLevel() );

    CBorrowed   Borrowed( *_pPhysStore,
                         _wid,
                         _PropStoreInfo.RecordsPerPage(),
                         _PropStoreInfo.RecordSize() );
    COnDiskPropertyRecord * prec = Borrowed.Get();

    ULONG cOverflowBlocks = 0;

    BOOL fIsConsistent = TRUE;

    for ( WORKID widOvfl = prec->OverflowBlock();
          0 != widOvfl;
          widOvfl = prec->OverflowBlock() )
    {
        if ( widOvfl > _widMax )
        {
            ciDebugOut(( DEB_ERROR,
                         "widOvfl (0x%X) > widMax (0x%X)\n",
                          widOvfl, _widMax ));

            fIsConsistent = FALSE;
            break;
        }

        Borrowed.Release();
        Borrowed.Set( widOvfl );
        prec = Borrowed.Get();

        //
        // If this is not marked as an overflow record, what should we do?
        //
        if ( !prec->IsOverflow() )
        {
            ciDebugOut(( DEB_WARN, "Wid (0x%X) should be an overflow record, but not!\n",
                         widOvfl ));
            fIsConsistent = FALSE;
            break;
        }

        //
        // Check the validity of the toplevel pointers.
        //
        if ( prec->ToplevelBlock() != _wid )
        {
            ciDebugOut(( DEB_WARN, "Changing the toplevel wid of (0x%X) from (0x%X) to (0x%X)\n",
                         widOvfl, prec->ToplevelBlock(), _wid ));
            fIsConsistent = FALSE;
            break;
        }

        cOverflowBlocks++;
    }

    if ( fIsConsistent )
    {
        fIsConsistent = cOverflowBlocks == _pRec->GetOverflowChainLength();
        if (!fIsConsistent)
        {
            ciDebugOut(( DEB_WARN, "Overflow length for toplevel wid %d(0x%x) is %d. Expected %d\n",
                         _wid, _wid, cOverflowBlocks, _pRec->GetOverflowChainLength() ));
        }
    }

    return fIsConsistent;
}

//+---------------------------------------------------------------------------
//
//  Member:     CPropertyStoreRecovery::FreeChain, private
//
//  Synopsis:   Free an overflow record chain to the free list
//
//  History:    02 May 96   AlanW      Added header
//
//----------------------------------------------------------------------------

void CPropertyStoreRecovery::FreeChain( )
{
    Win4Assert(!_pRec->IsLeanRecord());

    if ( !_pRec->IsTopLevel() )
    {
        ciDebugOut(( DEB_WARN, "Ignore chain with non-top-level wid (0x%X)\n", _wid ));
        return;
    }

    ciDebugOut(( DEB_WARN, "Freeing chain with wid (0x%X)\n", _wid ));

    BOOL fOverflow = FALSE;
    WORKID  wid = _wid;

    CBorrowed   Borrowed( *_pPhysStore,
                         _PropStoreInfo.RecordsPerPage(),
                         _PropStoreInfo.RecordSize() );

    while ( 0 != wid && wid <= _widMax )
    {
        Borrowed.Release();
        Borrowed.Set(wid);

        COnDiskPropertyRecord * prec = Borrowed.Get();

        if ( fOverflow )
        {
            if ( !prec->IsOverflow() )
            {
                ciDebugOut(( DEB_WARN,
                             "Ignore chain with non-overflow wid (0x%X)\n",
                             _wid ));
                break;
            }
        }
        else
            fOverflow = TRUE;

        ciDebugOut(( DEB_PROPSTORE,
                     "Force freeing up wid (0x%X) prec (0x%X)\n",
                     wid, prec ));

        WORKID widNext = prec->OverflowBlock();
        ULONG cRec = prec->CountRecords();
        if ( ! prec->IsValidLength( wid, _cRecPerPage ) )
        {
            ciDebugOut(( DEB_WARN,
                         "Ignore chain with invalid block size (0x%X)\n",
                         _wid ));

            cRec = 1;
            widNext = 0;
        }

        _aFreeBlocks[cRec] = AddToFreeList( wid, cRec, prec, _aFreeBlocks[cRec] );
        _cForceFreed++;
        wid = widNext;
    }

    _cTopLevel--;
}

//+---------------------------------------------------------------------------
//
//  Member:     CPropertyStoreRecovery::Pass0
//
//  Synopsis:   Restore sections of the property store from the backup file.
//
//  History:    12-Jun-97   KrishnaN   Created
//
//----------------------------------------------------------------------------

void CPropertyStoreRecovery::Pass0()
{
    if (!_xPSBkpStrm->IsOpenForRecovery())
    {
        ciDebugOut((DEB_WARN, "PROPSTORE: Backup file is not available for recovery.\n"));
        return;
    }

    ULONG cPages = _xPSBkpStrm->Pages();
    _pageTable.Reset(cPages);

    // Remember that the property store could have been moved from a different architecture.
    ULONG cPageSize = _xPSBkpStrm->PageSize();
    if (0 != COMMON_PAGE_SIZE%cPageSize)
    {
        ciDebugOut((DEB_WARN, "PROPSTORE: Backup file's page size (%d) is not compatible with "
                              "the large page size (%d) used by prop store.\n",
                              cPageSize, COMMON_PAGE_SIZE));
        return;
    }

    ULONG cCustomPagesPerLargePage = COMMON_PAGE_SIZE/cPageSize;

    // Read each page from the backup and graft those pages at the appropriate location
    // in the property store.

    for (ULONG i = 0; i < cPages; i++)
    {
        ULONG ulLoc = _xPSBkpStrm->GetPageLocation(i);
        if (invalidPage == ulLoc)
        {
            Win4Assert(!"How did we get an invalid page in backup!");
            ciDebugOut((DEB_PSBACKUP, "Page %d in backup is invalid.\n", i));
            continue;
        }
        _pageTable.AddEntry(ulLoc);

        // takes care of borrowing/returning large page and actual copy of page
        // from backup to primary
        CGraftPage graftPage(i, ulLoc, cPageSize, cCustomPagesPerLargePage,
                             _pPhysStore, _xPSBkpStrm.GetPointer());
    }

    // Close it now. We will open it again later, most likely for backup.
    _xPSBkpStrm->Close();
}

//+---------------------------------------------------------------------------
//
//  Member:     CPropertyStoreRecovery::Pass1
//
//  Synopsis:   Perform the pass1 recovery operation.
//
//  History:    4-10-96   srikants   Created
//              6-16-97   KrishnaN   Modified to enumerate wids in backed
//                                   up pages as part of the pass.
//
//----------------------------------------------------------------------------

void CPropertyStoreRecovery::Pass1()
{
    Win4Assert(_fnUpdateCallback);
    CPageHashTable widsRefiltered(_xPSBkpStrm->Pages()+1);

    //
    // Extract the pidLastSeenTime info.
    //
    CPropDesc const * pFTDesc =
                        _PropStoreInfo.GetDescription( pidLastSeenTime );
    FILETIME    ftLastSeen;
    RtlZeroMemory( &ftLastSeen, sizeof(ftLastSeen) );
    CStorageVariant varFtLast( ftLastSeen );

    if ( _pPhysStore->PageSize() > 0 )
    {
        ULONG cCustomPagesPerLargePage = COMMON_PAGE_SIZE/_xPSBkpStrm->PageSize();

        ULONG  cLargePages = (_PropStoreInfo.MaxWorkId() / _PropStoreInfo.RecordsPerPage()) + 1;

        Win4Assert( cLargePages <= _pPhysStore->PageSize() / (COMMON_PAGE_SIZE / CI_PAGE_SIZE) );

        //
        // Loop through and rebuild free list and max workid.
        //
        CBorrowed Borrowed( *_pPhysStore, _PropStoreInfo.RecordsPerPage(),
                            _PropStoreInfo.RecordSize() );

        while ( TRUE )
        {

            if ( _propStore._fAbort )
            {
                ciDebugOut(( DEB_WARN,
                             "Stopping Restore because of abort\n" ));
                THROW( CException(STATUS_TOO_LATE) );
            }

            //
            // End of file?
            //

            ULONG nLargePage = _wid / _PropStoreInfo.RecordsPerPage();

            if ( nLargePage >= cLargePages )
                break;

            //
            // Valid record.
            //
            Borrowed.Release();
            Borrowed.Set( _wid );

            CLockRecordForWrite recLock( _propStore, _wid );

            _pRec = Borrowed.Get();

            //
            // If this wid falls in one of the backed up pages we should
            // enumerate it. Wids in backup should be scheduled for
            // re-filtering and if necessary, deleted.
            //

            // compute i-th custom page based on other params
            ULONG nCustomPage = nLargePage*cCustomPagesPerLargePage +
                                (_PropStoreInfo.RecordSize()*sizeof(ULONG)*(_wid%_PropStoreInfo.RecordsPerPage())) /
                                _xPSBkpStrm->PageSize();

            if ( _pRec->IsValidInUseRecord(_wid, _cRecPerPage) )
            {
                WORKID widToplevel;

                _cRec = _pRec->CountRecords();

                //
                // If this is a topLevel record, set the pidLastSeenTime to 0.
                //
                if ( _pRec->IsTopLevel() )
                {
                    widToplevel = _wid;

                    //
                    // Set the pidLastSeenTime to 0
                    //
                    if ( pFTDesc )
                    {
                        // We should be doing this only in the store containing pidLastSeenTime.
                        Win4Assert(PRIMARY_STORE == _PropStoreInfo.GetStoreLevel());
                        _pRec->WriteFixed( pFTDesc->Ordinal(),
                                           pFTDesc->Mask(),
                                           pFTDesc->Offset(),
                                           pFTDesc->Type(),
                                           _PropStoreInfo.CountProps(),
                                           varFtLast );
                    }

                    _cTopLevel++;

                }
                else
                {
                    Win4Assert( eNormal == _PropStoreInfo.GetRecordFormat() );

                    widToplevel = _pRec->ToplevelBlock();
                    Win4Assert( _pRec->IsOverflow() );

                    ciDebugOut(( DEB_PROPSTORE,
                                 "PROPSTORE: Overflow Record 0x%X\n",
                                 _wid ));
                }
                _widMax = _wid+_cRec-1;

                // If this wid is in a backed up page we should
                // schedule the top-level wid for re-filtering.

                if (_pageTable.LookUp(nCustomPage))
                {

                    ULONG ul;
                    // Refilter it if it has not already been
                    if (!widsRefiltered.LookUp((ULONG)widToplevel, ul))
                    {
                        _fnUpdateCallback(widToplevel, FALSE, _pUserData);

                        ciDebugOut((DEB_PSBACKUP, "Wid %d (0x%x) in custom page %d scheduled for re-filtering.\n",
                                           widToplevel, widToplevel, nCustomPage));

                        widsRefiltered.AddEntry((ULONG)widToplevel, 0);
                    }
                }
            }
            else
            {
                // This assert could go off in case of file corruption.
                Win4Assert(!_pRec->IsInUse());

                // For the Normal Format records:
                //  If this wid is in a backed up page and points to the wid
                //  occupying its place in the primary, we should delete the
                //  occupying wid.
                //
                // For the Lean Format records:
                //  We do not store the top-level wid of the occupying wid for lean records.
                //  Each lean record is only "one record" long. So every displaced
                //  free record was displaced by a newly indexed document. Since we
                //  delete newly indexed docs as part of restore, we need to delete
                //  _wid if it is found in the backup.
                //

                if (_pageTable.LookUp(nCustomPage))
                {
                    if (eNormal == _PropStoreInfo.GetRecordFormat() && _pRec->ToplevelBlock() == _wid)
                    {
                        _pRec->ClearToplevelField();

                        ciDebugOut((DEB_PSBACKUP, "Wid %d (0x%x) in page %d scheduled for deletion\n",
                                    _wid, _wid, nCustomPage));

                        _fnUpdateCallback(_wid, TRUE, _pUserData);

                    }
                    else if (eLean == _PropStoreInfo.GetRecordFormat())
                    {
                        ciDebugOut((DEB_PSBACKUP, "Wid %d (0x%x) in page %d scheduled for deletion\n",
                                    _wid, _wid, nCustomPage));

                        _fnUpdateCallback(_wid, TRUE, _pUserData);
                    }
                }

                if ( _pRec->IsFreeRecord() &&
                     _pRec->IsValidLength(_wid, _cRecPerPage) )
                {
                    _cRec = _pRec->CountRecords();
                }
                else
                {
                    _cRec = 1;
                }

                //
                // coalesce any adjacent free blocks.
                //
                CBorrowed BorrowedNext( *_pPhysStore,
                                         _PropStoreInfo.RecordsPerPage(),
                                         _PropStoreInfo.RecordSize() );
                WORKID widNext = _wid + _cRec;
                BOOL fCoalesced = FALSE;
#if CIDBG
                WCHAR wszDeletedWids[4096];
                wszDeletedWids[0] = 0;
                short cWritten = 0;
#endif // CIDBG

                while ( widNext % _cRecPerPage != 0 )
                {

                    BorrowedNext.Set( widNext );
                    COnDiskPropertyRecord * precNext = BorrowedNext.Get();

                    // Schedule the wid for deletion or re-filtering as appropriate
                    if (precNext->IsInUse())
                        break;

                    // compute i-th custom page based on other params
                    nCustomPage = nLargePage*cCustomPagesPerLargePage +
                                (_PropStoreInfo.RecordSize()*sizeof(DWORD)*(widNext%_PropStoreInfo.RecordsPerPage())) /
                                _xPSBkpStrm->PageSize();
                    if (_pageTable.LookUp(nCustomPage))
                    {
                    #if CIDBG == 1
                        BOOL fDump = TRUE;
                    #endif // CIDBG
                        if (eNormal == _PropStoreInfo.GetRecordFormat() && precNext->ToplevelBlock() == widNext)
                        {
                            precNext->ClearToplevelField();
                            _fnUpdateCallback(widNext, TRUE, _pUserData);
                        }
                        else if (eLean == _PropStoreInfo.GetRecordFormat())
                        {
                            _fnUpdateCallback(widNext, TRUE, _pUserData);
                        }
                    #if CIDBG == 1
                        else
                            fDump = FALSE;

                        if (fDump)
                        {
                            // Writing individual wids to debugout is
                            // overwhelming it. So batch up a few at a time.
                            WCHAR szbuff[12];
                            swprintf(szbuff, L"%d,", widNext);
                            wcscat(wszDeletedWids, szbuff);
                            cWritten++;
                            if (cWritten % 32 == 0)
                            {
                                ciDebugOut((DEB_PSBACKUP, "Scheduled the following %d wids for deletion\n", cWritten));
                                ciDebugOut((DEB_PSBACKUP, "%ws\n", wszDeletedWids));
                                cWritten = 0;
                                wszDeletedWids[0] = 0;
                            }
                        }
                    #endif // CIDBG
                    }

                    if ( precNext->IsFreeRecord() &&
                         precNext->IsValidLength(_wid, _cRecPerPage) )
                        _cRec += precNext->CountRecords();
                    else if ( !precNext->IsInUse() )
                        _cRec += 1;
                    else
                        break;

                    fCoalesced = TRUE;
                    widNext = _wid + _cRec;
                    BorrowedNext.Release();
                }

#if CIDBG
                if (cWritten > 0 && cWritten < 32)
                {
                    ciDebugOut((DEB_PSBACKUP, "Scheduled the following %d wids for deletion\n", cWritten));
                    ciDebugOut((DEB_PSBACKUP, "%ws\n", wszDeletedWids));
                    cWritten = 0;
                    wszDeletedWids[0] = 0;
                }
#endif // CIDBG

                if (fCoalesced)
                {
                    ciDebugOut(( DEB_PROPSTORE,
                                 "PROPSTORE: Coalesced free records 0x%X(%d)\n",
                                 _wid, _cRec ));
                }
                SetFree();
            }

            _wid += _cRec;
        }
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CPropertyStoreRecovery::Pass2
//
//  Synopsis:   Pass2 of the recovery phase.
//
//  History:    4-10-96   srikants   Created
//
//  NTRAID#DB-NTBUG9-84467-2000/07/31-dlee Indexing Service property store doesn't checked for orphaned overflow chains
//
//----------------------------------------------------------------------------

void CPropertyStoreRecovery::Pass2()
{
    ciDebugOut(( DEB_WARN, "PROPSTORE: Recovery Pass2\n" ));

    if ( _pPhysStore->PageSize() > 0 )
    {
        ULONG  cLargePages = _pPhysStore->PageSize() / (COMMON_PAGE_SIZE / CI_PAGE_SIZE);

        //
        //  Check each top-level record for consistency
        //
        CBorrowed Borrowed( *_pPhysStore, _PropStoreInfo.RecordsPerPage(),
                            _PropStoreInfo.RecordSize() );

        _wid = 1;

        while ( TRUE )
        {
            if ( _propStore._fAbort )
            {
                ciDebugOut(( DEB_WARN,
                             "Stopping Restore because of abort\n" ));
                THROW( CException(STATUS_TOO_LATE) );
            }

            //
            // End of file?
            //

            ULONG nLargePage = _wid / _PropStoreInfo.RecordsPerPage();

            if ( nLargePage >= cLargePages )
                break;

            //
            // Valid record.
            //
            Borrowed.Release();
            Borrowed.Set( _wid );

            CLockRecordForWrite recLock( _propStore, _wid );

            _pRec = Borrowed.Get();
            _cRec = _pRec->CountRecords();

            // There is no overflow chaining involved in a property store
            // made up of lean records, so check that only for normal records.
            if ( _pRec->IsNormalTopLevel() )
            {
                if ( !CheckOverflowChain() )
                {
                    //
                    // Free up this workid.
                    //
                    _cInconsistencies++;
                    FreeChain();
                }
            }

            _wid += _cRec;
        }
    }
}


//+---------------------------------------------------------------------------
//
//  Member:     CPropertyStoreRecovery::Complete
//
//  Synopsis:   Complete the recovery operation.
//
//  History:    4-10-96   srikants   Created
//
//----------------------------------------------------------------------------

void CPropertyStoreRecovery::Complete()
{

    //
    //  Now chain all the free lists together and remove entries that
    //  are beyond _widMax.
    //

    WORKID widFreeListHead = 0;
    WORKID widFreeListTail = 0;

    COnDiskPropertyRecord * prec = 0;
    COnDiskPropertyRecord * precPrev = 0;

    CBorrowed Borrowed( *_pPhysStore,
                        _PropStoreInfo.RecordsPerPage(),
                        _PropStoreInfo.RecordSize() );
    CBorrowed BorrowedPrev( *_pPhysStore,
                            _PropStoreInfo.RecordsPerPage(),
                            _PropStoreInfo.RecordSize() );

    for (unsigned cSize = _PropStoreInfo.RecordsPerPage(); cSize >= 1; cSize-- )
    {
        WORKID wid = _aFreeBlocks[ cSize ];

        // Skip to the first valid block in the free list
        while ( wid != 0 && wid > _widMax )
        {
            Borrowed.Set( wid );
            prec = Borrowed.Get();
            ciDebugOut(( DEB_PROPSTORE,
                         "  Tossing free entry %x(%d)\n",
                         wid, prec->CountRecords() ));
            wid = prec->GetNextFreeRecord();
            prec->ClearAll( _PropStoreInfo.RecordSize() );
            Borrowed.Release();
        }
        _aFreeBlocks[ cSize ] = wid;
        if ( wid == 0 )
            continue;

        Borrowed.Set( wid );
        prec = Borrowed.Get();

        //
        // Found a valid wid.  Splice this list to the previous list
        //
        if (widFreeListHead == 0)
            widFreeListHead = wid;
        else
        {
            Win4Assert( widFreeListTail != 0 &&
                        precPrev != 0 );
            prec->SetPreviousFreeRecord( widFreeListTail );
            precPrev->SetNextFree( wid, cSize );
        }

        WORKID widPrev = widFreeListTail;
        widFreeListTail = wid;

        while (wid != 0)
        {
            BorrowedPrev.Release();
            BorrowedPrev = Borrowed;
            precPrev = prec;

            Borrowed.Set( wid );
            prec = Borrowed.Get();

            while ( wid != 0 && wid > _widMax )
            {
                //
                // Remove an entry > widMax from the list
                //
                ciDebugOut(( DEB_PROPSTORE,
                             "  Tossing free entry %x(%d)\n",
                             wid, prec->CountRecords() ));
                wid = prec->GetNextFreeRecord();
                precPrev->SetNextFree( wid, prec->GetNextFreeSize() );
                prec->ClearAll( _PropStoreInfo.RecordSize() );
                Borrowed.Release();
                if (wid != 0)
                {
                    Borrowed.Set( wid );
                    prec = Borrowed.Get();
                }
            }
            if (wid == 0)
                continue;

            prec->SetPreviousFreeRecord( widPrev );
            widFreeListTail = wid;
            widPrev = wid;
            wid = prec->GetNextFreeRecord();
        }
        BorrowedPrev.Release();
        BorrowedPrev = Borrowed;
        precPrev = prec;
    }

    ciDebugOut(( DEB_WARN,
                 "PROPSTORE: 0x%x top level, widFreeList = 0x%x : 0x%x, widMax = 0x%x\n",
                 _cTopLevel, widFreeListHead, widFreeListTail, _widMax ));

    if ( _cInconsistencies )
    {
        ciDebugOut(( DEB_WARN,
            "PROPSTORE: Inconsistencies= 0x%X; Records forcefully freed= 0x%X\n",
            _cInconsistencies, _cForceFreed ));
    }

    _PropStoreInfo.SetRecordsInUse( _cTopLevel );
    _PropStoreInfo.SetMaxWorkId( _widMax );
    _PropStoreInfo.SetFreeListHead( widFreeListHead );
    _PropStoreInfo.SetFreeListTail( widFreeListTail );

    _propStore._aFreeBlocks = _aFreeBlocks;
    _aFreeBlocks = 0;

    // Don't flush here. We will flush both the prop stores from the manager
    // after LongInit has been performed on both.
}

//+---------------------------------------------------------------------------
//
//  Member:     CPropertyStoreRecovery::DoRecovery
//
//  Synopsis:   Do the recovery operation
//
//  History:    4-10-96   srikants   Created
//              6-13-97   KrishnaN   Added pass 0 to repair propstore from bkp.
//
//----------------------------------------------------------------------------

void CPropertyStoreRecovery::DoRecovery()
{
    NTSTATUS status = STATUS_SUCCESS;

    TRY
    {
        CLock mtxLock( _propStore._mtxWrite );

        Pass0();
        Pass1();
        Pass2();
        Complete();
    }
    CATCH( CException, e )
    {
        ciDebugOut(( DEB_ERROR, "Error 0x%X doing PropertyStore restore\n",
                                e.GetErrorCode() ));
        status = e.GetErrorCode();
    }
    END_CATCH

    if ( STATUS_SUCCESS != status )
    {
        if ( STATUS_ACCESS_VIOLATION == status )
        {

            Win4Assert ( 0 != _propStore._pStorage );

            _propStore._pStorage->ReportCorruptComponent( L"PropertyCache1" );

            status = CI_CORRUPT_CATALOG;
        }

        THROW( CException( status ) );
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\ntciutil\lib\makefile.inc ===
!IF 0

Copyright (C) Microsoft Corporation, 1997

Module Name:

    makefile.inc.

!ENDIF


$(_OBJ_DIR)\$(TARGET_DIRECTORY)\ntciutil.def: ntciutil.def
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\pch\empty.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1996.
//
//  File:       Empty.cxx
//
//  Contents:   Pre-compiled header
//
//  History:    21-Dec-92       BartoszM        Created
//
//--------------------------------------------------------------------------


#include <pch.cxx>
#pragma hdrstop
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\ntciutil\spropmap.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1994.
//
//  File:       spropmap.cxx
//
//  Contents:   Standard Property + Volatile Property mapper
//
//  Classes:    CStandardPropMapper
//
//  History:    1-03-97   srikants   Created (Moved code from qcat.cxx)
//
//----------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include <propspec.hxx>
#include <spropmap.hxx>

IMPL_DYNARRAY( CPropSpecArray, CPropSpecPidMap );

static const GUID guidDbBookmark = DBBMKGUID;
static const GUID guidDbSelf = DBSELFGUID;
static const GUID guidDbColumn = DBCIDGUID;

//+---------------------------------------------------------------------------
//
//  Member:     Constructor of the Standard property mapper.
//
//  History:    1-03-97   srikants   Created
//
//----------------------------------------------------------------------------

CStandardPropMapper::CStandardPropMapper()
    : _pidNextAvailable( INIT_DOWNLEVEL_PID ),
      _cps( 0 ),
      _cRefs( 1 )
{
}


//+-------------------------------------------------------------------------
//
//  Method:     CStandardPropMapper::StandardPropertyToPropId, protected
//
//  Synopsis:   Locate pid for standard properties
//
//  Arguments:  [ps]      -- Property specification (name)
//
//  Returns:    The pid of [ps] if ps is one of the standard properties.
//
//  History:    10 Jan 1996     Alanw    Created
//              3  Jan 1997     Srikants Moved from CQCat
//
//--------------------------------------------------------------------------

PROPID CStandardPropMapper::StandardPropertyToPropId(
                    CFullPropSpec const & ps )
{
    if ( ps.IsPropertyName() )
        return pidInvalid;             // no name-based standard properties

    PROPID pid = pidInvalid;

    if ( ps.GetPropSet() == guidStorage )
    {
        if ( ps.IsPropertyPropid() )
        {
            pid = ps.GetPropertyPropid();
            if (pid > PID_DICTIONARY && pid <= PID_STG_MAX)
            {
                pid = MK_CISTGPROPID(pid);
            }
            else if (pid == PID_SECURITY) // Note: overload PID_DICTIONARY
            {
                pid = pidSecurity;
            }
        }
    }
    else if ( ps.GetPropSet() == guidQuery )
    {
        if ( ps.IsPropertyPropid() )
        {
            switch( ps.GetPropertyPropid() )
            {
            case DISPID_QUERY_RANK:
                pid = pidRank;
                break;

            case DISPID_QUERY_RANKVECTOR:
                pid = pidRankVector;
                break;

            case DISPID_QUERY_HITCOUNT:
                pid = pidHitCount;
                break;

            case DISPID_QUERY_WORKID:
                pid = pidWorkId;
                break;

            case DISPID_QUERY_ALL:
                pid = pidAll;
                break;

            case DISPID_QUERY_UNFILTERED:
                pid = pidUnfiltered;
                break;

            case DISPID_QUERY_REVNAME:
                pid = pidRevName;
                break;

            case DISPID_QUERY_VIRTUALPATH:
                pid = pidVirtualPath;
                break;

            case DISPID_QUERY_LASTSEENTIME:
                pid = pidLastSeenTime;
                break;


            default:

                pid = pidInvalid;
            }
        }
    }
    else if ( ps.GetPropSet() == guidQueryMetadata )
    {
        if ( ps.IsPropertyPropid() )
        {
            switch( ps.GetPropertyPropid() )
            {
            case DISPID_QUERY_METADATA_VROOTUSED:
                pid = pidVRootUsed;
                break;

            case DISPID_QUERY_METADATA_VROOTAUTOMATIC:
                pid = pidVRootAutomatic;
                break;

            case DISPID_QUERY_METADATA_VROOTMANUAL:
                pid = pidVRootManual;
                break;

            case DISPID_QUERY_METADATA_PROPGUID:
                pid = pidPropertyGuid;
                break;

            case DISPID_QUERY_METADATA_PROPDISPID:
                pid = pidPropertyDispId;
                break;

            case DISPID_QUERY_METADATA_PROPNAME:
                pid = pidPropertyName;
                break;

            case DISPID_QUERY_METADATA_STORELEVEL:
                pid = pidPropertyStoreLevel;
                break;

            case DISPID_QUERY_METADATA_PROPMODIFIABLE:
                pid = pidPropDataModifiable;
                break;

            default:
                pid = pidInvalid;
            }
        }
    }
    else if ( ps.GetPropSet() == guidDbColumn )
    {
        if (ps.GetPropertyPropid() < CDBCOLDISPIDS)
        {
            pid = MK_CIDBCOLPROPID( ps.GetPropertyPropid() );
        }
    }
    else if ( ps.GetPropSet() == guidDbBookmark )
    {
        if (ps.GetPropertyPropid() < CDBBMKDISPIDS)
        {
            pid = MK_CIDBBMKPROPID( ps.GetPropertyPropid() );
        }
    }
    else if ( ps.GetPropSet() == guidDbSelf )
    {
        if (ps.GetPropertyPropid() == PROPID_DBSELF_SELF)
        {
            pid = pidSelf;
        }
    }

    return( pid );
}

//+-------------------------------------------------------------------------
//
//  Method:     CStandardPropMapper::PropertyToPropId, public
//
//  Synopsis:   Locate pid for property
//
//  Arguments:  [ps]      -- Property specification (name)
//              [fCreate] -- TRUE if non-existent mapping should be created
//
//  Returns:    The pid of [ps].
//
//  History:    28-Feb-1994     KyleP    Created
//              30-Jun-1994     KyleP    Added downlevel property support
//              03-Jan-1997     SrikantS Moved from CQCat
//
//--------------------------------------------------------------------------

PROPID CStandardPropMapper::PropertyToPropId(
            CFullPropSpec const & ps,
            BOOL fCreate )
{
    PROPID pid = StandardPropertyToPropId( ps );

    if (pidInvalid == pid)
    {
        //
        // Create pid good only for life of catalog.
        //

        //
        // Have we seen this property before?  Use linear search since
        // we shouldn't have too many of these.
        //

        for ( unsigned i = 0; i < _cps; i++ )
        {
            if ( ps == _aps.Get(i)->PS() )
                break;
        }

        if ( i < _cps )
        {
            pid = _aps.Get(i)->Pid();
        }
        else
        {
            pid = _pidNextAvailable++;
            CPropSpecPidMap * ppm = new CPropSpecPidMap( ps, pid );

            _aps.Add( ppm, _cps );
            _cps++;
        }
    }

    return pid;
}

//+-------------------------------------------------------------------------
//
//  Method:     CStandardPropMapper::AddRef
//
//  Synopsis:   Increments refcount
//
//  History:    31-Jan-1997      SitaramR       Created
//
//--------------------------------------------------------------------------

ULONG STDMETHODCALLTYPE CStandardPropMapper::AddRef()
{
    return InterlockedIncrement( (long *) &_cRefs );
}

//+-------------------------------------------------------------------------
//
//  Method:     CStandardPropMapper::Release
//
//  Synopsis:   Decrement refcount.  Delete if necessary.
//
//  History:    31-Jan-1997     SitaramR        Created
//
//--------------------------------------------------------------------------

ULONG STDMETHODCALLTYPE CStandardPropMapper::Release()
{
    Win4Assert( _cRefs > 0 );

    ULONG uTmp = InterlockedDecrement( (long *) &_cRefs );

    if ( 0 == uTmp )
        delete this;

    return uTmp;
}

//+-------------------------------------------------------------------------
//
//  Method:     CStandardPropMapper::QueryInterface
//
//  Synopsis:   Rebind to other interface
//
//  Arguments:  [riid]      -- IID of new interface
//              [ppvObject] -- New interface * returned here
//
//  Returns:    S_OK if bind succeeded, E_NOINTERFACE if bind failed
//
//  History:    31-Jan-1997     SitaramR   Created
//
//--------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE CStandardPropMapper::QueryInterface(
    REFIID  riid,
    void ** ppvObject)
{
    if ( 0 == ppvObject )
        return E_INVALIDARG;

    *ppvObject = 0;

    if ( IID_IPropertyMapper == riid )
        *ppvObject = (IUnknown *)(IPropertyMapper *) this;
    else if ( IID_IUnknown == riid )
        *ppvObject = (IUnknown *) this;
    else
        return E_NOINTERFACE;

    AddRef();

    return S_OK;
}

//+-------------------------------------------------------------------------
//
//  Method:     CStandardPropMapper::PropertyToPropid
//
//  Synopsis:   Convert propspec to pid
//
//  Arguments:  [pFullPropSpec] -- propspec to convert
//              [fCreate]       -- Create property if not found ?
//              [pPropId]       -- pid returned here
//
//  History:    31-Jan-1997     SitaramR   Created
//
//--------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE CStandardPropMapper::PropertyToPropid( const FULLPROPSPEC *pFullPropSpec,
                                                               BOOL fCreate,
                                                               PROPID *pPropId)
{
    SCODE sc = S_OK;

    TRY
    {
        CFullPropSpec const * pProperty = (CFullPropSpec const *) pFullPropSpec;
        *pPropId = PropertyToPropId( *pProperty, fCreate );
    }
    CATCH( CException, e )
    {
        sc = e.GetErrorCode();

        vqDebugOut(( DEB_ERROR,
                     "CStandardPropMapper:PropertyToPropid - Exception caught 0x%x\n",
                     sc ));
    }
    END_CATCH;

    return sc;
}

//+-------------------------------------------------------------------------
//
//  Method:     CStandardPropMapper::PropidToProperty
//
//  Synopsis:   Convert pid to propspec
//
//  Arguments:  [pPropId]       -- pid to convert
//              [pFullPropSpec] -- propspec returned here
//
//  History:    31-Jan-1997     SitaramR   Created
//
//--------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE CStandardPropMapper::PropidToProperty( PROPID propId,
                                                               FULLPROPSPEC **ppFullPropSpec )
{
    Win4Assert( !"Not yet implemented" );

    return E_NOTIMPL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\nullfilt\nullfilt.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1998.
//
//  File:       nullfilt.cxx
//
//  Contents:   Null IFilter implementation
//
//  History:    23-Aug-94   Created     t-jeffc
//
//--------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include <nullfilt.hxx>

extern long gulcInstances;

extern "C" GUID CLSID_CNullIFilter = {
    0xC3278E90,
    0xBEA7,
    0x11CD,
    { 0xB5, 0x79, 0x08, 0x00, 0x2B, 0x30, 0xBF, 0xEB }
};

//+-------------------------------------------------------------------------
//
//  Method:     CNullIFilter::CNullIFilter
//
//  Synopsis:   Class constructor
//
//  Effects:    Manages global refcount
//
//  History:    23-Aug-1994     t-jeffc     Created
//
//--------------------------------------------------------------------------

CNullIFilter::CNullIFilter()
        : _cRefs(1),
          _pwszFileName( 0 )
{
    InterlockedIncrement( &gulcInstances );
}

//+-------------------------------------------------------------------------
//
//  Method:     CNullIFilter::~CNullIFilter
//
//  Synopsis:   Class destructor
//
//  Effects:    Manages global refcount
//
//  History:    23-Aug-1994     t-jeffc     Created
//
//--------------------------------------------------------------------------

CNullIFilter::~CNullIFilter()
{
    delete [] _pwszFileName;
    InterlockedDecrement( &gulcInstances );
}

//+-------------------------------------------------------------------------
//
//  Method:     CNullIFilter::QueryInterface
//
//  Synopsis:   Rebind to other interface
//
//  Arguments:  [riid]      -- IID of new interface
//              [ppvObject] -- New interface * returned here
//
//  Returns:    S_OK if bind succeeded, E_NOINTERFACE if bind failed
//
//  History:    23-Aug-1994     t-jeffc     Created
//
//--------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE CNullIFilter::QueryInterface( REFIID riid,
                                                      void  ** ppvObject)
{
    SCODE sc = S_OK;

    if ( 0 == ppvObject )
        return E_INVALIDARG;

    *ppvObject = 0;

    if ( IID_IFilter == riid )
        *ppvObject = (IFilter *)this;
    else if ( IID_IPersist == riid )
        *ppvObject = (IUnknown *)(IPersist *)(IPersistFile *)this;
    else if ( IID_IPersistFile == riid )
        *ppvObject = (IUnknown *)(IPersistFile *)this;
    else if ( IID_IUnknown == riid )
        *ppvObject = (IUnknown *)(IPersist *)(IPersistFile *)this;
    else
        sc = E_NOINTERFACE;

    if ( SUCCEEDED( sc ) )
        AddRef();

    return sc;
} //QueryInterface

//+-------------------------------------------------------------------------
//
//  Method:     CNullIFilter::AddRef
//
//  Synopsis:   Increments refcount
//
//  History:    23-Aug-1994     t-jeffc     Created
//
//--------------------------------------------------------------------------

ULONG STDMETHODCALLTYPE CNullIFilter::AddRef()
{
    return InterlockedIncrement( &_cRefs );
}

//+-------------------------------------------------------------------------
//
//  Method:     CNullIFilter::Release
//
//  Synopsis:   Decrement refcount.  Delete if necessary.
//
//  History:    23-Aug-1994     t-jeffc     Created
//
//--------------------------------------------------------------------------

ULONG STDMETHODCALLTYPE CNullIFilter::Release()
{
    unsigned long uTmp = InterlockedDecrement( &_cRefs );

    if ( 0 == uTmp )
        delete this;

    return(uTmp);
}

//+---------------------------------------------------------------------------
//
//  Member:     CNullIFilter::Init, public
//
//  Synopsis:   Initializes instance (essentially do nothing)
//
//  Arguments:  [grfFlags]    -- Flags for filter behavior
//              [cAttributes] -- Number of strings in array ppwcsAttributes
//              [aAttributes] -- Array of attribute strings
//              [pFlags]      -- Return flags
//
//  History:    23-Aug-94   t-jeffc        Created.
//
//----------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE CNullIFilter::Init( ULONG grfFlags,
                                            ULONG cAttributes,
                                            FULLPROPSPEC const * aAttributes,
                                            ULONG * pFlags )
{
    //
    // Can't hurt to try and look for properties.  In NT5 any file can have
    // properties.
    //

    *pFlags = IFILTER_FLAGS_OLE_PROPERTIES;

    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Member:     CNullIFilter::GetChunk, public
//
//  Synopsis:   Pretends there aren't any chunks
//
//  Arguments:  [ppStat] -- for chunk information (not modified)
//
//  History:    23-Aug-94   t-jeffc        Created.
//
//----------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE CNullIFilter::GetChunk( STAT_CHUNK * pStat )
{
    return FILTER_E_END_OF_CHUNKS;
}

//+---------------------------------------------------------------------------
//
//  Member:     CNullIFilter::GetText, public
//
//  Synopsis:   Retrieves text (again, pretend there isn't any text)
//
//  Arguments:  [pcwcBuffer] -- count of UniCode characters in buffer
//              [awcBuffer]  -- buffer for text
//
//  History:    23-Aug-94   t-jeffc        Created.
//
//----------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE CNullIFilter::GetText( ULONG * pcwcBuffer,
                                               WCHAR * awcBuffer )
{
    return FILTER_E_NO_MORE_TEXT;
}

//+---------------------------------------------------------------------------
//
//  Member:     CNullIFilter::GetValue, public
//
//  Synopsis:   No value chunks.
//
//  History:    23-Aug-94   t-jeffc        Created.
//
//----------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE CNullIFilter::GetValue( PROPVARIANT ** ppPropValue )
{
    return FILTER_E_NO_VALUES;
}

//+---------------------------------------------------------------------------
//
//  Member:     CNullIFilter::BindRegion, public
//
//  Synopsis:   Creates moniker or other interface for text indicated
//
//  Arguments:  [origPos] -- the region of text to be mapped to a moniker
//              [riid]    -- Interface to bind
//              [ppunk]   -- Output pointer to interface
//
//  History:    16-Jul-93   AmyA           Created.
//
//----------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE CNullIFilter::BindRegion( FILTERREGION origPos,
                                                  REFIID riid,
                                                  void ** ppunk )
{
    return E_NOTIMPL;
}

//+---------------------------------------------------------------------------
//
//  Member:     CNullIFilter::GetClassID, public
//
//  Synopsis:   Returns the class id of this class.
//
//  Arguments:  [pClassID] -- the class id
//
//  History:    23-Aug-94   t-jeffc        Created.
//
//----------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE CNullIFilter::GetClassID( CLSID * pClassID )
{
    *pClassID = CLSID_CNullIFilter;
    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Member:     CNullIFilter::IsDirty, public
//
//  Synopsis:   Always returns S_FALSE since this class is read-only.
//
//  History:    23-Aug-94   t-jeffc        Created.
//
//----------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE CNullIFilter::IsDirty()
{
    return S_FALSE; // Since the filter is read-only, there will never be
                    // changes to the file.
}

//+---------------------------------------------------------------------------
//
//  Member:     CNullIFilter::Load, public
//
//  Synopsis:   Pretend to load the indicated file
//
//  Arguments:  [pszFileName] -- the file name
//              [dwMode] -- the mode to load the file in
//
//  History:    23-Aug-94   t-jeffc        Created.
//
//----------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE CNullIFilter::Load(LPCWSTR pszFileName, DWORD dwMode)
{
    SCODE sc = S_OK;

    TRY
    {
        delete [] _pwszFileName;
        _pwszFileName = 0;

        int cc = wcslen( pszFileName ) + 1;
        _pwszFileName = new WCHAR [cc];
        wcscpy( _pwszFileName, pszFileName );
    }
    CATCH( CException, e )
    {
        sc = e.GetErrorCode();
    }
    END_CATCH

    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Member:     CNullIFilter::Save, public
//
//  Synopsis:   Always returns E_FAIL, since the file is opened read-only
//
//  History:    23-Aug-94   t-jeffc        Created.
//
//----------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE CNullIFilter::Save(LPCWSTR pszFileName, BOOL fRemember)
{
    return E_FAIL;  // cannot be saved since it is read-only
}

//+---------------------------------------------------------------------------
//
//  Member:     CNullIFilter::SaveCompleted, public
//
//  Synopsis:   Always returns E_FAIL since the file is opened read-only
//
//  History:    23-Aug-94   t-jeffc        Created.
//
//----------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE CNullIFilter::SaveCompleted(LPCWSTR pszFileName)
{
    return E_FAIL;
}

//+---------------------------------------------------------------------------
//
//  Member:     CNullIFilter::GetCurFile, public
//
//  Synopsis:   Returns a copy of the current file name
//
//  Arguments:  [ppszFileName] -- where the copied string is returned.
//
//  History:    24-Aug-94   t-jeffc        Created.
//
//----------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE CNullIFilter::GetCurFile(LPWSTR * ppszFileName)
{
    if ( _pwszFileName == 0 )
        return E_FAIL;

    SCODE sc = S_OK;

    unsigned cc = wcslen( _pwszFileName ) + 1;
    *ppszFileName = (WCHAR *)CoTaskMemAlloc(cc*sizeof(WCHAR));

    if ( *ppszFileName )
        wcscpy( *ppszFileName, _pwszFileName );
    else
        sc = E_OUTOFMEMORY;

    return sc;
}

//+-------------------------------------------------------------------------
//
//  Method:     CNullIFilterCF::CNullIFilterCF
//
//  Synopsis:   Text IFilter class factory constructor
//
//  History:    23-Aug-1994     t-jeffc     Created
//
//--------------------------------------------------------------------------

CNullIFilterCF::CNullIFilterCF()
        : _cRefs( 1 )
{
    InterlockedIncrement( &gulcInstances );
}

//+-------------------------------------------------------------------------
//
//  Method:     CNullIFilterCF::~CNullIFilterCF
//
//  Synopsis:   Text IFilter class factory constructor
//
//  History:    23-Aug-1994     t-jeffc     Created
//
//--------------------------------------------------------------------------

CNullIFilterCF::~CNullIFilterCF()
{
    InterlockedDecrement( &gulcInstances );
}

//+-------------------------------------------------------------------------
//
//  Method:     CNullIFilterCF::QueryInterface
//
//  Synopsis:   Rebind to other interface
//
//  Arguments:  [riid]      -- IID of new interface
//              [ppvObject] -- New interface * returned here
//
//  Returns:    S_OK if bind succeeded, E_NOINTERFACE if bind failed
//
//  History:    23-Aug-1994     t-jeffc     Created
//
//--------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE CNullIFilterCF::QueryInterface( REFIID riid,
                                                        void  ** ppvObject )
{
    //
    // Optimize QueryInterface by only checking minimal number of bytes.
    //
    // IID_IUnknown      = 00000000-0000-0000-C000-000000000046
    // IID_IClassFactory = 00000001-0000-0000-C000-000000000046
    //                           --
    //                           |
    //                           +--- Unique!
    //

    Win4Assert( (IID_IUnknown.Data1      & 0x000000FF) == 0x00 );
    Win4Assert( (IID_IClassFactory.Data1 & 0x000000FF) == 0x01 );

    IUnknown *pUnkTemp;
    SCODE sc;

    if ( IID_IClassFactory == riid )
        pUnkTemp = (IUnknown *)(IClassFactory *)this;
    else if ( IID_IUnknown == riid )
        pUnkTemp = (IUnknown *)this;
    else
        pUnkTemp = 0;

    if( 0 != pUnkTemp )
    {
        *ppvObject = (void  * )pUnkTemp;
        pUnkTemp->AddRef();
        sc = S_OK;
    }
    else
        sc = E_NOINTERFACE;

    return(sc);
}

//+-------------------------------------------------------------------------
//
//  Method:     CNullIFilterCF::AddRef
//
//  Synopsis:   Increments refcount
//
//  History:    23-Aug-1994     t-jeffc     Created
//
//--------------------------------------------------------------------------

ULONG STDMETHODCALLTYPE CNullIFilterCF::AddRef()
{
    return InterlockedIncrement( &_cRefs );
}

//+-------------------------------------------------------------------------
//
//  Method:     CNullIFilterCF::Release
//
//  Synopsis:   Decrement refcount.  Delete if necessary.
//
//  History:    23-Aug-1994     t-jeffc     Created
//
//--------------------------------------------------------------------------

ULONG STDMETHODCALLTYPE CNullIFilterCF::Release()
{
    unsigned long uTmp = InterlockedDecrement( &_cRefs );

    if ( 0 == uTmp )
        delete this;

    return(uTmp);
}


//+-------------------------------------------------------------------------
//
//  Method:     CNullIFilterCF::CreateInstance
//
//  Synopsis:   Creates new TextIFilter object
//
//  Arguments:  [pUnkOuter] -- 'Outer' IUnknown
//              [riid]      -- Interface to bind
//              [ppvObject] -- Interface returned here
//
//  History:    23-Aug-1994     t-jeffc     Created
//
//--------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE CNullIFilterCF::CreateInstance( IUnknown * pUnkOuter,
                                                        REFIID riid,
                                                        void  * * ppvObject )
{
    CNullIFilter *  pIUnk = 0;
    SCODE sc = S_OK;

    TRY
    {
        pIUnk = new CNullIFilter();
        sc = pIUnk->QueryInterface(  riid , ppvObject );

        pIUnk->Release();  // Release extra refcount from QueryInterface
    }
    CATCH(CException, e)
    {
        Win4Assert( 0 == pIUnk );

        switch( e.GetErrorCode() )
        {
        case E_OUTOFMEMORY:
            sc = (E_OUTOFMEMORY);
            break;
        default:
            sc = (E_UNEXPECTED);
        }
    }
    END_CATCH;

    return (sc);
}

//+-------------------------------------------------------------------------
//
//  Method:     CNullIFilterCF::LockServer
//
//  Synopsis:   Force class factory to remain loaded
//
//  Arguments:  [fLock] -- TRUE if locking, FALSE if unlocking
//
//  Returns:    S_OK
//
//  History:    23-Aug-1994     t-jeffc     Created
//
//--------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE CNullIFilterCF::LockServer(BOOL fLock)
{
    if(fLock)
        InterlockedIncrement( &gulcInstances );
    else
        InterlockedDecrement( &gulcInstances );

    return(S_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\pch\pch.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1999.
//
//  File:       PCH.cxx
//
//  Contents:   Pre-compiled header
//
//  History:    21-Dec-92       BartoszM        Created
//
//--------------------------------------------------------------------------


// CoTaskAllocator is 'extern' to items in query.dll except where defined,
// where it is __declspec(dllexport).
// To all other dlls, it is __declspec(dllimport)
//

#define COTASKDECLSPEC extern

#define _OLE32_
#define __QUERY__

extern "C"
{
    #include <nt.h>
    #include <ntioapi.h>
    #include <ntrtl.h>
    #include <nturtl.h>
}
#include <ctype.h>
#include <float.h>
#include <limits.h>
#include <malloc.h>
#include <math.h>
#include <memory.h>
#include <stddef.h>
#include <string.h>
#include <stdarg.h>
#include <stdio.h>
#include <stdlib.h>

#include <windows.h>
#include <lmcons.h>

#define _DCOM_
#define _CAIROSTG_

#include <cidebnot.h>
#include <cierror.h>

//
// NOTE: DBINITCONSTANTS is defined in private\genx\types\uuid\oledbdat.c
//       OLEDBVER is defined in user.mk
// 
#include <oleext.h>
#include <oledberr.h>

#define deprecated      // enable IRowsetExactScroll
#include <oledb.h>
#include <oledbdep.h>   // deprecated OLE DB interfaces
#include <cmdtree.h>    // ICommandTree interface

#include <query.h>
#include <stgprop.h>
#include <filter.h>
#include <filterr.h>
#include <dbcmdtre.hxx>
#include <vquery.hxx>
#include <restrict.hxx>

//
// Base services
//

#include <ciexcpt.hxx>
#include <smart.hxx>
#include <tsmem.hxx>
#include <xolemem.hxx>
#include <dynarray.hxx>
#include <dynstack.hxx>
#include <dblink.hxx>
#include <cisem.hxx>
#include <thrd32.hxx>
#include <readwrit.hxx>
#include <ci.h>
#include <ci64.hxx>

//
// Debug files from
//

#include <cidebug.hxx>
#include <vqdebug.hxx>

//
// CI-specific
//

#include <align.hxx>
#include <memser.hxx>
#include <memdeser.hxx>

#include <tgrow.hxx>
#include <funypath.hxx>
#include <params.hxx>
#include <key.hxx>
#include <keyarray.hxx>
#include <irest.hxx>
#include <cursor.hxx>
#include <idxids.hxx>

#include <dberror.hxx>

// property-related macros and includes

#include <propapi.h>
#include <propstm.hxx>
extern UNICODECALLOUTS UnicodeCallouts;
#define DebugTrace( x, y, z )
#ifdef PROPASSERTMSG
#undef PROPASSERTMSG
#endif
#define PROPASSERTMSG( x, y )

#pragma hdrstop
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\ntciutil\worker.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 2000.
//
//  File:       QQueue.cxx
//
//  Contents:   Query queue
//
//  History:    29-Dec-93 KyleP    Created
//
//--------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include <worker.hxx>
#include <ciregkey.hxx>
#include <regacc.hxx>
#include <imprsnat.hxx>

extern BOOL g_fPerfmonCounterHackIsProcessDetached;

//+-------------------------------------------------------------------------
//
//  Member:     CWorkQueue::GetWorkQueueRegParams, public
//
//  Synopsis:   Fetches registry params for the work queue
//
//  History:    30-Dec-96 SrikantS Moved the code from RefreshRegParams
//
//--------------------------------------------------------------------------

void CWorkQueue::GetWorkQueueRegParams( ULONG & cMaxActiveThreads,
                                        ULONG & cMinIdleThreads )
{
    CRegAccess reg( RTL_REGISTRY_CONTROL, wcsRegAdmin );

    if ( CWorkQueue::workQueueQuery == _QueueType )
    {
        cMaxActiveThreads = reg.Read( wcsMaxActiveQueryThreads,
                                       CI_MAX_ACTIVE_QUERY_THREADS_DEFAULT,
                                       CI_MAX_ACTIVE_QUERY_THREADS_MIN,
                                       CI_MAX_ACTIVE_QUERY_THREADS_MAX );
        cMinIdleThreads = reg.Read( wcsMinIdleQueryThreads,
                                     CI_MIN_IDLE_QUERY_THREADS_DEFAULT,
                                     CI_MIN_IDLE_QUERY_THREADS_MIN,
                                     CI_MIN_IDLE_QUERY_THREADS_MAX );
    }
    else if ( CWorkQueue::workQueueRequest == _QueueType )
    {
        cMaxActiveThreads = reg.Read( wcsMaxActiveRequestThreads,
                                      CI_MAX_ACTIVE_REQUEST_THREADS_DEFAULT,
                                      CI_MAX_ACTIVE_REQUEST_THREADS_MIN,
                                      CI_MAX_ACTIVE_REQUEST_THREADS_MAX );
        cMinIdleThreads = reg.Read( wcsMinIdleRequestThreads,
                                      CI_MIN_IDLE_REQUEST_THREADS_DEFAULT,
                                      CI_MIN_IDLE_REQUEST_THREADS_MIN,
                                      CI_MIN_IDLE_REQUEST_THREADS_MAX );
    }
    else
    {
        cMaxActiveThreads = 2;
        cMinIdleThreads = 0;
    }
} //GetWorkQueueRegParams

//+-------------------------------------------------------------------------
//
//  Member:     CWorkQueue::CWorkQueue, public
//
//  Synopsis:   Initialize queue.
//
//  Arguments:  [cThread]   -- Number of worker threads.
//              [workQueue] -- Work queue type for getting registry settings.
//
//  History:    29-Dec-93 KyleP     Created
//
//--------------------------------------------------------------------------

CWorkQueue::CWorkQueue(
    unsigned      cThread,
    WorkQueueType workQueue )
        : _cItems( 0 ),
          _pHead( 0 ),
          _pTail( 0 ),
          _apWorker( 0 ), // avoid allocation in construction of global
          _pIdle( 0 ),
          _cIdle( 0 ),
          _fInit( FALSE ),
          _fAbort( FALSE ),
          _cWorker( 0 ),
          _cMaxActiveThreads(cThread),
          _cMinIdleThreads(0),
          _QueueType( workQueue ),
          _mtxLock( FALSE )
{
    Win4Assert( workQueueQuery == workQueue ||
                workQueueRequest == workQueue ||
                workQueueFrmwrkClient == workQueue );

    // Note: don't call RefreshRegParams as long as the work queue
    // is a global object -- there's no telling what security context will
    // be used to load the .dll.

    //RefreshParams( cThread, cThread );
} //CWorkQueue

//+-------------------------------------------------------------------------
//
//  Member:     CWorkQueue::~CWorkQueue, public
//
//  Synopsis:   Waits for queue threads to stop.
//
//  Requires:   An external source has killed all queue items.
//
//  History:    29-Dec-93 KyleP     Created
//
//--------------------------------------------------------------------------

CWorkQueue::~CWorkQueue()
{
    Win4Assert( _cItems == 0 );

    if ( _fInit )
    {
        // If somehow we're unwinding a global object after the heap has
        // been destroyed, don't do any work.

        if ( g_fPerfmonCounterHackIsProcessDetached )
        {
            // Don't free this since the heap is already gone!

            _apWorker.AcquireAll();

            return;
        }

        Shutdown();
    }
} //~CWorkQueue

//+-------------------------------------------------------------------------
//
//  Member:     CWorkQueue::RefreshParams, public
//
//  Synopsis:   Refreshes registry params for the work queue
//
//  History:    7-Nov-96 dlee     Created
//             30-Dec-96 SrikantS Changed name to RefreshParams and removed
//                                the dependency on registry.
//
//--------------------------------------------------------------------------

#pragma warning(push)
#pragma warning(disable:4296)

void CWorkQueue::RefreshParams( ULONG cMaxActiveThread,
                                ULONG cMinIdleThread )
{
    CLock lock( _mtxLock );

    if ( CWorkQueue::workQueueQuery == _QueueType )
    {
        _cMaxActiveThreads = min( CI_MAX_ACTIVE_QUERY_THREADS_MAX,
                                  max(CI_MAX_ACTIVE_QUERY_THREADS_MIN,
                                      cMaxActiveThread) );
    
        _cMinIdleThreads   = min( CI_MIN_IDLE_QUERY_THREADS_MAX,
                                  max(CI_MIN_IDLE_QUERY_THREADS_MIN,
                                      cMinIdleThread) );
    }
    else if ( CWorkQueue::workQueueRequest == _QueueType )
    {
        _cMaxActiveThreads = min( CI_MAX_ACTIVE_REQUEST_THREADS_MAX,
                                  max(CI_MAX_ACTIVE_REQUEST_THREADS_MIN,
                                      cMaxActiveThread) );
    
        _cMinIdleThreads   = min( CI_MIN_IDLE_REQUEST_THREADS_MAX,
                                  max(CI_MIN_IDLE_REQUEST_THREADS_MIN,
                                      cMinIdleThread) );
    }
    else // framework client queue
    {
        _cMaxActiveThreads = 2;
        _cMinIdleThreads = 0;
    }
} //RefreshParams

#pragma warning(pop)

//+-------------------------------------------------------------------------
//
//  Member:     CWorkQueue::Shutdown, public
//
//  Synopsis:   Shuts down the work queue
//
//  History:    7-Nov-96 dlee     Added header
//
//--------------------------------------------------------------------------

void CWorkQueue::Shutdown()
{
    if (_fInit)
    {
        CLock lock( _mtxLock );
        _fAbort = TRUE;
        for ( CWorkThread * pw = _pIdle; pw; pw = pw->Next() )
        {
            Win4Assert(pw != pw->Next());
            pw->Wakeup();
        }

        vqDebugOut(( DEB_ITRACE, "Work queue shutdown: woke up threads\n" ));
    }

    _apWorker.Free();
    _cWorker = 0;

    vqDebugOut(( DEB_ITRACE, "Work queue shutdown: exiting\n" ));
} //Shutdown

//+-------------------------------------------------------------------------
//
//  Member:     CWorkQueue::AddRefWorkThreads, public
//
//  Synopsis:   Addrefs the current set of worker threads
//
//  History:    21-May-97 dlee     Created
//
//--------------------------------------------------------------------------

void CWorkQueue::AddRefWorkThreads()
{
    CLock lock( _mtxLock );

    for ( ULONG x = 0; x < _cWorker; x++ )
        _apWorker[x]->AddRef();
} //AddRefWorkThreads

//+-------------------------------------------------------------------------
//
//  Member:     CWorkQueue::ReleaseWorkThreads, public
//
//  Synopsis:   Releases the current set of worker threads
//
//  History:    21-May-97 dlee     Created
//
//--------------------------------------------------------------------------

void CWorkQueue::ReleaseWorkThreads()
{
    CLock lock( _mtxLock );

    for ( ULONG x = 0; x < _cWorker; x++ )
        _apWorker[x]->Release();
} //ReleaseWorkThreads

//+-------------------------------------------------------------------------
//
//  Member:     CWorkQueue::Add, public
//
//  Synopsis:   Add a query to the queue.
//
//  Arguments:  [pitem] -- Query to add
//
//  History:    29-Dec-93 KyleP     Created
//
//--------------------------------------------------------------------------

void CWorkQueue::Add( PWorkItem * pitem )
{
    BOOL fTryRemove = FALSE;

    {
        CLock lock( _mtxLock );

        if ( _fAbort )
        {
            vqDebugOut(( DEB_ITRACE, "work queue, shutdown, so not adding item\n" ));
            return;
        }

        pitem->AddRef();

        //
        // Insert at end of list
        //

        if ( _pTail )
        {
            _pTail->Link( pitem );
            _pTail = pitem;
        }
        else
        {
            Win4Assert( !_pHead );

            _pHead = pitem;
            _pTail = pitem;
        }

        _pTail->Link( 0 );
        _cItems++;

        vqDebugOut(( DEB_ITRACE, "Work queue: add 0x%x\n", pitem ));

        //
        // Add a new thread if there are no idle ones (or ones processing APCs)
        //

        if ( ( ( _cWorker == (unsigned) _cInAPC ) || ( 0 == _pIdle ) ) &&
             ( _cWorker < _cMaxActiveThreads ) )
        {
            TRY
            {
                lokAddThread();
            }
            CATCH( CException, e )
            {
                //
                // Remove the item from the work queue so it gets released
                // properly.
                //

                Remove( pitem );

                //
                // Now rethrow the exception, which will only happen if
                // there are not worker threads at all.
                //

                RETHROW();
            }
            END_CATCH;

            Win4Assert( _pIdle == 0 || _pIdle->Next() != _pIdle );
        }

        //
        // Wake up a thread if there is an idle one.
        //

        if ( _pIdle )
        {
            Win4Assert( _cIdle > 0 );

            // Move any thread not processing an APC to the start of the list

            CWorkThread * pwPrev = 0;

            for ( CWorkThread * pw = _pIdle; 0 != pw; pw = pw->Next() )
            {
                if ( !pw->IsProcessingAPC() )
                {
                    if ( pw != _pIdle )
                    {
                        Win4Assert( 0 != pwPrev );

                        pwPrev->Link( pw->Next() );

                        pw->Link( _pIdle );

                        _pIdle = pw;
                    }

                    break;
                }

                pwPrev = pw;
            }

            CWorkThread * pWorker = _pIdle;
            _pIdle = _pIdle->Next();
            _cIdle--;
            Win4Assert( _pIdle != pWorker );
            pWorker->Link( 0 );
            pWorker->Wakeup();

            if ( _cIdle > _cMinIdleThreads )
                fTryRemove = TRUE;
        }
    }

    if ( fTryRemove )
        RemoveThreads();
} //Add

//+-------------------------------------------------------------------------
//
//  Member:     CWorkQueue::Release, public
//
//  Synopsis:   Release refcount on worker thread
//
//  Arguments:  [pThread] -- Worker thread
//
//  History:    13-Mar-96 KyleP     Created
//
//--------------------------------------------------------------------------

void CWorkQueue::Release( CWorkThread * pThread )
{
    pThread->Release();
    BOOL fTryRemove = FALSE;

    if ( GetCurrentThreadId() != pThread->GetThreadId() )
    {
        CLock lock( _mtxLock );

        if ( _pIdle )
        {
            Win4Assert( _cIdle > 0 );

            if ( _cIdle > _cMinIdleThreads )
                fTryRemove = TRUE;
        }

    }

    if ( fTryRemove )
        RemoveThreads();
} //Release

//+-------------------------------------------------------------------------
//
//  Member:     CWorkQueue::Remove, private
//
//  Synopsis:   Remove a query from the queue.
//
//  Arguments:  [Worker] -- Worker thread to own the query
//
//  History:    29-Dec-93 KyleP     Created
//
//  Notes:      Remove is used by worker threads to acquire a new work
//              item.  In contrast, the other remove will just remove
//              an item from the queue.
//
//--------------------------------------------------------------------------

void CWorkQueue::Remove( CWorkThread & Worker )
{
    Win4Assert( Worker.ActiveItem() == 0 );

    for (;;)
    {
        //
        // Look for an item
        //

        {
            CLock lock( _mtxLock );

            Worker.Reset();
            //
            // We may have been awoken by an APC.  Be sure we're not
            // still on the idle queue in this case.
            //
            if ( _pIdle )
            {
                if ( _pIdle == &Worker )
                {
                    _cIdle--;
                    _pIdle = Worker.Next();
                }
                else
                {
                    for ( CWorkThread * pw = _pIdle; pw; pw = pw->Next() ) {
                        if (pw->Next() == &Worker)
                        {
                            _cIdle--;
                            pw->Link(Worker.Next());
                            break;
                        }
                    }
                }
            }

            if ( _fAbort || Worker.lokShouldAbort() )
            {
                vqDebugOut(( DEB_ITRACE,
                             "Work queue: abort worker thread.\n" ));
                break;
            }

            if ( Count() > 0 )
            {
                vqDebugOut(( DEB_ITRACE,
                             "Work queue: %d pending\n", _cItems ));

                Worker.lokSetActiveItem( _pHead );
                _pHead = _pHead->Next();

                if ( _pHead == 0 )
                    _pTail = 0;

                _cItems--;

                break;
            }

            //
            // Nothing on the queue right now.  Wait for item.
            //

            Worker.Link( _pIdle );
            _pIdle = &Worker;
            _cIdle++;
            Win4Assert(Worker.Next() != &Worker);
        }

        Worker.Wait();
    }

    vqDebugOut(( DEB_ITRACE, "Work queue: remove 0x%x\n", Worker.ActiveItem() ));

    //
    // We're not sleeping the thread, make sure we
    // process APCs.
    //

    SleepEx( 0, TRUE );
} //Remove

//+-------------------------------------------------------------------------
//
//  Member:     CWorkQueue::Remove, public
//
//  Effects:    Deletes all references to [pitem] from the queue.  If
//              pitem is a query-in-progress in a worker thread then
//              we wait until that query completes before returning from
//              Delete.
//
//  Arguments:  [pitem] -- Query to remove
//
//  History:    29-Dec-93 KyleP     Created
//              09-Feb-94 KyleP     Speed up removal of active item
//
//  Notes:      The item may still be running on a worker thread when we
//              return from this call.
//
//--------------------------------------------------------------------------

void CWorkQueue::Remove( PWorkItem * pitem )
{
    CLock lock( _mtxLock );

    if ( _pHead == pitem )
    {
        _pHead = pitem->Next();

        if ( _pTail == pitem )
        {
            Win4Assert( _pHead == 0 );
            _pTail = 0;
        }

        _cItems--;

        pitem->Release();

        vqDebugOut(( DEB_ITRACE,
                     "Work queue: delete 0x%x\n", pitem ));
    }
    else
    {
        for ( PWorkItem * pCurrent = _pHead;
              pCurrent && pCurrent->Next() != pitem;
              pCurrent = pCurrent->Next() )
            continue;          // Null body

        if ( pCurrent )
        {
            Win4Assert( pCurrent->Next() == pitem );

            if ( _pTail == pitem )
            {
                _pTail = pCurrent;
            }

            pCurrent->Link( pitem->Next() );

            _cItems--;

            pitem->Release();

            vqDebugOut(( DEB_ITRACE,
                         "Work queue: delete 0x%x\n", pitem ));
        }
    }
} //Remove

//+-------------------------------------------------------------------------
//
//  Member:     CWorkQueue::AddThread, private
//
//  Synopsis:   Adds new worker thread to idle worker list.
//
//  History:    12-Jan-94 KyleP     Created
//
//--------------------------------------------------------------------------

void CWorkQueue::lokAddThread()
{
    TRY
    {
        vqDebugOut(( DEB_ITRACE, "Add worker thread %d of %d\n",
                     _cWorker+1, _apWorker.Size() ));

        //
        // Worker threads must be created in the system context or they
        // won't have the permission to revert to system, which is needed
        // for queries on remote volumes and to write to catalog files.
        //

        CImpersonateSystem impersonate;

        CEventSem evt1;
        SHandle hEvt1( evt1.AcquireHandle() );
        CEventSem evt2;
        SHandle hEvt2( evt2.AcquireHandle() );

        _apWorker.Add( new CWorkThread( *this,
                                        _pIdle,
                                        hEvt1,
                                        hEvt2 ),
                       _cWorker );
        _pIdle = _apWorker[_cWorker];
        _cIdle++;
        _cWorker++;
    }
    CATCH( CException, e )
    {
        vqDebugOut(( DEB_ERROR,
                     "Exception 0x%x caught creating query worker threads."
                     " Running with %d threads.\n", e.GetErrorCode(), _cWorker ));

        // Only throw an excption if there are no threads around at all.
        // If there is at least 1 thread it'll eventually get to the work
        // items.

        if ( 0 == _cWorker )
        {
            RETHROW();
        }
    }
    END_CATCH

    Win4Assert( _cWorker != 0 );
} //lokAddThread

//+-------------------------------------------------------------------------
//
//  Member:     CWorkQueue::RemoveThreads, private
//
//  Synopsis:   Removes one or more threads from idle queue.
//
//  History:    28-Sep-95 KyleP     Created
//
//--------------------------------------------------------------------------

const DWORD tenSeconds = 1000 * 10;

void CWorkQueue::RemoveThreads()
{
    while ( TRUE )
    {
        CWorkThread * pThread = 0;

        //
        // Check for too many idle threads under lock.
        //

        {
            CLock lock( _mtxLock );

            if ( _cIdle > _cMinIdleThreads )
            {
                //
                // Find an idle thread that has a refcount of 0 and hasn't
                // done anything in 10 seconds.
                //

                CWorkThread * pPrev = 0;

                for ( pThread = _pIdle; 0 != pThread; pThread = pThread->Next() )
                {
                    if ( !pThread->IsReferenced() )
                    {
                        vqDebugOut(( DEB_ITRACE, "isidle? %d\n", pThread->IsIdleFor( tenSeconds ) ));

                        if ( pThread->IsIdleFor( tenSeconds ) )
                            break;
                    }

                    pPrev = pThread;
                }

                if ( 0 != pThread )
                {
                    for ( unsigned i = 0; i < _cWorker; i++ )
                    {
                        //
                        // Remove first idle thread from all queues and abort it.
                        //

                        if ( _apWorker[i] == pThread )
                        {
                            vqDebugOut(( DEB_ITRACE, "Deleting extra idle thread\n" ));

                            if ( 0 == pPrev )
                                _pIdle = _pIdle->Next();
                            else
                                pPrev->Link( pThread->Next() );

                            _cIdle--;

                            _cWorker--;
                            _apWorker.Acquire( i );
                            _apWorker.Add( _apWorker.Acquire(_cWorker), i );

                            pThread->lokAbort();
                            pThread->Wakeup();
                            break;
                        }
                    }

                    Win4Assert( i <= _cWorker );
                }
            }
        }

        //
        // If we found an extra idle thread, delete it and try again, else just get out.
        //

        if ( pThread )
            delete pThread;
        else
            break;
    }
} //RemoveThreads

//+-------------------------------------------------------------------------
//
//  Member:     CWorkThread::WorkerThread, static private
//
//  Synopsis:   Main loop that executes query.
//
//  Arguments:  [self] -- this pointer for CWorkThread object
//
//  History:    29-Dec-93 KyleP     Created
//
//--------------------------------------------------------------------------

DWORD WINAPI CWorkThread::WorkerThread( void * self )
{
    CWorkThread * pWorker = (CWorkThread *)self;

    for( pWorker->_queue.Remove( *pWorker );
         pWorker->ActiveItem();
         pWorker->_queue.Remove( *pWorker ) )
    {
        TRY
        {
            pWorker->ActiveItem()->DoIt( pWorker );
        }
        CATCH( CException, e )
        {
            vqDebugOut(( DEB_ERROR, "pWorker->DoIt() failed with error 0x%x\n", e.GetErrorCode() ));
        }
        END_CATCH

        pWorker->Done();
    }

    //
    // We should not do an ExitThread() here because there will be a deadlock
    // during shutdown. The DLL_PROCESS_DETACH is called with the "LoaderLock"
    // CriticalSection held by the LdrUnloadDll() during the DLL detach.
    // Terminating the thread here is okay because there is no cleanup to be
    // done after this.
    //

    vqDebugOut(( DEB_ITRACE, "WorkerThread 0x%x: exiting\n", self ));

    return 0;
} //WorkerThread

//+-------------------------------------------------------------------------
//
//  Member:     CWorkThread::CWorkThread, public
//
//  Synopsis:   Creates worker thread.
//
//  Arguments:  [queue] -- Work queue which owns worker.
//              [pNext] -- Link.  Used by Work queue.
//              [hEvt1] -- Event handle for first event in the worker thread
//              [hEvt2] -- Event handle for second event in the worker thread
//
//  History:    29-Dec-93 KyleP     Created
//
//--------------------------------------------------------------------------

#pragma warning( disable : 4355 )       // this used in base initialization

CWorkThread::CWorkThread( CWorkQueue & queue,
                          CWorkThread * pNext
                          , SHandle & hEvt1
                          , SHandle & hEvt2
                        )
        : _queue( queue ),
          _pNext( pNext ),
          _pitem( 0 ),
          _fAbort( FALSE ),
          _Thread( CWorkThread::WorkerThread, this, TRUE ),
          _cRef( 0 )
        , _evtQueryAvailable( hEvt1.Acquire() )
        , _evtDone( hEvt2.Acquire() ),
          _pDeferredAPCs( 0 ),
          _fProcessingAPC( FALSE ),
          _dwLastUsed( GetTickCount() )
{
    _Thread.Resume();
}

#pragma warning( default : 4355 )

//+-------------------------------------------------------------------------
//
//  Member:     CWorkThread::~CWorkThread, public
//
//  Synopsis:   Waits for thread to die.
//
//  History:    29-Dec-93 KyleP     Created
//
//--------------------------------------------------------------------------

CWorkThread::~CWorkThread()
{
    vqDebugOut(( DEB_ITRACE, "Worker 0x%x: WAIT for death\n", this ));
    Win4Assert( GetCurrentThreadId() != GetThreadId() );
    _Thread.WaitForDeath();
    vqDebugOut(( DEB_ITRACE, "Worker 0x%x: done waiting for death\n", this ));
}

//+-------------------------------------------------------------------------
//
//  Member:     CWorkThread::ProcessDeferredAPCs, private
//
//  Synopsis:   Processes all deferred APCs
//
//  History:    17-Jul-00 dlee     Created
//
//--------------------------------------------------------------------------

void CWorkThread::ProcessDeferredAPCs()
{
    Win4Assert( !_fProcessingAPC );

    while ( 0 != _pDeferredAPCs )
    {
        //
        // Pull the item out of the list and invoke it.
        // DeferredAPC() is guaranteed not to throw.
        //

        PWorkItem * pItem = _pDeferredAPCs;
        _pDeferredAPCs = pItem->Next();
        pItem->Link( 0 );

        pItem->DeferredAPC();

        // Release once per APC processed

        Release();
    }
} //ProcessDeferredAPCs

//+-------------------------------------------------------------------------
//
//  Member:     CWorkThread::Wait, public
//
//  Synopsis:   Waits for 'new work' event
//
//  History:    29-Dec-93 KyleP     Created
//
//--------------------------------------------------------------------------

void CWorkThread::Wait()
{
    vqDebugOut(( DEB_RESULTS, "Worker 0x%x: WAIT for work\n", this ));

    // Process any deferred APCs before sleeping to get more.

    ProcessDeferredAPCs();

    //
    // There is no need to loop to look for work just because we woke
    // up after processing an APC.  But do process deferred APCs.
    //

    while ( STATUS_USER_APC == _evtQueryAvailable.Wait( INFINITE, TRUE ) )
        ProcessDeferredAPCs();
} //Wait

//+-------------------------------------------------------------------------
//
//  Member:     CWorkThread::Done, public
//
//  Effects:    Finishes one work item and sets 'done' event.
//
//  History:    29-Dec-93 KyleP     Created
//
//--------------------------------------------------------------------------

void CWorkThread::Done()
{
    _dwLastUsed = GetTickCount();

    CLock lock( _queue._mtxLock );
    ActiveItem()->Release();

    lokSetActiveItem( 0 );

    vqDebugOut(( DEB_ITRACE, "Worker 0x%x: SET completion\n", this ));
    _evtDone.Set();
}

//+-------------------------------------------------------------------------
//
//  Member:     CWorkThread::WaitForCompletion, public
//
//  Synopsis:   Waits for completion of current work item.
//
//  History:    29-Dec-93 KyleP     Created
//
//--------------------------------------------------------------------------

void CWorkThread::WaitForCompletion( PWorkItem * pitem )
{
    {
        CLock lock( _queue._mtxLock );

        if ( ActiveItem() != pitem )
            return;

        vqDebugOut(( DEB_ITRACE, "Worker 0x%x: RESET completion\n", this ));
        _evtDone.Reset();
    }

    vqDebugOut(( DEB_ITRACE, "Worker 0x%x: WAIT for completion\n", this ));
    _evtDone.Wait( INFINITE, TRUE );
} //WaitForCompletion

//+-------------------------------------------------------------------------
//
//  Member:     CWorkThread::DeferAPC, public
//
//  Synopsis:   Puts the work item on a list to be called back later when
//              no APC is being processed.
//
//  History:    17-Jul-00 dlee     Created
//
//--------------------------------------------------------------------------

void CWorkThread::DeferAPC( PWorkItem * pItem )
{
    //
    // Make sure the thread doesn't go away until all APCs are processed.
    //

    Win4Assert( _Thread.GetThreadId() == GetCurrentThreadId() );

    AddRef();

    //
    // Add the item to the list.
    // No locking is needed since only this thread can call it.

    pItem->Link( _pDeferredAPCs );
    _pDeferredAPCs = pItem;
} //DeferAPC

//+-------------------------------------------------------------------------
//
//  Member:     CWorkThread::SetProcessingAPC, public
//
//  Synopsis:   Sets the flags that keep track of whether APC work is going
//              on.
//
//  Arguments:  [f]  -- TRUE if processing an APC or FALSE if all done.
//
//  History:    7-Jan-01 dlee     Created
//
//--------------------------------------------------------------------------

void CWorkThread::SetProcessingAPC( BOOL f )
{
    _fProcessingAPC = f;

    if ( f )
        _queue.IncrementAPC();
    else
        _queue.DecrementAPC();
} //SetProcessingAPC
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\qperf\cidata.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1993 - 1998.
//
//  File:       cidata.cxx
//
//  Contents:   the initialized Object and Counter definition for Content Index
//              performance DLL
//
//  History:    23-March-94     t-joshh     Created
//
//----------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include <perfci.hxx>

//
// For Content Index
//

CI_DATA_DEFINITION CIDataDefinition;

//
// For Content Filter
//

FILTER_DATA_DEFINITION FILTERDataDefinition;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\ntciutil\sysimprs.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 2000.
//
//  File:       imprsnat.cxx
//
//  Contents:   
//
//  Classes:    
//
//  Functions:  
//
//  History:    2-16-96   srikants   Created
//
//----------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include <imprsnat.hxx>
#include <ciregkey.hxx>

BOOL CImpersonateSystem::_fIsRunningAsSystem = TRUE;

BOOL CImpersonateSystem::IsRunningAsSystem()
{
    return CImpersonateSystem::_fIsRunningAsSystem;
}

void CImpersonateSystem::SetRunningAsSystem()
{
    CImpersonateSystem::_fIsRunningAsSystem = TRUE;
}


//+---------------------------------------------------------------------------
//
//  Member:     CImpersonateSystem::MakePrivileged
//
//  Synopsis:   This call makes the caller a "privileged" user by reverting
//              to the "original" context.
//
//  History:    2-19-96   srikants   Created
//
//  Notes:      We are assuming that the "original" context of the thread
//              is a "privileged" context.
//
//----------------------------------------------------------------------------

void CImpersonateSystem::MakePrivileged()
{
    Win4Assert( !_fRevertedToSystem );

    //
    // The typical path here is failure, and it's expensive for NT to
    // convert the NTSTATUS to a Win32 error.  So call NT.
    //

    NTSTATUS status = NtOpenThreadToken( GetCurrentThread(),
                                         TOKEN_DUPLICATE | TOKEN_QUERY |
                                             TOKEN_IMPERSONATE,
                                         TRUE,  // Access check against the process
                                         &_hClientToken );
    
    if ( NT_ERROR( status ) )
    {
        if ( ( STATUS_NO_TOKEN == status ) ||
             ( STATUS_ACCESS_DENIED == status ) )
        {
            //
            // This thread is currently not impersonating anyone. We don't
            // have to become system. We should already have the correct
            // privileges.  Or we're in asp.net and can't get the token.
            //
        }
        else
        {
            ciDebugOut(( DEB_ERROR,
                         "NtOpenThreadToken() failed with error %#x\n",
                         status ));
            THROW( CException( status ) );
        }
    }
    else
    {
        _fRevertedToSystem = RevertToSelf();

        //
        // NTRAID#DB-NTBUG9-84492-2000/07/31-dlee Indexing Service assumes in multiple places that RevertToSelf will always succeed
        // what should we do if we fail to revert to self?
        //

        if ( !_fRevertedToSystem )
        {
            ciDebugOut(( DEB_ERROR,
                "RevertToSelf() failed with error %d\n", GetLastError() ));
        }
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CImpersonateSystem::~CImpersonateSystem
//
//  Synopsis:   ~dtor of the CImpersonateSystem class. Will restore the
//              context of the thread before making it privileged.
//
//  History:    2-19-96   srikants   Created
//
//  Notes:      
//
//----------------------------------------------------------------------------

CImpersonateSystem::~CImpersonateSystem()
{
    if ( _fRevertedToSystem )
    {
        Win4Assert( INVALID_HANDLE_VALUE != _hClientToken );
        BOOL fResult = ImpersonateLoggedOnUser( _hClientToken );
        if ( !fResult )
        {
            DWORD dwError = GetLastError();
            ciDebugOut(( DEB_ERROR, "ImpersonateLoggedOnUser failed with error code %d\n",
                         dwError ));
        }
    }

    if ( INVALID_HANDLE_VALUE != _hClientToken )
    {
        CloseHandle( _hClientToken );    
    }
}
//+---------------------------------------------------------------------------
//
//  Function:   IsImpersonated
//
//  Synopsis:   Tests if the caller is impersonated.
//
//  Returns:    TRUE if impersonated; FALSE if not.
//
//  History:    12-31-96   srikants   Created
//
//----------------------------------------------------------------------------

BOOL CImpersonateSystem::IsImpersonated()
{
    BOOL fImpersonated = FALSE;

    HANDLE hThreadToken;

    NTSTATUS status = NtOpenThreadToken( GetCurrentThread(),
                                         TOKEN_QUERY,
                                         TRUE,  // Access check against the process
                                         &hThreadToken );
    
    if ( NT_SUCCESS( status ) )
    {
        CloseHandle( hThreadToken );
        fImpersonated = TRUE;
    }
    else
    {
        if ( STATUS_NO_TOKEN != status )
        {
            ciDebugOut(( DEB_ERROR,
                         "NtOpenThreadToken() failed with error %#x\n",
                         status ));
            fImpersonated = TRUE;
        }
    }

    return fImpersonated;
}

//+---------------------------------------------------------------------------
//
//  Member:     CImpersonateClient::Impersonate
//
//  Synopsis:   Assume a client context.
//
//  History:    19 Mar 96   AlanW    Created
//
//  Notes:      We are assuming that the "original" context of the thread
//              is a "privileged" context.
//
//----------------------------------------------------------------------------

void CImpersonateClient::Impersonate()
{
    if ( INVALID_HANDLE_VALUE != _hClientToken )
    {
        BOOL fResult = ImpersonateLoggedOnUser( _hClientToken );
        if ( !fResult )
        {
            ciDebugOut(( DEB_ERROR,
                         "ImpersonateLoggedOnUser failed with error code %d\n",
                         GetLastError() ));
        }
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CImpersonateClient::~CImpersonateClient
//
//  Synopsis:   ~dtor of the CImpersonateClient class.  Will restore the
//              context of the thread before impersonating (assumed to be
//              running as "system" previously).
//
//  History:    19 Mar 96   AlanW    Created
//
//  Notes:      
//
//----------------------------------------------------------------------------

CImpersonateClient::~CImpersonateClient()
{
    if ( INVALID_HANDLE_VALUE != _hClientToken )
    {
        BOOL fRevertedToSystem = RevertToSelf();

        if ( !fRevertedToSystem )
        {
            ciDebugOut(( DEB_ERROR,
                         "RevertToSelf() failed with error %d\n",
                         GetLastError() ));
        }
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   VerifyThreadHasAdminPrivilege, public
//
//  Synopsis:   Checks to see if the client has administrative access.
//
//  Arguments:  - NONE -
//
//  Returns:    Nothing, throws if access is denied.
//
//  Notes:      The ACL on the HKEY_CURRENT_MACHINE\system\CurrentControlSet\
//              Control\ContentIndex registry key is used to determine if
//              access is permitted.
//
//  History:    26 Jun 96   AlanW       Created.
//  History:     1 Oct 96   dlee        Stole from idq and renamed
//
//----------------------------------------------------------------------------

void VerifyThreadHasAdminPrivilege()
{
    HKEY hNewKey = (HKEY) INVALID_HANDLE_VALUE;
    LONG dwError = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                                 wcsRegAdminSubKey,
                                 0,
                                 KEY_WRITE,
                                 &hNewKey );

    if ( ERROR_SUCCESS == dwError )
    {
        RegCloseKey( hNewKey );
    }
    else if ( ERROR_ACCESS_DENIED == dwError )
    {
        THROW( CException( STATUS_ACCESS_DENIED ) );
    }
    else
    {
        ciDebugOut(( DEB_ERROR,
                     "Can't open reg key %ws, error %d\n",
                     wcsRegAdminSubKey, dwError ));
        THROW( CException( HRESULT_FROM_WIN32( dwError ) ) );
    }
} //VerifyThreadHasAdminPrivilege
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\qperf\idqperf.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996-1999
//
//  File:       IdqPerf.hxx
//
//  Contents:   Perfmon counters for ISAPI search engine.
//
//  History:    15-Mar-1996   KyleP    Created (from perfci.hxx)
//
//----------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include <idqperf.hxx>
#include <smem.hxx>

#include "prfutil.hxx"

//
// For Ci - ISAPI HTTP
//

CI_ISAPI_DATA_DEFINITION CIISAPIDataDefinition = {
    {   sizeof(CI_ISAPI_DATA_DEFINITION) +
        CI_ISAPI_SIZE_OF_COUNTER_BLOCK,  // Total Bytes ( Size of this header, the counter definitions
                                         // and the size of the actual counter data )
        sizeof(CI_ISAPI_DATA_DEFINITION),// Definition length ( This header and the counter definitions )
        sizeof(PERF_OBJECT_TYPE),     // Header Length ( This header )
        CIISAPIOBJECT,                // Object Name Title Index
        0,                            // Object Name Title
        CIISAPIOBJECT,                // Object Help Title Index
        0,                            // Object Help Title
        PERF_DETAIL_NOVICE,           // Detail Level
        CI_ISAPI_TOTAL_NUM_COUNTERS,  // Number of Counters
        1,                            // Default Counters
        PERF_NO_INSTANCES,            // Num Instances
        0,                            // Code Page
        {0,0},                        // Perf Time
        {0,0}                         // Perf Freq
    },
    {   sizeof(PERF_COUNTER_DEFINITION),    // Number of cache items
        NUM_CACHE_ITEMS,
        0,
        NUM_CACHE_ITEMS,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        NUM_CACHE_ITEMS_OFF
    },
    {   sizeof(PERF_COUNTER_DEFINITION),    // Number of cache hits
        NUM_CACHE_HITS,
        0,
        NUM_CACHE_HITS,
        0,
        -1,
        PERF_DETAIL_NOVICE,
        PERF_RAW_FRACTION,
        sizeof(DWORD),
        NUM_CACHE_HITS_OFF
    },
    {   sizeof(PERF_COUNTER_DEFINITION),    // Base for number of cache hits
        NUM_CACHE_HITS_AND_MISSES_1,
        0,
        NUM_CACHE_HITS_AND_MISSES_1,
        0,
        -1,
        PERF_DETAIL_NOVICE,
        PERF_RAW_BASE,
        sizeof(DWORD),
        NUM_CACHE_HITS_AND_MISSES_OFF
    },
    {   sizeof(PERF_COUNTER_DEFINITION),    // Number of cache misses
        NUM_CACHE_MISSES,
        0,
        NUM_CACHE_MISSES,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_RAW_FRACTION,
        sizeof(DWORD),
        NUM_CACHE_MISSES_OFF
    },
    {   sizeof(PERF_COUNTER_DEFINITION),    // Base for number of cache hits
        NUM_CACHE_HITS_AND_MISSES_2,
        0,
        NUM_CACHE_HITS_AND_MISSES_2,
        0,
        -1,
        PERF_DETAIL_NOVICE,
        PERF_RAW_BASE,
        sizeof(DWORD),
        NUM_CACHE_HITS_AND_MISSES_OFF
    },
    {   sizeof(PERF_COUNTER_DEFINITION),    // Number of running queries
        NUM_RUNNING_QUERIES,
        0,
        NUM_RUNNING_QUERIES,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        NUM_RUNNING_QUERIES_OFF
    },
    {   sizeof(PERF_COUNTER_DEFINITION),    // Total queries
        NUM_TOTAL_QUERIES,
        0,
        NUM_TOTAL_QUERIES,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        NUM_TOTAL_QUERIES_OFF
    },
    {   sizeof(PERF_COUNTER_DEFINITION),    // Number of queries per minute
        NUM_QUERIES_PER_MINUTE,
        0,
        NUM_QUERIES_PER_MINUTE,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        NUM_QUERIES_PER_MINUTE_OFF
    },
    {   sizeof(PERF_COUNTER_DEFINITION),    // Current # of queued requests
        NUM_REQUESTS_QUEUED,
        0,
        NUM_REQUESTS_QUEUED,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        NUM_REQUESTS_QUEUED_OFF
    },
    {   sizeof(PERF_COUNTER_DEFINITION),    // Total # of rejected requests
        NUM_REQUESTS_REJECTED,
        0,
        NUM_REQUESTS_REJECTED,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        NUM_REQUESTS_REJECTED_OFF
    }
};

CNamedSharedMem TheMem;

WCHAR const CIISAPIPerformanceKeyName[] =
        TEXT("SYSTEM\\CurrentControlSet\\Services\\ISAPISearch\\Performance");
WCHAR const FirstCounterKeyName [] = TEXT("First Counter");
WCHAR const FirstHelpKeyName [] = TEXT("First Help");

//+---------------------------------------------------------------------------
//
//  Function:  InitializeCIISAPIerformanceData
//
//  Purpose:   Build and initialize the performance data structure.
//
//  Arguments: [pInstance] -- dummy variable
//
//  History:   15-Mar-96   KyleP   Created
//
//----------------------------------------------------------------------------

DWORD InitializeCIISAPIPerformanceData( LPWSTR pInstance )
{
    //
    // Some apps open perfmon keys more than once and Done() doesn't
    // free any resources, do don't bother refcounting.
    //

    static BOOL fInit = FALSE;

    if ( fInit )
        return NO_ERROR;

    CTranslateSystemExceptions translate;
    TRY
    {
        if ( !TheMem.Ok() )
            TheMem.OpenForRead( CI_ISAPI_PERF_SHARED_MEM );

        //
        // If no IDQ queries have been issued, there will be no memory, but
        // don't fail the initialize; just return 0 data in Collect().
        // This (apparently) is the intended design of perfmon.
        //

        if ( 0 == TheMem.GetPointer() )
            return NO_ERROR; //the collect function will just return no data
    }
    CATCH( CException, e )
    {
        return NO_ERROR; // the collect function will just return no data
    }
    END_CATCH;

    //
    //  Open the registry which contain the last key's index
    //

    HKEY hKeyPerf = 0;
    LONG status = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                                CIISAPIPerformanceKeyName,
                                0L,
                                KEY_READ,
                                &hKeyPerf );

    if (status != ERROR_SUCCESS)
    {
        RegCloseKey( hKeyPerf );
        //ciGibDebugOut(( DEB_ERROR, "Error in RegOpenKeyEx\n"));
        return status;
    }

    //
    //  Get the index of the first counter
    //
    DWORD type;
    DWORD dwFirstCounter;
    DWORD size = sizeof dwFirstCounter;
    status = RegQueryValueEx( hKeyPerf, FirstCounterKeyName, 0L, &type,
                              (LPBYTE)&dwFirstCounter, &size);

    if (status != ERROR_SUCCESS)
    {
        //ciGibDebugOut(( DEB_ERROR, "Error in Query First Counter\n"));
        RegCloseKey( hKeyPerf );
        return status;
    }

    //
    //  Get the index of the first help
    //
    DWORD dwFirstHelp;
    size = sizeof dwFirstHelp;
    status = RegQueryValueEx( hKeyPerf, FirstHelpKeyName,
                              0L, &type, (LPBYTE)&dwFirstHelp, &size );

    if (status != ERROR_SUCCESS)
    {
        //ciGibDebugOut(( DEB_ERROR, "Error in Query First Help Key\n"));
        RegCloseKey( hKeyPerf );
        return status;
    }

    //
    //  Update the index of both title and help of each counter
    //

    CIISAPIDataDefinition.CIISAPIObjectType.ObjectNameTitleIndex += dwFirstCounter;
    CIISAPIDataDefinition.CIISAPIObjectType.ObjectHelpTitleIndex += dwFirstHelp;

    PERF_COUNTER_DEFINITION * pTmp = (PERF_COUNTER_DEFINITION *) ((BYTE *)&CIISAPIDataDefinition
                                     + sizeof(PERF_OBJECT_TYPE) );

    for ( unsigned i = 0;
          i < CIISAPIDataDefinition.CIISAPIObjectType.NumCounters;
          i++ )
    {
        pTmp->CounterNameTitleIndex += dwFirstCounter;
        pTmp->CounterHelpTitleIndex += dwFirstHelp;
        pTmp++;
    }

    //
    //  Close the registry key
    //

    RegCloseKey( hKeyPerf );

    //
    // set the flag to TRUE
    //

    //ciGibDebugOut((DEB_ITRACE, "InitializeFilterPerformanceData : Done\n" ));
    fInit = TRUE;

    return ERROR_SUCCESS;
} //InitializeCIISAPIPerformanceData

//+---------------------------------------------------------------------------
//
//  Function : CollectCIISAPIPerformanceData
//
//  Purpose :  Collect Performance Data of Content Index to PerfMon
//
//  Arguments:
//    [lpValueName] -- pointer to a wide character string passed by registry
//
//    [lppData] -- IN: pointer to the address of the buffer to receive the
//                 completed PerfDataBlock and subordinate structures. This
//                 routine will append its data to the buffer starting at
//                 the point referenced by *lppData.
//
//                 OUT: points to the first byte after the data structure
//                 added by this routine. This routine updated the value at
//                 lppdata after appending its data.
//
//    [lpcbTotalBytes] -- IN: the address of the DWORD that tells the size in bytes
//                        of the buffer referenced by the lppData argument
//
//                        OUT: the number of bytes added by this routine is written
//                        to the DWORD pointed to by this argument
//
//    [lpNumObjectTypes] -- IN: the address of the DWORD to receive the number of
//                          objects added by this routine
//
//                          OUT: the number of objects added by this routine is written
//                          to the DWORD pointed to by this argument
//
//  History :   23-March-94     t-joshh     Created
//
//  Return : ERROR_MORE_DATA if the size of the input buffer is too small
//           ERROR_SUCCESS   if success
//----------------------------------------------------------------------------

DWORD CollectCIISAPIPerformanceData( LPWSTR  lpValueName,
                                     LPVOID  *lppData,
                                     LPDWORD lpcbTotalBytes,
                                     LPDWORD lpNumObjectTypes )
{
    //
    // see if this is a foreign (i.e. non-NT) computer data request
    //

    DWORD dwQueryType = GetQueryType (lpValueName);

    if ( ( QUERY_FOREIGN == dwQueryType ) ||
         ( !TheMem.Ok() ) )
    {
        //
        // This routine does not service requests for data from
        // Non-NT computers.  Or if Init() failed.
        //
        *lpcbTotalBytes = (DWORD) 0;
        *lpNumObjectTypes = (DWORD) 0;
        return( ERROR_SUCCESS );
    }

    //
    // If the caller only wanted some counter, check if we have them
    //

    if ( dwQueryType == QUERY_ITEMS )
    {
        WCHAR wcsNum[50];
        _ultow( CIISAPIDataDefinition.CIISAPIObjectType.ObjectNameTitleIndex,
                wcsNum,
                10 );

        if ( 0 == wcsstr( lpValueName, wcsNum ) )
        {
            //
            // request received for data object not provided by this routine
            //

            *lpcbTotalBytes = (DWORD) 0;
            *lpNumObjectTypes = (DWORD) 0;
            return( ERROR_SUCCESS );
        }
    }

    //
    //  Check whether there is enough space allocated in the lppData
    //

    ULONG ulSpaceNeeded = CIISAPIDataDefinition.CIISAPIObjectType.TotalByteLength;

    if ( *lpcbTotalBytes < (DWORD) ulSpaceNeeded )
    {
        *lpcbTotalBytes = (DWORD) 0;
        *lpNumObjectTypes = (DWORD) 0;
        return( ERROR_MORE_DATA );
    }


    //
    //  Copy the Data Definition to the buffer first
    //

    CI_ISAPI_DATA_DEFINITION * pCIISAPIDataDefinition =
        (CI_ISAPI_DATA_DEFINITION *) *lppData;

    RtlCopyMemory( pCIISAPIDataDefinition,
                   &CIISAPIDataDefinition,
                   sizeof(CI_ISAPI_DATA_DEFINITION) );

    DWORD * pdwCounter = (DWORD *)( pCIISAPIDataDefinition + 1 );

    //
    // Number of Object are always 1
    //

    *lpNumObjectTypes = 1;

    //
    // Fill in counter block.
    //

    *pdwCounter = CI_ISAPI_SIZE_OF_COUNTER_BLOCK;
    pdwCounter++;

    RtlCopyMemory( pdwCounter, TheMem.GetPointer(), CI_ISAPI_SIZE_OF_COUNTER_BLOCK - sizeof(DWORD) );

    //
    //  Fill in the number of bytes copied including object and counter
    //  definition and counter data
    //

    *lpcbTotalBytes = ulSpaceNeeded;
    *lppData = (void *) (((BYTE *) *lppData) + ulSpaceNeeded);

    return ERROR_SUCCESS;
} //CollectCIISAPIPerformanceData

//+---------------------------------------------------------------------------
//
//  Function :  DoneCIISAPIPerformanceData
//
//  Purpose :   dummy function
//
//  Argument :  none
//
//  History :   23-March-94     t-joshh     Created
//
//----------------------------------------------------------------------------

DWORD DoneCIISAPIPerformanceData ( void )
{
    return ERROR_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\qperf\perfci.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1993 - 2002.
//
//  File:       perfCI.cxx
//
//  Contents:   Functions for collecting data to Performance Monitor
//
//  History:    23-March-94     t-joshh    Created
//              10-May-99       dlee       Cleanup
//
//----------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include <perfci.hxx>

#include "prfutil.hxx"
#include "perfobj2.hxx"

extern FILTER_DATA_DEFINITION FILTERDataDefinition;
extern CI_DATA_DEFINITION CIDataDefinition;

extern BOOL g_fPerfmonCounterHackIsProcessDetached;

CReadUserPerfData   * g_pReadUserPerfData = 0;
CReadKernelPerfData * g_pReadKernelPerfData = 0;

WCHAR FILTERPerformanceKeyName[] =
        TEXT("SYSTEM\\CurrentControlSet\\Services\\ContentFilter\\Performance");
WCHAR CIPerformanceKeyName[] =
        TEXT("SYSTEM\\CurrentControlSet\\Services\\ContentIndex\\Performance");

WCHAR FirstCounterKeyName [] = TEXT("First Counter");
WCHAR FirstHelpKeyName [] = TEXT("First Help");

const CI_DATA_DEFINITION CIDataDefinitionFixed = {
    {   sizeof(CI_DATA_DEFINITION)+
        CI_SIZE_OF_COUNTER_BLOCK,     // Total Bytes ( Size of this header, the counter definitions
                                      // and the size of the actual counter data )
        sizeof(CI_DATA_DEFINITION),   // Definition length ( This header and the counter definitions )
        sizeof(PERF_OBJECT_TYPE),     // Header Length ( This header )
        CIOBJECT,                     // Object Name Title Index
        0,                            // Object Name Title
        CIOBJECT,                     // Object Help Title Index
        0,                            // Object Help Title
        PERF_DETAIL_NOVICE,           // Detail Level
        CI_TOTAL_NUM_COUNTERS,        // Number of Counters
        0,                            // Default Counters
        0,                            // Num Instances
        0,                            // Code Page
        {0,0},                        // Perf Time
        {0,0}                         // Perf Freq
    },
    {   sizeof(PERF_COUNTER_DEFINITION),    // Wordlist
        NUM_WORDLIST,
        0,
        NUM_WORDLIST,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        NUM_WORDLIST_OFF
    },
    {   sizeof(PERF_COUNTER_DEFINITION),    // PersistentIndex
        NUM_PERSISTENT_INDEX,
        0,
        NUM_PERSISTENT_INDEX,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        NUM_PERSISTENT_INDEX_OFF
    },
    {   sizeof(PERF_COUNTER_DEFINITION),    // Index Size
        INDEX_SIZE,
        0,
        INDEX_SIZE,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        INDEX_SIZE_OFF
    },
    {   sizeof(PERF_COUNTER_DEFINITION),    // Files to-be-filtered
        FILES_TO_BE_FILTERED,
        0,
        FILES_TO_BE_FILTERED,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        FILES_TO_BE_FILTERED_OFF
    },
    {   sizeof(PERF_COUNTER_DEFINITION),    // Number of unique keys
        NUM_UNIQUE_KEY,
        0,
        NUM_UNIQUE_KEY,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        NUM_UNIQUE_KEY_OFF
    },
    {   sizeof(PERF_COUNTER_DEFINITION),    // Running Queries
        RUNNING_QUERIES,
        0,
        RUNNING_QUERIES,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        RUNNING_QUERIES_OFF
    },
    {   sizeof(PERF_COUNTER_DEFINITION),    // Merge Progress
        MERGE_PROGRESS,
        0,
        MERGE_PROGRESS,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        MERGE_PROGRESS_OFF
    },
    {   sizeof(PERF_COUNTER_DEFINITION),    // Number of documents filtered
        DOCUMENTS_FILTERED,
        0,
        DOCUMENTS_FILTERED,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        DOCUMENTS_FILTERED_OFF
    },
    {   sizeof(PERF_COUNTER_DEFINITION),    // Number of unique documents
        NUM_DOCUMENTS,
        0,
        NUM_DOCUMENTS,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        NUM_DOCUMENTS_OFF
    },
    {   sizeof(PERF_COUNTER_DEFINITION),    // Total queries
        TOTAL_QUERIES,
        0,
        TOTAL_QUERIES,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        TOTAL_QUERIES_OFF
    },
    {   sizeof(PERF_COUNTER_DEFINITION),    // Files deferred for filtering (Secondary Q)
        DEFERRED_FILTER_FILES,
        0,
        DEFERRED_FILTER_FILES,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        DEFERRED_FILTER_FILES_OFF
    }
};

const FILTER_DATA_DEFINITION FILTERDataDefinitionFixed = {
    {   sizeof(FILTER_DATA_DEFINITION)+
        FILTER_SIZE_OF_COUNTER_BLOCK, // Total Bytes ( Size of this header, the counter definitions
                                      // and the size of the actual counter data )
        sizeof(FILTER_DATA_DEFINITION),   // Definition length ( This header and the counter definitions )
        sizeof(PERF_OBJECT_TYPE),     // Header Length ( This header )
        FILTEROBJECT,                 // Object Name Title Index
        0,                            // Object Name Title
        FILTEROBJECT,                 // Object Help Title Index
        0,                            // Object Help Title
        PERF_DETAIL_NOVICE,           // Detail Level
        FILTER_TOTAL_NUM_COUNTERS,    // Number of Counters
        0,                            // Default Counters
        0,                            // Num Instances
        0,                            // Code Page
        {0,0},                        // Perf Time
        {0,0}                         // Perf Freq
    },
    {   sizeof(PERF_COUNTER_DEFINITION),    // Total Filter Time
        FILTER_TIME_TOTAL,
        0,
        FILTER_TIME_TOTAL,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        FILTER_TIME_TOTAL_OFF
    },
    {   sizeof(PERF_COUNTER_DEFINITION),    // Binding Time for one file
        BIND_TIME,
        0,
        BIND_TIME,
        0,
        -1,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        BIND_TIME_OFF
    },
    {   sizeof(PERF_COUNTER_DEFINITION),    // Filter Time
        FILTER_TIME,
        0,
        FILTER_TIME,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        FILTER_TIME_OFF
    }
};

//+---------------------------------------------------------------------------
//
//  Function:   CloseKey
//
//  Synopsis:   Close the registry key handle
//
//  Arguments:  [hOpenKey] -- Key.  NULL if closed.
//
//----------------------------------------------------------------------------

inline void CloseKey ( HKEY hOpenKey )
{
   if ( 0 != hOpenKey )
       RegCloseKey (hOpenKey); // close key to registry
}

CStaticMutexSem g_mtxQPerf;   // Serialization during "ReadUser/KernelPerfData"
LONG            g_cKernelRefs = 0;
LONG            g_cUserRefs = 0;
UINT            g_KernSeqNo;  // "CI" sequence number
UINT            g_UserSeqNo;  // "Filter" sequence number

//+---------------------------------------------------------------------------
//
//  Function :  InitializeFILTERPerformanceData
//
//  Purpose :   Build and initialize the performance data structure and create
//              perfCI.ini file
//
//  Arguments :
//              [pInstance] --  dummy variable
//
//  History :   23-March-94     t-joshh     Created
//
//  Note    :   Must start cidaemon before executing this function
//
//----------------------------------------------------------------------------

DWORD InitializeFILTERPerformanceData( LPWSTR pInstance )
{
    CLock lock( g_mtxQPerf );

    g_cUserRefs++;

    if ( g_cUserRefs > 1 )
        return NO_ERROR;

    //
    // Start with a clean slate. Note that in some cases the final Done() may
    // have been called but the dll wasn't unloaded.
    //

    RtlCopyMemory( &FILTERDataDefinition,
                   &FILTERDataDefinitionFixed,
                   sizeof FILTERDataDefinition );

    //
    //  Open the registry which contain the last key's index
    //

    HKEY hKeyPerf = 0;
    LONG status = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                                FILTERPerformanceKeyName,
                                0L, KEY_READ,
                                &hKeyPerf );

    if (status != ERROR_SUCCESS)
    {
        CloseKey( hKeyPerf );
        PerfDebugOut(( DEB_ERROR, "Error in RegOpenKeyEx\n"));
        return status;
    }

    //
    //  Get the index of the first counter
    //

    DWORD dwFirstCounter;
    DWORD size = sizeof dwFirstCounter;
    DWORD type;
    status = RegQueryValueEx( hKeyPerf, FirstCounterKeyName, 0L, &type,
                              (LPBYTE)&dwFirstCounter, &size);

    if (status != ERROR_SUCCESS)
    {
        PerfDebugOut(( DEB_ERROR, "Error in Query First Counter\n"));
        CloseKey( hKeyPerf );
        return status;
    }

    //
    //  Get the index of the first help
    //

    DWORD dwFirstHelp;
    size = sizeof dwFirstHelp;
    status = RegQueryValueEx( hKeyPerf, FirstHelpKeyName,
                              0L, &type, (LPBYTE)&dwFirstHelp, &size );

    if (status != ERROR_SUCCESS)
    {
        PerfDebugOut(( DEB_ERROR, "Error in Query First Help Key\n"));
        CloseKey( hKeyPerf );
        return status;
    }

    //
    //  Update the index of both title and help of each counter
    //

    FILTERDataDefinition.FILTERObjectType.ObjectNameTitleIndex += dwFirstCounter;
    FILTERDataDefinition.FILTERObjectType.ObjectHelpTitleIndex += dwFirstHelp;

    PERF_COUNTER_DEFINITION * pTmp = (PERF_COUNTER_DEFINITION *) ((BYTE *)&FILTERDataDefinition
                                     + sizeof(PERF_OBJECT_TYPE) );

    for ( unsigned i = 0;
          i < FILTERDataDefinition.FILTERObjectType.NumCounters;
          i++)
    {
        pTmp->CounterNameTitleIndex += dwFirstCounter;
        pTmp->CounterHelpTitleIndex += dwFirstHelp;
        pTmp++;
    }

    //
    //  Close the registry key
    //

    CloseKey( hKeyPerf );

    DWORD dwErr = ERROR_SUCCESS;
    BOOL fNoServer = FALSE;

    CTranslateSystemExceptions translate;
    TRY
    {
        if ( 0 == g_pReadUserPerfData )
            g_pReadUserPerfData = new CReadUserPerfData;

        if ( g_pReadUserPerfData->InitForRead() )
            g_UserSeqNo = g_pReadUserPerfData->GetSeqNo();
        else
        {
            fNoServer = TRUE;
            dwErr = ERROR_CAN_NOT_COMPLETE;
        }

        PerfDebugOut((DEB_ITRACE, "InitializeFilterPerformanceData : Done\n" ));
    }
    CATCH( CException, e )
    {
        dwErr = ERROR_CAN_NOT_COMPLETE; // lie here
    }
    END_CATCH;

    if ( NO_ERROR != dwErr )
    {
        delete g_pReadUserPerfData;
        g_pReadUserPerfData = 0;

        // Lie if cisvc isn't running, and Collect() will return no data

        if ( fNoServer )
            dwErr = NO_ERROR;
    }

    return dwErr;
} //InitializeFILTERPerformanceData

//+---------------------------------------------------------------------------
//
//  Function : CollectFILTERPerformanceData
//
//  Purpose :  Collect Performance Data of Content Index to PerfMon
//
//  Arguments:
//    [lpValueName] -- pointer to a wide character string passed by registry
//
//    [lppData] -- IN: pointer to the address of the buffer to receive the
//                 completed PerfDataBlock and subordinate structures. This
//                 routine will append its data to the buffer starting at
//                 the point referenced by *lppData.
//
//                 OUT: points to the first byte after the data structure
//                 added by this routine. This routine updated the value at
//                 lppdata after appending its data.
//
//    [lpcbTotalBytes] -- IN: the address of the DWORD that tells the size in bytes
//                        of the buffer referenced by the lppData argument
//
//                        OUT: the number of bytes added by this routine is written
//                        to the DWORD pointed to by this argument
//
//    [lpNumObjectTypes] -- IN: the address of the DWORD to receive the number of
//                          objects added by this routine
//
//                          OUT: the number of objects added by this routine is written
//                          to the DWORD pointed to by this argument
//
//  History :   23-March-94     t-joshh     Created
//
//  Return : ERROR_MORE_DATA if the size of the input buffer is too small
//           ERROR_SUCCESS   if success
//----------------------------------------------------------------------------

DWORD CollectFILTERPerformanceData( LPWSTR  lpValueName,
                                    LPVOID  *lppData,
                                    LPDWORD lpcbTotalBytes,
                                    LPDWORD lpNumObjectTypes)
{
    //
    // if initial procedure failed, exit
    //
    if ( 0 == g_pReadUserPerfData || !g_pReadUserPerfData->InitOK())
    {
        *lpcbTotalBytes = 0;
        *lpNumObjectTypes = 0;
        return ERROR_SUCCESS; // yes, this is a successful exit
    }

    if ( g_pReadUserPerfData->GetSeqNo() != g_UserSeqNo )
    {
        CLock lock( g_mtxQPerf );

        g_UserSeqNo = g_pReadUserPerfData->GetSeqNo();
        if (!g_pReadUserPerfData->InitForRead())
        {
            *lpcbTotalBytes = 0;
            *lpNumObjectTypes = 0;
            return ERROR_SUCCESS; // yes, this is a successful exit
        }
    }

    //
    // see if this is a foreign (i.e. non-NT) computer data request
    //

    DWORD dwQueryType = GetQueryType (lpValueName);

    if (dwQueryType == QUERY_FOREIGN)
    {
        //
        // this routine does not service requests for data from
        // Non-NT computers
        //
        *lpcbTotalBytes = 0;
        *lpNumObjectTypes = 0;
        return ERROR_SUCCESS;
    }

    //
    // If the caller only wanted some counter, check if we have them
    //

    if (dwQueryType == QUERY_ITEMS)
    {
        if ( !(IsNumberInUnicodeList (
               FILTERDataDefinition.FILTERObjectType.ObjectNameTitleIndex,
                lpValueName)))
        {
            //
            // request received for data object not provided by this routine
            //
            *lpcbTotalBytes = 0;
            *lpNumObjectTypes = 0;
            return ERROR_SUCCESS;
        }
    }

    //
    //  Check whether there is enough space allocated in the lppData
    //

    ULONG ulSpaceNeeded = sizeof(FILTER_DATA_DEFINITION);

    if ( *lpcbTotalBytes < (DWORD) ulSpaceNeeded)
    {
        *lpcbTotalBytes = 0;
        *lpNumObjectTypes = 0;
        return ERROR_MORE_DATA;
    }


    //
    //  Copy the Data Definition to the buffer first
    //

    FILTER_DATA_DEFINITION * pFILTERDataDefinition = (FILTER_DATA_DEFINITION *) *lppData;

    RtlCopyMemory(pFILTERDataDefinition,
           &FILTERDataDefinition,
           sizeof(FILTER_DATA_DEFINITION));

    PERF_INSTANCE_DEFINITION * pFILTERInstanceDefinition = (PERF_INSTANCE_DEFINITION *)( (BYTE *)*lppData
                                                       + sizeof(FILTER_DATA_DEFINITION));

    PerfDebugOut(( DEB_ITRACE, "No. of Instance %d\n", g_pReadUserPerfData->NumberOfInstance() ));

    //
    //  Check how many instance exist (how many OFS drive have cidaemon running on)
    //
    for ( int i = 0;
          i < g_pReadUserPerfData->NumberOfInstance();
          i++ )
    {
        //
        // Check whether there is enough space
        //

        UINT uiLen = wcslen(g_pReadUserPerfData->GetInstanceName(i));
        ulSpaceNeeded += ( sizeof(PERF_INSTANCE_DEFINITION) +
                           FILTER_SIZE_OF_COUNTER_BLOCK +
                           (4+1+uiLen) * sizeof(WCHAR) );

        if ( *lpcbTotalBytes < ulSpaceNeeded )
        {
            *lpcbTotalBytes = 0;
            *lpNumObjectTypes = 0;
            return ERROR_MORE_DATA;
        }

        //
        // Make a copy of the instance name with UNICODE_STRING type
        //

        UNICODE_STRING usName;

        usName.Length = (USHORT) uiLen * sizeof(WCHAR);
        usName.MaximumLength = (USHORT) (uiLen+1)*sizeof(WCHAR);
        usName.Buffer = g_pReadUserPerfData->GetInstanceName(i);

        PERF_COUNTER_BLOCK * pCounterBlock;

        MonBuildInstanceDefinition ( pFILTERInstanceDefinition,
                                     (PVOID *) &pCounterBlock,
                                     0,
                                     0,
                                     PERF_NO_UNIQUE_ID, // use name, not index
                                     &usName );

        pCounterBlock->ByteLength = FILTER_SIZE_OF_COUNTER_BLOCK;

        //
        // Put each counter value into the buffer
        //

        DWORD * pdwCounter = (DWORD *) ((BYTE *)pCounterBlock + sizeof(PERF_COUNTER_BLOCK));

        for ( UINT j = 0 ;
              j < FILTERDataDefinition.FILTERObjectType.NumCounters;
              j++)
        {
            *pdwCounter = g_pReadUserPerfData->GetCounterValue( (int)i, (int)j );
            pdwCounter++;
        }

        //
        // Point to the next location of instance definition
        //

        pFILTERInstanceDefinition = (PERF_INSTANCE_DEFINITION *)pdwCounter;
    }

    *lppData = (LPVOID) pFILTERInstanceDefinition;

    //
    //  Fill in the number of instances
    //

    pFILTERDataDefinition->FILTERObjectType.NumInstances = g_pReadUserPerfData->NumberOfInstance();

    //
    // Number of Object are always 1
    //

    *lpNumObjectTypes = 1;

    //
    //  Fill in the number of bytes copied including object and counter
    //  definition and counter data
    //

    *lpcbTotalBytes = (DWORD) ((BYTE *) *lppData - (BYTE *) pFILTERDataDefinition);

    pFILTERDataDefinition->FILTERObjectType.TotalByteLength = *lpcbTotalBytes;

    PerfDebugOut((DEB_ITRACE, "CollectFilterPerformanceData : Done\n"));

    return ERROR_SUCCESS;
} //CollectFILTERPerformanceData

//+---------------------------------------------------------------------------
//
//  Function :  DoneFILTERPerformanceData
//
//  Purpose :   dummy function
//
//  Argument :  none
//
//  History :   23-March-94     t-joshh     Created
//
//----------------------------------------------------------------------------

DWORD DoneFILTERPerformanceData( void )
{
    CLock lock( g_mtxQPerf );

    //
    // A bug in a perfmon dll makes them call this function after we've
    // been process detached!  They call us in their process detach, which
    // is well after we've been detached and destroyed our heap.
    //

    if ( g_fPerfmonCounterHackIsProcessDetached )
        return ERROR_SUCCESS;

    g_cUserRefs--;

    if ( 0 == g_cUserRefs )
    {
        delete g_pReadUserPerfData;
        g_pReadUserPerfData = 0;
    }

    return ERROR_SUCCESS;
} //DoneFILTERPerformanceData

//+---------------------------------------------------------------------------
//
//  Function :  InitializeCIPerformanceData
//
//  Purpose :   Build and initialize the performance data structure and create
//              perfCI.ini file
//
//  Arguments :
//              [pInstance] --  dummy variable
//
//  History :   23-March-94     t-joshh     Created
//
//----------------------------------------------------------------------------

DWORD InitializeCIPerformanceData( LPWSTR pInstance )
{
    LONG status;
    HKEY hKeyPerf = 0;
    DWORD size;
    DWORD type;
    DWORD dwFirstCounter;
    DWORD dwFirstHelp;

    CLock lock( g_mtxQPerf );

    g_cKernelRefs++;

    if ( g_cKernelRefs > 1 )
        return NO_ERROR;

    //
    // Start with a clean slate. Note that in some cases the final Done() may
    // have been called but the dll wasn't unloaded.
    //

    RtlCopyMemory( &CIDataDefinition,
                   &CIDataDefinitionFixed,
                   sizeof CIDataDefinition );

    //
    //  Open the registry which contain the last key's index
    //
    status = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                           CIPerformanceKeyName,
                           0L, KEY_READ,
                           &hKeyPerf );

    if (status != ERROR_SUCCESS)
    {
        CloseKey( hKeyPerf );
        PerfDebugOut(( DEB_ERROR,  "Error in RegOpenKeyEx\n"));
        return status;
    }

    //
    //  Get the index of the first counter
    //
    size = sizeof (dwFirstCounter);
    status = RegQueryValueEx( hKeyPerf, FirstCounterKeyName, 0L, &type,
                              (LPBYTE)&dwFirstCounter, &size);

    if (status != ERROR_SUCCESS)
    {
        PerfDebugOut(( DEB_ERROR, "Error in Query First Counter\n"));
        CloseKey( hKeyPerf );
        return status;
    }

    //
    //  Get the index of the first help
    //
    size = sizeof (dwFirstHelp);
    status = RegQueryValueEx( hKeyPerf, FirstHelpKeyName,
                              0L, &type, (LPBYTE)&dwFirstHelp, &size );

    if (status != ERROR_SUCCESS)
    {
        PerfDebugOut(( DEB_ERROR, "Error in Query First Help Key\n" ));
        CloseKey( hKeyPerf );
        return status;
    }

    //
    //  Update the index of both title and help of each counter
    //

    CIDataDefinition.CIObjectType.ObjectNameTitleIndex += dwFirstCounter;
    CIDataDefinition.CIObjectType.ObjectHelpTitleIndex += dwFirstHelp;

    PERF_COUNTER_DEFINITION * pTmp = (PERF_COUNTER_DEFINITION *) ((BYTE *)&CIDataDefinition
                                     + sizeof(PERF_OBJECT_TYPE) );

    for ( unsigned i = 0;
          i < CIDataDefinition.CIObjectType.NumCounters;
          i++)
    {
        pTmp->CounterNameTitleIndex += dwFirstCounter;
        pTmp->CounterHelpTitleIndex += dwFirstHelp;
        pTmp += 1;
    }

    //
    //  Close the registry key
    //
    CloseKey( hKeyPerf );

    DWORD dwErr = ERROR_SUCCESS;
    BOOL fNoServer = FALSE;

    CTranslateSystemExceptions translate;
    TRY
    {
        if ( 0 == g_pReadKernelPerfData )
            g_pReadKernelPerfData = new CReadKernelPerfData;

        BOOL fOK = g_pReadKernelPerfData->InitForRead();

        if ( fOK )
            g_KernSeqNo = g_pReadKernelPerfData->GetSeqNo();
        else
        {
            fNoServer = TRUE;
            dwErr = ERROR_CAN_NOT_COMPLETE;
        }

        PerfDebugOut(( DEB_ITRACE, "InitialCIPerformanceData : Finish\n" ));
    }
    CATCH( CException, e )
    {
        dwErr = ERROR_CAN_NOT_COMPLETE; // lie here
    }
    END_CATCH;

    if ( NO_ERROR != dwErr )
    {
        delete g_pReadKernelPerfData;
        g_pReadKernelPerfData = 0;

        // Lie if cisvc isn't running, and Collect() will return no data

        if ( fNoServer )
            dwErr = NO_ERROR;
    }

    return dwErr;
} //InitializeCIPerformanceData

//+---------------------------------------------------------------------------
//
//  Function : CollectCIPerformanceData
//
//  Purpose :  Collect Performance Data of Content Index to PerfMon
//
//  Arguments:
//    [lpValueName] -- pointer to a wide character string passed by registry
//
//    [lppData] -- IN: pointer to the address of the buffer to receive the
//                 completed PerfDataBlock and subordinate structures. This
//                 routine will append its data to the buffer starting at
//                 the point referenced by *lppData.
//
//                 OUT: points to the first byte after the data structure
//                 added by this routine. This routine updated the value at
//                 lppdata after appending its data.
//
//    [lpcbTotalBytes] -- IN: the address of the DWORD that tells the size in bytes
//                        of the buffer referenced by the lppData argument
//
//                        OUT: the number of bytes added by this routine is written
//                        to the DWORD pointed to by this argument
//
//    [lpNumObjectTypes] -- IN: the address of the DWORD to receive the number of
//                          objects added by this routine
//
//                          OUT: the number of objects added by this routine is written
//                          to the DWORD pointed to by this argument
//
//  History :   23-March-94     t-joshh     Created
//
//  Return : ERROR_MORE_DATA if the size of the input buffer is too small
//           ERROR_SUCCESS   if success
//----------------------------------------------------------------------------

DWORD CollectCIPerformanceData( LPWSTR  lpValueName,
                                LPVOID  *lppData,
                                LPDWORD lpcbTotalBytes,
                                LPDWORD lpNumObjectTypes)
{
    ULONG ulSpaceNeeded = 0;
    DWORD dwQueryType;

    //
    // if initial procedure failed, exit
    //
    if ( 0 == g_pReadKernelPerfData || !g_pReadKernelPerfData->InitOK())
    {
        *lpcbTotalBytes = 0;
        *lpNumObjectTypes = 0;
        return ERROR_SUCCESS; // yes, this is a successful exit
    }

    if ( g_pReadKernelPerfData->GetSeqNo() != g_KernSeqNo )
    {
        CLock lock( g_mtxQPerf );

        g_pReadKernelPerfData->InitForRead();

        if (!g_pReadKernelPerfData->InitOK())
        {
            *lpcbTotalBytes = 0;
            *lpNumObjectTypes = 0;
            return ERROR_SUCCESS; // yes, this is a successful exit
        }

        g_KernSeqNo = g_pReadKernelPerfData->GetSeqNo();
    }

    //
    // see if this is a foreign (i.e. non-NT) computer data request
    //
    dwQueryType = GetQueryType (lpValueName);

    if (dwQueryType == QUERY_FOREIGN)
    {
        //
        // this routine does not service requests for data from
        // Non-NT computers
        //
        *lpcbTotalBytes = 0;
        *lpNumObjectTypes = 0;
        return ERROR_SUCCESS;
    }

    //
    // If the caller only wanted some counter, check if we have them
    //
    if (dwQueryType == QUERY_ITEMS)
    {
        if ( !(IsNumberInUnicodeList(
               CIDataDefinition.CIObjectType.ObjectNameTitleIndex,
               lpValueName)) )
        {
            //
            // request received for data object not provided by this routine
            //
            *lpcbTotalBytes = 0;
            *lpNumObjectTypes = 0;
            return ERROR_SUCCESS;
        }
    }

    //
    //  Check whether there is enough space allocated in the lppData
    //

    ulSpaceNeeded = sizeof(CI_DATA_DEFINITION);

    if ( *lpcbTotalBytes < (DWORD) ulSpaceNeeded)
    {
        *lpcbTotalBytes = 0;
        *lpNumObjectTypes = 0;
        return ERROR_MORE_DATA;
    }


    //
    //  Copy the Data Definition to the buffer first
    //
    CI_DATA_DEFINITION * pCIDataDefinition = (CI_DATA_DEFINITION *) *lppData;

    RtlCopyMemory(pCIDataDefinition,
           &CIDataDefinition,
           sizeof(CI_DATA_DEFINITION));

    PERF_INSTANCE_DEFINITION * pCIInstanceDefinition = (PERF_INSTANCE_DEFINITION *)( (BYTE *)*lppData
                                                       + sizeof(CI_DATA_DEFINITION));

    PerfDebugOut(( DEB_ITRACE, "*lppData: %#x\n", *lppData ));
    PerfDebugOut(( DEB_ITRACE, "pCIInstanceDefinition: %#x\n", pCIInstanceDefinition ));

    //
    //  Check how many instance exist (how many OFS drive have cidaemon running on)
    //
    for ( int i = 0;
          i < g_pReadKernelPerfData->NumberOfInstance();
          i++ )
    {
        //
        // Check whether there is enough space
        //

        UINT uiLen = wcslen(g_pReadKernelPerfData->GetInstanceName(i));
        ulSpaceNeeded += ( sizeof(PERF_INSTANCE_DEFINITION) +
                           CI_SIZE_OF_COUNTER_BLOCK +
                           (4+1+uiLen) * sizeof(WCHAR) );

        if ( *lpcbTotalBytes < ulSpaceNeeded )
        {
            *lpcbTotalBytes = (DWORD) 0;
            *lpNumObjectTypes = (DWORD) 0;
            return ERROR_MORE_DATA;
        }

        //
        // Make a copy of the instance name with UNICODE_STRING type
        //

        UNICODE_STRING usName;

        usName.Length = (USHORT) uiLen * sizeof(WCHAR);
        usName.MaximumLength = (USHORT) (uiLen+1)*sizeof(WCHAR);
        usName.Buffer = g_pReadKernelPerfData->GetInstanceName(i);

        PERF_COUNTER_BLOCK * pCounterBlock;

        MonBuildInstanceDefinition ( pCIInstanceDefinition,
                                     (PVOID *) &pCounterBlock,
                                     0,
                                     0,
                                     PERF_NO_UNIQUE_ID, // use name, not index
                                     &usName );

        pCounterBlock->ByteLength = CI_SIZE_OF_COUNTER_BLOCK;

        //
        // Refresh the buffer
        //
        g_pReadKernelPerfData->Refresh( i );

        //
        // Put each counter value into the buffer
        //
        DWORD * pdwCounter = (DWORD *) ((BYTE *)pCounterBlock + sizeof(PERF_COUNTER_BLOCK));

        for ( UINT j = 0 ;
              j < CIDataDefinition.CIObjectType.NumCounters;
              j++)
        {
            *pdwCounter = g_pReadKernelPerfData->GetCounterValue( (int)j );
            pdwCounter++;
        }

        //
        // Point to the next location of instance definition
        //
        pCIInstanceDefinition = (PERF_INSTANCE_DEFINITION *)pdwCounter;
    }

    *lppData = (LPVOID) pCIInstanceDefinition;

    //
    //  Fill in the number of instances
    //
    pCIDataDefinition->CIObjectType.NumInstances = g_pReadKernelPerfData->NumberOfInstance();

    //
    // Number of Object are always 1
    //
    *lpNumObjectTypes = 1;

    //
    //  Fill in the number of bytes copied including object and counter
    //  definition and counter data
    //
    *lpcbTotalBytes = (DWORD) ((BYTE *) *lppData - (BYTE *) pCIDataDefinition);

    pCIDataDefinition->CIObjectType.TotalByteLength = *lpcbTotalBytes;

    PerfDebugOut(( DEB_ITRACE, "CollectCIPerformanceData : Done\n" ));

    Win4Assert( *lpcbTotalBytes == EIGHT_BYTE_MULTIPLE(*lpcbTotalBytes) );
    return ERROR_SUCCESS;
} //CollectCIPerformanceData

//+---------------------------------------------------------------------------
//
//  Function :  DoneCIPerformanceData
//
//  Purpose :   dummy function
//
//  Argument :  none
//
//  History :   23-March-94     t-joshh     Created
//
//----------------------------------------------------------------------------

DWORD DoneCIPerformanceData( void )
{
    CLock lock( g_mtxQPerf );

    //
    // A bug in a perfmon dll makes them call this function after we've
    // been process detached!  They call us in their process detach, which
    // is well after we've been detached and destroyed our heap.
    //

    if ( g_fPerfmonCounterHackIsProcessDetached )
        return ERROR_SUCCESS;

    g_cKernelRefs--;

    if ( 0 == g_cKernelRefs )
    {
        delete g_pReadKernelPerfData;
        g_pReadKernelPerfData = 0;
    }

    return ERROR_SUCCESS;
} //DoneCIPerformanceData
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\qperf\perfobj2.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1993 - 2000.
//
//  File:       perfobj.cxx
//
//  Contents:   Performance Data Object
//
//  Classes :   CPerfMon, PPerfCounter,
//              CPerfCount, CPerfTime,
//              CReadUserPerfData
//
//  History:    23-March-94     t-joshh    Created
//
//----------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include <mutex.hxx>
#include <perfci.hxx>

#include "perfobj2.hxx"

extern CI_DATA_DEFINITION     CIDataDefinition;
extern FILTER_DATA_DEFINITION FILTERDataDefinition;

#define FILTERTOTALCOUNTER ((int) FILTERDataDefinition.FILTERObjectType.NumCounters)
#define CITOTALCOUNTER  ((int) CIDataDefinition.CIObjectType.NumCounters)

//
// Total size occupied by the counters
//
#define TOTALCOUNTERSIZE ( (FILTERTOTALCOUNTER + CITOTALCOUNTER ) * sizeof(DWORD) )

//+---------------------------------------------------------------------------
//
//  Function :  CReadUserPerfData::CReadUserPerfData
//
//  Purpose :   Constructor
//
//  Arguments : none
//
//  History :   23-March-94     t-joshh     Created
//
//----------------------------------------------------------------------------

CReadUserPerfData::CReadUserPerfData() :
   _cInstances( 0 ),
   _finitOK( FALSE ),
   _cCounters( 0 ),
   _pSeqNo( 0 ),
   _cMaxCats( 0 ),
   _cbPerfHeader( 0 )
{
}

//+---------------------------------------------------------------------------
//
//  Function :  CReadUserPerfData::Finish
//
//  Purpose :   Close and clean up the handles
//
//  Arguments : none
//
//  History :   23-March-94     t-joshh     Created
//
//  Note:       Must execute when done with getting the data
//
//----------------------------------------------------------------------------

void CReadUserPerfData::Finish()
{
    CleanupForReInit();
    _xSharedMemObj.Free();
}

//+---------------------------------------------------------------------------
//
//  Member:     CReadUserPerfData::CleanupForReInit
//
//  Synopsis:   Cleans up the data structures in preparation for a
//              re-initialization. Only the data which needs to be re-read
//              and initialized is thrown away. The Shared memory object is
//              NOT deleted because it is system-wide state and there is no
//              need to throw it away.
//
//  History:    6-21-96   srikants   Created
//
//----------------------------------------------------------------------------

void CReadUserPerfData::CleanupForReInit()
{
}

//+---------------------------------------------------------------------------
//
//  Function :  CReadUserPerfData::InitforRead
//
//  Purpose :   Initialize to be ready for reading the perf. data
//
//  Arguments : none
//
//  History :   23-March-94     t-joshh     Created
//
//  Note:       Must be executed before any operations
//
//  Return :    TRUE -- success, FALSE -- failed
//
//----------------------------------------------------------------------------

BOOL CReadUserPerfData::InitForRead()
{
    if ( _xSharedMemObj.IsNull() )
    {
        ULONG cbCatBitfield, cbSharedMem;

        ComputeCIPerfmonVars( _cMaxCats, cbCatBitfield, _cbPerfHeader, cbSharedMem );

        //
        // Open the shared memory
        //

        _xSharedMemObj.Set( new CNamedSharedMem() );

        BOOL fOK = _xSharedMemObj->OpenForRead( CI_PERF_MEM_NAME );

        if ( !fOK )
            return FALSE;

        _pSeqNo = (UINT *) (((BYTE *)_xSharedMemObj->Get())+sizeof(int) + cbCatBitfield);
    }

    if ( _finitOK )
        CleanupForReInit();

    _finitOK = FALSE;

    if ( _xSharedMemObj->Ok() )
    {
        _cInstances = *((int *)_xSharedMemObj->Get());

        PerfDebugOut(( DEB_ITRACE, "!!! Reader : No. of Instance : %d\n", _cInstances ));

        _cCounters = FILTERTOTALCOUNTER;

        _finitOK = TRUE;
        return TRUE;
    }

    return FALSE;
} //InitForRead

//+---------------------------------------------------------------------------
//
//  Function :  CReadUserPerfData::NumberOfInstance
//
//  Purpose :   Return the number of existing instances
//
//  Arguments : none
//
//  History :   23-March-94     t-joshh     Created
//
//----------------------------------------------------------------------------

int CReadUserPerfData::NumberOfInstance()
{
    return _cInstances;
}

UINT CReadUserPerfData::GetSeqNo() const
{
    return _pSeqNo ? *_pSeqNo : 0;
}

//+---------------------------------------------------------------------------
//
//  Function :  CReadUserPerfData::GetInstanceName
//
//  Purpose :   Return the specified instance's name
//
//  Arguments : [iWhichOne] -- which instance
//
//  History :   23-March-94     t-joshh     Created
//
//----------------------------------------------------------------------------

WCHAR * CReadUserPerfData::GetInstanceName ( int iWhichOne )
{
    if ( !_xSharedMemObj.IsNull() && _xSharedMemObj->Ok() )
    {
        //
        // Find the corresponding slot in the shared memory
        //

        BYTE * pbBitfield = (BYTE *) _xSharedMemObj->Get() + sizeof(int);
        CBitfield bits( pbBitfield );

        int i = 0;

        for ( int j = 0; j <= iWhichOne && i < (int) _cMaxCats; i++ )
        {
           if ( bits.IsBitSet( i ) )
               j++;
        }

        iWhichOne = i - 1;

        ULONG ByteToSkip = _cbPerfHeader +
                           ( iWhichOne * cbPerfCatalogSlot ) +
                           sizeof(int);

        return( (WCHAR *)((BYTE *)_xSharedMemObj->Get() + ByteToSkip) );
    }

    return 0;
} //GetInstanceName

//+---------------------------------------------------------------------------
//
//  Function :  CReadUserPerfData::GetCounterValue
//
//  Purpose :   Return the value of the specified counter
//
//  Arguments : [iWhichInstance] --  which instance of object does the
//                                   counter belong to
//              [iWhichCounter] --   which counter
//
//  History :   23-March-94     t-joshh     Created
//
//----------------------------------------------------------------------------

DWORD CReadUserPerfData::GetCounterValue( int iWhichInstance, int iWhichCounter )
{
    if ( !_xSharedMemObj.IsNull() && _xSharedMemObj->Ok() )
    {
        //
        // Find the corresponding slot
        //

        BYTE * pbBitfield = (BYTE *) _xSharedMemObj->Get() + sizeof(int);
        CBitfield bits( pbBitfield );

        int i = 0;
        for ( int j = 0; j <= iWhichInstance && i < (int) _cMaxCats; i++ )
        {
           if ( bits.IsBitSet( i ) )
               j++;
        }

        int iWhichSlot = i - 1;

        PerfDebugOut(( DEB_ITRACE, "Choose slot %i\n", iWhichSlot));

        ULONG ByteToSkip = _cbPerfHeader
                           + ( iWhichSlot * cbPerfCatalogSlot )
                           + sizeof(int)
                           + ( CI_PERF_MAX_CATALOG_LEN * sizeof(WCHAR) )  // Name of the instance
                           + ( iWhichCounter * sizeof(DWORD) );

        return *(DWORD *)((BYTE *)_xSharedMemObj->Get() + ByteToSkip);
     }

    return 0;
} //GetCounterValue

//+---------------------------------------------------------------------------
//
//  Function :  CReadKernelPerfData::CReadKernelPerfData
//
//  Purpose :   Constructor
//
//  Arguments : none
//
//  History :   23-March-94     t-joshh     Created
//
//----------------------------------------------------------------------------

CReadKernelPerfData::CReadKernelPerfData() :
   _pSeqNo(0),
   _cInstance( 0 ),
   _finitOK( FALSE ),
   _cCounters( 0 ),
   _cMaxCats( 0 ),
   _cbPerfHeader( 0 ),
   _cbSharedMem( 0 )
{
}

UINT CReadKernelPerfData::GetSeqNo() const
{
    return _pSeqNo ? *_pSeqNo : 0;
}

//+---------------------------------------------------------------------------
//
//  Function :  CReadKernelPerfData::Finish
//
//  Purpose :   Close and clean up the handles
//
//  Arguments : none
//
//  History :   23-March-94     t-joshh     Created
//
//  Note:       Must execute when done with getting the data
//
//----------------------------------------------------------------------------

void CReadKernelPerfData::Finish()
{
    CleanupForReInit();

    _xSharedMemory.Free();
    _xMemory.Free();
    _xCatalogs.Free();
    _xCatalogMem.Free();
}

//+---------------------------------------------------------------------------
//
//  Function :  CReadKernelPerfData::FindDownlevelDrives
//
//  Purpose :   Find the remote drive
//
//  History :   23-Mar-94     t-joshh     Created
//              31-Jan-96     KyleP       Look for all downlevel drives
//
//----------------------------------------------------------------------------

void CReadKernelPerfData::FindDownlevelDrives()
{
    if ( _xSharedMemory->Ok() )
    {
        //
        // Get active drive count and active bit array.
        //

        int cCount = * (int *) _xSharedMemory->Get();
        BYTE * pbBitfield = (BYTE *) _xSharedMemory->Get() + sizeof(int);
        CBitfield bits( pbBitfield );

        //
        // Loop through looking for drives.
        //

        for (int i = 0; cCount > 0 ; cCount--, i++)
        {
            for (; i < (int) _cMaxCats && !bits.IsBitSet( i ); i++) {}

            if ( (int) _cMaxCats == i )
            {
                PerfDebugOut(( DEB_ITRACE, "!!! Error in the empty slot\n"));
                return;
            }
            else
            {
                //
                // Find offset of drive name in shared memory buffer.
                //

                ULONG oCounters = _cbPerfHeader +
                                  (i * cbPerfCatalogSlot) +
                                  sizeof(int);

                WCHAR * wszTmp = (WCHAR *) ((BYTE *) _xSharedMemory->Get() + oCounters);

                //
                // Make sure this isn't already in the list
                //

                for ( int j = 0; j < cCount; j++ )
                {
                    if ( 0 != _xCatalogs[j] && wcscmp( _xCatalogs[j], wszTmp ) == 0 )
                        break;
                }

                //
                // Add downlevel drive.
                //

                if ( j == cCount )
                {
                    PerfDebugOut(( DEB_ITRACE, "!!! Kernel Reader : Downlevel Drive %ws\n", wszTmp ));

                    //
                    // Find offset of first counter.
                    //

                    oCounters += ((sizeof(DWORD) * NUM_KERNEL_AND_USER_COUNTER)
                                 + (CI_PERF_MAX_CATALOG_LEN * sizeof(WCHAR)));
                    _xCatalogMem[_cInstance] = (void *) ((BYTE *) _xSharedMemory->Get() + oCounters);
                    _xCatalogs[_cInstance] = new WCHAR[wcslen(wszTmp) + 1];
                    wcscpy(_xCatalogs[_cInstance++], wszTmp);
                }
            }
        }
    }
} //FindDownlevelDrives

//+---------------------------------------------------------------------------
//
//  Member:     CReadKernelPerfData::CleanupForReInit
//
//  Synopsis:   Cleans up the state and makes it ready for re-initialization.
//
//  History:    6-21-96   srikants   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

void CReadKernelPerfData::CleanupForReInit()
{
    for ( int i = 0; i < _cInstance; i++)
    {
        delete _xCatalogs[i];
        _xCatalogs[i] = 0;
    }

    _cInstance = 0;
}

//+---------------------------------------------------------------------------
//
//  Function :  CReadKernelPerfData::InitForRead
//
//  Purpose :   Initialize to be ready for reading the perf. data
//
//  Arguments : none
//
//  History :   23-Mar-94     t-joshh     Created
//              31-Jan-96     KyleP       Improvements for downlevel CI
//
//  Note:       Must be executed before any operations
//
//----------------------------------------------------------------------------

BOOL CReadKernelPerfData::InitForRead()
{
    if ( _xSharedMemory.IsNull() )
    {
        ULONG cbCatBitfield;

        ComputeCIPerfmonVars( _cMaxCats, cbCatBitfield, _cbPerfHeader, _cbSharedMem );

        //
        // Open the shared memory
        //

        _xSharedMemory.Set( new CNamedSharedMem() );

        BOOL fOK = _xSharedMemory->OpenForRead( CI_PERF_MEM_NAME );

        if ( !fOK )
            return FALSE;

        _pSeqNo = (UINT *) (((BYTE *)_xSharedMemory->Get())+sizeof(int) + cbCatBitfield);
    }

    //
    // Initialize the drive list
    //

    if ( _finitOK )
        CleanupForReInit();

    _finitOK = FALSE;

    if ( _xCatalogs.IsNull() )
        _xCatalogs.Init( _cMaxCats );

    if ( _xCatalogMem.IsNull() )
        _xCatalogMem.Init( _cMaxCats );

    for ( unsigned j = 0; j < _cMaxCats; j++)
    {
        _xCatalogs[j] = 0;
        _xCatalogMem[j] = 0;
    }

    FindDownlevelDrives();

    _cCounters = CITOTALCOUNTER;

    _finitOK = TRUE;

    return TRUE;

    PerfDebugOut(( DEB_ITRACE, "!!! Kernel Reader : Initialize finish\n"));
} //InitForRead

//+---------------------------------------------------------------------------
//
//  Function :  CReadKernelPerfData::NumberOfInstance
//
//  Purpose :   Return the number of existing instances
//
//  Arguments : none
//
//  History :   23-March-94     t-joshh     Created
//
//----------------------------------------------------------------------------

int CReadKernelPerfData::NumberOfInstance()
{
    return _cInstance;
}

//+---------------------------------------------------------------------------
//
//  Function :  CReadKernelPerfData::GetInstanceName
//
//  Purpose :   Return the specified instance's name
//
//  Arguments : [iWhichOne] -- which instance
//
//  History :   23-March-94     t-joshh     Created
//
//----------------------------------------------------------------------------

WCHAR * CReadKernelPerfData::GetInstanceName ( int iWhichOne )
{
    return _xCatalogs[iWhichOne];
}

//+---------------------------------------------------------------------------
//
//  Function :  CReadKernelPerfData::Refresh
//
//  Purpose :   Retrieve the most updated data
//
//  Arguments : [iWhichInstance] --  which instance of object does the
//                                   counter belong to
//
//  History :   23-March-94     t-joshh     Created
//
//----------------------------------------------------------------------------
BOOL CReadKernelPerfData::Refresh( int iWhichInstance )
{
    //
    // the instance is either downlevel drive or remote drive
    //

    Win4Assert( 0 != _cbSharedMem );

    if ( _xMemory.IsNull() )
        _xMemory.Init( _cbSharedMem );

    ULONG oCounters = _cbPerfHeader +
                      sizeof(int) +
                      (CI_PERF_MAX_CATALOG_LEN * sizeof WCHAR);

    if ( _xCatalogMem.IsNull() )
        _xCatalogMem.Init( _cMaxCats );

    void * pvTmp = _xCatalogMem[iWhichInstance];

    for ( int j = 0; j < CITOTALCOUNTER; j++)
    {
        *(DWORD *)(_xMemory.GetPointer() + oCounters) = *(DWORD *)pvTmp;

        oCounters += sizeof(DWORD);
        pvTmp = (void *)((BYTE *)pvTmp + sizeof(DWORD));
    }

    return TRUE;
} //Refresh

//+---------------------------------------------------------------------------
//
//  Function :  CReadKernelPerfData::GetCounterValue
//
//  Purpose :   Return the value of the specified counter
//
//  Arguments : [iWhichCounter] --   which counter
//
//  History :   23-March-94     t-joshh     Created
//
//----------------------------------------------------------------------------

DWORD CReadKernelPerfData::GetCounterValue( int iWhichCounter )
{
   if ( !_xMemory.IsNull() )
   {
      ULONG ByteToSkip = _cbPerfHeader
                         + sizeof(int)
                         + (CI_PERF_MAX_CATALOG_LEN * sizeof WCHAR)  // Name of the instance
                         + ( iWhichCounter * sizeof(DWORD) );

      return *(DWORD *)(_xMemory.GetPointer() + ByteToSkip);
   }

   return 0;
} //GetCounterValue
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\qperf\prfutil.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 2001.
//
//  File :      prfutil.CXX
//
//  Contents :  Utility procedures stolen from the VGACTRS code in the DDK
//
//  History:    22-Mar-94   t-joshh    Created
//
//----------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#define DEFINE_STRING
#include "prfutil.hxx"

WCHAR const wcsGlobal[] =  L"Global";
WCHAR const wcsForeign[] = L"Foreign";
WCHAR const wcsCostly[] =  L"Costly";

QueryType GetQueryType( WCHAR * lpValue )
{
    if (lpValue == 0)
        return QUERY_GLOBAL;
    else if (*lpValue == 0)
        return QUERY_GLOBAL;

    //
    // check for "Global" request
    //

    unsigned ccValue = wcslen( lpValue ) + 1;

    if ( ccValue == sizeof(wcsGlobal)/sizeof(WCHAR) &&
         RtlEqualMemory( lpValue, wcsGlobal, sizeof(wcsGlobal) ) )
    {
        return QUERY_GLOBAL;
    }

    //
    // check for "Foreign" request
    //

    if ( ccValue == sizeof(wcsForeign)/sizeof(WCHAR) &&
         RtlEqualMemory( lpValue, wcsForeign, sizeof(wcsForeign) ) )
    {
        return QUERY_FOREIGN;
    }

    //
    // check for "Costly" request
    //

    if ( ccValue == sizeof(wcsCostly)/sizeof(WCHAR) &&
         RtlEqualMemory( lpValue, wcsCostly, sizeof(wcsCostly) ) )
    {
        return QUERY_COSTLY;
    }

    // if not Global and not Foreign and not Costly,
    // then it must be an item list

    return QUERY_ITEMS;
}

BOOL
IsNumberInUnicodeList (
    IN DWORD   dwNumber,
    IN LPWSTR  lpwszUnicodeList
)
/*++

IsNumberInUnicodeList

Arguments:

    IN dwNumber
        DWORD number to find in list

    IN lpwszUnicodeList
        Null terminated, Space delimited list of decimal numbers

Return Value:

    TRUE:
            dwNumber was found in the list of unicode number strings

    FALSE:
            dwNumber was not found in the list.

--*/
{
    DWORD   dwThisNumber;
    TCHAR   *pwcThisChar;
    BOOL    bValidNumber;
    BOOL    bNewItem;
    TCHAR   wcDelimiter;    // could be an argument to be more flexible

    if (lpwszUnicodeList == 0) return FALSE;    // null pointer, # not founde

    pwcThisChar = lpwszUnicodeList;
    dwThisNumber = 0;
    wcDelimiter = TEXT(' ');
    bValidNumber = FALSE;
    bNewItem = TRUE;

    while (TRUE) {
        switch (EvalThisChar (*pwcThisChar, wcDelimiter)) {
            case DIGIT:
                // if this is the first digit after a delimiter, then
                // set flags to start computing the new number
                if (bNewItem) {
                    bNewItem = FALSE;
                    bValidNumber = TRUE;
                }
                if (bValidNumber) {
                    dwThisNumber *= 10;
                    dwThisNumber += (*pwcThisChar - TEXT('0'));
                }
                break;

            case DELIMITER:
                // a delimter is either the delimiter character or the
                // end of the string ('\0') if when the delimiter has been
                // reached a valid number was found, then compare it to the
                // number from the argument list. if this is the end of the
                // string and no match was found, then return.
                //
                if (bValidNumber) {
                    if (dwThisNumber == dwNumber) return TRUE;
                    bValidNumber = FALSE;
                }
                if (*pwcThisChar == 0) {
                    return FALSE;
                } else {
                    bNewItem = TRUE;
                    dwThisNumber = 0;
                }
                break;

            case INVALID:
                // if an invalid character was encountered, ignore all
                // characters up to the next delimiter and then start fresh.
                // the invalid number is not compared.
                bValidNumber = FALSE;
                break;

            default:
                break;

        }
        pwcThisChar++;
    }

}   // IsNumberInUnicodeList

BOOL
MonBuildInstanceDefinition(
    PERF_INSTANCE_DEFINITION *pBuffer,
    PVOID *pBufferNext,
    DWORD ParentObjectTitleIndex,
    DWORD ParentObjectInstance,
    DWORD UniqueID,
    PUNICODE_STRING Name
    )

/*++

    MonBuildInstanceDefinition  -   Build an instance of an object

        Inputs:

            pBuffer         -   pointer to buffer where instance is to
                                be constructed

            pBufferNext     -   pointer to a pointer which will contain
                                next available location, DWORD aligned

            ParentObjectTitleIndex
                            -   Title Index of parent object type; 0 if
                                no parent object

            ParentObjectInstance
                            -   Index into instances of parent object
                                type, starting at 0, for this instances
                                parent object instance

            UniqueID        -   a unique identifier which should be used
                                instead of the Name for identifying
                                this instance

            Name            -   Name of this instance
--*/

{
    DWORD NameLength;
    WCHAR *pName;

    //
    //  Include trailing null in name size
    //

    NameLength = Name->Length;
    if ( !NameLength ||
         Name->Buffer[(NameLength/sizeof(WCHAR))-1] != UNICODE_NULL ) {
        NameLength += sizeof(WCHAR);
    }

    pBuffer->ByteLength = sizeof(PERF_INSTANCE_DEFINITION) +
                          EIGHT_BYTE_MULTIPLE(NameLength);

    pBuffer->ParentObjectTitleIndex = ParentObjectTitleIndex;
    pBuffer->ParentObjectInstance = ParentObjectInstance;
    pBuffer->UniqueID = UniqueID;
    pBuffer->NameOffset = sizeof(PERF_INSTANCE_DEFINITION);
    pBuffer->NameLength = NameLength;

    pName = (PWCHAR)&pBuffer[1];
    RtlMoveMemory(pName,Name->Buffer,Name->Length);

    //  Always null terminated.  Space for this reserved above.

    pName[(NameLength/sizeof(WCHAR))-1] = UNICODE_NULL;

    *pBufferNext = (PVOID) ((PCHAR) pBuffer + pBuffer->ByteLength);

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\query\bindexp.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996 - 2000.
//
//  File:       bindexp.cxx
//
//  Contents:   IFilter binding functions
//
//  Functions:  BindIFilterFromStorage
//              BindIFilterFromStream
//              LoadIFilter
//              LoadTextFilter
//              LoadBHIFilter
//
//  History:    30-Jan-96   KyleP       Created
//
//----------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include <ciregkey.hxx>
#include <ciole.hxx>
#include <queryexp.hxx>

//
// Local prototypes and data
//

SCODE Bind( IFilter * pIFilter, WCHAR const * pwszPath, IFilter ** ppIFilter );

static GUID const CLSID_CNullIFilter = {
    0xC3278E90,
    0xBEA7,
    0x11CD,
    { 0xB5, 0x79, 0x08, 0x00, 0x2B, 0x30, 0xBF, 0xEB }
};

//+-------------------------------------------------------------------------
//
//  Function:   BindIFilterFromStorage, public
//
//  Synopsis:   Binds an embedding (IStorage) to IFilter
//
//  Arguments:  [pStg]      -- IStorage
//              [pUnkOuter] -- Outer unknown for aggregation
//              [ppIUnk]    -- IFilter returned here
//
//  Returns:    Status code
//
//  History:    30-Jan-96   KyleP    Created
//              28-Jun-96   KyleP    Added support for aggregation
//
//--------------------------------------------------------------------------

SCODE BindIFilterFromStorage(
    IStorage * pStg,
    IUnknown * pUnkOuter,
    void **    ppIUnk )
{
    SCODE sc = S_OK;

    if ( 0 == pStg )
        return E_INVALIDARG;

    CTranslateSystemExceptions xlate;
    TRY
    {
        sc = CCiOle::BindIFilter( pStg, pUnkOuter, (IFilter **)ppIUnk, FALSE );
    }
    CATCH( CException, e )
    {
        sc = GetOleError( e );
    }
    END_CATCH

    return sc;
} //BindIFilterFromStorage

//+-------------------------------------------------------------------------
//
//  Function:   BindIFilterFromStream, public
//
//  Synopsis:   Binds an embedding (IStream) to IFilter
//
//  Arguments:  [pStm]      -- IStream
//              [pUnkOuter] -- Outer unknown for aggregation
//              [ppIUnk]    -- IFilter returned here
//
//  Returns:    Status code
//
//  History:    28-Jun-96   KyleP    Created
//
//--------------------------------------------------------------------------

SCODE BindIFilterFromStream(
    IStream *  pStm,
    IUnknown * pUnkOuter,
    void **    ppIUnk )
{
    SCODE sc = S_OK;

    if ( 0 == pStm )
        return E_INVALIDARG;

    CTranslateSystemExceptions xlate;
    TRY
    {
        sc = CCiOle::BindIFilter( pStm, pUnkOuter, (IFilter **)ppIUnk, FALSE );
    }
    CATCH( CException, e )
    {
        sc = GetOleError( e );
    }
    END_CATCH

    return sc;
} //BindIFilterFromStream

//+-------------------------------------------------------------------------
//
//  Function:   LoadIFilter, public
//
//  Synopsis:   Loads an object (path) and binds to IFilter
//
//  Arguments:  [pwcsPath]  -- Full path to file.
//              [pUnkOuter] -- Outer unknown for aggregation
//              [ppIUnk]    -- IFilter returned here
//
//  Returns:    Status code
//
//  History:    30-Jan-96   KyleP    Created
//              28-Jun-96   KyleP    Added support for aggregation
//
//--------------------------------------------------------------------------

SCODE LoadIFilter(
    WCHAR const * pwcsPath,
    IUnknown *    pUnkOuter,
    void **       ppIUnk )
{
    if ( 0 == pwcsPath )
        return E_INVALIDARG;

    SCODE sc = S_OK;

    CTranslateSystemExceptions xlate;
    TRY
    {
        sc = CCiOle::BindIFilter( pwcsPath, pUnkOuter, (IFilter **)ppIUnk, FALSE );
    }
    CATCH( CException, e )
    {
        sc = GetOleError( e );
    }
    END_CATCH

    return sc;
} //LoadIFilter

//+-------------------------------------------------------------------------
//
//  Function:   LoadIFilterEx, public
//
//  Synopsis:   Loads an object (path) and binds to IFilter.  Depending on
//              flags, falls back to the plain text filter if no filter is
//              found.
//
//  Arguments:  [pwcsPath]  -- Full path to file.
//              [dwFlags]   -- Whether to fall back on the text filter
//              [riid]      -- Interface requested
//              [ppIUnk]    -- IFilter returned here
//
//  Returns:    Status code
//
//  History:    20-Aug-01   dlee created
//
//--------------------------------------------------------------------------

SCODE LoadIFilterEx(
    WCHAR const * pwcsPath,
    DWORD         dwFlags,
    REFIID        riid,
    void **       ppIUnk )
{
    if ( 0 == pwcsPath || 0 == ppIUnk )
        return E_INVALIDARG;

    SCODE sc = S_OK;

    CTranslateSystemExceptions xlate;
    TRY
    {
        XInterface<IFilter> xFilter;
        sc = CCiOle::BindIFilter( pwcsPath, 0, xFilter.GetPPointer(), FALSE );

        if ( FAILED( sc ) )
        {
            if ( LIFF_FORCE_TEXT_FILTER_FALLBACK == dwFlags )
                sc = LoadTextFilter( pwcsPath, xFilter.GetPPointer() );
            else if ( LIFF_IMPLEMENT_TEXT_FILTER_FALLBACK_POLICY == dwFlags )
            {
                DWORD fUseTextFilter = CI_FFILTER_FILES_WITH_UNKNOWN_EXTENSIONS_DEFAULT;

                HKEY hKey;
                DWORD dwError = RegOpenKeyW( HKEY_LOCAL_MACHINE, wcsRegAdminSubKey, &hKey );

                if ( ERROR_SUCCESS == dwError )
                {
                    DWORD dwType;
                    DWORD cb = sizeof fUseTextFilter;
                    dwError = RegQueryValueExW( hKey,
                                                wcsFilterFilesWithUnknownExtensions,
                                                0,
                                                &dwType,
                                                ( BYTE * ) & fUseTextFilter,
                                                &cb );
                    RegCloseKey( hKey );
                }

                if ( fUseTextFilter )
                    sc = LoadTextFilter( pwcsPath, xFilter.GetPPointer() );
            }
        }

        // Now go get the interface requested

        if ( SUCCEEDED( sc ) )
            sc = xFilter->QueryInterface( riid, ppIUnk );
    }
    CATCH( CException, e )
    {
        sc = GetOleError( e );
    }
    END_CATCH

    return sc;
} //LoadIFilterEx

static const GUID CLSID_CTextIFilter = CLSID_TextIFilter;

//+---------------------------------------------------------------------------
//
//  Function:   LoadTextFilter
//
//  Synopsis:   Creates a text filter and returns its pointer.
//
//  Arguments:  [pwszPath]  -- File to bind
//              [ppIFilter] -- IFilter returned here
//
//  Returns:    Status
//
//  History:    2-27-97   srikants   Created
//
//----------------------------------------------------------------------------

SCODE LoadTextFilter( WCHAR const * pwszPath, IFilter ** ppIFilter )
{
    if ( 0 == ppIFilter )
        return E_INVALIDARG;

    IFilter * pIFilter = 0;

    SCODE sc = CoCreateInstance( CLSID_CTextIFilter,
                                 NULL,
                                 CLSCTX_INPROC_SERVER,
                                 IID_IFilter,
                                 (void **) &pIFilter );

    if ( FAILED(sc) )
    {
        ciDebugOut(( DEB_WARN,
                     "CoCreateInstance of CLSID_CTextIFilter failed with error 0x%X\n",
                     sc ));
        return sc;
    }

    return Bind( pIFilter, pwszPath, ppIFilter );
} //LoadTextFilter

//+---------------------------------------------------------------------------
//
//  Function:   LoadBinaryFilter
//
//  Synopsis:   Creates a binary filter and returns its pointer.
//
//  Arguments:  [pwszPath]  -- File to bind
//              [ppIFilter] -- IFilter returned here
//
//  Returns:    Status
//
//  History:    03-Nov-1998  KyleP    Lifted from LoadTextFilter
//
//----------------------------------------------------------------------------

SCODE LoadBinaryFilter( WCHAR const * pwszPath, IFilter ** ppIFilter )
{

    if ( 0 == ppIFilter )
        return E_INVALIDARG;


    IFilter * pIFilter = 0;

    SCODE sc = CoCreateInstance( CLSID_CNullIFilter,
                                 NULL,
                                 CLSCTX_INPROC_SERVER,
                                 IID_IFilter,
                                 (void **) &pIFilter );

    if ( FAILED(sc) )
    {
        ciDebugOut(( DEB_WARN,
                     "CoCreateInstance of CLSID_CTextIFilter failed with error 0x%X\n",
                     sc ));
        return sc;
    }

    return Bind( pIFilter, pwszPath, ppIFilter );
} //LoadBinaryFilter

//+---------------------------------------------------------------------------
//
//  Function:   Bind, private
//
//  Synopsis:   Worker for common portion of Load*Filter.
//
//  Arguments:  [pIFilter]  -- Filter instance to bind
//              [pwszPath]  -- File to bind to
//              [ppIFilter] -- IFilter returned here
//
//  Returns:    Status
//
//  History:    03-Nov-1998  KyleP    Lifted from LoadTextFilter
//
//----------------------------------------------------------------------------

SCODE Bind( IFilter * pIFilter, WCHAR const * pwszPath, IFilter ** ppIFilter )
{
    XInterface<IFilter> xFilter(pIFilter);

    IPersistFile * pf = 0;
    SCODE sc = pIFilter->QueryInterface( IID_IPersistFile,
                                         (void **) &pf );
    if ( FAILED(sc) )
    {
        ciDebugOut(( DEB_WARN,
                     "QI for IID_IPersistFile on text filter failed. Error 0x%X\n",
                     sc ));
        return sc;
    }

    XInterface<IPersistFile> xpf(pf);

    sc = pf->Load( pwszPath, 0 );

    if ( FAILED(sc) )
    {
        ciDebugOut(( DEB_WARN,
                     "IPersistFile->Load failed with error 0x%X\n", sc ));
        return sc;
    }

    *ppIFilter = xFilter.Acquire();

    return S_OK;
} //Bind

//+-------------------------------------------------------------------------
//
//  Function:   LoadBHIFilter, public
//
//  Synopsis:   Loads an object (path) and binds to IFilter.  This is the
//              'BoneHead' version.  Can be made to refuse load of single-
//              threaded filter.
//
//  Arguments:  [pwcsPath]  -- Full path to file.
//              [pUnkOuter] -- Outer unknown for aggregation
//              [ppIUnk]    -- IFilter returned here
//              [fBHOk]     -- TRUE --> Allow load of single-threaded filter.
//
//  Returns:    Status code. S_FALSE if filter found but could not be
//              loaded because it is free-threaded.
//
//  History:    12-May-97   KyleP    Created from the smart version
//
//--------------------------------------------------------------------------

SCODE LoadBHIFilter( WCHAR const * pwcsPath,
                     IUnknown *    pUnkOuter,
                     void **       ppIUnk,
                     BOOL          fBHOk )
{
    if ( 0 == pwcsPath )
        return E_INVALIDARG;

    SCODE sc = S_OK;

    CTranslateSystemExceptions xlate;
    TRY
    {
        sc = CCiOle::BindIFilter( pwcsPath, pUnkOuter, (IFilter **)ppIUnk, !fBHOk );
    }
    CATCH( CException, e )
    {
        sc = GetOleError( e );
    }
    END_CATCH

    return sc;
} //LoadBHIFilter
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\query\cifailte.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1991 - 1992.
//
//  File:   CIFAILTE.CXX
//
//  Contents:   Selective fail testing functions in ci.
//
//  Functions:  DoFailTest
//
//  History:    Jul 07 1994     SrikantS    Created
//
//  Notes:      Selective fail testing is done by introducing
//              "ciFAILTEST" statements in the code where a failure scenario
//              should be tested, setting a break point and modifying the
//              "ciFailTest" variable to be true. If ciFailTest is set to
//              TRUE, an exception will be thrown.
//
//----------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include <cifailte.hxx>

extern "C" ciFailTest = 0;

void DoFailTest( NTSTATUS status )
{
    if ( ciFailTest )
        THROW( CException( status ) );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\query\codepage.cxx ===
//+---------------------------------------------------------------------------
//
//  Copyright (C) Microsoft Corporation, 1991 - 1996
//
//  File:   codepage.hxx
//
//  Contents:   Locale to codepage
//
//  History:    08-Jul-96     SitaramR    Created
//
//-----------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include <codepage.hxx>

//+---------------------------------------------------------------------------
//
//  Function:   LocaleToCodepage
//
//  Purpose:    Returns a codepage from a locale
//
//  Arguments:  [lcid]  --  Locale
//
//  History:    08-Jul-96   SitaramR    Created
//
//----------------------------------------------------------------------------

ULONG LocaleToCodepage( LCID lcid )
{
    // optimize a typical case

    if ( 0x409 == lcid )
        return 0x4e4;

    ULONG codepage;

    int cwc = GetLocaleInfoW( lcid,
                              LOCALE_RETURN_NUMBER |
                              LOCALE_IDEFAULTANSICODEPAGE,
                              (WCHAR *) &codepage,
                              sizeof DWORD / sizeof WCHAR );

    //
    // If error, return Ansi code page
    //
    if ( cwc == 0 )
    {
         ciDebugOut(( DEB_ERROR, "GetLocaleInfoW for lcid %d returned %d\n", lcid, GetLastError() ));

         return CP_ACP;
    }

    return codepage;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\query\dbprpini.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1997.
//
//  File:       dbprpini.cxx
//
//  Contents:   A wrapper class to get DB_INIT_PROPSET properties.
//
//  History:    1-16-97   srikants   Created
//
//----------------------------------------------------------------------------

#include <pch.cxx>
#pragma  hdrstop

#include <dbprpini.hxx>
#include <guidutil.hxx>


const GUID guidQueryCorePropset = DBPROPSET_CIFRMWRKCORE_EXT;

//+---------------------------------------------------------------------------
//
//  Member:     CGetDbInitProps::GetProperties
//
//  Synopsis:   Retrieves the specified properties from pDbProperties
//
//  Arguments:  [pDbProperties] - Interface to use for retrieving
//              [fPropsToGet]   - Properties to retrieve.
//
//  History:    1-16-97   srikants   Created
//
//----------------------------------------------------------------------------

void CGetDbInitProps::GetProperties( IDBProperties * pDbProperties,
                                     const ULONG fPropsToGet )
{
    _Cleanup();

    //
    // Initialize the input parameters to IDBProperties::GetProperties()
    //
    const cPropIdSets = 1;
    DBPROPIDSET aDbPropIdSet[cPropIdSets];

    //
    // PropertyIds for DBPROPSET_INIT.
    //
    DBPROPID  aInitPropId[cInitProps];
    ULONG     cProps = 0;

    RtlZeroMemory( aInitPropId, sizeof aInitPropId );

    if ( fPropsToGet & eMachine )
    {
        aInitPropId[cProps] = DBPROP_MACHINE;
        cProps++;
    }

    if ( fPropsToGet & eClientGuid )
    {
        aInitPropId[cProps] = DBPROP_CLIENT_CLSID;
        cProps++;
    }

    if ( cProps > 0 )
    {
        aDbPropIdSet[0].rgPropertyIDs = aInitPropId;
        aDbPropIdSet[0].cPropertyIDs = cProps;
        aDbPropIdSet[0].guidPropertySet = guidQueryCorePropset;

        DBPROPSET * pDbPropSet;
        ULONG cPropertySets;
        SCODE sc = pDbProperties->GetProperties( cPropIdSets,
                                                 aDbPropIdSet,
                                                 &cPropertySets,
                                                 &pDbPropSet );
        if ( FAILED(sc) )
        {
            ciDebugOut(( DEB_ERROR, "Failed to do GetProperties (0x%X)\n", sc ));
            THROW( CException( sc ) );
        }
    

        Win4Assert( cPropertySets <= cPropIdSets );
    

        if ( cPropertySets > 0 )
        {
            XArrayOLEInPlace<CDbPropSet> xPropSet;
            xPropSet.Set( cPropertySets, (CDbPropSet *) pDbPropSet );

            _ProcessDbInitPropSet( pDbPropSet[0] );            
        }
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CGetDbInitProps::AcquireWideStr
//
//  Synopsis:   Acquires the LPWSTR property in the given DBPROP
//
//  Arguments:  [prop] - Property to retrieve from.
//
//  Returns:    LPWSTR in the variant if successful; NULL o/w
//
//  History:    1-13-97   srikants   Created
//
//----------------------------------------------------------------------------

WCHAR * CGetDbInitProps::AcquireWideStr( CDbProp & prop )
{
    WCHAR * pVal = 0;

    PROPVARIANT * pVar = (PROPVARIANT *) &(prop.vValue);

    if ( prop.dwStatus == DBPROPSTATUS_OK && prop.vValue.vt == VT_LPWSTR )
    {
        pVal = pVar->pwszVal;
        pVar->vt = VT_EMPTY;
    }

    return pVal;
}

//+---------------------------------------------------------------------------
//
//  Member:     CGetDbInitProps::_AcquireBStr
//
//  Synopsis:   Acquires the BSTR value from the value in the property.
//
//  History:    1-17-97   srikants   Created
//
//----------------------------------------------------------------------------

WCHAR * CGetDbInitProps::AcquireBStr( CDbProp & prop )
{
    WCHAR * pVal = 0;

    PROPVARIANT * pVar = (PROPVARIANT *) &(prop.vValue);

    if ( prop.dwStatus == DBPROPSTATUS_OK && prop.vValue.vt == VT_BSTR )
    {
        pVal = (WCHAR *) pVar->bstrVal;
        pVar->vt = VT_EMPTY;
    }

    return pVal;
}

//+---------------------------------------------------------------------------
//
//  Member:     CGetDbInitProps::_ProcessDbInitPropSet
//
//  Synopsis:   Processes the given propset.
//
//  Arguments:  [propSet] - PropSet to process
//
//  History:    1-16-97   srikants   Created
//
//  Notes:      
//
//----------------------------------------------------------------------------

void CGetDbInitProps::_ProcessDbInitPropSet( DBPROPSET & propSet )
{
    CDbPropSet * pDbPropSet = (CDbPropSet *) &propSet;

    for ( ULONG i = 0; i < propSet.cProperties; i++ )
    {
        CDbProp * pDbProp = pDbPropSet->GetProperty(i);

        switch ( pDbProp->dwPropertyID )
        {
            case DBPROP_MACHINE:
                Win4Assert( 0 == _pwszMachine );
                _pwszMachine = AcquireBStr( *pDbProp );
                break;

            case DBPROP_CLIENT_CLSID:

                {
                    WCHAR * pGuid = AcquireBStr( *pDbProp );
                    if ( pGuid )
                    {
                        CGuidUtil::StringToGuid( pGuid, _guid );
                        _fGuidValid = TRUE;
                        SysFreeString( pGuid );
                    }
                }
                break;

            default:
                Win4Assert( !"Invalid Property Id" );
                break;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\query\ciole.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996 - 2000.
//
//  File:       CiOle.cxx
//
//  Contents:   Switch between OLE and 'Short' OLE
//
//  Classes:    CCiOle
//
//  History:    01-Feb-96       KyleP       Added header
//              31-Jan-96       KyleP       Added support for embeddings
//
//----------------------------------------------------------------------------
#include <pch.cxx>
#pragma hdrstop

#include <ciole.hxx>

BOOL CCiOle::_fUseOle = FALSE;

CShtOle CCiOle::_shtOle;

void CCiOle::Init()
{
    _shtOle.Init();
}

void CCiOle::Shutdown()
{
    _shtOle.Shutdown();
}

void CCiOle::FlushIdle()
{
    _shtOle.FlushIdle();
}

//+---------------------------------------------------------------------------
//
//  Member:     CCiOle::BindIFilter, public static
//
//  Synopsis:   Load and bind object to IFilter interface.
//
//  Arguments:  [pwszPath]          -- Path of file to load.
//              [pUnkOuter]         -- Outer unknown, for aggregation
//              [ppFilter]          -- Filter returned here
//              [fFreeThreadedOnly] -- TRUE --> only bind free threaded filters.
//
//  Returns:    S_OK on success, S_FALSE if single-threaded filter (and
//              [fFreeThreadedOnly] is TRUE.
//
//  History:    30-Jan-96   KyleP       Added header.
//              28-Jun-96   KyleP       Added support for aggregation
//              12-May-97   KyleP       Added single-threaded disambiguation
//
//----------------------------------------------------------------------------

SCODE CCiOle::BindIFilter( WCHAR const * pwszPath,
                           IUnknown * pUnkOuter,
                           IFilter ** ppFilter,
                           BOOL fFreeThreadedOnly )
{
    return _shtOle.Bind( pwszPath,
                         IID_IFilter,
                         pUnkOuter,
                         (void **)ppFilter,
                         fFreeThreadedOnly );
}

//+---------------------------------------------------------------------------
//
//  Member:     CCiOle::BindIFilter, public static
//
//  Synopsis:   Load and bind object to IFilter interface.  Assumes class
//              of object has been pre-determined in some way (e.g. the
//              docfile was already opened for property enumeration)
//
//  Arguments:  [pwszPath]          -- Path of file to load.
//              [pUnkOuter]         -- Outer unknown, for aggregation
//              [classid]           -- Pre-determined class id of object
//              [ppFilter]          -- Filter returned here
//              [fFreeThreadedOnly] -- TRUE --> only bind free threaded filters.
//
//  Returns:    S_OK on success, S_FALSE if single-threaded filter (and
//              [fFreeThreadedOnly] is TRUE.
//
//  History:    30-Jan-96   KyleP       Added header.
//              28-Jun-96   KyleP       Added support for aggregation
//              12-May-97   KyleP       Added single-threaded disambiguation
//
//----------------------------------------------------------------------------

SCODE CCiOle::BindIFilter( WCHAR const * pwszPath,
                           IUnknown * pUnkOuter,
                           GUID const & classid,
                           IFilter ** ppFilter,
                           BOOL fFreeThreadedOnly )
{
    return _shtOle.Bind( pwszPath,
                         classid,
                         IID_IFilter,
                         pUnkOuter,
                         (void **)ppFilter,
                         fFreeThreadedOnly );
}

//+---------------------------------------------------------------------------
//
//  Member:     CCiOle::BindIFilter, public static
//
//  Synopsis:   Bind embedding to IFilter interface.
//
//  Arguments:  [pStg]              -- IStorage of embedding.
//              [pUnkOuter]         -- Outer unknown, for aggregation
//              [ppFilter]          -- Filter returned here
//              [fFreeThreadedOnly] -- TRUE --> only bind free threaded filters.
//
//  Returns:    S_OK on success, S_FALSE if single-threaded filter (and
//              [fFreeThreadedOnly] is TRUE.
//
//  History:    30-Jan-96   KyleP       Added header.
//              28-Jun-96   KyleP       Added support for aggregation
//              12-May-97   KyleP       Added single-threaded disambiguation
//
//----------------------------------------------------------------------------

SCODE CCiOle::BindIFilter( IStorage * pStg,
                           IUnknown * pUnkOuter,
                           IFilter ** ppFilter,
                           BOOL fFreeThreadedOnly )
{
    return _shtOle.Bind( pStg,
                         IID_IFilter,
                         pUnkOuter,
                         (void **)ppFilter,
                         fFreeThreadedOnly );
}

//+---------------------------------------------------------------------------
//
//  Member:     CCiOle::BindIFilter, public static
//
//  Synopsis:   Bind embedding to IFilter interface.
//
//  Arguments:  [pStm]              -- IStream of embedding.
//              [pUnkOuter]         -- Outer unknown, for aggregation
//              [ppFilter]          -- Filter returned here
//              [fFreeThreadedOnly] -- TRUE --> only bind free threaded filters.
//
//  Returns:    S_OK on success, S_FALSE if single-threaded filter (and
//              [fFreeThreadedOnly] is TRUE.
//
//  History:    30-Jan-96   KyleP       Added header.
//              28-Jun-96   KyleP       Added support for aggregation
//              12-May-97   KyleP       Added single-threaded disambiguation
//
//----------------------------------------------------------------------------

SCODE CCiOle::BindIFilter( IStream * pStm,
                           IUnknown * pUnkOuter,
                           IFilter ** ppFilter,
                           BOOL fFreeThreadedOnly )
{
    return _shtOle.Bind( pStm,
                         IID_IFilter,
                         pUnkOuter,
                         (void **)ppFilter,
                         fFreeThreadedOnly );
}

//+---------------------------------------------------------------------------
//
//  Member:     CCiOle::NewWordBreaker, public static
//
//  Synopsis:   Create new instance of specified class and bind to
//              IWordBreaker interface.
//
//  Arguments:  [classid] -- Classid of object to create
//
//  Returns:    IWordBreaker interface, or zero if it cannot be bound.
//
//  History:    30-Jan-96   KyleP       Added header.
//
//----------------------------------------------------------------------------

IWordBreaker * CCiOle::NewWordBreaker( GUID const & classid )
{
    IWordBreaker * pWBreak = 0;

    if ( _fUseOle )
    {
       IClassFactory *pIClassFactory = 0;

       SCODE sc = CoGetClassObject( classid,
                                    CLSCTX_INPROC_SERVER, NULL,
                                    IID_IClassFactory,
                                    (LPVOID *) &pIClassFactory );

       if ( sc == S_OK )
       {
          sc = pIClassFactory->CreateInstance( 0,
                                               IID_IWordBreaker,
                                               (LPVOID *) &pWBreak );

          pIClassFactory->Release();
       }

       if ( FAILED(sc) )
           pWBreak = 0;
    }
    else
    {
        SCODE sc = _shtOle.NewInstance( classid,
                                        IID_IWordBreaker,
                                        (void **)(&pWBreak) );
    }

    return( pWBreak );
}

//+---------------------------------------------------------------------------
//
//  Member:     CCiOle::NewStemmer, public static
//
//  Synopsis:   Create new instance of specified class and bind to
//              IStemmer interface.
//
//  Arguments:  [classid] -- Classid of object to create
//
//  Returns:    IStemmer interface, or zero if it cannot be bound.
//
//  History:    30-Jan-96   KyleP       Added header.
//
//----------------------------------------------------------------------------

IStemmer * CCiOle::NewStemmer( GUID const & classid )
{
    IStemmer * pStemmer = 0;

    if ( _fUseOle )
    {
       IClassFactory *pIClassFactory = 0;

       SCODE sc = CoGetClassObject( classid,
                                    CLSCTX_INPROC_SERVER, NULL,
                                    IID_IClassFactory,
                                    (LPVOID *) &pIClassFactory );

       if ( sc == S_OK )
       {
          sc = pIClassFactory->CreateInstance( 0,
                                               IID_IStemmer,
                                               (LPVOID *) &pStemmer );

          pIClassFactory->Release();
       }

       if ( FAILED(sc) )
           pStemmer = 0;
    }
    else
    {
        SCODE sc = _shtOle.NewInstance( classid,
                                        IID_IStemmer,
                                        (void **)(&pStemmer) );
    }

    return( pStemmer );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\query\dbprputl.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1998.
//
//  File:       dbprputl.cxx
//
//  Contents:   A wrapper around IDbProperties to retrieve the dbproperties
//              set by the FileSystem CI client.
//
//  History:    1-13-97   srikants   Created
//              5-10-97   mohamedn   core/fs property set split
//
//----------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include <dbprputl.hxx>
#include <fsciclnt.h>
#include <guidutil.hxx>

GUID const guidQueryCorePropset        = DBPROPSET_CIFRMWRKCORE_EXT;
GUID const guidCiFsExt                 = DBPROPSET_FSCIFRMWRK_EXT;
GUID const clsidStorageDocStoreLocator = CLSID_StorageDocStoreLocator;

//+---------------------------------------------------------------------------
//
//  Member:     CGetDbProps::CGetDbProps
//
//  Synopsis:   Constructor - Initializes all pointers to NULL.
//
//  History:    1-13-97   srikants   Created
//              5-14-97   mohamedn   core/fs property split
//
//----------------------------------------------------------------------------

CGetDbProps::CGetDbProps()
:_fGuidValid(FALSE),
 _aDepths(0),
 _aMachines(0),
 _cDepths(0),
 _cScopes(0),
 _cCatalogs(0),
 _cMachines(0),
 _cGuids(0),
 _type(CiNormal)
{
    ZeroMemory( &_clientGuid, sizeof GUID );

    //
    // init Defaults
    //
    _aDefaultDepth[0] = QUERY_DEEP;  
    _aDefaultPath[0]  = L"\\";
}

//+---------------------------------------------------------------------------
//
//  Member:     CGetDbProps::GetProperties
//
//  Synopsis:   Retrieves the properties requested from the IDBProperties
//              interface.
//
//  Arguments:  [pDbProperties] -  IDbProperties interface pointer to use
//              [fPropsToGet]   -  subset of enumerated props to get
//
//  History:    1-13-97   srikants   Created
//              5-10-97   mohamedn   core/fs property set split
//
//----------------------------------------------------------------------------


void CGetDbProps::GetProperties( IDBProperties * pDbProperties,
                                 const ULONG fPropsToGet )
{

    //
    // Initialize the input parameters to IDBProperties::GetProperties()
    // 
    DBPROPIDSET aDbPropIdSet[cScopePropSets];
    ULONG       cPropIdSets = 0;

    //
    // PropertyIds for core properties.
    //
    DBPROPID  aInitPropId[cInitProps];
    ULONG     cCoreProps = 0;

    RtlZeroMemory( aInitPropId, sizeof aInitPropId );

    if ( fPropsToGet & eMachine )
    {
        aInitPropId[cCoreProps++] = DBPROP_MACHINE;
    }

    if ( fPropsToGet & eClientGuid )
    {
        aInitPropId[cCoreProps++] = DBPROP_CLIENT_CLSID;
    }

    if ( cCoreProps > 0 )
    {
        aDbPropIdSet[cPropIdSets].rgPropertyIDs   = aInitPropId;
        aDbPropIdSet[cPropIdSets].cPropertyIDs    = cCoreProps;
        aDbPropIdSet[cPropIdSets].guidPropertySet = guidQueryCorePropset;

        cPropIdSets++;
    }

    //
    // PropertyIds for DBPROPSET_FSCIFRMWRK_EXT.
    //
    DBPROPID  aFsCiPropId[cFsCiProps];
    ULONG     cFsCiPropsToGet = 0;

    if ( fPropsToGet & (eCatalog|eScopesAndDepths|eQueryType) )
    {
        RtlZeroMemory( aFsCiPropId, sizeof aFsCiPropId );

        if ( fPropsToGet & eCatalog )
        {
            aFsCiPropId[cFsCiPropsToGet] = DBPROP_CI_CATALOG_NAME;
            cFsCiPropsToGet++;
        }

        if ( fPropsToGet & eScopesAndDepths )
        {
            aFsCiPropId[cFsCiPropsToGet] = DBPROP_CI_INCLUDE_SCOPES;
            cFsCiPropsToGet++;
            aFsCiPropId[cFsCiPropsToGet] = DBPROP_CI_DEPTHS;
            cFsCiPropsToGet++;
        }

        if ( fPropsToGet & eQueryType )
        {
            aFsCiPropId[cFsCiPropsToGet] = DBPROP_CI_QUERY_TYPE;
            cFsCiPropsToGet++;
        }

        aDbPropIdSet[cPropIdSets].rgPropertyIDs   = aFsCiPropId;
        aDbPropIdSet[cPropIdSets].cPropertyIDs    = cFsCiPropsToGet;
        aDbPropIdSet[cPropIdSets].guidPropertySet = guidCiFsExt;

        cPropIdSets++;
    }


    DBPROPSET * pDbPropSet;
    ULONG       cPropertySets = 0;

    SCODE sc = pDbProperties->GetProperties( cPropIdSets,
                                             aDbPropIdSet,
                                             &cPropertySets, &pDbPropSet );
    if ( FAILED(sc) )
    {
        ciDebugOut(( DEB_ERROR, "Failed to do GetProperties (0x%X)\n", sc ));
        THROW( CException( sc ) );
    }

    Win4Assert( cPropertySets <= cPropIdSets );

    _xPropSet.Set( cPropertySets, (CDbPropSet *) pDbPropSet );

    for ( ULONG i = 0; i < cPropertySets; i++ )
    {
        ProcessPropSet( pDbPropSet[i] );            
    }

    //
    // assign defaults if needed
    //

    if ( (_cDepths != _cScopes) && 
         ( (_cDepths > 1) || (_cScopes > 1) ))
    {
      Win4Assert( _cDepths != _cScopes );
      THROW (CException(E_INVALIDARG));
    }
    
    if ( 0 == _cDepths )
    {
        _aDepths = _aDefaultDepth;
        _cDepths = 1;
    }

    if ( 0 == _cScopes )
    {
        _cScopes = 1;
        _xNotFunnyPaths.SetSize( _cScopes );
        _xNotFunnyPaths[0] = _aDefaultPath[0];
    }

    if ( !_fGuidValid )
    {
        _clientGuid = clsidStorageDocStoreLocator;
        _fGuidValid = TRUE;
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CGetDbProps::ProcessDbInitPropSet
//
//  Synopsis:   Processes the core property set.
//
//  Arguments:  [propSet] - The property set to process.
//
//  History:    1-13-97   srikants   Created
//              5-10-97   mohamedn   fs/core properties split
//
//----------------------------------------------------------------------------

void CGetDbProps::ProcessDbInitPropSet( DBPROPSET & propSet )
{
    CDbPropSet * pDbPropSet = (CDbPropSet *) &propSet;

    for ( ULONG i = 0; i < propSet.cProperties; i++ )
    {
        CDbProp * pDbProp = pDbPropSet->GetProperty(i);

        if ( DBPROPSTATUS_OK != pDbProp->dwStatus )
        {
             ciDebugOut(( DEB_TRACE, "DbProp.dwPropertyID: %x has dwStatus= %x\n",
                          pDbProp->dwPropertyID,pDbProp->dwStatus));            

             continue;
        }

        switch ( pDbProp->dwPropertyID )
        {
            case DBPROP_MACHINE:
                    
                 _aMachines = GetWCharFromVariant(*pDbProp, &_cMachines);
                 if ( _cMachines != 1 )
                 {
                    ciDebugOut(( DEB_ERROR, "Inavlid Machine Count: %x\n",_cMachines));

                    Win4Assert( _cMachines == 1 );

                    THROW( CException(STATUS_INVALID_PARAMETER) );
                 }

                 break;

            case DBPROP_CLIENT_CLSID:
                 {   

                    WCHAR **apGuids = GetWCharFromVariant(*pDbProp, &_cGuids);

                    if ( _cGuids == 1 )
                    {
                        CGuidUtil::StringToGuid( apGuids[0], _clientGuid );
                        _fGuidValid = TRUE;
                    }
                    else
                    {
                         ciDebugOut(( DEB_ERROR, "Invalid ClientGuid, cGuids = %x\n",_cGuids ));
                         THROW( CException(STATUS_INVALID_PARAMETER) );
                    }                        
                 }
                 break;

            default:
                Win4Assert( !"Invalid Property Id" );
                THROW( CException(STATUS_INVALID_PARAMETER) );
        }
    }
}


//+---------------------------------------------------------------------------
//
//  Member:     CGetDbProps::_PreProcessForFunnyPaths
//
//  Synopsis:   Do some pre processing on paths:
//              - Get rid of funny characters before the paths (\\?\ and \\?\UNC\)
//
//  Arguments:  [aPaths] - input array of paths
//              [cPaths] - count of elements in the above array
//              [xNotFunnyPaths] - the output array. Each element of this array
//              points to the corressponding element in aPaths array after the funny
//              characters.
//
//  History:    08-27-98  vikasman   created
//
//----------------------------------------------------------------------------

void CGetDbProps::_PreProcessForFunnyPaths( WCHAR * const * aPaths, DWORD cPaths, 
                                            XPathArray  & xNotFunnyPaths )
{
    if ( aPaths && cPaths > 0 )
    {
        xNotFunnyPaths.SetSize( cPaths );
    
        for ( unsigned iPath = 0; iPath < cPaths; iPath++ )
        {
            // Handle funny paths
            CFunnyPath::FunnyUNC funnyUNC = CFunnyPath::IsFunnyUNCPath( aPaths[iPath] );

            switch ( funnyUNC )
            {
            case CFunnyPath::FUNNY_ONLY:
                xNotFunnyPaths[iPath] = aPaths[iPath] + _FUNNY_PATH_LENGTH;
                break;
        
            case CFunnyPath::FUNNY_UNC:
                xNotFunnyPaths[iPath] = aPaths[iPath] + _UNC_FUNNY_PATH_LENGTH;

                // NOTE: We are modifying memory which is not owned by this
                // class. Unethical, but saves us from allocating new memory.
                *(xNotFunnyPaths[iPath]) = L'\\'; // replace 'C' in "\\?\UNC\..." with '\'
                break;
        
            default:
                xNotFunnyPaths[iPath] = aPaths[iPath];
                break;
            }
        }
    }    
}

//+---------------------------------------------------------------------------
//
//  Member:     CGetDbProps::ProcessCiFsExtPropSet, private
//
//  Synopsis:   Processes the FSCI extension property set.
//
//  Arguments:  [propSet] - The propety set to process.
//
//  History:    1-13-97   srikants   Created
//              5-10-97   mohamedn   fs/core properties split
//
//----------------------------------------------------------------------------

void CGetDbProps::ProcessCiFsExtPropSet( DBPROPSET & propSet )
{
    CDbPropSet * pDbPropSet = (CDbPropSet *) &propSet;

    for ( ULONG i = 0; i < propSet.cProperties; i++ )
    {
        CDbProp * pDbProp = pDbPropSet->GetProperty(i);

        if ( pDbProp->dwStatus != DBPROPSTATUS_OK )
        {
            ciDebugOut(( DEB_TRACE, "PropStatus (0x%X) for (%d) th property\n",
                         pDbProp->dwStatus, i ));
            continue;    
        }

        switch ( pDbProp->dwPropertyID )
        {
            case DBPROP_CI_CATALOG_NAME:
            {
                 WCHAR * * aCatalogs = GetWCharFromVariant(*pDbProp,&_cCatalogs);

                 if ( 1 != _cCatalogs )
                 {
                    Win4Assert( 1 == _cCatalogs );

                    THROW( CException(STATUS_INVALID_PARAMETER) );
                 }

                 // Handle funny paths
                 _PreProcessForFunnyPaths( aCatalogs, _cCatalogs, _xNotFunnyCatalogs );
             }
             break;

            case DBPROP_CI_DEPTHS:

                 _aDepths =  GetDepthsFromVariant(*pDbProp, &_cDepths,
                                                  (ULONG)~( QUERY_SHALLOW       |
                                                            QUERY_DEEP          |
                                                            QUERY_PHYSICAL_PATH |
                                                            QUERY_VIRTUAL_PATH  ) );   
                 break;

            case DBPROP_CI_INCLUDE_SCOPES:
            {
                 WCHAR * * aPaths = GetWCharFromVariant(*pDbProp, &_cScopes);

                 Win4Assert( aPaths && _cScopes >= 1 );

                 // Handle funny paths
                 _PreProcessForFunnyPaths( aPaths, _cScopes, _xNotFunnyPaths );
             }
             break;

            case DBPROP_CI_QUERY_TYPE:

                 switch ( pDbProp->vValue.vt)
                 {
                    case VT_I4:
                    case VT_UI4:

                         _type = (CiMetaData) pDbProp->vValue.ulVal;
                         break;
  
                    default:
                        ciDebugOut(( DEB_ERROR, "Invalid CI_QUERY_TYPE values: %x\n",pDbProp->vValue.vt));
                        THROW( CException(STATUS_INVALID_PARAMETER) );
                 }
                 break;

            default:
                 {
                    Win4Assert( !"Invalid PropertyID");

                    ciDebugOut(( DEB_ERROR, "InvalidPropertyID(%x)\n",
                                 pDbProp->dwPropertyID ));
                 }
        }
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CGetDbProps::ProcessPropSet, private
//
//  Synopsis:   Processes the given property set.
//
//  Arguments:  [propSet] -  The propety set to process.
//
//  History:    1-13-97   srikants   Created
//
//----------------------------------------------------------------------------

void CGetDbProps::ProcessPropSet( DBPROPSET & propSet )
{
    if ( propSet.guidPropertySet == guidCiFsExt )
    {
        ProcessCiFsExtPropSet( propSet );    
    }
    else if ( propSet.guidPropertySet == guidQueryCorePropset )
    {
        ProcessDbInitPropSet( propSet );    
    }
    else
    {
        ciDebugOut(( DEB_ERROR, "Got an Invalid PropertySet\n" ));
        THROW( CException( STATUS_INVALID_PARAMETER ) );
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     GetWCharFromVariant, private
//
//  Synopsis:   obtains pointer to WChar values in variants
//
//  Arguments:  [dbProp ]   -- source dbProp
//              [cElements] -- count of strings in the returned array
//
//  Returns:    Upon success, a valid pointer to array of WCHARs
//              Upon failure, THROWS
//
//  History:    10-May-97   mohamedn    created
//
//----------------------------------------------------------------------------

WCHAR ** GetWCharFromVariant( DBPROP  & dbProp, ULONG *cElements )
{
    Win4Assert( dbProp.dwStatus == DBPROPSTATUS_OK );

    VARIANT &  var    = dbProp.vValue;
    WCHAR   ** ppData = 0;
    *cElements        = 0;

    switch (var.vt)
    {
        case VT_BSTR:
                
                if ( var.bstrVal )
                {
                    *cElements = 1;
                    ppData = (WCHAR **)&var.bstrVal;
                }
                else
                {
                    Win4Assert( !"Invalid BSTR value" );
                    THROW( CException( STATUS_INVALID_PARAMETER ) );
                }
                break;

        case VT_BSTR|VT_ARRAY:
                {
                    SAFEARRAY & sa = *var.parray;

                    if ( sa.cDims != 1 )
                    {
                        THROW( CException( STATUS_INVALID_PARAMETER ) );
                    }
                    else if ( sa.pvData )
                    {
                        *cElements = sa.rgsabound[0].cElements;
                        ppData = (WCHAR **)sa.pvData;
                    }
                    else
                    {
                        Win4Assert( !"Invalid SafeArray of BSTRs" );
                        THROW( CException( STATUS_INVALID_PARAMETER ) );
                    }
                    break;
                }

                case VT_EMPTY:
                    //
                    // ignore unset values
                    //
                    break;
        default:
                ciDebugOut(( DEB_ERROR, "Hit an Invalid variant type\n" ));
                THROW( CException( STATUS_INVALID_PARAMETER ) );
    }

    return ppData;
}

//+---------------------------------------------------------------------------
//
//  Member:     GetDepthsFromVariant, private
//
//  Synopsis:   obtains pointer to WChar values in a variant
//
//  Arguments:  [dbProp]    -- src property
//              [cElemetns] -- count of depths
//              [mask]      -- mask to verify validity of depths
//
//  Returns:    pointer to valid array of depths upon success
//              THROWS upon failure.
//
//  History:    10-May-97   mohamedn    created
//
//----------------------------------------------------------------------------

DWORD *GetDepthsFromVariant( DBPROP  & dbProp, ULONG *cElements, ULONG mask )
{
    Win4Assert( dbProp.dwStatus == DBPROPSTATUS_OK );

    VARIANT & var     = dbProp.vValue;
    DWORD   * pdwData = 0;
    *cElements        = 0;

    switch (var.vt)
    {
        case VT_I4:
        case VT_UI4:
                
                *cElements = 1;
                pdwData = (ULONG *)&var.lVal;

                break;

        case VT_I4|VT_ARRAY:
        case VT_UI4|VT_ARRAY:
                {
                    SAFEARRAY & sa = *var.parray;

                    if ( sa.cDims != 1 )
                    {
                        THROW( CException( STATUS_INVALID_PARAMETER ) );
                    }
                    else if ( sa.pvData )
                    {
                        *cElements = sa.rgsabound[0].cElements;
                        pdwData = (ULONG *)sa.pvData;
                    }
                    else
                    {
                        Win4Assert( !"Invalid SafeArray of Depths" );
                        THROW( CException( STATUS_INVALID_PARAMETER ) );
                    }
                    break;
               }

                case VT_EMPTY:
                    //
                    // ignore unset values.
                    //
                    break;

        default:
                ciDebugOut(( DEB_ERROR, "Got an Invalid Variant\n" ));
                THROW( CException( STATUS_INVALID_PARAMETER ) );
    }

    //
    // verify validity of Depth values
    //

    for ( unsigned i = 0; i < *cElements; i++ )
    {
        if ( 0 != (mask & pdwData[i]) )
        {
            Win4Assert( !"Invalid Depth value" );
            THROW( CException( STATUS_INVALID_PARAMETER ) );
        }
    }

    return pdwData;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\query\cidbprop.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 2000.
//
//  File:       cidbprop.cxx
//
//  Contents:   IDBProperties implementation 
//
//  History:    1-09-97   srikants   Created
//
//----------------------------------------------------------------------------


#include <pch.cxx>
#pragma hdrstop

#include <cidbprop.hxx>

CStorageVariant * StgVarFromVar( VARIANT & p )
{
    return (CStorageVariant *) (void *) (&p);
}

CStorageVariant const * StgVarFromVar( VARIANT const & p )
{
    return (CStorageVariant const *) (void const *) (&p);
}

//+---------------------------------------------------------------------------
//
//  Member:     CDbProperties::QueryInterface
//
//  Synopsis:   Supports IID_IUnknown, IID_IDBProperties
//
//  History:    01-13-97   srikants   Created
//
//----------------------------------------------------------------------------


STDMETHODIMP CDbProperties::QueryInterface(
    REFIID riid,
    void **ppvObject)
{
    Win4Assert( 0 != ppvObject );
    *ppvObject = 0;

    if ( IID_IUnknown == riid )
        *ppvObject = (void *)((IUnknown *) (IDBProperties *)this);
    else if ( IID_IDBProperties == riid )
        *ppvObject = (void *)((IDBProperties *)this);
    else
        return E_NOINTERFACE;

    AddRef();
    return S_OK;
} //QueryInterface


//+---------------------------------------------------------------------------
//
//  Member:     CDbProperties::AddRef
//
//  History:    1-13-97   srikants    Created
//
//----------------------------------------------------------------------------

STDMETHODIMP_(ULONG) CDbProperties::AddRef()
{
    if ( _pUnkOuter )
        return _pUnkOuter->AddRef();

    return InterlockedIncrement( &_refCount );
} //AddRef

//+---------------------------------------------------------------------------
//
//  Member:     CDbProperties::Release
//
//  History:    1-13-97   srikants    Created
//
//----------------------------------------------------------------------------

STDMETHODIMP_(ULONG) CDbProperties::Release()
{
    if ( _pUnkOuter )
    {
        return _pUnkOuter->Release();    
    }
    else
    {
        Win4Assert( _refCount > 0 );
    
        LONG refCount = InterlockedDecrement(&_refCount);
    
        if (  refCount <= 0 )
            delete this;
    
        return (ULONG) refCount;
    }
}  //Release

//+---------------------------------------------------------------------------
//
//  Member:     CDbProperties::GetProperties
//
//  Synopsis:   Retrieves the properties that have been set.
//
//  Arguments:  [cPropertyIDSets]  - 
//              [rgPropertyIDSets] - 
//              [pcPropertySets]   - 
//              [prgPropertySets]  - 
//
//  Returns:    
//
//  History:    1-09-97   srikants   Created
//
//----------------------------------------------------------------------------


SCODE CDbProperties::GetProperties( 
            ULONG cPropertyIDSets,
            const DBPROPIDSET pPropIDSet[],
            ULONG *pcPropertySets,
            DBPROPSET ** prgPropertySets)
{
    //
    // If cPropertyIDSets is not zero, then return that many property sets.
    // Otherwise, return as many as we have.
    //
    unsigned cAllocPropSets = cPropertyIDSets ?
                                cPropertyIDSets : _aPropSet.Count();

    //
    // Check if there are not property sets available to be
    // given.
    //
    if ( 0 == cAllocPropSets )
    {
        pcPropertySets = 0;
        prgPropertySets = 0;
        return S_OK;
    }

    SCODE sc = S_OK;

    XArrayOLEInPlace<CDbPropSet> aProps;

    unsigned cPropsRet = 0;
    unsigned cPropErrs = 0;

    TRY
    {
        aProps.Init( cAllocPropSets );

        for ( ULONG i = 0; i < cAllocPropSets; i++ )
        {
            if ( cPropertyIDSets )
            {
                cPropErrs += CreateReturnPropset( pPropIDSet[i] , aProps[i] );
            }
            else
            {
                if ( !aProps[i].Copy( _aPropSet[i] ) )
                    THROW( CException( E_OUTOFMEMORY ) );
            }

            cPropsRet += aProps[i].cProperties;
        }
    }
    CATCH( CException, e )
    {
        cPropErrs = 0;
        sc = e.GetErrorCode();
        if ( !FAILED(sc) )
            sc = DB_E_ERRORSOCCURRED;    
    }
    END_CATCH

    if ( S_OK == sc )
    {
        if ( cPropErrs > 0 )
            sc = cPropErrs == cPropsRet ? DB_E_ERRORSOCCURRED : DB_S_ERRORSOCCURRED;    
    }

    if ( !FAILED(sc) )
    {
        Win4Assert( cPropsRet >= cPropErrs );
        *pcPropertySets = cAllocPropSets;
        *prgPropertySets = aProps.GetPointer();
        aProps.Acquire();
    }

    return sc;
}


//+---------------------------------------------------------------------------
//
//  Member:     CDbProperties::GetPropertyInfo
//
//  Synopsis:   Retrieves the PropertyInfo 
//
//  Arguments:  [cPropertyIDSets]     - 
//              [rgPropertyIDSets]    - 
//              [pcPropertyInfoSets]  - 
//              [prgPropertyInfoSets] - 
//              [ppDescBuffer]        - 
//
//  Returns:    
//
//  History:    1-09-97   srikants   Created
//
//----------------------------------------------------------------------------

SCODE CDbProperties::GetPropertyInfo( 
            ULONG cPropertyIDSets,
            const DBPROPIDSET  rgPropertyIDSets[],
            ULONG  *pcPropertyInfoSets,
            DBPROPINFOSET  * *prgPropertyInfoSets,
            OLECHAR  * *ppDescBuffer)
{

    SCODE sc = S_OK;

    TRY
    {
        Win4Assert( !"Not Yet Implemented" );
        sc = E_NOTIMPL;
    }
    CATCH( CException, e )
    {
        sc = e.GetErrorCode();    
    }
    END_CATCH

    return sc;
}

//+---------------------------------------------------------------------------
//
//  Member:     CDbProperties::SetProperties
//
//  Synopsis:   Sets the given properties.
//
//  Arguments:  [cPropertySets]  - 
//              [rgPropertySets] - 
//
//  Returns:    
//
//  History:    1-09-97   srikants   Created
//
//----------------------------------------------------------------------------

SCODE CDbProperties::SetProperties( 
            ULONG cPropertySets,
            DBPROPSET  rgPropertySets[])
{    
    SCODE sc = S_OK;

    ULONG cErrors = 0;
    
    TRY
    {
        _aPropSet.Free();
        _aPropSet.Init( cPropertySets );

        for (unsigned i = 0; i < cPropertySets; i++)
        {
            DBPROP * pProp = rgPropertySets[i].rgProperties;

            if ( !(_aPropSet[i].Copy( rgPropertySets[i] )) )
                THROW( CException( E_OUTOFMEMORY ) );
        }
    }
    CATCH( CException, e )
    {
        cErrors = 0;
        sc = e.GetErrorCode();
        if ( !FAILED(sc) )
        {
            sc = DB_E_ERRORSOCCURRED;    
        }
    }
    END_CATCH

    if ( S_OK == sc )
    {
        if ( cErrors > 0 )
        {
            sc = cErrors == cPropertySets ?
                            DB_E_ERRORSOCCURRED : DB_S_ERRORSOCCURRED;
        }
    }

    return sc;
}

//+---------------------------------------------------------------------------
//
//  Method:     CDbProperties::CreateReturnPropset, private
//
//  Synopsis:   Allocate and fill in an array of DBPROP structures
//
//  Arguments:  [PropIDSet]  - a DBPROPIDSET
//              [Props]      - a DBPROPSET
//
//  Returns:    unsigned - number of errors
//
//  History:    25 Sep 96   AlanW       Created
//
//----------------------------------------------------------------------------

unsigned CDbProperties::CreateReturnPropset(
    DBPROPIDSET const & PropIDSet,
    CDbPropSet & Props )
{
    unsigned cErrors = 0;

    //
    // Locate the PropIDSet.
    //
    for ( unsigned i = 0; i < _aPropSet.Count(); i++ )
    {
        if ( _aPropSet[i].guidPropertySet == PropIDSet.guidPropertySet )
            break;    
    }

    XArrayOLEInPlace<CDbProp> aProps;

    Props.guidPropertySet = PropIDSet.guidPropertySet;
    Props.cProperties = 0;

    if ( i == _aPropSet.Count() )
    {
        //
        // The given propset could not be found in our list.
        //
        aProps.Init(1);

        //
        //  Unrecognized property set ID
        //
        aProps[0].dwPropertyID = 0;
        aProps[0].dwOptions = 0;
        aProps[0].dwStatus = DBPROPSTATUS_NOTSUPPORTED;
        aProps[0].vValue.vt = VT_EMPTY;
        cErrors++;
    }
    else
    {
        unsigned cAllocProp = (PropIDSet.cPropertyIDs != 0) ?
                                 PropIDSet.cPropertyIDs : _aPropSet[i].cProperties;


        aProps.Init( cAllocProp );

        CDbPropSet & srcPropSet = _aPropSet[i];

        if ( 0 == PropIDSet.cPropertyIDs )
        {
            //
            // The client wants to know about all the properties.
            //
            for ( unsigned j =0; j < cAllocProp; j++ )
            {
                if (!aProps[j].Copy( srcPropSet.rgProperties[j] ))
                    THROW( CException( E_OUTOFMEMORY ) );
            }
        }
        else
        {
            for ( unsigned j = 0; j < cAllocProp; j++ )
            {
                CopyProp( aProps[j], srcPropSet, PropIDSet.rgPropertyIDs[j] );
                if ( aProps[j].dwStatus != DBPROPSTATUS_OK )
                    cErrors++;    
            }
        }
    }
    
    Props.cProperties = aProps.Count();
    Props.rgProperties = aProps.Acquire();

    return cErrors;
}

//+---------------------------------------------------------------------------
//
//  Member:     CDbProperties::CopyProp
//
//  Synopsis:   Copies the given property to the destination from Source.
//
//  Arguments:  [dst]      - The destination DBPROP
//              [src]      - Source DBPROPSET 
//              [dwPropId] - The propertyId to copy.
//
//  History:    1-09-97   srikants   Created
//
//----------------------------------------------------------------------------

void  CDbProperties::CopyProp(
    CDbProp & dst,
    CDbPropSet const & src,
    DBPROPID dwPropId )
{
    RtlZeroMemory( &dst, sizeof CDbProp);

    dst.dwPropertyID = dwPropId;
    dst.dwStatus = DBPROPSTATUS_OK;

    for ( unsigned i = 0; i < src.cProperties; i++ )
    {
        if ( src.rgProperties[i].dwPropertyID == dwPropId )
        {
            if ( !dst.Copy( src.rgProperties[i] ) )
                THROW( CException( E_OUTOFMEMORY ) );
            break;
        }
    }

    if ( i == src.cProperties )
    {
        dst.vValue.vt = VT_EMPTY;
        dst.dwStatus = DBPROPSTATUS_NOTSUPPORTED;
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CDbProperties::Marshall
//
//  Synopsis:   Marshalls the properties to a stream.
//
//  Arguments:  [stm] - 
//
//  History:    1-09-97   srikants   Created
//
//----------------------------------------------------------------------------


void CDbProperties::Marshall( PSerStream & stm  ) const
{
    stm.PutULong( _aPropSet.Count() );
    for ( unsigned i = 0; i < _aPropSet.Count(); i++ )
    {
        _aPropSet[i].Marshall( stm );        
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CDbProperties::Marshall
//
//  Synopsis:   Marshalls the properties to a stream except for those listed.
//
//  Arguments:  [stm]    -- Stream into which data is marshalled
//              [cGuids] -- Count of guids in pGuids
//              [pGuids] -- Array of guids to ignore when marshalling
//
//  History:    1-02-98   dlee   Created
//
//----------------------------------------------------------------------------


void CDbProperties::Marshall(
    PSerStream & stm,
    ULONG        cGuids,
    GUID const * pGuids  ) const
{
    ULONG c = _aPropSet.Count();

    for ( ULONG i = 0; i < _aPropSet.Count(); i++ )
    {
        const DBPROPSET & PropSet = * _aPropSet[i].CastToStruct();

        for ( ULONG x = 0; x < cGuids; x++ )
        {
            if ( PropSet.guidPropertySet == pGuids[ x ] )
            {
                c--;
                break;
            }
        }
    }

    ciDebugOut(( DEB_ITRACE,
                 "CDbProperties::Marshall, emit %d of %d properties\n",
                 c, _aPropSet.Count() ));

    stm.PutULong( c );

    for ( i = 0; i < _aPropSet.Count(); i++ )
    {
        const DBPROPSET & PropSet = * _aPropSet[i].CastToStruct();

        BOOL fIgnore = FALSE;

        for ( ULONG x = 0; x < cGuids; x++ )
        {
            if ( PropSet.guidPropertySet == pGuids[ x ] )
            {
                fIgnore = TRUE;
                break;
            }
        }

        if ( !fIgnore )
            _aPropSet[i].Marshall( stm );        
    }
} //Marshall

//+---------------------------------------------------------------------------
//
//  Member:     CDbProperties::UnMarshall
//
//  Synopsis:   Unmarshalls the array of properties from the stream
//
//  Arguments:  [stm] - Stream from which the properties are unmarshalled
//
//  Returns:    TRUE if successful; FALSE o/w
//
//  History:    1-09-97   srikants   Created
//
//----------------------------------------------------------------------------

BOOL CDbProperties::UnMarshall( PDeSerStream & stm  )
{
    ULONG cProps = stm.GetULong();

    // Guard against attack

    if ( cProps > 100 )
        return FALSE;

    _aPropSet.Free();

    BOOL fOk = TRUE;

    if ( cProps != 0 )
    {
        _aPropSet.InitNoThrow( cProps );
        if ( _aPropSet.IsNull() )
            return FALSE;

        for ( ULONG i = 0; i < cProps; i++ )
        {
            if ( !_aPropSet[i].UnMarshall( stm ) )
            {
                fOk = FALSE;
                break;                
            }
        }
    }

    return fOk;
} //UnMarshall
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\query\dllmain.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996 - 2000.
//
//  File:       dllmain.cxx
//
//  Contents:   Dll entry code for query
//
//  History:    28-Feb-96     KyleP        Created
//              28-Dec-98     dlee         Added header
//
//--------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include <ntverp.h>
#include <fnreg.h>
#include <ciole.hxx>

#define _DECL_DLLMAIN 1
#include <process.h>

DECLARE_INFOLEVEL (ci);
DECLARE_INFOLEVEL (vq);
DECLARE_INFOLEVEL (tb);

#if CIDBG == 1
    #define VER_CIDEBUG "chk"
#else // CIDBG == 1
    #define VER_CIDEBUG "fre"
#endif // CIDBG == 1

#define MAKELITERALSTRING( s, lit ) s #lit
#define MAKELITERAL( s, lit ) MAKELITERALSTRING( s, lit )

#define VERSION_STRING "Indexing Service 3.0 (query) " VER_CIDEBUG\
                       MAKELITERAL(" built by ", BUILD_USERNAME)\
                       MAKELITERAL(" with ", VER_PRODUCTBUILD)\
                       " headers on " __DATE__ " at " __TIME__

const char g_ciBuild[] = VERSION_STRING;

HANDLE g_hCurrentDll;

BOOL g_fInitDone = FALSE;

//
// A bug in a perfmon dll makes them call this function after we've
// been process detached!  They call us in their process detach, which
// is well after we've been detached and destroyed our heap.  This
// hack works around their bug.
//

BOOL g_fPerfmonCounterHackIsProcessDetached = FALSE;

extern CStaticMutexSem g_mtxCommandCreator;
extern CStaticMutexSem g_mtxQPerf;
extern CStaticMutexSem g_mtxStartStop;
extern CStaticMutexSem g_mtxFilePropList;
extern CStaticMutexSem g_mtxPropListIter;

extern void InitializeDocStore();

void InitializeModule()
{
    g_mtxCommandCreator.Init();
    g_mtxQPerf.Init();
    g_mtxStartStop.Init();
    g_mtxFilePropList.Init();
    g_mtxPropListIter.Init();

    CCiOle::Init();

    InitializeDocStore();

    g_fInitDone = TRUE;
}

//+---------------------------------------------------------------------------
//
//  Function:   DllMain
//
//  Synopsis:   Called from C-Runtime on process/thread attach/detach
//
//  Arguments:  [hInstance]  -- Module / Instance handle
//              [dwReason]   -- Reason for being called
//              [lpReserved] --
//
//  History:    28-Feb-96   KyleP       Created
//
//----------------------------------------------------------------------------

BOOL WINAPI DllMain( HANDLE hInstance, DWORD dwReason, void * lpReserved )
{
    BOOL fOk = TRUE;

    TRANSLATE_EXCEPTIONS;
    try
    {
        //
        // Initialize exception / memory system.
        //
 
        fOk = ExceptDllMain( hInstance, dwReason, lpReserved );
    
#ifndef OLYMPUS
        if ( fOk )
            fOk = FNPrxDllMain( (HINSTANCE) hInstance, dwReason, lpReserved );
#endif //ndef OLYMPUS
 
        if ( fOk )
        {
            switch ( dwReason )
            {
                case DLL_PROCESS_ATTACH:
                {
                    g_hCurrentDll = hInstance;
                    DisableThreadLibraryCalls( (HINSTANCE) hInstance );
                    InitializeModule();
                    break;
                }
 
                case DLL_PROCESS_DETACH:
                {
                    g_fPerfmonCounterHackIsProcessDetached = TRUE;
                    break;
                }
            }
        }
    }
    catch( ... )
    {
        //
        // One possible cause of an exception is STATUS_NO_MEMORY thrown
        // by InitializeCriticalSection.
        //
        fOk = FALSE;
    }
    UNTRANSLATE_EXCEPTIONS;

    return fOk;
} //DllMain
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\query\driveinf.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1998.
//
//  File:       driveinf.cxx
//
//  Contents:   Retrieves information about a specific volume.
//
//  Classes:    CDriveInfo
//
//  History:    17-Nov-98   KLam     Created
//
//----------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include <driveinf.hxx>

//+---------------------------------------------------------------------------
//
//  Member:     CDriveInfo::CDriveInfo
//
//  Synopsis:   Constructor - stores away the drive name and initializes members
//
//  Arguments:  [pwszPath]            -  A Path on the drive.
//              [cbMegToLeaveOnDisk]  -  Number of bytes to leave on disk
//
//  History:    17-Nov-98  KLam     Created
//
//----------------------------------------------------------------------------

CDriveInfo::CDriveInfo( WCHAR const * wcsPath, ULONG cMegToLeaveOnDisk )
                    : _cbDiskSpaceToLeave ( (__int64)(cMegToLeaveOnDisk) * 1024 * 1024 ),
                      _cbSectorSize ( 0 ),
                      _efsType ( VOLINFO_UNKNOWN ),
                      _ulDriveType ( DRIVE_NO_ROOT_DIR ),
                      _fCheckedProtection ( FALSE ),
                      _fWriteProtected ( TRUE )
{
    _awcVolumeName[0] = 0;

    GetDrive ( wcsPath, _wcsDrive );
    
    if ( 0 == _wcsDrive[0] )
        THROW( CException( STATUS_INVALID_PARAMETER ) );

    wcscpy ( _wcsRoot, _wcsDrive );
    wcscat ( _wcsRoot, L"\\" );
}

//+---------------------------------------------------------------------------
//
//  Member:     CDriveInfo::IsSameDrive, public
//
//  Synopsis:   Determines if the path is on the same drive as current object
//
//  Arguments:  [pwszPath] -  A Path on the drive. [IN]
//
//  Returns:    TRUE if the path is on the same volume, FALSE otherwise.
//
//  History:    17-Nov-98  KLam     Created
//
//----------------------------------------------------------------------------

BOOL CDriveInfo::IsSameDrive ( WCHAR const * wcsPath )
{
    WCHAR wcsDrive[_MAX_DRIVE + 1];
    GetDrive ( wcsPath, wcsDrive );
    return wcsDrive[0] == _wcsDrive[0];
}

//+---------------------------------------------------------------------------
//
//  Member:     CDriveInfo::ContainsDrive, public static
//
//  Synopsis:   Determines if there is a drive letter in the path
//
//  Arguments:  [pwszPath] -  A Path on the drive. [IN]
//
//  Returns:    TRUE if there is a drive in the path. FALSE otherwise.
//
//  History:    17-Nov-98  KLam     Created
//
//----------------------------------------------------------------------------

BOOL CDriveInfo::ContainsDrive ( WCHAR const * wcsPath )
{
    ULONG cwcDrive = wcslen ( wcsPath );
    if ( ( cwcDrive > 1 && L':' == wcsPath[1] )
        || ( cwcDrive > 5 && L':' == wcsPath[5] ))
        return TRUE;
    
    return FALSE;
}

//+---------------------------------------------------------------------------
//
//  Member:     CDriveInfo::GetDrive, static public
//
//  Synopsis:   Gets the drive out of the path
//
//  Arguments:  [pwszPath] -  A Path on the drive. [IN]
//              [wcsDrive] -  Buffer to receive drive. Buffer should be at least
//                            _MAX_DRIVE characters in length.[OUT]
//
//  History:    17-Nov-98  KLam     Created
//
//  Notes:      If there is no drive in the path wcsDrive will contain an empty
//              string.  This method handles funny paths as well as regular paths.
//
//----------------------------------------------------------------------------

void CDriveInfo::GetDrive ( WCHAR const * wcsPath, WCHAR * wcsDrive )
{
    //
    // Get the drive letter from the path
    // Must either be of the form <drive>:<path> or \\?\<drive>:<path>
    //
    wcsDrive[0] = 0;
    ULONG cwcDrive = wcslen ( wcsPath );
    WCHAR wcDrive = 0;
    if ( cwcDrive > 1 && L':' == wcsPath[1] )
    {
        wcDrive = wcsPath[0];
    }
    else if ( cwcDrive > 5 && L':' == wcsPath[5] )
    {
        wcDrive = wcsPath[4];
    }

    if ( 0 != wcDrive )
    {
        wcsDrive[0] = wcDrive;
        wcsDrive[1] = L':';
        wcsDrive[2] = 0;
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CDriveInfo::IsWriteProtected, public
//
//  Synopsis:   Determines if drive is writable
//
//  Returns:    TRUE if the drive is write protected. FALSE otherwise.
//
//  History:    17-Nov-98  KLam     Created
//
//  Notes:      Caches value after first call.
//
//----------------------------------------------------------------------------

BOOL CDriveInfo::IsWriteProtected ()
{
    if ( !_fCheckedProtection )
    {
        _fCheckedProtection = TRUE;

        Win4Assert ( 0 != _wcsDrive[0] );

        // Format needed to open a handle to a volume \\.\<drive>:
        WCHAR wcsVolumePath[] = L"\\\\.\\a:";
        wcsVolumePath[4] = _wcsDrive[0];
    
        HANDLE hVolume = CreateFile( wcsVolumePath,
                                     FILE_READ_ATTRIBUTES,
                                     FILE_SHARE_READ | FILE_SHARE_WRITE,
                                     NULL,
                                     OPEN_EXISTING,
                                     0,
                                     NULL );    
    
        SHandle shVolume ( hVolume );

        if ( INVALID_HANDLE_VALUE == hVolume) 
        {
            DWORD dwError = GetLastError();

            ciDebugOut(( DEB_ITRACE, "CDriveInfo::IsWriteProtected[%wc]: dwError is %d\n", 
                        _wcsDrive[0], dwError ));

            if ( ERROR_ACCESS_DENIED != dwError && ERROR_WRITE_PROTECT != dwError )
                THROW (CException (HRESULT_FROM_WIN32(dwError) ));

            _fWriteProtected = FALSE;
        }
        else 
        { 
            ciDebugOut(( DEB_ITRACE, "Get volume handle succeeded for volume %wc\n", _wcsDrive[0] ));

            IO_STATUS_BLOCK IoStatus;

            NTSTATUS Status = NtDeviceIoControlFile( hVolume,
                                                     0, NULL, NULL,
                                                     &IoStatus,
                                                     IOCTL_DISK_IS_WRITABLE,
                                                     NULL, 0, NULL, 0);

            _fWriteProtected = ( STATUS_MEDIA_WRITE_PROTECTED == Status );
        }
    }

    return _fWriteProtected;
}

//+---------------------------------------------------------------------------
//
//  Member:     CDriveInfo::GetSectorSize, public
//
//  Synopsis:   Gets the number of bytes in a sector for this volume
//
//  History:    17-Nov-98  KLam     Created
//
//  Notes:      Caches value after first call.
//
//----------------------------------------------------------------------------

ULONG CDriveInfo::GetSectorSize ()
{
    //
    // Only get the sector size once
    //
    if ( 0 == _cbSectorSize )
    {
        Win4Assert ( 0 != _wcsRoot[0] );

        DWORD dwSectorsPerCluster;
        DWORD dwFreeClusters;
        DWORD dwTotalClusters;

        if ( !GetDiskFreeSpace ( _wcsRoot,
                                 &dwSectorsPerCluster,
                                 &_cbSectorSize,
                                 &dwFreeClusters,
                                 &dwTotalClusters ) )
        {
            DWORD dwError = GetLastError();
            vqDebugOut(( DEB_ITRACE, "GetDiskFreeSpace( %ws ) returned %d\n",
                         _wcsRoot, dwError ));
            THROW (CException (HRESULT_FROM_WIN32(dwError) ));
        }
    }

    return _cbSectorSize;
}

//+---------------------------------------------------------------------------
//
//  Member:     CDriveInfo::GetDiskSpace, public
//
//  Synopsis:   Gets the total and remaining disk space on the volume
//
//  Arguments:  [cbTotal]     -  Total number of bytes on disk available to 
//                               caller [OUT]
//              [cbRemaining] -  Number of bytes remaining on disk available
//                               to caller [OUT]
//
//  History:    17-Nov-98  KLam     Created
//
//----------------------------------------------------------------------------

void CDriveInfo::GetDiskSpace ( __int64 & cbTotal, __int64 & cbRemaining )
{
    Win4Assert ( 0 != _wcsRoot[0] );

    ULARGE_INTEGER cbFreeToCaller, cbTotalToCaller;
    if (! GetDiskFreeSpaceEx ( _wcsRoot, &cbFreeToCaller, &cbTotalToCaller, 0 ))
    {
        DWORD dwError = GetLastError();
        vqDebugOut(( DEB_ITRACE, "GetDiskFreeSpaceEx( %ws ) returned %d\n",
                     _wcsRoot, dwError ));
        THROW (CException (HRESULT_FROM_WIN32(dwError) ));
    }

    cbTotal = ( (__int64)(cbTotalToCaller.QuadPart) > _cbDiskSpaceToLeave )
            ? cbTotalToCaller.QuadPart - _cbDiskSpaceToLeave
            : 0;

    cbRemaining = ( (__int64)(cbFreeToCaller.QuadPart) > _cbDiskSpaceToLeave )
                ? cbFreeToCaller.QuadPart -  _cbDiskSpaceToLeave
                : 0;
}

//+---------------------------------------------------------------------------
//
//  Member:     CDriveInfo::GetDriveType, public
//
//  Synopsis:   Gets the type of media the volume is on.
//
//  Arguments:  [fRefresh] -  Do you want the cached value refreshed [Default: FALSE]
//
//  Returns:    The return value is zero if the function cannot determine the drive
//              type, or 1 if the specified root directory does not exist.
//
//              DRIVE_UNKNOWN     - The drive type can not be determined.
//              DRIVE_NO_ROOT_DIR - The root directory does not exist.
//              DRIVE_REMOVABLE   - Disk can be removed from the drive.
//              DRIVE_FIXED       - Disk cannot be removed from the drive.
//              DRIVE_REMOTE      - Drive is a remote (network) drive.
//              DRIVE_CDROM       - Drive is a CD rom drive.
//              DRIVE_RAMDISK     - Drive is a RAM disk.
//
//  History:    17-Nov-98  KLam     Created
//
//  Notes:      Caches result after first call.
//
//----------------------------------------------------------------------------

ULONG CDriveInfo::GetDriveType ( BOOL fRefresh )
{
    //
    // Only get the drive type once
    //
    if ( DRIVE_NO_ROOT_DIR != _ulDriveType || fRefresh )
    {
        Win4Assert ( 0 != _wcsRoot[0] );
        _ulDriveType = ::GetDriveType ( _wcsRoot );
    }

    return _ulDriveType;
}

//+---------------------------------------------------------------------------
//
//  Member:     CDriveInfo::GetFileSystem, public
//
//  Synopsis:   Gets the type of file system of the volume
//
//  Arguments:  [fRefresh] -  Do you want the cached value refreshed [Default: FALSE]
//
//  History:    17-Nov-98  KLam     Created
//
//  Notes:      Caches result after first call.
//
//----------------------------------------------------------------------------

CDriveInfo::eFileSystem CDriveInfo::GetFileSystem ( BOOL fRefresh )
{
    //
    // Only get the file system type once and volume name
    //
    if ( VOLINFO_UNKNOWN == _efsType || fRefresh )
    {
        Win4Assert ( 0 != _wcsRoot[0] );

        //
        // Not the right constant for this buffer size, but probably good
        // enough -- 30
        //

        WCHAR awcFileSystem[MAX_VOLUME_ID_SIZE + 1];
        BOOL fSuccess = GetVolumeInformation( _wcsRoot,
                                              _awcVolumeName,
                                              sizeof _awcVolumeName / sizeof WCHAR,
                                              0, // Volume Serial Number
                                              0, // Maximum Component Length
                                              0, // File System Flags
                                              awcFileSystem,
                                              sizeof awcFileSystem / sizeof WCHAR );

        if ( !fSuccess )
        {
            THROW ( CException ( HRESULT_FROM_WIN32( GetLastError() ) ) );
        }
        else if ( 0 == wcscmp ( L"NTFS", awcFileSystem ) )
            _efsType = VOLINFO_NTFS;
        else if ( 0 == wcscmp ( L"FAT", awcFileSystem ) )
            _efsType = VOLINFO_FAT;
        else
            _efsType = VOLINFO_OTHER;
    }

    return _efsType;
}

//+---------------------------------------------------------------------------
//
//  Member:     CDriveInfo::GetVolumeName, public
//
//  Synopsis:   Gets the name of the volume
//
//  Arguments:  [fRefresh] -  Do you want the cached value refreshed [Default: FALSE]
//
//  History:    17-Nov-98  KLam     Created
//
//  Notes:      Caches result after first call.
//
//----------------------------------------------------------------------------

WCHAR const * CDriveInfo::GetVolumeName ( BOOL fRefresh )
{
    //
    // Only get the volume name and the file system type once
    //
    if ( VOLINFO_UNKNOWN == _efsType || fRefresh )
    {
        GetFileSystem( fRefresh );
    }

    return _awcVolumeName;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\query\fullpath.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997 - 1998
//
//  File:       fullpath.cxx
//
//  Contents:   Full path manipulation
//
//  Classes:    CFullPath
//
//  History:    2-18-97   srikants   Created
//
//----------------------------------------------------------------------------

#include <pch.cxx>
#pragma  hdrstop

#include <fullpath.hxx>

//+-------------------------------------------------------------------------
//
//  Member:     CFullPath::CFullPath, public
//
//  Synopsis:   Constructor for CFullPath
//
//  Arguments:  [pwszPath] -- string which contains directory path
//
//  History:    27-Mar-92 AmyA      Created
//              04 Jun 96 AlanW     Modified to accomodate path names larger
//                                  than MAX_PATH
//
//--------------------------------------------------------------------------

CFullPath::CFullPath( WCHAR const * pwszPath )
{
    _lcaseFunnyPath.SetPath( pwszPath );
    _lcaseFunnyPath.AppendBackSlash();
    _ccActualPathLength = _lcaseFunnyPath.GetActualLength();
}

//+-------------------------------------------------------------------------
//
//  Member:     CFullPath::CFullPath, public
//
//  Synopsis:   Constructor for CFullPath
//
//  Arguments:  [pwszPath] -- string which contains directory path
//              [ccPath]   -- Size in characters of [pwszPath]
//
//  History:    30-Jun-1998   KyleP   Created
//
//--------------------------------------------------------------------------

CFullPath::CFullPath( WCHAR const * pwszPath, unsigned ccPath )
        : _lcaseFunnyPath( pwszPath, ccPath )
{
    _lcaseFunnyPath.AppendBackSlash();
    _ccActualPathLength = _lcaseFunnyPath.GetActualLength();
}

//+-------------------------------------------------------------------------
//
//  Member:     CFullPath::MakePath, public
//
//  Synopsis:   Creates a full pathname from a filename and the path in
//              FullPath.
//
//  Arguments:  [pFileName] - pointer to the filename
//
//  History:    27-Mar-92 AmyA      Created
//              04 Jun 96 AlanW     Modified to allow paths longer than MAX_PATH
//
//--------------------------------------------------------------------------

void CFullPath::MakePath( WCHAR const * pFileName )
{
    _lcaseFunnyPath.Truncate( _ccActualPathLength );
    _lcaseFunnyPath.AppendPath( pFileName );
}

//+-------------------------------------------------------------------------
//
//  Member:     CFullPath::MakePath, public
//
//  Synopsis:   Creates a full pathname from a filename and the path in
//              FullPath.
//
//  Arguments:  [pFileName]  -- pointer to the filename
//              [ccFileName] -- Size in characters of [pFileName]
//
//  History:    30-Jun-1998   KyleP   Created
//
//--------------------------------------------------------------------------

void CFullPath::MakePath( WCHAR const * pFileName, unsigned ccFileName )
{
    _lcaseFunnyPath.Truncate( _ccActualPathLength );
    _lcaseFunnyPath.AppendPath( pFileName, ccFileName );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\query\exports.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1999
//
//  File:       exports.cxx
//
//  Contents:   Code to export filter and word breaker class factories
//
//  History:    15-Aug-1994     SitaramR   Created
//
//  Notes:      Copied from txtifilt.hxx and then modified
//
//--------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include <dsocf.hxx>
#include <qryreg.hxx>
#include <ciintf.h>
#include <fnreg.h>

long gulcInstances = 0;

extern "C" SCODE STDMETHODCALLTYPE FsciDllGetClassObject( REFCLSID cid,
                                                          REFIID   iid,
                                                          void **  ppvObj );

extern "C" SCODE STDMETHODCALLTYPE CifrmwrkDllGetClassObject( REFCLSID cid,
                                                              REFIID   iid,
                                                              void **  ppvObj );

//+-------------------------------------------------------------------------
//
//  Function:   DllGetClassObject
//
//  Synopsis:   Ole DLL load class routine
//
//  Arguments:  [cid]    -- Class to load
//              [iid]    -- Interface to bind to on class object
//              [ppvObj] -- Interface pointer returned here
//
//  Returns:    Text filter or a word breaker class factory
//
//  History:    23-Feb-1994     KyleP   Created
//
//--------------------------------------------------------------------------

extern "C" SCODE STDMETHODCALLTYPE DllGetClassObject( REFCLSID   cid,
                                                      REFIID     iid,
                                                      void **    ppvObj )
{
    IUnknown * pResult = 0;
    SCODE       sc      = S_OK;

    TRY
    {
        const CLSID clsidCommandCreator = CLSID_CISimpleCommandCreator;

        if ( CLSID_CiFwDSO == cid )
        {
            pResult = (IUnknown *) new CDataSrcObjectCF;

        }
        else if (CLSID_CI_ERROR == cid )
        {
            pResult = (IUnknown *)new CErrorLookupCF;
        }
        else if (clsidCommandCreator == cid )
        {
            pResult = (IUnknown *) GetSimpleCommandCreatorCF();
        }
        else
        {
            void *pv = 0;

            sc = CifrmwrkDllGetClassObject( cid, iid, &pv );

#ifndef OLYMPUS
            if ( E_NOINTERFACE == sc )
                sc = FsciDllGetClassObject( cid, iid, &pv );

            if ( E_NOINTERFACE == sc )
                sc = FNPrxDllGetClassObject ( &cid, &iid, &pv );
#endif //ndef OLYMPUS

            if ( FAILED(sc) )
            {
                ciDebugOut(( DEB_ITRACE, "DllGetClassObject: no such interface found\n" ));
                pResult = 0;
                sc = E_NOINTERFACE;
            }
            else
                pResult = (IUnknown *) pv;
        }
    }
    CATCH(CException, e)
    {
        switch( e.GetErrorCode() )
        {
        case E_OUTOFMEMORY:
            sc = (E_OUTOFMEMORY);
            break;
        default:
            sc = (E_UNEXPECTED);
        }
    }
    END_CATCH;

    if (0 != pResult)
    {
        sc = pResult->QueryInterface( iid, ppvObj );
        pResult->Release( );
    }

    return (sc);
}

//+-------------------------------------------------------------------------
//
//  Method:     DllCanUnloadNow
//
//  Synopsis:   Notifies DLL to unload (cleanup global resources)
//
//  Returns:    S_OK if it is acceptable for caller to unload DLL.
//
//  History:    23-Feb-1994     KyleP   Created
//
//--------------------------------------------------------------------------

extern "C" SCODE STDMETHODCALLTYPE DllCanUnloadNow( void )
{
    if ( gulcInstances <= 0 )
        return( S_OK );
    else
        return( S_FALSE );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\query\guidutil.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1997.
//
//  File:       guidutil.cxx
//
//  History:    2-18-97   srikants   Created
//
//----------------------------------------------------------------------------

#include <pch.cxx>
#pragma  hdrstop

#include <guidutil.hxx>

//+---------------------------------------------------------------------------
//
//  Member:     CGuidUtil::StringToGuid, private
//
//  Synopsis:   Helper function to convert string-ized guid to guid.
//
//  Arguments:  [wcsValue] -- String-ized guid.
//              [guid]     -- Guid returned here.
//
//  History:    30-Jan-96   KyleP       Added header.
//
//----------------------------------------------------------------------------

void CGuidUtil::StringToGuid( WCHAR * wcsValue, GUID & guid )
{
    //
    // If the first character is a '{', skip it.
    //
    if ( wcsValue[0] == L'{' )
        wcsValue++;

    //
    // Convert classid string to guid
    // (since wcsValue may be used again below, no permanent modification to
    //  it may be made)
    //

    WCHAR wc = wcsValue[8];
    wcsValue[8] = 0;
    guid.Data1 = wcstoul( &wcsValue[0], 0, 16 );
    wcsValue[8] = wc;
    wc = wcsValue[13];
    wcsValue[13] = 0;
    guid.Data2 = (USHORT)wcstoul( &wcsValue[9], 0, 16 );
    wcsValue[13] = wc;
    wc = wcsValue[18];
    wcsValue[18] = 0;
    guid.Data3 = (USHORT)wcstoul( &wcsValue[14], 0, 16 );
    wcsValue[18] = wc;

    wc = wcsValue[21];
    wcsValue[21] = 0;
    guid.Data4[0] = (unsigned char)wcstoul( &wcsValue[19], 0, 16 );
    wcsValue[21] = wc;
    wc = wcsValue[23];
    wcsValue[23] = 0;
    guid.Data4[1] = (unsigned char)wcstoul( &wcsValue[21], 0, 16 );
    wcsValue[23] = wc;

    for ( int i = 0; i < 6; i++ )
    {
        wc = wcsValue[26+i*2];
        wcsValue[26+i*2] = 0;
        guid.Data4[2+i] = (unsigned char)wcstoul( &wcsValue[24+i*2], 0, 16 );
        wcsValue[26+i*2] = wc;
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CGuidUtil::GuidToString, private
//
//  Synopsis:   Helper function to convert guid to string-ized guid.
//
//  Arguments:  [guid]     -- Guid to convert.
//              [wcsValue] -- String-ized guid.
//
//  History:    30-Jan-96   KyleP       Added header.
//
//----------------------------------------------------------------------------

void CGuidUtil::GuidToString( GUID const & guid, WCHAR * wcsValue )
{
    swprintf( wcsValue,
              L"%08lX-%04X-%04X-%02X%02X-%02X%02X%02X%02X%02X%02X",
              guid.Data1,
              guid.Data2,
              guid.Data3,
              guid.Data4[0], guid.Data4[1],
              guid.Data4[2], guid.Data4[3],
              guid.Data4[4], guid.Data4[5],
              guid.Data4[6], guid.Data4[7] );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\query\dllreg.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997 - 1999.
//
//  File:       dllreg.cxx
//
//  Contents:   Null and Plain Text filter registration
//
//  History:    06-May-97     KrishnaN     Created
//              06-Jun-97     mohamedn     CiDSO registration
//
//--------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include <qryreg.hxx>
#include <ciregkey.hxx>
#include <olectl.h>
#include <FNReg.h>

extern "C" STDAPI FsciDllUnregisterServer(void);
extern "C" STDAPI FsciDllRegisterServer(void);
extern "C" STDAPI CifrmwrkDllUnregisterServer(void);
extern "C" STDAPI CifrmwrkDllRegisterServer(void);

extern const LPWSTR g_wszProviderName;

static const REGENTRIES s_rgMSIDXSRegInfo[] =
{
    { 0, L"MSIDXS",         NULL,       g_wszProviderName },
    { 0, L"MSIDXS\\Clsid",  NULL,       L"{F9AE8980-7E52-11d0-8964-00C04FD611D7}" },
    { 0, L"CLSID\\{F9AE8980-7E52-11d0-8964-00C04FD611D7}",                              NULL,               L"MSIDXS" },
    { 0, L"CLSID\\{F9AE8980-7E52-11d0-8964-00C04FD611D7}\\ProgID",                      NULL,               L"MSIDXS.1" },
    { 0, L"CLSID\\{F9AE8980-7E52-11d0-8964-00C04FD611D7}\\VersionIndependentProgID",    NULL,               L"MSIDXS" },
    { 0, L"CLSID\\{F9AE8980-7E52-11d0-8964-00C04FD611D7}\\InprocServer32",              NULL,               L"%s" },
    { 0, L"CLSID\\{F9AE8980-7E52-11d0-8964-00C04FD611D7}\\InprocServer32",              L"ThreadingModel",  L"Both" },
    { 0, L"CLSID\\{F9AE8980-7E52-11d0-8964-00C04FD611D7}\\OLE DB Provider",             NULL,               g_wszProviderName },

    { 0, L"MSIDXS ErrorLookup",         NULL,           L"Microsoft OLE DB Error Lookup for Indexing Service"},
    { 0, L"MSIDXS ErrorLookup\\Clsid",  NULL,           L"{F9AE8981-7E52-11d0-8964-00C04FD611D7}"},
    { 0, L"CLSID\\{F9AE8981-7E52-11d0-8964-00C04FD611D7}",                          NULL,               L"MSIDXS ErrorLookup" },
    { 0, L"CLSID\\{F9AE8981-7E52-11d0-8964-00C04FD611D7}\\ProgID",                  NULL,               L"MSIDXSErrorLookup.1" },
    { 0, L"CLSID\\{F9AE8981-7E52-11d0-8964-00C04FD611D7}\\VersionIndependentProgID",NULL,               L"MSIDXSErrorLookup" },
    { 0, L"CLSID\\{F9AE8981-7E52-11d0-8964-00C04FD611D7}\\InprocServer32",          NULL,               L"%s" },
    { 0, L"CLSID\\{F9AE8981-7E52-11d0-8964-00C04FD611D7}\\InprocServer32",          L"ThreadingModel",  L"Both" },
    { 0, L"CLSID\\{F9AE8980-7E52-11d0-8964-00C04FD611D7}\\ExtendedErrors",          NULL,               L"Extended Error Service"},
    { 0, L"CLSID\\{F9AE8980-7E52-11d0-8964-00C04FD611D7}\\ExtendedErrors\\{F9AE8981-7E52-11d0-8964-00C04FD611D7}", NULL, L"MSIDXS Error Lookup"},
};

static const REGENTRIES s_rgDBErrRegInfo[] =
{
    { 0, L"CI ErrorLookup", NULL, L"Microsoft OLE DB Error Lookup for Content Index"},
    { 0, L"CI ErrorLookup\\Clsid", NULL, L"{B02C2D1E-C26B-11d0-9940-00C04FC2F410}"},
    { 0, L"CLSID\\{B02C2D1E-C26B-11d0-9940-00C04FC2F410}", NULL, L"CI ErrorLookup" },
    { 0, L"CLSID\\{B02C2D1E-C26B-11d0-9940-00C04FC2F410}\\ProgID", NULL, L"CIErrorLookup.1" },
    { 0, L"CLSID\\{B02C2D1E-C26B-11d0-9940-00C04FC2F410}\\VersionIndependentProgID", NULL, L"CIErrorLookup" },
    { 0, L"CLSID\\{B02C2D1E-C26B-11d0-9940-00C04FC2F410}\\InprocServer32", NULL, L"%s" },
    { 0, L"CLSID\\{B02C2D1E-C26B-11d0-9940-00C04FC2F410}\\InprocServer32", L"ThreadingModel", L"Both" },
    { 0, L"CLSID\\{D7A2B01A-A47D-11d0-8C55-00C04FC2DB8D}\\ExtendedErrors", NULL, L"Extended Error Service"},
    { 0, L"CLSID\\{D7A2B01A-A47D-11d0-8C55-00C04FC2DB8D}\\ExtendedErrors\\{B02C2D1E-C26B-11d0-9940-00C04FC2F410}", NULL, L"CI Error Lookup"},
};

static const REGENTRIES s_rgICmdRegInfo[] =
{
    { 0, L"CLSID\\{C7B6C04A-CBB5-11d0-BB4C-00C04FC2F410}", NULL, L"IndexServer Simple Command Creator" },
    { 0, L"CLSID\\{C7B6C04A-CBB5-11d0-BB4C-00C04FC2F410}\\ProgID", NULL, L"ISSimpleCommandCreator.1" },
    { 0, L"CLSID\\{C7B6C04A-CBB5-11d0-BB4C-00C04FC2F410}\\VersionIndependentProgID", NULL, L"ISSimpleCommandCreator" },
    { 0, L"CLSID\\{C7B6C04A-CBB5-11d0-BB4C-00C04FC2F410}\\InprocServer32", NULL, L"%s" },
    { 0, L"CLSID\\{C7B6C04A-CBB5-11d0-BB4C-00C04FC2F410}\\InprocServer32", L"ThreadingModel", L"Both" },
};

static const REGENTRIES s_rgCiDSOInfo[] =
{
    { 0, L".cidso",                              NULL,                      L"Microsoft.CiDSO" },
    { 0, L"Microsoft.CiDSO",                     NULL,                      L"Microsoft Content Index OLE DB Provider" },
    { 0, L"Microsoft.CiDSO\\CLSID",              NULL,                      L"{D7A2B01A-A47D-11d0-8C55-00C04FC2DB8D}" },
    { 0, L"CLSID\\{D7A2B01A-A47D-11d0-8C55-00C04FC2DB8D}",                   NULL,                      L"Microsoft Content Index OLE DB Provider" },
    { 0, L"CLSID\\{D7A2B01A-A47D-11d0-8C55-00C04FC2DB8D}\\ProgID",           NULL,                      L"Microsoft.CiDSO.1" },
    { 0, L"CLSID\\{D7A2B01A-A47D-11d0-8C55-00C04FC2DB8D}\\VersionIndependentProgID", NULL,              L"Microsoft.CiDSO" },
    { 0, L"CLSID\\{D7A2B01A-A47D-11d0-8C55-00C04FC2DB8D}\\OLE DB Provider",  NULL,                      L"Microsoft Content Index OLE DB Provider" },
    { 0, L"CLSID\\{D7A2B01A-A47D-11d0-8C55-00C04FC2DB8D}\\InprocServer32",   NULL,                      L"%s" },
    { 0, L"CLSID\\{D7A2B01A-A47D-11d0-8C55-00C04FC2DB8D}\\InprocServer32",   L"ThreadingModel",         L"Both" }
};

//+-------------------------------------------------------------------------
//
//  Function:   DllRegisterServer
//
//  Synopsis:   Registers all that needs to be registered for this dll.
//
//  Returns:    Success or failure of registration.
//
//
//  History:    01-May-1997     KrishnaN   Created Header.
//
//--------------------------------------------------------------------------

extern "C" STDAPI DllRegisterServer(void)
{
    SCODE sc = S_OK;

    CTranslateSystemExceptions xlate;

    TRY
    {
        sc = RegisterServer(HKEY_CLASSES_ROOT,
                                  sizeof(s_rgMSIDXSRegInfo)/sizeof(s_rgMSIDXSRegInfo[0]),
                                  s_rgMSIDXSRegInfo);
    
        if (S_OK == sc)
            sc = RegisterServer(HKEY_CLASSES_ROOT,
                                  sizeof(s_rgICmdRegInfo)/sizeof(s_rgICmdRegInfo[0]),
                                  s_rgICmdRegInfo);
    
        //
        // create the CICommon registry key so all dependents of query.dll can
        // set/get non-framework registry entries there.
        //
    
        HKEY hKey;
        if (S_OK == sc &&
            ERROR_SUCCESS == RegOpenKey( HKEY_LOCAL_MACHINE, wcsRegControlSubKey, &hKey ))
        {
            HKEY hCommonKey;
            DWORD dwDisp;
    
            // create the subkey
            if (ERROR_SUCCESS == RegCreateKeyEx( hKey,
                                                 wcsRegCommonAdmin,
                                                 0,
                                                 0,
                                                 0,
                                                 KEY_ALL_ACCESS,
                                                 0,
                                                 &hCommonKey,
                                                 &dwDisp )
                )
            {
                RegCloseKey(hCommonKey);
            }
            else
            {
                sc = SELFREG_E_CLASS;
            }
    
            RegCloseKey(hKey);
        }
        else
            sc = SELFREG_E_CLASS;
    
        if (FAILED(sc))
            return SELFREG_E_CLASS;
    
        sc = FsciDllRegisterServer();
    
        if (FAILED(sc))
            return sc;
    
        sc = CifrmwrkDllRegisterServer();
    
        if (FAILED(sc))
            return sc;
    
        sc = FNPrxDllRegisterServer();
    }
    CATCH( CException, e )
    {
        sc = e.GetErrorCode();
    }
    END_CATCH

    return sc;
} //DllRegisterServer

//+-------------------------------------------------------------------------
//
//  Function:   DllUnregisterServer
//
//  Synopsis:   Unregisters all that needs to be unregistered for this dll.
//
//  Returns:    Success or failure of registration.
//
//
//  History:    01-May-1997     KrishnaN   Created Header.
//
//--------------------------------------------------------------------------

extern "C" STDAPI DllUnregisterServer(void)
{
    SCODE sc = S_OK;
    SCODE sc2 = S_OK;
    SCODE sc3 = S_OK;
    SCODE sc4 = S_OK;
    SCODE sc5 = S_OK;
    SCODE sc6 = S_OK;
    SCODE sc7 = S_OK;

    CTranslateSystemExceptions xlate;

    TRY
    {
        sc = UnRegisterServer(HKEY_CLASSES_ROOT,
                              sizeof(s_rgDBErrRegInfo)/sizeof(s_rgDBErrRegInfo[0]),
                              s_rgDBErrRegInfo);
    
        sc2 = UnRegisterServer(HKEY_CLASSES_ROOT,
                               sizeof(s_rgCiDSOInfo)/sizeof(s_rgCiDSOInfo[0]),
                               s_rgCiDSOInfo);
    
        sc3 = UnRegisterServer(HKEY_CLASSES_ROOT,
                                     sizeof(s_rgICmdRegInfo)/sizeof(s_rgICmdRegInfo[0]),
                                     s_rgICmdRegInfo);
    
        sc4 = RegisterServer(HKEY_CLASSES_ROOT,
                                      sizeof(s_rgMSIDXSRegInfo)/sizeof(s_rgMSIDXSRegInfo[0]),
                                      s_rgMSIDXSRegInfo);
    
        sc5 = FsciDllUnregisterServer();
    
        sc6 = CifrmwrkDllUnregisterServer();
    
        sc7 = FNPrxDllUnregisterServer();

    }
    CATCH( CException, e )
    {
        sc = e.GetErrorCode();
    }
    END_CATCH

    if ( FAILED(sc) || FAILED(sc2) || FAILED(sc3) || FAILED(sc4) || FAILED(sc5) || FAILED(sc6) || FAILED(sc7) )
        return SELFREG_E_CLASS;

    return S_OK;
} //DllUnregisterServer

//+-------------------------------------------------------------------------
//
//  Function:   RegisterServer
//
//  Synopsis:   Registers all the entries passed.
//
//  Arguments:  [hKey]      -- Registry key for the entries.
//              [cEntries]  -- Number of entries in the array.
//              [rgEntries] -- Array of registry entr/values.
//
//  Returns:    Success or failure of registration.
//
//  History:    01-May-1997     KrishnaN   Created
//
//--------------------------------------------------------------------------

extern HANDLE g_hCurrentDll;
#define MAX_REGISTRY_LEN    300

HRESULT RegisterServer (const HKEY  hKey,
                        const ULONG cEntries,
                        const REGENTRIES rgEntries[])
{
    ULONG           i;
    HKEY            hk;
    DWORD           dwDisposition;
    LONG            stat;

    XArray<WCHAR>   xwszFileName(MAX_PATH+1);
    XArray<WCHAR>   xwszBuff(MAX_REGISTRY_LEN+1);
    int             cch = 0;

    Win4Assert( g_hCurrentDll );
    if ( 0 == GetModuleFileName( (HINSTANCE)g_hCurrentDll, xwszFileName.Get(), xwszFileName.Count()) )
        return E_FAIL;

    //
    // Make a clean start.
    // We ignore errors here.
    //

    UnRegisterServer(hKey, cEntries, rgEntries);

    //
    // Loop through rgEntries, and put everything in it.
    // Every entry is based on HKEY_CLASSES_ROOT.
    //

    for (i=0; i < cEntries; i++)
    {
        //
        // Create the Key.  If it exists, we open it.
        // Thus we can still change the value below.
        //

        stat = RegCreateKeyEx(
                        hKey,
                        rgEntries[i].strRegKey,
                        0,
                        NULL,
                        REG_OPTION_NON_VOLATILE,
                        KEY_ALL_ACCESS,
                        NULL,
                        &hk,
                        &dwDisposition );
        if (stat != ERROR_SUCCESS )
            return E_FAIL;

        // Assign a value, if we have one.
        if (rgEntries[i].strValue)
        {
            cch = swprintf( xwszBuff.Get(), rgEntries[i].strValue, xwszFileName.Get() );

            stat = RegSetValueEx(
                            hk,
                            rgEntries[i].strValueName,
                            0,
                            rgEntries[i].fExpand ? REG_EXPAND_SZ : REG_SZ,
                            (BYTE *) xwszBuff.Get(),
                            sizeof(WCHAR) * (wcslen(xwszBuff.Get()) + 1));
            if (stat != ERROR_SUCCESS )
                return E_FAIL;
        }

        RegCloseKey( hk );
    }

    return S_OK;
}

//+-------------------------------------------------------------------------
//
//  Function:   UnRegisterServer
//
//  Synopsis:   Unregisters all the entries passed.
//
//  Arguments:  [hKey]      -- Registry key for the entries.
//              [cEntries]  -- Number of entries in the array.
//              [rgEntries] -- Array of registry entr/values.
//
//  Returns:    Success or failure of unregistration.
//
//  History:    01-May-1997     KrishnaN   Created
//
//--------------------------------------------------------------------------

HRESULT UnRegisterServer
        (
        const HKEY              hKey,
        const ULONG             cEntries,
        const REGENTRIES        rgEntries[]
        )
{
    ULONG   i;
    int     iNumErrors = 0;
    LONG    stat;

    // Delete all table entries.  Loop in reverse order, since they
    // are entered in a basic-to-complex order.
    //

    for (i = cEntries; i > 0; i--)
    {
        stat = RegDeleteKey( HKEY_CLASSES_ROOT, rgEntries[i-1].strRegKey );
        if (stat != ERROR_SUCCESS && stat != ERROR_FILE_NOT_FOUND)
        {
                iNumErrors++;
        }
    }

    //
    // We fail on error, since that gives proper message to end user.
    // DllRegisterServer should ignore these errors.
    //

    return iNumErrors ? E_FAIL : S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\query\isreg.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1993 - 2000.
//
//  File:       isreg.cxx
//
//  Contents:   'Simple' registry access
//
//  History:    21-Dec-93 KyleP     Created
//
//--------------------------------------------------------------------------

#include "pch.cxx"
#pragma hdrstop

#include <isreg.hxx>

//+-------------------------------------------------------------------------
//
//  Member:     CWin32RegAccess::CWin32RegAccess, public
//
//  Synopsis:   Initialize registry access object
//
//  Arguments:  [ulRelative] -- Position in registry from which [pwcsRegPath]
//                              begins.  See ntrtl.h for constants.
//              [pwcsRegPath] -- Path to node.
//
//  History:    21-Dec-93 KyleP     Created
//
//--------------------------------------------------------------------------

CWin32RegAccess::CWin32RegAccess( HKEY keyRelative, WCHAR const * pwcsRegPath )
        : _hKey( (HKEY)INVALID_HANDLE_VALUE ),
          _wcsPath( 0 ),
          _iSubKey( 0 ),
          _dwLastError( ERROR_SUCCESS )
{
    _dwLastError = RegOpenKey( keyRelative, pwcsRegPath, &_hKey );

    if ( ERROR_SUCCESS != _dwLastError || (HKEY)INVALID_HANDLE_VALUE == _hKey )
    {
        //
        // Try the ACSII version.  It may work on Win95.
        //

        int cc = wcslen( pwcsRegPath ) + 1;

        char * pszPath = new char [cc];

        if ( 0 != pszPath )
        {
            wcstombs( pszPath, pwcsRegPath, cc );

            RegOpenKeyA( keyRelative, pszPath, &_hKey );
        }

        delete [] pszPath;
    }
}

//+-------------------------------------------------------------------------
//
//  Member:     CWin32RegAccess::~CWin32RegAccess, public
//
//  Synopsis:   Destructor
//
//  History:    21-Dec-93 KyleP     Created
//
//--------------------------------------------------------------------------

CWin32RegAccess::~CWin32RegAccess()
{
    RegCloseKey( _hKey );
    delete [] _wcsPath;
}

//+-------------------------------------------------------------------------
//
//  Member:     CWin32RegAccess::Get, public
//
//  Synopsis:   Retrive value of specified key from registry.
//
//  Arguments:  [pwcsKey] -- Key to retrieve value of.
//              [wcsVal]  -- String stored here.
//              [cc]      -- Size (in characters) of [wcsVal]
//
//  History:    21-Dec-93 KyleP     Created
//
//  Notes:      Key must be string for successful retrieval.
//
//--------------------------------------------------------------------------

BOOL CWin32RegAccess::Get( WCHAR const * pwcsKey,
                           WCHAR * wcsVal,
                           unsigned cc,
                           BOOL fExpandEnvironmentStrings )
{
    if ( (HKEY)INVALID_HANDLE_VALUE == _hKey )
    {
        _dwLastError = ERROR_INVALID_HANDLE;
        return FALSE;
    }

    DWORD dwType;
    DWORD cb = cc * sizeof(WCHAR);
    wcsVal[0] = 0;

    _dwLastError = RegQueryValueEx( _hKey,
                                    pwcsKey,
                                    0,
                                    &dwType,
                                    (BYTE *)wcsVal,
                                    &cb );

    if ( ( ERROR_SUCCESS == _dwLastError ) &&
         ( ( wcsVal[0] == 0 ) || ( REG_SZ != dwType && REG_MULTI_SZ != dwType && REG_EXPAND_SZ != dwType ) ) )
        _dwLastError = ERROR_INVALID_PARAMETER;

    if ( fExpandEnvironmentStrings && ERROR_SUCCESS == _dwLastError && REG_EXPAND_SZ == dwType ) 
    {
        WCHAR wszFile[MAX_PATH + 1];
        wcscpy(wszFile, wcsVal);

        if ( 0 == ExpandEnvironmentStrings(wszFile, wcsVal, cc) )
            _dwLastError = GetLastError();
    }

    BOOL fOk = ( ERROR_SUCCESS == _dwLastError );

    #if 0
    //
    // Try the ASCII version.  It may work on Win95.
    //

    if ( !fOk )
    {
        int cc2 = wcslen( pwcsKey ) + 1;

        char * pszKey = new char [cc2];
        char * pszVal = new char [cc];
        cb = cc;

        if ( 0 != pszKey && 0 != pszVal )
        {
            wcstombs( pszKey, pwcsKey, cc );

            _dwLastError = RegQueryValueExA( _hKey, pszKey, 0, &dwType, (BYTE *)pszVal, &cb );

            if ( ( ERROR_SUCCESS == _dwLastError ) &&
                 ( ( wcsVal[0] == 0 ) || ( REG_SZ != dwType && REG_MULTI_SZ != dwType && REG_EXPAND_SZ != dwType ) ) )
                _dwLastError = ERROR_INVALID_PARAMETER;

            fOk = (ERROR_SUCCESS == _dwLastError );

            mbstowcs( wcsVal, pszVal, cb );

            delete [] pszVal;
            delete [] pszKey;
        }
    }
    #endif

    return fOk;
}

//+-------------------------------------------------------------------------
//
//  Member:     CWin32RegAccess::Get, public
//
//  Synopsis:   Retrive value of specified key from registry.
//
//  Arguments:  [pwcsName] -- Name of value to retrieve
//              [dwVal]    -- Returns the value
//
//  Returns:    TRUE if successful, FALSE otherwise.
//
//  History:    8-Jan-97 dlee     Created
//
//  Notes:      Value must be dword for successful retrieval.
//
//--------------------------------------------------------------------------

BOOL CWin32RegAccess::Get( WCHAR const * pwcsName,
                           DWORD &       dwVal )
{
    if ( (HKEY)INVALID_HANDLE_VALUE == _hKey )
    {
        _dwLastError = ERROR_INVALID_HANDLE;
        return FALSE;
    }

    DWORD dwType;
    DWORD cb = sizeof DWORD;

    _dwLastError = RegQueryValueEx( _hKey,
                                    pwcsName,
                                    0,
                                    &dwType,
                                    (BYTE *)&dwVal,
                                    &cb );

    if ( ERROR_SUCCESS == _dwLastError && REG_DWORD != dwType )
        _dwLastError = ERROR_INVALID_PARAMETER;

    return ( ERROR_SUCCESS == _dwLastError );
} //Get

//+-------------------------------------------------------------------------
//
//  Member:     CWin32RegAccess::Set, public
//
//  Synopsis:   Sets the DWORD value of a value name
//
//  Arguments:  [pwcsName] -- Name of value to set
//              [dwVal]   --  Value to set
//
//  Returns:    TRUE if successful, FALSE otherwise.
//
//  History:    8-Jan-97 dlee     Created
//
//--------------------------------------------------------------------------

BOOL CWin32RegAccess::Set( WCHAR const * pwcsKey,
                           DWORD         dwVal )
{
    if ( (HKEY)INVALID_HANDLE_VALUE == _hKey )
    {
        _dwLastError = ERROR_INVALID_HANDLE;
        return FALSE;
    }

    _dwLastError = RegSetValueEx( _hKey,
                                  pwcsKey,
                                  0,
                                  REG_DWORD,
                                  (BYTE *)&dwVal,
                                  sizeof DWORD );

    return ( ERROR_SUCCESS == _dwLastError );
} //Set


//+-------------------------------------------------------------------------
//
//  Member:     CWin32RegAccess::Enum, public
//
//  Synopsis:   enums subkeys
//
//  Arguments:  [pwcsName] -- pointer to buffer of subkey name
//              [cwcName]  -- buffer size in WCHARs
//
//  Returns:    TRUE if successful, FALSE otherwise.
//
//  History:    4/24/98 mohamedn    created
//
//--------------------------------------------------------------------------

BOOL CWin32RegAccess::Enum( WCHAR * pwszName, DWORD cwcName )
{
    if ( (HKEY)INVALID_HANDLE_VALUE == _hKey )
    {
        _dwLastError = ERROR_INVALID_HANDLE;
        return FALSE;
    }

    _dwLastError = RegEnumKey( _hKey,
                               _iSubKey,
                               pwszName,
                               cwcName );

    _iSubKey++;

    return ( ERROR_SUCCESS == _dwLastError );

} // Enum

//+-------------------------------------------------------------------------
//
//  Member:     CWin32RegAccess::Set, public
//
//  Synopsis:   Sets the REG_SZ value of a value name
//
//  Arguments:  [pwcsName] -- Name of value to set
//              [wcsVal]   -- value to set
//
//  Returns:    TRUE if successful, FALSE otherwise.
//
//  History:    8-Jan-97 dlee     Created
//
//--------------------------------------------------------------------------

BOOL CWin32RegAccess::Set( WCHAR const * pwcsName,
                           WCHAR const * wcsVal )
{
    if ( (HKEY)INVALID_HANDLE_VALUE == _hKey )
    {
        _dwLastError = ERROR_INVALID_HANDLE;
        return FALSE;
    }

    DWORD cb = sizeof WCHAR * ( 1 + wcslen( wcsVal ) );

    _dwLastError = RegSetValueEx( _hKey,
                                  pwcsName,
                                  0,
                                  REG_SZ,
                                  (BYTE *)wcsVal,
                                  cb );

    return (ERROR_SUCCESS == _dwLastError);
} //Set

//+-------------------------------------------------------------------------
//
//  Member:     CWin32RegAccess::SetMultiSZ, public
//
//  Synopsis:   Sets the REG_MULTI_SZ value of a value name
//
//  Arguments:  [pwcsName] -- Name of value to set
//              [wcsVal]   -- value to set
//              [cb]       -- count of bytes in the value
//
//  Returns:    TRUE if successful, FALSE otherwise.
//
//  History:    8-Jan-97 dlee     Created
//
//--------------------------------------------------------------------------

BOOL CWin32RegAccess::SetMultiSZ( WCHAR const * pwcsName,
                                  WCHAR const * wcsVal,
                                  DWORD         cb )
{
    if ( (HKEY)INVALID_HANDLE_VALUE == _hKey )
    {
        _dwLastError = ERROR_INVALID_HANDLE;
        return FALSE;
    }

    _dwLastError = RegSetValueEx( _hKey,
                                  pwcsName,
                                  0,
                                  REG_MULTI_SZ,
                                  (BYTE *)wcsVal,
                                  cb );

    return (ERROR_SUCCESS == _dwLastError);
} //SetMultiSZ

//+-------------------------------------------------------------------------
//
//  Member:     CWin32RegAccess::Remove, public
//
//  Synopsis:   Removes a value name and its value
//
//  Arguments:  [pwcsName] -- Name of value to set
//
//  Returns:    TRUE if successful, FALSE otherwise.
//
//  History:    8-Jan-97 dlee     Created
//
//--------------------------------------------------------------------------

BOOL CWin32RegAccess::Remove( WCHAR const * pwcsName )
{
    if ( (HKEY)INVALID_HANDLE_VALUE == _hKey )
    {
        _dwLastError = ERROR_INVALID_HANDLE;
        return FALSE;
    }
    else
        _dwLastError = ERROR_SUCCESS;  // Maintain existing behavior (ignore RegDelete result)

    RegDeleteValue( _hKey, pwcsName );

    return TRUE;
} //Remove

//+-------------------------------------------------------------------------
//
//  Member:     CWin32RegAccess::CreateKey, public
//
//  Synopsis:   Adds a key to the registry
//
//  Arguments:  [pwcsKey]  -- Key name
//              [fExisted] -- Returns TRUE the key already existed
//
//  Returns:    TRUE if successful, FALSE otherwise.
//
//  History:    8-Jan-97 dlee     Created
//
//--------------------------------------------------------------------------

BOOL CWin32RegAccess::CreateKey( WCHAR const * pwcsKey,
                                 BOOL &        fExisted )
{
    if ( (HKEY)INVALID_HANDLE_VALUE == _hKey )
    {
        _dwLastError = ERROR_INVALID_HANDLE;
        return FALSE;
    }

    DWORD dwDisp;
    HKEY hKey;

    _dwLastError = RegCreateKeyEx( _hKey,
                                   pwcsKey,
                                   0,
                                   0,
                                   0,
                                   KEY_ALL_ACCESS,
                                   0,
                                   &hKey,
                                   &dwDisp );

    if ( ERROR_SUCCESS != _dwLastError )
    {
        SetLastError( _dwLastError );

        return FALSE;
    }

    RegCloseKey( hKey );
    fExisted = ( dwDisp == REG_OPENED_EXISTING_KEY );

    return TRUE;
} //CreateKey

//+-------------------------------------------------------------------------
//
//  Member:     CWin32RegAccess::RemoveKey, public
//
//  Synopsis:   Removes a key from the registry
//
//  Arguments:  [pwcsKey]  -- Key name
//
//  Returns:    TRUE if successful, FALSE otherwise.
//
//  History:    7-Apr-99 dlee     Created
//
//--------------------------------------------------------------------------

BOOL CWin32RegAccess::RemoveKey( WCHAR const * pwcsKey )
{
    if ( (HKEY)INVALID_HANDLE_VALUE == _hKey )
    {
        _dwLastError = ERROR_INVALID_HANDLE;
        return FALSE;
    }

    _dwLastError = RegDeleteKey( _hKey, pwcsKey );

    if ( ERROR_SUCCESS != _dwLastError )
    {
        SetLastError( _dwLastError );
        return FALSE;
    }

    return TRUE;
} //RemoveKey
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\query\mmstrm.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 2000.
//
//  File:       mmstrm.cxx
//
//  Contents:   Memory Mapped Stream using win32 API
//
//  Classes:    CMmStream, CMmStreamBuf
//
//  History:    10-Mar-93 BartoszM  Created
//
//----------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include <mmstrm.hxx>

//+-------------------------------------------------------------------------
//
//  Member:     CMmStream::CMmStream
//
//  Synopsis:   constructor
//
//  History:    18-Mar-98   kitmanh     Passed fIsReadOnly into CMmStream
//                                      constructor and init _fIsReadOnly 
//                                      with its value
//              18-Nov-98   KLam        Added cMegToLeaveOnDisk
//
//--------------------------------------------------------------------------
CMmStream::CMmStream( ULONG cMegToLeaveOnDisk, BOOL fIsReadOnly )
        : _hFile(INVALID_HANDLE_VALUE),
          _hMap(0),
          _fSparse(FALSE),
          _fWrite(FALSE),
          _cMap(0),
          _fIsReadOnly( fIsReadOnly ),
          _cMegToLeaveOnDisk( cMegToLeaveOnDisk )
{
#if CIDBG == 1
    _xwcPath[0] = 0;
#endif
}


//+-------------------------------------------------------------------------
//
//  Member:     CMmStream::~CMmStream
//
//  Synopsis:   destructor
//
//  History:    Jun-23-1995 SrikantS    Added a wait for the lock event
//                                      to complete before closing it.
//
//--------------------------------------------------------------------------
CMmStream::~CMmStream()
{
    if (Ok())
    {
        if ( 0 != _hMap )
        {
            CloseHandle( _hMap );
            _hMap = 0;
        }

        CloseHandle ( _hFile );
        _hFile = INVALID_HANDLE_VALUE;
    }

    if ( 0 != _cMap )
    {
        ciDebugOut(( DEB_WARN, "closing a stream with %d open views\n", _cMap ));
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CMmStream::OpenExlusive
//
//  Synopsis:   Opens the stream for exclusive read/write access.
//              Throws if it fails.
//
//  Arguments:  [wcsPath] - Path of the memory mapped file
//
//  History:    5-14-96   srikants   Created
//              2-13-98   kitmanh    Added code for dealing with read-only
//                                   read-only catalogs
//              3-13-98   kitmanh    Always SHARE_READ if catalog is read-only
//              3-18-98   kitmanh    fReadOnly is not passed by ref anymore
//              26-Oct-98 KLam       Make sure there is enough disk space
//
//  Notes:  
//
//----------------------------------------------------------------------------

void CMmStream::OpenExclusive( WCHAR * wcsPath, BOOL fReadOnly )
{
    Win4Assert( _fIsReadOnly == fReadOnly );
    
    _fWrite = FALSE;

    DWORD accessMode = FILE_GENERIC_READ;
    
    if (!_fIsReadOnly) 
        accessMode |= FILE_GENERIC_WRITE;

#if CIDBG == 1
    _xwcPath.SetSize( 1 + wcslen( wcsPath ) );
    wcscpy( _xwcPath.Get(), wcsPath );
#endif

    if ( _xDriveInfo.IsNull() || !_xDriveInfo->IsSameDrive ( wcsPath ) )
    {
        _xDriveInfo.Free();
        if ( CDriveInfo::ContainsDrive ( wcsPath ) )
            _xDriveInfo.Set( new CDriveInfo ( wcsPath, _cMegToLeaveOnDisk ) );
    }

    _status = STATUS_SUCCESS;

    DWORD sharing = FILE_SHARE_READ | FILE_SHARE_WRITE;

    _hFile = CreateFile( wcsPath,
                         accessMode,
                         sharing, // sharing
                         0, // security
                         OPEN_ALWAYS,
                         FILE_ATTRIBUTE_NORMAL,
                         0 ); // template

    if (Ok())
    {
        if (!fReadOnly)
            _fWrite = TRUE;
    }
    else
       THROW( CException() );

    _sizeLow = GetFileSize( _hFile, &_sizeHigh );

    if (_sizeLow == 0xffffffff && GetLastError() != NO_ERROR)
        Close();

    DWORD protection = fReadOnly ? PAGE_READONLY : PAGE_READWRITE;

    if ( _sizeLow != 0 || _sizeHigh != 0 )
    {
        _hMap = CreateFileMapping( _hFile,
                                   0, // security
                                   protection,
                                   _sizeHigh,
                                   _sizeLow,
                                   0 ); // name

        if ( 0 == _hMap )
        {
            Close();
            THROW( CException() );
        }
    }
} //OpenExclusive

//+---------------------------------------------------------------------------
//
//  Function:   IsCreateExisting
//
//  Synopsis:   Tests if the error was a result of trying to create a
//              file that already exists.
//
//  Arguments:  [Error]      --  Error returned by the system.
//              [modeAccess] --  access mode specified to CreateFile.
//              [modeCreate] --  create mode specified to CreateFile.
//
//  Returns:    TRUE if the failure is because of trying to create a "New"
//              file with the same name as the one already existing.
//              FALSE otherwise.
//
//  History:    3-22-94   srikants   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

BOOL IsCreateExisting( ULONG Error, ULONG modeAccess, ULONG modeCreate )
{
    return ( (Error == ERROR_ALREADY_EXISTS || Error == ERROR_FILE_EXISTS) &&
             (modeAccess & GENERIC_WRITE) &&
             (modeCreate & CREATE_NEW) );
}

//+-------------------------------------------------------------------------
//
//  Member:     CMmStream::Open, public
//
//  Synopsis:   Open stream
//
//  Arguments:  [wcsPath]    -- file path
//              [modeAccess] -- access mode
//              [modeShare]  -- sharing mode
//              [modeCreate] -- create mode
//              [fSparse]    -- if TRUE, make the stream sparse
//
//  History:    13-Apr-93 BartoszM  Created
//
//--------------------------------------------------------------------------

void CMmStream::Open(
    const WCHAR* wcsPath,
    ULONG modeAccess,
    ULONG modeShare,
    ULONG modeCreate,
    ULONG modeAttribute,
    BOOL  fSparse )
{
#if CIDBG == 1
    _xwcPath.SetSize( 1 + wcslen( wcsPath ) );
    wcscpy( _xwcPath.Get(), wcsPath );
#endif

    if ( _xDriveInfo.IsNull() || !_xDriveInfo->IsSameDrive ( wcsPath ) )
    {
        _xDriveInfo.Free();
        if ( CDriveInfo::ContainsDrive ( wcsPath ) )
            _xDriveInfo.Set( new CDriveInfo ( wcsPath, _cMegToLeaveOnDisk ) );
    }

    _fSparse = fSparse;

    _status = STATUS_SUCCESS;
    _fWrite = FALSE;

    //
    // Open files
    //

    UNICODE_STRING uScope;

    if ( !RtlDosPathNameToNtPathName_U( wcsPath,
                                       &uScope,
                                        0,
                                        0 ) )
    {
        ciDebugOut(( DEB_ERROR, "Error converting %ws to Nt path\n", wcsPath ));
        THROW( CException(STATUS_INSUFFICIENT_RESOURCES) );
    }

    IO_STATUS_BLOCK IoStatus;
    OBJECT_ATTRIBUTES ObjectAttr;

    InitializeObjectAttributes( &ObjectAttr,          // Structure
                                &uScope,              // Name
                                OBJ_CASE_INSENSITIVE, // Attributes
                                0,                    // Root
                                0 );                  // Security

    switch ( modeCreate )
    {
    case CREATE_NEW        :
    case CREATE_ALWAYS     :
        modeCreate = FILE_OVERWRITE_IF;
        break;
    case OPEN_EXISTING     :
    case TRUNCATE_EXISTING :
        modeCreate = FILE_OPEN;
        break;
    case OPEN_ALWAYS       :
        modeCreate = FILE_OPEN_IF;
        break;
    }

    ULONG modeTranslatedAccess = 0;

    if ( modeAccess & GENERIC_READ )
        modeTranslatedAccess |= ( FILE_READ_DATA | FILE_READ_ATTRIBUTES );

    if ( modeAccess & GENERIC_WRITE ) 
    { 
        Win4Assert( !_fIsReadOnly );
        modeTranslatedAccess |= ( FILE_READ_DATA | FILE_READ_ATTRIBUTES |
                                  FILE_WRITE_DATA | FILE_WRITE_ATTRIBUTES );
    }

    NTSTATUS Status = NtCreateFile( &_hFile,            // Handle
                         modeTranslatedAccess,          // Access
                         &ObjectAttr,                   // Object Attributes
                         &IoStatus,                     // I/O Status block
                         0,                             // Allocation Size
                         modeAttribute,                 // File Attributes
                         modeShare,                     // File Sharing
                         modeCreate,                    // Create Disposition
                         FILE_SEQUENTIAL_ONLY,          // Create Options
                         0,                             // EA Buffer
                         0 );                           // EA Buffer Length

    RtlFreeHeap( RtlProcessHeap(), 0, uScope.Buffer );

    if ( FAILED(Status) )
    {
        ciDebugOut(( DEB_IERROR, "NtCreateFile(%ws) returned 0x%x\n", wcsPath, Status ));
        _hFile = INVALID_HANDLE_VALUE;
        _status = Status;
        SetLastError ( Status );
    }

    if ( Ok() )
    {
        //
        // Mark the stream as sparse if it was opened for write and it
        // should be marked as sparse.  Don't just make the stream sparse
        // on file create, since we want to be able to copy catalogs from
        // non-ntfs5 volumes to ntfs5 volumes and have things work.
        //

        if ( ( GENERIC_WRITE & modeAccess ) && fSparse )
        {
            CEventSem evt;
            evt.Reset();

            Status = NtFsControlFile( _hFile,
                                      evt.GetHandle(),
                                      0, 0,
                                      &IoStatus,
                                      FSCTL_SET_SPARSE,
                                      0, 0, 0, 0 );

            if ( NT_ERROR( Status ) )
            {
                ciDebugOut(( DEB_WARN,
                             "ntstatus 0x%x, can't make '%ws' sparse\n",
                             Status, wcsPath ));

                Close();
                THROW( CException( Status ) );
            }

            if ( STATUS_PENDING == Status )
            {
                // wait for the io to complete

                ciDebugOut(( DEB_ITRACE, "make file sparse pending\n" ));
                evt.Wait();
                Status = STATUS_SUCCESS;
            }
        }

        _sizeLow = GetFileSize ( _hFile, &_sizeHigh );

        LARGE_INTEGER sizeOriginal = { _sizeLow, _sizeHigh };

        if (_sizeLow == 0xffffffff && GetLastError() != NO_ERROR)
        {
            Close();
            ciDebugOut (( DEB_ERROR, "Open stream %ws failed\n", wcsPath ));
            THROW( CException() );
        }

        if ( modeAccess & GENERIC_WRITE )
        {
            _fWrite = TRUE;
            CommonPageRound(_sizeLow, _sizeHigh);

            if (_sizeLow == 0 && _sizeHigh == 0)
            {
                if ( SetFilePointer ( _hFile,
                                      COMMON_PAGE_SIZE,
                                      0,
                                      FILE_BEGIN ) == 0xFFFFFFFF  &&
                     GetLastError() != NO_ERROR )
                {
                    Close();
                    ciDebugOut(( DEB_ERROR,
                                 "CMmStream::Open -- SetFilePointer returned %d\n",
                                 GetLastError() ));
                    THROW( CException() );
                }

                if ( !SetEndOfFile( _hFile ) )
                {
                    Close();
                    ciDebugOut(( DEB_ERROR,
                                 "CMmStream::Open -- SetEndOfFile returned %d\n",
                                 GetLastError() ));
                    THROW( CException() );
                }
                _sizeLow = COMMON_PAGE_SIZE;
            }
        }

        if ( _sizeLow != 0 || _sizeHigh != 0 )
        {
            //
            // Make sure there is enough disk space if growing the file
            //
            LARGE_INTEGER sizeNew = { _sizeLow, _sizeHigh };
            if ( sizeNew.QuadPart > sizeOriginal.QuadPart )
            {
                Win4Assert ( !_xDriveInfo.IsNull() );
                __int64 sizeRemaining, sizeTotal;
                _xDriveInfo->GetDiskSpace ( sizeTotal, sizeRemaining );

                if ( sizeRemaining < ( sizeNew.QuadPart - sizeOriginal.QuadPart ))
                {
                    Close();

                    ciDebugOut(( DEB_ERROR,
                                 "CMmStream::Open -- Not enogh disk space, need %I64d have %I64d\n",
                                 sizeNew.QuadPart - sizeOriginal.QuadPart, sizeRemaining ));
            
                    THROW( CException( CI_E_CONFIG_DISK_FULL ) );
                }
            }

            _hMap = CreateFileMapping ( _hFile,
                                0, // security
                                _fWrite?PAGE_READWRITE: PAGE_READONLY,
                                _sizeHigh,
                                _sizeLow,
                                0 ); // name
            if (_hMap == NULL)
            {
                Close();
                ciDebugOut (( DEB_ERROR, "File mapping failed\n" ));
                THROW( CException() );
            }

            #if CIDBG == 1
            
            if ( FILE_OVERWRITE_IF == modeCreate )
            {
                // Zero out the entire file upon creation. We need to map/write/flush/unmap to
                // accomplish this. Currently all allocations are < _sizeLow, so _sizeHigh should
                // be zero.

                Win4Assert(0 == _sizeHigh);
                
                CMmStreamBuf sbuf;
            
                Map(sbuf, min(COMMON_PAGE_SIZE, _sizeLow), 0, 0, _fWrite);
                WCHAR *wszGarbage = L"Intentionally written garbage. No part of Indexing Service should choke on this! Contact NTQUERY.";
                Win4Assert(wcslen(wszGarbage) <= min(COMMON_PAGE_SIZE, _sizeLow));
                wcscpy((WCHAR *)sbuf.Get(), wszGarbage);
                Flush(sbuf, min(COMMON_PAGE_SIZE, _sizeLow) );
                Unmap(sbuf);
            }
            #endif
        }
    }
    else
    {
        ciDebugOut (( DEB_ITRACE, "Open failed on MM Stream; GetLastError()=0x%x\n",
                      GetLastError() ));
    }
} //Open

//+-------------------------------------------------------------------------
//
//  Member:     CMmStream::Close, public
//
//  Synopsis:   Create all handles
//
//  History:    10-Mar-93 BartoszM  Created
//
//--------------------------------------------------------------------------

void CMmStream::Close()
{
#if CIDBG == 1
    if ( _cMap > 0 )
    {
        ciDebugOut(( DEB_ERROR, "Closing stream with %u open maps\n", _cMap ));
    }

    Win4Assert( _cMap == 0 );
#endif // CIDBG == 1

    if (Ok())
    {
        if(_hMap )
        {
            if ( !CloseHandle(_hMap))
            {
                ciDebugOut (( DEB_ERROR, "Closing file mapping failed\n" ));
                THROW( CException() );
            }
            _hMap = 0;
        }
        if ( !CloseHandle ( _hFile ))
        {

            ciDebugOut (( DEB_ERROR, "Closing file handle failed\n" ));
            THROW( CException() );
        }
        _hFile = INVALID_HANDLE_VALUE;
    }
} //Close

//+-------------------------------------------------------------------------
//
//  Member:     CMmStream::SetSize, public
//
//  Synopsis:   Increase the size of the (writable) file
//
//  Arguments:  [storage] -- storage (not used)
//              [newSizeLow]  -- Low 32 bits of filesize
//              [newSizeHigh] -- High 32 bits of filesize
//
//  History:    10-Mar-93 BartoszM  Created
//              26-Oct-98 KLam      Make sure there is enough disk space
//              03-Dec-98 KLam      Don't close the stream if there isn't
//                                  enough disk space
//
//--------------------------------------------------------------------------

#if CIDBG == 1
BOOL g_fFailMMFExtend = FALSE;
#endif // CIDBG == 1

void CMmStream::SetSize(
    PStorage & storage,
    ULONG      newSizeLow,
    ULONG      newSizeHigh )
{
    Win4Assert( !_fIsReadOnly );
    Win4Assert( TRUE == _fWrite );

    LARGE_INTEGER sizeOld = { _sizeLow, _sizeHigh };
    LARGE_INTEGER sizeNew = { newSizeLow, newSizeHigh };

    if ( sizeNew.QuadPart < sizeOld.QuadPart && 0 != _cMap )
    {
        //
        // Fail silently to truncate the file if there are open views.  This
        // will happen at the end of a master merge on the new index if the
        // index is being used by a query cursor.  So we waste a little
        // disk space.  Leave the map open.
        //

        return;
    }
 
    //
    // Make sure there is enough space on the disk if growing the file
    //
    if ( sizeNew.QuadPart > sizeOld.QuadPart )
    {
        Win4Assert ( !_xDriveInfo.IsNull() );
        __int64 sizeRemaining, sizeTotal;
        _xDriveInfo->GetDiskSpace ( sizeTotal, sizeRemaining );

        if ( sizeRemaining < ( sizeNew.QuadPart - sizeOld.QuadPart ))
        {
            ciDebugOut(( DEB_ERROR,
                         "CMmStream::SetSize -- Not enogh disk space, need %I64d have %I64d\n",
                         sizeNew.QuadPart - sizeOld.QuadPart, sizeRemaining ));
            
            THROW( CException( CI_E_CONFIG_DISK_FULL ) );
        }
    }
    //
    // Free the mapping before trying to shrink the file.
    //

    if ( 0 != _hMap )
    {
        HANDLE hMap = _hMap;
        _hMap = 0;
        CloseHandle( hMap );
    }

    DWORD dwErr = NO_ERROR;

    if (sizeNew.QuadPart < sizeOld.QuadPart)
    {
        if ( SetFilePointer ( _hFile,
                              newSizeLow,
                              (long *)&newSizeHigh, 
                              FILE_BEGIN ) == 0xFFFFFFFF  &&
             GetLastError() != NO_ERROR )
        {
            dwErr = GetLastError();
            ciDebugOut(( DEB_ERROR,
                         "CMmStream::SetSize -- SetFilePointer returned %d\n",
                         dwErr ));
        }

        if ( NO_ERROR == dwErr && !SetEndOfFile( _hFile ) )
        {
            dwErr = GetLastError();
            ciDebugOut(( DEB_ERROR,
                         "CMmStream::SetSize -- SetEndOfFile returned %d\n",
                         dwErr ));
        }
    }
    //
    // Restore the mapping or grow the file
    //
    
    _hMap = CreateFileMapping( _hFile,
                               0, // security
                               PAGE_READWRITE,
                               newSizeHigh,
                               newSizeLow,
                               0 ); // name
    
    #if CIDBG == 1
        if ( g_fFailMMFExtend && 0 != _hMap )
        {
            CloseHandle( _hMap );
            _hMap = 0;
            SetLastError( ERROR_HANDLE_DISK_FULL );
            g_fFailMMFExtend = FALSE;
        }
    #endif // CIDBG == 1
    
    if ( 0 == _hMap )
    {
        dwErr = GetLastError();
    
        //
        // ok, so we can't grow the file and we're going to throw.  At
        // least try to restore the mapping.  Ignore if this fails.
        //
    
        _hMap = CreateFileMapping( _hFile,
                                   0, // security
                                   PAGE_READWRITE,
                                   _sizeHigh,
                                   _sizeLow,
                                   0 ); // name
    }
    
    if ( NO_ERROR != dwErr )
        THROW( CException( HRESULT_FROM_WIN32( dwErr ) ) );

    if ( sizeOld.QuadPart != sizeNew.QuadPart )
        FlushMetaData( TRUE );

    _sizeLow = newSizeLow;
    _sizeHigh = newSizeHigh;
} //SetSize

//+-------------------------------------------------------------------------
//
//  Member:     CMmStream::MapAll, public
//
//  Synopsis:   Create file mapping
//
//  Arguments:
//
//  History:
//
//--------------------------------------------------------------------------
void CMmStream::MapAll ( CMmStreamBuf& sbuf )
{
    Win4Assert ( SizeHigh() == 0 );
    Map( sbuf, SizeLow(), 0, 0 );
}

//+-------------------------------------------------------------------------
//
//  Member:     CMmStream::Map, private
//
//  Synopsis:   Create file mapping
//
//  Arguments:  [sbuf]    -- the stream buffer used to record the view
//              [cb]      -- size of the mapped area
//              [offLow]  -- low part of file offset
//              [offHigh] -- high part of file offset
//              [fMapForWrite] --
//
//  History:    10-Mar-93 BartoszM  Created
//
//--------------------------------------------------------------------------

void CMmStream::Map( CMmStreamBuf & sbuf,
                     ULONG          cb,
                     ULONG          offLow,
                     ULONG          offHigh,
                     BOOL           fMapForWrite )
{
    //
    // In success paths, the file would be mapped right now.  But if there
    // was a failure earlier, attempt to restore the file mapping now.
    //
    if ( 0 == _hMap )
    {
        Win4Assert( INVALID_HANDLE_VALUE != _hFile );

        // Extend the file if necessary and remap it

        if ( fMapForWrite )
        {
            LARGE_INTEGER li;
            li.LowPart = offLow;
            li.HighPart = offHigh;
            li.QuadPart += cb;
            SetSize( *(PStorage *) 0, li.LowPart, li.HighPart );
        }
        else
        {
            // Try to re-create the mapping

            _hMap = CreateFileMapping( _hFile,
                                       0, // security
                                       _fWrite ? PAGE_READWRITE : PAGE_READONLY,
                                       _sizeHigh,
                                       _sizeLow,
                                       0 ); // name

            if ( 0 == _hMap )
                THROW( CException() );
        }
    }

    Win4Assert( 0 != _hMap );

    //
    // The file can be writable, but if the map is for READ, don't try
    // mapping beyond the end of the file.
    //

    if ( !fMapForWrite )
    {
        //
        // Adjust size to be min( cb, sizeoffile - off )
        //

        LARGE_INTEGER size = { _sizeLow, _sizeHigh };
        LARGE_INTEGER off  = { offLow, offHigh };
        LARGE_INTEGER licb = { cb, 0 };
        LARGE_INTEGER diff;

        diff.QuadPart = size.QuadPart - off.QuadPart;

        if ( diff.QuadPart < licb.QuadPart )
        {
            cb = diff.LowPart;
            ciDebugOut(( DEB_ITRACE,
                         "CMmStream::Map -- reducing map to 0x%x bytes\n",
                         cb ));
        }
    }

    Win4Assert( 0 != _hMap );

    if ( 0 == offHigh && 0 == _sizeHigh )
    {
        Win4Assert( offLow < _sizeLow );
        Win4Assert( offLow + cb <= _sizeLow );
    }

    void* buf = MapViewOfFile( _hMap,
                               _fWrite ? FILE_MAP_WRITE : FILE_MAP_READ,
                               offHigh,
                               offLow,
                               cb );

    if ( 0 == buf )
    {
        ciDebugOut(( DEB_ERROR,
                     "CMmStream::Map -- MapViewOfFile returned %d\n",
                     GetLastError() ));
        THROW( CException() );
    }

    sbuf.SetBuf( buf );
    sbuf.SetSize ( cb );
    sbuf.SetStream ( this );

    _cMap++;
} //Map

//+-------------------------------------------------------------------------
//
//  Member:     CMmStream::Unmap, public
//
//  Synopsis:   Unmap the view of file
//
//  History:    10-Mar-93 BartoszM  Created
//
//--------------------------------------------------------------------------
void CMmStream::Unmap( CMmStreamBuf& sbuf )
{
    //
    // Note that UnmapViewOfFile doesn't take a _hMap, and the _hMap used
    // to map the view may already have been closed (but is kept open by
    // the refcount due to the view).  The current _hMap may be different
    // than the one used to create the view.
    //

    if ( _cMap > 0 )
    {
    
        if ( !UnmapViewOfFile( sbuf.Get() ) )
        {
            ciDebugOut(( DEB_ERROR, "UnmapViewOfFile returned %d\n",
                         GetLastError() ));

            //
            // don't throw! -- unmap is called from destructors and can fail
            // if the system is really busy
            //
        }

        _cMap--;
    }

    sbuf.SetBuf( 0 );
} //Unmap

//+-------------------------------------------------------------------------
//
//  Member:     CMmStream::Flush, public
//
//  Synopsis:   Flush the view back to disk
//
//  History:    10-Mar-93 BartoszM  Created
//              04-Mar-98 KitmanH   Only flush if CMmStream is writable
//
//--------------------------------------------------------------------------

void CMmStream::Flush( CMmStreamBuf& sbuf, ULONG cb, BOOL fThrowOnFailure )
{
    if ( _fWrite )
    {
        BOOL fOk = FlushViewOfFile( sbuf.Get(), cb );

        if ( !fOk )
        {
            ciDebugOut(( DEB_WARN,
                         "FlushViewOfFile failed, error %d, throwing: %d\n",
                         GetLastError(), fThrowOnFailure ));

            if ( fThrowOnFailure )
            {
                //Win4Assert( !"FlushViewOfFile failed!" );
                THROW( CException() );
            }
        }

        Win4Assert( INVALID_HANDLE_VALUE != _hFile );
    }
} //Flush

//+-------------------------------------------------------------------------
//
//  Member:     CMmStream::FlushMetaData, public
//
//  Synopsis:   Flush any and all metadata for a file to disk
//
//  History:    5-Mar-01 dlee  Created
//
//--------------------------------------------------------------------------

void CMmStream::FlushMetaData( BOOL fThrowOnFailure )
{
    if ( _fWrite )
    {
        //
        // FlushViewOfFile writes the contents of the file to disk.
        // FlushFileBuffers writes the metadata to disk.
        //

        if ( INVALID_HANDLE_VALUE != _hFile )
        {
            BOOL fOk = FlushFileBuffers( _hFile );

            if ( !fOk && fThrowOnFailure )
            {
                THROW( CException() );
            }
        }
    }
} //FlushMetaData

//+-------------------------------------------------------------------------
//
//  Member:     CMmStream::ShrinkFromFront, public
//
//  Synopsis:   Decommits the front part of a file
//
//  Arguments:  [iFirstPage] -- the first 4k page to decommit
//              [cPages]     -- # of 4k pages to decommit
//
//  Returns:    # of 4k pages actually shrunk
//
//  History:    4-Nov-97 dlee  Created
//
//--------------------------------------------------------------------------

ULONG CMmStream::ShrinkFromFront( ULONG iFirstPage, ULONG cPages )
{
    ciDebugOut(( DEB_ITRACE, "SFF attempt start 4k page 0x%x, 0x%x pages\n",
                 iFirstPage, cPages ));
    Win4Assert( INVALID_HANDLE_VALUE != _hFile );

    Win4Assert( !_fIsReadOnly );
    Win4Assert( _fWrite );

    if ( !_fSparse )
        return 0;

    if ( 0 == cPages )
        return 0;

    //
    // When NTFS/MM check in support for zeroing part of a file
    // while another part of the file has a mapped view open, change this
    // code to not check _cMap and to not close/repoen _hMap.

    //
    // If there are open views on the mapping, we can't shrink since NTFS
    // doesn't support this.  Views will be open if there are active queries
    // using the current master index.
    //

    if ( 0 != _cMap )
    {
        ciDebugOut(( DEB_ITRACE, "can't SFF, %d mappings are open\n", _cMap ));
        return 0;
    }

    //
    // Close the mapping; NTFS doesn't allow shrinking with an open map
    //

    if ( 0 != _hMap )
    {
        CloseHandle( _hMap );
        _hMap = 0;
    }

    //
    // Send the fsctl to do the truncation on 64k boundaries.
    //

    cPages = ( cPages * 16 ) / 16;

    if ( 0 == cPages )
        return 0;

    FILE_ZERO_DATA_INFORMATION zeroInfo;
    zeroInfo.FileOffset.QuadPart = ( (LONGLONG) iFirstPage ) * 4096;
    zeroInfo.BeyondFinalZero.QuadPart = ( (LONGLONG) iFirstPage + cPages ) * 4096;

    IO_STATUS_BLOCK ioStatusBlock;
    CEventSem evt;
    evt.Reset();

    NTSTATUS s = NtFsControlFile( _hFile,
                                  evt.GetHandle(),
                                  0, 0,
                                  &ioStatusBlock,
                                  FSCTL_SET_ZERO_DATA,
                                  &zeroInfo,
                                  sizeof zeroInfo,
                                  0, 0 );

    //
    // NOTE: If this fails, do we really care?  Sure, we'll be wasting disk
    // space, but why abort the master merge because of this?  Let's wait
    // and see when/if it can fail.
    //

    if ( NT_ERROR( s ) )
    {
        ciDebugOut(( DEB_WARN, "set zero data failed 0x%x\n", s ));
        THROW( CException( s ) );
    }

    if ( STATUS_PENDING == s )
    {
        // wait for the io to complete

        ciDebugOut(( DEB_ITRACE, "SFF pending\n" ));
        evt.Wait();
        s = STATUS_SUCCESS;
    }

    ciDebugOut(( DEB_ITRACE, "SFF succeeded\n" ));

    //
    // Re-open the mapping
    //

    _hMap = CreateFileMapping( _hFile,
                               0, // security
                               PAGE_READWRITE,
                               _sizeHigh,
                               _sizeLow,
                               0 );
    if ( 0 == _hMap )
    {
        DWORD dw= GetLastError();
        ciDebugOut(( DEB_WARN, "can't re-establish the map in SFF %d\n", dw ));
        Close();
        THROW( CException( HRESULT_FROM_WIN32( dw ) ) );
    }

    return cPages;
} //ShrinkFromFront

//+-------------------------------------------------------------------------
//
//  Member:     CMmStream::Read, public
//
//  Synopsis:   Reads from the stream
//
//  Arguments:  [pvBuffer]  -- Where the read data will go.  This buffer
//                             must be 0-filled for the full cbToRead.
//              [oStart]    -- Offset in the file where the read starts
//              [cbToRead]  -- # of bytes to read
//              [cbRead]    -- Returns the # of bytes actually read
//
//  History:    30-Oct-98 dlee  Created
//
//  Notes:      Win32 does not guarantee coherence if you mix read/write and
//              mapped IO in the same part of the file.
//
//--------------------------------------------------------------------------

void CMmStream::Read(
    void *    pvBuffer,
    ULONGLONG oStart,
    DWORD     cbToRead,
    DWORD &   cbRead )
{
    ciDebugOut(( DEB_ITRACE,
                 "ReadFile %#x, into %#p, offset %#I64x cb, %d\n",
                 _hFile, pvBuffer, oStart, cbToRead ));

    //
    // This function takes a zero-filled buffer.  If the buffer isn't zero-
    // filled, the caller has a bug.  Assume 8-byte alignment.
    //

    #if CIDBG == 1

        Win4Assert( 0 == ( ( (ULONG_PTR) pvBuffer ) & 7 ) );
        Win4Assert( 0 == ( cbToRead & 7 ) );

        LONGLONG *pll = (LONGLONG *) pvBuffer;
        unsigned cll = cbToRead / sizeof LONGLONG;

        for ( unsigned i = 0; i < cll; i++, pll++ )
            Win4Assert( 0 == *pll );
    
    #endif // CIDBG == 1

    _sizeLow = GetFileSize( _hFile, &_sizeHigh );

    if ( 0xffffffff == _sizeLow &&
         NO_ERROR != GetLastError() )
        THROW( CException() );

    //
    // Always read the amount requested, even if it doesn't exist on disk
    //

    cbRead = cbToRead;

    LARGE_INTEGER liSize;
    liSize.LowPart = _sizeLow;
    liSize.HighPart = _sizeHigh;

    //
    // Master merge asks for buffers after the end of the file.  The file
    // will be extended at when the buffer is written.
    //

    if ( liSize.QuadPart <= (LONGLONG) oStart )
        return;

    //
    // Truncate the read if the file isn't as large as requested
    //

    if ( liSize.QuadPart < (LONGLONG) ( oStart + cbToRead ) )
        cbToRead = (DWORD) ( liSize.QuadPart - oStart );

    //
    // The file is opened async, so the IO can be pending
    //

    LARGE_INTEGER li;
    li.QuadPart = oStart;

    CEventSem evt;

    OVERLAPPED o;
    o.Offset = li.LowPart;
    o.OffsetHigh = li.HighPart;
    o.hEvent = evt.GetHandle();

    DWORD cbFromFile;

    if ( !ReadFile( _hFile,
                    pvBuffer,
                    cbToRead,
                    &cbFromFile,
                    &o ) )
    {
        if ( ERROR_IO_PENDING == GetLastError() )
        {
            if ( ! GetOverlappedResult( _hFile, &o, &cbFromFile, TRUE ) )
                THROW( CException() );
        }
        else
            THROW( CException() );
    }

    Win4Assert( cbFromFile == cbToRead );
} //Read

//+-------------------------------------------------------------------------
//
//  Member:     CMmStream::Write, public
//
//  Synopsis:   Writes to the stream
//
//  Arguments:  [pvBuffer]  -- The data to write
//              [oStart]    -- Offset in the file where the write starts
//              [cbToWrite] -- # of bytes to write
//
//  History:    30-Oct-98 dlee  Created
//              23-Nov-98 KLam  Check for enough disk space
//              03-Dec-98 KLam  Don't close the stream if there isn't
//                              enough disk space
//
//  Notes:      Win32 does not guarantee coherence if you mix read/write and
//              mapped IO in the same part of the file.
//
//--------------------------------------------------------------------------

void CMmStream::Write(
    void *    pvBuffer,
    ULONGLONG oStart,
    DWORD     cbToWrite )
{
    ciDebugOut(( DEB_ITRACE,
                 "WriteFile %#x, from %#p, offset %#I64x cb, %d\n",
                 _hFile, pvBuffer, oStart, cbToWrite ));

    //
    // Make sure there is enough disk space
    //
    __int64 cbNewSize = oStart + (__int64) cbToWrite;
    LARGE_INTEGER sizeCurrent = { _sizeLow, _sizeHigh };
    
    if ( cbNewSize > sizeCurrent.QuadPart )
    {
        __int64 cbTotal, cbRemaining;
        Win4Assert ( !_xDriveInfo.IsNull() );
        _xDriveInfo->GetDiskSpace ( cbTotal, cbRemaining );
        if ( (cbNewSize - sizeCurrent.QuadPart) > cbRemaining )
        {
            ciDebugOut(( DEB_ERROR,
                         "CMmStream::Write -- Not enogh disk space, need %I64d have %I64d\n",
                         cbNewSize - sizeCurrent.QuadPart, cbRemaining ));
            THROW( CException( CI_E_CONFIG_DISK_FULL ) );
        }
    }
    
    //
    // The file is opened async, so the IO can be pending
    //

    LARGE_INTEGER li;
    li.QuadPart = oStart;

    CEventSem evt;

    OVERLAPPED o;
    o.Offset = li.LowPart;
    o.OffsetHigh = li.HighPart;
    o.hEvent = evt.GetHandle();

    DWORD cbWritten;

    if ( !WriteFile( _hFile,
                     pvBuffer,
                     cbToWrite,
                     &cbWritten,
                     &o ) )
    {
        if ( ERROR_IO_PENDING == GetLastError() )
        {
            if ( ! GetOverlappedResult( _hFile, &o, &cbWritten, TRUE ) )
                THROW( CException() );
        }
        else
            THROW( CException() );
    }

    _sizeLow = GetFileSize( _hFile, &_sizeHigh );

    if ( 0xffffffff == _sizeLow &&
         NO_ERROR != GetLastError() )
        THROW( CException() );
} //Write
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\query\keyarray.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1991 - 1992.
//
//  File:       keyarray.cxx
//
//  Contents:   Key Array Class
//
//  Classes:    CKeyArray
//
//  History:    30-Jan-92       AmyA            Created
//              16-Apr-92       BartoszM        Reimplemented
//
//----------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

//+---------------------------------------------------------------------------
//
//  Member:     CKeyArray::CKeyArray, public
//
//  Synopsis:   Constructor of key array
//
//  Arguments:  [size] -- initial size
//
//  History:    16-Apr-92   BartoszM       Created.
//
//----------------------------------------------------------------------------
CKeyArray::CKeyArray(
    int  size,
    BOOL fThrow ) :
    _size(size),
    _count(0),
    _aKey(0),
    _fThrow( fThrow )
{
    // We don't want to use a vector constructor, since
    // this array may possibly be reallocated
    // (see CKeyArray::Grow)

    TRY
    {
        _aKey = (CKey*) new BYTE [ _size * sizeof(CKey) ];
    }
    CATCH( CException, e )
    {
        if ( fThrow )
            RETHROW();
    }
    END_CATCH;

    for ( int n = 0; n < _size; n++)
        _aKey[n].Init();
}

//+---------------------------------------------------------------------------
//
//  Member:     CKeyArray::CKeyArray, public
//
//  Synopsis:   Copy constructor of key array
//
//  Arguments:  [keyArray] -- key array to be copied
//
//  History:    29-Nov-94   SitaramR       Created.
//
//----------------------------------------------------------------------------

CKeyArray::CKeyArray(
    const CKeyArray& keyArray,
    BOOL             fThrow ) :
    _count( keyArray.Count() ),
    _size( _count ),
    _aKey( 0 ),
    _fThrow( fThrow )
{
    int i = 0;

    TRY
    {
        _aKey = (CKey*) new BYTE [ _size * sizeof(CKey) ];

        for ( i=0; i<_size; i++)
            _aKey[i].CKey::CKey( keyArray.Get(i) );
    }
    CATCH( CException, e )
    {
        for ( int j = 0; j < i; j++ )
            _aKey[ j ].Free();

        delete (BYTE *) _aKey;
        _aKey = 0;

        if ( fThrow )
            RETHROW();
    }
    END_CATCH;
}

//+---------------------------------------------------------------------------
//
//  Member:     CKeyArray::~CKeyArray, public
//
//  Synopsis:   Destroy all keys
//
//  History:    16-Apr-92   BartoszM       Created.
//
//----------------------------------------------------------------------------
CKeyArray::~CKeyArray()
{
    Win4Assert(_aKey || _count==0);

    if (_aKey)
    {
        for ( int i=0; i < _size; i++)
            _aKey[i].Free();
    }
    delete (BYTE *) _aKey;
}

void CKeyArray::Marshall( PSerStream & stm ) const
{
    stm.PutULong( _count );

    for ( int i = 0; i < _count; i++ )
    {
        _aKey[i].Marshall( stm );
    }
}

CKeyArray::CKeyArray(
    PDeSerStream & stm,
    BOOL           fThrow ) :
    _count( stm.GetULong() ),
    _fThrow( fThrow ),
    _aKey( 0 )
{
    _size = _count;

    int i = 0;

    TRY
    {
        // guard against attack

        if ( _count > 10000 )
            THROW( CException( E_INVALIDARG ) );

        _aKey = (CKey*) new BYTE [ _size * sizeof(CKey) ];

        for ( i = 0; i < _size; i++)
            _aKey[i].CKey::CKey( stm );
    }
    CATCH( CException, e )
    {
        for ( int j = 0; j < i; j++ )
            _aKey[ j ].Free();

        delete (BYTE *) _aKey;
        _aKey = 0;

        if ( fThrow )
            RETHROW();
    }
    END_CATCH;
}

//+---------------------------------------------------------------------------
//
//  Member:     CKeyArray::TotalKeySize, public
//
//  Synopsis:   Calculate space needed to store all the keys
//
//  History:    30-Jun-93   BartoszM       Created.
//
//----------------------------------------------------------------------------
int CKeyArray::TotalKeySize() const
{
    int cb = 0;

    // calculate total byte count of key buffers
    for ( int i = 0; i < _count; i++)
    {
        cb += _aKey[i].Count();
    }
    // add space for pid and cb
    cb += _count * ( sizeof(ULONG) + sizeof(PROPID));
    return(cb);
}

//+---------------------------------------------------------------------------
//
//  Member:     CKeyArray::_Grow, private
//
//  Synopsis:   Reallocate the array
//
//  Arguments:  [pos] -- position that mast fit into new array
//
//  History:    16-Apr-92   BartoszM       Created.
//
//----------------------------------------------------------------------------
void CKeyArray::_Grow ( int pos )
{
    // cuDebugOut (( DEB_ITRACE, "Grow KeyArray form %d to %d\n", _size, pos ));
#if CIDBG == 1
    Display();
#endif // CIDBG == 1

    int sizeNew = 2 * _size;
    while ( sizeNew <= pos)
    {
        sizeNew *= 2;
    }

    XPtr<CKey> xKeyNew((CKey *)new BYTE [ sizeNew * sizeof(CKey) ]);

    memcpy ( xKeyNew.GetPointer(), _aKey, _size * sizeof(CKey) );

    for ( int n = _size; n < sizeNew; n++ )
        (xKeyNew.GetPointer())[n].Init();

    delete (BYTE *) _aKey;
    _aKey = xKeyNew.Acquire();
    _size = sizeNew;
#if CIDBG == 1
    Display();
#endif
}

//+---------------------------------------------------------------------------
//
//  Member:     CKeyArray::Add, public
//
//  Synopsis:   Add next key by copying it
//
//  Arguments:  [Key] -- key to be added
//
//  History:    16-Apr-92   BartoszM       Created.
//
//----------------------------------------------------------------------------
BOOL CKeyArray::Add(const CKey& Key)
{
    BOOL fOk = TRUE;

    if ( _fThrow )
        _Add( Key );
    else
    {
        TRY
        {
            _Add( Key );
        }
        CATCH( CException, e )
        {
            fOk = FALSE;
        }
        END_CATCH;
    }

    return fOk;
}

//+---------------------------------------------------------------------------
//
//  Member:     CKeyArray::Add, public
//
//  Synopsis:   Add next key by copying it
//
//  Arguments:  [Key] -- key to be added
//
//  History:    16-Apr-92   BartoszM       Created.
//
//----------------------------------------------------------------------------
BOOL CKeyArray::Add(const CKeyBuf& Key)
{
    BOOL fOk = TRUE;

    if ( _fThrow )
        _Add( Key );
    else
    {
        TRY
        {
            _Add( Key );
        }
        CATCH( CException, e )
        {
            fOk = FALSE;
        }
        END_CATCH;
    }

    return fOk;
}

//+---------------------------------------------------------------------------
//
//  Member:     CKeyArray::Add, public
//
//  Synopsis:   Add key at position by copying it from key buffer
//
//  Arguments:  [pos] -- position in array
//              [key] -- key to be added
//
//  History:    16-Apr-92   BartoszM       Created.
//
//----------------------------------------------------------------------------
BOOL CKeyArray::Add( int pos, const CKeyBuf& key)
{
    BOOL fOk = TRUE;

    if ( _fThrow )
        _Add( pos, key );
    else
    {
        TRY
        {
            _Add( pos, key );
        }
        CATCH( CException, e )
        {
            fOk = FALSE;
        }
        END_CATCH;
    }

    return fOk;
}

//+---------------------------------------------------------------------------
//
//  Member:     CKeyArray::Add, public
//
//  Synopsis:   Add key at posistion by copying it
//
//  Arguments:  [pos] -- position in array
//              [key] -- key to be added
//
//  History:    16-Apr-92   BartoszM       Created.
//
//----------------------------------------------------------------------------
BOOL CKeyArray::Add( int pos, const CKey& key)
{
    BOOL fOk = TRUE;

    if ( _fThrow )
        _Add( pos, key );
    else
    {
        TRY
        {
            _Add( pos, key );
        }
        CATCH( CException, e )
        {
            fOk = FALSE;
        }
        END_CATCH;
    }

    return fOk;
}

//+---------------------------------------------------------------------------
//
//  Member:     CKeyArray::FillMax, public
//
//  Synopsis:   Create a sentinel key at given position
//
//  Arguments:  [pos] -- position in array
//
//  History:    16-Apr-92   BartoszM       Created.
//
//----------------------------------------------------------------------------
BOOL CKeyArray::FillMax ( int pos )
{
    BOOL fOk = TRUE;

    if ( _fThrow )
        _FillMax( pos );
    else
    {
        TRY
        {
            _FillMax( pos );
        }
        CATCH( CException, e )
        {
            fOk = FALSE;
        }
        END_CATCH;
    }

    return fOk;
}

//+---------------------------------------------------------------------------
//
//  Member:     CKeyArray::_Add, private
//
//  Synopsis:   Add next key by copying it
//
//  Arguments:  [Key] -- key to be added
//
//  History:    16-Apr-92   BartoszM       Created.
//
//----------------------------------------------------------------------------
void CKeyArray::_Add(const CKey& Key)
{
    if (_count == _size)
        _Grow(_count);

    _aKey[_count] = Key;
    _count++;

#if CIDBG == 1
    Display();
#endif
}

//+---------------------------------------------------------------------------
//
//  Member:     CKeyArray::_Add, private
//
//  Synopsis:   Add next key by copying it
//
//  Arguments:  [Key] -- key to be added
//
//  History:    16-Apr-92   BartoszM       Created.
//
//----------------------------------------------------------------------------
void CKeyArray::_Add(const CKeyBuf& Key)
{
    if (_count == _size)
        _Grow(_count);

    _aKey[_count] = Key;
    _count++;
}

//+---------------------------------------------------------------------------
//
//  Member:     CKeyArray::_Add, private
//
//  Synopsis:   Add key at position by copying it from key buffer
//
//  Arguments:  [pos] -- position in array
//              [key] -- key to be added
//
//  History:    16-Apr-92   BartoszM       Created.
//
//----------------------------------------------------------------------------
void CKeyArray::_Add( int pos, const CKeyBuf& key)
{
    if ( pos >= _size)
        _Grow(pos);

    _aKey[pos] = key;

#if CIDBG == 1
    Display();
#endif
}

//+---------------------------------------------------------------------------
//
//  Member:     CKeyArray::_Add, private
//
//  Synopsis:   Add key at posistion by copying it
//
//  Arguments:  [pos] -- position in array
//              [key] -- key to be added
//
//  History:    16-Apr-92   BartoszM       Created.
//
//----------------------------------------------------------------------------
void CKeyArray::_Add( int pos, const CKey& key)
{
    if ( pos >= _size)
       _Grow(pos);

    _aKey[pos] = key;

#if CIDBG == 1
    Display();
#endif
}

//+---------------------------------------------------------------------------
//
//  Member:     CKeyArray::_FillMax, private
//
//  Synopsis:   Create a sentinel key at given position
//
//  Arguments:  [pos] -- position in array
//
//  History:    16-Apr-92   BartoszM       Created.
//
//----------------------------------------------------------------------------
void CKeyArray::_FillMax ( int pos )
{
    if (pos >= _size)
        _Grow(pos);

    _aKey[pos].FillMax();
}

#if 0
void CKeyArray::Display()
{
    cuDebugOut (( DEB_ITRACE, "KeyArray: size %d\n", _size ));
    for (int i = 0; i < _size; i++)
    {
        cuDebugOut (( DEB_ITRACE | DEB_NOCOMPNAME, "%2d ", i ));
        int count = _aKey[i].Count();
        if ( count != 0 )
        {
            BYTE* buf = _aKey[i].GetBuf();
            for (int k = 0; k < count; k++)
            {
                cuDebugOut (( DEB_ITRACE | DEB_NOCOMPNAME, "%c", buf[k] ));
            }
            cuDebugOut (( DEB_ITRACE | DEB_NOCOMPNAME, "\n" ));
        }
        else
            cuDebugOut (( DEB_ITRACE | DEB_NOCOMPNAME, "<NULL>\n" ));
    }
}
#endif // 0
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\query\key.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1991 - 1992.
//
//  File:       Key.cxx
//
//  Contents:   Key implementation
//
//  Classes:    CKeyBuf
//
//  History:    29-Mar-91       BartoszM        Created
//
//  Notes:      Key comparison is tricky. The global Compare function
//              is the basis for key sorting. Searching may involve
//              wildcard pidAll.
//
//----------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include "norm.hxx"

static WCHAR TmpBuf[cwcMaxKey*2 + 1];        // 2 WCHAR per hex byte + '='

static const WCHAR aHexDigit[16] = { '0', '1', '2', '3', '4', '5',
                       '6', '7', '8', '9', 'A', 'B',
                       'C', 'D', 'E', 'F' };

static WCHAR wcsDisplay[cwcMaxKey + 1];


WCHAR * MungeStr( BYTE const * p, BOOL fValue, unsigned cwc )
{
    if (p)
    {
        if ( fValue )
        {
            WCHAR *pwcsBuf = TmpBuf;
            p += cbKeyPrefix;
            *(pwcsBuf++)   = L'=';

            cwc = min(cwc, cwcMaxKey*2);
            for (unsigned i=1; i<cwc; i+=2)
            {
                Win4Assert(aHexDigit[0] == L'0');

                *(pwcsBuf++) = aHexDigit[ (*p >> 4) & 0xF ];
                *(pwcsBuf++) = aHexDigit[ *p & 0xF ];

                p++;
            }

            *(pwcsBuf) = 0;
            return TmpBuf;
        }
        else
        {
            p += cbKeyPrefix;

            //
            // WARNING: Potential serialization conflict.  This static buffer
            //   is used to word-align the 'string' portion of the buffer for
            //   display as WCHAR.  No serialization is done.  Since the
            //   strings are counted (not null terminated) the worst that
            //   can happen is a debug string is incorrectly displayed.
            //

            for ( unsigned i = 0; i < cwc; i++ )
            {
                wcsDisplay[i] = (p[i*sizeof(WCHAR)] << 8)
                    + (p[i*sizeof(WCHAR)+1]);
            }

            wcsDisplay[cwc] = 0;

            return( &wcsDisplay[0] );
        }
    }

    return( 0 );
}


WCHAR* CKey::GetStr() const
{
    BYTE const * p = GetBuf();

    return( MungeStr( p, p ? IsValue() : 0, StrLen() ) );
}

WCHAR* CKeyBuf::GetStr() const
{
    BYTE const * p = GetBuf();

    return( MungeStr( p, p ? IsValue() : 0, StrLen() ) );
}

unsigned CKey::StrLen() const
{
    unsigned len = Count();
    if (len > 0)
    {
        if ( IsValue() )
        {
            return (len - cbKeyPrefix)*2 + 1;
        }

        len -= cbKeyPrefix; // subtract off space used to store STRING_KEY
    }
    return ( len / sizeof(WCHAR) );
}

unsigned CKeyBuf::StrLen() const
{
    unsigned len = Count();
    if (len > 0)
    {
        if ( IsValue() )
        {
            return (len - cbKeyPrefix)*2 + 1;    // Length in characters
        }

        len -= cbKeyPrefix; // subtract off space used to store STRING_KEY
    }
    return( len / sizeof(WCHAR) );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\query\vkrep.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1991 - 2000.
//
//  File:   QKREP.CXX
//
//  Contents:   Query Key Repository
//
//  Classes:    CQueryKeyRepository
//
//  History:    04-Jun-91    t-WadeR    Created.
//              23-Sep-91    BartosM    Rewrote to use phrase expr.
//              31-Jan-93    KyleP      Use restrictions, not expressions
//
//----------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include <vkrep.hxx>

//+---------------------------------------------------------------------------
//
//  Member:     CRangeKeyRepository::CRangeKeyRepository
//
//  Synopsis:   Creates Range Key repository
//
//  History:    24-Sep-92   BartoszM    Created
//
//----------------------------------------------------------------------------

CRangeKeyRepository::CRangeKeyRepository ()
        : _count(0)
{
    _pRangeRst = new CRangeRestriction;
}

//+---------------------------------------------------------------------------
//
//  Member:     CRangeKeyRepository::~CRangeKeyRepository
//
//  Synopsis:   Destroys
//
//  History:    24-Sep-92   BartoszM    Created
//
//----------------------------------------------------------------------------

CRangeKeyRepository::~CRangeKeyRepository()
{
    delete _pRangeRst;
}

//+---------------------------------------------------------------------------
//
//  Member:     CRangeKeyRepository::AcqXpr
//
//  Synopsis:   Acquire Phrase Expression
//
//  History:    24-Sep-92   BartoszM    Created
//
//----------------------------------------------------------------------------

CRangeRestriction* CRangeKeyRepository::AcqRst()
{
    CRangeRestriction* tmp = 0;

    if ( _count == 2 )
    {
        if( _pRangeRst->GetStartKey()->
            CompareStr( *_pRangeRst->GetEndKey() ) > 0 )
        {
            //
            // absolute false restriction
            //
            vqDebugOut(( DEB_ERROR, "Absolute false restriction" ));
            delete _pRangeRst;
        }
        else
        {
            tmp = _pRangeRst;
        }
        _pRangeRst = 0;
    }

    return tmp;
}

//+---------------------------------------------------------------------------
//
//  Member:     CRangeKeyRepository::PutKey
//
//  Synopsis:   Puts a key into the key list and occurrence list
//
//  Arguments:  cNoiseWordsSkipped -- ignored (used by CQueryKeyRepository::PutKey )
//
//  History:    24-Sep-92   BartoszM    Created
//
//----------------------------------------------------------------------------

void  CRangeKeyRepository::PutKey ( ULONG cNoiseWordsSkipped )
{
    vqDebugOut (( DEB_ITRACE, "RangeKeyRepository::PutKey \"%.*ws\", pid=%d\n",
                  _key.StrLen(), _key.GetStr(), _key.Pid() ));
    Win4Assert ( _count < 2 );

    if (_count == 0)
        _pRangeRst->SetStartKey ( _key );
    else
        _pRangeRst->SetEndKey ( _key );
    _count++;
}

//+---------------------------------------------------------------------------
//
//  Member:     CRangeKeyRepository::GetBuffers
//
//  Synopsis:   Returns address of repository's input buffers
//
//  Effects:
//
//  Arguments:  [ppcbInBuf] -- pointer to pointer to size of input buffer
//              [ppbInBuf] -- pointer to pointer to recieve address of buffer
//              [ppocc] -- pointer to pointer to recieve address of occurrences
//
//  History:    24-Sep-92   BartoszM    Created
//
//  Notes:
//
//----------------------------------------------------------------------------

void CRangeKeyRepository::GetBuffers( unsigned** ppcbWordBuf,
                                      BYTE** ppbWordBuf, OCCURRENCE** ppocc )
{
    _key.SetCount(MAXKEYSIZE);
    *ppcbWordBuf = _key.GetCountAddress();
    *ppbWordBuf = _key.GetWritableBuf();
    *ppocc = &_occ;
}

//+---------------------------------------------------------------------------
//
//  Member:     CRangeKeyRepository::GetFlags
//
//  Synopsis:   Returns address of rank and range flags
//
//  Arguments:  [ppRange] -- range flag
//              [ppRank] -- rank flag
//
//  History:    11-Feb-92   BartoszM    Created.
//
//----------------------------------------------------------------------------

void CRangeKeyRepository::GetFlags ( BOOL** ppRange, CI_RANK** ppRank )
{
    *ppRange = 0;
    *ppRank  = 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\query\regacc.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 2000.
//
//  File:       RegAcc.cxx
//
//  Contents:   'Simple' registry access
//
//  History:    21-Dec-93 KyleP     Created
//
//--------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include <regacc.hxx>
#include <regevent.hxx>

//+-------------------------------------------------------------------------
//
//  Method:     CRegNotifyKey::CRegNotifyKey, public
//
//  Purpose:    A smart pointer to a registry key
//
//  History:    07-Jun-94   DwightKr    Created
//
//--------------------------------------------------------------------------

inline CRegNotifyKey::CRegNotifyKey( const WCHAR * wcsRegKey )
{
    wcscpy( _wcsKey, wcsRegKey );

    RtlInitUnicodeString( &_KeyName, _wcsKey );

    InitializeObjectAttributes( &_ObjectAttr,           // Structure
                                &_KeyName,              // Name
                                OBJ_CASE_INSENSITIVE,   // Attributes
                                NULL,                   // Root
                                NULL );                 // Security
}

//+-------------------------------------------------------------------------
//
//  Method:     CRegChangeEvent::CRegChangeEvent, public
//
//  Purpose:    Sets up waiting on a registry change event
//
//  History:    07-Jun-94   DwightKr    Created
//
//--------------------------------------------------------------------------

CRegChangeEvent::CRegChangeEvent( const WCHAR * wcsRegKey,
                                  BOOL fDeferInit ) :
                         CRegNotifyKey( wcsRegKey ),
                         _regEvent(TRUE),
                         _hKey(INVALID_HANDLE_VALUE),
                         _fDeferInit( fDeferInit ),
                         _fNotifyEnabled( FALSE )
{
    if (!fDeferInit)
        Reset();
}

//+-------------------------------------------------------------------------
//
//  Method:     CRegChangeEvent::~CRegChangeEvent, public
//
//  Purpose:    Destructs a registry change event
//
//  History:    17-Jul-98   dlee    Created
//
//--------------------------------------------------------------------------

CRegChangeEvent::~CRegChangeEvent()
{
    if ( INVALID_HANDLE_VALUE != _hKey )
    {
        NtClose( _hKey );

        // Wait for the notification to complete if it is enabled.
        // It'll write into the IO_STATUS_BLOCK when it aborts due to the
        // key close above.

        if ( _fNotifyEnabled )
            _regEvent.Wait();
    }
} //~CRegChangeEvent

//+---------------------------------------------------------------------------
//
//  Member:     CRegChangeEvent::Register
//
//  Synopsis:   Closes an existing key handle (if open) and reopens it.
//
//  History:    10-08-96   srikants   Created
//
//----------------------------------------------------------------------------

void CRegChangeEvent::Register()
{
    Win4Assert( !_fNotifyEnabled );

    //
    // Close previous handle.
    //
    if ( _hKey != INVALID_HANDLE_VALUE )
    {
        NtClose( _hKey );
        _hKey = INVALID_HANDLE_VALUE;
    }

    //
    // Try to re-open.  This sub-optimal behavior works around peculiarities
    // in Gibraltar.
    //
    NTSTATUS Status = NtOpenKey( &_hKey,                // Resulting handle
                                  KEY_NOTIFY,           // Access requested
                                 &_ObjectAttr);

    if ( NT_ERROR( Status ) )
    {
        ciDebugOut((DEB_ERROR, "NtOpenKey(%ws) failed, rc=0x%x\n",
                                       _wcsKey,           Status ));
        _hKey = INVALID_HANDLE_VALUE;
    }
}

//+-------------------------------------------------------------------------
//
//  Method:     CRegChangeEvent::Reset, public
//
//  Purpose:    Sets up waiting on a registry change event
//
//  History:    07-Jun-94   DwightKr    Created
//
//--------------------------------------------------------------------------

void CRegChangeEvent::Reset()
{
    _fNotifyEnabled = FALSE;
    _regEvent.Reset();

    NTSTATUS Status = STATUS_SUCCESS;

    //
    // There seems to be some peculiarities with the event based notifies.
    // After the first notify, NtNotifyChangeKey returns STATUS_KEY_DELETED
    // if we use the same key handle. So, close it and reopen it.
    //

    Register();

    if ( INVALID_HANDLE_VALUE != _hKey )
    {
        Status = NtNotifyChangeKey( _hKey,            // Handle to watch
                                    _regEvent.GetHandle(), // Event to set
                                    NULL,             // Optional APC
                                    NULL,             // Optional context
                                    &_IoStatus,
                                    REG_NOTIFY_CHANGE_ATTRIBUTES |
                                        REG_NOTIFY_CHANGE_NAME   |
                                        REG_NOTIFY_CHANGE_LAST_SET,
                                    TRUE,             // Watch tree
                                    NULL,             // Buffer
                                    0,                // buffer size
                                    TRUE );           // Asynchronous
    }

    if ( NT_SUCCESS( Status ) )
    {
        _fNotifyEnabled = TRUE;
    }
    else
    {
        ciDebugOut ((DEB_ERROR, "NtNotifyChangeKey failed, rc=0x%x\n", Status ));
    }
}

//+-------------------------------------------------------------------------
//
//  Method:     CRegChangeEvent::Init, public
//
//  Purpose:    Deferred initialization.
//
//  History:    27-Apr-97   KrishnaN    Created
//
//--------------------------------------------------------------------------

void CRegChangeEvent::Init()
{
    Win4Assert(_fDeferInit);

    Reset();
}

//+-------------------------------------------------------------------------
//
//  Method:     CRegNotify::CRegNotify, public
//
//  Purpose:    Sets up waiting on a registry change event
//
//  History:    07-Jun-94   DwightKr    Created
//
//--------------------------------------------------------------------------

CRegNotify::CRegNotify( const WCHAR * wcsRegKey ) :
          _fShutdown(FALSE),
          _hKey( INVALID_HANDLE_VALUE ),
          _refCount( 1 ),
          _mtx(),
          CRegNotifyKey( wcsRegKey )
{
    Register();
}

//+-------------------------------------------------------------------------
//
//  Method:     CRegNotify::DisableNotification, public
//
//  Purpose:    Close registry notifcation.  Leads to destruction after
//              APC completes.
//
//  History:    26-Feb-96   KyleP       Created
//
//--------------------------------------------------------------------------

void CRegNotify::DisableNotification()
{
    {
        CLock lck(_mtx);
        HANDLE hKey=_hKey;

        Win4Assert ( INVALID_HANDLE_VALUE != _hKey );
        _fShutdown=TRUE;
        if ( INVALID_HANDLE_VALUE != _hKey )
        {
            _hKey = INVALID_HANDLE_VALUE;
            NtClose( hKey );
        }
    }
    Release();
}

//+---------------------------------------------------------------------------
//
//  Member:     CRegNotify::~CRegNotify, protected
//
//  Synopsis:   Destructor
//
//  History:    2-26-96   KyleP      Added header
//
//----------------------------------------------------------------------------

CRegNotify::~CRegNotify()
{
    Win4Assert( 0 == _refCount );
    Win4Assert( _hKey == INVALID_HANDLE_VALUE );
}

//+---------------------------------------------------------------------------
//
//  Member:     CRegNotify::AddRef
//
//  History:    2-26-96   KyleP      Created
//
//----------------------------------------------------------------------------

void CRegNotify::AddRef()
{
    InterlockedIncrement(&_refCount);
}

//+---------------------------------------------------------------------------
//
//  Member:     CRegNotify::Release
//
//  Synopsis:   If the refcount goes to 0, the object will be deleted.
//
//  History:    2-26-96   KyleP      Created
//
//----------------------------------------------------------------------------

void CRegNotify::Release()
{
    Win4Assert( _refCount > 0 );
    if ( InterlockedDecrement(&_refCount) <= 0 )
        delete this;
}

//+---------------------------------------------------------------------------
//
//  Member:     CRegNotify::Register
//
//  Synopsis:   Re-registers APC
//
//  History:    2-26-96   KyleP      Added header
//
//----------------------------------------------------------------------------

void CRegNotify::Register()
{
    CLock lck(_mtx);

    if ( _fShutdown )
        return;

    //
    // Close previous handle.
    //

    if ( _hKey != INVALID_HANDLE_VALUE )
    {
        NtClose( _hKey );
        _hKey = INVALID_HANDLE_VALUE;
    }

    //
    // Try to re-open.  This sub-optimal behavior works around peculiarities
    // in Gibraltar.
    //

    NTSTATUS Status = STATUS_SUCCESS;

    Status = NtOpenKey( &_hKey,                 // Resulting handle
                        KEY_NOTIFY,             // Access requested
                        &_ObjectAttr);

    if ( NT_ERROR( Status ) )
    {
        ciDebugOut((DEB_ERROR, "NtOpenKey(%ws) failed, rc=0x%x\n", _wcsKey, Status ));
    }

    if ( _hKey != INVALID_HANDLE_VALUE )
    {
        Status = NtNotifyChangeKey( _hKey,             // Handle to watch
                                    0,                 // Event to set
                                    APC,               // Optional APC
                                    this,              // Optional context
                                    &_IoStatus,
                                    REG_NOTIFY_CHANGE_ATTRIBUTES |
                                        REG_NOTIFY_CHANGE_NAME   |
                                        REG_NOTIFY_CHANGE_LAST_SET,
                                    TRUE,              // Watch tree
                                    NULL,              // Buffer
                                    0,                 // buffer size
                                    TRUE );            // Asynchronous
    }

    if ( NT_ERROR( Status ) )
    {
        ciDebugOut ((DEB_ERROR, "NtNotifyChangeKey failed, rc=0x%x\n", Status ));
    }
    else
        AddRef();
}
//+---------------------------------------------------------------------------
//
//  Member:     CRegNotify::APC
//
//  Synopsis:   Asynchronous Procedure Call invoked by the system when there
//              is a change notification (or related error).
//
//  Arguments:  [ApcContext]    -  Pointer to "this"
//              [IoStatusBlock] -
//              [Reserved]      -
//
//  History:    2-20-96   KyleP      Created
//
//----------------------------------------------------------------------------

void CRegNotify::APC( void * ApcContext,
                      IO_STATUS_BLOCK * IoStatusBlock,
                      ULONG Reserved )
{
    Win4Assert( 0 != ApcContext );

    CRegNotify * pthis = (CRegNotify *)ApcContext;

    TRY
    {
        //
        // NTRAID#DB-NTBUG9-84531-2000/07/31-dlee Indexing Service registry notifications don't re-register after errors.
        //

        if ( NT_ERROR(IoStatusBlock->Status) )
        {
            ciDebugOut(( DEB_ERROR,
                         "Error 0x%x during Registry APC processing.\n",
                         IoStatusBlock->Status ));
        }

        if ( IoStatusBlock->Status != STATUS_NOTIFY_CLEANUP)
        {
            if( !NT_ERROR(IoStatusBlock->Status) )
            {
                pthis->DoIt();
                pthis->Register();
            }
            else
            {
                ciDebugOut(( DEB_ERROR, "Status 0x%x during Registry APC processing.\n",
                             IoStatusBlock->Status));
            }
        }
        else
        {
            Win4Assert(pthis->_fShutdown);
            //
            // Key closed
            //
        }
    }
    CATCH( CException, e )
    {
        ciDebugOut(( DEB_ERROR, "Exception 0x%x during Registry APC processing.\n",
                     e.GetErrorCode() ));
    }
    END_CATCH

    pthis->Release();
}

//+-------------------------------------------------------------------------
//
//  Member:     CRegAccess::CRegAccess, public
//
//  Synopsis:   Initialize registry access object
//
//  Arguments:  [ulRelative] -- Position in registry from which [pwcsRegPath]
//                              begins.  See ntrtl.h for constants.
//              [pwcsRegPath] -- Path to node.
//
//  History:    21-Dec-93 KyleP     Created
//              19-Aug-98 KLam          Removed END_CONSTRUCTION
//
//--------------------------------------------------------------------------

CRegAccess::CRegAccess( ULONG ulRelative, WCHAR const * pwcsRegPath )
        : _ulRelative( ulRelative ),
          _wcsPath( 0 )
{
    //
    // Setup unchanged regtable entries.
    //

    _regtab[0].DefaultType = REG_NONE;
    _regtab[0].DefaultData = 0;
    _regtab[0].DefaultLength = 0;
    _regtab[0].QueryRoutine = 0;

    _regtab[1].QueryRoutine = 0;
    _regtab[1].Flags = 0;

    int cch = wcslen( pwcsRegPath ) + 1;
    WCHAR * wcsPath = _wcsPathBuf;

    if( cch > sizeof(_wcsPathBuf)/sizeof(_wcsPathBuf[0]) )
    {
        _wcsPath = new WCHAR[ cch ];
        wcsPath = _wcsPath;
    }

    memcpy( wcsPath, pwcsRegPath, cch * sizeof(WCHAR) );
}

//+-------------------------------------------------------------------------
//
//  Member:     CRegAccess::Get, public
//
//  Synopsis:   Retrive value of specified key from registry.
//
//  Arguments:  [pwcsKey] -- Key to retrieve value of.
//              [wcsVal]  -- String stored here.
//              [cc]      -- Size (in characters) of [wcsVal]
//
//  History:    21-Dec-93 KyleP     Created
//
//  Notes:      Key must be string for successful retrieval.
//
//--------------------------------------------------------------------------

void CRegAccess::Get( WCHAR const * pwcsKey, WCHAR * wcsVal, unsigned cc )
{
    WCHAR * wcsPath = _wcsPath ? _wcsPath : _wcsPathBuf;

    UNICODE_STRING usVal;
    usVal.Buffer = wcsVal;
    usVal.MaximumLength = (USHORT)(cc*sizeof(WCHAR));

    SetName( pwcsKey );
    SetEntryContext( &usVal );

    NTSTATUS Status = RtlQueryRegistryValues( _ulRelative,
                                              wcsPath,
                                              &_regtab[0],
                                              0,
                                              0 );

    if ( NT_ERROR(Status) )
    {
        ciDebugOut(( DEB_IERROR,
                     "RtlQueryRegistryValues (...\\%ws  %ws) returned 0x%x\n",
                     wcsPath, pwcsKey, Status ));

        QUIETTHROW( CException( Status ) );
    }
} //Get

//+-------------------------------------------------------------------------
//
//  Member:     CRegAccess::CallBackDWORD, public
//
//  Synopsis:   CallBack function that retrieves a DWORD value
//
//  Arguments:  [pValueName]   -- name of value
//              [uValueType]   -- type such as REG_MULTI_SZ
//              [pValueData]   -- data associated with value
//              [uValueLength] -- length of valueData
//              [context]      -- ptr to RTL_QUERY_REGISTRY_TABLE
//              [entryContext] -- where the DWORD goes
//
//  Returns:    NTSTATUS
//
//  History:    21-Sep-1998     dlee     Created
//
//--------------------------------------------------------------------------

NTSTATUS CRegAccess::CallBackDWORD(
    WCHAR * pValueName,
    ULONG   uValueType,
    VOID *  pValueData,
    ULONG   uValueLength,
    VOID *  pContext,
    VOID *  pEntryContext )
{
    Win4Assert( 0 != pContext );
    RTL_QUERY_REGISTRY_TABLE *p = (RTL_QUERY_REGISTRY_TABLE *) pContext;

    ciDebugOut(( DEB_ITRACE,
                 "callback for %ws, type %d, pValueData %#x, defaultData %#x\n",
                 pValueName, uValueType, pValueData, p->DefaultData ));

    if ( REG_DWORD == uValueType )
    {
        // If there is no value in the registry, return an error
        // Note: if there is a default value, NT passes the default value
        //       in pValueData.  pValueData will only be 0 if there is no
        //       default.

        if ( 0 == pValueData )
            return STATUS_OBJECT_NAME_NOT_FOUND;

        Win4Assert( sizeof DWORD == uValueLength );

        // The value is a DWORD and it exists

        RtlCopyMemory( pEntryContext, pValueData, sizeof DWORD );
    }
    else
    {
        // The type isn't DWORD as expected, so try to use the default.

        // If there is no default, return an error

        if ( 0 == p->DefaultData )
            return STATUS_OBJECT_TYPE_MISMATCH;

        // Copy the default value

        Win4Assert( sizeof DWORD == p->DefaultLength );
        RtlCopyMemory( pEntryContext, p->DefaultData, sizeof DWORD );
    }

    return STATUS_SUCCESS;
} //CallBackDWORD

//+-------------------------------------------------------------------------
//
//  Member:     CRegAccess::ReadDWORD, private
//
//  Synopsis:   Retrive value of specified key from registry, use default if
//              key was not present or was of type other than DWORD
//
//  Arguments:  [pwcsKey]       -- Value name
//              [pDefaultValue] -- The default value if none exists or
//                                 if the type isn't DWORD.  If this is 0,
//                                 an exception is thrown if a DWORD isn't
//                                 found.
//
//  Returns:    Value of [pwcsKey].
//
//  History:    22-Sep-98  dlee    created
//
//--------------------------------------------------------------------------

ULONG CRegAccess::ReadDWORD( WCHAR const * pwcsKey, ULONG * pDefaultValue )
{
    WCHAR * wcsPath = _wcsPath ? _wcsPath : _wcsPathBuf;

    DWORD dwVal;

    RTL_QUERY_REGISTRY_TABLE rtab[2];
    rtab[0].DefaultType = REG_DWORD;
    rtab[0].DefaultLength = sizeof DWORD;
    rtab[0].QueryRoutine = CallBackDWORD;
    rtab[0].Name = (WCHAR *) pwcsKey;
    rtab[0].Flags = RTL_QUERY_REGISTRY_REQUIRED;
    rtab[0].EntryContext = &dwVal;
    rtab[0].DefaultData = pDefaultValue;

    rtab[1].QueryRoutine = 0;
    rtab[1].Flags = 0;

    NTSTATUS Status = RtlQueryRegistryValues( _ulRelative,
                                              wcsPath,
                                              &rtab[0],
                                              &rtab[0],
                                              0 );
    if ( NT_ERROR(Status) )
    {
        if ( STATUS_OBJECT_NAME_NOT_FOUND == Status &&
             0 != pDefaultValue )
             dwVal = *pDefaultValue;
        else
        {
            ciDebugOut(( DEB_IERROR,
                         "RtlQueryRegistryValues (...\\%ws  %ws) returned 0x%x\n",
                         wcsPath, pwcsKey, Status ));

            THROW( CException( Status ) );
        }
    }

    return dwVal;
} //Read

//+-------------------------------------------------------------------------
//
//  Member:     CRegAccess::Get, public
//
//  Synopsis:   Retrive value of specified key from registry.  Throws if the
//              value doesn't exist or is of type other than DWORD.
//
//  Arguments:  [pwcsKey] -- Key to retrieve value of.
//
//  Returns:    Value of [pwcsKey].
//
//  History:    21-Dec-93 KyleP     Created
//
//  Notes:      Key must be dword for successful retrieval.
//
//--------------------------------------------------------------------------

ULONG CRegAccess::Get( WCHAR const * pwcsKey )
{
    return ReadDWORD( pwcsKey, 0 );
} //Get

//+-------------------------------------------------------------------------
//
//  Member:     CRegAccess::Read, public
//
//  Synopsis:   Retrive value of specified key from registry, use default if
//              key was not present or was of type other than DWORD
//
//  Arguments:  [pwcsKey]   -- Key to retrieve value of.
//              [ulDefaultValue] -- Default value if not found
//
//  Returns:    Value of [pwcsKey].
//
//  History:    13-Jun-94 DwightKr  Created
//
//  Notes:      Key must be dword for successful retrieval.
//
//--------------------------------------------------------------------------

ULONG CRegAccess::Read( WCHAR const * pwcsKey, ULONG ulDefaultValue )
{
    return ReadDWORD( pwcsKey, &ulDefaultValue );
} //Read

//+-------------------------------------------------------------------------
//
//  Member:     CRegAccess::CallBack, public
//
//  Synopsis:   CallBack function that casts Context to CRegCallBack and
//              then calls CRegCallBack::CallBack
//
//  Arguments:  [pValueName] -- name of value
//              [uValueType] -- type such as REG_MULTI_SZ
//              [pValueData] -- data associated with value
//              [uVvalueLength] -- length of valueData
//              [pContext] -- ptr to CRegCallBack
//              [pEntryContext] -- ignored
//
//  Returns:    status
//
//  History:    29-Aug-1994     SitaramR      Created
//
//--------------------------------------------------------------------------

NTSTATUS CRegAccess::CallBack(WCHAR *pValueName, ULONG uValueType,
                              VOID *pValueData, ULONG uValueLength,
                              VOID *pContext, VOID *pEntryContext )
{
    NTSTATUS status = ( (CRegCallBack *) pContext)->CallBack( pValueName,
                                                              uValueType,
                                                              pValueData,
                                                              uValueLength );
    return status;
}

//+-------------------------------------------------------------------------
//
//  Member:     CRegAccess::EnumerateValues, public
//
//  Synopsis:   Enumerate (REG_MULTI_SZ) values of a given key. Call the
//              callback routine passing each such enumerated value.
//
//  Arguments:  [wszValue] -- value to be enumerated
//              [regCallBack] -- callback class
//
//  History:    15-Aug-1994     SitaramR      Created
//
//--------------------------------------------------------------------------


void CRegAccess::EnumerateValues( WCHAR *wszValue,
                                  CRegCallBack& regCallBack )
{
    WCHAR * wcsPath = _wcsPath ? _wcsPath : _wcsPathBuf;

    NTSTATUS status;

    SetName( wszValue );
    SetEntryContext( 0 );
    _regtab[0].QueryRoutine = CRegAccess::CallBack;

    status = RtlQueryRegistryValues( _ulRelative,
                                     wcsPath,
                                     &_regtab[0],
                                     &regCallBack,
                                     0 );
    if ( NT_ERROR(status) && STATUS_OBJECT_NAME_NOT_FOUND != status )
    {
        ciDebugOut(( DEB_ITRACE,
                     "RtlQueryRegistryValues(..%ws) returned 0x%x\n",
                     wcsPath, status ));
        QUIETTHROW( CException( status ) );
    }
}


//+-------------------------------------------------------------------------
//
//  Member:     CRegAccess::Read, public
//
//  Synopsis:   Retrive value of specified key from registry, use default if
//              key was not present
//
//  Arguments:  [pwcsKey]           -- Key to retrieve value of.
//              [pwcsDefaultValue]  -- Default value if not found
//
//  Returns:    Value of [pwcsKey].
//
//  History:    18-Aug-98   KLam    Created header
//
//  Notes:      Key must be a string for successful retrieval.
//
//--------------------------------------------------------------------------

WCHAR * CRegAccess::Read( WCHAR const * pwcsKey, WCHAR const * pwcsDefaultValue )
{
    WCHAR * wcsPath = _wcsPath ? _wcsPath : _wcsPathBuf;

    UNICODE_STRING usVal;

    SetName( pwcsKey );
    SetEntryContext( &usVal );

    usVal.Length = 50 * sizeof(WCHAR);
    usVal.Buffer = 0;

    NTSTATUS Status = STATUS_BUFFER_TOO_SMALL;

    while ( Status == STATUS_BUFFER_TOO_SMALL )
    {
        // could cause a delete before any call to new

        if ( 0 != usVal.Buffer )
            delete [] usVal.Buffer;

        usVal.Length *= 2;
        usVal.MaximumLength = usVal.Length;
        usVal.Buffer = new WCHAR[ usVal.Length/sizeof(WCHAR) ];

        Status = RtlQueryRegistryValues( _ulRelative,
                                         wcsPath,
                                         &_regtab[0],
                                         0,
                                         0 );
    }

    WCHAR * pwcs = 0;

    if ( NT_ERROR(Status) )
    {
        if ( 0 != usVal.Buffer )
            delete [] usVal.Buffer;

        usVal.Buffer = 0;

        if ( Status == STATUS_OBJECT_NAME_NOT_FOUND )
        {
            unsigned cc = wcslen(pwcsDefaultValue) + 1;
            pwcs = new WCHAR[cc];
            memcpy( pwcs, pwcsDefaultValue, cc*sizeof(WCHAR) );
        }
        else
        {
            ciDebugOut(( DEB_IERROR,
                         "RtlQueryRegistryValues (...\\%ws  %ws) returned 0x%x\n",
                         wcsPath, pwcsKey, Status ));

            THROW( CException( Status ) );
        }
    }
    else
    {
        //
        // Copy string to new heap
        //

        pwcs = usVal.Buffer;
        usVal.Buffer = 0;
    }

    return pwcs;
} //Read
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\query\ci\catadmin.cxx ===
//+---------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1997 - 2002.
//
// File:        CatAdmin.cxx
//
// Contents:    Catalog administration API
//
// Classes:     CMachineAdmin, CCatalogAdmin, CCatalogEnum, CScopeEnum, ...
//
// History:     04-Feb-97       KyleP       Created
//
//----------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include <ntquery.h>

#include <CatAdmin.hxx>
#include <regprop.hxx>
#include <CiRegKey.hxx>
#include <RegScp.hxx>
#include <SMatch.hxx>
#include <shlwapi.h>
#include <shlwapip.h>
#include <winnetwk.h>
#include <dynload.hxx>
#include <dynmpr.hxx>

extern BOOL ApplySystemAcl( WCHAR const *pwcDir );
extern BOOL ApplySystemOnlyAcl( WCHAR const *pwcDir );

//
// Constants
//

const unsigned MAX_CAT_PATH = MAX_PATH - 13*2;
const unsigned MAX_CAT_NAME = 40;

HKEY const hkeyInvalid = 0;
WCHAR const wcsCatalogDotWCI[] = L"\\catalog.wci";

//
// Local prototypes.
//

ULONG Delnode( WCHAR const * wcsDir, BOOL fDelTopDir = TRUE );
BOOL IsSUBST( WCHAR wcDrive );
BOOL IsMsNetwork( LPCWSTR  pwszMachine );

BOOL WaitForSvcPause( CServiceHandle &x )
{
    SERVICE_STATUS svcStatus;
    if ( QueryServiceStatus( x.Get(), &svcStatus ) )
        return SERVICE_PAUSE_PENDING == svcStatus.dwCurrentState ||
               SERVICE_RUNNING == svcStatus.dwCurrentState;

    return FALSE;
} //WaitForSvcPause

//+---------------------------------------------------------------------------
//
//  Method:     IsShortPath, private
//
//  Arguments:  Path in question
//
//  Returns:    TRUE if the path name potentially contains a short (8.3) name
//              for a file with a long name.
//
//  History:    15-Sep-1998   AlanW       Created
//              11-May-1998   KrishnaN    Borrowed from CFunnyPath
//
//----------------------------------------------------------------------------

BOOL IsShortPath( LPCTSTR lpszPath )
{
    Win4Assert( 0 != lpszPath);

    //
    // Check to see if the input path name contains an 8.3 short name
    //
    WCHAR * pwszTilde = wcschr( lpszPath, L'~' );

    if (pwszTilde)
    {
        WCHAR * pwszComponent;
        for ( pwszComponent = wcschr( lpszPath, L'\\' );
              pwszComponent;
              pwszComponent = wcschr( pwszComponent, L'\\' ) )
        {
            pwszComponent++;
            pwszTilde = wcschr( pwszComponent, L'~' );
            if ( 0 == pwszTilde || pwszTilde - pwszComponent > 13)
                continue;
            if (CFunnyPath::IsShortName( pwszComponent ))
                return TRUE;
        }
    }
    return FALSE;
}

//+---------------------------------------------------------------------------
//
//  Member:     CMachineAdmin::CMachineAdmin, public
//
//  Synopsis:   Creates admin object for machine
//
//  Arguments:  [pwszMachine] -- Machine name.  Null for local machine
//              [fWrite]      -- If TRUE, open the registry for write
//
//  History:    02-Feb-19   KyleP       Created
//
//----------------------------------------------------------------------------

CMachineAdmin::CMachineAdmin( WCHAR const * pwszMachine, BOOL fWrite )
        : _hkeyLM( hkeyInvalid ),
          _hkeyContentIndex( hkeyInvalid ),
          _fWrite( fWrite )
{
    DWORD dwError;

    if ( 0 == pwszMachine )
    {
        _hkeyLM = HKEY_LOCAL_MACHINE;
        _xwcsMachName[0] = 0;
    }
    else
    {
        unsigned cc = wcslen( pwszMachine );

        _xwcsMachName.SetSize( cc + 1 );

        RtlCopyMemory( _xwcsMachName.Get(), pwszMachine, (cc+1) * sizeof(WCHAR) );

        if ( 1 == cc && pwszMachine[0] == L'.' )
        {
            _hkeyLM = HKEY_LOCAL_MACHINE;
        }
        else
        {
            //
            // The first thing about connecting to a remote registry is it must be
            // a MS network or else the RegConnectRegistry time out will
            // take at least 20 seconds.

            if ( !IsMsNetwork( pwszMachine ) )
            {
                THROW( CException( HRESULT_FROM_WIN32( RPC_S_SERVER_UNAVAILABLE ) ) );;
            }

            dwError = RegConnectRegistry( pwszMachine,
                                          HKEY_LOCAL_MACHINE,
                                          &_hkeyLM );

            if ( ERROR_SUCCESS != dwError )
                THROW( CException( HRESULT_FROM_WIN32( dwError ) ) );
        }
    }

    //
    // Open key to ContentIndex level
    //

    dwError = RegOpenKeyEx( _hkeyLM,
                            wcsRegAdminSubKey,
                            0,
                            fWrite ? KEY_ALL_ACCESS : KEY_READ,
                            &_hkeyContentIndex );

    if ( ERROR_SUCCESS != dwError )
    {
        if (!IsLocal())
        {
           RegCloseKey(_hkeyLM);
           _hkeyLM = hkeyInvalid;
        }
        THROW( CException( HRESULT_FROM_WIN32( dwError ) ) );
    }
}


//+---------------------------------------------------------------------------
//
//  Member:     CMachineAdmin::~CMachineAdmin, public
//
//  Synopsis:   Destructor
//
//  History:    02-Feb-97   KyleP       Created
//
//----------------------------------------------------------------------------

CMachineAdmin::~CMachineAdmin()
{
    if ( hkeyInvalid != _hkeyContentIndex )
        RegCloseKey( _hkeyContentIndex );

    if ( hkeyInvalid != _hkeyLM && !IsLocal() )
        RegCloseKey( _hkeyLM );
}

//+---------------------------------------------------------------------------
//
//  Member:     CMachineAdmin::WaitForSvcStateChange, public
//
//  Synopsis:   Waits for svc state change
//
//  History:    20-Jan-99   KrishnaN       Created
//
//  Returns TRUE if state change is not pending. FALSE if time out.
//
//----------------------------------------------------------------------------

BOOL CMachineAdmin::WaitForSvcStateChange( SERVICE_STATUS *pss, int iSecs )
{
    BOOL fTransition = TRUE;
    int iSecsWaited = 0;
    do
    {
        QueryServiceStatus( _xSCCI.Get(), pss );
        fTransition = !(SERVICE_STOPPED == pss->dwCurrentState ||
                        SERVICE_RUNNING == pss->dwCurrentState ||
                        SERVICE_PAUSED  == pss->dwCurrentState);
        
        if (fTransition)
        {
            Sleep (1000);   // one second
            iSecsWaited++;
        }
    }
    while ( fTransition && iSecsWaited < iSecs );

    return !fTransition;
}


//+---------------------------------------------------------------------------
//
//  Member:     CMachineAdmin::AddCatalog, public
//
//  Synopsis:   Add a new catalog to the registry
//
//  Arguments:  [pwszCatalog]      -- Name of catalog
//              [pwszDataLocation] -- Location of catalog (catalog.wci directory)
//
//  History:    02-Feb-97   KyleP       Created
//
//----------------------------------------------------------------------------


void CMachineAdmin::AddCatalog( WCHAR const * pwszCatalog,
                                WCHAR const * pwszDataLocation )
{
    if ( !_fWrite )
        THROW( CException( HRESULT_FROM_WIN32( ERROR_ACCESS_DENIED ) ) );

    //
    // Parameter validation.
    //

    if ( 0 == pwszCatalog ||
         0 == pwszDataLocation )
    {
        ciDebugOut(( DEB_ERROR, "CMachineAdmin::AddCatalog -- Null catalog name or location.\n" ));
        THROW( CException( HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER) ) );
    }

    ULONG cchCatalog = wcslen(pwszCatalog);
    ULONG cchDataLocation = wcslen(pwszDataLocation);

    if ( cchCatalog < 1 || cchCatalog > MAX_CAT_NAME ||
         cchDataLocation < 3 || cchDataLocation > MAX_CAT_PATH )
    {
        ciDebugOut(( DEB_ERROR,
                     "CMachineAdmin::AddCatalog -- Invalid catalog name or location length.\n" ));
        THROW( CException( HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER) ) );
    }


    //
    // Order may be important here, because as soon as a key has
    // been written, notification of the change may be received
    // by the content index.  So, first create the directory then
    // create the registry keys.
    //
    // I'd really like to add the keys in a transaction, but there
    // doesn't appear to be any registry support for transactions.
    //

    //
    // Step 1. Attempt to create the directory.
    //

    //
    // Make sure directory is on a local disk.
    //

    if ( L':' != pwszDataLocation[1] )
    {
        ciDebugOut(( DEB_ERROR, "CMachineAdmin::AddCatalog -- remote path specified.\n" ));
        THROW( CException( HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER) ) );
    }

    if ( IsSUBST( pwszDataLocation[0] ) )
    {
        ciDebugOut(( DEB_ERROR, "CMachineAdmin::AddCatalog -- SUBST drive specified.\n" ));
        THROW( CException( HRESULT_FROM_WIN32( ERROR_IS_SUBST_PATH ) ) );
    }

    WCHAR wcsRoot[] = L"?:\\";
    wcsRoot[0] = pwszDataLocation[0];

    if ( IsLocal() &&
         GetDriveType( wcsRoot ) != DRIVE_FIXED &&
         GetDriveType( wcsRoot ) != DRIVE_REMOVABLE )
    {
        ciDebugOut(( DEB_ERROR, "CMachineAdmin::AddCatalog -- non-fixed drive specified.\n" ));
        THROW( CException( HRESULT_FROM_WIN32(ERROR_INVALID_DRIVE) ) );
    }

    TRY
    {
        CreateSubdirs( pwszDataLocation );

        //
        // Step 2. Create catalog key
        //

        HKEY hkeyCatalogs = hkeyInvalid;

        DWORD dwError = RegOpenKey( _hkeyLM,
                                    wcsRegCatalogsSubKey,
                                    &hkeyCatalogs );

        if ( ERROR_SUCCESS != dwError )
        {
            ciDebugOut(( DEB_ERROR, "Error %d opening catalogs.\n", dwError ));
            THROW( CException( HRESULT_FROM_WIN32( dwError ) ) );
        }

        SRegKey xkeyCatalogs( hkeyCatalogs );

        HKEY hkeyNewCatalog;
        DWORD dwDisposition;

        dwError = RegCreateKeyEx( hkeyCatalogs,         // Root
                                  pwszCatalog,          // Sub key
                                  0,                    // Reserved
                                  0,                    // Class
                                  0,                    // Flags
                                  KEY_ALL_ACCESS,       // Access
                                  0,                    // Security
                                  &hkeyNewCatalog,      // Handle
                                  &dwDisposition );     // Disposition

        if ( ERROR_SUCCESS != dwError )
        {
            ciDebugOut(( DEB_ERROR, "Error %d creating catalog in registry.\n", dwError ));
            THROW( CException( HRESULT_FROM_WIN32( dwError ) ) );
        }

        SRegKey xkeyNewCatalog( hkeyNewCatalog );

        if ( REG_CREATED_NEW_KEY != dwDisposition )
        {
            ciDebugOut(( DEB_ERROR, "Catalog being created already exists in registry.\n" ));
            THROW( CException( HRESULT_FROM_WIN32( ERROR_ALREADY_EXISTS ) ) );
        }

        HKEY hkeyScopes;

        dwError = RegCreateKeyEx( hkeyNewCatalog,    // Root
                                  wcsCatalogScopes,  // Sub key
                                  0,                 // Reserved
                                  0,                 // Class
                                  0,                 // Flags
                                  KEY_ALL_ACCESS,    // Access
                                  0,                 // Security
                                  &hkeyScopes,       // Handle
                                  &dwDisposition );  // Disposition

        if ( ERROR_SUCCESS != dwError )
        {
            ciDebugOut(( DEB_ERROR, "Error %d creating catalog scope in registry.\n", dwError ));
            THROW( CException( HRESULT_FROM_WIN32( dwError ) ) );
        }

        RegCloseKey( hkeyScopes );

        //
        // Step 3. Set data location and default catalog attributes.
        //

        dwError = RegSetValueEx( hkeyNewCatalog,           // Key
                                 wcsCatalogLocation,       // Name
                                 0,                        // Reserved
                                 REG_SZ,                   // Type
                                 (BYTE *)pwszDataLocation, // Value
                                 (1 + wcslen(pwszDataLocation) ) * sizeof(WCHAR) );

        if ( ERROR_SUCCESS != dwError )
        {
            ciDebugOut(( DEB_ERROR, "Error %d creating catalog location in registry.\n", dwError ));
            THROW( CException( HRESULT_FROM_WIN32( dwError ) ) );
        }

        DWORD dwDefaultValue = 0;

        dwError = RegSetValueEx( hkeyNewCatalog,           // Key
                                 wcsIsIndexingW3Roots,     // Name
                                 0,                        // Reserved
                                 REG_DWORD,                // Type
                                 (BYTE *)&dwDefaultValue,  // Value
                                 sizeof DWORD );

        if ( ERROR_SUCCESS != dwError )
        {
            ciDebugOut(( DEB_ERROR, "Error %d creating IsIndexingW3Roots in registry.\n", dwError ));
            THROW( CException( HRESULT_FROM_WIN32( dwError ) ) );
        }


        dwError = RegSetValueEx( hkeyNewCatalog,           // Key
                                 wcsIsIndexingNNTPRoots,   // Name
                                 0,                        // Reserved
                                 REG_DWORD,                // Type
                                 (BYTE *)&dwDefaultValue,  // Value
                                 sizeof DWORD );

        if ( ERROR_SUCCESS != dwError )
        {
            ciDebugOut(( DEB_ERROR, "Error %d creating IsIndexingNNTPRoots in registry.\n", dwError ));
            THROW( CException( HRESULT_FROM_WIN32( dwError ) ) );
        }
    }
    CATCH( CException, e )
    {
        ciDebugOut(( DEB_ERROR, "Caught exception 0x%x in CMachineAdmin::AddCatalog.\n", e.GetErrorCode() ));

        //
        // Remove subdirectory, but only if empty.
        //

        RemoveDirectory( pwszDataLocation );

        RETHROW();
    }
    END_CATCH
}

//+---------------------------------------------------------------------------
//
//  Member:     CMachineAdmin::RemoveCatalog, public
//
//  Synopsis:   Removes a catalog from the registry (and maybe the data)
//
//  Arguments:  [pwszCatalog] -- Catalog to remove
//              [fRemoveData] -- TRUE --> remove data (catalog.wci directory)
//
//  History:    02-Feb-97   KyleP       Created
//
//----------------------------------------------------------------------------

void CMachineAdmin::RemoveCatalog( WCHAR const * pwszCatalog,
                                   BOOL fRemoveData )
{
    if ( !_fWrite )
        THROW( CException( HRESULT_FROM_WIN32( ERROR_ACCESS_DENIED ) ) );

    if ( fRemoveData && !IsCIStopped() )
    {
        ciDebugOut(( DEB_ERROR, "RemoveCatalog() Failed, CiSvc must be stopped\n" ));

        THROW( CException(E_ABORT) );
    }

    //
    // Before we delete, be sure to get the path to the metadata.
    //

    XGrowable<WCHAR> xwcsLocation;
    XPtr<CCatalogAdmin> xCatAdmin( QueryCatalogAdmin( pwszCatalog ) );

    if ( IsLocal() )
    {
        xwcsLocation.SetSize( wcslen(xCatAdmin->GetLocation()) + sizeof(wcsCatalogDotWCI)/sizeof(WCHAR) + 1 );

        wcscpy( xwcsLocation.Get(), xCatAdmin->GetLocation() );
        wcscat( xwcsLocation.Get(), wcsCatalogDotWCI );
    }
    else
    {
        unsigned ccMachName = wcslen( _xwcsMachName.Get() );
        unsigned ccCat = wcslen( xCatAdmin->GetLocation() );

        xwcsLocation.SetSize( ccMachName + ccCat + sizeof(wcsCatalogDotWCI)/sizeof(WCHAR) + 6 );

        xwcsLocation[0] = L'\\';
        xwcsLocation[1] = L'\\';
        RtlCopyMemory( xwcsLocation.Get() + 2, _xwcsMachName.Get(), ccMachName * sizeof(WCHAR) );
        xwcsLocation[2 + ccMachName] = L'\\';

        wcscpy( xwcsLocation.Get() + 3 + ccMachName, xCatAdmin->GetLocation() );

        Win4Assert( xwcsLocation[4 + ccMachName] == L':' );
        xwcsLocation[4 + ccMachName] = L'$';

        wcscat( xwcsLocation.Get(), wcsCatalogDotWCI );
    }

    xCatAdmin.Free();

    //
    // Now, delete the keys.
    //

    HKEY hkeyCatalogs = hkeyInvalid;

    DWORD dwError = RegOpenKey( _hkeyLM,
                                wcsRegCatalogsSubKey,
                                &hkeyCatalogs );

    if ( ERROR_SUCCESS != dwError )
    {
        ciDebugOut(( DEB_ERROR, "Error %d opening catalogs.\n", dwError ));
        THROW( CException( HRESULT_FROM_WIN32( dwError ) ) );
    }

    SRegKey xkeyCatalogs( hkeyCatalogs );

    {
        HKEY hkeyCatalog;

        DWORD dwError = RegOpenKey( hkeyCatalogs,
                                    pwszCatalog,
                                    &hkeyCatalog );

        if ( ERROR_SUCCESS != dwError )
        {
            ciDebugOut(( DEB_ERROR, "Error %d opening catalog.\n", dwError ));
            THROW( CException( HRESULT_FROM_WIN32( dwError ) ) );
        }

        SRegKey xkeyCatalog( hkeyCatalog );

        dwError = RegDeleteKey( hkeyCatalog, wcsCatalogScopes );

        if ( ERROR_SUCCESS != dwError )
        {
            ciDebugOut(( DEB_ERROR, "Error %d deleting scopes.\n", dwError ));
            THROW( CException( HRESULT_FROM_WIN32( dwError ) ) );
        }

        dwError = RegDeleteKey( hkeyCatalog, wcsCatalogProperties );

        if ( ERROR_SUCCESS != dwError && ERROR_FILE_NOT_FOUND != dwError )
        {
            ciDebugOut(( DEB_ERROR, "Error %d deleting properties.\n", dwError ));
            THROW( CException( HRESULT_FROM_WIN32( dwError ) ) );
        }
    }

    dwError = RegDeleteKey( hkeyCatalogs, pwszCatalog );

    if ( ERROR_SUCCESS != dwError )
    {
        ciDebugOut(( DEB_ERROR, "Error %d deleting catalog.\n", dwError ));
        THROW( CException( HRESULT_FROM_WIN32( dwError ) ) );
    }

    //
    // And delete the metadata, if requested.
    //

    if ( fRemoveData )
    {
        dwError = Delnode( xwcsLocation.Get() );

        if ( ERROR_SUCCESS != dwError )
        {
            ciDebugOut(( DEB_ERROR, "Error %d deleting catalog data.\n", dwError ));
            THROW( CException( HRESULT_FROM_WIN32( dwError ) ) );
        }
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CMachineAdmin::RemoveCatalogFiles, public
//
//  Synopsis:   Removes a catalog from the registry (and maybe the data)
//
//  Arguments:  [pwszCatalog] -- Catalog where to remove the files
//
//  History:    16-Sep-98   KrishnaN       Created
//
//----------------------------------------------------------------------------

void CMachineAdmin::RemoveCatalogFiles( WCHAR const * pwszCatalog )
{
    if ( !_fWrite )
        THROW( CException( HRESULT_FROM_WIN32( ERROR_ACCESS_DENIED ) ) );

    if ( !IsCIStopped() )
    {
        ciDebugOut(( DEB_ERROR, "RemoveCatalogFiles() Failed, CiSvc must be stopped\n" ));

        THROW( CException(E_ABORT) );
    }

    //
    // Before we delete, be sure to get the path to the metadata.
    //

    XGrowable<WCHAR> xwcsLocation;

    XPtr<CCatalogAdmin> xCatAdmin( QueryCatalogAdmin( pwszCatalog ) );

    if ( IsLocal() )
    {
        xwcsLocation.SetSize( wcslen(xCatAdmin->GetLocation()) + sizeof(wcsCatalogDotWCI)/sizeof(WCHAR) + 1 );

        wcscpy( xwcsLocation.Get(), xCatAdmin->GetLocation() );
        wcscat( xwcsLocation.Get(), wcsCatalogDotWCI );
    }
    else
    {
        unsigned ccMachName = wcslen( _xwcsMachName.Get() );
        unsigned ccCat = wcslen( xCatAdmin->GetLocation() );

        xwcsLocation.SetSize( ccMachName + ccCat + sizeof wcsCatalogDotWCI/sizeof(WCHAR) + 6 );

        xwcsLocation[0] = L'\\';
        xwcsLocation[1] = L'\\';
        RtlCopyMemory( xwcsLocation.Get() + 2,
                       _xwcsMachName.Get(),
                       ccMachName * sizeof(WCHAR) );
        xwcsLocation[2 + ccMachName] = L'\\';

        RtlCopyMemory( xwcsLocation.Get() + 3 + ccMachName,
                       xCatAdmin->GetLocation(),
                       ccCat * sizeof(WCHAR) );

        Win4Assert( xwcsLocation[4 + ccMachName] == L':' );
        xwcsLocation[4 + ccMachName] = L'$';

        RtlCopyMemory( xwcsLocation.Get() + 3 + ccMachName + ccCat,
                       wcsCatalogDotWCI,
                       sizeof wcsCatalogDotWCI );
    }

    // Preserve the directory. Delete only the files.
    DWORD dwError = Delnode( xwcsLocation.Get(), FALSE );

    if ( ERROR_SUCCESS != dwError )
    {
        ciDebugOut(( DEB_ERROR, "Error %d deleting catalog files.\n", dwError ));
        THROW( CException( HRESULT_FROM_WIN32( dwError ) ) );
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CMachineAdmin::QueryCatalogEnum, public
//
//  Returns:    Catalog enumerator
//
//  History:    02-Feb-97   KyleP       Created
//
//----------------------------------------------------------------------------

CCatalogEnum * CMachineAdmin::QueryCatalogEnum()
{
    return new CCatalogEnum( _hkeyLM, _xwcsMachName.Get(), _fWrite );
}

//+---------------------------------------------------------------------------
//
//  Member:     CMachineAdmin::QueryCatalogAdmin, public
//
//  Arguments:  [pwszCatalog] -- Catalog name
//
//  Returns:    Catalog admin object for [pwszCatalog]
//
//  History:    02-Feb-97   KyleP       Created
//
//----------------------------------------------------------------------------

CCatalogAdmin * CMachineAdmin::QueryCatalogAdmin( WCHAR const * pwszCatalog )
{
    return new CCatalogAdmin( _hkeyLM, _xwcsMachName.Get(), pwszCatalog, _fWrite );
}

//+---------------------------------------------------------------------------
//
//  Member:     CMachineAdmin::GetDWORDParam, public
//
//  Synopsis:   Retrieves global value of named parameter.
//
//  Arguments:  [pwszParam] -- Parameter to fetch
//              [dwValue]   -- Value returned here
//
//  Returns:    TRUE if parameter exists and was fetched.
//
//  History:    02-Feb-97   KyleP       Created
//
//----------------------------------------------------------------------------

BOOL CMachineAdmin::GetDWORDParam( WCHAR const * pwszParam, DWORD & dwValue )
{
    DWORD dwType;
    DWORD dwSize = sizeof(dwValue);

    DWORD dwError = RegQueryValueEx( _hkeyContentIndex,  // Key handle
                                     pwszParam,          // Name
                                     0,                  // Reserved
                                     &dwType,            // Datatype
                                     (BYTE *)&dwValue,   // Data returned here
                                     &dwSize );          // Size of data

    return ( ERROR_SUCCESS == dwError && REG_DWORD == dwType );
}

//+---------------------------------------------------------------------------
//
//  Member:     CMachineAdmin::SetDWORDParam, public
//
//  Synopsis:   Sets global value of named parameter.
//
//  Arguments:  [pwszParam] -- Parameter to set
//              [dwValue]   -- New value
//
//  History:    02-Feb-97   KyleP       Created
//
//----------------------------------------------------------------------------

void CMachineAdmin::SetDWORDParam( WCHAR const * pwszParam, DWORD dwValue )
{

    DWORD dwError = RegSetValueEx( _hkeyContentIndex,  // Key
                                   pwszParam,          // Name
                                   0,                  // Reserved
                                   REG_DWORD,          // Type
                                   (BYTE *)&dwValue,    // Value
                                   sizeof(dwValue) );  // Size of value

    if ( ERROR_SUCCESS != dwError )
    {
        THROW( CException( HRESULT_FROM_WIN32( dwError ) ) );
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CMachineAdmin::GetSZParam, public
//
//  Synopsis:   Retrieves global value of named parameter.
//
//  Arguments:  [pwszParam] -- Parameter to fetch
//              [pwszValue] -- Value returned here
//              [cbLen    ] -- length in bytes of passed in buffer
//
//  Returns:    TRUE if parameter exists and was fetched.
//
//  History:    3-30-98 mohamedn    created
//
//----------------------------------------------------------------------------

BOOL CMachineAdmin::GetSZParam( WCHAR const * pwszParam, WCHAR * pwszValue, DWORD cbLen )
{
    DWORD dwType;

    DWORD dwError = RegQueryValueEx( _hkeyContentIndex,  // Key handle
                                     pwszParam,          // Name
                                     0,                  // Reserved
                                     &dwType,            // Datatype
                                     (BYTE *)pwszValue,   // Data returned here
                                     &cbLen );           // Size of data

    return ( ERROR_SUCCESS == dwError && REG_SZ == dwType );
}

//+---------------------------------------------------------------------------
//
//  Member:     CMachineAdmin::SetSZParam, public
//
//  Synopsis:   Sets global value of named parameter.
//
//  Arguments:  [pwszParam] -- Parameter to set
//              [pwszValue] -- New value
//              [cbLen]     -- length in bytes of passed in buffer
//
//  History:    03-30-98    mohamedn    created
//
//----------------------------------------------------------------------------

void CMachineAdmin::SetSZParam( WCHAR const * pwszParam, WCHAR const * pwszValue, DWORD cbLen )
{
    DWORD dwError = RegSetValueEx( _hkeyContentIndex,  // Key
                                   pwszParam,          // Name
                                   0,                  // Reserved
                                   REG_SZ,             // Type
                                   (BYTE *)pwszValue,  // Value
                                   cbLen );            // Size of value in bytes

    if ( ERROR_SUCCESS != dwError )
    {
        THROW( CException( HRESULT_FROM_WIN32( dwError ) ) );
    }
}

BOOL CMachineAdmin::RegisterForNotification( HANDLE hEvent )
{
    return FALSE;
}

//+---------------------------------------------------------------------------
//
//  Member:     CMachineAdmin::CreateSubdirs, private
//
//  Synopsis:   Helper to create nested subdirectories and catalog.wci
//
//  Arguments:  [pwszPath] -- Path up to but not including catalog.wci
//
//  History:    02-Feb-97   KyleP       Created
//
//----------------------------------------------------------------------------

WCHAR const * pwszSysVolInfo = L"System Volume Information";

void CMachineAdmin::CreateSubdirs( WCHAR const * pwszPath )
{
    XGrowable<WCHAR> xwcsTemp;

    //
    // Just don't accept paths to a catalog longer than MAX_PATH.  Take
    // into account that we will append two 8.3 filenames onto the path.
    //

    unsigned cc = wcslen( pwszPath );
    unsigned ccBegin = 3;

    if ( cc > MAX_CAT_PATH )
    {
        ciDebugOut(( DEB_ERROR, "CreateSubdirs: Path too deep\n" ));
        THROW( CException( HRESULT_FROM_WIN32(ERROR_BAD_PATHNAME) ) );
    }

    if ( IsLocal() )
    {
        xwcsTemp.SetSize( cc + wcslen(wcsCatalogDotWCI) + 4 );
        RtlCopyMemory( xwcsTemp.Get(), pwszPath, (cc + 1) * sizeof(WCHAR) );

        //
        // More error checking.
        //

        Win4Assert( xwcsTemp[1] == L':' );

        if ( 0 == xwcsTemp[2] )
        {
            xwcsTemp[2] = L'\\';
            xwcsTemp[3] = 0;
        }
    }
    else
    {
        //
        // For the non-local case, the best we can do is try to use the $ admin
        // shares to create directories.
        //

        unsigned ccMachName = wcslen( _xwcsMachName.Get() );

        xwcsTemp.SetSize( cc + ccMachName + wcslen(wcsCatalogDotWCI) + 4 );

        xwcsTemp[0] = L'\\';
        xwcsTemp[1] = L'\\';

        RtlCopyMemory( xwcsTemp.Get() + 2, _xwcsMachName.Get(), ccMachName * sizeof(WCHAR) );

        xwcsTemp[ccMachName + 2] = L'\\';

        RtlCopyMemory( xwcsTemp.Get() + 2 + ccMachName + 1, pwszPath, (cc + 1) * sizeof(WCHAR) );

        //
        // More error checking.
        //

        Win4Assert( xwcsTemp[2 + ccMachName + 2] == L':' );

        xwcsTemp[2 + ccMachName + 2] = L'$';

        if ( 0 == xwcsTemp[2 + ccMachName + 3] )
        {
            xwcsTemp[2 + ccMachName + 3] = L'\\';
            xwcsTemp[2 + ccMachName + 4] = 0;
        }

        ccBegin = 2 + ccMachName + 3 + 1;   // "\\<machname>\c$\" --> 2 + ccMachName + 3
                                            //   + 1 to skip trying to create share itself.
    }

    //
    // Loop through and try to create every level of directory.
    // ERROR_ALREADY_EXISTS is a legal error.
    //

    WCHAR * pwcsEnd = xwcsTemp.Get() + ccBegin;

    while ( *pwcsEnd )
    {
        //
        // Find next backslash
        //

        for ( ; *pwcsEnd && *pwcsEnd != L'\\'; pwcsEnd++ )
            continue;

        //
        // Ensure that the slash appended below is followed by a null.
        //

        if ( *pwcsEnd == 0 )
            *(pwcsEnd + 1) = 0;

        *pwcsEnd = 0;

        if ( !CreateDirectory( xwcsTemp.Get(), 0 ) )
        {
            if ( GetLastError() != ERROR_ALREADY_EXISTS )
            {
                ciDebugOut(( DEB_ERROR, "CreateSubdirs: Error %d from CreateDirectory.\n",
                              GetLastError() ));
                THROW( CException() );
            }
        }
        else
        {
            //
            // If this directory was the "System Volume Information" folder,
            // we need to set its ACL and make it Hidden+System.
            //
            if ( _wcsicmp( xwcsTemp.Get() + ccBegin, pwszSysVolInfo ) == 0 )
            {
                SetFileAttributes( xwcsTemp.Get(),
                               FILE_ATTRIBUTE_HIDDEN | FILE_ATTRIBUTE_SYSTEM );

                if ( !ApplySystemOnlyAcl( xwcsTemp.Get() ) )
                {
                    ciDebugOut(( DEB_ERROR,
                                 "Can't apply system-only ACL to directory '%ws'\n",
                                 xwcsTemp.Get() ));
                    THROW( CException( HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER ) ) );
                }
            }
        }

        *pwcsEnd = L'\\';
        pwcsEnd++;
    }

    //
    // Create the final level: catalog.wci
    //

    Win4Assert( xwcsTemp[ wcslen(xwcsTemp.Get()) - 1 ] == L'\\' );

    wcscat( xwcsTemp.Get(), &wcsCatalogDotWCI[1] );

    if ( !CreateDirectory( xwcsTemp.Get(), 0 ) )
    {
        if ( GetLastError() != ERROR_ALREADY_EXISTS )
        {
            ciDebugOut(( DEB_ERROR, "CreateSubdirs: Error %d from CreateDirectory.\n",
                          GetLastError() ));
            THROW( CException() );
        }
    }

    // Make the directory hidden and not indexed
    // Setting the not content indexed bit on a FAT directory has no effect.
    // The bit is silently ignored by FAT.

    SetFileAttributes( xwcsTemp.Get(),
                       GetFileAttributes( xwcsTemp.Get() ) |
                       FILE_ATTRIBUTE_HIDDEN |
                       FILE_ATTRIBUTE_NOT_CONTENT_INDEXED );

    // Apply system/admin ACL to the directory

    if ( !ApplySystemAcl( xwcsTemp.Get() ) )
    {
        ciDebugOut(( DEB_ERROR,
                     "Can't apply admin ACL to catalog in '%ws'\n",
                     xwcsTemp.Get() ));
        THROW( CException( HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER ) ) );
    }
} //CreateSubdirs

//+---------------------------------------------------------------------------
//
//  Member:     CCatalogEnum::CCatalogEnum, public
//
//  Synopsis:   Creates catalog enumeration object
//
//  Arguments:  [hkeyLM]      -- HKEY_LOCAL_MACHINE (or remote equivalent)
//              [pwcsMachine] -- Machine name
//              [fWrite]      -- TRUE for writable access
//
//  History:    02-Feb-97   KyleP       Created
//
//----------------------------------------------------------------------------

CCatalogEnum::CCatalogEnum( HKEY hkeyLM, WCHAR const * pwcsMachine, BOOL fWrite )
        : _hkeyLM( hkeyLM ),
          _hkeyCatalogs( hkeyInvalid ),
          _dwIndex( 0 ),
          _fWrite( fWrite )
{
    //
    // Don't have to error check length because we trust the caller.
    //

    if ( 0 == pwcsMachine )
        _xawcCurrentMachine[0] = 0;
    else
    {
        unsigned cc = wcslen(pwcsMachine) + 1;

        _xawcCurrentMachine.SetSize( cc );

        RtlCopyMemory( _xawcCurrentMachine.Get(), pwcsMachine, cc * sizeof(WCHAR) );
    }

    //
    // Open catalog section of registry
    //

    DWORD dwError = RegOpenKeyEx( hkeyLM,
                                  wcsRegCatalogsSubKey,
                                  0,
                                  fWrite ? KEY_ALL_ACCESS : KEY_READ,
                                  &_hkeyCatalogs );

    if ( ERROR_SUCCESS != dwError )
        THROW( CException( HRESULT_FROM_WIN32( dwError ) ) );
}

//+---------------------------------------------------------------------------
//
//  Member:     CCatalogEnum::~CCatalogEnum, public
//
//  Synopsis:   Destructs a catalog enumerator object
//
//  History:    3-Aug-98   dlee       Created
//
//----------------------------------------------------------------------------

CCatalogEnum::~CCatalogEnum()
{
    if ( hkeyInvalid != _hkeyCatalogs )
        RegCloseKey( _hkeyCatalogs );
}

//+---------------------------------------------------------------------------
//
//  Member:     CCatalogEnum::QueryCatalogAdmin, public
//
//  Synopsis:   Creates catalog admin object for current catalog
//
//  Returns:    Catalog admin object
//
//  History:    02-Feb-97   KyleP   Created
//
//----------------------------------------------------------------------------

CCatalogAdmin * CCatalogEnum::QueryCatalogAdmin()
{
    return new CCatalogAdmin( _hkeyLM,
                              (0 == _xawcCurrentMachine[0]) ? 0 : _xawcCurrentMachine.Get(),
                              _awcCurrentCatalog,
                              _fWrite );
}

//+---------------------------------------------------------------------------
//
//  Member:     CCatalogEnum::Next, public
//
//  Synopsis:   Moves to next catalog
//
//  Returns:    FALSE for end-of-catalogs
//
//  History:    02-Feb-97   KyleP   Created
//
//----------------------------------------------------------------------------

BOOL CCatalogEnum::Next( )
{
    DWORD cwcName = sizeof( _awcCurrentCatalog ) / sizeof( _awcCurrentCatalog[0] );
    FILETIME ftUnused;

    DWORD dwError = RegEnumKeyEx( _hkeyCatalogs,      // handle of key to enumerate
                                  _dwIndex,           // index of subkey to enumerate
                                  _awcCurrentCatalog, // address of buffer for subkey name
                                  &cwcName,           // address for size of subkey buffer
                                  0,                  // reserved
                                  0,                  // address of buffer for class string
                                  0,                  // address for size of class buffer
                                  &ftUnused );        // address for time key last written to

    _dwIndex++;

    if ( ERROR_SUCCESS == dwError )
        return TRUE;
    else if ( ERROR_NO_MORE_ITEMS != dwError )
    {
        THROW( CException( HRESULT_FROM_WIN32( dwError ) ) );
    }

    return FALSE;
}

//+---------------------------------------------------------------------------
//
//  Member:     CCatalogAdmin::CCatalogAdmin, public
//
//  Synopsis:   Constructor for catalog admin object
//
//  Arguments:  [hkeyLM]      -- HKEY_LOCAL_MACHINE (or remote equivalent)
//              [pwszMachine] -- Name of machine
//              [pwszCatalog] -- Name of catalog
//
//  History:    02-Feb-97   KyleP   Created
//
//----------------------------------------------------------------------------

CCatalogAdmin::CCatalogAdmin( HKEY hkeyLM,
                              WCHAR const * pwszMachine,
                              WCHAR const * pwszCatalog,
                              BOOL fWrite )
        : _hkeyCatalog( hkeyInvalid ),
          _fWrite( fWrite ),
#pragma warning( disable : 4355 )               // this used in base initialization
          _catStateInfo(*this)
#pragma warning( default : 4355 )               // this used in base initialization

{
    if ( 0 == pwszMachine )
    {
        _xwcsMachName[0] = 0;
    }
    else
    {
        unsigned cc = wcslen( pwszMachine ) + 1;

        _xwcsMachName.SetSize( cc );

        RtlCopyMemory( _xwcsMachName.Get(), pwszMachine, cc * sizeof(WCHAR) );
    }

    unsigned cc = wcslen( pwszCatalog );

    if ( cc >= sizeof(_wcsCatName)/sizeof(_wcsCatName[0]) )
    {
        ciDebugOut(( DEB_ERROR, "Catalog name too big: %ws.\n", pwszCatalog ));
        THROW( CException( HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER ) ) );
    }

    wcscpy( _wcsCatName, pwszCatalog );

    XArray<WCHAR> xBuf( wcslen(wcsRegCatalogsSubKey) + MAX_PATH + 1 );
    
    RtlCopyMemory( xBuf.GetPointer(), wcsRegCatalogsSubKey, sizeof(wcsRegCatalogsSubKey) );
    xBuf[ sizeof(wcsRegCatalogsSubKey) / sizeof(WCHAR) - 1] = L'\\';
    wcscpy( xBuf.GetPointer() + sizeof(wcsRegCatalogsSubKey) / sizeof(WCHAR), pwszCatalog );
    
    DWORD dwError = RegOpenKeyEx( hkeyLM,
                                  xBuf.GetPointer(),
                                  0,
                                  fWrite ? KEY_ALL_ACCESS : KEY_READ,
                                  &_hkeyCatalog );

    if ( ERROR_SUCCESS != dwError )
    {
        ciDebugOut(( DEB_ERROR, "Error %d opening %ws\n", dwError, xBuf.GetPointer() ));
        THROW( CException( HRESULT_FROM_WIN32( dwError ) ) );
    }

    // Retrieve and remember the drive hosting the catalog
    WCHAR const *pwcsLocation = GetLocation();
    if (0 == pwcsLocation)
    {
        RegCloseKey( _hkeyCatalog );
        _hkeyCatalog = hkeyInvalid;

        ciDebugOut(( DEB_ERROR, "No location available for catalog %ws on machine %ws\n",
                     pwszCatalog, pwszMachine ));
        THROW( CException( E_UNEXPECTED ) );
    }
    _wsplitpath(pwcsLocation, _wcsDriveOfLocation, 0, 0, 0);
}

//+---------------------------------------------------------------------------
//
//  Member:     CCatalogAdmin::~CCatalogAdmin, public
//
//  Synopsis:   Destructor
//
//  History:    02-Feb-97   KyleP   Created
//
//----------------------------------------------------------------------------

CCatalogAdmin::~CCatalogAdmin()
{
    if ( hkeyInvalid != _hkeyCatalog )
        RegCloseKey( _hkeyCatalog );
}

//+---------------------------------------------------------------------------
//
//  Member:     CCatalogAdmin::AddScope, public
//
//  Synopsis:   Adds scope to catalog
//
//  Arguments:  [pwszScope]    -- Path
//              [pwszAlias]    -- Alias (for remote UNC access). Null allowed.
//              [fExclude]     -- TRUE for exclude scope
//              [pwszLogon]    -- Logon name (for UNC paths). Null allowed.
//              [pwszPassword] -- Password (for UNC paths). Null allowed.
//
//  History:    02-Feb-97   KyleP   Created
//
//----------------------------------------------------------------------------

void CCatalogAdmin::AddScope( WCHAR const * pwszScope,
                              WCHAR const * pwszAlias,
                              BOOL          fExclude,
                              WCHAR const * pwszLogon,
                              WCHAR const * pwszPassword )
{
    if ( 0 == pwszScope )
        THROW( CException( QUERY_E_INVALID_DIRECTORY ) );

    SCODE sc = IsScopeValid(pwszScope, wcslen(pwszScope), IsLocal() );
    if (FAILED(sc))
        THROW( CException( sc ) );

    // Only check if the scope is on a remover device for local catalogs
    if ( IsLocal() )
    {
        WCHAR wszScopeDrive[_MAX_DRIVE];
        _wsplitpath(pwszScope, wszScopeDrive, NULL, NULL, NULL);
        UINT uiDriveType = GetDriveType(wszScopeDrive);

        if (DRIVE_CDROM == uiDriveType ||
            ( DRIVE_REMOVABLE == uiDriveType &&
              _wcsicmp(wszScopeDrive, _wcsDriveOfLocation) ))
            THROW( CException( QUERY_E_DIR_ON_REMOVABLE_DRIVE ) );
    }

    DWORD dwDisposition;
    HKEY  hkeyScopes;

    DWORD dwError = RegCreateKeyEx( _hkeyCatalog,      // Root
                                    wcsCatalogScopes,  // Sub key
                                    0,                 // Reserved
                                    0,                 // Class
                                    0,                 // Flags
                                    KEY_ALL_ACCESS,    // Access
                                    0,                 // Security
                                    &hkeyScopes,       // Handle
                                    &dwDisposition );  // Disposition

    if ( ERROR_SUCCESS != dwError )
    {
        ciDebugOut(( DEB_ERROR, "Error %d opening scopes registry key.\n", dwError ));
        THROW( CException( HRESULT_FROM_WIN32( dwError ) ) );
    }

    SRegKey xkeyScopes( hkeyScopes );

    XGrowable<WCHAR>    xLine;

    AssembleScopeValueString( pwszAlias, fExclude, pwszLogon, xLine );

    WCHAR const * pwszTemp = xLine.Get();

    //
    // Set the new scope.
    //

    dwError = RegSetValueEx( hkeyScopes,           // Key
                             pwszScope,            // Value name
                             0,                    // Reserved
                             REG_SZ,               // Type
                             (BYTE *)pwszTemp,     // Data
                             ( (1 + wcslen(pwszTemp)) * sizeof WCHAR ) ); // Size (in bytes)

    if ( ERROR_SUCCESS != dwError )
    {
        ciDebugOut(( DEB_ERROR, "Error %d adding scope %ws.\n",
                     dwError, pwszScope ));
        THROW( CException( HRESULT_FROM_WIN32( dwError ) ) );
    }

    //
    // If we need to store a password, do so.  The password can be
    // an empty string (L"")!
    //

    if ( 0 != pwszLogon && 0 != pwszPassword)
    {
        AddOrReplaceSecret( pwszLogon, pwszPassword );
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CCatalogAdmin::AddCachedProperty, public
//
//  Synopsis:   Adds a cached property to catalog
//
//  Arguments:  [fps]           -- Property
//              [vt]            -- Data type
//              [cb]            -- Size of data in cache
//              [dwStoreLevel]  -- Property storage level
//              [fModifiable]   -- Can property metadata be modified once set?
//
//  History:    08-Dec-97   KrishnaN   Created
//
//----------------------------------------------------------------------------

void CCatalogAdmin::AddCachedProperty( CFullPropSpec const & fps,
                                       ULONG vt,
                                       ULONG cb,
                                       DWORD dwStoreLevel,
                                       BOOL fModifiable)
{
    DWORD dwDisposition;
    HKEY  hkeyProperties;

    DWORD dwError = RegCreateKeyEx( _hkeyCatalog,      // Root
                                    wcsCatalogProperties,  // Sub key
                                    0,                 // Reserved
                                    0,                 // Class
                                    0,                 // Flags
                                    KEY_ALL_ACCESS,    // Access
                                    0,                 // Security
                                    &hkeyProperties,       // Handle
                                    &dwDisposition );  // Disposition

    if ( ERROR_SUCCESS != dwError )
    {
        ciDebugOut(( DEB_ERROR, "Error %d opening properties registry key.\n", dwError ));
        THROW( CException( HRESULT_FROM_WIN32( dwError ) ) );
    }

    SRegKey xkeyProperties( hkeyProperties );

    // build up the property value/data
    CBuildRegistryProperty PropBuild( fps, vt, cb, dwStoreLevel, fModifiable);

    // Make an entry for the property as a value.
    dwError = RegSetValueEx( hkeyProperties,                  // Key
                             PropBuild.GetValue(),      // Name
                             0,                         // Reserved
                             REG_SZ,                    // Type
                             (BYTE *)PropBuild.GetData(), // Value
                             (1 + wcslen(PropBuild.GetData()) ) * sizeof(WCHAR) );
    if ( ERROR_SUCCESS != dwError )
    {
        ciDebugOut(( DEB_ERROR, "Error %d adding property %ws.\n",
                     dwError, PropBuild.GetValue() ));
        THROW( CException( HRESULT_FROM_WIN32( dwError ) ) );
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CCatalogAdmin::RemoveScope, public
//
//  Synopsis:   Remove scope from catalog
//
//  Arguments:  [pwcsPath] -- Directory to remove
//
//  History:    02-Feb-97   KyleP   Created
//
//----------------------------------------------------------------------------

void CCatalogAdmin::RemoveScope( WCHAR const * pwcsPath )
{
    if ( !_fWrite )
        THROW( CException( HRESULT_FROM_WIN32( ERROR_ACCESS_DENIED ) ) );

    HKEY hkeyScopes;

    DWORD dwError = RegOpenKey( _hkeyCatalog,
                                wcsCatalogScopes,
                                &hkeyScopes );

    if ( ERROR_SUCCESS != dwError )
    {
        ciDebugOut(( DEB_ERROR, "Error %d opening scopes registry key.\n", dwError ));
        THROW( CException( HRESULT_FROM_WIN32( dwError ) ) );
    }

    SRegKey xkeyScopes( hkeyScopes );

    //
    // Error check.  Can't remove virtual or shadow scopes.
    //


    {
        WCHAR awcScopeData[MAX_PATH];

        DWORD dwType;
        DWORD dwSize = sizeof awcScopeData;

        dwError = RegQueryValueEx( hkeyScopes,           // Key handle
                                   pwcsPath,             // Name
                                   0,                    // Reserved
                                   &dwType,              // Datatype
                                   (BYTE *)awcScopeData, // Data returned here
                                   &dwSize );            // Size of data

        if ( ERROR_SUCCESS != dwError )
        {
            ciDebugOut(( DEB_ERROR, "Error %d reading scope\n", dwError ));
            THROW( CException( HRESULT_FROM_WIN32( dwError ) ) );
        }

        CParseRegistryScope Parse( pwcsPath,
                                   dwType,
                                   awcScopeData,
                                   dwSize );

        if ( Parse.IsVirtualPlaceholder() || Parse.IsShadowAlias() )
        {
            ciDebugOut(( DEB_ERROR, "Attempt to delete virtual/shadow alias %ws\n", pwcsPath ));
            THROW( CException( E_INVALIDARG ) );
        }
    }

    dwError = RegDeleteValue( hkeyScopes, pwcsPath );

    if ( ERROR_SUCCESS != dwError )
    {
        ciDebugOut(( DEB_ERROR, "Error %d deleting scope\n", dwError ));
        THROW( CException( HRESULT_FROM_WIN32( dwError ) ) );
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CCatalogAdmin::GetLocation, public
//
//  Returns:    Location of catalog.wci directory
//
//  History:    02-Feb-97   KyleP   Created
//
//----------------------------------------------------------------------------

WCHAR const * CCatalogAdmin::GetLocation()
{
    DWORD dwType;
    DWORD dwSize = sizeof(_wcsLocation);

    DWORD dwError = RegQueryValueEx( _hkeyCatalog,          // Key handle
                                      wcsCatalogLocation,   // Name
                                      0,                    // Reserved
                                      &dwType,              // Datatype
                                      (BYTE *)_wcsLocation, // Data returned here
                                      &dwSize );            // Size of data

    if ( ERROR_SUCCESS != dwError || REG_SZ != dwType )
    {
        ciDebugOut(( DEB_ERROR, "Missing location (err = %d, type = %d)\n", dwError, dwType ));
        return 0;
    }

    return _wcsLocation;
}

//+---------------------------------------------------------------------------
//
//  Member:     CCatalogAdmin::IsStarted, public
//
//  Returns:    TRUE if catalog is active
//
//  History:    07-Jul-1998  KyleP  Created
//
//----------------------------------------------------------------------------

BOOL CCatalogAdmin::IsStarted()
{
    DWORD dwState;

    SCODE sc = SetCatalogState ( _wcsCatName,
                                 (0 == _xwcsMachName[0]) ? L"." : _xwcsMachName.Get(),
                                 CICAT_GET_STATE,
                                 &dwState );

    if ( FAILED(sc) )
    {
        ciDebugOut(( DEB_ERROR, "Error 0x%x from SetCatalogState( %ws, %ws )\n",
                     sc, _wcsCatName, (0 == _xwcsMachName[0]) ? L"." : _xwcsMachName.Get() ));
        THROW( CException(sc) )
    }

    return ( 0 != (dwState & CICAT_WRITABLE) );
}

//+---------------------------------------------------------------------------
//
//  Member:     CCatalogAdmin::IsStopped, public
//
//  Returns:    TRUE if catalog is not active
//
//  History:    07-Jul-1998  KyleP  Created
//
//----------------------------------------------------------------------------

BOOL CCatalogAdmin::IsStopped()
{
    DWORD dwState;

    SCODE sc = SetCatalogState ( _wcsCatName,
                                 (0 == _xwcsMachName[0]) ? L"." : _xwcsMachName.Get(),
                                 CICAT_GET_STATE,
                                 &dwState );

    if ( FAILED(sc) )
    {
        ciDebugOut(( DEB_ERROR, "Error 0x%x from SetCatalogState( %ws, %ws )\n", 
                     sc, _wcsCatName, (0 == _xwcsMachName[0]) ? L"." : _xwcsMachName.Get() ));
        THROW( CException(sc) )
    }

    return ( 0 != (dwState & CICAT_STOPPED) );
}

//+---------------------------------------------------------------------------
//
//  Member:     CCatalogAdmin::IsStopped, public
//
//  Returns:    TRUE if catalog is read-only
//
//  History:    07-Jul-1998  KyleP  Created
//
//----------------------------------------------------------------------------

BOOL CCatalogAdmin::IsPaused()
{
    DWORD dwState;

    SCODE sc = SetCatalogState ( _wcsCatName,
                                 (0 == _xwcsMachName[0]) ? L"." : _xwcsMachName.Get(),
                                 CICAT_GET_STATE,
                                 &dwState );

    if ( FAILED(sc) )
    {
        ciDebugOut(( DEB_ERROR, "Error 0x%x from SetCatalogState( %ws, %ws )\n", 
                     sc, _wcsCatName, (0 == _xwcsMachName[0]) ? L"." : _xwcsMachName.Get() ));
        THROW( CException(sc) )
    }

    return ( 0 != (dwState & CICAT_READONLY) );
}

//+---------------------------------------------------------------------------
//
//  Member:     CCatalogAdmin::Start, public
//
//  Synopsis:   Starts catalog
//
//  Returns:    TRUE
//
//  History:    06-Jul-1998   KyleP   Created
//
//----------------------------------------------------------------------------

BOOL CCatalogAdmin::Start()
{
    DWORD dwState;

    SCODE sc = SetCatalogState ( _wcsCatName,
                                 (0 == _xwcsMachName[0]) ? L"." : _xwcsMachName.Get(),
                                 CICAT_WRITABLE,
                                 &dwState );

    if ( FAILED(sc) )
    {
        ciDebugOut(( DEB_ERROR, "Error 0x%x from SetCatalogState( %ws, %ws )\n",
                     sc, _wcsCatName, (0 == _xwcsMachName[0]) ? L"." : _xwcsMachName.Get() ));
        THROW( CException(sc) )
    }

    return TRUE;
}

//+---------------------------------------------------------------------------
//
//  Member:     CCatalogAdmin::Stop, public
//
//  Synopsis:   Stops catalog
//
//  Returns:    TRUE
//
//  History:    06-Jul-1998   KyleP   Created
//
//----------------------------------------------------------------------------

BOOL CCatalogAdmin::Stop()
{
    DWORD dwState;

    SCODE sc = SetCatalogState ( _wcsCatName,
                                 (0 == _xwcsMachName[0]) ? L"." : _xwcsMachName.Get(),
                                 CICAT_STOPPED,
                                 &dwState );

    if ( FAILED(sc) )
    {
        ciDebugOut(( DEB_ERROR, "Error 0x%x from SetCatalogState( %ws, %ws )\n", 
                     sc, _wcsCatName, (0 == _xwcsMachName[0]) ? L"." : _xwcsMachName.Get() ));
        THROW( CException(sc) )
    }

    return TRUE;
}

//+---------------------------------------------------------------------------
//
//  Member:     CCatalogAdmin::Pause, public
//
//  Synopsis:   Pauses catalog
//
//  Returns:    TRUE
//
//  History:    06-Jul-1998   KyleP   Created
//
//----------------------------------------------------------------------------

BOOL CCatalogAdmin::Pause()
{
    DWORD dwState;

    SCODE sc = SetCatalogState ( _wcsCatName,
                                 (0 == _xwcsMachName[0]) ? L"." : _xwcsMachName.Get(),
                                 CICAT_READONLY,
                                 &dwState );

    if ( FAILED(sc) )
    {
        ciDebugOut(( DEB_ERROR, "Error 0x%x from SetCatalogState( %ws, %ws )\n", 
                     sc, _wcsCatName, (0 == _xwcsMachName[0]) ? L"." : _xwcsMachName.Get() ));
        THROW( CException(sc) )
    }

    return TRUE;
}

//+---------------------------------------------------------------------------
//
//  Member:     CCatalogAdmin::IsCatalogInactive, public
//
//  Returns:    Is the catalog inactive?
//
//  History:    29-Jan-98   KrishnaN   Created
//
//----------------------------------------------------------------------------

BOOL CCatalogAdmin::IsCatalogInactive()
{
    DWORD dwIsInactive;

    if ( GetDWORDParam( wcsCatalogInactive, dwIsInactive ) )
        return dwIsInactive;
    else
        return CI_CATALOG_INACTIVE_DEFAULT;
}

//+---------------------------------------------------------------------------
//
//  Member:     CCatalogAdmin::GetDWORDParam, public
//
//  Synopsis:   Retrieves catalog-specific value of named parameter.
//
//  Arguments:  [pwszParam] -- Parameter to fetch
//              [dwValue]   -- Value returned here
//
//  Returns:    TRUE if parameter exists and was fetched.
//
//  History:    02-Feb-97   KyleP       Created
//
//----------------------------------------------------------------------------

BOOL CCatalogAdmin::GetDWORDParam( WCHAR const * pwszParam, DWORD & dwValue )
{
    DWORD dwType;
    DWORD dwSize = sizeof(dwValue);

    DWORD dwError = RegQueryValueEx( _hkeyCatalog,  // Key handle
                                     pwszParam,          // Name
                                     0,                  // Reserved
                                     &dwType,            // Datatype
                                     (BYTE *)&dwValue,   // Data returned here
                                     &dwSize );          // Size of data

    return ( ERROR_SUCCESS == dwError && REG_DWORD == dwType );
}

//+---------------------------------------------------------------------------
//
//  Member:     CCatalogAdmin::SetDWORDParam, public
//
//  Synopsis:   Sets catalog-specific value of named parameter.
//
//  Arguments:  [pwszParam] -- Parameter to set
//              [dwValue]   -- New value
//
//  History:    02-Feb-97   KyleP       Created
//
//----------------------------------------------------------------------------

void CCatalogAdmin::SetDWORDParam( WCHAR const * pwszParam, DWORD dwValue )
{

    DWORD dwError = RegSetValueEx( _hkeyCatalog,       // Key
                                   pwszParam,          // Name
                                   0,                  // Reserved
                                   REG_DWORD,          // Type
                                   (BYTE *)&dwValue,   // Value
                                   sizeof(dwValue) );  // Size of value

    if ( ERROR_SUCCESS != dwError )
    {
        THROW( CException( HRESULT_FROM_WIN32( dwError ) ) );
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CCatalogAdmin::DeleteRegistryParamNoThrow, public
//
//  Synopsis:   Deletes catalog-specific named parameter.
//
//  Arguments:  [pwszParam] -- Parameter to delete
//
//  History:    08-Dec-98   KrishnaN       Created
//
//----------------------------------------------------------------------------

void  CCatalogAdmin::DeleteRegistryParamNoThrow( WCHAR const * pwszParam )
{
    RegDeleteValue( _hkeyCatalog, pwszParam );
}

//+---------------------------------------------------------------------------
//
//  Member:     CCatalogAdmin::IsTrackingIIS, public
//
//  Returns:    TRUE if catalog is tracking virtual roots
//
//  History:    02-Feb-97   KyleP   Created
//
//----------------------------------------------------------------------------

BOOL CCatalogAdmin::IsTrackingIIS()
{
    DWORD dwIsTracking;

    if ( GetDWORDParam( wcsIsIndexingW3Roots, dwIsTracking ) )
        return (0 != dwIsTracking);
    else
        return TRUE;   // Default.
}

//+---------------------------------------------------------------------------
//
//  Member:     CCatalogAdmin::QueryScopeEnum, public
//
//  Returns:    New scope enumerator
//
//  History:    02-Feb-97   KyleP   Created
//
//----------------------------------------------------------------------------

CScopeEnum * CCatalogAdmin::QueryScopeEnum()
{
    return new CScopeEnum( _hkeyCatalog, IsLocal(), _fWrite );
}


//+---------------------------------------------------------------------------
//
//  Member:     CCatalogAdmin::QueryScopeEnum, public
//
//  Arguments:  [pwszPath]  -- scope path
//
//  Returns:    Scope admin object for [pwszPath]
//
//  History:    12/10/97    mohamedn    created
//
//----------------------------------------------------------------------------

CScopeAdmin * CCatalogAdmin::QueryScopeAdmin(WCHAR const * pwszPath)
{

    CScopeEnum  ScopeEnum( _hkeyCatalog, IsLocal(), _fWrite );

    while ( ScopeEnum.Next() )
    {
        if ( !_wcsicmp(ScopeEnum.Path(), pwszPath) )
            return ScopeEnum.QueryScopeAdmin();
    }

    return 0;
}

//+---------------------------------------------------------------------------
//
//  Member:     CCatalogAdmin::AddOrReplaceSecret, public
//
//  Synopsis:   Adds/replaces user password
//
//  Arguments:  [pwcUser] -- User
//              [pwcPW]   -- Password
//
//  History:    1-Oct-97   KyleP   Created
//
//----------------------------------------------------------------------------

void CCatalogAdmin::AddOrReplaceSecret( WCHAR const * pwcUser, WCHAR const * pwcPW )
{
    //
    // write objects start blank -- the old entries must be copied
    // into the write object, along with the new entry.
    //

    CCiSecretWrite secretWrite( _xwcsMachName.Get() );
    CCiSecretRead secret( _xwcsMachName.Get() );
    CCiSecretItem * pItem = secret.NextItem();

    while ( 0 != pItem )
    {
        if ( ( 0 == _wcsicmp( _wcsCatName, pItem->getCatalog() ) ) &&
             ( 0 == _wcsicmp( pwcUser, pItem->getUser() ) ) )
        {
            // don't add this -- replace it below
        }
        else
        {
            // just copy the item

            secretWrite.Add( pItem->getCatalog(),
                             pItem->getUser(),
                             pItem->getPassword() );
        }

        pItem = secret.NextItem();
    }

    // add the new item

    secretWrite.Add( _wcsCatName, pwcUser, pwcPW );

    // write it to the sam database

    secretWrite.Flush();
}

//+---------------------------------------------------------------------------
//
//  Member:     CCatStateInfo::Update, public
//
//  Synopsis:   updates catalog state information
//
//  Arguments:  none.
//
//  Returns:    TRUE upon sucess, FALSE upon failure to update.
//
//  History:    4-1-98  mohamedn    created
//
//----------------------------------------------------------------------------

BOOL CCatStateInfo::LokUpdate(void)
{

    RtlFillMemory( &_state, sizeof(CI_STATE), 0xFF );

    _state.cbStruct = sizeof(CI_STATE);

    SCODE sc = CIState( _catAdmin.GetName(),
                        _catAdmin.GetMachName(),
                        &_state );
    if ( FAILED(sc) )
    {
        _sc = sc;

        RtlFillMemory( &_state, sizeof(CI_STATE), 0xFF );
    }

    return ( S_OK == _sc );
}

//+---------------------------------------------------------------------------
//
//  Member:     CScopeEnum::CScopeEnum, public
//
//  Synopsis:   Constructor for scope enumerator
//
//  Arguments:  [hkeyCatalog] -- Registry key for catalog (e.g. ...\catalogs\web)
//
//  History:    02-Feb-97   KyleP   Created
//
//  Notes:      Initially positioned *before* first scope.
//
//----------------------------------------------------------------------------

CScopeEnum::CScopeEnum( HKEY hkeyCatalog,
                        BOOL fIsLocal,
                        BOOL fWrite )
        : _pwcsAlias( 0 ),
          _pwcsLogon( 0 ),
          _dwIndex( 0 ),
          _fIsLocal( fIsLocal ),
          _fWrite( fWrite )
{
    DWORD dwError = RegOpenKeyEx( hkeyCatalog,
                                  wcsCatalogScopes,
                                  0,
                                  KEY_READ,
                                  _xkeyScopes.GetPointer() );

    if ( ERROR_SUCCESS != dwError || _xkeyScopes.IsNull() )
    {
        ciDebugOut(( DEB_ERROR, "Error %d opening scopes registry key.\n", dwError ));
        THROW( CException( HRESULT_FROM_WIN32( dwError ) ) );
    }

    //
    // get another handle to the catalog using RegOpenKeyEx, DuplicateHandle doesn't work for handle of remore reg.
    //
    dwError = RegOpenKeyEx( hkeyCatalog,
                            NULL,
                            0,
                            fWrite ? KEY_ALL_ACCESS : KEY_READ,
                            _xkeyCatalog.GetPointer() );

    if ( ERROR_SUCCESS != dwError || _xkeyCatalog.IsNull() )
    {
        ciDebugOut(( DEB_ERROR, "Error %d opening Catalogs registry key.\n", dwError ));
        THROW( CException( HRESULT_FROM_WIN32( dwError ) ) );
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CScopeEnum::~CScopeEnum, public
//
//  Synopsis:   Destructor
//
//  History:    02-Feb-97   KyleP   Created
//
//----------------------------------------------------------------------------

CScopeEnum::~CScopeEnum()
{
    delete [] _pwcsAlias;
    delete [] _pwcsLogon;
}

//+---------------------------------------------------------------------------
//
//  Member:     CScopeEnum::QueryScopeAdmin, public
//
//  Synopsis:   Creates scope admin object for current scope
//
//  Returns:    scope admin object for current scope
//
//  History:    12-05-97  mohamedn   Created
//
//----------------------------------------------------------------------------

CScopeAdmin * CScopeEnum::QueryScopeAdmin()
{
    return new CScopeAdmin( _xkeyCatalog.Get(),
                            _awcCurrentScope,
                            _pwcsAlias,
                            _pwcsLogon,
                            _fExclude,
                            _fVirtual,
                            _fShadowAlias,
                            _fIsLocal,
                            _fWrite,
                            FALSE ); // don't do validity check
}

//+---------------------------------------------------------------------------
//
//  Member:     CScopeEnum::Next, public
//
//  Synopsis:   Advances to next scope.
//
//  Returns:    FALSE at end-of-scopes.
//
//  History:    02-Feb-97   KyleP   Created
//
//----------------------------------------------------------------------------

BOOL CScopeEnum::Next()
{
    //
    // Clean up from last scope.
    //

    delete [] _pwcsAlias;
    _pwcsAlias = 0;
    delete [] _pwcsLogon;
    _pwcsLogon = 0;

    //
    // Look for next entry.
    //

    DWORD cwcName = sizeof( _awcCurrentScope ) / sizeof( _awcCurrentScope[0] );
    WCHAR awcCurrentScopeData[MAX_PATH];
    DWORD cbData = sizeof( awcCurrentScopeData );
    DWORD dwType;
    FILETIME ftUnused;

    DWORD dwError = RegEnumValue( _xkeyScopes.Get(),  // handle of key to query
                                  _dwIndex,           // index of value to query
                                  _awcCurrentScope,   // address of buffer for value string
                                  &cwcName,           // address for size of value buffer
                                  0,                  // reserved
                                  &dwType,            // address of buffer for type code
                                  (BYTE *)awcCurrentScopeData, // address of buffer for value data
                                  &cbData );          // address for size of data buffer

    _dwIndex++;

    if ( ERROR_SUCCESS == dwError )
    {
        CParseRegistryScope Parse( _awcCurrentScope,
                                   dwType,
                                   awcCurrentScopeData,
                                   cbData );

        Parse.GetScope( _awcCurrentScope );
        _pwcsAlias    = Parse.AcqFixup();
        _pwcsLogon    = Parse.AcqUsername();
        _fExclude     = !Parse.IsIndexed();
        _fVirtual     = Parse.IsVirtualPlaceholder();
        _fShadowAlias = Parse.IsShadowAlias();

        return TRUE;
    }
    else if ( ERROR_NO_MORE_ITEMS != dwError )
    {
        THROW( CException( HRESULT_FROM_WIN32( dwError ) ) );
    }

    return FALSE;
}

//+---------------------------------------------------------------------------
//
//  Member:     CScopeAdmin::CScopeAdmin, public
//
//  Synopsis:   Constructor for scope admin
//
//  Arguments:  [hkeyCatalog]  -- Registry key for catalog (e.g. ...\catalogs\web)
//              [pwszScope]    -- scope path
//              [pwszAlias]    -- alias
//              [pwszLogon]    -- logon name
//              [fExclude]     -- exclude scope flag
//              [fVirtual]     -- isVirtual flag
//              [fShadowAlias] -- TRUE for shadow alias place-holder
//              [fWrite]       -- Open for write access
//              [fValidityCheck] -- TRUE to check of scope is valid
//
//  Returns:    none- throws in case of failure
//
//  History:    12-10-97    mohamedn    created
//
//----------------------------------------------------------------------------

CScopeAdmin::CScopeAdmin( HKEY    hkeyCatalog,
                          WCHAR const * pwszScope,
                          WCHAR const * pwszAlias,
                          WCHAR const * pwszLogon,
                          BOOL    fExclude,
                          BOOL    fVirtual,
                          BOOL    fShadowAlias,
                          BOOL    fIsLocal,
                          BOOL    fWrite,
                          BOOL    fValidityCheck )
        :_fExclude(fExclude),
         _fVirtual(fVirtual),
         _fShadowAlias(fShadowAlias),
         _fWrite( fWrite ),
         _fIsLocal( fIsLocal )
{

    _awcScope[0] = L'';
    _awcAlias[0] = L'';
    _awcLogon[0] = L'';

    unsigned len = wcslen(pwszScope);

    // The caller doesn't need to know what kind of error it is.
    if ( len >= (sizeof _awcScope/sizeof WCHAR ) ||
         len == 0 ||
         ( fValidityCheck && fIsLocal && FAILED(IsScopeValid(pwszScope, len, fIsLocal)) ) )
    {
        ciDebugOut(( DEB_ERROR, "invalid scope: %ws, len: %d\n", pwszScope, len ));
        THROW(CException(E_INVALIDARG));
    }
    else
    {
        wcscpy( _awcScope, pwszScope );
    }

    len = (pwszAlias == 0) ? 0 : wcslen( pwszAlias );

    if ( len >= (sizeof _awcAlias/sizeof WCHAR) )
    {
        ciDebugOut(( DEB_ERROR, "invalid Alias: %ws, len: %d\n", pwszAlias, len ));
        THROW(CException(E_INVALIDARG));
    }
    else if ( len > 0 )
    {
        wcscpy( _awcAlias, pwszAlias );
    }

    len = (pwszLogon == 0) ? 0 : wcslen( pwszLogon );
    if ( len >= (sizeof _awcAlias / sizeof WCHAR) )
    {
        ciDebugOut(( DEB_ERROR, "invalid logon: %ws, len: %d\n", pwszLogon, len ));
        THROW(CException(E_INVALIDARG));
    }
    else if ( len > 0 )
    {
        wcscpy( _awcLogon, pwszLogon );
    }

    DWORD dwError = RegOpenKey( hkeyCatalog,
                                wcsCatalogScopes,
                                _xkeyScopes.GetPointer() );

    if ( ERROR_SUCCESS != dwError || _xkeyScopes.IsNull() )
    {
        ciDebugOut(( DEB_ERROR, "Error %d opening scopes registry key.\n", dwError ));
        THROW( CException( HRESULT_FROM_WIN32( dwError ) ) );
    }
} //CScopeAdmin

//+---------------------------------------------------------------------------
//
//  Member:     CScopeAdmin::SetPath, public
//
//  Synopsis:   Sets a new path value
//
//  Arguments:  [pwszScope] -- path value to set
//
//  Returns:    none - throws upon failure.
//
//  History:    12-10-97 mohamedn   created
//
//----------------------------------------------------------------------------

void CScopeAdmin::SetPath( WCHAR const * pwszScope )
{
    if ( !_fWrite )
        THROW( CException( HRESULT_FROM_WIN32( ERROR_ACCESS_DENIED ) ) );

    Win4Assert( pwszScope );

    unsigned len = ( 0 == pwszScope ) ? 0 : wcslen(pwszScope);

    if ( 0 >= len ||
         len >= (sizeof _awcScope/sizeof WCHAR) ||
         FAILED(IsScopeValid(pwszScope, len, IsLocal())) )
    {
        ciDebugOut(( DEB_ERROR, "Invalid pwszScopes(%ws)\n", (0 != len) ? pwszScope: L"" ));
        THROW(CException( E_INVALIDARG ) );
    }

    DWORD dwError = RegDeleteValue( _xkeyScopes.Get(), _awcScope );

    if ( ERROR_SUCCESS != dwError )
    {
        ciDebugOut(( DEB_ERROR, "Error %d deleting scopes registry value:%ws\n", dwError, _awcScope ));
        THROW( CException( HRESULT_FROM_WIN32( dwError ) ) );
    }

    //
    // set the value of the new scope path.
    //
    wcscpy( _awcScope, pwszScope );

    //
    // clear logon info if path is local drive
    //
    if ( _awcScope[1] == L':' )
    {
        wcscpy(_awcLogon,L"");
    }

    SetScopeValueString();
}

//+---------------------------------------------------------------------------
//
//  Member:     CScopeAdmin::SetAlias, public
//
//  Synopsis:   Sets a new Alias
//
//  Arguments:  [pwszAlias] -- Alias to set
//
//  History:    10-12-97    mohamedn    created
//
//----------------------------------------------------------------------------

void CScopeAdmin::SetAlias( WCHAR const * pwszAlias )
{
    if ( !_fWrite )
        THROW( CException( HRESULT_FROM_WIN32( ERROR_ACCESS_DENIED ) ) );

    // OK to have 0 == pwszalias
    //Win4Assert( pwszAlias );

    unsigned len = ( 0 == pwszAlias ) ? 0 : wcslen(pwszAlias);

    if ( len >= (sizeof _awcAlias/sizeof WCHAR) )
    {
        ciDebugOut(( DEB_ERROR, "Invalid pwszAlias(%ws)\n", (0 == len) ? L"" : pwszAlias ));
        THROW(CException( E_INVALIDARG ) );
    }

    //
    // set the value of the new Alias.
    //
    _awcAlias[0] = L'';
    if (pwszAlias)
       wcscpy( _awcAlias, pwszAlias );

    SetScopeValueString();
}


//+---------------------------------------------------------------------------
//
//  Member:     CScopeAdmin::SetExclude, public
//
//  Synopsis:   Sets the ExcludeScope flag.
//
//  Arguments:  [fExclude] -- Exclude scope flag to set
//
//  History:    12-10-97    mohamedn    created
//
//----------------------------------------------------------------------------

void CScopeAdmin::SetExclude( BOOL fExclude )
{
    if ( !_fWrite )
        THROW( CException( HRESULT_FROM_WIN32( ERROR_ACCESS_DENIED ) ) );

    if ( _fVirtual )
         THROW( CException( HRESULT_FROM_WIN32( ERROR_NOT_SUPPORTED ) ) );

    _fExclude = fExclude;

    SetScopeValueString();
}

//+---------------------------------------------------------------------------
//
//  Member:     CScopeAdmin::SetLogonInfo, public
//
//  Synopsis:   Sets logon/password info
//
//  Arguments:  [pwszLogon]    -- Logon name
//              [pwszPassword] -- logon password
//              [CatAdmin]     -- reference to parent catalog
//
//  History:    12-10-97    mohamedn    created
//
//----------------------------------------------------------------------------

void CScopeAdmin::SetLogonInfo(WCHAR  const  * pwszLogon,
                               WCHAR  const  * pwszPassword,
                               CCatalogAdmin & CatAdmin)
{
    if ( !_fWrite )
        THROW( CException( HRESULT_FROM_WIN32( ERROR_ACCESS_DENIED ) ) );

    // ok to have 0 == pwszPassword
    //Win4Assert( pwszPassword );

    unsigned len = pwszLogon ? wcslen(pwszLogon) : 0;

    if ( len >= (sizeof _awcLogon/sizeof WCHAR) )
    {
        ciDebugOut(( DEB_ERROR, "Invalid LogonInfo(%ws)\n", (0 != len) ? pwszLogon: L"" ));
        THROW(CException( E_INVALIDARG ) );
    }

    //
    // set the value of the new logon
    //
    _awcLogon[0] = L'';
    if (pwszLogon)
        wcscpy( _awcLogon, pwszLogon );

    SetScopeValueString();

    if ( 0 != pwszLogon && 0 != pwszPassword)
        CatAdmin.AddOrReplaceSecret( pwszLogon, pwszPassword );
}

//+---------------------------------------------------------------------------
//
//  Member:     CScopeAdmin::SetScopeValueString, private
//
//  Synopsis:   updates scope value string
//
//  Arguments:  none
//
//  History:    12-10-97    mohamedn    created
//
//----------------------------------------------------------------------------

void CScopeAdmin::SetScopeValueString()
{
    if ( !_fWrite )
        THROW( CException( HRESULT_FROM_WIN32( ERROR_ACCESS_DENIED ) ) );

    XGrowable<WCHAR>    xLine;

    AssembleScopeValueString( _awcAlias, _fExclude, _awcLogon, xLine );

    WCHAR const * pwszTemp = xLine.Get();

    //
    // Set the new value.
    //

    DWORD dwError;

    dwError = RegSetValueEx( _xkeyScopes.Get(),    // Key
                             _awcScope,            // Value name
                             0,                    // Reserved
                             REG_SZ,               // Type
                             (BYTE *)pwszTemp,     // Data
                             ( ( 1 + wcslen(pwszTemp) ) * sizeof WCHAR ) ); // Size (in bytes)

    if ( ERROR_SUCCESS != dwError )
    {
        ciDebugOut(( DEB_ERROR, "Error %d setting value for scope %ws.\n", dwError, _awcScope ));
        THROW( CException( HRESULT_FROM_WIN32( dwError ) ) );
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   LocateCatalog, private
//
//  Synopsis:   Locates a catalog containing [pwszScope]
//
//  Arguments:  [Machine]   -- MachineAdmin object to search
//              [pwszScope] -- Scope to locate
//              [iBmk]      -- Input: catalog instance to find (0, 1, etc)
//                             Output: number found
//              [pwszCat]   -- Catalog returned here
//              [pcc]       -- Input: Size of [pwszCat]
//                             Output: Size needed to store catalog.  If > *pcc
//                             then catalog name was not stored.
//
//  Returns:    S_OK --> Found match, S_FALSE --> No matches.
//
//  History:    08-May-97   KyleP   Created
//
//----------------------------------------------------------------------------

SCODE LocateCatalog( CMachineAdmin & Machine,
                     WCHAR const * pwszScope,
                     ULONG & iBmk,
                     WCHAR * pwszCat,
                     ULONG * pcc )
{
    SCODE sc = S_FALSE;
    XGrowable<WCHAR, 4*MAX_PATH> aCatNames;

    unsigned iMatch = 0;
    ULONG cCats = 0; // Tracks the number of catalogs.

    CLowcaseBuf lcScope( pwszScope );
    CScopeMatch Match( lcScope.Get(), lcScope.Length() );

    //
    // Interate over catalogs.
    //

    XPtr<CCatalogEnum> xCatEnum( Machine.QueryCatalogEnum() );

    while ( S_FALSE == sc && xCatEnum->Next() )
    {
        XPtr<CCatalogAdmin> xCatAdmin( xCatEnum->QueryCatalogAdmin() );

        // Inactive catalogs can't match

        if ( xCatAdmin->IsCatalogInactive() )
            continue;

        //
        // Iterate over scopes within a catalog.
        //

        XPtr<CScopeEnum> xScopeEnum( xCatAdmin->QueryScopeEnum() );

        while ( S_FALSE == sc && xScopeEnum->Next() )
        {
            BOOL fFound = FALSE;

            XPtr<CScopeAdmin> xScopeAdmin( xScopeEnum->QueryScopeAdmin() );

            //
            // Don't really want to match exclude scopes.
            //

            if ( xScopeAdmin->IsExclude() )
                continue;

            //
            // Root scopes (virtual or physical) match any catalog
            //

            if ( ( 0 == *(pwszScope+1) ) && ( L'\\' == *pwszScope ) )
                 fFound = TRUE;
            else
            {
                //
                // Local access?
                //

                if ( Machine.IsLocal() )
                {
                    CLowcaseBuf lcCatalogScope( xScopeAdmin->GetPath() );
                    fFound = Match.IsPrefix( lcCatalogScope.Get(), lcCatalogScope.Length() );
                }

                //
                // Remote access
                //
                else
                {
                    if ( 0 == xScopeAdmin->GetAlias() || 0 == *(xScopeAdmin->GetAlias()) )
                        continue;

                    CLowcaseBuf lcCatalogAlias( xScopeAdmin->GetAlias() );
                    fFound = Match.IsPrefix( lcCatalogAlias.Get(), lcCatalogAlias.Length() );
                }
            }

            if ( fFound )
            {
                //
                // We don't want to enumerate the same catalog multiple times.
                // Use an array to store names of catalogs found so far.
                // Optimization: Since the most common case is to retrieve the
                // first catalog (iBmk == 0), avoid usage of the array in that case.
                //

                if ( iBmk > 0 )
                {
                   // Check if the entry already exists in the array. If it does,
                   // continue iterating, else make a new entry and proceed down.
                   for (ULONG i = 0;
                        i < cCats && wcscmp(xCatEnum->Name(), &aCatNames[i*MAX_PATH]);
                        i++);

                   if (i < cCats)   // For loop terminated because a match was found
                   {
                      ciDebugOut((DEB_TRACE, "Entry %ws already exists in table.\n", xCatEnum->Name()));
                      continue;
                   }
                   else
                   {
                      // Do we have enough space?
                      if (aCatNames.Count() < (cCats + 1)*MAX_PATH)
                      {
                          aCatNames.SetSize((cCats+4) * MAX_PATH);
                          ciDebugOut((DEB_TRACE, "Expanded space to %d chars",
                                      aCatNames.Count()));
                      }

                      wcscpy(&aCatNames[cCats*MAX_PATH], xCatEnum->Name());
                      ciDebugOut((DEB_TRACE, "Adding %ws to the array.\n", xCatEnum->Name()));
                      cCats++;
                   }
                }

                //
                // Looking for additional matches?
                //

                if ( iBmk != iMatch )
                {
                    iMatch++;
                    continue;
                }

                //
                // Found match.  Return catalog to user.
                //

                unsigned ccCatalog = wcslen( xCatEnum->Name() ) + 1;

                if ( ccCatalog <= *pcc )
                    RtlCopyMemory( pwszCat, xCatEnum->Name(), ccCatalog * sizeof(WCHAR) );

                *pcc = ccCatalog;

                sc = S_OK;
            }
        }
    }

    iBmk = iMatch;

    return sc;
}

//+---------------------------------------------------------------------------
//
//  Function:   LocateCatalogs, public
//
//  Synopsis:   Locates a catalog containing [pwszScope]
//
//  Arguments:  [pwszScope]   -- Scope to locate
//              [iBmk]        -- Catalog instance to find (0, 1, etc)
//              [pwszMachine] -- Name of machine returned here.
//              [pccMachine]  -- Input: Size of [pwszMachine]
//                               Output: Size needed to store Machine.  If
//                               needed size > *pccMachine then machine name
//                               was not stored.
//              [pwszCat]     -- Catalog returned here
//              [pccCat]      -- Input: Size of [pwszCat]
//                               Output: Size needed to store catalog.  If
//                               needed size > *pccCat then catalog name
//                               was not stored.
//
//  Returns:    S_OK --> Found match, S_FALSE --> No matches.
//
//  History:    08-May-97   KyleP   Created
//
//----------------------------------------------------------------------------

SCODE LocateCatalogsW( WCHAR const * pwszScope,
                       ULONG iBmk,
                       WCHAR * pwszMachine,
                       ULONG * pccMachine,
                       WCHAR * pwszCat,
                       ULONG * pccCat )
{
    //
    // Parameter checks
    //

    if ( 0 == pwszScope ||
         0 == pccMachine ||
         0 == pccCat )
    {
        return E_INVALIDARG;
    }

    // null ptrs for pszMachine and pszCat are tolerated if the corresponding length
    // indicators are 0.
    if ( (0 == pwszMachine && *pccMachine > 0) ||
         (0 == pwszCat && *pccCat > 0) )
    {
        return E_INVALIDARG;
    }

    //
    // If we have a short path, we should expand it to its long form
    //
        
    XPtrST<WCHAR> xwszScopeLocal;

    if ( IsShortPath( pwszScope ) )
    {
        //
        // An expanded long path name could be longer than MAX_PATH, so it's best
        // to allocate space after a call to GetLongPathName
        //

        DWORD cBufSizeInChars = GetLongPathName(pwszScope, 0, 0);
        if (0 == cBufSizeInChars)
           return HRESULT_FROM_WIN32(GetLastError());

        xwszScopeLocal.Set(new WCHAR[cBufSizeInChars + 1]);

        DWORD dwRet2 = GetLongPathName(pwszScope, xwszScopeLocal.GetPointer(), cBufSizeInChars);
        if (0 == dwRet2)
           return HRESULT_FROM_WIN32(GetLastError());

        //
        // We are passing in the right sized buffer, so the following should hold.
        //

        Win4Assert( cBufSizeInChars == (dwRet2 + 1) );

        ciDebugOut(( DEB_ITRACE, "Short path %ws is converted to\n %ws\n", 
                     pwszScope, xwszScopeLocal.GetPointer() ));

        pwszScope = xwszScopeLocal.GetPointer();
    }

    //
    // Validate the path. One sure way of validating all path combinations is to attempt 
    // getting file attributes on the path. If the attempt fails, so will we.
    // Don't validate for the special cases of "\" and "\\machine"
    //

    if ( wcscmp( pwszScope, L"\\" ) &&
         ! ( pwszScope[0] == L'\\' && pwszScope[1] == L'\\' &&
             0 == wcschr( pwszScope + 2, L'\\' ) ) )
    {
        DWORD dwRet = GetFileAttributes(pwszScope);
        if (0xFFFFFFFF == dwRet)
           return HRESULT_FROM_WIN32(GetLastError());
    }

    SCODE sc = S_OK;

    TRANSLATE_EXCEPTIONS;

    TRY
    {
        // Handle funny paths
        CFunnyPath::FunnyUNC funnyUNC = CFunnyPath::IsFunnyUNCPath( pwszScope );
        XGrowable<WCHAR> xScope;
        switch ( funnyUNC )
        {
        case CFunnyPath::FUNNY_ONLY:
            pwszScope += _FUNNY_PATH_LENGTH;
            break;

        case CFunnyPath::FUNNY_UNC:
        {
            unsigned ccActualLen = wcslen( pwszScope ) - _UNC_FUNNY_PATH_LENGTH;
            xScope.SetSize( ccActualLen + 1 );
            xScope[0] = L'\\';
            xScope[1] = L'\\';
            RtlCopyMemory( xScope.Get() + 2,
                           pwszScope + _UNC_FUNNY_PATH_LENGTH + 2,
                           (ccActualLen - 2 + 1) * sizeof( WCHAR ) );
            pwszScope = xScope.Get();
            break;
        }

        default:
            break;
        }

        //
        // Any catalog on the remote machine will do for a scope of the form
        // \\machine
        //

        sc = S_FALSE;

        if ( pwszScope[0] == L'\\' &&
             pwszScope[1] == L'\\' &&
             0 != pwszScope[2] &&
             0 == wcschr( pwszScope + 2, L'\\' ) )
        {
            WCHAR const *pwcM = pwszScope + 2;
            CMachineAdmin RemoteMachine( pwcM, FALSE );

            ULONG iBmkTemp = iBmk;
            sc = LocateCatalog( RemoteMachine, L"\\", iBmkTemp, pwszCat, pccCat );

            if ( S_OK == sc )
            {
                unsigned cc = wcslen( pwcM ) + 1;
                if ( *pccMachine >= cc )
                    wcscpy( pwszMachine, pwcM );

                *pccMachine = cc + 1;
            }
            else
                iBmk -= iBmkTemp;
        }    
        else 
        {
            //
            // Next try local machine.
            //

            CMachineAdmin LocalMachine( 0, FALSE );

            ULONG iBmkTemp = iBmk;
            sc = LocateCatalog( LocalMachine, pwszScope, iBmkTemp, pwszCat, pccCat );

            if ( S_OK == sc )
            {
                if ( *pccMachine >= 2 )
                {
                    pwszMachine[0] = L'.';
                    pwszMachine[1] = 0;
                }

                *pccMachine = 2;
            }
            else
                iBmk -= iBmkTemp;
        }

        //
        // If the path is a UNC path, then also try the remote machine.
        //

        if ( S_OK != sc && pwszScope[0] == L'\\' && pwszScope[1] == L'\\' )
        {
            WCHAR wcsMachine[MAX_PATH];

            WCHAR * pwcsSlash = wcschr( pwszScope + 2, L'\\' );

            if (  0 != pwcsSlash )
            {
                if ( (pwcsSlash - pwszScope - 2) > sizeof(wcsMachine)/sizeof(WCHAR) )
                {
                    ciDebugOut(( DEB_WARN, "Too long or ill-formed UNC path %ws\n", pwszScope ));
                    sc = QUERY_E_INVALID_DIRECTORY;
                }
                else
                {
                    unsigned cc = (unsigned)(pwcsSlash - pwszScope - 2);
                    RtlCopyMemory( wcsMachine, pwszScope + 2, cc * sizeof(WCHAR) );
                    wcsMachine[cc] = 0;
    
                    CMachineAdmin RemoteMachine( wcsMachine, FALSE );
    
                    sc = LocateCatalog( RemoteMachine, pwszScope, iBmk, pwszCat, pccCat );
    
                    if ( S_OK == sc )
                    {
                        if ( *pccMachine >= cc + 1 )
                        {
                            RtlCopyMemory( pwszMachine, wcsMachine, (cc + 1) * sizeof(WCHAR) );
                        }
    
                        *pccMachine = cc + 1;
                    }
                }
            }
        }
    }
    CATCH( CException, e )
    {
        ciDebugOut(( DEB_ERROR, "Exception 0x%x caught in LocateCatalogs\n", e.GetErrorCode() ));

        sc = e.GetErrorCode();
    }
    END_CATCH

    UNTRANSLATE_EXCEPTIONS;

    return sc;
}

STDAPI LocateCatalogsA( char const * pszScope,
                        ULONG        iBmk,
                        char  *      pszMachine,
                        ULONG *      pccMachine,
                        char *       pszCat,
                        ULONG *      pccCat )
{
    //
    // Parameter checks
    //

    if ( 0 == pszScope ||
         0 == pccMachine ||
         0 == pccCat )
    {
        return E_INVALIDARG;
    }

    // null ptrs for pszMachine and pszCat are tolerated if the corresponding length
    // indicators are 0.
    if ( (0 == pszMachine && *pccMachine > 0) ||
         (0 == pszCat && *pccCat > 0) )
    {
        return E_INVALIDARG;
    }


    SCODE sc = S_OK;

    TRANSLATE_EXCEPTIONS;

    TRY
    {
        USHORT ccScope = (USHORT)strlen(pszScope);

        // RtlOemStringToUnicodeString is expecting
        // maxlength to be greater than actual length, so throwing
        // in an extra character.

        XPtrST<WCHAR> xwszScope( new WCHAR[ccScope + 1] );
        XPtrST<WCHAR> xwszMachine( new WCHAR[*pccMachine] );
        XPtrST<WCHAR> xwszCat( new WCHAR[*pccCat] );

        //
        // Convert to Unicode
        //

        OEM_STRING uStrOem;
        uStrOem.Buffer = (char *)pszScope;
        uStrOem.Length = ccScope;
        uStrOem.MaximumLength = ccScope + 1;

        UNICODE_STRING uStr;
        uStr.Buffer = xwszScope.GetPointer();
        uStr.Length = 0;
        uStr.MaximumLength = (ccScope + 1) * sizeof(WCHAR);

        NTSTATUS Status = RtlOemStringToUnicodeString( &uStr,
                                                       &uStrOem,
                                                       FALSE );

        if ( !NT_SUCCESS(Status) )
        {
           DWORD dwError = RtlNtStatusToDosError( sc );

           return (ERROR_MR_MID_NOT_FOUND == dwError ) ? E_FAIL : HRESULT_FROM_WIN32( dwError );
        }

        ULONG ccMachine = *pccMachine;
        ULONG ccCat = *pccCat;

        sc = LocateCatalogsW( xwszScope.GetPointer(),
                              iBmk,
                              xwszMachine.GetPointer(),
                              &ccMachine,
                              xwszCat.GetPointer(),
                              &ccCat );

        if ( S_OK != sc )
            return sc;

        // We need to go through this conversion attempt even when we know it
        // is going to fail (i.e. when *pccMachine <= ccMachine). That is the
        // only way to know the right size to be returned through pccMachine.
        uStrOem.Buffer = pszMachine;
        uStrOem.Length = 0;
        uStrOem.MaximumLength = (USHORT)*pccMachine;

        uStr.Buffer = xwszMachine.GetPointer();
        uStr.Length = (USHORT)(ccMachine-1) * sizeof(WCHAR);
        uStr.MaximumLength = uStr.Length + sizeof(WCHAR);

        Status = RtlUnicodeStringToOemString( &uStrOem,
                                              &uStr,
                                              FALSE );

        // We don't return an error if we get back the STATUS_BUFFER_OVERFLOW
        // error. We merely won't copy the string but will have the right length
        // in *pccMachine. That is how LocateCatalogs works.
        if ( !NT_SUCCESS(Status) && Status != STATUS_BUFFER_OVERFLOW)
        {
           DWORD dwError = RtlNtStatusToDosError( sc );

           return (ERROR_MR_MID_NOT_FOUND == dwError ) ? E_FAIL : HRESULT_FROM_WIN32( dwError );
        }

        *pccMachine = uStrOem.Length + sizeof(WCHAR);

        // We need to go through this conversion attempt even when we know it
        // is going to fail (i.e. when *pccCat <= ccCat). That is the
        // only way to know the right size to be returned through pccCat.
        uStrOem.Buffer = pszCat;
        uStrOem.Length = 0;
        uStrOem.MaximumLength = (USHORT)*pccCat;

        uStr.Buffer = xwszCat.GetPointer();
        uStr.Length = (USHORT)(ccCat-1) * sizeof(WCHAR);
        uStr.MaximumLength = uStr.Length + sizeof(WCHAR);

        Status = RtlUnicodeStringToOemString( &uStrOem,
                                              &uStr,
                                              FALSE );

        // We don't return an error if we get back the STATUS_BUFFER_OVERFLOW
        // error. We merely won't copy the string but will have the right length
        // in *pccMachine. That is how LocateCatalogs works.
        if ( !NT_SUCCESS(Status) && Status != STATUS_BUFFER_OVERFLOW)
        {
            DWORD dwError = RtlNtStatusToDosError( sc );

            return (ERROR_MR_MID_NOT_FOUND == dwError ) ? E_FAIL : HRESULT_FROM_WIN32( dwError );
        }

        *pccCat = uStrOem.Length + sizeof(WCHAR);
    }
    CATCH( CException, e )
    {
        ciDebugOut(( DEB_ERROR, "Exception 0x%x caught in LocateCatalogs\n", e.GetErrorCode() ));

        sc = e.GetErrorCode();
    }
    END_CATCH

    UNTRANSLATE_EXCEPTIONS;

    return sc;
}

//+-------------------------------------------------------------------------
//
//  Function:   Delnode, private
//
//  Synopsis:   Deletes a directory recursively.
//
//  Arguments:  [wcsDir]     -- Directory to kill
//              [fDelTopDir] -- if TRUE, delete directory structure also
//
//
//  Returns:    ULONG - error code if failure
//
//  History:    22-Jul-92 KyleP     Created
//              06 May 1995 AlanW   Made recursive, and more tolerant of
//                                  errors in case of interactions with
//                                  CI filtering.
//              08-Jan-97 dlee      Copied from tdbv1
//              28-Jul-97 KyleP     Copied from setup (indexsrv.dll)
//
//--------------------------------------------------------------------------

ULONG Delnode( WCHAR const * wcsDir, BOOL fDelTopDir )
{
    ciDebugOut(( DEB_ITRACE, "Delnoding '%ws'\n", wcsDir ));

    WIN32_FIND_DATA finddata;
    WCHAR wcsBuffer[MAX_PATH];

    unsigned cwc = wcslen( wcsDir ) + wcslen( L"\\*.*" );

    if ( cwc >= MAX_PATH )
        return 0;

    wcscpy( wcsBuffer, wcsDir );
    wcscat( wcsBuffer, L"\\*.*" );

    HANDLE hFindFirst = FindFirstFile( wcsBuffer, &finddata );

    while( INVALID_HANDLE_VALUE != hFindFirst )
    {
        // Look for . and ..

        if ( wcscmp( finddata.cFileName, L"." ) &&
             wcscmp( finddata.cFileName, L".." ) )
        {
            cwc = wcslen( wcsDir ) + 1 + wcslen( finddata.cFileName );

            if ( cwc >= MAX_PATH )
                return 0;

            wcscpy( wcsBuffer, wcsDir );
            wcscat( wcsBuffer, L"\\" );
            wcscat( wcsBuffer, finddata.cFileName );

            if ( finddata.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
                Delnode( wcsBuffer, fDelTopDir );
            else
                DeleteFile( wcsBuffer );
        }

        if ( !FindNextFile( hFindFirst, &finddata ) )
        {
            FindClose( hFindFirst );
            break;
        }
    }

    if (fDelTopDir)
      RemoveDirectory( (WCHAR *)wcsDir );

    return 0;
} //Delnode

#undef LocateCatalogs

STDAPI LocateCatalogs( WCHAR const * pwszScope,
                       ULONG         iBmk,
                       WCHAR *       pwszMachine,
                       ULONG *       pccMachine,
                       WCHAR *       pwszCat,
                       ULONG *       pccCat )
{
    return LocateCatalogsW( pwszScope,
                            iBmk,
                            pwszMachine,
                            pccMachine,
                            pwszCat,
                            pccCat );
} //LocateCatalogs


//+---------------------------------------------------------------------------
//
//  Function:   AssembleScopeValueString
//
//  Synopsis:   assembels a buffer out of the passed in params.
//
//  Arguments:  [ pwszAlias ]  -- Alias
//              [ fExclude  ]  -- Exclude scope flag.
//              [ pwszLogon ]  -- Logon name
//              [ xLine     ]  -- returns concatinated string.
//
//  Returns:    none
//
//  History:    12-10-97    mohamedn    cut from AddScope
//
//----------------------------------------------------------------------------

void AssembleScopeValueString( WCHAR const      * pwszAlias,
                               BOOL               fExclude,
                               WCHAR const      * pwszLogon,
                               XGrowable<WCHAR> & xLine )
{
    //
    // initialize output buffer
    //
    RtlZeroMemory( xLine.Get(), sizeof WCHAR );

    //
    // Build up the value string.
    //

    unsigned cc = 4;  // Null, 2 commas, one digit flag

    if ( 0 != pwszAlias )
        cc += wcslen( pwszAlias );

    if ( 0 != pwszLogon )
        cc += wcslen( pwszLogon );

    xLine.SetSize(cc);

    if ( 0 != pwszAlias )
        wcscat( xLine.Get(), pwszAlias );

    wcscat( xLine.Get(), L"," );

    if ( 0 != pwszLogon )
        wcscat( xLine.Get(), pwszLogon );

    wcscat( xLine.Get(), L"," );

    if ( fExclude )
        wcscat( xLine.Get(), L"4" );
    else
        wcscat( xLine.Get(), L"5" );

}

//+---------------------------------------------------------------------------
//
//  Function:   IsSUBST, private
//
//  Synopsis:   Determines if a drive is a SUBST path or a SIS volume
//
//  Arguments:  [wcDrive] -- Drive
//
//  Returns:    TRUE if the drive is SUBST.
//
//  History:    13-Nov-1998   KyleP  Created
//
//----------------------------------------------------------------------------

BOOL IsSUBST( WCHAR wcDrive )
{
    //
    // If substitutions can be > MAX_PATH this won't work, but since
    // SUBST came from DOS I doubt it's a problem.
    //

    WCHAR wszTargetDevice[MAX_PATH+5];  // "\??\" + null
    WCHAR wszVolume[] = L"C:";
    wszVolume[0] = wcDrive;

    DWORD cc = QueryDosDevice( wszVolume,             // Drive
                               wszTargetDevice,       // Target
                               sizeof(wszTargetDevice)/sizeof(WCHAR) );

    if ( 0 == cc )
    {
        ciDebugOut(( DEB_ERROR, "Error %u from QueryDosDevice(%ws)\n", GetLastError(), wszVolume ));
        THROW( CException() );
    }

    //
    // SUBSTs always start with L"\\??\\"
    //

    if ( cc > 4 &&
         wszTargetDevice[0] == L'\\' &&
         wszTargetDevice[1] == L'?' &&
         wszTargetDevice[2] == L'?' &&
         wszTargetDevice[3] == L'\\' )
    {
        ciDebugOut(( DEB_ERROR, "QueryDosDevice(%ws) reported redirected drive.\n", wszVolume ));
        return TRUE;
    }

    //
    // Checking for SIS
    //
    // -----Original Message-----
    // From: Bill Bolosky
    // Sent: Monday, February 14, 2000 1:09 PM
    // To: Drew McDaniel; Mihai Popescu-Stanesti
    // Cc: Neal Christiansen
    // Subject: RE: SIS and NTFS
    // [...]
    // We have not published external APIs for any of the things that you want to do, although I can explain
    // how to do them. Basically, all SIS has for an external API is the FSCTL_SIS_COPYFILE fscontrol. It's
    // possible to use this to determine if SIS is installed on a volume (just send it down with zero length
    // strings and see if it fails with ERROR_INVALID_FUNCTION; if it does, then it's not a SIS volume; if it
    // fails with some other error, then it is).
    // [...]
    //

    wszTargetDevice[ 0 ] = wszTargetDevice[ 1 ] = wszTargetDevice[ 3 ] = L'\\';
    wszTargetDevice[ 2 ] = L'.';
    wszTargetDevice[ 4 ] = wcDrive;
    wszTargetDevice[ 5 ] = L':';
    wszTargetDevice[ 6 ] = 0;
    HANDLE hVol = CreateFileW( wszTargetDevice, 
                               0, 
                               FILE_SHARE_READ | FILE_SHARE_WRITE, 
                               NULL, 
                               OPEN_EXISTING, 
                               0, 
                               NULL );

    if( INVALID_HANDLE_VALUE == hVol )
    {
        ciDebugOut(( DEB_ERROR, "Error %u from CreateFileW(%ws)\n", GetLastError(), wszTargetDevice ));
        THROW( CException() );
    }
    SHandle sh( hVol );

    BOOL fSuccess = DeviceIoControl( hVol, FSCTL_SIS_COPYFILE, 0, 0, 0, 0, 0, 0 );
    if( !fSuccess && ERROR_INVALID_FUNCTION == GetLastError() )
    {
        //
        // Not a SIS volume
        //
        return FALSE;
    }

    ciDebugOut(( DEB_ERROR, "FSCTL_SIS_COPYFILE(%ws) reported SIS drive.\n", wszTargetDevice ));
    return TRUE;
}

//+---------------------------------------------------------------------------
//
//  Function:   IsScopeValid, public
//
//  Synopsis:   Validates a scope referring to local path or UNC name
//
//  Arguments:  [pwszScope]   -- scope path
//              [len]         -- string len of pwszScope
//
//  Returns:    S_OK if scope is valid; error code otherwise.
//
//  History:    12-10-1997    mohamedn    created
//              08-25-2000    KitmanH     Added fLocal. Only validate scope
//                                        format for non local machine. Don't
//                                        check drive exitence nor drive type
//                                        for remote catalogs
//
//----------------------------------------------------------------------------

SCODE IsScopeValid( WCHAR const * pwszScope, unsigned len, BOOL fLocal )
{
    if (len < 3)
        return QUERY_E_INVALID_DIRECTORY;

    // is it UNC path?
    if ( len >= 5 && pwszScope[0] == L'\\' && pwszScope[1] == L'\\' )
    {
        WCHAR * ptr = wcschr( pwszScope + 2, L'\\' );
        
        // TRUE if we find a backslash. FALSE otherwise.
        BOOL fBackslashFound = 0 != ptr && ptr < &(pwszScope[len-1]) && ptr[1] != L'\\';
 
        if ( fBackslashFound ) 
        {
            for ( unsigned i = 2; i < len; i++ )
            {
                if (!PathIsValidChar( pwszScope[i], ( PIVC_LFN_NAME | PIVC_ALLOW_SLASH ) ))    
                    return QUERY_E_INVALID_DIRECTORY;
            }
          
            return S_OK;
        }
        else
            return QUERY_E_INVALID_DIRECTORY;
    }

    // Check if we have a scope on a valid local drive.
    // Verify that if the scope is on a removable drive, then the catalog is
    // also located on the same drive.

    if ( pwszScope[1] != L':' || pwszScope[2] != L'\\' )
        return QUERY_E_INVALID_DIRECTORY;

    for ( unsigned i = 3; i < len; i++ )
    {
        if (!PathIsValidChar( pwszScope[i], ( PIVC_LFN_NAME | PIVC_ALLOW_SLASH ) ))
            return QUERY_E_INVALID_DIRECTORY;
    }

    if ( !fLocal )
        return S_OK;

    WCHAR wszScopeDrive[_MAX_DRIVE];

    _wsplitpath(pwszScope, wszScopeDrive, 0, 0, 0);
    UINT uiDriveType = GetDriveType(wszScopeDrive);

    //
    // Check for cdrom and removable media doesn't need to happen here.
    //

    switch(uiDriveType)
    {
        case DRIVE_UNKNOWN:
        case DRIVE_NO_ROOT_DIR:
        case DRIVE_REMOTE:
            return QUERY_E_INVALID_DIRECTORY;

        default:
            break;
    }

    //
    // Make sure this isn't a substituted drive.
    //

    if ( IsSUBST( pwszScope[0] ) )
        return HRESULT_FROM_WIN32( ERROR_IS_SUBST_PATH );

    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Member:     CMachineAdmin::IsCIStopped, public
//
//  Synopsis:   tests if cisvc is not active
//
//  Returns:    TRUE if cisvc is not active
//
//  History:    2/16/98 mohamedn    created
//
//----------------------------------------------------------------------------

BOOL CMachineAdmin::IsCIStopped()
{
    if ( !OpenSCM() )
        return TRUE;

    SERVICE_STATUS ss;

    BOOL fOk = QueryServiceStatus( _xSCCI.Get(), &ss );

    if ( !fOk )
    {
        ciDebugOut(( DEB_ERROR, "QueryServiceStatus Failed: %d\n",GetLastError() ));

        THROW( CException() );
    }

    WaitForSvcStateChange(&ss);

    return (ss.dwCurrentState == SERVICE_STOPPED );
}

//+---------------------------------------------------------------------------
//
//  Member:     CMachineAdmin::IsCIStarted, public
//
//  Synopsis:   tests if cisvc is running
//
//  Returns:    TRUE if cisvc is running
//
//  History:    3-Oct-97   KyleP   Created
//
//----------------------------------------------------------------------------

BOOL CMachineAdmin::IsCIStarted()
{
    if ( !OpenSCM() )
        return FALSE;

    SERVICE_STATUS ss;

    BOOL fOk = QueryServiceStatus( _xSCCI.Get(), &ss );

    if ( !fOk )
    {
        ciDebugOut(( DEB_ERROR, "QueryServiceStatus Failed: %d\n",GetLastError() ));

        THROW( CException() );
    }

    WaitForSvcStateChange(&ss);

    return (ss.dwCurrentState == SERVICE_RUNNING);
}

//+---------------------------------------------------------------------------
//
//  Member:     CMachineAdmin::IsCIPaused, public
//
//  Synopsis:   tests if cisvc is paused
//
//  Returns:    TRUE if cisvc is running
//
//  History:    3-Oct-97   KyleP   Created
//
//----------------------------------------------------------------------------

BOOL CMachineAdmin::IsCIPaused()
{
    if ( !OpenSCM() )
        return FALSE;

    SERVICE_STATUS ss;

    BOOL fOk = QueryServiceStatus( _xSCCI.Get(), &ss );

    if ( !fOk )
    {
        ciDebugOut(( DEB_ERROR, "QueryServiceStatus Failed: %d\n",GetLastError() ));

        THROW( CException() );
    }

    WaitForSvcStateChange(&ss);

    return (ss.dwCurrentState == SERVICE_PAUSED);
}

//+---------------------------------------------------------------------------
//
//  Member:     CMachineAdmin::StartCI, public
//
//  Synopsis:   starts cisvc
//
//  Returns:    TRUE if cisvc was started successfully
//
//  History:    3-Oct-97   KyleP   Created
//
//----------------------------------------------------------------------------

BOOL CMachineAdmin::StartCI()
{
    BOOL fStarted = FALSE;

    if ( OpenSCM() )
    {
        if ( IsCIPaused() )
        {
            SERVICE_STATUS svcStatus;

            fStarted = ControlService( _xSCCI.Get(),
                                       SERVICE_CONTROL_CONTINUE,
                                       &svcStatus );

#if CIDBG == 1
            if ( !fStarted )
                ciDebugOut(( DEB_ERROR, "Failed to resume: %d\n", GetLastError() ));
#endif
        }
        else
        {
            fStarted = StartService( _xSCCI.Get(), 0, 0 );

#if CIDBG == 1
            if ( !fStarted )
                ciDebugOut(( DEB_ERROR, "Failed to start CI: %d\n", GetLastError() ));
#endif

            // Check the status until the service is no longer start pending.

            SERVICE_STATUS ssStatus;
            BOOL fOK = QueryServiceStatus( _xSCCI.Get(), &ssStatus);

#if CIDBG == 1
            if ( !fOK )
                ciDebugOut(( DEB_ERROR, "Failed to query service status: %d\n", GetLastError() ));
#endif

            DWORD dwOldCheckPoint;

            int i = 0;
            DWORD dwSleepTime = 3000;  // 3 seconds
            int iTimes = ssStatus.dwWaitHint/dwSleepTime + 1;

            while (ssStatus.dwCurrentState == SERVICE_START_PENDING)
            {
                // Save the current checkpoint.
               dwOldCheckPoint = ssStatus.dwCheckPoint;

               // Wait for a fraction of the specified interval. The waithint is a conservatively
               // large number and we don't have to wait that long
               Sleep(dwSleepTime);
               i++;

               // Check the status again.
               if (!QueryServiceStatus( _xSCCI.Get(), &ssStatus) )
               {
                   ciDebugOut(( DEB_ERROR, "Failed to query service status: %d\n", GetLastError() ));
                   break;
               }

               // Break if the checkpoint has not been incremented. We should only check the break point
               // after having slept at least dwWaitHint milliseconds.
               if (i == iTimes)
               {
                  i = 0;
                  if (dwOldCheckPoint >= ssStatus.dwCheckPoint)
                      break;
               }
            }

            unsigned uSecsWaited = 0;
            unsigned uTotalSecs = 0;
            DWORD dwState = 0;

            // Wait till all catalogs (including the removable ones) are up or timeout in 5 seconds 
            do
            {
                SCODE sc = SetCatalogState ( NULL,
                                             (0 == _xwcsMachName[0]) ? L"." : _xwcsMachName.Get(),
                                             CICAT_ALL_OPENED,
                                             &dwState );

                if ( 0 == dwState )
                {
                    Sleep (1000);   // one second

                    if ( SUCCEEDED(sc) )
                        uSecsWaited++;

                    uTotalSecs++;
                }

            } while ( ( 0 == dwState ) && ( uSecsWaited < 5 ) && ( uTotalSecs < 8 ) );
        }
    }

    return fStarted;
}

//+---------------------------------------------------------------------------
//
//  Member:     CMachineAdmin::StopCI, public
//
//  Synopsis:   stop cisvc
//
//  Returns:    TRUE if cisvc was stopped successfully
//
//  History:    3-Oct-97   KyleP   Created
//
//----------------------------------------------------------------------------

BOOL CMachineAdmin::StopCI()
{
    BOOL fStopped = FALSE;
    BOOL fOK = TRUE;

    if ( OpenSCM() )
    {
        SERVICE_STATUS svcStatus;

        if ( WaitForSvc( _xSCCI ) )
        {
            if ( ControlService( _xSCCI.Get(),
                                 SERVICE_CONTROL_STOP,
                                 &svcStatus ) )
            {
                for ( unsigned i = 0; i < 30 && WaitForSvc( _xSCCI ) ; i++ )
                {
                    ciDebugOut(( DEB_ITRACE, "Sleeping waiting for CI to stop\n" ));
                    Sleep( 1000 );
                }

                if ( !WaitForSvc( _xSCCI ) )
                {
                    ciDebugOut(( DEB_ITRACE, "Stopped CI\n" ));
                    fStopped = TRUE;
                }
            }
            else
            {
                DWORD dw = GetLastError();
                ciDebugOut(( DEB_ERROR, "Can't stop CI, error %d\n", dw ));

                // failures other than timeout and out-of-control are ok

                if ( ERROR_SERVICE_REQUEST_TIMEOUT == dw ||
                     ERROR_SERVICE_CANNOT_ACCEPT_CTRL == dw )
                     fOK = FALSE;
            }
        }
    }

    return fOK;
}

//+---------------------------------------------------------------------------
//
//  Member:     CMachineAdmin::PauseCI, public
//
//  Synopsis:   Pause cisvc
//
//  Returns:    TRUE if cisvc was paused successfully
//
//  History:    06-Jul-1997   KyleP   Created
//
//----------------------------------------------------------------------------

BOOL CMachineAdmin::PauseCI()
{
    BOOL fStopped = FALSE;
    BOOL fOK = TRUE;

    if ( OpenSCM() )
    {
        SERVICE_STATUS svcStatus;

        if ( WaitForSvcPause( _xSCCI ) )
        {
            if ( ControlService( _xSCCI.Get(),
                                 SERVICE_CONTROL_PAUSE,
                                 &svcStatus ) )
            {
                for ( unsigned i = 0; i < 30 && WaitForSvcPause( _xSCCI ) ; i++ )
                {
                    ciDebugOut(( DEB_ITRACE, "Sleeping waiting for CI to pause\n" ));
                    Sleep( 1000 );
                }

                if ( !WaitForSvcPause( _xSCCI ) )
                {
                    ciDebugOut(( DEB_ITRACE, "Paused CI\n" ));
                    fStopped = TRUE;
                }
            }
            else
            {
                DWORD dw = GetLastError();
                ciDebugOut(( DEB_ERROR, "Can't pause CI, error %d\n", dw ));

                // failures other than timeout and out-of-control are ok

                if ( ERROR_SERVICE_REQUEST_TIMEOUT == dw ||
                     ERROR_SERVICE_CANNOT_ACCEPT_CTRL == dw )
                     fOK = FALSE;
            }
        }
    }

    return fOK;
}

//+---------------------------------------------------------------------------
//
//  Member:     CMachineAdmin::IsCIEnabled, public
//
//  Returns:    TRUE if the Indexing Service is enabled (automatic start)
//
//  History:    07-Jul-1998   KyleP   Created
//
//----------------------------------------------------------------------------

BOOL CMachineAdmin::IsCIEnabled()
{
    if ( !OpenSCM() )
        return FALSE;

    XGrowable<QUERY_SERVICE_CONFIG, 10> xQSC;  // Extra space is for strings.

    DWORD cbNeeded;

    BOOL fOk = QueryServiceConfig( _xSCCI.Get(),
                                   xQSC.Get(),
                                   xQSC.SizeOf(),
                                   &cbNeeded );

    if ( !fOk && ERROR_INSUFFICIENT_BUFFER == GetLastError() )
    {
        Win4Assert( xQSC.Count() < (cbNeeded + sizeof(QUERY_SERVICE_CONFIG) - 1) / sizeof(QUERY_SERVICE_CONFIG) );
        xQSC.SetSize( (cbNeeded + sizeof(QUERY_SERVICE_CONFIG) - 1) / sizeof(QUERY_SERVICE_CONFIG) );

        BOOL fOk = QueryServiceConfig( _xSCCI.Get(),
                                       xQSC.Get(),
                                       xQSC.SizeOf(),
                                       &cbNeeded );
    }

    if ( !fOk )
    {
        ciDebugOut(( DEB_ERROR, "QueryServiceConfig Failed: %d\n",GetLastError() ));

        THROW( CException() );
    }

    return ( xQSC[0].dwStartType == SERVICE_AUTO_START );
}

//+---------------------------------------------------------------------------
//
//  Member:     CMachineAdmin::EnableCI, public
//
//  Synopsis:   Set the Indexing Service to automatic start.
//
//  Returns:    TRUE if operation succeeded
//
//  History:    07-Jul-1998   KyleP   Created
//
//----------------------------------------------------------------------------

BOOL CMachineAdmin::EnableCI()
{
    if ( !OpenSCM() )
        return FALSE;


    BOOL fOk = ChangeServiceConfig( _xSCCI.Get(),             // Handle
                                    SERVICE_NO_CHANGE,        // Type of service (no change)
                                    SERVICE_AUTO_START,       // Auto-start
                                    SERVICE_NO_CHANGE,        // Severity if service fails to start (no change)
                                    0,                        // Service binary file name (no change)
                                    0,                        // Load ordering group name (no change)
                                    0,                        // Tag identifier (no change)
                                    0,                        // Dependency names (no change)
                                    0,                        // Name of service account (no change)
                                    0,                        // Password for service account (no change)
                                    0 );                      // Display name (no change)

    if ( !fOk )
    {
        ciDebugOut(( DEB_ERROR, "ChangeServiceConfig Failed: %d\n",GetLastError() ));
    }

    return fOk;
}

//+---------------------------------------------------------------------------
//
//  Member:     CMachineAdmin::DisableCI, public
//
//  Synopsis:   Set the Indexing Service to manual start.
//
//  Returns:    TRUE if operation succeeded
//
//  History:    07-Jul-1998   KyleP   Created
//
//----------------------------------------------------------------------------

BOOL CMachineAdmin::DisableCI()
{
    if ( !OpenSCM() )
        return FALSE;


    BOOL fOk = ChangeServiceConfig( _xSCCI.Get(),             // Handle
                                    SERVICE_NO_CHANGE,        // Type of service (no change)
                                    SERVICE_DEMAND_START,     // Auto-start
                                    SERVICE_NO_CHANGE,        // Severity if service fails to start (no change)
                                    0,                        // Service binary file name (no change)
                                    0,                        // Load ordering group name (no change)
                                    0,                        // Tag identifier (no change)
                                    0,                        // Dependency names (no change)
                                    0,                        // Name of service account (no change)
                                    0,                        // Password for service account (no change)
                                    0 );                      // Display name (no change)

    if ( !fOk )
    {
        ciDebugOut(( DEB_ERROR, "ChangeServiceConfig Failed: %d\n",GetLastError() ));
    }

    return fOk;
}

//+---------------------------------------------------------------------------
//
//  Member:     CMachineAdmin::OpenSCM, private
//
//  Synopsis:   Open service controller
//
//  Returns:    TRUE if SCM was opened successfully
//
//  History:    3-Oct-97   KyleP   Created
//
//----------------------------------------------------------------------------

BOOL CMachineAdmin::OpenSCM()
{
    if ( _xSCCI.IsOk() )
        return TRUE;

    _xSCRoot.Set( OpenSCManager( IsLocal() ? 0 : _xwcsMachName.Get(),
                                 0,
                                 GENERIC_READ |
                                 GENERIC_WRITE |
                                 GENERIC_EXECUTE |
                                 SC_MANAGER_ALL_ACCESS ) );

    Win4Assert( _xSCRoot.IsOk() );

    if ( _xSCRoot.IsOk() )
    {
        _xSCCI.Set( OpenService( _xSCRoot.Get(),
                                 L"cisvc",
                                 SERVICE_ALL_ACCESS ) );
    }

    return _xSCCI.IsOk();
}

//+---------------------------------------------------------------------------
//
//  Member:     CMachineAdmin::TunePerformance, public
//
//  Synopsis:   Tune Indexing Service parameters for Indexing.
//
//  Parameters: [fServer]   -- True if the machine is a Server.
//              [wIndexingPerf] -- Desired level of Indexing performance.
//              [wQueryingPerf] -- Desired level of querying performance.
//
//  History:    7-Oct-98   KrishnaN   Created
//
//----------------------------------------------------------------------------

void CMachineAdmin::TunePerformance(BOOL fServer, WORD wIndexingPerf,
                                    WORD wQueryingPerf)
{
   TuneFilteringParameters(fServer, wIndexingPerf, wQueryingPerf);
   TuneMergeParameters(fServer, wIndexingPerf, wQueryingPerf);
   TunePropCacheParameters(fServer, wIndexingPerf, wQueryingPerf);
   TuneMiscellaneousParameters(fServer, wIndexingPerf, wQueryingPerf);
}

//+---------------------------------------------------------------------------
//
//  Member:     CMachineAdmin::TuneFilteringParameters, private
//
//  Synopsis:   Tune filtering parameters.
//
//  Parameters: [fServer]   -- True if the machine is a Server.
//              [wIndexingPerf] -- Desired level of Indexing performance.
//              [wQueryingPerf] -- Desired level of querying performance.
//
//  History:    7-Oct-98   KrishnaN   Created
//
//----------------------------------------------------------------------------

#pragma warning(push)
#pragma warning(disable:4296)

void CMachineAdmin::TuneFilteringParameters(BOOL fServer, WORD wIndexingPerf,
                                            WORD wQueryingPerf)
{
    // FilterRetryInterval - Controls how often the filter daemon will attempt to
    // refilter a document currently open elsewhere. Decrease interval for aggressive indexing
    // behavior. Leave it at default for moderate behavior. Leave it near max for
    // low key indexing.

    // MaxFileSizeFiltered - No need to change this to tweak aggressiveness.

    // FilterRetries - Controls the max number of times refiltering will be
    // attempted. Approach max for aggressive indexing behavior so we can index
    // as many docs as we can. Leave it at default for moderate behavior. Approach
    // the min value for low key indexing.

    // MaxDaemonVmUse - Maximum amount of pagefile space consumed by out-of-process filter
    // daemon. No need to change this to tweak aggressiveness.


    Win4Assert(wIndexingPerf <= wHighPos && wIndexingPerf >= wLowPos);

    DWORD dwFilterRetryInterval, dwFilterRetries, dwFilterDelayInterval,
          dwFilterRemainingThreshold, dwSecQFilterRetries;

    switch (wIndexingPerf)
    {
        case wHighPos:
            dwFilterRetryInterval = 5;
            dwFilterRetries = 2;
            dwSecQFilterRetries = CI_SECQ_FILTER_RETRIES_MIN + 1;   // try max number of times before giving up
            dwFilterDelayInterval = 5; // 5 second wait in the daemon...
            dwFilterRemainingThreshold = 5; // when there are this many docs left
            break;

        case wMidPos:
            dwFilterRetryInterval = CI_FILTER_RETRY_INTERVAL_DEFAULT / 2;
            dwFilterRetries = CI_FILTER_RETRIES_DEFAULT;
            dwSecQFilterRetries = CI_SECQ_FILTER_RETRIES_DEFAULT;
            dwFilterDelayInterval = CI_FILTER_DELAY_INTERVAL_DEFAULT;
            dwFilterRemainingThreshold = CI_FILTER_REMAINING_THRESHOLD_DEFAULT;
            break;

        case wLowPos:
            dwFilterRetryInterval = CI_FILTER_RETRY_INTERVAL_DEFAULT * 2;
            dwFilterRetries = CI_FILTER_RETRIES_MIN;
            dwSecQFilterRetries = CI_SECQ_FILTER_RETRIES_DEFAULT;
            dwFilterDelayInterval = CI_FILTER_DELAY_INTERVAL_DEFAULT;
            dwFilterRemainingThreshold = CI_FILTER_REMAINING_THRESHOLD_DEFAULT;
            break;

        default:
            Win4Assert(!"How did we get here?");
            break;
    }

    Win4Assert(dwFilterRetryInterval <= CI_FILTER_RETRY_INTERVAL_MAX &&
               dwFilterRetryInterval >= CI_FILTER_RETRY_INTERVAL_MIN);
    Win4Assert(dwFilterDelayInterval <= CI_FILTER_DELAY_INTERVAL_MAX &&
               dwFilterDelayInterval >= CI_FILTER_DELAY_INTERVAL_MIN);
    Win4Assert(dwFilterRemainingThreshold <= CI_FILTER_REMAINING_THRESHOLD_MAX &&
               dwFilterRemainingThreshold >= CI_FILTER_REMAINING_THRESHOLD_MIN);
    Win4Assert(dwSecQFilterRetries <= CI_SECQ_FILTER_RETRIES_MAX &&
               dwSecQFilterRetries >= CI_SECQ_FILTER_RETRIES_MIN);
    Win4Assert(dwFilterRetries <= CI_FILTER_RETRIES_MAX &&
               dwFilterRetries >= CI_FILTER_RETRIES_MIN);

    // Set registry parameters

    SetDWORDParam( wcsFilterRetryInterval, dwFilterRetryInterval );
    SetDWORDParam( wcsFilterDelayInterval, dwFilterDelayInterval );
    SetDWORDParam( wcsFilterRetries, dwFilterRetries );
    SetDWORDParam( wcsSecQFilterRetries, dwSecQFilterRetries );
    SetDWORDParam( wcsFilterRemainingThreshold, dwFilterRemainingThreshold );
} //TuneFilteringParameters

#pragma warning(pop)

//+---------------------------------------------------------------------------
//
//  Member:     CMachineAdmin::TuneMergeParameters, private
//
//  Synopsis:   Tune merging parameters.
//
//  Parameters: [fServer]   -- True if the machine is a Server.
//              [wIndexingPerf] -- Desired level of Indexing performance.
//              [wQueryingPerf] -- Desired level of querying performance.
//
//  History:    7-Oct-98   KrishnaN   Created
//
//----------------------------------------------------------------------------

void CMachineAdmin::TuneMergeParameters(BOOL fServer, WORD wIndexingPerf,
                                        WORD wQueryingPerf)
{
    // MasterMergeCheckPointInterval - Determines how much work (data written to the
    // new master index) to redo in case a master merge is paused and restarted. Ignore
    // this because it should be an uncommon occurrence.

    // MaxFreshCount - Max # of files whose latest indexed data is not in the master
    // index. When this limit is reached, a master merge will be started. For aggressive
    // indexing we want to set this param to a high value to minimize the disk intensive
    // master merges. For other situations, let this be the default value.

    // MaxIdealIndexes - Maximum number of indices considered acceptable in a
    // well-tuned system. When the number of indices climbs above this number and the
    // system is idle then an annealing merge will take place to bring the total
    // count of indices to this number. I think this should be left alone.

    // MaxMergeInterval - Sleep time between merges. Index Server activates this often
    // to determine if a merge is necessary. Usually an annealing merge, but may be a
    // shadow or master merge. I think this should be left alone.

    // MaxWordlistSize - Maximum amount of memory consumed by an individual word list.
    // When this limit is reached, only the document being filtered will be added.
    // Additional documents will be refiled and later placed in another word list. I think
    // this should be left alone because we will be in a classic space-time tradeoff
    // irrespective of how it is tuned.

    // MaxWordLists - Max number of word lists that can exist at one time. The more there'
    // are, the less often you need to merge. For aggressive indexing behavior, use more
    // word lists. Use default value for the other cases.

    // MaxWordlistIo - More than this amount of I/O results in a delay before creating
    // a word list. For aggressive indexing, let this value be higher. Lower it for less
    // aggressive indexing.

    // MinMergeIdleTime - If average system idle time for the last merge check period
    // is greater than this value, then an annealing merge can be performed. I think
    // this can be ignored.

    // MinSizeMergeWordlist - Minimum combined size of word lists that will force a
    // shadow merge. For aggressive indexing behavior increase the minimum size to
    // prevent frequent shadow merges. Leave this at default for other cases.

    // MinWordlistMemory - Minimum free memory for word list creation. Leave it alone.
    // Tweaking this will introduce you to a time-space tradeoff.

    Win4Assert(wIndexingPerf <= wHighPos && wIndexingPerf >= wLowPos);

    DWORD dwMaxFreshCount, dwMaxWordlists, dwMinSizeMergeWordlist, dwMaxWordlistIo;
    DWORD dwMaxWordlistIoDiskPerf, dwMaxIndexes, dwMaxFreshDeletes;

    switch (wIndexingPerf)
    {
        case wHighPos:
            dwMaxFreshCount = 100000;
            dwMaxWordlists = (CI_MAX_WORDLISTS_MAX + CI_MAX_WORDLISTS_DEFAULT) / 2;
            dwMaxWordlistIo = CI_MAX_WORDLIST_IO_MAX;
            dwMinSizeMergeWordlist = CI_MIN_SIZE_MERGE_WORDLISTS_DEFAULT * 4;
            dwMaxWordlistIoDiskPerf = CI_MAX_WORDLIST_IO_DISKPERF_MAX;
            dwMaxIndexes = 50;
            dwMaxFreshDeletes = 10000;
            break;

        case wMidPos:
            dwMaxFreshCount = CI_MAX_FRESHCOUNT_DEFAULT;
            dwMaxWordlists = CI_MAX_WORDLISTS_DEFAULT;
            dwMaxWordlistIo = CI_MAX_WORDLIST_IO_DEFAULT * 2;
            dwMinSizeMergeWordlist = CI_MIN_SIZE_MERGE_WORDLISTS_DEFAULT;
            dwMaxWordlistIoDiskPerf = CI_MAX_WORDLIST_IO_DISKPERF_DEFAULT;
            dwMaxIndexes = 25;
            dwMaxFreshDeletes = CI_MAX_FRESH_DELETES_DEFAULT;
            break;

        case wLowPos:
            dwMaxFreshCount = CI_MAX_FRESHCOUNT_DEFAULT;
            dwMaxWordlists = CI_MAX_WORDLISTS_MIN; 
            dwMaxWordlistIo = CI_MAX_WORDLIST_IO_DEFAULT;
            dwMinSizeMergeWordlist = CI_MIN_SIZE_MERGE_WORDLISTS_DEFAULT - 50;
            dwMaxWordlistIoDiskPerf = CI_MAX_WORDLIST_IO_DISKPERF_DEFAULT; // MIN may be too low
            dwMaxIndexes = 20;
            dwMaxFreshDeletes = CI_MAX_FRESH_DELETES_DEFAULT;
            break;

        default:
            Win4Assert(!"How did we get here?");
            break;
    }
 
    Win4Assert(dwMaxFreshCount <= CI_MAX_FRESHCOUNT_MAX &&
               dwMaxFreshCount >= CI_MAX_FRESHCOUNT_MIN);
    Win4Assert(dwMaxWordlists <= CI_MAX_WORDLISTS_MAX &&
               dwMaxWordlists >= CI_MAX_WORDLISTS_MIN);
    Win4Assert(dwMaxWordlistIo <= CI_MAX_WORDLIST_IO_MAX &&
               dwMaxWordlistIo >= CI_MAX_WORDLIST_IO_MIN);
    Win4Assert(dwMinSizeMergeWordlist <= CI_MIN_SIZE_MERGE_WORDLISTS_MAX &&
               dwMinSizeMergeWordlist >= CI_MIN_SIZE_MERGE_WORDLISTS_MIN);
    Win4Assert(dwMaxWordlistIoDiskPerf <= CI_MAX_WORDLIST_IO_DISKPERF_MAX &&
               dwMaxWordlistIoDiskPerf >= CI_MAX_WORDLIST_IO_DISKPERF_MIN);
    Win4Assert(dwMaxIndexes <= CI_MAX_INDEXES_MAX &&
               dwMaxIndexes >= CI_MAX_INDEXES_MIN);
    Win4Assert(dwMaxFreshDeletes <= CI_MAX_FRESH_DELETES_MAX &&
               dwMaxFreshDeletes >= CI_MAX_FRESH_DELETES_MIN);
 
    SetDWORDParam( wcsMaxFreshCount, dwMaxFreshCount );
    SetDWORDParam( wcsMaxWordLists, dwMaxWordlists );
    SetDWORDParam( wcsMaxWordlistIo, dwMaxWordlistIo );
    SetDWORDParam( wcsMinSizeMergeWordlists, dwMinSizeMergeWordlist );
    SetDWORDParam( wcsMaxWordlistIoDiskPerf, dwMaxWordlistIoDiskPerf );
    SetDWORDParam( wcsMaxIndexes, dwMaxIndexes );
    SetDWORDParam( wcsMaxFreshDeletes, dwMaxFreshDeletes );
} //TuneMergeParameters

//+---------------------------------------------------------------------------
//
//  Member:     CMachineAdmin::TunePropCacheParameters, private
//
//  Synopsis:   Tune prop cache parameters.
//
//  Parameters: [fServer]   -- True if the machine is a Server.
//              [wIndexingPerf] -- Desired level of Indexing performance. Try to
//                                 tune for this desired level within the
//                                 constraints imposed by resource usage.
//
//  History:    7-Oct-98   KrishnaN   Created
//
//----------------------------------------------------------------------------

#pragma warning(push)
#pragma warning(disable:4296)

void CMachineAdmin::TunePropCacheParameters(BOOL fServer, WORD wIndexingPerf,
                                            WORD wQueryingPerf)
{
    // PrimaryStoreMappedCache and SecondaryStoreMappedCache control how much
    // of the property cache is in memory. The higher, the greater is indexing
    // and search performance. Since it affects both, use wIndexingPerf and
    // wQueryingPerf to control the params.

    WORD wAvgPerf = (wIndexingPerf + wQueryingPerf + 1)/2;  // roundup

    DWORD dwPSMappedCache, dwSSMappedCache;

    Win4Assert(wAvgPerf <= wHighPos && wAvgPerf >= wLowPos);

    // 0 is minimum; 16 is default; 0xFFFFFFFF is maximum
    switch (wAvgPerf)
    {
        case wHighPos:
           // NTRAID#DB-NTBUG9-84518-2000/07/31-dlee Setting Indexing Service to the highest performance level doesn't keep the property store in RAM
           // The best thing to get max query perf is to have the entire store
           // in memory. It would be nice to have a special param (like 0xFFFFFFFF) to tell
           // propstore to do the right thing and use just the right data structure to map
           // the entire propstore in memory.
           dwPSMappedCache = dwSSMappedCache = CI_PROPERTY_STORE_MAPPED_CACHE_DEFAULT * 8;
           break;

        case wMidPos:
           dwPSMappedCache = dwSSMappedCache = CI_PROPERTY_STORE_MAPPED_CACHE_DEFAULT * 2;
           break;

        case wLowPos:
           dwPSMappedCache = dwSSMappedCache = CI_PROPERTY_STORE_MAPPED_CACHE_DEFAULT;
           break;

        default:
           Win4Assert(!"How did we get here?");
           break;
    }

    // PrimaryStoreBackupSize and SecondaryStoreBackupSize control (partially)
    // how often the prop cache has to be flushed to disk. The less often, the
    // faster Indexing can proceed. This has little impact on querying, so use
    // only wIndexingPerf to set the params.

    DWORD dwPSBackupSize, dwSSBackupSize;

    // 32 is minimum; 1024 is default; 500000 is maximum.
    switch (wIndexingPerf)
    {
        case wHighPos:
        case wMidPos:
           dwPSBackupSize = dwSSBackupSize = CI_PROPERTY_STORE_BACKUP_SIZE_DEFAULT;
           break;

        case wLowPos:
           dwPSBackupSize = dwSSBackupSize = CI_PROPERTY_STORE_BACKUP_SIZE_DEFAULT / 2;
           break;

        default:
           Win4Assert(!"How did we get here?");
           break;
    }

    Win4Assert(dwPSMappedCache >= CI_PROPERTY_STORE_MAPPED_CACHE_MIN &&
               dwPSMappedCache <= CI_PROPERTY_STORE_MAPPED_CACHE_MAX);
    Win4Assert(dwSSMappedCache >= CI_PROPERTY_STORE_MAPPED_CACHE_MIN &&
               dwSSMappedCache <= CI_PROPERTY_STORE_MAPPED_CACHE_MAX);
    Win4Assert(dwPSBackupSize >= CI_PROPERTY_STORE_BACKUP_SIZE_MIN &&
               dwPSBackupSize <= CI_PROPERTY_STORE_BACKUP_SIZE_MAX);
    Win4Assert(dwSSBackupSize >= CI_PROPERTY_STORE_BACKUP_SIZE_MIN &&
               dwSSBackupSize <= CI_PROPERTY_STORE_BACKUP_SIZE_MAX);

    SetDWORDParam( wcsPrimaryStoreMappedCache, dwPSMappedCache );
    SetDWORDParam( wcsSecondaryStoreMappedCache, dwSSMappedCache );
    SetDWORDParam( wcsPrimaryStoreBackupSize, dwPSBackupSize );
    SetDWORDParam( wcsSecondaryStoreBackupSize, dwSSBackupSize );
}

#pragma warning(pop)

//+---------------------------------------------------------------------------
//
//  Member:     CMachineAdmin::TuneMiscellaneousParameters, private
//
//  Synopsis:   Tune filtering parameters.
//
//  Parameters: [fServer]   -- True if the machine is a Server.
//              [wIndexingPerf] -- Desired level of Indexing performance. Try to
//                                 tune for this desired level within the
//                                 constraints imposed by resource usage.
//
//  History:    7-Oct-98   KrishnaN   Created
//
//----------------------------------------------------------------------------

#pragma warning(push)
#pragma warning(disable:4296)

void CMachineAdmin::TuneMiscellaneousParameters(BOOL fServer, WORD wIndexingPerf,
                                                WORD wQueryingPerf)
{
    // MinWordlistBattery - This controls when battery operated machines should have indexing turned off
    // to prevent rapid power erosion triggered by incessant disk activity. For aggressive indexing, ignore
    // battery power and keep on chugging. For cautious indexing, turn off indexing when running on battery.

    // WordlistUserIdle - User idle time required to keep filtering running. For aggressive indexing, always
    // keep running. For moderate indexing, use the default value. To keep a low profile, use a value closer
    // to the max, which indicates that the user has to be idle for quite a while bofore indexing can resume.

    // LowResourceSleep - How long to wait after a low resource condition before trying again.

    // ScanBackoff - Backoff from scanning based on some conditions. For aggressive indexing, back off a bit.
    // For low key indexing, use a value closer to the max value.

    // MaxUsnLogSize - Irrelevant for performance.

    // UsnLogAllocationDelta - Irrelevant for performance.

    // UsnReadTimeOut - This is the maximum amount of time the system waits before sending out
    // a USN notification (it works in conjuction with the UsnReadMinSize. When one of these two
    // conditions trigger, we get a USN notification). For aggressive indexing behavior, we want
    // this parameter to be as small as possible so we can receive notifications of file changes
    // almost instantaneously.

    // UsnReadMinSize - The minimum size of the changes beyond which a USN notification will
    // be sent. For aggressive indexing behavior we want this to be set at 1 so that any change
    // will be communicated instananeously.

    // DelayUsnReadOnLowResource  - Determines whether USN read should be delayed when machine is busy.
    // Set this to FALSE for aggressive indexing and TRUE for the other cases.

    DWORD dwMinWordlistBattery, dwWordlistUserIdle, dwScanBackoff, dwLowResourceSleep;
    DWORD dwUsnReadTimeout, dwUsnReadMinSize, dwDelayUsnReadOnLowResource;

    switch (wIndexingPerf)
    {
        case wHighPos:
            dwMinWordlistBattery = CI_MIN_WORDLIST_BATTERY_MIN;   // always filter, irrespective of battery power
            dwWordlistUserIdle = CI_WORDLIST_USER_IDLE_MIN; // always run
            dwScanBackoff = CI_SCAN_BACKOFF_MIN;
            dwLowResourceSleep = CI_LOW_RESOURCE_SLEEP_MIN;

            // USN parameters
            dwUsnReadTimeout = CI_USN_READ_TIMEOUT_MIN;  // Don't wait to notify!
            dwUsnReadMinSize = CI_USN_READ_MIN_SIZE_MIN; // Notify even if one byte changes!
            dwDelayUsnReadOnLowResource = 0x0;           // Don't delay!

            break;

        case wMidPos:
            dwMinWordlistBattery = CI_MIN_WORDLIST_BATTERY_DEFAULT;
            dwWordlistUserIdle = CI_WORDLIST_USER_IDLE_DEFAULT / 2; // index if user is idle for a minute
            dwScanBackoff = CI_SCAN_BACKOFF_DEFAULT;
            dwLowResourceSleep = CI_LOW_RESOURCE_SLEEP_DEFAULT / 2;

            // USN parameters
            dwUsnReadTimeout = CI_USN_READ_TIMEOUT_DEFAULT;
            dwUsnReadMinSize = CI_USN_READ_MIN_SIZE_DEFAULT;
            dwDelayUsnReadOnLowResource = 0x1;           // Delay!
            break;

        case wLowPos:
            dwMinWordlistBattery = CI_MIN_WORDLIST_BATTERY_MAX;   // Don't filter when on battery
            dwWordlistUserIdle = CI_WORDLIST_USER_IDLE_DEFAULT;
            dwScanBackoff = CI_SCAN_BACKOFF_DEFAULT;
            dwLowResourceSleep = CI_LOW_RESOURCE_SLEEP_DEFAULT;

            // USN parameters
            dwUsnReadTimeout = 2 * CI_USN_READ_TIMEOUT_DEFAULT;
            dwUsnReadMinSize = 2 * CI_USN_READ_MIN_SIZE_DEFAULT;
            dwDelayUsnReadOnLowResource = 0x1;           // Delay!
            break;

  