nvalidParameter);
        goto cleanup;
    }

    memset(&columns, 0, sizeof(columns));
    columns.cbStruct = sizeof(JET_COLUMNLIST);
    cbMax = sizeof(JET_COLUMNLIST);

    m_JetErr = JetGetColumnInfo(
                            GetJetSessionID(),
                            GetJetDatabaseID(),
                            lpszTableName,
                            NULL,
                            (PVOID)&columns,
                            cbMax,
                            1                   // retrieve column list
                        );
    if(IsSuccess() == FALSE)
        goto cleanup;

    //
    // Table has just been created
    //
    if(columns.cRecord == 0)
        goto cleanup;

    m_JetColumns = new JBColumn[columns.cRecord];
    if(m_JetColumns == NULL)
    {
        SetLastJetError(JET_errOutOfMemory);
        goto cleanup;
    }

    SetLastJetError(JET_errSuccess);

    //
    // TODO - use JBColumn class to retrieve value
    //
    m_NumJetColumns = columns.cRecord;
    for(index=0;
        index < columns.cRecord && IsSuccess() == TRUE;
        index++)
    {
        m_JetColumns[index].AttachToTable(this);

        if(m_JetColumns[index].LoadJetColumnInfoFromJet(&columns) == FALSE)
        {
            m_JetErr = m_JetColumns[index].GetLastJetError();
            break;
        }

        m_JetErr = JetMove(
                            GetJetSessionID(),
                            columns.tableid,
                            JET_MoveNext,
                            0
                        );

    }

    if(GetLastJetError() == JET_errNoCurrentRecord && index >= columns.cRecord)
    {
        // otherwise - got to be a JetBlue bug here.
        SetLastJetError(JET_errSuccess);
    }


    //
    //
    //
cleanup:

    FreeJBstr(lpszTableName);
    if(IsSuccess() == FALSE && m_JetColumns)
    {
        delete [] m_JetColumns;
        m_JetColumns = NULL;
        m_NumJetColumns = 0;
    }

    return IsSuccess();
#else
    LPSTR lpszTableName=NULL;
    JET_COLUMNLIST columns;
    unsigned long cbMax;
    JET_RETINFO jetRetInfo;
    unsigned long cbActual;
    char lpszColumnName[MAX_JETBLUE_NAME_LENGTH+1];
    int NumChars;
    unsigned long index;
    SINGLE_JET_CALL;


    if(ConvertWstrToJBstr(GetTableName(), &lpszTableName) == FALSE)
    {
        SetLastJetError(JET_errInvalidParameter);
        goto cleanup;
    }

    memset(&columns, 0, sizeof(columns));
    columns.cbStruct = sizeof(JET_COLUMNLIST);
    cbMax = sizeof(JET_COLUMNLIST);


    m_JetErr = JetGetColumnInfo(
                            GetJetSessionID(),
                            GetJetDatabaseID(),
                            lpszTableName,
                            NULL,
                            (PVOID)&columns,
                            cbMax,
                            1                   // retrieve column list
                        );
    if(IsSuccess() == FALSE)
        goto cleanup;

    //
    // Table has just been created
    //
    if(columns.cRecord == 0)
        goto cleanup;

    // retrieve column name, column id, column type and column size
    m_Columns = (PJetColumns) AllocateMemory(sizeof(JetColumns) * columns.cRecord);
    if(m_Columns == NULL)
    {
        SetLastJetError(JET_errOutOfMemory);
        goto cleanup;
    }

    SetLastJetError(JET_errSuccess);

    //
    // TODO - use JBColumn class to retrieve value
    //
    m_NumColumns = columns.cRecord;
    for(index=0;
        index < columns.cRecord && IsSuccess() == TRUE;
        index++)
    {
        memset(&jetRetInfo, 0, sizeof(JET_RETINFO));
        jetRetInfo.cbStruct = sizeof(JET_RETINFO);

        // retrieve column name
        m_JetErr = JetRetrieveColumn(
                                GetJetSessionID(),
                                columns.tableid,
                                columns.columnidcolumnname,
                                lpszColumnName,
                                sizeof(lpszColumnName),
                                &cbActual,
                                0,
                                &jetRetInfo
                            );

        if(IsSuccess() == FALSE)
            continue;

        NumChars = MultiByteToWideChar(
                            GetACP(),
                            MB_PRECOMPOSED,
                            lpszColumnName,
                            cbActual,
                            (m_Columns+index)->pszColumnName,
                            sizeof((m_Columns+index)->pszColumnName)
                        );

        if(NumChars == 0)
        {
            SetLastJetError(JET_errInvalidParameter);
            continue;
        }

        memset(&jetRetInfo, 0, sizeof(JET_RETINFO));
        jetRetInfo.cbStruct = sizeof(JET_RETINFO);

        // retrieve column ID
        m_JetErr = JetRetrieveColumn(
                                GetJetSessionID(),
                                columns.tableid,
                                columns.columnidcolumnid,
                                &((m_Columns+index)->colId),
                                sizeof((m_Columns+index)->colId),
                                &cbActual,
                                0,
                                &jetRetInfo
                            );

        if(IsSuccess() == FALSE)
            continue;

        memset(&jetRetInfo, 0, sizeof(JET_RETINFO));
        jetRetInfo.cbStruct = sizeof(JET_RETINFO);

        m_JetErr = JetRetrieveColumn(
                                GetJetSessionID(),
                                columns.tableid,
                                columns.columnidcoltyp,
                                &((m_Columns+index)->colType),
                                sizeof((m_Columns+index)->colType),
                                &cbActual,
                                0,
                                &jetRetInfo
                            );

        if(IsSuccess() == FALSE)
            continue;

        memset(&jetRetInfo, 0, sizeof(JET_RETINFO));
        jetRetInfo.cbStruct = sizeof(JET_RETINFO);

        m_JetErr = JetRetrieveColumn(
                                GetJetSessionID(),
                                columns.tableid,
                                columns.columnidcbMax,
                                &((m_Columns+index)->cbMaxLength),
                                sizeof((m_Columns+index)->cbMaxLength),
                                &cbActual,
                                0,
                                &jetRetInfo
                            );

        if(IsSuccess() == FALSE)
            continue;

        memset(&jetRetInfo, 0, sizeof(JET_RETINFO));
        jetRetInfo.cbStruct = sizeof(JET_RETINFO);

        m_JetErr = JetRetrieveColumn(
                                GetJetSessionID(),
                                columns.tableid,
                                columns.columnidgrbit,
                                &((m_Columns+index)->jbGrbit),
                                sizeof((m_Columns+index)->jbGrbit),
                                &cbActual,
                                0,
                                &jetRetInfo
                            );
        DebugOutput(
                _TEXT("Loaded Column name %s, Column Type %d, Column ID %d\n"),
                m_Columns[index].pszColumnName,
                m_Columns[index].colType,
                m_Columns[index].colId
            );

        if(IsSuccess() == FALSE)
            continue;

        m_JetErr = JetMove(
                            GetJetSessionID(),
                            columns.tableid,
                            JET_MoveNext,
                            0
                        );

    }

    if(GetLastJetError() == JET_errNoCurrentRecord && index >= columns.cRecord)
    {
        // otherwise - got to be a JetBlue bug here.
        SetLastJetError(JET_errSuccess);
    }


    //
    //
    //
cleanup:
    FreeJBstr(lpszTableName);
    if(IsSuccess() == FALSE && m_Columns)
    {
        FreeMemory(m_Columns);
        m_Columns = NULL;
        m_NumColumns = 0;
    }

    return IsSuccess();
#endif
}


//-------------------------------------------------------------

JET_COLUMNID
JBTable::GetJetColumnID(
    LPCTSTR pszColumnName
    )
/*
*/
{
    int index;

    index = GetJetColumnIndex(pszColumnName);
    if(index < 0 || index >= m_NumJetColumns)
    {
        return (DWORD)JET_NIL_COLUMN;
    }

    return m_JetColumns[index].GetJetColumnID();
}

//-------------------------------------------------------------

int
JBTable::GetJetColumnIndex(
    LPCTSTR pszColumnName
    )
/*
*/
{
    if(m_JetColumns == NULL || m_NumJetColumns == 0)
    {
        SetLastJetError(JET_errNotInitialized);
        return -1;
    }

    for(int index=0; index < m_NumJetColumns; index++)
    {
        if(_tcsicmp(m_JetColumns[index].GetJetColumnName(), pszColumnName) == 0)
            break;
    }

    return (index >= m_NumJetColumns) ? -1 : index;
}

//-------------------------------------------------------------

JBColumn*
JBTable::FindColumnByIndex(
    const int index
    )
/*
*/
{
    if(m_JetColumns == NULL || m_NumJetColumns == 0)
    {
        SetLastJetError(JET_errNotInitialized);
        return NULL;
    }

    if(index < 0 || index >= m_NumJetColumns)
    {
        SetLastJetError(JET_errInvalidParameter);
        return NULL;
    }

    return m_JetColumns+index;
}

//--------------------------------------------------------------

JBColumn*
JBTable::FindColumnByColumnId(
    const JET_COLUMNID JetColId
    )
/*
*/
{
    if(m_JetColumns == NULL || m_NumJetColumns == 0)
    {
        SetLastJetError(JET_errNotInitialized);
        return NULL;
    }

    for(int index=0; index < m_NumJetColumns; index++)
    {
        if(m_JetColumns[index].GetJetColumnID() == JetColId)
            break;
    }

    return FindColumnByIndex( index );
}

//--------------------------------------------------------------

JBColumn*
JBTable::FindColumnByName(
    LPCTSTR pszColumnName
    )
/*
*/
{
    return FindColumnByIndex(GetJetColumnIndex(pszColumnName));
}

//--------------------------------------------------------------

BOOL
JBTable::BeginUpdate(
    BOOL bUpdate /* false */
    )
/*
*/
{
    if(GetTransactionLevel() == 0)
    {
        SetLastJetError(JET_errNotInTransaction);
        JB_ASSERT(FALSE);
        return FALSE;
    }

    SINGLE_JET_CALL;

    m_JetErr = JetPrepareUpdate(
                            GetJetSessionID(),
                            GetJetTableID(),
                            (bUpdate) ? JET_prepReplace : JET_prepInsert
                        );

    return IsSuccess();
}

//-------------------------------------------------------------

BOOL
JBTable::EndUpdate(
    BOOL bDisacrd /* FALSE */
    )
/*
*/
{
    BYTE pBookmark[JET_cbBookmarkMost+1];
    DWORD cbActual = 0;

    SINGLE_JET_CALL;

    //
    // Hack for work item table.
    //
    m_JetErr = JetUpdate(
                        GetJetSessionID(),
                        GetJetTableID(),
                        pBookmark,
                        JET_cbBookmarkMost,
                        &cbActual
                    );

    if(IsSuccess() && m_InsertRepositionBookmark)
    {
        GotoBookmark(pBookmark, cbActual);
    }

    return IsSuccess();
}

//-------------------------------------------------------------
BOOL
JBTable::SetCurrentIndex(
    LPCTSTR pszIndexName,
    JET_GRBIT grbit /* JET_bitMoveFirst */
    )
/*++

--*/
{
    if(IsValid() == FALSE || m_InEnumeration == TRUE)
    {
        SetLastJetError(JET_errNotInitialized);
        return FALSE;
    }

    //
    // Can't be in enumeration and and try to set index
    //
    JB_ASSERT(m_InEnumeration == FALSE);

    char* lpszIndexName=NULL;

    if(ConvertWstrToJBstr(pszIndexName, &lpszIndexName) == FALSE)
    {
        SetLastJetError(JET_errInvalidParameter);
        goto cleanup;
    }

    {
        SINGLE_JET_CALL;

        m_JetErr = JetSetCurrentIndex2(
                            GetJetSessionID(),
                            GetJetTableID(),
                            lpszIndexName,
                            grbit
                        );
    }

    if(IsSuccess())
    {
        m_InEnumeration = TRUE;
    }

cleanup:

    FreeJBstr(lpszIndexName);
    return IsSuccess();
}

//-------------------------------------------------------------

BOOL
JBTable::EnumBegin(
    LPCTSTR pszIndexName,
    JET_GRBIT grbit /* JET_bitMoveFirst */
    )
/*
*/
{
    if(m_InEnumeration == TRUE)
    {
        //
        // Force terminate enumeration
        //
        EnumEnd();
    }

    return SetCurrentIndex(pszIndexName, grbit);
}

//-------------------------------------------------------------

JBTable::ENUM_RETCODE
JBTable::EnumNext(
    JET_GRBIT crow  /* JET_MoveNext */,
    JET_GRBIT grbit /* 0 */
    )
/*
*/
{
    if(m_InEnumeration == FALSE)
    {
        SetLastJetError(JET_errInvalidParameter);
        return ENUM_ERROR;
    }

    if(IsValid() == FALSE)
    {
        SetLastJetError(JET_errNotInitialized);
        return ENUM_ERROR;
    }

    ENUM_RETCODE retCode = ENUM_CONTINUE;

    while( retCode == ENUM_CONTINUE )
    {
        MoveToRecord(crow, grbit);

        switch(m_JetErr)
        {
            case JET_errSuccess:
                retCode = ENUM_SUCCESS;
                break;

            case JET_errNoCurrentRecord:
                retCode = ENUM_END;
                break;

            case JET_errRecordDeleted:
                retCode = ENUM_CONTINUE;
                break;

            default:
                retCode = ENUM_ERROR;
        }
    }

    return retCode;
}

//-------------------------------------------------------------

BOOL
JBTable::SeekToKey(
    JBKeyBase* key,
    DWORD dwSeachParam,
    JET_GRBIT jetseekgrbit /* =JET_bitSeekGE */
    )
/*
*/
{
    if(IsValid() == FALSE)
    {
        SetLastJetError(JET_errNotInitialized);
        return FALSE;
    }

#ifdef DEBUG_SEEK
    LPTSTR szKey=key->GetIndexKey();
#endif

    EnumBegin(
            key->GetIndexName(),
            JET_bitMoveFirst
        );

    if(IsSuccess() == FALSE)
        return FALSE;

    if(key->IsEmptyValue() == TRUE)
    {
        return TRUE;
    }

    PVOID pbData;
    unsigned long cbData;
    JET_GRBIT key_grbit=JET_bitNewKey;

    SetLastJetError(JET_errSuccess);

    for(DWORD dwComponent=0;
        dwComponent < key->GetNumKeyComponents();
        dwComponent++)
    {
        if(key->GetSearchKey(dwComponent, &pbData, &cbData, &key_grbit, dwSeachParam) == FALSE)
            break;

        if(MakeKey(pbData, cbData, key_grbit) == FALSE)
            break;
    }

#ifdef DEBUG_SEEK
    PVOID pb=NULL;
    DWORD cb=0;
    unsigned long actual;

    SINGLE_JET_CALL;

    m_JetErr = JetRetrieveKey(
                        GetJetSessionID(),
                        GetJetTableID(),
                        pb,
                        cb,
                        &actual,
                        0
                    );

    pb = (PVOID)AllocateMemory(actual);
    cb = actual;

    m_JetErr = JetRetrieveKey(
                        GetJetSessionID(),
                        GetJetTableID(),
                        pb,
                        cb,
                        &actual,
                        0
                    );

    FreeMemory(pb);
#endif

    return IsSuccess() ? SeekValue(jetseekgrbit) : FALSE;
}

//-------------------------------------------------------------

BOOL
JBTable::EnumBegin(
    JBKeyBase* key,
    DWORD dwSearchParam
    )
/*
*/
{
    if(IsValid() == FALSE)
    {
        SetLastJetError(JET_errNotInitialized);
        return FALSE;
    }

    if(m_InEnumeration == TRUE)
    {
        // what do we do???
    }

    return SeekToKey(key, dwSearchParam);
}



//-------------------------------------------------------------

BOOL
JBTable::GetCurrentIndex(
    LPTSTR pszIndexName,
    unsigned long* bufferSize
    )
/*
*/
{
    char lpszIndexName[MAX_JETBLUE_NAME_LENGTH+1];
    int NumChars=0;

    SINGLE_JET_CALL;

    m_JetErr = JetGetCurrentIndex(
                            GetJetSessionID(),
                            GetJetTableID(),
                            lpszIndexName,
                            sizeof(lpszIndexName)
                        );

    if(IsSuccess() == FALSE)
        goto cleanup;

    NumChars = MultiByteToWideChar(
                        GetACP(),
                        MB_PRECOMPOSED,
                        lpszIndexName,
                        -1,
                        pszIndexName,
                        *bufferSize
                    );

    if(NumChars == 0)
    {
        SetLastJetError(JET_errInvalidParameter);
        goto cleanup;
    }

    *bufferSize = NumChars;

cleanup:

    return IsSuccess();
}

//-------------------------------------------------------------

BOOL
JBTable::GetBookmark(
    PVOID pbBuffer,
    PDWORD pcbBufSize
    )
/*++

--*/
{
    DWORD cbBufferSize = *pcbBufSize;

    SINGLE_JET_CALL;

    m_JetErr = JetGetBookmark(
                        GetJetSessionID(),
                        GetJetTableID(),
                        pbBuffer,
                        cbBufferSize,
                        pcbBufSize
                    );

    if(m_JetErr == JET_errBufferTooSmall)
    {
        SetLastJetError(m_JetErr);
        SetLastError(ERROR_INSUFFICIENT_BUFFER);
    }

    return IsSuccess();
}

//-------------------------------------------------------------

BOOL
JBTable::GotoBookmark(
    PVOID pbBuffer,
    DWORD cbBuffer
    )
/*++

--*/
{
    SINGLE_JET_CALL;

    m_JetErr = JetGotoBookmark(
                            GetJetSessionID(),
                            GetJetTableID(),
                            pbBuffer,
                            cbBuffer
                        );

    return IsSuccess();
}

//-------------------------------------------------------------

BOOL
JBTable::ReadLock()
{
    SINGLE_JET_CALL;

    m_JetErr = JetGetLock(
                    GetJetSessionID(),
                    GetJetTableID(),
                    JET_bitReadLock
                );

    return IsSuccess();
}

//-------------------------------------------------------------

BOOL
JBTable::WriteLock()
{
    SINGLE_JET_CALL;

    m_JetErr = JetGetLock(
                    GetJetSessionID(),
                    GetJetTableID(),
                    JET_bitWriteLock
                );

    return IsSuccess();
}

//-------------------------------------------------------------

BOOL
JBTable::RetrieveKey(
    PVOID pbData,
    unsigned long cbData,
    unsigned long* pcbActual,
    JET_GRBIT grbit
    )
/*
*/
{
    unsigned long cbActual;
    SINGLE_JET_CALL;

    m_JetErr = JetRetrieveKey(
                        GetJetSessionID(),
                        GetJetTableID(),
                        pbData,
                        cbData,
                        (pcbActual) ? pcbActual : &cbActual,
                        grbit  // user2.doc - unuse.
                    );
    return IsSuccess();
}

//-------------------------------------------------------------

BOOL
JBTable::MoveToRecord(
    long crow,
    JET_GRBIT grbit
    )
/*
*/
{
    SINGLE_JET_CALL;
    m_JetErr = JetMove(
                    GetJetSessionID(),
                    GetJetTableID(),
                    crow,
                    grbit
                );

    return IsSuccess();
}

//-------------------------------------------------------------
unsigned long
JBTable::GetIndexRecordCount(
    unsigned long max
    )
/*
*/
{
    unsigned long count;
    SINGLE_JET_CALL;

    m_JetErr = JetIndexRecordCount(
                            GetJetSessionID(),
                            GetJetTableID(),
                            &count,
                            max
                        );

    return IsSuccess() ? count : 0;
}

//-------------------------------------------------------------

BOOL
JBTable::MakeKey(
    PVOID pbData,
    unsigned long cbData,
    JET_GRBIT grbit
    )
/*
*/
{
    SINGLE_JET_CALL;

    m_JetErr = JetMakeKey(
                        GetJetSessionID(),
                        GetJetTableID(),
                        pbData,
                        cbData,
                        grbit
                    );

    return IsSuccess();
}

//-------------------------------------------------------------

BOOL
JBTable::SeekValue(
    JET_GRBIT grbit
    )
/*
*/
{
    SINGLE_JET_CALL;

    m_JetErr = JetSeek(
                    GetJetSessionID(),
                    GetJetTableID(),
                    grbit
                );

    return IsSuccess();
}


//-------------------------------------------------------------

BOOL
JBTable::DeleteRecord()
/*
*/
{
    SINGLE_JET_CALL;

    // must have current record set
    m_JetErr = JetDelete(
                        GetJetSessionID(),
                        GetJetTableID()
                    );

    return IsSuccess();
}


//
//////////////////////////////////////////////////////////////
//
CLASS_PRIVATE void
JBColumn::Cleanup()
/*
*/
{
    memset(m_szColumnName, 0, sizeof(m_szColumnName));
}

//-----------------------------------------------------------

JBColumn::JBColumn(JBTable* pJetTable) :
m_pJetTable(pJetTable),
m_JetColId(0),
m_JetColType(JET_coltypNil),
m_JetMaxColLength(0),
m_JetGrbit(0),
m_JetColCodePage(TLS_JETBLUE_COLUMN_CODE_PAGE),
m_JetColCountryCode(TLS_JETBLUE_COLUMN_COUNTRY_CODE),
m_JetColLangId(TLS_JETBLUE_COLUMN_LANGID),
m_cbActual(0),
m_pbDefValue(NULL),
m_cbDefValue(0),
m_JetNullColumn(FALSE)
/*
*/
{
    Cleanup();
}

//-----------------------------------------------------------

CLASS_PRIVATE JET_ERR
JBColumn::RetrieveColumnValue(
    IN JET_SESID sesid,
    IN JET_TABLEID tableid,
    IN JET_COLUMNID columnid,
    IN OUT PVOID pbBuffer,
    IN unsigned long cbBuffer,
    IN unsigned long offset
    )
/*
*/
{
    m_JetRetInfo.cbStruct = sizeof(m_JetRetInfo);
    m_JetRetInfo.ibLongValue = offset;
    m_JetNullColumn = FALSE;
    m_cbActual = 0;

    SINGLE_JET_CALL;

    //
    // JETBLUE bug??? passing zeror buffer size returns Column NULL
    //
    m_JetErr = JetRetrieveColumn(
                            sesid,
                            tableid,
                            columnid,
                            pbBuffer,
                            cbBuffer,
                            &m_cbActual,
                            0,
                            NULL // &m_JetRetInfo
                        );

    if(m_JetErr == JET_wrnColumnNull)
        m_JetNullColumn = TRUE;

    return IsSuccess();
}

//-----------------------------------------------------------

CLASS_PRIVATE BOOL
JBColumn::LoadJetColumnInfoFromJet(
    const JET_COLUMNLIST* pColumnList
    )
/*
*/
{
    char lpszColumnName[MAX_JETBLUE_NAME_LENGTH+1];
    int NumChars;

    //
    // retrieve column name
    //
    RetrieveColumnValue(
                GetJetSessionID(),
                pColumnList->tableid,
                pColumnList->columnidcolumnname,
                lpszColumnName,
                sizeof(lpszColumnName)
            );

    if(IsSuccess() == FALSE)
        goto cleanup;

    NumChars = MultiByteToWideChar(
                        GetACP(),
                        MB_PRECOMPOSED,
                        lpszColumnName,
                        m_cbActual,
                        m_szColumnName,
                        sizeof(m_szColumnName)/sizeof(m_szColumnName[0])
                    );

    if(NumChars == 0)
    {
        SetLastJetError(JET_errInvalidParameter);
        goto cleanup;
    }

    //DebugOutput(
    //        _TEXT("Load column %s"),
    //        m_szColumnName
    //    );

    //
    // retrieve column ID
    //
    RetrieveColumnValue(
                GetJetSessionID(),
                pColumnList->tableid,
                pColumnList->columnidcolumnid,
                &m_JetColId,
                sizeof(m_JetColId)
            );

    if(IsSuccess() == FALSE)
        goto cleanup;

    //DebugOutput(
    //        _TEXT("\tColId - %d"),
    //        m_JetColId
    //    );

    //
    // Retrieve Column Type
    //
    RetrieveColumnValue(
                GetJetSessionID(),
                pColumnList->tableid,
                pColumnList->columnidcoltyp,
                &m_JetColType,
                sizeof(m_JetColType)
            );

    if(IsSuccess() == FALSE)
        goto cleanup;

    //DebugOutput(
    //        _TEXT("\tCol Type %d"),
    //        m_JetColType
    //    );

    //
    // Retrieve Max. length for LongText and Long Binary
    //
    RetrieveColumnValue(
                GetJetSessionID(),
                pColumnList->tableid,
                pColumnList->columnidcbMax,
                &m_JetMaxColLength,
                sizeof(m_JetMaxColLength)
            );

    if(IsSuccess() == FALSE)
        goto cleanup;

    //DebugOutput(
    //        _TEXT("\tMax Col Length %d"),
    //        m_JetMaxColLength
    //    );

    //
    // Retrieve Column Grbit
    //
    RetrieveColumnValue(
                GetJetSessionID(),
                pColumnList->tableid,
                pColumnList->columnidgrbit,
                &m_JetGrbit,
                sizeof(m_JetGrbit)
            );

    if(IsSuccess() == FALSE)
        goto cleanup;

    //DebugOutput(
    //        _TEXT("\tCol grbit %d"),
    //        m_JetGrbit
    //    );

cleanup:

    //DebugOutput(
    //        _TEXT("\n")
    //    );

    return IsSuccess();
}

//-----------------------------------------------------------
BOOL
JBColumn::IsValid() const
/*
*/
{
    return m_pJetTable != NULL && m_pJetTable->IsValid();
}

//-----------------------------------------------------------

BOOL
JBColumn::InsertColumn(
    PVOID pbData,
    unsigned long cbData,
    unsigned long offset
    )
/*
*/
{
    //JET_SETINFO setinfo;

    if(IsValid() == FALSE)
    {
        SetLastJetError(JET_errInvalidParameter);
        return IsSuccess();
    }

    SINGLE_JET_CALL;

    // if(GetJetColumnType() == JET_coltypLongText || GetJetColumnType() == JET_coltypLongBinary)
    if(pbData == NULL || cbData == 0)
    {
        m_JetErr = JetSetColumn(
                            GetJetSessionID(),
                            GetJetTableID(),
                            GetJetColumnID(),
                            0,
                            0,
                            JET_bitSetZeroLength,
                            NULL
                        );

        if(IsSuccess() == FALSE)
            return FALSE;

        m_JetErr = JetSetColumn(
                            GetJetSessionID(),
                            GetJetTableID(),
                            GetJetColumnID(),
                            0,
                            0,
                            0,
                            NULL
                        );

        if(IsSuccess() == FALSE)
            return FALSE;
    }

    m_JetErr = JetSetColumn(
                        GetJetSessionID(),
                        GetJetTableID(),
                        GetJetColumnID(),
                        pbData,
                        cbData,
                        0,
                        NULL
                    );

    return IsSuccess();
}

//-----------------------------------------------------------

BOOL
JBColumn::FetchColumn(
    PVOID pbData,
    unsigned long cbData,
    unsigned long starting_offset
    )
/*
    pass NULL and 0 to determine buffer size needed.
*/
{
    if(IsValid() == FALSE)
    {
        SetLastJetError(JET_errNotInitialized);
    }
    else
    {
        RetrieveColumnValue(
                    GetJetSessionID(),
                    GetJetTableID(),
                    GetJetColumnID(),
                    pbData,
                    cbData,
                    starting_offset
                );
    }

    return IsSuccess();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\license\tlserver\jetblue\jetblue.h ===
//+--------------------------------------------------------------------------
//
// Copyright (c) 1997-1999 Microsoft Corporation
//
// File:        
//
// Contents:    
//
// History:     
//
//---------------------------------------------------------------------------

#ifndef __JETBLUE_H__
#define __JETBLUE_H__

#include "JBDef.h"
#include "locks.h"

#define JETBLUE_EDBLOG      _TEXT("edb*.log")
#define JETBLUE_RESLOG      _TEXT("res?.log")


class JBError;
class JBSession;
class JBDatabase;
class JBTable;
class JBColumn;


// class JBIndex;
// class JBRecordSet;

//
/////////////////////////////////////////////////////////////////////
//
class JBInstance : public JBError {
    friend class JBSession;

    friend operator==(const JBInstance& jbInst1, const JBInstance& jbInst2);
    friend operator!=(const JBInstance& jbInst1, const JBInstance& jbInst2);

private:

    JET_INSTANCE    m_JetInstance;

    // DWORD    m_NumSession;

    CSafeCounter    m_NumSession;
    BOOL            m_bInit;

private:

    JET_SESID
    BeginJetSession(
        LPCTSTR pszUserName=NULL,
        LPCTSTR pszPwd=NULL
    );

    BOOL
    EndJetSession(
        JET_SESID JetSessionID,
        JET_GRBIT grbit = 0
    );

    BOOL
    EndSession(
        JET_SESID sesId,
        JET_GRBIT grbit
    );

public:

    JBInstance();
    ~JBInstance();

    BOOL
    SetSystemParameter(
        JET_SESID SesId,
        unsigned long lParamId,
        ULONG_PTR lParam,
        PBYTE sz
    );

    BOOL
    GetSystemParameter(
        JET_SESID SesId,
        unsigned long lParamId,
        ULONG_PTR* plParam,
        PBYTE sz,
        unsigned long cbMax
    );

    const JET_INSTANCE
    GetInstanceID() const {
        return m_JetInstance;
    }

    BOOL
    JBInitJetInstance();

    BOOL
    JBTerminate(
        JET_GRBIT grbit = JET_bitTermComplete,
        BOOL bDeleteLogFile = FALSE
    );

    BOOL
    IsValid() const
    {
        return m_bInit;
    }

};

//--------------------------------------------------------------------

inline BOOL
operator==(
    const JBInstance& jbInst1,
    const JBInstance& jbInst2
    )
{
    return jbInst1.GetInstanceID() == jbInst2.GetInstanceID();
}

inline BOOL
operator!=(
    const JBInstance& jbInst1,
    const JBInstance& jbInst2
    )
{
    return !(jbInst1 == jbInst2);
}

//
/////////////////////////////////////////////////////////////////////
//
class JBSession : public JBError {

    friend class JBDatabase;

private:

    JBInstance&  m_JetInstance;

    JET_SESID    m_JetSessionID;

    // JetBlue Transaction is session base
    int          m_TransactionLevel;


    // DWORD        m_JetDBInitialized;
    CSafeCounter m_JetDBInitialized;
    // CCriticalSection    m_JetSessionLock;

private:

    JET_DBID
    OpenJetDatabase(
        LPCTSTR szDatabase,
        LPCTSTR szConnect=NULL,
        JET_GRBIT grbit=0
    );

    BOOL
    CloseJetDatabase(
        JET_DBID jdbId,
        JET_GRBIT grbit=0
    );

    JET_DBID
    CreateJetDatabase(
        LPCTSTR szFileName,
        LPCTSTR szConnect=NULL,
        JET_GRBIT grbit=0
    );

    BOOL
    DuplicateSession(
        JET_SESID sesID
    );

    JBInstance&
    GetJetInstance() {
        return m_JetInstance;
    }

    BOOL
    CloseDatabase(
        JET_DBID jdbId,
        JET_GRBIT grbit=0
    );

public:

    JBSession(JBSession& JetSession);       // JetDupSession()
    JBSession(
            JBInstance& JetInstance,
            JET_SESID JetSessID=JET_sesidNil
    );

    ~JBSession();


    BOOL
    IsValid() const {
        return m_JetInstance.IsValid() &&
               m_JetSessionID != JET_sesidNil;
    }

    BOOL
    BeginSession(
        LPCTSTR szUserName=NULL,
        LPCTSTR szPwd=NULL
    );

    BOOL
    EndSession(
        JET_GRBIT grbit = JET_bitTermComplete
    );

    const JBInstance&
    GetJetInstance() const {
        return m_JetInstance;
    }

    const JET_SESID
    GetJetSessionID() const {
        return m_JetSessionID;
    }

    BOOL
    SetSystemParameter(
        unsigned long lParamId,
        ULONG_PTR lParam,
        const PBYTE sz
    );

    BOOL
    GetSystemParameter(
        unsigned long lParamId,
        ULONG_PTR* plParam,
        PBYTE sz,
        unsigned long cbMax
    );

    //
    // make JetBlue aware of database
    //
    BOOL
    AttachDatabase(
        LPCTSTR szFileName,
        JET_GRBIT grbit=0
    );

    BOOL
    DetachDatabase(
        LPCTSTR szFileName
    );

    //
    // Transaction
    //
    BOOL
    BeginTransaction();

    BOOL
    CommitTransaction(JET_GRBIT grbit=0);

    BOOL
    RollbackTransaction(JET_GRBIT grbit=JET_bitRollbackAll);

    int
    GetTransactionLevel() const {
        return m_TransactionLevel;
    }

    BOOL
    EndAllTransaction(
        BOOL bCommit=FALSE,
        JET_GRBIT grbit=0
    );

    BOOL
    Compatible(const JBSession& jbSess) const {
        return GetJetInstance() == jbSess.GetJetInstance();
    }

    //CCriticalSection&
    //GetSessionLock()
    //{
    //    return m_JetSessionLock;
    //}
};


//
/////////////////////////////////////////////////////////////////////
//
class JBDatabase : public JBError {
    friend class JBTable;

private:
    JBSession&      m_JetSession;
    TCHAR           m_szDatabaseFile[MAX_PATH+1];

    CSafeCounter    m_TableOpened;

    // DWORD        m_TableOpened;

    JET_DBID m_JetDbId;

private:

    JET_TABLEID
    OpenJetTable(
        LPCTSTR pszTableName,
        void* pvParam=NULL,
        unsigned long cbParam=0,
        JET_GRBIT grbit=JET_bitTableUpdatable
    );

    JET_TABLEID
    DuplicateJetCursor(
        // JET_SESID sesId,
        JET_TABLEID tableid,
        JET_GRBIT grbit=0       // must be zero
    );

    JET_TABLEID
    CreateJetTable(
        LPCTSTR pszTableName,
        unsigned long lPage=0,
        unsigned long lDensity=20
    );

    BOOL
    CloseJetTable(
        // JET_SESID sesId,
        JET_TABLEID tableid
    );

    JET_TABLEID
    CreateJetTableEx(
        LPCTSTR pszTableName,
        const PTLSJBTable table_attribute,
        const PTLSJBColumn columns,
        const DWORD num_columns,
        const PTLSJBIndex index,
        const DWORD num_index
    );

    BOOL
    CloseTable(
        JET_TABLEID tableid
    );

public:

    JBDatabase(
        JBSession& jbSession,
        JET_DBID jdbId=JET_dbidNil,
        LPCTSTR pszDatabase=NULL
    );

    ~JBDatabase();

    BOOL
    IsValid() const {
        return m_JetSession.IsValid() && m_JetDbId != JET_dbidNil;
    }

    const JBSession&
    GetJetSession() const {
        return m_JetSession;
    }

    const JET_SESID
    GetJetSessionID() const {
        return m_JetSession.GetJetSessionID();
    }

    const JET_DBID
    GetJetDatabaseID() const {
        return m_JetDbId;
    }

    BOOL
    Compatible(const JBDatabase& jbDatabase) const {
        return GetJetSession().Compatible(jbDatabase.GetJetSession());
    }

    LPCTSTR
    GetDatabaseName() const {
        return m_szDatabaseFile;
    }

    BOOL
    OpenDatabase(
        LPCTSTR szDatabase,
        LPCTSTR szConnect=NULL,
        JET_GRBIT grbit=0
    );

    BOOL
    CreateDatabase(
        LPCTSTR szDatabase,
        LPCTSTR szConnect=NULL,
        JET_GRBIT grbit=0
    );

    BOOL
    CloseDatabase(
        JET_GRBIT grbit=0
    );

    BOOL
    DeleteTable(
        LPCTSTR pszTableName
    );

    //
    // tableid return from JetCreateTable is not usable
    //
    JET_TABLEID
    CreateTable(
        LPCTSTR pszTableName,
        unsigned long lPage=0,
        unsigned long lDensity=20
    );

    JET_TABLEID
    CreateTableEx(
        LPCTSTR pszTableName,
        const PTLSJBTable table_attribute,
        const PTLSJBColumn columns,
        DWORD num_columns,
        const PTLSJBIndex index,
        DWORD num_index
    );

    //JBTable*
    //CreateTable(
    //    LPCTSTR pszTableName,
    //    unsigned long lPage=0,
    //    unsigned long lDensity=20
    //);

    //JBTable*
    //CreateTableEx(
    //    LPCTSTR pszTableName,
    //    const PTLSJBTable table_attribute,
    //    const PTLSJBColumn columns,
    //    DWORD num_columns,
    //    const PTLSJBIndex index,
    //    DWORD num_index
    //);

    //
    // Transaction
    //
    BOOL
    BeginTransaction() {
        return m_JetSession.BeginTransaction();
    }

    BOOL
    CommitTransaction(JET_GRBIT grbit=0) {
        return m_JetSession.CommitTransaction(grbit);
    }

    BOOL
    RollbackTransaction(JET_GRBIT grbit=JET_bitRollbackAll) {
        return m_JetSession.RollbackTransaction(grbit);
    }

    int
    GetTransactionLevel() const {
        return m_JetSession.GetTransactionLevel();
    }


    //CCriticalSection&
    //GetSessionLock() {
    //    return m_JetSession.GetSessionLock();
    //}
};

//
/////////////////////////////////////////////////////////////////////
//
// Pure virtual base struct for index
//
struct JBKeyBase {

    BOOL m_EmptyValue;

    JBKeyBase() : m_EmptyValue(TRUE) {}

    void
    SetEmptyValue(BOOL bEmpty) { m_EmptyValue = bEmpty; }

    virtual JET_GRBIT
    GetJetGrbit() {
        return JET_bitIndexIgnoreNull;
    }

    virtual unsigned long
    GetJetDensity() {
        return TLS_TABLE_INDEX_DEFAULT_DENSITY;
    }

    virtual BOOL
    IsEmptyValue() {
        return m_EmptyValue;
    }

    virtual DWORD
    GetKeyLength() {
        LPCTSTR pszIndexKey = GetIndexKey();
        DWORD keylength;

        // calculate index key length, terminated with double 0
        keylength = 2;

        while(pszIndexKey[keylength-1] != _TEXT('\0') ||
              pszIndexKey[keylength-2] != _TEXT('\0'))
        {
            if(keylength >= TLS_JETBLUE_MAX_INDEXKEY_LENGTH)
            {
                DebugBreak();   // error
                return TLS_JETBLUE_MAX_INDEXKEY_LENGTH;
            }

            keylength++;
        }

        return keylength;
    }

    // ----------------------------------------------------
    // Virtual function must be implemented
    // ----------------------------------------------------
    virtual BOOL
    GetSearchKey(
        DWORD dwComponentIndex,
        PVOID* pbData,
        unsigned long* cbData,
        JET_GRBIT* grbit,
        DWORD dwSearchType
    )=0;

    virtual LPCTSTR
    GetIndexName()=0;

    virtual LPCTSTR
    GetIndexKey() = 0;

    virtual DWORD
    GetNumKeyComponents() = 0;
};

//
/////////////////////////////////////////////////////////////////////
//
struct JBIndexStructBase {
    virtual LPCTSTR
    GetIndexName() = 0;

    virtual LPCTSTR
    GetIndexKey() = 0;

    virtual DWORD
    GetNumKeyComponent() = 0;

    virtual BOOL
    GetSearchKey(
        DWORD dwComponentIndex,
        PVOID* pbData,
        unsigned long* cbData,
        JET_GRBIT* grbit,
        DWORD dwSearchType
    ) = 0;
};

//
/////////////////////////////////////////////////////////////////////
//
class JBTable : public JBError {
    friend class JBDatabase;

private:
    static JBColumn m_ErrColumn;

    JBDatabase& m_JetDatabase;
    TCHAR       m_szTableName[MAX_TABLENAME_LENGTH+1];

    JET_TABLEID m_JetTableId;

    typedef struct JetColumns {
        TCHAR           pszColumnName[MAX_JETBLUE_NAME_LENGTH];

        JET_COLTYP      colType;
        JET_COLUMNID    colId;
        unsigned long   cbMaxLength;    // max length of column

        JET_GRBIT       jbGrbit;

    } JetColumns, *PJetColumns;

    //PJetColumns     m_Columns;
    //int             m_NumColumns;

    JBColumn*       m_JetColumns;
    int             m_NumJetColumns;
    BOOL            m_InEnumeration;

    BOOL            m_InsertRepositionBookmark;

private:

    JBDatabase&
    GetJetDatabase() {
        return m_JetDatabase;
    }

    JET_COLUMNID
    AddJetColumn(
        LPCTSTR pszColumnName,
        const JET_COLUMNDEF* pColumnDef,
        const PVOID pbDefaultValue=NULL,
        const unsigned long cbDefaultValue=0
    );

    BOOL
    LoadTableInfo();

public:

    void
    SetInsertRepositionBookmark(
        BOOL bRepo
        )
    /*++
    --*/
    {
        m_InsertRepositionBookmark = bRepo;
        return;
    }

    typedef enum {
        ENUM_ERROR=0,
        ENUM_SUCCESS,
        ENUM_END,
        ENUM_CONTINUE
    } ENUM_RETCODE;

    int
    GetNumberOfColumns() {
        return m_NumJetColumns;
    }

    JBTable(
        JBDatabase& JetDatabase,
        LPCTSTR pszTableName=NULL,
        JET_TABLEID tableid=JET_tableidNil
    );

    JBTable(
        JBTable& jbTable
    );

    ~JBTable();

    BOOL
    IsValid() const {
        return m_JetTableId != JET_tableidNil && m_JetDatabase.IsValid();
    }

    const JBDatabase&
    GetJetDatabase() const {
        return m_JetDatabase;
    }

    const JET_TABLEID
    GetJetTableID() const {
        return m_JetTableId;
    }

    const JET_SESID
    GetJetSessionID() const {
        return m_JetDatabase.GetJetSessionID();
    }

    const JET_DBID
    GetJetDatabaseID() const {
        return m_JetDatabase.GetJetDatabaseID();
    }

    LPCTSTR
    GetTableName() const {
        return m_szTableName;
    }

    JBTable*
    DuplicateCursor(
        JET_GRBIT grbit=0
    );

    JBTable&
    operator=(const JBTable& srcTable);

    BOOL
    CloseTable();

    BOOL
    CreateOpenTable(
        LPCTSTR pszTableName,
        unsigned long lPage=0,
        unsigned long lDensity=20
    );


    BOOL
    OpenTable(
        LPCTSTR pszTableName,
        void* pvParam=NULL,
        unsigned long cbParam=0,
        JET_GRBIT grbit=0
    );


    BOOL
    AddIndex(
        JBKeyBase* key
    );

    int
    AddIndex(
        int numIndex,
        PTLSJBIndex pIndex
    );

    BOOL
    DoesIndexExist(
        LPCTSTR pszIndexName
        );

    int
    AddColumn(
        int numColumns,
        PTLSJBColumn pColumnDef
    );

    BOOL
    AddJetIndex(
        LPCTSTR pszIndexName,
        LPCTSTR pszKey,
        unsigned long cbKey,
        JET_GRBIT jetGrbit,
        unsigned long lDensity=20
    );

    // ----------------------------------------------
    // Transaction
    // ----------------------------------------------
    BOOL
    BeginTransaction() {
        return m_JetDatabase.BeginTransaction();
    }

    BOOL
    CommitTransaction(JET_GRBIT grbit=0) {
        return m_JetDatabase.CommitTransaction(grbit);
    }

    BOOL
    RollbackTransaction(JET_GRBIT grbit=JET_bitRollbackAll) {
        return m_JetDatabase.RollbackTransaction(grbit);
    }

    int
    GetTransactionLevel() const {
        return m_JetDatabase.GetTransactionLevel();
    }

    JBColumn*
    FindColumnByName(LPCTSTR pszColumnName);

    JBColumn*
    FindColumnByIndex(const int index);

    JBColumn*
    FindColumnByColumnId(const JET_COLUMNID);

#if 1
    JBColumn&
    operator[](LPCTSTR pszColumnName) {
        JBColumn* jb = FindColumnByName(pszColumnName);
        return (jb) ? *jb : m_ErrColumn;
    }

    JBColumn&
    operator[](const int index) {
        JBColumn* jb = FindColumnByIndex(index);
        return (jb) ? *jb : m_ErrColumn;
    }

    JBColumn&
    operator[](const JET_COLUMNID jetid) {
        JBColumn* jb = FindColumnByColumnId(jetid);
        return (jb) ? *jb : m_ErrColumn;
    }

#else

    JBColumn*
    operator[](LPCTSTR pszColumnName) {
        return FindColumn(pszColumnName);
    }

    JBColumn*
    operator[](const int index) {
        return FindColumn(index);
    }

    JBColumn*
    operator[](const JET_COLUMNID jetid) {
        return FindColumn(jetid);
    }

#endif

    JET_COLUMNID
    GetJetColumnID(LPCTSTR pszColumnName);

    int
    GetJetColumnIndex(LPCTSTR pszColumnName);

    BOOL
    ReadLock();

    BOOL
    WriteLock();

    BOOL
    BeginUpdate(BOOL bUpdate = FALSE);

    BOOL
    EndUpdate(
        BOOL bDiscard = FALSE
    );

    BOOL
    SeekToKey(
        JBKeyBase* key,
        DWORD dwSearchType,
        JET_GRBIT jet_seek_grbit=JET_bitSeekGE
    );

    BOOL
    RetrieveKey(
        PVOID pbData,
        unsigned long cbData,
        unsigned long* pcbActual=NULL,
        JET_GRBIT grbit=0
    );

    //
    //  Enumeration
    //
    BOOL
    EnumBegin(
        LPCTSTR pszIndexName=NULL,      // enumeration thru primary index
        JET_GRBIT grbit=JET_bitMoveFirst
    );

    BOOL
    MoveToRecord(
        long crow=JET_MoveNext,
        JET_GRBIT grbit=0
    );

    BOOL
    EnumBegin(
        JBKeyBase* key,
        DWORD dwParam=0
    );

    ENUM_RETCODE
    EnumNext(
        JET_GRBIT crow=JET_MoveNext,
        JET_GRBIT grbit=0 //JET_bitMoveKeyNE  // limit our traveral to index
    );

    void
    EnumEnd()
    {
        m_InEnumeration = FALSE;
    }

    //-----------------------------------------------------------
    BOOL
    SetCurrentIndex(
        LPCTSTR pszIndexName,
        JET_GRBIT grbit = JET_bitMoveFirst
    );

    //-----------------------------------------------------------

    BOOL
    GetCurrentIndex(
        LPTSTR pszIndexName,
        unsigned long* bufferSize
    );

    BOOL
    EndOfRecordSet() {
        return m_JetErr == JET_errNoCurrentRecord;
    }

    unsigned long
    GetIndexRecordCount(
        unsigned long max=0xFFFFFFFF
    );

    BOOL
    MakeKey(
        PVOID pbData,
        unsigned long cbData,
        JET_GRBIT grbit=JET_bitNewKey
    );

    BOOL
    SeekValue(JET_GRBIT grbit=JET_bitSeekEQ);

    BOOL
    SeekValueEx(
        PVOID pbData,
        unsigned long cbData,
        JET_GRBIT keyGrbit,
        JET_GRBIT seekGrbit
        )
    /*

        Only work for single component key

    */
    {
        if(MakeKey(pbData, cbData, keyGrbit) == FALSE)
            return FALSE;

        return SeekValue(seekGrbit);
    }

    BOOL
    DeleteRecord();

    BOOL
    GetBookmark(
        PVOID pbBookmark,
        PDWORD pcbBookmark
    );

    BOOL
    GotoBookmark(
        PVOID pbBookmark,
        DWORD cbBookmark
    );

    //CCriticalSection&
    //GetSessionLock() {
    //    return m_JetDatabase.GetSessionLock();
    //}
};

//------------------------------------------------------------------------

struct JBColumnBufferBase {
    virtual PVOID
    GetInputBuffer() = 0;

    virtual PVOID
    GetOutputBuffer() = 0;

    virtual DWORD
    GetInputBufferLength() = 0;

    virtual DWORD
    GetOutputBufferLength() = 0;
};

//------------------------------------------------------------------------

class JBColumn : public JBError {
    friend class JBTable;

private:

    JBTable*        m_pJetTable;

    TCHAR           m_szColumnName[MAX_JETBLUE_NAME_LENGTH+1];

    JET_COLUMNID    m_JetColId;
    JET_COLTYP      m_JetColType;
    unsigned long   m_JetMaxColLength;
    JET_GRBIT       m_JetGrbit;

    PVOID           m_pbDefValue;
    int             m_cbDefValue;

    unsigned long   m_JetColCodePage;
    unsigned long   m_JetColCountryCode;
    unsigned long   m_JetColLangId;
    unsigned long   m_cbActual;

    JET_RETINFO     m_JetRetInfo;
    BOOL            m_JetNullColumn;

    //-------------------------------------------------------------

    void Cleanup();

    BOOL
    LoadJetColumnInfoFromJet(
        const JET_COLUMNLIST* column
    );

    JET_ERR
    RetrieveColumnValue(
        JET_SESID sesid,
        JET_TABLEID tableid,
        JET_COLUMNID columnid,
        PVOID pbBuffer,
        unsigned long cbBuffer,
        unsigned long offset=0
    );

    void
    AttachToTable( JBTable* pJetTable ) {
        m_pJetTable = pJetTable;
        return;
    }

public:

    JBColumn(JBTable* pJetTable=NULL);
    ~JBColumn() {}

    const unsigned long
    GetMaxColumnLength() const {
        return m_JetMaxColLength;
    }

    BOOL
    IsValid() const;

    const JET_COLTYP
    GetJetColumnType() const {
        return m_JetColType;
    }

    const JET_COLUMNID
    GetJetColumnID() const {
        return m_JetColId;
    }

    const JET_SESID
    GetJetSessionID() const {
        return (m_pJetTable) ? m_pJetTable->GetJetSessionID() : JET_sesidNil;
    }

    const JET_TABLEID
    GetJetTableID() const {
        return (m_pJetTable) ? m_pJetTable->GetJetTableID() : JET_tableidNil;
    }

    LPCTSTR
    GetJetColumnName() const {
        return (IsValid()) ? m_szColumnName : NULL;
    }

    const JBTable*
    GetJetTable() const {
        return m_pJetTable;
    }

    //
    // TODO - append to long binary column
    //
    BOOL
    InsertColumn(
        PVOID pbData,
        unsigned long cbData,
        unsigned long starting_offset=0
    );

    BOOL
    FetchColumn(
        PVOID pbData,
        unsigned long cbData,
        unsigned long starting_offset=0     // for future enhancement
    );

    void
    SetRetrieveOffset( unsigned long offset ) {
        m_JetRetInfo.ibLongValue = offset;
    }

    JBTable*
    GetWorkingTable() {
        return m_pJetTable;
    }

    unsigned long
    GetDataSize() {
        return m_cbActual;
    }

    //-----------------------------------------------

    BOOL
    FetchColumn(
        JBColumnBufferBase* pBuffer,
        DWORD offset=0
        )
    /*
    */
    {
        return FetchColumn(
                    pBuffer->GetInputBuffer(),
                    pBuffer->GetInputBufferLength(),
                    offset
                );
    }

    BOOL
    InsertColumn(
        JBColumnBufferBase* pBuffer,
        DWORD offset=0
        )
    /*
    */
    {
        return FetchColumn(
                    pBuffer->GetOutputBuffer(),
                    pBuffer->GetOutputBufferLength(),
                    offset
                );
    }
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\license\tlserver\jetblue\jbbase.cpp ===
//+--------------------------------------------------------------------------
//
// Copyright (c) 1997-1999 Microsoft Corporation
//
// File:        
//
// Contents:    
//
// History:     
//
//---------------------------------------------------------------------------

#include "JetBlue.h"


//----------------------------------------------------------------
BOOL
ConvertMJBstrToMWstr(
    JB_STRING in,
    DWORD length,
    LPTSTR* out
    )
/*

*/
{
#if defined(UNICODE) && !defined(JET_BLUE_SUPPORT_UNICODE)
    if(in == NULL)
    {
        *out = NULL;
        return TRUE;
    }

    int bufSize;

    bufSize = MultiByteToWideChar(
                            GetACP(),
                            MB_PRECOMPOSED,
                            in,
                            length,
                            NULL,
                            0
                        );

    if(bufSize == 0)
    {
        return FALSE;
    }

    *out = (LPTSTR)LocalAlloc(LPTR, bufSize * sizeof(TCHAR));
    if(*out == NULL)
    {
        return FALSE;
    }

    return (MultiByteToWideChar(
                            GetACP(),
                            MB_PRECOMPOSED,
                            in,
                            length,
                            *out, 
                            bufSize
                        ) != 0);
    
#else

    *out = in;
    return TRUE;

#endif
}

//----------------------------------------------------------------
BOOL
ConvertJBstrToWstr(
    JB_STRING   in,
    LPTSTR*     out
    )
/*
*/
{
    return ConvertMJBstrToMWstr(in, -1, out);
}
    
//----------------------------------------------------------------
BOOL
ConvertMWstrToMJBstr(
    LPCTSTR in, 
    DWORD length,
    JB_STRING* out
    )
/* 
*/
{
#if defined(UNICODE) && !defined(JET_BLUE_SUPPORT_UNICODE)

    if(in == NULL)
    {
        *out = NULL;
        return TRUE;
    }

    
    int bufSize;

    bufSize = WideCharToMultiByte(
                            GetACP(),
                            0,
                            in,
                            length,
                            NULL,
                            0,
                            NULL,
                            NULL
                        );

    if(bufSize == 0)
    {
        return FALSE;
    }

    *out = (LPSTR)LocalAlloc(LPTR, bufSize);
    if(*out == NULL)
    {
        return FALSE;
    }

    return (WideCharToMultiByte( GetACP(),
                                 0,
                                 in,
                                 length, 
                                 *out, 
                                 bufSize,
                                 NULL,
                                 NULL) != 0);
#else

    *out = in;
    return TRUE;

#endif
}


//----------------------------------------------------------------
BOOL 
ConvertWstrToJBstr(
    LPCTSTR in, 
    JB_STRING* out
    )
{
    return ConvertMWstrToMJBstr( in, -1, out );
}

//----------------------------------------------------------------
void
FreeJBstr( JB_STRING pstr )
{
#if defined(UNICODE) && !defined(JET_BLUE_SUPPORT_UNICODE)

    if(pstr)
        LocalFree(pstr);
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\license\tlserver\server\clilic.h ===
//+--------------------------------------------------------------------------
//
// Copyright (c) 1997-1999 Microsoft Corporation
//
// File:        clilic.h
//
// Contents:    
//
// History:     
//
//---------------------------------------------------------------------------
#ifndef __CLIENTLICNESE_H__
#define __CLIENTLICNESE_H__
#include "server.h"


#ifdef __cplusplus
extern "C" {
#endif

void 
TLSDBLockLicenseTable();

void 
TLSDBUnlockLicenseTable();

DWORD
TLSDBLicenseFind(
    IN PTLSDbWorkSpace pDbWkSpace,
    IN BOOL   bMatchAllParm,
    IN DWORD  dwSearchParm,
    IN LPLICENSEDCLIENT lpSearch,
    IN OUT LPLICENSEDCLIENT lpFound
);

DWORD
TLSDBLicenseEnumBegin( 
    IN PTLSDbWorkSpace pDbWkSpace,
    IN BOOL   bMatchAll,
    IN DWORD  dwSearchParm,
    IN LPLICENSEDCLIENT  lpSearch
);

DWORD
TLSDBLicenseEnumBeginEx( 
    IN PTLSDbWorkSpace pDbWkSpace,
    IN BOOL   bMatchAll,
    IN DWORD  dwSearchParm,
    IN LPLICENSEDCLIENT  lpSearch,
    IN JET_GRBIT jet_seek_grbit
);

DWORD
TLSDBLicenseEnumNext( 
    IN PTLSDbWorkSpace pDbWkSpace,
    IN OUT LPLICENSEDCLIENT lplsLicense
);

DWORD
TLSDBLicenseEnumNextEx( 
    IN PTLSDbWorkSpace pDbWkSpace,
    IN BOOL bReverse,
    IN BOOL bAnyRecord,
    IN OUT LPLICENSEDCLIENT lplsLicense
);

void
TLSDBLicenseEnumEnd(
    IN PTLSDbWorkSpace pDbWkSpace
);


DWORD
TLSDBLicenseAddEntry(
    IN PTLSDbWorkSpace pDbWkSpace,
    IN LPLICENSEDCLIENT pLicense
);

DWORD
TLSDBLicenseDeleteEntry(
    IN PTLSDbWorkSpace pDbWkSpace,
    IN LPLICENSEDCLIENT pLicense,
    IN BOOL bInternalCall
);

DWORD
TLSDBDeleteEnumeratedLicense(
    IN PTLSDbWorkSpace pDbWkSpace
);

DWORD
TLSDBLicenseUpdateEntry(
    IN PTLSDbWorkSpace pDbWkSpace,
    IN DWORD dwUpdateParm,
    IN LPLICENSEDCLIENT pLicense,
    IN BOOL bInternalCall
);

DWORD
TLSDBLicenseSetValue( 
    IN PTLSDbWorkSpace pDbWkSpace,
    IN DWORD dwSetParm,
    IN LPLICENSEDCLIENT lpLicense,
    IN BOOL bPointerOnRecord
);

DWORD
TLSDBLicenseGetCert( 
    IN PTLSDbWorkSpace pDbWorkSpace,
    IN DWORD dwLicenseId, 
    IN OUT PDWORD cbCert, 
    IN OUT PBYTE pbCert 
);

DWORD
TLSDBLicenseAdd(
    IN PTLSDbWorkSpace pDbWorkSpace,
    LPLICENSEDCLIENT pLicense, 
    DWORD cbLicense, 
    PBYTE pbLicense
);

#ifdef __cplusplus
}
#endif


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\license\tlserver\jetblue\jbdef.h ===
//+--------------------------------------------------------------------------
//
// Copyright (c) 1997-1999 Microsoft Corporation
//
// File:        
//
// Contents:    
//
// History:     
//
//---------------------------------------------------------------------------

#ifndef __JBDEF_H__
#define __JBDEF_H__

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntddkbd.h>
#include <ntddmou.h>
#include <windows.h>
#include <winbase.h>
#include <winerror.h>

#include <stdio.h>
#include <stdlib.h>
#include <tchar.h>
#include <esent.h>
#include "tlsdef.h"
#include "tlsassrt.h"

#ifdef JB_ASSERT
#undef JB_ASSERT
#endif

#define JB_ASSERT TLSASSERT
#define MAX_JB_ERRSTRING    512

//
// 
// 
#define INDEXNAME               _TEXT("idx")
#define SEPERATOR               _TEXT("_")
#define JBSTRING_NULL           _TEXT("")
#define JETBLUE_NULL            _TEXT("")

#define INDEX_SORT_ASCENDING    _TEXT("+")
#define INDEX_SORT_DESCENDING   _TEXT("-")
#define INDEX_END_COLNAME       _TEXT("\0")

#define JB_COLTYPE_TEXT         JET_coltypLongBinary

//------------------------------------------------------------------
//
// JetBlue does not support UNICODE string
//
//------------------------------------------------------------------
#undef JET_BLUE_SUPPORT_UNICODE


#ifdef JET_BLUE_SUPPORT_UNICODE

    typedef LPTSTR JB_STRING;

#else

    typedef LPSTR JB_STRING;

#endif

//----------------------------------------------------------------

#ifndef AllocateMemory

    #define AllocateMemory(size) \
        LocalAlloc(LPTR, size)

#endif

#ifndef FreeMemory

    #define FreeMemory(ptr) \
        if(ptr)             \
        {                   \
            LocalFree(ptr); \
            ptr=NULL;       \
        }

#endif

#ifndef ReallocateMemory

    #define ReallocateMemory(ptr, size)                 \
                LocalReAlloc(ptr, size, LMEM_ZEROINIT)

#endif

//
// Private member function
//
#define CLASS_PRIVATE


//
// No define for NIL instance ID
// 
#define JET_NIL_INSTANCE        JET_sesidNil


//
// No define for NIL column id
// 
#define JET_NIL_COLUMN        JET_sesidNil

//
// No define for max table name length,
// user2.doc says 64 ASCII
//
#define MAX_TABLENAME_LENGTH    32

//
// Jet Blue text only 255 BYTES
//
#define MAX_JETBLUE_TEXT_LENGTH LSERVER_MAX_STRING_SIZE


//
// Jet Blue Index, Column, ... name length
//
#define MAX_JETBLUE_NAME_LENGTH 64


//
// Jet Blue column code page must be 1200 or 1250
//
#define TLS_JETBLUE_COLUMN_CODE_PAGE 1252


//
// Jet Blue Text column language ID
//
#define TLS_JETBLUE_COLUMN_LANGID   0x409

//
// Jet Blue Column Country Code
//
#define TLS_JETBLUE_COLUMN_COUNTRY_CODE 1


//
// Max Jet Blue index key length - 127 fix columns
//
#define TLS_JETBLUE_MAX_INDEXKEY_LENGTH \
    (127 + 1) * MAX_JETBLUE_NAME_LENGTH


//
// Max. Jet Blue key length documented is 255 in user2.doc
//


//
// Default table density
//
#define TLS_JETBLUE_DEFAULT_TABLE_DENSITY   20


//
// JetBlue max key size - user2.doc
//
#define TLS_JETBLUE_MAX_KEY_LENGTH          255

//
//
#define TLS_TABLE_INDEX_DEFAULT_DENSITY  20

///////////////////////////////////////////////////////////////
//
// Various structure
//
///////////////////////////////////////////////////////////////
typedef struct __TLSJBTable {
    LPCTSTR         pszTemplateTableName;
    unsigned long   ulPages;
    unsigned long   ulDensity;
    JET_GRBIT       jbGrbit;
} TLSJBTable, *PTLSJBTable;

typedef struct __TLSJBColumn {
    TCHAR           pszColumnName[MAX_JETBLUE_NAME_LENGTH];

    JET_COLTYP      colType;
    unsigned long   cbMaxLength;    // max length of column

    JET_GRBIT       jbGrbit;

    PVOID           pbDefValue;     // column default value
    int             cbDefValue;

    unsigned short  colCodePage;
    unsigned short  wCountry;
    unsigned short  langid;
} TLSJBColumn, *PTLSJBColumn;    

typedef struct __TLSJBIndex {
    TCHAR           pszIndexName[MAX_JETBLUE_NAME_LENGTH];
    LPTSTR          pszIndexKey;
    unsigned long   cbKey;          // length of key
    JET_GRBIT       jbGrbit;
    unsigned long   ulDensity;
} TLSJBIndex, *PTLSJBIndex;



#ifdef __cplusplus
extern "C" {
#endif

    BOOL
    ConvertJBstrToWstr(
        JB_STRING   in,
        LPTSTR*     out
    );

    BOOL 
    ConvertWstrToJBstr(
        LPCTSTR in, 
        JB_STRING* out
    );

    void
    FreeJBstr( 
        JB_STRING pstr 
    );
   
    BOOL
    ConvertMWstrToMJBstr(
        LPCTSTR in, 
        DWORD length,
        JB_STRING* out
    );

    BOOL
    ConvertMJBstrToMWstr(
        JB_STRING in,
        DWORD length,
        LPTSTR* out
    );

#ifdef __cplusplus
}
#endif

//
/////////////////////////////////////////////////////////////////////
//
class JBError {
public:

    JET_ERR m_JetErr;

    JBError() : m_JetErr(JET_errSuccess) {}

    JBError(const JET_ERR jet_error) : m_JetErr(jet_error) {}

    const JET_ERR 
    GetLastJetError() const { 
        return m_JetErr; 
    }

    void
    SetLastJetError(JET_ERR jetError = JET_errSuccess) { 
        m_JetErr = jetError; 
    }

    BOOL 
    IsSuccess() const {
        return m_JetErr >= JET_errSuccess;
    }

    BOOL
    GetJBErrString(
        const JET_ERR jbErr,
        LPTSTR* pszErrString
    )
    /*++

    --*/
    {
        BOOL bStatus=FALSE;
        JET_ERR err;
        CHAR szAnsiBuffer[MAX_JB_ERRSTRING+1];
    
        if(pszErrString == NULL)
        {
            SetLastError(ERROR_INVALID_PARAMETER);
            return bStatus;
        }

        memset(szAnsiBuffer, 0, sizeof(szAnsiBuffer));
        err = JetGetSystemParameter(
                            JET_instanceNil,
                            JET_sesidNil,
                            JET_paramErrorToString,
                            (ULONG_PTR *) &jbErr,
                            szAnsiBuffer,
                            MAX_JB_ERRSTRING
                        );
        
        if(err == JET_errBufferTooSmall || err == JET_errSuccess)
        {
            // return partial error string.
            if(ConvertJBstrToWstr(szAnsiBuffer, pszErrString))
            {
                bStatus = TRUE;
            }
        }

        return bStatus;
    }
                
    void
    DebugOutput(
        LPTSTR format, ...
        ) const 
    /*++
    ++*/
    {
        va_list marker;
        va_start(marker, format);

#ifdef DEBUG_JETBLUE

        TCHAR  buf[8096];
        DWORD  dump;

        memset(buf, 0, sizeof(buf));

        _vsntprintf(
                buf, 
                sizeof(buf)/sizeof(buf[0]), 
                format, 
                marker
            );

        _tprintf(_TEXT("%s"), buf);

#endif

        va_end(marker);
    }
};

//------------------------------------------------------------

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\license\tlserver\server\clrhouse.h ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (c) 1997-1999 Microsoft Corporation
//
// File:        clrhouse.h
//
// Contents:    
//              All Clearing house related function
//
// History:     
// 
// Note:        
//---------------------------------------------------------------------------
#ifndef __LICENSE_SERVER_CLEARING_HOUSE_H__
#define __LICENSE_SERVER_CLEARING_HOUSE_H__

//-----------------------------------------------------------------------------
//
// Registry key for storing various certificates
//
#define LSERVER_CERTIFICATE_STORE_BASE              LSERVER_SERVER_CERTIFICATE_REGKEY

//-----------------------------------------------------------------------------
// Actual License Server Certificate
//
#define LSERVER_CERTIFICATE_STORE_SIGNATURE         "Signature"
#define LSERVER_CERTIFICATE_STORE_EXCHANGE          "Exchange"

//-----------------------------------------------------------------------------
// License Server Certificate Chain 
//
#define LSERVER_CERTIFICATE_CHAIN_SIGNATURE         "SignatureChain"
#define LSERVER_CERTIFICATE_CHAIN_EXCHANGE          "ExchangeChain"


#define LSERVER_CERTIFICATE_STORE_CA                "CA"
#define LSERVER_CERTIFICATE_STORE_RA                "RA"
#define LSERVER_CERTIFICATE_STORE_CH                "CH"
#define LSERVER_CERTIFICATE_STORE_ROOT              "ROOT"

//------------------------------------------------------------------------------
//
// Registry key for CA certificate
// 
#define LSERVER_CERTIFICATE_REG_CA_SIGNATURE \
    LSERVER_CERTIFICATE_STORE_BASE _TEXT("\\") _TEXT(LSERVER_CERTIFICATE_STORE_SIGNATURE) _TEXT("\\") _TEXT(LSERVER_CERTIFICATE_STORE_CA)

#define LSERVER_CERTIFICATE_REG_CA_EXCHANGE \
    LSERVER_CERTIFICATE_STORE_BASE _TEXT("\\") _TEXT(LSERVER_CERTIFICATE_STORE_EXCHANGE) _TEXT("\\") _TEXT(LSERVER_CERTIFICATE_STORE_CA)


//------------------------------------------------------------------------------
//
// Registry key for RA certificate
// 
#define LSERVER_CERTIFICATE_REG_MF_SIGNATURE \
    LSERVER_CERTIFICATE_STORE_BASE _TEXT("\\") _TEXT(LSERVER_CERTIFICATE_STORE_SIGNATURE) _TEXT("\\") _TEXT(LSERVER_CERTIFICATE_STORE_RA)

#define LSERVER_CERTIFICATE_REG_MF_EXCHANGE \
    LSERVER_CERTIFICATE_STORE_BASE _TEXT("\\") _TEXT(LSERVER_CERTIFICATE_STORE_EXCHANGE) _TEXT("\\") _TEXT(LSERVER_CERTIFICATE_STORE_RA)


//------------------------------------------------------------------------------
//
// Registry key for CH certificate
//
#define LSERVER_CERTIFICATE_REG_CH_SIGNATURE \
    LSERVER_CERTIFICATE_STORE_BASE _TEXT("\\") _TEXT(LSERVER_CERTIFICATE_STORE_SIGNATURE) _TEXT("\\") _TEXT(LSERVER_CERTIFICATE_STORE_CH)

#define LSERVER_CERTIFICATE_REG_CH_EXCHANGE \
    LSERVER_CERTIFICATE_STORE_BASE _TEXT("\\") _TEXT(LSERVER_CERTIFICATE_STORE_EXCHANGE) _TEXT("\\") _TEXT(LSERVER_CERTIFICATE_STORE_CH)

//------------------------------------------------------------------------------
//
// Registry key for ROOT certificate
//
#define LSERVER_CERTIFICATE_REG_ROOT_SIGNATURE \
    LSERVER_CERTIFICATE_STORE_BASE _TEXT("\\") _TEXT(LSERVER_CERTIFICATE_STORE_SIGNATURE) _TEXT("\\") _TEXT(LSERVER_CERTIFICATE_STORE_ROOT)

#define LSERVER_CERTIFICATE_REG_ROOT_EXCHANGE \
    LSERVER_CERTIFICATE_STORE_BASE _TEXT("\\") _TEXT(LSERVER_CERTIFICATE_STORE_EXCHANGE) _TEXT("\\") _TEXT(LSERVER_CERTIFICATE_STORE_ROOT)


#ifdef __cplusplus
extern "C" {
#endif

    BOOL
    TLSChainIssuerCertificate( 
        HCRYPTPROV hCryptProv, 
        HCERTSTORE hChainFromStore, 
        HCERTSTORE hChainToStore, 
        PCCERT_CONTEXT pSubjectContext 
    );

    HCERTSTORE
    CertOpenRegistryStore(
        HKEY hKeyType, 
        LPCTSTR szSubKey, 
        HCRYPTPROV hCryptProv, 
        HKEY* phKey
    );
    
    DWORD 
    TLSSaveCertAsPKCS7(
        PBYTE pbCert, 
        DWORD cbCert, 
        PBYTE* ppbEncodedCert, 
        PDWORD pcbEncodedCert
    );

    DWORD
    IsCertificateLicenseServerCertificate(
        IN HCRYPTPROV hCryptProv,
        IN DWORD dwCertType,
        IN DWORD cbPKCS7Cert, 
        IN PBYTE pbPKCS7Cert,
        IN OUT DWORD* cbLsCert,
        IN OUT PBYTE* pbLsCert
    );

    DWORD
    TLSSaveRootCertificateToReg(
        HCRYPTPROV hCryptProv, 
        HKEY hKey, 
        DWORD cbEncodedCert, 
        PBYTE pbEncodedCert
    );

    DWORD
    TLSSaveCertificateToReg(
        HCRYPTPROV hCryptProv, 
        HKEY hKey, 
        DWORD cbPKCS7Cert, 
        PBYTE pbPKCS7Cert
    );

    DWORD 
    TLSSaveRootCertificatesToStore(  
        IN HCRYPTPROV    hCryptProv,
        IN DWORD         cbSignatureCert, 
        IN PBYTE         pbSignatureCert, 
        IN DWORD         cbExchangeCert, 
        IN PBYTE         pbExchangeCert
    );

    DWORD
    TLSSaveCertificatesToStore(
        IN HCRYPTPROV    hCryptProv,
        IN DWORD         dwCertType,
        IN DWORD         dwCertLevel,
        IN DWORD         cbSignatureCert, 
        IN PBYTE         pbSignatureCert, 
        IN DWORD         cbExchangeCert, 
        IN PBYTE         pbExchangeCert
    );

#ifdef __cplusplus
}
#endif


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\license\tlserver\legacy\marshal\marshal.c ===
//+--------------------------------------------------------------------------
//
// Copyright (c) 1997-1999 Microsoft Corporation
//
// File:        
//
// Contents:    
//
// History:     
//
//---------------------------------------------------------------------------

#include <stdio.h>
#include <stddef.h>
#include "hydrals.h"
#include "license.h"

void __RPC_USER 
LICENSE_REQUEST_TYPE_to_xmit( LICENSE_REQUEST_TYPE __RPC_FAR * pRequest,
                              LICENSE_REQUEST_XMIT_TYPE  __RPC_FAR * __RPC_FAR * pRequestXmit)
{
    DWORD size;

    size = sizeof(LICENSE_REQUEST_XMIT_TYPE) + 
                pRequest->pProductInfo->cbCompanyName + 
                pRequest->pProductInfo->cbProductID +
                pRequest->cbEncryptedHwid;

    *pRequestXmit = (LICENSE_REQUEST_XMIT_TYPE *)midl_user_allocate(size);

    // copy request structure
    (*pRequestXmit)->dwLangId = pRequest->dwLanguageID;
    (*pRequestXmit)->dwPlatformId = pRequest->dwPlatformID;
    (*pRequestXmit)->cbEncryptedHwid = pRequest->cbEncryptedHwid;

    // copy product requested
    (*pRequestXmit)->dwVersion = pRequest->pProductInfo->dwVersion;
    (*pRequestXmit)->cbCompanyName = pRequest->pProductInfo->cbCompanyName;
    (*pRequestXmit)->cbProductId = pRequest->pProductInfo->cbProductID;

     memcpy( &((*pRequestXmit)->pbData[0]),
            pRequest->pProductInfo->pbCompanyName, 
            pRequest->pProductInfo->cbCompanyName);

    memcpy( &((*pRequestXmit)->pbData[0]) + pRequest->pProductInfo->cbCompanyName, 
            pRequest->pProductInfo->pbProductID, 
            pRequest->pProductInfo->cbProductID);

    if(pRequest->cbEncryptedHwid)
    {
        memcpy( &((*pRequestXmit)->pbData[0]) + pRequest->pProductInfo->cbCompanyName + pRequest->pProductInfo->cbProductID, 
                pRequest->pbEncryptedHwid, 
                pRequest->cbEncryptedHwid);
    }
}


void __RPC_USER 
LICENSE_REQUEST_TYPE_from_xmit( LICENSE_REQUEST_XMIT_TYPE  __RPC_FAR *pRequestXmit, 
                                LICENSE_REQUEST_TYPE __RPC_FAR * pRequest)
{
    pRequest->cbEncryptedHwid = pRequestXmit->cbEncryptedHwid;
    pRequest->dwLanguageID = pRequestXmit->dwLangId;
    pRequest->dwPlatformID = pRequestXmit->dwPlatformId;
    pRequest->pProductInfo = (PProduct_Info)midl_user_allocate(sizeof(Product_Info));

    pRequest->pProductInfo->dwVersion = pRequestXmit->dwVersion;
    pRequest->pProductInfo->cbCompanyName = pRequestXmit->cbCompanyName;
    pRequest->pProductInfo->cbProductID = pRequestXmit->cbProductId;

    pRequest->pProductInfo->pbCompanyName = (PBYTE)midl_user_allocate(pRequestXmit->cbCompanyName+sizeof(CHAR));
    memcpy(pRequest->pProductInfo->pbCompanyName, &(pRequestXmit->pbData[0]), pRequestXmit->cbCompanyName);

    pRequest->pProductInfo->pbProductID = (PBYTE)midl_user_allocate(pRequestXmit->cbProductId+sizeof(CHAR));
    memcpy(pRequest->pProductInfo->pbProductID, 
           &(pRequestXmit->pbData[0]) + pRequest->pProductInfo->cbCompanyName, 
           pRequestXmit->cbProductId);

    if(pRequestXmit->cbEncryptedHwid)
    {
        pRequest->pbEncryptedHwid = (PBYTE)midl_user_allocate(pRequestXmit->cbEncryptedHwid);
        memcpy(pRequest->pbEncryptedHwid, 
               &(pRequestXmit->pbData[0]) + pRequest->pProductInfo->cbCompanyName + pRequest->pProductInfo->cbProductID,
               pRequestXmit->cbEncryptedHwid);
    }
    else
    {
        pRequest->pbEncryptedHwid = NULL;
    }
}

void __RPC_USER 
LICENSE_REQUEST_TYPE_free_xmit(LICENSE_REQUEST_XMIT_TYPE  __RPC_FAR *ptr)
{
    midl_user_free(ptr);
}

void __RPC_USER 
LICENSE_REQUEST_TYPE_free_inst( LICENSE_REQUEST_TYPE __RPC_FAR *pRequest )
{
    if(pRequest->pProductInfo)
    {
        if(pRequest->pbEncryptedHwid)
            midl_user_free(pRequest->pbEncryptedHwid);

        if(pRequest->pProductInfo->pbProductID)
            midl_user_free(pRequest->pProductInfo->pbProductID);

        if(pRequest->pProductInfo->pbCompanyName)
            midl_user_free(pRequest->pProductInfo->pbCompanyName);

        midl_user_free(pRequest->pProductInfo);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\license\tlserver\server\ch.cpp ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996-1996
//
// File:        ch.cpp
//
// Contents:    
//              All Clearing house related function
//
// History:     
// 
// Note:        
//---------------------------------------------------------------------------
#include "pch.cpp"
#include "clrhouse.h"
#include "globals.h"
#include "gencert.h"


/*****************************************************************************

*****************************************************************************/
BOOL
TLSChainIssuerCertificate( 
    HCRYPTPROV hCryptProv, 
    HCERTSTORE hChainFromStore, 
    HCERTSTORE hChainToStore, 
    PCCERT_CONTEXT pSubjectContext 
    )
/*
*/
{
    DWORD dwStatus = ERROR_SUCCESS;
    PCCERT_CONTEXT pCertIssuer=NULL;
    PCCERT_CONTEXT pCurrentSubject = NULL;
    DWORD dwFlags;

    //
    // Increase reference count on Subject context.
    //
    // From MSDN: Currently, a copy is not made of the context, and the
    // returned pointer to a context has the same value as the pointer to a
    // context that was input.
    //

    pCurrentSubject = CertDuplicateCertificateContext(
                                                pSubjectContext
                                            );

    
    while( TRUE )
    {
        dwFlags = CERT_STORE_SIGNATURE_FLAG;   
        pCertIssuer = CertGetIssuerCertificateFromStore(
                                            hChainFromStore, 
                                            pCurrentSubject,
                                            NULL,
                                            &dwFlags
                                        );

        CertFreeCertificateContext(pCurrentSubject);
        if(!pCertIssuer)
        {
            dwStatus = GetLastError();
            break;
        }

        if(dwFlags & CERT_STORE_SIGNATURE_FLAG)
        {
            //
            // we have invalid signature from certificate
            //
            dwStatus =  TLS_E_INVALID_DATA;
            break;
        }      

        if(!CertAddCertificateContextToStore( 
                                        hChainToStore, 
                                        pCertIssuer,
                                        CERT_STORE_ADD_REPLACE_EXISTING,
                                        NULL
                                    ))
        {
            dwStatus = GetLastError();
            break;
        }

        pCurrentSubject = pCertIssuer;
    }

    if(dwStatus == CRYPT_E_SELF_SIGNED)
    {
        dwStatus = ERROR_SUCCESS;
    }

    SetLastError(dwStatus);

    if(pCertIssuer)
    {
        CertFreeCertificateContext(pCertIssuer);
    }

    return dwStatus == ERROR_SUCCESS;
}

/*****************************************************************************

*****************************************************************************/
HCERTSTORE
CertOpenRegistryStore(
    HKEY hKeyType, 
    LPCTSTR szSubKey, 
    HCRYPTPROV hCryptProv, 
    HKEY* phKey
    )
/*
*/
{
    DWORD dwStatus;
    HCERTSTORE hCertStore;

    dwStatus=RegOpenKeyEx(hKeyType, szSubKey, 0, KEY_ALL_ACCESS, phKey);
    if(dwStatus != ERROR_SUCCESS)
    {
        SetLastError(dwStatus);
        return NULL;
    }

    hCertStore = CertOpenStore( 
                            CERT_STORE_PROV_REG,
                            X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
                            hCryptProv,
                            CERT_STORE_NO_CRYPT_RELEASE_FLAG,
                            (PVOID)*phKey
                        );

    return hCertStore;
}

/*****************************************************************************

    TransferCertFromStoreToStore()

*****************************************************************************/
DWORD
TransferCertFromStoreToStore(
    HCERTSTORE hSrcStore, 
    HCERTSTORE hDestStore
    )
/*
*/
{
    PCCERT_CONTEXT pCertContext=NULL;
    PCCERT_CONTEXT pPrevCertContext=NULL;
    DWORD dwStatus=ERROR_SUCCESS;

    do {
        pCertContext = CertEnumCertificatesInStore(hSrcStore, pPrevCertContext);
        if(pCertContext)
        {
            if(!CertAddCertificateContextToStore( 
                                    hDestStore, 
                                    pCertContext,
                                    CERT_STORE_ADD_REPLACE_EXISTING,
                                    NULL
                                ))
            {
                dwStatus = GetLastError();
                break;
            }
        }

        pPrevCertContext = pCertContext;
    } while( pCertContext != NULL );

    if(GetLastError() == CRYPT_E_NOT_FOUND)
    {
        dwStatus = ERROR_SUCCESS;
    }

    return dwStatus;
}

/*****************************************************************************

    LSSaveCertAsPKCS7()

*****************************************************************************/
DWORD 
TLSSaveCertAsPKCS7(
    PBYTE pbCert, 
    DWORD cbCert, 
    PBYTE* ppbEncodedCert, 
    PDWORD pcbEncodedCert
    )
/*
*/
{
    DWORD           dwStatus=ERROR_SUCCESS;

    HCRYPTPROV      hCryptProv=g_hCryptProv;
    HCERTSTORE      hStore=NULL;
    PCCERT_CONTEXT  pCertContext=NULL;

    do {
        //
        // Must have call CryptoInit()
        //if(!CryptAcquireContext(&hCryptProv, _TEXT(KEYCONTAINER), MS_DEF_PROV, PROV_RSA_FULL, CRYPT_MACHINE_KEYSET))
        //{
        //    LSLogEvent(EVENTLOG_ERROR_TYPE, TLS_E_CRYPT_ACQUIRE_CONTEXT, dwStatus=GetLastError());
        //    break;
        //}

        hStore=CertOpenStore(
                        CERT_STORE_PROV_MEMORY,
                        X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
                        hCryptProv,
                        CERT_STORE_NO_CRYPT_RELEASE_FLAG,
                        NULL
                    );

        if(!hStore)
        {
            TLSLogEvent(
                    EVENTLOG_ERROR_TYPE, 
                    TLS_E_GENERATECLIENTELICENSE,
                    TLS_E_OPEN_CERT_STORE, 
                    dwStatus=GetLastError()
                );
            break;
        }

        pCertContext = CertCreateCertificateContext(
                                            X509_ASN_ENCODING,
                                            pbCert,
                                            cbCert
                                        );

        if(!pCertContext)
        {
            TLSLogEvent(
                    EVENTLOG_ERROR_TYPE, 
                    TLS_E_GENERATECLIENTELICENSE,
                    TLS_E_CREATE_CERTCONTEXT, 
                    dwStatus=GetLastError()
                );  
            break;
        }

        //
        // always start from empty so CERT_STORE_ADD_ALWAYS
        if(!CertAddCertificateContextToStore(
                                hStore, 
                                pCertContext, 
                                CERT_STORE_ADD_ALWAYS, 
                                NULL
                            ))
        {
            TLSLogEvent(
                    EVENTLOG_ERROR_TYPE,  
                    TLS_E_GENERATECLIENTELICENSE,  
                    TLS_E_ADD_CERT_TO_STORE, 
                    dwStatus=GetLastError()
                );  
            break;
        }

#ifdef ENFORCE_LICENSING
        if(g_bHasHydraCert && g_hCaStore)
        {
            if(!TLSChainIssuerCertificate( 
                                    hCryptProv,
                                    g_hCaStore,
                                    hStore,
                                    pCertContext
                                ))
            {
                TLSLogEvent(
                        EVENTLOG_ERROR_TYPE, 
                        TLS_E_GENERATECLIENTELICENSE,
                        TLS_E_ADD_CERT_TO_STORE, 
                        dwStatus=GetLastError()
                    );  
                break;
            }
        }
#endif

        CRYPT_DATA_BLOB saveBlob;
        memset(&saveBlob, 0, sizeof(saveBlob));

        // save certificate into memory
        if(!CertSaveStore(hStore, 
                          X509_ASN_ENCODING | PKCS_7_ASN_ENCODING, 
                          LICENSE_BLOB_SAVEAS_TYPE,
                          CERT_STORE_SAVE_TO_MEMORY,
                          &saveBlob,
                          0) && (dwStatus=GetLastError()) != ERROR_MORE_DATA)
        {
            TLSLogEvent(
                    EVENTLOG_ERROR_TYPE, 
                    TLS_E_GENERATECLIENTELICENSE,
                    TLS_E_SAVE_STORE, 
                    dwStatus=GetLastError()
                );  
            break;
        }

        if(!(saveBlob.pbData = (PBYTE)midl_user_allocate(saveBlob.cbData)))
        {
            dwStatus=GetLastError();
            break;
        }

        // save certificate into memory
        if(!CertSaveStore(hStore, 
                          X509_ASN_ENCODING | PKCS_7_ASN_ENCODING, 
                          LICENSE_BLOB_SAVEAS_TYPE,
                          CERT_STORE_SAVE_TO_MEMORY,
                          &saveBlob,
                          0))
        {
            TLSLogEvent(
                    EVENTLOG_ERROR_TYPE, 
                    TLS_E_GENERATECLIENTELICENSE,
                    TLS_E_SAVE_STORE, 
                    dwStatus=GetLastError()
                );  
            break;
        }
        
        *ppbEncodedCert = saveBlob.pbData;
        *pcbEncodedCert = saveBlob.cbData;

    } while(FALSE);    

    if(pCertContext)
    {
        CertFreeCertificateContext(pCertContext);
    }

    if(hStore)
    {
        CertCloseStore(hStore, CERT_CLOSE_STORE_FORCE_FLAG);
    }

    return (dwStatus == ERROR_SUCCESS) ? ERROR_SUCCESS : TLS_E_SAVE_STORE;
}

//--------------------------------------------------------------------------
//
static LONG
OpenCertRegStore( 
    LPCTSTR szSubKey, 
    PHKEY phKey
    )
/*
*/
{
    DWORD dwDisposition;

    return RegCreateKeyEx(
                    HKEY_LOCAL_MACHINE,
                    szSubKey,
                    0,
                    NULL,
                    REG_OPTION_NON_VOLATILE,
                    KEY_ALL_ACCESS,
                    NULL,
                    phKey,
                    &dwDisposition
                );
}

//--------------------------------------------------------------------------
//
static DWORD
IsHydraRootOIDInCert(
    PCCERT_CONTEXT pCertContext,
    DWORD dwKeyType
    )
/*
*/
{
    BOOL bFound=FALSE;
    PCERT_INFO pCertInfo = pCertContext->pCertInfo;
    PCERT_EXTENSION pCertExtension=pCertInfo->rgExtension;
    PCERT_PUBLIC_KEY_INFO pbPublicKey=NULL;
    DWORD dwStatus = ERROR_SUCCESS;
    DWORD dwSize = 0;

    //
    // Must have a CH root extension.
    //
    for(DWORD i=0; i < pCertInfo->cExtension && bFound == FALSE; i++, pCertExtension++)
    {
        bFound=(strcmp(pCertExtension->pszObjId, szOID_PKIX_HYDRA_CERT_ROOT) == 0);
    }

    if(bFound == TRUE)
    {
        //
        // Public Key must be the same
        //
        dwStatus = TLSExportPublicKey(
                            g_hCryptProv,
                            dwKeyType,
                            &dwSize,
                            &pbPublicKey
                        );

        if(dwStatus == ERROR_SUCCESS)
        {
            bFound = CertComparePublicKeyInfo(
                                        X509_ASN_ENCODING, 
                                        pbPublicKey,
                                        &(pCertContext->pCertInfo->SubjectPublicKeyInfo)
                                    );

            if(bFound == FALSE)
            {
                dwStatus = TLS_E_CH_INSTALL_NON_LSCERTIFICATE;
            }
        }
    }
    else
    {
        dwStatus = TLS_E_CH_LSCERTIFICATE_NOTFOUND;
    }
        
    FreeMemory(pbPublicKey);
    return dwStatus;
}

//---------------------------------------------------------------------------
// Functions:
//      IsCertificateLicenseServerCertificate()
//
// Abstract:
//      Find License Server certificate in PKCS 7 certificate blob
//
// Parameters:
//      hCryptProv - Cryto. Provider
//      cbPKCS7Cert - Size of PKCS7 certificate.
//      pbPKCS7Cert - pointer to PKCS7 certificate
//      cbLsCert - size of encoded license server certificate.
//      pbLsCert - pointer to pointer to receive license server encoded certificate.
//
// Returns:
//      ERROR_SUCCESS
//      TLS_E_INVALID_DATA
//      Crypto. error code.
//---------------------------------------------------------------------------
DWORD
IsCertificateLicenseServerCertificate(
    IN HCRYPTPROV hCryptProv,
    IN DWORD dwCertType,
    IN DWORD cbPKCS7Cert, 
    IN PBYTE pbPKCS7Cert,
    IN OUT DWORD* cbLsCert,
    IN OUT PBYTE* pbLsCert
    ) 
/*
*/
{
    //
    // Certificate must be in PCKS 7 format.
    //
    DWORD dwStatus=ERROR_SUCCESS;
    HCERTSTORE  hCertStore=NULL;
    PCCERT_CONTEXT  pPrevCertContext=NULL;
    PCCERT_CONTEXT  pCertContext=NULL;

    CRYPT_DATA_BLOB Serialized;

    Serialized.pbData = pbPKCS7Cert;
    Serialized.cbData = cbPKCS7Cert;

    hCertStore = CertOpenStore( 
                            CERT_STORE_PROV_PKCS7,
                            X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
                            hCryptProv,
                            CERT_STORE_NO_CRYPT_RELEASE_FLAG,
                            &Serialized
                        );

    if(!hCertStore)
    {
        return dwStatus=GetLastError();
    }

    //
    // enumerate all certificate and find certificate with our extension.
    //
    do {
        pCertContext = CertEnumCertificatesInStore(
                                            hCertStore, 
                                            pPrevCertContext
                                        );
        if(pCertContext)
        {
            dwStatus = IsHydraRootOIDInCert(
                                        pCertContext, 
                                        dwCertType
                                    );

            if(dwStatus == ERROR_SUCCESS)
            {
                //
                // this is our certificate.
                //
                *pbLsCert = (PBYTE)AllocateMemory(*cbLsCert = pCertContext->cbCertEncoded);
                if(*pbLsCert)
                {
                    memcpy(
                            *pbLsCert, 
                            pCertContext->pbCertEncoded, 
                            pCertContext->cbCertEncoded
                        );
                }
                else
                {
                    dwStatus = GetLastError();
                }

                break;
            }
            else if(dwStatus == TLS_E_CH_INSTALL_NON_LSCERTIFICATE)
            {
                break;
            }

            //
            // reset status code.
            //
            dwStatus = ERROR_SUCCESS;
        }

        pPrevCertContext = pCertContext;
    } while( pCertContext != NULL );

    if(pCertContext != NULL)
    {
        CertFreeCertificateContext(pPrevCertContext);
    }

    if(hCertStore)
    {
        CertCloseStore(hCertStore, CERT_CLOSE_STORE_FORCE_FLAG);    
    }

    return dwStatus;
}


//---------------------------------------------------------------------------
// Functions:
//      LSSaveCertificateToReg()
//
// Abstract:
//      
//
// Parameters:
//      hCryptProv - Cryto. Provider
//      
//      
//      
//      
//
// Returns:
//      
//      
//      
//---------------------------------------------------------------------------
DWORD
TLSSaveRootCertificateToReg(
    HCRYPTPROV hCryptProv, 
    HKEY hKey, 
    DWORD cbEncodedCert, 
    PBYTE pbEncodedCert
    )
/*
*/
{
    PCCERT_CONTEXT  pCertContext=NULL;
    HCERTSTORE      hCertSaveStore=NULL;
    DWORD           dwStatus=ERROR_SUCCESS;


    do {
        hCertSaveStore = CertOpenStore( 
                                    CERT_STORE_PROV_REG,
                                    X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
                                    hCryptProv,
                                    CERT_STORE_NO_CRYPT_RELEASE_FLAG,
                                    (PVOID)hKey
                                );
        if(!hCertSaveStore)
        {
            // dwStatus = GetLastError();
            dwStatus = TLS_E_INVALID_DATA;
            break;
        }

        pCertContext = CertCreateCertificateContext(
                                        X509_ASN_ENCODING,
                                        pbEncodedCert,
                                        cbEncodedCert
                                    );

        if(!pCertContext)
        {
            // dwStatus = GetLastError();
            dwStatus = TLS_E_INVALID_DATA;
            break;
        }

        if(!CertAddCertificateContextToStore( 
                                hCertSaveStore, 
                                pCertContext,
                                CERT_STORE_ADD_REPLACE_EXISTING,
                                NULL
                            ))
        {
            dwStatus=GetLastError();
        }
    } while(FALSE);

    if(pCertContext)
    {
        CertFreeCertificateContext( pCertContext );
    }

    if(hCertSaveStore)
    {
        CertCloseStore(
                    hCertSaveStore, 
                    CERT_CLOSE_STORE_FORCE_FLAG
                );
    }

    return dwStatus;
}

//---------------------------------------------------------------------------
// Functions:
//      LSSaveCertificateToReg()
//
// Abstract:
//      
//
// Parameters:
//      hCryptProv - Cryto. Provider
//      
//      
//      
//      
//
// Returns:
//      
//      
//      
//---------------------------------------------------------------------------
DWORD
TLSSaveCertificateToReg(
    HCRYPTPROV hCryptProv, 
    HKEY hKey, 
    DWORD cbPKCS7Cert, 
    PBYTE pbPKCS7Cert
    )
/*
*/
{
    //
    // Certificate must be in PCKS 7 format.
    //
    DWORD           dwStatus=ERROR_SUCCESS;
    HCERTSTORE      hCertOpenStore=NULL;
    HCERTSTORE      hCertSaveStore=NULL;

    PCCERT_CONTEXT  pPrevCertContext=NULL;
    PCCERT_CONTEXT  pCertContext=NULL;

    CRYPT_DATA_BLOB Serialized;

    Serialized.pbData = pbPKCS7Cert;
    Serialized.cbData = cbPKCS7Cert;

    hCertOpenStore = CertOpenStore( 
                                CERT_STORE_PROV_PKCS7,
                                X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
                                hCryptProv,
                                CERT_STORE_NO_CRYPT_RELEASE_FLAG,
                                &Serialized
                            );

    if(!hCertOpenStore)
    {
        // dwStatus = GetLastError();
        dwStatus = TLS_E_INVALID_DATA;
        goto cleanup;
    }

    hCertSaveStore = CertOpenStore( 
                                CERT_STORE_PROV_REG,
                                X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
                                hCryptProv,
                                CERT_STORE_NO_CRYPT_RELEASE_FLAG,
                                (PVOID)hKey
                            );

    if(!hCertSaveStore)
    {
        dwStatus = TLS_E_INVALID_DATA;
        goto cleanup;
    }

    dwStatus = TransferCertFromStoreToStore(
                                hCertOpenStore, 
                                hCertSaveStore
                            );

cleanup:    
    if(hCertSaveStore)
    {
        CertCloseStore(
                    hCertSaveStore, 
                    CERT_CLOSE_STORE_FORCE_FLAG
                );
    }

    if(hCertOpenStore)
    {
        CertCloseStore(
                    hCertOpenStore, 
                    CERT_CLOSE_STORE_FORCE_FLAG
                );    
    }

    return dwStatus;
}

//---------------------------------------------------------------------------
// Functions:
//      LSSaveRootCertificatesToStore()
//
// Abstract:
//      
//      Save root certificate to license server certificate store.
//
// Parameters:
//      hCryptProv - Cryto. Provider
//      cbSignatureCert - size of root's signature certificate.
//      pbSignatureCert - pointer to root's signature certificate.
//      cbExchangeCert - size of root's exchange certficate.
//      pbExchangeCert - pointer to root's exchange certificate
//
// Returns:
//      
//---------------------------------------------------------------------------
DWORD 
TLSSaveRootCertificatesToStore(  
    IN HCRYPTPROV    hCryptProv,
    IN DWORD         cbSignatureCert, 
    IN PBYTE         pbSignatureCert, 
    IN DWORD         cbExchangeCert, 
    IN PBYTE         pbExchangeCert
    )
/*
*/
{
    HKEY    hKey;
    LONG    status=ERROR_SUCCESS;

    if(cbSignatureCert == 0 && cbExchangeCert == 0)
    {
        return status = TLS_E_INVALID_DATA;
    }

    if(cbSignatureCert)
    {
        status = OpenCertRegStore(
                            LSERVER_CERTIFICATE_REG_ROOT_SIGNATURE, 
                            &hKey
                        );
        if(status != ERROR_SUCCESS)
            return status;

        status = TLSSaveRootCertificateToReg( 
                            hCryptProv, 
                            hKey, 
                            cbSignatureCert, 
                            pbSignatureCert
                        );
        RegCloseKey(hKey);
        if(status != ERROR_SUCCESS)
            return status;            
    }

    if(cbExchangeCert)
    {
        status = OpenCertRegStore(
                            LSERVER_CERTIFICATE_REG_ROOT_EXCHANGE, 
                            &hKey
                        );
        if(status != ERROR_SUCCESS)
            return status;

        status=TLSSaveRootCertificateToReg(
                            hCryptProv, 
                            hKey, 
                            cbExchangeCert, 
                            pbExchangeCert
                        );
        RegCloseKey(hKey);
    }

    return status;
}

//---------------------------------------------------------------------------
// Functions:
//      LSSaveCertificatesToStore()
//
// Abstract:
//      
//
// Parameters:
//      hCryptProv - Cryto. Provider
//      
//      
//      
//      
//
// Returns:
//      
//      
//      
//---------------------------------------------------------------------------
DWORD
TLSSaveCertificatesToStore(
    IN HCRYPTPROV    hCryptProv,
    IN DWORD         dwCertType,
    IN DWORD         dwCertLevel,
    IN DWORD         cbSignatureCert, 
    IN PBYTE         pbSignatureCert, 
    IN DWORD         cbExchangeCert, 
    IN PBYTE         pbExchangeCert
    )
/*
*/
{
    HKEY    hKey;
    LONG    status = ERROR_SUCCESS;
    LPTSTR  szRegSignature;
    LPTSTR  szRegExchange;

    switch(dwCertType)
    {
        case CERTIFICATE_CA_TYPE:
            szRegSignature = LSERVER_CERTIFICATE_REG_CA_SIGNATURE;
            szRegExchange = LSERVER_CERTIFICATE_REG_CA_EXCHANGE;
            break;
                                        
        case CERTITICATE_MF_TYPE:
            szRegSignature = LSERVER_CERTIFICATE_REG_MF_SIGNATURE;
            szRegExchange = LSERVER_CERTIFICATE_REG_MF_EXCHANGE;
            break;

        case CERTIFICATE_CH_TYPE:
            szRegSignature = LSERVER_CERTIFICATE_REG_CH_SIGNATURE;
            szRegExchange = LSERVER_CERTIFICATE_REG_CH_EXCHANGE;
            break;

        default:
            status = TLS_E_INVALID_DATA;
            return status;
    }

    if(cbSignatureCert)
    {
        status = OpenCertRegStore(szRegSignature, &hKey);
        if(status != ERROR_SUCCESS)
            return status;

        status=TLSSaveCertificateToReg(
                            hCryptProv, 
                            hKey, 
                            cbSignatureCert, 
                            pbSignatureCert
                        );

        RegCloseKey(hKey);
        if(status != ERROR_SUCCESS)
            return status;            
    }

    if(cbExchangeCert)
    {
        status = OpenCertRegStore(szRegExchange, &hKey);
        if(status != ERROR_SUCCESS)
            return status;

        status=TLSSaveCertificateToReg(
                                hCryptProv, 
                                hKey, 
                                cbExchangeCert, 
                                pbExchangeCert
                            );
        RegCloseKey(hKey);
    }

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\license\tlserver\server\debug.cpp ===
//+--------------------------------------------------------------------------
//
// Copyright (c) 1997-1999 Microsoft Corporation
//
// File:        debug.cpp
//
// Contents:    License Server debugging spew routine
//
// History:     
//
//---------------------------------------------------------------------------
#include "pch.cpp"

#include <windows.h>
#include <stdio.h>
#include <tchar.h>
#include "debug.h"
#include "locks.h"
#include "dbgout.h"


//-----------------------------------------------------------
static HANDLE   DbgConsole=NULL;
//static LPTSTR   DbgEventSrc;

static DWORD    DbgSeverityCode=0;
static DWORD    DbgLevel=0;
static DWORD    DbgModule=0;
//CCriticalSection ConsoleLock;


//-----------------------------------------------------------
void
InitDBGPrintf(
    IN BOOL bConsole,
    IN LPTSTR DbgEventSrc,  // unuse for now
    IN DWORD dwDebug
    )
/*
*/
{
    DbgSeverityCode = (dwDebug & DEBUG_SEVERITY) >> 10;
    DbgModule = (dwDebug & DEBUG_MODULE) >> 12;
    DbgLevel = dwDebug & DEBUG_LEVEL;

    if(DbgConsole == NULL && bConsole == TRUE)
    {
        // allocate a console, ignore error
        AllocConsole();
        DbgConsole = GetStdHandle(STD_OUTPUT_HANDLE);
    }

    return;
}

//-----------------------------------------------------------

void 
DBGPrintf(
    DWORD dwSeverityCode,
    DWORD dwModule,
    DWORD dwLevel, 
    LPTSTR format, ... 
    )
/*
*/
{
    if((dwModule & DbgModule) == 0)
        return;

    //
    // Report all error
    //
    if((dwSeverityCode & DbgSeverityCode) == 0)
        return;

    if((dwLevel & DbgLevel) == 0)
        return;

    va_list marker;

    va_start(marker, format);
    DebugOutput(DbgConsole, format, &marker);
    va_end(marker);

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\license\tlserver\server\dblevel.h ===
//+--------------------------------------------------------------------------
//
// Copyright (c) 1997-1999 Microsoft Corporation
//
// File:        dblevel.h
//
// Contents:    
//
// History:     
//
//---------------------------------------------------------------------------
#ifndef __DBLEVEL_H__

#define __DBLEVEL_H__

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\license\tlserver\server\db.h ===
//+--------------------------------------------------------------------------
//
// Copyright (c) 1997-1999 Microsoft Corporation
//
// File:        db.h
//
// Contents:    
//
// History:     
//
//---------------------------------------------------------------------------
#ifndef __DB_H__
#define __DB_H__


#ifdef __cplusplus
extern "C" {
#endif

    DWORD
    TLSDBValidateLicense(
        PTLSDbWorkSpace      pDbWkSpace,
        IN PHWID             phWid,
        IN PLICENSEREQUEST   pLicensedProduct,
        IN DWORD             dwKeyPackId, 
        IN DWORD             dwLicenseId,
        OUT PTLSLICENSEPACK   lpKeyPack,
        OUT LPLICENSEDCLIENT  lpLicense
    );

    DWORD 
    TLSDBDeleteLicense(
        PTLSDbWorkSpace pDbWkSpace,
        IN DWORD dwKeyPackId, 
        DWORD dwLicenseId
    );

    DWORD 
    TLSDBRevokeLicense(
        PTLSDbWorkSpace pDbWkSpace,
        IN DWORD dwKeyPacKId, 
        IN DWORD dwLicenseId
    );

    DWORD 
    TLSDBReturnLicense(
        PTLSDbWorkSpace pDbWkSpace,
        IN DWORD dwKeyPackId, 
        IN DWORD dwLicenseId,
        IN DWORD dwNewLicenseStatus
    );

    DWORD 
    TLSDBReturnLicenseToKeyPack(
        PTLSDbWorkSpace pDbWkSpace,
        IN DWORD dwKeyPackId, 
        IN int dwNumLicense
    );


    DWORD 
    TLSDBReturnLicenseToAnyKeyPack(
        PTLSDbWorkSpace pDbWkSpace,
        IN TCHAR *szProductId,
        IN WORD wMajorVersion,
        IN WORD wMinorVersion,
        IN DWORD dwKeyPackIdSkip,
        IN int dwNumLicense
    );

    DWORD 
    TLSDBRevokeKeyPack(
        IN PTLSDbWorkSpace pDbWkSpace,
        IN DWORD dwKeyPackId
    );

    DWORD 
    TLSDBReturnKeyPack(
        IN PTLSDbWorkSpace pDbWkSpace,
        IN DWORD dwKeyPackId
    );

    DWORD 
    TLSDBDeleteKeyPack(
        PTLSDbWorkSpace pDbWkSpace,
        IN DWORD dwKeyPackId
    );

    DWORD
    VerifyTLSDBAllocateRequest(
        IN PTLSDBAllocateRequest pRequest 
    );

    DWORD
    AllocateLicensesFromDB(
        IN PTLSDbWorkSpace pDbWkSpace,
        IN PTLSDBAllocateRequest pRequest,
        IN BOOL fCheckAgreementType,
        IN OUT PTLSDBLicenseAllocation pAllocated
    );


#ifdef __cplusplus
}
#endif


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\license\tlserver\server\db.cpp ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996-1998
//
// File:        db.cpp
//
// Contents:    
//              all routine deal with cross table query
//
// History:     
//  Feb 4, 98      HueiWang    Created
//---------------------------------------------------------------------------
#include "pch.cpp"
#include "globals.h"
#include "db.h"
#include "clilic.h"
#include "keypack.h"
#include "kp.h"
#include "lkpdesc.h"
#include "postjob.h"

#define STRSAFE_NO_DEPRECATE
#include <strsafe.h>

/****************************************************************************
Function:
    LSDBValidateLicense()

Description:
    Routine to validate license agaist database, must call LSDecodeLicense()
    to convert hydra license to LICENSEREQUEST structure.

Arguments:
    IN CSQLStmt* - SQL Statement handle to use
    IN PLICENSEREQUEST - License in the form of LICENSEREQUEST structure
    IN dwKeyPackId - KeyPack table's ID that is license is issued from
    IN dwLicenseId - License tables's License ID 
    OUT LPKEYPACK - KeyPack record this license is issued from, NULL if not
                      interested in this value.
    OUT LPLICENSE - Corresponding license record for this license, NULL if
                      not interest in this value.

Returns:
    ERROR_SUCCESS
    TLS_E_INVALID_LICENSE
    TLS_E_INTERNAL
    ODBC error.
****************************************************************************/
DWORD
TLSDBValidateLicense(
    PTLSDbWorkSpace      pDbWkSpace,
    //IN PBYTE             pbLicense,
    //IN DWORD             cbLicense,
    IN PHWID             phWid,
    IN PLICENSEREQUEST   pLicensedProduct,
    IN DWORD             dwKeyPackId, 
    IN DWORD             dwLicenseId,
    OUT PTLSLICENSEPACK   lpKeyPack,
    OUT LPLICENSEDCLIENT  lpLicense
    )
/*

*/
{
    DWORD dwStatus=ERROR_SUCCESS;
    DWORD dwMatchCount=0;

    if(pDbWkSpace == NULL)
    {
        SetLastError(dwStatus = ERROR_INVALID_PARAMETER);
        TLSASSERT(FALSE);
        return dwStatus;
    }

    TLSLICENSEPACK keypack_search;
    TLSLICENSEPACK keypack_found;

    LICENSEDCLIENT license_search;
    LICENSEDCLIENT license_found;
    int count=0;
    BOOL bValid=TRUE;

    memset(&license_search, 0, sizeof(LICENSEDCLIENT));
    memset(&license_found, 0, sizeof(LICENSEDCLIENT));
    keypack_found.pbDomainSid = NULL;

    license_search.dwLicenseId = dwLicenseId;
    dwStatus = TLSDBLicenseEnumBegin(
                        pDbWkSpace,
                        TRUE,
                        LSLICENSE_SEARCH_LICENSEID,
                        &license_search
                    );

    if(dwStatus != ERROR_SUCCESS)
    {
        if(IS_JB_ERROR(dwStatus) != TRUE)
        {
            SetLastError(dwStatus = TLS_E_INVALID_LICENSE);
        }

        goto cleanup;
    }

    do
    {
        dwStatus=TLSDBLicenseEnumNext(
                                pDbWkSpace, 
                                &license_found
                            );

        if(dwStatus != ERROR_SUCCESS)
            break;

        count++;
    } while(count < 1);

    TLSDBLicenseEnumEnd(pDbWkSpace);

    if(count != 1)
    {
        // can't find the license
        SetLastError(dwStatus = TLS_E_INVALID_LICENSE);
        goto cleanup;
    }

    if(count > 1)
    {
        // more than one entry in database has identical
        // license id
        SetLastError(dwStatus = TLS_E_INTERNAL);
        goto cleanup;
    }

    //
    // Not issue by this license server???
    //
    if(license_found.dwKeyPackId != dwKeyPackId)
    {
        SetLastError(dwStatus = TLS_E_INVALID_LICENSE);
        goto cleanup;
    }

    //
    // new license request might pass different HWID
    //
    dwMatchCount += (int)(license_found.dwSystemBiosChkSum == phWid->dwPlatformID);
    dwMatchCount += (int)(license_found.dwVideoBiosChkSum == phWid->Data1);
    dwMatchCount += (int)(license_found.dwFloppyBiosChkSum == phWid->Data2);
    dwMatchCount += (int)(license_found.dwHardDiskSize == phWid->Data3);
    dwMatchCount += (int)(license_found.dwRamSize == phWid->Data4);

    if(dwMatchCount < LICENSE_MIN_MATCH)
    {
        SetLastError(dwStatus = TLS_E_INVALID_LICENSE);
    }

    //
    // Verify against KeyPack Table
    //
    memset(&keypack_search, 0, sizeof(keypack_search));
    keypack_search.dwKeyPackId = dwKeyPackId;

    dwStatus = TLSDBKeyPackFind(
                            pDbWkSpace,
                            TRUE,
                            LSKEYPACK_EXSEARCH_DWINTERNAL,
                            &keypack_search,
                            &keypack_found
                        );

    if(dwStatus != ERROR_SUCCESS)
    {
        if(IS_JB_ERROR(dwStatus) != TRUE)
        {
            SetLastError(dwStatus = TLS_E_INVALID_LICENSE);
        }

        goto cleanup;
    }

    // match KeyPack's Product ID, Version, Language ID, PlatformID
    // structure change, no more product version.
    if(pLicensedProduct->dwPlatformID != keypack_found.dwPlatformType ||
       _tcsicmp((LPTSTR)pLicensedProduct->pProductInfo->pbCompanyName, keypack_found.szCompanyName) ||
       _tcsicmp((LPTSTR)pLicensedProduct->pProductInfo->pbProductID, keypack_found.szProductId) )
    {
        SetLastError(dwStatus = TLS_E_INVALID_LICENSE);
    }

cleanup:

    //FreeTlsLicensePack(&keypack_found);

    if(dwStatus == ERROR_SUCCESS)
    {
        if(lpKeyPack)
        {
            *lpKeyPack = keypack_found;
        }

        if(lpLicense)
        {
            *lpLicense = license_found;
        }
    }

    return dwStatus;
}

/*************************************************************************
Function:
    LSDBDeleteLicense()

*************************************************************************/
DWORD 
TLSDBDeleteLicense(
    PTLSDbWorkSpace pDbWkSpace,
    IN DWORD dwKeyPackId, 
    DWORD dwLicenseId
    )
/*
*/
{
    // TODO - license entry base on license id
    // 1) Return license back to key pack
    // 2) 'Physically' delete the license.

    return ERROR_SUCCESS;
}

/*************************************************************************
Function:
    LSDBRevokeLicense()

*************************************************************************/
DWORD 
TLSDBRevokeLicense(
    PTLSDbWorkSpace pDbWkSpace,
    IN DWORD dwKeyPacKId, 
    IN DWORD dwLicenseId
)
{
    // Set License Status to revoked
    // Return License to KeyPack

    // call LSDBDeleteKeyPack() and if not successful, insert into RevokeLicenseTable
    return ERROR_SUCCESS;
}

/*************************************************************************
Function:
    LSDBReturnLicense()

*************************************************************************/
DWORD 
TLSDBReturnLicense(
    PTLSDbWorkSpace pDbWkSpace,
    IN DWORD dwKeyPackId, 
    IN DWORD dwLicenseId,
    IN DWORD dwNewLicenseStatus
    )
/*
*/
{
    DWORD dwStatus=ERROR_SUCCESS;
    DWORD dwQuantity = 1;

    TLSDBLockKeyPackTable();
    TLSDBLockLicenseTable();

    //
    // no verification on record got updated.
    //
    LICENSEDCLIENT license;
    license.dwLicenseId = dwLicenseId;
    license.ucLicenseStatus = dwNewLicenseStatus;

    //
    // use undocumented feature to delete license
    //
    DBGPrintf(
            DBG_INFORMATION,
            DBG_FACILITY_RETURN,
            DBGLEVEL_FUNCTION_DETAILSIMPLE,
            _TEXT("Deleting license ID %d issued by keypack %d\n"),
            license.dwLicenseId,
            dwKeyPackId
        );

    if (dwNewLicenseStatus == LSLICENSESTATUS_DELETE)
    {
        // get number of CALs in this license

        LICENSEDCLIENT licenseFound;

        dwStatus = TLSDBLicenseFind(
                        pDbWkSpace,
                        TRUE,
                        LSLICENSE_SEARCH_LICENSEID,
                        &license,
                        &licenseFound
                        );

        if(dwStatus == ERROR_SUCCESS)
        {
            dwQuantity = licenseFound.dwNumLicenses;
        }
    }

    dwStatus = TLSDBLicenseSetValue(
                        pDbWkSpace, 
                        LSLICENSE_EXSEARCH_LICENSESTATUS, 
                        &license,
                        FALSE
                    );

    if(dwStatus == ERROR_SUCCESS && dwNewLicenseStatus == LSLICENSESTATUS_DELETE)
    {
        dwStatus = TLSDBReturnLicenseToKeyPack(
                                    pDbWkSpace, 
                                    dwKeyPackId, 
                                    dwQuantity
                                );
    }

    TLSDBUnlockLicenseTable();
    TLSDBUnlockKeyPackTable();
    return dwStatus;
}


/*************************************************************************
Function:
    LSDBReturnLicenseToKeyPack()
*************************************************************************/
DWORD 
TLSDBReturnLicenseToKeyPack(
    IN PTLSDbWorkSpace pDbWkSpace,
    IN DWORD dwKeyPackId, 
    IN int dwNumLicense
    )
{
    DWORD dwStatus = ERROR_SUCCESS;
    TLSDBLockKeyPackTable();

    #ifdef DBG
    DWORD dwPrevNumLicense=0;
    #endif

    TLSLICENSEPACK found;
    TLSLICENSEPACK search;

    found.pbDomainSid = NULL;

    do {

        // retrieve number of licenses
        search.dwKeyPackId = dwKeyPackId;
        dwStatus = TLSDBKeyPackFind(
                            pDbWkSpace,
                            TRUE,
                            LSKEYPACK_EXSEARCH_DWINTERNAL,
                            &search,
                            &found
                        );

        if(dwStatus != ERROR_SUCCESS)
        {
            if(IS_JB_ERROR(dwStatus) == FALSE)
            {
                SetLastError(dwStatus = TLS_E_RECORD_NOTFOUND);
            }
            break;
        }

        if(search.dwKeyPackId != found.dwKeyPackId)
        {
            TLSASSERT(FALSE);
        }

        #ifdef DBG
        dwPrevNumLicense = found.dwNumberOfLicenses;
        #endif

        // set the number of licenses issued by 1
        switch( (found.ucAgreementType & ~LSKEYPACK_RESERVED_TYPE) )
        {
            case LSKEYPACKTYPE_RETAIL:
            case LSKEYPACKTYPE_OPEN:
            case LSKEYPACKTYPE_SELECT:
                // number of licenses available
                if (found.dwNumberOfLicenses + dwNumLicense <= found.dwTotalLicenseInKeyPack)
                {
                    found.dwNumberOfLicenses += dwNumLicense;
                    dwNumLicense = 0;
                }
                else
                {
                    DWORD dwRet = found.dwTotalLicenseInKeyPack - found.dwNumberOfLicenses;
                    found.dwNumberOfLicenses = found.dwTotalLicenseInKeyPack;
                    dwNumLicense -= dwRet;
                }
                break;

            case LSKEYPACKTYPE_FREE:
            case LSKEYPACKTYPE_TEMPORARY:
                // number of license issued
                if(found.dwNumberOfLicenses > 0)
                {
                    found.dwNumberOfLicenses -= dwNumLicense;
                    dwNumLicense = 0;
                }
                break;

            default:
                SetLastError(dwStatus = TLS_E_CORRUPT_DATABASE);
                break;
        }
    
        #ifdef DBG
        DBGPrintf(
                DBG_INFORMATION,
                DBG_FACILITY_RETURN,
                DBGLEVEL_FUNCTION_DETAILSIMPLE,
                _TEXT("Returning license to keypack %d - from %d to %d\n"),
                found.dwKeyPackId,
                dwPrevNumLicense,
                found.dwNumberOfLicenses
            );
        #endif

        //
        // use undocumented feature to delete temp. keypack
        if( (found.ucAgreementType & ~LSKEYPACK_RESERVED_TYPE) == LSKEYPACKTYPE_TEMPORARY && 
            found.dwNumberOfLicenses == 0)
        {
            found.ucKeyPackStatus = LSKEYPACKSTATUS_DELETE;
            
            // delete keypack desc table
            LICPACKDESC keyPackDesc;

            memset(&keyPackDesc, 0, sizeof(LICPACKDESC));
            keyPackDesc.dwKeyPackId = found.dwKeyPackId;
            TLSDBKeyPackDescSetValue(
                                pDbWkSpace, 
                                KEYPACKDESC_SET_DELETE_ENTRY, 
                                &keyPackDesc
                            );
        }

        dwStatus=TLSDBKeyPackSetValues(
                            pDbWkSpace, 
                            TRUE, 
                            LSKEYPACK_EXSEARCH_AVAILABLE, 
                            &found
                        );
    } while(FALSE);

    if ((dwStatus == ERROR_SUCCESS) && (dwNumLicense > 0))
    {
        // next, find more keypacks of the same type to return licenses to
        // ignore any error

        TLSDBReturnLicenseToAnyKeyPack(
                        pDbWkSpace,
                        found.szProductId,
                        found.wMajorVersion,
                        found.wMinorVersion,
                        dwKeyPackId,
                        dwNumLicense);


    }

    TLSDBUnlockKeyPackTable();

    return dwStatus;
}


/*************************************************************************
Function:
    TLSDBReturnLicenseToAnyKeyPack()
*************************************************************************/
DWORD 
TLSDBReturnLicenseToAnyKeyPack(
    IN PTLSDbWorkSpace pDbWkSpace,
    IN TCHAR *szProductId,
    IN WORD wMajorVersion,
    IN WORD wMinorVersion,
    IN DWORD dwKeyPackIdSkip,
    IN int dwNumLicense
    )
{
    DWORD dwStatus = ERROR_SUCCESS;

    TLSLICENSEPACK found;
    TLSLICENSEPACK search;

    SAFESTRCPY(search.szProductId,szProductId);

    dwStatus = TLSDBKeyPackEnumBegin(pDbWkSpace,
                                     TRUE,      // bMatchAll
                                     LSKEYPACK_SEARCH_PRODUCTID,
                                     &search
                                     );

    if(dwStatus != ERROR_SUCCESS)
    {
        goto cleanup;
    }

    while ((dwNumLicense > 0)
           && ((dwStatus = TLSDBKeyPackEnumNext(pDbWkSpace, &found))
               == ERROR_SUCCESS))
    {
        if (found.dwKeyPackId == dwKeyPackIdSkip)
            continue;

        if (found.wMajorVersion != wMajorVersion)
            continue;

        if (found.wMinorVersion != wMinorVersion)
            continue;

        if (found.ucAgreementType & LSKEYPACK_REMOTE_TYPE)
            continue;

        if (found.ucKeyPackStatus & LSKEYPACKSTATUS_REMOTE)
            continue;

        UCHAR ucKeyPackStatus = found.ucKeyPackStatus & ~LSKEYPACKSTATUS_RESERVED;

        if(ucKeyPackStatus == LSKEYPACKSTATUS_UNKNOWN
           || ucKeyPackStatus == LSKEYPACKSTATUS_RETURNED
           || ucKeyPackStatus == LSKEYPACKSTATUS_REVOKED
           || ucKeyPackStatus == LSKEYPACKSTATUS_OTHERS)
            continue;

        if (found.dwNumberOfLicenses == found.dwTotalLicenseInKeyPack)
            continue;

        UCHAR ucAgreementType = found.ucAgreementType & ~LSKEYPACK_RESERVED_TYPE;

        if (ucAgreementType != LSKEYPACKTYPE_RETAIL
            && ucAgreementType != LSKEYPACKTYPE_OPEN
            && ucAgreementType != LSKEYPACKTYPE_SELECT)
            continue;

        if (_tcsicmp(found.szProductId, szProductId) != 0)
            continue;

        // number of licenses available
        if (found.dwNumberOfLicenses + dwNumLicense <= found.dwTotalLicenseInKeyPack)
        {
            found.dwNumberOfLicenses += dwNumLicense;

            dwStatus=TLSDBKeyPackSetValues(
                            pDbWkSpace, 
                            TRUE, 
                            LSKEYPACK_EXSEARCH_AVAILABLE, 
                            &found
                            );

            if (ERROR_SUCCESS == dwStatus)
            {
                dwNumLicense = 0;
            }
        }
        else
        {
            DWORD dwRet = found.dwTotalLicenseInKeyPack - found.dwNumberOfLicenses;
            found.dwNumberOfLicenses = found.dwTotalLicenseInKeyPack;

            dwStatus=TLSDBKeyPackSetValues(
                            pDbWkSpace, 
                            TRUE, 
                            LSKEYPACK_EXSEARCH_AVAILABLE, 
                            &found
                            );

            if (ERROR_SUCCESS == dwStatus)
            {
                dwNumLicense -= dwRet;
            }
        }
    }

    TLSDBKeyPackEnumEnd(pDbWkSpace);

cleanup:
    return dwStatus;
}

/*************************************************************************
Function:
    LSDBRevokeKeyPack()

*************************************************************************/
DWORD 
TLSDBRevokeKeyPack(
    IN PTLSDbWorkSpace pDbWkSpace,
    IN DWORD dwKeyPackId
    )
{
    // Set Key Pack Status to Revoke
    // Insert this key pack into RevokeKeyPackTable ???
    return ERROR_SUCCESS;
}

/*************************************************************************
Function:
    LSDBReturnKeyPack()

*************************************************************************/
DWORD 
TLSDBReturnKeyPack(
    IN PTLSDbWorkSpace pDbWkSpace,
    IN DWORD dwKeyPackId
    )
{
    // Same as RevokeKeyPack except status is return
    // Delete Key pack only when all license has been returned.
    return ERROR_SUCCESS;
}

/*************************************************************************
Function:
    LSDBDeleteKeyPack()

*************************************************************************/
DWORD 
TLSDBDeleteKeyPack(
    PTLSDbWorkSpace pDbWkSpace,
    IN DWORD dwKeyPackId
    )
{
    // Delete Only when all license has been returned.
    return ERROR_SUCCESS;
}


//+------------------------------------------------------------------------
//  Function: 
//      AllocateLicenses()
//
//  Description:
//      Allocate license from key Pack
//
//  Arguments:
//      IN lpSqlStmt - sql statement handle
//      IN ucKeyPackType - key pack type to allocate license from
//      IN szCompanyName - Product Company
//      IN szProductId - Product Name
//      IN dwVersion - Product Version
//      IN dwPlatformId - Product PlatformId
//      IN dwLangId - Product Lanugage Id
//      IN OUT lpdwNumLicense - number of license to be allocated and on
//                              return, number of licenses actually allocated
//      IN bufSize - number of interested keypack that has requested license
//      IN OUT lpAllocationVector - number of license allocated from list of 
//                                  key pack that has requested licenses.
//      IN OUT LPKEYPACK - key Pack that license was allocated from
//
//  Returns:
//      TLS_E_INVALID_DATA      Invalid parameter
//      TLS_I_NO_MORE_DATA      No key pack has the requested license
//
//  Notes:
//      To keep code clean/simple, call ReturnLicenses() for returning 
//      licenses
//-------------------------------------------------------------------------
DWORD
VerifyTLSDBAllocateRequest(
    IN PTLSDBAllocateRequest pRequest 
    )
/*
*/
{
    DWORD dwStatus = ERROR_SUCCESS;
    UCHAR ucAgreementType;

    if(pRequest == NULL)
    {
        SetLastError(dwStatus = ERROR_INVALID_PARAMETER);
        goto cleanup;
    }

    ucAgreementType = (pRequest->ucAgreementType & ~LSKEYPACK_RESERVED_TYPE);

    if(ucAgreementType < LSKEYPACKTYPE_FIRST || ucAgreementType > LSKEYPACKTYPE_LAST)
    {
        DBGPrintf(
                DBG_ERROR,
                DBGLEVEL_FUNCTION_DETAILSIMPLE, 
                DBG_ALL_LEVEL,
                _TEXT("AllocateLicenses() invalid keypack type - %d\n"),
                pRequest->ucAgreementType
            );
        SetLastError(dwStatus = TLS_E_INVALID_DATA);
        goto cleanup;
    }

    if(pRequest->szCompanyName == NULL || _tcslen(pRequest->szCompanyName) == 0)
    {
        DBGPrintf(
                DBG_ERROR,
                DBGLEVEL_FUNCTION_DETAILSIMPLE, 
                DBG_ALL_LEVEL,
                _TEXT("AllocateLicenses() invalid company name\n")
            );
        SetLastError(dwStatus = TLS_E_INVALID_DATA);
        goto cleanup;
    }

    if(pRequest->szProductId == NULL || _tcslen(pRequest->szProductId) == 0)
    {
        DBGPrintf(
                DBG_ERROR,
                DBGLEVEL_FUNCTION_DETAILSIMPLE, 
                DBG_ALL_LEVEL,
                _TEXT("AllocateLicenses() invalid product id\n")
            );
        SetLastError(dwStatus = TLS_E_INVALID_DATA);
    }

cleanup:
    return dwStatus;
}
//----------------------------------------------------------------------

DWORD
AllocateLicensesFromDB(
    IN PTLSDbWorkSpace pDbWkSpace,
    IN PTLSDBAllocateRequest pRequest,
    IN BOOL fCheckAgreementType,
    IN OUT PTLSDBLicenseAllocation pAllocated
    )
/*
*/
{
    DWORD status=ERROR_SUCCESS;

    if(pDbWkSpace == NULL || pRequest == NULL || pAllocated == NULL)
    {
        DBGPrintf(
                DBG_ERROR,
                DBGLEVEL_FUNCTION_DETAILSIMPLE, 
                DBG_ALL_LEVEL,
                _TEXT("pDbWkSpace is NULL...\n")
            );

        SetLastError(status = ERROR_INVALID_PARAMETER);
        TLSASSERT(FALSE);
        return status;
    }

    status = VerifyTLSDBAllocateRequest(pRequest);
    if(status != ERROR_SUCCESS)
        return status;

    if(pAllocated->dwBufSize <= 0)
    {
        DBGPrintf(
                DBG_ERROR,
                DBG_FACILITY_ALLOCATELICENSE, 
                DBGLEVEL_FUNCTION_DETAILSIMPLE,
                _TEXT("AllocateLicenses() invalid return buffer size\n")
            );
        SetLastError(status = TLS_E_INVALID_DATA);
        return status;
    }

    #ifdef DBG
    DWORD dwPrevNumLicense;
    #endif

    BOOL bProductInstalled=FALSE;
    DWORD bufIndex=0;
    TLSLICENSEPACK keypack_search;
    TLSLICENSEPACK keypack_found;

    DWORD dwNumLicenses = pRequest->dwNumLicenses;          // number of license wanted/returned
    DWORD dwTotalAllocated=0;

    memset(&keypack_search, 0, sizeof(keypack_search));
    memset(&keypack_found, 0, sizeof(keypack_found));

    keypack_search.ucAgreementType = pRequest->ucAgreementType;
    StringCbCopy(keypack_search.szCompanyName, sizeof(keypack_search.szCompanyName), pRequest->szCompanyName);
    StringCbCopy(keypack_search.szProductId, sizeof(keypack_search.szProductId), pRequest->szProductId);
    keypack_search.wMajorVersion = HIWORD(pRequest->dwVersion);
    keypack_search.wMinorVersion = LOWORD(pRequest->dwVersion);
    keypack_search.dwPlatformType = pRequest->dwPlatformId;

    LicPackTable& licpack_table=pDbWkSpace->m_LicPackTable;
    time_t current_time=time(NULL);

    //
    // Lock Key Pack table
    // Only update requires locking, read might get in-correct value.
    //

    //
    // Only allow one thread to enter - Jet not fast enough in updating entry
    //
    TLSDBLockKeyPackTable();

    status = TLSDBKeyPackEnumBegin(
                            pDbWkSpace, 
                            TRUE,
                            LSKEYPACK_SEARCH_PRODUCTID | (fCheckAgreementType ? LICENSEDPACK_FIND_LICENSEPACK : 0),
                            &keypack_search
                        );

    if(status != ERROR_SUCCESS)
        goto cleanup;


    while(status == ERROR_SUCCESS && dwNumLicenses != 0 && bufIndex < pAllocated->dwBufSize)
    {
        status = TLSDBKeyPackEnumNext(
                                pDbWkSpace,
                                &keypack_found
                            );
        if(status != ERROR_SUCCESS)
            break;


        //
        // Skip remote keypack
        //
        if(keypack_found.ucAgreementType & LSKEYPACK_REMOTE_TYPE)
        {
            continue;
        }

        if(keypack_found.ucKeyPackStatus & LSKEYPACKSTATUS_REMOTE)
        {
            continue;
        }

        if(fCheckAgreementType
           && (keypack_found.ucAgreementType != pRequest->ucAgreementType))
        {
            continue;
        }

        UCHAR ucKeyPackStatus = keypack_found.ucKeyPackStatus & ~LSKEYPACKSTATUS_RESERVED;

        // Allocating licenses
        //
        // Throw away any key pack that has bad status
        // one of the reason why can't returning license in this routine
        // for returning license, we should not care about key pack 
        // status.
        if(ucKeyPackStatus == LSKEYPACKSTATUS_UNKNOWN ||
           ucKeyPackStatus == LSKEYPACKSTATUS_RETURNED ||
           ucKeyPackStatus == LSKEYPACKSTATUS_REVOKED ||
           ucKeyPackStatus == LSKEYPACKSTATUS_OTHERS)
        {
            continue;
        }

        //
        // we find the product, make sure the version is what we want.
        //
        bProductInstalled=TRUE;

        // Expired keypack
        // TODO - update table here.
        if((DWORD)keypack_found.dwExpirationDate < current_time)
           continue;

        //
        // never allocate from older version
        //
        if( keypack_found.wMajorVersion < HIWORD(pRequest->dwVersion) )
        {
            continue;
        }

        //
        // Same major version but older minor
        //
        if( keypack_found.wMajorVersion == HIWORD(pRequest->dwVersion) && 
            keypack_found.wMinorVersion < LOWORD(pRequest->dwVersion) )
        {
            continue;
        }

        if(pRequest->dwScheme == ALLOCATE_EXACT_VERSION)
        {
            if(keypack_found.wMajorVersion != HIWORD(pRequest->dwVersion) ||
               keypack_found.wMinorVersion < LOWORD(pRequest->dwVersion) )
            {
                continue;
            }
        }

        UCHAR ucAgreementType = (keypack_found.ucAgreementType & ~LSKEYPACK_RESERVED_TYPE);

        //
        // Verify number of licenses left
        //
        if((ucAgreementType == LSKEYPACKTYPE_SELECT ||
            ucAgreementType == LSKEYPACKTYPE_RETAIL || 
			ucAgreementType == LSKEYPACKTYPE_OPEN) &&
            keypack_found.dwNumberOfLicenses == 0)
        {
            continue;
        }

        pAllocated->lpAllocateKeyPack[bufIndex] = keypack_found;

        #ifdef DBG
        dwPrevNumLicense = pAllocated->lpAllocateKeyPack[bufIndex].dwNumberOfLicenses;
        #endif

        if( ucAgreementType != LSKEYPACKTYPE_RETAIL && 
		    ucAgreementType != LSKEYPACKTYPE_OPEN &&
            ucAgreementType != LSKEYPACKTYPE_SELECT )
        {
            // For Free/temporary license, number of available license is
            // how many license has been issued
            pAllocated->lpAllocateKeyPack[bufIndex].dwNumberOfLicenses += dwNumLicenses;
            pAllocated->pdwAllocationVector[bufIndex] = dwNumLicenses;

            dwTotalAllocated += dwNumLicenses;
            pAllocated->lpAllocateKeyPack[bufIndex].dwNextSerialNumber += dwNumLicenses;
            dwNumLicenses=0;
        } 
        else 
        {
            int allocated=min(dwNumLicenses, keypack_found.dwNumberOfLicenses);

            pAllocated->lpAllocateKeyPack[bufIndex].dwNumberOfLicenses -= allocated;
            dwNumLicenses -= allocated;
            pAllocated->pdwAllocationVector[bufIndex] = allocated;

            dwTotalAllocated += allocated;
            pAllocated->lpAllocateKeyPack[bufIndex].dwNextSerialNumber += allocated;
        }

        #if DBG
        DBGPrintf(
                DBG_INFORMATION,
                DBG_FACILITY_ALLOCATELICENSE,
                DBGLEVEL_FUNCTION_DETAILSIMPLE,
                _TEXT("Updating keypack %d number of license from %d to %d\n"),
                pAllocated->lpAllocateKeyPack[bufIndex].dwKeyPackId,
                dwPrevNumLicense,
                pAllocated->lpAllocateKeyPack[bufIndex].dwNumberOfLicenses
            );
        #endif

        //
        // Update number of licenses available for this keypack and license id in keypack
        //
        GetSystemTimeAsFileTime(&(pAllocated->lpAllocateKeyPack[bufIndex].ftLastModifyTime));
        if(licpack_table.UpdateRecord(
                            pAllocated->lpAllocateKeyPack[bufIndex],
                            LICENSEDPACK_ALLOCATE_LICENSE_UPDATE_FIELD
                        ) == FALSE)
        {
            SetLastError(status = SET_JB_ERROR(licpack_table.GetLastJetError()));
            TLSASSERT(FALSE);
            break;
        }

        #ifdef DBG
        TLSLICENSEPACK test;

        if(licpack_table.FetchRecord(test) == FALSE)
        {
            SetLastError(status = SET_JB_ERROR(licpack_table.GetLastJetError()));
            TLSASSERT(FALSE);
        }
    
        if(test.dwKeyPackId != pAllocated->lpAllocateKeyPack[bufIndex].dwKeyPackId ||
           test.dwNumberOfLicenses != pAllocated->lpAllocateKeyPack[bufIndex].dwNumberOfLicenses)
        {
            TLSASSERT(FALSE);
        }

        //FreeTlsLicensePack(&test);
        #endif

        bufIndex++;
        }
    //
    // terminate enumeration.
    //
    TLSDBKeyPackEnumEnd(pDbWkSpace);
    if(status == TLS_I_NO_MORE_DATA)
    {
        if(bufIndex != 0)
        {
            status = ERROR_SUCCESS;
        }
        else if(!bProductInstalled)
        {
            SetLastError(status = TLS_E_PRODUCT_NOTINSTALL);
        }
    }

    if(keypack_found.dwNumberOfLicenses == 0)
    {
        TLSAnnounceLKPToAllRemoteServer(keypack_found.dwKeyPackId,0);
    }

    pAllocated->dwBufSize = bufIndex;
    pAllocated->dwTotalAllocated = dwTotalAllocated;   
    pAllocated->dwBufSize = bufIndex;

cleanup:

    TLSDBUnlockKeyPackTable();
    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\license\tlserver\server\errcode.cpp ===
//+--------------------------------------------------------------------------
//
// Copyright (c) 1997-1999 Microsoft Corporation
//
// File:        errcode.cpp
//
// Contents:    Convert License Server error code to TLSAPI return code
//
// History:     
//
//---------------------------------------------------------------------------
#include "pch.cpp"
#include "server.h"
#include "messages.h"

//+------------------------------------------------------------------------
// Function:   
//      LSMapReturnCode()
//     
// Description:
//      Map license server internal code to RPC return code
//
// Arguments:
//      dwCode - license server internal code
//
// Return Value:  
//      RPC return code.
//
// Note:
//      Internal routine within this file.           
//-------------------------------------------------------------------------
DWORD
TLSMapReturnCode(DWORD dwCode)
{
    static struct _TLSMapReturnCode {
        DWORD dwErrCode;
        DWORD dwReturnCode;
    } MapReturnCode[] = {
        {ERROR_SUCCESS,                     LSERVER_S_SUCCESS},
        {TLS_I_SERVICE_STOP,                LSERVER_I_SERVICE_SHUTDOWN},
        {TLS_I_NO_MORE_DATA,                LSERVER_I_NO_MORE_DATA},
        {TLS_W_LICENSE_PROXIMATE,           LSERVER_I_PROXIMATE_LICENSE},
        {TLS_W_TEMPORARY_LICENSE_ISSUED,    LSERVER_I_TEMPORARY_LICENSE},
        {TLS_I_FOUND_TEMPORARY_LICENSE,     LSERVER_I_TEMPORARY_LICENSE},
        {TLS_E_INTERNAL,                    LSERVER_E_INTERNAL_ERROR},
        {TLS_E_ACCESS_DENIED,               LSERVER_E_ACCESS_DENIED},
        {TLS_E_DUPLICATE_RECORD,            LSERVER_E_DUPLICATE},
        {TLS_E_SPKALREADYEXIST,             LSERVER_E_DUPLICATE},
        {ERROR_INVALID_HANDLE,              LSERVER_E_INVALID_HANDLE},
        {TLS_E_INVALID_SEQUENCE,            LSERVER_E_INVALID_SEQUENCE},
        {TLS_E_ALLOCATE_HANDLE,             LSERVER_E_SERVER_BUSY},
        {ERROR_OUTOFMEMORY,                 LSERVER_E_OUTOFMEMORY},
        {TLS_E_INVALID_DATA,                LSERVER_E_INVALID_DATA},
        {ERROR_INVALID_DATA,                LSERVER_E_INVALID_DATA},
        {TLS_E_DECODE_LKP,                  LSERVER_E_INVALID_DATA},
        {TLS_E_RECORD_NOTFOUND,             LSERVER_E_DATANOTFOUND},
        {TLS_E_SERVERLOOKUP,                LSERVER_E_DATANOTFOUND}, 
        {TLS_E_NO_LICENSE,                  LSERVER_E_NO_LICENSE},
        {TLS_E_PRODUCT_NOTINSTALL,          LSERVER_E_NO_PRODUCT},
        //{TLS_E_LICENSE_REJECTED,            LSERVER_E_LICENSE_REJECTED},
        //{TLS_E_LICENSE_REVOKED,             LSERVER_E_LICENSE_REVOKED},
        {TLS_E_CORRUPT_DATABASE,            LSERVER_E_CORRUPT_DATABASE},
        {TLS_E_LICENSE_EXPIRED,             LSERVER_E_LICENSE_EXPIRED},
        {TLS_I_LICENSE_UPGRADED,            LSERVER_I_LICENSE_UPGRADED},
        {TLS_E_NOTSUPPORTED,                LSERVER_E_NOTSUPPORTED},
        {TLS_E_NO_CERTIFICATE,              LSERVER_E_NO_CERTIFICATE},
        {TLS_W_REMOVE_TOOMANY,              LSERVER_I_REMOVE_TOOMANY},
        {TLS_E_DECODE_KEYPACKBLOB,          LSERVER_E_INVALID_DATA},
        {TLS_W_SELFSIGN_CERTIFICATE,        LSERVER_I_SELFSIGN_CERTIFICATE},
        {TLS_W_TEMP_SELFSIGN_CERT,          LSERVER_I_TEMP_SELFSIGN_CERT},
        {TLS_E_CH_INSTALL_NON_LSCERTIFICATE, LSERVER_E_NOT_LSCERTIFICATE},
        {TLS_E_POLICYMODULEERROR,            LSERVER_E_POLICYMODULEERROR},
        {TLS_E_POLICYMODULEEXCEPTION,       LSERVER_E_POLICYMODULEERROR},
        {TLS_E_INCOMPATIBLEVERSION,         LSERVER_E_INCOMPATIBLE},
        {TLS_E_INVALID_SPK,                 LSERVER_E_INVALID_SPK},
        {TLS_E_INVALID_LKP,                 LSERVER_E_INVALID_LKP},
        {TLS_E_SPK_INVALID_SIGN,            LSERVER_E_INVALID_SIGN},
        {TLS_E_LKP_INVALID_SIGN,            LSERVER_E_INVALID_SIGN},
        {TLS_E_NOPOLICYMODULE,              LSERVER_E_NOPOLICYMODULE},
        {TLS_E_POLICYERROR,                 LSERVER_E_POLICYDENYREQUEST}
    };
    
    static numMapReturnCode=sizeof(MapReturnCode)/sizeof(MapReturnCode[0]);
        
    DWORD fStatus;

    for(int i=0; i < numMapReturnCode && MapReturnCode[i].dwErrCode != dwCode; i++);

    if(i >= numMapReturnCode)
    {
        fStatus = dwCode;
        // DebugBreak();
    }
    else
    {
        fStatus = MapReturnCode[i].dwReturnCode;
    }

    return fStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\license\tlserver\server\expperm.cpp ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 2000-2000
//
// File:        expperm.cpp
//
// Contents:    
//
// History:     
//
// Note:        
//---------------------------------------------------------------------------
#include "pch.cpp"
#include <tchar.h>
#include <process.h>
#include "lscommon.h"
#include "debug.h"
#include "globals.h"
#include "db.h"
#include "keypack.h"
#include "clilic.h"
#include "server.h"

#define EXPIRE_THREAD_INITIAL_SLEEP     (1000*60)    /* 1 minute */
#define EXPIRATION_DAYS 30
#define DELETE_EXPIRED_TEMPORARY_IN_DAYS L"EffectiveDaysToDeleteTemporary"

/*++

Function:

    CalculateEffectiveTemporaryExpiration

Description:

    Calculate the license expiration.

Argument:

    pExpiration - The expiration date and time of the license.

Return:

    TRUE if the expiration is calculated successfully or FALSE otherwise.

--*/

BOOL
CalculateEffectiveTemporaryExpiration(
    PDWORD  pdwExpiration )
{
    DWORD dwDays = EXPIRATION_DAYS;
    DWORD dwStatus = ERROR_SUCCESS;
    HKEY hKey = NULL;

    time_t 
        now = time( NULL );
    
    if( NULL == pdwExpiration )
    {
        return( FALSE );
    }

    //-------------------------------------------------------------------
    //
    // Open HKLM\system\currentcontrolset\sevices\termservlicensing\parameters
    //
    //-------------------------------------------------------------------
    dwStatus =RegCreateKeyEx(
                        HKEY_LOCAL_MACHINE,
                        LSERVER_REGISTRY_BASE _TEXT(SZSERVICENAME) _TEXT("\\") LSERVER_PARAMETERS,
                        0,
                        NULL,
                        REG_OPTION_NON_VOLATILE,
                        KEY_READ,
                        NULL,
                        &hKey,
                        NULL
                    );

    if(dwStatus == ERROR_SUCCESS)
    {
        DWORD dwBuffer;
        DWORD cbBuffer = sizeof(DWORD);

        dwStatus = RegQueryValueEx(
                        hKey,
                        DELETE_EXPIRED_TEMPORARY_IN_DAYS,
                        NULL,
                        NULL,
                        (LPBYTE)&dwBuffer,
                        &cbBuffer
                    );

        RegCloseKey(hKey);

        if(dwStatus == ERROR_SUCCESS)
        {
            dwDays = (dwBuffer <7) ? 30: (dwBuffer);
        }
    }

    DWORD dwTemp = (dwDays * 24 *60 *60);
    DWORD dwNow = (DWORD)now;

    if(dwNow > dwTemp)
        dwNow -= dwTemp;
    else
        dwNow -= (EXPIRATION_DAYS * 24 *60 *60);

    *pdwExpiration = dwNow;
    return( TRUE );
}

unsigned int WINAPI
DeleteExpiredTemporaryLicenses()
{
    DWORD dwStatus=ERROR_SUCCESS;
    LICENSEDCLIENT search_license;
	DWORD dwTempLicenseExpiration;

    memset(&search_license,0,sizeof(search_license));

    DBGPrintf(
              DBG_INFORMATION,
              DBGLEVEL_FUNCTION_DETAILSIMPLE,
              DBG_ALL_LEVEL,
              _TEXT("ExpireTemporary : ready...\n")
              );                

    PTLSDbWorkSpace pDbWkSpace = NULL;
    LICENSEDCLIENT found_license;
    TLSLICENSEPACK search_keypack;
    TLSLICENSEPACK found_keypack;

    if( !CalculateEffectiveTemporaryExpiration(&dwTempLicenseExpiration))
		return TLS_E_INTERNAL;

    search_license.ftExpireDate = dwTempLicenseExpiration;

    memset(&found_license,0,sizeof(found_license));
    memset(&search_keypack,0,sizeof(search_keypack));
    memset(&found_keypack,0,sizeof(found_keypack));

    if (!(ALLOCATEDBHANDLE(pDbWkSpace, g_EnumDbTimeout)))
    {
        dwStatus = TLS_E_ALLOCATE_HANDLE;
        return dwStatus;
    }

    TLSDBLockKeyPackTable();
    TLSDBLockLicenseTable();

    CLEANUPSTMT;

    dwStatus = TLSDBLicenseEnumBeginEx(
                    USEHANDLE(pDbWkSpace),
                    TRUE,
                    LSLICENSE_SEARCH_EXPIREDATE,
                    &search_license,
                    JET_bitSeekLE
                    );

    if (ERROR_SUCCESS != dwStatus)
    {
        TLSDBUnlockLicenseTable();        
        TLSDBUnlockKeyPackTable();
        FREEDBHANDLE(pDbWkSpace);
        return TLS_E_INTERNAL;

    }

    while (1)
    {
        dwStatus = TLSDBLicenseEnumNextEx(
                    USEHANDLE(pDbWkSpace),
                    TRUE,    // bReverse
                    TRUE,     // bAnyRecord
                    &found_license
                    );

        if(dwStatus != ERROR_SUCCESS)
        {
            goto next_time;
        }

        //
        // See if this is the right product type
        //
        search_keypack.dwKeyPackId = found_license.dwKeyPackId;

        dwStatus = TLSDBKeyPackFind(
            USEHANDLE(pDbWkSpace),
            TRUE,
            LSKEYPACK_EXSEARCH_DWINTERNAL,
            &search_keypack,
            &found_keypack
            );

        if(dwStatus != ERROR_SUCCESS)
        {
		        continue;               				
        }

        //
        // Only check per-seat temporary
        //
        if (found_keypack.ucAgreementType != LSKEYPACKTYPE_TEMPORARY)
        {
            continue;
        }
		
        BEGIN_TRANSACTION(pDbWorkSpace);

        //  Delete currently enumerated license.            
        dwStatus = TLSDBDeleteEnumeratedLicense(USEHANDLE(pDbWkSpace));

        if (dwStatus == ERROR_SUCCESS)
        {
            dwStatus = TLSDBReturnLicenseToKeyPack(
                            USEHANDLE(pDbWkSpace),
                            found_license.dwKeyPackId,
                            found_license.dwNumLicenses
                            );
        }
        if(dwStatus == ERROR_SUCCESS)
        {
            COMMIT_TRANSACTION(pDbWkSpace);
        }
        else
        {
            ROLLBACK_TRANSACTION(pDbWkSpace);
        }
        
    }

next_time:

    TLSDBLicenseEnumEnd(USEHANDLE(pDbWkSpace));
    TLSDBUnlockLicenseTable();        
    TLSDBUnlockKeyPackTable();
    FREEDBHANDLE(pDbWkSpace);

    return dwStatus;
}


//---------------------------------------------------------------------
unsigned int WINAPI
ExpirePermanentThread(void* ptr)
{
    HANDLE hEvent=(HANDLE) ptr;
    DWORD dwStatus=ERROR_SUCCESS;
    LICENSEDCLIENT search_license;

    memset(&search_license,0,sizeof(search_license));

    //
    // Signal initializer thread we are ready
    //
    SetEvent(hEvent);

    DBGPrintf(
              DBG_INFORMATION,
              DBGLEVEL_FUNCTION_DETAILSIMPLE,
              DBG_ALL_LEVEL,
              _TEXT("ExpirePermanent : ready...\n")
              );                

    //
    // Give service chance to initialize
    //
    Sleep(EXPIRE_THREAD_INITIAL_SLEEP);

    //
    // Forever loop
    //
    while(1)
    {
		DeleteExpiredTemporaryLicenses();

        PTLSDbWorkSpace pDbWkSpace = NULL;
        LICENSEDCLIENT found_license;
        TLSLICENSEPACK search_keypack;
        TLSLICENSEPACK found_keypack;

        search_license.ftExpireDate = time(NULL);

        memset(&found_license,0,sizeof(found_license));
        memset(&search_keypack,0,sizeof(search_keypack));
        memset(&found_keypack,0,sizeof(found_keypack));

        if (!(ALLOCATEDBHANDLE(pDbWkSpace, g_EnumDbTimeout)))
        {
            goto do_sleep;
        }

        TLSDBLockKeyPackTable();
        TLSDBLockLicenseTable();

        CLEANUPSTMT;

        dwStatus = TLSDBLicenseEnumBeginEx(
                              USEHANDLE(pDbWkSpace),
                              TRUE,
                              LSLICENSE_SEARCH_EXPIREDATE,
                              &search_license,
                              JET_bitSeekLE
                              );

        if (ERROR_SUCCESS != dwStatus)
        {
            TLSDBUnlockLicenseTable();        
            TLSDBUnlockKeyPackTable();
            FREEDBHANDLE(pDbWkSpace);

            goto do_sleep;

        }

        while (1)
        {
			dwStatus = TLSDBLicenseEnumNextEx(
                              USEHANDLE(pDbWkSpace),
                              TRUE,    // bReverse
                              TRUE,     // bAnyRecord
                              &found_license
                              );

            if(dwStatus != ERROR_SUCCESS)
            {
                goto next_time;
            }

            //
            // See if this is the right product type
            //
            search_keypack.dwKeyPackId = found_license.dwKeyPackId;

            dwStatus = TLSDBKeyPackFind(
                          USEHANDLE(pDbWkSpace),
                          TRUE,
                          LSKEYPACK_EXSEARCH_DWINTERNAL,
                          &search_keypack,
                          &found_keypack
                          );

            if(dwStatus != ERROR_SUCCESS)
            {
                continue;
            }
			
            //
            // only check licenses that we reissue
            //
            if(found_keypack.ucAgreementType != LSKEYPACKTYPE_RETAIL &&
               found_keypack.ucAgreementType != LSKEYPACKTYPE_SELECT &&
               found_keypack.ucAgreementType != LSKEYPACKTYPE_FREE &&
               found_keypack.ucAgreementType != LSKEYPACKTYPE_OPEN )
            {
                continue;
            }

            UCHAR ucKeyPackStatus = found_keypack.ucKeyPackStatus &
                    ~LSKEYPACKSTATUS_RESERVED;

            //
            // Don't check pending activation key pack
            //
            if(ucKeyPackStatus != LSKEYPACKSTATUS_ACTIVE)
            {
                continue;
            }

            //
            // Only check per-seat and concurrent
            //
            if ((_tcsnicmp(found_keypack.szProductId,
                         TERMSERV_PRODUCTID_SKU,
                         _tcslen(TERMSERV_PRODUCTID_SKU)) != 0)
                && (_tcsnicmp(found_keypack.szProductId,
                         TERMSERV_PRODUCTID_CONCURRENT_SKU,
                         _tcslen(TERMSERV_PRODUCTID_CONCURRENT_SKU)) != 0))
            {
                continue;
            }
            BEGIN_TRANSACTION(pDbWorkSpace);

            //
            //  Return currently enumerated license.
            //


            dwStatus = TLSDBDeleteEnumeratedLicense(USEHANDLE(pDbWkSpace));

            if (dwStatus == ERROR_SUCCESS)
            {
                //
                //  Adjust available license number.
                //

                dwStatus = TLSDBReturnLicenseToKeyPack(
                            USEHANDLE(pDbWkSpace),
                            found_license.dwKeyPackId,
                            found_license.dwNumLicenses
                            );
            }

            if (dwStatus == ERROR_SUCCESS)
            {
                COMMIT_TRANSACTION(pDbWkSpace);

                InterlockedIncrement(&g_lPermanentLicensesReturned);
            }
            else
            {
                ROLLBACK_TRANSACTION(pDbWkSpace);
            }
            
        }

next_time:

        TLSDBLicenseEnumEnd(USEHANDLE(pDbWkSpace));

        TLSDBUnlockLicenseTable();        
        TLSDBUnlockKeyPackTable();

        FREEDBHANDLE(pDbWkSpace);

do_sleep:

        if (WAIT_OBJECT_0 == WaitForSingleObject(GetServiceShutdownHandle(),g_dwReissueExpireThreadSleep))
        {
            break;
        }

        DBGPrintf(
                  DBG_INFORMATION,
                  DBG_FACILITY_RPC,
                  DBGLEVEL_FUNCTION_DETAILSIMPLE,
                  _TEXT("ExpirePermanent : woke up\n")
                  );                

    }
            
    //
    // Initializer function will close the event handle
    //

    return dwStatus;
}


//---------------------------------------------------------------------
DWORD
InitExpirePermanentThread()
/*++

++*/
{
    HANDLE hThread = NULL;
    unsigned int  dwThreadId;
    HANDLE hEvent = NULL;
    DWORD dwStatus = ERROR_SUCCESS;
    HANDLE waithandles[2];


    //
    // Create a event for namedpipe thread to signal it is ready.
    //
    hEvent = CreateEvent(
                        NULL,
                        FALSE,
                        FALSE,  // non-signal
                        NULL
                    );
        
    if(hEvent == NULL)
    {
        dwStatus = GetLastError();
        goto cleanup;
    }

    hThread = (HANDLE)_beginthreadex(
                                NULL,
                                0,
                                ExpirePermanentThread,
                                hEvent,
                                0,
                                &dwThreadId
                            );

    if(hThread == NULL)
    {
        dwStatus = GetLastError();
        goto cleanup;
    }

    waithandles[0] = hEvent;
    waithandles[1] = hThread;
    
    //
    // Wait 30 second for thread to complete initialization
    //
    dwStatus = WaitForMultipleObjects(
                                sizeof(waithandles)/sizeof(waithandles[0]), 
                                waithandles, 
                                FALSE,
                                30*1000
                            );

    if(dwStatus == WAIT_OBJECT_0)
    {    
        //
        // thread is ready
        //
        dwStatus = ERROR_SUCCESS;
    }
    else 
    {
        if(dwStatus == (WAIT_OBJECT_0 + 1))
        {
            //
            // Thread terminate abnormally
            //
            GetExitCodeThread(
                        hThread,
                        &dwStatus
                    );
        }
        else
        {
            dwStatus = TLS_E_SERVICE_STARTUP_CREATE_THREAD;
        }
    }
    

cleanup:

    if(hEvent != NULL)
    {
        CloseHandle(hEvent);
    }

    if(hThread != NULL)
    {
        CloseHandle(hThread);
    }


    return dwStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\license\tlserver\server\debug.h ===
//+--------------------------------------------------------------------------
//
// Copyright (c) 1997-1999 Microsoft Corporation
//
// File:        debug.h
//
// Contents:    Debugging define in license server
//
// History:     
//
//---------------------------------------------------------------------------
#ifndef __DEBUG_H__
#define __DEBUG_H__

//------------------------------------------------------
#define DEBUG_LEVEL                     0x000003FF
#define DEBUG_SEVERITY                  0x00000C00
#define DEBUG_MODULE                    0xFFFFF000

//
// 
// Debug level : Bit 0 to 13 (total of 14 debug level)
//


//
// severity code : Bit 30 and 31 
//
#define DBG_SUCCESS                     0x00
#define DBG_INFORMATION                 0x01
#define DBG_WARNING                     0x10
#define DBG_ERROR                       0x11

//
// Facility Code : Bit 14 - 29 
//
#define DBG_FACILITY_JETBLUE            0x00001
#define DBG_FACILITY_RPC                0x00002
#define DBG_FACILITY_KEYPACK            0x00004
#define DBG_FACILITY_LICENSED           0x00008
#define DBG_FACILITY_KEYPACKDESC        0x00010
#define DBG_FACILITY_ALLOCATELICENSE    0x00020
#define DBG_FACILITY_INIT               0x00040
#define DBG_FACILITY_LOCK               0x00080
#define DBG_FACILITY_HANDLEPOOL         0x00100
#define DBG_FACILITY_RETURN             0x00200
#define DBG_FACILITY_UPGRADE            0x00400
#define DBG_FACILITY_POLICY             0x00800
#define DBG_FACILITY_WORKMGR            0x01000
#define DBG_FACILITY_WKSTORAGE          0x02000
#define DBG_FACILITY_SRVLIST            0x04000
#define DBG_FACILITY_JOB                0x08000

//
// All level
//
#define DBG_ALL_LEVEL                   DEBUG_LEVEL

//
// Debug Level
// 
#define DBGLEVEL_FUNCTION_ERROR         0x0001
#define DBGLEVEL_FUNCTION_TRACE         0x0001
#define DBGLEVEL_FUNCTION_DETAILSIMPLE  0x0002
#define DBGLEVEL_FUNCTION_DETAILFULL    0x0004
#define DBGLEVEL_FUNCTION_ALL           DBG_ALL_LEVEL  


//-------------------------------------------------------------

#ifdef __cplusplus
extern "C" {
#endif

    void
    InitDBGPrintf(
        IN BOOL bConsole,
        IN LPTSTR DbgEventSrc,  // unuse for now
        IN DWORD dwDebug
    );

    void 
    DBGPrintf(
        DWORD dwSeverityCode,
        DWORD dwModule,
        DWORD dwLevel, 
        LPTSTR format, ... 
    );

#ifdef __cplusplus
}
#endif


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\license\tlserver\server\defpol.cpp ===
//+--------------------------------------------------------------------------
//
// Copyright (c) 1997-1999 Microsoft Corporation
//
// File:        defpol.cpp
//
// Contents:    Default policy module
//
// History:     
//
//---------------------------------------------------------------------------
#include "pch.cpp"
#include "tlspol.h"
#include "policy.h"


//---------------------------------------------------------------
//
// Default Policy Module Function.
//
//---------------------------------------------------------------
POLICYSTATUS WINAPI
PMInitialize(
    DWORD dwLicenseServerVersion,    // HIWORD is major, LOWORD is minor
    LPCTSTR pszCompanyName,
    LPCTSTR pszProductCode,
    PDWORD pdwNumProduct,
    PPMSUPPORTEDPRODUCT* ppszProduct,
    PDWORD pdwErrCode
    )
/*++


--*/
{
    *pdwNumProduct = 0;
    *ppszProduct = NULL;
    *pdwErrCode = ERROR_SUCCESS;
    return POLICY_SUCCESS;
}
   
//-------------------------------------------------------
POLICYSTATUS WINAPI
PMReturnLicense(
	PMHANDLE hClient,
	ULARGE_INTEGER* pLicenseSerialNumber,
	PPMLICENSETOBERETURN pLicenseTobeReturn,
	PDWORD pdwLicenseStatus,
    PDWORD pdwErrCode
    )
/*++

++*/
{

    //
    // default return license is always delete old license
    // and return license to license pack
    //

    *pdwLicenseStatus = LICENSE_RETURN_DELETE;
    *pdwErrCode = ERROR_SUCCESS;
    return POLICY_SUCCESS;
}

//--------------------------------------------------------------
POLICYSTATUS WINAPI
PMInitializeProduct(
    LPCTSTR pszCompanyName,
    LPCTSTR pszCHCode,
    LPCTSTR pszTLSCode,
    PDWORD pdwErrCode
    )
/*++

++*/
{
    //
    // Initialize internal data here
    //
    *pdwErrCode = ERROR_SUCCESS;
    return POLICY_SUCCESS;
}

//--------------------------------------------------------------
POLICYSTATUS WINAPI
PMUnloadProduct(
    LPCTSTR pszCompanyName,
    LPCTSTR pszCHCode,
    LPCTSTR pszTLSCode,
    PDWORD pdwErrCode
    )
/*++

++*/
{

    //
    // Free all internal data here
    //
    *pdwErrCode = ERROR_SUCCESS;
    return POLICY_SUCCESS;
}

//--------------------------------------------------------------
void WINAPI
PMTerminate()
/*++

++*/
{

    //
    // Free internal data here
    //

    return;
}

//--------------------------------------------------------------

POLICYSTATUS
ProcessLicenseRequest(
    PMHANDLE client,
    PPMLICENSEREQUEST pbRequest,
    PPMLICENSEREQUEST* pbAdjustedRequest,
    PDWORD pdwErrCode
    )
/*++

++*/
{
    POLICYSTATUS dwStatus = POLICY_SUCCESS;

    *pbAdjustedRequest = pbRequest;

    if(pbRequest->dwLicenseType != LICENSETYPE_LICENSE)
    {
        dwStatus = POLICY_NOT_SUPPORTED;
        *pdwErrCode = TLS_E_NOCONCURRENT;
    }

    return dwStatus;
}


//--------------------------------------------------------------

POLICYSTATUS
ProcessAllocateRequest(
    PMHANDLE client,
    DWORD dwSuggestType,
    PDWORD pdwKeyPackType,
    PDWORD pdwErrCode
    )    
/*++

    Default sequence is always FREE/RETAIL/OPEN/SELECT/TEMPORARY

++*/
{
    POLICYSTATUS dwStatus = POLICY_SUCCESS;

    switch(dwSuggestType)
    {
        case LSKEYPACKTYPE_UNKNOWN:
            *pdwKeyPackType = LSKEYPACKTYPE_FREE;
            break;

        case LSKEYPACKTYPE_FREE:
            *pdwKeyPackType = LSKEYPACKTYPE_RETAIL;
            break;

        case LSKEYPACKTYPE_RETAIL:
            *pdwKeyPackType = LSKEYPACKTYPE_OPEN;
            break;

        case LSKEYPACKTYPE_OPEN:
            *pdwKeyPackType = LSKEYPACKTYPE_SELECT;
            break;

        case LSKEYPACKTYPE_SELECT:
            //
            // No more keypack to look for, instruct license
            // server to terminate.
            //
            *pdwKeyPackType = LSKEYPACKTYPE_UNKNOWN;
            break;

        default:

            //
            // Instruct License Server to terminate request
            //
            *pdwKeyPackType = LSKEYPACKTYPE_UNKNOWN;
    }        

    *pdwErrCode = ERROR_SUCCESS;
    return dwStatus;
}

//-------------------------------------------------------------

POLICYSTATUS
ProcessGenLicenses(
    PMHANDLE client,
    PPMGENERATELICENSE pGenLicense,
    PPMCERTEXTENSION *pCertExtension,
    PDWORD pdwErrCode
    )
/*++

++*/
{
    // No policy extension to return.
    *pCertExtension = NULL;
    *pdwErrCode = ERROR_SUCCESS;

    return POLICY_SUCCESS;
}

//--------------------------------------------------------------

POLICYSTATUS
ProcessComplete(
    PMHANDLE client,
    DWORD dwErrCode,
    PDWORD pdwRetCode
    )
/*++

++*/
{
    *pdwRetCode = ERROR_SUCCESS;
    return POLICY_SUCCESS;
}
    

//--------------------------------------------------------------

POLICYSTATUS WINAPI
PMLicenseRequest(
    PMHANDLE client,
    DWORD dwProgressCode, 
    PVOID pbProgressData, 
    PVOID* pbNewProgressData,
    PDWORD pdwErrCode
    )
/*++


++*/
{
    POLICYSTATUS dwStatus = POLICY_SUCCESS;

    switch( dwProgressCode )
    {
        case REQUEST_NEW:
            //
            // License Server ask to fine tune the request.
            //
            dwStatus = ProcessLicenseRequest(
                                    client,
                                    (PPMLICENSEREQUEST) pbProgressData,
                                    (PPMLICENSEREQUEST *) pbNewProgressData,
                                    pdwErrCode
                                );
            break;

        case REQUEST_KEYPACKTYPE:
            //
            // License Server ask for the license pack type
            //
            dwStatus = ProcessAllocateRequest(
                                    client,
                                    #ifdef _WIN64
                                    PtrToUlong(pbProgressData),
                                    #else
                                    (DWORD) pbProgressData,
                                    #endif
                                    (PDWORD) pbNewProgressData,
                                    pdwErrCode
        
                                );
            break;

        case REQUEST_TEMPORARY:
            //
            // License Server ask if temporary license should be issued
            //
            *(BOOL *)pbNewProgressData = TRUE;
            *pdwErrCode = ERROR_SUCCESS;
            break;

        case REQUEST_GENLICENSE:
            //
            // License Server ask for certificate extension
            //
            dwStatus = ProcessGenLicenses(
                                    client,
                                    (PPMGENERATELICENSE) pbProgressData,
                                    (PPMCERTEXTENSION *) pbNewProgressData,
                                    pdwErrCode
                                );

            break;


        case REQUEST_COMPLETE:
            //
            // Request complete
            //
            dwStatus = ProcessComplete(
                                    client,
                                    #ifdef _WIN64
                                    PtrToUlong(pbNewProgressData),
                                    #else
                                    (DWORD) pbNewProgressData,
                                    #endif
                                    pdwErrCode
                                );
            break;

        case REQUEST_KEYPACKDESC:
            if(pbNewProgressData != NULL)
            {
                *pbNewProgressData = NULL;
            }

            // FALL THRU

        default:
            *pdwErrCode = ERROR_SUCCESS;
            dwStatus = POLICY_SUCCESS;
    }

    return dwStatus;
}

//------------------------------------------------------------------------
POLICYSTATUS 
ProcessUpgradeRequest(
    PMHANDLE hClient,
    PPMUPGRADEREQUEST pUpgrade,
    PPMLICENSEREQUEST* pbAdjustedRequest,
    PDWORD pdwRetCode
    )
/*++

++*/
{
    *pdwRetCode = ERROR_SUCCESS;
    *pbAdjustedRequest = pUpgrade->pUpgradeRequest;
    return POLICY_SUCCESS;
}

//------------------------------------------------------------------------

POLICYSTATUS WINAPI
PMLicenseUpgrade(
    PMHANDLE hClient,
    DWORD dwProgressCode,
    PVOID pbProgressData,
    PVOID *ppbReturnData,
    PDWORD pdwRetCode,
    DWORD dwIndex
    )
/*++

++*/
{   
    POLICYSTATUS dwStatus = POLICY_SUCCESS;

    switch(dwProgressCode)
    {
        case REQUEST_UPGRADE:
                dwStatus = ProcessUpgradeRequest(
                                        hClient,
                                        (PPMUPGRADEREQUEST) pbProgressData,
                                        (PPMLICENSEREQUEST *) ppbReturnData,
                                        pdwRetCode
                                    );

                break;

        case REQUEST_COMPLETE:
                dwStatus = ProcessComplete(
                                        hClient,
                                        #ifdef _WIN64
                                        PtrToUlong(pbProgressData),
                                        #else
                                        (DWORD) (pbProgressData),
                                        #endif
                                        pdwRetCode
                                    );

                break;

        default:
            //assert(FALSE);

            *pdwRetCode = ERROR_SUCCESS;
            dwStatus = POLICY_SUCCESS;
    }
        
    return dwStatus;
}

//------------------------------------------------------------------------

POLICYSTATUS WINAPI
PMRegisterLicensePack(
    PMHANDLE hClient,
    DWORD dwProgressCode,
    PVOID pbProgressData,
    PVOID pbProgressReturnData,
    PDWORD pdwRetCode
    )
/*++

    Not supported.

--*/
{
    *pdwRetCode = ERROR_INVALID_FUNCTION;
    return POLICY_NOT_SUPPORTED;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\license\tlserver\server\forward.cpp ===
//+--------------------------------------------------------------------------
//
// Copyright (c) 1997-1999 Microsoft Corporation
//
// File:        forward.cpp
//
// Contents:    Forward license request.
//
// History:     
//
//---------------------------------------------------------------------------
#include "pch.cpp"
#include "globals.h"
#include "srvlist.h"
#include "forward.h"
#include "keypack.h"
#include "postjob.h"


//-----------------------------------------------------------------------

CopyRpcTLSRequestToRequest(
    TLSLICENSEREQUEST* lpRpcRequest ,
    LICENSEREQUEST* lpRequest
    )
/*++

--*/
{
    lpRequest->cbEncryptedHwid = lpRpcRequest->cbEncryptedHwid;
    lpRequest->pbEncryptedHwid = lpRpcRequest->pbEncryptedHwid;
    lpRequest->dwLanguageID = lpRpcRequest->dwLanguageID;
    lpRequest->dwPlatformID = lpRpcRequest->dwPlatformID;
    lpRequest->pProductInfo->dwVersion = lpRpcRequest->ProductInfo.dwVersion;
    lpRequest->pProductInfo->cbCompanyName = lpRpcRequest->ProductInfo.cbCompanyName;
    lpRequest->pProductInfo->pbCompanyName = lpRpcRequest->ProductInfo.pbCompanyName;
    lpRequest->pProductInfo->cbProductID = lpRpcRequest->ProductInfo.cbProductID;
    lpRequest->pProductInfo->pbProductID = lpRpcRequest->ProductInfo.pbProductID;
    return ERROR_SUCCESS;
}


//-----------------------------------------------------------------------
DWORD
ForwardUpgradeLicenseRequest( 
    IN LPTSTR pszServerSetupId,
    IN OUT DWORD *pdwSupportFlags,
    IN TLSLICENSEREQUEST* pRequest,
    IN CHALLENGE_CONTEXT ChallengeContext,
    IN DWORD cbChallengeResponse,
    IN PBYTE pbChallengeResponse,
    IN DWORD cbOldLicense,
    IN PBYTE pbOldLicense,
    OUT PDWORD pcbNewLicense,
    OUT PBYTE* ppbNewLicense,
    OUT PDWORD pdwErrCode
    )
/*++


--*/
{
    TLS_HANDLE hHandle = NULL;
    DWORD dwStatus;
    LICENSEREQUEST LicenseRequest;

    BYTE pbEncryptedHwid[1024];        // encrypted HWID can't be more than 1024
    TCHAR szCompanyName[LSERVER_MAX_STRING_SIZE+2];
    TCHAR szProductId[LSERVER_MAX_STRING_SIZE+2];
    Product_Info ProductInfo;

    TLServerInfo ServerInfo;

    DBGPrintf(
            DBG_INFORMATION,
            DBG_FACILITY_RPC,
            DBGLEVEL_FUNCTION_TRACE,
            _TEXT("ForwardUpgradeLicenseRequest() ...\n")
        );

    dwStatus = TLSLookupRegisteredServer(
                                    pszServerSetupId,
                                    NULL,
                                    NULL,
                                    &ServerInfo
                                );

    if(dwStatus != ERROR_SUCCESS)
    {
        goto cleanup;
    }

    if(TLSCanForwardRequest(
                        TLS_CURRENT_VERSION,
                        ServerInfo.GetServerVersion()
                    ) == FALSE)
    {
        SetLastError(dwStatus = ERROR_INVALID_PARAMETER);
        goto cleanup;
    }

    DBGPrintf(
            DBG_INFORMATION,
            DBG_FACILITY_RPC,
            DBGLEVEL_FUNCTION_TRACE,
            _TEXT("ForwardUpgradeLicenseRequest() to %s %s\n"),
            pszServerSetupId,
            ServerInfo.GetServerName()
        );


    hHandle = TLSConnectToServerWithServerId(pszServerSetupId);
    if(hHandle == NULL)
    {
        //
        // server not available
        //
        dwStatus = GetLastError();
        goto cleanup;
    }

    //
    // RPC AC if pass in the original address
    // TlsRequestToRequest(pTlsRequest, &LicenseRequest);
    if(pRequest->cbEncryptedHwid >= sizeof(pbEncryptedHwid))
    {
        TLSASSERT(FALSE);
        SetLastError(dwStatus = ERROR_INVALID_DATA);
        goto cleanup;
    }

    if(pRequest->ProductInfo.cbCompanyName >= sizeof(szCompanyName) ||
       pRequest->ProductInfo.cbProductID >= sizeof(szProductId)  )
    {
        TLSASSERT(FALSE);
        SetLastError(dwStatus = ERROR_INVALID_DATA);
        goto cleanup;
    }

    memset(&LicenseRequest, 0, sizeof(LicenseRequest));

    memcpy(
            pbEncryptedHwid, 
            pRequest->pbEncryptedHwid, 
            pRequest->cbEncryptedHwid
        );

    LicenseRequest.pbEncryptedHwid = pbEncryptedHwid;
    LicenseRequest.cbEncryptedHwid = pRequest->cbEncryptedHwid;
    LicenseRequest.dwLanguageID = pRequest->dwLanguageID;
    LicenseRequest.dwPlatformID = pRequest->dwPlatformID;
    LicenseRequest.pProductInfo = &ProductInfo;

    ProductInfo.dwVersion = pRequest->ProductInfo.dwVersion;
    ProductInfo.pbCompanyName = (PBYTE)szCompanyName;
    ProductInfo.pbProductID = (PBYTE)szProductId;
    ProductInfo.cbCompanyName = pRequest->ProductInfo.cbCompanyName;
    ProductInfo.cbProductID = pRequest->ProductInfo.cbProductID;

    memset(szCompanyName, 0, sizeof(szCompanyName));
    memset(szProductId, 0, sizeof(szProductId));

    memcpy(
            szCompanyName, 
            pRequest->ProductInfo.pbCompanyName, 
            pRequest->ProductInfo.cbCompanyName
        );

    memcpy(
            szProductId,
            pRequest->ProductInfo.pbProductID,
            pRequest->ProductInfo.cbProductID
        );
    if(IsServiceShuttingdown() == TRUE)
    {
        dwStatus = TLS_I_SERVICE_STOP;
    }
    else
    {
        dwStatus = TLSUpgradeLicenseEx(
                            hHandle,
                            pdwSupportFlags,
                            &LicenseRequest,
                            ChallengeContext,
                            cbChallengeResponse,
                            pbChallengeResponse,
                            cbOldLicense,
                            pbOldLicense,
                            1,  // dwQuantity
                            pcbNewLicense,
                            ppbNewLicense,
                            pdwErrCode
                        );
    }

cleanup:

    if(hHandle)
    {
        TLSDisconnectFromServer(hHandle);           
    }

    return dwStatus;
}

//-----------------------------------------------------------------------

DWORD
ForwardNewLicenseRequest(
    IN LPTSTR pszServerSetupId,
    IN OUT DWORD *pdwSupportFlags,
    IN CHALLENGE_CONTEXT ChallengeContext,
    IN PTLSLICENSEREQUEST pRequest,
    IN LPTSTR pszMachineName,
    IN LPTSTR pszUserName,
    IN DWORD cbChallengeResponse,
    IN PBYTE pbChallengeResponse,
    IN BOOL bAcceptTemporaryLicense,
    IN BOOL bAcceptFewerLicenses,
    IN OUT DWORD *pdwQuantity,
    OUT PDWORD pcbLicense,
    OUT PBYTE *ppbLicense,
    IN OUT PDWORD pdwErrCode
    )
/*++

++*/
{
    TLS_HANDLE hHandle = NULL;
    DWORD dwStatus;
    LICENSEREQUEST LicenseRequest;
    BYTE pbEncryptedHwid[1024];       // encrypted HWID can't be more than 1024
    TCHAR szCompanyName[LSERVER_MAX_STRING_SIZE+2];
    TCHAR szProductId[LSERVER_MAX_STRING_SIZE+2];
    Product_Info ProductInfo;
    TLServerInfo ServerInfo;

    DBGPrintf(
            DBG_INFORMATION,
            DBG_FACILITY_RPC,
            DBGLEVEL_FUNCTION_TRACE,
            _TEXT("ForwardNewLicenseRequest() ...\n")
        );


    dwStatus = TLSLookupRegisteredServer(
                                    pszServerSetupId,
                                    NULL,
                                    NULL,
                                    &ServerInfo
                                );

    if(dwStatus != ERROR_SUCCESS)
    {
        goto cleanup;
    }

    if(TLSCanForwardRequest(
                        TLS_CURRENT_VERSION,
                        ServerInfo.GetServerVersion()
                    ) == FALSE)
    {
        SetLastError(dwStatus = ERROR_INVALID_PARAMETER);
        goto cleanup;
    }

    DBGPrintf(
            DBG_INFORMATION,
            DBG_FACILITY_RPC,
            DBGLEVEL_FUNCTION_TRACE,
            _TEXT("ForwardNewLicenseRequest() to %s %s\n"),
            pszServerSetupId,
            ServerInfo.GetServerName()
        );

   
    hHandle = TLSConnectToServerWithServerId(pszServerSetupId);
    if(hHandle == NULL)
    {
        //
        // server not available
        //
        dwStatus = GetLastError();
        goto cleanup;
    }

    //TlsRequestToRequest(pRequest, &LicenseRequest);

    if(pRequest->cbEncryptedHwid >= sizeof(pbEncryptedHwid))
    {
        TLSASSERT(FALSE);
        SetLastError(dwStatus = ERROR_INVALID_DATA);
        goto cleanup;
    }

    if(pRequest->ProductInfo.cbCompanyName >= sizeof(szCompanyName) ||
       pRequest->ProductInfo.cbProductID >= sizeof(szProductId)  )
    {
        TLSASSERT(FALSE);
        SetLastError(dwStatus = ERROR_INVALID_DATA);
        goto cleanup;
    }

    memset(&LicenseRequest, 0, sizeof(LicenseRequest));

    memcpy(
            pbEncryptedHwid, 
            pRequest->pbEncryptedHwid, 
            pRequest->cbEncryptedHwid
        );

    LicenseRequest.pbEncryptedHwid = pbEncryptedHwid;
    LicenseRequest.cbEncryptedHwid = pRequest->cbEncryptedHwid;
    LicenseRequest.dwLanguageID = pRequest->dwLanguageID;
    LicenseRequest.dwPlatformID = pRequest->dwPlatformID;
    LicenseRequest.pProductInfo = &ProductInfo;

    ProductInfo.dwVersion = pRequest->ProductInfo.dwVersion;
    ProductInfo.pbCompanyName = (PBYTE)szCompanyName;
    ProductInfo.pbProductID = (PBYTE)szProductId;
    ProductInfo.cbCompanyName = pRequest->ProductInfo.cbCompanyName;
    ProductInfo.cbProductID = pRequest->ProductInfo.cbProductID;

    memset(szCompanyName, 0, sizeof(szCompanyName));
    memset(szProductId, 0, sizeof(szProductId));

    memcpy(
            szCompanyName, 
            pRequest->ProductInfo.pbCompanyName, 
            pRequest->ProductInfo.cbCompanyName
        );

    memcpy(
            szProductId,
            pRequest->ProductInfo.pbProductID,
            pRequest->ProductInfo.cbProductID
        );

    if(IsServiceShuttingdown() == TRUE)
    {
        dwStatus = TLS_I_SERVICE_STOP;
    }
    else
    {
        dwStatus = TLSIssueNewLicenseExEx(
                            hHandle,
                            pdwSupportFlags,
                            ChallengeContext,
                            &LicenseRequest,
                            pszMachineName,
                            pszUserName,
                            cbChallengeResponse,
                            pbChallengeResponse,
                            bAcceptTemporaryLicense,
                            bAcceptFewerLicenses,
                            pdwQuantity,
                            pcbLicense,
                            ppbLicense,
                            pdwErrCode
                        );
    }

cleanup:

    if(hHandle)
    {
        TLSDisconnectFromServer(hHandle);           
    }

    return dwStatus;
}

//---------------------------------------------------------
DWORD
TLSForwardUpgradeRequest( 
    IN PTLSForwardUpgradeLicenseRequest pForward,
    IN OUT DWORD *pdwSupportFlags,
    IN PTLSDBLICENSEREQUEST pRequest,
    OUT PDWORD pcbLicense,
    OUT PBYTE* ppbLicense,
    IN BOOL bVerifyNumOfLicenses
    )
/*++

++*/
{
    DWORD dwStatus = ERROR_SUCCESS;
    DWORD dwErrCode = ERROR_SUCCESS;
    PTLSDbWorkSpace pDbWkSpace = NULL;
    TLServerInfo ServerInfo;
    TLSLICENSEPACK search;
    TLSLICENSEPACK found;
    DWORD dwSupportFlagsTemp;

    SAFESTRCPY(search.szProductId,pRequest->pszProductId);

    pDbWkSpace = AllocateWorkSpace(g_EnumDbTimeout);
    if(pDbWkSpace == NULL)
    {
        dwStatus=TLS_E_ALLOCATE_HANDLE;
        goto cleanup;
    }
    dwStatus = TLSDBKeyPackEnumBegin(
                                pDbWkSpace,
                                TRUE,
                                LSKEYPACK_SEARCH_PRODUCTID,
                                &search
                            );


    if(dwStatus != ERROR_SUCCESS)
    {
        goto cleanup;
    }

    while( (dwStatus = TLSDBKeyPackEnumNext(pDbWkSpace, &found)) == ERROR_SUCCESS  )
    {
        if(IsServiceShuttingdown() == TRUE)
        {
            SetLastError(dwStatus = TLS_I_SERVICE_STOP);
            break;
        }

        if(bVerifyNumOfLicenses == TRUE && found.dwNumberOfLicenses == 0)
        {
            continue;
        }

        #if 0
        if(!(found.ucAgreementType & LSKEYPACK_REMOTE_TYPE))
        {
            continue;
        }
        #endif

        if(!(found.ucKeyPackStatus & LSKEYPACKSTATUS_REMOTE))
        {
            continue;
        }

        if(found.wMajorVersion < HIWORD(pRequest->dwProductVersion))
        {
            continue;
        }

        if(found.wMinorVersion < LOWORD(pRequest->dwProductVersion))
        {
            continue;
        }

        if((found.dwPlatformType & ~LSKEYPACK_PLATFORM_REMOTE) != pRequest->dwPlatformID)
        {
            continue;
        }

        if(_tcsicmp(found.szCompanyName, pRequest->pszCompanyName) != 0)
        {
            continue;
        }

        //
        // Save the original Support flags; they can be changed
        //

        dwSupportFlagsTemp = *pdwSupportFlags;

        //
        // make call to remote server
        //
        dwStatus = ForwardUpgradeLicenseRequest(
                                        found.szInstallId,
                                        &dwSupportFlagsTemp,
                                        pForward->m_pRequest,
                                        pForward->m_ChallengeContext,
                                        pForward->m_cbChallengeResponse,
                                        pForward->m_pbChallengeResponse,
                                        pForward->m_cbOldLicense,
                                        pForward->m_pbOldLicense,
                                        pcbLicense,
                                        ppbLicense,
                                        &dwErrCode
                                    );

        if (dwStatus == ERROR_SUCCESS &&
            dwErrCode == LSERVER_S_SUCCESS)
        {
            *pdwSupportFlags = dwSupportFlagsTemp;

            break;
        }

        if (dwStatus == TLS_I_SERVICE_STOP)
        {
            break;
        }

        // try next server
        dwStatus = ERROR_SUCCESS;
    }

    TLSDBKeyPackEnumEnd(pDbWkSpace);
    
cleanup:

    if(pDbWkSpace != NULL)
    {
        ReleaseWorkSpace(&pDbWkSpace);
    }

    return dwStatus;
}

    
//-----------------------------------------------------------------------

DWORD
TLSForwardLicenseRequest(
    IN PTLSForwardNewLicenseRequest pForward,
    IN OUT DWORD *pdwSupportFlags,
    IN PTLSDBLICENSEREQUEST pRequest,
    IN BOOL bAcceptFewerLicenses,
    IN OUT DWORD *pdwQuantity,
    OUT PDWORD pcbLicense,
    OUT PBYTE* ppbLicense
    )
/*++


++*/
{
    DWORD dwStatus = ERROR_SUCCESS;
    DWORD dwErrCode = ERROR_SUCCESS;
    PTLSDbWorkSpace pDbWkSpace = NULL;
    TLServerInfo ServerInfo;
    TLSLICENSEPACK search;
    TLSLICENSEPACK found;
    DWORD dwSupportFlagsTemp;
    DWORD dwQuantityTemp;

    SAFESTRCPY(search.szProductId,pRequest->pszProductId);

    pDbWkSpace = AllocateWorkSpace(g_EnumDbTimeout);
    if(pDbWkSpace == NULL)
    {
        dwStatus=TLS_E_ALLOCATE_HANDLE;
        goto cleanup;
    }

    dwStatus = TLSDBKeyPackEnumBegin(
                                pDbWkSpace,
                                TRUE,
                                LSKEYPACK_SEARCH_PRODUCTID,
                                &search
                            );


    if(dwStatus != ERROR_SUCCESS)
    {
        goto cleanup;
    }

    while( (dwStatus = TLSDBKeyPackEnumNext(pDbWkSpace, &found)) == ERROR_SUCCESS  )
    {
        if(IsServiceShuttingdown() == TRUE)
        {
            SetLastError(dwStatus = TLS_I_SERVICE_STOP);
            break;
        }

        #if 0
        if(!(found.ucAgreementType & LSKEYPACK_REMOTE_TYPE))
        {
            continue;
        }
        #endif

        if(!(found.ucKeyPackStatus & LSKEYPACKSTATUS_REMOTE))
        {
            continue;
        }

        if(found.wMajorVersion < HIWORD(pRequest->dwProductVersion))
        {
            continue;
        }

        if(found.wMinorVersion < LOWORD(pRequest->dwProductVersion))
        {
            continue;
        }

        if((found.dwPlatformType & ~LSKEYPACK_PLATFORM_REMOTE) != pRequest->dwPlatformID)
        {
            continue;
        }

        if(_tcsicmp(found.szCompanyName, pRequest->pszCompanyName) != 0)
        {
            continue;
        }

        //
        // Save the original support flags and quantity;
        // they can be changed
        //

        dwSupportFlagsTemp = *pdwSupportFlags;
        dwQuantityTemp = *pdwQuantity;

        //
        // make call to remote server
        //
        dwStatus = ForwardNewLicenseRequest(
                                        found.szInstallId,
                                        &dwSupportFlagsTemp,
                                        pForward->m_ChallengeContext,
                                        pForward->m_pRequest,
                                        pForward->m_szMachineName,
                                        pForward->m_szUserName,
                                        pForward->m_cbChallengeResponse,
                                        pForward->m_pbChallengeResponse,
                                        FALSE,      // bAcceptTemporaryLicense
                                        bAcceptFewerLicenses,
                                        &dwQuantityTemp,
                                        pcbLicense,
                                        ppbLicense,
                                        &dwErrCode
                                    );

        if (dwStatus == ERROR_SUCCESS &&
            dwErrCode == LSERVER_S_SUCCESS)
        {
            *pdwSupportFlags = dwSupportFlagsTemp;
            *pdwQuantity = dwQuantityTemp;

            break;
        }

        if (dwStatus == TLS_I_SERVICE_STOP)
        {
            break;
        }

        // try next server
        dwStatus = ERROR_SUCCESS;
    }

    TLSDBKeyPackEnumEnd(pDbWkSpace);


cleanup:

    if(pDbWkSpace != NULL)
    {
        ReleaseWorkSpace(&pDbWkSpace);
    }

    return dwStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\license\tlserver\server\forward.h ===
//+--------------------------------------------------------------------------
//
// Copyright (c) 1997-1999 Microsoft Corporation
//
// File:        forward.h
//
// Contents:    
//
// History:     
//
//---------------------------------------------------------------------------
#ifndef __TLS_FORWARD_H__
#define __TLS_FORWARD_H__

#ifdef __cplusplus
extern "C" {
#endif

    DWORD
    TLSForwardUpgradeRequest( 
        IN PTLSForwardUpgradeLicenseRequest pForward,
        IN OUT DWORD *pdwSupportFlags,
        IN PTLSDBLICENSEREQUEST pRequest,
        OUT PDWORD pcbLicense,
        OUT PBYTE* ppbLicense,
        IN BOOL bVerifyNumOfLicenses
    );

    DWORD
    TLSForwardLicenseRequest(
        IN PTLSForwardNewLicenseRequest pForward,
        IN OUT DWORD *pdwSupportFlags,
        IN PTLSDBLICENSEREQUEST pRequest,
        IN BOOL bAcceptFewerLicenses,
        IN OUT DWORD *pdwQuantity,
        OUT PDWORD pcbLicense,
        OUT PBYTE* ppbLicense
    );

    DWORD
    ForwardUpgradeLicenseRequest( 
        IN LPTSTR pszServerSetupId,
        IN OUT DWORD *pdwSupportFlags,
        IN TLSLICENSEREQUEST* pRequest,
        IN CHALLENGE_CONTEXT ChallengeContext,
        IN DWORD cbChallengeResponse,
        IN PBYTE pbChallengeResponse,
        IN DWORD cbOldLicense,
        IN PBYTE pbOldLicense,
        OUT PDWORD pcbNewLicense,
        OUT PBYTE* ppbNewLicense,
        OUT PDWORD pdwErrCode
    );

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\license\tlserver\server\findlost.h ===
//+--------------------------------------------------------------------------
//
// Copyright (c) 1997-1999 Microsoft Corporation
//
// File:        findlost.h
//
// Contents:    
//
// History:     
//
//---------------------------------------------------------------------------
#ifndef __FINDLOST_H__
#define __FINDLOST_H__
#include "server.h"

#ifdef __cplusplus
extern "C" {
#endif

    DWORD
    TLSFindLicense(
        IN PLICENSEDPRODUCT pLicProduct,
        OUT PLICENSEDCLIENT pLicClient
    );

    DWORD
    TLSFindDbLicensedProduct(
        IN PTLSDBLICENSEDPRODUCT pLicProduct,
        OUT PLICENSEDCLIENT pLicClient
    );

    DWORD
    TLSDBFindLostLicense(
        IN PTLSDbWorkSpace pDbWkSpace,
        IN PTLSDBLICENSEREQUEST pLicenseRequest,
        IN PHWID pHwid,
        IN OUT PTLSDBLICENSEDPRODUCT pLicensedProduct,
        OUT PUCHAR pucMarked
    );

#ifdef __cplusplus
}
#endif


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\license\tlserver\server\gencert.h ===
//+--------------------------------------------------------------------------
//
// Copyright (c) 1997-1999 Microsoft Corporation
//
// File:        gencert.h
//
// Contents:    
//
// History:     
//
//---------------------------------------------------------------------------
#ifndef __GEN_CERT_H__
#define __GEN_CERT_H__
#include "server.h"
   

#ifdef __cplusplus
extern "C" {
#endif

    BOOL 
    TLSEncryptBase64EncodeHWID(
        PHWID pHwid, 
        DWORD* cbBase64EncodeHwid, 
        PBYTE* szBase64EncodeHwid
    );

    DWORD
    TLSExportPublicKey(
        IN HCRYPTPROV hCryptProv,
        IN DWORD      dwKeyType,
        IN OUT PDWORD pcbByte,
        IN OUT PCERT_PUBLIC_KEY_INFO  *ppbByte
    );

    DWORD 
    TLSCryptEncodeObject(  
        IN  DWORD   dwEncodingType,
        IN  LPCSTR  lpszStructType,
        IN  const void * pvStructInfo,
        OUT PBYTE*  ppbEncoded,
        OUT DWORD*  pcbEncoded
    );

    DWORD
    TLSChainProprietyCertificate(
        HCRYPTPROV  hCryptProv,
        BOOL        bTemp,
        PBYTE       pbLicense, 
        DWORD       cbLicense, 
        PBYTE*      pbChained, 
        DWORD*      cbChained
    );


    DWORD
    TLSVerifyProprietyChainedCertificate(
        HCRYPTPROV  hCryptProv, 
        PBYTE       pbData, 
        DWORD       cbData
    );

    DWORD
    TLSGenerateClientCertificate(
        IN HCRYPTPROV hCryptProv,
        IN DWORD dwNumLicensedProduct,
        IN PTLSDBLICENSEDPRODUCT pLicProduct,
        IN WORD wLicenseChainDetail,
        OUT PBYTE* ppbEncodedCert,
        OUT PDWORD pcbEncodedCert
    );

    DWORD 
    TLSCreateSelfSignCertificate(
        HCRYPTPROV,
        DWORD,
        PBYTE,
        DWORD,
        DWORD,
        PCERT_EXTENSION,
        PDWORD,
        PBYTE*
    );

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\license\tlserver\server\findlost.cpp ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996-1998
//
// File:        findlost.cpp
//
// Contents:    
//              Find lost license
//
// History:     
//              Feb 4, 98      HueiWang    Created
//---------------------------------------------------------------------------
#include "pch.cpp"
#include "globals.h"
#include "findlost.h"
#include "misc.h"
#include "db.h"
#include "clilic.h"
#include "keypack.h"
#include "kp.h"
#include "lkpdesc.h"

#define STRSAFE_NO_DEPRECATE
#include <strsafe.h>

//++-------------------------------------------------------------------
DWORD
DBFindLicenseExact(
    IN PTLSDbWorkSpace pDbWkSpace,
    IN PLICENSEDPRODUCT pLicProduct,
    OUT LICENSEDCLIENT *pFoundLicense
    )
/*++

Abstract:

    Find license based on exact match of client HWID

Parameter:

    pDbWkSpace : workspace handle.
    pLicProduct : product to request license.
    pFoundLicense: found license

Returns:

    TLS_E_RECORD_NOTFOUND: HWID not found
++*/
{
    DWORD dwStatus = ERROR_SUCCESS;
    BOOL  bFound=FALSE;
    DWORD dwMatchHwidCount;
    LICENSEDCLIENT search_license;
    TLSLICENSEPACK search_keypack;
    TLSLICENSEPACK found_keypack;

    memset(&search_license, 0, sizeof(search_license));
    memset(pFoundLicense, 0, sizeof(LICENSEDCLIENT));

    search_license.dwSystemBiosChkSum = pLicProduct->Hwid.dwPlatformID;
    search_license.dwVideoBiosChkSum = pLicProduct->Hwid.Data1;
    search_license.dwFloppyBiosChkSum = pLicProduct->Hwid.Data2;
    search_license.dwHardDiskSize = pLicProduct->Hwid.Data3; 
    search_license.dwRamSize = pLicProduct->Hwid.Data4;

    //
    // lock both tables - 
    //   Other threads might be in the process of allocating a temp. license
    //   while this thread is searching
    //
    TLSDBLockKeyPackTable();
    TLSDBLockLicenseTable();

    dwStatus = TLSDBLicenseEnumBegin(
                                pDbWkSpace,
                                TRUE,
                                LICENSE_COLUMN_SEARCH_HWID,
                                &search_license
                            );
    if(dwStatus != ERROR_SUCCESS)
    {
        goto cleanup;
    }

    while(bFound == FALSE)
    {
        dwStatus = TLSDBLicenseEnumNext(
                                    pDbWkSpace,
                                    pFoundLicense
                                );

        if(dwStatus != ERROR_SUCCESS)
        {
            break;
        }

        //
        // Verify against client HWID
        //
        dwMatchHwidCount = 0;

        dwMatchHwidCount += (pFoundLicense->dwSystemBiosChkSum == pLicProduct->Hwid.dwPlatformID);
        dwMatchHwidCount += (pFoundLicense->dwVideoBiosChkSum == pLicProduct->Hwid.Data1);
        dwMatchHwidCount += (pFoundLicense->dwFloppyBiosChkSum == pLicProduct->Hwid.Data2);
        dwMatchHwidCount += (pFoundLicense->dwHardDiskSize == pLicProduct->Hwid.Data3);
        dwMatchHwidCount += (pFoundLicense->dwRamSize == pLicProduct->Hwid.Data4);

        if(dwMatchHwidCount != 5)
        {
            break;
        }

        //
        // See if this match our license pack
        //
        search_keypack.dwKeyPackId = pFoundLicense->dwKeyPackId;
        
        dwStatus = TLSDBKeyPackFind(
                                pDbWkSpace,
                                TRUE,
                                LSKEYPACK_EXSEARCH_DWINTERNAL,
                                &search_keypack,
                                &found_keypack
                            );

        if(dwStatus != ERROR_SUCCESS)
        {
            continue;
        }

        //
        // No actual license is issued for concurrent KeyPack.
        //
        if(found_keypack.ucAgreementType != LSKEYPACKTYPE_RETAIL &&
           found_keypack.ucAgreementType != LSKEYPACKTYPE_SELECT && 
           found_keypack.ucAgreementType != LSKEYPACKTYPE_OPEN &&
           found_keypack.ucAgreementType != LSKEYPACKTYPE_TEMPORARY &&
           found_keypack.ucAgreementType != LSKEYPACKTYPE_FREE )
        {
            continue;
        }

        UCHAR ucKeyPackStatus = found_keypack.ucKeyPackStatus & ~LSKEYPACKSTATUS_RESERVED;

        //
        // No license for pending activation key pack, use temporary license scheme.
        //                
        if(ucKeyPackStatus != LSKEYPACKSTATUS_ACTIVE &&
           ucKeyPackStatus != LSKEYPACKSTATUS_TEMPORARY)
        {
            continue;
        }

        if(found_keypack.wMajorVersion != pLicProduct->pLicensedVersion->wMajorVersion ||
           found_keypack.wMinorVersion != pLicProduct->pLicensedVersion->wMinorVersion)
        {
            continue;
        }

        if(found_keypack.dwPlatformType != pLicProduct->LicensedProduct.dwPlatformID)
        {
            continue;
        }

        if(_tcsnicmp(found_keypack.szProductId,
                     (LPTSTR)(pLicProduct->pbOrgProductID),
                     ((pLicProduct->cbOrgProductID)/sizeof(TCHAR)) - 1)
           != 0)
        {
            continue;
        }


        //
        // Found our lost license.
        //
        bFound = TRUE;
    }

    TLSDBLicenseEnumEnd(pDbWkSpace);

cleanup:
    if(dwStatus == TLS_I_NO_MORE_DATA)
    {
        SetLastError(dwStatus = TLS_E_RECORD_NOTFOUND);
    }

    TLSDBUnlockLicenseTable();
    TLSDBUnlockKeyPackTable();

    return dwStatus;

}

//++-------------------------------------------------------------------
DWORD
DBFindLostLicenseExact(
    IN PTLSDbWorkSpace pDbWkSpace,
    IN PTLSDBAllocateRequest pRequest,    // ucKeyPackType not use
    // IN BOOL bMatchHwid,
    IN PHWID pHwid,
    IN OUT PTLSLICENSEPACK lpKeyPack,
    IN OUT PLICENSEDCLIENT lpLicense
    )
/*++

Abstract:

    Find lost license base on exact/closest match of client HWID

Parameter:

    pDbWkSpace : workspace handle.
    pRequest : product to request license.
    bMatchHwid : TRUE if match HWID, FALSE otherwise.
    lpKeyPack : keyPack that license was issued from.
    lpLicense : Founded license record.

Returns:

++*/
{
    DWORD dwStatus = ERROR_SUCCESS;
    BOOL  bFound=FALSE;

    DWORD dwMatchHwidCount;
    LICENSEDCLIENT search_license;
    LICENSEDCLIENT found_license;

    TLSLICENSEPACK search_keypack;
    TLSLICENSEPACK found_keypack;



    //
    // Ignore ucKeyPackType
    //
    pRequest->ucAgreementType = LSKEYPACKTYPE_FIRST;
    dwStatus = VerifyTLSDBAllocateRequest(pRequest);
    if(dwStatus != ERROR_SUCCESS)
    {
        return dwStatus;
    }

    memset(&search_license, 0, sizeof(search_license));
    memset(&found_license, 0, sizeof(found_license));

    search_license.dwSystemBiosChkSum = pHwid->dwPlatformID;
    search_license.dwVideoBiosChkSum = pHwid->Data1;
    search_license.dwFloppyBiosChkSum = pHwid->Data2;
    search_license.dwHardDiskSize = pHwid->Data3; 
    search_license.dwRamSize = pHwid->Data4;

    //
    // lock both table - 
    //   Other thread might be in the process of allocating a temp. license while this 
    //   thread try to delete the temp. key pack.
    //
    TLSDBLockKeyPackTable();
    TLSDBLockLicenseTable();

    dwStatus = TLSDBLicenseEnumBegin(
                                pDbWkSpace,
                                TRUE,
                                LICENSE_COLUMN_SEARCH_HWID,
                                &search_license
                            );
    if(dwStatus != ERROR_SUCCESS)
    {
        goto cleanup;
    }

    while(bFound == FALSE)
    {
        dwStatus = TLSDBLicenseEnumNext(
                                    pDbWkSpace,
                                    &found_license
                                );

        if(dwStatus != ERROR_SUCCESS)
        {
            break;
        }

        //
        // Verify against client HWID
        //
        dwMatchHwidCount = 0;

        dwMatchHwidCount += (found_license.dwSystemBiosChkSum == pHwid->dwPlatformID);
        dwMatchHwidCount += (found_license.dwVideoBiosChkSum == pHwid->Data1);
        dwMatchHwidCount += (found_license.dwFloppyBiosChkSum == pHwid->Data2);
        dwMatchHwidCount += (found_license.dwHardDiskSize == pHwid->Data3);
        dwMatchHwidCount += (found_license.dwRamSize == pHwid->Data4);

        if(dwMatchHwidCount != 5)
        {
            break;
        }

        //
        // consider only valid license 
        //
        if( found_license.ucLicenseStatus != LSLICENSE_STATUS_ACTIVE && 
            found_license.ucLicenseStatus != LSLICENSE_STATUS_PENDING &&
            found_license.ucLicenseStatus != LSLICENSE_STATUS_TEMPORARY)
        {
            continue;
        }

        //
        // See if this match our license pack
        //
        search_keypack.dwKeyPackId = found_license.dwKeyPackId;
        
        dwStatus = TLSDBKeyPackFind(
                                pDbWkSpace,
                                TRUE,
                                LSKEYPACK_EXSEARCH_DWINTERNAL,
                                &search_keypack,
                                &found_keypack
                            );

        if(dwStatus != ERROR_SUCCESS)
        {
            continue;
        }

        //
        // No actual license is issued for concurrent KeyPack.
        //
        if(found_keypack.ucAgreementType != LSKEYPACKTYPE_RETAIL &&
           found_keypack.ucAgreementType != LSKEYPACKTYPE_SELECT && 
           found_keypack.ucAgreementType != LSKEYPACKTYPE_OPEN &&
           found_keypack.ucAgreementType != LSKEYPACKTYPE_TEMPORARY &&
           found_keypack.ucAgreementType != LSKEYPACKTYPE_FREE )
        {
            continue;
        }

        UCHAR ucKeyPackStatus = found_keypack.ucKeyPackStatus & ~LSKEYPACKSTATUS_RESERVED;

        //
        // No license for pending activation key pack, use temporary license scheme.
        //                
        if(ucKeyPackStatus != LSKEYPACKSTATUS_ACTIVE &&
           ucKeyPackStatus != LSKEYPACKSTATUS_TEMPORARY)
        {
            continue;
        }

        if(found_keypack.wMajorVersion != HIWORD(pRequest->dwVersion) ||
           found_keypack.wMinorVersion != LOWORD(pRequest->dwVersion)  )
        {
            continue;
        }

        if(found_keypack.dwPlatformType != pRequest->dwPlatformId)
        {
            continue;
        }

        if(_tcscmp(found_keypack.szCompanyName, pRequest->szCompanyName) != 0)
        {
            continue;
        }

        if(_tcscmp(found_keypack.szProductId, pRequest->szProductId) != 0)
        {
            continue;
        }


        //
        // Found our lost license.
        //
        bFound = TRUE;
        *lpLicense = found_license;
        *lpKeyPack = found_keypack;
    }

    TLSDBLicenseEnumEnd(pDbWkSpace);

cleanup:
    if(dwStatus == TLS_I_NO_MORE_DATA)
    {
        SetLastError(dwStatus = TLS_E_RECORD_NOTFOUND);
    }

    TLSDBUnlockLicenseTable();
    TLSDBUnlockKeyPackTable();

    return dwStatus;
}

//++--------------------------------------------------------------------
DWORD
TLSFindLicense(
    IN PLICENSEDPRODUCT pLicProduct,
    OUT PLICENSEDCLIENT pLicClient
    )
{
    PTLSDbWorkSpace pDbWkSpace = NULL;
    DWORD status = ERROR_SUCCESS;

    pDbWkSpace = AllocateWorkSpace(g_EnumDbTimeout);

    if(pDbWkSpace == NULL)
    {
        status=TLS_E_ALLOCATE_HANDLE;
        goto cleanup;
    }

    status = DBFindLicenseExact(pDbWkSpace,pLicProduct,pLicClient);

    ReleaseWorkSpace(&pDbWkSpace);

cleanup:

    return status;
}

//++--------------------------------------------------------------------
DWORD
TLSFindDbLicensedProduct(
    IN PTLSDBLICENSEDPRODUCT pDbLicProduct,
    OUT PLICENSEDCLIENT pLicClient
    )
{
    PTLSDbWorkSpace pDbWkSpace = NULL;
    DWORD status = ERROR_SUCCESS;
    LICENSEDPRODUCT LicProduct;
    LICENSED_VERSION_INFO LicVerInfo;

    pDbWkSpace = AllocateWorkSpace(g_EnumDbTimeout);

    if(pDbWkSpace == NULL)
    {
        status=TLS_E_ALLOCATE_HANDLE;
        goto cleanup;
    }

    memcpy(&(LicProduct.Hwid), &(pDbLicProduct->ClientHwid), sizeof(HWID));
    LicVerInfo.wMajorVersion = HIWORD(pDbLicProduct->dwProductVersion);
    LicVerInfo.wMinorVersion = LOWORD(pDbLicProduct->dwProductVersion);
    LicProduct.pLicensedVersion = &LicVerInfo;
    LicProduct.LicensedProduct.dwPlatformID = pDbLicProduct->dwPlatformID;
    LicProduct.pbOrgProductID = (PBYTE)(pDbLicProduct->szLicensedProductId);
    LicProduct.cbOrgProductID = _tcslen(pDbLicProduct->szLicensedProductId) * sizeof(TCHAR);

    status = DBFindLicenseExact(pDbWkSpace,&LicProduct,pLicClient);

    ReleaseWorkSpace(&pDbWkSpace);

cleanup:

    return status;
}

//++--------------------------------------------------------------------
DWORD
TLSDBFindLostLicense(
    IN PTLSDbWorkSpace pDbWkSpace,
    IN PTLSDBLICENSEREQUEST pLicenseRequest,
    IN PHWID pHwid,
    IN OUT PTLSDBLICENSEDPRODUCT pLicensedProduct,
    OUT PUCHAR pucMarked
    )
/*++

Abstract:

    Wrapper to DBFindLostLicense().

    See DBFindLostLicense.


++*/
{
    DWORD dwStatus=ERROR_SUCCESS;
    TLSLICENSEPACK keypack;
    LICENSEDCLIENT License;

    ULARGE_INTEGER ulSerialNumber;

    FILETIME notBefore;
    FILETIME notAfter;
    PMGENERATELICENSE PolModGenLicense;
    PPMCERTEXTENSION pPolModCertExtension=NULL;
    PMLICENSEREQUEST PolRequest;
    TLSDBAllocateRequest AllocateRequest;

    DWORD dwRetCode=ERROR_SUCCESS;

    keypack.pbDomainSid = NULL;
    AllocateRequest.szCompanyName = (LPTSTR)pLicenseRequest->pszCompanyName;
    AllocateRequest.szProductId = (LPTSTR)pLicenseRequest->pszProductId;
    AllocateRequest.dwVersion = pLicenseRequest->dwProductVersion;
    AllocateRequest.dwPlatformId = pLicenseRequest->dwPlatformID;
    AllocateRequest.dwLangId = pLicenseRequest->dwLanguageID;
    AllocateRequest.dwNumLicenses = 1;

    dwStatus = DBFindLostLicenseExact(
                            pDbWkSpace,
                            &AllocateRequest,
                            //TRUE,
                            pHwid,
                            &keypack,
                            &License
                        ); 

#if 0
    //
    // TermSrv does not support matching, comment out for now
    //
    if(dwStatus == TLS_E_RECORD_NOTFOUND)
    {
        //
        // find by matching, very expensive operation
        //
        dwStatus = DBFindLostLicenseMatch(
                                pDbWkSpace,
                                &AllocateRequest,
                                FALSE,
                                pHwid,
                                &keypack,
                                &License
                            ); 

        if(dwStatus == ERROR_SUCCESS)
        {
            dwRetCode = TLS_W_LICENSE_PROXIMATE;
        }
    }
#endif

    if(dwStatus != ERROR_SUCCESS)
    {
        goto cleanup;
    }

    UnixTimeToFileTime(License.ftIssueDate, &notBefore);
    UnixTimeToFileTime(License.ftExpireDate, &notAfter);

    ulSerialNumber.LowPart = License.dwLicenseId;
    ulSerialNumber.HighPart = keypack.dwKeyPackId;

    PolRequest.dwProductVersion = MAKELONG(keypack.wMinorVersion, keypack.wMajorVersion);
    PolRequest.pszProductId = (LPTSTR)keypack.szProductId;
    PolRequest.pszCompanyName = (LPTSTR)keypack.szCompanyName;
    PolRequest.dwLanguageId = pLicenseRequest->dwLanguageID; 
    PolRequest.dwPlatformId = keypack.dwPlatformType;
    PolRequest.pszMachineName = License.szMachineName;
    PolRequest.pszUserName = License.szUserName;

    //
    // Inform Policy Module of license generation.
    // 
    PolModGenLicense.pLicenseRequest = &PolRequest;
    PolModGenLicense.dwKeyPackType = keypack.ucAgreementType;
    PolModGenLicense.dwKeyPackId = keypack.dwKeyPackId;
    PolModGenLicense.dwKeyPackLicenseId = License.dwKeyPackLicenseId;
    PolModGenLicense.ClientLicenseSerialNumber = ulSerialNumber;
    PolModGenLicense.ftNotBefore = notBefore;
    PolModGenLicense.ftNotAfter = notAfter;

    dwStatus = pLicenseRequest->pPolicy->PMLicenseRequest( 
                                pLicenseRequest->hClient,
                                REQUEST_GENLICENSE,
                                (PVOID)&PolModGenLicense,
                                (PVOID *)&pPolModCertExtension
                            );

    if(dwStatus != ERROR_SUCCESS)
    {
        //
        // Error in policy module
        //
        goto cleanup;
    }

    //  
    // Check error return from policy module
    //
    if(pPolModCertExtension != NULL)
    {
        if(pPolModCertExtension->pbData != NULL && pPolModCertExtension->cbData == 0 ||
           pPolModCertExtension->pbData == NULL && pPolModCertExtension->cbData != 0  )
        {
            // assuming no extension data
            pPolModCertExtension->cbData = 0;
            pPolModCertExtension->pbData = NULL;
        }

        if(CompareFileTime(&(pPolModCertExtension->ftNotBefore), &(pPolModCertExtension->ftNotAfter)) > 0)
        {
            //
            // invalid data return from policy module
            //
            TLSLogEvent(
                    EVENTLOG_ERROR_TYPE,
                    TLS_E_GENERATECLIENTELICENSE,
                    dwStatus = TLS_E_POLICYMODULEERROR,
                    pLicenseRequest->pPolicy->GetCompanyName(),
                    pLicenseRequest->pPolicy->GetProductId()
                );

            goto cleanup;
        }

        //
        // Ignore not before and not after
        //
    }

    if(keypack.ucAgreementType == LSKEYPACKTYPE_TEMPORARY)
    {
        //
        // we found a temporary license
        //
        dwRetCode = TLS_I_FOUND_TEMPORARY_LICENSE;
    }

    //
    // License expired
    //
    if(License.ftExpireDate < time(NULL))
    {   
        dwRetCode = TLS_E_LICENSE_EXPIRED;
    }

    //
    // Return licensed product
    //
    pLicensedProduct->pSubjectPublicKeyInfo = NULL;
    pLicensedProduct->dwQuantity = License.dwNumLicenses;
    pLicensedProduct->ulSerialNumber = ulSerialNumber;

    pLicensedProduct->dwKeyPackId = keypack.dwKeyPackId;
    pLicensedProduct->dwLicenseId = License.dwLicenseId;
    pLicensedProduct->dwKeyPackLicenseId = License.dwKeyPackLicenseId;

    pLicensedProduct->ClientHwid.dwPlatformID = License.dwSystemBiosChkSum;
    pLicensedProduct->ClientHwid.Data1 = License.dwVideoBiosChkSum;
    pLicensedProduct->ClientHwid.Data2 = License.dwFloppyBiosChkSum;
    pLicensedProduct->ClientHwid.Data3 = License.dwHardDiskSize;
    pLicensedProduct->ClientHwid.Data4 = License.dwRamSize;


    pLicensedProduct->bTemp = (keypack.ucAgreementType == LSKEYPACKTYPE_TEMPORARY);

    pLicensedProduct->NotBefore = notBefore;
    pLicensedProduct->NotAfter = notAfter;

    pLicensedProduct->dwProductVersion = MAKELONG(keypack.wMinorVersion, keypack.wMajorVersion);

    _tcscpy(pLicensedProduct->szCompanyName, keypack.szCompanyName);
    _tcscpy(pLicensedProduct->szLicensedProductId, keypack.szProductId);
    StringCbCopy(pLicensedProduct->szRequestProductId, sizeof(pLicensedProduct->szRequestProductId), pLicenseRequest->pClientLicenseRequest->pszProductId);

    _tcscpy(pLicensedProduct->szUserName, License.szUserName);
    _tcscpy(pLicensedProduct->szMachineName, License.szMachineName);

    pLicensedProduct->dwLanguageID = pLicenseRequest->dwLanguageID;
    pLicensedProduct->dwPlatformID = pLicenseRequest->dwPlatformID;
    pLicensedProduct->pbPolicyData = (pPolModCertExtension) ? pPolModCertExtension->pbData : NULL;
    pLicensedProduct->cbPolicyData = (pPolModCertExtension) ? pPolModCertExtension->cbData : 0;

    if (NULL != pucMarked)
    {
        // this field is being reused for marking (e.g. user is authenticated)

        *pucMarked = License.ucEntryStatus;
    }

cleanup:
    return (dwStatus == ERROR_SUCCESS) ? dwRetCode : dwStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\license\tlserver\server\globals.cpp ===
//+--------------------------------------------------------------------------
//
// Copyright (c) 1997-1999 Microsoft Corporation
//
// File:        globals.cpp 
//
// Contents:    Global varaiables
//
// History:     
//
//---------------------------------------------------------------------------
#include "pch.cpp"
#include "windows.h"
#include "winsock2.h"

#include "tlsjob.h"
#include "wkspace.h"
#include "srvdef.h"


#ifndef _NO_ODBC_JET
TLSDbWorkSpace* g_DbWorkSpace;
#endif

// Defaule server scope
TCHAR g_szScope[LSERVER_MAX_STRING_SIZE+1];
LPTSTR g_pszScope;

// Full Path to database file name.
TCHAR g_szDatabaseFile[MAX_PATH+1];

// database file directory.
// JetBlue require last character be '\'
TCHAR g_szDatabaseDir[MAX_PATH+1];
TCHAR g_szDatabaseFname[MAX_PATH+1];

TCHAR g_szDbUser[MAXUSERNAMELENGTH+1];
TCHAR g_szDbPwd[MAXUSERNAMELENGTH+1];


LPCTSTR szManufactureMS=_TEXT("Microsoft");

LONG g_NextKeyPackId=0;
LONG g_NextLicenseId=0;

PBYTE g_pbSecretKey=NULL;
DWORD g_cbSecretKey=0;


LPTSTR  g_pszServerUniqueId = NULL;
DWORD   g_cbServerUniqueId = 0;

LPTSTR  g_pszServerPid = NULL;
DWORD   g_cbServerPid = 0;

PBYTE  g_pbServerSPK = NULL;
DWORD  g_cbServerSPK = 0;

DWORD g_GracePeriod=GRACE_PERIOD;     // in days.
BOOL  g_IssueTemporayLicense=TRUE;

BOOL  g_bHasHydraCert=FALSE;
PBYTE g_pbSignatureEncodedCert=NULL;
DWORD g_cbSignatureEncodedCert=0;

PBYTE g_pbExchangeEncodedCert=NULL;
DWORD g_cbExchangeEncodedCert=0;

TCHAR g_szHostName[MAXTCPNAME+1];
DWORD g_cbHostName=sizeof(g_szHostName)/sizeof(g_szHostName[0]);

TCHAR g_szComputerName[MAX_COMPUTERNAME_LENGTH+2];
DWORD g_cbComputerName=MAX_COMPUTERNAME_LENGTH+1;

PCCERT_CONTEXT  g_LicenseCertContext=NULL;

//
// Self-signed certificates...
//
PCCERT_CONTEXT g_SelfSignCertContext = NULL;

HCRYPTPROV g_hCryptProv=NULL;

DWORD g_GeneralDbTimeout = DEFAULT_CONNECTION_TIMEOUT;  // Time out for acquiring DB handle
DWORD g_EnumDbTimeout = DB_ENUM_WAITTIMEOUT;            // Time out for acquiring enumeration DB handle
DWORD g_dwMaxDbHandles = DEFAULT_DB_CONNECTIONS;        // number of connection to DB

#if ENFORCE_LICENSING
HCERTSTORE  g_hCaStore=NULL;
HKEY  g_hCaRegKey=NULL;
#endif

HCRYPTKEY g_SignKey=NULL;
HCRYPTKEY g_ExchKey=NULL;
//PBYTE g_pbDomainSid=NULL;
//DWORD g_cbDomainSid=0;
DWORD g_SrvRole=0;

LPTSTR g_szDomainGuid = NULL;

PCERT_EXTENSIONS g_pCertExtensions;
DWORD            g_cbCertExtensions;

FILETIME         g_ftCertExpiredTime;
FILETIME        g_ftLastShutdownTime={0, 0};

DWORD           g_dwTlsJobInterval=DEFAULT_JOB_INTERVAL;
DWORD           g_dwTlsJobRetryTimes=DEFAULT_JOB_RETRYTIMES;
DWORD           g_dwTlsJobRestartTime=DEFAULT_JOB_INTERVAL;

SERVER_ROLE_IN_DOMAIN g_ServerRoleInDomain;

DWORD           g_LowLicenseCountWarning=0;

DWORD           g_EsentMaxCacheSize=0;
DWORD           g_EsentStartFlushThreshold=0;
DWORD           g_EsentStopFlushThreadhold=0;
DWORD           g_EsentMaxVerPages=0;

//
//  Reissuance Parameters
//

DWORD g_dwReissueLeaseMinimum;
DWORD g_dwReissueLeaseRange;
DWORD g_dwReissueLeaseLeeway;
DWORD g_dwReissueExpireThreadSleep;

//
// Counters
//

LONG g_lTemporaryLicensesIssued = 0;
LONG g_lPermanentLicensesIssued = 0;
LONG g_lPermanentLicensesReissued = 0;
LONG g_lPermanentLicensesReturned = 0;
LONG g_lLicensesMarked = 0;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\license\tlserver\server\gencert.cpp ===
//+--------------------------------------------------------------------------
//
// Copyright (c) 1997-1999 Microsoft Corporation
//
// File:        gencert.cpp
//
// Contents:    
//
// History:     
//
//---------------------------------------------------------------------------
#include "pch.cpp"
#include "misc.h"
#include "utils.h"
#include "gencert.h"
#include "globals.h"

#ifndef UNICODE

    const DWORD dwCertRdnValueType = CERT_RDN_PRINTABLE_STRING;
    
#else

    const DWORD dwCertRdnValueType = CERT_RDN_UNICODE_STRING;

#endif


#ifndef CertStrToName

//
// Function prototype not found in wincrypt.h or anywhere but
// is in crypt32.lib
//

#ifdef __cplusplus
extern "C" {
#endif

    BOOL WINAPI 
    CertStrToNameA(  
        DWORD dwCertEncodingType,   // in
        LPCSTR pszX500,            // in  
        DWORD dwStrType,            // in
        void* pvReserved,           // in, optional
        BYTE* pbEncoded,            // out  
        DWORD* pcbEncoded,         // in/out
        LPCSTR* ppszError          // out, optional
    );

    CertStrToNameW(  
        DWORD dwCertEncodingType,   // in
        LPCWSTR pszX500,            // in  
        DWORD dwStrType,            // in
        void* pvReserved,           // in, optional
        BYTE* pbEncoded,            // out  
        DWORD* pcbEncoded,         // in/out
        LPCWSTR* ppszError          // out, optional
    );

    #ifdef UNICODE
    #define CertStrToName CertStrToNameW
    #else
    #define CertStrToName CertStrToNameA
    #endif

#ifdef __cplusplus
}
#endif

#endif


/*******************************************************************************************
Function:
    LSEncryptBase64EncodeHWID()

Description:
    Encrypt using license server private key then base64 encode the hardware ID

Arguments:
    IN PHWID - pointer to HWID to be encrypt/encoded
    OUT DWORD* cbBase64EncodeHwid - size of pointer to encrypted/encoded string
    OUT PBYTE* szBase64EncodeHwid - Pointer to encrypted/encoded string.

Returns:
    TRUE if successful, FALSE otherwise, call GetLastError() for detail.
*******************************************************************************************/
BOOL 
TLSEncryptBase64EncodeHWID(
    PHWID pHwid, 
    DWORD* cbBase64EncodeHwid, 
    PBYTE* szBase64EncodeHwid
    )
{
    DWORD status=ERROR_SUCCESS;

    //
    // Encrypt HWID
    //
    BYTE tmp_pbEncryptedHwid[sizeof(HWID)*2+2];
    DWORD tmp_cbEncryptedHwid=sizeof(tmp_pbEncryptedHwid);

    do {
        memset(tmp_pbEncryptedHwid, 0, sizeof(tmp_pbEncryptedHwid));
        if((status=LicenseEncryptHwid(
                        pHwid,
                        &tmp_cbEncryptedHwid, 
                        tmp_pbEncryptedHwid, 
                        g_cbSecretKey,
                        g_pbSecretKey) != LICENSE_STATUS_OK))
        {
            break;
        }


        //
        // BASE64 Encode Encrypted HWID - printable char. string
        //
        if((status=LSBase64Encode(
                        tmp_pbEncryptedHwid, 
                        tmp_cbEncryptedHwid, 
                        NULL, 
                        cbBase64EncodeHwid)) != ERROR_SUCCESS)
        {
            break;
        }

        *szBase64EncodeHwid=(PBYTE)AllocateMemory(*cbBase64EncodeHwid*(sizeof(TCHAR)+1));
        if(*szBase64EncodeHwid == NULL)
        {
            SetLastError(status = ERROR_OUTOFMEMORY);
            break;
        }

        // base64 encoding
        status=LSBase64Encode(
                    tmp_pbEncryptedHwid, 
                    tmp_cbEncryptedHwid, 
                    (TCHAR *)*szBase64EncodeHwid, 
                    cbBase64EncodeHwid);
    } while(FALSE);

    return status == ERROR_SUCCESS;
}

/*******************************************************************************************/

DWORD
TLSAddCertAuthorityInfoAccess(
    LPTSTR szIssuerDnsName, 
    PCERT_EXTENSION pExtension
    )
/*
*/
{
    LSCERT_AUTHORITY_INFO_ACCESS certInfoAccess;
    LSCERT_ACCESS_DESCRIPTION certAcccessDesc;

    certAcccessDesc.pszAccessMethod=szOID_X509_ACCESS_PKIX_OCSP;
    certAcccessDesc.AccessLocation.dwAltNameChoice = LSCERT_ALT_NAME_DNS_NAME;
    certAcccessDesc.AccessLocation.pwszDNSName = szIssuerDnsName;

    certInfoAccess.cAccDescr = 1;
    certInfoAccess.rgAccDescr = &certAcccessDesc;

    pExtension->pszObjId = szOID_X509_AUTHORITY_ACCESS_INFO;
    pExtension->fCritical = TRUE;

    return TLSCryptEncodeObject(
                    X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
                    szOID_X509_AUTHORITY_ACCESS_INFO, 
                    &certInfoAccess, 
                    &pExtension->Value.pbData,
                    &pExtension->Value.cbData
                );
}

///////////////////////////////////////////////////////////////////////////////

DWORD
TLSAddCertAuthorityKeyIdExtension(
    LPTSTR           szIssuer,
    ULARGE_INTEGER*  CertSerialNumber, 
    PCERT_EXTENSION  pExtension
    )
/*
*/
{
    //
    // Use CERT_AUTHORITY_KEY_ID2_INFO
    // some structure not defined in SP3's wincrypt.h
    //
    LSCERT_ALT_NAME_ENTRY certAltNameEntry;
    LSCERT_AUTHORITY_KEY_ID2_INFO authKeyId2Info;

    memset(&authKeyId2Info, 0, sizeof(authKeyId2Info));
    authKeyId2Info.AuthorityCertSerialNumber.cbData = sizeof(ULARGE_INTEGER);
    authKeyId2Info.AuthorityCertSerialNumber.pbData = (PBYTE)CertSerialNumber;


    memset(&certAltNameEntry, 0, sizeof(certAltNameEntry));
    certAltNameEntry.dwAltNameChoice=CERT_ALT_NAME_DIRECTORY_NAME; //LSCERT_ALT_NAME_RFC822_NAME;
    certAltNameEntry.DirectoryName.cbData = (_tcslen(szIssuer) + 1) * sizeof(TCHAR);
    certAltNameEntry.DirectoryName.pbData = (PBYTE)szIssuer;

    authKeyId2Info.AuthorityCertIssuer.cAltEntry=1;
    authKeyId2Info.AuthorityCertIssuer.rgAltEntry=&certAltNameEntry; 
  
    pExtension->pszObjId = szOID_X509_AUTHORITY_KEY_ID2;
    pExtension->fCritical = TRUE;
    
    return TLSCryptEncodeObject(
                        X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
                        szOID_X509_AUTHORITY_KEY_ID2, 
                        &authKeyId2Info, 
                        &pExtension->Value.pbData,
                        &pExtension->Value.cbData
                    );
}

///////////////////////////////////////////////////////////////////////////////

DWORD
TLSExportPublicKey(
    IN HCRYPTPROV hCryptProv,
    IN DWORD      dwKeyType,
    IN OUT PDWORD pcbByte,
    IN OUT PCERT_PUBLIC_KEY_INFO  *ppbByte
    )
/*

*/
{
    BOOL bRetCode=TRUE;

    *pcbByte=0;
    *ppbByte=NULL;

    bRetCode = CryptExportPublicKeyInfo(
                    hCryptProv, 
                    dwKeyType, 
                    X509_ASN_ENCODING, 
                    NULL, 
                    pcbByte);
    if(bRetCode == FALSE)
        goto cleanup;
    
    if((*ppbByte=(PCERT_PUBLIC_KEY_INFO)AllocateMemory(*pcbByte)) == NULL)
    {   
        bRetCode = FALSE;
        goto cleanup;
    }

    bRetCode = CryptExportPublicKeyInfo(
                    hCryptProv, 
                    dwKeyType,
                    X509_ASN_ENCODING, 
                    *ppbByte, 
                    pcbByte);
    if(bRetCode == FALSE)
    {
        FreeMemory(*ppbByte);
        *pcbByte = 0;
    }

cleanup:

    return (bRetCode) ? ERROR_SUCCESS : GetLastError();
}

///////////////////////////////////////////////////////////////////////////////

DWORD 
TLSCryptEncodeObject(  
    IN  DWORD   dwEncodingType,
    IN  LPCSTR  lpszStructType,
    IN  const void * pvStructInfo,
    OUT PBYTE*  ppbEncoded,
    OUT DWORD*  pcbEncoded
    )
/*

Description:
    
    Allocate memory and encode object, wrapper for CryptEncodeObject()

*/
{
    DWORD dwStatus = ERROR_SUCCESS;

    if(!CryptEncodeObject(dwEncodingType, lpszStructType, pvStructInfo, NULL, pcbEncoded) ||
       (*ppbEncoded=(PBYTE)AllocateMemory(*pcbEncoded)) == NULL ||
       !CryptEncodeObject(dwEncodingType, lpszStructType, pvStructInfo, *ppbEncoded, pcbEncoded))
    {
        dwStatus=GetLastError();
    }

    return dwStatus;
}

//////////////////////////////////////////////////////////////////////

DWORD
TLSCryptSignAndEncodeCertificate(
    IN HCRYPTPROV  hCryptProv,
    IN DWORD dwKeySpec,
    IN PCERT_INFO pCertInfo,
    IN PCRYPT_ALGORITHM_IDENTIFIER pSignatureAlgorithm,
    IN OUT PBYTE* ppbEncodedCert,
    IN OUT PDWORD pcbEncodedCert
    )
/*

*/
{
    BOOL bRetCode;

    bRetCode = CryptSignAndEncodeCertificate(  
                    hCryptProv,
                    dwKeySpec,
                    X509_ASN_ENCODING,
                    X509_CERT_TO_BE_SIGNED,
                    pCertInfo,
                    pSignatureAlgorithm,
                    NULL,
                    NULL,
                    pcbEncodedCert);

    if(bRetCode == FALSE && GetLastError() != ERROR_MORE_DATA)
        goto cleanup;

    *ppbEncodedCert=(PBYTE)AllocateMemory(*pcbEncodedCert);
    if(*ppbEncodedCert == FALSE)
        goto cleanup;

    bRetCode = CryptSignAndEncodeCertificate(  
                    hCryptProv,
                    AT_SIGNATURE,
                    X509_ASN_ENCODING,
                    X509_CERT_TO_BE_SIGNED,
                    pCertInfo,
                    pSignatureAlgorithm,
                    NULL,
                    *ppbEncodedCert,
                    pcbEncodedCert);

    if(bRetCode == FALSE)
    {
        FreeMemory(*ppbEncodedCert);
        *pcbEncodedCert = 0;
    }

cleanup:

    return (bRetCode) ? ERROR_SUCCESS : GetLastError();
}

////////////////////////////////////////////////////////////////////////

#define MAX_NUM_CERT_BLOBS 200  // actually, we can't go over 10.


DWORD
TLSVerifyProprietyChainedCertificate(
    HCRYPTPROV  hCryptProv, 
    PBYTE       pbCert, 
    DWORD       cbCert
    )
/*++

--*/
{
    DWORD dwStatus=ERROR_SUCCESS, cbRequired = 0;
    PCert_Chain pCertChain = (PCert_Chain)pbCert;
    UNALIGNED Cert_Blob *pCertificate = NULL;
    PCCERT_CONTEXT pIssuerCert = NULL;
    PCCERT_CONTEXT pSubjectCert = NULL; 

    DWORD dwVerifyFlag = CERT_DATE_DONT_VALIDATE;
    int i;

    cbRequired = 2 * sizeof(DWORD);

    if( pCertChain == NULL || ( cbCert < cbRequired ) ||
        MAX_CERT_CHAIN_VERSION < GET_CERTIFICATE_VERSION(pCertChain->dwVersion) ||
        pCertChain->dwNumCertBlobs > MAX_NUM_CERT_BLOBS ||
        pCertChain->dwNumCertBlobs <= 1 )   // must have at least two certificates
    {
        SetLastError(dwStatus = TLS_E_INVALID_DATA);
        return dwStatus;
    }
    
    //
    // Verify input data before actually allocate memory
    //
    pCertificate = (PCert_Blob)&(pCertChain->CertBlob[0]);
    for(i=0; i < pCertChain->dwNumCertBlobs; i++)
    {
        cbRequired += (sizeof (DWORD)+ sizeof(BYTE)) ;

        if(cbCert < cbRequired )
        {
            SetLastError(dwStatus = TLS_E_INVALID_DATA);
            return dwStatus;
        }

        if (((PBYTE)pCertificate > (cbCert + pbCert - sizeof(Cert_Blob))) || 
            (pCertificate->cbCert == 0) ||
            (pCertificate->cbCert > (DWORD)((pbCert + cbCert) - pCertificate->abCert)))
        {
            return (LICENSE_STATUS_INVALID_INPUT);
        }

        pCertificate = (PCert_Blob)(pCertificate->abCert + pCertificate->cbCert);
    }

    //
    // First certificate is root certificate
    //
    pCertificate = (PCert_Blob)&(pCertChain->CertBlob[0]);
    pIssuerCert = CertCreateCertificateContext(
                                        X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
                                        &(pCertificate->abCert[0]),
                                        pCertificate->cbCert
                                    );
    if(pIssuerCert == NULL)
    {
        dwStatus = GetLastError();  // just for debugging.
        goto cleanup;
    }

    dwStatus = ERROR_SUCCESS;
    pSubjectCert = CertDuplicateCertificateContext(pIssuerCert);

    for(i=0; i < pCertChain->dwNumCertBlobs; i++)
    {
        if(pSubjectCert == NULL)
        {
            dwStatus = GetLastError();
            break;
        }

        //
        // verify subject's certificate
        dwVerifyFlag = CERT_STORE_SIGNATURE_FLAG;
        if(CertVerifySubjectCertificateContext(
                                        pSubjectCert,
                                        pIssuerCert,
                                        &dwVerifyFlag
                                    ) == FALSE)
        {
            dwStatus = GetLastError();
            break;
        }            

        if(dwVerifyFlag != 0)
        {
            // signature verification failed.
            dwStatus = TLS_E_INVALID_DATA;
            break;
        }

        if(CertFreeCertificateContext(pIssuerCert) == FALSE)
        {
            dwStatus = GetLastError();
            break;
        }

        pIssuerCert = pSubjectCert;

        pCertificate = (PCert_Blob)(pCertificate->abCert + pCertificate->cbCert);

        pSubjectCert = CertCreateCertificateContext(
                                        X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
                                        &(pCertificate->abCert[0]),
                                        pCertificate->cbCert
                                    );
    }
            
cleanup:

    if(pSubjectCert != NULL)
    {
        CertFreeCertificateContext(pSubjectCert);
    }

    if(pIssuerCert != NULL)
    {
        CertFreeCertificateContext(pIssuerCert);
    }

    return dwStatus;
}

////////////////////////////////////////////////////////////////////////

BOOL IsHydraClientCertficate( PCERT_INFO pCertInfo )
{
    CERT_EXTENSION UNALIGNED * pCertExtension=pCertInfo->rgExtension;
    DWORD dwVersion = TERMSERV_CERT_VERSION_UNKNOWN;
    DWORD UNALIGNED * pdwVersion;

    for(DWORD i=0; i < pCertInfo->cExtension; i++, pCertExtension++)
    {
        if(strcmp(pCertExtension->pszObjId, szOID_PKIX_HYDRA_CERT_VERSION) == 0)
        {
            pdwVersion = (DWORD UNALIGNED *) pCertExtension->Value.pbData;

            if(pCertExtension->Value.cbData == sizeof(DWORD) &&
               *pdwVersion <= TERMSERV_CERT_VERSION_CURRENT)
            {
                dwVersion = *pdwVersion;
                break;
            }
        }
    }

    return (dwVersion == TERMSERV_CERT_VERSION_UNKNOWN) ? FALSE : TRUE;
}

////////////////////////////////////////////////////////////////////////

DWORD
ChainProprietyCert(
        HCRYPTPROV      hCryptProv,
        HCERTSTORE      hCertStore, 
        PCCERT_CONTEXT  pCertContext, 
        PCert_Chain     pCertChain,
        DWORD*          dwCertOffset,
        DWORD           dwBufSize)
{
    DWORD       dwStatus = ERROR_SUCCESS;
    DWORD       dwFlags;
    PCCERT_CONTEXT pCertIssuer=NULL;

    pCertIssuer=NULL;
    dwFlags = CERT_STORE_SIGNATURE_FLAG;


    //
    // Get the issuer's certificate from store
    //
    pCertIssuer = CertGetIssuerCertificateFromStore(
                                                hCertStore,
                                                pCertContext,
                                                pCertIssuer,
                                                &dwFlags
                                            );

    if(pCertIssuer != NULL)
    {
        if(dwFlags & CERT_STORE_SIGNATURE_FLAG)
        {
            // invalid signature
            dwStatus = TLS_E_INVALID_DATA;
        }
        else
        {
            //
            // Recursively find the issuer of the issuer's certificate
            //
            dwStatus = ChainProprietyCert(
                                    hCryptProv, 
                                    hCertStore, 
                                    pCertIssuer, 
                                    pCertChain, 
                                    dwCertOffset, 
                                    dwBufSize
                                );
        }
    }
    else 
    {
        dwStatus = GetLastError();
        if(dwStatus != CRYPT_E_SELF_SIGNED)
        {
            goto cleanup;
        }

        //
        // Verify issuer's certificate
        //
        if(CryptVerifyCertificateSignature(
                                   hCryptProv,
                                   X509_ASN_ENCODING,
                                   pCertContext->pbCertEncoded,
                                   pCertContext->cbCertEncoded,
                                   &pCertContext->pCertInfo->SubjectPublicKeyInfo))
        {
            dwStatus=ERROR_SUCCESS;
        }
    }

    if(dwStatus == ERROR_SUCCESS)
    {
        //
        // Push certificate into propriety certificate chain
        //
        if((*dwCertOffset + pCertContext->cbCertEncoded) >= dwBufSize)
        {
            dwStatus = ERROR_MORE_DATA;
            goto cleanup;
        }

        (pCertChain->dwNumCertBlobs)++;

        UNALIGNED Cert_Blob *pCertBlob = (PCert_Blob)((PBYTE)&(pCertChain->CertBlob) + *dwCertOffset);
        pCertBlob->cbCert = pCertContext->cbCertEncoded;
        memcpy( &(pCertBlob->abCert),
                pCertContext->pbCertEncoded,
                pCertContext->cbCertEncoded);

        *dwCertOffset += (sizeof(pCertBlob->cbCert) + pCertContext->cbCertEncoded);
    }

cleanup:

    if(pCertIssuer != NULL)
    {
        CertFreeCertificateContext(pCertIssuer);
    }

    return dwStatus;
}

////////////////////////////////////////////////////////////////////////


DWORD 
TLSChainProprietyCertificate(
    HCRYPTPROV  hCryptProv,
    BOOL        bTemp,
    PBYTE       pbLicense, 
    DWORD       cbLicense, 
    PBYTE*      pbChained, 
    DWORD*      cbChained
    )
{
    HCERTSTORE      hCertStore=NULL;
    DWORD           dwStatus=ERROR_SUCCESS;
    CRYPT_DATA_BLOB Serialized;
    PCCERT_CONTEXT  pCertContext=NULL;
    PCCERT_CONTEXT  pPrevCertContext=NULL;
    PCERT_INFO      pCertInfo;
    BOOL            bFound=FALSE;
    
    Serialized.pbData = pbLicense;
    Serialized.cbData = cbLicense;

    DWORD dwCertOffset = 0;
    PCert_Chain pCertChain;

    DWORD numCerts=0;
    DWORD cbSize=0;

    if(hCryptProv == NULL)
    {
        SetLastError(dwStatus = ERROR_INVALID_PARAMETER);
        goto cleanup;
    }

    hCertStore=CertOpenStore(
                        sz_CERT_STORE_PROV_PKCS7,
                        X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
                        hCryptProv,
                        CERT_STORE_NO_CRYPT_RELEASE_FLAG,
                        &Serialized
                    );

    if(!hCertStore)
    {
        dwStatus=GetLastError();
        goto cleanup;
    }

    //
    // Get number of certificate and estimated size first - save memory
    //
    do {
        pCertContext = CertEnumCertificatesInStore(
                                                hCertStore, 
                                                pPrevCertContext
                                            );
        if(pCertContext == NULL)
        {
            dwStatus = GetLastError();
            if(dwStatus != CRYPT_E_NOT_FOUND)
                goto cleanup;

            dwStatus = ERROR_SUCCESS;
            break;
        }

        numCerts++;
        cbSize += pCertContext->cbCertEncoded;
        pPrevCertContext = pCertContext;

    } while(TRUE);


    *cbChained = cbSize + numCerts * sizeof(Cert_Blob) + sizeof(Cert_Chain);

    //
    // Allocate memory for our propriety certificate chain
    //
    pCertChain=(PCert_Chain)LocalAlloc(LPTR, *cbChained);
    if(pCertChain == NULL)
    {
        dwStatus = GetLastError();
        goto cleanup;
    }

    pCertChain->dwVersion = CERT_CHAIN_VERSION_2 | ((bTemp) ? 0x80000000 : 0);

    //
    // Enumerate license in certificate to find actual client license.
    //
    pPrevCertContext = NULL;
    do {
        pCertContext=CertEnumCertificatesInStore(hCertStore, pPrevCertContext);
        if(pCertContext == NULL)
        {
            // end certificate in store or error
            if((dwStatus=GetLastError()) != CRYPT_E_NOT_FOUND)
                goto cleanup;

            dwStatus = ERROR_SUCCESS;
            break;
        }

        pPrevCertContext = pCertContext;

        if(IsHydraClientCertficate(pCertContext->pCertInfo))     
        {       
            bFound = TRUE;
        }
    } while(bFound == FALSE);

    if(bFound == FALSE)
    {
        dwStatus = ERROR_INVALID_PARAMETER;
        goto cleanup;
    }
   
    //
    // Recusively chain certificate in backward.
    //    
    dwStatus = ChainProprietyCert(
                        hCryptProv, 
                        hCertStore, 
                        pCertContext, 
                        pCertChain, 
                        &dwCertOffset,
                        *cbChained);
    
    *pbChained = (PBYTE)pCertChain;

cleanup:

    if(hCertStore)
        CertCloseStore(hCertStore, CERT_CLOSE_STORE_FORCE_FLAG);
       
    return dwStatus;
}

///////////////////////////////////////////////////////////////////////////////

DWORD
TLSCertSetCertRdnStr(
    IN OUT CERT_NAME_BLOB* pCertNameBlob,
    IN LPTSTR          szRdn
    )
/*

Abstract:

    Add RDN into certificate

Parameter:

    pCertNameBlob -
    szRdn - RDN to be added, see CertStrToName() for help

Returns:

    ERROR_INVALID_PARAMETER
    Memory allocation failed.
    Error returns from CertStrToName()
    
*/
{
    if(pCertNameBlob == NULL)
        return ERROR_INVALID_PARAMETER;

    BOOL bRetCode=TRUE;

    bRetCode = CertStrToName(
                    X509_ASN_ENCODING,
                    szRdn,
                    CERT_X500_NAME_STR | CERT_SIMPLE_NAME_STR,
                    NULL,
                    pCertNameBlob->pbData,
                    &pCertNameBlob->cbData,
                    NULL
                );

    if(bRetCode != TRUE)
        goto cleanup;

    pCertNameBlob->pbData = (PBYTE)AllocateMemory(pCertNameBlob->cbData);
    if(pCertNameBlob->pbData == NULL)
        goto cleanup;

    bRetCode = CertStrToName(
                    X509_ASN_ENCODING,
                    szRdn,
                    CERT_X500_NAME_STR | CERT_SIMPLE_NAME_STR,
                    NULL,
                    pCertNameBlob->pbData,
                    &pCertNameBlob->cbData,
                    NULL
                );

cleanup:

    return (bRetCode) ? ERROR_SUCCESS : GetLastError();
}

///////////////////////////////////////////////////////////////////////////////

DWORD 
TLSCertSetCertRdnName(
    IN OUT CERT_NAME_BLOB* pCertNameBlob, 
    IN CERT_NAME_INFO* pRdn
    )
/*

Abstract:

    Add RDN into certificate

Parameters:

    pCertNameBlob -
    pRdn -

Returns

    ERROR_INVALID_PARAMETER
    Error code from CryptEncodeObject()
    Memory allocation fail.    

*/
{
    if(pCertNameBlob == NULL || pRdn == NULL)
        return ERROR_INVALID_PARAMETER;

    //
    // CertStrToName() not defined in SP3 build environment
    //
    return TLSCryptEncodeObject( 
                    CRYPT_ASN_ENCODING, 
                    X509_NAME, 
                    pRdn, 
                    &pCertNameBlob->pbData, 
                    &pCertNameBlob->cbData
                );
}

//////////////////////////////////////////////////////////////////////////
DWORD
TLSSetCertRdn(
    PCERT_NAME_BLOB pCertNameBlob,
    PTLSClientCertRDN pLsCertRdn
    )
/*
*/
{  
    DWORD dwStatus=ERROR_SUCCESS;

    switch(pLsCertRdn->type)
    {
        case LSCERT_RDN_STRING_TYPE:
            dwStatus = TLSCertSetCertRdnStr(
                                pCertNameBlob,
                                pLsCertRdn->szRdn
                            );
            break;

        case LSCERT_RDN_NAME_INFO_TYPE:
            dwStatus = TLSCertSetCertRdnName(
                                pCertNameBlob,
                                pLsCertRdn->pCertNameInfo
                            );

            break;

        case LSCERT_RDN_NAME_BLOB_TYPE:
            *pCertNameBlob = *pLsCertRdn->pNameBlob;
            break;

        case LSCERT_CLIENT_INFO_TYPE:
            {
                PBYTE szBase64EncodeHwid=NULL;
                DWORD cbBase64EncodeHwid=0;
    
                if(!TLSEncryptBase64EncodeHWID(
                                pLsCertRdn->ClientInfo.pClientID, 
                                &cbBase64EncodeHwid, 
                                &szBase64EncodeHwid))
                {
                    TLSLogEvent(
                            EVENTLOG_ERROR_TYPE, 
                            TLS_E_GENERATECLIENTELICENSE,
                            dwStatus=TLS_E_ENCRYPTHWID, 
                            GetLastError()
                        );

                    break;
                }

                CERT_RDN_ATTR rgNameAttr[] = { 
                    {   
                        OID_SUBJECT_CLIENT_COMPUTERNAME, 
                        dwCertRdnValueType, 
                        _tcslen(pLsCertRdn->ClientInfo.szMachineName) * sizeof(TCHAR), 
                        (UCHAR *)pLsCertRdn->ClientInfo.szMachineName
                    },
                    {
                        OID_SUBJECT_CLIENT_USERNAME, 
                        dwCertRdnValueType, 
                        _tcslen(pLsCertRdn->ClientInfo.szUserName) * sizeof(TCHAR), 
                        (UCHAR *)pLsCertRdn->ClientInfo.szUserName
                    },
                    {
                        OID_SUBJECT_CLIENT_HWID, 
                        dwCertRdnValueType, 
                        cbBase64EncodeHwid*sizeof(TCHAR), 
                        (UCHAR *)szBase64EncodeHwid
                    }
                };
                                
                CERT_RDN rgRDN[] = { 
                    sizeof(rgNameAttr)/sizeof(rgNameAttr[0]), 
                    &rgNameAttr[0] 
                };

                CERT_NAME_INFO Name = {1, rgRDN};

                dwStatus = TLSCertSetCertRdnName(
                                        pCertNameBlob,
                                        &Name
                                    );

                FreeMemory(szBase64EncodeHwid);
            }
            break;

        default:

            dwStatus = ERROR_INVALID_PARAMETER;
    }

    return dwStatus;
}
                      

//////////////////////////////////////////////////////////////////////////

DWORD 
TLSGenerateCertificate(
    HCRYPTPROV         hCryptProv,
    DWORD              dwKeySpec,
    ULARGE_INTEGER*    pCertSerialNumber,
    PTLSClientCertRDN   pCertIssuer,
    PTLSClientCertRDN   pCertSubject, 
    FILETIME*          ftNotBefore,
    FILETIME*          ftNotAfter,
    PCERT_PUBLIC_KEY_INFO pSubjectPublicKey,
    DWORD              dwNumExtensions,
    PCERT_EXTENSION    pCertExtensions,
    PDWORD             pcbEncodedCert,
    PBYTE*             ppbEncodedCert
    )
/*

*/
{
    DWORD dwStatus=ERROR_SUCCESS;
    CRYPT_ALGORITHM_IDENTIFIER SignatureAlgorithm={ szOID_OIWSEC_sha1RSASign, 0, 0 };
    CERT_INFO CertInfo;
    PCERT_PUBLIC_KEY_INFO pbPublicKeyInfo=NULL;
    DWORD cbPublicKeyInfo=0;


    memset(&CertInfo, 0, sizeof(CERT_INFO));
    
    CertInfo.dwVersion = CERT_V3;
    CertInfo.SerialNumber.cbData = sizeof(*pCertSerialNumber);
    CertInfo.SerialNumber.pbData = (PBYTE)pCertSerialNumber;
    
    CertInfo.SignatureAlgorithm = SignatureAlgorithm;

    dwStatus = TLSSetCertRdn(
                        &CertInfo.Issuer,
                        pCertIssuer
                    );

    if(dwStatus != ERROR_SUCCESS)
    {
        TLSLogEvent(
                EVENTLOG_ERROR_TYPE, 
                TLS_E_GENERATECLIENTELICENSE, 
                TLS_E_SETCERTISSUER, 
                dwStatus
            );
        goto cleanup;
    }

    CertInfo.NotBefore = *ftNotBefore;
    CertInfo.NotAfter = *ftNotAfter;

    dwStatus = TLSSetCertRdn(
                        &CertInfo.Subject,
                        pCertSubject
                    );
    if(dwStatus != ERROR_SUCCESS)
    {
        TLSLogEvent(
                EVENTLOG_ERROR_TYPE, 
                TLS_E_GENERATECLIENTELICENSE, 
                TLS_E_SETCERTSUBJECT, 
                dwStatus
            );
        goto cleanup;
    }

    if(pSubjectPublicKey)
    {
        CertInfo.SubjectPublicKeyInfo = *pSubjectPublicKey;
    }
    else
    {
        dwStatus = TLSExportPublicKey(
                            hCryptProv,
                            dwKeySpec,
                            &cbPublicKeyInfo,
                            &pbPublicKeyInfo
                        );

        if(dwStatus != ERROR_SUCCESS)
        {
            TLSLogEvent(
                    EVENTLOG_ERROR_TYPE, 
                    TLS_E_GENERATECLIENTELICENSE, 
                    TLS_E_EXPORT_KEY, 
                    dwStatus
                );
            goto cleanup;
        }

        CertInfo.SubjectPublicKeyInfo = *pbPublicKeyInfo;
    }
    
    CertInfo.cExtension = dwNumExtensions;
    CertInfo.rgExtension = pCertExtensions;

    dwStatus = TLSCryptSignAndEncodeCertificate(
                            hCryptProv,
                            dwKeySpec,
                            &CertInfo,
                            &SignatureAlgorithm,
                            ppbEncodedCert,
                            pcbEncodedCert
                        );

    if(dwStatus != ERROR_SUCCESS)
    {
        TLSLogEvent(
                EVENTLOG_ERROR_TYPE, 
                TLS_E_GENERATECLIENTELICENSE, 
                TLS_E_SIGNENCODECERT, 
                dwStatus
            );
    }

cleanup:

    if(pbPublicKeyInfo)
    {
        FreeMemory(pbPublicKeyInfo);
    }       

    if(pCertIssuer->type != LSCERT_RDN_NAME_BLOB_TYPE)
    {
        FreeMemory(CertInfo.Issuer.pbData);
    }

    if(pCertSubject->type != LSCERT_RDN_NAME_BLOB_TYPE)
    {
        FreeMemory(CertInfo.Subject.pbData);
    } 
    return dwStatus;
}

//////////////////////////////////////////////////////////////////////

DWORD 
TLSCreateSelfSignCertificate(
    IN HCRYPTPROV hCryptProv,
    IN DWORD dwKeySpec, 
    IN PBYTE pbSPK,
    IN DWORD cbSPK,
    IN DWORD dwNumExtensions,
    IN PCERT_EXTENSION pCertExtension,
    OUT PDWORD cbEncoded, 
    OUT PBYTE* pbEncoded
)
/*

*/
{
    DWORD dwStatus=ERROR_SUCCESS;
    DWORD index;

#define MAX_EXTENSIONS_IN_SELFSIGN 40

    SYSTEMTIME      sysTime;
    FILETIME        ftTime;
    CERT_EXTENSION  rgExtension[MAX_EXTENSIONS_IN_SELFSIGN];
    int             iExtCount=0, iExtNotFreeCount=0;
    FILETIME        ftNotBefore;
    FILETIME        ftNotAfter;
    ULARGE_INTEGER  ulSerialNumber;
    TLSClientCertRDN certRdn;
    
    CERT_BASIC_CONSTRAINTS2_INFO basicConstraint;

    // modify here is we want to set to different issuer name
    LPTSTR szIssuerName;
    szIssuerName = g_szComputerName;

    //static LPTSTR pszEnforce=L"Enforce";


    CERT_RDN_ATTR rgNameAttr[] = { 
        {   
            szOID_COMMON_NAME, 
            dwCertRdnValueType, 
            _tcslen(szIssuerName) * sizeof(TCHAR), 
            (UCHAR *)szIssuerName 
        },

//#if ENFORCE_LICENSING
//        {
//            szOID_BUSINESS_CATEGORY,
//            dwCertRdnValueType,
//            _tcslen(pszEnforce) * sizeof(TCHAR),
//            (UCHAR *)pszEnforce
//        },
//#endif       

        {
            szOID_LOCALITY_NAME, 
            dwCertRdnValueType, 
            _tcslen(g_pszScope) * sizeof(TCHAR), 
            (UCHAR *)g_pszScope
        }

    };
                                    
    CERT_RDN rgRDN[] = { sizeof(rgNameAttr)/sizeof(rgNameAttr[0]), &rgNameAttr[0] };
    CERT_NAME_INFO Name = {1, rgRDN};

    certRdn.type = LSCERT_RDN_NAME_INFO_TYPE;
    certRdn.pCertNameInfo = &Name;

    memset(rgExtension, 0, sizeof(rgExtension));

    //
    // Set validity of self sign certificate
    //

    //
    // If system time is not in sync, this will cause server
    // can't request cert. from license server
    //

    memset(&sysTime, 0, sizeof(sysTime));
    GetSystemTime(&sysTime);
    sysTime.wYear = 1970;
    if(TLSSystemTimeToFileTime(&sysTime, &ftNotBefore) == FALSE)
    {
        dwStatus = GetLastError();
        goto cleanup;
    }

    //
    // draft-ietf-pkix-ipki-part1-06.txt section 4.1.2.5.1
    //  where year is greater or equal to 50, the year shall be interpreted as 19YY; and
    //  where year is less than 50, the year shall be interpreted as 20YY
    //
    sysTime.wYear = PERMANENT_CERT_EXPIRE_DATE; 
    if(TLSSystemTimeToFileTime(&sysTime, &ftNotAfter) == FALSE)
    {
        dwStatus = GetLastError();
        goto cleanup;
    }

    ulSerialNumber.LowPart = ftNotBefore.dwLowDateTime;
    ulSerialNumber.HighPart = ftNotBefore.dwHighDateTime;

    //
    // Add basic constrains extension to indicate this is a CA certificate
    //
    rgExtension[iExtCount].pszObjId = szOID_BASIC_CONSTRAINTS2;
    rgExtension[iExtCount].fCritical = FALSE;

    basicConstraint.fCA = TRUE;     // act as CA
    basicConstraint.fPathLenConstraint = TRUE;
    basicConstraint.dwPathLenConstraint = 0; // can only issue certificates 
                                             // to end-entities and not to further CAs
    dwStatus=TLSCryptEncodeObject( 
                        X509_ASN_ENCODING,
                        szOID_BASIC_CONSTRAINTS2,
                        &basicConstraint,
                        &(rgExtension[iExtCount].Value.pbData),
                        &(rgExtension[iExtCount].Value.cbData)
                    );
    if(dwStatus != ERROR_SUCCESS)
    {
        TLSLogEvent(
                EVENTLOG_ERROR_TYPE, 
                TLS_E_GENERATECLIENTELICENSE,
                TLS_E_SIGNENCODECERT, 
                dwStatus
            );
        goto cleanup;
    }

    iExtCount++;


    //
    // From here - extension memory should not be free
    //
    if(pbSPK != NULL && cbSPK != 0)
    {
        rgExtension[iExtCount].pszObjId = szOID_PKIS_TLSERVER_SPK_OID;
        rgExtension[iExtCount].fCritical = FALSE;
        rgExtension[iExtCount].Value.pbData = pbSPK;
        rgExtension[iExtCount].Value.cbData = cbSPK;

        iExtNotFreeCount++;
        iExtCount++;
    }

    for(index = 0; 
        index < dwNumExtensions;
        index ++, iExtCount++, iExtNotFreeCount++ )
    {
        if (iExtCount >= MAX_EXTENSIONS_IN_SELFSIGN)
        {
            iExtCount--;
            dwStatus = ERROR_INVALID_PARAMETER;
            goto cleanup;
        }

        rgExtension[iExtCount] = pCertExtension[index];
    }        
        
    dwStatus = TLSGenerateCertificate(
                        hCryptProv,
                        dwKeySpec,
                        &ulSerialNumber,
                        &certRdn,
                        &certRdn,
                        &ftNotBefore,
                        &ftNotAfter,
                        NULL,
                        iExtCount,
                        rgExtension,
                        cbEncoded,
                        pbEncoded
                    );                      
cleanup:

    //
    // Don't free memory for SPK and extensions...
    //
    for(int i=0; i < iExtCount - iExtNotFreeCount; i++)
    {
        FreeMemory(rgExtension[i].Value.pbData);
    }

    return (dwStatus != ERROR_SUCCESS) ? TLS_E_CREATE_SELFSIGN_CERT : ERROR_SUCCESS;
}


////////////////////////////////////////////////////////////////////////////
DWORD
TLSGenerateSingleCertificate(
    IN HCRYPTPROV hCryptProv,
    IN PCERT_NAME_BLOB pIssuerRdn,
    IN PTLSClientCertRDN pSubjectRdn,
    IN PCERT_PUBLIC_KEY_INFO pSubjectPublicKeyInfo,
    IN PTLSDBLICENSEDPRODUCT pLicProduct,
    OUT PBYTE* ppbEncodedCert,
    IN PDWORD pcbEncodedCert
    )
/*

*/
{
    DWORD dwStatus = ERROR_SUCCESS;

    #define MAX_CLIENT_EXTENSION 10

    CERT_EXTENSION CertExtension[MAX_CLIENT_EXTENSION];
    DWORD dwNumExtensions=0;
    DWORD currentCertVersion=TERMSERV_CERT_VERSION_CURRENT;

    TLSClientCertRDN IssuerRdn;
    

#if ENFORCE_LICENSING

    //
    // Use certificate that CH gets for us
    //
    IssuerRdn.type = LSCERT_RDN_NAME_BLOB_TYPE;
    //IssuerRdn.pNameBlob = &g_LicenseCertContext->pCertInfo->Subject;
    IssuerRdn.pNameBlob = pIssuerRdn;

#else

    LPTSTR szIssuerName;

    // modify here if we want to set to different issuer name
    szIssuerName = g_szComputerName;

    CERT_RDN_ATTR rgNameAttr[] = { 
        {
            OID_ISSUER_LICENSE_SERVER_NAME, 
            dwCertRdnValueType, 
            _tcslen(szIssuerName) * sizeof(TCHAR), 
            (UCHAR *)szIssuerName 
        },
        {
            OID_ISSUER_LICENSE_SERVER_SCOPE, 
            dwCertRdnValueType, 
            _tcslen(g_pszScope) * sizeof(TCHAR), 
            (UCHAR *)g_pszScope
        }
    };
                                
    CERT_RDN rgRDN[] = { 
        sizeof(rgNameAttr)/sizeof(rgNameAttr[0]), 
        &rgNameAttr[0] 
    };
    CERT_NAME_INFO Name = {1, rgRDN};

    IssuerRdn.type = LSCERT_RDN_NAME_INFO_TYPE;
    IssuerRdn.pCertNameInfo = &Name;

#endif

    //------------------------------------------------------------------------------------------
    // add extension to certificate
    // WARNING : End of routine free memory allocated for extension's pbData, skip those
    //           that can't be free, for example, version stamp extension. all these is just 
    //           to keep memory fragmentaion low
    //------------------------------------------------------------------------------------------

    //
    // DO NOT FREE pbData on first two extensions
    //

    // Hydra Certificate version stamp - DO NOT FREE
    memset(CertExtension, 0, sizeof(CertExtension));
    dwNumExtensions = 0;

    //
    // Add License Server Info
    //
    CertExtension[dwNumExtensions].pszObjId = szOID_PKIX_HYDRA_CERT_VERSION;
    CertExtension[dwNumExtensions].fCritical = TRUE;
    CertExtension[dwNumExtensions].Value.cbData = sizeof(DWORD);
    CertExtension[dwNumExtensions].Value.pbData = (PBYTE)&currentCertVersion;
    dwNumExtensions++;

    // manufacturer's name, no encoding - DO NOT FREE
    CertExtension[dwNumExtensions].pszObjId = szOID_PKIX_MANUFACTURER;
    CertExtension[dwNumExtensions].fCritical = TRUE;
    CertExtension[dwNumExtensions].Value.cbData = (_tcslen(pLicProduct->szCompanyName)+1) * sizeof(TCHAR);
    CertExtension[dwNumExtensions].Value.pbData = (PBYTE)pLicProduct->szCompanyName;
    dwNumExtensions++;

    //
    // MS Licensed Product Info, no encoding
    //
    LICENSED_VERSION_INFO LicensedInfo;

    memset(&LicensedInfo, 0, sizeof(LicensedInfo));
    LicensedInfo.wMajorVersion = HIWORD(pLicProduct->dwProductVersion);
    LicensedInfo.wMinorVersion = LOWORD(pLicProduct->dwProductVersion);
    LicensedInfo.dwFlags = (pLicProduct->bTemp) ? LICENSED_VERSION_TEMPORARY : 0;

    DWORD dwLSVersionMajor;
    DWORD dwLSVersionMinor;

    dwLSVersionMajor = GET_SERVER_MAJOR_VERSION(TLS_CURRENT_VERSION);
    dwLSVersionMinor = GET_SERVER_MINOR_VERSION(TLS_CURRENT_VERSION);
    LicensedInfo.dwFlags |= ((dwLSVersionMajor << 4 | dwLSVersionMinor) << 16);

    if(TLSIsBetaNTServer() == FALSE)
    {
        LicensedInfo.dwFlags |= LICENSED_VERSION_RTM;
    }

#if ENFORCE_LICENSING
    LicensedInfo.dwFlags |= LICENSE_ISSUER_ENFORCE_TYPE;
#endif


    CertExtension[dwNumExtensions].pszObjId = szOID_PKIX_LICENSED_PRODUCT_INFO;
    CertExtension[dwNumExtensions].fCritical = TRUE;
    dwStatus=LSLicensedProductInfoToExtension(
                            1, 
                            pLicProduct->dwPlatformID,
                            pLicProduct->dwLanguageID,
                            (PBYTE)pLicProduct->szRequestProductId,
                            (_tcslen(pLicProduct->szRequestProductId) + 1) * sizeof(TCHAR),
                            (PBYTE)pLicProduct->szLicensedProductId,
                            (_tcslen(pLicProduct->szLicensedProductId) + 1) * sizeof(TCHAR),
                            &LicensedInfo, 
                            1,
                            &(CertExtension[dwNumExtensions].Value.pbData),
                            &(CertExtension[dwNumExtensions].Value.cbData)
                        );

    if(dwStatus != ERROR_SUCCESS)
        goto cleanup;

    dwNumExtensions++;        

    //
    // Add license server info into extension
    //
    CertExtension[dwNumExtensions].pszObjId = szOID_PKIX_MS_LICENSE_SERVER_INFO;
    CertExtension[dwNumExtensions].fCritical = TRUE;
    dwStatus=LSMsLicenseServerInfoToExtension(
                            g_szComputerName, 
                            (LPTSTR)g_pszServerPid,
                            g_pszScope,
                            &(CertExtension[dwNumExtensions].Value.pbData),
                            &(CertExtension[dwNumExtensions].Value.cbData)
                        ); 

    if(dwStatus != ERROR_SUCCESS)
        goto cleanup;

    dwNumExtensions++;

    //
    // Add policy module specific extension
    if( pLicProduct->pbPolicyData != NULL && pLicProduct->cbPolicyData != 0 )
    {
        CertExtension[dwNumExtensions].pszObjId = szOID_PKIS_PRODUCT_SPECIFIC_OID;
        CertExtension[dwNumExtensions].fCritical = TRUE;
        CertExtension[dwNumExtensions].Value.pbData = pLicProduct->pbPolicyData;
        CertExtension[dwNumExtensions].Value.cbData = pLicProduct->cbPolicyData;

        dwNumExtensions++;
    }

    //
    // Add CertAuthorityKeyId2Info for certificate chain
    dwStatus=TLSAddCertAuthorityKeyIdExtension(
                        g_szComputerName,
                        &pLicProduct->ulSerialNumber, 
                        CertExtension + dwNumExtensions
                    );
    if(dwStatus != ERROR_SUCCESS)
        goto cleanup;

    dwNumExtensions++;

    // Add Access info

    dwStatus = TLSGenerateCertificate(
                        hCryptProv,
                        AT_SIGNATURE,
                        &pLicProduct->ulSerialNumber,
                        &IssuerRdn,
                        pSubjectRdn,
                        &pLicProduct->NotBefore,
                        &pLicProduct->NotAfter,
                        pLicProduct->pSubjectPublicKeyInfo,
                        dwNumExtensions,
                        CertExtension,
                        pcbEncodedCert,
                        ppbEncodedCert
                    );                      

cleanup:

    // Extensions. DO NOT FREE first two extensions
    for(int i=2; i < dwNumExtensions; i++)
    {
        FreeMemory(CertExtension[i].Value.pbData);
    }
    
    return (dwStatus != ERROR_SUCCESS) ? TLS_E_CREATE_CERT : ERROR_SUCCESS;
}


////////////////////////////////////////////////////////////

DWORD
TLSGenerateClientCertificate(
    IN HCRYPTPROV hCryptProv,
    IN DWORD dwNumLicensedProduct,
    IN PTLSDBLICENSEDPRODUCT pLicProduct,
    IN WORD wLicenseChainDetail,
    OUT PBYTE* ppbEncodedCert,
    OUT PDWORD pcbEncodedCert
    )
/*++


++*/
{
    DWORD dwStatus = ERROR_SUCCESS;
    HCERTSTORE hStore = NULL;
    PCCERT_CONTEXT pCertContext = NULL;
    PBYTE pbCert=NULL;
    DWORD cbCert=NULL;
    DWORD index;
    TLSClientCertRDN clientCertRdn;
    PCERT_NAME_BLOB pIssuerNameBlob = NULL;


    //
    // Create a in-memory store
    //
    hStore=CertOpenStore(
                    CERT_STORE_PROV_MEMORY,
                    X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
                    hCryptProv,
                    CERT_STORE_NO_CRYPT_RELEASE_FLAG,
                    NULL
                );

    if(!hStore)
    {
        TLSLogEvent(
                    EVENTLOG_ERROR_TYPE, 
                    TLS_E_GENERATECLIENTELICENSE,
                    TLS_E_OPEN_CERT_STORE, 
                    dwStatus=GetLastError()
                );

        goto cleanup;
    }
    
#ifndef ENFORCE_LICENSING
    
    pIssuerNameBlob = &g_SelfSignCertContext->pCertInfo->Subject;

#else

    if( g_SelfSignCertContext == NULL )
    {
        TLSASSERT(FALSE);
        dwStatus = TLS_E_INTERNAL;
        goto cleanup;
    }

    if(g_bHasHydraCert && g_hCaStore && wLicenseChainDetail == LICENSE_DETAIL_DETAIL)
    {
        pIssuerNameBlob = &g_LicenseCertContext->pCertInfo->Subject;
    }
    else
    {
        pIssuerNameBlob = &g_SelfSignCertContext->pCertInfo->Subject;
    }

#endif


    //
    // Generate client certificate and add to certstore
    //
    for(index = 0; index < dwNumLicensedProduct; index++)
    {
        if(pCertContext != NULL)
        {
            //
            // Need to keep one pCertContext for later use
            //
            CertFreeCertificateContext(pCertContext);
            pCertContext = NULL;
        }

        clientCertRdn.type = LSCERT_CLIENT_INFO_TYPE;
        clientCertRdn.ClientInfo.szUserName = pLicProduct[index].szUserName;
        clientCertRdn.ClientInfo.szMachineName = pLicProduct[index].szMachineName;
        clientCertRdn.ClientInfo.pClientID = &pLicProduct[index].ClientHwid;

        dwStatus = TLSGenerateSingleCertificate(
                                    hCryptProv,
                                    pIssuerNameBlob,
                                    &clientCertRdn,
                                    pLicProduct[index].pSubjectPublicKeyInfo,
                                    pLicProduct+index,
                                    &pbCert,
                                    &cbCert
                                );

        if(dwStatus != ERROR_SUCCESS)
        {
            break;
        }

        //
        // Add certificate to store
        //
        pCertContext = CertCreateCertificateContext(
                                        X509_ASN_ENCODING,
                                        pbCert,
                                        cbCert
                                    );

        if(pCertContext == NULL)
        {
            TLSLogEvent(
                    EVENTLOG_ERROR_TYPE, 
                    TLS_E_GENERATECLIENTELICENSE,
                    TLS_E_CREATE_CERTCONTEXT, 
                    dwStatus=GetLastError()
                );  
            break;
        }

        //
        // always start from empty so CERT_STORE_ADD_ALWAYS
        //
        if(!CertAddCertificateContextToStore(hStore, pCertContext, CERT_STORE_ADD_ALWAYS, NULL))
        {
            TLSLogEvent(
                    EVENTLOG_ERROR_TYPE, 
                    TLS_E_GENERATECLIENTELICENSE,
                    TLS_E_ADD_CERT_TO_STORE, 
                    dwStatus=GetLastError()
                );
  
            break;
        }

        FreeMemory(pbCert);
        pbCert = NULL;
    }

    if(dwStatus == ERROR_SUCCESS)
    {
        
#ifndef ENFORCE_LICENSING
        //
        // Add license server's certificate
        if(!CertAddCertificateContextToStore(hStore, g_LicenseCertContext, CERT_STORE_ADD_ALWAYS, NULL))
        {
            TLSLogEvent(
                    EVENTLOG_ERROR_TYPE, 
                    TLS_E_GENERATECLIENTELICENSE,
                    TLS_E_ADD_CERT_TO_STORE, 
                    dwStatus=GetLastError()
                );  
            goto cleanup;
        }
#else

        //
        // we don't support LICENSE_DETAIL_MODERATE at this time, treat it as LICENSE_DETAIL_SIMPLE
        //
        if(g_bHasHydraCert && g_hCaStore && wLicenseChainDetail == LICENSE_DETAIL_DETAIL)
        {
            //
            // Chain issuer certificate with client certificate
            //
            if(!TLSChainIssuerCertificate(hCryptProv, g_hCaStore, hStore, pCertContext))
            {
                TLSLogEvent(
                        EVENTLOG_ERROR_TYPE, 
                        TLS_E_GENERATECLIENTELICENSE,
                        TLS_E_ADD_CERT_TO_STORE, 
                        dwStatus=GetLastError()
                    );  
                goto cleanup;
            }
        }
        else
        {
            //
            // Add license server's certificate
            if(!CertAddCertificateContextToStore(hStore, g_SelfSignCertContext, CERT_STORE_ADD_ALWAYS, NULL))
            {
                TLSLogEvent(
                        EVENTLOG_ERROR_TYPE, 
                        TLS_E_GENERATECLIENTELICENSE,
                        TLS_E_ADD_CERT_TO_STORE, 
                        dwStatus=GetLastError()
                    );  
                goto cleanup;
            }
        }
#endif             
        
        CRYPT_DATA_BLOB saveBlob;
        memset(&saveBlob, 0, sizeof(saveBlob));

        // save certificate into memory
        if(!CertSaveStore(hStore, 
                          X509_ASN_ENCODING | PKCS_7_ASN_ENCODING, 
                          LICENSE_BLOB_SAVEAS_TYPE,
                          CERT_STORE_SAVE_TO_MEMORY,
                          &saveBlob,
                          0) && (dwStatus=GetLastError()) != ERROR_MORE_DATA)
        {
            TLSLogEvent(
                    EVENTLOG_ERROR_TYPE, 
                    TLS_E_GENERATECLIENTELICENSE,
                    TLS_E_SAVE_STORE, 
                    dwStatus=GetLastError()
                );  
            goto cleanup;
        }

        if(!(saveBlob.pbData = (PBYTE)AllocateMemory(saveBlob.cbData)))
        {
            dwStatus=TLS_E_ALLOCATE_MEMORY;
            goto cleanup;
        }

        // save certificate into memory
        if(!CertSaveStore(hStore, 
                          X509_ASN_ENCODING | PKCS_7_ASN_ENCODING, 
                          LICENSE_BLOB_SAVEAS_TYPE,
                          CERT_STORE_SAVE_TO_MEMORY,
                          &saveBlob,
                          0))
        {
            TLSLogEvent(
                    EVENTLOG_ERROR_TYPE, 
                    TLS_E_GENERATECLIENTELICENSE,
                    TLS_E_SAVE_STORE, 
                    dwStatus=GetLastError()
                );  
            goto cleanup;
        }
        
        *ppbEncodedCert = saveBlob.pbData;
        *pcbEncodedCert = saveBlob.cbData;
    }

cleanup:

    FreeMemory(pbCert);

    if(pCertContext)
    {
        CertFreeCertificateContext(pCertContext);
    }

    if(hStore)
    {
        CertCloseStore(hStore, CERT_CLOSE_STORE_FORCE_FLAG);
    }

    return dwStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\license\tlserver\server\globals.h ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996-1998
//
// File:        globals.h
//
// Contents:    All global variable used in Hydra License Server
//
// History:     12-09-97    HueiWang    Created
//
//---------------------------------------------------------------------------
#ifndef __LS_GLOBALS_H
#define __LS_GLOBALS_H
#include "server.h"
#include "postsrv.h"

#ifndef INITGUID
#define INITGUID
#include <guiddef.h>
#undef INITGUID
#else
#include <guiddef.h>
#endif

//---------------------------------------------------------------------------
// All globals variable are declared in globals.cpp
//
#ifndef _NO_ODBC_JET
extern TLSDbWorkSpace* g_DbWorkSpace;
#endif



// Defaule server scope

extern CTlsVssJetWriter *g_pWriter;
extern GUID idWriter;

extern DWORD GetPageSize( VOID );
extern BOOL MyVirtualAlloc( IN  DWORD  dwSize,
            OUT PVOID *ppvData );
extern VOID MyVirtualFree( IN PVOID pvData ) ;

//---------------------------------------------------------------------------

extern TCHAR g_szScope[LSERVER_MAX_STRING_SIZE+1];
extern LPTSTR g_pszScope;

extern TCHAR g_szDatabaseFile[MAX_PATH+1];
extern TCHAR g_szDatabaseDir[MAX_PATH+1];
extern TCHAR g_szDatabaseFname[MAX_PATH+1];
extern TCHAR g_szDbUser[MAXUSERNAMELENGTH+1];
extern TCHAR g_szDbPwd[MAXUSERNAMELENGTH+1];

extern LPCTSTR szManufactureMS;

extern LONG g_NextKeyPackId;
extern LONG g_NextLicenseId;

extern PBYTE g_pbSecretKey;
extern DWORD g_cbSecretKey;


extern LPTSTR  g_pszServerUniqueId;
extern DWORD   g_cbServerUniqueId;

extern LPTSTR  g_pszServerPid;
extern DWORD   g_cbServerPid;

extern PBYTE  g_pbServerSPK;
extern DWORD  g_cbServerSPK;

extern DWORD g_GracePeriod;
extern BOOL  g_IssueTemporayLicense;

extern BOOL  g_bHasHydraCert;
extern PBYTE g_pbSignatureEncodedCert;
extern DWORD g_cbSignatureEncodedCert;

extern PBYTE g_pbExchangeEncodedCert;
extern DWORD g_cbExchangeEncodedCert;

extern TCHAR g_szHostName[MAXTCPNAME+1];
extern DWORD g_cbHostName;

extern TCHAR g_szComputerName[MAX_COMPUTERNAME_LENGTH+2];
extern DWORD g_cbComputerName;

extern PCCERT_CONTEXT  g_LicenseCertContext;
extern HCRYPTPROV g_hCryptProv;

extern PCCERT_CONTEXT g_SelfSignCertContext;

extern DWORD g_GeneralDbTimeout;
extern DWORD g_EnumDbTimeout;
extern DWORD g_dwMaxDbHandles;

#if ENFORCE_LICENSING
extern HCERTSTORE  g_hCaStore;
extern HKEY  g_hCaRegKey;
#endif

extern HCRYPTKEY g_SignKey;
extern HCRYPTKEY g_ExchKey;
//extern PBYTE g_pbDomainSid;
//extern DWORD g_cbDomainSid;
extern DWORD g_SrvRole;

extern LPTSTR g_szDomainGuid;

extern PCERT_EXTENSIONS g_pCertExtensions;
extern DWORD            g_cbCertExtensions;

extern FILETIME        g_ftCertExpiredTime;
extern FILETIME        g_ftLastShutdownTime;

extern DWORD           g_dwTlsJobInterval;
extern DWORD           g_dwTlsJobRetryTimes;
extern DWORD           g_dwTlsJobRestartTime;

extern SERVER_ROLE_IN_DOMAIN g_ServerRoleInDomain;

extern DWORD            g_LowLicenseCountWarning;

extern DWORD g_EsentMaxCacheSize;
extern DWORD g_EsentStartFlushThreshold;
extern DWORD g_EsentStopFlushThreadhold;
extern DWORD g_EsentMaxVerPages;

//
//  Reissuance Parameters
//

extern DWORD g_dwReissueLeaseMinimum;
extern DWORD g_dwReissueLeaseRange;
extern DWORD g_dwReissueLeaseLeeway;
extern DWORD g_dwReissueExpireThreadSleep;

//
// Counters
//

extern LONG g_lTemporaryLicensesIssued;
extern LONG g_lPermanentLicensesIssued;
extern LONG g_lPermanentLicensesReissued;
extern LONG g_lPermanentLicensesReturned;
extern LONG g_lLicensesMarked;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\license\tlserver\server\hydrals-s.c ===
#include <hydrals_s.c>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\license\tlserver\server\init.cpp ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996-1996
//
// File:        init.cpp
//
// Contents:    
//              All hydra license server initialization code.
//
// History:     
//          Feb. 4, 98      HueiWang    Created
// Note:        
//---------------------------------------------------------------------------
#include "pch.cpp"
#include "globals.h"
#include "init.h"
#include "misc.h"
#include "tlscert.h"
#include "pid.h"
#include "upgdb.h"
#include "lkplite.h"
#include "gencert.h"

#define WHISTLER_CAL   L"SYSTEM\\CurrentControlSet\\Services\\TermService\\Parameters\\WhistlerCAL"    

//
// file scope define
//
#define DEFAULT_CSP     MS_DEF_PROV
#define PROVIDER_TYPE   PROV_RSA_FULL

DWORD
TLSStartupLSDB(
    IN BOOL bCheckDBStatus,
    IN DWORD dwMaxDbHandles,
    IN BOOL bStartEmptyIfError,
    IN LPTSTR pszChkPointDirPath,
    IN LPTSTR pszTempDirPath,
    IN LPTSTR pszLogDirPath,
    IN LPTSTR pszDbFile,
    IN LPTSTR pszUserName,
    IN LPTSTR pszPassword
);

DWORD
TLSLoadRuntimeParameters();

DWORD
TLSStartLSDbWorkspaceEngine(
    BOOL,
    BOOL,
    BOOL,
    BOOL
);

////////////////////////////////////////////////////////////////////////////
//
//
// Global Variables
//
//
////////////////////////////////////////////////////////////////////////////
static BOOL g_ValidDatabase=FALSE;

#if DBG
void
EnsureExclusiveAccessToDbFile( 
    LPTSTR szDatabaseFile 
    )
/*++

--*/
{
    HANDLE hFile = NULL;
    DWORD dwErrCode;

    hFile = CreateFile(
                    szDatabaseFile,
                    GENERIC_WRITE | GENERIC_READ,
                    0,
                    NULL,
                    OPEN_EXISTING,
                    FILE_ATTRIBUTE_NORMAL,
                    NULL
                );

    if( INVALID_HANDLE_VALUE == hFile )
    {
        dwErrCode = GetLastError();

        if( ERROR_FILE_NOT_FOUND != dwErrCode )
        {
            DBGPrintf(
                    DBG_INFORMATION,
                    DBG_FACILITY_INIT,
                    DBGLEVEL_FUNCTION_DETAILSIMPLE,
                    _TEXT("EnsureExclusiveAccessToDbFile() failed with %d\n"),
                    dwErrCode
                );
        }
        else if( ERROR_SHARING_VIOLATION == dwErrCode )
        {
            // special attention...
            TLSASSERT( FALSE );
        }
        else
        {
            TLSASSERT( FALSE );
        }
    }
    else
    {
        CloseHandle( hFile );
    }                    

    return;
}
#endif


////////////////////////////////////////////////////////////////////////////
BOOL
TLSGenerateLSDBBackupFileName(
    IN LPCTSTR pszPath,
    IN OUT LPTSTR pszTempFile
    )
/*++

--*/
{
    DWORD dwTempRandom;

    if (lstrlen(pszPath)+13 > MAX_PATH)
    {
        // path too long
        return FALSE;
    }

    //
    // Generate a temporary file name.
    //
    dwTempRandom = GetTempFileName(
                            pszPath,
                            _TEXT("TLS"),
                            0,
                            pszTempFile
                        );

    if(dwTempRandom == 0)
    {
        //
        // GetTempFileName failed
        // Generate a backup file name based on current time,
        // possibility of collision is high
        //
        SYSTEMTIME LocalTime;

        if (lstrlen(pszPath)+25 > MAX_PATH)
        {
            // path too long
            return FALSE;
        }


        GetLocalTime(&LocalTime);

        wsprintf(
                pszTempFile,
                _TEXT("%s\\LSDBBackup.%02d%02d%02d%02d%02d%02d"),
                pszPath,
                LocalTime.wYear,
                LocalTime.wMonth,
                LocalTime.wDay,
                LocalTime.wHour,
                LocalTime.wMinute,
                LocalTime.wSecond
            );
    }

    return TRUE;
}


/////////////////////////////////////////////////////////////////////////////
BOOL
CanIssuePermLicense()
{
#ifndef ENFORCE_LICENSING
    return TRUE;
#else
    if(g_bHasHydraCert == TRUE || (g_pbServerSPK != NULL && g_cbServerSPK != 0))
    {
        return TRUE;
    }

    return FALSE;
#endif
}

/////////////////////////////////////////////////////////////////////////////
void
GetServiceLastShutdownTime(
    OUT FILETIME* ft
    )
/*++

--*/
{
    *ft = g_ftLastShutdownTime;
    return;
}

//---------------------------------------------------------------------
void
SetServiceLastShutdownTime()
{
    GetSystemTimeAsFileTime(&g_ftLastShutdownTime);
}
    
//---------------------------------------------------------------------
void
GetJobObjectDefaults(
    PDWORD pdwInterval,
    PDWORD pdwRetries,
    PDWORD pdwRestartTime
    )
/*++

--*/
{
    *pdwInterval = g_dwTlsJobInterval;
    *pdwRetries = g_dwTlsJobRetryTimes;
    *pdwRestartTime = g_dwTlsJobRestartTime;
}

/////////////////////////////////////////////////////////////////////////////

DWORD
GetLicenseServerRole()
{
    return g_SrvRole;
}

/////////////////////////////////////////////////////////////////////////////

void 
ServerShutdown()
{
#if ENFORCE_LICENSING
    if(g_hCaStore)
    {
        CertCloseStore(
                    g_hCaStore, 
                    CERT_CLOSE_STORE_FORCE_FLAG
                );
    }

    if(g_hCaRegKey)
    {
        RegCloseKey(g_hCaRegKey);
    }
#endif

    if(g_SignKey)
    {
        CryptDestroyKey(g_SignKey);
    }

    if(g_ExchKey)
    {
        CryptDestroyKey(g_ExchKey);
    }

    TLServerLastRun lastRun;

    memset(&lastRun, 0, sizeof(TLServerLastRun));
    lastRun.dwVersion = LSERVER_LSA_LASTRUN_VER_CURRENT;
    lastRun.ftLastShutdownTime = g_ftLastShutdownTime;

    // if unclean shutdown or can't get next ID, set to 0
    if( g_ValidDatabase == FALSE ||
        TLSDBGetMaxKeyPackId(g_DbWorkSpace, (DWORD *)&g_NextKeyPackId) == FALSE ||
        TLSDBGetMaxLicenseId(g_DbWorkSpace, (DWORD *)&g_NextLicenseId) == FALSE )
    {
        g_NextKeyPackId = 0;
        g_NextLicenseId = 0;
    }

    lastRun.dwMaxKeyPackId = g_NextKeyPackId;
    lastRun.dwMaxLicenseId = g_NextLicenseId;

    StoreKey(
            LSERVER_LSA_LASTRUN, 
            (PBYTE)&lastRun, 
            sizeof(TLServerLastRun)
        );

    LSShutdownCertutilLib();

    if( g_SelfSignCertContext != NULL )
    {
        CertFreeCertificateContext(g_SelfSignCertContext);
    }

    if(g_LicenseCertContext)
    {
        CertFreeCertificateContext(g_LicenseCertContext);
    }

    TLSDestroyCryptContext(g_hCryptProv);
    g_hCryptProv=NULL;

    //
    // shutdown Work manager
    //  
    TLSWorkManagerShutdown();
    

#ifndef _NO_ODBC_JET
    if(g_DbWorkSpace != NULL)
    {
        ReleaseWorkSpace(&g_DbWorkSpace);
    }
#endif

    CloseWorkSpacePool();

    FreeMemory(g_pbSecretKey);
    FreeMemory(g_pbSignatureEncodedCert);
    FreeMemory(g_pbExchangeEncodedCert);
    //FreeMemory(g_pbDomainSid);
    FreeMemory(g_pCertExtensions);

    FreeMemory(g_pszServerUniqueId);
    FreeMemory(g_pszServerPid);
    FreeMemory(g_pbServerSPK);

    if(g_szDomainGuid != NULL)
    {
        RpcStringFree(&g_szDomainGuid);
    }

    return;
}

/////////////////////////////////////////////////////////////////////////////

DWORD 
StartServerInitThread( 
    void* p 
    )
/*
*/
{
    DWORD dwStatus = ERROR_SUCCESS;
    BOOL bDebug = (p) ? TRUE : FALSE;
    HKEY hKey = NULL;
    PTLSLSASERVERID pTlsLsaServerIds=NULL;
    DWORD cbTlsLsaServerIds=0;

    do {

        TLSInit();

        //
        // Load various run time parameters
        //
        dwStatus = TLSLoadRuntimeParameters();

        if(dwStatus != ERROR_SUCCESS)
        {
            break;
        }       

        //
        // Retrive License Server's IDs
        //
        dwStatus = RetrieveKey(
                            LSERVER_LSA_LSERVERID, 
                            (PBYTE *)&pTlsLsaServerIds,
                            &cbTlsLsaServerIds
                        );

        if(dwStatus != ERROR_SUCCESS)
        {
            //
            // First time, generate various license server ID
            //
            dwStatus = TLSGeneratePid(
                                &g_pszServerPid,
                                &g_cbServerPid,
                                &g_pszServerUniqueId,
                                &g_cbServerUniqueId
                            );

            if(dwStatus != ERROR_SUCCESS)
            {
                TLSLogEvent(
                        EVENTLOG_ERROR_TYPE,
                        TLS_E_SERVICEINIT,
                        TLS_E_GENERATE_IDS
                    );

                break;
            }

            //
            // Store this into LSA
            //
            dwStatus = ServerIdsToLsaServerId(
                                        (PBYTE)g_pszServerUniqueId,
                                        g_cbServerUniqueId,
                                        (PBYTE)g_pszServerPid,
                                        g_cbServerPid,
                                        g_pbServerSPK,
                                        g_cbServerSPK,
                                        NULL,
                                        0,
                                        &pTlsLsaServerIds,
                                        &cbTlsLsaServerIds
                                    );
            if(dwStatus != ERROR_SUCCESS)
            {
                TLSLogEvent(
                        EVENTLOG_ERROR_TYPE,
                        TLS_E_SERVICEINIT,
                        dwStatus = TLS_E_STORE_IDS
                    );

                break;
            }

            dwStatus = StoreKey(
                            LSERVER_LSA_LSERVERID,
                            (PBYTE)pTlsLsaServerIds,
                            cbTlsLsaServerIds
                        );

            if(dwStatus != ERROR_SUCCESS)
            {
                TLSLogEvent(
                        EVENTLOG_ERROR_TYPE,
                        TLS_E_SERVICEINIT,
                        dwStatus = TLS_E_STORE_IDS
                    );

                break;
            }
        }
        else
        {
            dwStatus = LsaServerIdToServerIds(
                                        pTlsLsaServerIds,
                                        cbTlsLsaServerIds,
                                        (PBYTE *)&g_pszServerUniqueId,
                                        &g_cbServerUniqueId,
                                        (PBYTE *)&g_pszServerPid,
                                        &g_cbServerPid,
                                        &g_pbServerSPK,
                                        &g_cbServerSPK,
                                        &g_pCertExtensions,
                                        &g_cbCertExtensions
                                    );

            if(dwStatus != ERROR_SUCCESS)
            {
                TLSLogEvent(
                        EVENTLOG_ERROR_TYPE,
                        TLS_E_SERVICEINIT,
                        dwStatus = TLS_E_RETRIEVE_IDS
                    );

                break;
            }

            if( g_pszServerUniqueId == NULL || 
                g_cbServerUniqueId == 0 ||
                g_pszServerPid == NULL ||
                g_cbServerPid == 0 )
            {
                TLSLogEvent(
                        EVENTLOG_ERROR_TYPE,
                        TLS_E_SERVICEINIT,
                        dwStatus = TLS_E_INTERNAL
                    );

                break;
            }
        }

        //
        // License Server common secret key for encoding/decoding
        // client HWID
        //
        LicenseGetSecretKey(&g_cbSecretKey, NULL);
        if((g_pbSecretKey = (PBYTE)AllocateMemory(g_cbSecretKey)) == NULL)
        {
            TLSLogEvent(
                    EVENTLOG_ERROR_TYPE,
                    TLS_E_SERVICEINIT,
                    dwStatus = TLS_E_ALLOCATE_MEMORY
                );

            break;
        }
    
        if(LicenseGetSecretKey( &g_cbSecretKey, g_pbSecretKey ) != LICENSE_STATUS_OK)
        {
            TLSLogEvent(
                    EVENTLOG_ERROR_TYPE,
                    TLS_E_SERVICEINIT,
                    dwStatus = TLS_E_RETRIEVE_KEY
                );

            break;
        }


        //--------------------------------------------------------------
        //
        // Check if our database file is in import directory
        //
        //--------------------------------------------------------------
        dwStatus = TLSStartLSDbWorkspaceEngine(
                                        bDebug == FALSE, 
                                        FALSE,              // check DB file on export directory
                                        FALSE,              // check file time on DB file
                                        TRUE                // log low license count warning.
                                    );
        if(dwStatus != ERROR_SUCCESS)
        {
            break;
        }

        dwStatus = ERROR_SUCCESS;
        g_ValidDatabase = TRUE;

        //
        // load all policy module, ignore error
        //
        ServiceLoadAllPolicyModule(
                        HKEY_LOCAL_MACHINE,
                        LSERVER_POLICY_REGBASE
                    ); 

        //
        // Upgrade - make two copies of certificate
        //
        dwStatus = RegOpenKeyEx(
                            HKEY_LOCAL_MACHINE,
                            LSERVER_SERVER_CERTIFICATE_REGKEY,
                            0,
                            KEY_ALL_ACCESS,
                            &hKey
                        );

        if(hKey != NULL)
        {
            RegCloseKey(hKey);
        }

        if(dwStatus != ERROR_SUCCESS)
        {
            dwStatus = ERROR_SUCCESS;

            // we are not register yet...
            break;
        }


        //
        // Verify first backup copy of certificate exists
        //
        hKey = NULL;
        dwStatus = RegOpenKeyEx(
                            HKEY_LOCAL_MACHINE,
                            LSERVER_SERVER_CERTIFICATE_REGKEY_BACKUP1,
                            0,
                            KEY_ALL_ACCESS,
                            &hKey
                        );
        if(hKey != NULL)
        {
            RegCloseKey(hKey);
        }

        if(dwStatus == ERROR_FILE_NOT_FOUND)
        {
            dwStatus = TLSRestoreLicenseServerCertificate(
                                            LSERVER_SERVER_CERTIFICATE_REGKEY,
                                            LSERVER_SERVER_CERTIFICATE_REGKEY_BACKUP1
                                        );

            if(dwStatus != ERROR_SUCCESS)
            {
                TLSLogWarningEvent(TLS_W_BACKUPCERTIFICATE);

                TLSRegDeleteKey(
                        HKEY_LOCAL_MACHINE,
                        LSERVER_SERVER_CERTIFICATE_REGKEY_BACKUP1
                    );
            }
        }

        //
        // Verify second backup copy of certificate exists
        //
        hKey = NULL;
        dwStatus = RegOpenKeyEx(
                            HKEY_LOCAL_MACHINE,
                            LSERVER_SERVER_CERTIFICATE_REGKEY_BACKUP2,
                            0,
                            KEY_ALL_ACCESS,
                            &hKey
                        );
        if(hKey != NULL)
        {
            RegCloseKey(hKey);
        }

        if(dwStatus == ERROR_FILE_NOT_FOUND)
        {
            dwStatus = TLSRestoreLicenseServerCertificate(
                                            LSERVER_SERVER_CERTIFICATE_REGKEY,
                                            LSERVER_SERVER_CERTIFICATE_REGKEY_BACKUP2
                                        );

            if(dwStatus != ERROR_SUCCESS)
            {
                TLSLogWarningEvent(TLS_W_BACKUPCERTIFICATE);

                TLSRegDeleteKey(
                        HKEY_LOCAL_MACHINE,
                        LSERVER_SERVER_CERTIFICATE_REGKEY_BACKUP2
                    );
            }
        }

        dwStatus = ERROR_SUCCESS;
    } while(FALSE);
    
    if(pTlsLsaServerIds != NULL)
    {
        LocalFree(pTlsLsaServerIds);
    }

    ExitThread(dwStatus); 

    return dwStatus;
}

/////////////////////////////////////////////////////////////////////////////

HANDLE 
ServerInit(
    BOOL bDebug
    )
{
    HANDLE hThread;
    DWORD  dump;

    hThread=(HANDLE)CreateThread(
                            NULL, 
                            0, 
                            StartServerInitThread, 
                            LongToPtr(bDebug), 
                            0, 
                            &dump
                        );
    return hThread;
}

/////////////////////////////////////////////////////////////////////////////

DWORD
TLSRestoreLicenseServerCertificate(
    LPCTSTR pszSourceRegKey,
    LPCTSTR pszTargetRegKey
    )
/*++

--*/
{
    DWORD dwStatus = ERROR_SUCCESS;

    // first delete the certificate key, ignore error 
    TLSRegDeleteKey(
                HKEY_LOCAL_MACHINE,
                pszTargetRegKey
            );

    // copy from backup
    dwStatus = TLSTreeCopyRegKey(
                            HKEY_LOCAL_MACHINE,
                            pszSourceRegKey,
                            HKEY_LOCAL_MACHINE,
                            pszTargetRegKey
                        );

    if(dwStatus == ERROR_FILE_NOT_FOUND)
    {
        // source registry key does not exist
        dwStatus = TLS_E_NO_CERTIFICATE;
    }

    return dwStatus;
}

////////////////////////////////////////////////////////////////////////////////

DWORD
TLSLoadVerifyLicenseServerCertificates()
/*++

--*/
{
    DWORD dwStatus;

#if ENFORCE_LICENSING

    // load certificate from normal place
    dwStatus = TLSLoadCHEndosedCertificate(
                                &g_cbSignatureEncodedCert, 
                                &g_pbSignatureEncodedCert,
                                &g_cbExchangeEncodedCert,
                                &g_pbExchangeEncodedCert
                            );
    
    if(dwStatus == ERROR_SUCCESS)
    {
        if(g_hCaStore != NULL)
        {
            CertCloseStore(
                    g_hCaStore, 
                    CERT_CLOSE_STORE_FORCE_FLAG
                );
        }

        if(g_hCaRegKey != NULL)
        {
            RegCloseKey(g_hCaRegKey);
        }

        //
        // license server is registered, verify certificate
        //
        g_hCaStore = CertOpenRegistryStore(
                                HKEY_LOCAL_MACHINE, 
                                LSERVER_CERTIFICATE_REG_CA_SIGNATURE, 
                                g_hCryptProv, 
                                &g_hCaRegKey
                            );
        if(g_hCaStore != NULL)
        {
            //
            // Go thru license server's certficiate to validate 
            //
            dwStatus = TLSValidateServerCertficates(
                                            g_hCryptProv,
                                            g_hCaStore,
                                            g_pbSignatureEncodedCert,
                                            g_cbSignatureEncodedCert,
                                            g_pbExchangeEncodedCert,
                                            g_cbExchangeEncodedCert,
                                            &g_ftCertExpiredTime
                                        );

            if(dwStatus != ERROR_SUCCESS)
            {
                //
                // Invalid certificate in registry
                //
                dwStatus = TLS_E_INVALID_CERTIFICATE;
            }
        }
        else
        {
            //
            // Can't open registry key, startup as non-register
            // server.
            //
            //TLSLogEvent(
            //            EVENTLOG_ERROR_TYPE, 
            //            TLS_E_SERVICEINIT,
            //            TLS_E_OPEN_CERTSTORE, 
            //            dwStatus = GetLastError()
            //        );  

            dwStatus = TLS_E_NO_CERTIFICATE;
        }
    }

    if(dwStatus == ERROR_SUCCESS)
    {
        if(g_LicenseCertContext != NULL)
        {
            CertFreeCertificateContext(g_LicenseCertContext);
        }

        g_LicenseCertContext = CertCreateCertificateContext(
                                            X509_ASN_ENCODING,
                                            g_pbSignatureEncodedCert,
                                            g_cbSignatureEncodedCert
                                        );

        //if(!g_LicenseCertContext)
        //{
        //    TLSLogEvent(
        //                EVENTLOG_ERROR_TYPE, 
        //                TLS_E_SERVICEINIT,
        //                TLS_E_CREATE_CERTCONTEXT, 
        //                GetLastError()
        //            );  
        //}
    }

    if(dwStatus != ERROR_SUCCESS)
    {
        g_bHasHydraCert = FALSE;
    }
    else
    {
        g_bHasHydraCert = TRUE;
    }                
   
#else

    dwStatus = TLS_E_NO_CERTIFICATE;

#endif

    return dwStatus;
}
    
///////////////////////////////////////////////////////////////////////

BOOL 
TLSLoadServerCertificate()
/*++

Abstract:

    Load license server certificate     

--*/
{
    BOOL bSuccess = FALSE;
    DWORD dwStatus;
    PBYTE pbSelfSignedCert = NULL;
    DWORD cbSelfSignedCert = 0;
    BOOL bSelfSignedCreated = FALSE;
    
    g_ftCertExpiredTime.dwLowDateTime = 0xFFFFFFFF;
    g_ftCertExpiredTime.dwHighDateTime = 0xFFFFFFFF;

#if ENFORCE_LICENSING

    dwStatus = TLSLoadVerifyLicenseServerCertificates();
    
    //
    // failed to load server certificate, try backup copy,
    // if either one success, make sure we have all three copy up
    // to date.
    //
    if(dwStatus == TLS_E_INVALID_CERTIFICATE || dwStatus == TLS_E_NO_CERTIFICATE)
    {
        dwStatus = TLSRestoreLicenseServerCertificate(
                                                LSERVER_SERVER_CERTIFICATE_REGKEY_BACKUP1,
                                                LSERVER_SERVER_CERTIFICATE_REGKEY
                                            );
        
        if(dwStatus == ERROR_SUCCESS)
        {
            dwStatus = TLSLoadVerifyLicenseServerCertificates();
            if(dwStatus == ERROR_SUCCESS)
            {
                //
                // Log event indicate we are using backup certificate
                //
                LPCTSTR pString[1];
                pString[0]= g_szComputerName;

                TLSLogEventString(
                        EVENTLOG_WARNING_TYPE,
                        TLS_W_CORRUPTTRYBACKUPCERTIFICATE,
                        1,
                        pString
                    );

                //
                // make sure second copy is same as first copy.
                //
                TLSRestoreLicenseServerCertificate(
                                            LSERVER_SERVER_CERTIFICATE_REGKEY_BACKUP1,
                                            LSERVER_SERVER_CERTIFICATE_REGKEY_BACKUP2
                                        );
            }
        }
    }

    if(dwStatus == TLS_E_INVALID_CERTIFICATE || dwStatus == TLS_E_NO_CERTIFICATE)
    {
        dwStatus = TLSRestoreLicenseServerCertificate(
                                                LSERVER_SERVER_CERTIFICATE_REGKEY_BACKUP2,
                                                LSERVER_SERVER_CERTIFICATE_REGKEY
                                            );
        
        if(dwStatus == ERROR_SUCCESS)
        {
            dwStatus = TLSLoadVerifyLicenseServerCertificates();
            if(dwStatus == ERROR_SUCCESS)
            {
                //
                // Log event indicate we are using backup certificate
                //
                LPCTSTR pString[1];
                pString[0]= g_szComputerName;

                TLSLogEventString(
                        EVENTLOG_WARNING_TYPE,
                        TLS_W_CORRUPTTRYBACKUPCERTIFICATE,
                        1,
                        pString
                    );

                //
                // make sure our first copy is up to date
                //
                TLSRestoreLicenseServerCertificate(
                                            LSERVER_SERVER_CERTIFICATE_REGKEY_BACKUP2,
                                            LSERVER_SERVER_CERTIFICATE_REGKEY_BACKUP1
                                        );
            }
        }
    }

    //
    // Everything failed, log an event state that license server 
    // will startup in un-registered mode
    //
    if(dwStatus == TLS_E_INVALID_CERTIFICATE)
    {
        LPCTSTR pString[1];

        pString[0] = g_szComputerName;

        TLSLogEventString(
                EVENTLOG_WARNING_TYPE,
                TLS_W_STARTUPCORRUPTEDCERT,
                1,
                pString
            );
    }
    else if(CanIssuePermLicense() == FALSE)
    {
        // we are not registered yet
        LPCTSTR pString[1];
        pString[0] = g_szComputerName;

        TLSLogEventString(
                    EVENTLOG_WARNING_TYPE, 
                    TLS_W_STARTUPNOCERT, 
                    1,
                    pString
                );
    }

    if( dwStatus != ERROR_SUCCESS )
    {
        //
        // if all failed, re-generate and start up as un-register 
        // license server
        //
        bSuccess = FALSE;

        //
        // wipe out all certificates and re-generate everything,
        // don't re-generate key if we are not registered yet.
        //
        if(g_pbServerSPK == NULL || g_cbServerSPK == 0)
        {
            TLSReGenerateKeys(FALSE);
        }
    }
    else
    {
        bSuccess = TRUE;
    }

#endif

	if(bSuccess == FALSE)
	{
        bSuccess = (TLSLoadSelfSignCertificates(
                                g_hCryptProv,
#if ENFORCE_LICENSING
                                g_pbServerSPK,
                                g_cbServerSPK,
#else
                                NULL,
                                0,
#endif
                                &g_cbSignatureEncodedCert, 
                                &g_pbSignatureEncodedCert,
                                &g_cbExchangeEncodedCert,
                                &g_pbExchangeEncodedCert
                            ) == ERROR_SUCCESS);

        #ifndef ENFORCE_LICENSING
        //
        // non enforce license version
        g_bHasHydraCert = TRUE;
        #endif        

        if(bSuccess == TRUE)
        {
            if(g_LicenseCertContext != NULL)
            {
                CertFreeCertificateContext(g_LicenseCertContext);
            }

            g_LicenseCertContext = CertCreateCertificateContext(
                                                X509_ASN_ENCODING,
                                                g_pbSignatureEncodedCert,
                                                g_cbSignatureEncodedCert
                                            );

            if(!g_LicenseCertContext)
            {
                bSuccess = FALSE;

                //
                // For self-signed cert, this is critical error, for 
                // cert. in registry store, it must have been thru validation
                // so still critical error.
                //
                TLSLogEvent(
                            EVENTLOG_ERROR_TYPE, 
                            TLS_E_SERVICEINIT,
                            TLS_E_CREATE_CERTCONTEXT, 
                            GetLastError()
                        );  
            }
            else
            {
                // we have created a self-signed certificate.
                bSelfSignedCreated = TRUE;
            }
        }
    }


    //
    // Create a self-signed certificate for old client, 
    //
    if( bSuccess == TRUE )
    {
        if( g_SelfSignCertContext != NULL )
        {
            CertFreeCertificateContext( g_SelfSignCertContext );
            g_SelfSignCertContext = NULL;
        }

        if( bSelfSignedCreated == FALSE )
        { 
            //
            // Create a self-signed certificate just for old client
            //
            dwStatus = TLSCreateSelfSignCertificate(
                                            g_hCryptProv,
                                            AT_SIGNATURE,
                                        #if ENFORCE_LICENSING
                                            g_pbServerSPK,
                                            g_cbServerSPK,
                                        #else
                                            NULL,
                                            0,
                                        #endif
                                            0,          
                                            NULL,
                                            &cbSelfSignedCert,
                                            &pbSelfSignedCert
                                        );

            if( dwStatus == ERROR_SUCCESS )
            {
                g_SelfSignCertContext = CertCreateCertificateContext(
                                                        X509_ASN_ENCODING,
                                                        pbSelfSignedCert,
                                                        cbSelfSignedCert
                                                    );
    
                if( g_SelfSignCertContext == NULL )
                {
                    bSuccess = FALSE;
                    TLSLogEvent(
                                EVENTLOG_ERROR_TYPE, 
                                TLS_E_SERVICEINIT,
                                TLS_E_CREATE_CERTCONTEXT, 
                                GetLastError()
                            );  
                }
            }
        }
        else
        {
            // we already have self-signed certificate created.
            g_SelfSignCertContext = CertDuplicateCertificateContext( g_LicenseCertContext );
            if( g_SelfSignCertContext == NULL )
            {
                TLSASSERT(FALSE);
                //
                // impossible, CertDuplicateCertificateContext() simply increase 
                // reference count
                //
                bSuccess = FALSE;
                TLSLogEvent(
                            EVENTLOG_ERROR_TYPE, 
                            TLS_E_SERVICEINIT,
                            TLS_E_CREATE_CERTCONTEXT, 
                            GetLastError()
                        );  
            }
        }
    }

    FreeMemory(pbSelfSignedCert);
    return bSuccess;
}

//---------------------------------------------------------------------

DWORD
ServiceInitCrypto(
    IN BOOL bCreateNewKeys,
    IN LPCTSTR pszKeyContainer,
    OUT HCRYPTPROV* phCryptProv,
    OUT HCRYPTKEY* phSignKey,
    OUT HCRYPTKEY* phExchKey
    )
/*

*/
{
    DWORD dwStatus=ERROR_SUCCESS;

    PBYTE pbSignKey=NULL;
    DWORD cbSignKey=0;
    PBYTE pbExchKey=NULL;
    DWORD cbExchKey=0;

    if(bCreateNewKeys == FALSE)
    {
        //
        // Load key from LSA
        //
        dwStatus = TLSLoadSavedCryptKeyFromLsa(
                                        &pbSignKey,
                                        &cbSignKey,
                                        &pbExchKey,
                                        &cbExchKey
                                    );
    } 

    if(bCreateNewKeys == TRUE || dwStatus == ERROR_FILE_NOT_FOUND)
    {
        dwStatus = TLSCryptGenerateNewKeys(
                                    &pbSignKey,
                                    &cbSignKey,
                                    &pbExchKey,
                                    &cbExchKey
                                );

        if(dwStatus == ERROR_SUCCESS)
        {
            // Save Key to LSA
            dwStatus = TLSSaveCryptKeyToLsa(
                                        pbSignKey,
                                        cbSignKey,
                                        pbExchKey,
                                        cbExchKey
                                    );
        }
    }

    if(dwStatus == ERROR_SUCCESS)
    {
        //
        // Initialize a clean crypto.
        //
        dwStatus = TLSInitCryptoProv(
                            pszKeyContainer,
                            pbSignKey,
                            cbSignKey,
                            pbExchKey,
                            cbExchKey,
                            phCryptProv,
                            phSignKey,
                            phExchKey
                        );
    }


    if(pbSignKey)
    {
        LocalFree(pbSignKey);
    }

    if(pbExchKey)
    {
        LocalFree(pbExchKey);
    }

    return dwStatus;
}

/////////////////////////////////////////////////////////////////////////////

DWORD 
InitCryptoAndCertificate()
{
    DWORD status=ERROR_SUCCESS;
    DWORD dwServiceState;
    DWORD dwCryptoState;

    //
    // Initialize single global Cryptographic Provider
    //
    status = ServiceInitCrypto(
                            FALSE,
                            NULL,
                            &g_hCryptProv,
                            &g_SignKey,
                            &g_ExchKey
                        );
    if(status != ERROR_SUCCESS)
    {
        TLSLogEvent(
                EVENTLOG_ERROR_TYPE, 
                TLS_E_SERVICEINIT,
                TLS_E_INIT_CRYPTO, 
                status
            );

        status = TLS_E_SERVICE_STARTUP;
        goto cleanup;
    }

    LSInitCertutilLib( NULL );

    if(!TLSLoadServerCertificate())
    {
        status = TLS_E_SERVICE_STARTUP;
        TLSLogErrorEvent(TLS_E_LOAD_CERTIFICATE);
        goto cleanup;
    }

    // 
    if(!g_pbExchangeEncodedCert || !g_pbSignatureEncodedCert)
    {
        TLSLogErrorEvent(status = TLS_E_INTERNAL);
    }

cleanup:

    return status;
}

//////////////////////////////////////////////////////////////////

DWORD
TLSReGenKeysAndReloadServerCert(
    BOOL bReGenKey
    )
/*++

--*/
{
    DWORD dwStatus;

    dwStatus = TLSReGenerateKeys(bReGenKey);
    
    //
    // always try reload certificate since TLSReGenerateKeys() 
    // will wipe out our keys.
    // 
    if(TLSLoadServerCertificate() == TRUE)
    {
        if(!g_pbExchangeEncodedCert || !g_pbSignatureEncodedCert)
        {
            TLSLogErrorEvent(dwStatus = TLS_E_INTERNAL);
        }
    }
    else
    {
        TLSLogErrorEvent(dwStatus = TLS_E_LOAD_CERTIFICATE);
    }

    return dwStatus;
}

////////////////////////////////////////////////////////////////////

DWORD
TLSReGenerateKeys(
    BOOL bReGenKey
    )

/*++

    Always restore state back to clean install, bReGenKeyOnly 
    not supported.

--*/
{
    HCRYPTPROV hCryptProv = NULL;
    HCRYPTKEY hSignKey = NULL;
    HCRYPTKEY hExchKey = NULL;
    DWORD dwStatus = ERROR_SUCCESS;

    PTLSLSASERVERID pTlsLsaServerIds=NULL;
    DWORD cbTlsLsaServerIds=0;

    //
    // Create a new clean crypto. 
    //
    dwStatus = ServiceInitCrypto(
                            bReGenKey,
                            NULL,
                            &hCryptProv,
                            &hSignKey,
                            &hExchKey
                        );

    if(dwStatus != ERROR_SUCCESS)
    {
        return dwStatus;
    }

    //
    // Cleanup our certificate registry.
    //
    TLSUninstallLsCertificate();

    //
    // Cleanup in-memory certificates, keys...
    //
    if(g_SignKey)
    {
        CryptDestroyKey(g_SignKey);
        g_SignKey = NULL;
    }

    if(g_ExchKey)
    {
        CryptDestroyKey(g_ExchKey);
        g_ExchKey = NULL;
    }

    if( g_SelfSignCertContext != NULL )
    {
        CertFreeCertificateContext( g_SelfSignCertContext );
        g_SelfSignCertContext = NULL;
    }

    if( g_LicenseCertContext != NULL )
    {
        CertFreeCertificateContext(g_LicenseCertContext);
        g_LicenseCertContext = NULL;
    }

    if(g_hCryptProv != NULL)
    {
        TLSDestroyCryptContext(g_hCryptProv);
    }

    g_hCryptProv=NULL;

    FreeMemory(g_pbSignatureEncodedCert);
    g_pbSignatureEncodedCert = NULL;
    g_cbSignatureEncodedCert = 0;

    FreeMemory(g_pbExchangeEncodedCert);
    g_pbExchangeEncodedCert = NULL;
    g_cbExchangeEncodedCert = 0;

    //
    // Always back to clean state.
    //
    FreeMemory(g_pCertExtensions);
    g_pCertExtensions = NULL;
    g_cbCertExtensions = 0;

    FreeMemory(g_pbServerSPK);
    g_pbServerSPK = NULL;
    g_cbServerSPK = 0;

    //
    // Store this into LSA
    //
    dwStatus = ServerIdsToLsaServerId(
                                (PBYTE)g_pszServerUniqueId,
                                g_cbServerUniqueId,
                                (PBYTE)g_pszServerPid,
                                g_cbServerPid,
                                NULL,
                                0,
                                NULL,
                                0,
                                &pTlsLsaServerIds,
                                &cbTlsLsaServerIds
                            );
    if(dwStatus != ERROR_SUCCESS)
    {
        assert(FALSE);
        goto cleanup;
    }

    dwStatus = StoreKey(
                    LSERVER_LSA_LSERVERID,
                    (PBYTE)pTlsLsaServerIds,
                    cbTlsLsaServerIds
                );

    if(dwStatus != ERROR_SUCCESS)
    {
        assert(FALSE);
        goto cleanup;
    }

    //
    // Re-generate in-memory certificates...
    //
    g_hCryptProv = hCryptProv;
    g_SignKey = hSignKey;
    g_ExchKey = hExchKey;

cleanup:

    FreeMemory(pTlsLsaServerIds);
    return dwStatus;
}

//////////////////////////////////////////////////////////////////

DWORD
TLSReGenSelfSignCert(
    IN HCRYPTPROV hCryptProv,
    IN PBYTE pbSPK,
    IN DWORD cbSPK,
    IN DWORD dwNumExtensions,
    IN PCERT_EXTENSION pCertExtensions
    )
/*++


--*/
{
    DWORD dwStatus;
    PTLSLSASERVERID pbLsaServerId = NULL;
    DWORD cbLsaServerId = 0;

    PBYTE pbSignCert = NULL;    
    DWORD cbSignCert = 0;
    PBYTE pbExchCert = NULL;
    DWORD cbExchCert = 0;
    DWORD dwVerifyResult;
    PCCERT_CONTEXT hLicenseCertContext = NULL;
    LPTSTR pszSPK = NULL;

    if(hCryptProv == NULL || pbSPK == NULL || cbSPK == 0)
    {
        dwStatus = ERROR_INVALID_PARAMETER;
        goto cleanup;
    }
    
    //
    // Verify SPK, current SPK is base 24 encoded string
    //
    pszSPK = (LPTSTR)AllocateMemory(cbSPK + sizeof(TCHAR));
    if(pszSPK == NULL)
    {
        dwStatus = TLS_E_ALLOCATE_MEMORY;
        goto cleanup;
    }
     
    memcpy(
            pszSPK,
            pbSPK,
            cbSPK
        );

    //
    // Verify SPK
    //
    dwVerifyResult = LKPLITE_SPK_VALID;
    dwStatus = LKPLiteVerifySPK(
                            g_pszServerPid,
                            pszSPK,
                            &dwVerifyResult
                        );

    if(dwStatus != ERROR_SUCCESS || dwVerifyResult != LKPLITE_SPK_VALID)
    {
        if(dwVerifyResult == LKPLITE_SPK_INVALID)
        {
            dwStatus = TLS_E_INVALID_SPK;
        }
        else if(dwVerifyResult == LKPLITE_SPK_INVALID_SIGN)
        {
            dwStatus = TLS_E_SPK_INVALID_SIGN;
        }

        goto cleanup;
    }

    //
    // Write SPK to LSA
    //
    dwStatus = ServerIdsToLsaServerId(
                            (PBYTE)g_pszServerUniqueId,
                            g_cbServerUniqueId,
                            (PBYTE)g_pszServerPid,
                            g_cbServerPid,
                            pbSPK,
                            cbSPK,
                            pCertExtensions,
                            dwNumExtensions,
                            &pbLsaServerId,
                            &cbLsaServerId
                        );

    if(dwStatus != ERROR_SUCCESS)
    {
        goto cleanup;
    }

    //
    // Save data to LSA
    //
    dwStatus = StoreKey(
                        LSERVER_LSA_LSERVERID,
                        (PBYTE) pbLsaServerId,
                        cbLsaServerId
                    );

    if(dwStatus != ERROR_SUCCESS)
    {
        goto cleanup;
    }

    //
    // Re-generate our certificatge
    //
    dwStatus = TLSCreateSelfSignCertificate(
                                hCryptProv,
                                AT_SIGNATURE, 
                                pbSPK,
                                cbSPK,
                                dwNumExtensions,
                                pCertExtensions,
                                &cbSignCert, 
                                &pbSignCert
                            );

    if(dwStatus != ERROR_SUCCESS)
    {
        goto cleanup;
    }

    hLicenseCertContext = CertCreateCertificateContext(
                                        X509_ASN_ENCODING,
                                        pbSignCert,
                                        cbSignCert
                                    );

    if( hLicenseCertContext == NULL )
    {
        dwStatus = GetLastError();
        goto cleanup;
    }

    dwStatus = TLSCreateSelfSignCertificate(
                                hCryptProv,
                                AT_KEYEXCHANGE, 
                                pbSPK,
                                cbSPK,
                                dwNumExtensions,
                                pCertExtensions,
                                &cbExchCert, 
                                &pbExchCert
                            );
    if(dwStatus != ERROR_SUCCESS)
    {
        goto cleanup;
    }

    //
    // Certificate generated is Perm. self-signed certificate,
    // don't store in registry.
    //

    //
    // Make a copy of SPK
    //
    g_pbServerSPK = (PBYTE)AllocateMemory(cbSPK);
    if(g_pbServerSPK == NULL)
    {
        dwStatus = GetLastError();
        goto cleanup;
    }

    memcpy(
            g_pbServerSPK,
            pbSPK,
            cbSPK
        );

    g_cbServerSPK = cbSPK;


    if( g_SelfSignCertContext != NULL )
    {
        CertFreeCertificateContext(g_SelfSignCertContext);
    }

    g_SelfSignCertContext = CertDuplicateCertificateContext(hLicenseCertContext);
    if( g_SelfSignCertContext == NULL )
    {
        TLSASSERT( g_SelfSignCertContext != NULL ); 
        dwStatus = GetLastError();
        goto cleanup;
    }

    //
    // Everything is OK, switch to new certificate
    //
    FreeMemory(g_pbSignatureEncodedCert);
    g_pbSignatureEncodedCert = pbSignCert;
    g_cbSignatureEncodedCert = cbSignCert;

    if(g_LicenseCertContext != NULL)
    {
        CertFreeCertificateContext(g_LicenseCertContext);
    }

    //
    // use duplicate instead of direct assign
    //
    g_LicenseCertContext = CertDuplicateCertificateContext(hLicenseCertContext);
    TLSASSERT(g_LicenseCertContext != NULL);                                                   

    FreeMemory(g_pbExchangeEncodedCert);
    g_pbExchangeEncodedCert = pbExchCert;
    g_cbExchangeEncodedCert = cbExchCert;

    pbSignCert = NULL;
    pbExchCert = NULL;

    //
    // Mark we have Perm. self-signed cert.
    //
    g_bHasHydraCert = FALSE;

cleanup:

    if( hLicenseCertContext != NULL )
    {
        CertFreeCertificateContext( hLicenseCertContext );
    }

    FreeMemory(pszSPK);
    FreeMemory(pbLsaServerId);
    FreeMemory(pbSignCert);
    FreeMemory(pbExchCert);

    return dwStatus;
}

//------------------------------------------------
void
CleanSetupLicenseServer()
/*++

--*/
{
    DWORD dwStatus;
    
    //
    // Wipe out SPK in LSA
    //
    dwStatus = StoreKey(
                    LSERVER_LSA_LSERVERID,
                    (PBYTE) NULL,
                    0
                );

    dwStatus = StoreKey(
                    LSERVER_LSA_LASTRUN, 
                    (PBYTE) NULL,
                    0
                );

    dwStatus = StoreKey(
                    LSERVER_LSA_PRIVATEKEY_EXCHANGE, 
                    (PBYTE) NULL,
                    0
                );


    dwStatus = StoreKey(
                    LSERVER_LSA_PRIVATEKEY_SIGNATURE, 
                    (PBYTE) NULL,
                    0
                );

    dwStatus = TLSUninstallLsCertificate();

    return;
}




//-----------------------------------------------
//
//
DWORD
TLSStartupLSDB(
    IN BOOL bCheckDBStatus,
    IN DWORD dwMaxDbHandles,
    IN BOOL bStartEmptyIfError,
    IN BOOL bLogWarning,
    IN LPTSTR pszChkPointDirPath,
    IN LPTSTR pszTempDirPath,
    IN LPTSTR pszLogDirPath,
    IN LPTSTR pszDbFile,
    IN LPTSTR pszUserName,
    IN LPTSTR pszPassword
    )
/*++

Abstract:

    Initialize License Server's DB workspace handle list.


Parameters:

    pszChkPointDirPath : ESE check point directory.
    pszTempDirPath : ESE temp. directory.
    pszLogDirPath : ESE log file directory.
    pszDbPath : License Server database file path.
    pszDbFile : License Server database file name (no path).
    pszUserName : Database file user name.
    pszPassword : Database file password.

Returns:

    ERROR_SUCCESS or error code.

--*/
{
    BOOL bSuccess = TRUE;
    DWORD status = ERROR_SUCCESS;
    BOOL bEmptyDatabase = FALSE;
    BOOL bRemoveAvailableLicense = FALSE;
      
    if( __TlsDbWorkSpace::g_JbInstance.IsValid() == FALSE )
    { 
        //
        // Initialize Jet Instance
        //
        bSuccess = TLSJbInstanceInit(
                                __TlsDbWorkSpace::g_JbInstance,
                                pszChkPointDirPath, 
                                pszTempDirPath,
                                pszLogDirPath
                            );
        if(bSuccess == FALSE)
        {
            status = GetLastError();
            TLSASSERT(FALSE);
            goto cleanup;
        }
    }

    //
    // Upgrade the database
    //
    status = TLSUpgradeDatabase(
                            __TlsDbWorkSpace::g_JbInstance,
                            pszDbFile, 
                            pszUserName, 
                            pszPassword
                        );

    
    if( status == TLS_E_BETADATABSE ||
        status == TLS_E_INCOMPATIBLEDATABSE ||
        (TLS_ERROR(status) == TRUE && bStartEmptyIfError == TRUE) )
    {
        if(status == TLS_E_BETADATABSE)
        {
            CleanSetupLicenseServer();
        }

        //
        // bad database, try to save a copy of it and 
        // restart from scratch
        //
        TLSLogInfoEvent(status);

        TCHAR szTmpFileName[2*MAX_PATH+1];

        bSuccess = TLSGenerateLSDBBackupFileName(
                                    pszTempDirPath,
                                    szTmpFileName
                                    );

        if (bSuccess)
        {
            bSuccess = MoveFileEx(
                                  pszDbFile, 
                                  szTmpFileName, 
                                  MOVEFILE_REPLACE_EXISTING | MOVEFILE_COPY_ALLOWED
                                  );
        }

        if(bSuccess == TRUE)
        {
            LPCTSTR pString[1];

            pString[0] = szTmpFileName;
            TLSLogEventString(
                    EVENTLOG_INFORMATION_TYPE,
                    TLS_I_RENAME_DBFILE,
                    sizeof(pString)/sizeof(pString[0]),
                    pString
                );

            status = TLSUpgradeDatabase(
                                    __TlsDbWorkSpace::g_JbInstance,
                                    pszDbFile, 
                                    pszUserName, 
                                    pszPassword
                                );
        }
        else
        {
            //
            // Can't rename this file, log an error and exit.
            //
            LPCTSTR pString[1];

            pString[0] = pszDbFile;
            TLSLogEventString(
                    EVENTLOG_ERROR_TYPE,
                    TLS_E_RENAME_DBFILE,
                    sizeof(pString)/sizeof(pString[0]),
                    pString
                );

            status = TLS_E_RENAME_DBFILE;
        }                                    
    }

    if(TLS_ERROR(status) == TRUE)
    {
        goto cleanup;
    }

    if(status == TLS_I_CREATE_EMPTYDATABASE)
    {
        // we startup from scratch, ignore ID checking
        bEmptyDatabase = TRUE;
    }
    else if(status == TLS_W_NOTOWNER_DATABASE)
    {
        #if ENFORCE_LICENSING
        // not owner of database or database version mismatch, we need to kill all the 
        // available licenses
        bRemoveAvailableLicense = TRUE;
        #endif
    }

    status = ERROR_SUCCESS;

    //
    // Allocate one handle to verify database
    //
    bSuccess = InitializeWorkSpacePool(
                                    1, 
                                    pszDbFile, 
                                    pszUserName, 
                                    pszPassword, 
                                    pszChkPointDirPath, 
                                    pszTempDirPath,
                                    pszLogDirPath,
                                    TRUE
                                );
    if(bSuccess == FALSE)
    {
        status = GetLastError();
        TLSASSERT(FALSE);
        goto cleanup;
    }

    if((g_DbWorkSpace = AllocateWorkSpace(g_GeneralDbTimeout)) == NULL)
    {

        TLSLogEvent(
                EVENTLOG_ERROR_TYPE,
                TLS_E_SERVICEINIT,
                status = TLS_E_ALLOCATE_HANDLE
            );

        goto cleanup;
    }

    //
    // Initialize next keypack id and license id
    //
    if(TLSDBGetMaxKeyPackId(g_DbWorkSpace, (DWORD *)&g_NextKeyPackId) == FALSE)
    {
        status=GetLastError();

        if(IS_JB_ERROR(status))
        {
            LPTSTR pString = NULL;
            
            TLSGetESEError(
                        GET_JB_ERROR_CODE(status), 
                        &pString
                    );

            TLSLogEvent(
                    EVENTLOG_ERROR_TYPE,
                    TLS_E_SERVICEINIT,
                    TLS_E_JB_BASE,
                    GET_JB_ERROR_CODE(status),
                    (pString != NULL) ? pString : _TEXT("")
                );

            if(pString != NULL)
            {
                LocalFree(pString);
            }
        }
        else
        {
            TLSLogEvent(
                    EVENTLOG_ERROR_TYPE,
                    TLS_E_SERVICEINIT,
                    status
                );
        }

        goto cleanup;
    }

    if(!TLSDBGetMaxLicenseId(g_DbWorkSpace, (DWORD *)&g_NextLicenseId))
    {
        status=GetLastError();

        if(IS_JB_ERROR(status))
        {
            LPTSTR pString = NULL;
            
            TLSGetESEError(
                        GET_JB_ERROR_CODE(status), 
                        &pString
                    );

            TLSLogEvent(
                    EVENTLOG_ERROR_TYPE,
                    TLS_E_SERVICEINIT,
                    TLS_E_JB_BASE,
                    GET_JB_ERROR_CODE(status),
                    (pString != NULL) ? pString : _TEXT("")
                );

            if(pString != NULL)
            {
                LocalFree(pString);
            }
        }
        else
        {
            TLSLogEvent(
                    EVENTLOG_ERROR_TYPE,
                    TLS_E_SERVICEINIT,
                    status
                );
        }

        goto cleanup;
    }

    DBGPrintf(
            DBG_INFORMATION,
            DBG_FACILITY_INIT,
            DBGLEVEL_FUNCTION_DETAILSIMPLE,
            _TEXT("Next KeyPack ID - %d, Next License ID - %d\n"),
            g_NextKeyPackId,
            g_NextLicenseId
        );

    //
    // Verify database status with last run status
    //
    {
        LPTLServerLastRun lpLastRun = NULL;
        DWORD   cbByte=0;
        PBYTE   pbByte=NULL;

        status = RetrieveKey(
                        LSERVER_LSA_LASTRUN, 
                        &pbByte, 
                        &cbByte
                    );

        lpLastRun = (LPTLServerLastRun)pbByte;

        if( status == ERROR_SUCCESS && lpLastRun != NULL )
        {
            DBGPrintf(
                    DBG_INFORMATION,
                    DBG_FACILITY_INIT,
                    DBGLEVEL_FUNCTION_DETAILSIMPLE,
                    _TEXT("Last run status : Next KeyPack ID - %d, Next License ID - %d\n"),
                    lpLastRun->dwMaxKeyPackId,
                    lpLastRun->dwMaxLicenseId
                );

            //
            // Verify no 'copy' database
            //
            if( bCheckDBStatus == TRUE && 
                bEmptyDatabase == FALSE &&
                bRemoveAvailableLicense == FALSE &&
                lpLastRun->dwMaxKeyPackId != 0 &&
                lpLastRun->dwMaxLicenseId != 0 )
            {
                // enforce version will remove all available licenses
                #if ENFORCE_LICENSING 

                if( lpLastRun->dwMaxKeyPackId != g_NextKeyPackId || 
                    lpLastRun->dwMaxLicenseId != g_NextLicenseId)
                {
                    TLSLogWarningEvent(TLS_W_INCONSISTENT_STATUS);
                    bRemoveAvailableLicense = TRUE;
                }

                #endif                            
            }
            else
            {
                g_ftLastShutdownTime = lpLastRun->ftLastShutdownTime;
            }
        }

        if(pbByte)
        {
            LocalFree(pbByte);
        }

        //
        // overwrite last run status to 0 so if we crash, 
        // check won't get kick it
        //
        TLServerLastRun LastRun;

        memset(&LastRun, 0, sizeof(LastRun));
        LastRun.ftLastShutdownTime = g_ftLastShutdownTime;
        StoreKey(
                LSERVER_LSA_LASTRUN, 
                (PBYTE)&LastRun, 
                sizeof(TLServerLastRun)
            );
    }

    g_NextKeyPackId++;
    g_NextLicenseId++;

    // 
    // remove available licenses
    if(bRemoveAvailableLicense == TRUE)
    {
        status = TLSRemoveLicensesFromInvalidDatabase(
                                        g_DbWorkSpace
                                    );

        if(status != ERROR_SUCCESS)
        {
            goto cleanup;
        }
    }
        
    // 
    // Insert a keypack for Terminal Service Certificate.
    //
    status = TLSAddTermServCertificatePack(g_DbWorkSpace, bLogWarning);
    if(status != ERROR_SUCCESS && status != TLS_E_DUPLICATE_RECORD)
    {
        TLSLogEvent(
                EVENTLOG_ERROR_TYPE,
                TLS_E_SERVICEINIT,
                status = TLS_E_UPGRADE_DATABASE
            );

        goto cleanup;
    }


    //
    // Allocate rest of the workspace handle
    //
    bSuccess = InitializeWorkSpacePool(
                                    dwMaxDbHandles, 
                                    pszDbFile, 
                                    pszUserName, 
                                    pszPassword, 
                                    NULL,
                                    NULL,
                                    NULL,
                                    FALSE
                                );

    //
    if(bSuccess == FALSE && GetNumberOfWorkSpaceHandle() < DB_MIN_HANDLE_NEEDED)
    {
        status = GetLastError();
    }

    // This is a temporary workaround to change keypack version in the database from 5.1 to 5.2 to accomodate for
    // Beta 3 and interim builds of LS. Only in the absence of Registry key we will convert the 5.1 keypacks to 5.2

    HKEY hKey = NULL;
    status = RegOpenKeyEx(HKEY_LOCAL_MACHINE, WHISTLER_CAL, 0,
                            KEY_ALL_ACCESS, &hKey);

    if (status == ERROR_SUCCESS)
    {            
        RegCloseKey(hKey);
    }
    else
    {
        status = UpgradeKeyPackVersion(g_DbWorkSpace);
    }

cleanup:

    return status;
}

///////////////////////////////////////////////////////////////
DWORD
TLSStartLSDbWorkspaceEngine(
    BOOL bChkDbStatus,
    BOOL bIgnoreRestoreFile,
    BOOL bIgnoreFileTimeChk,
    BOOL bLogWarning
    )
/*++

bChkDbStatus : Match next LKP ID and License ID with LSA
bIgnoreRestoreFile : FALSE if try to open DB file under EXPORT, TRUE otherwise
bLogWarning : TRUE if log low license count warning, FALSE otherwise.
              note, this parameter is ignore in enforce build.

--*/
{
    TCHAR szDbRestoreFile[MAX_PATH+1];
    WIN32_FIND_DATA RestoreFileAttr;
    WIN32_FIND_DATA LsDbFileAttr;
    BOOL bSuccess = TRUE;
    DWORD dwStatus = ERROR_SUCCESS;

    TCHAR szDbBackupFile[MAX_PATH+1];
    TCHAR szDbRestoreTmpFile[MAX_PATH+1];

    if(bIgnoreRestoreFile == TRUE)
    {
        DBGPrintf(
                DBG_INFORMATION,
                DBG_FACILITY_INIT,
                DBGLEVEL_FUNCTION_DETAILSIMPLE,
                _TEXT("Ignore restore file\n")
            );
        
        goto open_existing;
    }


    //----------------------------------------------------------
    //
    // Check database file in the export directory.
    //
    //----------------------------------------------------------
    if(MAX_PATH < (_tcslen(g_szDatabaseDir)+_tcslen(TLSBACKUP_EXPORT_DIR)+ _tcslen(g_szDatabaseFname) + 1))
    {
        dwStatus = E_OUTOFMEMORY;
        goto open_existing;
    }
    _tcscpy(szDbRestoreFile, g_szDatabaseDir);
    _tcscat(szDbRestoreFile, TLSBACKUP_EXPORT_DIR);
    _tcscat(szDbRestoreFile, _TEXT("\\"));
    _tcscat(szDbRestoreFile, g_szDatabaseFname);

    bSuccess = FileExists(
                        szDbRestoreFile, 
                        &RestoreFileAttr
                    );

    if(bSuccess == FALSE)
    {
        goto open_existing;
    }

    bSuccess = FileExists(
                        g_szDatabaseFile, 
                        &LsDbFileAttr
                    );

    if(bSuccess == FALSE)
    {

        DBGPrintf(
                DBG_INFORMATION,
                DBG_FACILITY_INIT,
                DBGLEVEL_FUNCTION_DETAILSIMPLE,
                _TEXT("No existing database file, use restored file...\n")
            );

        //
        // Database file does not exist, move the restored file over and open it.
        //
        bSuccess = MoveFileEx(
                            szDbRestoreFile, 
                            g_szDatabaseFile, 
                            MOVEFILE_REPLACE_EXISTING | MOVEFILE_WRITE_THROUGH
                        );

        if(bSuccess == FALSE)
        {

            DBGPrintf(
                    DBG_INFORMATION,
                    DBG_FACILITY_INIT,
                    DBGLEVEL_FUNCTION_DETAILSIMPLE,
                    _TEXT("Failed to move restore to existing db file - %d\n"),
                    GetLastError()
                );

            // can't move restore file, don't use the restore file, 
            // startup with empty database
            dwStatus = GetLastError();

            LPCTSTR pString[1];
            pString[0] = szDbRestoreFile;

            TLSLogEventString(
                    EVENTLOG_WARNING_TYPE,
                    TLS_E_DBRESTORE_MOVEFILE,
                    1,
                    pString
                );
        }
        else
        {
            TLSLogInfoEvent(TLS_I_USE_DBRESTOREFILE);
        }

        #if DBG
        EnsureExclusiveAccessToDbFile( g_szDatabaseFile );
        #endif

        goto open_existing;
    }

    //
    // Compare file's last modification time, if existing database file is newer 
    // than restore one, log event and continue opening existing file
    //
    if( bIgnoreFileTimeChk == FALSE )
    {
        if(CompareFileTime(&(RestoreFileAttr.ftLastWriteTime), &(LsDbFileAttr.ftLastWriteTime)) <= 0 )
        {
            DBGPrintf(
                DBG_INFORMATION,
                DBG_FACILITY_INIT,
                DBGLEVEL_FUNCTION_DETAILSIMPLE,
                _TEXT("Restore file is too old...\n"),
                GetLastError()
            );

            //TLSLogInfoEvent(TLS_I_DBRESTORE_OLD);
            goto open_existing;
        }
    }

    //
    // make a backup copy of existing database file.
    //
    bSuccess = TLSGenerateLSDBBackupFileName(
                            g_szDatabaseDir,
                            szDbBackupFile
                        );

    if (bSuccess)
    {
        DBGPrintf(
                  DBG_INFORMATION,
                  DBG_FACILITY_INIT,
                  DBGLEVEL_FUNCTION_DETAILSIMPLE,
                  _TEXT("Existing database file has been backup to %s\n"),
                  szDbBackupFile
                  );
    
        bSuccess = MoveFileEx(
                              g_szDatabaseFile, 
                              szDbBackupFile,
                              MOVEFILE_REPLACE_EXISTING | MOVEFILE_WRITE_THROUGH
                              );
    }

    if(bSuccess == FALSE)
    {
        DBGPrintf(
                DBG_INFORMATION,
                DBG_FACILITY_INIT,
                DBGLEVEL_FUNCTION_DETAILSIMPLE,
                _TEXT("Failed to backup existing database file - %d\n"),
                GetLastError()
            );


        //
        // Can't save a copy of existing database file
        // Log an error and continue to open using existing database
        //
        LPCTSTR pString[1];

        pString[0] = g_szDatabaseFile;
        
        TLSLogEventString(
                    EVENTLOG_WARNING_TYPE,
                    TLS_W_DBRESTORE_SAVEEXISTING,
                    1,
                    pString
                );

        goto open_existing;
    }

    //
    // Rename restore file and then try to open the restore file.
    //
    bSuccess = MoveFileEx(
                        szDbRestoreFile,
                        g_szDatabaseFile,
                        MOVEFILE_REPLACE_EXISTING | MOVEFILE_WRITE_THROUGH
                    );

    if(bSuccess == TRUE)
    {
        #if DBG
        EnsureExclusiveAccessToDbFile( g_szDatabaseFile );
        #endif

        //
        // Open the restore database file
        //
        dwStatus = TLSStartupLSDB(
                            bChkDbStatus,
                            g_dwMaxDbHandles,
                            FALSE,
                            bLogWarning,
                            g_szDatabaseDir,
                            g_szDatabaseDir,
                            g_szDatabaseDir,
                            g_szDatabaseFile,
                            g_szDbUser,
                            g_szDbPwd
                        );

        if(dwStatus == ERROR_SUCCESS)
        {
            //
            // Log event indicating we open the restore file, existing 
            // database file has been saved as ...
            //
            LPCTSTR pString[1];

            pString[0] = szDbBackupFile;
            
            TLSLogEventString(
                            EVENTLOG_INFORMATION_TYPE,
                            TLS_I_OPENRESTOREDBFILE,
                            1,
                            pString
                        );

            return dwStatus;
        }
    }
            
    //
    // Can't open the restore db file or MoveFileEx() failed
    //
    bSuccess = TLSGenerateLSDBBackupFileName(
                        g_szDatabaseDir,
                        szDbRestoreTmpFile
                        );

    if (bSuccess)
    {
        DBGPrintf(
                  DBG_INFORMATION,
                  DBG_FACILITY_INIT,
                  DBGLEVEL_FUNCTION_DETAILSIMPLE,
                  _TEXT("Backup restore file to %s\n"),
                  szDbRestoreTmpFile
                  );

        bSuccess = MoveFileEx(
                        g_szDatabaseFile,
                        szDbRestoreTmpFile,
                        MOVEFILE_REPLACE_EXISTING | MOVEFILE_WRITE_THROUGH
                        );
    }

    if(bSuccess == FALSE)
    {
        // failed to backup restore db file, delete it
        bSuccess = DeleteFile(g_szDatabaseFile);
        TLSLogErrorEvent(TLS_E_RESTOREDBFILE_OPENFAIL);
    }
    else
    {
        LPCTSTR pString[1];
        
        pString[0] = szDbRestoreTmpFile;
        TLSLogEventString(
                        EVENTLOG_ERROR_TYPE,
                        TLS_E_RESTOREDBFILE_OPENFAIL_SAVED,
                        1,
                        pString
                    );
    }

    DBGPrintf(
            DBG_INFORMATION,
            DBG_FACILITY_INIT,
            DBGLEVEL_FUNCTION_DETAILSIMPLE,
            _TEXT("Restore original database file %s to %s\n"),
            szDbBackupFile,
            g_szDatabaseFile
        );

    //
    // Restore the existing database file
    //
    bSuccess = MoveFileEx(
                        szDbBackupFile,
                        g_szDatabaseFile,
                        MOVEFILE_REPLACE_EXISTING | MOVEFILE_WRITE_THROUGH
                    );

    if(bSuccess == FALSE)
    {
        DBGPrintf(
                DBG_INFORMATION,
                DBG_FACILITY_INIT,
                DBGLEVEL_FUNCTION_DETAILSIMPLE,
                _TEXT("failed to restore original DB file - %d\n"),
                GetLastError()
            );

        TLSASSERT(FALSE);
        // this is really bad, continue with empty database file.
    }

    #if DBG
    EnsureExclusiveAccessToDbFile( g_szDatabaseFile );
    #endif

open_existing:

    return TLSStartupLSDB(
                    bChkDbStatus,
                    g_dwMaxDbHandles,
                    TRUE,
                    bLogWarning,    
                    g_szDatabaseDir,
                    g_szDatabaseDir,
                    g_szDatabaseDir,
                    g_szDatabaseFile,
                    g_szDbUser,
                    g_szDbPwd
                );
}

///////////////////////////////////////////////////////////////
DWORD
TLSLoadRuntimeParameters()
/*++


--*/
{
    HKEY hKey = NULL;
    DWORD dwStatus = ERROR_SUCCESS;
    DWORD dwKeyType;
    TCHAR szDbPath[MAX_PATH+1];;
    TCHAR szDbFileName[MAX_PATH+1];
    DWORD dwBuffer;

    DWORD cbByte = 0;
    PBYTE pbByte = NULL;


    //-------------------------------------------------------------------
    //
    // Open HKLM\system\currentcontrolset\sevices\termservlicensing\parameters
    //
    //-------------------------------------------------------------------
    dwStatus =RegCreateKeyEx(
                        HKEY_LOCAL_MACHINE,
                        LSERVER_REGISTRY_BASE _TEXT(SZSERVICENAME) _TEXT("\\") LSERVER_PARAMETERS,
                        0,
                        NULL,
                        REG_OPTION_NON_VOLATILE,
                        KEY_ALL_ACCESS,
                        NULL,
                        &hKey,
                        NULL
                    );

    if(dwStatus != ERROR_SUCCESS)
    {
        TLSLogEvent(
                EVENTLOG_ERROR_TYPE,
                TLS_E_SERVICEINIT,
                TLS_E_ACCESS_REGISTRY,
                dwStatus
            );

        dwStatus = TLS_E_INIT_GENERAL;
        goto cleanup;
    }

    
    //-------------------------------------------------------------------
    //
    // Get database file location and file name
    //
    //-------------------------------------------------------------------
    dwBuffer = sizeof(szDbPath) / sizeof(szDbPath[0]);

    dwStatus = RegQueryValueEx(
                        hKey,
                        LSERVER_PARAMETERS_DBPATH,
                        NULL,
                        NULL,
                        (LPBYTE)szDbPath,
                        &dwBuffer
                    );
    if(dwStatus != ERROR_SUCCESS)
    {
        //
        // need to startup so use default value, 
        //
        _tcscpy(
                szDbPath,
                LSERVER_DEFAULT_DBPATH
            );
    }

    //
    // Get database file name
    //
    dwBuffer = sizeof(szDbFileName) / sizeof(szDbFileName[0]);
    dwStatus = RegQueryValueEx(
                        hKey,
                        LSERVER_PARAMETERS_DBFILE,
                        NULL,
                        NULL,
                        (LPBYTE)szDbFileName,
                        &dwBuffer
                    );
    if(dwStatus != ERROR_SUCCESS)
    {
        //
        // Use default value.
        //
        _tcscpy(
                szDbFileName,
                LSERVER_DEFAULT_EDB
            );
    }

    _tcscpy(g_szDatabaseFname, szDbFileName);


    //
    // Always expand DB Path.
    //
    
    dwStatus = ExpandEnvironmentStrings(
                        szDbPath,
                        g_szDatabaseDir,
                        sizeof(g_szDatabaseDir) / sizeof(g_szDatabaseDir[0])
                    );

    if(dwStatus == 0)
    {
        // can't expand environment variable, error out.

        TLSLogEvent(
                EVENTLOG_ERROR_TYPE,
                TLS_E_SERVICEINIT,
                TLS_E_LOCALDATABASEFILE,
                dwStatus = GetLastError()
            );

        goto cleanup;
    }        

    if(g_szDatabaseDir[_tcslen(g_szDatabaseDir) - 1] != _TEXT('\\'))
    {
        // JetBlue needs this.
        _tcscat(g_szDatabaseDir, _TEXT("\\"));
    } 

    //
    // Full path to database file
    //
    _tcscpy(g_szDatabaseFile, g_szDatabaseDir);
    _tcscat(g_szDatabaseFile, szDbFileName);


    //
    // Database file user and password
    //
    dwBuffer = sizeof(g_szDbUser) / sizeof(g_szDbUser[0]);
    dwStatus = RegQueryValueEx(
                        hKey,
                        LSERVER_PARAMETERS_USER,
                        NULL,
                        NULL,
                        (LPBYTE)g_szDbUser,
                        &dwBuffer
                    );

    // password is rendomly generated
    dwStatus = RetrieveKey(
                    LSERVER_LSA_PASSWORD_KEYNAME, 
                    &pbByte, 
                    &cbByte
                );

    // backward compatibilty
    if(dwStatus != ERROR_SUCCESS)
    {
        //
        // Load password from registry or default to 'default' password
        //
        dwBuffer = sizeof(g_szDbPwd) / sizeof(g_szDbPwd[0]);
        dwStatus = RegQueryValueEx(
                            hKey,
                            LSERVER_PARAMETERS_PWD,
                            NULL,
                            NULL,
                            (LPBYTE)g_szDbPwd,
                            &dwBuffer
                        );
    }
    else
    {
        //
        // save info into global variable
        //
        memset(g_szDbPwd, 0, sizeof(g_szDbPwd));
        memcpy((PBYTE)g_szDbPwd, pbByte, min(cbByte, sizeof(g_szDbPwd)));

    }

    if(pbByte != NULL)
    {
        LocalFree(pbByte);
    }

    //--------------------------------------------------------------------
    //
    // Work Object Parameters
    //
    //--------------------------------------------------------------------

    dwBuffer = sizeof(g_dwTlsJobInterval);

    dwStatus = RegQueryValueEx(
                        hKey,
                        LSERVER_PARAMETERS_WORKINTERVAL,
                        NULL,
                        NULL,
                        (LPBYTE)&g_dwTlsJobInterval,
                        &dwBuffer
                    );

    if(dwStatus != ERROR_SUCCESS)
    {
        g_dwTlsJobInterval = DEFAULT_JOB_INTERVAL;
    }                

    dwBuffer = sizeof(g_dwTlsJobRetryTimes);
    dwStatus = RegQueryValueEx(
                        hKey,
                        LSERVER_PARAMETERS_RETRYTIMES,
                        NULL,
                        NULL,
                        (LPBYTE)&g_dwTlsJobRetryTimes,
                        &dwBuffer
                    );

    if(dwStatus != ERROR_SUCCESS)
    {
        g_dwTlsJobRetryTimes = DEFAULT_JOB_RETRYTIMES;
    }                


    dwBuffer=sizeof(g_dwTlsJobRestartTime);
    dwStatus = RegQueryValueEx(
                        hKey,
                        LSERVER_PARAMETERS_WORKRESTART,
                        NULL,
                        NULL,
                        (LPBYTE)&g_dwTlsJobRestartTime,
                        &dwBuffer
                    );

    if(dwStatus != ERROR_SUCCESS)
    {
        g_dwTlsJobRestartTime = DEFAULT_JOB_INTERVAL;
    }                


    //---------------------------------------------------
    //
    // load low license warning count
    //
    //---------------------------------------------------
    dwBuffer = sizeof(g_LowLicenseCountWarning);
    dwStatus = RegQueryValueEx(
                            hKey,
                            LSERVER_PARAMETERS_LOWLICENSEWARNING,
                            NULL,
                            &dwKeyType,
                            NULL,
                            &dwBuffer
                        );

    if(dwStatus == ERROR_SUCCESS && dwKeyType == REG_DWORD)
    {
        dwStatus = RegQueryValueEx(
                            hKey,
                            LSERVER_PARAMETERS_LOWLICENSEWARNING,
                            NULL,
                            &dwKeyType,
                            (LPBYTE)&g_LowLicenseCountWarning,
                            &dwBuffer
                        );
    }
                      
    //---------------------------------------------------
    //
    // Temp. license grace period
    //
    //---------------------------------------------------
    dwBuffer = sizeof(g_GracePeriod);
    dwStatus = RegQueryValueEx(
                            hKey,
                            LSERVER_PARAMETERS_GRACEPERIOD,
                            NULL,
                            &dwKeyType,
                            NULL,
                            &dwBuffer
                        );
    if(dwStatus == ERROR_SUCCESS && dwKeyType == REG_DWORD)
    {
        dwStatus = RegQueryValueEx(
                            hKey,
                            LSERVER_PARAMETERS_GRACEPERIOD,
                            NULL,
                            &dwKeyType,
                            (LPBYTE)&g_GracePeriod,
                            &dwBuffer
                        );
    }

    if(g_GracePeriod > GRACE_PERIOD)
    {
        // grace period can be greated than this.
        g_GracePeriod = GRACE_PERIOD;
    }

    //
    // Are we allow to issue temp. license
    //
    dwBuffer = sizeof(g_IssueTemporayLicense);
    dwStatus = RegQueryValueEx(
                            hKey,
                            LSERVER_PARAMETERS_ISSUETEMPLICENSE,
                            NULL,
                            &dwKeyType,
                            NULL,
                            &dwBuffer
                        );

    if(dwStatus == ERROR_SUCCESS && dwKeyType == REG_DWORD)
    {
        dwStatus = RegQueryValueEx(
                            hKey,
                            LSERVER_PARAMETERS_ISSUETEMPLICENSE,
                            NULL,
                            &dwKeyType,
                            (LPBYTE)&g_IssueTemporayLicense,
                            &dwBuffer
                        );
    }

    //------------------------------------------------------
    //
    // Timeout value if can't allocate a DB handle
    //
    //------------------------------------------------------

    //
    // Timeout for allocating a write handle
    //
    dwBuffer = sizeof(g_GeneralDbTimeout);
    dwStatus = RegQueryValueEx(
                            hKey,
                            LSERVER_PARAMETERS_DBTIMEOUT,
                            NULL,
                            &dwKeyType,
                            NULL,
                            &dwBuffer
                        );

    if(dwStatus == ERROR_SUCCESS && dwKeyType == REG_DWORD)
    {
        dwStatus = RegQueryValueEx(
                            hKey,
                            LSERVER_PARAMETERS_DBTIMEOUT,
                            NULL,
                            &dwKeyType,
                            (LPBYTE)&g_GeneralDbTimeout,
                            &dwBuffer
                        );
    }

    //
    // Timeout for read handle
    //
    dwBuffer = sizeof(g_EnumDbTimeout);
    dwStatus = RegQueryValueEx(
                            hKey,
                            LSERVER_PARAMETERS_EDBTIMEOUT,
                            NULL,
                            &dwKeyType,
                            NULL,
                            &dwBuffer
                        );

    if(dwStatus == ERROR_SUCCESS && dwKeyType == REG_DWORD)
    {
        dwStatus = RegQueryValueEx(
                            hKey,
                            LSERVER_PARAMETERS_EDBTIMEOUT,
                            NULL,
                            &dwKeyType,
                            (LPBYTE)&g_EnumDbTimeout,
                            &dwBuffer
                        );
    }

    //------------------------------------------------------
    //
    // Number of database handles
    //
    //------------------------------------------------------
    dwBuffer = sizeof(g_dwMaxDbHandles);
    dwStatus = RegQueryValueEx(
                            hKey,
                            LSERVER_PARAMETERS_MAXDBHANDLES,
                            NULL,
                            &dwKeyType,
                            NULL,
                            &dwBuffer
                        );

    if(dwStatus == ERROR_SUCCESS && dwKeyType == REG_DWORD)
    {
        dwStatus = RegQueryValueEx(
                            hKey,
                            LSERVER_PARAMETERS_MAXDBHANDLES,
                            NULL,
                            &dwKeyType,
                            (LPBYTE)&g_dwMaxDbHandles,
                            &dwBuffer
                        );

        if(g_dwMaxDbHandles > DB_MAX_CONNECTIONS-1)
        {
            g_dwMaxDbHandles = DEFAULT_DB_CONNECTIONS;
        }
    }

    //------------------------------------------------------
    // 
    // Load parameters for ESENT, all parameter must be set
    // and confirm to ESENT document, any error, we just 
    // revert back to some value we know it works.
    //
    //------------------------------------------------------
    dwBuffer = sizeof(g_EsentMaxCacheSize);
    dwStatus = RegQueryValueEx(
                        hKey,
                        LSERVER_PARAMETERS_ESENTMAXCACHESIZE,
                        NULL,
                        NULL,
                        (LPBYTE)&g_EsentMaxCacheSize,
                        &dwBuffer
                    );

    if(dwStatus == ERROR_SUCCESS)
    {
        dwBuffer = sizeof(g_EsentStartFlushThreshold);
        dwStatus = RegQueryValueEx(
                            hKey,
                            LSERVER_PARAMETERS_ESENTSTARTFLUSH,
                            NULL,
                            NULL,
                            (LPBYTE)&g_EsentStartFlushThreshold,
                            &dwBuffer
                        );

        if(dwStatus == ERROR_SUCCESS)
        {
            dwBuffer = sizeof(g_EsentStopFlushThreadhold);
            dwStatus = RegQueryValueEx(
                                hKey,
                                LSERVER_PARAMETERS_ESENTSTOPFLUSH,
                                NULL,
                                NULL,
                                (LPBYTE)&g_EsentStopFlushThreadhold,
                                &dwBuffer
                            );
        }
    }
    
    if( dwStatus != ERROR_SUCCESS || 
        g_EsentStartFlushThreshold > g_EsentStopFlushThreadhold ||
        g_EsentStopFlushThreadhold > g_EsentMaxCacheSize ||
        g_EsentMaxCacheSize < LSERVER_PARAMETERS_ESENTMAXCACHESIZE_MIN ||
        g_EsentStartFlushThreshold < LSERVER_PARAMETERS_ESENTSTARTFLUSH_MIN ||
        g_EsentStopFlushThreadhold < LSERVER_PARAMETERS_ESENTSTOPFLUSH_MIN ||
        g_EsentMaxCacheSize > LSERVER_PARAMETERS_ESENTMAXCACHESIZE_MAX ||
        g_EsentStartFlushThreshold > LSERVER_PARAMETERS_ESENTSTARTFLUSH_MAX ||
        g_EsentStopFlushThreadhold > LSERVER_PARAMETERS_ESENTSTOPFLUSH_MAX )
    {
        // pre-define number to let ESENT picks its number
        if( g_EsentMaxCacheSize != LSERVER_PARAMETERS_USE_ESENTDEFAULT )
        {
            g_EsentMaxCacheSize = LSERVER_PARAMETERS_ESENTMAXCACHESIZE_DEFAULT;
            g_EsentStartFlushThreshold = LSERVER_PARAMETERS_ESENTSTARTFLUSH_DEFAULT;
            g_EsentStopFlushThreadhold = LSERVER_PARAMETERS_ESENTSTOPFLUSH_DEFAULT;
        }
    }

    dwBuffer = sizeof(g_EsentMaxVerPages);
    dwStatus = RegQueryValueEx(
                        hKey,
                        LSERVER_PARAMETERS_ESENTMAXVERPAGES,
                        NULL,
                        NULL,
                        (LPBYTE)&g_EsentMaxVerPages,
                        &dwBuffer
                    );

    if ((dwStatus != ERROR_SUCCESS)
        || (g_EsentMaxVerPages > LSERVER_PARAMETERS_ESENTMAXVERPAGES_MAX)
        || (g_EsentMaxVerPages < LSERVER_PARAMETERS_ESENTMAXVERPAGES_MIN))
    {
        g_EsentMaxVerPages = LSERVER_PARAMETERS_USE_ESENTDEFAULT;
    }

    //------------------------------------------------------
    //
    // Determine role of server in enterprise
    //
    //------------------------------------------------------
    dwBuffer = sizeof(g_SrvRole);
    dwStatus = RegQueryValueEx(
                        hKey,
                        LSERVER_PARAMETERS_ROLE,
                        NULL,
                        NULL,
                        (LPBYTE)&g_SrvRole,
                        &dwBuffer
                    );


    if(g_SrvRole & TLSERVER_ENTERPRISE_SERVER)
    {
        dwBuffer = sizeof(g_szScope)/sizeof(g_szScope[0]);
        memset(g_szScope, 0, sizeof(g_szScope));

        dwStatus = RegQueryValueEx(
                                hKey,
                                LSERVER_PARAMETERS_SCOPE,
                                NULL,
                                &dwKeyType,
                                (LPBYTE)g_szScope,
                                &dwBuffer
                            );

        if(dwStatus != ERROR_SUCCESS)
        {
            // no scope is set, default to local machine name
            // consider using domain name ???
            LoadResourceString(
                            IDS_SCOPE_ENTERPRISE, 
                            g_szScope, 
                            sizeof(g_szScope)/sizeof(g_szScope[0])
                        );
        }

        g_pszScope = g_szScope;
    }
    else
    {
        //
        // Use the workgroup or domain name as scope
        //
        LPWSTR pszScope;

        if(GetMachineGroup(NULL, &pszScope) == FALSE)
        {
            TLSLogEvent(
                    EVENTLOG_ERROR_TYPE,
                    TLS_E_SERVICEINIT,
                    TLS_E_RETRIEVEGROUPNAME
                );

            goto cleanup;
        }

        g_pszScope = pszScope;
    }

    //------------------------------------------------------
    //
    // Reissuance Parameters
    //
    //------------------------------------------------------

    dwBuffer = sizeof(g_dwReissueLeaseMinimum);
    dwStatus = RegQueryValueEx(
                        hKey,
                        LSERVER_PARAMETERS_LEASE_MIN,
                        NULL,
                        NULL,
                        (LPBYTE)&g_dwReissueLeaseMinimum,
                        &dwBuffer
                    );

    if (dwStatus == ERROR_SUCCESS)
    {
        g_dwReissueLeaseMinimum = min(g_dwReissueLeaseMinimum,
                PERMANENT_LICENSE_LEASE_EXPIRE_MIN);
    }
    else
    {
        g_dwReissueLeaseMinimum = PERMANENT_LICENSE_LEASE_EXPIRE_MIN;
    }

    dwBuffer = sizeof(g_dwReissueLeaseRange);
    dwStatus = RegQueryValueEx(
                        hKey,
                        LSERVER_PARAMETERS_LEASE_RANGE,
                        NULL,
                        NULL,
                        (LPBYTE)&g_dwReissueLeaseRange,
                        &dwBuffer
                    );

    if (dwStatus == ERROR_SUCCESS)
    {
        g_dwReissueLeaseRange = min(g_dwReissueLeaseRange,
                PERMANENT_LICENSE_LEASE_EXPIRE_RANGE);

        g_dwReissueLeaseRange = max(g_dwReissueLeaseRange, 1);
    }
    else
    {
        g_dwReissueLeaseRange = PERMANENT_LICENSE_LEASE_EXPIRE_RANGE;
    }

    dwBuffer = sizeof(g_dwReissueLeaseLeeway);
    dwStatus = RegQueryValueEx(
                        hKey,
                        LSERVER_PARAMETERS_LEASE_LEEWAY,
                        NULL,
                        NULL,
                        (LPBYTE)&g_dwReissueLeaseLeeway,
                        &dwBuffer
                    );

    if (dwStatus == ERROR_SUCCESS)
    {
        g_dwReissueLeaseLeeway = min(g_dwReissueLeaseLeeway,
                PERMANENT_LICENSE_LEASE_EXPIRE_LEEWAY);
    }
    else
    {
        g_dwReissueLeaseLeeway = PERMANENT_LICENSE_LEASE_EXPIRE_LEEWAY;
    }

    dwBuffer = sizeof(g_dwReissueExpireThreadSleep);
    dwStatus = RegQueryValueEx(
                        hKey,
                        LSERVER_PARAMETERS_EXPIRE_THREAD_SLEEP,
                        NULL,
                        NULL,
                        (LPBYTE)&g_dwReissueExpireThreadSleep,
                        &dwBuffer
                    );

    if (dwStatus == ERROR_SUCCESS)
    {
        g_dwReissueExpireThreadSleep = min(g_dwReissueExpireThreadSleep,
                EXPIRE_THREAD_SLEEP_TIME);
    }
    else
    {
        g_dwReissueExpireThreadSleep = EXPIRE_THREAD_SLEEP_TIME;
    }

    dwStatus = ERROR_SUCCESS;

cleanup:
    
    if(hKey != NULL)
    {
        RegCloseKey(hKey);
    }
    

    return dwStatus;
}


///////////////////////////////////////////////////////////////
DWORD
TLSPrepareForBackupRestore()
{
    DBGPrintf(
            DBG_INFORMATION,
            DBG_FACILITY_INIT,
            DBGLEVEL_FUNCTION_DETAILSIMPLE,
            _TEXT("TLSPrepareForBackupRestore...\n")
        );

    //
    // Pretend we are shutting down.
    //
    // ServiceSignalShutdown();

    //
    // first stop workmanager thread
    //
    TLSWorkManagerShutdown();

    //
    // Close all workspace and DB handle
    //
#ifndef _NO_ODBC_JET
    if(g_DbWorkSpace != NULL)
    {
        ReleaseWorkSpace(&g_DbWorkSpace);
    }
#endif

    CloseWorkSpacePool();

    return ERROR_SUCCESS;
}

///////////////////////////////////////////////////////////////
DWORD
TLSRestartAfterBackupRestore(
    BOOL bRestartAfterbackup
    )
/*++

bRestartAfterbackup : TRUE if restart after backup, FALSE if restart after restore.

--*/
{
    DWORD dwStatus;
    BOOL bIgnoreRestoreFile;
    BOOL bIgnoreFileTimeChecking;
    BOOL bLogWarning;

    DBGPrintf(
            DBG_INFORMATION,
            DBG_FACILITY_INIT,
            DBGLEVEL_FUNCTION_DETAILSIMPLE,
            _TEXT("TLSRestartAfterBackupRestore...\n")
        );


    //
    // Reset shutdown event
    //
    // ServiceResetShutdownEvent();

    //
    // Startup DB engine.
    //
    bIgnoreRestoreFile = bRestartAfterbackup;
    bIgnoreFileTimeChecking = (bRestartAfterbackup == FALSE);   // on restore, we need to ignore file time checking
    bLogWarning = bIgnoreFileTimeChecking;  // log warning after restart from restore

    dwStatus = TLSStartLSDbWorkspaceEngine(
                                    TRUE, 
                                    bIgnoreRestoreFile,             
                                    bIgnoreFileTimeChecking,
                                    bLogWarning
                                );

    if(dwStatus == ERROR_SUCCESS)
    {
        dwStatus = TLSWorkManagerInit();
    }

    // backup/restore always shutdown namedpipe thread
    InitNamedPipeThread();

    TLSASSERT(dwStatus == ERROR_SUCCESS);

    DBGPrintf(
            DBG_INFORMATION,
            DBG_FACILITY_INIT,
            DBGLEVEL_FUNCTION_DETAILSIMPLE,
            _TEXT("\tTLSRestartAfterBackupRestore() returns %d\n"),
            dwStatus
        );

    return dwStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\license\tlserver\server\keypack.cpp ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996-1998
//
// File:        keypack.cpp
//
// Contents:    
//              KeyPack Table related function.
//
// History:     
//          Feb. 4, 98      HueiWang        Created.
//---------------------------------------------------------------------------
#include "pch.cpp"
#include "globals.h"
#include "keypack.h"
#include "misc.h"

//++--------------------------------------------------------------------
static BOOL
ValidKeyPackParameter(
    IN PTLSLICENSEPACK lpKeyPack, 
    IN BOOL bAdd
    )
/*++

Abstract:

    Validate Licese KeyPack value

Parameter:


Returns:

++*/
{
    BOOL bValid=FALSE;
    UCHAR ucAgreementType = (lpKeyPack->ucAgreementType & ~LSKEYPACK_RESERVED_TYPE);
    UCHAR ucKeyPackStatus = (lpKeyPack->ucKeyPackStatus & ~LSKEYPACKSTATUS_RESERVED);
    do {
        // verify input parameter
        if(ucAgreementType < LSKEYPACKTYPE_FIRST || 
           ucAgreementType > LSKEYPACKTYPE_LAST)
        {
            DBGPrintf(
                    DBG_INFORMATION,
                    DBG_FACILITY_KEYPACK,
                    DBGLEVEL_FUNCTION_DETAILSIMPLE,
                    _TEXT("Invalid ucKeyPackType - %d\n"),
                    lpKeyPack->ucAgreementType
                );
                   
            break;
        }

        if((ucKeyPackStatus < LSKEYPACKSTATUS_FIRST || 
            ucKeyPackStatus > LSKEYPACKSTATUS_LAST) &&
            ucKeyPackStatus != LSKEYPACKSTATUS_DELETE)
        {
            DBGPrintf(
                    DBG_INFORMATION,
                    DBG_FACILITY_KEYPACK,
                    DBGLEVEL_FUNCTION_DETAILSIMPLE,
                    _TEXT("Invalid ucKeyPackStatus - %d\n"),
                    lpKeyPack->ucKeyPackStatus
                );
                
            break;
        }

        if(lpKeyPack->ucLicenseType < LSKEYPACKLICENSETYPE_FIRST || 
           lpKeyPack->ucLicenseType > LSKEYPACKLICENSETYPE_LAST)
        {
            DBGPrintf(
                    DBG_INFORMATION,
                    DBG_FACILITY_KEYPACK,
                    DBGLEVEL_FUNCTION_DETAILSIMPLE,
                    _TEXT("Invalid ucLicenseType - %d\n"),
                    lpKeyPack->ucLicenseType
                );
       
            break;
        }

        if(!bAdd)
        {
            bValid = TRUE;
            break;
        }

        //
        // Following value is required for adding entry into keypack
        //
        if(lpKeyPack->ucChannelOfPurchase < LSKEYPACKCHANNELOFPURCHASE_FIRST ||
           lpKeyPack->ucChannelOfPurchase > LSKEYPACKCHANNELOFPURCHASE_LAST)
        {
            DBGPrintf(
                    DBG_INFORMATION,
                    DBG_FACILITY_KEYPACK,
                    DBGLEVEL_FUNCTION_DETAILSIMPLE,
                    _TEXT("Invalid ucChannelOfPurchase - %d\n"),
                    lpKeyPack->ucChannelOfPurchase
                );
       
            break;
        }

        if(!_tcslen(lpKeyPack->szCompanyName))
        {
            DBGPrintf(
                    DBG_INFORMATION,
                    DBG_FACILITY_KEYPACK,
                    DBGLEVEL_FUNCTION_DETAILSIMPLE,
                    _TEXT("Null szCompanyName\n")
                );
       
            break;
        }

        if(!_tcslen(lpKeyPack->szKeyPackId))
        {
            DBGPrintf(
                    DBG_INFORMATION,
                    DBG_FACILITY_KEYPACK,
                    DBGLEVEL_FUNCTION_DETAILSIMPLE,
                    _TEXT("Null szKeyPackId\n")
                );
       
            break;
        }

        if(!_tcslen(lpKeyPack->szProductId))
        {
            DBGPrintf(
                    DBG_INFORMATION,
                    DBG_FACILITY_KEYPACK,
                    DBGLEVEL_FUNCTION_DETAILSIMPLE,
                    _TEXT("Null szProductId\n")
                );
       
            break;
        }

        if(!_tcslen(lpKeyPack->szBeginSerialNumber))
        {
            DBGPrintf(
                    DBG_INFORMATION,
                    DBG_FACILITY_KEYPACK,
                    DBGLEVEL_FUNCTION_DETAILSIMPLE,
                    _TEXT("Null szBeginSerialNumber\n")
                );
       
            break;
        }

        bValid=TRUE;
    } while(FALSE);
 
    return bValid;
}

//++-----------------------------------------------------------
void
TLSDBLockKeyPackTable()
/*++

Abstract:

    Lock both LicPack and LicPackStatus table.


Parameter:

    None.

++*/
{
    DBGPrintf(
            DBG_INFORMATION,
            DBG_FACILITY_LOCK,
            DBGLEVEL_FUNCTION_TRACE,
            _TEXT("Locking table KeyPackTable\n")
        );
            
    LicPackTable::LockTable();
}

//++-----------------------------------------------------------
void
TLSDBUnlockKeyPackTable()
/*++

Abstract:

    Unlock both LicPack and LicPackStatus table.

Parameter:

    None:

++*/
{
    DBGPrintf(
            DBG_INFORMATION,
            DBG_FACILITY_LOCK,
            DBGLEVEL_FUNCTION_TRACE,
            _TEXT("Unlocking table KeyPackTable\n")
        );

    LicPackTable::UnlockTable();
}

//++--------------------------------------------------------------
DWORD
TLSDBKeyPackFind(
    IN PTLSDbWorkSpace pDbWkSpace,
    IN BOOL bMatchAllParm,
    IN DWORD dwSearchParm,
    IN PTLSLICENSEPACK lpKeyPack,
    IN OUT PTLSLICENSEPACK lpFound
    )
/*++

Abstract:

    Find a license pack based on search parameter.

Parameter:

    pDbWkSpace : workspace handle.
    bMatchAllParm : TRUE if match all parameter, FALSE otherwise.
    dwSearchParm : search parameter.
    lpKeyPack : value to search for.
    lpFound : record found.

Return:


++*/
{
    DWORD dwStatus=ERROR_SUCCESS;
    BOOL bSuccess;

    if(pDbWkSpace == NULL || lpKeyPack == NULL)
    {
        SetLastError(dwStatus = ERROR_INVALID_PARAMETER);
        TLSASSERT(FALSE);
        return dwStatus;
    }

    LicPackTable& licpackTable=pDbWkSpace->m_LicPackTable;

    //
    // Find the record in LicPack table
    //        
    bSuccess = licpackTable.FindRecord(
                                bMatchAllParm,
                                dwSearchParm,
                                *lpKeyPack,
                                *lpFound
                            );

    if(bSuccess != TRUE)
    {
        if(licpackTable.GetLastJetError() == JET_errRecordNotFound)
        {
            SetLastError(dwStatus = TLS_E_RECORD_NOTFOUND);
        }
        else
        {
            LPTSTR pString = NULL;
            
            TLSGetESEError(licpackTable.GetLastJetError(), &pString);

            TLSLogEvent(
                    EVENTLOG_ERROR_TYPE,
                    TLS_E_DBGENERAL,
                    TLS_E_JB_BASE,
                    licpackTable.GetLastJetError(),
                    (pString != NULL) ? pString : _TEXT("")
                );

            if(pString != NULL)
            {
                LocalFree(pString);
            }

            SetLastError(
                    dwStatus = (SET_JB_ERROR(licpackTable.GetLastJetError()))
                );

            TLSASSERT(licpackTable.GetLastJetError() == JET_errRecordNotFound);
        }
    }
   

    return dwStatus;                        
}

//++-------------------------------------------------------------------
DWORD
TLSDBKeyPackAddEntry(
    IN PTLSDbWorkSpace pDbWkSpace,
    IN PTLSLICENSEPACK lpKeyPack
    )
/*++

Abstract:

    Add an entry into LicPack and LicPackStatus table.

Parameter:

    pDbWkSpace :
    lpKeyPack ;

Returns:
    
++*/
{
    DWORD dwStatus = ERROR_SUCCESS;
    TLSLICENSEPACK found;
    BOOL bSuccess;

    LicPackTable& licpackTable=pDbWkSpace->m_LicPackTable;

    found.pbDomainSid = NULL;
    found.cbDomainSid = 0;

    //
    //
    //
    TLSDBLockKeyPackTable();

    TLSASSERT(pDbWkSpace != NULL && lpKeyPack != NULL);
    if(pDbWkSpace == NULL || lpKeyPack == NULL)
    {
        SetLastError(dwStatus = ERROR_INVALID_PARAMETER);
        goto cleanup;
    }

    // lpKeyPack->pbDomainSid == NULL || lpKeyPack->cbDomainSid == 0 ||
    if( _tcslen(lpKeyPack->szInstallId) == 0 || _tcslen(lpKeyPack->szTlsServerName) == 0 )
    {
        TLSASSERT(FALSE);
        SetLastError(dwStatus = ERROR_INVALID_PARAMETER);
        goto cleanup;
    }

    //
    // make sure no duplicate entry via primary index
    dwStatus = TLSDBKeyPackFind(
                            pDbWkSpace,
                            TRUE,
                            LICENSEDPACK_PROCESS_DWINTERNAL,
                            lpKeyPack,
                            &found
                        );
    if(dwStatus == ERROR_SUCCESS)
    {
        dwStatus = TLS_E_DUPLICATE_RECORD;
        goto cleanup;
    }

    dwStatus = ERROR_SUCCESS;

    //
    // Mark internal field - 
    // 
    switch( (lpKeyPack->ucAgreementType & ~LSKEYPACK_RESERVED_TYPE) )
    {
        case LSKEYPACKTYPE_SELECT:
        case LSKEYPACKTYPE_RETAIL:
        case LSKEYPACKTYPE_OPEN:
            // number of license available to client
            lpKeyPack->dwNumberOfLicenses = lpKeyPack->dwTotalLicenseInKeyPack;
            break;

        default:
            // number of licenses issued.
            lpKeyPack->dwNumberOfLicenses = 0;
            break;
    }

    //
    // Begin serial number in this keypack
    //
    lpKeyPack->dwNextSerialNumber = 1;
    GetSystemTimeAsFileTime(&(lpKeyPack->ftLastModifyTime));

    //
    // Mark beta keypack.
    //
    if(TLSIsBetaNTServer() == TRUE)
    {
        lpKeyPack->ucKeyPackStatus |= LSKEYPACKSTATUS_BETA;
    }

    //
    // insert the record
    //
    bSuccess = licpackTable.InsertRecord(
                                *lpKeyPack
                            );

    if(bSuccess == FALSE)
    {
        if(licpackTable.GetLastJetError() == JET_errKeyDuplicate)
        {
            SetLastError(dwStatus=TLS_E_DUPLICATE_RECORD);
        }
        else
        {
            LPTSTR pString = NULL;
            
            TLSGetESEError(licpackTable.GetLastJetError(), &pString);

            TLSLogEvent(
                    EVENTLOG_ERROR_TYPE,
                    TLS_E_DBGENERAL,
                    TLS_E_JB_BASE,
                    licpackTable.GetLastJetError(),
                    (pString != NULL) ? pString : _TEXT("")
                );

            if(pString != NULL)
            {
                LocalFree(pString);
            }

            SetLastError(dwStatus = SET_JB_ERROR(licpackTable.GetLastJetError()));
            TLSASSERT(FALSE);
        }
    }
    
cleanup:

    TLSDBUnlockKeyPackTable();
    SetLastError(dwStatus);
    return dwStatus;
}

//-----------------------------------------------------

DWORD
TLSDBKeyPackDeleteEntry(
    IN PTLSDbWorkSpace pDbWkSpace,
    IN BOOL bDeleteAllRecord,
    IN PTLSLICENSEPACK lpKeyPack
    )
/*++

Abstract:

    Delete an entry from both LicPack and LicPackStatus table.

Parameter:

    pDbWkSpace : workspace handle.
    bDeleteAllRecord : Delete all record with same ID.
    lpKeyPack : record to be delete.

Returns:

Note:

    If not deleting same record, current record must be point
    to the record that going to be deleted.

++*/
{
    DWORD dwStatus=ERROR_SUCCESS;
    BOOL bSuccess;

    LicPackTable& licpackTable = pDbWkSpace->m_LicPackTable;

    GetSystemTimeAsFileTime(&(lpKeyPack->ftLastModifyTime));

    //
    // BACKUP - Need to update this record to deleted state instead of delete it.
    //

    if(bDeleteAllRecord == TRUE)
    {
        //
        // Delete record from LicPack Table.
        //
        bSuccess = licpackTable.DeleteAllRecord(
                                    TRUE,
                                    LICENSEDPACK_PROCESS_DWINTERNAL,
                                    *lpKeyPack
                                );
    }
    else
    {
        bSuccess = licpackTable.DeleteRecord();
    }
                                    
    if(bSuccess == FALSE)
    {
        SetLastError(dwStatus = SET_JB_ERROR(licpackTable.GetLastJetError()));
        if(licpackTable.GetLastJetError() != JET_errRecordNotFound)
        {

            LPTSTR pString = NULL;
            
            TLSGetESEError(licpackTable.GetLastJetError(), &pString);

            TLSLogEvent(
                    EVENTLOG_ERROR_TYPE,
                    TLS_E_DBGENERAL,
                    TLS_E_JB_BASE,
                    licpackTable.GetLastJetError(),
                    (pString != NULL) ? pString : _TEXT("")
                );

            if(pString != NULL)
            {
                LocalFree(pString);
            }

            TLSASSERT(FALSE);
        }
    }



    return dwStatus;
}

//-----------------------------------------------------

DWORD
TLSDBKeyPackUpdateEntry(
    IN PTLSDbWorkSpace pDbWkSpace,
    IN BOOL bPointerOnRecord,
    IN DWORD dwUpdateParm,
    IN PTLSLICENSEPACK lpKeyPack
    )
/*
*/
{
    DWORD dwStatus = ERROR_SUCCESS;
    BOOL bSuccess;
    TLSLICENSEPACK found;

    LicPackTable& licpackTable=pDbWkSpace->m_LicPackTable;

    if(bPointerOnRecord == FALSE)
    {
        found.pbDomainSid = NULL;

        dwStatus = TLSDBKeyPackFind(
                            pDbWkSpace,
                            TRUE,
                            LICENSEDPACK_PROCESS_DWINTERNAL,
                            lpKeyPack,
                            &found
                        );


        lpKeyPack->dwKeyPackId = found.dwKeyPackId;

        if(dwStatus != ERROR_SUCCESS)
        {
            TLSASSERT(FALSE);
            goto cleanup;
        }
    }


#if DBG
    {
        //
        // try to cache some bug...
        //
        TLSLICENSEPACK found1;

        found.pbDomainSid = NULL;

        bSuccess = licpackTable.FetchRecord( found1, 0xFFFFFFFF );

        //
        // Make sure we update right record
        if( found1.dwKeyPackId != lpKeyPack->dwKeyPackId )
        {
            TLSASSERT(FALSE);
        }

        //
        // check input parameter
        if( ValidKeyPackParameter( lpKeyPack, FALSE ) == FALSE )
        {
            TLSASSERT(FALSE);
        }
    }

#endif

    //
    // Update the timestamp for this record.
    //
    GetSystemTimeAsFileTime(&(lpKeyPack->ftLastModifyTime));
    bSuccess = licpackTable.UpdateRecord(
                                *lpKeyPack,
                                (dwUpdateParm & ~LICENSEDPACK_PROCESS_DWINTERNAL) | LICENSEDPACK_PROCESS_MODIFYTIME
                            );

    if(bSuccess == FALSE)
    {
        LPTSTR pString = NULL;
        
        TLSGetESEError(licpackTable.GetLastJetError(), &pString);

        TLSLogEvent(
                EVENTLOG_ERROR_TYPE,
                TLS_E_DBGENERAL,
                TLS_E_JB_BASE,
                licpackTable.GetLastJetError(),
                (pString != NULL) ? pString : _TEXT("")
            );

        if(pString != NULL)
        {
            LocalFree(pString);
        }

        SetLastError(dwStatus = SET_JB_ERROR(licpackTable.GetLastJetError()));
        TLSASSERT(FALSE);
    }

cleanup:

    return dwStatus;
}    

//-----------------------------------------------------

DWORD
TLSDBKeyPackUpdateNumOfAvailableLicense( 
    IN PTLSDbWorkSpace pDbWkSpace,
    IN BOOL bAdd, 
    IN PTLSLICENSEPACK lpKeyPack 
    )
/*++

Abstract:

    Update number of license available .

Parameter:

    pDbWkSpace : workspace handle.
    bAdd : TRUE if add license 
    lpKeyPack : 

Returns:

++*/
{
    DWORD   dwStatus=ERROR_SUCCESS;

    if(pDbWkSpace == NULL || lpKeyPack == NULL)
    {
        SetLastError(dwStatus = ERROR_INVALID_PARAMETER);
        TLSASSERT(pDbWkSpace != NULL);
        return dwStatus;
    }
    
    TLSLICENSEPACK found;
    DWORD   dwNumberLicenseToAddRemove;
    BOOL    bRemoveMoreThanAvailable=FALSE;

    found.pbDomainSid = NULL;

    TLSDBLockKeyPackTable();
    dwStatus = TLSDBKeyPackFind(
                        pDbWkSpace,
                        TRUE,
                        LICENSEDPACK_PROCESS_DWINTERNAL,
                        lpKeyPack,
                        &found
                    );

    if(dwStatus != ERROR_SUCCESS)
    {
        goto cleanup;
    }

    dwNumberLicenseToAddRemove = lpKeyPack->dwTotalLicenseInKeyPack;

    *lpKeyPack = found;

    if(dwNumberLicenseToAddRemove == 0)
    {
        // query only, a hook so that test program can get actual
        // numbers - Jet not re-reading MDB file problem
        goto cleanup;
    }

    //
    // Only allow add/remove license on retail
    //
    if( (found.ucAgreementType & ~LSKEYPACK_RESERVED_TYPE) != LSKEYPACKTYPE_RETAIL)
    {
        DBGPrintf(
                DBG_INFORMATION,
                DBG_FACILITY_KEYPACK,
                DBGLEVEL_FUNCTION_DETAILSIMPLE,
                _TEXT("LSDBKeyPackUpdate : Invalid parameter...\n")
            );

        SetLastError(dwStatus = TLS_E_INVALID_DATA);
        goto cleanup;
    }

    if(bAdd)
    {
        // increase both total and number available
        found.dwNumberOfLicenses += dwNumberLicenseToAddRemove;
        found.dwTotalLicenseInKeyPack += dwNumberLicenseToAddRemove;
    }
    else
    {
        //
        // if number of licenses to remove is greater that what's available, 
        // remove all available license and set the return code to invalid data.
        //
        if(found.dwNumberOfLicenses < dwNumberLicenseToAddRemove)
        {
            bRemoveMoreThanAvailable = TRUE;
        }

        dwNumberLicenseToAddRemove = min(dwNumberLicenseToAddRemove, found.dwNumberOfLicenses);
        found.dwNumberOfLicenses -= dwNumberLicenseToAddRemove;
        found.dwTotalLicenseInKeyPack -= dwNumberLicenseToAddRemove;
    }

    dwStatus = TLSDBKeyPackSetValues(
                            pDbWkSpace,
                            TRUE, 
                            LSKEYPACK_SEARCH_TOTALLICENSES | LSKEYPACK_EXSEARCH_AVAILABLE, 
                            &found
                        );

    *lpKeyPack = found;

cleanup:

    TLSDBUnlockKeyPackTable();
    if(dwStatus == ERROR_SUCCESS && bRemoveMoreThanAvailable)
        SetLastError(dwStatus = TLS_W_REMOVE_TOOMANY);

    return dwStatus;
}

//+-----------------------------------------------------------------
DWORD
TLSDBKeyPackAdd(
    IN PTLSDbWorkSpace pDbWkSpace,
    IN OUT PTLSLICENSEPACK lpKeyPack  // return internal tracking ID
    )
/*++

Abstract:

    Install a product keypack into keypack table, routine only set 
    keypack status to pending, must call corresponding set status
    routine to activate key pack.

Parameters:

    pDbWkSpace : Workspace handle.
    lpKeyPack : value to be inserted.

Returns:

++*/
{
    DWORD lNextKeyPackId;
    DWORD dwStatus;

    if(!ValidKeyPackParameter(lpKeyPack, TRUE))
    {
        SetLastError(TLS_E_INVALID_DATA);
        return TLS_E_INVALID_DATA;
    }

    TLSLICENSEPACK found;
    TLSDBLockKeyPackTable();

    found.pbDomainSid = NULL;

    //
    // No duplicate entry for product installed
    //
    dwStatus = TLSDBKeyPackFind(
                            pDbWkSpace,
                            TRUE,
                            LICENSEDPACK_FIND_PRODUCT,
                            lpKeyPack,
                            &found
                        );

    if(dwStatus == ERROR_SUCCESS)
    {
        // Product already installed
        switch( (found.ucKeyPackStatus & ~LSKEYPACKSTATUS_RESERVED) )
        {
            case LSKEYPACKSTATUS_TEMPORARY:
                // case 1 : keypack is installed by temporary license
                if(found.ucAgreementType == lpKeyPack->ucAgreementType)
                {
                    dwStatus = TLS_E_DUPLICATE_RECORD;
                }
                break;

            case LSKEYPACKSTATUS_ACTIVE:
            case LSKEYPACKSTATUS_PENDING:
                // case 2 : duplicate entry
                dwStatus = TLS_E_DUPLICATE_RECORD;
                break;
            
            case LSKEYPACKSTATUS_RETURNED:
            case LSKEYPACKSTATUS_REVOKED:
            case LSKEYPACKSTATUS_OTHERS:
                // de-activated license key pack.
                // keep it.
                break;

            default:
                dwStatus = TLS_E_CORRUPT_DATABASE;

                #if DBG
                TLSASSERT(FALSE);
                #endif
        }

        if(dwStatus != ERROR_SUCCESS)
            goto cleanup;
    }
    else if(dwStatus == TLS_E_RECORD_NOTFOUND)
    {
        //
        // Always use new keypack ID 
        // temporary license will be deleted after all license
        // has been returned.
        //
        lpKeyPack->dwKeyPackId = TLSDBGetNextKeyPackId();

        dwStatus = TLSDBKeyPackAddEntry(
                                pDbWkSpace,
                                lpKeyPack
                            );
    }

cleanup:

    TLSDBUnlockKeyPackTable();
    return dwStatus;
}

//+-------------------------------------------------------------------
DWORD
TLSDBKeyPackEnumBegin( 
    IN PTLSDbWorkSpace pDbWkSpace,
    IN BOOL  bMatchAll,
    IN DWORD dwSearchParm,
    IN PTLSLICENSEPACK lpSearch
    )
/*

Abstract:

    Begin enumeration of licensepack table.

Parameter:

    pDbWkSpace : workspace handle.
    bMatchAll : match all search value.
    dwSearchParm : value to search.
    lpSearch : search value

Return:


*/
{
    DWORD dwStatus = ERROR_SUCCESS;
    BOOL bSuccess = TRUE;

    if(pDbWkSpace == NULL)
    {
        SetLastError(dwStatus = ERROR_INVALID_PARAMETER);
        TLSASSERT(FALSE);
        return dwStatus;
    }      

    LicPackTable& licpackTable=pDbWkSpace->m_LicPackTable;

    bSuccess = licpackTable.EnumerateBegin(
                                bMatchAll,
                                dwSearchParm,
                                lpSearch
                            );

    if(bSuccess == FALSE)
    {
        LPTSTR pString = NULL;
        
        TLSGetESEError(licpackTable.GetLastJetError(), &pString);

        TLSLogEvent(
                EVENTLOG_ERROR_TYPE,
                TLS_E_DBGENERAL,
                TLS_E_JB_BASE,
                licpackTable.GetLastJetError(),
                (pString != NULL) ? pString : _TEXT("")
            );

        if(pString != NULL)
        {
            LocalFree(pString);
        }

        SetLastError(dwStatus = SET_JB_ERROR(licpackTable.GetLastJetError()));
        TLSASSERT(FALSE);
    }
    
    return dwStatus;
}

//+-------------------------------------------------------------------
DWORD
TLSDBKeyPackEnumNext( 
    IN PTLSDbWorkSpace pDbWkSpace, 
    IN OUT PTLSLICENSEPACK lpKeyPack
    )
/*++

Abstract:

    Fetch next row of record that match search condition.

Parameters:

    pDbWkSpace : workspace handle.
    lpKeyPack : return founded keypack.

Return:


++*/
{
    DWORD dwStatus = ERROR_SUCCESS;

    if(pDbWkSpace == NULL || lpKeyPack == NULL)
    {
        SetLastError(dwStatus = ERROR_INVALID_PARAMETER);
        TLSASSERT(FALSE);
        return dwStatus;
    }

    //FreeTlsLicensePack(lpKeyPack);

    LicPackTable& licpackTable=pDbWkSpace->m_LicPackTable;
    
    switch(licpackTable.EnumerateNext(*lpKeyPack))
    {
        case RECORD_ENUM_ERROR:
            {
                LPTSTR pString = NULL;
        
                TLSGetESEError(licpackTable.GetLastJetError(), &pString);

                TLSLogEvent(
                        EVENTLOG_ERROR_TYPE,
                        TLS_E_DBGENERAL,
                        TLS_E_JB_BASE,
                        licpackTable.GetLastJetError(),
                        (pString != NULL) ? pString : _TEXT("")
                    );

                if(pString != NULL)
                {
                    LocalFree(pString);
                }
            }

            dwStatus = SET_JB_ERROR(licpackTable.GetLastJetError());
            TLSASSERT(FALSE);
            break;

        case RECORD_ENUM_MORE_DATA:
            dwStatus = ERROR_SUCCESS;
            break;

        case RECORD_ENUM_END:
            dwStatus = TLS_I_NO_MORE_DATA;
    }

    return dwStatus;
}

//+-------------------------------------------------------------------
void
TLSDBKeyPackEnumEnd( 
    IN PTLSDbWorkSpace pDbWkSpace
    )
/*++

Abstract:

    End enumeration of licensepack.

Parameter:

    pDbWkSpace : workspace handle.
++*/
{
    TLSASSERT(pDbWkSpace != NULL);
    pDbWkSpace->m_LicPackTable.EnumerateEnd();
    return;
}


//+-------------------------------------------------------------------
DWORD
TLSDBKeyPackSetValues(
    IN PTLSDbWorkSpace pDbWkSpace, 
    IN BOOL         bPointerOnRecord,
    IN DWORD        dwSetParm,
    IN PTLSLICENSEPACK lpKeyPack
    )
/*++

Abstract:

    Set column value of a license pack record.

Parameter;

    pDbWkSpace : workspace handle.
    bInternal : call is from internal routine, no error checking.
    dwSetParm : Columns to be set.
    lpKeyPack : value to be set.

Returns.

++*/
{

    DWORD dwStatus=ERROR_SUCCESS;

    if(pDbWkSpace == NULL || lpKeyPack == NULL)
    {
        SetLastError(dwStatus = ERROR_INVALID_PARAMETER);
        TLSASSERT(FALSE);
        goto cleanup;
    }

    if(bPointerOnRecord == FALSE)
    {
        TLSLICENSEPACK found;

        // Find this keypack's internal keypack id
        dwStatus = TLSDBKeyPackFind(
                                pDbWkSpace,
                                TRUE,
                                LICENSEDPACK_FIND_PRODUCT,
                                lpKeyPack,
                                &found
                            );

        //FreeTlsLicensePack(&found);

        if(dwStatus != ERROR_SUCCESS)
        {
            goto cleanup;
        }

        lpKeyPack->dwKeyPackId = found.dwKeyPackId;
    }

    if(lpKeyPack->ucKeyPackStatus == LSKEYPACKSTATUS_DELETE)
    {
        dwStatus = TLSDBKeyPackDeleteEntry(
                                    pDbWkSpace,
                                    TRUE,       // delete all records with same ID
                                    lpKeyPack
                                );
    }
    else
    {
        dwStatus = TLSDBKeyPackUpdateEntry(
                                    pDbWkSpace,
                                    TRUE,
                                    dwSetParm,
                                    lpKeyPack
                                );
    }

cleanup:
    return dwStatus;
}

//+-------------------------------------------------------------------
DWORD
TLSDBKeyPackSetStatus( 
    IN PTLSDbWorkSpace pDbWkSpace, 
    IN DWORD      dwSetStatus,
    IN PTLSLICENSEPACK  lpKeyPack
    )
/*++

Abstract:

    Stub routine for RPC to set status of a keypack


++*/
{
    return TLSDBKeyPackSetValues(
                        pDbWkSpace, 
                        FALSE, 
                        dwSetStatus, 
                        lpKeyPack
                    );
}

//+-------------------------------------------------------------------
DWORD
TLSDBKeyPackGetAvailableLicenses( 
    IN PTLSDbWorkSpace pDbWkSpace, 
    IN DWORD dwSearchParm,
    IN PTLSLICENSEPACK lplsKeyPack,
    IN OUT LPDWORD lpdwAvail
    )
/*++

Abstract:

    retrieve number of available licenses for the key pack.

Parameter:

    pDbWkSpace : workspace handle.
    dwSearchParm : search parameters.
    lpLsKeyPack : search value.
    lpdwAvail : return number of available licenses.

Return:

++*/
{
    DWORD dwStatus = ERROR_SUCCESS;
    TLSLICENSEPACK found;

    dwStatus = TLSDBKeyPackFind(
                        pDbWkSpace,
                        TRUE,
                        dwSearchParm,
                        lplsKeyPack,
                        &found
                    );

    if(dwStatus == ERROR_SUCCESS)
    {
        switch(found.ucAgreementType)
        {
            case LSKEYPACKTYPE_SELECT:
            case LSKEYPACKTYPE_RETAIL:
            case LSKEYPACKTYPE_OPEN:
                *lpdwAvail = found.dwNumberOfLicenses;
                break;

            default:
                *lpdwAvail = LONG_MAX;
        }
    }

    return dwStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\license\tlserver\server\init.h ===
//+--------------------------------------------------------------------------
//
// Copyright (c) 1997-1999 Microsoft Corporation
//
// File:        init.h
//
// Contents:    
//
// History:     
//
//---------------------------------------------------------------------------
#ifndef __INIT_H__
#define __INIT_H__



#ifdef __cplusplus
extern "C" {
#endif
    DWORD
    TLSPrepareForBackupRestore();

    DWORD
    TLSRestartAfterBackupRestore(BOOL);

    void 
    ServerShutdown();

    DWORD
    GetLicenseServerRole();

    void
    GetJobObjectDefaults(
        PDWORD pdwInterval,
        PDWORD pdwRetries,
        PDWORD pdwRestartTime
    );

    void
    SetServiceLastShutdownTime();


    void
    GetServiceLastShutdownTime(
        OUT FILETIME* ft
    );

    DWORD 
    StartServerInitThread( 
        void* p 
    );

    HANDLE 
    ServerInit(
        BOOL bDebug
    );

    BOOL 
    TLSLoadServerCertificate();

    DWORD
    ServiceInitCrypto(
        IN BOOL bCreateNewKeys,
        IN LPCTSTR pszKeyContainer,
        OUT HCRYPTPROV* phCryptProv,
        OUT HCRYPTKEY* phSignKey,
        OUT HCRYPTKEY* phExchKey
    );

    DWORD 
    InitCryptoAndCertificate();

    DWORD
    TLSReGenerateKeys(
        BOOL bReGenKeyOnly
    );

    DWORD
    TLSReGenKeysAndReloadServerCert(
        BOOL bReGenKeyOnly
    );

    DWORD
    TLSReGenSelfSignCert(
        IN HCRYPTPROV hCryptProv,
        IN PBYTE pbSPK,
        IN DWORD cbSPK,
        IN DWORD dwNumExtensions,
        IN PCERT_EXTENSION pCertExtensions
    );

    void
    CleanSetupLicenseServer();

    DWORD
    TLSLoadVerifyLicenseServerCertificates();

    DWORD
    TLSRestoreLicenseServerCertificate(
        LPCTSTR pszSourceRegKey,
        LPCTSTR pszTargetRegKey
    );

    BOOL
    CanIssuePermLicense();

#ifdef __cplusplus
}
#endif


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\license\tlserver\server\keypack.h ===
//+--------------------------------------------------------------------------
//
// Copyright (c) 1997-1999 Microsoft Corporation
//
// File:        keypack.h
//
// Contents:    
//
// History:     
//
//---------------------------------------------------------------------------
#ifndef __KEYPACK_H__
#define __KEYPACK_H__
#include "server.h"


#ifdef __cplusplus
extern "C" {
#endif

void
TLSDBLockKeyPackTable();

void
TLSDBUnlockKeyPackTable();

DWORD
TLSDBKeyPackFind(
    IN PTLSDbWorkSpace pDbWkSpace,
    IN BOOL bMatchAllParm,
    IN DWORD dwSearchParm,
    IN PTLSLICENSEPACK lpKeyPack,
    IN OUT PTLSLICENSEPACK lpFound
);

DWORD
TLSDBKeyPackAddEntry(
    IN PTLSDbWorkSpace pDbWkSpace,
    IN PTLSLICENSEPACK lpKeyPack
);

DWORD
TLSDBKeyPackDeleteEntry(
    IN PTLSDbWorkSpace pDbWkSpace,
    IN BOOL bDeleteAllRecord,
    IN PTLSLICENSEPACK lpKeyPack
);

DWORD
TLSDBKeyPackUpdateEntry(
    IN PTLSDbWorkSpace pDbWkSpace,
    IN BOOL bPointerOnRecord,
    IN DWORD dwUpdateParm,
    IN PTLSLICENSEPACK lpKeyPack
);

DWORD
TLSDBKeyPackUpdateNumOfAvailableLicense( 
    IN PTLSDbWorkSpace pDbWkSpace,
    IN BOOL bAdd, 
    IN PTLSLICENSEPACK lpKeyPack 
);

DWORD
TLSDBKeyPackAdd(
    IN PTLSDbWorkSpace pDbWkSpace,
    IN OUT PTLSLICENSEPACK lpKeyPack  // return internal tracking ID
);

DWORD
TLSDBKeyPackEnumBegin( 
    IN PTLSDbWorkSpace pDbWkSpace,
    IN BOOL  bMatchAll,
    IN DWORD dwSearchParm,
    IN PTLSLICENSEPACK lpSearch
);

DWORD
TLSDBKeyPackEnumNext( 
    IN PTLSDbWorkSpace pDbWkSpace, 
    IN OUT PTLSLICENSEPACK lpKeyPack
);

void
TLSDBKeyPackEnumEnd( 
    IN PTLSDbWorkSpace pDbWkSpace
);

DWORD
TLSDBKeyPackSetValues(
    IN PTLSDbWorkSpace pDbWkSpace, 
    IN BOOL bPointerOnRecord,
    IN DWORD        dwSetParm,
    IN PTLSLICENSEPACK lpKeyPack
);

DWORD
TLSDBKeyPackGetAvailableLicenses( 
    IN PTLSDbWorkSpace pDbWkSpace, 
    IN DWORD dwSearchParm,
    IN PTLSLICENSEPACK lplsKeyPack,
    IN OUT LPDWORD lpdwAvail
);

#ifdef __cplusplus
}
#endif


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\license\tlserver\server\jobmgr.cpp ===
//+--------------------------------------------------------------------------
//
// Copyright (c) 1997-1999 Microsoft Corporation
//
// File:        jobmgr.cpp
//
// Contents:    Job scheduler    
//
// History:     
//
//---------------------------------------------------------------------------
#include "pch.cpp"
#include <process.h>
#include "server.h"
#include "jobmgr.h"
#include "debug.h"


//------------------------------------------------------------
//
//
CLASS_PRIVATE BOOL
CWorkManager::SignalJobRunning(
    IN CWorkObject *ptr
    )
/*++

Abstract:

    Class private routine for work object to 'signal' 
    work manger it has started processing.

Parameter:

    ptr : Pointer to CWorkObject that is ready to run.

Returns:

    TRUE/FALSE 

--*/
{
    DWORD dwStatus = ERROR_SUCCESS;
    INPROCESSINGJOBLIST::iterator it;

    if(ptr != NULL)
    {
        m_InProcessingListLock.Lock();

        DBGPrintf(
                DBG_INFORMATION,
                DBG_FACILITY_WORKMGR,
                DBGLEVEL_FUNCTION_TRACE,
                _TEXT("WorkManager : SignalJobRunning() Job %p ...\n"),
                ptr
            );

        //
        // find our pointer in processing list
        //
        it = m_InProcessingList.find(ptr);

        if(it != m_InProcessingList.end())
        {
            // TODO - make processing thread handle a list.
            if((*it).second.m_hThread == NULL)
            {
                HANDLE hHandle;
                BOOL bSuccess;

                bSuccess = DuplicateHandle(
                                        GetCurrentProcess(), 
                                        GetCurrentThread(), 
                                        GetCurrentProcess(), 
                                        &hHandle, 
                                        DUPLICATE_SAME_ACCESS, 
                                        FALSE, 
                                        0
                                    );

                if(bSuccess == FALSE)
                {
                    //
                    // non-critical error, if we fail, we won't be able to 
                    // cancel our rpc call.
                    //
                    SetLastError(dwStatus = GetLastError());

                    DBGPrintf(
                            DBG_INFORMATION,
                            DBG_FACILITY_WORKMGR,
                            DBGLEVEL_FUNCTION_DETAILSIMPLE,
                            _TEXT("WorkManager : SignalJobRunning() duplicate handle return %d...\n"),
                            dwStatus
                        );
                }
                else
                {
                    //
                    // set processing thread handle of job.
                    //
                    (*it).second.m_hThread = hHandle;
                }
            }
        }
        else
        {
            DBGPrintf(
                    DBG_INFORMATION,
                    DBG_FACILITY_WORKMGR,
                    DBGLEVEL_FUNCTION_TRACE,
                    _TEXT("WorkManager : SignalJobRunning can't find job %p in processing list...\n"),
                    ptr
                );

            //
            // timing problem, job might be re-scheduled and actually execute before we have 
            // time to remove from our in-processing list.
            //
            //TLSASSERT(FALSE);
        }         

        m_InProcessingListLock.UnLock();
    }
    else
    {
        SetLastError(dwStatus = ERROR_INVALID_DATA);
    }

    return dwStatus;
}

//----------------------------------------------------------------
//
CLASS_PRIVATE void
CWorkManager::CancelInProcessingJob()
/*++

Abstract:

    Class private : cancel job currently in processing state, 
    only invoked at the time of service shutdown.

Parameter:

    None.

Return:

    None.

--*/
{
    INPROCESSINGJOBLIST::iterator it;

    DBGPrintf(
            DBG_INFORMATION,
            DBG_FACILITY_WORKMGR,
            DBGLEVEL_FUNCTION_TRACE,
            _TEXT("WorkManager : CancelInProcessingJob...\n")
        );
        
    m_InProcessingListLock.Lock();

    for(it = m_InProcessingList.begin(); 
        it != m_InProcessingList.end(); 
        it++ )
    {
        if((*it).second.m_hThread != NULL)
        {
            // cancel everything and ignore error.
            (VOID)RpcCancelThread((*it).second.m_hThread);
        }
    }

    m_InProcessingListLock.UnLock();
    return;
}

//------------------------------------------------------------
//
//
CLASS_PRIVATE DWORD
CWorkManager::AddJobToProcessingList(
    IN CWorkObject *ptr
    )
/*++

Abstract:

    Class private, move job from wait queue to in-process queue.

Parameter:

    ptr : Pointer to job.

Parameter:

    ERROR_SUCESS or error code.

--*/
{
    DWORD dwStatus = ERROR_SUCCESS;
    INPROCESSINGJOBLIST::iterator it;
    WorkMangerInProcessJob job;

    if(ptr == NULL)
    {
        SetLastError(dwStatus = ERROR_INVALID_DATA);
    }
    else
    {
        DBGPrintf(
                DBG_INFORMATION,
                DBG_FACILITY_WORKMGR,
                DBGLEVEL_FUNCTION_TRACE,
                _TEXT("WorkManager : Add Job <%s> to processing list...\n"),
                ptr->GetJobDescription()
            );
            

        m_InProcessingListLock.Lock();

        it = m_InProcessingList.find(ptr);
        if(it != m_InProcessingList.end())
        {
            // increase the reference counter.
            InterlockedIncrement(&((*it).second.m_refCounter));
        }
        else
        {
            job.m_refCounter = 1;
            job.m_hThread = NULL;   // job not run yet.

            m_InProcessingList[ptr] = job;
        }

        ResetEvent(m_hJobInProcessing);
    
        m_InProcessingListLock.UnLock();
    }

    return dwStatus;
}

//------------------------------------------------------------
//
//
CLASS_PRIVATE DWORD
CWorkManager::RemoveJobFromProcessingList(
    IN CWorkObject *ptr
    )
/*++

Abstract:

    Class private, remove a job from in-processing list.

Parameter:

    ptr : Pointer to job to be removed from list.

Returns:

    ERROR_SUCCESS or error code.
 
--*/
{
    DWORD dwStatus = ERROR_SUCCESS;
    INPROCESSINGJOBLIST::iterator it;

    if(ptr != NULL)
    {
        m_InProcessingListLock.Lock();

        DBGPrintf(
                DBG_INFORMATION,
                DBG_FACILITY_WORKMGR,
                DBGLEVEL_FUNCTION_TRACE,
                _TEXT("WorkManager : RemoveJobFromProcessingList Job %p from processing list...\n"),
                ptr
            );

        it = m_InProcessingList.find(ptr);

        if(it != m_InProcessingList.end())
        {
            // decrease the reference counter
            InterlockedDecrement(&((*it).second.m_refCounter));

            if((*it).second.m_refCounter <= 0)
            {
                // close thread handle.
                if((*it).second.m_hThread != NULL)
                {
                    CloseHandle((*it).second.m_hThread);
                }

                m_InProcessingList.erase(it);
            }
            else
            {
                DBGPrintf(
                        DBG_INFORMATION,
                        DBG_FACILITY_WORKMGR,
                        DBGLEVEL_FUNCTION_TRACE,
                        _TEXT("WorkManager : RemoveJobFromProcessingList job %p reference counter = %d...\n"),
                        ptr,
                        (*it).second
                    );
            }
        }
        else
        {
            DBGPrintf(
                    DBG_INFORMATION,
                    DBG_FACILITY_WORKMGR,
                    DBGLEVEL_FUNCTION_TRACE,
                    _TEXT("WorkManager : RemoveJobFromProcessingList can't find job %p in processing list...\n"),
                    ptr
                );

            //
            // timing problem, job might be re-scheduled and actually execute before we have 
            // time to remove from our in-processing list.
            //
            //TLSASSERT(FALSE);
        }

        if(m_InProcessingList.empty() == TRUE)
        {
            //
            // Inform Work Manager that no job is in processing.
            //
            SetEvent(m_hJobInProcessing);
        }        

        m_InProcessingListLock.UnLock();
    }
    else
    {
        SetLastError(dwStatus = ERROR_INVALID_DATA);
    }

    return dwStatus;
}
    
//------------------------------------------------------------
//
//
CLASS_PRIVATE BOOL
CWorkManager::WaitForObjectOrShutdown(
    IN HANDLE hHandle
    )
/*++

Abstract:

    Class private, Wait for a sync. handle or service shutdown
    event.

Parameter:

    hHandle : handle to wait for,

Returns:

    TRUE if sucessful, FALSE if service shutdown or error.
    
--*/
{
    HANDLE handles[] = {hHandle, m_hShutdown};
    DWORD dwStatus;

    dwStatus = WaitForMultipleObjects(
                                sizeof(handles)/sizeof(handles[0]),
                                handles,
                                FALSE,
                                INFINITE
                            );

    return (dwStatus == WAIT_OBJECT_0);
}

//------------------------------------------------------------
//
//
CLASS_PRIVATE DWORD
CWorkManager::RunJob(
    IN CWorkObject* ptr,
    IN BOOL bImmediate
    )
/*++

Abstract:

    Process a job object via QueueUserWorkItem() Win32 API subject 
    to our max. concurrent job limitation.

Parameter:

    ptr : Pointer to CWorkObject.
    bImmediate : TRUE if job must be process immediately, 
                 FALSE otherwise.

Returns:

    ERROR_SUCCESS or Error code.

--*/
{
    BOOL bSuccess;
    DWORD dwStatus = ERROR_SUCCESS;

    if(ptr != NULL)
    {
        DBGPrintf(
                DBG_INFORMATION,
                DBG_FACILITY_WORKMGR,
                DBGLEVEL_FUNCTION_TRACE,
                _TEXT("WorkManager : RunJob <%s>...\n"),
                ptr->GetJobDescription()
            );

        //
        // Wait if we exceed max. concurrent job
        //
        bSuccess = (bImmediate) ? bImmediate : m_hMaxJobLock.AcquireEx(m_hShutdown);

        if(bSuccess == TRUE)
        {
            DWORD dwFlag;
            DWORD dwJobRunningAttribute;

            dwJobRunningAttribute = ptr->GetJobRunningAttribute();
            dwFlag = TranslateJobRunningAttributeToThreadPoolFlag(
                                                        dwJobRunningAttribute
                                                    );

            dwStatus = AddJobToProcessingList(ptr);
            if(dwStatus == ERROR_SUCCESS)
            {
                DBGPrintf(
                        DBG_INFORMATION,
                        DBG_FACILITY_WORKMGR,
                        DBGLEVEL_FUNCTION_DETAILSIMPLE,
                        _TEXT("RunJob() : queuing user work item %p...\n"),
                        ptr
                    );

                // need immediate attention.
                bSuccess = QueueUserWorkItem(
                                        CWorkManager::ExecuteWorkObject,
                                        ptr,
                                        dwFlag
                                    );

                if(bSuccess == FALSE)
                {
                    dwStatus = GetLastError();

                    DBGPrintf(
                            DBG_ERROR,
                            DBG_FACILITY_WORKMGR,
                            DBGLEVEL_FUNCTION_DETAILSIMPLE,
                            _TEXT("RunJob() : queuing user work item %p failed with 0x%08x...\n"),
                            ptr,
                            dwStatus
                        );

                    //TLSASSERT(dwStatus == ERROR_SUCCESS);
                    dwStatus = RemoveJobFromProcessingList(ptr);
                }
            }
            else
            {
                bSuccess = FALSE;
            }
            
            if(bSuccess == FALSE)
            {
                dwStatus = GetLastError();
                //TLSASSERT(FALSE);
            }

            //
            // release max. concurrent job lock
            //
            if(bImmediate == FALSE)
            {
                m_hMaxJobLock.Release();
            }
        }
        else
        {
            dwStatus = TLS_I_WORKMANAGER_SHUTDOWN;
        }
    }
    else
    {
        SetLastError(dwStatus = ERROR_INVALID_PARAMETER);
    }

    return dwStatus;
}

//------------------------------------------------------------
//
//
CLASS_PRIVATE DWORD
CWorkManager::ProcessScheduledJob()
/*++

Abstract:

    Class private, process a scheduled job.

Parameter:

    None.

Return:

    ERROR_SUCCESS or error code.

--*/
{
    DWORD dwStatus = ERROR_SUCCESS;
    BOOL bSuccess = TRUE;
    BOOL bFlag = FALSE;
  

    DBGPrintf(
            DBG_INFORMATION,
            DBG_FACILITY_WORKMGR,
            DBGLEVEL_FUNCTION_TRACE,
            _TEXT("CWorkManager::ProcessScheduledJob(), %d %d\n"),
            GetNumberJobInStorageQueue(),
            GetNumberJobInMemoryQueue()
        );

    if(GetNumberJobInStorageQueue() != 0 && IsShuttingDown() == FALSE)
    {
        //
        // Could have use work item to process both
        // queue but this uses one extra handle, and
        // work manager thread will just doing nothing
        // 
        ResetEvent(m_hInStorageWait);

        //
        // Queue a user work item to thread pool to process
        // in storage job
        //
        bSuccess = QueueUserWorkItem(
                                    CWorkManager::ProcessInStorageScheduledJob,
                                    this,
                                    WT_EXECUTELONGFUNCTION
                                );
        if(bSuccess == FALSE)
        {
            dwStatus = GetLastError();
            DBGPrintf(
                    DBG_ERROR,
                    DBG_FACILITY_WORKMGR,
                    DBGLEVEL_FUNCTION_DETAILSIMPLE,
                    _TEXT("CWorkManager::ProcessScheduledJob() queue user work iterm returns 0x%08x\n"),
                    dwStatus
                );

            TLSASSERT(dwStatus == ERROR_SUCCESS);
        }
        else
        {
            bFlag = TRUE;
        }
    }

    if(bSuccess == TRUE)
    {
        dwStatus = ProcessInMemoryScheduledJob(this);

        if(bFlag == TRUE)
        {
            if(WaitForObjectOrShutdown(m_hInStorageWait) == FALSE)
            {
                dwStatus = TLS_I_WORKMANAGER_SHUTDOWN;
            }
        }
    }    

    return dwStatus;
}

//------------------------------------------------------------
//
//
CLASS_PRIVATE CLASS_STATIC DWORD WINAPI
CWorkManager::ProcessInMemoryScheduledJob(
    IN PVOID pContext
    )
/*++

Abstract:

    Static class private, process in-memory scheduled jobs.  
    WorkManagerThread kick off two threads, one to process 
    in-memory job and the other to process persistent job.

Parameter:

    pContext : Pointer to work manager object.

Return:

    ERROR_SUCCESS or error code.

--*/
{
    DWORD ulCurrentTime;
    DWORD dwJobTime;
    CWorkObject* pInMemoryWorkObject = NULL;
    BOOL bSuccess = TRUE;
    BOOL dwStatus = ERROR_SUCCESS;
    
    CWorkManager* pWkMgr = (CWorkManager *)pContext;

    DBGPrintf(
            DBG_INFORMATION,
            DBG_FACILITY_WORKMGR,
            DBGLEVEL_FUNCTION_TRACE,
            _TEXT("CWorkManager::ProcessInMemoryScheduledJob()\n")
        );


    if(pWkMgr == NULL)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        TLSASSERT(pWkMgr != NULL);
        return ERROR_INVALID_PARAMETER;
    }

    do {    
        if(pWkMgr->IsShuttingDown() == TRUE)
        {
            dwStatus = TLS_I_WORKMANAGER_SHUTDOWN;
            break;
        }

        ulCurrentTime = time(NULL);
        dwJobTime = ulCurrentTime;
        pInMemoryWorkObject = pWkMgr->GetNextJobInMemoryQueue(&dwJobTime);

        if(pInMemoryWorkObject != NULL)
        {
            // TLSASSERT(dwJobTime <= ulCurrentTime);
            if(dwJobTime <= ulCurrentTime)
            {
                dwStatus = pWkMgr->RunJob(
                                    pInMemoryWorkObject,
                                    FALSE
                                );

                if(dwStatus != ERROR_SUCCESS)
                {
                    //
                    // consider to re-schedule job again.
                    //
                    pInMemoryWorkObject->EndJob();

                    if(pInMemoryWorkObject->CanBeDelete() == TRUE)
                    {
                        pInMemoryWorkObject->SelfDestruct();
                    }
                }
            }
            else
            {
                //
                // Very expansive operation, GetNextJobInMemoryQueue() must be
                // wrong.
                //
                dwStatus = pWkMgr->AddJobIntoMemoryQueue(
                                            dwJobTime, 
                                            pInMemoryWorkObject
                                        );

                if(dwStatus != ERROR_SUCCESS)
                {
                    //
                    // delete the job
                    //
                    pInMemoryWorkObject->EndJob();

                    if(pInMemoryWorkObject->CanBeDelete() == TRUE)
                    {
                        pInMemoryWorkObject->SelfDestruct();
                    }
                }
            }
        }
    } while(dwStatus == ERROR_SUCCESS && (pInMemoryWorkObject != NULL && dwJobTime <= ulCurrentTime));

    return dwStatus;
}

//------------------------------------------------------------
//
//
CLASS_PRIVATE CLASS_STATIC DWORD WINAPI
CWorkManager::ProcessInStorageScheduledJob(
    IN PVOID pContext
    )
/*++

Abstract:

    Static class private, process scheduled persistent jobs.  
    WorkManagerThread kick off two threads, one to process 
    in-memory job and the other to process persistent job.

Parameter:

    pContext : Pointer to work manager object.

Return:

    ERROR_SUCCESS or error code.

--*/
{
    DWORD ulCurrentTime = 0;
    DWORD dwJobScheduledTime = 0;
    CWorkObject* pInStorageWorkObject = NULL;
    DWORD dwStatus = ERROR_SUCCESS;
    BOOL bSuccess = TRUE;
    CWorkManager* pWkMgr = (CWorkManager *)pContext;

    DBGPrintf(
            DBG_INFORMATION,
            DBG_FACILITY_WORKMGR,
            DBGLEVEL_FUNCTION_TRACE,
            _TEXT("CWorkManager::ProcessInStorageScheduledJob()\n")
        );

    if(pWkMgr == NULL)
    {
        TLSASSERT(pWkMgr != NULL);
        SetLastError(ERROR_INVALID_PARAMETER);
        return ERROR_INVALID_PARAMETER;
    }
            
    TLSASSERT(pWkMgr->m_pPersistentWorkStorage != NULL);

    if(pWkMgr->m_pPersistentWorkStorage->GetNumJobs() > 0)
    {
        do
        {
            if(pWkMgr->IsShuttingDown() == TRUE)
            {
                dwStatus = TLS_I_WORKMANAGER_SHUTDOWN;
                break;
            }

            ulCurrentTime = time(NULL);
            pInStorageWorkObject = pWkMgr->m_pPersistentWorkStorage->GetNextJob(&dwJobScheduledTime);

            if(pInStorageWorkObject == NULL)
            {
                //
                // Something wrong in persistent storage???
                //
                DBGPrintf(
                        DBG_WARNING,
                        DBG_FACILITY_WORKMGR,
                        DBGLEVEL_FUNCTION_DETAILSIMPLE,
                        _TEXT("CWorkManager::ProcessInStorageScheduledJob() : Persistent work storage return NULL job\n")
                    );

                break;
            }
            else if(dwJobScheduledTime > ulCurrentTime)
            {
                DBGPrintf(
                        DBG_WARNING,
                        DBG_FACILITY_WORKMGR,
                        DBGLEVEL_FUNCTION_DETAILSIMPLE,
                        _TEXT("CWorkManager::ProcessInStorageScheduledJob() : return job back to persistent storage\n")
                    );

                pWkMgr->m_pPersistentWorkStorage->EndProcessingJob( 
                                                            ENDPROCESSINGJOB_RETURN,
                                                            dwJobScheduledTime,
                                                            pInStorageWorkObject
                                                        );
            }
            else
            {
                pInStorageWorkObject->SetScheduledTime(dwJobScheduledTime);
                pWkMgr->m_pPersistentWorkStorage->BeginProcessingJob(pInStorageWorkObject);

                dwStatus = pWkMgr->RunJob(
                                            pInStorageWorkObject, 
                                            FALSE
                                        );

                if(dwStatus != ERROR_SUCCESS)
                {
                    DBGPrintf(
                            DBG_WARNING,
                            DBG_FACILITY_WORKMGR,
                            DBGLEVEL_FUNCTION_DETAILSIMPLE,
                            _TEXT("CWorkManager::ProcessInStorageScheduledJob() : unable to queue job, return job back ") \
                            _TEXT("to persistent storage\n")
                        );

                    pWkMgr->m_pPersistentWorkStorage->EndProcessingJob( 
                                                                ENDPROCESSINGJOB_RETURN,
                                                                pInStorageWorkObject->GetScheduledTime(),
                                                                pInStorageWorkObject
                                                            );
                }
            }
        } while(dwStatus == ERROR_SUCCESS && ulCurrentTime >= dwJobScheduledTime);
    }

    //
    // Signal we are done
    //
    SetEvent(pWkMgr->m_hInStorageWait);
    return dwStatus;     
}

//------------------------------------------------------------
//
//
CLASS_PRIVATE CLASS_STATIC
unsigned int __stdcall
CWorkManager::WorkManagerThread(
    IN PVOID pContext
    )
/*++

Abstract:

    Static class private, this is the work manager thread to handle
    job scheduling and process scheduled job.  WorkManagerThread() 
    will not terminate until m_hShutdown event is signal.

Parameter:
    
    pContext : Pointer to work manager object.

Returns:

    ERROR_SUCCESS

--*/
{
    DWORD dwTimeToNextJob = INFINITE;
    CWorkManager* pWkMgr = (CWorkManager *)pContext;
    DWORD dwHandleFlag;
    
    TLSASSERT(pWkMgr != NULL);
    TLSASSERT(GetHandleInformation(pWkMgr->m_hNewJobArrive, &dwHandleFlag) == TRUE);
    TLSASSERT(GetHandleInformation(pWkMgr->m_hShutdown, &dwHandleFlag) == TRUE);

    HANDLE m_hWaitHandles[] = {pWkMgr->m_hShutdown, pWkMgr->m_hNewJobArrive};
    DWORD dwWaitStatus = WAIT_TIMEOUT;
    DWORD dwStatus = ERROR_SUCCESS;
    
    //
    // Get the time to next job
    // 
    while(dwWaitStatus != WAIT_OBJECT_0 && dwStatus == ERROR_SUCCESS)
    {
        DBGPrintf(
                DBG_INFORMATION,
                DBG_FACILITY_WORKMGR,
                DBGLEVEL_FUNCTION_TRACE,
                _TEXT("CWorkManager::WorkManagerThread() : Time to next job %d\n"),
                dwTimeToNextJob
            );
        
        dwWaitStatus = WaitForMultipleObjectsEx(
                                            sizeof(m_hWaitHandles) / sizeof(m_hWaitHandles[0]),
                                            m_hWaitHandles,
                                            FALSE,
                                            dwTimeToNextJob * 1000,
                                            TRUE        // we might need this thread to do some work 
                                        );

        switch( dwWaitStatus )
        {
            case WAIT_OBJECT_0:
                dwStatus = ERROR_SUCCESS;

                DBGPrintf(
                        DBG_INFORMATION,
                        DBG_FACILITY_WORKMGR,
                        DBGLEVEL_FUNCTION_DETAILSIMPLE,
                        _TEXT("CWorkManager::WorkManagerThread() : shutdown ...\n")
                    );

                break;

            case WAIT_OBJECT_0 + 1:
                // still a possibility that we might not catch a new job
                ResetEvent(pWkMgr->m_hNewJobArrive);
    
                // New Job arrived
                dwTimeToNextJob = pWkMgr->GetTimeToNextJob();
                break;
        
            case WAIT_TIMEOUT:
                // Time to process job.
                dwStatus = pWkMgr->ProcessScheduledJob();
                dwTimeToNextJob = pWkMgr->GetTimeToNextJob();
                break;

            default:
                DBGPrintf(
                        DBG_ERROR,
                        DBG_FACILITY_WORKMGR,
                        DBGLEVEL_FUNCTION_DETAILSIMPLE,
                        _TEXT("CWorkManager::WorkManagerThread() : unexpected return %d\n"),
                        dwStatus
                    );

                dwStatus = TLS_E_WORKMANAGER_INTERNAL;
                TLSASSERT(FALSE);
        }
    }

    if(dwStatus != ERROR_SUCCESS && dwStatus != TLS_I_WORKMANAGER_SHUTDOWN)
    {
        DBGPrintf(
                DBG_ERROR,
                DBG_FACILITY_WORKMGR,
                DBGLEVEL_FUNCTION_DETAILSIMPLE,
                _TEXT("CWorkManager::WorkManagerThread() : unexpected return %d, generate console event\n"),
                dwStatus
            );

        // immediately shut down server
        GenerateConsoleCtrlEvent(CTRL_C_EVENT, 0);
    }
            
    _endthreadex(dwStatus);
    return dwStatus;
}

//----------------------------------------------------------------
//
//
CLASS_PRIVATE CLASS_STATIC 
DWORD WINAPI
CWorkManager::ExecuteWorkObject(
    IN PVOID pContext
    )
/*++

Abstract:

    Static class private, execute a work object.

Parameter:

    pContext : Pointer to work object to be process.

Returns:

    ERROR_SUCCESS or error code.
    
--*/
{
    DWORD dwStatus = ERROR_SUCCESS;
    CWorkObject* pWorkObject = (CWorkObject *)pContext;
    DWORD dwJobRescheduleTime;
    BOOL bStorageJobCompleted;
    CWorkManager* pWkMgr = NULL;
    BOOL bPersistentJob = FALSE;


    if(pContext == NULL)
    {
        TLSASSERT(FALSE);
        dwStatus = ERROR_INVALID_PARAMETER;
        return dwStatus;
    }

    DBGPrintf(
            DBG_INFORMATION,
            DBG_FACILITY_WORKMGR,
            DBGLEVEL_FUNCTION_TRACE,
            _TEXT("CWorkManager::ExecuteWorkObject() : executing %p <%s>\n"),
            pWorkObject,
            pWorkObject->GetJobDescription()
        );

    //
    // Set RPC cancel timeout, thread dependent.
    (VOID)RpcMgmtSetCancelTimeout(DEFAULT_RPCCANCEL_TIMEOUT);

    bPersistentJob = pWorkObject->IsWorkPersistent();

    pWkMgr = pWorkObject->GetWorkManager();

    if(pWkMgr != NULL)
    {
        pWkMgr->SignalJobRunning(pWorkObject);   // tell work manager that we are running

        pWorkObject->ExecuteWorkObject();

        if(bPersistentJob == TRUE)
        {
            //
            // Persistent work object, let work storage handle
            // its re-scheduling
            //
            bStorageJobCompleted = pWorkObject->IsJobCompleted();
        
            pWorkObject->GetWorkManager()->m_pPersistentWorkStorage->EndProcessingJob(
                                                                                ENDPROCESSINGJOB_SUCCESS,
                                                                                pWorkObject->GetScheduledTime(),
                                                                                pWorkObject
                                                                            );

            if(bStorageJobCompleted == FALSE)
            {
                //
                // This job might be re-scheduled 
                // before our work manager thread wakes up, 
                // so signal job is ready 
                //
                pWkMgr->SignalJobArrive();
            }
        }
        else
        {
            //
            // Reschedule job if necessary
            //
            dwJobRescheduleTime = pWorkObject->GetSuggestedScheduledTime();
            if(dwJobRescheduleTime != INFINITE)
            {
                dwStatus = pWorkObject->ScheduleJob(dwJobRescheduleTime);
            }

            if(dwJobRescheduleTime == INFINITE || dwStatus != ERROR_SUCCESS)
            {
                //
                // if can't schedule job again, go ahead and delete it.
                //
                pWorkObject->EndJob();
                if(pWorkObject->CanBeDelete() == TRUE)
                {
                    pWorkObject->SelfDestruct();
                }
            }                
        }
    }   

    if(pWkMgr)
    {
        // Delete this job from in-processing list.
        pWkMgr->EndProcessingScheduledJob(pWorkObject);
    }    

    return dwStatus;
}

//----------------------------------------------------------------
//
//
CWorkManager::CWorkManager() :
m_hWorkMgrThread(NULL),
m_hNewJobArrive(NULL),
m_hShutdown(NULL),
m_hInStorageWait(NULL),
m_hJobInProcessing(NULL),
m_dwNextInMemoryJobTime(WORKMANAGER_WAIT_FOREVER),
m_dwNextInStorageJobTime(WORKMANAGER_WAIT_FOREVER),
m_dwMaxCurrentJob(DEFAULT_NUM_CONCURRENTJOB),
m_dwDefaultInterval(DEFAULT_WORK_INTERVAL)
{
}


//----------------------------------------------------------------
//
CWorkManager::~CWorkManager()
{
    Shutdown();

    if(m_hNewJobArrive != NULL)
    {
        CloseHandle(m_hNewJobArrive);
    }

    if(m_hWorkMgrThread != NULL)
    {
        CloseHandle(m_hWorkMgrThread);
    }

    if(m_hShutdown != NULL)
    {
        CloseHandle(m_hShutdown);
    }

    if(m_hInStorageWait != NULL)
    {
        CloseHandle(m_hInStorageWait);
    }

    if(m_hJobInProcessing != NULL)
    {
        CloseHandle(m_hJobInProcessing);
    }
}

//----------------------------------------------------------------
//
DWORD
CWorkManager::Startup(
    IN CWorkStorage* pPersistentWorkStorage,
    IN DWORD dwWorkInterval,            // DEFAULT_WORK_INTERVAL
    IN DWORD dwNumConcurrentJob         // DEFAULT_NUM_CONCURRENTJOB
    )

/*++

Abstract:

    Initialize work manager

Parameters:

    pPersistentWorkStorage : A C++ object that derived from CPersistentWorkStorage class
    dwWorkInterval : Default schedule job interval
    dwNumConcurrentJob : Max. number of concurrent job to be fired at the same time

Return:

    ERROR_SUCCESS or Erro Code.

--*/

{
    DWORD index;
    DWORD dwStatus = ERROR_SUCCESS;
    unsigned dump;
    BOOL bSuccess;
    unsigned threadid;

    #ifdef __TEST_WORKMGR__
    _set_new_handler(handle_new_failed);
    #endif


    if(dwNumConcurrentJob == 0 || dwWorkInterval == 0 || pPersistentWorkStorage == NULL)
    {
        SetLastError(dwStatus = ERROR_INVALID_PARAMETER);
        goto cleanup;
    }

    if(m_hMaxJobLock.IsGood() == FALSE)
    {
        if(m_hMaxJobLock.Init(dwNumConcurrentJob, dwNumConcurrentJob) == FALSE)
        {
            //
            // out of resource
            //
            dwStatus = GetLastError();
            goto cleanup;
        }
    }

    m_dwDefaultInterval = dwWorkInterval;
    m_dwMaxCurrentJob = dwNumConcurrentJob;
    m_pPersistentWorkStorage = pPersistentWorkStorage;


    if(m_hJobInProcessing == NULL)
    {
        //
        // initial state is signal, no job in processing
        //
        m_hJobInProcessing = CreateEvent(
                                        NULL,
                                        TRUE,
                                        TRUE,
                                        NULL
                                    );
        if(m_hJobInProcessing == NULL)
        {
            dwStatus = GetLastError();
            goto cleanup;
        }
    }


    if(m_hShutdown == NULL)
    {
        //
        // Create a handle for signaling shutdown
        //
        m_hShutdown = CreateEvent(
                                NULL,
                                TRUE,
                                FALSE,
                                NULL
                            );

        if(m_hShutdown == NULL)
        {
            dwStatus = GetLastError();
            goto cleanup;
        }
    }

    if(m_hNewJobArrive == NULL)
    {
        //
        // initial state is signal so work manager thread can
        // update wait time
        //
        m_hNewJobArrive = CreateEvent(
                                    NULL,
                                    TRUE,
                                    TRUE,
                                    NULL
                                );

        if(m_hNewJobArrive == NULL)
        {
            dwStatus = GetLastError();
            goto cleanup;
        }
    }

    if(m_hInStorageWait == NULL)
    {
        m_hInStorageWait = CreateEvent(
                                    NULL,
                                    TRUE,
                                    TRUE, // signal state
                                    NULL
                                );

        if(m_hInStorageWait == NULL)
        {
            dwStatus = GetLastError();
            goto cleanup;
        }
    }

    //
    // Startup Work Storage first.
    //
    if(m_pPersistentWorkStorage->Startup(this) == FALSE)
    {
        DBGPrintf(
                DBG_ERROR,
                DBG_FACILITY_WORKMGR,
                DBGLEVEL_FUNCTION_DETAILSIMPLE,
                _TEXT("CWorkManager::Startup() : Persistent storage has failed to startup - 0x%08x\n"),
                GetLastError()
            );
        
        dwStatus = GetLastError();

        if (dwStatus == ERROR_SUCCESS)
            dwStatus = TLS_E_WORKMANAGER_PERSISTENJOB;

        goto cleanup;
    }

    //
    // Get time to next persistent job.
    //
    if(UpdateTimeToNextPersistentJob() == FALSE)
    {
        dwStatus = TLS_E_WORKMANAGER_PERSISTENJOB;
        goto cleanup;
    }

    if(m_hWorkMgrThread == NULL)
    {
        //
        // Create work manager thread, suspended first
        //
        m_hWorkMgrThread = (HANDLE)_beginthreadex(
                                            NULL,
                                            0,
                                            CWorkManager::WorkManagerThread,
                                            this,
                                            0,
                                            &threadid
                                        );

        if(m_hWorkMgrThread == NULL)
        {
            dwStatus = GetLastError();
            goto cleanup;
        }
    }

cleanup:

    return dwStatus;
}    

//----------------------------------------------------------------
void
CWorkManager::Shutdown()
/*++

Abstract:

    Shutdown work manager.

Parameter:

    None.

Return:

    None.

--*/
{
    HANDLE handles[] = {m_hInStorageWait, m_hJobInProcessing};
    DWORD dwStatus;

    //
    // Signal we are shuting down
    //
    if(m_hShutdown != NULL)
    {
        SetEvent(m_hShutdown);
    }


    //
    // Wait for dispatch thread to terminate so no job can be
    // dispatched.
    //
    if(m_hWorkMgrThread != NULL)
    {
        dwStatus = WaitForSingleObject( 
                                    m_hWorkMgrThread,
                                    INFINITE
                                );

        TLSASSERT(dwStatus != WAIT_FAILED);
        CloseHandle(m_hWorkMgrThread);
        m_hWorkMgrThread = NULL;
    }

    //
    // Cancel all in progress job
    //
    CancelInProcessingJob();

    //
    // Inform all existing job to shutdown.
    //
    DeleteAllJobsInMemoryQueue();

    //
    // Wait for all processing job to terminate
    //
    if(m_hInStorageWait != NULL && m_hJobInProcessing != NULL)
    {
        dwStatus = WaitForMultipleObjects(
                                sizeof(handles)/sizeof(handles[0]),
                                handles,
                                TRUE,
                                INFINITE
                            );

        TLSASSERT(dwStatus != WAIT_FAILED);

        CloseHandle(m_hInStorageWait);
        m_hInStorageWait = NULL;

        CloseHandle(m_hJobInProcessing);
        m_hJobInProcessing = NULL;
    }

    if(m_pPersistentWorkStorage != NULL)
    {
        //
        // Signal we are shutting down, no job is in
        // processing and we are not taking any
        // new job
        //
        m_pPersistentWorkStorage->Shutdown();
        m_pPersistentWorkStorage = NULL;
    }
   
    TLSASSERT( GetNumberJobInProcessing() == 0 );
    // TLSASSERT( GetNumberJobInMemoryQueue() == 0 );

    if(m_hNewJobArrive != NULL)
    {
        CloseHandle(m_hNewJobArrive);
        m_hNewJobArrive = NULL;
    }

    if(m_hWorkMgrThread != NULL)
    {
        CloseHandle(m_hWorkMgrThread);
        m_hWorkMgrThread = NULL;   
    }

    if(m_hShutdown != NULL)
    {
        CloseHandle(m_hShutdown);
        m_hShutdown = NULL;
    }

    if(m_hInStorageWait != NULL)
    {
        CloseHandle(m_hInStorageWait);
        m_hInStorageWait = NULL;
    }

    if(m_hJobInProcessing != NULL)
    {
        CloseHandle(m_hJobInProcessing);
        m_hJobInProcessing = NULL;
    }

    return;
}

//----------------------------------------------------------------
CLASS_PRIVATE DWORD
CWorkManager::GetTimeToNextJob()
/*++

Abstract:

    Class private, return time to next scheduled job.

Parameter:

    None.

Return:

    Time to next job in second.

--*/
{
    DWORD dwNextJobTime = WORKMANAGER_WAIT_FOREVER;
    DWORD dwNumPersistentJob = GetNumberJobInStorageQueue();
    DWORD dwNumInMemoryJob = GetNumberJobInMemoryQueue();
    DWORD dwCurrentTime = time(NULL);

    if( dwNumPersistentJob == 0 && dwNumInMemoryJob == 0 )
    {
        // DO NOTHING

        // dwTimeToNextJob = WORKMANAGER_WAIT_FOREVER;
    }
    else
    {
        UpdateTimeToNextInMemoryJob();
        UpdateTimeToNextPersistentJob();

        dwNextJobTime = min((DWORD)m_dwNextInMemoryJobTime, (DWORD)m_dwNextInStorageJobTime);

        if((DWORD)dwNextJobTime < (DWORD)dwCurrentTime)
        {
            dwNextJobTime = 0;
        }
        else
        {
            dwNextJobTime -= dwCurrentTime;
        }
    }

    return dwNextJobTime;
}

//----------------------------------------------------------------
//
CLASS_PRIVATE CWorkObject* 
CWorkManager::GetNextJobInMemoryQueue(
    PDWORD pdwTime
    )
/*++

Abstract:

    Class private, return pointer to next scheduled 
    in memory job.

Parameter:

    pdwTime : Pointer to DWORD to receive time to the 
              scheduled job.

Returns:

    Pointer to CWorkObject.

Note:

    Remove the job from queue if job is <= time.

--*/
{
    SCHEDULEJOBMAP::iterator it;
    DWORD dwWantedJobTime;
    CWorkObject* ptr = NULL;

    SetLastError(ERROR_SUCCESS);

    if(pdwTime != NULL)
    {
        dwWantedJobTime = *pdwTime;
        m_JobLock.Acquire(READER_LOCK);

        it = m_Jobs.begin();
        if(it != m_Jobs.end())
        {
            *pdwTime = (*it).first;

            if(dwWantedJobTime >= *pdwTime)
            {
                ptr = (*it).second;

                // remove job from queue
                m_Jobs.erase(it);
            }
        }
        m_JobLock.Release(READER_LOCK);
    }
    else
    {
        SetLastError(ERROR_INVALID_PARAMETER);
    }

    return ptr;
}

//----------------------------------------------------------------
//
CLASS_PRIVATE void
CWorkManager::DeleteAllJobsInMemoryQueue()
/*++

Abstract:

    Class private, unconditionally delete all in-memory job.

Parameter:

    None.

Return:

    None.

--*/
{
    m_JobLock.Acquire(WRITER_LOCK);

    SCHEDULEJOBMAP::iterator it;

    for(it = m_Jobs.begin(); it != m_Jobs.end(); it++)
    {
        //
        // let calling routine to delete it
        //
        (*it).second->EndJob();
        if((*it).second->CanBeDelete() == TRUE)
        {
            (*it).second->SelfDestruct();
        }
        (*it).second = NULL;        
    }

    m_Jobs.erase(m_Jobs.begin(), m_Jobs.end());
    m_JobLock.Release(WRITER_LOCK);
    return;
}

//----------------------------------------------------------------
//
CLASS_PRIVATE BOOL
CWorkManager::RemoveJobFromInMemoryQueue(
    IN DWORD ulTime,
    IN CWorkObject* ptr
    )
/*++

Abstract:

    Class private, remove a scheduled job.

Parameters:

    ulTime : Job scheduled time.
    ptr : Pointer to Job to be deleted.

Returns:

    TRUE/FALSE.

Note:

    A job might be scheduled multiple time so we
    need to pass in the time.

--*/
{
    BOOL bSuccess = FALSE;

    m_JobLock.Acquire(WRITER_LOCK);

    SCHEDULEJOBMAP::iterator low = m_Jobs.lower_bound(ulTime);
    SCHEDULEJOBMAP::iterator high = m_Jobs.upper_bound(ulTime);

    for(;low != m_Jobs.end() && low != high; low++)
    {
        if( (*low).second == ptr )
        {
            //
            // let calling routine to delete it
            //
            (*low).second = NULL;
            m_Jobs.erase(low);
            bSuccess = TRUE;
            break;
        }
    }

    if(bSuccess == FALSE)
    {
        SetLastError(ERROR_INVALID_DATA);
        TLSASSERT(FALSE);
    }

    m_JobLock.Release(WRITER_LOCK);
         
    return bSuccess;
}
//----------------------------------------------------------------
//
CLASS_PRIVATE DWORD
CWorkManager::AddJobIntoMemoryQueue(
    IN DWORD dwTime,            // suggested scheduled time
    IN CWorkObject* pJob        // Job to be scheduled
    )
/*++

Abstract:

    Class private, add a job into in-memory list.

Parameters:

    dwTime : suggested scheduled time.
    pJob : Pointer to job to be added.

Returns:

    ERROR_SUCCESS or error code.

--*/
{
    DWORD dwStatus = ERROR_SUCCESS;
    BOOL bSuccess = FALSE;
    DWORD dwJobScheduleTime = time(NULL) + dwTime;

    if(IsShuttingDown() == TRUE)
    {
        dwStatus = TLS_I_WORKMANAGER_SHUTDOWN;
        return dwStatus;
    }

    m_JobLock.Acquire(WRITER_LOCK);

    //
    // insert a job into our queue
    //
    m_Jobs.insert( SCHEDULEJOBMAP::value_type( dwJobScheduleTime, pJob ) );
    AddJobUpdateInMemoryJobWaitTimer(dwJobScheduleTime);
    
    m_JobLock.Release(WRITER_LOCK);
    return dwStatus;
}   
        
//----------------------------------------------------------------
//
DWORD
CWorkManager::ScheduleJob(
    IN DWORD ulTime,            // suggested scheduled time
    IN CWorkObject* pJob        // Job to be scheduled
    )

/*++

Abstract:

    Schedule a job at time relative to current time

Parameters:
    
    ulTime : suggested scheduled time.
    pJob : Pointer to job to be scheduled

Returns:

    ERROR_SUCCESS or error code.

--*/

{
    BOOL bSuccess = TRUE;
    DWORD dwStatus = ERROR_SUCCESS;

    if(pJob == NULL)
    {
        SetLastError(dwStatus = ERROR_INVALID_PARAMETER);
        goto cleanup;
    }

    if(IsShuttingDown() == TRUE)
    {
        SetLastError(dwStatus = TLS_I_WORKMANAGER_SHUTDOWN);
        goto cleanup;
    }

    DBGPrintf(
            DBG_INFORMATION,
            DBG_FACILITY_WORKMGR,
            DBGLEVEL_FUNCTION_TRACE,
            _TEXT("CWorkManager::ScheduleJob() : schedule job <%s> to queue at time %d\n"),
            pJob->GetJobDescription(),
            ulTime
        );

    pJob->SetProcessingWorkManager(this);

    if(ulTime == INFINITE && pJob->IsWorkPersistent() == FALSE)
    {
        //
        // Only in-memory job can be executed at once.
        //
        dwStatus = RunJob(pJob, TRUE);
    }
    else 
    {
        if(pJob->IsWorkPersistent() == TRUE)
        {
            if(m_pPersistentWorkStorage->AddJob(ulTime, pJob) == FALSE)
            {
                dwStatus = TLS_E_WORKMANAGER_PERSISTENJOB;
            }                
        }
        else
        {
            //
            // insert a workobject into job queue, reason not to
            // use RegisterWaitForSingleObject() or threadpool's timer
            // is that we don't need to track handle nor wait for 
            // DeleteTimerXXX to finish
            //
            dwStatus = AddJobIntoMemoryQueue(
                                        ulTime, // Memory queue is absolute time
                                        pJob
                                    );
        }

        if(dwStatus == ERROR_SUCCESS)
        {
            if(SignalJobArrive() == FALSE)
            {
                dwStatus = GetLastError();
                TLSASSERT(FALSE);
            }
        }
    }

cleanup:

    return dwStatus;
}


///////////////////////////////////////////////////////////////
//
// CWorkObject base class
//
CWorkObject::CWorkObject(
    IN BOOL bDestructorDelete /* = FALSE */
    ) : 
m_dwLastRunStatus(ERROR_SUCCESS),
m_refCount(0),
m_pWkMgr(NULL),
m_bCanBeFree(bDestructorDelete)
{
}

//----------------------------------------------------------
DWORD
CWorkObject::Init(
    IN BOOL bDestructorDelete  /* = FALSE */
    )
/*++

Abstract:

    Initialize a work object.

Parameter:

    bDestructorDelete : TRUE if destructor should delete the memory,
                        FALSE otherwise.

Returns:

    ERROR_SUCCESS or error code.

Note:

    if bDestructorDelete is FALSE, memory will not be free.

--*/
{
    m_dwLastRunStatus = ERROR_SUCCESS;
    m_refCount = 0;
    m_bCanBeFree = bDestructorDelete;
    return ERROR_SUCCESS;
} 

//----------------------------------------------------------
CLASS_PRIVATE long
CWorkObject::GetReferenceCount() 
/*++

Abstract:

    Return reference count of work object.

Parameter:

    None.

Return:

    Reference count.

--*/
{
    return m_refCount;
}

//----------------------------------------------------------
CLASS_PRIVATE void
CWorkObject::IncrementRefCount()
/*++

Abstract:

    Increment object's reference counter.

Parameter:

    None.

Return:

    None.

--*/
{
    InterlockedIncrement(&m_refCount); 
}

//----------------------------------------------------------
CLASS_PRIVATE void
CWorkObject::DecrementRefCount() 
/*++

Abstract:

    Decrement object's reference counter.

Parameter:

    None.

Return:

    None.

--*/
{ 
    InterlockedDecrement(&m_refCount); 
}

//----------------------------------------------------------
CLASS_PRIVATE void
CWorkObject::ExecuteWorkObject() 
/*++

Abstract:

    Execute a work object.  Work manager invoke work object's
    ExecuteWorkObject so that base class can set its reference 
    counter.

Parameter:

    None.

Return:

    None.

--*/
{
    if(IsValid() == TRUE)
    {
        IncrementRefCount();
        m_dwLastRunStatus = Execute();
        DecrementRefCount(); 
    }
    else
    {
        m_dwLastRunStatus = ERROR_INVALID_DATA;
        TLSASSERT(FALSE);
    }
}

//----------------------------------------------------------
CLASS_PRIVATE void
CWorkObject::EndExecuteWorkObject() 
/*++

Abstract:

    End a job, this does not terminate job currently in 
    processing, it remove the job from work manager's in-processing
    list

Parameter:

    None.

Return:

    None.    

--*/
{
    TLSASSERT(IsValid() == TRUE);
    m_pWkMgr->EndProcessingScheduledJob(this);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\license\tlserver\server\jobmgr.h ===
//+--------------------------------------------------------------------------
//
// Copyright (c) 1997-1999 Microsoft Corporation
//
// File:        jobmgr.h
//
// Contents:    
//
// History:     
//
//---------------------------------------------------------------------------
#ifndef __WORKMANAGER_H__
#define __WORKMANAGER_H__
#include <new.h>
#include <eh.h>

#include "tlsstl.h"
#include "dbgout.h"
#include "locks.h"
#include "tlsassrt.h"
#include "license.h"
#include "tlsapip.h"
#include "tlspol.h"

//
// Default cancel timeout is 5 seconds
//
#define DEFAULT_RPCCANCEL_TIMEOUT       5


//
// Default interval time is 15 mins.
//
#define DEFAULT_WORK_INTERVAL       15*60*1000

//
// Default shutdown wait time
//   
#define DEFAULT_SHUTDOWN_TIME       60*2*1000

//
// Max. Number of concurrent Jobs
//
#define DEFAULT_NUM_CONCURRENTJOB   50

//
// 
//
#define WORKMANAGER_TIMER_PERIOD_TIMER  0xFFFFFFFF  // see RtlUpdateTimer()
#define WORKMANAGER_WAIT_FOREVER        INFINITE

#define CLASS_PRIVATE
#define CLASS_STATIC

class CWorkManager;
class CWorkObject;


#ifdef __TEST_WORKMGR__
#define DBGCONSOLE          GetStdHandle(STD_OUTPUT_HANDLE)
#else
#define DBGCONSOLE          NULL        
#endif
     

//--------------------------------------------------------------
//
// Work Object initialization function, each work object 
// must supply its own initialization routine to work 
// manager.
//
typedef enum {
    JOBDURATION_UNKNOWN=0,
    JOBDURATION_RUNONCE,        // Run Once Work
    JOBDURATION_SESSION,        // Session Job
    JOBDURATION_PERSISTENT      // Persistent Job
} JOBDURATION;

#define JOB_SHORT_LIVE          0x00000001
#define JOB_INCLUDES_IO         0x00000002
#define JOB_LONG_RUNNING        0x00000004

#define WORK_TYPE_UNKNOWN    0x00000000

#ifndef AllocateMemory

    #define AllocateMemory(size) \
        LocalAlloc(LPTR, size)
#endif

#ifndef FreeMemory

    #define FreeMemory(ptr) \
        if(ptr)             \
        {                   \
            LocalFree(ptr); \
            ptr=NULL;       \
        }

#endif

#ifndef ReallocateMemory

    #define ReallocateMemory(ptr, size)                 \
                LocalReAlloc(ptr, size, LMEM_ZEROINIT)

#endif

//------------------------------------------------------
//
class MyCSemaphore {
private:

    HANDLE  m_semaphore;
    long   m_TryEntry;
    long   m_Acquired;
    long   m_Max;

public:
    MyCSemaphore() : m_semaphore(NULL), m_TryEntry(0), m_Acquired(0), m_Max(0) {}

    //--------------------------------------------------
    const long
    GetTryEntryCount() { return m_TryEntry; }

    //--------------------------------------------------
    const long
    GetAcquiredCount() { return m_Acquired; }

    //--------------------------------------------------
    const long
    GetMaxCount() { return m_Max; }

    
    //--------------------------------------------------
    BOOL
    Init(
        LONG lInitCount, 
        LONG lMaxCount 
        )
    /*++

    --*/
    {
        m_semaphore=CreateSemaphore(
                                NULL, 
                                lInitCount, 
                                lMaxCount, 
                                NULL
                            );

        m_Max = lMaxCount;
        m_TryEntry = 0;
        m_Acquired = 0;
        TLSASSERT(m_semaphore != NULL);
        return m_semaphore != NULL;
    }

    //--------------------------------------------------
    ~MyCSemaphore()
    {
        TLSASSERT(m_Acquired == 0);
        TLSASSERT(m_TryEntry == 0);

        if(m_semaphore)
        {
            CloseHandle(m_semaphore);
        }
    }

    //--------------------------------------------------
    BOOL
    AcquireEx(
        HANDLE hHandle,
        DWORD dwWaitTime=INFINITE,
        BOOL bAlertable=FALSE
        )
    /*++

    --*/
    {
        BOOL bSuccess = TRUE;
        DWORD dwStatus;
        HANDLE hHandles[] = {m_semaphore, hHandle};

        TLSASSERT(IsGood() == TRUE);

        if(hHandle == NULL || hHandle == INVALID_HANDLE_VALUE)
        {
            SetLastError(ERROR_INVALID_PARAMETER);
            bSuccess = FALSE;
        }
        else
        {
            InterlockedIncrement(&m_TryEntry);

            dwStatus = WaitForMultipleObjectsEx(
                                        sizeof(hHandles)/sizeof(hHandles[0]),
                                        hHandles,
                                        FALSE,
                                        dwWaitTime,
                                        bAlertable
                                    );

            if(dwStatus == WAIT_OBJECT_0)
            {
                InterlockedIncrement(&m_Acquired);
            }
            else
            {
                bSuccess = FALSE;
            }

            InterlockedDecrement(&m_TryEntry);
        }

        return bSuccess;
    }

    //--------------------------------------------------
    DWORD 
    Acquire(
        DWORD dwWaitTime=INFINITE, 
        BOOL bAlertable=FALSE
    )
    /*++

    --*/
    {
        DWORD dwStatus;

        TLSASSERT(IsGood() == TRUE);

        InterlockedIncrement(&m_TryEntry);

        dwStatus = WaitForSingleObjectEx(
                                m_semaphore, 
                                dwWaitTime, 
                                bAlertable
                            );

        if(dwStatus == WAIT_OBJECT_0)
        {
            InterlockedIncrement(&m_Acquired);
        }

        InterlockedDecrement(&m_TryEntry);
        return dwStatus;
    }

    //--------------------------------------------------
    BOOL 
    Release(
        long count=1
    )
    /*++

    --*/
    {
        BOOL bSuccess;

        TLSASSERT(IsGood() == TRUE);
        
        bSuccess = ReleaseSemaphore(
                                m_semaphore, 
                                count, 
                                NULL
                            );

        if(bSuccess == TRUE)
        {
            InterlockedDecrement(&m_Acquired);
        }

        return bSuccess;
    }

    //--------------------------------------------------
    BOOL 
    IsGood()
    /*++

    --*/
    {
        return m_semaphore != NULL;
    }

    //--------------------------------------------------
    const HANDLE 
    GetHandle() 
    {
        return m_semaphore;
    }
};


//-------------------------------------------------------------
// 
// Pure virtual base class for CWorkManager to store persistent
// work object.
//

typedef enum {
    ENDPROCESSINGJOB_RETURN=0,      // unable to process job, wait for next term.
    ENDPROCESSINGJOB_SUCCESS,       // job completed.
    ENDPROCESSINGJOB_ERROR          // error in processing this job
} ENDPROCESSINGJOB_CODE;


class CWorkStorage {
    friend class CWorkManager;

protected:
    CWorkManager* m_pWkMgr;

public:
    
    CWorkStorage(
        CWorkManager* pWkMgr=NULL
        ) : 
        m_pWkMgr(pWkMgr) {}

    ~CWorkStorage()   {}

    //---------------------------------------------------    
    CWorkManager*
    GetWorkManager() { 
        return m_pWkMgr; 
    }


    //---------------------------------------------------
    virtual BOOL
    Startup(
        IN CWorkManager* pWkMgr
        )
    /*++

    --*/
    {
        if(pWkMgr != NULL)
        {
            m_pWkMgr = pWkMgr;
        }
        else
        {
            SetLastError(ERROR_INVALID_PARAMETER);
        }

        return pWkMgr != NULL;
    }

    //---------------------------------------------------
    virtual BOOL
    Shutdown() = 0;

    virtual BOOL
    AddJob(
        IN DWORD dwTime,        // relative to current time
        IN CWorkObject* ptr     // Pointer to work object
    ) = 0;

    //virtual BOOL
    //JobEnumBegin(
    //    DWORD dwLowScheduleTime=0,
    //    DWORD dwHighScheduleTime=0
    //) = 0;

    //
    // Return time to next job
    virtual DWORD
    GetNextJobTime() = 0;

    // 
    // return job to be processed next
    virtual CWorkObject*
    GetNextJob(PDWORD pdwTime) = 0;

    //
    // Inform storage that we are processing this job
    virtual BOOL
    BeginProcessingJob(
        IN CWorkObject* pJob
    ) = 0;

    // Inform storage that this job has completed
    virtual BOOL
    EndProcessingJob(
        IN ENDPROCESSINGJOB_CODE opCode,
        IN DWORD dwOriginalScheduledTime,
        IN CWorkObject* pJob
    ) = 0;

    //virtual BOOL
    //JobEnumEnd() = 0;

    virtual DWORD
    GetNumJobs() = 0;
};

//-------------------------------------------------------------
//
typedef struct _ScheduleJob {
    DWORD        m_ulScheduleTime;      // absolute time
    CWorkObject* m_pWorkObject;
} SCHEDULEJOB, *PSCHEDULEJOB, *LPSCHEDULEJOB;

inline bool 
operator<(
    const struct _ScheduleJob& a,
    const struct _ScheduleJob& b
    ) 
/*++

--*/
{
    return a.m_ulScheduleTime < b.m_ulScheduleTime; 
}

//-------------------------------------------------------------
//
// TODO : Re-design our in-memory job as a plugin like persistent
// Job.
//
//-------------------------------------------------------------

class CWorkManager {
    friend class CWorkObject;

private:

    typedef struct {
        BOOL bProcessInMemory;
        CWorkManager* pWorkMgr;
    } WorkManagerProcessContext, *PWorkManagerProcessContext;

    //
    // Schedule job might be at the same time, so use multimap
    // TODO : Need to move this into template.
    //
    // All in memory job schedule time are in absolute time
    //
    typedef multimap<DWORD, CWorkObject* > SCHEDULEJOBMAP;
    SCHEDULEJOBMAP  m_Jobs;                 // schedule jobs.
    CRWLock         m_JobLock;              // Schedule Job Lock

    typedef struct {
        long m_refCounter;
        HANDLE m_hThread;
    } WorkMangerInProcessJob;

    typedef map<PVOID, WorkMangerInProcessJob > INPROCESSINGJOBLIST;
    CCriticalSection     m_InProcessingListLock;
    INPROCESSINGJOBLIST m_InProcessingList;
    HANDLE          m_hJobInProcessing;     // signal if no job, non-signal
                                            // if job currently in process

    HANDLE          m_hWorkMgrThread;
    HANDLE          m_hNewJobArrive;
    HANDLE          m_hShutdown;            // shutdown timer.

    HANDLE          m_hInStorageWait;

    // relative time to next schedule job
    //CCriticalSection m_JobTimeLock;

    //CMyCounter      m_dwNextInStorageJobTime;
    //CMyCounter      m_dwNextInMemoryJobTime;

    CSafeCounter    m_dwNextInStorageJobTime;
    CSafeCounter    m_dwNextInMemoryJobTime;



    //DWORD           m_dwNextInMemoryJobTime;    // Absolute time.
    //DWORD           m_dwNextInStorageJobTime;   // Absolute time.

    long            m_NumJobInProcess;

    // 
    // Default interval to process job
    DWORD           m_dwDefaultInterval;    

    // Max. concurrent job, not use 
    DWORD           m_dwMaxCurrentJob;      
    MyCSemaphore    m_hMaxJobLock;

    CWorkStorage* m_pPersistentWorkStorage;

private:
    //-------------------------------------------------------------
    DWORD
    AddJobToProcessingList(
        CWorkObject* ptr
    );

    //-------------------------------------------------------------
    DWORD
    RemoveJobFromProcessingList(
        CWorkObject* ptr
    );
    
    //-------------------------------------------------------------
    DWORD
    ProcessScheduledJob();

    //-------------------------------------------------------------
    BOOL
    SignalJobArrive() { return SetEvent(m_hNewJobArrive); }

    //-------------------------------------------------------------
    BOOL
    WaitForObjectOrShutdown(
        HANDLE hHandle
    );

    //-------------------------------------------------------------
    DWORD
    RunJob(
        IN CWorkObject* ptr,
        IN BOOL bImmediate
    );

    //-------------------------------------------------------------
    void
    EndProcessingScheduledJob(
        IN CWorkObject* ptr
        )
    /*++


    --*/
    {
        RemoveJobFromProcessingList(ptr);
        return;
    }

    //-------------------------------------------------------------
    void
    DeleteAllJobsInMemoryQueue();

    //-------------------------------------------------------------
    void
    CancelInProcessingJob();

    //-------------------------------------------------------------
    BOOL
    SignalJobRunning(
        CWorkObject* ptr
    );

    //-------------------------------------------------------------
    CWorkObject*
    GetNextJobInMemoryQueue(
        PDWORD pulTime
    );

    //-------------------------------------------------------------
    BOOL
    RemoveJobFromInMemoryQueue(
        IN DWORD ulJobTime, 
        IN CWorkObject* ptr
    );

    //-------------------------------------------------------------
    DWORD
    AddJobIntoMemoryQueue(
        DWORD ulTime,
        CWorkObject* pWork
    );

    //-------------------------------------------------------------
    BOOL
    IsShuttingDown() 
    {
        if(m_hShutdown == NULL)
        {
            return TRUE;
        }

        return (WaitForSingleObject( m_hShutdown, 0 ) == WAIT_OBJECT_0);
    }

    //-------------------------------------------------------------
    static DWORD WINAPI
    ProcessInMemoryScheduledJob(PVOID);

    //-------------------------------------------------------------
    static DWORD WINAPI
    ProcessInStorageScheduledJob(PVOID);

    //-------------------------------------------------------------
    static unsigned int __stdcall
    WorkManagerThread(PVOID);

    //-------------------------------------------------------------
    static DWORD WINAPI
    ExecuteWorkObject(PVOID);

    //-------------------------------------------------------------
    DWORD
    GetTimeToNextJob();

    //-------------------------------------------------------------
    void
    AddJobUpdateInMemoryJobWaitTimer(
        DWORD dwJobTime
        )
    /*++

    --*/
    {
        //m_JobTimeLock.Lock();

        if((DWORD)m_dwNextInMemoryJobTime > dwJobTime)
        {
            m_dwNextInMemoryJobTime = dwJobTime;
        }

        //m_JobTimeLock.UnLock();
        return;
    }
            
    //-------------------------------------------------------------
    void
    AddJobUpdateInStorageJobWaitTimer(
        DWORD dwJobTime
        )
    /*++

    --*/
    {
        //m_JobTimeLock.Lock();

        if((DWORD)m_dwNextInStorageJobTime > dwJobTime)
        {
            m_dwNextInStorageJobTime = dwJobTime;
        }

        //m_JobTimeLock.UnLock();
        return;
    }

    //-------------------------------------------------------------
    BOOL
    UpdateTimeToNextPersistentJob() 
    /*++

    --*/
    {
        BOOL bSuccess = TRUE;

        //
        // Work Manager thread are processing storage job, don't
        // Update the storage job timer.
        //
        TLSASSERT(m_pPersistentWorkStorage != NULL);

        if(m_pPersistentWorkStorage->GetNumJobs() > 0)
        {
            m_dwNextInStorageJobTime = m_pPersistentWorkStorage->GetNextJobTime();
        }

        return bSuccess;
    }

    //------------------------------------------------------------
    BOOL
    UpdateTimeToNextInMemoryJob() 
    /*++

        Must have called m_JobTimeLock.Lock();
    
    --*/
    {
        BOOL bSuccess = TRUE;
        SCHEDULEJOBMAP::iterator it;

        m_JobLock.Acquire(READER_LOCK);

        it = m_Jobs.begin();
        if(it != m_Jobs.end())
        {
            m_dwNextInMemoryJobTime = (*it).first;
        }
        else
        {
            m_dwNextInMemoryJobTime = WORKMANAGER_WAIT_FOREVER;
        }

        m_JobLock.Release(READER_LOCK);
        return bSuccess;
    }

    //-------------------------------------------------------------
    DWORD
    TranslateJobRunningAttributeToThreadPoolFlag(
        DWORD dwJobAttribute
        )
    /*++

    --*/
    {
        DWORD dwThreadPoolFlag = 0;

        if(dwJobAttribute & JOB_LONG_RUNNING)
        {
            dwThreadPoolFlag |= WT_EXECUTELONGFUNCTION;
        }
        else if(dwJobAttribute & JOB_INCLUDES_IO)
        {
            dwThreadPoolFlag |= WT_EXECUTEINIOTHREAD;
        }
        else
        {
            dwThreadPoolFlag = WT_EXECUTEDEFAULT; // = 0
        }

        return dwThreadPoolFlag;
    }

public:

    //------------------------------------------------
    // 
    // Constructor, only initialize member variable, must
    // invokd Init()
    //
    CWorkManager();

    //------------------------------------------------
    // Destructor.
    ~CWorkManager();


    //------------------------------------------------
    //
    // Startup Work Manager.
    //
    DWORD
    Startup(
        IN CWorkStorage* pPersistentWorkStorage,
        IN DWORD dwInterval = DEFAULT_WORK_INTERVAL,
        IN DWORD dwMaxConcurrentJob=DEFAULT_NUM_CONCURRENTJOB
    );

    //------------------------------------------------
    //
    // Schedule a Job
    //
    DWORD
    ScheduleJob(
        IN DWORD dwTime,        // relative to current time.
        IN CWorkObject* pJob
    );

    //------------------------------------------------
    //
    // Shutdown WorkManager
    //
    void
    Shutdown();

    //------------------------------------------------
    //
    //
    inline DWORD
    GetNumberJobInMemoryQueue() {
        DWORD dwNumJob = 0;

        m_JobLock.Acquire(READER_LOCK);
        dwNumJob = m_Jobs.size();
        m_JobLock.Release(READER_LOCK);

        return dwNumJob;
    }

    //-------------------------------------------------------------
    inline DWORD
    GetNumberJobInStorageQueue() {
        return m_pPersistentWorkStorage->GetNumJobs();
    }

    //-------------------------------------------------------------
    DWORD
    GetNumberJobInProcessing()
    {
        DWORD dwNumJobs;

        m_InProcessingListLock.Lock();
        dwNumJobs = m_InProcessingList.size();
        m_InProcessingListLock.UnLock();

        return dwNumJobs;
    }

    //-------------------------------------------------------------
    DWORD
    GetTotalNumberJobInQueue()
    {
        return GetNumberJobInMemoryQueue() + GetNumberJobInStorageQueue();
    }

    //-------------------------------------------------------------
    #ifdef DBG
    void
    SuspendWorkManagerThread() {
        SuspendThread(m_hWorkMgrThread);
    };

    void
    ResumeWorkManagerThread() {
        ResumeThread(m_hWorkMgrThread);
    };
    #endif
};


//-------------------------------------------------------------

class CWorkObject {
    friend class CWorkManager;

private:
    CWorkManager* m_pWkMgr;
    long    m_refCount;             // reference counter
    DWORD   m_dwLastRunStatus;      // status from last Execute().
    BOOL    m_bCanBeFree;           // TRUE if work manager should call
                                    // SelfDestruct().

    DWORD   m_dwScheduledTime;      // time schedule to be processed by
                                    // work manager

    //
    // Private function invoke only by CWorkManager
    //
    long
    GetReferenceCount();

    void
    IncrementRefCount();

    void
    DecrementRefCount();

    void
    ExecuteWorkObject();

    void
    EndExecuteWorkObject();

    //------------------------------------------------------------
    // 
    virtual void
    SetScheduledTime(
        IN DWORD dwTime
        ) 
    /*++
    
    Abstract:

        Set original scheduled processing time, this is call by work manager

    Parameter:

        dwTime : absolute scheduled time in second

    Returns:

        None.

    --*/
    {
        m_dwScheduledTime = dwTime;
        return;
    }
        
protected:


    CWorkManager* 
    GetWorkManager() {
        return m_pWkMgr;
    }

    BOOL
    CanBeDelete() { 
        return m_bCanBeFree; 
    }

public:

    //------------------------------------------------------------
    //
    // Constructor
    //
    CWorkObject(
        IN BOOL bDestructorDelete = TRUE
    );

    //------------------------------------------------------------
    // 
    // Destructor
    //
    ~CWorkObject() 
    {
        Cleanup();
    }

    //------------------------------------------------------------
    // 
    BOOL
    IsWorkManagerShuttingDown()
    {
        return (m_pWkMgr != NULL) ? m_pWkMgr->IsShuttingDown() : TRUE;
    }

    //------------------------------------------------------------
    // TODO - quick fix, persistent storage can't assign this.
    void
    SetProcessingWorkManager(
        IN CWorkManager* pWkMgr
        )
    /*++

    --*/
    {
        m_pWkMgr = pWkMgr;
    }

    //------------------------------------------------------------
    // 
    virtual DWORD
    GetJobRestartTime() 
    /*
    Abstract:

        Return suggested re-start time after server has been 
        shutdown/restart, this is used by work storage class only.

    Parameter:

        None.

    Returns:

        Time in second relative to current time.

    --*/
    {
        return INFINITE;
    }

    //------------------------------------------------------------
    // 
    virtual DWORD
    GetScheduledTime() 
    /*++

    Abstract:

        Get Job's scheduled time.

    Parameter:

        None:

    Returns:

        Absolute scheduled time in seconds.

    --*/
    { 
        return m_dwScheduledTime; 
    }
    
    //------------------------------------------------------------
    // 
    // Abstract:
    //
    //      Initialize work object, similar to constructor.
    //
    virtual DWORD
    Init(
        IN BOOL bDestructorDelete = TRUE
    );

    //------------------------------------------------------------
    // 
    virtual BOOL
    IsWorkPersistent()
    /*++
    Abstract:

        Return if this is persistent job - across session.

    Parameter:

        None.

    Returns:

        TRUE/FALSE.

    --*/
    {
        return FALSE;
    }
        
    //------------------------------------------------------------
    // 
    virtual BOOL
    IsValid() 
    /*++

    Abstract:

        Return if this object has been properly initialized.

    Parameter:

        None:

    Returns:
        
        TRUE/FALSE

    --*/
    {
        return m_pWkMgr != NULL;
    }

    //------------------------------------------------------------
    // 
    virtual void
    Cleanup()
    /*++

    Abstract:

        Cleanup internal data in this object.

    Parameter:

        None.

    Returns:

        None.

    --*/
    {
        InterlockedExchange(&m_refCount, 0);
        return;
    }

    //------------------------------------------------------------
    //
    // Abstract:
    //
    //      Pure virtual function to return type of work
    //
    // Parameter:
    //  
    //      None.
    //
    // Returns:
    //  
    //      Derived class dependent.
    //
    virtual DWORD 
    GetWorkType() = 0;

    //------------------------------------------------------------
    //
    virtual BOOL
    SetWorkType(
        IN DWORD dwType
        )
    /*++

    Abstract:

        Set the type of work for this object, not call by any of work
        manager function.

    Parameter:

        dwType : Type of work.        

    return:
    
        TRUE/FALSE.

    --*/
    {
        SetLastError(ERROR_INVALID_DATA);
        return FALSE;
    }

    //-----------------------------------------------------------
    //
    // Abstract:
    //
    //      pure virtual function to return work object specific data.
    // 
    // Parameters:
    //
    //      ppbData : Pointer to pointer to buffer to receive object
    //                specific work data.
    //      pcbData : Pointer to DWORD to receive size of object specific
    //                work data.
    //
    //  Returns:
    //
    //      TRUE/FALSE, all derived class specific.
    virtual BOOL
    GetWorkObjectData(
        OUT PBYTE* ppbData,
        OUT PDWORD pcbData
    ) = 0;

    //-----------------------------------------------------------
    //
    // Abstract:
    //
    //      Pure virtual function for work storage class to assign
    //      storage ID.
    //
    // Parameters:
    //
    //      pbData : Work Storage assigned storage ID.
    //      cbData : size of storage ID.
    //
    // Returns:
    //
    //      TRUE/FALSE, derived class specific.
    //
    virtual BOOL
    SetJobId(
        IN PBYTE pbData, 
        IN DWORD cbData
    ) = 0;

    //-----------------------------------------------------------
    //
    // Abstract:
    //
    //      Pure virtual function to return storage ID assigned by
    //      storage class.
    //
    // parameter:
    //  
    //      ppbData : Pointer to pointer to buffer to receive storage ID.
    //      pcbData : size of storage ID.
    //
    // Returns:
    //  
    //      TRUE/FALSE, derived class specific.
    //
    virtual BOOL
    GetJobId(
        OUT PBYTE* ppbData, 
        OUT PDWORD pcbData
    ) = 0;

    //-------------------------------------------------------------
    // 
    //  Abstract:
    //      
    //      Virtual function, execute a job.
    //
    //  Parameters:
    //  
    //      None.
    //
    //  Returns:
    //
    //      None
    //
    virtual DWORD
    Execute() = 0;
    

    //-------------------------------------------------------------
    //
    // Abstract :
    // 
    //      Schedule a job at relative time
    //
    // Parameters:
    //
    //      pftStartTime : Time relative to current system time, if NULL,
    //                     Job will be placed infront of job queue
    //
    //  Return:
    //
    //      TRUE if successful, FALSE otherwise
    //
    //  Note:
    //
    //      Could cause job stavation if set to NULL
    //
    virtual DWORD
    ScheduleJob(
        IN DWORD StartTime 
        ) 
    /*++

    --*/
    {
        TLSASSERT(m_pWkMgr != NULL);
        return (m_pWkMgr == NULL) ? ERROR_INVALID_DATA : m_pWkMgr->ScheduleJob(StartTime, this);
    }
    
    //----------------------------------------------------------
    //
    // For threadpool function, see thread pool doc.
    //
    virtual DWORD
    GetJobRunningAttribute() 
    { 
        return JOB_INCLUDES_IO | JOB_LONG_RUNNING; 
    }

    //---------------------------------------------------------------
    //
    // Return suggested schedule time relative to current time
    //
    virtual DWORD
    GetSuggestedScheduledTime() = 0;

    //--------------------------------------------------------------
    //
    // Get last status return from Execute().
    //
    virtual BOOL
    GetLastRunStatus() {
        return m_dwLastRunStatus;
    }

    //--------------------------------------------------------------
    //
    // Return TRUE if job can be deleted from queue
    //
    virtual BOOL
    IsJobCompleted() = 0;

    //-------------------------------------------------------------
    //
    // End Job, work manager, after invoke Execute(), calls EndJob() 
    // to inform. work object that job has completed, derived class
    // should perform internal data cleanup.
    //
    virtual void
    EndJob() = 0;

    //-------------------------------------------------------------
    //
    // Pure virtual function, work manager operates on CWorkObject
    // so it has no idea the actual class it is running, derive class
    // should cast the pointer back to its class and delete the pointer
    // to free up memory associated with object.
    //
    virtual BOOL
    SelfDestruct() = 0;

    //-------------------------------------------------------------
    //
    // Pure virtual, for debugging purpose only.
    //
    virtual LPCTSTR
    GetJobDescription() = 0;

    //--------------------------------------------------------
    virtual void 
    SetJobRetryTimes(
        IN DWORD dwRetries
    ) = 0;

    //--------------------------------------------------------
    virtual DWORD
    GetJobRetryTimes() = 0;

    //---------------------------------------------------------
    virtual void
    SetJobInterval(
        IN DWORD dwInterval
    ) = 0;

    //---------------------------------------------------------
    virtual DWORD
    GetJobInterval() = 0;

    //---------------------------------------------------------
    virtual void
    SetJobRestartTime(
        IN DWORD dwRestartTime
        )
    /*++

    --*/
    {
        return;
    }

};


#ifndef __TEST_WORKMGR__
#define TLSDebugOutput
#endif

//-----------------------------------------------------

#ifdef __cplusplus
extern "C" {
#endif




#ifdef __cplusplus
}
#endif
   
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\license\tlserver\server\kp.cpp ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996-1998
//
// File:        kp.cpp
//
// Contents:    
//              Contains wrapper call to deal with concepture 
//              license key pack table, this includes LicPack, LicPackStatus,
//              and LicPackDesc table.
//
// History:     
//          04/16/98      HueiWang        Created.
//---------------------------------------------------------------------------

#include "pch.cpp"
#include "kp.h"
#include "globals.h"
#include "server.h"
#include "lkplite.h"
#include "keypack.h"
#include "lkpdesc.h"
#include "misc.h"
#include "permlic.h"

#define STRSAFE_NO_DEPRECATE
#include <strsafe.h>

//++-------------------------------------------------------------------------------
BOOL 
ValidLicenseKeyPackParameter(
    IN LPLSKeyPack lpKeyPack, 
    IN BOOL bAdd
    )
/*++

Abtract:

    Validate a LSKeyPack value.

Parameter:

    lpKeyPack - keypack value to be validated,
    bAdd - TRUE if this value is to be inserted into table, FALSE otherwise, note
           if value is to be inserted into table, it require more parameters.

Return:

    TRUE if valid LSKeyPack value, FALSE otherwise.

++*/
{
    BOOL bValid=FALSE;

    do {
        // verify input parameter
        if((lpKeyPack->ucKeyPackType & ~LSKEYPACK_RESERVED_TYPE) < LSKEYPACKTYPE_FIRST || 
           (lpKeyPack->ucKeyPackType & ~LSKEYPACK_RESERVED_TYPE) > LSKEYPACKTYPE_LAST)
        {
            DBGPrintf(
                    DBG_ERROR,
                    DBG_FACILITY_RPC,
                    DBG_FACILITY_KEYPACK,
                    _TEXT("ValidLicenseKeyPackParameter : invalid key pack type - %d\n"), 
                    lpKeyPack->ucKeyPackType
                );
            break;
        }

        UCHAR ucKeyPackStatus = lpKeyPack->ucKeyPackStatus & ~LSKEYPACKSTATUS_RESERVED;

        if((ucKeyPackStatus < LSKEYPACKSTATUS_FIRST || 
            ucKeyPackStatus > LSKEYPACKSTATUS_LAST) &&
            ucKeyPackStatus != LSKEYPACKSTATUS_DELETE)
        {
            DBGPrintf(
                    DBG_ERROR,
                    DBG_FACILITY_RPC,
                    DBG_FACILITY_KEYPACK,
                    _TEXT("ValidLicenseKeyPackParameter : invalid key pack status - %d\n"), 
                    lpKeyPack->ucKeyPackStatus
                );
            break;
        }

        if(lpKeyPack->ucLicenseType < LSKEYPACKLICENSETYPE_FIRST || 
           lpKeyPack->ucLicenseType > LSKEYPACKLICENSETYPE_LAST)
        {
            DBGPrintf(
                    DBG_ERROR,
                    DBG_FACILITY_RPC,
                    DBG_FACILITY_KEYPACK,
                    _TEXT("ValidLicenseKeyPackParameter : invalid license type - %d\n"), 
                    lpKeyPack->ucLicenseType
                );
            break;
        }

        if(!bAdd)
        {
            bValid = TRUE;
            break;
        }

        if(lpKeyPack->ucChannelOfPurchase < LSKEYPACKCHANNELOFPURCHASE_FIRST ||
           lpKeyPack->ucChannelOfPurchase > LSKEYPACKCHANNELOFPURCHASE_LAST)
        {
            DBGPrintf(
                    DBG_ERROR,
                    DBG_FACILITY_RPC,
                    DBG_FACILITY_KEYPACK,
                    _TEXT("ValidLicenseKeyPackParameter : invalid channel of purchase - %d\n"), 
                    lpKeyPack->ucChannelOfPurchase
                );
            break;
        }

        if(!_tcslen(lpKeyPack->szCompanyName))
        {
            DBGPrintf(
                    DBG_ERROR,
                    DBG_FACILITY_RPC,
                    DBG_FACILITY_KEYPACK,
                    _TEXT("ValidLicenseKeyPackParameter : invalid company name\n")
                );
            break;
        }

        if(!_tcslen(lpKeyPack->szKeyPackId))
        {
            DBGPrintf(
                    DBG_ERROR,
                    DBG_FACILITY_RPC,
                    DBG_FACILITY_KEYPACK,
                    _TEXT("ValidLicenseKeyPackParameter : invalid key pack id\n")
                );
            break;
        }

        if(!_tcslen(lpKeyPack->szProductName))
        {
            DBGPrintf(
                    DBG_ERROR,
                    DBG_FACILITY_RPC,
                    DBG_FACILITY_KEYPACK,
                    _TEXT("ValidLicenseKeyPackParameter : invalid product name\n")
                );
            break;
        }

        if(!_tcslen(lpKeyPack->szProductId))
        {
            DBGPrintf(
                    DBG_ERROR,
                    DBG_FACILITY_RPC,
                    DBG_FACILITY_KEYPACK,
                    _TEXT("ValidLicenseKeyPackParameter : invalid product id\n")
                );
            break;
        }

        if(!_tcslen(lpKeyPack->szProductDesc))
        {
            // set product desc = product name
            _tcscpy(lpKeyPack->szProductDesc, lpKeyPack->szProductName);
        }

        if(!_tcslen(lpKeyPack->szBeginSerialNumber))
        {
            DBGPrintf(
                    DBG_ERROR,
                    DBG_FACILITY_RPC,
                    DBG_FACILITY_KEYPACK,
                    _TEXT("ValidLicenseKeyPackParameter : invalid serial number\n")
                );
            break;
        }

        bValid=TRUE;
    } while(FALSE);
 
    return bValid;
}


//++----------------------------------------------------------------------
DWORD
TLSDBLicenseKeyPackAdd( 
    IN PTLSDbWorkSpace pDbWkSpace, 
    IN LPLSKeyPack lpLsKeyPack 
    )
/*++

Abstract:

    Add an entry into concepture keypack table, this includes LicPack, 
    LicPackStatus, and LicPackDesc table.

Parameter:

    pDbWkSpace : workspace handle.
    lpLsKeyPack : license key pack to be added into table.

Returns: 

++*/
{
    DWORD   dwStatus;
    PTLSLICENSEPACK pLicPack = NULL;
    LICPACKDESC LicPackDesc;

    if(!ValidLicenseKeyPackParameter(lpLsKeyPack, TRUE))
        return TLS_E_INVALID_DATA;

    TLSDBLockKeyPackTable();
    TLSDBLockKeyPackDescTable();    

    do {

        pLicPack = new TLSLICENSEPACK;
        if(pLicPack == NULL)
        {
            SetLastError(dwStatus = TLS_E_ALLOCATE_MEMORY);
            break;
        }

        if(ConvertLsKeyPackToKeyPack(
                            lpLsKeyPack,    
                            pLicPack, 
                            &LicPackDesc
                        ) == FALSE)
        {
            dwStatus = GetLastError();
            break;
        }

        //
        // Add license server info into TLSLICENSEPACK
        //
        //LicPack.pbDomainSid = g_pbDomainSid;
        //LicPack.cbDomainSid = g_cbDomainSid;

        _tcscpy(pLicPack->szInstallId, (LPTSTR)g_pszServerPid);
        _tcscpy(pLicPack->szTlsServerName, g_szComputerName);

        //
        // No domain name at this time
        //
        memset(pLicPack->szDomainName, 0, sizeof(pLicPack->szDomainName));


        if(lpLsKeyPack->ucKeyPackStatus != LSKEYPACKSTATUS_ADD_DESC)
        {
            dwStatus = TLSDBKeyPackAdd(pDbWkSpace, pLicPack);
            if(dwStatus != ERROR_SUCCESS)
            {
                // this is global memory, destructor will try to free it.
                pLicPack->pbDomainSid = NULL;
                pLicPack->cbDomainSid = 0;
                break;
            }
        }

        pLicPack->pbDomainSid = NULL;
        pLicPack->cbDomainSid = 0;

        //
        // Make sure keypack got inserted
        //
        dwStatus = TLSDBKeyPackEnumBegin( 
                                    pDbWkSpace, 
                                    TRUE, 
                                    LSKEYPACK_EXSEARCH_DWINTERNAL, 
                                    pLicPack 
                                );
        if(dwStatus != ERROR_SUCCESS)
            break;

        dwStatus = TLSDBKeyPackEnumNext(
                                pDbWkSpace, 
                                pLicPack
                            );

        TLSDBKeyPackEnumEnd(pDbWkSpace);

        if(dwStatus != ERROR_SUCCESS)
            break;

        LicPackDesc.dwKeyPackId = pLicPack->dwKeyPackId;

        //
        // Add keypack description into keypack desc
        //
        dwStatus = TLSDBKeyPackDescAddEntry(
                                    pDbWkSpace, 
                                    &LicPackDesc
                                );

        ConvertKeyPackToLsKeyPack(
                            pLicPack, 
                            &LicPackDesc, 
                            lpLsKeyPack
                        );

        if(pLicPack != NULL)
        {
            delete pLicPack;
        }

    } while(FALSE);

    TLSDBUnlockKeyPackDescTable();
    TLSDBUnlockKeyPackTable();
    return dwStatus;
}

//++-----------------------------------------------------------------------
DWORD
TLSDBLicenseKeyPackSetStatus( 
    IN PTLSDbWorkSpace pDbWkSpace, 
    IN DWORD       dwSetStatus,
    IN LPLSKeyPack  lpLsKeyPack
    )
/*++

Abstract:

    Set the status of Licensed KeyPack.

Parameter:

    pDbWkSpace - workspace handle.
    dwSetStatus - type of status to be set.
    lpLsKeyPack - record/value to be set.

Returns:

++*/
{
    TLSLICENSEPACK LicPack;
    
    //
    // Status of keypack is in KeyPack table
    //
    if(ConvertLsKeyPackToKeyPack(
                        lpLsKeyPack, 
                        &LicPack, 
                        NULL
                    ) == FALSE)
    {
        return GetLastError();
    }

    return TLSDBKeyPackSetValues(pDbWkSpace, FALSE, dwSetStatus, &LicPack);
}

//++---------------------------------------------------------------------
DWORD
TLSDBLicenseKeyPackUpdateLicenses( 
    PTLSDbWorkSpace pDbWkSpace, 
    BOOL bAdd, 
    IN LPLSKeyPack lpLsKeyPack 
    )
/*++
    
Abstract:

    Add/Remove license from a keypack.

Parameter:

    pDbWkSpace - workspace handle.
    bAdd - TRUE if add entry into table, FALSE otherwise.
    lpLsKeyPack - 

Returns:

++*/
{
    DWORD dwStatus;
    TLSLICENSEPACK LicPack;

    //
    // Redirect call to KeyPack Table, not thing in KeyPackDesc can be updated.
    //
    if(ConvertLsKeyPackToKeyPack(
                        lpLsKeyPack, 
                        &LicPack, 
                        NULL
                    ) == FALSE)
    {
        dwStatus = GetLastError();
        goto cleanup;
    }

    dwStatus=TLSDBKeyPackUpdateNumOfAvailableLicense(
                            pDbWkSpace, 
                            bAdd, 
                            &LicPack
                        );

    //
    // return new value back to caller
    //
    ConvertKeyPackToLsKeyPack( 
                        &LicPack, 
                        NULL, 
                        lpLsKeyPack 
                    );

cleanup:
    return dwStatus;
}

//++---------------------------------------------------------------------
LPENUMHANDLE 
TLSDBLicenseKeyPackEnumBegin(
    BOOL bMatchAll, 
    DWORD dwSearchParm, 
    LPLSKeyPack lpLsKeyPack
    )
/*++

Abstract:

    Begin enumeration of concepture License Key Pack table.

Parameter:

    bMatchAll - TRUE if match all search value, FALSE otherwise.
    dwSearchParm - Field to be included in search.
    lpLsKeyPack - KeyPack value to search.
    
Returns:


++*/
{
    DWORD dwStatus;
    LPENUMHANDLE hEnum=NULL;
    TLSLICENSEPACK licpack;

    licpack.pbDomainSid = NULL;

    hEnum = new ENUMHANDLE;
    if(hEnum == NULL)
        return NULL;

    hEnum->pbWorkSpace=AllocateWorkSpace(g_EnumDbTimeout);
    if(hEnum->pbWorkSpace == NULL)
    {
        SetLastError(TLS_E_ALLOCATE_HANDLE);
        TLSDBLicenseKeyPackEnumEnd(hEnum);
        return NULL;
    }

    memset(&hEnum->CurrentKeyPack, 0, sizeof(hEnum->CurrentKeyPack));
    memset(&hEnum->KPDescSearchValue, 0, sizeof(hEnum->KPDescSearchValue));
    hEnum->dwKPDescSearchParm = 0;

    if(ConvertLsKeyPackToKeyPack(
                        lpLsKeyPack, 
                        &licpack, 
                        &hEnum->KPDescSearchValue
                    ) == FALSE)
    {
        TLSDBLicenseKeyPackEnumEnd(hEnum);
        return NULL;
    }

    //
    // establish KeyPack enumeration
    dwStatus = TLSDBKeyPackEnumBegin(
                                hEnum->pbWorkSpace, 
                                bMatchAll, 
                                dwSearchParm, 
                                &licpack
                            );
    if(dwStatus != ERROR_SUCCESS)
    {
        SetLastError(dwStatus);
        TLSDBLicenseKeyPackEnumEnd(hEnum);
        return NULL;
    }


    //
    // Store keypack desc search value
    //
    if(dwSearchParm & LSKEYPACK_SEARCH_LANGID)
        hEnum->dwKPDescSearchParm |= LICPACKDESCRECORD_TABLE_SEARCH_LANGID;
    
    if(dwSearchParm & LSKEYPACK_SEARCH_COMPANYNAME)
        hEnum->dwKPDescSearchParm |= LICPACKDESCRECORD_TABLE_SEARCH_COMPANYNAME;

    if(dwSearchParm & LSKEYPACK_SEARCH_PRODUCTNAME)
        hEnum->dwKPDescSearchParm |= LICPACKDESCRECORD_TABLE_SEARCH_PRODUCTNAME;

    if(dwSearchParm & LSKEYPACK_SEARCH_PRODUCTDESC)
        hEnum->dwKPDescSearchParm |= LICPACKDESCRECORD_TABLE_SEARCH_PRODUCTDESC;

    hEnum->bKPDescMatchAll=bMatchAll;
    hEnum->chFetchState=ENUMHANDLE::FETCH_NEXT_KEYPACK;
    return hEnum;
}

//++----------------------------------------------------------------------
DWORD 
TLSDBLicenseKeyPackEnumNext(
    LPENUMHANDLE lpEnumHandle, 
    LPLSKeyPack lpLsKeyPack,
    BOOL bShowAll
    )
/*++

Abstract:

    Fetch next combined LicPack, LicPackStatus, and LicPackDesc record that
    match search condiftion.

Parameter:

    lpEnumHandle - enumeration handle return by TLSDBLicenseKeyPackEnumBegin().
    lpLsKeyPack - return value found.
    bShowAll - return all keypack

Returns:


Note:
    Caller need to discard return value and call TLSDBLicenseKeyPackEnumNext() 
    again when this function return TLS_I_MORE_DATA, this is to prevent 
    stack overflow in recursive call.

++*/
{
    //
    // No recursive call to prevent stack overflow
    // 

    DWORD dwStatus;

    switch(lpEnumHandle->chFetchState)
    {
        case ENUMHANDLE::FETCH_NEXT_KEYPACK:

            //
            // Retrieve next row in keypack
            dwStatus=TLSDBKeyPackEnumNext(
                                lpEnumHandle->pbWorkSpace, 
                                &lpEnumHandle->CurrentKeyPack
                            );
            if(dwStatus != ERROR_SUCCESS)
                break;

            if(bShowAll == FALSE)
            {

                //
                // Never return keypack that is solely for issuing certificate to 
                // Hydra Server
                if(_tcsicmp(lpEnumHandle->CurrentKeyPack.szKeyPackId, 
                            HYDRAPRODUCT_HS_CERTIFICATE_KEYPACKID) == 0 &&
                   _tcsicmp(lpEnumHandle->CurrentKeyPack.szProductId, 
                            HYDRAPRODUCT_HS_CERTIFICATE_SKU) == 0)
                {
                    //
                    // Prevent infinite recursive call, let calling routine handle this
                    return TLS_I_MORE_DATA;
                }

                //
                // Do not show remote key pack
                //
                if( lpEnumHandle->CurrentKeyPack.ucAgreementType & LSKEYPACK_REMOTE_TYPE)
                {
                    return TLS_I_MORE_DATA;
                }

                if( lpEnumHandle->CurrentKeyPack.ucKeyPackStatus & LSKEYPACKSTATUS_REMOTE)
                {
                    return TLS_I_MORE_DATA;
                }

                lpEnumHandle->CurrentKeyPack.ucAgreementType &= ~LSKEYPACK_RESERVED_TYPE;
                lpEnumHandle->CurrentKeyPack.ucKeyPackStatus &= ~LSKEYPACKSTATUS_RESERVED;
            }

            //
            // Fetch KeyPackDesc table
            //
            lpEnumHandle->chFetchState=ENUMHANDLE::FETCH_NEW_KEYPACKDESC;
           
            // 
            // FALL THRU.
            //

        case ENUMHANDLE::FETCH_NEW_KEYPACKDESC:
            //
            // retrieve new keypackdesc that match up with keypack
            lpEnumHandle->KPDescSearchValue.dwKeyPackId = lpEnumHandle->CurrentKeyPack.dwKeyPackId;
            lpEnumHandle->dwKPDescSearchParm |= LICPACKDESCRECORD_TABLE_SEARCH_KEYPACKID;
            // lpEnumHandle->pbWorkSpace->Cleanup();

            //
            // First issue a query to see if product has matching language ID
            LICPACKDESC kpDesc;

            memset(&kpDesc, 0, sizeof(LICPACKDESC));
            kpDesc = lpEnumHandle->KPDescSearchValue;
            dwStatus = TLSDBKeyPackDescFind(
                                        lpEnumHandle->pbWorkSpace, 
                                        TRUE,
                                        lpEnumHandle->dwKPDescSearchParm, 
                                        &kpDesc,
                                        NULL
                                    );

            if(dwStatus == TLS_E_RECORD_NOTFOUND)
            {
                //
                // Show description in English
                kpDesc.dwLanguageId = MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US);

                dwStatus = TLSDBKeyPackDescFind(
                                            lpEnumHandle->pbWorkSpace, 
                                            TRUE,
                                            lpEnumHandle->dwKPDescSearchParm, 
                                            &kpDesc,
                                            NULL
                                        );

                if(dwStatus == TLS_E_RECORD_NOTFOUND)
                {
                    //
                    // No product description for this lanuage ID and english
                    //
                    _tcscpy(kpDesc.szCompanyName, lpEnumHandle->CurrentKeyPack.szCompanyName);
                    _tcscpy(kpDesc.szProductName, lpEnumHandle->CurrentKeyPack.szProductId);
                    _tcscpy(kpDesc.szProductDesc, lpEnumHandle->CurrentKeyPack.szProductId);
        
                    ConvertKeyPackToLsKeyPack(
                                        &lpEnumHandle->CurrentKeyPack, 
                                        &kpDesc, 
                                        lpLsKeyPack
                                    );

                    dwStatus = ERROR_SUCCESS;
                    lpEnumHandle->chFetchState=ENUMHANDLE::FETCH_NEXT_KEYPACK;
                    break;
                }
            }

            dwStatus = TLSDBKeyPackDescEnumBegin(
                                        lpEnumHandle->pbWorkSpace, 
                                        lpEnumHandle->bKPDescMatchAll,
                                        lpEnumHandle->dwKPDescSearchParm,
                                        &kpDesc
                                    );

                
            if(dwStatus != ERROR_SUCCESS)
                break;

            lpEnumHandle->chFetchState=ENUMHANDLE::FETCH_NEXT_KEYPACKDESC;

            //
            // FALL THRU
            //

        case ENUMHANDLE::FETCH_NEXT_KEYPACKDESC:
            {
                LICPACKDESC licpackdesc;
                dwStatus = TLSDBKeyPackDescEnumNext(
                                            lpEnumHandle->pbWorkSpace, 
                                            &licpackdesc
                                        );
                if(dwStatus == ERROR_SUCCESS)
                {
                    ConvertKeyPackToLsKeyPack(
                                        &lpEnumHandle->CurrentKeyPack, 
                                        &licpackdesc, 
                                        lpLsKeyPack
                                    );
                }
                else if(dwStatus == TLS_I_NO_MORE_DATA)
                {
                    lpEnumHandle->chFetchState=ENUMHANDLE::FETCH_NEXT_KEYPACK;
                    
                    //
                    // Set the status to MORE DATA 
                    //
                    dwStatus = TLS_I_MORE_DATA;
                    
                    // terminate enumeration for keypack description table
                    TLSDBKeyPackDescEnumEnd(lpEnumHandle->pbWorkSpace);                    
                } 
            }
            break;
    }

    return dwStatus;
}

//++------------------------------------------------------------------
DWORD 
TLSDBLicenseKeyPackEnumEnd(
    LPENUMHANDLE lpEnumHandle
    )
/*++

Abstract:

    End enumeration of concepture license key pack table.

Parameter;

    lpEnumHandle - enumeration handle return by TLSDBLicenseKeyPackEnumBegin().

Returns:

++*/
{
    if(lpEnumHandle)
    {
        if(lpEnumHandle->pbWorkSpace)
        {
            TLSDBKeyPackDescEnumEnd(lpEnumHandle->pbWorkSpace);
            TLSDBKeyPackEnumEnd(lpEnumHandle->pbWorkSpace);

            //FreeTlsLicensePack(&(lpEnumHandle->CurrentKeyPack));
            ReleaseWorkSpace(&(lpEnumHandle->pbWorkSpace));
        }
        delete lpEnumHandle;
    }

    return ERROR_SUCCESS;
}



//+--------------------------------------------------------------------

#define CH_PLATFORMID_OTHERS    3
#define CH_PLATFORMID_UPGRADE   2

BOOL
VerifyInternetLicensePack(
    License_KeyPack* pLicensePack
    )
/*++

--*/
{
    BOOL bSuccess = TRUE;

    switch(pLicensePack->dwKeypackType)
    {
        case LICENSE_KEYPACK_TYPE_SELECT:
        case LICENSE_KEYPACK_TYPE_MOLP:
        case LICENSE_KEYPACK_TYPE_RETAIL:
            break;           
            
        default:
            DBGPrintf(
                    DBG_ERROR,
                    DBG_FACILITY_RPC,
                    DBG_FACILITY_KEYPACK,
                    _TEXT("LSDBRegisterLicenseKeyPack : invalid keypack type - %d\n"), 
                    pLicensePack->dwKeypackType
                );
            bSuccess = FALSE;
    }

    if(bSuccess == FALSE)
    {
        goto cleanup;
    }
    
    if(bSuccess == FALSE)
    {
        goto cleanup;
    }

    if(CompareFileTime(&pLicensePack->ActiveDate, &pLicensePack->ExpireDate) > 0)
    {
        DBGPrintf(
                DBG_ERROR,
                DBG_FACILITY_RPC,
                DBG_FACILITY_KEYPACK,
                _TEXT("LSDBRegisterLicenseKeyPack : invalid activate date and expiration date\n")
            );
        bSuccess = FALSE;
        goto cleanup;
    }

    if(pLicensePack->pbProductId == NULL || pLicensePack->cbProductId == NULL)
    {
        DBGPrintf(
                DBG_ERROR,
                DBG_FACILITY_RPC,
                DBG_FACILITY_KEYPACK,
                _TEXT("LSDBRegisterLicenseKeyPack : No product ID\n")
            );
        bSuccess = FALSE;
        goto cleanup;
    }

    if(pLicensePack->dwDescriptionCount == 0 || pLicensePack->pDescription == NULL)
    {
        DBGPrintf(
                DBG_ERROR,
                DBG_FACILITY_RPC,
                DBG_FACILITY_KEYPACK,
                _TEXT("LSDBRegisterLicenseKeyPack : No product description\n")
            );
        bSuccess = FALSE;
        goto cleanup;
    }

    if(pLicensePack->cbManufacturer == 0 || pLicensePack->pbManufacturer == NULL)
    {
        DBGPrintf(
                DBG_ERROR,
                DBG_FACILITY_RPC,
                DBG_FACILITY_KEYPACK,
                _TEXT("LSDBRegisterLicenseKeyPack : No product manufacturer\n")
            );
        bSuccess = FALSE;
    }

cleanup:
    return bSuccess;
}

//----------------------------------------------------------------------
        
DWORD
ConvertInternetLicensePackToPMLicensePack(
    License_KeyPack* pLicensePack,
    PPMREGISTERLICENSEPACK ppmLicensePack
    )
/*++

--*/
{
    DWORD dwStatus = ERROR_SUCCESS;

    memset(ppmLicensePack, 0, sizeof(PMREGISTERLICENSEPACK));

    if(VerifyInternetLicensePack(pLicensePack) == FALSE)
    {
        SetLastError(dwStatus = ERROR_INVALID_PARAMETER);
        goto cleanup;
    }

    ppmLicensePack->SourceType = REGISTER_SOURCE_INTERNET;
    ppmLicensePack->dwKeyPackType = pLicensePack->dwKeypackType;

    ppmLicensePack->dwDistChannel = pLicensePack->dwDistChannel;
    ppmLicensePack->KeypackSerialNum = pLicensePack->KeypackSerialNum;
    ppmLicensePack->IssueDate = pLicensePack->IssueDate;
    ppmLicensePack->ActiveDate = pLicensePack->ActiveDate;
    ppmLicensePack->ExpireDate = pLicensePack->ExpireDate;
    ppmLicensePack->dwBeginSerialNum = pLicensePack->dwBeginSerialNum;
    ppmLicensePack->dwQuantity = pLicensePack->dwQuantity;
    memcpy(
            ppmLicensePack->szProductId,
            pLicensePack->pbProductId,
            min(sizeof(ppmLicensePack->szProductId) - sizeof(TCHAR), pLicensePack->cbProductId)
        );
                
    memcpy(
            ppmLicensePack->szCompanyName,
            pLicensePack->pbManufacturer,
            min(sizeof(ppmLicensePack->szCompanyName) - sizeof(TCHAR), pLicensePack->cbManufacturer)
        );

    ppmLicensePack->dwProductVersion = pLicensePack->dwProductVersion;
    ppmLicensePack->dwPlatformId = pLicensePack->dwPlatformId;
    ppmLicensePack->dwLicenseType = pLicensePack->dwLicenseType;
    ppmLicensePack->dwDescriptionCount = pLicensePack->dwDescriptionCount;

    if( pLicensePack->dwDescriptionCount != 0 )
    {
        ppmLicensePack->pDescription = (PPMREGISTERLKPDESC)AllocateMemory(sizeof(PMREGISTERLKPDESC) * ppmLicensePack->dwDescriptionCount);
        if(ppmLicensePack->pDescription != NULL)
        {
            for(DWORD dwIndex = 0; dwIndex < ppmLicensePack->dwDescriptionCount; dwIndex++)
            {
                ppmLicensePack->pDescription[dwIndex].Locale = pLicensePack->pDescription[dwIndex].Locale;

                memcpy(
                    ppmLicensePack->pDescription[dwIndex].szProductName,
                    pLicensePack->pDescription[dwIndex].pbProductName,
                    min(
                          sizeof(ppmLicensePack->pDescription[dwIndex].szProductName) - sizeof(TCHAR),
                            pLicensePack->pDescription[dwIndex].cbProductName
                        )
                );
                    
                memcpy(
                    ppmLicensePack->pDescription[dwIndex].szProductDesc,
                    pLicensePack->pDescription[dwIndex].pDescription,
                    min(
                          sizeof(ppmLicensePack->pDescription[dwIndex].szProductDesc) - sizeof(TCHAR),
                            pLicensePack->pDescription[dwIndex].cbDescription
                        )
                );
            }
        }
        else
        {
            SetLastError(dwStatus = ERROR_OUTOFMEMORY);
        }
    }

cleanup:
    return dwStatus;
}

//----------------------------------------------------------------------------
DWORD
TLSDBInstallKeyPack(
    IN PTLSDbWorkSpace pDbWkSpace, 
    IN PPMLSKEYPACK ppmLsKeyPack,
    OUT LPLSKeyPack lpInstalledKeyPack
    )
/*++

--*/
{
    DWORD dwStatus = ERROR_SUCCESS;
    LSKeyPack KeyPack;
    DWORD i;

    //
    // Policy module should leave product name/description in PPMREGISTERLKPDESC
    //
    memset(&KeyPack, 0, sizeof(LSKeyPack));
    KeyPack = ppmLsKeyPack->keypack;

    if (!FileTimeToLicenseDate(
            &ppmLsKeyPack->ActiveDate, 
            &KeyPack.dwActivateDate
            ))
    {
        dwStatus = GetLastError();
        goto cleanup;
    }

    if (!FileTimeToLicenseDate(
            &ppmLsKeyPack->ExpireDate, 
            &KeyPack.dwExpirationDate
            ))
    {
        dwStatus = GetLastError();
        goto cleanup;
    }

    //
    // Add to KeyPack and KeyPackDesc Table.
    for(i=0; i < ppmLsKeyPack->dwDescriptionCount && dwStatus == ERROR_SUCCESS; i++)
    {
        KeyPack.ucKeyPackStatus = (i) ? LSKEYPACKSTATUS_ADD_DESC : LSKEYPACKSTATUS_ACTIVE;

        KeyPack.dwLanguageId = ppmLsKeyPack->pDescription[i].Locale;
        _tcscpy(
                KeyPack.szProductName, 
                ppmLsKeyPack->pDescription[i].szProductName
            );

        _tcscpy(
                KeyPack.szProductDesc, 
                ppmLsKeyPack->pDescription[i].szProductDesc
            );

        //
        //  This is a temporary workaround to Install Whistler CALs: If registry key is not set,
        //  Keypack's minor version number is set to 2.
        //

        HKEY hKey = NULL;
        dwStatus = RegOpenKeyEx(HKEY_LOCAL_MACHINE, WHISTLER_CAL, 0,
                                KEY_ALL_ACCESS, &hKey);

        if (dwStatus == ERROR_SUCCESS)
        {            
            RegCloseKey(hKey);
        }
        else
        {
            if(KeyPack.wMajorVersion == 5 && KeyPack.wMinorVersion == 1)
            {
                KeyPack.wMinorVersion = 2;
        
                KeyPack.szProductId[7] = _T('2');
            }

        }
       
        dwStatus = TLSDBLicenseKeyPackAdd(pDbWkSpace, &KeyPack);
    }

    if(dwStatus == ERROR_SUCCESS)
    {
        KeyPack.dwNumberOfLicenses = KeyPack.dwTotalLicenseInKeyPack;

        KeyPack.ucKeyPackStatus = LSKEYPACKSTATUS_ACTIVE;

        if (!FileTimeToLicenseDate(
                &ppmLsKeyPack->ActiveDate, 
                &KeyPack.dwActivateDate
                ))
        {
            dwStatus = GetLastError();
            goto cleanup;
        }

        if (!FileTimeToLicenseDate(
                &ppmLsKeyPack->ExpireDate, 
                &KeyPack.dwExpirationDate
                ))
        {
            dwStatus = GetLastError();
            goto cleanup;
        }

        dwStatus=TLSDBLicenseKeyPackSetStatus(
                                    pDbWkSpace, 
                                    LSKEYPACK_SET_ACTIVATEDATE | LSKEYPACK_SET_KEYPACKSTATUS | LSKEYPACK_SET_EXPIREDATE | LSKEYPACK_EXSEARCH_AVAILABLE, 
                                    &KeyPack
                                );
    }        

    //
    // Post a ssync work object to all known server.
    //
    if(dwStatus == ERROR_SUCCESS)
    {
        *lpInstalledKeyPack = KeyPack;
    }

cleanup:

    return dwStatus;
}


DWORD
TLSDBRegisterLicenseKeyPack(
    IN PTLSDbWorkSpace pDbWkSpace, 
    IN License_KeyPack* pLicenseKeyPack,
    OUT LPLSKeyPack lpInstalledKeyPack
    )
/*++

Abstract:

    Add a license keypack into database.

Parameter:

    pDbWkSpace : workspace handle.
    pLicenseKeyPack : Licensed key pack to be added.

Returns:
    
*/
{
    LSKeyPack KeyPack;
    long activeDate;
    long expireDate;
    DWORD dwStatus=ERROR_SUCCESS;
    PMREGISTERLICENSEPACK pmLicensePack;
    PMLSKEYPACK pmLsKeyPack;

    CTLSPolicy* pPolicy = NULL;
    PMHANDLE hClient = NULL;

    TCHAR szTlsProductCode[LSERVER_MAX_STRING_SIZE+1];
    TCHAR szCHProductCode[LSERVER_MAX_STRING_SIZE+1];
    DWORD dwBufSize = LSERVER_MAX_STRING_SIZE + 1;

    DWORD i;

    dwStatus = ConvertInternetLicensePackToPMLicensePack(
                                        pLicenseKeyPack,
                                        &pmLicensePack
                                    );

    if(dwStatus != ERROR_SUCCESS)
    {
        goto cleanup;
    }    

    StringCbCopyN(szCHProductCode,
                  sizeof(szCHProductCode),
                  pmLicensePack.szProductId,
                  LSERVER_MAX_STRING_SIZE+1);

    if(TranslateCHCodeToTlsCode(
                            pmLicensePack.szCompanyName,
                            szCHProductCode,
                            szTlsProductCode,
                            &dwBufSize) == TRUE )
    {
        // if can't find a policy module to handle, use default.
        StringCbCopyN(pmLicensePack.szProductId,
                      sizeof(pmLicensePack.szProductId),
                      szTlsProductCode,
                      sizeof(pmLicensePack.szProductId));
    }
     
    // use default if necessary                       
    pPolicy = AcquirePolicyModule(
                            pmLicensePack.szCompanyName,
                            pmLicensePack.szProductId,
                            TRUE
                        );

    if(pPolicy == NULL)
    {
        dwStatus = GetLastError();
        goto cleanup;
    }

    hClient = GenerateClientId();

    dwStatus = pPolicy->PMRegisterLicensePack(
                                        hClient,
                                        REGISTER_PROGRESS_NEW,
                                        (PVOID)&pmLicensePack,
                                        (PVOID)&pmLsKeyPack
                                    );
    if(dwStatus != ERROR_SUCCESS)
    {
        goto cleanup;
    }

    dwStatus = TLSDBInstallKeyPack(
                            pDbWkSpace, 
                            &pmLsKeyPack,
                            lpInstalledKeyPack
                        );

    if(dwStatus == ERROR_SUCCESS)
    {
        TLSResetLogLowLicenseWarning(
                            pmLicensePack.szCompanyName,
                            pmLicensePack.szProductId,
                            pmLicensePack.dwProductVersion,
                            FALSE
                        );
    }

                            
cleanup:

    if(pPolicy != NULL && hClient != NULL)
    {
        pPolicy->PMRegisterLicensePack(
                                hClient,
                                REGISTER_PROGRESS_END,
                                UlongToPtr(dwStatus),
                                NULL
                            );

        ReleasePolicyModule(pPolicy);
    }

    if(pmLicensePack.pDescription != NULL)
    {
        FreeMemory(pmLicensePack.pDescription);
    }

    return dwStatus;
}

//+--------------------------------------------------------------------
//
// TermSrv specific code...
//
// PRODUCT_INFO_COMPANY_NAME is defined in license.h
//
#define LKP_VERSION_BASE            1
#define WINDOWS_VERSION_NT5         5
#define WINDOWS_VERSION_BASE        2000

DWORD
TLSDBTelephoneRegisterLicenseKeyPack(
    IN PTLSDbWorkSpace pDbWkSpace, 
    IN LPTSTR pszPID,
    IN PBYTE pbLKP,
    IN DWORD cbLKP,
    OUT LPLSKeyPack lpInstalledKeyPack
    )
/*++

Abstract:

    Add a license keypack into database.

Parameter:

    pDbWkSpace : workspace handle.
    pLicenseKeyPack : Licensed key pack to be added.

Returns:
    
*/
{
    DWORD dwStatus;
    DWORD dwVerifyResult;
    DWORD dwQuantity;
    DWORD dwSerialNumber;
    DWORD dwExpirationMos;
    DWORD dwVersion;
    DWORD dwUpgrade;
    LSKeyPack keypack;
    DWORD dwProductVersion;

    PMKEYPACKDESCREQ kpDescReq;
    PPMKEYPACKDESC pKpDesc = NULL;
    CTLSPolicy* pPolicy=NULL;
    PMHANDLE hClient = NULL;
    DWORD dwProgramType;

    struct tm expire;
    time_t currentDate;
    time_t ExpirationDate;

    PMREGISTERLICENSEPACK pmLicensePack;
    PMLSKEYPACK pmLsKeyPack;
    LPTSTR pszLKP = NULL;

    TCHAR szTlsProductCode[LSERVER_MAX_STRING_SIZE+1];
    TCHAR szCHProductCode[LSERVER_MAX_STRING_SIZE+1];
    DWORD dwBufSize = LSERVER_MAX_STRING_SIZE + 1;

    if(pDbWkSpace == NULL || pszPID == NULL || pbLKP == NULL || cbLKP == 0)
    {
        dwStatus = ERROR_INVALID_PARAMETER;
        goto cleanup;
    }

    //
    // Make sure data passed in is NULL terminated, current LKP
    // is base 24 encoded string.
    //
    pszLKP = (LPTSTR)AllocateMemory( cbLKP + sizeof(TCHAR) );
    if(pszLKP == NULL)
    {
        dwStatus = TLS_E_ALLOCATE_MEMORY;
        goto cleanup;
    }

    StringCbCopyN(pszLKP,
                  cbLKP+sizeof(TCHAR),
                  (LPTSTR)pbLKP,
                  cbLKP);

    //
    // Verify LKP
    //
    dwVerifyResult = LKPLITE_LKP_VALID;
    dwStatus = LKPLiteVerifyLKP(
                            pszPID,
                            pszLKP,
                            &dwVerifyResult
                        );

    if(dwStatus != ERROR_SUCCESS || dwVerifyResult != LKPLITE_LKP_VALID)
    {
        if(dwVerifyResult == LKPLITE_LKP_INVALID)
        {
            dwStatus = TLS_E_INVALID_LKP;
        }
        else if(dwVerifyResult == LKPLITE_LKP_INVALID_SIGN)
        {
            dwStatus = TLS_E_LKP_INVALID_SIGN;
        }

        goto cleanup;
    }

    //
    // Decode LKP
    //
    dwStatus = LKPLiteCrackLKP(
                            pszPID,
                            pszLKP,
                            szCHProductCode,
                            &dwQuantity,
                            &dwSerialNumber,
                            &dwExpirationMos,
                            &dwVersion,
                            &dwUpgrade,
                            &dwProgramType
                        );

    if(dwStatus != ERROR_SUCCESS)
    {
        dwStatus = TLS_E_DECODE_LKP;
        goto cleanup;
    }

    if(TranslateCHCodeToTlsCode(
                            PRODUCT_INFO_COMPANY_NAME,
                            szCHProductCode,
                            szTlsProductCode,
                            &dwBufSize) == FALSE )
    {
        // if can't find a policy module to handle, use default.
        StringCbCopyN(szTlsProductCode,
                      sizeof(szTlsProductCode),
                      szCHProductCode,
                      sizeof(szTlsProductCode));
    }

    //
    // Current LKP does not support 1) other company, 2)
    // only register with NT5 or later
    //
    pPolicy = AcquirePolicyModule(
                                PRODUCT_INFO_COMPANY_NAME,
                                szTlsProductCode,
                                TRUE
                            );

    if(pPolicy == NULL)
    {
        dwStatus = GetLastError();
        goto cleanup;
    }

    memset(&keypack, 0, sizeof(keypack));


    memset(&pmLicensePack, 0, sizeof(pmLicensePack));
    pmLicensePack.SourceType = REGISTER_SOURCE_PHONE;

    switch(dwProgramType)
    {
        case LKPLITE_PROGRAM_SELECT:
            pmLicensePack.dwKeyPackType = LICENSE_KEYPACK_TYPE_SELECT;
            break;

        case LKPLITE_PROGRAM_MOLP:
            pmLicensePack.dwKeyPackType = LICENSE_KEYPACK_TYPE_MOLP;
            break;
        
        case LKPLITE_PROGRAM_RETAIL:
            pmLicensePack.dwKeyPackType = LICENSE_KEYPACK_TYPE_RETAIL;
            break;

        default:
            SetLastError(dwStatus = TLS_E_INVALID_DATA);
            goto cleanup;
    }

    pmLicensePack.dwDistChannel = LSKEYPACKCHANNELOFPURCHASE_RETAIL;
    GetSystemTimeAsFileTime(&pmLicensePack.IssueDate);
    pmLicensePack.ActiveDate = pmLicensePack.IssueDate;

    currentDate = time(NULL);
    expire = *gmtime( (time_t *)&currentDate );
    expire.tm_mon += dwExpirationMos;
    ExpirationDate = mktime(&expire);

    if(ExpirationDate == (time_t) -1)
    {
        //
        // expiration month is too big, 
        // set it to 2038/1/1
        //
        memset(&expire, 0, sizeof(expire));

        expire.tm_year = 2038 - 1900;
        expire.tm_mon = 0;
        expire.tm_mday = 1;

        ExpirationDate = mktime(&expire);
    }

    if(ExpirationDate == (time_t) -1)
    {
        //
        // invalid time
        //
        dwStatus = ERROR_INVALID_PARAMETER;
        goto cleanup;
    }

    UnixTimeToFileTime(ExpirationDate, &pmLicensePack.ExpireDate);   

    //
    // dwSerialNumber is license pack serial number not begin 
    // serial number in license pack.
    //
    pmLicensePack.KeypackSerialNum.Data1 = dwSerialNumber;

    //
    // Tel. registration does not have any info regarding
    // begin serial number in license pack.
    //
    pmLicensePack.dwBeginSerialNum = 0;
    pmLicensePack.dwQuantity = dwQuantity;
    _tcscpy(pmLicensePack.szProductId, szTlsProductCode);
    _tcscpy(pmLicensePack.szCompanyName, PRODUCT_INFO_COMPANY_NAME);
    if(dwVersion == 1)
    {
        pmLicensePack.dwProductVersion = MAKELONG(0, WINDOWS_VERSION_NT5);
    }
    else
    {           
        DWORD dwMajorVer = (dwVersion >> 3); 
        
        // Right most 3 bits represent Minor version and stored in LOBYTE(LOWORD)
        pmLicensePack.dwProductVersion = (DWORD)(dwVersion & 07);

        // 4 bits starting at 6th position represent Major version and stored in LOBYTE(HIWORD)
        pmLicensePack.dwProductVersion |= (DWORD)(dwMajorVer << 16);
    }

    pmLicensePack.dwPlatformId = dwUpgrade;
    pmLicensePack.dwLicenseType = LSKEYPACKLICENSETYPE_UNKNOWN;
    pmLicensePack.pbLKP = pbLKP;
    pmLicensePack.cbLKP = cbLKP;

    hClient = GenerateClientId();
    dwStatus = pPolicy->PMRegisterLicensePack(
                                        hClient,
                                        REGISTER_PROGRESS_NEW,
                                        (PVOID)&pmLicensePack,
                                        (PVOID)&pmLsKeyPack
                                    );
    if(dwStatus != ERROR_SUCCESS)
    {
        goto cleanup;
    }


    dwStatus = TLSDBInstallKeyPack(
                            pDbWkSpace, 
                            &pmLsKeyPack,
                            lpInstalledKeyPack
                        );

    if(dwStatus == ERROR_SUCCESS)
    {
        TLSResetLogLowLicenseWarning(
                            pmLicensePack.szCompanyName,
                            pmLicensePack.szProductId,
                            pmLicensePack.dwProductVersion,
                            FALSE
                        );
    }

cleanup:

    FreeMemory(pszLKP);

    //
    // Close policy module
    //
    if(pPolicy != NULL && hClient != NULL)
    {
        pPolicy->PMRegisterLicensePack(
                                hClient,
                                REGISTER_PROGRESS_END,
                                UlongToPtr(dwStatus),
                                NULL
                            );

        ReleasePolicyModule(pPolicy);
    }

    return dwStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\license\tlserver\server\lkpdesc.cpp ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996-1998
//
// File:        kpDesc.cpp
//
// Contents:    
//              KeyPackDesc Table related function.
//
// History:     
//          Feb. 4, 98      HueiWang        Created.
//
// Note :
//      Bind Parameter and Bind Column need to to in sync with select column
//---------------------------------------------------------------------------
#include "pch.cpp"
#include "lkpdesc.h"
#include "globals.h"


//---------------------------------------------------------------------------
//  Functions : LSDBLockKeyPackDescTable()
//              LSDBUnlockKeyPackDescTable()
//
//  Abstract : Lock and Unlock single access to key pack desc. table.
//---------------------------------------------------------------------------
void
TLSDBLockKeyPackDescTable()
{
    DBGPrintf(
            DBG_INFORMATION,
            DBG_FACILITY_LOCK,
            DBGLEVEL_FUNCTION_TRACE,
            _TEXT("Locking table KeyPackDescTable\n")
        );
            

    LicPackDescTable::LockTable();
    return;
}

void
TLSDBUnlockKeyPackDescTable()
{
    DBGPrintf(
            DBG_INFORMATION,
            DBG_FACILITY_LOCK,
            DBGLEVEL_FUNCTION_TRACE,
            _TEXT("Unlocking table KeyPackDescTable\n")
        );

    LicPackDescTable::UnlockTable();
    return;
}

//++--------------------------------------------------------------------
DWORD 
TLSDBKeyPackDescEnumBegin(
    IN PTLSDbWorkSpace pDbWkSpace, 
    IN BOOL bMatchAll, 
    IN DWORD dwSearchParm, 
    IN PLICPACKDESC lpKeyPackDesc
    )
/*++
Abstract:

    Begin enumeration of license pack description table.

Parameters:

    pDbWkSpace : Workspace handle.
    bMatchAll : TRUE if matching all license pack 
                description search value, FALSE otherwise
    dwSearchParam : Field that will be search on.
    lpKeyPackDesc : value to be search, subject to bMatchAll criteral

Returns:

*/
{
    DWORD dwStatus=ERROR_SUCCESS;
    BOOL  bSuccess=TRUE;

    if(pDbWkSpace == NULL)
    {
        SetLastError(dwStatus = ERROR_INVALID_PARAMETER);
        TLSASSERT(FALSE);
        return dwStatus;
    }

    bSuccess = pDbWkSpace->m_LicPackDescTable.EnumerateBegin(
                                                    bMatchAll, 
                                                    dwSearchParm, 
                                                    lpKeyPackDesc
                                                );

    if(bSuccess == FALSE)
    {
        LPTSTR pString = NULL;
    
        TLSGetESEError(
                    pDbWkSpace->m_LicPackDescTable.GetLastJetError(), 
                    &pString
                );

        TLSLogEvent(
                EVENTLOG_ERROR_TYPE,
                TLS_E_DBGENERAL,
                TLS_E_JB_BASE,
                pDbWkSpace->m_LicPackDescTable.GetLastJetError(),
                (pString != NULL) ? pString : _TEXT("")
            );

        if(pString != NULL)
        {
            LocalFree(pString);
        }

        SetLastError(dwStatus = SET_JB_ERROR(pDbWkSpace->m_LicPackDescTable.GetLastJetError()));
        TLSASSERT(FALSE);
    }

    return dwStatus;
}

//++----------------------------------------------------------------------
DWORD 
TLSDBKeyPackDescEnumNext(
    IN PTLSDbWorkSpace pDbWkSpace, 
    IN OUT PLICPACKDESC lpKeyPackDesc
    )
/*++
Abstract:    

    Fetch next record in LicPackDesc table that match search condition.

Parameter:

    pDbWkSpace : Workspace handle.
    lpKeyPackDesc : return record that match search condition.

Returns:

++*/
{
    DWORD dwStatus=ERROR_SUCCESS;

    if(pDbWkSpace == NULL)
    {
        SetLastError(dwStatus = ERROR_INVALID_PARAMETER);
        TLSASSERT(FALSE);
        return dwStatus;
    }

    switch(pDbWkSpace->m_LicPackDescTable.EnumerateNext(*lpKeyPackDesc))
    {
        case RECORD_ENUM_ERROR:
            {
                LPTSTR pString = NULL;
    
                TLSGetESEError(
                            pDbWkSpace->m_LicPackDescTable.GetLastJetError(), 
                            &pString
                        );

                TLSLogEvent(
                        EVENTLOG_ERROR_TYPE,
                        TLS_E_DBGENERAL,
                        TLS_E_JB_BASE,
                        pDbWkSpace->m_LicPackDescTable.GetLastJetError(),
                        (pString != NULL) ? pString : _TEXT("")
                    );

                if(pString != NULL)
                {
                    LocalFree(pString);
                }
            }

            dwStatus = SET_JB_ERROR(pDbWkSpace->m_LicPackDescTable.GetLastJetError());
            TLSASSERT(FALSE);
            break;

        case RECORD_ENUM_MORE_DATA:
            dwStatus = ERROR_SUCCESS;
            break;

        case RECORD_ENUM_END:
            dwStatus = TLS_I_NO_MORE_DATA;
    }
            
    return dwStatus;
}

//++-----------------------------------------------------------------------
DWORD 
TLSDBKeyPackDescEnumEnd(
    IN PTLSDbWorkSpace pDbWkSpace
    )
/*++
Abstract:

    End enumeration of LicPackDesc. table

Parameter:

    pdbWkSpace : Workspace handle.

Returns:

++*/
{
    pDbWkSpace->m_LicPackDescTable.EnumerateEnd();
    return ERROR_SUCCESS;
}

//++-----------------------------------------------------------------------
DWORD
TLSDBKeyPackDescAddEntry(
    IN PTLSDbWorkSpace pDbWkSpace,
    IN PLICPACKDESC lpKeyPackDesc
    )
/*++
Abstract:

    Add a record into licensepackdesc table.

Parameter:

    pDbWkSpace : workspace handle.
    lpKeyPackDesc : record to be added into table.

Returns:
   

++*/
{
    DWORD dwStatus = ERROR_SUCCESS;
    LicPackDescTable& kpDescTable = pDbWkSpace->m_LicPackDescTable;

    //
    // Check for duplicate entry
    //
    dwStatus = TLSDBKeyPackDescFind(
                            pDbWkSpace,
                            TRUE,
                            LICPACKDESCRECORD_TABLE_SEARCH_KEYPACKID | LICPACKDESCRECORD_TABLE_SEARCH_LANGID, 
                            lpKeyPackDesc,
                            NULL
                        );

    if(dwStatus == ERROR_SUCCESS)
    {
        SetLastError(dwStatus = TLS_E_DUPLICATE_RECORD);
        goto cleanup;
    }
    else if(dwStatus != TLS_E_RECORD_NOTFOUND)
    {
        goto cleanup;
    }
    SetLastError(dwStatus = ERROR_SUCCESS);
    if(kpDescTable.InsertRecord(*lpKeyPackDesc) == FALSE)
    {
        if(kpDescTable.GetLastJetError() == JET_errKeyDuplicate)
        {
            SetLastError(dwStatus=TLS_E_DUPLICATE_RECORD);
        }
        else
        {
            LPTSTR pString = NULL;
    
            TLSGetESEError(kpDescTable.GetLastJetError(), &pString);

            TLSLogEvent(
                    EVENTLOG_ERROR_TYPE,
                    TLS_E_DBGENERAL,
                    TLS_E_JB_BASE,
                    kpDescTable.GetLastJetError(),
                    (pString != NULL) ? pString : _TEXT("")
                );

            if(pString != NULL)
            {
                LocalFree(pString);
            }

            SetLastError(dwStatus = SET_JB_ERROR(kpDescTable.GetLastJetError()));
            TLSASSERT(FALSE);
        }
    }

cleanup:
    
    return dwStatus;
}

//++------------------------------------------------------------------------
DWORD
TLSDBKeyPackDescDeleteEntry(
    IN PTLSDbWorkSpace pDbWkSpace,
    IN PLICPACKDESC lpKeyPackDesc
    )
/*++
Abstract:

    Delete all record from LicPackDesc table that match the keypack id

Parameter:

    pDbWkSpace : workspace handle.
    lpKeyPackDesc : keypack Id to be deleted

Returns:

*/
{
    DWORD dwStatus = ERROR_SUCCESS;
    LicPackDescTable& kpDescTable = pDbWkSpace->m_LicPackDescTable;
    BOOL bSuccess;

    bSuccess = kpDescTable.DeleteAllRecord(
                                    TRUE, 
                                    LICPACKDESCRECORD_TABLE_SEARCH_KEYPACKID, 
                                    *lpKeyPackDesc
                                );

    if( bSuccess == FALSE )
    {
        SetLastError(dwStatus = SET_JB_ERROR(kpDescTable.GetLastJetError()));

        // ignore record not found error
        if(kpDescTable.GetLastJetError() != JET_errRecordNotFound)
        {
            LPTSTR pString = NULL;
    
            TLSGetESEError(kpDescTable.GetLastJetError(), &pString);

            TLSLogEvent(
                    EVENTLOG_ERROR_TYPE,
                    TLS_E_DBGENERAL,
                    TLS_E_JB_BASE,
                    kpDescTable.GetLastJetError(),
                    (pString != NULL) ? pString : _TEXT("")
                );

            if(pString != NULL)
            {
                LocalFree(pString);
            }

            TLSASSERT(kpDescTable.GetLastJetError() == JET_errRecordNotFound);
        }
    }

    return dwStatus;
}

//++------------------------------------------------------------------------
DWORD
TLSDBKeyPackDescUpdateEntry(
    IN PTLSDbWorkSpace pDbWkSpace,
    IN DWORD dwUpdateParm,
    IN PLICPACKDESC lpKeyPackDesc
    )
/*++
Abstract:

    Update column value of record in LicPackDescTable that match 
    the keypackid

Parameter:

    pDbWkSpace : Work space handle.
    dwUpdateParm : Fields that will be updated, note, keypack ID and language ID
                   can't be update.
    lpKeyPackDesc : Record/value to be update

Returns:


Note:

    dwKeyPackId and dwLangId can't be update.

++*/
{
    DWORD dwStatus = ERROR_SUCCESS;
    LicPackDescTable& kpDescTable = pDbWkSpace->m_LicPackDescTable;
    BOOL bSuccess;

    //
    // Check for duplicate entry
    //
    dwStatus = TLSDBKeyPackDescFind(
                            pDbWkSpace,
                            TRUE,
                            LICPACKDESCRECORD_TABLE_SEARCH_KEYPACKID | LICPACKDESCRECORD_TABLE_SEARCH_LANGID, 
                            lpKeyPackDesc,
                            NULL
                        );

    if(dwStatus != ERROR_SUCCESS)
    {
        TLSASSERT(dwStatus == ERROR_SUCCESS);
        goto cleanup;
    }

    
    bSuccess = kpDescTable.UpdateRecord(
                            *lpKeyPackDesc, 
                            dwUpdateParm & ~(LICPACKDESCRECORD_TABLE_SEARCH_KEYPACKID | LICPACKDESCRECORD_TABLE_SEARCH_LANGID)
                        );

    if(bSuccess == FALSE)
    {
        LPTSTR pString = NULL;
    
        TLSGetESEError(kpDescTable.GetLastJetError(), &pString);

        TLSLogEvent(
                EVENTLOG_ERROR_TYPE,
                TLS_E_DBGENERAL,
                TLS_E_JB_BASE,
                kpDescTable.GetLastJetError(),
                (pString != NULL) ? pString : _TEXT("")
            );

        if(pString != NULL)
        {
            LocalFree(pString);
        }

        SetLastError(dwStatus = SET_JB_ERROR(kpDescTable.GetLastJetError()));
        TLSASSERT(FALSE);
    }

cleanup:
    
    return dwStatus;
}

//++----------------------------------------------------------------------
DWORD
TLSDBKeyPackDescSetValue(
    PTLSDbWorkSpace pDbWkSpace, 
    DWORD dwSetParm, 
    PLICPACKDESC lpKeyPackDesc
    )
/*++
Abstract:

    Add/Delete/Update a record in LicPackDescTable.

Parameter:

    pDbWkSpace : workspace handle.
    dwSetParm : Columns to be update.
    lpKeyPackDesc : record/value to be update/delete/add.

Return:


Note:
    Wrapper around TLSDBKeyPackDescDeleteEntry(),
    TLSDBKeyPackDescAddEntry(), TLSDBKeyPackDescUpdateEntry()
    base on dwSetParm value.
++*/
{
    DWORD dwStatus=ERROR_SUCCESS;

    if(pDbWkSpace == NULL || lpKeyPackDesc == NULL)
    {
        SetLastError(dwStatus = ERROR_INVALID_PARAMETER);
        goto cleanup;
    }

    TLSDBLockKeyPackDescTable();

    if(dwSetParm & KEYPACKDESC_SET_DELETE_ENTRY)
    {
        dwStatus = TLSDBKeyPackDescDeleteEntry(
                                        pDbWkSpace,
                                        lpKeyPackDesc
                                    );
    }
    else if(dwSetParm & KEYPACKDESC_SET_ADD_ENTRY)
    {
        dwStatus = TLSDBKeyPackDescAddEntry(
                                        pDbWkSpace,
                                        lpKeyPackDesc
                                    );
    }
    else
    {
        dwStatus = TLSDBKeyPackDescUpdateEntry(
                                        pDbWkSpace,
                                        dwSetParm,
                                        lpKeyPackDesc
                                    );
    }

    TLSDBUnlockKeyPackDescTable();

cleanup:
    return dwStatus;
}

//++---------------------------------------------------------------------
DWORD
TLSDBKeyPackDescFind(
    IN PTLSDbWorkSpace pDbWkSpace, 
    IN BOOL bMatchAllParam,        
    IN DWORD dwSearchParm, 
    IN PLICPACKDESC lpKeyPackDesc,
    IN OUT PLICPACKDESC lpKeyPackDescFound
    )
/*
Abstract:

    Find a LicPackDesc record based on search parameters.

Parameter:

    pDbWkSpace - workspace handle.
    bMatchAllParam - TRUE match all search parameters, FALSE otherwise.
    dwSearchParam - Fields that will participate in search.
    lpKeyPackDesc - value to be search.
    lpKeyPackDescFound - return found record.

Returns:


Note:

*/
{
    DWORD dwStatus=ERROR_SUCCESS;
    BOOL bSuccess;
    LICPACKDESC kpDescFound;

    if(pDbWkSpace == NULL || lpKeyPackDesc == NULL)
    {
        SetLastError(dwStatus = ERROR_INVALID_PARAMETER);
        TLSASSERT(pDbWkSpace != NULL);
        return dwStatus;
    }

    LicPackDescTable& kpDescTable = pDbWkSpace->m_LicPackDescTable;

    bSuccess = kpDescTable.FindRecord(
                                bMatchAllParam,
                                dwSearchParm,
                                *lpKeyPackDesc,
                                kpDescFound
                            );

    if(bSuccess != TRUE)
    {
        if(kpDescTable.GetLastJetError() == JET_errRecordNotFound)
        {
            SetLastError(dwStatus = TLS_E_RECORD_NOTFOUND);
        }
        else
        {
            LPTSTR pString = NULL;
    
            TLSGetESEError(kpDescTable.GetLastJetError(), &pString);

            TLSLogEvent(
                    EVENTLOG_ERROR_TYPE,
                    TLS_E_DBGENERAL,
                    TLS_E_JB_BASE,
                    kpDescTable.GetLastJetError(),
                    (pString != NULL) ? pString : _TEXT("")
                );

            if(pString != NULL)
            {
                LocalFree(pString);
            }

            SetLastError(
                    dwStatus = (SET_JB_ERROR(kpDescTable.GetLastJetError()))
                );

            TLSASSERT(kpDescTable.GetLastJetError() == JET_errRecordNotFound);
        }
    }
    else
    {
        if(lpKeyPackDescFound != NULL) 
        {
            *lpKeyPackDescFound = kpDescFound;
        }
    }
            
    return dwStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\license\tlserver\server\misc.cpp ===
//+--------------------------------------------------------------------------
//
// Copyright (c) 1997-1999 Microsoft Corporation
//
// File:        misc.cpp 
//
// Contents:    Misc. routines
//
// History:     
//
//---------------------------------------------------------------------------

#include "pch.cpp"
#include "globals.h"
#include "misc.h"

//------------------------------------------------------------
PMHANDLE
GenerateClientId()
{
    return (PMHANDLE)ULongToPtr(GetCurrentThreadId());
}

//---------------------------------------------------------------------------

void
TlsLicenseRequestToPMLicenseRequest(
    DWORD dwLicenseType,
    PTLSLICENSEREQUEST pTlsRequest,
    LPTSTR pszMachineName,
    LPTSTR pszUserName,
    DWORD dwSupportFlags,
    PPMLICENSEREQUEST pPmRequest
    )
/*++

    Private routine.

++*/
{
    pPmRequest->dwLicenseType = dwLicenseType;
    pPmRequest->dwProductVersion = pTlsRequest->ProductInfo.dwVersion;
    pPmRequest->pszProductId = (LPTSTR)pTlsRequest->ProductInfo.pbProductID;
    pPmRequest->pszCompanyName = (LPTSTR) pTlsRequest->ProductInfo.pbCompanyName;
    pPmRequest->dwLanguageId = pTlsRequest->dwLanguageID;
    pPmRequest->dwPlatformId = pTlsRequest->dwPlatformID;
    pPmRequest->pszMachineName = pszMachineName;
    pPmRequest->pszUserName = pszUserName;
    pPmRequest->fTemporary = FALSE;
    pPmRequest->dwSupportFlags = dwSupportFlags;

    return;
}
    
//---------------------------------------------------------------------------
BOOL
TLSDBGetMaxKeyPackId(
    PTLSDbWorkSpace pDbWkSpace,
    DWORD* pdwKeyPackId
    )
/*
*/
{
    TLSLICENSEPACK keypack;

    SetLastError(ERROR_SUCCESS);

    // 
    if(pDbWkSpace == NULL || pdwKeyPackId == NULL)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return GetLastError();
    }

    LicPackTable& licpackTable = pDbWkSpace->m_LicPackTable;

    // use primary index - internal keypack id
    if( licpackTable.EnumBegin() == FALSE ||
        licpackTable.MoveToRecord(JET_MoveLast) == FALSE)
    {
        if(licpackTable.GetLastJetError() == JET_errNoCurrentRecord)
        {
            *pdwKeyPackId = 0;
            goto cleanup;
        }
        else
        {
            SetLastError(SET_JB_ERROR(licpackTable.GetLastJetError()));
            goto cleanup;
        }
    }

    
    if(licpackTable.FetchRecord(keypack) == FALSE)
    {
        SetLastError(SET_JB_ERROR(licpackTable.GetLastJetError()));
        goto cleanup;
    }

    //FreeTlsLicensePack(&keypack);

    *pdwKeyPackId = keypack.dwKeyPackId;        

cleanup:
    return GetLastError() == ERROR_SUCCESS;
}

//---------------------------------------------------------------------------

BOOL
TLSDBGetMaxLicenseId(
    PTLSDbWorkSpace pDbWkSpace,
    DWORD* pdwLicenseId
    )
/*
*/
{
    LICENSEDCLIENT licensed;

    SetLastError(ERROR_SUCCESS);

    // 
    if(pDbWkSpace == NULL || pdwLicenseId == NULL)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return GetLastError();
    }

    LicensedTable& licensedTable = pDbWkSpace->m_LicensedTable;

    // use primary index - internal keypack id
    if( licensedTable.EnumBegin() == FALSE ||
        licensedTable.MoveToRecord(JET_MoveLast) == FALSE)
    {
        if(licensedTable.GetLastJetError() == JET_errNoCurrentRecord)
        {
            *pdwLicenseId = 0;
            goto cleanup;
        }
        else
        {
            SetLastError(SET_JB_ERROR(licensedTable.GetLastJetError()));
            goto cleanup;
        }
    }

    
    if(licensedTable.FetchRecord(licensed) == FALSE)
    {
        SetLastError(SET_JB_ERROR(licensedTable.GetLastJetError()));
        goto cleanup;
    }

    *pdwLicenseId = licensed.dwLicenseId;        

cleanup:
    return GetLastError() == ERROR_SUCCESS;
}



//+------------------------------------------------------------------------
//  Function: 
//      LSDBGetNextKeyPackId()
//
//  Description:
//      Return next available KeyPackId to be used in KeyPack table
//
//  Arguments:
//      None
//
//  Returns:
//      Key Pack Id
//
//  Notes:
//      Could use AUTO NUMBER column type but returning the value would be
//      more toublesome.
//
//  History:
//-------------------------------------------------------------------------
DWORD
TLSDBGetNextKeyPackId()
{
    LONG nextkeypack = InterlockedExchangeAdd(&g_NextKeyPackId, 1);

    DBGPrintf(
            DBG_INFORMATION,
            DBG_FACILITY_ALLOCATELICENSE, 
            DBGLEVEL_FUNCTION_TRACE,
            _TEXT("GetNextKeyPack returns %d\n"), 
            nextkeypack
        );

    return nextkeypack;
}

//+------------------------------------------------------------------------
//  Function: 
//      LSDBGetNextLicenseId()
//
//  Abstract:
//      Return next available LicenseId to be used in License Table
//
//  Arguments:
//      None.
//
//  Returns:
//      Next available License Id
//
//  Notes:
//
//  History:
//-------------------------------------------------------------------------
DWORD 
TLSDBGetNextLicenseId()
{
    LONG nextlicenseid = InterlockedExchangeAdd(&g_NextLicenseId, 1);

    DBGPrintf(
            DBG_INFORMATION,
            DBG_FACILITY_ALLOCATELICENSE, 
            DBGLEVEL_FUNCTION_TRACE,
            _TEXT("GetNextLicenseId returns %d\n"), 
            nextlicenseid
        );

    return nextlicenseid;
}  

//---------------------------------------------------------------------------
DWORD
TLSFormDBRequest(
    PBYTE pbEncryptedHwid,
    DWORD cbEncryptedHwid,
    DWORD dwProductVersion,
    LPTSTR pszCompanyName,
    LPTSTR pszProductId,
    DWORD dwLanguageId,
    DWORD dwPlatformId,
    LPTSTR szClientMachine, 
    LPTSTR szUserName, 
    LPTLSDBLICENSEREQUEST pDbRequest 
    )
/*++

++*/
{
    DWORD status;

    memset(pDbRequest, 0, sizeof(TLSDBLICENSEREQUEST));

    // Decrypt HWID
    if(pbEncryptedHwid)
    {
        status=LicenseDecryptHwid(
                    &pDbRequest->hWid, 
                    cbEncryptedHwid,
                    pbEncryptedHwid,
                    g_cbSecretKey,
                    g_pbSecretKey);

        if(status != LICENSE_STATUS_OK)
        {
            return status;
        }
    }

    //
    // NOTE : No allocation of memory here...
    //
    pDbRequest->dwProductVersion = dwProductVersion;
    pDbRequest->pszCompanyName = pszCompanyName;
    pDbRequest->pszProductId = pszProductId;
    pDbRequest->dwLanguageID = dwLanguageId;
    pDbRequest->dwPlatformID = dwPlatformId;
    pDbRequest->pbEncryptedHwid = pbEncryptedHwid;
    pDbRequest->cbEncryptedHwid = cbEncryptedHwid;

    if(szClientMachine)
        _tcscpy(pDbRequest->szMachineName, szClientMachine);

    if(szUserName)
        _tcscpy(pDbRequest->szUserName, szUserName);

    pDbRequest->clientCertRdn.type = LSCERT_CLIENT_INFO_TYPE;
    pDbRequest->clientCertRdn.ClientInfo.szUserName = pDbRequest->szUserName;
    pDbRequest->clientCertRdn.ClientInfo.szMachineName = pDbRequest->szMachineName;
    pDbRequest->clientCertRdn.ClientInfo.pClientID = &pDbRequest->hWid;

    return ERROR_SUCCESS;
}

//---------------------------------------------------------------------------

DWORD
TLSConvertRpcLicenseRequestToDbRequest( 
    PBYTE pbEncryptedHwid,
    DWORD cbEncryptedHwid,
    TLSLICENSEREQUEST* pRequest, 
    LPTSTR szClientMachine, 
    LPTSTR szUserName, 
    LPTLSDBLICENSEREQUEST pDbRequest 
    )
/*++

++*/
{
    DWORD status;

    memset(pDbRequest, 0, sizeof(TLSDBLICENSEREQUEST));

    // Decrypt HWID
    if(pbEncryptedHwid)
    {
        status=LicenseDecryptHwid(
                    &pDbRequest->hWid, 
                    cbEncryptedHwid,
                    pbEncryptedHwid,
                    g_cbSecretKey,
                    g_pbSecretKey);

        if(status != LICENSE_STATUS_OK)
        {
            return status;
        }
    }

    //
    // NOTE : No allocation of memory here...
    //

    // pDbRequest->pProductInfo = &(pRequest->ProductInfo);
    pDbRequest->dwProductVersion = pRequest->ProductInfo.dwVersion;
    pDbRequest->pszCompanyName = (LPTSTR)pRequest->ProductInfo.pbCompanyName;
    pDbRequest->pszProductId = (LPTSTR)pRequest->ProductInfo.pbProductID;


    pDbRequest->dwLanguageID = pRequest->dwLanguageID;
    pDbRequest->dwPlatformID = pRequest->dwPlatformID;
    pDbRequest->pbEncryptedHwid = pRequest->pbEncryptedHwid;
    pDbRequest->cbEncryptedHwid = pRequest->cbEncryptedHwid;

    if(szClientMachine)
        _tcscpy(pDbRequest->szMachineName, szClientMachine);

    if(szUserName)
        _tcscpy(pDbRequest->szUserName, szUserName);

    pDbRequest->clientCertRdn.type = LSCERT_CLIENT_INFO_TYPE;
    pDbRequest->clientCertRdn.ClientInfo.szUserName = pDbRequest->szUserName;
    pDbRequest->clientCertRdn.ClientInfo.szMachineName = pDbRequest->szMachineName;
    pDbRequest->clientCertRdn.ClientInfo.pClientID = &pDbRequest->hWid;

    return ERROR_SUCCESS;
}

//---------------------------------------------------------------------------
BOOL
ConvertLsKeyPackToKeyPack(
    IN LPLSKeyPack lpLsKeyPack, 
    IN OUT PTLSLICENSEPACK lpLicPack,
    IN OUT PLICPACKDESC lpLicPackDesc
    )
/*
Abstract:

    Convert LSKeyPack from client to internally use structure


Parameter:
    
    lpLsKeyPack - source value.
    lpLicPack - Target license pack.
    lpLicPackDesc - target license pack description
    
Return:

    None.    
*/
{
    if(lpLsKeyPack == NULL)
    {
        SetLastError(TLS_E_INVALID_DATA);
        return FALSE;
    }

    //
    // BUG 226875
    //
    DWORD dwBufSize;

    dwBufSize = sizeof(lpLsKeyPack->szCompanyName)/sizeof(lpLsKeyPack->szCompanyName[0]);
    lpLsKeyPack->szCompanyName[dwBufSize - 1] = _TEXT('\0');

    dwBufSize = sizeof(lpLsKeyPack->szKeyPackId)/sizeof(lpLsKeyPack->szKeyPackId[0]);
    lpLsKeyPack->szKeyPackId[dwBufSize - 1] = _TEXT('\0');

    dwBufSize = sizeof(lpLsKeyPack->szProductId)/sizeof(lpLsKeyPack->szProductId[0]);
    lpLsKeyPack->szProductId[dwBufSize - 1] = _TEXT('\0');

    dwBufSize = sizeof(lpLsKeyPack->szProductDesc)/sizeof(lpLsKeyPack->szProductDesc[0]);
    lpLsKeyPack->szProductDesc[dwBufSize - 1] = _TEXT('\0');

    dwBufSize = sizeof(lpLsKeyPack->szBeginSerialNumber)/sizeof(lpLsKeyPack->szBeginSerialNumber[0]);
    lpLsKeyPack->szBeginSerialNumber[dwBufSize - 1] = _TEXT('\0');

    dwBufSize = sizeof(lpLsKeyPack->szProductName)/sizeof(lpLsKeyPack->szProductName[0]);
    lpLsKeyPack->szProductName[dwBufSize - 1] = _TEXT('\0');

    if(lpLicPack)
    {
        memset(lpLicPack, 0, sizeof(TLSLICENSEPACK));
        lpLicPack->ucAgreementType = lpLsKeyPack->ucKeyPackType;
        SAFESTRCPY(lpLicPack->szCompanyName, lpLsKeyPack->szCompanyName);
        SAFESTRCPY(lpLicPack->szKeyPackId, lpLsKeyPack->szKeyPackId);
        SAFESTRCPY(lpLicPack->szProductId, lpLsKeyPack->szProductId);
        lpLicPack->wMajorVersion = lpLsKeyPack->wMajorVersion;
        lpLicPack->wMinorVersion = lpLsKeyPack->wMinorVersion;
        lpLicPack->dwPlatformType = lpLsKeyPack->dwPlatformType;
        lpLicPack->ucLicenseType = lpLsKeyPack->ucLicenseType;
        lpLicPack->ucChannelOfPurchase = lpLsKeyPack->ucChannelOfPurchase;
        SAFESTRCPY(lpLicPack->szBeginSerialNumber, lpLsKeyPack->szBeginSerialNumber);
        lpLicPack->dwTotalLicenseInKeyPack = lpLsKeyPack->dwTotalLicenseInKeyPack;
        lpLicPack->dwProductFlags = lpLsKeyPack->dwProductFlags;
        lpLicPack->dwKeyPackId = lpLsKeyPack->dwKeyPackId;
        lpLicPack->dwExpirationDate = lpLsKeyPack->dwExpirationDate;

        lpLicPack->dwKeyPackId = lpLsKeyPack->dwKeyPackId;
        lpLicPack->dwActivateDate = lpLsKeyPack->dwActivateDate;
        lpLicPack->dwExpirationDate = lpLsKeyPack->dwExpirationDate;
        lpLicPack->dwNumberOfLicenses = lpLsKeyPack->dwNumberOfLicenses;
        lpLicPack->ucKeyPackStatus = lpLsKeyPack->ucKeyPackStatus;
    }

    if(lpLicPackDesc)
    {
        lpLicPackDesc->dwKeyPackId = lpLsKeyPack->dwKeyPackId;
        lpLicPackDesc->dwLanguageId = lpLsKeyPack->dwLanguageId;
        SAFESTRCPY(lpLicPackDesc->szCompanyName, lpLsKeyPack->szCompanyName);
        SAFESTRCPY(lpLicPackDesc->szProductName, lpLsKeyPack->szProductName);
        SAFESTRCPY(lpLicPackDesc->szProductDesc, lpLsKeyPack->szProductDesc);
    }        

    return TRUE;
}

//-----------------------------------------------------------
void
ConvertKeyPackToLsKeyPack(  
    IN PTLSLICENSEPACK lpLicPack,
    IN PLICPACKDESC lpLicPackDesc,
    IN OUT LPLSKeyPack lpLsKeyPack
    )
/*
Abstract:

    Combine internally used license pack structure into one for 
    return back to RPC client

Parameter:

    lpLicPack  - source
    lpLicPackStatus - source
    lpLicPackDesc - source
    lpLsKeyPack - target 
    
Return:

    None.

*/
{
    if(lpLicPack)
    {
        lpLsKeyPack->ucKeyPackType = lpLicPack->ucAgreementType;
        SAFESTRCPY(lpLsKeyPack->szCompanyName, lpLicPack->szCompanyName);
        SAFESTRCPY(lpLsKeyPack->szKeyPackId, lpLicPack->szKeyPackId);
        SAFESTRCPY(lpLsKeyPack->szProductId, lpLicPack->szProductId);
        lpLsKeyPack->wMajorVersion = lpLicPack->wMajorVersion;
        lpLsKeyPack->wMinorVersion = lpLicPack->wMinorVersion;
        lpLsKeyPack->dwPlatformType = lpLicPack->dwPlatformType;
        lpLsKeyPack->ucLicenseType = lpLicPack->ucLicenseType;
        lpLsKeyPack->ucChannelOfPurchase = lpLicPack->ucChannelOfPurchase;
        SAFESTRCPY(lpLsKeyPack->szBeginSerialNumber, lpLicPack->szBeginSerialNumber);
        lpLsKeyPack->dwTotalLicenseInKeyPack = lpLicPack->dwTotalLicenseInKeyPack;
        lpLsKeyPack->dwProductFlags = lpLicPack->dwProductFlags;
        lpLsKeyPack->dwKeyPackId = lpLicPack->dwKeyPackId;

        lpLsKeyPack->ucKeyPackStatus = lpLicPack->ucKeyPackStatus;
        lpLsKeyPack->dwActivateDate = lpLicPack->dwActivateDate;
        lpLsKeyPack->dwExpirationDate = lpLicPack->dwExpirationDate;
        lpLsKeyPack->dwNumberOfLicenses = lpLicPack->dwNumberOfLicenses;
    }

    if(lpLicPackDesc)
    {
        lpLsKeyPack->dwKeyPackId = lpLicPackDesc->dwKeyPackId;
        lpLsKeyPack->dwLanguageId = lpLicPackDesc->dwLanguageId;
        SAFESTRCPY(lpLsKeyPack->szCompanyName, lpLicPackDesc->szCompanyName);
        SAFESTRCPY(lpLsKeyPack->szProductName, lpLicPackDesc->szProductName);
        SAFESTRCPY(lpLsKeyPack->szProductDesc, lpLicPackDesc->szProductDesc);
    }        

    return;
}

//-----------------------------------------------------------------------
void
ConvertLSLicenseToLicense(
    LPLSLicense lplsLicense, 
    LPLICENSEDCLIENT lpLicense
)
/*
*/
{
    lpLicense->dwLicenseId = lplsLicense->dwLicenseId;
    lpLicense->dwKeyPackId = lplsLicense->dwKeyPackId;

    memset(lpLicense->szMachineName, 0, sizeof(lpLicense->szMachineName));
    memset(lpLicense->szUserName, 0, sizeof(lpLicense->szUserName));

    //SAFESTRCPY(lpLicense->szMachineName, lplsLicense->szMachineName);

    _tcsncpy(
            lpLicense->szMachineName, 
            lplsLicense->szMachineName, 
            sizeof(lpLicense->szMachineName)/sizeof(lpLicense->szMachineName[0]) - 1
        );


    //SAFESTRCPY(lpLicense->szUserName, lplsLicense->szUserName);
    _tcsncpy(
            lpLicense->szUserName, 
            lplsLicense->szUserName, 
            sizeof(lpLicense->szUserName)/sizeof(lpLicense->szUserName[0]) - 1
        );

    lpLicense->ftIssueDate = lplsLicense->ftIssueDate;
    lpLicense->ftExpireDate = lplsLicense->ftExpireDate;
    lpLicense->ucLicenseStatus = lplsLicense->ucLicenseStatus;
    DWORD dwPlatformId = 0;
    //In order to get the entire HWID in a TCHAR[37], the PlatformID is shrunk to 2 bytes as follows.
	
    dwPlatformId = HIBYTE(HIWORD(lpLicense->dwSystemBiosChkSum));
    dwPlatformId <<=8;
    dwPlatformId |= LOBYTE(LOWORD(lpLicense->dwSystemBiosChkSum));

    wsprintf(lplsLicense->szHWID,_TEXT("%04x%08x%08x%08x%08x"),
                dwPlatformId,
                lpLicense->dwVideoBiosChkSum,
                lpLicense->dwFloppyBiosChkSum,
                lpLicense->dwHardDiskSize,
                lpLicense->dwRamSize);
    lplsLicense->szHWID[GUID_MAX_SIZE-1] = '\0';

    //
    // not expose to client
    //
    lpLicense->dwNumLicenses = 0;
    return;
}

//-----------------------------------------------------------------------
void
ConvertLicenseToLSLicense(
    LPLICENSEDCLIENT lpLicense, 
    LPLSLicense lplsLicense
)
/*
*/
{
    lplsLicense->dwLicenseId = lpLicense->dwLicenseId;
    lplsLicense->dwKeyPackId = lpLicense->dwKeyPackId;
    SAFESTRCPY(lplsLicense->szMachineName, lpLicense->szMachineName);
    SAFESTRCPY(lplsLicense->szUserName, lpLicense->szUserName);
    lplsLicense->ftIssueDate = lpLicense->ftIssueDate;
    lplsLicense->ftExpireDate = lpLicense->ftExpireDate;
    lplsLicense->ucLicenseStatus = lpLicense->ucLicenseStatus;

    DWORD dwPlatformId = 0;
    //In order to get the entire HWID in a TCHAR[37], the PlatformID is shrunk to 2 bytes as follows.
    dwPlatformId = HIBYTE(HIWORD(lpLicense->dwSystemBiosChkSum));
    dwPlatformId <<=8;
    dwPlatformId |= LOBYTE(LOWORD(lpLicense->dwSystemBiosChkSum));

    wsprintf(lplsLicense->szHWID,_TEXT("%04x%08x%08x%08x%08x"),
                dwPlatformId,
                lpLicense->dwVideoBiosChkSum,
                lpLicense->dwFloppyBiosChkSum,
                lpLicense->dwHardDiskSize,
                lpLicense->dwRamSize);

    lplsLicense->szHWID[GUID_MAX_SIZE-1] = '\0';
   
    return;
}

//-----------------------------------------------------------------------
void
ConvertLicenseToLSLicenseEx(
    LPLICENSEDCLIENT lpLicense, 
    LPLSLicenseEx lplsLicense
)
/*
*/
{
    lplsLicense->dwLicenseId = lpLicense->dwLicenseId;
    lplsLicense->dwKeyPackId = lpLicense->dwKeyPackId;
    SAFESTRCPY(lplsLicense->szMachineName, lpLicense->szMachineName);
    SAFESTRCPY(lplsLicense->szUserName, lpLicense->szUserName);
    lplsLicense->ftIssueDate = lpLicense->ftIssueDate;
    lplsLicense->ftExpireDate = lpLicense->ftExpireDate;
    lplsLicense->ucLicenseStatus = lpLicense->ucLicenseStatus;
    lplsLicense->dwQuantity = lpLicense->dwNumLicenses;

    DWORD dwPlatformId = 0;
    //In order to get the entire HWID in a TCHAR[37], the PlatformID is shrunk to 2 bytes as follows.
    dwPlatformId = HIBYTE(HIWORD(lpLicense->dwSystemBiosChkSum));
    dwPlatformId <<=8;
    dwPlatformId |= LOBYTE(LOWORD(lpLicense->dwSystemBiosChkSum));

    wsprintf(lplsLicense->szHWID,_TEXT("%04x%08x%08x%08x%08x"),
                dwPlatformId,
                lpLicense->dwVideoBiosChkSum,
                lpLicense->dwFloppyBiosChkSum,
                lpLicense->dwHardDiskSize,
                lpLicense->dwRamSize);
    lplsLicense->szHWID[GUID_MAX_SIZE-1] = '\0';
   
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\license\tlserver\server\kp.h ===
//+--------------------------------------------------------------------------
//
// Copyright (c) 1997-1999 Microsoft Corporation
//
// File:        kp.h
//
// Contents:    
//
// History:     
//
//---------------------------------------------------------------------------
#ifndef __KP_H__
#define __KP_H__
#include "server.h"

#define WHISTLER_CAL                    L"SYSTEM\\CurrentControlSet\\Services\\TermService\\Parameters\\WhistlerCAL"

#ifdef __cplusplus
extern "C" {
#endif

BOOL 
ValidLicenseKeyPackParameter(
    IN LPLSKeyPack lpKeyPack, 
    IN BOOL bAdd
);

DWORD
TLSDBLicenseKeyPackAdd( 
    IN PTLSDbWorkSpace pDbWkSpace, 
    IN LPLSKeyPack lpLsKeyPack 
);

DWORD
TLSDBLicenseKeyPackSetStatus( 
    IN PTLSDbWorkSpace pDbWkSpace, 
    IN DWORD       dwSetStatus,
    IN LPLSKeyPack  lpLsKeyPack
);

DWORD
TLSDBLicenseKeyPackUpdateLicenses( 
    PTLSDbWorkSpace pDbWkSpace, 
    BOOL bAdd, 
    IN LPLSKeyPack lpLsKeyPack 
);

LPENUMHANDLE 
TLSDBLicenseKeyPackEnumBegin(
    BOOL bMatchAll, 
    DWORD dwSearchParm, 
    LPLSKeyPack lpLsKeyPack
);

DWORD 
TLSDBLicenseKeyPackEnumNext(
    LPENUMHANDLE lpEnumHandle, 
    LPLSKeyPack lpLsKeyPack,
    BOOL bShowAll
);

DWORD 
TLSDBLicenseKeyPackEnumEnd(
    LPENUMHANDLE lpEnumHandle
);

BOOL
VerifyInternetLicensePack(
    License_KeyPack* pLicensePack
);

DWORD
TLSDBRegisterLicenseKeyPack(
    IN PTLSDbWorkSpace pDbWkSpace, 
    IN License_KeyPack* pLicenseKeyPack,
    OUT LPLSKeyPack lpInstalledKeyPack
);

DWORD
TLSDBTelephoneRegisterLicenseKeyPack(
    IN PTLSDbWorkSpace pDbWkSpace, 
    IN LPTSTR pszPID,
    IN PBYTE pbLKP,
    IN DWORD cbLKP,
    OUT LPLSKeyPack lpInstalledKeyPack
);

#ifdef __cplusplus
}
#endif


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\license\tlserver\server\mailslot.cpp ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996-1996
//
// File:        mailslot.cpp
//
// Contents:    
//
// History:     
//
// Note:        
//---------------------------------------------------------------------------
#include "pch.cpp"
#include <tchar.h>
#include <process.h>
#include "lscommon.h"
#include "debug.h"
#include "globals.h"



typedef DWORD (* LSPROTOCOLHANDLER)(DWORD cbData, PBYTE pbData);

typedef struct _ProtocolFuncMapper {
    LPTSTR szProtocol;
    LSPROTOCOLHANDLER func;
} ProtocolFuncMapper;

DWORD HandleDiscovery( DWORD cbData, PBYTE pbData );
DWORD HandleChallenge( DWORD cbData, PBYTE pbData );   

ProtocolFuncMapper pfm[] = { 
    {_TEXT(LSERVER_DISCOVERY), HandleDiscovery}, 
    {_TEXT(LSERVER_CHALLENGE), HandleChallenge}
};

DWORD dwNumProtocol=sizeof(pfm) / sizeof(pfm[0]);


//--------------------------------------------------------------------

DWORD 
HandleDiscovery( 
    DWORD cbData, 
    PBYTE pbData 
    )
/*++


++*/
{
    TCHAR szDiscMsg[MAX_MAILSLOT_MSG_SIZE+1];
    TCHAR szPipeName[MAX_MAILSLOT_MSG_SIZE+20];
    TCHAR szComputerName[MAX_COMPUTERNAME_LENGTH+2];
    DWORD cbComputerName = MAX_COMPUTERNAME_LENGTH+1;
    
    DWORD byteWritten = 0;
    LPTSTR pClientName;
    LPTSTR pMailSlot;
    LPTSTR ePtr;
    DWORD dwStatus=ERROR_SUCCESS;
    HANDLE hSlot = INVALID_HANDLE_VALUE;
    DWORD dwFileType;

    if(cbData >= sizeof(szDiscMsg)-sizeof(TCHAR))
    {
        dwStatus = ERROR_INVALID_PARAMETER;
        return dwStatus;
    }

    //
    // Prevent no NULL terminated input
    //
    memset(szDiscMsg, 0, sizeof(szDiscMsg));
    memcpy(szDiscMsg, pbData, cbData);

    GetComputerName(szComputerName, &cbComputerName);
    do {
        //
        // Extract client machine name
        //
        pClientName=_tcschr(szDiscMsg, _TEXT(LSERVER_OPEN_BLK));
        if(pClientName == NULL)
        {
            DBGPrintf(
                    DBG_INFORMATION,
                    DBG_FACILITY_RPC,
                    DBGLEVEL_FUNCTION_DETAILSIMPLE,
                    _TEXT("Can't find beginning client name\n")
                );                

            dwStatus = ERROR_INVALID_PARAMETER;
            break;
        }

        pClientName = _tcsinc(pClientName);

        ePtr=_tcschr(pClientName, _TEXT(LSERVER_CLOSE_BLK));
        if(ePtr == NULL)
        {
            DBGPrintf(
                    DBG_INFORMATION,
                    DBG_FACILITY_RPC,
                    DBGLEVEL_FUNCTION_DETAILSIMPLE,
                    _TEXT("Can't find ending client name\n")
                );                

            dwStatus = ERROR_INVALID_PARAMETER;
            break;
        }

        *ePtr = _TEXT('\0');

        //
        // Extract Mailslot name
        //
        ePtr = _tcsinc(ePtr);
        
        pMailSlot = _tcschr(ePtr, _TEXT(LSERVER_OPEN_BLK));
        if(pMailSlot == NULL)
        {
            DBGPrintf(
                    DBG_INFORMATION,
                    DBG_FACILITY_RPC,
                    DBGLEVEL_FUNCTION_DETAILSIMPLE,
                    _TEXT("Can't find beginning mailslot name\n")
                );                

            dwStatus = ERROR_INVALID_PARAMETER;
            break;
        }

        pMailSlot = _tcsinc(pMailSlot);

        ePtr=_tcschr(pMailSlot, _TEXT(LSERVER_CLOSE_BLK));
        if(ePtr == NULL)
        {

            DBGPrintf(
                    DBG_INFORMATION,
                    DBG_FACILITY_RPC,
                    DBGLEVEL_FUNCTION_DETAILSIMPLE,
                    _TEXT("Can't find ending mailslot name\n")
                );                

            dwStatus = ERROR_INVALID_PARAMETER;
            break;
        }

        *ePtr = _TEXT('\0');
        

        DBGPrintf(
                DBG_INFORMATION,
                DBG_FACILITY_RPC,
                DBGLEVEL_FUNCTION_DETAILSIMPLE,
                _TEXT("response to client %s, %s\n"),
                pClientName,
                pMailSlot
            );                

        //
        // Do not respond to "*"
        //
        if(_tcscmp(pClientName, _TEXT("*")) == 0)
        {
            dwStatus = ERROR_INVALID_PARAMETER;
            break;
        }

        if (lstrlen(pClientName) + lstrlen(pMailSlot) + 13 > sizeof(szPipeName) / sizeof(TCHAR))
        {
            dwStatus = ERROR_INVALID_PARAMETER;
            break;
        }

        //
        // SECURITY: Must make sure that what we're opening is really a
        // mailslot (no tricks with .., extra backslashes, etc.
        //
        if ((_tcsstr(pClientName,_TEXT("..")) != NULL)
            || (_tcsstr(pMailSlot,_TEXT("..")) != NULL))
        {
            dwStatus = ERROR_INVALID_PARAMETER;
            break;
        }

        if ((_tcschr(pClientName, _TEXT('\\')) != NULL)
            || (_tcschr(pMailSlot, _TEXT('\\')) != NULL))
        {
            dwStatus = ERROR_INVALID_PARAMETER;
            break;
        }

        //
        // Open client side mailslot
        //
        wsprintf(
                szPipeName, 
                _TEXT("\\\\%s\\mailslot\\%s"), 
                pClientName, 
                pMailSlot
            );

        if (0 == ImpersonateAnonymousToken(GetCurrentThread()))
        {
            dwStatus = GetLastError();
            break;
        }

        hSlot = CreateFile(
                        szPipeName,
                        GENERIC_WRITE,             // only need write
                        FILE_SHARE_WRITE,
                        NULL,
                        OPEN_EXISTING,
                        FILE_ATTRIBUTE_NORMAL,
                        NULL
                    );
        if(hSlot == INVALID_HANDLE_VALUE)
        {
            dwStatus = GetLastError();

            RevertToSelf();

            DBGPrintf(
                    DBG_INFORMATION,
                    DBG_FACILITY_RPC,
                    DBGLEVEL_FUNCTION_DETAILSIMPLE,
                    _TEXT("CreateFile %s failed with %d\n"),
                    szPipeName,
                    dwStatus
                );
            break;
        }

        dwFileType = GetFileType(hSlot);

        if ((FILE_TYPE_DISK == dwFileType)
            || (FILE_TYPE_CHAR == dwFileType)
            || (FILE_TYPE_PIPE == dwFileType))
        {
            //
            // This isn't a mailslot!
            //
            RevertToSelf();

            dwStatus = ERROR_INVALID_PARAMETER;
            break;
        }

        //
        // Write our computername to client side mailslot
        //  
        if(!WriteFile(hSlot, szComputerName, (_tcslen(szComputerName)+1)*sizeof(TCHAR), &byteWritten, NULL) || 
           byteWritten != (_tcslen(szComputerName)+1)*sizeof(TCHAR) )
        {
            dwStatus = GetLastError();

            RevertToSelf();

            DBGPrintf(
                    DBG_INFORMATION,
                    DBG_FACILITY_RPC,
                    DBGLEVEL_FUNCTION_DETAILSIMPLE,
                    _TEXT("Write to %s failed with %d\n"),
                    szPipeName,
                    dwStatus
                );

            break;
        }

        RevertToSelf();

    } while(FALSE);

    if(hSlot != INVALID_HANDLE_VALUE)
    {
        CloseHandle(hSlot);
    }

    return dwStatus;
}    
    
//--------------------------------------------------------------------            
               
DWORD 
HandleChallenge( 
    DWORD cbData, 
    PBYTE pbData 
    )    
/*++

++*/
{
    return ERROR_SUCCESS;
}

//---------------------------------------------------------------------
unsigned int WINAPI
MailSlotThread(void* ptr)
{
    HANDLE hEvent=(HANDLE) ptr;
    DWORD dwStatus=ERROR_SUCCESS;
    HANDLE hSlot=INVALID_HANDLE_VALUE;
    DWORD cbToRead;
    TCHAR szMailSlotName[MAX_PATH+1];
    TCHAR szMessage[MAX_MAILSLOT_MSG_SIZE+1];
    BOOL fResult=TRUE;

    do {
        //
        // Create the mail slot
        //
        wsprintf(
                szMailSlotName, 
                _TEXT("\\\\.\\mailslot\\%s"), 
                _TEXT(SERVERMAILSLOTNAME)
            );

        hSlot=CreateMailslot( 
                            szMailSlotName, 
                            MAX_MAILSLOT_MSG_SIZE,
                            MAILSLOT_WAIT_FOREVER,
                            NULL //&SecurityAttributes
                        );
        if(hSlot == INVALID_HANDLE_VALUE)
        {
            dwStatus=GetLastError();
            break;
        }

        //
        // Signal mail thread we are ready
        //
        SetEvent(hEvent);

        DBGPrintf(
                DBG_INFORMATION,
                DBGLEVEL_FUNCTION_DETAILSIMPLE,
                DBG_ALL_LEVEL,
                _TEXT("Mailslot : ready...\n")
            );                


        //
        // Forever loop
        //
        while(dwStatus == ERROR_SUCCESS)
        {
            memset(szMessage, 0, sizeof(szMessage));

            //
            // Wait on the Slot - TODO consider using IO completion port.
            // 
            fResult=ReadFile( 
                            hSlot, 
                            szMessage, 
                            sizeof(szMessage) - sizeof(TCHAR), 
                            &cbToRead, 
                            NULL
                        );

            if(!fResult)
            {
                DBGPrintf(
                        DBG_ERROR,
                        DBG_FACILITY_RPC,
                        DBGLEVEL_FUNCTION_ERROR,
                        _TEXT("Mailslot : read failed %d\n"),
                        GetLastError()
                    );                

                continue;
            }

            DBGPrintf(
                    DBG_INFORMATION,
                    DBG_FACILITY_RPC,
                    DBGLEVEL_FUNCTION_DETAILSIMPLE,
                    _TEXT("Mailslot : receive message %s\n"),
                    szMessage
                );                

            //
            // Process Message
            //
            for(int i=0; i < dwNumProtocol; i++)
            {
                if(!_tcsnicmp(szMessage, pfm[i].szProtocol, _tcslen(pfm[i].szProtocol)))
                {
                    (pfm[i].func)( ((DWORD)_tcslen(szMessage) - (DWORD)_tcslen(pfm[i].szProtocol))*sizeof(TCHAR), 
                                   (PBYTE)(szMessage + _tcslen(pfm[i].szProtocol)) );
                }
            }
        }
            
    } while (FALSE);
    

    if(hSlot != INVALID_HANDLE_VALUE)
        CloseHandle(hSlot);
    
    //
    // Mail thread will close the event handle
    //

    ExitThread(dwStatus);
    return dwStatus;
}


//---------------------------------------------------------------------
DWORD
InitMailSlotThread()
/*++

++*/
{
    HANDLE hThread = NULL;
    unsigned int  dwThreadId;
    HANDLE hEvent = NULL;
    DWORD dwStatus = ERROR_SUCCESS;
    HANDLE waithandles[2];


    //
    // Create a event for namedpipe thread to signal it is ready.
    //
    hEvent = CreateEvent(
                        NULL,
                        FALSE,
                        FALSE,  // non-signal
                        NULL
                    );
        
    if(hEvent == NULL)
    {
        dwStatus = GetLastError();
        goto cleanup;
    }

    hThread = (HANDLE)_beginthreadex(
                                NULL,
                                0,
                                MailSlotThread,
                                hEvent,
                                0,
                                &dwThreadId
                            );

    if(hThread == NULL)
    {
        dwStatus = GetLastError();
        goto cleanup;
    }

    waithandles[0] = hEvent;
    waithandles[1] = hThread;
    
    //
    // Wait 30 second for thread to complet initialization
    //
    dwStatus = WaitForMultipleObjects(
                                sizeof(waithandles)/sizeof(waithandles[0]), 
                                waithandles, 
                                FALSE,
                                30*1000
                            );

    if(dwStatus == WAIT_OBJECT_0)
    {    
        //
        // thread is ready
        //
        dwStatus = ERROR_SUCCESS;
    }
    else 
    {
        if(dwStatus == (WAIT_OBJECT_0 + 1))
        {
            //
            // Thread terminate abnormally
            //
            GetExitCodeThread(
                        hThread,
                        &dwStatus
                    );
        }
        else
        {
            dwStatus = TLS_E_SERVICE_STARTUP_CREATE_THREAD;
        }
    }
    

cleanup:

    if(hEvent != NULL)
    {
        CloseHandle(hEvent);
    }

    if(hThread != NULL)
    {
        CloseHandle(hThread);
    }


    return dwStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\license\tlserver\server\licreq.h ===
//+--------------------------------------------------------------------------
//
// Copyright (c) 1997-1999 Microsoft Corporation
//
// File:        licreq.h
//
// Contents:    
//
// History:     
//
//---------------------------------------------------------------------------
#ifndef __LICREQ_H__
#define __LICREQ_H__
#include "server.h"



#ifdef __cplusplus
extern "C" {
#endif

    DWORD 
    TLSDBUpgradeClientLicense(
        IN PTLSDbWorkSpace pDbWkSpace,
        IN PTLSDBLICENSEREQUEST pRequest,
        IN PTLSDBLICENSEDPRODUCT pLicensedProduct,
        IN BOOL bAcceptFewerLicenses,
        IN OUT DWORD *pdwQuantity,
        IN OUT PTLSDBLICENSEDPRODUCT pUpgradedProduct,
        IN DWORD dwSupportFlags
    );


    DWORD
    TLSNewLicenseRequest(   
        IN BOOL bForwardRequest,
        IN OUT DWORD *pdwSupportFlags,
        IN PTLSForwardNewLicenseRequest pForward,
        IN PTLSDBLICENSEREQUEST lpLsLicenseRequest,
        IN BOOL bAcceptTemporaryLicense,
        IN BOOL bRequireTemporaryLicense,
        IN BOOL bFindLostLicense,
        IN BOOL bAcceptFewerLicenses,
        IN OUT DWORD *pdwQuantity,
        OUT PDWORD pcbEncodedCert, 
        OUT PBYTE* ppbEncodedCert
    );

    DWORD
    TLSUpgradeLicenseRequest(
        IN BOOL bForwardRequest,
        IN PTLSForwardUpgradeLicenseRequest pForward,
        IN OUT DWORD *pdwSupportFlags,
        IN PTLSDBLICENSEREQUEST pRequest,
        IN PBYTE pbOldLicense,
        IN DWORD cbOldLicense,
        IN DWORD dwNumLicProduct,
        IN PLICENSEDPRODUCT pLicProduct,
        IN BOOL bRequireTemporaryLicense,
        IN OUT PDWORD pcbEncodedCert,
        OUT PBYTE* ppbEncodedCert
    );

    DWORD
    TLSReturnClientLicensedProduct(
        IN PTLSDbWorkSpace pDbWkSpace,
        IN PMHANDLE hClient,
        IN CTLSPolicy* pPolicy,
        IN PTLSLicenseToBeReturn pClientLicense
    );

    DWORD
    TLSCheckLicenseMarkRequest(
        IN BOOL bForwardRequest,
        IN PLICENSEDPRODUCT pLicProduct,
        IN DWORD cbLicense,
        IN PBYTE pLicense,
        OUT PUCHAR pucMarkFlags
    );

    DWORD
    TLSMarkLicenseRequest(
        IN BOOL bForwardRequest,
        IN UCHAR ucMarkFlags,
        IN PLICENSEDPRODUCT pLicProduct,
        IN DWORD cbLicense,
        IN PBYTE pLicense
        );

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\license\tlserver\server\license.cpp ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996-1996
//
// File:        license.c
//
// Contents:    
//          Routine related to License Table
//
// History:     12-09-98    HueiWang    Created
//
//---------------------------------------------------------------------------
#include "pch.cpp"
#include "clilic.h"
#include "globals.h"


void 
TLSDBLockLicenseTable()
{
    DBGPrintf(
            DBG_INFORMATION,
            DBG_FACILITY_LOCK,
            DBGLEVEL_FUNCTION_TRACE,
            _TEXT("Locking table LicenseTable\n")
        );

    LicensedTable::LockTable();
}

void 
TLSDBUnlockLicenseTable()
{
    DBGPrintf(
            DBG_INFORMATION,
            DBG_FACILITY_LOCK,
            DBGLEVEL_FUNCTION_TRACE,
            _TEXT("Unlocking table LicenseTable\n")
        );
            

    LicensedTable::UnlockTable();
}
    
/*************************************************************************
Function:
    LSDBLicenseEnumBegin()

Description:
    Begin a enumeration through license table based on search criterial

Arguments:
    IN CSQLStmt* - SQL handle to bind input parameter
    IN bMatchAll - TRUE if match all search criterial, FALSE otherwise.
    IN dwSearchParm - which column in License table to bind
    IN LPLSLicenseSearchParm - search value

Returns:
    ERROR_SUCCESS
    SQL error code.
*************************************************************************/
DWORD
TLSDBLicenseFind(
    IN PTLSDbWorkSpace pDbWkSpace,
    IN BOOL   bMatchAllParm,
    IN DWORD  dwSearchParm,
    IN LPLICENSEDCLIENT lpSearch,
    IN OUT LPLICENSEDCLIENT lpFound
    )
/*
*/
{
    DWORD dwStatus=ERROR_SUCCESS;

    if(pDbWkSpace == NULL)
    {
        SetLastError(dwStatus = ERROR_INVALID_PARAMETER);
        TLSASSERT(pDbWkSpace != NULL);
        return dwStatus;
    }

    LicensedTable& licenseTable = pDbWkSpace->m_LicensedTable;
    BOOL bSuccess;
    LICENSEDCLIENT found;

    bSuccess = licenseTable.FindRecord(
                        bMatchAllParm,
                        dwSearchParm,
                        *lpSearch,
                        (lpFound) ? *lpFound : found
                    );

    if(bSuccess == FALSE)
    {
        if(licenseTable.GetLastJetError() == JET_errRecordNotFound)
        {
            SetLastError(dwStatus = TLS_E_RECORD_NOTFOUND);
        }
        else
        {
            LPTSTR pString = NULL;
        
            TLSGetESEError(licenseTable.GetLastJetError(), &pString);

            TLSLogEvent(
                    EVENTLOG_ERROR_TYPE,
                    TLS_E_DBGENERAL,
                    TLS_E_JB_BASE,
                    licenseTable.GetLastJetError(),
                    (pString != NULL) ? pString : _TEXT("")
                );

            if(pString != NULL)
            {
                LocalFree(pString);
            }

            SetLastError(
                    dwStatus = (SET_JB_ERROR(licenseTable.GetLastJetError()))
                );

            TLSASSERT(FALSE);
        }
    }

    return dwStatus;
}
    

//-----------------------------------------------------------------------
DWORD
TLSDBLicenseEnumBegin( 
    IN PTLSDbWorkSpace pDbWkSpace,
    IN BOOL   bMatchAll,
    IN DWORD  dwSearchParm,
    IN LPLICENSEDCLIENT  lpSearch
    )
/*++

--*/
{
    return TLSDBLicenseEnumBeginEx(
                pDbWkSpace,
                bMatchAll,
                dwSearchParm,
                lpSearch,
                JET_bitSeekGE
                );
}

//-----------------------------------------------------------------------
DWORD
TLSDBLicenseEnumBeginEx( 
    IN PTLSDbWorkSpace pDbWkSpace,
    IN BOOL   bMatchAll,
    IN DWORD  dwSearchParm,
    IN LPLICENSEDCLIENT  lpSearch,
    IN JET_GRBIT jet_seek_grbit
    )
/*++

--*/
{
    DWORD dwStatus=ERROR_SUCCESS;
    LicensedTable& licenseTable = pDbWkSpace->m_LicensedTable;
    BOOL bSuccess;
    
    bSuccess = licenseTable.EnumerateBegin(
                            bMatchAll,
                            dwSearchParm,
                            lpSearch,
                            jet_seek_grbit
                        );

    if(bSuccess == FALSE)
    {
        LPTSTR pString = NULL;
    
        TLSGetESEError(licenseTable.GetLastJetError(), &pString);

        TLSLogEvent(
                EVENTLOG_ERROR_TYPE,
                TLS_E_DBGENERAL,
                TLS_E_JB_BASE,
                licenseTable.GetLastJetError(),
                (pString != NULL) ? pString : _TEXT("")
            );

        if(pString != NULL)
        {
            LocalFree(pString);
        }

        SetLastError(
                dwStatus = SET_JB_ERROR(licenseTable.GetLastJetError())
            );

        TLSASSERT(FALSE);
    }

    return dwStatus;
}        

/*************************************************************************
Function:
    LSDBLicenseEnumNext()

Description:
    Retrieve next record that match search criterial, must have
    call LSDBLicenseEnumBegin() to establish search criterial.

Arguments:
    IN CSQLStmt* - SQL handle to bind input parameter
    IN LPLSLicense - return record.
    IN LPLSHARDWARECHECKSUM - return hardware checksum value, see note

Returns:
    ERROR_SUCCESS
    SQL error code.
    HLS_I_NO_MORE_DATA      End of recordset.

Note:
    Hardware checksum column is consider internal and not exposed across
    RPC layer.
*************************************************************************/
DWORD
TLSDBLicenseEnumNext( 
    IN PTLSDbWorkSpace pDbWkSpace,
    IN OUT LPLICENSEDCLIENT lplsLicense
    )
/*
*/
{
    return TLSDBLicenseEnumNextEx(
                pDbWkSpace,
                FALSE,
                FALSE,
                lplsLicense
                );
}

/*************************************************************************
Function:
    LSDBLicenseEnumNext()

Description:
    Retrieve next record that match search criterial, must have
    call LSDBLicenseEnumBegin() to establish search criterial.

Arguments:
    IN pDbWkSpace - Workspace to search in
    IN bReverse - search in reverse order
    IN bAnyRecord - don't do equality comparison if true
    IN LPLSLicense - return record.

Returns:
    ERROR_SUCCESS
    SQL error code.
    HLS_I_NO_MORE_DATA      End of recordset.

Note:
    Hardware checksum column is consider internal and not exposed across
    RPC layer.
*************************************************************************/
DWORD
TLSDBLicenseEnumNextEx( 
    IN PTLSDbWorkSpace pDbWkSpace,
    IN BOOL bReverse,
    IN BOOL bAnyRecord,
    IN OUT LPLICENSEDCLIENT lplsLicense
    )
/*
*/
{
    DWORD dwStatus=ERROR_SUCCESS;
    if(pDbWkSpace == NULL || lplsLicense == NULL)
    {
        SetLastError(dwStatus = ERROR_INVALID_PARAMETER);
        TLSASSERT(FALSE);
        return dwStatus;
    }

    LicensedTable& licenseTable = pDbWkSpace->m_LicensedTable;
    BOOL bSuccess;

    switch(licenseTable.EnumerateNext(*lplsLicense,bReverse,bAnyRecord))
    {
        case RECORD_ENUM_ERROR:
            {
                LPTSTR pString = NULL;
    
                TLSGetESEError(licenseTable.GetLastJetError(), &pString);

                TLSLogEvent(
                        EVENTLOG_ERROR_TYPE,
                        TLS_E_DBGENERAL,
                        TLS_E_JB_BASE,
                        licenseTable.GetLastJetError(),
                        (pString != NULL) ? pString : _TEXT("")
                    );

                if(pString != NULL)
                {
                    LocalFree(pString);
                }
            }

            dwStatus = SET_JB_ERROR(licenseTable.GetLastJetError());

            TLSASSERT(FALSE);
            break;

        case RECORD_ENUM_MORE_DATA:
            dwStatus = ERROR_SUCCESS;
            break;

        case RECORD_ENUM_END:
            dwStatus = TLS_I_NO_MORE_DATA;
            break;
    }


    return dwStatus;
}    

/*************************************************************************
Function:
    LSDBLicenseEnumEnd()

Description:
    Terminate a license table enumeration 

Arguments:
    IN CSQLStmt* - SQL handle

Returns:
    None
*************************************************************************/
void
TLSDBLicenseEnumEnd(
    IN PTLSDbWorkSpace pDbWkSpace
    )
/*
*/
{
    DWORD dwStatus=ERROR_SUCCESS;

    if(pDbWkSpace == NULL)
    {
        SetLastError(dwStatus = ERROR_INVALID_PARAMETER);
        TLSASSERT(FALSE);
        return;
    }

    LicensedTable& licenseTable = pDbWkSpace->m_LicensedTable;
    licenseTable.EnumerateEnd();
    return;
}

//---------------------------------------------------------------------

DWORD
TLSDBLicenseAddEntry(
    IN PTLSDbWorkSpace pDbWkSpace,
    IN LPLICENSEDCLIENT pLicense
    )
/*
*/
{
    TLSASSERT(pDbWkSpace != NULL && pLicense != NULL);

    DWORD dwStatus=ERROR_SUCCESS;
    LicensedTable& licenseTable = pDbWkSpace->m_LicensedTable;
    BOOL bSuccess;
    TLSLicensedIndexMatchHwid dump(*pLicense);

    //
    // Check for duplicate entry - license ID
    //
    dwStatus = TLSDBLicenseFind(
                        pDbWkSpace,
                        TRUE,
                        LSLICENSE_SEARCH_LICENSEID,
                        pLicense,
                        NULL
                    );

    if(dwStatus == ERROR_SUCCESS)
    {
        SetLastError(dwStatus = TLS_E_DUPLICATE_RECORD);
        goto cleanup;
    }
    else if(dwStatus != TLS_E_RECORD_NOTFOUND)
    {
        goto cleanup;
    }

    dwStatus = ERROR_SUCCESS;    

    pLicense->dbLowerBound = dump.dbLowerBound;
    GetSystemTimeAsFileTime(&(pLicense->ftLastModifyTime));
    bSuccess = licenseTable.InsertRecord(*pLicense);

    if(bSuccess == FALSE)
    {
        if(licenseTable.GetLastJetError() == JET_errKeyDuplicate)
        {
            SetLastError(dwStatus=TLS_E_DUPLICATE_RECORD);
        }
        else
        {
            LPTSTR pString = NULL;
        
            TLSGetESEError(licenseTable.GetLastJetError(), &pString);

            TLSLogEvent(
                    EVENTLOG_ERROR_TYPE,
                    TLS_E_DBGENERAL,
                    TLS_E_JB_BASE,
                    licenseTable.GetLastJetError(),
                    (pString != NULL) ? pString : _TEXT("")
                );

            if(pString != NULL)
            {
                LocalFree(pString);
            }


            SetLastError(dwStatus = SET_JB_ERROR(licenseTable.GetLastJetError()));
            TLSASSERT(FALSE);
        }
    };

cleanup:
    return dwStatus;
}

//---------------------------------------------------------------

DWORD
TLSDBLicenseDeleteEntry(
    IN PTLSDbWorkSpace pDbWkSpace,
    IN LPLICENSEDCLIENT pLicense,
    IN BOOL bPointerOnRecord
    )
/*
*/
{
    TLSASSERT(pDbWkSpace != NULL && pLicense != NULL);

    DWORD dwStatus=ERROR_SUCCESS;
    LicensedTable& licenseTable = pDbWkSpace->m_LicensedTable;
    BOOL bSuccess;


    bSuccess = licenseTable.DeleteAllRecord(
                            TRUE,
                            LSLICENSE_SEARCH_LICENSEID,
                            *pLicense
                        );

    if(bSuccess == FALSE)
    {
        SetLastError(dwStatus = SET_JB_ERROR(licenseTable.GetLastJetError()));
        if(licenseTable.GetLastJetError() != JET_errRecordNotFound)
        {
            LPTSTR pString = NULL;
        
            TLSGetESEError(licenseTable.GetLastJetError(), &pString);

            TLSLogEvent(
                    EVENTLOG_ERROR_TYPE,
                    TLS_E_DBGENERAL,
                    TLS_E_JB_BASE,
                    licenseTable.GetLastJetError(),
                    (pString != NULL) ? pString : _TEXT("")
                );

            if(pString != NULL)
            {
                LocalFree(pString);
            }

            TLSASSERT(licenseTable.GetLastJetError() == JET_errRecordNotFound);
        }
    }

    return dwStatus;
}

DWORD
TLSDBDeleteEnumeratedLicense(
    IN PTLSDbWorkSpace pDbWkSpace
    )
{
    TLSASSERT(pDbWkSpace != NULL);

    DWORD dwStatus = ERROR_SUCCESS;
    LicensedTable& licenseTable = pDbWkSpace->m_LicensedTable;
    BOOL fSuccess;

    fSuccess = licenseTable.DeleteRecord();

    if (!fSuccess)
    {
        SetLastError(dwStatus = SET_JB_ERROR(licenseTable.GetLastJetError()));
        if(licenseTable.GetLastJetError() != JET_errRecordNotFound)
        {
            LPTSTR pString = NULL;

            TLSGetESEError(licenseTable.GetLastJetError(), &pString);

            TLSLogEvent(
                    EVENTLOG_ERROR_TYPE,
                    TLS_E_DBGENERAL,
                    TLS_E_JB_BASE,
                    licenseTable.GetLastJetError(),
                    (pString != NULL) ? pString : _TEXT("")
                );

            if(pString != NULL)
            {
                LocalFree(pString);
            }

            TLSASSERT(licenseTable.GetLastJetError() == JET_errRecordNotFound);
        }
    }

    return dwStatus;
}

//----------------------------------------------------------------

DWORD
TLSDBLicenseUpdateEntry(
    IN PTLSDbWorkSpace pDbWkSpace,
    IN DWORD dwUpdateParm,
    IN LPLICENSEDCLIENT pLicense,
    IN BOOL bPointerOnRecord
    )
/*
*/
{
    TLSASSERT(pDbWkSpace != NULL && pLicense != NULL);

    DWORD dwStatus=ERROR_SUCCESS;
    LicensedTable& licenseTable = pDbWkSpace->m_LicensedTable;
    BOOL bSuccess;


    if(bPointerOnRecord == FALSE)
    {
        //
        // Check for duplicate entry - license ID, position pointer
        // to record and prepare for update.
        //
        dwStatus = TLSDBLicenseFind(
                            pDbWkSpace,
                            TRUE,
                            LSLICENSE_SEARCH_LICENSEID,
                            pLicense,
                            NULL
                        );

        if(dwStatus != ERROR_SUCCESS)
        {
            TLSASSERT(dwStatus == ERROR_SUCCESS);
            goto cleanup;
        }
    }
   
    GetSystemTimeAsFileTime(&(pLicense->ftLastModifyTime));
    bSuccess = licenseTable.UpdateRecord(
                            *pLicense, 
                            (dwUpdateParm & ~LSLICENSE_SEARCH_LICENSEID) | LICENSE_PROCESS_LASTMODIFYTIME
                        );

    if(bSuccess == FALSE)
    {
        LPTSTR pString = NULL;
    
        TLSGetESEError(licenseTable.GetLastJetError(), &pString);

        TLSLogEvent(
                EVENTLOG_ERROR_TYPE,
                TLS_E_DBGENERAL,
                TLS_E_JB_BASE,
                licenseTable.GetLastJetError(),
                (pString != NULL) ? pString : _TEXT("")
            );

        if(pString != NULL)
        {
            LocalFree(pString);
        }


        SetLastError(dwStatus = SET_JB_ERROR(licenseTable.GetLastJetError()));
        TLSASSERT(FALSE);
    }

cleanup:
    
    return dwStatus;
}

//-----------------------------------------------------------------

DWORD
TLSDBLicenseSetValue( 
    IN PTLSDbWorkSpace pDbWkSpace,
    IN DWORD dwSetParm,
    IN LPLICENSEDCLIENT lpLicense,
    IN BOOL bPointerOnRecord
    )
/*
*/
{
    DWORD dwStatus=ERROR_SUCCESS;
    BOOL bSuccess;

    if(pDbWkSpace == NULL || lpLicense == NULL)
    {
        SetLastError(dwStatus = ERROR_INVALID_PARAMETER);
        TLSASSERT(FALSE);
        return dwStatus;
    }

    LicensedTable& licenseTable = pDbWkSpace->m_LicensedTable;

    TLSDBLockLicenseTable();

    if(lpLicense->ucLicenseStatus == LSLICENSESTATUS_DELETE)
    {
        dwStatus = TLSDBLicenseDeleteEntry(
                                    pDbWkSpace,
                                    lpLicense,
                                    bPointerOnRecord
                                );
    }
    else 
    {
        dwStatus = TLSDBLicenseUpdateEntry(
                                    pDbWkSpace,
                                    dwSetParm,
                                    lpLicense,
                                    bPointerOnRecord
                                );
    }

    TLSDBUnlockLicenseTable();
    return  dwStatus;                 
}

/*************************************************************************
Function:
    LSDBLicenseGetCert()

Description:
    Retrieve certificate issued to specific client

Arguments:
    IN CSQLStmt* - SQL handle
    IN dwLicenseId - License Id
    OUT cbCert - size of certificate
    OUT pbCert - certificate issued to client

Returns:
    ERROR_SUCCESS
    HLS_E_RECORD_NOTFOUND
    HLS_E_CORRUPT_DATABASE
    SQL error

Note:
    Must have valid LicenseId.
*************************************************************************/
DWORD
TLSDBLicenseGetCert( 
    IN PTLSDbWorkSpace pDbWorkSpace,
    IN DWORD dwLicenseId, 
    IN OUT PDWORD cbCert, 
    IN OUT PBYTE pbCert 
    )
/*
*/
{
    // unsupport function.
    TLSASSERT(FALSE);
    return TLS_E_INTERNAL;
}

/*************************************************************************
Function:
    LSDBLicenseAdd()

Description:
    Add an entry into license table

Arguments:
    IN CSQLStmt* - SQL handle
    IN LSLicense* - value to be inserted
    IN PHWID - hardware ID.
    IN cbLicense - size of certificate
    IN pbLicense - Pointer to certificate

Returns:
    ERROR_SUCCESS
    SQL error
*************************************************************************/
DWORD
TLSDBLicenseAdd(
    IN PTLSDbWorkSpace pDbWorkSpace,
    LPLICENSEDCLIENT pLicense, 
    DWORD cbLicense, 
    PBYTE pbLicense
    )
/*
*/
{
    if(pDbWorkSpace == NULL || pLicense == NULL)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        TLSASSERT(FALSE);
        return ERROR_INVALID_PARAMETER;
    }

    return TLSDBLicenseAddEntry(
                        pDbWorkSpace,
                        pLicense
                    );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\license\tlserver\server\lkpdesc.h ===
//+--------------------------------------------------------------------------
//
// Copyright (c) 1997-1999 Microsoft Corporation
//
// File:        lkpdesc.h
//
// Contents:    
//
// History:     
//
//---------------------------------------------------------------------------

#ifndef __LKPDESC_H__
#define __LKPDESC_H__
#include "server.h"

#ifdef __cplusplus
extern "C" {
#endif

void
TLSDBLockKeyPackDescTable();

void
TLSDBUnlockKeyPackDescTable();

DWORD 
TLSDBKeyPackDescEnumBegin(
    IN PTLSDbWorkSpace pDbWkSpace, 
    IN BOOL bMatchAll, 
    IN DWORD dwSearchParm, 
    IN PLICPACKDESC lpKeyPackDesc
);

DWORD 
TLSDBKeyPackDescEnumNext(
    IN PTLSDbWorkSpace pDbWkSpace, 
    IN OUT PLICPACKDESC lpKeyPackDesc
);

DWORD 
TLSDBKeyPackDescEnumEnd(
    IN PTLSDbWorkSpace pDbWkSpace
);

DWORD
TLSDBKeyPackDescAddEntry(
    IN PTLSDbWorkSpace pDbWkSpace,
    IN PLICPACKDESC lpKeyPackDesc
);

DWORD
TLSDBKeyPackDescDeleteEntry(
    IN PTLSDbWorkSpace pDbWkSpace,
    IN PLICPACKDESC lpKeyPackDesc
);

DWORD
TLSDBKeyPackDescUpdateEntry(
    IN PTLSDbWorkSpace pDbWkSpace,
    IN DWORD dwUpdateParm,
    IN PLICPACKDESC lpKeyPackDesc
);

DWORD
TLSDBKeyPackDescSetValue(
    PTLSDbWorkSpace pDbWkSpace, 
    DWORD dwSetParm, 
    PLICPACKDESC lpKeyPackDesc
);

DWORD
TLSDBKeyPackDescFind(
    IN PTLSDbWorkSpace pDbWkSpace, 
    IN BOOL bMatchAllParam,        
    IN DWORD dwSearchParm, 
    IN PLICPACKDESC lpKeyPackDesc,
    IN OUT PLICPACKDESC lpKeyPackDescFound
);

#ifdef __cplusplus
}
#endif


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\license\tlserver\server\licreq.cpp ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996-1998
//
// File:        licreq.cpp
//
// Contents:    
//              New license request
//
// History:     
//              09/13/98 HueiWang   Created
//---------------------------------------------------------------------------
#include "pch.cpp"
#include "licreq.h"
#include "db.h"
#include "findlost.h"
#include "permlic.h"
#include "templic.h"
#include "gencert.h"
#include "globals.h"
#include "forward.h"
#include "postjob.h"
#include "cryptkey.h"
#include "init.h"
#include "clilic.h"
#include <winsta.h>

DWORD
TLSDBIssueNewLicenseFromLocal(
    IN PTLSDbWorkSpace pDbWkSpace,
    IN PTLSDBLICENSEREQUEST pRequest,
    IN BOOL bFindLostLicense,
    IN BOOL bRequireTempLicense,
    IN BOOL bAcceptFewerLicenses,
    IN OUT DWORD *pdwQuantity,
    OUT PTLSDBLICENSEDPRODUCT pLicensedProduct,
    IN DWORD dwSupportFlags
);

//
// State of issuing function - used for counters
//

#define NONE_TRIED              0
#define PERMANENT_ISSUE_TRIED   1
#define TEMPORARY_ISSUE_TRIED   2
#define PERMANENT_REISSUE_TRIED 3

////////////////////////////////////////////////////////////////////

void
TLSLicenseTobeReturnToPMLicenseToBeReturn(
    PTLSLicenseToBeReturn pTlsLicense,
    BOOL bTempLicense,
    PPMLICENSETOBERETURN  pPmLicense
    )
/*++

--*/
{
    pPmLicense->dwQuantity = pTlsLicense->dwQuantity;
    pPmLicense->dwProductVersion = pTlsLicense->dwProductVersion;
    pPmLicense->pszOrgProductId = pTlsLicense->pszOrgProductId;
    pPmLicense->pszCompanyName = pTlsLicense->pszCompanyName;
    pPmLicense->pszProductId = pTlsLicense->pszProductId;
    pPmLicense->pszUserName = pTlsLicense->pszUserName;
    pPmLicense->pszMachineName = pTlsLicense->pszMachineName;
    pPmLicense->dwPlatformID = pTlsLicense->dwPlatformID;
    pPmLicense->bTemp = bTempLicense;

    return;
}

////////////////////////////////////////////////////////////////////

DWORD
TLSReturnClientLicensedProduct(
    IN PTLSDbWorkSpace pDbWkSpace,
    IN PMHANDLE hClient,
    IN CTLSPolicy* pPolicy,
    IN PTLSLicenseToBeReturn pClientLicense
    )
/*++

--*/
{
    DWORD dwStatus = ERROR_SUCCESS;
    DWORD dwPolicyLicenseStatus;
    ULARGE_INTEGER serialNumber;
    HWID hwid;
    LICENSEREQUEST LicensedProduct;
    Product_Info ProductInfo;
    TLSLICENSEPACK  LicensePack;
    LICENSEDCLIENT  LicenseClient;
    PMLICENSETOBERETURN pmLicToBeReturn;
    DWORD dwLicenseStatus;


    dwStatus = LicenseDecryptHwid(
                            &hwid,
                            pClientLicense->cbEncryptedHwid,
                            pClientLicense->pbEncryptedHwid,
                            g_cbSecretKey,
                            g_pbSecretKey
                        );

    if(dwStatus != ERROR_SUCCESS)
    {
        SetLastError(dwStatus = TLS_E_INVALID_LICENSE);
        goto cleanup;
    }


    LicensedProduct.pbEncryptedHwid = pClientLicense->pbEncryptedHwid;
    LicensedProduct.cbEncryptedHwid = pClientLicense->cbEncryptedHwid;
    LicensedProduct.dwLanguageID = 0;
    LicensedProduct.dwPlatformID = pClientLicense->dwPlatformID;
    LicensedProduct.pProductInfo = &ProductInfo;

    ProductInfo.cbCompanyName = (lstrlen(pClientLicense->pszCompanyName) + 1) * sizeof(TCHAR);
    ProductInfo.pbCompanyName = (PBYTE)pClientLicense->pszCompanyName;

    ProductInfo.cbProductID = (lstrlen(pClientLicense->pszProductId) + 1) * sizeof(TCHAR);
    ProductInfo.pbProductID = (PBYTE)pClientLicense->pszProductId;

    //
    // Verify with local database
    //
    dwStatus = TLSDBValidateLicense(
                                    pDbWkSpace,
                                    &hwid,
                                    &LicensedProduct,
                                    pClientLicense->dwKeyPackId,
                                    pClientLicense->dwLicenseId,
                                    &LicensePack,
                                    &LicenseClient
                                );

    if(dwStatus != ERROR_SUCCESS)
    {
        // tell caller this record is wrong.
        SetLastError(dwStatus = TLS_E_RECORD_NOTFOUND);
        goto cleanup;
    }

    if( LicenseClient.ucLicenseStatus == LSLICENSE_STATUS_UPGRADED ||
        LicenseClient.ucLicenseStatus == LSLICENSE_STATUS_REVOKE ||
        LicenseClient.ucLicenseStatus == LSLICENSE_STATUS_UNKNOWN )
    {
        // License already been return/revoke
        dwStatus = ERROR_SUCCESS;
        goto cleanup;
    }

    //
    //
    // only inform policy module if license status is 
    // active, temporary, active_pending, concurrent
    // TODO - pass all status to policy module
    //
    if( LicenseClient.ucLicenseStatus == LSLICENSE_STATUS_TEMPORARY ||
        LicenseClient.ucLicenseStatus == LSLICENSE_STATUS_ACTIVE ||
        //LicenseClient.ucLicenseStatus == LSLICENSE_STATUS_PENDING_ACTIVE ||
        LicenseClient.ucLicenseStatus == LSLICENSE_STATUS_CONCURRENT )
    {
        serialNumber.HighPart = pClientLicense->dwKeyPackId;
        serialNumber.LowPart = pClientLicense->dwLicenseId;

        TLSLicenseTobeReturnToPMLicenseToBeReturn(
                                        pClientLicense,
                                        LicenseClient.ucLicenseStatus == LSLICENSE_STATUS_TEMPORARY,
                                        &pmLicToBeReturn
                                    );

        dwStatus = pPolicy->PMReturnLicense(
                                        hClient,
                                        &serialNumber,
                                        &pmLicToBeReturn,
                                        &dwPolicyLicenseStatus
                                    );
    
        if(dwStatus != ERROR_SUCCESS)
        {
            goto cleanup;
        }

        //
        // delete license on request.
        //
        dwLicenseStatus = (dwPolicyLicenseStatus == LICENSE_RETURN_KEEP) ? 
                                    LSLICENSE_STATUS_UPGRADED : LSLICENSESTATUS_DELETE;
    }

    if (LicenseClient.dwNumLicenses == pClientLicense->dwQuantity)
    {
        // delete the whole license

        dwStatus = TLSDBReturnLicense(
                        pDbWkSpace, 
                        pClientLicense->dwKeyPackId, 
                        pClientLicense->dwLicenseId, 
                        dwLicenseStatus
                        );
    }
    else
    {
        dwStatus = TLSDBReturnLicenseToKeyPack(
                        pDbWkSpace, 
                        pClientLicense->dwKeyPackId, 
                        pClientLicense->dwQuantity
                        );

        if (dwStatus == ERROR_SUCCESS)
        {
            // Set number of CALs in license
            
            LICENSEDCLIENT license;

            license.dwLicenseId = pClientLicense->dwLicenseId;
            license.dwNumLicenses = LicenseClient.dwNumLicenses - pClientLicense->dwQuantity;
            license.ucLicenseStatus = LSLICENSE_STATUS_UPGRADED;

            dwStatus = TLSDBLicenseSetValue(pDbWkSpace,
                                            LSLICENSE_SEARCH_NUMLICENSES,
                                            &license,
                                            FALSE     // bPointerOnRecord
                                            );
        }
    }

cleanup:

    return dwStatus;
}

////////////////////////////////////////////////////////////////////
DWORD
TLSDBMarkClientLicenseUpgraded(
    IN PTLSDbWorkSpace pDbWkSpace,
    IN PTLSDBLICENSEREQUEST pRequest,
    IN PTLSDBLICENSEDPRODUCT pLicensedProduct
    )
/*++

--*/
{
    DWORD dwStatus = ERROR_SUCCESS;
    DWORD dwLicenseStatus;
    PMLICENSETOBERETURN pmLicense;


    if(pRequest == NULL || pRequest->pPolicy == NULL)
    {
        SetLastError(dwStatus = ERROR_INVALID_PARAMETER);
        return dwStatus;
    }

    pmLicense.dwQuantity = pLicensedProduct->dwQuantity;
    pmLicense.dwProductVersion = pLicensedProduct->dwProductVersion;
    pmLicense.pszOrgProductId = pLicensedProduct->szRequestProductId;
    pmLicense.pszCompanyName = pLicensedProduct->szCompanyName;
    pmLicense.pszProductId = pLicensedProduct->szLicensedProductId;
    pmLicense.pszUserName = pLicensedProduct->szUserName;
    pmLicense.pszMachineName = pLicensedProduct->szMachineName;
    pmLicense.dwPlatformID = pLicensedProduct->dwPlatformID;
    pmLicense.bTemp = pLicensedProduct->bTemp;

    //
    // Ask if we can delete the old license
    //
    dwStatus = pRequest->pPolicy->PMReturnLicense(
                                        pRequest->hClient,
                                        &pLicensedProduct->ulSerialNumber,
                                        &pmLicense, 
                                        &dwLicenseStatus
                                    );


    //
    // MarkClientLicenseUpgrade() can only be called by FindLostLicense() which will only
    // return valid licenses.
    // TODO - Check license status.
    //
    if(dwStatus == ERROR_SUCCESS)
    {
        // Temporary license - delete license and don't bother about 
        // Permenant license - keep license and DO NOT return license to keypack
        dwStatus = TLSDBReturnLicense(
                            pDbWkSpace, 
                            pLicensedProduct->dwKeyPackId, 
                            pLicensedProduct->dwLicenseId, 
                            (dwLicenseStatus == LICENSE_RETURN_KEEP) ? LSLICENSE_STATUS_UPGRADED : LSLICENSESTATUS_DELETE
                        );
    }

    return dwStatus;
}

//////////////////////////////////////////////////////////////

DWORD 
TLSDBUpgradeClientLicense(
    IN PTLSDbWorkSpace pDbWkSpace,
    IN PTLSDBLICENSEREQUEST pRequest,
    IN PTLSDBLICENSEDPRODUCT pLicensedProduct,
    IN BOOL bAcceptFewerLicenses,
    IN OUT DWORD *pdwQuantity,
    IN OUT PTLSDBLICENSEDPRODUCT pUpgradedProduct,
    IN DWORD dwSupportFlags
    )
/*

Abstract:

    Upgrade a license - issue a new license and return old license

Parameters:


Returns

*/
{
    DWORD dwStatus=ERROR_SUCCESS;

    dwStatus=TLSDBIssuePermanentLicense( 
                            pDbWkSpace,
                            pRequest,
                            TRUE,       // bLatestVersion
                            bAcceptFewerLicenses,
                            pdwQuantity,
                            pUpgradedProduct,
                            dwSupportFlags
                        );

    if (dwStatus == ERROR_SUCCESS)
    {
        //
        // Return license to keypack
        //

        dwStatus = TLSDBMarkClientLicenseUpgraded(
                                            pDbWkSpace,
                                            pRequest,
                                            pLicensedProduct
                                            );
    }

    return dwStatus;
}


//--------------------------------------------------------------------
void
LicensedProductToDbLicensedProduct(
    PLICENSEDPRODUCT pSrc,
    PTLSDBLICENSEDPRODUCT pDest
    )
/*++

++*/
{    

    pDest->dwQuantity = pSrc->dwQuantity;
    pDest->ulSerialNumber = pSrc->ulSerialNumber;
    pDest->dwKeyPackId = pSrc->ulSerialNumber.HighPart;
    pDest->dwLicenseId = pSrc->ulSerialNumber.LowPart;
    pDest->ClientHwid = pSrc->Hwid;
    pDest->NotBefore = pSrc->NotBefore;
    pDest->NotAfter = pSrc->NotAfter;
    pDest->bTemp = ((pSrc->pLicensedVersion->dwFlags & LICENSED_VERSION_TEMPORARY) != 0);
    pDest->dwProductVersion = pSrc->LicensedProduct.pProductInfo->dwVersion;

    SAFESTRCPY(
            pDest->szCompanyName, 
            (LPTSTR)(pSrc->LicensedProduct.pProductInfo->pbCompanyName)
        );

    SAFESTRCPY(
            pDest->szLicensedProductId,
            (LPTSTR)(pSrc->LicensedProduct.pProductInfo->pbProductID)
        );

    SAFESTRCPY(
            pDest->szRequestProductId,
            (LPTSTR)(pSrc->pbOrgProductID)
        );

    SAFESTRCPY(
            pDest->szUserName,
            pSrc->szLicensedUser
        );

    SAFESTRCPY(
            pDest->szMachineName,
            pSrc->szLicensedClient
        );

    pDest->dwLanguageID = pSrc->LicensedProduct.dwLanguageID;
    pDest->dwPlatformID = pSrc->LicensedProduct.dwPlatformID;
    pDest->pbPolicyData = pSrc->pbPolicyData;
    pDest->cbPolicyData = pSrc->cbPolicyData;
}

//--------------------------------------------------------------------
void
CopyDbLicensedProduct(
    PTLSDBLICENSEDPRODUCT pSrc,
    PTLSDBLICENSEDPRODUCT pDest
    )
/*++

++*/
{    

    pDest->dwQuantity = pSrc->dwQuantity;
    pDest->ulSerialNumber = pSrc->ulSerialNumber;
    pDest->dwKeyPackId = pSrc->dwKeyPackId;
    pDest->dwLicenseId = pSrc->dwLicenseId;
    pDest->ClientHwid = pSrc->ClientHwid;
    pDest->NotBefore = pSrc->NotBefore;
    pDest->NotAfter = pSrc->NotAfter;
    pDest->bTemp = pSrc->bTemp;
    pDest->dwProductVersion = pSrc->dwProductVersion;

    SAFESTRCPY(
            pDest->szCompanyName, 
            pSrc->szCompanyName
        );

    SAFESTRCPY(
            pDest->szLicensedProductId,
            pSrc->szLicensedProductId
        );

    SAFESTRCPY(
            pDest->szRequestProductId,
            pSrc->szRequestProductId
        );

    SAFESTRCPY(
            pDest->szUserName,
            pSrc->szUserName
        );

    SAFESTRCPY(
            pDest->szMachineName,
            pSrc->szMachineName
        );

    pDest->dwLanguageID = pSrc->dwLanguageID;
    pDest->dwPlatformID = pSrc->dwPlatformID;
    pDest->pbPolicyData = pSrc->pbPolicyData;
    pDest->cbPolicyData = pSrc->cbPolicyData;
}


//------------------------------------------------------------------
DWORD
TLSDBIssueNewLicenseFromLocal(
    IN PTLSDbWorkSpace pDbWkSpace,
    IN PTLSDBLICENSEREQUEST pRequest,
    IN BOOL bFindLostLicense,
    IN BOOL bRequireTempLicense,
    IN BOOL bAcceptFewerLicenses,
    IN OUT DWORD *pdwQuantity,
    IN OUT PTLSDBLICENSEDPRODUCT pLicensedProduct,
    IN DWORD dwSupportFlags
    )
/*++

Abstract:

    Allocate a license from locally installed license pack.

Parameters:

    pDbWkSpace - workspace handle
    lpLsLicenseRequest - license request
    bAcceptTemporaryLicense - accept temporary license
    bFindLostLicense - TRUE if find lost license before issuing a new one
    bRequireTempLicense -TRUE if permanent license can't be issued (DoS fix)
    bAcceptFewerLicenses - TRUE if succeeding with fewer licenses than
                           requested is acceptable
    pdwQuantity - on input, number of licenses requested
                  on output, number of licenses actually allocated
    pLicensedProduct - return licensed product

Returns:


++*/
{
    DWORD status=TLS_E_RECORD_NOTFOUND;
    UCHAR ucMarked;

    if(bFindLostLicense == TRUE)
    {       
        //
        // Try to find the lost license
        //
        status=TLSDBFindLostLicense( 
                        pDbWkSpace,
                        pRequest,
                        &pRequest->hWid,
                        pLicensedProduct,
                        &ucMarked
                    );

        if( status != TLS_E_RECORD_NOTFOUND && 
            status != TLS_E_LICENSE_EXPIRED && 
            status != TLS_I_FOUND_TEMPORARY_LICENSE &&
            status != ERROR_SUCCESS)
        {
            goto cleanup;
        }

        //
        // If license has been expired or it is a temporary license, 
        // try to allocate a new permanent one.
        //

        DWORD tExpireDate;
        BOOL fSoftExpired;

        FileTimeToLicenseDate(&(pLicensedProduct->NotAfter),
                              &tExpireDate);

        fSoftExpired = (tExpireDate-g_dwReissueLeaseLeeway < ((DWORD)time(NULL)));

        if ( (status == TLS_E_LICENSE_EXPIRED)
             || (status == TLS_I_FOUND_TEMPORARY_LICENSE)
             || ((status == ERROR_SUCCESS)
                 && (fSoftExpired)) )
        {
            if ((!pLicensedProduct->bTemp) && CanIssuePermLicense())
            {
                TLSDBLICENSEDPRODUCT upgradeProduct;

                //
                // expired permanent
                //

                status = TLSDBReissueFoundPermanentLicense(
                                              USEHANDLE(pDbWkSpace),
                                              pLicensedProduct,
                                              &upgradeProduct
                                              );

                if (ERROR_SUCCESS == status)
                {
                    *pLicensedProduct = upgradeProduct;
                    status = TLS_I_LICENSE_UPGRADED;
                }
                else
                {
                    //
                    // reissuance failed, try to issue a new permanent
                    //
                    status = TLS_E_RECORD_NOTFOUND;
                }
            }

            //
            // no upgrade if license server hasn't been registered
            // or if DoS fix required and license isn't marked
            //

            else if (((!bRequireTempLicense)
                      || (ucMarked & MARK_FLAG_USER_AUTHENTICATED))
                     && CanIssuePermLicense())
                
            {
                DWORD upgrade_status;
                TLSDBLICENSEDPRODUCT upgradeProduct;

                upgrade_status = TLSDBUpgradeClientLicense(
                                        pDbWkSpace,
                                        pRequest,
                                        pLicensedProduct,
                                        bAcceptFewerLicenses,
                                        pdwQuantity,
                                        &upgradeProduct,
                                        dwSupportFlags
                                    );

                if(upgrade_status == ERROR_SUCCESS)
                {
                    *pLicensedProduct = upgradeProduct;
                    status = TLS_I_LICENSE_UPGRADED;
                } 
                else if(upgrade_status != TLS_E_NO_LICENSE && 
                        upgrade_status != TLS_E_PRODUCT_NOTINSTALL)
                {
                    //
                    // Error in upgrade license.
                    //
                    status = upgrade_status;
                }    

                goto cleanup;
            }

            //
            // Temporary license has expired and can't allocate permanent 
            // license, refuse connection
            //

            if( status == TLS_E_LICENSE_EXPIRED )
            {
                goto cleanup;
            }
        }
        else if ((status == ERROR_SUCCESS)
                 && (pLicensedProduct->dwQuantity != *pdwQuantity))
        {
            // user has wrong number of licenses

            if (*pdwQuantity > pLicensedProduct->dwQuantity)
            {

                if (bRequireTempLicense || !CanIssuePermLicense())
                {
                    goto try_next;
                }

#define NUM_KEYPACKS 5

                DWORD                       upgrade_status;
                TLSDBLicenseAllocation      allocation;
                DWORD                       dwAllocation[NUM_KEYPACKS];
                TLSLICENSEPACK              keypack[NUM_KEYPACKS];
                TLSDBAllocateRequest        AllocateRequest;

                for (int i=0; i < NUM_KEYPACKS; i++)
                {
                    keypack[i].pbDomainSid = NULL;
                }

                memset(&allocation,0,sizeof(allocation));
                    
                allocation.dwBufSize = NUM_KEYPACKS;
                allocation.pdwAllocationVector = dwAllocation;
                allocation.lpAllocateKeyPack = keypack;


                AllocateRequest.szCompanyName
                    = (LPTSTR)pRequest->pszCompanyName;
                AllocateRequest.szProductId
                    = (LPTSTR)pRequest->pszProductId;
                AllocateRequest.dwVersion
                    = pRequest->dwProductVersion;
                AllocateRequest.dwPlatformId
                    = pRequest->dwPlatformID;
                AllocateRequest.dwLangId
                    = pRequest->dwLanguageID;
                AllocateRequest.dwNumLicenses
                    = *pdwQuantity - pLicensedProduct->dwQuantity;
                AllocateRequest.dwScheme
                    = ALLOCATE_ANY_GREATER_VERSION;
                AllocateRequest.ucAgreementType
                    = LSKEYPACKTYPE_UNKNOWN;
                    
                upgrade_status = AllocateLicensesFromDB(
                                          pDbWkSpace,
                                          &AllocateRequest,
                                          FALSE,        // fCheckAgreementType
                                          &allocation
                                          );

                if ((upgrade_status == ERROR_SUCCESS)
                    && ((allocation.dwTotalAllocated == 0)
                        || (!bAcceptFewerLicenses
                            && (allocation.dwTotalAllocated != *pdwQuantity-pLicensedProduct->dwQuantity))))
                    
                {
                    status = TLS_E_NO_LICENSE;
                    goto cleanup;
                }
                else
                {
                    *pdwQuantity = pLicensedProduct->dwQuantity + allocation.dwTotalAllocated;
                }

                if (TLS_I_NO_MORE_DATA == upgrade_status)
                {
                    status = TLS_E_NO_LICENSE;
                    goto cleanup;
                }
                
                if(upgrade_status == ERROR_SUCCESS)
                {
                    status = TLS_I_LICENSE_UPGRADED;
                } 
                else
                {
                    //
                    // Error in upgrade license.
                    //
                    status = upgrade_status;
                    goto cleanup;
                }
            }
            else
            {
                // return unwanted licenses to keypack

                status = TLSDBReturnLicenseToKeyPack(
                                        pDbWkSpace, 
                                        pLicensedProduct->dwKeyPackId, 
                                        pLicensedProduct->dwQuantity - *pdwQuantity
                                        );

                if (status != ERROR_SUCCESS)
                {
                    goto cleanup;
                }
            }

            {
                // Set number of CALs in license
                
                LICENSEDCLIENT license;

                license.dwLicenseId = pLicensedProduct->dwLicenseId;
                license.dwNumLicenses = *pdwQuantity;
                license.ucLicenseStatus = LSLICENSE_STATUS_UPGRADED;

                status = TLSDBLicenseSetValue(pDbWkSpace,
                                              LSLICENSE_SEARCH_NUMLICENSES,
                                              &license,
                                              FALSE     // bPointerOnRecord
                                              );
            }

            goto cleanup;
        }
    }

try_next:
    //
    // Issue permanent license only if license server has been registered
    // and user is allowed to have one
    //
    if((status == TLS_E_RECORD_NOTFOUND) && (!bRequireTempLicense))
    {
		if(CanIssuePermLicense() == FALSE)
        {
            SetLastError(status = TLS_E_NO_CERTIFICATE);
        }
        else
        {
            status=TLSDBIssuePermanentLicense( 
                                pDbWkSpace,
                                pRequest,
                                FALSE,
                                bAcceptFewerLicenses,
                                pdwQuantity,
                                pLicensedProduct,
                                dwSupportFlags
                            );
        }
    }

cleanup:

    return status;
}


//////////////////////////////////////////////////////////////////////

DWORD
TLSUpgradeLicenseRequest(
    IN BOOL bForwardRequest,
    IN PTLSForwardUpgradeLicenseRequest pForward,        
    IN OUT DWORD *pdwSupportFlags,
    IN PTLSDBLICENSEREQUEST pRequest,
    IN PBYTE pbOldLicense,
    IN DWORD cbOldLicense,
    IN DWORD dwNumLicProduct,
    IN PLICENSEDPRODUCT pLicProduct,
    IN BOOL bRequireTempLicense,
    IN OUT PDWORD pcbEncodedCert,
    OUT PBYTE* ppbEncodedCert
    )
/*++



++*/
{
    DWORD dwStatus = TLS_E_NO_LICENSE;
    BOOL bAcceptTempLicense = FALSE;
    DWORD index;
    DWORD dwNumNewLicProduct;
    TLSDBLICENSEDPRODUCT NewLicProduct;
    PTLSDbWorkSpace pDbWkSpace=NULL;

    PTLSDBLICENSEDPRODUCT pGenCertProduct=NULL;
    FILETIME* pNotBefore=NULL;
    FILETIME* pNotAfter=NULL;
    DWORD dwNumChars;
    DWORD dwLicGenStatus;
    BOOL bDbHandleAcquired = FALSE;
    BOOL fReissue = FALSE;
    DWORD dwTried = NONE_TRIED;
    BOOL bVerifyNumLicenses = TRUE;

    POLICY_TS_MACHINE groupPolicy;
    RegGetMachinePolicy(&groupPolicy);
    BOOL bPreventLicenseUpgrade = FALSE;
    BOOL bDeleteExpired = FALSE;

    if( groupPolicy.fPolicyPreventLicenseUpgrade == 1 && groupPolicy.fPreventLicenseUpgrade == 1)
    {
        bPreventLicenseUpgrade = TRUE;
    }

    // If the client has 2 or more licenses and has an expired permanent license same as the requested version
    // the requested version is reissued.
    

    for(index=0; index < dwNumLicProduct; index++)
    {

        if( (((pLicProduct+index)->pLicensedVersion->dwFlags & LICENSED_VERSION_TEMPORARY) == 1)
            && (CompareTLSVersions((pLicProduct+index)->LicensedProduct.pProductInfo->dwVersion, pRequest->dwProductVersion) > 0) 
            && dwNumLicProduct-index > 1)
        { 
            if(bPreventLicenseUpgrade == FALSE)
            {
                bDeleteExpired = TRUE;
            }

            if((((pLicProduct+index+1)->pLicensedVersion->dwFlags & LICENSED_VERSION_TEMPORARY) == 0) &&
                (CompareTLSVersions((pLicProduct+index+1)->LicensedProduct.pProductInfo->dwVersion, pRequest->dwProductVersion) == 0) )
            {
                ++index;                    
                bRequireTempLicense = FALSE;
                bAcceptTempLicense = FALSE;
                goto MixedLicense;
            }
            else
                continue;                    
        }                
    }

    index = 0;

    // If the client has an expired permanent license greater than the requested version the expired license
    // is reissued. If reissuance fails, a permanent license same as the requested version is issued. 

    if(CompareTLSVersions(pRequest->dwProductVersion, pLicProduct->LicensedProduct.pProductInfo->dwVersion) < 0)
    {
        if ((pLicProduct->pLicensedVersion->dwFlags & LICENSED_VERSION_TEMPORARY) == 0)
        {
            DWORD t;

            FileTimeToLicenseDate(&(pLicProduct->NotAfter), &t);
            
            if (t-g_dwReissueLeaseLeeway < time(NULL))
            {
                // perm license has expired and is version greater than the request. Hence re-issue permanent requested license.
                                
                bDeleteExpired = TRUE;                
                bRequireTempLicense = FALSE;
                bAcceptTempLicense = FALSE;
            }
        }  

        // If the client License is temporary unmarked and expired then reissue for another 90 days.
        else if (((pLicProduct->pLicensedVersion->dwFlags & LICENSED_VERSION_TEMPORARY) == 1) && !(bRequireTempLicense))
        {
            DWORD t;
            
            FileTimeToLicenseDate(&(pLicProduct->NotAfter), &t);
            
            if (t < time(NULL))
            {
                 // let them have another 90 days of unmarked licenses
                bAcceptTempLicense = TRUE;
            }
        }
        
    }
    //
    // check to see if we can take temp. license
    //
    // The only case that we need to set temp. license's expiration date is
    // latest licensed product is temporary and client is requesting a version
    // greater than latest license.
    // 
    else if(CompareTLSVersions(pRequest->dwProductVersion, pLicProduct->LicensedProduct.pProductInfo->dwVersion) > 0)
    {
        bAcceptTempLicense = TRUE;

        if(pLicProduct->pLicensedVersion->dwFlags & LICENSED_VERSION_TEMPORARY)
        {        
            DWORD t;
            
            FileTimeToLicenseDate(&(pLicProduct->NotAfter), &t);
            
            if (t > time(NULL))
            {
                //
                // client holding 5.0 temp. and request 6.0 licenses.
                // we need to issue 6.0 license but the license expiration 
                // date stay the same.
                //
                pNotBefore = &(pLicProduct->NotBefore);
                pNotAfter = &(pLicProduct->NotAfter);
            }
            else
            {
                // temp license has expired
                if (!bRequireTempLicense)
                {
                    // Temp license is marked
                    bAcceptTempLicense = FALSE;
                }
            }
        }        
    }
    else if(CompareTLSVersions(pRequest->dwProductVersion, pLicProduct->LicensedProduct.pProductInfo->dwVersion) == 0)
    {
        if( IS_LICENSE_ISSUER_RTM(pLicProduct->pLicensedVersion->dwFlags) == FALSE && 
            TLSIsBetaNTServer() == FALSE )
        {
            // issuer is beta/eval, we are a RTM, accept temp. license
            bAcceptTempLicense = TRUE;
            bRequireTempLicense = TRUE;
        }
        else if ((pLicProduct->pLicensedVersion->dwFlags & LICENSED_VERSION_TEMPORARY)
                 && (bRequireTempLicense))
        {
            DWORD t;

            // they already had a temporary license that expired and the temporary license
            // isn't marked (or we couldn't contact the LS that issued it)

            // therefore issue a new temp license for another 90 days with us as the issuer.

            FileTimeToLicenseDate(&(pLicProduct->NotAfter), &t);           
            if (t <= time(NULL))
            {                
                bAcceptTempLicense = TRUE;
            }
        }        
    }
    

MixedLicense:

    if(ALLOCATEDBHANDLE(pDbWorkSpace, g_EnumDbTimeout) == FALSE)
    {
        dwStatus = TLS_E_ALLOCATE_HANDLE;
        goto cleanup;
    }

    CLEANUPSTMT;
    BEGIN_TRANSACTION(pDbWorkSpace);
    bDbHandleAcquired = TRUE;

    if (!bRequireTempLicense)
    {

        //
        // Check for reissuance first, if a) reissuance is supported, b)
        // the license is permanent, c) the license is expired.
        // Note: the license could be older (if preventupgrade is disabled), same or newer version.
        //

        if ((*pdwSupportFlags & SUPPORT_PER_SEAT_REISSUANCE) &&
            ((_tcsnicmp((TCHAR *)(pLicProduct+index)->LicensedProduct.pProductInfo->pbProductID,
                        TERMSERV_PRODUCTID_SKU,
                        _tcslen(TERMSERV_PRODUCTID_SKU)) == 0) ||
             (_tcsnicmp((TCHAR *)(pLicProduct+index)->LicensedProduct.pProductInfo->pbProductID,
                        TERMSERV_PRODUCTID_CONCURRENT_SKU,
                        _tcslen(TERMSERV_PRODUCTID_CONCURRENT_SKU)) == 0)) &&
            (!((pLicProduct+index)->pLicensedVersion->dwFlags & LICENSED_VERSION_TEMPORARY)))
        {            

            DWORD t;

            //
            // Checking expiration with filetimes is a pain; convert.
            //

            FileTimeToLicenseDate(&((pLicProduct+index)->NotAfter), &t);

            if (t-g_dwReissueLeaseLeeway < time(NULL))
            {
                // do reissue

                fReissue = TRUE;

                if (CanIssuePermLicense())
                {
                    dwStatus = TLSDBReissuePermanentLicense(
                                 USEHANDLE(pDbWkSpace),
                                 (pLicProduct+index),
                                 &NewLicProduct
                                 );

                    if (dwStatus == ERROR_SUCCESS)
                    {
                        dwTried = PERMANENT_REISSUE_TRIED;

                        // skip past the next stuff if all goes well
                        goto licenseReissued;
                    }
                    else
                    {                        
                        bVerifyNumLicenses = FALSE;
                    }
                }
                else
                {                    
                    dwStatus = TLS_E_RECORD_NOTFOUND;
                }

                if ((dwStatus == TLS_E_RECORD_NOTFOUND)
                    && bForwardRequest
                    && (_tcsicmp((pLicProduct+index)->szIssuerId,
                                 (LPTSTR)g_pszServerPid) != 0))
                {
                    // couldn't find the license, forward the request to issuer
                    DWORD dwSupportFlagsTemp = *pdwSupportFlags;
                    DWORD dwErrCode;

                    dwStatus = ForwardUpgradeLicenseRequest(
                                       (pLicProduct+index)->szIssuerId,
                                       &dwSupportFlagsTemp,
                                       pForward->m_pRequest,
                                       pForward->m_ChallengeContext,
                                       pForward->m_cbChallengeResponse,
                                       pForward->m_pbChallengeResponse,
                                       pForward->m_cbOldLicense,
                                       pForward->m_pbOldLicense,
                                       pcbEncodedCert,
                                       ppbEncodedCert,
                                       &dwErrCode
                                       );

                    if (ERROR_SUCCESS == dwStatus
                        && LSERVER_S_SUCCESS == dwErrCode)
                    {
                        *pdwSupportFlags = dwSupportFlagsTemp;
                        goto cleanup;
                    }
                }

                // other failure cases just follow the existing codepath
                dwStatus = ERROR_SUCCESS;
            }
        }
        if(CanIssuePermLicense())
        {
            DWORD dwQuantity = 1;

            //
            // Try to issue a new license from local 
            // if this server is registered
            //
            dwStatus = TLSDBIssueNewLicenseFromLocal( 
                                 USEHANDLE(pDbWkSpace),
                                 pRequest,
                                 TRUE,  // bFindLostLicense
                                 FALSE, // bRequireTempLicense
                                 FALSE, // bAcceptFewerLicenses
                                 &dwQuantity,
                                 &NewLicProduct,
                                 *pdwSupportFlags
                                 );

            if (TLS_I_FOUND_TEMPORARY_LICENSE == dwStatus)
            {
                // Found a temporary license; not what we want

                dwStatus = TLS_E_RECORD_NOTFOUND;
            }
            else
            {
                dwTried = PERMANENT_ISSUE_TRIED;
            }
        }
        else
        {
            dwStatus = TLS_E_NO_CERTIFICATE;
        }        

        if(dwStatus != ERROR_SUCCESS && bForwardRequest == FALSE)
        {
            //
            // If remote server can't handle upgrade, we don't do anything but 
            // return the license back to client, don't try to issue a temp.
            // license for this client if we are not the original contact
            // of client
            //            

            goto cleanup;
        }  

        if((dwStatus == TLS_E_PRODUCT_NOTINSTALL ||
            dwStatus == TLS_E_NO_CERTIFICATE ||
            dwStatus == TLS_E_NO_LICENSE || 
            dwStatus == TLS_E_RECORD_NOTFOUND) && bForwardRequest)
        {
            //
            // release our DB handle and forward request to other server
            //
            ROLLBACK_TRANSACTION(pDbWorkSpace);
            FREEDBHANDLE(pDbWorkSpace);
            bDbHandleAcquired = FALSE;
            DWORD dwForwardStatus;
            DWORD dwSupportFlagsTemp = *pdwSupportFlags;
            
            dwForwardStatus = TLSForwardUpgradeRequest(
                                        pForward,
                                        &dwSupportFlagsTemp,
                                        pRequest,
                                        pcbEncodedCert,
                                        ppbEncodedCert,
                                        bVerifyNumLicenses
                                        );

            if(dwForwardStatus == TLS_I_SERVICE_STOP || dwForwardStatus == ERROR_SUCCESS)
            {
                if (dwForwardStatus == ERROR_SUCCESS)
                {
                    *pdwSupportFlags = dwSupportFlagsTemp;
                }

                dwStatus = dwForwardStatus;

                goto cleanup;
            }                           
        }        

        if(bDbHandleAcquired == FALSE)
        {
            if(ALLOCATEDBHANDLE(pDbWorkSpace, g_GeneralDbTimeout) == FALSE)
            {
                dwStatus = TLS_E_ALLOCATE_HANDLE;
                goto cleanup;
            }
            
            CLEANUPSTMT;
            BEGIN_TRANSACTION(pDbWorkSpace);
            bDbHandleAcquired = TRUE;
        }
    }
   
    //
    // if can't get license from remote, try temporary
    //
    if((dwStatus == TLS_E_PRODUCT_NOTINSTALL ||
        dwStatus == TLS_E_NO_CERTIFICATE ||
        dwStatus == TLS_E_NO_LICENSE || 
        dwStatus == TLS_E_RECORD_NOTFOUND) && bAcceptTempLicense)
    {
        // Issue a temporary license if can't allocate a permenent license
        if( TLSDBIssueTemporaryLicense( 
                                       USEHANDLE(pDbWkSpace),
                                       pRequest,
                                       pNotBefore,
                                       pNotAfter,
                                       &NewLicProduct
                                       ) == ERROR_SUCCESS )
        {
            dwStatus = TLS_W_TEMPORARY_LICENSE_ISSUED;
            
            dwTried = TEMPORARY_ISSUE_TRIED;
        }
    }

    //
    // If we can find a server to upgrade or we can't issue temp
    // license, get out.
    //
    if(TLS_ERROR(dwStatus) == TRUE)
    {
        goto cleanup;
    }

licenseReissued:

    //
    // Determine which licensed product should be in the license blob
    //
    pGenCertProduct = (PTLSDBLICENSEDPRODUCT)AllocateMemory(
                                            sizeof(TLSDBLICENSEDPRODUCT)*(dwNumLicProduct+1)
                                        );
    if(pGenCertProduct == NULL)
    {
        dwStatus = TLS_E_ALLOCATE_MEMORY;
        goto cleanup;
    }

    dwNumNewLicProduct = 0;

    //
    // Copy all licensed product with version greater than requested 
    //
    for( index = 0;  
        index < dwNumLicProduct && !bDeleteExpired && CompareTLSVersions((pLicProduct+index)->LicensedProduct.pProductInfo->dwVersion, NewLicProduct.dwProductVersion) > 0;
        index++, dwNumNewLicProduct++)
    {
        LicensedProductToDbLicensedProduct( pLicProduct+index, pGenCertProduct+dwNumNewLicProduct );
    }

    //
    // Append new license
    //
    *(pGenCertProduct+index) = NewLicProduct;
    dwNumNewLicProduct++;

    //
    // Append licensed product older than request
    //
    for(;index < dwNumLicProduct;index++)
    {
        BOOL bTemp;
        BOOL bDifferentProduct;
        BOOL bDifferentVersion = (CompareTLSVersions(NewLicProduct.dwProductVersion, (pLicProduct+index)->LicensedProduct.pProductInfo->dwVersion) != 0); 
        BOOL bNotNewerVersion = (CompareTLSVersions(NewLicProduct.dwProductVersion, (pLicProduct+index)->LicensedProduct.pProductInfo->dwVersion) <= 0);

        bTemp = (((pLicProduct+index)->pLicensedVersion->dwFlags & LICENSED_VERSION_TEMPORARY) != 0);

        // if we are running on RTM server, treat license issued from beta server as temporary license
        if(bTemp == FALSE && TLSIsBetaNTServer() == FALSE)
        {
            bTemp = (IS_LICENSE_ISSUER_RTM((pLicProduct+index)->pLicensedVersion->dwFlags) == FALSE);
        }

        bDifferentProduct = (_tcscmp(NewLicProduct.szLicensedProductId, (LPTSTR)(pLicProduct+index)->LicensedProduct.pProductInfo->pbProductID) != 0);
        if (bNotNewerVersion && !bDifferentProduct && !(bTemp || fReissue))
        {
            //
            // we can't issue same version for the same product unless the old
            // one was a temp or it is being re-issued
            //
            SetLastError(dwStatus = TLS_E_INTERNAL);
            goto cleanup;
        }

        if(NewLicProduct.bTemp == FALSE || bTemp == TRUE)
        {
            if( IS_LICENSE_ISSUER_RTM((pLicProduct+index)->pLicensedVersion->dwFlags) == FALSE && 
                TLSIsBetaNTServer() == FALSE )
            {
                // we wipe out beta database so ignore return.
                continue;
            }

            // check for older permanent cals and delete since multiple permanent cals are not allowed
            if(NewLicProduct.bTemp == FALSE && bTemp == FALSE && bDifferentVersion && !bDifferentProduct)
            {
                continue;
            }

            if(_tcsicmp(pLicProduct->szIssuerId, (LPTSTR)g_pszServerPid) == 0)  
            {
                //
                // Convert LicensedProduct to TLSLicenseToBeReturn
                // TODO - have its own version.
                //
                TLSLicenseToBeReturn tobeReturn;

                tobeReturn.dwQuantity = (pLicProduct+index)->dwQuantity;
                tobeReturn.dwKeyPackId = (pLicProduct+index)->ulSerialNumber.HighPart;
                tobeReturn.dwLicenseId = (pLicProduct+index)->ulSerialNumber.LowPart;
                tobeReturn.dwPlatformID = (pLicProduct+index)->LicensedProduct.dwPlatformID;
                tobeReturn.cbEncryptedHwid = (pLicProduct+index)->LicensedProduct.cbEncryptedHwid;
                tobeReturn.pbEncryptedHwid = (pLicProduct+index)->LicensedProduct.pbEncryptedHwid;
                tobeReturn.dwProductVersion = MAKELONG(
                                            (pLicProduct+index)->pLicensedVersion->wMinorVersion,
                                            (pLicProduct+index)->pLicensedVersion->wMajorVersion
                                        );

                tobeReturn.pszOrgProductId = (LPTSTR)(pLicProduct+index)->pbOrgProductID;
                tobeReturn.pszCompanyName = (LPTSTR) (pLicProduct+index)->LicensedProduct.pProductInfo->pbCompanyName;
                tobeReturn.pszProductId = (LPTSTR) (pLicProduct+index)->LicensedProduct.pProductInfo->pbProductID;
                tobeReturn.pszUserName = (LPTSTR) (pLicProduct+index)->szLicensedUser;
                tobeReturn.pszMachineName = (pLicProduct+index)->szLicensedClient;

                dwStatus = TLSReturnClientLicensedProduct(
                                                USEHANDLE(pDbWkSpace),
                                                pRequest->hClient,
                                                pRequest->pPolicy,
                                                &tobeReturn
                                            );

            }    

            // Removed attempt to return license to remote server because it was logging events and flooding the LS database
            //
            // Ignore can't find the record in database
            //
            dwStatus = ERROR_SUCCESS;
        }
        else 
        {
            LicensedProductToDbLicensedProduct( pLicProduct + index, pGenCertProduct + dwNumNewLicProduct);
            dwNumNewLicProduct++;
        }
    }

    dwLicGenStatus = TLSGenerateClientCertificate(
                                    g_hCryptProv,
                                    dwNumNewLicProduct,
                                    pGenCertProduct,
                                    pRequest->wLicenseDetail,
                                    ppbEncodedCert,
                                    pcbEncodedCert
                                );
    if(dwLicGenStatus != ERROR_SUCCESS)
    {
        dwStatus = dwLicGenStatus;
    }

cleanup:


    if(bDbHandleAcquired == TRUE)
    {
        if(TLS_ERROR(dwStatus))
        {
            ROLLBACK_TRANSACTION(pDbWorkSpace);
        }
        else
        {
            COMMIT_TRANSACTION(pDbWorkSpace);

            switch (dwTried)
            {

            case PERMANENT_ISSUE_TRIED:
                InterlockedIncrement(&g_lPermanentLicensesIssued);
                break;

            case TEMPORARY_ISSUE_TRIED:
                InterlockedIncrement(&g_lTemporaryLicensesIssued);
                break;

            case PERMANENT_REISSUE_TRIED:
                InterlockedIncrement(&g_lPermanentLicensesReissued);
                break;
            }
        }

        FREEDBHANDLE(pDbWorkSpace);
    }

    if(TLS_ERROR(dwStatus) == FALSE)
    {
        if(NewLicProduct.dwNumLicenseLeft == 0 && NewLicProduct.bTemp == FALSE)
        {
            // ignore error if we can't get it out to
            // other server
            TLSAnnounceLKPToAllRemoteServer(NewLicProduct.dwKeyPackId, 0);
        }
    }

    FreeMemory(pGenCertProduct);
    return dwStatus;
}

//----------------------------------------------------------
DWORD
TLSNewLicenseRequest(
    IN BOOL bForwardRequest,
    IN OUT DWORD *pdwSupportFlags,
    IN PTLSForwardNewLicenseRequest pForward,
    IN PTLSDBLICENSEREQUEST pRequest,
    IN BOOL bAcceptTempLicense,
    IN BOOL bRequireTempLicense,
    IN BOOL bFindLostLicense,
    IN BOOL bAcceptFewerLicenses,
    IN OUT DWORD *pdwQuantity,
    OUT PDWORD pcbEncodedCert,
    OUT PBYTE* ppbEncodedCert
    )
/*++

Abstract:

Parameter:

Returns:


++*/
{
    DWORD dwStatus = TLS_E_NO_LICENSE;
    TLSDBLICENSEDPRODUCT LicensedProduct;
    PTLSDbWorkSpace pDbWorkSpace=NULL;
    BOOL bDbHandleAcquired = FALSE;
    DWORD dwSupportFlagsTemp = *pdwSupportFlags;
    DWORD dwTried = NONE_TRIED;

    if(ALLOCATEDBHANDLE(pDbWorkSpace, g_GeneralDbTimeout) == FALSE)
    {
        dwStatus = TLS_E_ALLOCATE_HANDLE;
        goto cleanup;
    }

    CLEANUPSTMT;
    BEGIN_TRANSACTION(pDbWorkSpace);
    bDbHandleAcquired = TRUE;

    dwStatus = TLSDBIssueNewLicenseFromLocal(
                         USEHANDLE(pDbWorkSpace),
                         pRequest,
                         bFindLostLicense,
                         bRequireTempLicense,
                         bAcceptFewerLicenses,
                         pdwQuantity,
                         &LicensedProduct,
                         *pdwSupportFlags
                         );

    dwTried = PERMANENT_ISSUE_TRIED;

    if (!bRequireTempLicense)
    {
        if( (dwStatus == TLS_E_PRODUCT_NOTINSTALL || dwStatus == TLS_I_FOUND_TEMPORARY_LICENSE ||
             dwStatus == TLS_E_NO_LICENSE || dwStatus == TLS_E_NO_CERTIFICATE ||
             dwStatus == TLS_E_RECORD_NOTFOUND) && bForwardRequest == TRUE )
        {
            //
            // release our DB handle so others can proceed
            //
            ROLLBACK_TRANSACTION(pDbWorkSpace);
            FREEDBHANDLE(pDbWorkSpace);
            bDbHandleAcquired = FALSE;
            DWORD dwForwardStatus;
            DWORD dwQuantityTemp = *pdwQuantity;
            
            //
            // forward call here
            //
            dwForwardStatus = TLSForwardLicenseRequest(
                                    pForward,
                                    &dwSupportFlagsTemp,
                                    pRequest,
                                    bAcceptFewerLicenses,
                                    &dwQuantityTemp,
                                    pcbEncodedCert,
                                    ppbEncodedCert
                                    );

            if(dwForwardStatus == TLS_I_SERVICE_STOP)
            {
                dwStatus = dwForwardStatus;
                goto cleanup;
            }

            if(dwForwardStatus == ERROR_SUCCESS)
            {
                //
                // remote server is able to issue perm. license, 
                // delete the license we are holding
                //

                *pdwSupportFlags = dwSupportFlagsTemp;

                *pdwQuantity = dwQuantityTemp;

                if(dwStatus == TLS_E_LICENSE_EXPIRED || dwStatus == TLS_I_FOUND_TEMPORARY_LICENSE)
                {
                    //
                    // re-acquire DB handle only if we are going to issue
                    // a temporary license
                    //
                    if(ALLOCATEDBHANDLE(pDbWorkSpace, g_GeneralDbTimeout) == FALSE)
                    {
                        dwStatus = TLS_E_ALLOCATE_HANDLE;
                        goto cleanup;
                    }

                    CLEANUPSTMT;
                    BEGIN_TRANSACTION(pDbWorkSpace);
                    bDbHandleAcquired = TRUE;
                    
                    //
                    // need to mark this license has been upgraded
                    //
                    dwStatus = TLSDBMarkClientLicenseUpgraded(
                                                              USEHANDLE(pDbWorkSpace),
                                                              pRequest,
                                                              &LicensedProduct
                                                              );

                    if(TLS_ERROR(dwStatus))
                    {
                        ROLLBACK_TRANSACTION(pDbWorkSpace);
                    }
                    else
                    {
                        COMMIT_TRANSACTION(pDbWorkSpace);
                    }

                    bDbHandleAcquired = FALSE;
                    FREEDBHANDLE(pDbWorkSpace);
                }

                dwStatus = ERROR_SUCCESS;
                
                // exit right here so we don't re-generate 
                // certificate
                goto cleanup;
            }
        }
    }

    //
    // if can't get license from remote, try temporary
    //
    // always issue a temporary license
    if((dwStatus == TLS_E_PRODUCT_NOTINSTALL ||
        dwStatus == TLS_E_NO_CERTIFICATE ||
        dwStatus == TLS_E_NO_LICENSE || 
        dwStatus == TLS_E_RECORD_NOTFOUND) && bAcceptTempLicense)
    {
        if(bDbHandleAcquired == FALSE)
        {
            //
            // re-acquire DB handle only if we going to issue
            // a temporary license
            //
            if(ALLOCATEDBHANDLE(pDbWorkSpace, g_GeneralDbTimeout) == FALSE)
            {
                dwStatus = TLS_E_ALLOCATE_HANDLE;
                goto cleanup;
            }

            CLEANUPSTMT;
            BEGIN_TRANSACTION(pDbWorkSpace);
            bDbHandleAcquired = TRUE;
        }

        // Issue a temporary license if can't allocate a permanent license
        dwStatus=TLSDBIssueTemporaryLicense( 
                            USEHANDLE(pDbWorkSpace),
                            pRequest,
                            NULL,
                            NULL,
                            &LicensedProduct
                        );

        if(dwStatus == ERROR_SUCCESS)
        {
            dwTried = TEMPORARY_ISSUE_TRIED;

            dwStatus = TLS_W_TEMPORARY_LICENSE_ISSUED;
        }    
    }

    if(bDbHandleAcquired == TRUE)
    {
        if(TLS_ERROR(dwStatus))
        {
            ROLLBACK_TRANSACTION(pDbWorkSpace);
        }
        else
        {
            COMMIT_TRANSACTION(pDbWorkSpace);

            switch (dwTried)
            {

            case PERMANENT_ISSUE_TRIED:
                InterlockedExchangeAdd(&g_lPermanentLicensesIssued,
                                       *pdwQuantity);
                break;

            case TEMPORARY_ISSUE_TRIED:
                InterlockedIncrement(&g_lTemporaryLicensesIssued);
                break;
            }
        }

        FREEDBHANDLE(pDbWorkSpace);
    }

    //
    // actually generate client certificate.
    //
    if(TLS_ERROR(dwStatus) == FALSE)
    {
        DWORD dwLicGenStatus;


        //
        // Post ssync job to inform other machine to delete this
        // entry
        //
        if(LicensedProduct.dwNumLicenseLeft == 0 && LicensedProduct.bTemp == FALSE)
        {
            // ignore error if we can't get it out to
            // other server
            TLSAnnounceLKPToAllRemoteServer(LicensedProduct.dwKeyPackId, 0);
        }

        dwLicGenStatus = TLSGenerateClientCertificate(
                                        g_hCryptProv,
                                        1,      // dwNumLicensedProduct
                                        &LicensedProduct,
                                        pRequest->wLicenseDetail,
                                        ppbEncodedCert,
                                        pcbEncodedCert
                                    );
        if(dwLicGenStatus != ERROR_SUCCESS)
        {
            dwStatus = dwLicGenStatus;
        }
    };


cleanup:
    return dwStatus;        
}

//----------------------------------------------------------
DWORD
TLSCheckLicenseMarkRequest(
    IN BOOL bForwardRequest,
    IN PLICENSEDPRODUCT pLicProduct,
    IN DWORD cbLicense,
    IN PBYTE pLicense,
    OUT PUCHAR pucMarkFlags
    )
{
    DWORD dwStatus = TLS_E_RECORD_NOTFOUND;
    DWORD dwErrCode = ERROR_SUCCESS;
    LICENSEDCLIENT licClient;

    // NB: licenses are in descending order, so use the first one

    if ((bForwardRequest) &&
        (_tcsicmp(pLicProduct->szIssuerId, (LPTSTR)g_pszServerPid) != 0))
    {
        // Check remote license server

        TCHAR szServer[LSERVER_MAX_STRING_SIZE+2];
        TCHAR *pszServer = szServer;
        TLS_HANDLE hHandle;

        dwStatus = TLSResolveServerIdToServer(pLicProduct->szIssuerId,
                                              sizeof(szServer),
                                              szServer);

        if (dwStatus != ERROR_SUCCESS)
        {
            // id not registered; use name
            pszServer = pLicProduct->szIssuer;
        }

        hHandle = TLSConnectAndEstablishTrust(pszServer, NULL);
        if(hHandle == NULL)
        {
            dwStatus = GetLastError();
        }

        // RPC to remote license server
        dwStatus = TLSCheckLicenseMark(
                           hHandle,
                           cbLicense,
                           pLicense,
                           pucMarkFlags,
                           &dwErrCode
                           );

        TLSDisconnectFromServer(hHandle);

        if ((dwStatus == ERROR_SUCCESS) && (dwErrCode == LSERVER_S_SUCCESS))
        {
            goto cleanup;
        }
    }

    // we're issuing server, or issuing server not found; try looking up HWID

    dwStatus = TLSFindLicense(pLicProduct,&licClient);

    if (ERROR_SUCCESS == dwStatus)
    {
        // this field is being reused for marking (e.g. user is authenticated)

        *pucMarkFlags = licClient.ucEntryStatus;
    }

cleanup:

    return dwStatus;
}

//----------------------------------------------------------
DWORD
TLSMarkLicenseRequest(
    IN BOOL bForwardRequest,
    IN UCHAR ucMarkFlags,
    IN PLICENSEDPRODUCT pLicProduct,
    IN DWORD cbLicense,
    IN PBYTE pLicense
    )
{
    DWORD dwStatus = TLS_E_RECORD_NOTFOUND;
    DWORD dwErrCode = ERROR_SUCCESS;
    PTLSDbWorkSpace pDbWkSpace=NULL;
    LICENSEDCLIENT license;

    // NB: licenses are in descending order, so use the first one

    if ((bForwardRequest) &&
        (_tcsicmp(pLicProduct->szIssuerId, (LPTSTR)g_pszServerPid) != 0))
    {
        // Check remote license server

        TCHAR szServer[LSERVER_MAX_STRING_SIZE+2];
        TCHAR *pszServer = szServer;
        TLS_HANDLE hHandle;

        dwStatus = TLSResolveServerIdToServer(pLicProduct->szIssuerId,
                                              sizeof(szServer),
                                              szServer);

        if (dwStatus != ERROR_SUCCESS)
        {
            // id not registered; use name
            pszServer = pLicProduct->szIssuer;
        }

        hHandle = TLSConnectAndEstablishTrust(pszServer, NULL);
        if(hHandle == NULL)
        {
            dwStatus = GetLastError();
        }

        // RPC to remote license server
        dwStatus = TLSMarkLicense(
                           hHandle,
                           ucMarkFlags,
                           cbLicense,
                           pLicense,
                           &dwErrCode
                           );

        TLSDisconnectFromServer(hHandle);

        if ((dwStatus == ERROR_SUCCESS) && (dwErrCode == LSERVER_S_SUCCESS))
        {
            goto cleanup;
        }
    }

    // we're issuing server, or issuing server not found; try looking up HWID

    dwStatus = TLSFindLicense(pLicProduct,&license);

    if((ERROR_SUCCESS == dwStatus) &&
       (ALLOCATEDBHANDLE(pDbWkSpace, g_GeneralDbTimeout)))
    {
        CLEANUPSTMT;

        BEGIN_TRANSACTION(pDbWkSpace);

        TLSDBLockLicenseTable();

        license.ucEntryStatus |= ucMarkFlags;

        dwStatus=TLSDBLicenseUpdateEntry( 
                         USEHANDLE(pDbWkSpace), 
                         LSLICENSE_SEARCH_MARK_FLAGS,
                         &license,
                         FALSE
                         );

    

        TLSDBUnlockLicenseTable();

        if(TLS_ERROR(dwStatus))
        {
            ROLLBACK_TRANSACTION(pDbWkSpace);
        }
        else
        {
            COMMIT_TRANSACTION(pDbWkSpace);

            InterlockedIncrement(&g_lLicensesMarked);
        }

        FREEDBHANDLE(pDbWkSpace);
    }
    else   
    {
        dwStatus=TLS_E_ALLOCATE_HANDLE;
    }

cleanup:

    return dwStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\license\tlserver\server\misc.h ===
//+--------------------------------------------------------------------------
//
// Copyright (c) 1997-1999 Microsoft Corporation
//
// File:        misc.h
//
// Contents:    
//
// History:     
//
//---------------------------------------------------------------------------
#ifndef __MISC_H__
#define __MISC_H__
#include "server.h"


#ifdef __cplusplus
extern "C" {
#endif

PMHANDLE
GenerateClientId();

void
TlsLicenseRequestToPMLicenseRequest(
    DWORD dwLicenseType,
    PTLSLICENSEREQUEST pTlsRequest,
    LPTSTR pszMachineName,
    LPTSTR pszUserName,
    DWORD dwSupportFlags,
    PPMLICENSEREQUEST pPmRequest
);

BOOL
TLSDBGetMaxKeyPackId(
    PTLSDbWorkSpace pDbWkSpace,
    DWORD* pdwKeyPackId
);

BOOL
TLSDBGetMaxLicenseId(
    PTLSDbWorkSpace pDbWkSpace,
    DWORD* pdwLicenseId
);

DWORD 
TLSDBGetNextKeyPackId();

DWORD
TLSDBGetNextLicenseId();

DWORD
TLSFormDBRequest(
    PBYTE pbEncryptedHwid,
    DWORD cbEncryptedHwid,
    DWORD dwProductVersion,
    LPTSTR pszCompanyName,
    LPTSTR pszProductId,
    DWORD dwLanguageId,
    DWORD dwPlatformId,
    LPTSTR szClientMachine, 
    LPTSTR szUserName, 
    LPTLSDBLICENSEREQUEST pDbRequest 
);

DWORD
TLSConvertRpcLicenseRequestToDbRequest( 
    PBYTE pbEncryptedHwid,
    DWORD cbEncryptedHwid,
    TLSLICENSEREQUEST* pRequest, 
    LPTSTR szClientMachine, 
    LPTSTR szUserName, 
    LPTLSDBLICENSEREQUEST pDbRequest 
);

BOOL
ConvertLsKeyPackToKeyPack(
    IN LPLSKeyPack lpLsKeyPack, 
    IN OUT PTLSLICENSEPACK lpLicPack,
    IN OUT PLICPACKDESC lpLicPackDesc
);

void
ConvertKeyPackToLsKeyPack(  
    IN PTLSLICENSEPACK lpLicPack,
    IN PLICPACKDESC lpLicPackDesc,
    IN OUT LPLSKeyPack lpLsKeyPack
);

void
ConvertLSLicenseToLicense(
    LPLSLicense lplsLicense, 
    LPLICENSEDCLIENT lpLicense
);

void
ConvertLicenseToLSLicense(
    LPLICENSEDCLIENT lpLicense, 
    LPLSLicense lplsLicense
);

void
ConvertLicenseToLSLicenseEx(
    LPLICENSEDCLIENT lpLicense, 
    LPLSLicenseEx lplsLicense
);

#ifdef __cplusplus
}
#endif


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\license\tlserver\server\permlic.h ===
//+--------------------------------------------------------------------------
//
// Copyright (c) 1997-1999 Microsoft Corporation
//
// File:        permlic.h
//
// Contents:    
//
// History:     
//
//---------------------------------------------------------------------------
#ifndef __PERMLIC_H__
#define __PERMLIC_H__
#include "server.h"


#ifdef __cplusplus
extern "C" {
#endif

DWORD
TLSDBIssuePermanentLicense( 
    IN PTLSDbWorkSpace pDbWkSpace,
    IN PTLSDBLICENSEREQUEST pRequest,
    IN BOOL bLatestVersion,
    IN BOOL bAcceptFewerLicenses,
    IN OUT DWORD *pdwQuantity,
    IN OUT PTLSDBLICENSEDPRODUCT pLicensedProduct,
    IN DWORD dwSupportFlags
);

DWORD
TLSDBReissuePermanentLicense(
    IN PTLSDbWorkSpace pDbWkSpace,
    IN PLICENSEDPRODUCT pExpiredLicense,
    IN OUT PTLSDBLICENSEDPRODUCT pReissuedLicense
);

DWORD
TLSDBReissueFoundPermanentLicense(
    IN PTLSDbWorkSpace pDbWkSpace,
    IN PTLSDBLICENSEDPRODUCT pExpiredLicense,
    IN OUT PTLSDBLICENSEDPRODUCT pReissuedLicense
);

DWORD
TLSDBGetPermanentLicense(
    IN PTLSDbWorkSpace pDbWkSpace,
    IN PTLSDBLICENSEREQUEST pRequest,
    IN BOOL bAcceptFewerLicenses,
    IN OUT DWORD *pdwQuantity,
    IN BOOL bLatestVersion,
    IN OUT PTLSLICENSEPACK pLicensePack
);

void
TLSResetLogLowLicenseWarning(
    IN LPTSTR pszCompanyName,
    IN LPTSTR pszProductId,
    IN DWORD dwProductVersion,
    IN BOOL bLogged
);

#ifdef __cplusplus
}
#endif


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\license\tlserver\server\pid.h ===
//+--------------------------------------------------------------------------
//
// Copyright (c) 1997-1999 Microsoft Corporation
//
// File:        pid.h
//
// Contents:    
//
// History:     
//
//---------------------------------------------------------------------------
#ifndef __PID_H__
#define __PID_H__

#include "srvdef.h"

#define NTPID_REGISTRY  _TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion")
#define NTPID_VALUE     _TEXT("ProductId")

#define TLSUNIQUEID_SIZE        3
#define TLSUNIQUEID_SIZE_2      7

#define TLSUNIQUEID_OFFSET_2    10

#define NTPID_OEM_OFFSET        6
#define NTPID_OEM_LENGTH        3
#define NTPID_OEM               _TEXT("OEM")

#define NTPID_OEM_CHANNELID_OFFSET  12

#define MAX_PID20_LENGTH        25


#ifdef __cplusplus
extern "C" {
#endif

    DWORD
    TLSGeneratePid(
        OUT LPTSTR* pszTlsPid,
        OUT PDWORD  pcbTlsPid,
        OUT LPTSTR* pszTlsUniqueId,
        OUT PDWORD  pcbTlsUniqueId
    );


    DWORD
    LoadNtPidFromRegistry(
        OUT LPTSTR* ppbNtPid
    );


    DWORD
    ServerIdsToLsaServerId(
        IN PBYTE pbServerUniqueId,
        IN DWORD cbServerUniqueId,
        IN PBYTE pbServerPid,
        IN DWORD cbServerPid,
        IN PBYTE pbServerSPK,
        IN DWORD cbServerSPK,
        IN PCERT_EXTENSION pCertExtensions,
        IN DWORD dwNumCertExtensions,
        OUT PTLSLSASERVERID* ppLsaServerId,
        OUT DWORD* pdwLsaServerId
    );

    DWORD
    LsaServerIdToServerIds(
        IN PTLSLSASERVERID pLsaServerId,
        IN DWORD dwLsaServerId,
        OUT PBYTE* ppbServerUniqueId,
        OUT PDWORD pcbServerUniqueId,
        OUT PBYTE* ppbServerPid,
        OUT PDWORD pcbServerPid,
        OUT PBYTE* ppbServerSPK,
        OUT PDWORD pcbServerSPK,
        OUT PCERT_EXTENSIONS* pCertExtensions,
        OUT PDWORD pdwNumCertExtensions
    );

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\license\tlserver\server\permlic.cpp ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996-1998
//
// File:        permlic.cpp
//
// Contents:    
//              Issue perm. license to client
//
// History:     
//  Feb 4, 98      HueiWang    Created
//---------------------------------------------------------------------------
#include "pch.cpp"
#include "globals.h"
#include "permlic.h"
#include "misc.h"
#include "db.h"
#include "clilic.h"
#include "findlost.h"
#include <winsta.h>

#define STRSAFE_NO_DEPRECATE
#include <strsafe.h>

DWORD
GenerateRandomNumber(
    IN  DWORD   Seed
    );

void
LicensedProductToDbLicensedProduct(
    PLICENSEDPRODUCT pSrc,
    PTLSDBLICENSEDPRODUCT pDest
    );

void
CopyDbLicensedProduct(
    PTLSDBLICENSEDPRODUCT pSrc,
    PTLSDBLICENSEDPRODUCT pDest
    );

//-------------------------------------------------------------------------

//
// Memory leak at service shutdown time
//
typedef struct __LoggedLowLicenseProduct {
    LPTSTR pszCompanyName;
    LPTSTR pszProductId;
    DWORD dwProductVersion;

    __LoggedLowLicenseProduct() : pszProductId(NULL), pszCompanyName(NULL) {};

    friend bool 
    operator<(
            const __LoggedLowLicenseProduct&, 
            const __LoggedLowLicenseProduct&
    );

} LoggedLowLicenseProduct;

//-------------------------------------------------------------------------
inline bool
operator<(
    const __LoggedLowLicenseProduct& a, 
    const __LoggedLowLicenseProduct& b
    )
/*++

--*/
{
    bool bStatus;

    TLSASSERT(a.pszCompanyName != NULL && b.pszCompanyName != NULL);
    TLSASSERT(a.pszProductId != NULL && b.pszProductId != NULL);

    // in case we mess up...
    if(a.pszProductId == NULL || a.pszCompanyName == NULL)
    {
        bStatus = TRUE;
    }
    else if(b.pszProductId == NULL || b.pszCompanyName == NULL)
    {
        bStatus = FALSE;
    }
    else
    {
        bStatus = (_tcsicmp(a.pszCompanyName, b.pszCompanyName) < 0);

        if(bStatus == TRUE)
        {
            bStatus = (_tcsicmp(a.pszProductId, b.pszProductId) < 0);
        }

        if(bStatus == TRUE)
        {
            bStatus = (CompareTLSVersions(a.dwProductVersion, b.dwProductVersion) < 0);
        }
    }

    return bStatus;
}

//-------------------------------------------------------------------------
typedef map<
            LoggedLowLicenseProduct, 
            BOOL, 
            less<LoggedLowLicenseProduct> 
    > LOGLOWLICENSEMAP;

static CCriticalSection LogLock;
static LOGLOWLICENSEMAP LowLicenseLog;


//---------------------------------------------------------------
void
TLSResetLogLowLicenseWarning(
    IN LPTSTR pszCompanyName,
    IN LPTSTR pszProductId,
    IN DWORD dwProductVersion,
    IN BOOL bLogged
    )
/*++

--*/
{
    LOGLOWLICENSEMAP::iterator it;
    LoggedLowLicenseProduct product;

    product.pszCompanyName = pszCompanyName;
    product.pszProductId = pszProductId;
    product.dwProductVersion = dwProductVersion;

    LogLock.Lock();

    it = LowLicenseLog.find(product);
    if(it != LowLicenseLog.end())
    {
        // reset to not logged warning yet.
        (*it).second = bLogged;
    }
    else if(bLogged == TRUE)
    {
        memset(&product, 0, sizeof(product));

        // memory leak here at service stop.
        product.pszProductId = _tcsdup(pszProductId);
        product.pszCompanyName = _tcsdup(pszCompanyName);
        product.dwProductVersion = dwProductVersion;

        if(product.pszProductId != NULL && product.pszCompanyName != NULL)
        {
            LowLicenseLog[product] = TRUE;
        }
        else
        {
            // if unable to allocate any more memory, log message every time
            if(product.pszProductId != NULL)
            {
                free(product.pszProductId);
            }

            if(product.pszCompanyName != NULL)
            {
                free(product.pszCompanyName);
            }
        }
    }   
        
    LogLock.UnLock();

    return;
}

//---------------------------------------------------------------

void
TLSLogLowLicenseWarning(
    IN PTLSDbWorkSpace pDbWkSpace,
    IN PTLSDBLICENSEREQUEST pRequest,
    IN BOOL bNoLicense
    )
/*++

Abstract:

    Log an low license count warning.

Parameter:

    pDbWkSpace - Workspace handle.
    pRequest - License Request.
    Workspace - No license available.
    LicensePack - License pack that is out of license

return:

    None
    
--*/
{
    LOGLOWLICENSEMAP::iterator it;
    BOOL bWarningLogged = FALSE;
    DWORD dwStatus;


    if( pRequest == NULL || pRequest->pClientLicenseRequest == NULL || 
        pRequest->pClientLicenseRequest->pszProductId == NULL )
    {
        TLSASSERT(FALSE);
        return;
    }

    LoggedLowLicenseProduct product;

    product.pszProductId = pRequest->pClientLicenseRequest->pszProductId;
    product.pszCompanyName = pRequest->pClientLicenseRequest->pszCompanyName;
    product.dwProductVersion = pRequest->pClientLicenseRequest->dwProductVersion;

    LogLock.Lock();

    // see if we already log this warning message
    it = LowLicenseLog.find(product);
    if(it == LowLicenseLog.end())
    {
        memset(&product, 0, sizeof(product));

        // memory leak here at service stop.
        product.pszProductId = _tcsdup(pRequest->pClientLicenseRequest->pszProductId);
        product.pszCompanyName = _tcsdup(pRequest->pClientLicenseRequest->pszCompanyName);
        product.dwProductVersion = pRequest->pClientLicenseRequest->dwProductVersion;

        if(product.pszProductId != NULL && product.pszCompanyName != NULL)
        {
            LowLicenseLog[product] = TRUE;
        }
        else
        {
            // if unable to allocate any more memory, log message every time
            if(product.pszProductId != NULL)
            {
                free(product.pszProductId);
            }

            if(product.pszCompanyName != NULL)
            {
                free(product.pszCompanyName);
            }
        }
    }
    else
    {
        bWarningLogged = (*it).second;
        (*it).second = TRUE;
    }
        
    LogLock.UnLock();

    if(bWarningLogged == TRUE)
    {
        return;
    }

    //
    // ask policy module if they have description
    //
    PMKEYPACKDESCREQ kpDescReq;
    PPMKEYPACKDESC pKpDesc;

    //
    // Ask for default system language ID
    //
    kpDescReq.pszProductId = pRequest->pszProductId;
    kpDescReq.dwLangId = GetSystemDefaultLangID();
    kpDescReq.dwVersion = pRequest->dwProductVersion;
    pKpDesc = NULL;

    dwStatus = pRequest->pPolicy->PMLicenseRequest(
                                            pRequest->hClient,
                                            REQUEST_KEYPACKDESC,
                                            (PVOID)&kpDescReq,
                                            (PVOID *)&pKpDesc
                                        );

    if(dwStatus != ERROR_SUCCESS || pKpDesc == NULL)
    {
        if(GetSystemDefaultLangID() != MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US))
        {
            // see if we have any US desc.
            kpDescReq.dwLangId = MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US);
            pKpDesc = NULL;

            dwStatus = pRequest->pPolicy->PMLicenseRequest(
                                            pRequest->hClient,
                                            REQUEST_KEYPACKDESC,
                                            (PVOID)&kpDescReq,
                                            (PVOID *)&pKpDesc
                                        );
        }
    }

    LPCTSTR pString[2];

    pString[0] = g_szComputerName;
    pString[1] = (dwStatus == ERROR_SUCCESS && pKpDesc != NULL) ? pKpDesc->szProductDesc : 
                       pRequest->pClientLicenseRequest->pszProductId;
 
    TLSLogEventString(
            EVENTLOG_WARNING_TYPE,
            (bNoLicense == TRUE) ? TLS_W_NOPERMLICENSE : TLS_W_PRODUCTNOTINSTALL,
            sizeof(pString)/sizeof(pString[0]),
            pString
        );

    return;
}

//--------------------------------------------------------------------------------
DWORD
TLSDBIssuePermanentLicense( 
    IN PTLSDbWorkSpace pDbWkSpace,
    IN PTLSDBLICENSEREQUEST pRequest,
    IN BOOL bLatestVersion,
    IN BOOL bAcceptFewerLicenses,
    IN OUT DWORD *pdwQuantity,
    IN OUT PTLSDBLICENSEDPRODUCT pLicensedProduct,
    IN DWORD dwSupportFlags
    )
/*
Abstract:

    Routine to allocate a perm. license.

Parameters:

    pDbWkSpace - Workspace handle.
    pRequest - license request.
    bLatestVersion - Request latest version (unused)
    bAcceptFewerLicenses - TRUE if succeeding with fewer licenses than
                           requested is acceptable
    pdwQuantity - on input, number of licenses to allocate.  on output,
                  number of licenses actually allocated
    IN OUT pLicensedProduct - licensed product
    dwSupportFlags - abilities supported by TS and LS.

Returns:

*/
{
    DWORD status=ERROR_SUCCESS;
    ULARGE_INTEGER  ulSerialNumber;
    DWORD  dwLicenseId;
    TLSLICENSEPACK LicensePack;
    UCHAR ucKeyPackStatus;
    LICENSEDCLIENT issuedLicense;
    DWORD CertSerialNumber;

    PMGENERATELICENSE PolModGenLicense;
    PPMCERTEXTENSION pPolModCertExtension=NULL;

    FILETIME notBefore, notAfter;
    UCHAR ucAgreementType;

    memset(&ulSerialNumber, 0, sizeof(ulSerialNumber));

    //----------------------------------------------------------------------
    //
    // this step require reduce available license by dwQuantity
    //
    status=TLSDBGetPermanentLicense(
                            pDbWkSpace,
                            pRequest,
                            bAcceptFewerLicenses,
                            pdwQuantity,
                            bLatestVersion,
                            &LicensePack
                        );

    if(status != ERROR_SUCCESS)
    {
        if(status == TLS_E_NO_LICENSE || status == TLS_E_PRODUCT_NOTINSTALL)
        {
            TLSLogLowLicenseWarning(
                                pDbWkSpace,
                                pRequest,
                                (status == TLS_E_NO_LICENSE)
                            );
        }

        goto cleanup;
    }

    ucKeyPackStatus = (LicensePack.ucKeyPackStatus & ~LSKEYPACKSTATUS_RESERVED);

    if( ucKeyPackStatus != LSKEYPACKSTATUS_PENDING && 
        ucKeyPackStatus != LSKEYPACKSTATUS_ACTIVE )
    {
        SetLastError(status = TLS_E_INTERNAL);
        goto cleanup;
    }

    ucAgreementType = (LicensePack.ucAgreementType & ~ LSKEYPACK_RESERVED_TYPE);

    if( ucAgreementType != LSKEYPACKTYPE_SELECT && 
        ucAgreementType != LSKEYPACKTYPE_RETAIL && 
        ucAgreementType != LSKEYPACKTYPE_FREE && 
        ucAgreementType != LSKEYPACKTYPE_OPEN )
    {
        SetLastError(status = TLS_E_INTERNAL);
        goto cleanup;
    }

     
    //
    // for pending activation keypack, we still 
    // issue permanent license and rely 
    // on revoke key pack list to invalidate licenses.
    //
    dwLicenseId=TLSDBGetNextLicenseId();

    //
    // Reset status
    //
    status = ERROR_SUCCESS;

    //
    // Formuate license serial number 
    //
    ulSerialNumber.LowPart = dwLicenseId;
    ulSerialNumber.HighPart = LicensePack.dwKeyPackId;

    // Update License Table Here
    memset(&issuedLicense, 0, sizeof(LICENSEDCLIENT));
    issuedLicense.dwLicenseId = dwLicenseId;
    issuedLicense.dwKeyPackId = LicensePack.dwKeyPackId;
    issuedLicense.dwKeyPackLicenseId = LicensePack.dwNextSerialNumber;
    issuedLicense.dwSystemBiosChkSum = pRequest->hWid.dwPlatformID;
    issuedLicense.dwVideoBiosChkSum = pRequest->hWid.Data1;
    issuedLicense.dwFloppyBiosChkSum = pRequest->hWid.Data2;
    issuedLicense.dwHardDiskSize = pRequest->hWid.Data3;
    issuedLicense.dwRamSize = pRequest->hWid.Data4;
    issuedLicense.dwNumLicenses = *pdwQuantity;
    issuedLicense.ftIssueDate = time(NULL);

    StringCbCopy(issuedLicense.szMachineName, sizeof(issuedLicense.szMachineName), pRequest->szMachineName);
    StringCbCopy(issuedLicense.szUserName, sizeof(issuedLicense.szUserName), pRequest->szUserName);

    if ((dwSupportFlags & SUPPORT_PER_SEAT_REISSUANCE) &&
        ((_tcsnicmp(LicensePack.szProductId, TERMSERV_PRODUCTID_SKU,
            _tcslen(TERMSERV_PRODUCTID_SKU)) == 0) ||
         (_tcsnicmp(LicensePack.szProductId, TERMSERV_PRODUCTID_CONCURRENT_SKU,
            _tcslen(TERMSERV_PRODUCTID_CONCURRENT_SKU)) == 0)) &&
        ((LicensePack.ucAgreementType == LSKEYPACKTYPE_SELECT) ||
         (LicensePack.ucAgreementType == LSKEYPACKTYPE_RETAIL) ||
         (LicensePack.ucAgreementType == LSKEYPACKTYPE_OPEN)))
    {
        DWORD dwRange;

        dwRange = GenerateRandomNumber(GetCurrentThreadId()) %
                g_dwReissueLeaseRange;

        issuedLicense.ftExpireDate = ((DWORD)time(NULL)) +
                g_dwReissueLeaseMinimum + dwRange;
    }
    else
    {
        issuedLicense.ftExpireDate = PERMANENT_LICENSE_EXPIRE_DATE;
    }

    issuedLicense.ucLicenseStatus =
        (LicensePack.ucKeyPackStatus == LSKEYPACKSTATUS_PENDING) ?  
            LSLICENSE_STATUS_PENDING : LSLICENSE_STATUS_ACTIVE;   

    UnixTimeToFileTime(LicensePack.dwActivateDate, &notBefore);
    UnixTimeToFileTime(issuedLicense.ftExpireDate, &notAfter);

    //
    // Inform Policy Module of license issued.
    // 
    if(pRequest->pPolicy)
    {
        PolModGenLicense.dwKeyPackType = LicensePack.ucAgreementType;
        PolModGenLicense.pLicenseRequest = pRequest->pPolicyLicenseRequest;
        PolModGenLicense.dwKeyPackId = LicensePack.dwKeyPackId;;
        PolModGenLicense.dwKeyPackLicenseId = LicensePack.dwNextSerialNumber;
        PolModGenLicense.ClientLicenseSerialNumber = ulSerialNumber;
        PolModGenLicense.ftNotBefore = notBefore;
        PolModGenLicense.ftNotAfter = notAfter;

        status = pRequest->pPolicy->PMLicenseRequest( 
                                        pRequest->hClient,
                                        REQUEST_GENLICENSE,
                                        (PVOID)&PolModGenLicense,
                                        (PVOID *)&pPolModCertExtension
                                    );

        if(status != ERROR_SUCCESS)
        {
            //
            // Error in policy module
            //
            goto cleanup;
        }
    }

    //  
    // Check error return from policy module
    //
    if(pPolModCertExtension != NULL)
    {
        if(pPolModCertExtension->pbData != NULL &&
           pPolModCertExtension->cbData == 0 ||
           pPolModCertExtension->pbData == NULL &&
           pPolModCertExtension->cbData != 0  )
        {
            // assuming no extension data
            pPolModCertExtension->cbData = 0;
            pPolModCertExtension->pbData = NULL;
        }

        if(CompareFileTime( &(pPolModCertExtension->ftNotBefore), 
                            &(pPolModCertExtension->ftNotAfter)) > 0)
        {
            //
            // invalid data return from policy module
            //
            TLSLogEvent(
                    EVENTLOG_ERROR_TYPE,
                    TLS_E_GENERATECLIENTELICENSE,
                    status = TLS_E_POLICYMODULEERROR,
                    pRequest->pPolicy->GetCompanyName(),
                    pRequest->pPolicy->GetProductId()
                );

            goto cleanup;
        }


        if( FileTimeToLicenseDate(&(pPolModCertExtension->ftNotBefore), &issuedLicense.ftIssueDate) == FALSE ||
            FileTimeToLicenseDate(&(pPolModCertExtension->ftNotAfter), &issuedLicense.ftExpireDate) == FALSE )
        {
            //
            // Invalid data return from policy module
            //
            TLSLogEvent(
                    EVENTLOG_ERROR_TYPE,
                    TLS_E_GENERATECLIENTELICENSE,
                    status = TLS_E_POLICYMODULEERROR,
                    pRequest->pPolicy->GetCompanyName(),
                    pRequest->pPolicy->GetProductId()
                );

            goto cleanup;
        }

        notBefore = pPolModCertExtension->ftNotBefore;
        notAfter = pPolModCertExtension->ftNotAfter;
    }

    //
    // Add license into license table
    //
    status=TLSDBLicenseAdd(
                    pDbWkSpace, 
                    &issuedLicense, 
                    0,          
                    NULL
                );

    if(status != ERROR_SUCCESS)
    {
        goto cleanup;
    }

    //
    // Return licensed product
    //
    pLicensedProduct->pSubjectPublicKeyInfo = NULL;
    pLicensedProduct->dwQuantity = *pdwQuantity;
    pLicensedProduct->ulSerialNumber = ulSerialNumber;

    pLicensedProduct->dwKeyPackId = LicensePack.dwKeyPackId;
    pLicensedProduct->dwLicenseId = dwLicenseId;
    pLicensedProduct->dwKeyPackLicenseId = LicensePack.dwNextSerialNumber;
    pLicensedProduct->dwNumLicenseLeft = LicensePack.dwNumberOfLicenses;
    pLicensedProduct->ClientHwid = pRequest->hWid;
    pLicensedProduct->bTemp = FALSE;

    pLicensedProduct->NotBefore = notBefore;
    pLicensedProduct->NotAfter = notAfter;

    pLicensedProduct->dwProductVersion = MAKELONG(LicensePack.wMinorVersion, LicensePack.wMajorVersion);

    StringCbCopy(pLicensedProduct->szUserName, sizeof(pLicensedProduct->szUserName), pRequest->szUserName);
    StringCbCopy(pLicensedProduct->szMachineName, sizeof(pLicensedProduct->szMachineName), pRequest->szMachineName);
    StringCbCopy(pLicensedProduct->szCompanyName, sizeof(pLicensedProduct->szCompanyName), LicensePack.szCompanyName);
    StringCbCopy(pLicensedProduct->szLicensedProductId, sizeof(pLicensedProduct->szLicensedProductId), LicensePack.szProductId);
    StringCbCopy(pLicensedProduct->szRequestProductId, sizeof(pLicensedProduct->szRequestProductId), pRequest->pClientLicenseRequest->pszProductId);    

    pLicensedProduct->dwLanguageID = pRequest->dwLanguageID;
    pLicensedProduct->dwPlatformID = pRequest->dwPlatformID;
    pLicensedProduct->pbPolicyData = (pPolModCertExtension) ? pPolModCertExtension->pbData : NULL;
    pLicensedProduct->cbPolicyData = (pPolModCertExtension) ? pPolModCertExtension->cbData : 0;

cleanup:

    return status;
}

DWORD
TLSDBReissuePermanentLicense(
    IN PTLSDbWorkSpace pDbWkSpace,
    IN PLICENSEDPRODUCT pExpiredLicense,
    IN OUT PTLSDBLICENSEDPRODUCT pReissuedLicense
    )
/*++
Abstract:

    Searches for the expired license in the database and, if found, resets
    the expiration and returns the modified license.

Parameters:

Returns:

--*/
{
    TLSDBLICENSEDPRODUCT LicensedProduct;

    LicensedProductToDbLicensedProduct(pExpiredLicense,&LicensedProduct);

    return TLSDBReissueFoundPermanentLicense(pDbWkSpace,
                                             &LicensedProduct,
                                             pReissuedLicense);
}

DWORD
TLSDBReissueFoundPermanentLicense(
    IN PTLSDbWorkSpace pDbWkSpace,
    IN PTLSDBLICENSEDPRODUCT pExpiredLicense,
    IN OUT PTLSDBLICENSEDPRODUCT pReissuedLicense
    )
/*++
Abstract:

    Searches for the expired license in the database and, if found, resets
    the expiration and returns the modified license.

Parameters:

Returns:

--*/
{
    DWORD dwStatus;
    LICENSEDCLIENT License;

    ASSERT(pDbWkSpace != NULL);
    ASSERT(pExpiredLicense != NULL);
    ASSERT(pReissuedLicense != NULL);

    dwStatus = TLSFindDbLicensedProduct(pExpiredLicense, &License);

    if (dwStatus == ERROR_SUCCESS)
    {
        DWORD dwRange;

        dwRange = GenerateRandomNumber(GetCurrentThreadId()) %
                g_dwReissueLeaseRange;

        License.ftExpireDate = ((DWORD)time(NULL)) +
                g_dwReissueLeaseMinimum + dwRange;

        TLSDBLockLicenseTable();

        dwStatus = TLSDBLicenseUpdateEntry(
                        USEHANDLE(pDbWkSpace),
                        LSLICENSE_SEARCH_EXPIREDATE,
                        &License,
                        FALSE
                        );       

        TLSDBUnlockLicenseTable();
    }

    if (dwStatus == ERROR_SUCCESS)
    {
        CopyDbLicensedProduct(pExpiredLicense, pReissuedLicense);
        UnixTimeToFileTime(License.ftExpireDate, &(pReissuedLicense->NotAfter));
        pReissuedLicense->pSubjectPublicKeyInfo = NULL;
    }

    return(dwStatus);
}

//+------------------------------------------------------------------------
DWORD
TLSDBGetPermanentLicense(
    IN PTLSDbWorkSpace pDbWkSpace,
    IN PTLSDBLICENSEREQUEST pRequest,
    IN BOOL bAcceptFewerLicenses,
    IN OUT DWORD *pdwQuantity,
    IN BOOL bLatestVersion,
    IN OUT PTLSLICENSEPACK pLicensePack
    )
/*++
Abstract:

    Allocate a permanent license from database.

Parameters:

    pDbWkSpace : workspace handle.
    pRequest : product to be request.
    bAcceptFewerLicenses - TRUE if succeeding with fewer licenses than
                           requested is acceptable
    pdwQuantity - on input, number of licenses to allocate.  on output,
                  number of licenses actually allocated
    bLatestversion : latest version (unused).
    pLicensePack : license pack where license is allocated.

Returns:


++*/
{
    DWORD dwStatus = ERROR_SUCCESS;
    TLSDBLicenseAllocation allocated;
    TLSDBAllocateRequest AllocateRequest;
    TLSLICENSEPACK LicenseKeyPack;
    DWORD dwTotalAllocated = 0;
    BOOL fRetried = FALSE;

    DWORD dwSearchedType = 0;
    DWORD dwSuggestType;
    DWORD dwPMAdjustedType = LSKEYPACKTYPE_UNKNOWN;
    DWORD dwLocalType = LSKEYPACKTYPE_UNKNOWN;

    POLICY_TS_MACHINE groupPolicy;
    RegGetMachinePolicy(&groupPolicy);

#define NUM_KEYPACKS 5

    DWORD                       dwAllocation[NUM_KEYPACKS];
    TLSLICENSEPACK              keypack[NUM_KEYPACKS];

    for (int i=0; i < NUM_KEYPACKS; i++)
    {
        keypack[i].pbDomainSid = NULL;
    }

    AllocateRequest.szCompanyName = (LPTSTR)pRequest->pszCompanyName;
    AllocateRequest.szProductId = (LPTSTR)pRequest->pszProductId;
    AllocateRequest.dwVersion = pRequest->dwProductVersion;
    AllocateRequest.dwPlatformId = pRequest->dwPlatformID;
    AllocateRequest.dwLangId = pRequest->dwLanguageID;
    AllocateRequest.dwNumLicenses = *pdwQuantity;
    if( groupPolicy.fPolicyPreventLicenseUpgrade == 1 && groupPolicy.fPreventLicenseUpgrade == 1)
    {
        AllocateRequest.dwScheme = ALLOCATE_EXACT_VERSION;
    }
    else
    {
        AllocateRequest.dwScheme = ALLOCATE_ANY_GREATER_VERSION;
    }
    memset(&allocated, 0, sizeof(allocated));

retry_search:

    do {

        allocated.dwBufSize = NUM_KEYPACKS;
        allocated.pdwAllocationVector = dwAllocation;
        allocated.lpAllocateKeyPack = keypack;

        dwSuggestType = dwLocalType;

        dwStatus = pRequest->pPolicy->PMLicenseRequest(
                                                pRequest->hClient,
                                                REQUEST_KEYPACKTYPE,
                                                UlongToPtr(dwSuggestType),
                                                (PVOID *)&dwPMAdjustedType
                                            );

        if(dwStatus != ERROR_SUCCESS)
            break;

        dwLocalType = (dwPMAdjustedType & ~LSKEYPACK_RESERVED_TYPE);
        if(dwLocalType > LSKEYPACKTYPE_LAST)
        {
            TLSLogEvent(
                    EVENTLOG_ERROR_TYPE,
                    TLS_E_GENERATECLIENTELICENSE,
                    dwStatus = TLS_E_POLICYMODULEERROR,
                    pRequest->pPolicy->GetCompanyName(),
                    pRequest->pPolicy->GetProductId()
                );
            
            break;
        }

        if(dwSearchedType & (0x1 << dwLocalType))
        {
            //
            // we already went thru this license pack, policy module error
            //
            TLSLogEvent(
                    EVENTLOG_ERROR_TYPE,
                    TLS_E_GENERATECLIENTELICENSE,
                    dwStatus = TLS_E_POLICYMODULERECURSIVE,
                    pRequest->pPolicy->GetCompanyName(),
                    pRequest->pPolicy->GetProductId()
                );
            break;
        }

        dwSearchedType |= (0x1 << dwLocalType);
        AllocateRequest.ucAgreementType = dwPMAdjustedType;

        dwStatus = AllocateLicensesFromDB(
                                    pDbWkSpace,
                                    &AllocateRequest,
                                    TRUE,       // fCheckAgreementType
                                    &allocated
                            );

        if(dwStatus == ERROR_SUCCESS)
        {
            //
            // successfully allocate a license
            //
            dwTotalAllocated += allocated.dwTotalAllocated;

            if (dwTotalAllocated >= *pdwQuantity)
            {
                break;
            }
            else
            {
                AllocateRequest.dwNumLicenses -= allocated.dwTotalAllocated;
                continue;
            }
        }

        if(dwStatus != TLS_I_NO_MORE_DATA && dwStatus != TLS_E_PRODUCT_NOTINSTALL)
        {
            //
            // error occurred in AllocateLicenseFromDB()
            //
            break;
        }
    } while(dwLocalType != LSKEYPACKTYPE_UNKNOWN);

    if ((!fRetried)
        && (dwTotalAllocated < *pdwQuantity)
        && (AllocateRequest.dwScheme == ALLOCATE_ANY_GREATER_VERSION)
        && (LOWORD(AllocateRequest.dwVersion) == 0))
    {
        //
        // Not enough 5.0 licenses found.  Try again with 5.1 licenses.
        //

        fRetried = TRUE;
        dwLocalType = LSKEYPACKTYPE_UNKNOWN;
        dwPMAdjustedType = LSKEYPACKTYPE_UNKNOWN;
        dwSearchedType = 0;
        AllocateRequest.dwVersion |= 1;
        AllocateRequest.szProductId[7] = L'1';

        goto retry_search;
    }


    if ((dwTotalAllocated == 0)
        || (!bAcceptFewerLicenses && 
            ((dwTotalAllocated < *pdwQuantity))))
    {
        // Failing to commit will return all licenses allocated so far

        SetLastError(dwStatus = TLS_E_NO_LICENSE);
    }
    else if ((dwTotalAllocated != 0) && bAcceptFewerLicenses)
    {
        dwStatus = ERROR_SUCCESS;
    }

    if(dwStatus == ERROR_SUCCESS)
    {
        //
        // LicenseKeyPack return via TLSDBLicenseAllocation structure
        //
        *pLicensePack = keypack[0];
        *pdwQuantity = dwTotalAllocated;
    } 

    return dwStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\license\tlserver\server\pid.cpp ===
//+--------------------------------------------------------------------------
//
// Copyright (c) 1997-1999 Microsoft Corporation
//
// File:       pid.cpp 
//
// Contents:   Generate/save/retrieve license server ID to LSA 
//
// History:     
//
//---------------------------------------------------------------------------

#include "pch.cpp"
#include "pid.h"
#include "gencert.h"
#include "certutil.h"
#include <stdlib.h>


//////////////////////////////////////////////////////////////////

DWORD
ServerIdsToLsaServerId(
    IN PBYTE pbServerUniqueId,
    IN DWORD cbServerUniqueId,
    IN PBYTE pbServerPid,
    IN DWORD cbServerPid,
    IN PBYTE pbServerSPK,
    IN DWORD cbServerSPK,
    IN PCERT_EXTENSION pCertExtensions,
    IN DWORD dwNumCertExtensions,
    OUT PTLSLSASERVERID* ppLsaServerId,
    OUT DWORD* pdwLsaServerId
    )

/*++

Abstract:

    Combine list of License Server ID to TLSLSASERVERID structure 
    suitable to be saved with LSA.

Parameters:


    pbServerUniqueId : License Server Unique ID.
    cbServerUniqueId : size of License Server Unique Id in bytes.
    pbServerPid : License Server's PID
    cbServerPid : size of License Server's PID in bytes
    pbServerSPK : License Server's SPK.
    cbServerSPK : size of License Server's SPK in bytes.
    pdwLsaServerId : Pointer to DWORD to receive size of TLSLSASERVERID.
    pLsaServerId : PPointer to TLSLSASERVERID

Returns:


Note:

    Internal Routine.

--*/

{
    DWORD dwStatus = ERROR_SUCCESS;
    DWORD dwOffset = offsetof(TLSLSASERVERID, pbVariableStart);

    PBYTE pbEncodedExt = NULL;
    DWORD cbEncodedExt = 0;

    CERT_EXTENSIONS cert_extensions;

    if( pbServerSPK != NULL && 
        cbServerSPK != 0 && 
        pCertExtensions != NULL &&
        dwNumCertExtensions != 0 )
    {
        cert_extensions.cExtension = dwNumCertExtensions;
        cert_extensions.rgExtension = pCertExtensions;
    
        //
        // encode cert. extension
        //
        dwStatus = TLSCryptEncodeObject(
                                    X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
                                    szOID_CERT_EXTENSIONS,
                                    &cert_extensions,
                                    &pbEncodedExt,
                                    &cbEncodedExt
                                );
                    
        if(dwStatus != ERROR_SUCCESS)
        {
            return dwStatus;
        }
    }

    *pdwLsaServerId = sizeof(TLSLSASERVERID) + 
                      cbServerUniqueId + 
                      cbServerPid + 
                      cbServerSPK +
                      cbEncodedExt;
 
    *ppLsaServerId = (PTLSLSASERVERID)AllocateMemory(*pdwLsaServerId);
    if(*ppLsaServerId != NULL)
    {
        (*ppLsaServerId)->dwVersion = TLSERVER_SERVER_ID_VERSION;
        (*ppLsaServerId)->dwUniqueId = 0;
        (*ppLsaServerId)->dwServerPid = 0;
        (*ppLsaServerId)->dwServerSPK = 0;
        (*ppLsaServerId)->dwExtensions = 0;

        if(pbServerUniqueId && cbServerUniqueId)
        {
            (*ppLsaServerId)->dwUniqueId = cbServerUniqueId;

            memcpy(
                    (PBYTE)(*ppLsaServerId) + dwOffset,
                    pbServerUniqueId,
                    cbServerUniqueId
                );
        }

        if(pbServerPid && cbServerPid)
        {
            (*ppLsaServerId)->dwServerPid = cbServerPid;

            memcpy(
                    (PBYTE)(*ppLsaServerId) + dwOffset + cbServerUniqueId,
                    pbServerPid,
                    cbServerPid
                );
        }

        if(pbServerSPK && cbServerSPK)
        {
            (*ppLsaServerId)->dwServerSPK = cbServerSPK;

            memcpy(
                    (PBYTE)(*ppLsaServerId) + dwOffset + cbServerUniqueId + cbServerPid,
                    pbServerSPK,
                    cbServerSPK
                );
        }

        if(pbEncodedExt && cbEncodedExt)
        {
            (*ppLsaServerId)->dwExtensions = cbEncodedExt;

            memcpy(
                    (PBYTE)(*ppLsaServerId) + dwOffset + cbServerUniqueId + cbServerPid + cbServerSPK,
                    pbEncodedExt,
                    cbEncodedExt
                );
        }
            
    }
    else
    {
        dwStatus = GetLastError();
    }

    FreeMemory(pbEncodedExt);
  
    return dwStatus;
}

//////////////////////////////////////////////////////////////////

DWORD
LsaServerIdToServerIds(
    IN PTLSLSASERVERID pLsaServerId,
    IN DWORD dwLsaServerId,
    OUT PBYTE* ppbServerUniqueId,
    OUT PDWORD pcbServerUniqueId,
    OUT PBYTE* ppbServerPid,
    OUT PDWORD pcbServerPid,
    OUT PBYTE* ppbServerSPK,
    OUT PDWORD pcbServerSPK,
    OUT PCERT_EXTENSIONS* pCertExtensions,
    OUT PDWORD pcbCertExtensions
    )

/*++

Abstract:

    Reverse of ServerIdsToLsaServerId()

--*/

{
    DWORD dwStatus = ERROR_SUCCESS;
    DWORD dwSize = 0;
    PBYTE pbUniqueId = NULL;
    PBYTE pbPid = NULL;
    PBYTE pbSPK = NULL;
    DWORD dwOffset = offsetof(TLSLSASERVERID, pbVariableStart);

    DWORD cbCertExt = 0;
    PCERT_EXTENSIONS pCertExt = NULL;


    //
    // verify input.
    //
    if(dwLsaServerId == 0 || pLsaServerId == NULL)
    {
        dwStatus = ERROR_INVALID_PARAMETER;
        goto cleanup;
    }

    if(pLsaServerId->dwVersion != TLSERVER_SERVER_ID_VERSION)
    {
        TLSLogErrorEvent(TLS_E_INCOMPATIBLELSAVERSION);
        goto cleanup;
    }

    dwSize = sizeof(TLSLSASERVERID) + 
             pLsaServerId->dwUniqueId + 
             pLsaServerId->dwServerPid + 
             pLsaServerId->dwServerSPK +
             pLsaServerId->dwExtensions;

    if(dwSize != dwLsaServerId)
    {
        dwStatus = ERROR_INVALID_PARAMETER;
        goto cleanup;
    }

    if(pLsaServerId->dwVersion != TLSERVER_SERVER_ID_VERSION)
    {
        dwStatus = ERROR_INVALID_PARAMETER;
        goto cleanup;
    }

    *pcbServerUniqueId = pLsaServerId->dwUniqueId;
    *pcbServerPid = pLsaServerId->dwServerPid;
    *pcbServerSPK = pLsaServerId->dwServerSPK;

    if(pLsaServerId->dwUniqueId != 0)
    {
        pbUniqueId = (PBYTE)AllocateMemory(pLsaServerId->dwUniqueId);
        if(pbUniqueId == NULL)
        {
            dwStatus = GetLastError();
            goto cleanup;
        }
    }

    if(pLsaServerId->dwServerPid != 0)
    {
        pbPid = (PBYTE)AllocateMemory(pLsaServerId->dwServerPid);
        if(pbPid == NULL)
        {
            dwStatus = GetLastError();
            goto cleanup;
        }
    }

    if(pLsaServerId->dwServerSPK != 0)
    {
        pbSPK = (PBYTE)AllocateMemory(pLsaServerId->dwServerSPK);
        if(pbSPK == NULL)
        {
            dwStatus = GetLastError();
            goto cleanup;
        }
    }

    if(pLsaServerId->dwUniqueId)
    {
        memcpy(
                pbUniqueId,
                (PBYTE)pLsaServerId + dwOffset,
                pLsaServerId->dwUniqueId
            );
    }

    if(pLsaServerId->dwServerPid)
    {
        memcpy(
                pbPid,
                (PBYTE)pLsaServerId + dwOffset + pLsaServerId->dwUniqueId,
                pLsaServerId->dwServerPid
            );
    }

    if(pLsaServerId->dwServerSPK)
    {
        memcpy(
                pbSPK,
                (PBYTE)pLsaServerId + dwOffset + pLsaServerId->dwUniqueId + pLsaServerId->dwServerPid,
                pLsaServerId->dwServerSPK
            );
    }

    if(pLsaServerId->dwExtensions)
    {
        PBYTE pbEncodedCert;
        DWORD cbEncodedCert;

        pbEncodedCert = (PBYTE)pLsaServerId + 
                        dwOffset + 
                        pLsaServerId->dwUniqueId + 
                        pLsaServerId->dwServerPid +
                        pLsaServerId->dwServerSPK;

        cbEncodedCert = pLsaServerId->dwExtensions;

        dwStatus = LSCryptDecodeObject(
                                    X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
                                    szOID_CERT_EXTENSIONS,
                                    pbEncodedCert,
                                    cbEncodedCert,
                                    0,
                                    (VOID **)&pCertExt,
                                    &cbCertExt
                                );
    }


cleanup:

    if(dwStatus != ERROR_SUCCESS)    
    {
        FreeMemory(pCertExt);
        FreeMemory(pbUniqueId);
        FreeMemory(pbPid);
        FreeMemory(pbSPK);
    }
    else
    {
        *pCertExtensions = pCertExt;
        *pcbCertExtensions = cbCertExt;
        *ppbServerUniqueId = pbUniqueId;
        *ppbServerPid = pbPid;
        *ppbServerSPK = pbSPK;
    }

    return dwStatus;
}
 
//////////////////////////////////////////////////////////////////

DWORD
LoadNtPidFromRegistry(
    OUT LPTSTR* ppszNtPid
    )

/*++

Abstract:

    Load the NT Product ID from registry key.


Parameters:

    pdwNtPidSize : Pointer to DWORD to receive size of data return.
    ppbNtPid : Pointer to PBYTE to receive return data pointer.

Return:


Note:

    use AllocateMemory() macro to allocate memory.
--*/

{
    DWORD dwPidSize=0;
    HKEY hKey = NULL;
    DWORD dwStatus = ERROR_SUCCESS;

    if(ppszNtPid == NULL)
    {
        SetLastError(dwStatus = ERROR_INVALID_PARAMETER);
        goto cleanup;
    }

    *ppszNtPid = NULL;

    dwStatus = RegOpenKeyEx(
                        HKEY_LOCAL_MACHINE,
                        NTPID_REGISTRY,
                        0,
                        KEY_READ,   // read only
                        &hKey
                    );

    if(dwStatus != ERROR_SUCCESS)
    {
        //
        // If this registry key does not exist, 
        // invalid NT installation, if we can't access it, 
        // we are in big trouble.
        //
        goto cleanup;
    }

    dwStatus = RegQueryValueEx(
                        hKey,
                        NTPID_VALUE,
                        NULL,
                        NULL,
                        NULL,
                        &dwPidSize
                    );

    if(dwStatus != ERROR_MORE_DATA && dwStatus != ERROR_SUCCESS)
    {
        // Big trouble.
        goto cleanup;
    }

    *ppszNtPid = (LPTSTR)AllocateMemory(dwPidSize + sizeof(TCHAR));
    if(*ppszNtPid == NULL)
    {
        dwStatus = GetLastError();
        goto cleanup;
    }

    dwStatus = RegQueryValueEx(
                            hKey,
                            NTPID_VALUE,
                            NULL,
                            NULL,
                            (PBYTE)*ppszNtPid,
                            &dwPidSize
                        );

cleanup:

    if(hKey != NULL)
    {
        RegCloseKey(hKey);    
    }

    if(dwStatus != NULL)
    {
        FreeMemory(*ppszNtPid);
    }

    return dwStatus;
}

//////////////////////////////////////////////////////////////////

DWORD
GenerateRandomNumber(
    IN  DWORD  Seed
    )

/*++

Routine Description:

    Generate a random number.

Arguments:

    Seed - Seed for random-number generator.

Return Value:

    Returns a random number.

--*/
{
    ULONG ulSeed = Seed;

    // Randomize the seed some more

    ulSeed = RtlRandomEx(&ulSeed);

    return RtlRandomEx(&ulSeed);
}

//////////////////////////////////////////////////////////////////

DWORD
TLSGeneratePid(
    OUT LPTSTR* pszTlsPid,
    OUT PDWORD  pcbTlsPid,
    OUT LPTSTR* pszTlsUniqueId,
    OUT PDWORD  pcbTlsUniqueId
    )

/*++

Abstract:

    Generate a PID for License Server, License Server PID is composed of 
    NT PID (from registry) with last 5 digit being randomly generated number.

Parameter:

    ppbTlsPid : Pointer to PBYTE that receive the License Server PID.
    pcbTlsPid : Pointer to DWORD to receive size of License Server PID.
    ppbTlsUniqueId : Pointer to PBYTE to receive the License Server Unique Id.
    pcbTlsUniqueId : Pointer to DWORD to receive size of License Server's unique ID.

Returns:

    Error code if can't access NT system PID.

Note:

    refer to PID20 format for detail, License Server treat PID as binary data.

--*/

{
    DWORD dwStatus;
    DWORD dwRandomNumber;
    DWORD dwNtPid;
    LPTSTR pszNtPid = NULL;
    LPTSTR pszPid20Random = NULL;
    int index;
    DWORD dwMod = 1;

    if( pszTlsPid == NULL || pcbTlsPid == NULL ||
        pszTlsUniqueId == NULL || pcbTlsUniqueId == NULL )
    {
        dwStatus = ERROR_INVALID_PARAMETER;
        goto cleanup;
    }

    //
    // Load NT system PID
    //
    dwStatus = LoadNtPidFromRegistry(
                            &pszNtPid
                        );

    if(dwStatus != ERROR_SUCCESS)
    {
        goto cleanup;
    }

    //
    // transform OEM format to non-OEM format
    //
    if (memcmp(pszNtPid+NTPID_OEM_OFFSET,NTPID_OEM,NTPID_OEM_LENGTH) == 0)
    {
        memcpy(pszNtPid+NTPID_OEM_OFFSET,
               pszNtPid+NTPID_OEM_CHANNELID_OFFSET,
               NTPID_OEM_LENGTH);
    }

    //
    // overwrite digits 11 to 17
    //

    pszPid20Random = (LPTSTR)AllocateMemory(
                 (max(TLSUNIQUEID_SIZE,TLSUNIQUEID_SIZE_2) + 1) * sizeof(TCHAR)
                 );

    if(pszPid20Random == NULL)
    {
        dwStatus = GetLastError();
        goto cleanup;
    }
    
    for(index = 0; index < TLSUNIQUEID_SIZE_2; index++)
    {
        dwMod *= 10;
    }

    dwRandomNumber = GenerateRandomNumber( GetCurrentThreadId() + GetTickCount() );

    swprintf( 
            pszPid20Random, 
            _TEXT("%0*u"), 
            TLSUNIQUEID_SIZE_2,
            dwRandomNumber % dwMod
        );
        
    memcpy(
            pszNtPid + TLSUNIQUEID_OFFSET_2,
            pszPid20Random,
            TLSUNIQUEID_SIZE_2 * sizeof(TCHAR)
        );

    //
    // overwrite last 3 digits
    //

    dwMod = 1;

    for(index = 0; index < TLSUNIQUEID_SIZE; index++)
    {
        dwMod *= 10;
    }

    dwRandomNumber = GenerateRandomNumber( GetCurrentThreadId() + GetTickCount() );

    swprintf( 
            pszPid20Random, 
            _TEXT("%0*u"), 
            TLSUNIQUEID_SIZE,
            dwRandomNumber % dwMod
        );
        
    lstrcpy(
            pszNtPid + (lstrlen(pszNtPid) - TLSUNIQUEID_SIZE),
            pszPid20Random
        );    

    DWORD dwSum = 0;
    LPTSTR lpszStr = NULL ;
    lpszStr= new TCHAR[7];

    // Copy 6 numbers from the third group of the product ID

    _tcsncpy(lpszStr, &pszNtPid[10], 6);
    lpszStr[6] = L'\0';

    DWORD dwOrigNum = _ttol(lpszStr);

    // Compute the sum of the 6 numbers and use the 7th digit as checksum for
    // rendering it divisible by 7.

    for(index = 10; index < 16; index++)
    {
        dwSum += (dwOrigNum % 10 ) ;
        dwOrigNum /= 10;
    }    
    
    dwSum %= 7;
    int iNum = 7-dwSum;
    TCHAR tchar[2];
    _itot(iNum, tchar, 10);
    pszNtPid[16] = tchar[0];

    if(lpszStr)
        delete[] lpszStr;
        
    *pszTlsPid = pszNtPid;
    *pcbTlsPid = (lstrlen(pszNtPid) + 1) * sizeof(TCHAR);
    *pszTlsUniqueId = pszPid20Random;
    *pcbTlsUniqueId = (lstrlen(pszPid20Random) + 1) * sizeof(TCHAR);

cleanup:

    if(dwStatus != ERROR_SUCCESS)
    {
        FreeMemory(pszNtPid);
        FreeMemory(pszPid20Random);
    }
        
    return dwStatus;            
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\license\tlserver\server\pch.cpp ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996-1997
//
// File:        pch.cpp
//
// Contents:    Hydra License Server Precompiled Header
//
//---------------------------------------------------------------------------

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <windows.h>
#include <tchar.h>
#include <stdio.h>
#include <stdarg.h>
#include <stdlib.h>
#include <process.h>
#include <rpc.h>
#include <shellapi.h>
#include <wincrypt.h>
#include <new.h>
#include <eh.h>
#include "resource.h"

//
// include for all license project
//
#include "license.h"
#include "certutil.h"



//
// Backward compatible
//
#include "hydrals.h"

#include "utils.h"
#include "locks.h"
#include "hpool.h"


//
// TLSDb
//
#include "JBDef.h"
#include "JetBlue.h"
#include "TLSDb.h"

#include "backup.h"
#include "KPDesc.h"
#include "Licensed.h"
#include "licpack.h"
#include "version.h"
#include "workitem.h"

// 
// Current RPC interface
//
#include "tlsrpc.h"
#include "tlsdef.h"
#include "tlsapi.h"
#include "tlsapip.h"
#include "tlspol.h"

//
//
#include "messages.h"

#include "tlsassrt.h"
#include "trust.h"
#include "svcrole.h"
#include "secstore.h"
#include "common.h"
#include "lscommon.h"

#include "Cryptkey.h"
#include "licekpak.h"
#include "base64.h"
#include "licecert.h"



#pragma hdrstop
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\license\tlserver\server\policy.cpp ===
//+--------------------------------------------------------------------------
//
// Copyright (c) 1997-1999 Microsoft Corporation
//
// File:       policy.cpp 
//
// Contents:   Loading product policy module 
//
// History:     
//
//---------------------------------------------------------------------------
#include "pch.cpp"
#include "utils.h"
#include <windows.h>
#include <wincrypt.h>
#include <assert.h>
#include "srvdef.h"
#include "server.h"
#include "policy.h"
#define STRSAFE_NO_DEPRECATE
#include "strsafe.h"

CTLSPolicyMgr PolicyMgr;
TCHAR g_szDefPolCompanyName[LSERVER_MAX_STRING_SIZE+1];
TCHAR g_szDefProductId[LSERVER_MAX_STRING_SIZE+1];


//-------------------------------------------------------------
//
// Internal routine
//

HINSTANCE
LoadPolicyModule(
    IN LPCTSTR pszDllName,
    OUT PDWORD pdwBufferSize,
    OUT LPTSTR pszBuffer
    )
/*++

Abstract:

    Load Policy module

Parameters:

    pszDll : Name of the DLL.
    pdwBufferSize : 
    pszBuffer

Returns:    

--*/
{
    TCHAR szDllFullPath[MAX_PATH+1];
    DWORD dwErrCode = ERROR_SUCCESS;
    HINSTANCE hPolicyModule = NULL;

    //
    // expand the environment string
    //
    memset(szDllFullPath, 0, sizeof(szDllFullPath));
    dwErrCode = ExpandEnvironmentStrings(
                        pszDllName,
                        szDllFullPath,
                        sizeof(szDllFullPath)/sizeof(szDllFullPath[0])
                    );

    if(dwErrCode == 0 && pszBuffer && pdwBufferSize && *pdwBufferSize)
    {
        _tcsncpy(pszBuffer, szDllFullPath, *pdwBufferSize);
        *pdwBufferSize = _tcslen(szDllFullPath);
    }

    dwErrCode = ERROR_SUCCESS;

    hPolicyModule = LoadLibrary(szDllFullPath);
    if(hPolicyModule == NULL) 
    {
        dwErrCode = GetLastError();
        TLSLogEvent(
                EVENTLOG_ERROR_TYPE, 
                TLS_E_LOADPOLICY,
                TLS_E_LOADPOLICYMODULE,
                pszDllName,
                dwErrCode
            );
    }

    return hPolicyModule;
}


//-------------------------------------------------------------
typedef struct _RegEnumHandle {
    DWORD dwKeyIndex;
    HKEY hKey;
} RegEnumHandle;

//-------------------------------------------------------------
DWORD
RegEnumBegin(
    IN HKEY hRoot,
    IN LPCTSTR pszSubKey,
    OUT RegEnumHandle* phEnum
    )
/*++

++*/
{
    DWORD dwStatus;
    dwStatus = RegOpenKeyEx(
                        hRoot,
                        pszSubKey,
                        0,
                        KEY_ALL_ACCESS,
                        &(phEnum->hKey)
                    );

    phEnum->dwKeyIndex = 0;
    return dwStatus;
}

//-------------------------------------------------------------
DWORD
RegEnumNext(
    RegEnumHandle* phEnum,
    LPTSTR lpName,
    LPDWORD lpcbName
    )
/*++

++*/
{
    DWORD dwStatus;
    FILETIME ftLastWriteTiem;

    dwStatus = RegEnumKeyEx(
                        phEnum->hKey,
                        phEnum->dwKeyIndex,
                        lpName,
                        lpcbName,
                        0,
                        NULL,
                        NULL,
                        &ftLastWriteTiem
                    );

    (phEnum->dwKeyIndex)++;
    return dwStatus;
}

//-------------------------------------------------------------
DWORD
RegEnumEnd(
    RegEnumHandle* phEnum
    )
/*++

++*/
{
    if(phEnum->hKey != NULL)
        RegCloseKey(phEnum->hKey);

    phEnum->dwKeyIndex = 0;

    return ERROR_SUCCESS;
}

//-------------------------------------------------------------
DWORD
ServiceInitPolicyModule(
    void
    )
/*++

++*/
{
    return PolicyMgr.InitProductPolicyModule();
}   

//------------------------------------------------------------
DWORD
ServiceLoadPolicyModule(
    IN HKEY hKey,
    IN LPCTSTR pszCompanyName,
    IN LPCTSTR pszProductId,
    IN LPCTSTR pszDllRegValue,
    IN LPCTSTR pszDllFlagValue
    )
/*++

++*/
{
    DWORD dwStatus;
    DWORD dwSize;
    TCHAR szDllName[MAX_PATH+1];
    DWORD dwDllFlag; 
    UINT uiNum = 0;
    TCHAR szName[] = _TEXT("\\tls236.dll");

    dwSize = sizeof(dwDllFlag);
    dwStatus = RegQueryValueEx(
                        hKey,
                        pszDllFlagValue,
                        NULL,
                        NULL,
                        (PBYTE)&dwDllFlag,
                        &dwSize
                    );
    if(dwStatus != ERROR_SUCCESS)
        dwDllFlag = POLICY_DENY_ALL_REQUEST; // (pszProductId == NULL) ? POLICY_DENY_ALL_REQUEST : POLICY_USE_DEFAULT;

    uiNum = GetSystemDirectory( ( LPTSTR )szDllName, MAX_PATH );

    if( uiNum != 0 && MAX_PATH > (uiNum + _tcslen(szName)))
    {
        _tcscat(szDllName, szName);

        dwStatus = ERROR_SUCCESS;
    }
    else
    {
        dwStatus = E_FAIL;
    }

    if(dwStatus == ERROR_SUCCESS)
    {
        dwStatus = PolicyMgr.AddPolicyModule(
                                        FALSE,
                                        pszCompanyName,
                                        pszProductId,
                                        szDllName,
                                        dwDllFlag
                                    );
        if(dwStatus != ERROR_SUCCESS)
        {
            LPCTSTR pString[1];

            pString[0] = szDllName;

            //
            // log event - use default or deny all request.
            //
            TLSLogEventString(
                    EVENTLOG_WARNING_TYPE, 
                    (dwDllFlag == POLICY_DENY_ALL_REQUEST) ? TLS_W_LOADPOLICYMODULEDENYALLREQUEST : TLS_W_LOADPOLICYMODULEUSEDEFAULT,
                    1,
                    pString
                );
        }
    }
    else if(pszProductId != NULL)
    {
        //
        // Load error indicate missing registry value
        //
        TLSLogEvent(
                EVENTLOG_ERROR_TYPE, 
                TLS_E_LOADPOLICY,
                TLS_E_NOPOLICYMODULE, 
                pszProductId,
                pszCompanyName
            );  
    }                 
    
    return dwStatus;
}

//-------------------------------------------------------------
DWORD
ServiceLoadAllPolicyModule(
    IN HKEY hRoot,
    IN LPCTSTR pszSubkey
    )
/*++


++*/
{
    DWORD dwStatus;
    RegEnumHandle hCompany;
    RegEnumHandle hProductId;
    PolicyModule PolModule;
    DWORD dwSize;

    //
    // Open registry key 
    // Software\microsoft\termsrvlicensing\policy
    //
    dwStatus = RegEnumBegin(
                        hRoot,
                        pszSubkey,
                        &hCompany
                    );


    while(dwStatus == ERROR_SUCCESS)
    {
        //
        // Enumerater all key (company name) under 
        // Software\microsoft\termsrvlicensing\policy
        //
        dwSize = sizeof(PolModule.m_szCompanyName)/sizeof(PolModule.m_szCompanyName[0]);
        dwStatus = RegEnumNext(
                            &hCompany,
                            PolModule.m_szCompanyName,
                            &dwSize
                        );

        if(dwStatus != ERROR_SUCCESS)
            break;

        //
        // ignore error here
        //

        //
        // Enumerate all product under company
        //
        dwStatus = RegEnumBegin(
                            hCompany.hKey,
                            PolModule.m_szCompanyName,
                            &hProductId
                        );

        if(dwStatus == ERROR_SUCCESS)
        {
            //
            // Load company wide policy module
            //
            ServiceLoadPolicyModule(
                                hProductId.hKey,
                                PolModule.m_szCompanyName,
                                NULL,
                                LSERVER_POLICY_DLLPATH,
                                LSERVER_POLICY_DLLFLAG
                            );
        }

        while(dwStatus == ERROR_SUCCESS)
        {
            dwSize = sizeof(PolModule.m_szProductId)/sizeof(PolModule.m_szProductId[0]);
            dwStatus = RegEnumNext(
                                &hProductId,
                                PolModule.m_szProductId,
                                &dwSize
                            );


            if(dwStatus == ERROR_SUCCESS)
            {
                HKEY hKey;

                dwStatus = RegOpenKeyEx(
                                    hProductId.hKey,
                                    PolModule.m_szProductId,
                                    0,
                                    KEY_ALL_ACCESS,
                                    &hKey
                                );

                if(dwStatus != ERROR_SUCCESS)
                    continue;

                //
                // Open product registry key
                //
                ServiceLoadPolicyModule(
                                hKey,
                                PolModule.m_szCompanyName,
                                PolModule.m_szProductId,
                                LSERVER_POLICY_DLLPATH,
                                LSERVER_POLICY_DLLFLAG
                            );

                //
                // ignore any error code here
                //

                RegCloseKey(hKey);
            }
        }

        dwStatus = RegEnumEnd(&hProductId);
    }

    dwStatus = RegEnumEnd(&hCompany);
 

    return dwStatus;   
}    


//-------------------------------------------------------

void
ReleasePolicyModule(
    CTLSPolicy* ptr
    )
/*++

++*/
{
    PolicyMgr.ReleaseProductPolicyModule(ptr);
}    


//-------------------------------------------------------
BOOL
TranslateCHCodeToTlsCode(
    IN LPCTSTR pszCompanyName,
    IN LPCTSTR pszCHProductId,
    IN LPTSTR pszTlsProductId,
    IN OUT PDWORD pdwBufferSize
    )
/*++


--*/
{
    return PolicyMgr.TranslateCHCodeToTlsCode(
                                        pszCompanyName,
                                        pszCHProductId,
                                        pszTlsProductId,
                                        pdwBufferSize
                                    );
}
    
//-------------------------------------------------------
CTLSPolicy*
AcquirePolicyModule(
    IN LPCTSTR pszCompanyName,
    IN LPCTSTR pszProductId,
    IN BOOL bUseProductPolicy
    )
/*++

Abstract:

    Acquire a policy module base on company name and product code.

Parameter:

    pszCompanyName : Company Name.
    pszProductId : Product Code.
    bUseProductPolicy : TRUE if only exact product policy module, FALSE uses
                        default policy module if can't find a policy module for 
                        product.

Return:

    Pointer to CTLSPolicy or NULL if not found.


Remark:

    Default behavior.

++*/
{
    CTLSPolicy* ptr;


    ptr = PolicyMgr.AcquireProductPolicyModule(
                            pszCompanyName,
                            pszProductId
                        );

    if(ptr == NULL && bUseProductPolicy == FALSE)
    {
        ptr = PolicyMgr.AcquireProductPolicyModule(
                                pszCompanyName,
                                NULL
                            );
    }

    if(ptr == NULL && bUseProductPolicy == FALSE)
    {
        ptr = PolicyMgr.AcquireProductPolicyModule(
                                g_szDefPolCompanyName,
                                g_szDefProductId
                            );
    }


    if(ptr == NULL)
    {
        TLSLogEvent(
                EVENTLOG_WARNING_TYPE,
                TLS_E_LOADPOLICY,
                TLS_E_NOPOLICYMODULE,
                pszCompanyName,
                pszProductId
            );
        
        SetLastError(TLS_E_NOPOLICYMODULE);
    }

    return ptr;
}


/////////////////////////////////////////////////////////
//
// Class CTLSPolicyMgr 
//
/////////////////////////////////////////////////////////
CTLSPolicyMgr::CTLSPolicyMgr()
/*++

++*/
{
    CTLSPolicy* ptr;
    PolicyModule pm;

    //
    // Load default name for default policy module
    //
    LoadResourceString(
                IDS_DEFAULT_POLICY,
                g_szDefPolCompanyName,
                sizeof(g_szDefPolCompanyName) / sizeof(g_szDefPolCompanyName[0]) - 1
            );

    LoadResourceString(
                IDS_DEFAULT_POLICY,
                g_szDefProductId,
                sizeof(g_szDefProductId) / sizeof(g_szDefProductId[0]) - 1
            );


    lstrcpy(pm.m_szCompanyName, g_szDefPolCompanyName);
    lstrcpy(pm.m_szProductId, g_szDefProductId);
                
    //
    // Create a default policy module to handle all cases...
    //
    ptr = new CTLSPolicy;
    ptr->CreatePolicy(
                (HMODULE) INVALID_HANDLE_VALUE,
                g_szDefPolCompanyName,
                g_szDefProductId,
                PMReturnLicense,
                PMLicenseUpgrade,
                PMLicenseRequest,
                PMUnloadProduct,
                PMInitializeProduct,
                PMRegisterLicensePack
            );

    //m_ProductPolicyModuleRWLock.Acquire(WRITER_LOCK);

    m_ProductPolicyModule[pm] = ptr;

    //m_ProductPolicyModuleRWLock.Release(WRITER_LOCK);
    //m_Handles.insert( 
    //        pair<PolicyModule, CTLSPolicy*>(pm, ptr) 
    //    );
}    

//-------------------------------------------------------
CTLSPolicyMgr::~CTLSPolicyMgr()
/*++

++*/
{
    m_ProductPolicyModuleRWLock.Acquire(WRITER_LOCK);

    for( PMProductPolicyMapType::iterator it = m_ProductPolicyModule.begin(); 
         it != m_ProductPolicyModule.end(); 
         it++ )   
    {
        CTLSPolicy* ptr = (CTLSPolicy*) (*it).second;
        delete ptr;
    }

    m_ProductPolicyModule.erase(m_ProductPolicyModule.begin(), m_ProductPolicyModule.end());
    m_ProductPolicyModuleRWLock.Release(WRITER_LOCK);


    m_LoadedPolicyRWLock.Acquire(WRITER_LOCK);
    for(PMLoadedModuleMapType::iterator loadedit = m_LoadedPolicy.begin();
        loadedit != m_LoadedPolicy.end();
        loadedit++ )
    {
        HMODULE hModule = (HMODULE) (*loadedit).second;
        if(hModule != NULL)
        {
            UnloadPolicyModule(hModule);
            FreeLibrary(hModule);
        }
    }

    m_LoadedPolicy.erase(m_LoadedPolicy.begin(), m_LoadedPolicy.end());
    m_LoadedPolicyRWLock.Release(WRITER_LOCK);

    m_ProductTranslationRWLock.Acquire(WRITER_LOCK);
    m_ProductTranslation.erase(m_ProductTranslation.begin(), m_ProductTranslation.end());
    m_ProductTranslationRWLock.Release(WRITER_LOCK);
}

//-------------------------------------------------------
HMODULE
CTLSPolicyMgr::LoadPolicyModule(
    LPCTSTR pszCompanyName,
    LPCTSTR pszProductCode,
    LPCTSTR pszDllName
    )
/*++

--*/
{
    HMODULE hModule;
    PMLoadedModuleMapType::iterator it;
    PolicyModule pm;
    
    memset(&pm, 0, sizeof(pm));

    if(pszCompanyName)
    {
        _tcscpy(pm.m_szCompanyName, pszCompanyName);
    }

    if(pszProductCode)
    {
        _tcscpy(pm.m_szProductId, pszProductCode);
    }

    m_LoadedPolicyRWLock.Acquire(WRITER_LOCK);

    it = m_LoadedPolicy.find( pm );

    if(it != m_LoadedPolicy.end())
    {
        hModule = (HMODULE) (*it).second;
    }
    else
    {
        hModule = ::LoadPolicyModule(
                                pszDllName,
                                NULL,
                                NULL
                            );

        if(hModule != NULL)
        {
            m_LoadedPolicy[pm] = hModule;
        }
    }

    m_LoadedPolicyRWLock.Release(WRITER_LOCK);

    return hModule;
}

//-------------------------------------------------------
DWORD
CTLSPolicyMgr::UnloadPolicyModule(
    HMODULE hModule
    )
/*++

--*/
{
    DWORD dwStatus = ERROR_SUCCESS;
    TLSPMTerminate pfnTerminate;


    if(hModule != NULL)
    {
        pfnTerminate = (TLSPMTerminate) GetProcAddress(
                                    hModule,
                                    TEMINATEPROCNAME
                                );

        if(pfnTerminate != NULL)
        {
            pfnTerminate();
        }
        else
        {
            dwStatus = GetLastError();
        }
    }
    else
    {
        dwStatus = ERROR_INVALID_PARAMETER;
    }

    return dwStatus;
}
    


//-------------------------------------------------------

DWORD
CTLSPolicyMgr::UnloadPolicyModule(
    LPCTSTR pszCompanyName,
    LPCTSTR pszProductCode
    )
/*++

    Not supported yet, need to remove all product policy in m_ProductPolicyModule()
    then unload DLL

--*/
{
    return ERROR_SUCCESS;
}

//-------------------------------------------------------
DWORD
CTLSPolicyMgr::InitProductPolicyModule()
/*++

++*/
{
    DWORD dwCount = 0;

    m_ProductPolicyModuleRWLock.Acquire(WRITER_LOCK);

    for( PMProductPolicyMapType::iterator it = m_ProductPolicyModule.begin(); 
         it != m_ProductPolicyModule.end(); 
         it++ )   
    {
        CTLSPolicy* ptr = (CTLSPolicy*) (*it).second;
        if(ptr->InitializePolicyModule() == ERROR_SUCCESS)
        {
            dwCount++;
        }
    }

    m_ProductPolicyModuleRWLock.Release(WRITER_LOCK);

    return dwCount;
}

//-------------------------------------------------------
CTLSPolicyMgr::PMProductTransationMapType::iterator
CTLSPolicyMgr::FindProductTransation(
    LPCTSTR pszCompanyName,
    LPCTSTR pszCHProductCode
    )
/*++

--*/
{
    PolicyModule pm;
    PMProductTransationMapType::iterator it;

    memset(&pm, 0, sizeof(pm));
    if(pszCompanyName)
    {
        StringCchCopyN(   
                pm.m_szCompanyName, 
                sizeof(pm.m_szCompanyName)/sizeof(pm.m_szCompanyName[0]),
                pszCompanyName, 
                sizeof(pm.m_szCompanyName)/sizeof(pm.m_szCompanyName[0])
            );        
    }

    if(pszCHProductCode)
    {
        StringCchCopyN(
                pm.m_szProductId,
                sizeof(pm.m_szProductId)/sizeof(pm.m_szProductId[0]),
                pszCHProductCode,
                sizeof(pm.m_szProductId)/sizeof(pm.m_szProductId[0])
            );        
    }

    it = m_ProductTranslation.find( pm );
    return it;
}

//-------------------------------------------------------
BOOL
CTLSPolicyMgr::TranslateCHCodeToTlsCode(
    LPCTSTR pszCompanyName,
    LPCTSTR pszCHCode,
    LPTSTR pszTlsProductCode,
    PDWORD pdwBufferSize
    )
/*++


--*/
{
    PMProductTransationMapType::iterator it;
    DWORD dwBufSize = *pdwBufferSize;

    SetLastError(ERROR_SUCCESS);

    m_ProductTranslationRWLock.Acquire(READER_LOCK);

    it = FindProductTransation(
                        pszCompanyName, 
                        pszCHCode
                    );

    if(it == m_ProductTranslation.end())
    {
        SetLastError(ERROR_INVALID_PARAMETER);
    }
    else
    {
        lstrcpyn(
                pszTlsProductCode,
                (*it).second.m_szProductId,
                dwBufSize
            );

        *pdwBufferSize = lstrlen((*it).second.m_szProductId);
        if(*pdwBufferSize >= dwBufSize)
        {
            SetLastError(ERROR_INSUFFICIENT_BUFFER);
        }
    }

    m_ProductTranslationRWLock.Release(READER_LOCK);

    return GetLastError() == ERROR_SUCCESS;
}

//-------------------------------------------------------
void
CTLSPolicyMgr::InsertProductTransation(
    LPCTSTR pszCompanyName,
    LPCTSTR pszCHProductCode,
    LPCTSTR pszTLSProductCode
    )
/*++

    List must be locked before entering this routine.

--*/
{
    PolicyModule key;
    PolicyModule value;

    memset(&key, 0, sizeof(key));
    memset(&value, 0, sizeof(value));

    if(pszCompanyName)
    {                
        StringCchCopyN(
                key.m_szCompanyName,
                sizeof(key.m_szCompanyName)/sizeof(key.m_szCompanyName[0]),
                pszCompanyName,
                sizeof(key.m_szCompanyName)/sizeof(key.m_szCompanyName[0])
            );

        StringCchCopyN(
                value.m_szCompanyName,
                sizeof(value.m_szCompanyName)/sizeof(value.m_szCompanyName[0]),
                pszCompanyName,
                sizeof(value.m_szCompanyName)/sizeof(value.m_szCompanyName[0])
            );
    }

    if(pszCHProductCode)
    {        
        StringCchCopyN(
                key.m_szProductId,
                sizeof(key.m_szProductId)/sizeof(key.m_szProductId[0]),
                pszCHProductCode,
                sizeof(key.m_szProductId)/sizeof(key.m_szProductId[0])
            );
    }

    if(pszTLSProductCode)
    {     
        StringCchCopyN(
                value.m_szProductId,
                sizeof(key.m_szProductId)/sizeof(key.m_szProductId[0]),
                pszTLSProductCode,
                sizeof(key.m_szProductId)/sizeof(key.m_szProductId[0])
            );        
    }

    //
    // Replace if already exists.
    //
    m_ProductTranslation[key] = value;
    
    return;
}


//-------------------------------------------------------
CTLSPolicyMgr::PMProductPolicyMapType::iterator 
CTLSPolicyMgr::FindProductPolicyModule(
    LPCTSTR pszCompanyName,
    LPCTSTR pszProductId
    )
/*++

    Must acquire reader/writer lock before 
    calling this routine

++*/
{
    PolicyModule pm;
    PMProductPolicyMapType::iterator it;
    CTLSPolicy* ptr=NULL;

    memset(&pm, 0, sizeof(pm));

    if(pszCompanyName)
    {        
        StringCchCopyN(
                pm.m_szCompanyName, 
                sizeof(pm.m_szCompanyName)/sizeof(pm.m_szCompanyName[0]),
                pszCompanyName,
                sizeof(pm.m_szCompanyName)/sizeof(pm.m_szCompanyName[0])
                );        
    }

    if(pszProductId)
    {       
        StringCchCopyN(
                pm.m_szProductId, 
                sizeof(pm.m_szProductId)/sizeof(pm.m_szProductId[0]),
                pszProductId,
                sizeof(pm.m_szProductId)/sizeof(pm.m_szProductId[0])
            );
    }

    it = m_ProductPolicyModule.find( pm );
    return it;
}

//-------------------------------------------------------
DWORD
CTLSPolicyMgr::GetSupportedProduct(
    IN HINSTANCE hPolicyModule,
    IN LPCTSTR pszDllName,
    IN LPCTSTR pszCompanyName,
    IN LPCTSTR pszProductId,
    IN OUT PDWORD pdwNumProducts,
    OUT PPMSUPPORTEDPRODUCT* pSupportedProduct
    )
/*++

Abstract:

    Get list of supported product from policy module

Parameters:

    pszCompanyName : Name of the company in registry
    pszProductId : Name of the product in registry
    pdwNumProducts : Pointer to DWORD, return number of product supported by policy module
    ppszSupportedProduct : Pointer to string array, return number of product supported by policy module.

Return:
     
--*/
{
    TLSPMInitialize pfnPMInitialize = NULL;
    POLICYSTATUS dwPolStatus = POLICY_SUCCESS;
    DWORD dwPolRetCode = ERROR_SUCCESS;

    DWORD dwStatus = ERROR_SUCCESS;
    PPMSUPPORTEDPRODUCT pProductList = NULL;
    DWORD dwIndex;

    *pSupportedProduct = NULL;
    *pdwNumProducts = 0;

    if(hPolicyModule != NULL && pszCompanyName != NULL && pdwNumProducts != NULL && pSupportedProduct != NULL)
    {
        pfnPMInitialize = (TLSPMInitialize) GetProcAddress(
                                            hPolicyModule,
                                            INITIALIZEPROCNAME
                                        );

        if(pfnPMInitialize != NULL)
        {
            dwPolStatus = pfnPMInitialize(
                                        TLS_CURRENT_VERSION,
                                        pszCompanyName,
                                        pszProductId,
                                        pdwNumProducts,
                                        &pProductList,
                                        &dwPolRetCode
                                    );

            if(dwPolStatus != POLICY_SUCCESS)
            {
                TLSLogEvent(
                        EVENTLOG_WARNING_TYPE,
                        TLS_E_LOADPOLICY,
                        TLS_E_POLICYMODULEPMINITALIZZE,
                        pszCompanyName,
                        pszProductId,
                        dwPolRetCode
                    );

                dwStatus = TLS_E_REQUESTDENYPOLICYERROR;
            }
            else if(*pdwNumProducts != 0 && pProductList != NULL)
            {
                *pSupportedProduct = (PPMSUPPORTEDPRODUCT)AllocateMemory(sizeof(PMSUPPORTEDPRODUCT) * (*pdwNumProducts));
                if(*pSupportedProduct != NULL)
                {
                    for(dwIndex = 0; dwIndex < *pdwNumProducts && dwStatus == ERROR_SUCCESS; dwIndex ++)
                    {
                        (*pSupportedProduct)[dwIndex] = pProductList[dwIndex];
                    }
                }
                else
                {
                    dwStatus = ERROR_OUTOFMEMORY;
                }
            }            
        }
        else
        {
            //
            // Policy module must support PMInitialize
            //
            dwStatus = TLS_E_LOADPOLICYMODULE_API;
            TLSLogEvent(
                    EVENTLOG_ERROR_TYPE, 
                    TLS_E_LOADPOLICY,
                    TLS_E_LOADPOLICYMODULE_API,
                    INITIALIZEPROCNAME
                );
        }
    }
    else
    {
        dwStatus = ERROR_INVALID_PARAMETER;
    }

    if(dwStatus != ERROR_SUCCESS)
    {
        if(pSupportedProduct != NULL)
        {
            FreeMemory(pSupportedProduct);
        }
    }

    return dwStatus;
}

//-----------------------------------------------------------
DWORD
CTLSPolicyMgr::InsertProductPolicyModule(
    IN HMODULE hModule,
    IN BOOL bReplace,
    IN LPCTSTR pszCompanyName,
    IN LPCTSTR pszCHProductCode,
    IN LPCTSTR pszTLSProductCode,
    IN LPCTSTR pszDllName,
    IN DWORD dwFlag
    )
/*++

Abstract:

    Insert or replace an existing policy module

Parameters:

    bReplace : TRUE if replace existing policy module, FALSE otherwise.
    pszCompanyName : Name of the company.
    pszProductId : Name of the product.
    pszDllName : Full path to the policy DLL.
    
returns:


++*/
{
    CTLSPolicy* ptr;
    DWORD dwErrCode = ERROR_SUCCESS;

    PMProductPolicyMapType::iterator it;
    PMProductTransationMapType::iterator translation_it;
    

    //
    // Lock module array
    //
    m_ProductPolicyModuleRWLock.Acquire(WRITER_LOCK);
    m_ProductTranslationRWLock.Acquire(WRITER_LOCK);

    it = FindProductPolicyModule(
                        pszCompanyName,
                        pszTLSProductCode
                    );

    translation_it = FindProductTransation(
                                    pszCompanyName,
                                    pszCHProductCode
                                );

    if( translation_it != m_ProductTranslation.end() && it == m_ProductPolicyModule.end() )
    {
        dwErrCode = TLS_E_INTERNAL;
        goto cleanup;
    }
       
    //
    // insert transation
    //
    InsertProductTransation(
                        pszCompanyName,
                        pszCHProductCode,
                        pszTLSProductCode
                    );

    // 
    // Replace policy module - 
    //  
    
    ptr = new CTLSPolicy;
    
    if(ptr != NULL)
    {
        dwErrCode = ptr->Initialize(
                                hModule,
                                pszCompanyName, 
                                pszCHProductCode,
                                pszTLSProductCode, 
                                pszDllName,
                                dwFlag
                            );

        if(dwErrCode == ERROR_SUCCESS || dwFlag == POLICY_DENY_ALL_REQUEST)
        {
            
            PolicyModule pm;

            if(pszCompanyName)
            {                
                StringCchCopy(
                    pm.m_szCompanyName,
                    sizeof(pm.m_szCompanyName)/sizeof(pm.m_szCompanyName[0]),
                    pszCompanyName
                    );
            }

            if(pszTLSProductCode)
            {
                StringCchCopy(
                    pm.m_szProductId, 
                    sizeof(pm.m_szProductId)/sizeof(pm.m_szProductId[0]),
                    pszTLSProductCode
                    );
            }

            // m_Handles.insert( pair<PolicyModule, CTLSPolicy*>(pm, ptr) );
            m_ProductPolicyModule[pm] = ptr;        
        }
    }
    else
    {
            dwErrCode = ERROR_OUTOFMEMORY;

    }

cleanup:
    m_ProductTranslationRWLock.Release(WRITER_LOCK);
    m_ProductPolicyModuleRWLock.Release(WRITER_LOCK);
    return dwErrCode;
}

//----------------------------------------------------------------------
DWORD
CTLSPolicyMgr::AddPolicyModule(
    IN BOOL bReplace,
    IN LPCTSTR pszCompanyName,
    IN LPCTSTR pszProductCode,
    IN LPCTSTR pszDllName,
    IN DWORD dwFlag
    )
/*++

Abstract:

    Insert or replace an existing policy module

Parameters:

    bReplace : TRUE if replace existing policy module, FALSE otherwise.
    pszCompanyName : Name of the company.
    pszProductId : Name of the product.
    pszDllName : Full path to the policy DLL.
    
returns:


++*/
{
    DWORD dwErrCode = ERROR_SUCCESS;
    DWORD dwNumProduct;
    DWORD dwIndex = 0; 
    DWORD dwUnloadIndex;
    HINSTANCE hInstance = NULL;    
    PMProductPolicyMapType::iterator it;
    PPMSUPPORTEDPRODUCT pSupportedProduct = NULL;

    //
    // Load policy module.
    //    
    hInstance = LoadPolicyModule(
                            pszCompanyName,
                            pszProductCode,
                            pszDllName
                        );

    if(hInstance != NULL)
    {
        //
        // Insert all support product
        //
        dwErrCode = GetSupportedProduct(
                                hInstance,
                                pszDllName,
                                pszCompanyName,
                                pszProductCode,
                                &dwNumProduct,
                                &pSupportedProduct
                            );

        if(dwNumProduct != 0 && pSupportedProduct != NULL)
        {
            for(dwIndex=0; 
                dwIndex < dwNumProduct && dwErrCode == ERROR_SUCCESS; 
                dwIndex++)
            {
                dwErrCode = InsertProductPolicyModule(
                                            hInstance,
                                            bReplace,
                                            pszCompanyName,
                                            pSupportedProduct[dwIndex].szCHSetupCode,
                                            pSupportedProduct[dwIndex].szTLSProductCode,
                                            pszDllName,
                                            dwFlag
                                        );
            }
        }
        else
        {
            dwErrCode = InsertProductPolicyModule(
                                        hInstance,
                                        bReplace,
                                        pszCompanyName,
                                        pszProductCode,
                                        pszProductCode,
                                        pszDllName,
                                        dwFlag
                                    );
        }
    }
    else
    {
        dwErrCode = GetLastError();
    }

    if(dwErrCode != ERROR_SUCCESS)
    {
        //
        // unload this policy module
        //
        for(dwUnloadIndex = 0; dwUnloadIndex < dwIndex; dwUnloadIndex++)
        {
            it = FindProductPolicyModule(
                                pszCompanyName,
                                pSupportedProduct[dwIndex].szTLSProductCode
                            );

            if(it != m_ProductPolicyModule.end())
            {
                CTLSPolicy *ptr;

                ptr = (CTLSPolicy *)(*it).second;
                delete ptr;
                m_ProductPolicyModule.erase(it);
            }
        }

        //
        // Let destructor to unload DLL
        //
    }
                
    if(pSupportedProduct != NULL)
    {
        FreeMemory(pSupportedProduct);
    }


    return dwErrCode;
}

//-------------------------------------------------------
CTLSPolicy*
CTLSPolicyMgr::AcquireProductPolicyModule(
    LPCTSTR pszCompanyName,
    LPCTSTR pszProductId
    )
/*++

++*/
{
    m_ProductPolicyModuleRWLock.Acquire(READER_LOCK);

    PMProductPolicyMapType::iterator it;
    CTLSPolicy* ptr=NULL;

    it = FindProductPolicyModule(
                    pszCompanyName,
                    pszProductId
                );

    if(it != m_ProductPolicyModule.end())
    {
        ptr = (*it).second;
        ptr->Acquire();
    }
    
    m_ProductPolicyModuleRWLock.Release(READER_LOCK);
    return ptr;
}

//-------------------------------------------------------
void
CTLSPolicyMgr::ReleaseProductPolicyModule(
    CTLSPolicy* p 
    )
/*++

++*/
{
    assert(p != NULL);

    p->Release();
    return;
}


/////////////////////////////////////////////////////////
//
// CTLSPolicy Implementation
//
/////////////////////////////////////////////////////////
//-------------------------------------------------------
  

DWORD
CTLSPolicy::InitializePolicyModule()
{
    DWORD dwStatus=ERROR_SUCCESS;

    if(m_dwModuleState == MODULE_LOADED)
    {
        //
        // Initialize Policy Module
        //
        dwStatus = PMInitProduct();
    }
    else if(m_dwModuleState == MODULE_ERROR)
    {
        dwStatus = TLS_E_POLICYERROR;
    }
    else if(m_dwModuleState != MODULE_PMINITALIZED)
    {
        dwStatus = TLS_E_POLICYNOTINITIALIZE;
    }

    return dwStatus;
}
   

//-------------------------------------------------------

DWORD
CTLSPolicy::Initialize(
    IN HINSTANCE hInstance,
    IN LPCTSTR pszCompanyName,
    IN LPCTSTR pszCHProductCode,
    IN LPCTSTR pszTLSProductCode,
    IN LPCTSTR pszDllName,
    IN DWORD dwDllFlags     // deny all request if failed to load
    )
/*++

Abstract:

    This routine load the policy module's DLL.

Parameters:

    pszCompanyName : Name of the company.
    pszProductId : Product Id.
    pszDllName : Full path to policy module's DLL.

Returns:

    ERROR_SUCCESS or error code from LoadLibrary() or 
    GetProAddress().

++*/
{
    m_dwFlags = dwDllFlags;
    DWORD dwErrCode=ERROR_SUCCESS;
    TCHAR  szDllFullPath[MAX_PATH+1];
    DWORD  dwBuffSize = MAX_PATH;

    if(hInstance == NULL)
    {
        dwErrCode = ERROR_INVALID_PARAMETER;
        goto cleanup;
    }

    //
    // Set the module state to unknown
    //
    SetModuleState(MODULE_UNKNOWN);
    SetLastError(ERROR_SUCCESS);

    //
    // Load policy module
    //
    m_hPolicyModule = hInstance;

    // make sure all require API is exported.
    m_pfnReturnLicense = (TLSPMReturnLicense) GetProcAddress(
                                                    m_hPolicyModule,
                                                    RETURNLICENSEPROCNAME
                                                );

    if(m_pfnReturnLicense == NULL)
    {
        dwErrCode = GetLastError();
        TLSLogEvent(
                EVENTLOG_ERROR_TYPE, 
                TLS_E_LOADPOLICY,
                TLS_E_LOADPOLICYMODULE_API,
                RETURNLICENSEPROCNAME
            );
       
        goto cleanup;
    }

    m_pfnLicenseUpgrade = (TLSPMLicenseUpgrade) GetProcAddress(
                                                    m_hPolicyModule,
                                                    LICENSEUPGRADEPROCNAME
                                                );
    if(m_pfnLicenseUpgrade == NULL)
    {
        dwErrCode = GetLastError();
        TLSLogEvent(
                EVENTLOG_ERROR_TYPE, 
                TLS_E_LOADPOLICY,
                TLS_E_LOADPOLICYMODULE_API,
                LICENSEUPGRADEPROCNAME
            );
       
        goto cleanup;
    }

    m_pfnLicenseRequest = (TLSPMLicenseRequest) GetProcAddress(
                                                    m_hPolicyModule,
                                                    LICENSEREQUESTPROCNAME
                                                );
    if(m_pfnLicenseRequest == NULL)
    {
        dwErrCode = GetLastError();
        TLSLogEvent(
                EVENTLOG_ERROR_TYPE, 
                TLS_E_LOADPOLICY,
                TLS_E_LOADPOLICYMODULE_API,
                LICENSEREQUESTPROCNAME
            );
       
        goto cleanup;
    }

    m_pfnUnloadProduct = (TLSPMUnloadProduct) GetProcAddress(
                                            m_hPolicyModule,
                                            ULOADPRODUCTPROCNAME
                                        );
    if(m_pfnUnloadProduct == NULL)
    {
        dwErrCode = GetLastError();
        TLSLogEvent(
                EVENTLOG_ERROR_TYPE, 
                TLS_E_LOADPOLICY,
                TLS_E_LOADPOLICYMODULE_API,
                ULOADPRODUCTPROCNAME
            );
       
        goto cleanup;
    }

    m_pfnInitProduct = (TLSPMInitializeProduct) GetProcAddress(
                                            m_hPolicyModule,
                                            SUPPORTEDPRODUCTPROCNAME
                                        );

    if(m_pfnInitProduct == NULL)
    {
        dwErrCode = GetLastError();
        TLSLogEvent(
                EVENTLOG_ERROR_TYPE, 
                TLS_E_LOADPOLICY,
                TLS_E_LOADPOLICYMODULE_API,
                INITIALIZEPROCNAME
            );
       
        goto cleanup;
    }

    m_pfnRegisterLkp = (TLSPMRegisterLicensePack) GetProcAddress(
                                            m_hPolicyModule,
                                            REGISTERLKPPROCNAME
                                        );

    if(m_pfnRegisterLkp == NULL)
    {
        dwErrCode = GetLastError();
        TLSLogEvent(
                EVENTLOG_ERROR_TYPE, 
                TLS_E_LOADPOLICY,
                TLS_E_LOADPOLICYMODULE_API,
                REGISTERLKPPROCNAME
            );
       
        goto cleanup;
    }
    
    //
    // Everything is OK, advance module state
    //
    SetModuleState(MODULE_LOADED);

    if(pszCompanyName)
    {
        _tcsncpy(
                m_szCompanyName, 
                pszCompanyName,
                sizeof(m_szCompanyName) / sizeof(m_szCompanyName[0])
            );
    }

    if(pszTLSProductCode)
    {
        _tcsncpy(
                m_szProductId, 
                pszTLSProductCode,
                sizeof(m_szProductId)/sizeof(m_szProductId[0])
            );
    }
    else
    {
        LoadResourceString(
                    IDS_UNKNOWN_STRING,
                    m_szProductId,
                    sizeof(m_szProductId) / sizeof(m_szProductId[0])
                ); 
    }

    if(pszCHProductCode)
    {
        _tcsncpy(
                m_szCHProductId, 
                pszCHProductCode,
                sizeof(m_szCHProductId)/sizeof(m_szCHProductId[0])
            );
    }
    else
    {
        LoadResourceString(
                    IDS_UNKNOWN_STRING,
                    m_szCHProductId,
                    sizeof(m_szCHProductId) / sizeof(m_szCHProductId[0])
                ); 
    }


       
cleanup:

    if(IsValid() == FALSE)
    {
        TLSLogEvent(
                EVENTLOG_WARNING_TYPE,
                TLS_E_LOADPOLICY,
                (m_dwFlags == POLICY_DENY_ALL_REQUEST) ?
                                TLS_W_LOADPOLICYMODULEDENYALLREQUEST : TLS_W_LOADPOLICYMODULEUSEDEFAULT,
                pszDllName
            );

        //
        // don't report error again.
        //
        m_bAlreadyLogError = TRUE;
    }

    return dwErrCode;
}

//---------------------------------------------------------------------------

BOOL
CTLSPolicy::IsValid()
/*++

Abstract:

    This routine determine if the CTLSPolicy object is valid or not.

Parameters:

    None.

Returns:

    TRUE if valid, FALSE otherwise.

++*/
{
    return (m_hPolicyModule != NULL &&
            m_pfnReturnLicense != NULL &&
            m_pfnLicenseUpgrade != NULL &&
            m_pfnLicenseRequest != NULL &&
            m_pfnUnloadProduct != NULL &&
            m_pfnInitProduct != NULL &&
            m_pfnRegisterLkp != NULL);
}

//---------------------------------------------------------------------------
void
CTLSPolicy::LogPolicyRequestStatus(
    DWORD dwMsgId
    )
/*++

--*/
{
    if(m_dwLastCallStatus != POLICY_SUCCESS)
    {
        TLSLogEvent(
                EVENTLOG_WARNING_TYPE,
                TLS_E_POLICYERROR,
                dwMsgId,
                GetCompanyName(),
                GetProductId(),
                m_dwPolicyErrCode
            );
        
        if(m_dwLastCallStatus == POLICY_CRITICAL_ERROR)
        {
            TLSLogEvent(
                    EVENTLOG_ERROR_TYPE,
                    TLS_E_POLICYERROR,
                    TLS_E_CRITICALPOLICYMODULEERROR,
                    GetCompanyName(),
                    GetProductId,
                    m_dwPolicyErrCode
                );

            SetModuleState(MODULE_ERROR);
        }
    }

    return;
}

//----------------------------------------------------------

DWORD
CTLSPolicy::PMReturnLicense(
	PMHANDLE hClient,
	ULARGE_INTEGER* pLicenseSerialNumber,
	PPMLICENSETOBERETURN pLicenseTobeReturn,
	PDWORD pdwLicenseStatus
    )
/*++

++*/
{
    DWORD dwErrCode = ERROR_SUCCESS;
    dwErrCode = InitializePolicyModule();
    if(dwErrCode != ERROR_SUCCESS)
    {
        return dwErrCode;
    }
    DBGPrintf(
            DBG_INFORMATION,
            DBG_FACILITY_POLICY,
            DBG_ALL_LEVEL,
            _TEXT("<%s - %s> : PMReturnLicense()\n"),
            GetCompanyName(),
            GetProductId()
        );

    m_dwLastCallStatus = m_pfnReturnLicense(
                                hClient,
                                pLicenseSerialNumber,
                                pLicenseTobeReturn,
                                pdwLicenseStatus,
                                &m_dwPolicyErrCode
                            );

    if(m_dwLastCallStatus != POLICY_SUCCESS)
    {
        LogPolicyRequestStatus(TLS_E_POLICYDENYRETURNLICENSE);
        dwErrCode = TLS_E_REQUESTDENYPOLICYERROR;
    }

    return dwErrCode;
}

//--------------------------------------------------------------

DWORD
CTLSPolicy::PMLicenseUpgrade(
	PMHANDLE hClient,
	DWORD dwProgressCode,
	PVOID pbProgressData,
	PVOID* ppbReturnData,
    DWORD dwIndex
    )
/*++

++*/
{
    DWORD dwErrCode = ERROR_SUCCESS;

    dwErrCode = InitializePolicyModule();
    if(dwErrCode != ERROR_SUCCESS)
    {
        return dwErrCode;
    }

    DBGPrintf(
            DBG_INFORMATION,
            DBG_FACILITY_POLICY,
            DBG_ALL_LEVEL,
            _TEXT("<%s - %s> : PMLicenseUpgrade()\n"),
            GetCompanyName(),
            GetProductId()
        );

    m_dwLastCallStatus = m_pfnLicenseUpgrade(
	                        hClient,
	                        dwProgressCode,
	                        pbProgressData,
	                        ppbReturnData,                                
                            &m_dwPolicyErrCode,
                            dwIndex
                        );

    if(m_dwLastCallStatus != ERROR_SUCCESS)
    {
        dwErrCode = TLS_E_REQUESTDENYPOLICYERROR;
        LogPolicyRequestStatus(TLS_E_POLICYDENYUPGRADELICENSE);
    }

    return dwErrCode;
}

//--------------------------------------------------------------

DWORD
CTLSPolicy::PMLicenseRequest(
    PMHANDLE client,
    DWORD dwProgressCode, 
    const PVOID pbProgressData, 
    PVOID* pbNewProgressData
    )
/*++

++*/
{
    DWORD dwErrCode = ERROR_SUCCESS;

    dwErrCode = InitializePolicyModule();
    if(dwErrCode != ERROR_SUCCESS)
    {
        return dwErrCode;
    }

    DBGPrintf(
            DBG_INFORMATION,
            DBG_FACILITY_POLICY,
            DBG_ALL_LEVEL,
            _TEXT("<%s - %s> : PMLicenseRequest()\n"),
            GetCompanyName(),
            GetProductId()
        );

    m_dwLastCallStatus = m_pfnLicenseRequest(
                            client,
                            dwProgressCode, 
                            pbProgressData, 
                            pbNewProgressData,
                            &m_dwPolicyErrCode
                        );

    if(m_dwLastCallStatus != ERROR_SUCCESS)
    {
        LogPolicyRequestStatus(TLS_E_POLICYDENYNEWLICENSE);
        dwErrCode =  TLS_E_REQUESTDENYPOLICYERROR;
    }    

    return dwErrCode;
}

//--------------------------------------------------------------

DWORD
CTLSPolicy::PMUnload()
/*++

++*/
{
    DWORD dwErrCode = ERROR_SUCCESS;
    
    //
    // Don't call PMUnloadProduct if policy module
    // already in error state.
    //
    if(m_dwModuleState == MODULE_ERROR)
    {
        return ERROR_SUCCESS;
    }

    m_dwLastCallStatus = m_pfnUnloadProduct(
                                    GetCompanyName(), 
                                    GetCHProductId(),
                                    GetProductId(),
                                    &m_dwPolicyErrCode
                                );

    if(m_dwLastCallStatus != POLICY_SUCCESS)
    {
        LogPolicyRequestStatus(TLS_E_POLICYUNLOADPRODUCT);
        dwErrCode = TLS_E_REQUESTDENYPOLICYERROR;
    }

    //
    // Always terminate module even error occurred
    //
    SetModuleState(MODULE_PMTERMINATED);
    return dwErrCode;
}
    

//--------------------------------------------------------------

DWORD
CTLSPolicy::PMInitProduct()
/*++

++*/
{
    DWORD dwErrCode = ERROR_SUCCESS;
    
    if(IsValid() == FALSE)
    {
        return TLS_E_POLICYNOTINITIALIZE;
    }

    DBGPrintf(
            DBG_INFORMATION,
            DBG_FACILITY_POLICY,
            DBG_ALL_LEVEL,
            _TEXT("<%s - %s> : PMInitialize()\n"),
            GetCompanyName(),
            GetProductId()
        );

    m_dwLastCallStatus = m_pfnInitProduct(
                                GetCompanyName(),
                                GetCHProductId(),
                                GetProductId(),
                                &m_dwPolicyErrCode
                            );        


    if(m_dwLastCallStatus != POLICY_SUCCESS)
    {
        LogPolicyRequestStatus(TLS_E_POLICYINITPRODUCT);
        dwErrCode = TLS_E_REQUESTDENYPOLICYERROR;
    }

    SetModuleState(
            (dwErrCode == ERROR_SUCCESS) ? MODULE_PMINITALIZED : MODULE_ERROR
        );

    return dwErrCode;
}

//--------------------------------------------------------------

void
CTLSPolicy::Unload() 
/*++

++*/
{
    if(m_hPolicyModule == NULL || m_hPolicyModule == INVALID_HANDLE_VALUE)
        return;

    assert(GetRefCount() == 0);

    m_pfnReturnLicense = NULL;
    m_pfnLicenseUpgrade = NULL;
    m_pfnLicenseRequest = NULL;
    m_pfnUnloadProduct = NULL;
    m_pfnInitProduct = NULL;
    m_pfnRegisterLkp = NULL;
    m_hPolicyModule = NULL;
    m_RefCount  = 0;
    m_bAlreadyLogError = FALSE;
    SetModuleState(MODULE_UNKNOWN);
}

//-------------------------------------------------------------------

DWORD
CTLSPolicy::PMRegisterLicensePack(
    PMHANDLE hClient,
    DWORD dwProgressCode,
    const PVOID pbProgessData,
    PVOID pbProgressRetData
    )
/*++

++*/
{
    DWORD dwErrCode = ERROR_SUCCESS;

    dwErrCode = InitializePolicyModule();
    if(dwErrCode != ERROR_SUCCESS)
    {
        return dwErrCode;
    }

    DBGPrintf(
            DBG_INFORMATION,
            DBG_FACILITY_POLICY,
            DBG_ALL_LEVEL,
            _TEXT("<%s - %s> : PMRegisterLicensePack()\n"),
            GetCompanyName(),
            GetProductId()
        );

    m_dwLastCallStatus = m_pfnRegisterLkp(
                                hClient,
                                dwProgressCode,
                                pbProgessData,
                                pbProgressRetData,
                                &m_dwPolicyErrCode
                            );

    if(m_dwLastCallStatus != POLICY_SUCCESS)
    {
        LogPolicyRequestStatus(TLS_E_POLICYMODULEREGISTERLKP);
        dwErrCode = TLS_E_REQUESTDENYPOLICYERROR;
    }

    return dwErrCode;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\license\tlserver\server\npipe.cpp ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996-1996
//
// File:        npipe.c
//
// Contents:    
//
// History:     12-09-98    HueiWang    Created
//
// Note:        
//---------------------------------------------------------------------------
#include "pch.cpp"
#include <tchar.h>
#include <process.h>
#include "server.h"
#include "lscommon.h"
#include "globals.h"
#include "debug.h"


#define NAMEPIPE_BUFFER_SIZE    512
#define NAMEPIPE_INSTANCE       2


unsigned int WINAPI
NamedPipeThread(
    void* ptr
);

//---------------------------------------------------------------------
DWORD
InitNamedPipeThread()
/*++

++*/
{
    HANDLE hThread = NULL;
    unsigned int  dwThreadId;
    HANDLE hEvent = NULL;
    DWORD dwStatus = ERROR_SUCCESS;
    HANDLE waithandles[2];


    //
    // Create a event for namedpipe thread to signal it is ready.
    //
    hEvent = CreateEvent(
                        NULL,
                        FALSE,
                        FALSE,  // non-signal
                        NULL
                    );
        
    if(hEvent == NULL)
    {
        dwStatus = GetLastError();
        goto cleanup;
    }

    hThread = (HANDLE)_beginthreadex(
                                NULL,
                                0,
                                NamedPipeThread,
                                hEvent,
                                0,
                                &dwThreadId
                            );

    if(hThread == NULL)
    {
        dwStatus = GetLastError();
        goto cleanup;
    }

    waithandles[0] = hEvent;
    waithandles[1] = hThread;
    
    //
    // Wait 30 second for thread to complet initialization
    //
    dwStatus = WaitForMultipleObjects(
                                sizeof(waithandles)/sizeof(waithandles[0]), 
                                waithandles, 
                                FALSE,
                                30*1000
                            );

    if(dwStatus == WAIT_OBJECT_0)
    {    
        //
        // thread is ready
        //
        dwStatus = ERROR_SUCCESS;
    }
    else 
    {
        if(dwStatus == (WAIT_OBJECT_0 + 1))
        {
            //
            // Thread terminate abnormally
            //
            GetExitCodeThread(
                        hThread,
                        &dwStatus
                    );
        }
        else
        {
            dwStatus = TLS_E_SERVICE_STARTUP_CREATE_THREAD;
        }
    }
    

cleanup:

    if(hEvent != NULL)
    {
        CloseHandle(hEvent);
    }

    if(hThread != NULL)
    {
        CloseHandle(hThread);
    }


    return dwStatus;
}

//------------------------------------------------------------------------

typedef struct {    
    OVERLAPPED ol;    
    HANDLE hPipeInst; 
} PIPEINST, *LPPIPEINST;

//------------------------------------------------------------------------

BOOL 
ConnectToNewClient(
    HANDLE hPipe, 
    LPOVERLAPPED lpo
    ) 
/*++

++*/
{ 
    BOOL bSuccess = FALSE;  

    // Start an overlapped connection for this pipe instance. 
    bSuccess = ConnectNamedPipe(hPipe, lpo);  

    //
    // Overlapped ConnectNamedPipe should return zero.
    //
    if(bSuccess == TRUE) 
    {
        return FALSE;
    }

    switch (GetLastError())    
    { 
        // The overlapped connection in progress.       
        case ERROR_IO_PENDING: 
            bSuccess = TRUE;
            break;  

        // Client is already connected, so signal an event. 
        case ERROR_PIPE_CONNECTED:
            bSuccess = TRUE;

            // If an error occurs during the connect operation... 
            if(SetEvent(lpo->hEvent)) 
                break;     

        default:          
            bSuccess = FALSE;
    }

    return bSuccess; 
} 

//------------------------------------------------------------------------

unsigned int WINAPI
NamedPipeThread(
    void* ptr
    )
/*++


++*/
{
    DWORD dwStatus=ERROR_SUCCESS;
    DWORD dwIndex;

    HANDLE hReady = (HANDLE)ptr;
    TCHAR szPipeName[MAX_PATH+1];

    PIPEINST Pipe[NAMEPIPE_INSTANCE];
    HANDLE hOlEvent[NAMEPIPE_INSTANCE];

    DWORD cbMessage, cbRead, cbToRead, cMessages;
    BYTE pbMessage[NAMEPIPE_BUFFER_SIZE+1];

    HANDLE waitHandles[NAMEPIPE_INSTANCE+1];

    BOOL bResult=TRUE;

    //SECURITY_ATTRIBUTES SecurityAttributes;
    //SECURITY_DESCRIPTOR SecurityDescriptor;

    int i;

    //------------------------------------------------

    ZeroMemory(Pipe, sizeof(Pipe));
    ZeroMemory(hOlEvent, sizeof(hOlEvent));

    //
    // Create a inbound name pipe, server only listen.
    //
    wsprintf(
            szPipeName, 
            _TEXT("\\\\.\\pipe\\%s"), 
            _TEXT(SZSERVICENAME)
        );

    //
    // init values
    //
    for(i = 0; i < NAMEPIPE_INSTANCE; i++)
    {
        Pipe[i].hPipeInst = INVALID_HANDLE_VALUE;
    }

    //
    // Create namedpipe
    //
    for(i=0; i < NAMEPIPE_INSTANCE; i++)
    {
        DWORD dwOpenMode = PIPE_ACCESS_INBOUND | FILE_FLAG_OVERLAPPED;

        hOlEvent[i] = CreateEvent(
                            NULL,
                            TRUE,
                            TRUE,
                            NULL
                        );
    
        if(hOlEvent[i] == NULL)
        {
            dwStatus = GetLastError();
            goto cleanup;
        }

        if (i == 0)
        {
            dwOpenMode |= FILE_FLAG_FIRST_PIPE_INSTANCE;
        }

        Pipe[i].ol.hEvent = hOlEvent[i];
        Pipe[i].hPipeInst = CreateNamedPipe(
                                        szPipeName,
                                        dwOpenMode,
                                        PIPE_TYPE_MESSAGE | PIPE_READMODE_MESSAGE | PIPE_WAIT,
                                        NAMEPIPE_INSTANCE,
                                        0,
                                        NAMEPIPE_BUFFER_SIZE,
                                        NMPWAIT_USE_DEFAULT_WAIT,
                                        NULL // &SecurityAttributes
                                    );

        if(Pipe[i].hPipeInst == INVALID_HANDLE_VALUE)
        {
            dwStatus = GetLastError();
            goto cleanup;
        }

        //
        // Initiate connect
        //
        bResult = ConnectToNewClient(
                                Pipe[i].hPipeInst, 
                                &(Pipe[i].ol)
                            );

        if(bResult == FALSE)
        {
            dwStatus = GetLastError();
            goto cleanup;
        }
    }

    //
    // Signal we are ready
    //
    SetEvent(hReady);

    DBGPrintf(
            DBG_INFORMATION,
            DBG_FACILITY_INIT,
            DBGLEVEL_FUNCTION_DETAILSIMPLE,
            _TEXT("NamedPipe : Ready...\n")
        );


    waitHandles[0] = GetServiceShutdownHandle();

    for(i=1; i <= NAMEPIPE_INSTANCE; i++)
    {
        waitHandles[i] = hOlEvent[i-1];
    }

    //
    // Forever loop
    //
    while(TRUE)
    {
        //
        // Wait for pipe or shutdown messages
        //
        dwStatus = WaitForMultipleObjects(
                                    sizeof(waitHandles)/sizeof(waitHandles[0]),
                                    waitHandles,
                                    FALSE,
                                    INFINITE
                                );

        if(dwStatus == WAIT_FAILED)
        {
            SetLastError(dwStatus = TLS_E_INTERNAL);
            break;
        }

        if(dwStatus == WAIT_OBJECT_0)
        {
            //
            // shutdown
            //
            DBGPrintf(
                    DBG_INFORMATION,
                    DBG_FACILITY_INIT,
                    DBGLEVEL_FUNCTION_DETAILSIMPLE,
                    _TEXT("NamedPipe : System Shutdown...\n")
                );

            dwStatus = ERROR_SUCCESS;
            break;
        }

        dwIndex = (dwStatus - 1) - WAIT_OBJECT_0;
        if(dwIndex > (NAMEPIPE_INSTANCE-1))
        {
            //
            // some internal error
            //
            SetLastError(dwStatus = TLS_E_INTERNAL);

            DBGPrintf(
                    DBG_INFORMATION,
                    DBG_FACILITY_INIT,
                    DBGLEVEL_FUNCTION_DETAILSIMPLE,
                    _TEXT("NamedPipe : Internal Error...\n")
                );

            break;
        }
            
        //
        // Read everything and discard it.
        //
        bResult = GetOverlappedResult(
                                    Pipe[dwIndex].hPipeInst,
                                    &(Pipe[dwIndex].ol),
                                    &cbToRead,  // can't count on this value
                                    TRUE
                                );
                                  
        if(bResult == TRUE)
        {
            //
            // Junk messages...
            //
            bResult = ReadFile(
                            Pipe[dwIndex].hPipeInst,
                            pbMessage,
                            sizeof(pbMessage),
                            &cbRead,
                            &(Pipe[dwIndex].ol)
                        );

            if(bResult == TRUE && cbRead != 0) 
                continue;                    

            dwStatus = GetLastError();
            if(dwStatus == ERROR_IO_PENDING)
                continue;
        }

        //
        // Any error, just disconnect named pipe
        //
        DisconnectNamedPipe(Pipe[dwIndex].hPipeInst);

        ConnectToNewClient(
                        Pipe[dwIndex].hPipeInst, 
                        &(Pipe[dwIndex].ol)
                    );
    }

cleanup:

    for(i = 0; i < NAMEPIPE_INSTANCE; i++)
    {
        if(Pipe[i].hPipeInst != INVALID_HANDLE_VALUE)
        {
            CloseHandle(Pipe[i].hPipeInst);
        }

        if(hOlEvent[i] != NULL)
        {
            CloseHandle(hOlEvent[i]);
        }
    }

    _endthreadex(dwStatus);   
    return dwStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\license\tlserver\server\postjob.h ===
//+--------------------------------------------------------------------------
//
// Copyright (c) 1997-1999 Microsoft Corporation
//
// File:        postjob.h
//
// Contents:    
//
// History:     
//
//---------------------------------------------------------------------------
#ifndef __POSTSJOB_H__
#define __POSTSJOB_H__
#include "server.h"

#ifdef __cplusplus
extern "C" {
#endif

BOOL
TLSCanForwardRequest(
    IN DWORD dwLocalServerVersion,
    IN DWORD dwTargetServerVersion
);

BOOL
IsLicensePackRepl(
    TLSLICENSEPACK* pLicensePack
);

BOOL
TLSIsServerCompatible(
    IN DWORD dwLocalServerVersion,
    IN DWORD dwTargetServerVersion
);

BOOL
TLSCanPushReplicateData(
    IN DWORD dwLocalServerVersion,
    IN DWORD dwTargetServerVersion
);

DWORD
PostSsyncLkpJob(
    PSSYNCLICENSEPACK syncLkp
);

DWORD
TLSAnnounceLKPToAllRemoteServer(
    IN DWORD dwKeyPackId,
    IN DWORD dwDelayTime
);

DWORD
TLSPushSyncLocalLkpToServer(
    IN LPTSTR pszSetupId,
    IN LPTSTR pszDomainName,
    IN LPTSTR pszLserverName,
    IN FILETIME* pSyncTime
);

DWORD
TLSStartAnnounceResponseJob(
    IN LPTSTR pszTargetServerId,
    IN LPTSTR pszTargetServerDomain,
    IN LPTSTR pszTargetServerName,
    IN FILETIME* pftTime
);

DWORD
TLSStartAnnounceToEServerJob(
    IN LPCTSTR pszServerId,
    IN LPCTSTR pszServerDomain,
    IN LPCTSTR pszServerName,
    IN FILETIME* pftFileTime
);

DWORD
TLSStartAnnounceLicenseServerJob(
    IN LPCTSTR pszServerId,
    IN LPCTSTR pszServerDomain,
    IN LPCTSTR pszServerName,
    IN FILETIME* pftFileTime
);

DWORD
TLSPostReturnClientLicenseJob(
    PLICENSEDPRODUCT pLicProduct
);


#ifdef __cplusplus
}
#endif


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\license\tlserver\server\remotedb.h ===
//+--------------------------------------------------------------------------
//
// Copyright (c) 1997-1999 Microsoft Corporation
//
// File:            remotedb.h
//
// Contents:    
//
// History:     
//
//---------------------------------------------------------------------------

#ifndef __REMOTEDB_H__
#define __REMOTEDB_H__
#include "server.h"



#ifdef __cplusplus
extern "C" {
#endif

DWORD
TLSDBRemoteKeyPackAdd(
    IN PTLSDbWorkSpace pDbWkSpace,
    IN OUT PTLSLICENSEPACK lpKeyPack
);


#ifdef __cplusplus
}
#endif


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\license\tlserver\server\resource.h ===
//+--------------------------------------------------------------------------
//
// Copyright (c) 1997-1999 Microsoft Corporation
//
//---------------------------------------------------------------------------
#ifndef __RESOURCE_H__

#define IDS_TEMPORARY_KEYPACKID         101
#define IDS_TEMPORARY_PRODUCTNAME       102
#define IDS_TEMPORARY_PRODUCTDESC       103
#define IDS_TEMPORARY_BSERIALNUMBER     104
#define IDS_UNKNOWN_STRING              105
#define IDS_DEFAULT_SCOPE               106


#define IDS_VU_COMPANYNAME              107
#define IDS_VU_PRODUCTNAME              108
#define IDS_VU_PRODUCTDESC              109
#define IDS_VU_PRODUCTID                110
#define IDS_S_PRODUCTDESC               111
#define IDS_EX_PRODUCTDESC              112

#define IDS_HS_COMPANYNAME              113
#define IDS_HS_PRODUCTNAME              114 
#define IDS_HS_PRODUCTDESC              115

#define IDS_HS_MACHINENAME              116
#define IDS_HS_USERNAME                 117

#define IDS_SCOPE_ENTERPRISE            118
#define IDS_UNKNOWN_PRODUCTDESC         119
#define IDS_DEFAULT_POLICY              120
#define IDS_TSLSLOCALGROUP_NAME         121
#define IDS_TSLSLOCALGROUP_DES          122

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\license\tlserver\server\postsrv.h ===
//+--------------------------------------------------------------------------
//
// Copyright (c) 1997-1999 Microsoft Corporation
//
// File:        postsrv.h
//
// Contents:    
//
// History:     
//
//---------------------------------------------------------------------------
#ifndef __POSTSERVICE_H__
#define __POSTSERVICE_H__
#include "server.h"
#include "vss.h"
#include "vswriter.h"
#include "jetwriter.h"

class CTlsVssJetWriter : public CVssJetWriter
	{
public:
    CTlsVssJetWriter();
    ~CTlsVssJetWriter();

    HRESULT Initialize();

    void Uninitialize();

    virtual bool STDMETHODCALLTYPE OnIdentify(IN IVssCreateWriterMetadata *pMetadata);


};


#ifdef __cplusplus
extern "C" {
#endif

DWORD
PostServiceInit();


#ifdef __cplusplus
}
#endif


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\license\tlserver\server\policy.h ===
//+--------------------------------------------------------------------------
//
// Copyright (c) 1997-1999 Microsoft Corporation
//
// File:        policy.h
//
// Contents:    
//
// History:     
//
//---------------------------------------------------------------------------
#ifndef __POLICY_MODULE_MGR__
#define __POLICY_MODULE_MGR__

#include "tlsstl.h"    // STL.

#include <stdio.h>
#include <tchar.h>
#include "tlsdef.h"
#include "tlspol.h"
#include "locks.h"

#define RETURNLICENSEPROCNAME       "PMReturnLicense"
#define LICENSEUPGRADEPROCNAME      "PMLicenseUpgrade"
#define LICENSEREQUESTPROCNAME      "PMLicenseRequest"
#define TEMINATEPROCNAME            "PMTerminate"
#define INITIALIZEPROCNAME          "PMInitialize"
#define SUPPORTEDPRODUCTPROCNAME    "PMInitializeProduct"
#define ULOADPRODUCTPROCNAME        "PMUnloadProduct"
#define REGISTERLKPPROCNAME         "PMRegisterLicensePack"

#define POLICY_DENY_ALL_REQUEST     0x00000000
#define POLICY_USE_DEFAULT          0x00000001

typedef POLICYSTATUS (WINAPI *TLSPMReturnLicense)(
	                        PMHANDLE hClient,
	                        ULARGE_INTEGER* pLicenseSerialNumber,
                            PPMLICENSETOBERETURN pLicenseToBeReturn,
	                        PDWORD pdwLicenseStatus,
                            PDWORD pdwRetCode
                        );

typedef POLICYSTATUS (WINAPI *TLSPMLicenseUpgrade)(
	                        PMHANDLE hClient,
	                        DWORD dwProgressCode,
	                        PVOID pbProgressData,
	                        PVOID* ppbReturnData,                            
                            PDWORD pdwRetCode,
                            DWORD dwIndex
                        );	

typedef POLICYSTATUS (WINAPI *TLSPMLicenseRequest)(
                            PMHANDLE client,
                            DWORD dwProgressCode, 
                            PVOID pbProgressData, 
                            PVOID* pbNewProgressData,
                            PDWORD pdwRetCode
                        );

typedef void (WINAPI *TLSPMTerminate)();

typedef POLICYSTATUS (WINAPI* TLSPMInitialize)(
                            DWORD dwLicenseServerVersion,
                            LPCTSTR pszCompanyName,
                            LPCTSTR pszProductCode,
                            PDWORD pdwNumProduct,
                            PPMSUPPORTEDPRODUCT* ppProduct,
                            PDWORD pdwRetCode
                        );

typedef POLICYSTATUS (WINAPI* TLSPMInitializeProduct)(
                            LPCTSTR pszCompanyName,
                            LPCTSTR pszCHProductId,
                            LPCTSTR pszTLSProductId,
                            PDWORD pdwRetCode
                        );

typedef POLICYSTATUS (WINAPI* TLSPMUnloadProduct)(
                            LPCTSTR pszCompanyName,
                            LPCTSTR pszCHProductId,
                            LPCTSTR pszTLSProductCode,
                            PDWORD pdwRetCode
                        );

typedef POLICYSTATUS (WINAPI* TLSPMRegisterLicensePack)(
                            PMHANDLE hClient,
                            DWORD dwProgressCode,
                            PVOID pbProgressData,
                            PVOID pbProgressRetData,
                            PDWORD pdwRetCode
                        );
    
                             
class CTLSPolicyMgr;

////////////////////////////////////////////////////////////////////////////

class CTLSPolicy {

    friend class CTLSPolicyMgr;
    
private:
    typedef enum { 
        MODULE_UNKNOWN,             // object has been initialized.
        MODULE_LOADED,              // module has been loaded.
        MODULE_PMINITALIZED,        // module has been initialized.
        MODULE_PMTERMINATED,        // module has been terminated.
        MODULE_ERROR,               // module initialization error or 
                                    // cause an exeption
        MODULE_UNLOADED             // module has been unloaded.
    } MODULE_STATE;

    long m_RefCount;
    DWORD m_dwFlags;
    BOOL  m_bAlreadyLogError;

    POLICYSTATUS m_dwLastCallStatus;    // Policy Module last call status
    DWORD m_dwPolicyErrCode;            // Policy specific error code.

    MODULE_STATE m_dwModuleState;

    //
    // Policy module must be multi-thread safe.
    //    
    TLSPMReturnLicense  m_pfnReturnLicense;
    TLSPMLicenseUpgrade m_pfnLicenseUpgrade;
    TLSPMLicenseRequest m_pfnLicenseRequest;
    TLSPMUnloadProduct m_pfnUnloadProduct;
    TLSPMInitializeProduct m_pfnInitProduct;
    TLSPMRegisterLicensePack m_pfnRegisterLkp;


    HMODULE m_hPolicyModule;
    TCHAR   m_szCompanyName[LSERVER_MAX_STRING_SIZE+1];
    TCHAR   m_szProductId[LSERVER_MAX_STRING_SIZE+1];
    TCHAR   m_szCHProductId[LSERVER_MAX_STRING_SIZE+1];

    //--------------------------------------------------------------
    void
    SetDllFlags(DWORD dllFlags) 
    {
        m_dwFlags = dllFlags;
    }
       
    //--------------------------------------------------------------

    long
    Acquire()
    {
        return InterlockedIncrement(&m_RefCount);
    }

    //--------------------------------------------------------------

    long
    Release()
    {
        return InterlockedDecrement(&m_RefCount);
    }

    //--------------------------------------------------------------

    DWORD
    InitializePolicyModule();

    //--------------------------------------------------------------

    void
    SetModuleState(
        MODULE_STATE state
        )
    /*++
    
    ++*/
    {
        m_dwModuleState = state;
        return;
    }
    
    //-------------------------------------------------------------

    MODULE_STATE
    GetModuleState() 
    { 
        return m_dwModuleState; 
    }

    //-------------------------------------------------------------

    void
    CreatePolicy(
        HMODULE hModule,
        LPCTSTR pszCompanyName,
        LPCTSTR pszProductId,
        TLSPMReturnLicense pfnReturnLicense,
        TLSPMLicenseUpgrade pfnLicenseUpgrade,
        TLSPMLicenseRequest pfnLicenseRequest,
        TLSPMUnloadProduct pfnUnloadProduct,
        TLSPMInitializeProduct pfnInitProduct,
        TLSPMRegisterLicensePack pfnRegisterLkp
        )
    /*++
    
    ++*/
    {
        m_hPolicyModule = hModule;
        m_pfnReturnLicense = pfnReturnLicense;
        m_pfnLicenseUpgrade = pfnLicenseUpgrade;
        m_pfnLicenseRequest = pfnLicenseRequest;
        m_pfnUnloadProduct = pfnUnloadProduct;
        m_pfnInitProduct = pfnInitProduct;
        m_pfnRegisterLkp = pfnRegisterLkp;
        SetModuleState(MODULE_PMINITALIZED);

        lstrcpyn(
                m_szCompanyName, 
                pszCompanyName, 
                sizeof(m_szCompanyName) / sizeof(m_szCompanyName[0])
            );
        lstrcpyn(
                m_szProductId, 
                pszProductId, 
                sizeof(m_szProductId) / sizeof(m_szProductId[0])
            );
    }


    void
    LogPolicyRequestStatus(
        DWORD dwMsgId
    );

public:
    CTLSPolicy() : 
        m_pfnReturnLicense(NULL),
        m_pfnLicenseUpgrade(NULL),
        m_pfnLicenseRequest(NULL),
        m_pfnUnloadProduct(NULL),
        m_pfnInitProduct(NULL),
        m_pfnRegisterLkp(NULL),
        m_hPolicyModule(NULL),
        m_RefCount(0),
        m_bAlreadyLogError(FALSE),
        m_dwModuleState(MODULE_UNKNOWN),
        m_dwFlags(0),
        m_dwLastCallStatus(POLICY_SUCCESS),
        m_dwPolicyErrCode(ERROR_SUCCESS)
    /*++
        Constructor
    ++*/
    {
        #ifdef DBG
        memset(m_szCompanyName, 0, sizeof(m_szCompanyName));
        memset(m_szProductId, 0, sizeof(m_szProductId));
        memset(m_szCHProductId, 0, sizeof(m_szCHProductId));
        #endif
    }

    //--------------------------------------------------------------
        
    ~CTLSPolicy()
    /*++
        Destructor
    ++*/
    {
        Unload();
    }

    //--------------------------------------------------------------

    DWORD
    GetProductFlags()
    {
        return m_dwFlags;
    }

    //--------------------------------------------------------------

    long
    GetRefCount()
    {
        return InterlockedExchange(&m_RefCount, m_RefCount);
    }

    //--------------------------------------------------------------

    void
    Unload();

    //--------------------------------------------------------------
    DWORD
    Initialize(
        HINSTANCE hInstance,
        LPCTSTR pszCompanyName, 
        LPCTSTR pszCHProductId,
        LPCTSTR pszProductId,
        LPCTSTR pszDllName,
        DWORD dwDllFlag = POLICY_DENY_ALL_REQUEST
    );

    //--------------------------------------------------------------
    LPCTSTR
    GetCompanyName() 
    { 
        return m_szCompanyName; 
    }

    //--------------------------------------------------------------

    LPCTSTR
    GetProductId() 
    { 
        return m_szProductId; 
    }

    //--------------------------------------------------------------
    LPCTSTR
    GetCHProductId()
    {
        return m_szCHProductId;
    }
    
    //--------------------------------------------------------------

    DWORD
    GetPolicyRetCode() { return m_dwPolicyErrCode; }

    //--------------------------------------------------------------

    DWORD
    GetPolicyLastCallStatus() { return m_dwLastCallStatus; }

    //--------------------------------------------------------------

    BOOL
    IsValid();

    //--------------------------------------------------------------

    DWORD
    PMReturnLicense(
	    PMHANDLE hClient,
	    ULARGE_INTEGER* pLicenseSerialNumber,
	    PPMLICENSETOBERETURN pLicenseTobeReturn,
	    PDWORD pdwLicenseStatus
    );

    //--------------------------------------------------------------

    DWORD
    PMLicenseUpgrade(
	    PMHANDLE hClient,
	    DWORD dwProgressCode,
	    PVOID pbProgressData,
	    PVOID* ppbReturnData,
        DWORD dwIndex
    );

    //--------------------------------------------------------------

    DWORD
    PMLicenseRequest(
        PMHANDLE client,
        DWORD dwProgressCode, 
        const PVOID pbProgressData, 
        PVOID* pbNewProgressData
    );

    //--------------------------------------------------------------
    
    DWORD
    PMRegisterLicensePack(
        PMHANDLE hClient,
        DWORD dwProgressCode,
        const PVOID pbProgessData,
        PVOID pbProgressRetData
    );

    //--------------------------------------------------------------

    DWORD
    PMUnload();

    //--------------------------------------------------------------

    DWORD
    PMInitProduct();
};

/////////////////////////////////////////////////////////////////////

typedef struct __PolicyModule {
    
    TCHAR   m_szCompanyName[LSERVER_MAX_STRING_SIZE+1];
    TCHAR   m_szProductId[LSERVER_MAX_STRING_SIZE+1];

    friend bool operator<(const __PolicyModule&, const __PolicyModule&);

    __PolicyModule() 
    {
        memset(m_szCompanyName, 0, sizeof(m_szCompanyName));
        memset(m_szProductId, 0, sizeof(m_szProductId));
    }

} PolicyModule;


inline bool
operator<( 
    const PolicyModule& a, 
    const PolicyModule& b 
    )
/*++

++*/
{
    int iComp;

    iComp = _tcsicmp(a.m_szCompanyName, b.m_szCompanyName);
    if(iComp == 0)
    {
        iComp = _tcsicmp(a.m_szProductId, b.m_szProductId);
    }

    return iComp < 0;
}

//////////////////////////////////////////////////////////
//
// CTLSPolicyMgr must be a global object so destructor is 
// invoked at the end.
//
class CTLSPolicyMgr {

private:
    typedef map<PolicyModule, HMODULE, less<PolicyModule> > PMLoadedModuleMapType;
    typedef map<PolicyModule, CTLSPolicy*, less<PolicyModule> > PMProductPolicyMapType;
    typedef map<PolicyModule, PolicyModule, less<PolicyModule> > PMProductTransationMapType;

    //
    // Policy module per product
    //
    CRWLock     m_ProductPolicyModuleRWLock;
    PMProductPolicyMapType   m_ProductPolicyModule;

    //
    // List of loaded policy module
    //
    CRWLock     m_LoadedPolicyRWLock;
    PMLoadedModuleMapType m_LoadedPolicy; 

    //
    // List of Product transation
    //
    CRWLock     m_ProductTranslationRWLock;
    PMProductTransationMapType  m_ProductTranslation;


    HMODULE 
    LoadPolicyModule(
        LPCTSTR pszCompanyName,
        LPCTSTR pszProductCode,
        LPCTSTR pszDllName
    );
        
    //
    // Find policy module handle for a particular product
    //
    PMProductPolicyMapType::iterator 
    FindProductPolicyModule(
        LPCTSTR pszCompanyName,
        LPCTSTR pszProductId
    );

    //
    // Find policy module handle for a particular product
    //
    PMProductTransationMapType::iterator
    FindProductTransation(
        LPCTSTR pszCompanyName,
        LPCTSTR pszCHProductCode
    );
    
    void
    InsertProductTransation(
        LPCTSTR pszCompanyName,
        LPCTSTR pszCHProductCode,
        LPCTSTR pszTLSProductCode
    );

    DWORD
    GetSupportedProduct(
        HMODULE hModule,
        LPCTSTR pszDllName,
        LPCTSTR pszCompanyName,
        LPCTSTR pszProductId,
        PDWORD pdwNumProducts,
        PPMSUPPORTEDPRODUCT* pSupportedProduct
    );

    DWORD
    InsertProductPolicyModule(
        HMODULE hModule,
        BOOL bReplace,
        LPCTSTR pszCompanyName,
        LPCTSTR pszCHProductId,
        LPCTSTR pszTLSProductId,
        LPCTSTR pszDllName,
        DWORD dwFlag
    );

    DWORD
    UnloadPolicyModule(
        HINSTANCE hModule
    );
        
   
public:
    CTLSPolicyMgr();

    ~CTLSPolicyMgr();

    // 
    // Insert a policy module handle into Handle arrays.
    //
    DWORD
    AddPolicyModule( 
        BOOL bReplace,
        LPCTSTR pszCompanyName,
        LPCTSTR pszProductId,
        LPCTSTR pszDllName,
        DWORD dwFlag
    );

    DWORD
    UnloadPolicyModule(
        LPCTSTR pszCompanyName,
        LPCTSTR pszProductCode
    );

    //
    // Find a policy module for specific product
    //
    CTLSPolicy*
    AcquireProductPolicyModule(
        LPCTSTR pszCompanyName,
        LPCTSTR pszProductId
    );

    //
    // Find a translation for CH.
    //
    BOOL
    TranslateCHCodeToTlsCode(
        LPCTSTR pszCompanyName,
        LPCTSTR pszCHProductCode,
        LPTSTR pszTlsProductCode,
        PDWORD pdwBufferSize
    );

    //
    // Release a product policy module
    //
    void
    ReleaseProductPolicyModule( CTLSPolicy* p );

    //
    // Initialize All Product Policy Module
    //
    DWORD
    InitProductPolicyModule();
};

#ifdef __cplusplus
extern "C" {
#endif

    DWORD
    ServiceInitPolicyModule(void);

    DWORD
    ServiceLoadAllPolicyModule(
        IN HKEY hRoot,
        IN LPCTSTR pszSubkey
    );

    CTLSPolicy*
    AcquirePolicyModule(
        IN LPCTSTR pszCompanyName,
        IN LPCTSTR pszProductId,
        IN BOOL bUseProductPolicy
    );

    BOOL
    TranslateCHCodeToTlsCode(
        IN LPCTSTR pszCompanyName,
        IN LPCTSTR pszCHProductId,
        IN LPTSTR pszTLSProductId,
        IN OUT PDWORD pdwBufferSize
    );

    void
    ReleasePolicyModule(
        CTLSPolicy* ptr
    );

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\license\tlserver\server\postsrv.cpp ===
//+--------------------------------------------------------------------------
//
// Copyright (c) 1997-1999 Microsoft Corporation
//
// File:       postsrv.cpp
//
// Contents:   Post service initialize routine 
//
// History:     
//
//---------------------------------------------------------------------------
#include "pch.cpp"
#include "postsrv.h"
#include "tlsjob.h"
#include "globals.h"
#include "init.h"


extern BOOL g_bReportToSCM;

DWORD
PostServiceInit()
{
    DWORD dwStatus = ERROR_SUCCESS;
    FILETIME ftTime;
    HRESULT hrStatus = NULL;
    BOOL fInDomain;

    //
    // Initialize work manager
    //
    dwStatus = TLSWorkManagerInit();


	hrStatus =  g_pWriter->Initialize ();	// files to exclude

	if (FAILED (hrStatus))
	{
		
        DBGPrintf(
                DBG_INFORMATION,
                DBG_FACILITY_INIT,
                DBGLEVEL_FUNCTION_DETAILSIMPLE,
                _TEXT("CVssJetWriter::Initialize failed with error code %08x...\n"), 
                hrStatus
            );
	}


    if(dwStatus != ERROR_SUCCESS)
    {
        TLSLogEvent(
                EVENTLOG_ERROR_TYPE,
                TLS_E_WORKMANAGERGENERAL,
                TLS_E_WORKMANAGER_STARTUP,
                dwStatus
            );

        dwStatus = TLS_E_SERVICE_STARTUP_WORKMANAGER;
        return dwStatus;
    }

    //
    // Initialize namedpipe for client to test connect
    //
    dwStatus = InitNamedPipeThread();
    if(dwStatus != ERROR_SUCCESS)
    {
        TLSLogErrorEvent(TLS_E_SERVICE_STARTUP_CREATE_THREAD);
        dwStatus = TLS_E_SERVICE_STARTUP_CREATE_THREAD;
        return dwStatus;
    }

    if ((!(GetLicenseServerRole() & TLSERVER_ENTERPRISE_SERVER))
        && (ERROR_SUCCESS == TLSInDomain(&fInDomain,NULL) && (!fInDomain)))
    {
        //
        // Initialize mailslot thread to receive broadcast
        //
        dwStatus = InitMailSlotThread();
        if(dwStatus != ERROR_SUCCESS)
        {
            TLSLogErrorEvent(TLS_E_SERVICE_STARTUP_CREATE_THREAD);
            dwStatus = TLS_E_SERVICE_STARTUP_CREATE_THREAD;
            return dwStatus;
        }
    }

    //
    // Initialize thread to put expired permanent licenses back in pool
    //
    dwStatus = InitExpirePermanentThread();
    if(dwStatus != ERROR_SUCCESS)
    {
        TLSLogErrorEvent(TLS_E_SERVICE_STARTUP_CREATE_THREAD);
        dwStatus = TLS_E_SERVICE_STARTUP_CREATE_THREAD;
        return dwStatus;
    }

    DBGPrintf(
            DBG_INFORMATION,
            DBG_FACILITY_INIT,
            DBGLEVEL_FUNCTION_TRACE,
            _TEXT("Server is %s (0x%08x)\n"),
            (IS_ENFORCE_SERVER(TLS_CURRENT_VERSION)) ? _TEXT("Enforce") : _TEXT("Non-Enforce"),
            IS_ENFORCE_SERVER(TLS_CURRENT_VERSION)
        );
      
    // must be running as service and not in debug mode      
    if(g_bReportToSCM == TRUE)
    {
        if(!(GetLicenseServerRole() & TLSERVER_ENTERPRISE_SERVER))
        {
            GetServiceLastShutdownTime(&ftTime);
            dwStatus = TLSStartAnnounceLicenseServerJob(
                                                g_pszServerPid,
                                                g_szScope,
                                                g_szComputerName,
                                                &ftTime
                                            );
            if(dwStatus != ERROR_SUCCESS)
            {
                return dwStatus;
            }
        }

        GetServiceLastShutdownTime(&ftTime);
        dwStatus = TLSStartAnnounceToEServerJob(
                                            g_pszServerPid,
                                            g_szScope,
                                            g_szComputerName,
                                            &ftTime
                                        );
    }

    ServiceInitPolicyModule();
    return dwStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\license\tlserver\server\remotedb.cpp ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996-1998
//
// File:        remotedb.cpp
//
// Contents:    
//              all routine deal with cross table query
//
// History:     
//  Feb 4, 98      HueiWang    Created
//---------------------------------------------------------------------------
#include "pch.cpp"
#include "globals.h"
#include "remotedb.h"
#include "kp.h"
#include "lkpdesc.h"
#include "keypack.h"
#include "misc.h"

////////////////////////////////////////////////////////////////////////////
DWORD
TLSDBRemoteKeyPackAdd(
    IN PTLSDbWorkSpace pDbWkSpace,
    IN OUT PTLSLICENSEPACK lpKeyPack
    )
/*++


--*/
{

    DWORD dwStatus = ERROR_SUCCESS;
    BOOL bSuccess = TRUE;
    TLSLICENSEPACK found;

    if(pDbWkSpace == NULL || lpKeyPack == NULL)
    {
        SetLastError(dwStatus = ERROR_INVALID_PARAMETER);
        TLSASSERT(FALSE);
        return dwStatus;
    }

    //
    // Lock table for update
    //
    TLSDBLockKeyPackTable();


    //
    // Quick fix so that find keypack will work.

    lpKeyPack->dwPlatformType |= LSKEYPACK_PLATFORM_REMOTE;
    //lpKeyPack->ucAgreementType |= (LSKEYPACK_REMOTE_TYPE | LSKEYPACK_HIDDEN_TYPE);
    lpKeyPack->ucKeyPackStatus |= (LSKEYPACKSTATUS_REMOTE | LSKEYPACKSTATUS_HIDDEN);


    LicPackTable& licpackTable = pDbWkSpace->m_LicPackTable;

    dwStatus = TLSDBKeyPackEnumBegin(
                                pDbWkSpace,
                                TRUE,
                                LICENSEDPACK_FIND_PRODUCT,
                                lpKeyPack   
                            );

    if(dwStatus != ERROR_SUCCESS)
    {
        goto cleanup;
    }

    while(TRUE)
    {
        dwStatus = TLSDBKeyPackEnumNext(
                                    pDbWkSpace,
                                    &found
                                );

        if(dwStatus == TLS_I_NO_MORE_DATA)
        {
            break;
        }

        if(_tcsicmp(found.szInstallId, lpKeyPack->szInstallId) == 0)
        {
            // find product is based on company name, 
            // keypack id, product id, platform type, so
            // this is duplicate
            //
            dwStatus = TLS_E_DUPLICATE_RECORD;

            licpackTable.UpdateRecord(*lpKeyPack);
            
            break;
        }
    }

    TLSDBKeyPackEnumEnd(pDbWkSpace);

    if(dwStatus == TLS_I_NO_MORE_DATA && lpKeyPack->dwNumberOfLicenses > 0)
    {
        lpKeyPack->dwKeyPackId = TLSDBGetNextKeyPackId();
        bSuccess = licpackTable.InsertRecord(*lpKeyPack);

        if(bSuccess == FALSE)
        {
            if(licpackTable.GetLastJetError() == JET_errKeyDuplicate)
            {
                TLSASSERT(FALSE);   // this should no happen
                SetLastError(dwStatus=TLS_E_DUPLICATE_RECORD);
            }
            else
            {
                LPTSTR pString = NULL;
    
                TLSGetESEError(licpackTable.GetLastJetError(), &pString);

                TLSLogEvent(
                        EVENTLOG_ERROR_TYPE,
                        TLS_E_DBGENERAL,
                        TLS_E_JB_BASE,
                        licpackTable.GetLastJetError(),
                        (pString != NULL) ? pString : _TEXT("")
                    );

                if(pString != NULL)
                {
                    LocalFree(pString);
                }

                SetLastError(dwStatus = SET_JB_ERROR(licpackTable.GetLastJetError()));
                TLSASSERT(FALSE);
            }
        }
        else
        {
            dwStatus = ERROR_SUCCESS;
        }
    }


cleanup:

    TLSDBUnlockKeyPackTable();
    SetLastError(dwStatus);
    return dwStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\license\tlserver\server\postjob.cpp ===
//+--------------------------------------------------------------------------
//
// Copyright (c) 1997-1999 Microsoft Corporation
//
// File:       postjob.cpp 
//
// Contents:   Post various job to job manager 
//
// History:     
//
//---------------------------------------------------------------------------
#include "pch.cpp"
#include "postjob.h"
#include "tlsjob.h"
#include "globals.h"

////////////////////////////////////////////////////////////////
BOOL
IsLicensePackRepl(
    IN TLSLICENSEPACK* pLicensePack
    )
/*++

Abstract:

    Determine if license pack is replicable.

Parameter:

    pLicensePack - License Pack.

Returns:

    TRUE if license pack can be replicated to other serve
    FALSE otherwise.

Remark:

    Do not replicate FREE or special license pack.

--*/
{
    BOOL bYes = TRUE;

    if( 
        (pLicensePack->ucAgreementType == LSKEYPACKTYPE_FREE) || 
        (pLicensePack->ucAgreementType & (LSKEYPACK_REMOTE_TYPE | LSKEYPACK_HIDDEN_TYPE | LSKEYPACK_LOCAL_TYPE)) ||
        (pLicensePack->ucKeyPackStatus & (LSKEYPACKSTATUS_HIDDEN | LSKEYPACKSTATUS_REMOTE | LSKEYPACKSTATUS_LOCAL))
      )
    {
        bYes = FALSE;
    }

    if( bYes == TRUE )
    {
        UCHAR ucKeyPackStatus = (pLicensePack->ucKeyPackStatus & ~LSKEYPACKSTATUS_RESERVED);

        // don't replicate temp. license pack.
        if( ucKeyPackStatus == LSKEYPACKSTATUS_TEMPORARY )
        {
            bYes = FALSE;
        }
    }

    return bYes;
}


////////////////////////////////////////////////////////////////
BOOL
TLSCanForwardRequest(
    IN DWORD dwLocalServerVersion,
    IN DWORD dwTargetServerVersion
    )
/*++

Abstract:

    Determine if version of server is compatible.

Parameter:

    dwLocalServerVersion : Local server version.
    dwTargetServerVersion : Targer server version.

Returns:

    TRUE/FALSE.

Remark:

    Rules

    1) No forward to server version older than 5.1.
    2) Enforce to enforce, non-enforce to non-enforce only.
    3) Enterprise to enterprise only.
    4) domain/workgroup server to enterprise no enterprise
       to domain/workgroup.

--*/
{
    BOOL bCanForward;
    BOOL bLocalEnforce;
    BOOL bRemoteEnforce;

    bCanForward = TLSIsServerCompatible(
                                    dwLocalServerVersion,
                                    dwTargetServerVersion
                                );

    //bLocalEnforce = IS_ENFORCE_SERVER(dwLocalServerVersion);
    //bRemoteEnforce = IS_ENFORCE_SERVER(dwTargetServerVersion);

    //
    // No enforce to non-enforce replication
    //
    //if( bLocalEnforce != bRemoteEnforce )
    //{
    //    bCanForward = FALSE;
    //}

    if(bCanForward == TRUE)
    {
        BOOL bEnterpriseLocal = IS_ENTERPRISE_SERVER(dwLocalServerVersion);
        BOOL bEnterpriseRemote = IS_ENTERPRISE_SERVER(dwTargetServerVersion);

        if( g_SrvRole & TLSERVER_ENTERPRISE_SERVER )
        {
            bEnterpriseLocal = TRUE;
        }

        if(bEnterpriseLocal == TRUE && bEnterpriseRemote == FALSE)
        {
            bCanForward = FALSE;
        }
    }

    return bCanForward;
}

////////////////////////////////////////////////////////////////

BOOL
TLSIsServerCompatible(
    IN DWORD dwLocalServerVersion,
    IN DWORD dwTargetServerVersion
    )
/*++

Abstract:

    Determine if two server is compatible.

Parameters:

    dwLocalServerVersion : Local server version.
    dwTargetServerVersion : Target server version.

Return:

    TRUE/FALSE.

Remark:

    1) No server older than 5.1
    2) Enforce to enforce and non-enforce to non-enforce only

--*/
{
    DWORD dwTargetMajor = GET_SERVER_MAJOR_VERSION(dwTargetServerVersion);
    DWORD dwTargetMinor = GET_SERVER_MINOR_VERSION(dwTargetServerVersion);

    //
    // This version of License Server is not compatible with anyother
    if(dwTargetMajor == 5 && dwTargetMinor == 0)
    {
        return FALSE;
    }

    return (IS_ENFORCE_SERVER(dwLocalServerVersion) == IS_ENFORCE_SERVER(dwTargetServerVersion));
}

////////////////////////////////////////////////////////////////

BOOL
TLSCanPushReplicateData(
    IN DWORD dwLocalServerVersion,
    IN DWORD dwTargetServerVersion
    )
/*++

Abstract:

    Determine if local server can 'push' replicate
    data to remote server.

Parameters:

    dwLocalServerVersion : Local server version.
    dwTargetServerVersion : Target server version.

Returns:

    TRUE/FALSE.

Remark:
    
    1) See TLSIsServerCompatible().
    2) only one-way from enterprise to 
       domain/workgroup server.

--*/
{
    BOOL bCanReplicate;
    BOOL bLocalEnforce;
    BOOL bRemoteEnforce;

    bCanReplicate = TLSIsServerCompatible(
                                    dwLocalServerVersion,
                                    dwTargetServerVersion
                                );

    bLocalEnforce = IS_ENFORCE_SERVER(dwLocalServerVersion);
    bRemoteEnforce = IS_ENFORCE_SERVER(dwTargetServerVersion);
    //
    // No enforce to non-enforce replication
    //
    if( bLocalEnforce != bRemoteEnforce )
    {
        bCanReplicate = FALSE;
    }

    if(bCanReplicate == TRUE)
    {
        BOOL bEnterpriseLocal = IS_ENTERPRISE_SERVER(dwLocalServerVersion);
        BOOL bEnterpriseRemote = IS_ENTERPRISE_SERVER(dwTargetServerVersion);

        if( g_SrvRole & TLSERVER_ENTERPRISE_SERVER )
        {
            bEnterpriseLocal = TRUE;
        }

        if(bEnterpriseLocal == FALSE && bEnterpriseRemote == TRUE)
        {
            bCanReplicate = FALSE;
        }
    }

    return bCanReplicate;
}

        
////////////////////////////////////////////////////////////////

DWORD
PostSsyncLkpJob(
    IN PSSYNCLICENSEPACK syncLkp
    )
/*++

Abstract:

    Wrapper to post a sync. license pack job to work manager.

Parameter:

    syncLkp : License pack and other info to be sync.

Returns:

    ERROR_SUCCESS or error code.

--*/
{
    DWORD dwStatus = ERROR_SUCCESS;

    CSsyncLicensePack* pSyncLicensePack;

    pSyncLicensePack = new CSsyncLicensePack(
                                        TRUE,
                                        syncLkp,
                                        sizeof(SSYNCLICENSEPACK)
                                    );

    //
    // Set work default interval/retry times
    //
    TLSWorkManagerSetJobDefaults(pSyncLicensePack);
    dwStatus = TLSWorkManagerSchedule(0, pSyncLicensePack);

    if(dwStatus != ERROR_SUCCESS)
    {
        TLSLogEvent(
            EVENTLOG_ERROR_TYPE,
            TLS_E_WORKMANAGERGENERAL,
            TLS_E_WORKMANAGER_SCHEDULEJOB,
            dwStatus
        );

        delete pSyncLicensePack;
    }  

    return dwStatus;
}

//--------------------------------------------------------------------

DWORD
TLSAnnounceLKPToAllRemoteServer(
    IN DWORD dwKeyPackId,
    IN DWORD dwDelayTime
    )
/*++

Abstract:

    Announce a license pack by its internal ID to all 
    known server.

Parameter:

    dwKeyPackId : License keypack's internal tracking Id.

Returns:

    ERROR_SUCCESS or error code.

--*/
{
    PTLServerInfo pServerInfo = NULL;
    DWORD dwStatus = ERROR_SUCCESS;
    DWORD dwCount;

    DBGPrintf(
            DBG_INFORMATION,
            DBG_FACILITY_JOB,
            DBGLEVEL_FUNCTION_TRACE,
            _TEXT("Announce %d LKP to servers...\n"),
            dwKeyPackId
        );

    SSYNCLICENSEPACK SsyncLkp;
    memset(
            &SsyncLkp,
            0, 
            sizeof(SSYNCLICENSEPACK)
        );

    SsyncLkp.dwStructVersion = CURRENT_SSYNCLICENSEKEYPACK_STRUCT_VER;
    SsyncLkp.dwStructSize = sizeof(SSYNCLICENSEPACK);

    SsyncLkp.dwSyncType = SSYNC_ONE_LKP;
    SsyncLkp.dwKeyPackId = dwKeyPackId;
    SsyncLkp.dwNumServer = 0;

    SAFESTRCPY(SsyncLkp.m_szServerId, g_pszServerPid);
    SAFESTRCPY(SsyncLkp.m_szServerName, g_szComputerName);

    //
    // Lock known server list
    //
    TLSBeginEnumKnownServerList();

    while((pServerInfo = TLSGetNextKnownServer()) != NULL)
    {
        if(TLSCanPushReplicateData(
                            TLS_CURRENT_VERSION,
                            pServerInfo->GetServerVersion()
                        ) == FALSE)
        {
            continue;
        }

        if(pServerInfo->IsServerSupportReplication() == FALSE)
        {
            continue;
        }

        if(SsyncLkp.dwNumServer >= SSYNCLKP_MAX_TARGET)
        {
            dwStatus = PostSsyncLkpJob(&SsyncLkp);

            if(dwStatus != ERROR_SUCCESS)
            {
                break;
            }

            SsyncLkp.dwNumServer = 0;
        }

        SAFESTRCPY(
                SsyncLkp.m_szTargetServer[SsyncLkp.dwNumServer],
                pServerInfo->GetServerName()
            );
        
        SsyncLkp.dwNumServer++;
    }

    TLSEndEnumKnownServerList();

    if(dwStatus == ERROR_SUCCESS && SsyncLkp.dwNumServer != 0)
    {
        dwStatus = PostSsyncLkpJob(&SsyncLkp);
    }

    return dwStatus;
}    


/////////////////////////////////////////////////////////////////////////

DWORD
TLSPushSyncLocalLkpToServer(
    IN LPTSTR pszSetupId,
    IN LPTSTR pszDomainName,
    IN LPTSTR pszLserverName,
    IN FILETIME* pSyncTime
    )
/*++

Abstract:

    'Push' sync registered license pack to other server.

Parameters:

    pszSetupId : Remote server's setup ID.
    pszDomainName : Remote server's domain name.
    pszLserverName : Remote server name.
    pSyncTime : Pointer to FILETIME, sync. all license pack with the time stamp 
                greater or equal to this time will be 'push' sync.

Returns:

    ERROR_SUCCESS or error code.

--*/
{
    DWORD dwStatus = ERROR_SUCCESS;
    TLServerInfo ServerInfo;
    SSYNCLICENSEPACK SsyncLkp;

    //
    // resolve ServerId to server name
    // 
    dwStatus = TLSLookupRegisteredServer(
                                    pszSetupId,
                                    pszDomainName,
                                    pszLserverName,
                                    &ServerInfo
                                );

    if(dwStatus != ERROR_SUCCESS)
    {
        goto cleanup;
    }

    //
    // Make sure local server can push replicate
    // data to remote server.
    //
    if(TLSCanPushReplicateData(
                        TLS_CURRENT_VERSION,
                        ServerInfo.GetServerVersion()
                    ) == FALSE)
    {
        goto cleanup;
    }

    //
    // Form a sync work object and post it to work manager.
    //        
    memset(
            &SsyncLkp,
            0, 
            sizeof(SSYNCLICENSEPACK)
        );

    SsyncLkp.dwStructVersion = CURRENT_SSYNCLICENSEKEYPACK_STRUCT_VER;
    SsyncLkp.dwStructSize = sizeof(SSYNCLICENSEPACK);
    SAFESTRCPY(SsyncLkp.m_szServerId, g_pszServerPid);
    SAFESTRCPY(SsyncLkp.m_szServerName, g_szComputerName);

    SsyncLkp.dwSyncType = SSYNC_ALL_LKP;
    SsyncLkp.dwNumServer = 1;
    SAFESTRCPY(
            SsyncLkp.m_szTargetServer[0],
            ServerInfo.GetServerName()
        );

    SsyncLkp.m_ftStartSyncTime = *pSyncTime;

    dwStatus = PostSsyncLkpJob(&SsyncLkp);

cleanup:
    return dwStatus;
}    

////////////////////////////////////////////////////////////////
DWORD
TLSStartAnnounceResponseJob(
    IN LPTSTR pszTargetServerId,
    IN LPTSTR pszTargetServerDomain,
    IN LPTSTR pszTargetServerName,
    IN FILETIME* pftTime
    )
/*++

Abstract:

    Create a License Server Announcement response work object and post it
    to work manager.

Parameter:

    pszTargetServerId : Target server Id.
    pszTargetServerDomain : Target server's domain.
    pszTargetServerName : Target server name.
    pftTime : Pointer to FILE, local server's last shutdown time.

Returns:

    ERROR_SUCCESS or error code.

--*/
{
    DWORD dwStatus = ERROR_SUCCESS;
    ANNOUNCERESPONSEWO response;
    TLServerInfo ServerInfo;
    CAnnounceResponse* pAnnounceResponse = NULL;


    //
    // Perform lookup on server to determine its eligibility 
    //
    dwStatus = TLSLookupRegisteredServer(
                                    pszTargetServerId,
                                    pszTargetServerDomain,
                                    pszTargetServerName,
                                    &ServerInfo
                                );

    if(dwStatus != ERROR_SUCCESS)
    {
        // can't find server, no response
        goto cleanup;
    }

    memset(&response, 0, sizeof(response));
    response.dwStructVersion = CURRENT_ANNOUNCERESPONSEWO_STRUCT_VER;
    response.dwStructSize = sizeof(response);
    response.bCompleted = FALSE;
    SAFESTRCPY(response.m_szTargetServerId, pszTargetServerId);
    SAFESTRCPY(response.m_szLocalServerId, g_pszServerPid);
    SAFESTRCPY(response.m_szLocalServerName, g_szComputerName);
    SAFESTRCPY(response.m_szLocalScope, g_szScope);
    response.m_ftLastShutdownTime = *pftTime;

    pAnnounceResponse = new CAnnounceResponse(
                                        TRUE, 
                                        &response, 
                                        sizeof(response)
                                    );

    //
    // Set work default interval/retry times
    //
    TLSWorkManagerSetJobDefaults(pAnnounceResponse);
    dwStatus = TLSWorkManagerSchedule(0, pAnnounceResponse);

    if(dwStatus != ERROR_SUCCESS)
    {
        TLSLogEvent(
                EVENTLOG_ERROR_TYPE,
                TLS_E_WORKMANAGERGENERAL,
                TLS_E_WORKMANAGER_SCHEDULEJOB,
                dwStatus
            );

        delete pAnnounceResponse;
    }    

cleanup:
    return dwStatus;
}
    

/////////////////////////////////////////////////////////////////////

DWORD
TLSStartAnnounceToEServerJob(
    IN LPCTSTR pszServerId,
    IN LPCTSTR pszServerDomain,
    IN LPCTSTR pszServerName,
    IN FILETIME* pftFileTime
    )
/*++

Abstract:

    Create a Enterprise server discovery job and post it to work 
    manager.

Parameters:
    
    pszServerId : Local server's ID.
    pszServerDomain : Local server's domain.
    pszServerName : Local server name.
    pftFileTime : Pointer to FILETIME, local server's last shutdown time.

Returns:

    ERROR_SUCCESS or error code.

--*/
{
    DWORD dwStatus = ERROR_SUCCESS;

    ANNOUNCETOESERVERWO AnnounceToES;

    memset(&AnnounceToES, 0, sizeof(AnnounceToES));

    AnnounceToES.dwStructVersion = CURRENT_ANNOUNCETOESERVEWO_STRUCT_VER;
    AnnounceToES.dwStructSize = sizeof(ANNOUNCETOESERVERWO);
    AnnounceToES.bCompleted = FALSE;

    SAFESTRCPY(AnnounceToES.m_szServerId, pszServerId);
    SAFESTRCPY(AnnounceToES.m_szServerName, pszServerName);
    SAFESTRCPY(AnnounceToES.m_szScope, pszServerDomain);
    AnnounceToES.m_ftLastShutdownTime = *pftFileTime;

    CAnnounceToEServer* pAnnounceESWO = NULL;

    pAnnounceESWO = new CAnnounceToEServer(
                                        TRUE, 
                                        &AnnounceToES, 
                                        sizeof(ANNOUNCETOESERVERWO)
                                    );

    //
    // Set work default interval/retry times
    //
    TLSWorkManagerSetJobDefaults(pAnnounceESWO);
    dwStatus = TLSWorkManagerSchedule(0, pAnnounceESWO);

    if(dwStatus != ERROR_SUCCESS)
    {
        TLSLogEvent(
            EVENTLOG_ERROR_TYPE,
            TLS_E_WORKMANAGERGENERAL,
            TLS_E_WORKMANAGER_SCHEDULEJOB,
            dwStatus
        );

        delete pAnnounceESWO;
    }

    return dwStatus;
}

/////////////////////////////////////////////////////////////////////////

DWORD
TLSStartAnnounceLicenseServerJob(
    IN LPCTSTR pszServerId,
    IN LPCTSTR pszServerDomain,
    IN LPCTSTR pszServerName,
    IN FILETIME* pftFileTime
    )
/*++

Abstract:

    Create a license server announcement job and post it to work
    manager.

Parameters:

    pszServerId : Local server's ID.
    pszServerDomain : Local server domain.
    pszServerName : Local server name.
    pftFileTime : Pointer to FILETIME, local server's last shutdown time.

Returns:

    ERROR_SUCCESS or error code.

--*/
{
    DWORD dwStatus = ERROR_SUCCESS;

    //
    // Create a CAnnounce Server work.
    //
    ANNOUNCESERVERWO AnnounceLs;

    memset(&AnnounceLs, 0, sizeof(AnnounceLs));

    AnnounceLs.dwStructVersion = CURRENT_ANNOUNCETOESERVEWO_STRUCT_VER;
    AnnounceLs.dwStructSize = sizeof(ANNOUNCETOESERVERWO);
    AnnounceLs.dwRetryTimes = 0;

    SAFESTRCPY(AnnounceLs.m_szServerId, pszServerId);
    SAFESTRCPY(AnnounceLs.m_szServerName, pszServerName);
    SAFESTRCPY(AnnounceLs.m_szScope, pszServerDomain);
    AnnounceLs.m_ftLastShutdownTime = *pftFileTime;

    CAnnounceLserver* pAnnounceWO = NULL;

    pAnnounceWO = new CAnnounceLserver(
                                    TRUE, 
                                    &AnnounceLs, 
                                    sizeof(ANNOUNCETOESERVERWO)
                                );

    //
    // Set work default interval/retry times
    //
    
    // Don't take other parameter for Announce Server
    // TLSWorkManagerSetJobDefaults(pAnnounceWO);

    dwStatus = TLSWorkManagerSchedule(0, pAnnounceWO);

    if(dwStatus != ERROR_SUCCESS)
    {
        TLSLogEvent(
            EVENTLOG_ERROR_TYPE,
            TLS_E_WORKMANAGERGENERAL,
            TLS_E_WORKMANAGER_SCHEDULEJOB,
            dwStatus
        );

        delete pAnnounceWO;
    }

    return dwStatus;
}

////////////////////////////////////////////////////////////////
DWORD
TLSPostReturnClientLicenseJob(
    IN PLICENSEDPRODUCT pLicProduct
    )
/*++

Abstract:

    Create a return license work object and post it to work manager.

Parameters:

    pLicProduct : Licensed product to be return/revoke...

Returns:

    ERROR_SUCCESS or error success.

Remark:

    Return license is a persistent job.

--*/
{
    DWORD dwStatus = ERROR_SUCCESS;
    RETURNLICENSEWO retlic;
    CReturnLicense* pReturnLicenseWO = NULL;


    //---------------------------------------------------------------

    if( pLicProduct == NULL || pLicProduct->pLicensedVersion == NULL ||
        pLicProduct->LicensedProduct.cbEncryptedHwid >= sizeof(retlic.pbEncryptedHwid) )
    {
        TLSASSERT(FALSE);
        SetLastError(dwStatus = ERROR_INVALID_DATA);
        goto cleanup;
    }

    memset(&retlic, 0, sizeof(retlic));

    retlic.dwStructVersion = CURRENT_RETURNLICENSEWO_STRUCT_VER;
    retlic.dwStructSize = sizeof(retlic);

    retlic.dwNumRetry = 0;
    SAFESTRCPY(retlic.szTargetServerId, pLicProduct->szIssuerId);
    SAFESTRCPY(retlic.szTargetServerName, pLicProduct->szIssuer);

    retlic.dwQuantity = pLicProduct->dwQuantity;
    retlic.dwKeyPackId = pLicProduct->ulSerialNumber.HighPart;
    retlic.dwLicenseId = pLicProduct->ulSerialNumber.LowPart;
    retlic.dwReturnReason = LICENSERETURN_UPGRADE;
    retlic.dwPlatformId = pLicProduct->LicensedProduct.dwPlatformID;

    retlic.cbEncryptedHwid = pLicProduct->LicensedProduct.cbEncryptedHwid;
    memcpy(
            retlic.pbEncryptedHwid,
            pLicProduct->LicensedProduct.pbEncryptedHwid,
            pLicProduct->LicensedProduct.cbEncryptedHwid
        );

    retlic.dwProductVersion = MAKELONG( 
                                    pLicProduct->pLicensedVersion->wMinorVersion, 
                                    pLicProduct->pLicensedVersion->wMajorVersion
                                );

    memcpy(
            retlic.szOrgProductID,
            pLicProduct->pbOrgProductID,
            min(sizeof(retlic.szOrgProductID) - sizeof(TCHAR), pLicProduct->cbOrgProductID)
        );

    memcpy(
            retlic.szCompanyName,
            pLicProduct->LicensedProduct.pProductInfo->pbCompanyName,
            min(sizeof(retlic.szCompanyName)-sizeof(TCHAR), pLicProduct->LicensedProduct.pProductInfo->cbCompanyName)
        );

    memcpy(
            retlic.szProductId,
            pLicProduct->LicensedProduct.pProductInfo->pbProductID,
            min(sizeof(retlic.szProductId)-sizeof(TCHAR), pLicProduct->LicensedProduct.pProductInfo->cbProductID)
        );

    lstrcpy(
            retlic.szUserName,
            pLicProduct->szLicensedUser
        );

    lstrcpy(
            retlic.szMachineName,
            pLicProduct->szLicensedClient
        );

    pReturnLicenseWO = new CReturnLicense(
                                        TRUE,
                                        &retlic,
                                        sizeof(retlic)
                                    );

    //
    // Set work default interval/retry times
    //
    
    // Don't take other parameter for Announce Server
    // TLSWorkManagerSetJobDefaults(pAnnounceWO);

    dwStatus = TLSWorkManagerSchedule(0, pReturnLicenseWO);

    if(dwStatus != ERROR_SUCCESS)
    {
        TLSLogEvent(
            EVENTLOG_ERROR_TYPE,
            TLS_E_WORKMANAGERGENERAL,
            TLS_E_WORKMANAGER_SCHEDULEJOB,
            dwStatus
        );
    }

    //
    // Work storage will make a copy of this job so we need
    // to delete it.
    //
    delete pReturnLicenseWO;

cleanup:

    return dwStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\license\tlserver\server\server.h ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996-1998
//
// File:        server.h
//
// Contents:    Hydra License Server Service Control Manager Interface
//
// History:     12-09-97    HueiWang    Modified from MSDN RPC Service Sample
//              07-27-98    HueiWang    Port to JetBlue
//
//---------------------------------------------------------------------------
#ifndef __SERVER_H_
#define __SERVER_H_
#include <windows.h>
#include <winsock2.h>
#include <stdio.h>
#include <stdlib.h>
#include <tchar.h>
#include <time.h>

#include "license.h"

//
// TLSDb
//
#include "JBDef.h"
#include "JetBlue.h"
#include "TLSDb.h"

#include "backup.h"
#include "KPDesc.h"
#include "Licensed.h"
#include "licpack.h"
#include "version.h"
#include "workitem.h"

//
// Current RPC interface
//
#include "tlsrpc.h"
#include "tlsdef.h"
#include "tlsapi.h"
#include "tlsapip.h"
#include "tlspol.h"

//
//
#include "messages.h"

#include "tlsassrt.h"
#include "trust.h"
#include "svcrole.h"
#include "common.h"
#include "lscommon.h"

#include "Cryptkey.h"
#include "licekpak.h"

#include "clrhouse.h"
#include "dblevel.h"
#include "SrvDef.h"
#include "policy.h"
#include "wkspace.h"
#include "tlsjob.h"
#include "srvlist.h"
#include "debug.h"


#if DBG
typedef enum {
    RPC_CALL_CONNECT,
    RPC_CALL_SEND_CERTIFICATE,
    RPC_CALL_GET_SERVERNAME,
    RPC_CALL_GET_SERVERSCOPE,
    RPC_CALL_GETINFO,
    RPC_CALL_GET_LASTERROR,
    RPC_CALL_ISSUEPLATFORMCHLLENGE,
    RPC_CALL_ALLOCATECONCURRENT,
    RPC_CALL_ISSUENEWLICENSE,
    RPC_CALL_UPGRADELICENSE,
    RPC_CALL_KEYPACKENUMBEGIN,
    RPC_CALL_KEYPACKENUMNEXT,
    RPC_CALL_KEYPACKENUMEND,
    RPC_CALL_KEYPACKADD,
    RPC_CALL_KEYPACKSETSTATUS,
    RPC_CALL_LICENSEENUMBEGIN,
    RPC_CALL_LICENSEENUMNEXT,
    RPC_CALL_LICENSEENUMEND,
    RPC_CALL_LICENSESETSTATUS,
    RPC_CALL_INSTALL_SERV_CERT,
    RPC_CALL_GETSERV_CERT,
    RPC_CALL_REGISTER_LICENSE_PACK,
    RPC_CALL_REQUEST_TERMSRV_CERT,
    RPC_CALL_RETRIEVE_TERMSRV_CERT,
    RPC_CALL_GETPKCS10CERT_REQUEST,
    RPC_CALL_ANNOUNCE_SERVER,
    RPC_CALL_SERVERLOOKUP,
    RPC_CALL_ANNOUNCELICENSEPACK,
    RPC_CALL_RETURNLICENSE,
    RPC_CALL_RETURNKEYPACK,
    RPC_CALL_GETPRIVATEDATA,
    RPC_CALL_SETPRIVATEDATA,
    RPC_CALL_CHALLENGESERVER,
    RPC_CALL_RESPONSESERVERCHALLENGE,
    RPC_CALL_TRIGGERREGENKEY,
    RPC_CALL_TELEPHONEREGISTERLKP,
    RPC_CALL_ALLOCATEINTERNETLICNESEEX,
    RPC_CALL_RETURNINTERNETLICENSEEX,
    RPC_CALL_RETURNINTERNETLICENSE
} DBG_RPC_CALL;
#endif

//---------------------------------------------------------------------------
typedef enum {
    LSCERT_RDN_STRING_TYPE,
    LSCERT_RDN_NAME_INFO_TYPE,
    LSCERT_RDN_NAME_BLOB_TYPE,
    LSCERT_CLIENT_INFO_TYPE
} TLSCLIENTCERTRDNTYPE;

typedef struct __LSClientInfo {
    LPTSTR szUserName;
    LPTSTR szMachineName;
    PHWID  pClientID;
} TLSClientInfo, *PTLSClientInfo, *LPTLSClientInfo;

typedef struct __LSClientCertRDN {
    TLSCLIENTCERTRDNTYPE  type;

    union {
        LPTSTR szRdn;
        PCERT_NAME_INFO pCertNameInfo;
        TLSClientInfo ClientInfo;
        PCERT_NAME_BLOB pNameBlob;
    };
} TLSClientCertRDN, *PTLSClientCertRDN, *LPTLSClientCertRDN;



//---------------------------------------------------------------------------
typedef struct _DbLicensedProduct {
    DWORD dwQuantity;

    ULARGE_INTEGER ulSerialNumber;

    DWORD dwKeyPackId;
    DWORD dwLicenseId;
    DWORD dwKeyPackLicenseId;
    DWORD dwNumLicenseLeft;

    HWID  ClientHwid;

    FILETIME NotBefore;
    FILETIME NotAfter;

    BOOL bTemp; // temporary license


    // licensed product version
    DWORD dwProductVersion;

    // manufaturer name
    TCHAR szCompanyName[LSERVER_MAX_STRING_SIZE+1];

    // licensed product Id
    TCHAR szLicensedProductId[LSERVER_MAX_STRING_SIZE+1];

    // original license request product ID
    TCHAR szRequestProductId[LSERVER_MAX_STRING_SIZE+1];

    TCHAR szUserName[LSERVER_MAX_STRING_SIZE+1];
    TCHAR szMachineName[LSERVER_MAX_STRING_SIZE+1];

    //
    DWORD dwLanguageID;
    DWORD dwPlatformID;

    PBYTE pbPolicyData;
    DWORD cbPolicyData;

    PCERT_PUBLIC_KEY_INFO   pSubjectPublicKeyInfo;
} TLSDBLICENSEDPRODUCT, *PTLSDBLICENSEDPRODUCT, *LPTLSDBLICENSEDPRODUCT;


//---------------------------------------------------------------------------
typedef struct __TLSDbLicenseRequest {
    CTLSPolicy*         pPolicy;
    PMHANDLE            hClient;

    //
    // Product request
    //
    DWORD               dwProductVersion;

    LPTSTR              pszCompanyName;
    LPTSTR              pszProductId;

    DWORD               dwLanguageID;
    DWORD               dwPlatformID;

    //
    // Client information
    //
    HWID                hWid;
    PBYTE               pbEncryptedHwid;
    DWORD               cbEncryptedHwid;

    TCHAR               szMachineName[MAX_COMPUTERNAME_LENGTH + 2];
    TCHAR               szUserName[MAXUSERNAMELENGTH+1];

    //
    // detail of licensing chain
    WORD                wLicenseDetail;


    //
    // special things to be put into certificate
    //
    PCERT_PUBLIC_KEY_INFO pClientPublicKey;
    TLSClientCertRDN     clientCertRdn;

    DWORD               dwNumExtensions;
    PCERT_EXTENSION     pExtensions;

    //
    // Policy Extension Data
    //
    //PBYTE               pbPolicyExtensionData;
    //DWORD               cbPolicyExtensionData;

    PPMLICENSEREQUEST   pClientLicenseRequest;      // original client license request
    PPMLICENSEREQUEST   pPolicyLicenseRequest;      // policy adjusted license request

    //
    // To do ?
    //  consider a callback routine but are we getting
    //  into issuing certificate business.
    //
} TLSDBLICENSEREQUEST, *PTLSDBLICENSEREQUEST, *LPTLSDBLICENSEREQUEST;


typedef struct __ForwardNewLicenseRequest {
    CHALLENGE_CONTEXT m_ChallengeContext;
    TLSLICENSEREQUEST* m_pRequest;
    LPTSTR m_szMachineName;
    LPTSTR m_szUserName;
    DWORD m_cbChallengeResponse;
    PBYTE m_pbChallengeResponse;

    // no forward on request.
} TLSForwardNewLicenseRequest, *PTLSForwardNewLicenseRequest, *LPTLSForwardNewLicenseRequest;

typedef struct __ForwardUpgradeRequest {
    TLSLICENSEREQUEST* m_pRequest;
    CHALLENGE_CONTEXT m_ChallengeContext;
    DWORD m_cbChallengeResponse;
    PBYTE m_pbChallengeResponse;
    DWORD m_cbOldLicense;
    PBYTE m_pbOldLicense;
} TLSForwardUpgradeLicenseRequest, *PTLSForwardUpgradeLicenseRequest, *LPTLSForwardUpgradeLicenseRequest;


//---------------------------------------------------------------------------
//
#define CLIENT_INFO_HYDRA_SERVER                0xFFFFFFFF

typedef enum {
    CONTEXTHANDLE_EMPTY_TYPE=0,
    CONTEXTHANDLE_KEYPACK_ENUM_TYPE,
    CONTEXTHANDLE_LICENSE_ENUM_TYPE,
    CONTEXTHANDLE_CLIENTINFO_TYPE,
    CONTEXTHANDLE_CLIENTCHALLENGE_TYPE,
    CONTEXTHANDLE_HYDRA_REQUESTCERT_TYPE,
    CONTEXTHANDLE_CHALLENGE_SERVER_TYPE,
    CONTEXTHANDLE_CHALLENGE_LRWIZ_TYPE,
    CONTEXTHANDLE_CHALLENGE_TERMSRV_TYPE
} CONTEXTHANDLE_TYPE;

// No access
#define CLIENT_ACCESS_NONE      0x00000000

// only keypack/license enumeration
#define CLIENT_ACCESS_USER      0x00000001

// Administrator, can update value but can't
// request license
#define CLIENT_ACCESS_ADMIN     0x00000002

// Client can request license no update
// database value
#define CLIENT_ACCESS_REQUEST   0x00000004

// client is registration wizard
// only install certificate
#define CLIENT_ACCESS_LRWIZ     0x00000008

// client is license server, allow
// full access
#define CLIENT_ACCESS_LSERVER   0xFFFFFFFF

#define CLIENT_ACCESS_DEFAULT   CLIENT_ACCESS_USER


typedef struct __ClientContext {
    #if DBG
    DWORD   m_PreDbg[2];            // debug signature
    DBG_RPC_CALL   m_LastCall;             // last call
    #endif

    LPTSTR  m_Client;
    long    m_RefCount;
    DWORD   m_ClientFlags;

    DWORD   m_LastError;
    CONTEXTHANDLE_TYPE m_ContextType;
    HANDLE  m_ContextHandle;

    // NEEDED - A list to store all memory/handle
    //          allocated for the client

    #if DBG
    DWORD   m_PostDbg[2];               // debug signature
    #endif

} CLIENTCONTEXT, *LPCLIENTCONTEXT;

//---------------------------------------------------------------

typedef struct __ENUMHANDLE {
    typedef enum {
        FETCH_NEXT_KEYPACK=1,
        FETCH_NEXT_KEYPACKDESC,
        FETCH_NEW_KEYPACKDESC
    } ENUM_FETCH_CODE;

    PTLSDbWorkSpace pbWorkSpace;
    TLSLICENSEPACK  CurrentKeyPack;         // current fetched keypack record

    LICPACKDESC     KPDescSearchValue;      // licensepack search value
    DWORD           dwKPDescSearchParm;     // licensepackdesc search parameter
    BOOL            bKPDescMatchAll;        // match all condition for keypackdesc
    CHAR            chFetchState;
} ENUMHANDLE, *LPENUMHANDLE;

typedef struct __TERMSERVCERTREQHANDLE {
    PTLSHYDRACERTREQUEST    pCertRequest;
    DWORD                   cbChallengeData;
    PBYTE                   pbChallengeData;
} TERMSERVCERTREQHANDLE, *LPTERMSERVCERTREQHANDLE;

typedef struct __ClientChallengeContext {
    DWORD       m_ClientInfo;
    HANDLE      m_ChallengeContext;
} CLIENTCHALLENGECONTEXT, *LPCLIENTCHALLENGECONTEXT;

typedef enum {
    ALLOCATE_EXACT_VERSION=0,
    ALLOCATE_ANY_GREATER_VERSION,
    ALLOCATE_LATEST_VERSION             // not supported
} LICENSE_ALLOCATION_SCHEME;

typedef struct __AllocateRequest {
    UCHAR       ucAgreementType;  // keypack type
    LPTSTR      szCompanyName;  // company name
    LPTSTR      szProductId;    // product
    DWORD       dwVersion;      // version wanted
    DWORD       dwPlatformId;   // license platform
    DWORD       dwLangId;       // unused

    DWORD       dwNumLicenses;  // number of license wanted/returned

    LICENSE_ALLOCATION_SCHEME dwScheme;

    // TODO - CallBack function to let calling
    // function decide

} TLSDBAllocateRequest, *PTLSDBAllocateRequest, *LPTLSDBAllocateRequest;

typedef struct __LicenseAllocation {
    // array size for dwAllocationVector
    DWORD       dwBufSize;

    //
    // Total license allocated
    DWORD       dwTotalAllocated;

    // number of license allocate from
    // each keypack
    DWORD*      pdwAllocationVector;

    // keypack that license allocate from
    PLICENSEPACK   lpAllocateKeyPack;
} TLSDBLicenseAllocation, *PTLSDBLicenseAllocation, *LPTLSDBLicenseAllocation;

//---------------------------------------------------------------------
//----------------------------------------------------------------------------
#ifdef __cplusplus
extern "C" {
#endif

    BOOL
    WaitForMyTurnOrShutdown(
        HANDLE hHandle,
        DWORD dwWaitTime
    );

    HANDLE
    GetServiceShutdownHandle();

    void
    ServiceSignalShutdown();

    void
    ServiceResetShutdownEvent();

    BOOL
    AcquireRPCExclusiveLock(
        IN DWORD dwWaitTime
    );

    void
    ReleaseRPCExclusiveLock();

    BOOL
    AcquireAdministrativeLock(
        IN DWORD dwWaitTime
    );

    void
    ReleaseAdministrativeLock();

    DWORD
    TLSMapReturnCode(DWORD);

    unsigned int WINAPI
    MailSlotThread(
        void* ptr
    );

    HANDLE
    ServerInit(
        BOOL bDebug
    );

    DWORD
    InitNamedPipeThread();

    DWORD
    InitMailSlotThread();

    DWORD
    InitExpirePermanentThread();

    BOOL
    IsServiceShuttingdown();

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\license\tlserver\server\sources.inc ===
!IF 0

Copyright (c) 1989  Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


Author:


NOTE:   Commented description of this file is in \nt\bak\bin\sources.tpl


!ENDIF

!include $(LSERVER_ROOT)\lserver.mk

INCLUDES = \
    $(INCLUDES); \
    $(LICENSE_ROOT)\lkplite; \
    $(DRIVERS_INC_PATH);

MINORCOMP=lserver

INCPATH0=$(INCLUDE)

TARGETNAME=$(MINORCOMP)
TARGETPATH=obj
TARGETTYPE=PROGRAM

PASS0_HEADERDIR=$(O)
MC_SOURCEDIR=$(O)

USE_MSVCRT=1
USE_NATIVE_EH=ASYNC
USE_STL=1
USE_RTTI=1

C_DEFINES=$(C_DEFINES) -DIGNORE_EXPIRATION

UMTYPE=console

LINKER_STACKCOMMITSIZE=16384

SOURCES= \
    ..\messages.mc \
    ..\debug.cpp \
    ..\misc.cpp \
    ..\db.cpp \
    ..\pid.cpp \
    ..\init.cpp \
    ..\utils.cpp \
    ..\remotedb.cpp \
    ..\postjob.cpp \
    ..\globals.cpp \
    ..\postsrv.cpp \
    ..\tlscert.cpp \
    ..\npipe.cpp \
    ..\licreq.cpp \
    ..\defpol.cpp \
    ..\policy.cpp \
    ..\server.rc \
    ..\permlic.cpp \
    ..\templic.cpp \
    ..\findlost.cpp \
    ..\hydrals-s.c \
    ..\tlsrpc-s.c \
    ..\wkspace.cpp \
    ..\tlsrpc.cpp \
    ..\license.cpp \
    ..\keypack.cpp \
    ..\rpc.cpp \
    ..\service.cpp \
    ..\gencert.cpp \
    ..\upgdb.cpp \
    ..\kp.cpp \
    ..\lkpdesc.cpp \
    ..\ch.cpp \
    ..\errcode.cpp \
    ..\srvlist.cpp \
    ..\mailslot.cpp \
    ..\forward.cpp \
    ..\jobmgr.cpp \
    ..\wkstore.cpp \
    ..\tlsbkup-s.c \
    ..\tlsbkup.cpp \
    ..\expperm.cpp \
    ..\tlsjob.cpp

PRECOMPILED_INCLUDE=..\pch.cpp

UMLIBS=\
    $(LICENSE_ROOT)\pidapi\lib\*\medsig.lib \
    $(LSERVER_LIB_PATH)\$(O)\trust.lib \
    $(LSERVER_LIB_PATH)\$(ALT_PROJECT_TARGET)\$(O)\tlsapip.lib \
    $(KEYPKLIB) \
    $(LKPLITELIB) \
    $(CERTUTILLIB) \
    $(COMMON_LIB) \
    $(LSCRYPTLIB) \
    $(LSERVER_LIB_PATH)\$(O)\asn1.lib \
    $(LSERVER_LIB_PATH)\$(O)\TlsDb.lib \
    $(LSERVER_LIB_PATH)\$(O)\JetBlue.lib \
    $(LSERVER_LIB_PATH)\$(O)\marshal.lib \
    $(LSERVER_LIB_PATH)\$(O)\esetup.lib \
    $(SDK_LIB_PATH)\activeds.lib   \
    $(SDK_LIB_PATH)\adsiid.lib     \
    $(DS_LIB_PATH)\randlib.lib     \
    $(DS_LIB_PATH)\bignum.lib \
    $(DS_LIB_PATH)\rsa32.lib \
    $(SDK_LIB_PATH)\esent.lib \
    $(SDK_LIB_PATH)\crypt32.lib \
    $(SDK_LIB_PATH)\ws2_32.lib \
    $(SDK_LIB_PATH)\ole32.lib \
    $(SDK_LIB_PATH)\oleaut32.lib \
    $(SDK_LIB_PATH)\uuid.lib \
    $(SDK_LIB_PATH)\shell32.lib \
    $(SDK_LIB_PATH)\gdi32.lib \
    $(SDK_LIB_PATH)\netapi32.lib \
    $(SDK_LIB_PATH)\rpcrt4.lib \
    $(SDK_LIB_PATH)\rpcns4.lib \
    $(SDK_LIB_PATH)\user32.lib \
    $(SDK_LIB_PATH)\vssapi.lib \
    $(SDK_LIB_PATH)\ntdll.lib  \
    $(TERMSRV_LIB_PATH)\regapi.lib \
    $(TERMSRV_ROOT)\lib\$(O)\tssec.lib
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\license\tlserver\server\srvdef.h ===
//+--------------------------------------------------------------------------
//
// Copyright (c) 1997-1999 Microsoft Corporation
//
// File :       srvdef.h
//
// Contents:    
//
// History:     
//
//---------------------------------------------------------------------------
#ifndef __TLSERVER_DEF_H__
#define __TLSERVER_DEF_H__

#include "ntverp.h"


//----------------------------------------------
// #define TLS_CURRENT_VERSION (MAKELONG(0, HIBYTE(VER_PRODUCTVERSION_W)))

//
// Bit 31 - 1 if enterprise server, 0 if domain/workgroup license server
// Bit 30 - 1 if enforce license server, 0 if non-enforce.
// Bit 29 - 1 if RTM version, 0 if beta
//
#if defined(ENFORCE_LICENSING)
#define TLS_ENFORCE_VERSION 0x4000
#else
#define TLS_ENFORCE_VERSION 0x0000
#endif

#define TLS_RTM_VERSION     0x2000

//-----------------------------------------------------------------
//
// License Server Version 
//
// 5.0 W2K license server version.
// 5.1 Add LKP replication.
// 5.2 Post W2K Beta 3 check in.
// 5.3 Turn on enforce build, TLSAPI enumeration will skip 5.2 non-enforce
// 5.4 Depends on platform challenge response from client, issue long or short cert cain
//     
#define TLS_MINOR_VERSION   0x04

#define TLS_CURRENT_VERSION (MAKELONG(MAKEWORD(TLS_MINOR_VERSION, HIBYTE(VER_PRODUCTVERSION_W)), TLS_ENFORCE_VERSION))

#define TLS_CURRENT_VERSION_RTM (MAKELONG(MAKEWORD(TLS_MINOR_VERSION, HIBYTE(VER_PRODUCTVERSION_W)), TLS_ENFORCE_VERSION | TLS_RTM_VERSION))

#define GET_SERVER_MAJOR_VERSION(version)   HIBYTE(LOWORD(version))
#define GET_SERVER_MINOR_VERSION(version)   LOBYTE(LOWORD(version))
#define IS_ENTERPRISE_SERVER(version)       ((version & TLS_VERSION_ENTERPRISE_BIT) > 0)
#define IS_ENFORCE_SERVER(version) \
    ((version & 0x40000000) > 0)


//----------------------------------------------
//
//  Service Manager Error  Code
//
//----------------------------------------------
//#define TLS_E_SERVICE_STARTUP_GENERAL       0x1
//#define TLS_E_SERVICE_STARTUP_CREATE_THREAD 0x2
//#define TLS_E_SERVICE_STARTUP_REPORT_SCM    0x3
//#define TLS_E_SERVICE_STARTUP_RPC_THREAD_ERROR  0x4
//#define TLS_E_SERVICE_STARTUP_INIT_THREAD_ERROR 0x5
//#define TLS_E_SERVICE_STARTUP_POST_INIT     0x6
//#define TLS_E_SERVICE_RPC_LISTEN            0x7
//#define TLS_E_SERVICE_LOAD_POLICY           0x8
//#define TLS_I_SERVICE_WARNING               0x9

#define SET_JB_ERROR(err)       (TLS_E_JB_BASE | abs(err))
#define IS_JB_ERROR(err)        ((err & (FACILITY_JETBLUE_BASE << 16)))

// JetBlue error code are in negative
#define GET_JB_ERROR_CODE(err)  (-((LONG)(err & ~(FACILITY_JETBLUE_BASE << 16))))

#ifndef USE_MULTIPLE_WORKSPACE

#define ALLOCATEDBHANDLE(stmt, timeout) \
    AcquireRPCExclusiveLock(timeout) \

#define FREEDBHANDLE(stmt) \
    g_DbWorkSpace->Cleanup(); \
    ReleaseRPCExclusiveLock()

#define BEGIN_TRANSACTION(stmt) \
    g_DbWorkSpace->BeginTransaction();

#define COMMIT_TRANSACTION(stmt) \
    g_DbWorkSpace->CommitTransaction();

#define ROLLBACK_TRANSACTION(stmt) \
    g_DbWorkSpace->RollbackTransaction();

#define CLEANUPSTMT \
    g_DbWorkSpace->Cleanup()

#define USEHANDLE(stmt) \
    g_DbWorkSpace

#define RPCCALL_LOCK(timeout) \
    AcquireRPCExclusiveLock(timeout)

#define RPCCALL_UNLOCK \
    ReleaseRPCExclusiveLock()

#else
//
// Not tested yet!!!
//
#define ALLOCATEDBHANDLE(pStmt, timeout) \
    pStmt = AllocateWorkSpace(timeout)

#define FREEDBHANDLE(pStmt) \
    pStmt->Cleanup(); \
    ReleaseWorkSpace(pStmt);

#define BEGIN_TRANSACTION(pStmt) \
    pStmt->BeginTransaction();

#define COMMIT_TRANSACTION(pStmt) \
    pStmt->CommitTransaction();

#define ROLLBACK_TRANSACTION(pStmt) \
    pStmt->RollbackTransaction();

#define CLEANUPSTMT \
    pStmt->Cleanup()

#define USEHANDLE(pStmt) \
    pStmt

#define RPCCALL_LOCK(timeout) \
    AcquireRPCExclusiveLock(timeout)

#define RPCCALL_UNLOCK \
    ReleaseRPCExclusiveLock()

#endif


//----------------------------------------------------------------------
//
//
#ifndef SPC_CERT_EXTENSIONS_OBJID
    #define SPC_CERT_EXTENSIONS_OBJID           "1.3.6.1.4.1.311.2.1.14"
#endif

//---------------------------------------------------------------------------
// Server specified Registry Entry 
//
#define LSERVER_REGISTRY_BASE           _TEXT("SYSTEM\\CurrentControlSet\\Services\\")
#define LSERVER_PARAMETERS              _TEXT("Parameters")
#define LSERVER_PARAMETERS_SCOPE        _TEXT("Scope")
#define LSERVER_PARAMETERS_DBPATH       _TEXT("DBPath")        // database file
#define LSERVER_PARAMETERS_DBFILE       _TEXT("DBFile")        // database file
#define LSERVER_PARAMETERS_USER         _TEXT("User")
#define LSERVER_PARAMETERS_PWD          _TEXT("Pwd")
#define LSERVER_PARAMETERS_LOGLEVEL     _TEXT("Log Level")
#define LSERVER_PARAMETERS_CONSOLE      _TEXT("Console")
#define LSERVER_PARAMETERS_ROLE         _TEXT("Role")

#define LSERVER_PARAMETERS_ESENTMAXCACHESIZE    _TEXT("MaxCacheSize")
#define LSERVER_PARAMETERS_ESENTSTARTFLUSH      _TEXT("StartFlushThreshold")
#define LSERVER_PARAMETERS_ESENTSTOPFLUSH       _TEXT("StopFlushThreshold")
#define LSERVER_PARAMETERS_ESENTMAXVERPAGES     _TEXT("MaxVerPages")

#define LSERVER_PARAMETERS_LEASE_MIN    _TEXT("LeaseMinimum")
#define LSERVER_PARAMETERS_LEASE_RANGE  _TEXT("LeaseRange")
#define LSERVER_PARAMETERS_LEASE_LEEWAY _TEXT("LeaseLeeway")
#define LSERVER_PARAMETERS_EXPIRE_THREAD_SLEEP _TEXT("ExpireThreadSleep")

//
// JET_paramCacheSizeMax is expressed in pages, 
// default 4K per page.
//
#define LSERVER_PARAMETERS_ESENTMAXCACHESIZE_DEFAULT    256
//#define LSERVER_PARAMETERS_ESENTMINCACHESIZE_DEFAULT    16
#define LSERVER_PARAMETERS_ESENTSTARTFLUSH_DEFAULT      100
#define LSERVER_PARAMETERS_ESENTSTOPFLUSH_DEFAULT       200

#define LSERVER_PARAMETERS_ESENTMAXCACHESIZE_MAX        512
#define LSERVER_PARAMETERS_ESENTSTARTFLUSH_MAX          100
#define LSERVER_PARAMETERS_ESENTSTOPFLUSH_MAX           400
#define LSERVER_PARAMETERS_ESENTMAXVERPAGES_MAX         2048

#define LSERVER_PARAMETERS_ESENTMAXCACHESIZE_MIN        64
#define LSERVER_PARAMETERS_ESENTSTARTFLUSH_MIN          16
#define LSERVER_PARAMETERS_ESENTSTOPFLUSH_MIN           32
#define LSERVER_PARAMETERS_ESENTMAXVERPAGES_MIN         256


//
// MaxCacheSize is set to 0xFFFFFFFF, we just let ESENT pick its number
//
#define LSERVER_PARAMETERS_USE_ESENTDEFAULT             0xFFFFFFFF

#define LSERVER_PARAMETERS_KEY \
    LSERVER_REGISTRY_BASE _TEXT(SZSERVICENAME) _TEXT("\\") LSERVER_PARAMETERS

#define LSERVER_SIGNATURE_CERTIFICATE_KEY   _TEXT("Signature Certificate")
#define LSERVER_EXCHANGE_CERTIFICATE_KEY    _TEXT("Exchange Certificate")

#define TLSERVER_SERVER_ID_VERSION          0x00010001
typedef struct _TlsLsaServerId {
    DWORD dwVersion;        // structure version
    DWORD dwUniqueId;       // TLServer 5 digit unique ID
    DWORD dwServerPid;      // TLServer PID
    DWORD dwServerSPK;      // TLServer's SPK if any.
    DWORD dwExtensions;     // Size of encoded certificate entension.
    BYTE  pbVariableStart[1];   // UniqueId follow by ServerPid then ServerSPK.
} TLSLSASERVERID, *PTLSLSASERVERID, *LPTLSLSASERVERID;

//----------------------------------------------------------------------
//
// Registry key for License Server certificate issued by CA
//
//----------------------------------------------------------------------
#define LSERVER_SOFTWARE_REGBASE \
    _TEXT("SOFTWARE\\Microsoft\\") _TEXT(SZSERVICENAME)

#define LSERVER_CERTIFICATE_STORE           _TEXT("Certificates")
#define LSERVER_CERTIFICATE_STORE_BACKUP1   _TEXT("Certificates.000")
#define LSERVER_CERTIFICATE_STORE_BACKUP2   _TEXT("Certificates.001")


#define LSERVER_SELFSIGN_CERTIFICATE_REGKEY \
    LSERVER_REGISTRY_BASE _TEXT(SZSERVICENAME) _TEXT("\\") LSERVER_SECRET

#define LSERVER_SERVER_CERTIFICATE_REGKEY \
    LSERVER_SOFTWARE_REGBASE _TEXT("\\") LSERVER_CERTIFICATE_STORE

#define LSERVER_SERVER_CERTIFICATE_REGKEY_BACKUP1 \
    LSERVER_PARAMETERS_KEY _TEXT("\\") LSERVER_CERTIFICATE_STORE_BACKUP1

#define LSERVER_SERVER_CERTIFICATE_REGKEY_BACKUP2 \
    LSERVER_PARAMETERS_KEY _TEXT("\\") LSERVER_CERTIFICATE_STORE_BACKUP2


#define LSERVER_PARAMETERS_GRACEPERIOD      _TEXT("GracePeriod")
#define LSERVER_PARAMETERS_LOWLICENSEWARNING    _TEXT("Low License Warning")
#define LSERVER_PARAMETERS_ISSUETEMPLICENSE _TEXT("IssueTemporaryLicenses")
#define LSERVER_PARAMETERS_WORKINTERVAL     _TEXT("DefaultJobInterval")
#define LSERVER_PARAMETERS_RETRYTIMES       _TEXT("DefaultJobRetryTimes")
#define LSERVER_PARAMETERS_WORKRESTART      _TEXT("DefaultJobRestartTime")


#define LSERVER_CLIENT_CERTIFICATE_ISSUER   _TEXT("Parm0")
#define LSERVER_SIGNATURE_CERT_KEY          _TEXT("Parm1")
#define LSERVER_EXCHANGE_CERT_KEY           _TEXT("Parm2")
#define LSERVER_SIGNATURE_CERTCHAIN_KEY     _TEXT("Parm3")

#define LSERVER_POLICY_REGKEY               _TEXT("Policy")
#define LSERVER_POLICY_DLLPATH              _TEXT("Dll")
#define LSERVER_POLICY_DLLFLAG              _TEXT("Flags")


#define LSERVER_POLICY_REGBASE \
    LSERVER_SOFTWARE_REGBASE _TEXT("\\") LSERVER_POLICY_REGKEY


#define TLS_ERROR(dwErrCode) ((dwErrCode & 0xC0000000) == 0xC0000000)


//---------------------------------------------------------------------

#define MAXTCPNAME                 MAXGETHOSTSTRUCT

//------------------------------------------------------------------------------------------------
// Hydra Specific Product SKU
//
//  236-4.00-S      Windows NT Workstation 4.0 Full Version         Non Windows and Non NT Client
//  236-4.00-VU     Windows NT Workstation 4.0 Version Upgrade      Windows NT 3.51 Client
//  236-4.00-EX     Existing Windows NT Workstation 4.0 License     Windows NT 4.0 and 5.0 Client
//
#define HYDRA_PRODUCTID_SKU         "236"
#define HYDRA_FULLVERSION_POSTFIX   "S"
#define HYDRA_UPGRADE_POSTFIX       "VU"
#define HYDRA_EXISTING              "EX"

#define HYDRAPRODUCT_FULLVERSION_SKU       _TEXT("236-4.00-S")
#define HYDRAPRODUCT_UPGRADE_SKU           _TEXT("236-4.00-VU")
#define HYDRAPRODUCT_EXISTING_SKU          _TEXT("236-4.00-EX")

//
// 236 Product ID
//
#define PLATFORMID_UPGRADE  1
#define PLATFORMID_FREE     2
#define PLATFORMID_OTHERS   0xFF

#define TERMSERV_PRODUCTID_SKU          _TEXT("A02")
#define TERMSERV_PRODUCTID_INTERNET_SKU _TEXT("B96")
#define TERMSERV_PRODUCTID_CONCURRENT_SKU  _TEXT("C50")

#define TERMSERV_FULLVERSION_TYPE   _TEXT("S")
#define TERMSERV_FREE_TYPE          _TEXT("EX")
#define TERMSERV_INTERNET_TYPE      _TEXT("I")
#define TERMSERV_CONCURRENT_TYPE    _TEXT("C")

#define TERMSERV_PRODUCTID_SCAN_FORMAT   _TEXT("%3s-%ld.%02ld-%9s")
#define MAX_TERMSRV_PRODUCTID       LSERVER_MAX_STRING_SIZE
#define MAX_SKU_PREFIX              10
#define MAX_SKU_POSTFIX             10


//
// Following two are info. for special key pack that 
// will be used for issuing certificate to hydra server.
//
#define HYDRAPRODUCT_HS_CERTIFICATE_SKU \
    _TEXT("3d267954-eeb7-11d1-b94e-00c04fa3080d")

#define HYDRAPRODUCT_HS_CERTIFICATE_KEYPACKID \
    _TEXT("3d267954-eeb7-11d1-b94e-00c04fa3080d")

#define HYDRACERT_PRODUCT_VERSION 0x0001000


// Windows NT Upgrade=1, Windows NT Free=2, Others=3

#define CLIENT_PLATFORMID_WINDOWS_NT_UPGRADE        1
#define CLIENT_PLATFORMID_WINDOWS_NT_FREE           2
#define CLIENT_PLATFORMID_OTHERS                    3


//---------------------------------------------------------------------------
//
// Common Define
//
#define LICENSE_MIN_MATCH               3
#define RPC_MINIMUMCALLTHREADS          1
#define RPC_MAXIMUMCALLTHREADS          RPC_C_LISTEN_MAX_CALLS_DEFAULT
#define SC_WAITHINT                     3000
#define ODBC_MAX_SQL_STRING             8196                    // max. sql string
#define DEFAULT_CONNECTION_TIMEOUT      5*60*1000      //  odbc.h
#define DB_ENUM_WAITTIMEOUT             10*1000                 // 10 second time out
                                                            // for enumeration handle
#define MAX_LICENSE_SIZE                4096

#define GRACE_PERIOD                    90         // default to 90 days

#define DEFAULT_DB_CONNECTIONS          4
#define LSERVER_PARAMETERS_DBTIMEOUT    _TEXT("Db ConnectionTimeout")
#define LSERVER_PARAMETERS_EDBTIMEOUT   _TEXT("Enum DbConnection Timeout")
#define LSERVER_PARAMETERS_MAXDBHANDLES _TEXT("Max DB Handles")

#define DB_MAX_CONNECTIONS              20
#define DB_MIN_HANDLE_NEEDED            3       // keypack enumeration uses two handle
                                                // need odd number to prevent deadlock

//---------------------------------------------------------------------------
//
// draft-ietf-pkix-ipki-part1-06.txt section 4.1.2.5.1
//  where year is greater or equal to 50, the year shall be interpreted as 19YY; and
//  where year is less than 50, the year shall be interpreted as 20YY
//
#define PERMANENT_CERT_EXPIRE_DATE  2049

//---------------------------------------------------------------------------
//
//  Internal specific not export to RPC 
//
#define LSKEYPACKSTATUS_DELETE              0xF
#define LSLICENSESTATUS_DELETE              0xF

#define LSKEYPACKSTATUS_BETA                0x10
#define LSKEYPACKSTATUS_HIDDEN              0x20
#define LSKEYPACKSTATUS_LOCAL               0x40
#define LSKEYPACKSTATUS_REMOTE              0x80
#define LSKEYPACKSTATUS_RESERVED            0xF0

#define LSKEYPACK_REMOTE_TYPE               0x80
#define LSKEYPACK_LOCAL_TYPE                0x40
#define LSKEYPACK_HIDDEN_TYPE               0x20
#define LSKEYPACK_RESERVED_TYPE             0xF0

#define LSKEYPACK_PLATFORM_REMOTE           0x80000000

//----------------------------------------------------------------------------
// 
// KeyPackDesc Table specific
//
#define KEYPACKDESC_SEARCH_NONE             0x00000000
#define KEYPACKDESC_SEARCH_ALL              0xFFFFFFFF

#define KEYPACKDESC_SET_ADD_ENTRY           0x00010000
#define KEYPACKDESC_SET_DELETE_ENTRY        0x00020000

//---------------------------------------------------------------------------

#ifndef AllocateMemory

    #define AllocateMemory(size) \
        LocalAlloc(LPTR, size)
#endif

#ifndef FreeMemory

    #define FreeMemory(ptr) \
        if(ptr)             \
        {                   \
            LocalFree(ptr); \
            ptr=NULL;       \
        }

#endif

#ifndef ReallocateMemory

    #define ReallocateMemory(ptr, size)                 \
                LocalReAlloc(ptr, size, LMEM_ZEROINIT)

#endif

#ifndef SAFESTRCPY

    #define SAFESTRCPY(dest, source) \
        _tcsncpy(dest, source, min(_tcslen(source), sizeof(dest)/sizeof(TCHAR))); \
        dest[min(_tcslen(source), (sizeof(dest)/sizeof(TCHAR) -1))] = _TEXT('\0');

#endif

//---------------------------------------------------------------------------
//
// Return code from LSWaitForService()
// 
#define WAIT_SERVICE_UNKNOWN            0
#define WAIT_SERVICE_ERROR              1
#define WAIT_SERVICE_ALREADY_RUNNING    2
#define WAIT_SERVICE_MANUALLY_STARTED   3
#define WAIT_SERVICE_NOT_EXIST          4
#define WAIT_SERVICE_DISABLED           5
#define WAIT_SERVICE_READY              6

#define LICENSE_TABLE_EXTERN_SEARCH_MASK \
   (LSLICENSE_SEARCH_LICENSEID | LSLICENSE_SEARCH_KEYPACKID | \
    LSLICENSE_SEARCH_MACHINENAME | \
    LSLICENSE_SEARCH_USERNAME | \
    LSLICENSE_SEARCH_ISSUEDATE | LSLICENSE_SEARCH_NUMLICENSES | \
    LSLICENSE_SEARCH_EXPIREDATE | LSLICENSE_EXSEARCH_LICENSESTATUS)

//
//  The original style permanent license will never expire. The leased license
//  will expire in a random period between 52 and 89 days.
//

#define PERMANENT_LICENSE_EXPIRE_DATE   INT_MAX

//#define PERMANENT_LICENSE_LEASE_EXPIRE_MIN      (3*60) // testing: 3 min
//#define PERMANENT_LICENSE_LEASE_EXPIRE_RANGE    (60) // testing: 1 min
//#define EXPIRE_THREAD_SLEEP_TIME                (1000*60*5) /* five min */
#define PERMANENT_LICENSE_LEASE_EXPIRE_MIN      (52 * 24 * 60 * 60)
#define PERMANENT_LICENSE_LEASE_EXPIRE_RANGE    (37 * 24 * 60 * 60)
#define EXPIRE_THREAD_SLEEP_TIME                (1000*60*60*24)  /* one day */

#define TLSERVER_CHALLENGE_CONTEXT      0xFFFFFFFF
#define TLSERVER_ENTERPRISE_SERVER      0x00000001

#define DEFAULT_CSP     MS_DEF_PROV
#define PROVIDER_TYPE   PROV_RSA_FULL

#define CRYPTOINIT_ALREADY_EXIST        0x00000000
#define CRYPTOINIT_CREATE_CONTAINER     0x00000001
#define CRYPTOINIT_CREATE_SIGNKEY       0x00000002
#define CRYPTOINIT_CREATE_EXCHKEY       0x00000004

#define TLSBACKUP_EXPORT_DIR            _TEXT("Export")


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\license\tlserver\server\srvlist.h ===
//+--------------------------------------------------------------------------
//
// Copyright (c) 1997-1999 Microsoft Corporation
//
// File:       srvlist.h 
//
// Contents:    
//
// History:     
//
//---------------------------------------------------------------------------
#ifndef __TLSERVER_LIST__
#define __TLSERVER_LIST__

#include "srvdef.h"
#include "tlsapi.h"
#include "tlsdef.h"
#include "tlsstl.h"

class CTLServerInfo;
class CTLServerMgr;


typedef struct _MapSetupIdToInfo {
    //
    // Setup ID could never change unless
    // system crash
    //
    LPCTSTR pszSetupId;
} MapSetupIdToInfo;


#define TLSERVER_UNKNOWN                    0x00000000
#define TLSERVER_OLDVERSION                 0x80000000
#define TLSERVER_SUPPORTREPLICATION         0x00000010

typedef struct _TLServerInfo {
    TCHAR  m_szDomainName[LSERVER_MAX_STRING_SIZE + 2];
    TCHAR  m_szServerName[MAX_COMPUTERNAME_LENGTH + 2];
    TCHAR  m_szSetupId[MAX_JETBLUE_TEXT_LENGTH+2];

    DWORD  m_dwTLSVersion;                  // Server version
    DWORD m_dwCapability;
    DWORD m_dwPushAnnounceTimes;
    FILETIME m_dwLastSyncTime;              // Last Sync Time.

    
    //------------------------------------------------------------
    _TLServerInfo() :
    m_dwTLSVersion(0),
    m_dwCapability(TLSERVER_UNKNOWN),
    m_dwPushAnnounceTimes(0)
    {
        memset(m_szDomainName, 0, sizeof(m_szDomainName));
        memset(m_szServerName, 0, sizeof(m_szServerName));
        memset(m_szSetupId, 0, sizeof(m_szSetupId));
        memset(&m_dwLastSyncTime, 0, sizeof(FILETIME));
    }

    //-----------------------------------------------------------
    _TLServerInfo(
        IN LPCTSTR pszSetupId,
        IN LPCTSTR pszDomainName,
        IN LPCTSTR pszServerName 
        ) :

        m_dwTLSVersion(0),
        m_dwCapability(TLSERVER_UNKNOWN)
    /*++

    --*/
    {
        memset(&m_dwLastSyncTime, 0, sizeof(FILETIME));
        memset(m_szDomainName, 0, sizeof(m_szDomainName));
        memset(m_szServerName, 0, sizeof(m_szServerName));
        memset(m_szSetupId, 0, sizeof(m_szSetupId));

        lstrcpyn(
                m_szSetupId, 
                pszSetupId, 
                MAX_JETBLUE_TEXT_LENGTH + 1
            );

        lstrcpyn(
                m_szServerName, 
                pszServerName, 
                MAX_COMPUTERNAME_LENGTH + 1
            );

        lstrcpyn(
                m_szDomainName, 
                pszDomainName, 
                LSERVER_MAX_STRING_SIZE + 1
            );
    }
    //----------------------------------------------
    void
    UpdateServerName(
        IN LPCTSTR pszServerName
        )
    /*++

    Abstract:

        Update Server name.

    Parameter:

        pszServerName : new server name.

    Returns:

        None.

    Remark:

        Server ID can't be changed but server name can,
        license server doesn't announce its shutdown so 
        on next boot, user might have change the machine 
        name.

    --*/
    {
        memset(m_szServerName, 0, sizeof(m_szServerName));
        lstrcpyn(
                m_szServerName,
                pszServerName,
                MAX_COMPUTERNAME_LENGTH + 1
            );
    }

    //----------------------------------------------    
    BOOL
    IsAnnounced()
    /*++

        detemine if local server already announce 
        anything to this server.

    --*/
    {
        return m_dwPushAnnounceTimes > 0;
    }

    //----------------------------------------------
    void
    UpdateLastSyncTime(
        FILETIME* pftTime
        )
    /*++

        Update last push sync. time that is initiate 
        from local server to this server.

    --*/
    {
        m_dwLastSyncTime = *pftTime;
    }

    //----------------------------------------------
    void
    GetLastSyncTime(
        FILETIME* pftTime
        )
    /*++

        Retrieve last push sync. time that is initiate 
        from local server to this server.

    --*/
    {
        *pftTime = m_dwLastSyncTime;
    }

    //----------------------------------------------
    DWORD
    GetServerVersion()
    /*++

        Get this remote server's version information.

    --*/
    {
        return m_dwTLSVersion;
    }

    //----------------------------------------------
    DWORD
    GetServerMajorVersion() 
    /*++

        Get this remote server's major version.

    --*/
    {
        return GET_SERVER_MAJOR_VERSION(m_dwTLSVersion);
    }

    //----------------------------------------------
    DWORD
    GetServerMinorVersion() 
    /*++

        Get this remote server's minor version.

    --*/
    {
        return GET_SERVER_MINOR_VERSION(m_dwTLSVersion);
    }

    //----------------------------------------------
    BOOL
    IsServerEnterpriseServer() 
    /*++

        Check if this remote server is a enterprise server
    
    --*/
    {
        return IS_ENTERPRISE_SERVER(m_dwTLSVersion);
    }

    //----------------------------------------------
    BOOL
    IsEnforceServer()
    /*++

        Check if this remote server is a enforce license
        server.

    --*/
    {
        return IS_ENFORCE_SERVER(m_dwTLSVersion);
    }

    //----------------------------------------------
    LPTSTR
    GetServerName()  
    { 
        return m_szServerName; 
    }

    //----------------------------------------------
    LPTSTR 
    GetServerDomain()  
    {
        return m_szDomainName;
    }

    //----------------------------------------------
    LPTSTR
    GetServerId()  
    {
        return m_szSetupId;
    }

    //----------------------------------------------
    DWORD
    GetServerCapability()
    /*++

        For future version only

    --*/
    {
        DWORD dwCap;

        dwCap = m_dwCapability;

        return dwCap;
    }

    //----------------------------------------------
    BOOL
    IsServerSupportReplication() {
        return (BOOL)(m_dwCapability & TLSERVER_SUPPORTREPLICATION);
    }
} TLServerInfo, *PTLServerInfo, *LPTLServerInfo;


//---------------------------------------------------------

class CTLServerMgr {
private:
    typedef map<MapSetupIdToInfo, PTLServerInfo, less<MapSetupIdToInfo> > MapIdToInfo;

    CRWLock     m_ReadWriteLock;    // reader/writer lock on m_Handles.
    MapIdToInfo m_Handles;

    MapIdToInfo::iterator enumIterator;

public:

    CTLServerMgr();
    ~CTLServerMgr();

    //
    // Add server to list
    DWORD
    AddServerToList(
        IN LPCTSTR pszSetupId,
        IN LPCTSTR pszDomainName,
        IN LPCTSTR pszServerName
    );

    DWORD
    AddServerToList(
        IN PTLServerInfo pServerInfo
    );

    //
    // Lookup function
    DWORD
    LookupBySetupId(
        IN LPCTSTR pszSetupId,
        OUT PTLServerInfo pServerInfo
    );

    DWORD
    LookupByServerName(
        LPCTSTR pszServerName,
        OUT PTLServerInfo pServerInfo
    );

    void
    ServerListEnumBegin();

    const PTLServerInfo
    ServerListEnumNext();

    void
    ServerListEnumEnd();
};

//----------------------------------------------------------

inline bool
operator<(
    const MapSetupIdToInfo& a,
    const MapSetupIdToInfo& b
    )
/*++

++*/
{
    int iComp = _tcsicmp(a.pszSetupId, b.pszSetupId);
    return iComp < 0;
}        


#ifdef __cplusplus
extern "C" {
#endif

void
TLSBeginEnumKnownServerList();

const PTLServerInfo
TLSGetNextKnownServer();

void
TLSEndEnumKnownServerList();


DWORD
TLSAnnounceServerToRemoteServerWithHandle(
    IN DWORD dwAnnounceType,
    IN TLS_HANDLE hHandle,
    IN LPTSTR pszLocalSetupId,
    IN LPTSTR pszLocalDomainName,
    IN LPTSTR pszLocalServerName,
    IN FILETIME* pftLocalLastShutdownTime
);

DWORD
TLSAnnounceServerToRemoteServer(
    IN DWORD dwAnnounceType,
    IN LPTSTR pszRemoteSetupId,
    IN LPTSTR pszRemoteDomainName,
    IN LPTSTR pszRemoteServerName,
    IN LPTSTR pszLocalSetupId,
    IN LPTSTR pszLocalDomainName,
    IN LPTSTR pszLocalServerName,
    IN FILETIME* pftLocalLastShutdownTime
);


TLS_HANDLE
TLSConnectAndEstablishTrust(
    IN LPTSTR pszServerName,
    IN HANDLE hHandle
);


DWORD
TLSRetrieveServerInfo(
    TLS_HANDLE hHandle,
    PTLServerInfo pServerInfo
);

DWORD
TLSLookupServerById(
    IN LPTSTR pszServerSetupId, 
    OUT LPTSTR pszServer
);

DWORD
TLSRegisterServerWithName(
    IN LPTSTR pszSetupId,
    IN LPTSTR pszDomainName,
    IN LPTSTR pszServerName
);

DWORD
TLSRegisterServerWithHandle(
    IN TLS_HANDLE hHandle,
    OUT PTLServerInfo pServerInfo
);

DWORD
TLSRegisterServerWithServerInfo(
    IN PTLServerInfo pServerInfo
);

DWORD
TLSLookupRegisteredServer(
    IN LPTSTR pszSetupId,
    IN LPTSTR pszDomainName,
    IN LPTSTR pszServerName,
    OUT PTLServerInfo pServerInfo
);

TLS_HANDLE
TLSConnectToServerWithServerId(
    LPTSTR pszServerSetupId
);

DWORD
TLSLookupAnyEnterpriseServer(
    OUT PTLServerInfo pServerInfo
);

DWORD
TLSResolveServerIdToServer(
    LPTSTR pszServerId,
    DWORD  cbServerName,
    LPTSTR pszServerName
);

#ifdef __cplusplus
}
#endif

    
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\license\tlserver\server\service.cpp ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996-1998
//
// File:        service.c
//
// Contents:    Hydra License Server Service Control Manager Interface
//
// History:     12-09-97    HueiWang    Modified from MSDN RPC Service Sample
//
//---------------------------------------------------------------------------
#include "pch.cpp"
#include <winsock2.h>
#include <ws2tcpip.h>
#include "server.h"
#include "globals.h"
#include "init.h"
#include "postsrv.h"
#include "tlsbkup.h"
#include "Lmaccess.h"
#include "Dsgetdc.h"

#define NULL_SESSION_KEY_NAME   _TEXT("SYSTEM\\CurrentControlSet\\Services\\LanmanServer\\Parameters")
#define NULL_SESSION_VALUE_NAME _TEXT("NullSessionPipes")


#define SERVICE_WAITHINT 60*1000                // WaitHint 1 mins.
#define SERVICE_SHUTDOWN_WAITTIME   15*60*1000  // must have shutdown already.

#define TSLSLOCALGROUPNAMELENGTH 64
#define TSLSLOCALGROUPDESLENGTH 128
#define ALLDOMAINCOMPUTERS L"Domain Computers"
PSECURITY_DESCRIPTOR g_pSecDes = NULL;  //Security Descriptor for local group
PSID g_pSid = NULL;                     //Sid for local group
PACL g_Dacl = NULL;                     //Dacl for local group

//---------------------------------------------------------------------------
//
// internal function prototypes
//
BOOL 
ReportStatusToSCMgr(
    DWORD, 
    DWORD, 
    DWORD
);

DWORD 
ServiceStart(
    DWORD, 
    LPTSTR *, 
    BOOL bDebug=FALSE
);

VOID WINAPI 
ServiceCtrl(
    DWORD
);

VOID WINAPI 
ServiceMain(
    DWORD, 
    LPTSTR *
);

VOID 
CmdDebugService(
    int, 
    char **, 
    BOOL
);

BOOL WINAPI 
ControlHandler( 
    DWORD 
);

extern "C" VOID 
ServiceStop();

VOID 
ServicePause();

VOID 
ServiceContinue();

HANDLE hRpcPause=NULL;


///////////////////////////////////////////////////////////
//
// internal variables
//
SERVICE_STATUS_HANDLE   sshStatusHandle;
DWORD                   ssCurrentStatus;       // current status of the service
BOOL g_bReportToSCM = TRUE;

HANDLE gSafeToTerminate=NULL;

HRESULT hrStatus = NULL;

DEFINE_GUID(TLS_WRITER_GUID, 0x5382579c, 0x98df, 0x47a7, 0xac, 0x6c, 0x98, 0xa6, 0xd7, 0x10, 0x6e, 0x9);
GUID idWriter = TLS_WRITER_GUID;

CTlsVssJetWriter *g_pWriter = NULL;


CTlsVssJetWriter::CTlsVssJetWriter() : CVssJetWriter()
{
}

CTlsVssJetWriter::~CTlsVssJetWriter()
{
}


HRESULT CTlsVssJetWriter::Initialize()
{
	return CVssJetWriter::Initialize(idWriter, L"TermServLicensing", TRUE, FALSE, L"", L"");
}

void CTlsVssJetWriter::Uninitialize()
{
	return CVssJetWriter::Uninitialize();
}


bool STDMETHODCALLTYPE CTlsVssJetWriter::OnIdentify(IN IVssCreateWriterMetadata *pMetadata)
{   
    HRESULT hr= E_FAIL;

    hr = pMetadata->SetRestoreMethod(
                          VSS_RME_RESTORE_AT_REBOOT,
                          NULL,
                          NULL,
                          VSS_WRE_NEVER,
                          true);

    if(ERROR_SUCCESS == hr)
        return CVssJetWriter::OnIdentify(pMetadata);    
    else
        return FALSE;

}


SERVICE_TABLE_ENTRY dispatchTable[] =
{
    { _TEXT(SZSERVICENAME), (LPSERVICE_MAIN_FUNCTION)ServiceMain },
    { NULL, NULL }
};


//-----------------------------------------------------------------
// Internal routine
//-----------------------------------------------------------------
void print_usage()
{
  _ftprintf(
        stdout, 
        _TEXT("Usage : %s can't be run as a console app\n"), 
        _TEXT(SZAPPNAME)
    );
  return;
}

#ifdef DISALLOW_ANONYMOUS_RPC

DWORD
RemoveStringFromMultiSz(
                        LPTSTR pszRemoveString1,
                        LPTSTR pszRemoveString2,
                        HKEY    hKey,
                        LPCTSTR pszValueName)
{
    DWORD dwErr;
    LPTSTR wszData = NULL, pwsz;
    DWORD cbData, cbDataRemaining;
    BOOL fFound = FALSE;
    
    if ((NULL == pszRemoveString1) || (NULL == pszRemoveString2)
        || (NULL == pszValueName) || (NULL == hKey))
    {
        return ERROR_INVALID_PARAMETER;
    }

    //
    // Retrieve existing MULTI_SZ
    //

    dwErr = RegQueryValueEx(hKey,
                            pszValueName,
                            NULL,
                            NULL,
                            NULL,
                            &cbData);

    if (dwErr != ERROR_SUCCESS)
    {
        if (dwErr == ERROR_FILE_NOT_FOUND)
        {
            //
            // Value isn't there
            //
            
            return ERROR_SUCCESS;
        }
        else
        {
            return dwErr;
        }
    }

    wszData = (LPTSTR) LocalAlloc(LPTR, cbData);

    if (NULL == wszData)
    {
        return ERROR_OUTOFMEMORY;
    }

    dwErr = RegQueryValueEx(hKey,
                            pszValueName,
                            NULL,
                            NULL,
                            (LPBYTE) wszData,
                            &cbData);

    if (dwErr != ERROR_SUCCESS)
    {
        LocalFree(wszData);
        return dwErr;
    }

    pwsz = wszData;
    cbDataRemaining = cbData;

    while (*pwsz)
    {
        DWORD cchDataToMove = _tcslen (pwsz) + 1;

        if ((0 == _tcsicmp(pwsz,pszRemoveString1))
            || (0 == _tcsicmp(pwsz,pszRemoveString2)))
        {
            LPTSTR pwszRemain = pwsz + cchDataToMove;

            MoveMemory(pwsz, pwszRemain, cbDataRemaining - (cchDataToMove * sizeof(TCHAR)));

            cbData -= cchDataToMove * sizeof(TCHAR);

            fFound = TRUE;
        }
        else
        {
            pwsz += cchDataToMove;
        }

        cbDataRemaining -= cchDataToMove * sizeof(TCHAR);
    }

    if (fFound)
    {
        dwErr = RegSetValueEx(
                              hKey,
                              wszData,
                              0,
                              REG_MULTI_SZ,
                              (LPBYTE) wszData,
                              cbData);
    }

    LocalFree(wszData);

    return dwErr;
}

DWORD
RemoveNullSessions()
{
    HKEY hKey;
    DWORD dwErr;

    dwErr = RegOpenKeyEx(
                HKEY_LOCAL_MACHINE,
                NULL_SESSION_KEY_NAME,
                0,
                KEY_READ | KEY_WRITE,
                &hKey
                );

    if (dwErr != ERROR_SUCCESS) {
        //
        // Key doesn't exist - success
        //
        return ERROR_SUCCESS;
    }

    dwErr = RemoveStringFromMultiSz(_TEXT(HLSPIPENAME),
                                    _TEXT(SZSERVICENAME),
                                    hKey,
                                    NULL_SESSION_VALUE_NAME);

    RegCloseKey(hKey);

    return dwErr;
}
#endif  // DISALLOW_ANONYMOUS_RPC

//-----------------------------------------------------------------

DWORD
AddNullSessionPipe(
    IN LPTSTR szPipeName
    )
/*++

Abstract:

    Add our RPC namedpipe into registry to allow unrestricted access.

Parameter:

    szPipeName : name of the pipe to append.

Returns:

    ERROR_SUCCESS or error code

--*/
{
    HKEY hKey;
    DWORD dwStatus;
    LPTSTR pbData=NULL, pbOrg=NULL;
    DWORD  cbData = 0;

    dwStatus = RegOpenKeyEx(
                        HKEY_LOCAL_MACHINE,
                        NULL_SESSION_KEY_NAME,
                        0,
                        KEY_ALL_ACCESS,
                        &hKey
                    );
    if(dwStatus != ERROR_SUCCESS)
        return dwStatus;

                                                       
    dwStatus = RegQueryValueEx(
                        hKey,
                        NULL_SESSION_VALUE_NAME,
                        NULL,
                        NULL,
                        NULL,
                        &cbData
                    );

    if(dwStatus != ERROR_MORE_DATA && dwStatus != ERROR_SUCCESS)
        return dwStatus;

    // pre-allocate our pipe name
    if(!(pbData = (LPTSTR)AllocateMemory(cbData + (_tcslen(szPipeName) + 1) * sizeof(TCHAR))))
        return GetLastError();

    dwStatus = RegQueryValueEx(
                        hKey,
                        NULL_SESSION_VALUE_NAME,
                        NULL,
                        NULL,
                        (LPBYTE)pbData,
                        &cbData
                    );
    
    BOOL bAddPipe=TRUE;
    pbOrg = pbData;

    // check pipe name
    while(*pbData)
    {
        if(!_tcsicmp(pbData, szPipeName))
        {
            bAddPipe=FALSE;
            break;
        }

        pbData += _tcslen(pbData) + 1;
    }

    if(bAddPipe)
    {
        _tcscat(pbData, szPipeName);
        cbData += (_tcslen(szPipeName) + 1) * sizeof(TCHAR);
        dwStatus = RegSetValueEx( 
                            hKey, 
                            NULL_SESSION_VALUE_NAME,
                            0, 
                            REG_MULTI_SZ, 
                            (PBYTE)pbOrg, 
                            cbData
                        );
    }

    FreeMemory(pbOrg);
    RegCloseKey(hKey);

    return dwStatus;
}


//-----------------------------------------------------------------
void _cdecl 
main(
    int argc, 
    char **argv
    )
/*++

Abstract 

    Entry point.

++*/
{
    // LARGE_INTEGER Time = USER_SHARED_DATA->SystemExpirationDate;

    
    gSafeToTerminate = CreateEvent(
                                NULL,
                                TRUE,
                                FALSE,
                                NULL
                            );
                                
    if(gSafeToTerminate == NULL)
    {
        TLSLogErrorEvent(TLS_E_ALLOCATE_RESOURCE);
        // out of resource.
        return;
    }    

    if(g_bReportToSCM == FALSE)
    {
        CmdDebugService(
                argc, 
                argv, 
                !g_bReportToSCM
            );
    }
    else if(!StartServiceCtrlDispatcher(dispatchTable))
    {
        TLSLogErrorEvent(TLS_E_SC_CONNECT);
    }

    WaitForSingleObject(gSafeToTerminate, INFINITE);
    CloseHandle(gSafeToTerminate);
}


//-----------------------------------------------------------------
void WINAPI 
ServiceMain(
    IN DWORD dwArgc, 
    IN LPTSTR *lpszArgv
    )
/*++

Abstract:

    To perform actual initialization of the service

Parameter:

    dwArgc   - number of command line arguments
    lpszArgv - array of command line arguments


Returns:

    none

++*/
{
    DWORD dwStatus;

    // register our service control handler:
    sshStatusHandle = RegisterServiceCtrlHandler( 
                                _TEXT(SZSERVICENAME), 
                                ServiceCtrl 
                            );

    if (sshStatusHandle)
    {
        ssCurrentStatus=SERVICE_START_PENDING;

        // report the status to the service control manager.
        //
        if(ReportStatusToSCMgr(
                        SERVICE_START_PENDING, // service state
                        NO_ERROR,              // exit code
                        SERVICE_WAITHINT))          // wait hint
        {
            dwStatus = ServiceStart(
                                    dwArgc, 
                                    lpszArgv
                                );

            if(dwStatus != ERROR_SUCCESS)
            {
                ReportStatusToSCMgr(
                                    SERVICE_STOPPED, 
                                    dwStatus, 
                                    0
                                );
            }
            else 
            {
                ReportStatusToSCMgr(
                                    SERVICE_STOPPED, 
                                    NO_ERROR, 
                                    0
                                );
            }
        }
    }
    else
    {
        dwStatus = GetLastError();
        TLSLogErrorEvent(TLS_E_SC_CONNECT);
    }

    DBGPrintf(
        DBG_INFORMATION,
        DBG_FACILITY_INIT,
        DBGLEVEL_FUNCTION_TRACE,
        _TEXT("Service terminated...\n")
    );

    return;
}

//-------------------------------------------------------------
VOID WINAPI 
ServiceCtrl(
    IN DWORD dwCtrlCode
    )
/*+++

Abstract:

    This function is called by the SCM whenever 
    ControlService() is called on this service.

Parameter:

    dwCtrlCode - type of control requested from SCM.

+++*/
{
    // Handle the requested control code.
    //
    switch(dwCtrlCode)
    {
        // Stop the service.
        //
        case SERVICE_CONTROL_SHUTDOWN:
        case SERVICE_CONTROL_STOP:

            ReportStatusToSCMgr(
                        SERVICE_STOP_PENDING, 
                        NO_ERROR, 
                        0
                    );
            ServiceStop();
            break;

        // We don't really accept pause and continue
        case SERVICE_CONTROL_PAUSE:
            ReportStatusToSCMgr(
                        SERVICE_PAUSED, 
                        NO_ERROR, 
                        0
                    );

            ServicePause();
            break;

        case SERVICE_CONTROL_CONTINUE:        
            ReportStatusToSCMgr(
                        SERVICE_RUNNING, 
                        NO_ERROR, 
                        0
                    );
            ServiceContinue();
            break;

        // Update the service status.
        case SERVICE_CONTROL_INTERROGATE:
            ReportStatusToSCMgr(
                        ssCurrentStatus, 
                        NO_ERROR, 
                        0
                    );
            break;

        // invalid control code
        default:
            break;

    }
}

//------------------------------------------------------------------
DWORD 
ServiceShutdownThread(
    void *p
    )
/*++

Abstract:

    Entry point into thread that shutdown server (mainly database).

Parameter:

    Ignore

++*/
{
    ServerShutdown();

    ExitThread(ERROR_SUCCESS);
    return ERROR_SUCCESS;
}    

//------------------------------------------------------------------
DWORD 
RPCServiceStartThread(
    void *p
    )
/*++

Abstract:

    Entry point to thread that startup RPC.

Parameter:

    None.

Return:

    Thread exit code.

++*/
{
    RPC_BINDING_VECTOR *pbindingVector = NULL;
    RPC_STATUS status = RPC_S_OK;
    WCHAR *pszEntryName = _TEXT(RPC_ENTRYNAME);
    DWORD dwNumSuccessRpcPro=0;
    do {
        //
        // local procedure call
        //
        status = RpcServerUseProtseq( 
                                _TEXT(RPC_PROTOSEQLPC),
                                RPC_C_PROTSEQ_MAX_REQS_DEFAULT,
                                NULL // &SecurityDescriptor
                            );
        if(status == RPC_S_OK)
        {
            dwNumSuccessRpcPro++;
        }

        //
        // NT4 backward compatible issue, let NT4 termsrv serivce
        // client connect so still set security descriptor
        //
        // 11/10/98 Tested on NT4 and NT5
        //

        //
        // Namedpipe
        //
        status = RpcServerUseProtseqEp( 
                                _TEXT(RPC_PROTOSEQNP),
                                RPC_C_PROTSEQ_MAX_REQS_DEFAULT,
                                _TEXT(LSNAMEPIPE),
                                NULL //&SecurityDescriptor
                            );
        if(status == RPC_S_OK)
        {
            dwNumSuccessRpcPro++;
        }

        //
        // TCP/IP
        //
        status = RpcServerUseProtseq( 
                                _TEXT(RPC_PROTOSEQTCP),
                                RPC_C_PROTSEQ_MAX_REQS_DEFAULT,
                                NULL //&SecurityDescriptor
                            );
        if(status == RPC_S_OK)
        {
            dwNumSuccessRpcPro++;
        }

        // Must have at least one protocol.
        if(dwNumSuccessRpcPro == 0)
        {
            status = TLS_E_RPC_PROTOCOL;
            break;
        }

        // Get server binding handles
        status = RpcServerInqBindings(&pbindingVector);
        if (status != RPC_S_OK)
        {
            status = TLS_E_RPC_INQ_BINDING;
            break;
        }

        // Register interface(s) and binding(s) (endpoints) with
        // the endpoint mapper.
        status = RpcEpRegister( 
                            TermServLicensing_v1_0_s_ifspec,   // from rpcsvc.h
                            pbindingVector,
                            NULL, // &export_uuid,
                            L""
                        );

        if (status != RPC_S_OK)
        {
            status = TLS_E_RPC_EP_REGISTER;
            break;
        }

        status = RpcServerRegisterIf(
                            TermServLicensing_v1_0_s_ifspec,
                            NULL,
                            NULL);
        if(status != RPC_S_OK)
        {
            status = TLS_E_RPC_REG_INTERFACE;
            break;
        }

        // Register interface(s) and binding(s) (endpoints) with
        // the endpoint mapper.
        status = RpcEpRegister( 
                            HydraLicenseService_v1_0_s_ifspec,   // from rpcsvc.h
                            pbindingVector,
                            NULL, // &export_uuid,
                            L"");

        if (status != RPC_S_OK)
        {
            status = TLS_E_RPC_EP_REGISTER;
            break;
        }

        status = RpcServerRegisterIf(
                            HydraLicenseService_v1_0_s_ifspec,
                            NULL,
                            NULL);
        if(status != RPC_S_OK)
        {
            status = TLS_E_RPC_REG_INTERFACE;
            break;
        }

        // Register interface(s) and binding(s) (endpoints) with
        // the endpoint mapper.
        status = RpcEpRegister( 
                            TermServLicensingBackup_v1_0_s_ifspec,   // from rpcsvc.h
                            pbindingVector,
                            NULL, // &export_uuid,
                            L"");

        if (status != RPC_S_OK)
        {
            status = TLS_E_RPC_EP_REGISTER;
            break;
        }

        status = RpcServerRegisterIf(
                            TermServLicensingBackup_v1_0_s_ifspec,
                            NULL,
                            NULL);
        if(status != RPC_S_OK)
        {
            status = TLS_E_RPC_REG_INTERFACE;
            break;
        }

        // Enable NT LM Security Support Provider (NtLmSsp service)
        status = RpcServerRegisterAuthInfo(0,
                                           RPC_C_AUTHN_GSS_NEGOTIATE,
                                           0,
                                           0);

        if (status != RPC_S_OK)
        {
            status = TLS_E_RPC_SET_AUTHINFO;
            break;
        }

    } while(FALSE);

    if(status != RPC_S_OK)
    {
        TLSLogEvent(
                EVENTLOG_ERROR_TYPE, 
                TLS_E_SERVICEINIT,
                TLS_E_INITRPC, 
                status
            );

        status = TLS_E_SERVICE_STARTUP;
    }

    ExitThread(status);
    return status;
}

//------------------------------------------------------------------------

DWORD SetupNamedPipes()
{
    DWORD dwStatus = ERROR_SUCCESS;

#ifdef DISALLOW_ANONYMOUS_RPC
    BOOL fInDomain = FALSE;

    TLSInDomain(&fInDomain,NULL);

    if (!fInDomain)
    {
#endif

        dwStatus = AddNullSessionPipe(_TEXT(HLSPIPENAME));

        if (dwStatus != ERROR_SUCCESS)
        {
            return dwStatus;
        }

        dwStatus = AddNullSessionPipe(_TEXT(SZSERVICENAME));

#ifdef DISALLOW_ANONYMOUS_RPC
    }
    else
    {
        dwStatus = RemoveNullSessions();
    }
#endif

    return dwStatus;
}


//---------------------------------------------------------------------------

/****************************************************************************/
// LSCreateLocalGroup
//
// Create Terminal Server Computers local group if not exist
// and create the security descriptor of this local group
/****************************************************************************/
BOOL TSLSCreateLocalGroupSecDes(BOOL fEnterpriseServer)
{    
    DWORD dwStatus;
    LPWSTR ReferencedDomainName = NULL;
    ULONG SidSize, ReferencedDomainNameSize;
    SID_NAME_USE SidNameUse;
    WCHAR TSLSLocalGroupName[TSLSLOCALGROUPNAMELENGTH];
    WCHAR TSLSLocalGroupDes[TSLSLOCALGROUPDESLENGTH];
    GROUP_INFO_1 TSLSGroupInfo = {TSLSLocalGroupName, TSLSLocalGroupDes};
    HMODULE HModule = NULL;
    LOCALGROUP_MEMBERS_INFO_3 DomainComputers = {ALLDOMAINCOMPUTERS};       
    DWORD cbAcl;
    DWORD SecurityDescriptorSize;
    NET_API_STATUS NetStatus;

    HModule = GetModuleHandle(NULL);
    
    if (HModule == NULL) 
    {
        dwStatus = GetLastError();
        if(dwStatus != ERROR_SUCCESS)
        {
            TLSLogEvent(
                    EVENTLOG_ERROR_TYPE,
                    TLS_E_SERVICEINIT,
                    TLS_E_CREATETSLSGROUP
                );           
        }
        goto cleanup;
    }

    LoadString(HModule, IDS_TSLSLOCALGROUP_NAME, TSLSLocalGroupName, sizeof(TSLSLocalGroupName) / sizeof(WCHAR));
    LoadString(HModule, IDS_TSLSLOCALGROUP_DES, TSLSLocalGroupDes, sizeof(TSLSLocalGroupDes) / sizeof(WCHAR));

    for( int i = 0; i < 3; i++)
    {
        // Create local group if not exist
        NetStatus = NetLocalGroupAdd(
                    NULL,
                    1,
                    (LPBYTE)&TSLSGroupInfo,
                    NULL
                    );
        if(NERR_Success == NetStatus || NERR_GroupExists == NetStatus || ERROR_ALIAS_EXISTS == NetStatus )
            break;

        Sleep (5000);
    }
    

    if(NERR_Success != NetStatus) 
    {
       if((NERR_GroupExists != NetStatus)
           && (ERROR_ALIAS_EXISTS != NetStatus)) 
        {
            dwStatus = ERROR_ACCESS_DENIED;
            //
            // Didn't create the group and group doesn't exist either.
            //            
            TLSLogEvent(
                    EVENTLOG_ERROR_TYPE,
                    TLS_E_SERVICEINIT,
                    TLS_E_CREATETSLSGROUP
                ); 
            goto cleanup;
        } 
        
    }  
    
    //
    // Group created. Now lookup the SID.
    //
    SidSize = ReferencedDomainNameSize = 0;
    ReferencedDomainName = NULL;

    NetStatus = LookupAccountName(
                NULL,
                TSLSGroupInfo.grpi1_name,
                NULL,
                &SidSize,
                NULL,
                &ReferencedDomainNameSize,
                &SidNameUse);

    if( NetStatus ) 
    {             
        dwStatus = GetLastError();
        if( ERROR_INSUFFICIENT_BUFFER != dwStatus ) 
            goto cleanup;
    }
        
    g_pSid = (PSID)LocalAlloc(LMEM_FIXED, SidSize);
    if (NULL == g_pSid) 
    {
        goto cleanup;
    }

    ReferencedDomainName = (LPWSTR)LocalAlloc(LMEM_FIXED,
                                              sizeof(WCHAR)*(1+ReferencedDomainNameSize));
    if (NULL == ReferencedDomainName) {
        goto cleanup;
    }
        
    NetStatus = LookupAccountName(
                NULL,
                TSLSGroupInfo.grpi1_name,
                g_pSid,
                &SidSize,
                ReferencedDomainName,
                &ReferencedDomainNameSize,
                &SidNameUse
                );
    if( 0 == NetStatus ) 
    {
        //
        // Failed.
        //
        dwStatus = GetLastError();
        if(dwStatus != ERROR_SUCCESS)
        {
            TLSLogEvent(
                    EVENTLOG_ERROR_TYPE,
                    TLS_E_SERVICEINIT,
                    TLS_E_CREATETSLSGROUP
                );         
        }
        goto cleanup;
    }
        
    // Create Security Descriptor
    // The size is equal to the size of an SD + twice the length of the SID
    // (for owner and group) + size of the DACL = sizeof ACL + size of the
    // ACE, which is an ACE + length of the SID.
    
    SecurityDescriptorSize = sizeof(SECURITY_DESCRIPTOR) +
                             sizeof(ACCESS_ALLOWED_ACE) +
                             sizeof(ACL) +
                             3 * GetLengthSid(g_pSid);

    g_pSecDes = (PSECURITY_DESCRIPTOR)LocalAlloc(LMEM_FIXED, SecurityDescriptorSize);
    
    if (NULL == g_pSecDes) 
    {
        goto cleanup;
    }
    if (!InitializeSecurityDescriptor(g_pSecDes, SECURITY_DESCRIPTOR_REVISION))
    {
        dwStatus = GetLastError();
        if(dwStatus != ERROR_SUCCESS)
        {
            TLSLogEvent(
                    EVENTLOG_ERROR_TYPE,
                    TLS_E_SERVICEINIT,
                    TLS_E_CREATETSLSGROUP
                );
        }
        goto cleanup;
    }

    SetSecurityDescriptorOwner(g_pSecDes, g_pSid, FALSE);
    SetSecurityDescriptorGroup(g_pSecDes, g_pSid, FALSE);

    // Add acl to security descriptor
    cbAcl = sizeof(ACL) + sizeof (ACCESS_ALLOWED_ACE) - sizeof (DWORD)+ GetLengthSid(g_pSid);
    g_Dacl = (PACL) LocalAlloc(LMEM_FIXED, cbAcl);
    
    if (NULL == g_Dacl) 
    {
        goto cleanup;
    }

    if(!InitializeAcl(g_Dacl,
                      cbAcl,
                      ACL_REVISION))
    {
        dwStatus = GetLastError();
        if(dwStatus != ERROR_SUCCESS)
        {
            TLSLogEvent(
                    EVENTLOG_ERROR_TYPE,
                    TLS_E_SERVICEINIT,
                    TLS_E_CREATETSLSGROUP
                );
        }
        goto cleanup;
    }

    if(!AddAccessAllowedAce(g_Dacl, ACL_REVISION, STANDARD_RIGHTS_READ, g_pSid))
    {
        dwStatus = GetLastError();  
        if(dwStatus != ERROR_SUCCESS)
        {
            TLSLogEvent(
                    EVENTLOG_ERROR_TYPE,
                    TLS_E_SERVICEINIT,
                    TLS_E_CREATETSLSGROUP
                );
        }
        goto cleanup;
    }

    if(!SetSecurityDescriptorDacl(g_pSecDes, TRUE, g_Dacl, FALSE))
    {
        dwStatus = GetLastError();  
        if(dwStatus != ERROR_SUCCESS)
        {
            TLSLogEvent(
                    EVENTLOG_ERROR_TYPE,
                    TLS_E_SERVICEINIT,
                    TLS_E_CREATETSLSGROUP
                );
        }
        goto cleanup;
    } 

    return TRUE;

cleanup:
    
    if (ReferencedDomainName)
        LocalFree(ReferencedDomainName);
    if (g_pSid)
        LocalFree(g_pSid);
    if (g_Dacl)
        LocalFree(g_Dacl);
    if (g_pSecDes)
        LocalFree(g_pSecDes);

    return FALSE;
}
//------------------------------------------------------------------------------

DWORD 
ServiceStart(
    IN DWORD dwArgc, 
    IN LPTSTR *lpszArgv, 
    IN BOOL bDebug
    )
/*
*/
{
    RPC_BINDING_VECTOR *pbindingVector = NULL;
    WCHAR *pszEntryName = _TEXT(RPC_ENTRYNAME);
    HANDLE hInitThread=NULL;
    HANDLE hRpcThread=NULL;
    HANDLE hMailslotThread=NULL;
    HANDLE hShutdownThread=NULL;

    DWORD   dump;
    HANDLE  hEvent=NULL;
    DWORD   dwStatus=ERROR_SUCCESS;
    WORD    wVersionRequested;
    WSADATA wsaData;
    int     err;     

    if (!ReportStatusToSCMgr(
                        SERVICE_START_PENDING,
                        NO_ERROR,
                        SERVICE_WAITHINT))
    {
        // resource leak but something went wrong already.
        dwStatus = TLS_E_SC_REPORT_STATUS;
        goto cleanup;
    }

    hrStatus = CoInitializeEx (NULL, COINIT_MULTITHREADED);

	if (FAILED (hrStatus))
	{
        DBGPrintf(
                    DBG_INFORMATION,
                    DBG_FACILITY_INIT,
                    DBGLEVEL_FUNCTION_DETAILSIMPLE,
                    _TEXT("CoInitializeEx failed with error code %08x...\n"), 
                    hrStatus
                );
	}

    if (!ReportStatusToSCMgr(
                        SERVICE_START_PENDING,
                        NO_ERROR,
                        SERVICE_WAITHINT))
    {
        // resource leak but something went wrong already.
        dwStatus = TLS_E_SC_REPORT_STATUS;
        goto cleanup;
    }

	if (SUCCEEDED (hrStatus))
    {
        hrStatus = CoInitializeSecurity(
	                                    NULL,
	                                    -1,
	                                    NULL,
	                                    NULL,
	                                    RPC_C_AUTHN_LEVEL_CONNECT,
	                                    RPC_C_IMP_LEVEL_IDENTIFY,
	                                    NULL,
	                                    EOAC_NONE,
	                                    NULL
	                                    );
    }

    if (!ReportStatusToSCMgr(
                        SERVICE_START_PENDING,
                        NO_ERROR,
                        SERVICE_WAITHINT))
    {
        // resource leak but something went wrong already.
        dwStatus = TLS_E_SC_REPORT_STATUS;
        goto cleanup;
    }

    if (SUCCEEDED (hrStatus))
    {

	    g_pWriter = new CTlsVssJetWriter;

	    if (NULL == g_pWriter)
		{
            DBGPrintf(
                    DBG_INFORMATION,
                    DBG_FACILITY_INIT,
                    DBGLEVEL_FUNCTION_DETAILSIMPLE,
                    _TEXT("new CVssJetWriter failed...\n")
                );
		    

		    hrStatus = HRESULT_FROM_WIN32 (ERROR_NOT_ENOUGH_MEMORY);
		}
	}

    // Report the status to the service control manager.
    if (!ReportStatusToSCMgr(
                        SERVICE_START_PENDING,
                        NO_ERROR,
                        SERVICE_WAITHINT))
    {
        // resource leak but something went wrong already.
        dwStatus = TLS_E_SC_REPORT_STATUS;
        goto cleanup;
    }

    {
        DWORD dwConsole;
        DWORD dwDbLevel;
        DWORD dwType;
        DWORD dwSize = sizeof(dwConsole);
        DWORD status;

        HKEY hKey=NULL;

        status = RegOpenKeyEx(
                            HKEY_LOCAL_MACHINE,
                            LSERVER_PARAMETERS_KEY,
                            0,
                            KEY_ALL_ACCESS,
                            &hKey);

        if(status == ERROR_SUCCESS)
        {

            if(RegQueryValueEx(
                        hKey,
                        LSERVER_PARAMETERS_CONSOLE,
                        NULL,
                        &dwType,
                        (LPBYTE)&dwConsole,
                        &dwSize
                    ) != ERROR_SUCCESS)
            {
                dwConsole = 0;
            }

            dwSize = sizeof(dwDbLevel);

            if(RegQueryValueEx(
                        hKey,
                        LSERVER_PARAMETERS_LOGLEVEL,
                        NULL,
                        &dwType,
                        (LPBYTE)&dwDbLevel,
                        &dwSize
                    ) == ERROR_SUCCESS)
            {
                InitDBGPrintf(
                        dwConsole != 0,
                        _TEXT(SZSERVICENAME),
                        dwDbLevel
                    );
            }

            RegCloseKey(hKey);
        }
    }

    // Report the status to the service control manager.
    if (!ReportStatusToSCMgr(
                        SERVICE_START_PENDING,
                        NO_ERROR,
                        SERVICE_WAITHINT))
    {
        // resource leak but something went wrong already.
        dwStatus = TLS_E_SC_REPORT_STATUS;
        goto cleanup;
    }

    do {

        dwStatus = SetupNamedPipes();

        if (dwStatus != ERROR_SUCCESS)
        {
            break;
        }

        wVersionRequested = MAKEWORD( 1, 1 ); 
        err = WSAStartup( 
                        wVersionRequested, 
                        &wsaData 
                    );
        if(err != 0) 
        {
            // None critical error
            TLSLogWarningEvent(
                        TLS_E_SERVICE_WSASTARTUP
                    );
        }
        else
        {
            char hostname[(MAXTCPNAME+1)*sizeof(TCHAR)];
            err=gethostname(hostname, MAXTCPNAME*sizeof(TCHAR));
            if(err == 0)
            {
                struct addrinfo *paddrinfo;
                struct addrinfo hints;

                memset(&hints,0,sizeof(hints));

                hints.ai_flags = AI_CANONNAME;
                hints.ai_family = PF_UNSPEC;

                if (0 == getaddrinfo(hostname,NULL,&hints,&paddrinfo) && paddrinfo && paddrinfo->ai_canonname)
                {
                    err = (MultiByteToWideChar(
                                        GetACP(), 
                                        MB_ERR_INVALID_CHARS, 
                                        paddrinfo->ai_canonname,
                                        -1, 
                                        g_szHostName, 
                                        g_cbHostName) == 0) ? -1 : 0;
                }
                else
                {
                    err = -1;
                }

                freeaddrinfo(paddrinfo);
            }
        }

        if(err != 0)
        {
            if(GetComputerName(g_szHostName, &g_cbHostName) == FALSE)
            {
                dwStatus = GetLastError();

                DBGPrintf(
                    DBG_INFORMATION,
                    DBG_FACILITY_INIT,
                    DBGLEVEL_FUNCTION_DETAILSIMPLE,
                    _TEXT("GetComputerName() failed with %d...\n"),
                    dwStatus
                );

                // this shoule not happen...
                TLSLogErrorEvent(TLS_E_INIT_GENERAL);
                break;
            }
        }

        if(GetComputerName(g_szComputerName, &g_cbComputerName) == FALSE)
        {
            dwStatus = GetLastError();

            DBGPrintf(
                DBG_INFORMATION,
                DBG_FACILITY_INIT,
                DBGLEVEL_FUNCTION_DETAILSIMPLE,
                _TEXT("GetComputerName() failed with %d...\n"),
                dwStatus
            );

            // this shoule not happen...
            TLSLogErrorEvent(TLS_E_INIT_GENERAL);
            break;
        }

        hRpcPause=CreateEvent(NULL, TRUE, TRUE, NULL);
        if(!hRpcPause)
        {
            TLSLogErrorEvent(TLS_E_ALLOCATE_RESOURCE);
            dwStatus = TLS_E_ALLOCATE_RESOURCE;
            break;
        }

        //
        // start up general server and RPC initialization thread
        //
        hInitThread=ServerInit(bDebug);
        if(hInitThread==NULL)
        {
            TLSLogErrorEvent(TLS_E_SERVICE_STARTUP_CREATE_THREAD);
            dwStatus = TLS_E_SERVICE_STARTUP_CREATE_THREAD;
            break;
        }

        dwStatus = ERROR_SUCCESS;
        
        //
        // Wait for general server init. thread to terminate
        //
        while(WaitForSingleObject( hInitThread, 100 ) == WAIT_TIMEOUT)
        {
            // Report the status to the service control manager.
            if (!ReportStatusToSCMgr(
                                SERVICE_START_PENDING,
                                NO_ERROR,
                                SERVICE_WAITHINT))
            {
                // resource leak but something went wrong already.
                dwStatus = TLS_E_SC_REPORT_STATUS;
                break;
            }
        }

        if(dwStatus != ERROR_SUCCESS)
        {
            break;
        }


        // Check thread exit code.
        GetExitCodeThread(
                    hInitThread, 
                    &dwStatus
                );
        if(dwStatus != ERROR_SUCCESS)
        {
            //
            // Server init. thread logs its own error
            //
            dwStatus = TLS_E_SERVICE_STARTUP_INIT_THREAD_ERROR;
            break;
        }

        CloseHandle(hInitThread);
        hInitThread=NULL;

        // Create the Terminal Servers group in case of Domain a/ Enterprise LS

        BOOL fInDomain;
        DWORD dwErr;
        BOOL fEnterprise = FALSE;
        
        if(GetLicenseServerRole() & TLSERVER_ENTERPRISE_SERVER)
        {
            fEnterprise = TRUE;
        }        
        else
        {
            dwErr = TLSInDomain(&fInDomain,NULL);
        }

        if(fEnterprise == TRUE || ( dwErr == ERROR_SUCCESS && fInDomain == TRUE))
        {
            // Create the License Server group that contains the list of Terminal servers that have access to it.

            if (!TSLSCreateLocalGroupSecDes(fEnterprise)) 
            {
                TLSLogErrorEvent(TLS_E_CREATETSLSGROUP);
                goto cleanup;
            }
        }


        // timing, if we startup RPC init thread but database init thread 
        // can't initialize, service will be in forever stop state.
        hRpcThread=CreateThread(
                            NULL, 
                            0, 
                            RPCServiceStartThread, 
                            ULongToPtr(bDebug), 
                            0, 
                            &dump
                        );
        if(hRpcThread == NULL)
        {
            TLSLogErrorEvent(TLS_E_SERVICE_STARTUP_CREATE_THREAD);
            dwStatus=TLS_E_SERVICE_STARTUP_CREATE_THREAD;
            break;
        }

        dwStatus = ERROR_SUCCESS;

        //
        // Wait for RPC init. thread to terminate
        //
        while(WaitForSingleObject( hRpcThread, 100 ) == WAIT_TIMEOUT)
        {
            // Report the status to the service control manager.
            if (!ReportStatusToSCMgr(SERVICE_START_PENDING, // service state
                                     NO_ERROR,              // exit code
                                     SERVICE_WAITHINT))          // wait hint
            {
                dwStatus = TLS_E_SC_REPORT_STATUS;
                break;
            }
        }

        if(dwStatus != ERROR_SUCCESS)
        {
            break;
        }

        // Check thread exit code.
        GetExitCodeThread(hRpcThread, &dwStatus);
        if(dwStatus != ERROR_SUCCESS)
        {
            dwStatus = TLS_E_SERVICE_STARTUP_RPC_THREAD_ERROR;
            break;
        }

        CloseHandle(hRpcThread);
        hRpcThread=NULL;

        //
        // Tell server control manager that we are ready.
        //
        if (!ReportStatusToSCMgr(
                            SERVICE_RUNNING,        // service state
                            NO_ERROR,               // exit code
                            SERVICE_WAITHINT             // wait hint
                        ))
        {
            dwStatus = TLS_E_SC_REPORT_STATUS;
            break;
        }

        
        //
        // Post service init. load self-signed certificate and init. crypt.
        // this is needed after reporting service running status back to 
        // service control manager because it may need to manually call 
        // StartService() to startup protected storage service. 
        //
        if(InitCryptoAndCertificate() != ERROR_SUCCESS)
        {
            dwStatus = TLS_E_SERVICE_STARTUP_POST_INIT;
            break;
        }

        TLSLogInfoEvent(TLS_I_SERVICE_START);


        // RpcMgmtWaitServerListen() will block until the server has
        // stopped listening.  If this service had something better to
        // do with this thread, it would delay this call until
        // ServiceStop() had been called. (Set an event in ServiceStop()).
        //
        BOOL bOtherServiceStarted = FALSE;

        do {
            WaitForSingleObject(hRpcPause, INFINITE);
            if(ssCurrentStatus == SERVICE_STOP_PENDING)
            {
                break;
            }

            // Start accepting client calls.PostServiceInit
            dwStatus = RpcServerListen(
                                RPC_MINIMUMCALLTHREADS,
                                RPC_MAXIMUMCALLTHREADS,
                                TRUE
                            );

            if(dwStatus != RPC_S_OK)
            {
                TLSLogErrorEvent(TLS_E_RPC_LISTEN);
                dwStatus = TLS_E_SERVICE_RPC_LISTEN;
                break;
            }

            //
            // Initialize all policy module
            //
            if(bOtherServiceStarted == FALSE)
            {
                dwStatus = PostServiceInit();
                if(dwStatus != ERROR_SUCCESS)
                {
                    // faild to initialize.
                    break;
                }

                //ServiceInitPolicyModule();
            }

            bOtherServiceStarted = TRUE;

            DBGPrintf(
                    DBG_INFORMATION,
                    DBG_FACILITY_INIT,
                    DBGLEVEL_FUNCTION_DETAILSIMPLE,
                    _TEXT("Ready to accept request...\n")
                );

            dwStatus = RpcMgmtWaitServerListen();
            assert(dwStatus == RPC_S_OK);
        } while(TRUE);

        // tell service control manager we are stopping
        ReportStatusToSCMgr(
                        SERVICE_STOP_PENDING, 
                        NO_ERROR, 
                        SERVICE_WAITHINT
                    );

        //
        // Terminate - ignore all error here on
        //
        dwStatus = RpcServerUnregisterIf(
                                TermServLicensingBackup_v1_0_s_ifspec,
                                NULL,
                                TRUE
                            );

        // tell service control manager we are stopping
        ReportStatusToSCMgr(
                        SERVICE_STOP_PENDING,
                        NO_ERROR,
                        SERVICE_WAITHINT
                    );

        dwStatus = RpcServerUnregisterIf(
                                HydraLicenseService_v1_0_s_ifspec,
                                NULL,
                                TRUE
                            );

        // tell service control manager we are stopping
        ReportStatusToSCMgr(
                        SERVICE_STOP_PENDING, 
                        NO_ERROR, 
                        SERVICE_WAITHINT
                    );

        dwStatus = RpcServerUnregisterIf(
                                    TermServLicensing_v1_0_s_ifspec,   // from rpcsvc.h
                                    NULL,
                                    TRUE
                            );

        // tell service control manager we are stopping
        ReportStatusToSCMgr(
                        SERVICE_STOP_PENDING, 
                        NO_ERROR, 
                        SERVICE_WAITHINT
                    );


        // Remove entries from the endpoint mapper database.
        dwStatus = RpcEpUnregister(
                            HydraLicenseService_v1_0_s_ifspec,   // from rpcsvc.h
                            pbindingVector,
                            NULL
                        );

        // tell service control manager we are stopping
        ReportStatusToSCMgr(
                        SERVICE_STOP_PENDING, 
                        NO_ERROR, 
                        SERVICE_WAITHINT
                    );

        // Remove entries from the endpoint mapper database.
        dwStatus = RpcEpUnregister(
                            TermServLicensing_v1_0_s_ifspec,   // from rpcsvc.h
                            pbindingVector,
                            NULL
                        );

        // tell service control manager we are stopping
        ReportStatusToSCMgr(
                        SERVICE_STOP_PENDING, 
                        NO_ERROR, 
                        SERVICE_WAITHINT
                    );

        // Remove entries from the endpoint mapper database.
        dwStatus = RpcEpUnregister(
                            TermServLicensingBackup_v1_0_s_ifspec,   // from rpcsvc.h
                            pbindingVector,
                            NULL
                        );

        // Get server binding handles
        dwStatus = RpcServerInqBindings(
                                &pbindingVector
                            );

        if(dwStatus == ERROR_SUCCESS)
        {
            dwStatus = RpcBindingVectorFree(
                                    &pbindingVector
                                );
        }
        

        // Create entry name in name database first
        // Only work for NT 5.0 
        // status = RpcNsMgmtEntryDelete(RPC_C_NS_SYNTAX_DEFAULT, pszEntryName);

        // try to report the stopped status to the service control manager.
        //
        // Initialize Crypto.
    } while(FALSE);

    if(hInitThread != NULL)
    {
        CloseHandle(hInitThread);
    }

    if(hRpcThread != NULL)
    {
        CloseHandle(hRpcThread);
    }

    if(hMailslotThread != NULL)
    {
        CloseHandle(hMailslotThread);
    }

    if(hEvent != NULL)
    {
        CloseHandle(hEvent);
    }

    if(hRpcPause != NULL)
    {
        CloseHandle(hRpcPause);
    }

    if(err == 0)
    {
        WSACleanup();
    }

    ReportStatusToSCMgr(
                SERVICE_STOP_PENDING, 
                dwStatus, //NO_ERROR, 
                SERVICE_WAITHINT
            );

    //
    // Create another thread to shutdown server.
    //
    hShutdownThread=CreateThread(
                            NULL, 
                            0, 
                            ServiceShutdownThread, 
                            (VOID *)NULL, 
                            0, 
                            &dump
                        );
    if(hShutdownThread == NULL)
    {
        // Report the status to the service control manager with
        // long wait hint time.
        ReportStatusToSCMgr(
                    SERVICE_STOP_PENDING, 
                    NO_ERROR, 
                    SERVICE_SHUTDOWN_WAITTIME
                );

        //
        // can't create thread, just call shutdown directory
        //
        ServerShutdown();
    }
    else
    {
        //
        // report in 5 second interval to SC.
        //
        DWORD dwMaxWaitTime = SERVICE_SHUTDOWN_WAITTIME / 5000;  
        DWORD dwTimes=0;

        //
        // Wait for general server shutdown thread to terminate
        // Gives max 1 mins to shutdown
        //
        while(WaitForSingleObject( hShutdownThread, SC_WAITHINT ) == WAIT_TIMEOUT &&
              dwTimes++ < dwMaxWaitTime)
        {
            // Report the status to the service control manager.
            ReportStatusToSCMgr(
                        SERVICE_STOP_PENDING, 
                        NO_ERROR, 
                        SERVICE_WAITHINT
                    );
        }

        CloseHandle(hShutdownThread);
    }

cleanup:

    if (NULL != g_pWriter)
	{
	    g_pWriter->Uninitialize();
	    delete g_pWriter;
	    g_pWriter = NULL;
	}

    CoUninitialize( );

    // Signal we are safe to shutting down
    SetEvent(gSafeToTerminate);
    return dwStatus;
}

//-----------------------------------------------------------------
VOID 
ServiceStop()
/*++

++*/
{
 
    ReportStatusToSCMgr(
                    SERVICE_STOP_PENDING,
                    NO_ERROR,
                    0
                );

    // Stop's the server, wakes the main thread.
    SetEvent(hRpcPause);

    //
    // Signal currently waiting RPC call to terminate
    //
    ServiceSignalShutdown();

    // this is the actual time we receive shutdown request.
    SetServiceLastShutdownTime();


    (VOID)RpcMgmtStopServerListening(NULL);
    TLSLogInfoEvent(TLS_I_SERVICE_STOP);
}

//-----------------------------------------------------------------
VOID 
ServicePause()
/*++

++*/
{
    ResetEvent(hRpcPause);
    (VOID)RpcMgmtStopServerListening(NULL);
    TLSLogInfoEvent(TLS_I_SERVICE_PAUSED);
}

//-----------------------------------------------------------------
VOID 
ServiceContinue()
/*++

++*/
{
    SetEvent(hRpcPause);
    TLSLogInfoEvent(TLS_I_SERVICE_CONTINUE);
}

//-----------------------------------------------------------------
BOOL 
ReportStatusToSCMgr(
    IN DWORD dwCurrentState, 
    IN DWORD dwExitCode, 
    IN DWORD dwWaitHint
    )
/*++
Abstract: 

    Sets the current status of the service and reports it 
    to the Service Control Manager

Parameter:

    dwCurrentState - the state of the service
    dwWin32ExitCode - error code to report
    dwWaitHint - worst case estimate to next checkpoint

Returns:

    TRUE if success, FALSE otherwise

*/
{
    BOOL fResult=TRUE;

    if(g_bReportToSCM == TRUE)
    {
        SERVICE_STATUS ssStatus;
        static DWORD dwCheckPoint = 1;

        ssStatus.dwServiceType = SERVICE_WIN32_OWN_PROCESS;

        //
        // global - current status of process
        //
        ssCurrentStatus = dwCurrentState;

        if (dwCurrentState == SERVICE_START_PENDING)
        {
            ssStatus.dwControlsAccepted = 0;
        }
        else
        {
            ssStatus.dwControlsAccepted = SERVICE_ACCEPT_STOP | SERVICE_ACCEPT_PAUSE_CONTINUE | SERVICE_CONTROL_SHUTDOWN;
        }

        ssStatus.dwCurrentState = dwCurrentState;
        if(dwExitCode != NO_ERROR) 
        {
            ssStatus.dwWin32ExitCode = ERROR_SERVICE_SPECIFIC_ERROR;
            ssStatus.dwServiceSpecificExitCode = dwExitCode;
        }
        else
        {
          ssStatus.dwWin32ExitCode = dwExitCode;
        }

        ssStatus.dwWaitHint = dwWaitHint;

        if(dwCurrentState == SERVICE_RUNNING || dwCurrentState == SERVICE_STOPPED)
        {
            ssStatus.dwCheckPoint = 0;
        }
        else
        {
            ssStatus.dwCheckPoint = dwCheckPoint++;
        }

        // Report the status of the service to the service control manager.
        //
        fResult = SetServiceStatus(
                            sshStatusHandle, 
                            &ssStatus
                        );
        if(fResult == FALSE)
        {
            DBGPrintf(
                    DBG_INFORMATION,
                    DBG_FACILITY_INIT,
                    DBGLEVEL_FUNCTION_TRACE,
                    _TEXT("Failed to set service status %d...\n"),
                    GetLastError()
                );


            TLSLogErrorEvent(TLS_E_SC_REPORT_STATUS);
        }
    }

    return fResult;
}



///////////////////////////////////////////////////////////////////
//
//  The following code is for running the service as a console app
//
void 
CmdDebugService(
    IN int argc, 
    IN char ** argv, 
    IN BOOL bDebug
    )
/*
*/
{
    int dwArgc;
    LPTSTR *lpszArgv;

#ifdef UNICODE
    lpszArgv = CommandLineToArgvW(GetCommandLineW(), &(dwArgc) );
#else
    dwArgc   = (DWORD) argc;
    lpszArgv = argv;
#endif

    _tprintf(
            _TEXT("Debugging %s.\n"), 
            _TEXT(SZSERVICEDISPLAYNAME)
        );

    SetConsoleCtrlHandler( 
            ControlHandler, 
            TRUE 
        );

    ServiceStart( 
            dwArgc, 
            lpszArgv, 
            bDebug 
        );
}

//------------------------------------------------------------------
BOOL WINAPI 
ControlHandler( 
    IN DWORD dwCtrlType 
    )
/*++

Abstract:


Parameter:

    IN dwCtrlType : control type

Return:

    
++*/
{
    switch( dwCtrlType )
    {
        case CTRL_BREAK_EVENT:  // use Ctrl+C or Ctrl+Break to simulate
        case CTRL_C_EVENT:      // SERVICE_CONTROL_STOP in debug mode
            _tprintf(
                    _TEXT("Stopping %s.\n"), 
                    _TEXT(SZSERVICEDISPLAYNAME)
                );

            ssCurrentStatus = SERVICE_STOP_PENDING;
            ServiceStop();
            return TRUE;
            break;

    }
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\license\tlserver\server\templic.cpp ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996-1998
//
// File:        templic.cpp
//
// Contents:    
//              all routine deal with temporary license
//
// History:     
//  Feb 4, 98      HueiWang    Created
//---------------------------------------------------------------------------
#include "pch.cpp"
#include "globals.h"
#include "templic.h"
#include "misc.h"
#include "db.h"
#include "clilic.h"
#include "keypack.h"
#include "kp.h"
#include "lkpdesc.h"
#define STRSAFE_NO_DEPRECATE
#include "strsafe.h"

#define USSTRING_TEMPORARY _TEXT("Temporary Licenses for")

DWORD
TLSDBGetTemporaryLicense(
    IN PTLSDbWorkSpace pDbWkSpace,
    IN PTLSDBLICENSEREQUEST pRequest,
    IN OUT PTLSLICENSEPACK pLicensePack
);


//+-------------------------------------------------------------
DWORD 
TLSDBIssueTemporaryLicense( 
    IN PTLSDbWorkSpace pDbWkSpace,
    IN PTLSDBLICENSEREQUEST pRequest,
    IN FILETIME* pNotBefore,
    IN FILETIME* pNotAfter,
    IN OUT PTLSDBLICENSEDPRODUCT pLicensedProduct
    )
/*++
Abstract:

    Issue a temporary license, insert a temporary license 
    pack if necessary

Parameters:

    pDbWkSpace - workspace handle.
    pRequest - license request.

Returns:


Note:

    Seperate routine for issuing perm license just in case 
    we decide to use our own format for temp. license
++*/
{
    DWORD dwStatus=ERROR_SUCCESS;
    ULARGE_INTEGER  ulSerialNumber;
    DWORD  dwLicenseId;
    LPTSTR lpRequest=NULL;
    LICENSEDCLIENT issuedLicense;
    TLSLICENSEPACK LicensePack;

    PMGENERATELICENSE PolModGenLicense;
    PPMCERTEXTENSION pPolModCertExtension=NULL;

    FILETIME notBefore, notAfter;

    // ----------------------------------------------------------
    // Issue license            
    memset(&ulSerialNumber, 0, sizeof(ulSerialNumber));

    //-----------------------------------------------------------------------------
    // this step require reduce available license by 1
    //
    long numLicense=1;

    dwStatus=TLSDBGetTemporaryLicense(
                                pDbWkSpace,
                                pRequest,
                                &LicensePack            
                            );

    if(dwStatus != ERROR_SUCCESS)
    {
        goto cleanup;
    }

    if((LicensePack.ucAgreementType & ~LSKEYPACK_RESERVED_TYPE) != LSKEYPACKTYPE_TEMPORARY && 
       (LicensePack.ucKeyPackStatus & ~LSKEYPACKSTATUS_RESERVED) != LSKEYPACKSTATUS_TEMPORARY )
    {
        SetLastError(dwStatus = TLS_E_INTERNAL);
        TLSASSERT(FALSE);
        goto cleanup;
    }
    
    // reset status
    dwStatus = ERROR_SUCCESS;
    dwLicenseId=TLSDBGetNextLicenseId();

    ulSerialNumber.LowPart = dwLicenseId;
    ulSerialNumber.HighPart = LicensePack.dwKeyPackId;

    //
    // Update License Table Here
    //
    memset(&issuedLicense, 0, sizeof(LICENSEDCLIENT));

    issuedLicense.dwLicenseId = dwLicenseId;
    issuedLicense.dwKeyPackId = LicensePack.dwKeyPackId;
    issuedLicense.dwKeyPackLicenseId = LicensePack.dwNextSerialNumber;
    issuedLicense.dwNumLicenses = 1;

    if(pNotBefore == NULL || pNotAfter == NULL)
    {
        issuedLicense.ftIssueDate = time(NULL);
        issuedLicense.ftExpireDate = issuedLicense.ftIssueDate + g_GracePeriod * 24 * 60 * 60;
    }
    else
    {
        FileTimeToLicenseDate(pNotBefore, &(issuedLicense.ftIssueDate));
        FileTimeToLicenseDate(pNotAfter, &(issuedLicense.ftExpireDate));
    }

    issuedLicense.ucLicenseStatus = LSLICENSE_STATUS_TEMPORARY;

    _tcscpy(issuedLicense.szMachineName, pRequest->szMachineName);
    _tcscpy(issuedLicense.szUserName, pRequest->szUserName);

    issuedLicense.dwSystemBiosChkSum = pRequest->hWid.dwPlatformID;
    issuedLicense.dwVideoBiosChkSum = pRequest->hWid.Data1;
    issuedLicense.dwFloppyBiosChkSum = pRequest->hWid.Data2;
    issuedLicense.dwHardDiskSize = pRequest->hWid.Data3;
    issuedLicense.dwRamSize = pRequest->hWid.Data4;


    UnixTimeToFileTime(issuedLicense.ftIssueDate, &notBefore);
    UnixTimeToFileTime(issuedLicense.ftExpireDate, &notAfter);

    //
    // Inform Policy Module of license generation.
    // 

    PolModGenLicense.pLicenseRequest = pRequest->pPolicyLicenseRequest;
    PolModGenLicense.dwKeyPackType = LSKEYPACKTYPE_TEMPORARY;
    PolModGenLicense.dwKeyPackId = LicensePack.dwKeyPackId;
    PolModGenLicense.dwKeyPackLicenseId = LicensePack.dwNextSerialNumber;
    PolModGenLicense.ClientLicenseSerialNumber = ulSerialNumber;
    PolModGenLicense.ftNotBefore = notBefore;
    PolModGenLicense.ftNotAfter = notAfter;

    dwStatus = pRequest->pPolicy->PMLicenseRequest( 
                                        pRequest->hClient,
                                        REQUEST_GENLICENSE,
                                        (PVOID)&PolModGenLicense,
                                        (PVOID *)&pPolModCertExtension
                                    );

    if(dwStatus != ERROR_SUCCESS)
    {
        //
        // Error in policy module
        //
        goto cleanup;
    }

    //  
    // Check error return from policy module
    //
    if(pPolModCertExtension != NULL)
    {
        if(pPolModCertExtension->pbData != NULL && pPolModCertExtension->cbData == 0 ||
           pPolModCertExtension->pbData == NULL && pPolModCertExtension->cbData != 0  )
        {
            // assuming no extension data
            pPolModCertExtension->cbData = 0;
            pPolModCertExtension->pbData = NULL;
        }

        if(CompareFileTime(&(pPolModCertExtension->ftNotBefore), &(pPolModCertExtension->ftNotAfter)) > 0)
        {
            //
            // invalid data return from policy module
            //
            TLSLogEvent(
                    EVENTLOG_ERROR_TYPE,
                    TLS_E_GENERATECLIENTELICENSE,
                    dwStatus = TLS_E_POLICYMODULEERROR,
                    pRequest->pPolicy->GetCompanyName(),
                    pRequest->pPolicy->GetProductId()
                );

            goto cleanup;
        }

        //
        // do not accept changes to license expiration date
        //
        if(pNotBefore != NULL && pNotAfter != NULL)
        {
            if( FileTimeToLicenseDate(&(pPolModCertExtension->ftNotBefore), &issuedLicense.ftIssueDate) == FALSE ||
                FileTimeToLicenseDate(&(pPolModCertExtension->ftNotAfter), &issuedLicense.ftExpireDate) == FALSE )
            {
                //
                // Invalid data return from policy module
                //
                TLSLogEvent(
                        EVENTLOG_ERROR_TYPE,
                        TLS_E_GENERATECLIENTELICENSE,
                        dwStatus = TLS_E_POLICYMODULEERROR,
                        pRequest->pPolicy->GetCompanyName(),
                        pRequest->pPolicy->GetProductId()
                    );

                goto cleanup;
            }
        }

        notBefore = pPolModCertExtension->ftNotBefore;
        notAfter = pPolModCertExtension->ftNotAfter;
    }

    //
    // Add license into license table
    //
    dwStatus = TLSDBLicenseAdd(
                        pDbWkSpace, 
                        &issuedLicense, 
                        0,
                        NULL
                    );


    //
    // Return licensed product
    //
    pLicensedProduct->pSubjectPublicKeyInfo = NULL;
    pLicensedProduct->dwQuantity = 1;
    pLicensedProduct->ulSerialNumber = ulSerialNumber;

    pLicensedProduct->dwKeyPackId = LicensePack.dwKeyPackId;
    pLicensedProduct->dwLicenseId = dwLicenseId;
    pLicensedProduct->dwKeyPackLicenseId = LicensePack.dwNextSerialNumber;
    pLicensedProduct->ClientHwid = pRequest->hWid;
    pLicensedProduct->bTemp = TRUE;

    pLicensedProduct->NotBefore = notBefore;
    pLicensedProduct->NotAfter = notAfter;

    pLicensedProduct->dwProductVersion = MAKELONG(LicensePack.wMinorVersion, LicensePack.wMajorVersion);

    _tcscpy(pLicensedProduct->szCompanyName, LicensePack.szCompanyName);
    _tcscpy(pLicensedProduct->szLicensedProductId, LicensePack.szProductId);
    _tcscpy(pLicensedProduct->szRequestProductId, pRequest->pClientLicenseRequest->pszProductId);

    _tcscpy(pLicensedProduct->szUserName, pRequest->szUserName);
    _tcscpy(pLicensedProduct->szMachineName, pRequest->szMachineName);

    pLicensedProduct->dwLanguageID = pRequest->dwLanguageID;
    pLicensedProduct->dwPlatformID = pRequest->dwPlatformID;
    pLicensedProduct->pbPolicyData = (pPolModCertExtension) ? pPolModCertExtension->pbData : NULL;
    pLicensedProduct->cbPolicyData = (pPolModCertExtension) ? pPolModCertExtension->cbData : 0;

cleanup:

    return dwStatus;
}


//-----------------------------------------------------------------
DWORD
TLSDBAddTemporaryKeyPack( 
    IN PTLSDbWorkSpace pDbWkSpace,
    IN PTLSDBLICENSEREQUEST pRequest,
    IN OUT LPTLSLICENSEPACK lpTmpKeyPackAdd
    )
/*++

Abstract:

    Add a temporary keypack into database.

Parameter:

    pDbWkSpace : workspace handle.
    szCompanyName :
    szProductId :
    dwVersion :
    dwPlatformId :
    dwLangId :
    lpTmpKeyPackAdd : added keypack.

Returns:

++*/
{
    DWORD  dwStatus;
    TLSLICENSEPACK LicPack;
    TLSLICENSEPACK existingLicPack;

    LICPACKDESC LicPackDesc;
    LICPACKDESC existingLicPackDesc;
    BOOL bAddDefDescription=FALSE;

    TCHAR szDefProductDesc[LSERVER_MAX_STRING_SIZE];
    int count=0;
    memset(&LicPack, 0, sizeof(TLSLICENSEPACK));
    memset(&existingLicPack, 0, sizeof(TLSLICENSEPACK));

    memset(&LicPackDesc, 0, sizeof(LICPACKDESC));
    memset(szDefProductDesc, 0, sizeof(szDefProductDesc));
    memset(&existingLicPackDesc, 0, sizeof(LICPACKDESC));

    //
    // Load product description prefix
    //
    LoadResourceString(
                    IDS_TEMPORARY_PRODUCTDESC,
                    szDefProductDesc,
                    sizeof(szDefProductDesc) / sizeof(szDefProductDesc[0])
                ); 

    LicPack.ucAgreementType = LSKEYPACKTYPE_TEMPORARY;

    StringCchCopyN(
            LicPack.szCompanyName, 
            sizeof(LicPack.szCompanyName)/sizeof(LicPack.szCompanyName[0]),
            pRequest->pszCompanyName, 
            min(_tcslen(pRequest->pszCompanyName), LSERVER_MAX_STRING_SIZE)
        );    

    StringCchCopyN(
            LicPack.szProductId, 
            sizeof(LicPack.szCompanyName)/ sizeof(LicPack.szProductId[0]),
            pRequest->pszProductId, 
            min(_tcslen(pRequest->pszProductId), LSERVER_MAX_STRING_SIZE)
        );    

    StringCchCopyN(
            LicPack.szInstallId,
            sizeof(LicPack.szInstallId)/sizeof(LicPack.szInstallId[0]),
            (LPTSTR)g_pszServerPid,
            min(_tcslen((LPTSTR)g_pszServerPid), LSERVER_MAX_STRING_SIZE)
        );

    StringCchCopyN(
            LicPack.szTlsServerName,
            sizeof(LicPack.szTlsServerName)/sizeof(LicPack.szTlsServerName[0]),
            g_szComputerName,
            min(_tcslen(g_szComputerName), LSERVER_MAX_STRING_SIZE)
        );

    LicPack.wMajorVersion = HIWORD(pRequest->dwProductVersion);
    LicPack.wMinorVersion = LOWORD(pRequest->dwProductVersion);
    LicPack.dwPlatformType = pRequest->dwPlatformID;

    LicPack.ucChannelOfPurchase = LSKEYPACKCHANNELOFPURCHASE_UNKNOWN;
    LicPack.dwTotalLicenseInKeyPack = INT_MAX;

    LoadResourceString( 
                IDS_TEMPORARY_KEYPACKID,
                LicPack.szKeyPackId,
                sizeof(LicPack.szKeyPackId)/sizeof(LicPack.szKeyPackId[0])
            );

    LoadResourceString( 
                IDS_TEMPORARY_BSERIALNUMBER,
                LicPack.szBeginSerialNumber,
                sizeof(LicPack.szBeginSerialNumber)/sizeof(LicPack.szBeginSerialNumber[0])
            );

    do {
        //
        // Add entry into keypack table.
        //
        dwStatus = TLSDBKeyPackAdd(
                                pDbWkSpace, 
                                &LicPack
                            );
        *lpTmpKeyPackAdd = LicPack;

        LicPack.pbDomainSid = NULL;
        LicPack.cbDomainSid = 0;

        if(dwStatus == TLS_E_DUPLICATE_RECORD)
        {
            //
            // temporary keypack already exist
            //
            dwStatus = ERROR_SUCCESS;
            break;
        }
        else if(dwStatus != ERROR_SUCCESS)
        {
            //
            // some other error occurred
            //
            break;
        }

        //
        // Activate KeyPack
        // 
        LicPack.ucKeyPackStatus = LSKEYPACKSTATUS_TEMPORARY;
        LicPack.dwActivateDate = (DWORD) time(NULL);
        LicPack.dwExpirationDate = INT_MAX;
        LicPack.dwNumberOfLicenses = 0;

        dwStatus=TLSDBKeyPackSetValues(
                            pDbWkSpace,
                            FALSE,
                            LSKEYPACK_SET_ACTIVATEDATE | LSKEYPACK_SET_KEYPACKSTATUS | 
                                LSKEYPACK_SET_EXPIREDATE | LSKEYPACK_EXSEARCH_AVAILABLE,
                            &LicPack
                        );

        bAddDefDescription = TRUE;

        //
        // Find existing keypack description
        //
        dwStatus = TLSDBKeyPackEnumBegin(
                                pDbWkSpace,
                                TRUE,
                                LSKEYPACK_SEARCH_PRODUCTID | LSKEYPACK_SEARCH_COMPANYNAME | LSKEYPACK_SEARCH_PLATFORMTYPE,
                                &LicPack
                            );

        if(dwStatus != ERROR_SUCCESS)
            break;

        do {
            dwStatus = TLSDBKeyPackEnumNext(    
                                    pDbWkSpace, 
                                    &existingLicPack
                                );

            if(existingLicPack.dwKeyPackId != LicPack.dwKeyPackId)
            {
                break;
            }

        } while(dwStatus == ERROR_SUCCESS);

        TLSDBKeyPackEnumEnd(pDbWkSpace);

        if(dwStatus != ERROR_SUCCESS || existingLicPack.dwKeyPackId != LicPack.dwKeyPackId)
        {   
            break;
        }

        //
        // Copy existing keypack description into keypack description table
        //
        existingLicPackDesc.dwKeyPackId = existingLicPack.dwKeyPackId;
        dwStatus = TLSDBKeyPackDescEnumBegin(
                                    pDbWkSpace,
                                    TRUE, 
                                    LICPACKDESCRECORD_TABLE_SEARCH_KEYPACKID, 
                                    &existingLicPackDesc
                                );
        while(dwStatus == ERROR_SUCCESS)
        {
            dwStatus = TLSDBKeyPackDescEnumNext(
                                        pDbWkSpace, 
                                        &existingLicPackDesc
                                    );
            if(dwStatus != ERROR_SUCCESS)
                break;

            LicPackDesc.dwKeyPackId = LicPack.dwKeyPackId;
            LicPackDesc.dwLanguageId = existingLicPackDesc.dwLanguageId;
            _tcscpy(LicPackDesc.szCompanyName, existingLicPackDesc.szCompanyName);
            _tcscpy(LicPackDesc.szProductName, existingLicPackDesc.szProductName);

            //
            // pretty format the description
            //
            _sntprintf(
                    LicPackDesc.szProductDesc, 
                    sizeof(LicPackDesc.szProductDesc)/sizeof(LicPackDesc.szProductDesc[0])-1,
                    _TEXT("%s %s"), 
                    (existingLicPackDesc.dwLanguageId != GetSystemDefaultLangID()) ? USSTRING_TEMPORARY : szDefProductDesc, 
                    existingLicPackDesc.szProductDesc
                );

            // quick and dirty fix,
            //
            // TODO - need to do a duplicate table then use the duplicate handle to 
            // insert the record, SetValue uses enumeration to verify if record exist 
            // which fail because we are already in enumeration
            //
            if(pDbWkSpace->m_LicPackDescTable.InsertRecord(LicPackDesc) != TRUE)
            {
                SetLastError(dwStatus = SET_JB_ERROR(pDbWkSpace->m_LicPackDescTable.GetLastJetError()));
                break;
            }
                                        
            //dwStatus = TLSDBKeyPackDescSetValue(
            //                            pDbWkSpace,
            //                            KEYPACKDESC_SET_ADD_ENTRY, 
            //                            &keyPackDesc
            //                        );
            count++;
        }

        if(count != 0)
        {
            bAddDefDescription = FALSE;
        }

        if(dwStatus == TLS_I_NO_MORE_DATA)
        {
            dwStatus = ERROR_SUCCESS;
        }
    } while(FALSE);


    if(bAddDefDescription)
    {
        //
        // ask policy module if they have description
        //
        PMKEYPACKDESCREQ kpDescReq;
        PPMKEYPACKDESC pKpDesc;

        //
        // Ask for English description
        //
        kpDescReq.pszProductId = pRequest->pszProductId;
        kpDescReq.dwLangId = MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US);
        kpDescReq.dwVersion = pRequest->dwProductVersion;
        pKpDesc = NULL;

        dwStatus = pRequest->pPolicy->PMLicenseRequest(
                                                pRequest->hClient,
                                                REQUEST_KEYPACKDESC,
                                                (PVOID)&kpDescReq,
                                                (PVOID *)&pKpDesc
                                            );

        if(dwStatus == ERROR_SUCCESS && pKpDesc != NULL)
        {
            LicPackDesc.dwKeyPackId = LicPack.dwKeyPackId;
            LicPackDesc.dwLanguageId = MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US);
            _tcscpy(LicPackDesc.szCompanyName, pKpDesc->szCompanyName);
            _tcscpy(LicPackDesc.szProductName, pKpDesc->szProductName);

            //
            // pretty format the description
            //
            _sntprintf(
                    LicPackDesc.szProductDesc, 
                    sizeof(LicPackDesc.szProductDesc)/sizeof(LicPackDesc.szProductDesc[0])-1,
                    _TEXT("%s %s"), 
                    USSTRING_TEMPORARY, // US langid, don't use localized one
                    pKpDesc->szProductDesc
                );

            //
            // Ignore error
            //
            dwStatus = TLSDBKeyPackDescAddEntry(
                                pDbWkSpace, 
                                &LicPackDesc
                            );

            if(dwStatus == ERROR_SUCCESS)
            {
                bAddDefDescription = FALSE;
            }
        }

        if(GetSystemDefaultLangID() != kpDescReq.dwLangId)
        {
            //
            // Get System default language id
            //
            kpDescReq.pszProductId = pRequest->pszProductId;
            kpDescReq.dwLangId = GetSystemDefaultLangID();
            kpDescReq.dwVersion = pRequest->dwProductVersion;
            pKpDesc = NULL;

            dwStatus = pRequest->pPolicy->PMLicenseRequest(
                                                    pRequest->hClient,
                                                    REQUEST_KEYPACKDESC,
                                                    (PVOID)&kpDescReq,
                                                    (PVOID *)&pKpDesc
                                                );

            if(dwStatus == ERROR_SUCCESS && pKpDesc != NULL)
            {
                LicPackDesc.dwKeyPackId = LicPack.dwKeyPackId;
                LicPackDesc.dwLanguageId = GetSystemDefaultLangID();
                _tcscpy(LicPackDesc.szCompanyName, pKpDesc->szCompanyName);
                _tcscpy(LicPackDesc.szProductName, pKpDesc->szProductName);

                //
                // pretty format the description
                //
                _sntprintf(
                        LicPackDesc.szProductDesc, 
                        sizeof(LicPackDesc.szProductDesc)/sizeof(LicPackDesc.szProductDesc[0])-1,
                        _TEXT("%s %s"), 
                        szDefProductDesc, 
                        pKpDesc->szProductDesc
                    );

                //
                // Ignore error
                //
                dwStatus = TLSDBKeyPackDescAddEntry(
                                    pDbWkSpace, 
                                    &LicPackDesc
                                );

                if(dwStatus == ERROR_SUCCESS)
                {
                    bAddDefDescription = FALSE;
                }
            }
        }
    }
     
    if(bAddDefDescription)
    {
        //
        // No existing keypack description, add predefined product description
        // "temporary license for <product ID>"
        //
        LicPackDesc.dwKeyPackId = LicPack.dwKeyPackId;
        _tcscpy(LicPackDesc.szCompanyName, LicPack.szCompanyName);
        _tcscpy(LicPackDesc.szProductName, LicPackDesc.szProductDesc);
        LicPackDesc.dwLanguageId = MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US);

        _sntprintf(LicPackDesc.szProductDesc, 
                   sizeof(LicPackDesc.szProductDesc)/sizeof(LicPackDesc.szProductDesc[0])-1,
                   _TEXT("%s %s"), 
                   USSTRING_TEMPORARY, 
                   pRequest->pszProductId);

        dwStatus = TLSDBKeyPackDescAddEntry(
                                        pDbWkSpace, 
                                        &LicPackDesc
                                    );

        if(GetSystemDefaultLangID() != MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US))
        {
            LicPackDesc.dwLanguageId = GetSystemDefaultLangID();
            _sntprintf(LicPackDesc.szProductDesc, 
                       sizeof(LicPackDesc.szProductDesc)/sizeof(LicPackDesc.szProductDesc[0])-1,
                       _TEXT("%s %s"), 
                       szDefProductDesc, 
                       pRequest->pszProductId);

            dwStatus = TLSDBKeyPackDescAddEntry(
                                            pDbWkSpace, 
                                            &LicPackDesc
                                        );
        }
    }                            

    return dwStatus;
}

                         
//++----------------------------------------------------------
DWORD
TLSDBGetTemporaryLicense(
    IN PTLSDbWorkSpace pDbWkSpace,
    IN PTLSDBLICENSEREQUEST pRequest,
    IN OUT PTLSLICENSEPACK pLicensePack
    )
/*++

Abstract:

    Allocate a temporary license from temporary license pack.

Parameter:

    pDbWkSpace : workspace handle.
    pRequest : Product to request license from.
    lpdwKeyPackId : return keypack ID that license is allocated from.
    lpdwKeyPackLicenseId : license ID for the keypack.
    lpdwExpirationDate : expiration date of license pack.
    lpucKeyPackStatus : status of keypack.
    lpucKeyPackType : type of keypack, always temporary.

Returns:

++*/
{
    DWORD dwStatus=ERROR_SUCCESS;

    DWORD dump;
    TLSLICENSEPACK LicenseKeyPack;
    TLSDBLicenseAllocation allocated;
    TLSDBAllocateRequest AllocateRequest;
    BOOL bAcceptTemp=TRUE;

    LicenseKeyPack.pbDomainSid = NULL;

    //
    // Tell policy module we are about to allocate a license from temporary
    // license pack
    //
    dwStatus = pRequest->pPolicy->PMLicenseRequest(
                                            pRequest->hClient,
                                            REQUEST_TEMPORARY,
                                            NULL,
                                            (PVOID *)&bAcceptTemp
                                        );

    //
    // Policy Module error
    //
    if(dwStatus != ERROR_SUCCESS)
    {
        return dwStatus; 
    }

    //
    // Policy module does not accept temporary license
    //
    if(bAcceptTemp == FALSE)
    {
        return dwStatus = TLS_I_POLICYMODULETEMPORARYLICENSE;
    }

    AllocateRequest.ucAgreementType = LSKEYPACKTYPE_TEMPORARY;
    AllocateRequest.szCompanyName = (LPTSTR)pRequest->pszCompanyName;
    AllocateRequest.szProductId = (LPTSTR)pRequest->pszProductId;
    AllocateRequest.dwVersion = pRequest->dwProductVersion;
    AllocateRequest.dwPlatformId = pRequest->dwPlatformID;
    AllocateRequest.dwLangId = pRequest->dwLanguageID;
    AllocateRequest.dwNumLicenses = 1;
    AllocateRequest.dwScheme = ALLOCATE_ANY_GREATER_VERSION;
    memset(&allocated, 0, sizeof(allocated));

    allocated.dwBufSize = 1;
    allocated.pdwAllocationVector = &dump;
    allocated.lpAllocateKeyPack = &LicenseKeyPack;

    dwStatus = TLSDBAddTemporaryKeyPack(
                            pDbWkSpace,
                            pRequest,
                            &LicenseKeyPack
                        );

    if(dwStatus == ERROR_SUCCESS)
    {
        allocated.dwBufSize = 1;
        dwStatus = AllocateLicensesFromDB(
                                pDbWkSpace,
                                &AllocateRequest,
                                TRUE,   // fCheckAgreementType
                                &allocated
                            );
    }

    if(dwStatus == ERROR_SUCCESS)
    {
        *pLicensePack = LicenseKeyPack;
    } 
    else if(dwStatus == TLS_I_NO_MORE_DATA)
    {
        SetLastError(dwStatus = TLS_E_INTERNAL);
    }

    return dwStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\license\tlserver\server\rpc.cpp ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996-1996
//
// File:        rpc.c
//
// Contents:    Various RPC function to accept client request
//
// History:     12-09-98    HueiWang    Created
//              05-26-98    HueiWang    Move all code to TLSRpcXXX
//                                      API here is only for compatible with
//                                      NT40 Hydra
//---------------------------------------------------------------------------
#include "pch.cpp"
#include "globals.h"
#include "server.h"
#include "init.h"

//+------------------------------------------------------------------------
error_status_t 
LSGetRevokeKeyPackList( 
    /* [in] */ PCONTEXT_HANDLE phContext,
    /* [out][in] */ PDWORD pcbNumberOfKeyPack,
    /* [size_is][out][in] */ PDWORD pRevokeKeyPackList
    )
/*

Note : For backward compatible with NT40 Hydra only

*/
{
    *pcbNumberOfKeyPack=0;
    return ERROR_SUCCESS;
}

//+------------------------------------------------------------------------
error_status_t 
LSGetRevokeLicenseList( 
    /* [in] */ PCONTEXT_HANDLE phContext,
    /* [out][in] */ PDWORD pcbNumberOfLicenses,
    /* [size_is][out][in] */ PDWORD pRevokeLicenseList
    )
/*

Note : For backward compatible with NT40 Hydra only

*/
{
    *pcbNumberOfLicenses=0;
    return ERROR_SUCCESS;
}

//+------------------------------------------------------------------------
error_status_t 
LSValidateLicense(  
    /* [in] */ PCONTEXT_HANDLE phContext,
    /* [in] */ DWORD cbLicense,
    /* [size_is][in] */ BYTE __RPC_FAR *pbLicense
    )
/*

Note : For backward compatible with NT40 Hydra only

*/
{
    RpcRaiseException(RPC_S_CANNOT_SUPPORT);    // doesn't return

    return RPC_S_CANNOT_SUPPORT;
}


//+------------------------------------------------------------------------
error_status_t
LSConnect( 
    /* [in] */ handle_t hRpcBinding, 
    /* [out] */ PCONTEXT_HANDLE __RPC_FAR *pphContext
    )
{
    return TLSRpcConnect( hRpcBinding, pphContext );
}

//-----------------------------------------------------------------------
error_status_t 
LSSendServerCertificate( 
    /* [in] */ PCONTEXT_HANDLE phContext,
    /* [in] */ DWORD cbCert,
    /* [size_is][in] */ PBYTE pbCert
    )
{
    DWORD status = ERROR_SUCCESS;

    TLSRpcSendServerCertificate( 
                        phContext, 
                        cbCert, 
                        pbCert, 
                        &status 
                    );
    return status;
}

//+------------------------------------------------------------------------

error_status_t
LSDisconnect( 
    /* [out][in] */ PPCONTEXT_HANDLE pphContext
    )
{
    return TLSRpcDisconnect(pphContext);
}

//+------------------------------------------------------------------------

error_status_t 
LSGetServerName(
    /* [in] */ PCONTEXT_HANDLE phContext,
    /* [size_is][string][out][in] */ LPTSTR szMachineName,
    /* [out][in] */ PDWORD pcbSize
    )
/*

Description :

    Return Server's Machine Name.

Arguments:
    
    phContext - client context handle.
    szMachineName - Pointer to a buffer that receives a null-terminated 
                    string containing the computer name. The buffer size 
                    should be large enough to contain 
                    MAX_COMPUTERNAME_LENGTH + 1 characters. 
    cbSize - Pointer to a DWORD variable. On input, the variable 
             specifies the size, in bytes or characters, of the buffer. 
             On output, the variable returns the number of bytes or characters 
             copied to the destination buffer, not including the terminating 
             null character. 

Returns:

    LSERVER_S_SUCCESS    

*/
{
    DWORD dwErrCode=ERROR_SUCCESS;

    TLSRpcGetServerName(
                phContext, 
                szMachineName, 
                pcbSize, 
                &dwErrCode
            );

    return dwErrCode;
}

//+------------------------------------------------------------------------

error_status_t 
LSGetServerScope( 
    /* [in] */ PCONTEXT_HANDLE phContext,
    /* [size_is][string][out][in] */ LPTSTR szScopeName,
    /* [out][in] */ PDWORD pcbSize
    )
/*

Description:
    Return License Server's scope

Arguments:
    IN phContext - Client context
    IN OUT szScopeName - return server's scope, must be at least 
                         MAX_COMPUTERNAME_LENGTH in length

Return Value:  
    LSERVER_S_SUCCESS or error code from WideCharToMultiByte()

*/
{
    DWORD status=ERROR_SUCCESS;

    TLSRpcGetServerScope(
                phContext, 
                szScopeName, 
                pcbSize,
                &status
            );

    return status;
}

//+------------------------------------------------------------------------

error_status_t
LSGetInfo(
    /* [in] */ PCONTEXT_HANDLE phContext,
    /* [in] */ DWORD cbHSCert,
    /* [size_is][ref][in] */ PBYTE pHSCert,
    /* [ref][out] */ PDWORD pcbLSCert,
    /* [size_is][size_is][out] */ BYTE __RPC_FAR *__RPC_FAR *pLSCert,
    /* [ref][out] */ PDWORD pcbLSSecretKey,
    /* [size_is][size_is][out] */ BYTE __RPC_FAR *__RPC_FAR *pLSSecretKey
    )
/*
Description:
    Routine to exchange Hydra server's certificate and License server's
    certificate/private key for signing client machine's hardware ID.

Arguments:
    IN phContext - client context handle
    IN cbHSCert - size of Hydra Server's certificate
    IN pHSCert - Hydra Server's certificate
    IN OUT pcbLSCert - return size of License Server's certificate
    OUT pLSCert - return License Server's certificate
    OUT pcbLSSecretKey - return size of License Server's private key.
    OUT pLSSecretKey - retrun License Server's private key

Return Value:  
    LSERVER_S_SUCCESS           success
    LSERVER_E_INVALID_DATA      Invalid hydra server certificate
    LSERVER_E_OUTOFMEMORY       Can't allocate required memory
    TLS_E_INTERNAL              Internal error occurred in License Server
*/
{
    return TLSMapReturnCode(TLS_E_NOTSUPPORTED);;
}

//+------------------------------------------------------------------------

error_status_t
LSGetLastError(
    /* [in] */ PCONTEXT_HANDLE phContext,
    /* [in] */ DWORD cbBufferSize,
    /* [string][out][in] */ LPTSTR szBuffer
    )
/*

Description:
    Return error description text for client's last LSXXX call

Arguments:
    IN phContext - Client context
    IN cbBufferSize - max. size of szBuffer
    IN OUT szBuffer - Pointer to a buffer to receive the 
                      null-terminated character string containing 
                      error description

Note:
    Return ANSI error string.

Returns:
    LSERVER_S_SUCCESS
    TLS_E_INTERNAL     No error or can't find corresponding error
                       description.
    Error code from WideCharToMultiByte().

*/
{
    DWORD status;

    TLSRpcGetLastError(
                phContext, 
                &cbBufferSize, 
                szBuffer, 
                &status
            );
    return status;
}

//+------------------------------------------------------------------------

error_status_t 
LSIssuePlatformChallenge(  
    /* [in] */ PCONTEXT_HANDLE phContext,
    /* [in] */ DWORD dwClientInfo,
    /* [ref][out] */ PCHALLENGE_CONTEXT pChallengeContext,
    /* [out] */ PDWORD pcbChallengeData,
    /* [size_is][size_is][out] */ BYTE __RPC_FAR *__RPC_FAR *pChallengeData
    )
/*

Description:
    Issue a platform challenge to hydra client.

Arguments:
    IN phContext - client context handle
    IN dwClientInfo - client info.
    OUT pChallengeContext - pointer to client challenge context.
    OUT pcbChallengeData - size of challenge data.
    OUT pChallengeData - random client challenge data.

Returns:
    LSERVER_S_SUCCESS
    LSERVER_E_OUTOFMEMORY
    LSERVER_E_INVALID_DATA      Invalid client info.
    LSERVER_E_SERVER_BUSY

*/
{
    DWORD status=ERROR_SUCCESS;

    TLSRpcIssuePlatformChallenge(
                    phContext, 
                    dwClientInfo, 
                    pChallengeContext, 
                    pcbChallengeData, 
                    pChallengeData, 
                    &status
                );

    return status;
}

//+------------------------------------------------------------------------

error_status_t 
LSAllocateConcurrentLicense( 
    /* [in] */ PCONTEXT_HANDLE phContext,
    /* [string][in] */ LPTSTR szHydraServer,
    /* [in] */ LICENSE_REQUEST_TYPE __RPC_FAR *pRequest,
    /* [ref][out][in] */ LONG __RPC_FAR *dwQuantity
    )
/*

Description:
    Allocate concurrent licenses base on product.

Arguments:
    IN phContext - client context handle
    IN szHydraServer - name of hydra server requesting concurrent licenses
    IN pRequest - product to request for concurrent license.
    IN OUT dwQuantity - See note

Return Value:
    LSERVER_S_SUCCESS
    LSERVER_E_INVALID_DATA      Invalid parameter.
    LSERVER_E_NO_PRODUCT        request product not installed
    LSERVER_E_NO_LICNESE        no available license for request product 
    LSERVER_E_LICENSE_REVOKED   Request license has been revoked
    LSERVER_E_LICENSE_EXPIRED   Request license has expired
    LSERVER_E_CORRUPT_DATABASE  Corrupt database
    LSERVER_E_INTERNAL_ERROR    Internal error in license server

Note:
    dwQuantity
    Input                       Output
    -------------------------   -----------------------------------------
    0                           Total number of concurrent license 
                                issued to hydra server.
    > 0, number of license      Actual number of license allocated
         requested
    < 0, number of license      Actual number of license returned, always
         to return              positive value.

*/
{
    RpcRaiseException(RPC_S_CANNOT_SUPPORT);    // doesn't return

    return RPC_S_CANNOT_SUPPORT;
}


//+------------------------------------------------------------------------

error_status_t
LSIssueNewLicense(  
    /* [in] */ PCONTEXT_HANDLE phContext,
    /* [in] */ CHALLENGE_CONTEXT ChallengeContext,
    /* [in] */ LICENSE_REQUEST_TYPE __RPC_FAR *pRequest_org,
    /* [string][in] */ LPTSTR szMachineName,
    /* [string][in] */ LPTSTR szUserName,
    /* [in] */ DWORD cbChallengeResponse,
    /* [size_is][in] */ PBYTE cbChallenge,
    /* [in] */ BOOL bAcceptTemporaryLicense,
    /* [out] */ PDWORD pcbLicense,
    /* [size_is][size_is][out] */ BYTE __RPC_FAR *__RPC_FAR *ppLicense
    )
/*

Description:
    Routine to issue new license to hydra client based on product requested, 
    it returns existing license if client already has a license and the 
    license is not expired/returned/revoked, if request product has not been 
    installed, it will issue a temporary license, if license found is temporary 
    or expired, it will tried to upgrade/re-issue a new license with latest 
    version of requested product, if the existing license is temporary and 
    no license can be issued, it returns LSERVER_E_LICENSE_EXPIRED


Arguments:
    IN phContext - client context handle.
    IN ChallengeContext - client challenge context handle, return from 
                          call LSIssuePlatformChallenge()
    IN cbChallengeResponse - size of the client's response to license server's
                             platform challenge.
    IN pbChallenge - client's response to license server's platform challenge
    OUT pcbLicense - size of return license.
    OUT ppLicense - return license, could be old license

Return Value:
    LSERVER_S_SUCCESS
    LSERVER_E_OUTOFMEMORY
    LSERVER_E_SERVER_BUSY       Server is busy to process request.
    LSERVER_E_INVALID_DATA      Invalid platform challenge response.
    LSERVER_E_NO_LICENSE        No license available.
    LSERVER_E_NO_PRODUCT        Request product is not installed on server.
    LSERVER_E_LICENSE_REJECTED  License request is rejected by cert. server
    LSERVER_E_LICENSE_REVOKED   Old license found and has been revoked
    LSERVER_E_LICENSE_EXPIRED   Request product's license has expired
    LSERVER_E_CORRUPT_DATABASE  Corrupted database.
    LSERVER_E_INTERNAL_ERROR    Internal error in license server
    LSERVER_I_PROXIMATE_LICENSE Closest match license returned.
    LSERVER_I_TEMPORARY_LICENSE Temporary license has been issued
    LSERVER_I_LICENSE_UPGRADED  Old license has been upgraded.

*/
{
    DWORD status=ERROR_SUCCESS;
    TLSLICENSEREQUEST RpcRequest;
    RequestToTlsRequest(pRequest_org, &RpcRequest);
    
    TLSRpcRequestNewLicense(
                    phContext,
                    ChallengeContext,
                    &RpcRequest,
                    szMachineName,
                    szUserName,
                    cbChallengeResponse,
                    cbChallenge,
                    bAcceptTemporaryLicense,
                    pcbLicense,
                    ppLicense,
                    &status
                );

    return status;
}

//+------------------------------------------------------------------------

error_status_t 
LSUpgradeLicense(
    /* [in] */ PCONTEXT_HANDLE phContext,
    /* [in] */ DWORD cbOldLicense,
    /* [size_is][in] */ PBYTE pbOldLicense,
    /* [in] */ DWORD dwClientInfo,
    /* [out] */ PDWORD pcbNewLicense,
    /* [size_is][size_is][out] */ PBYTE __RPC_FAR *ppbNewLicense
    )
/*

Description:

    Update an old license.

Arguments:

    IN phContext - client context handle.
    IN cbOldLicense - size of license to be upgraded.
    IN pOldLicense - license to be upgrade.
    OUT pcbNewLicense - size of upgraded license
    OUT pNewLicense - upgraded license.

Return Value:  

    LSERVER_S_SUCCESS
    TLS_E_INTERNAL
    LSERVER_E_INTERNAL_ERROR
    LSERVER_E_INVALID_DATA      old license is invalid.
    LSERVER_E_NO_LICENSE        no available license
    LSERVER_E_NO_PRODUCT        request product not install in current server.
    LSERVER_E_CORRUPT_DATABASE  Corrupted database.
    LSERVER_E_LICENSE_REJECTED  License request rejected by cert. server.
    LSERVER_E_SERVER_BUSY

Note:

    Unused - just return error

*/
{
    RpcRaiseException(RPC_S_CANNOT_SUPPORT);    // doesn't return

    return RPC_S_CANNOT_SUPPORT;
}

//+------------------------------------------------------------------------

error_status_t 
LSKeyPackEnumBegin( 
    /* [in] */ PCONTEXT_HANDLE phContext,
    /* [in] */ DWORD dwSearchParm,
    /* [in] */ BOOL bMatchAll,
    /* [ref][in] */ LPLSKeyPackSearchParm lpSearchParm
    )
/*

Description:

      Function to begin enumerate through all key pack installed on server
      based on search criterial.

Arguments:
    IN phContext - client context handle.
    IN dwSearchParm - search criterial.
    IN bMatchAll - match all search criterial.
    IN lpSearchParm - search parameter.

Return Value:  
    LSERVER_S_SUCCESS
    LSERVER_E_SERVER_BUSY       Server is too busy to process request
    LSERVER_E_OUTOFMEMORY
    TLS_E_INTERNAL
    LSERVER_E_INTERNAL_ERROR    
    LSERVER_E_INVALID_DATA      Invalid data in search parameter
    LSERVER_E_INVALID_SEQUENCE  Invalid calling sequence, likely, previous
                                enumeration has not ended.

*/
{
    DWORD status=ERROR_SUCCESS;

    TLSRpcKeyPackEnumBegin(
                phContext,
                dwSearchParm,
                bMatchAll,
                lpSearchParm,
                &status
            );

    return status;
}

//+------------------------------------------------------------------------

DWORD 
LSKeyPackEnumNext(  
    /* [in] */ PCONTEXT_HANDLE phContext,
    /* [ref][out] */ LPLSKeyPack lpKeyPack
    )
/*
Description:

    Return next key pack that match search criterial

Arguments:

    IN phContext - client context handle
    OUT lpKeyPack - key pack that match search criterial

Return Value:  
    LSERVER_S_SUCCESS
    LSERVER_I_NO_MORE_DATA      No more keypack match search criterial
    TLS_E_INTERNAL     General error in license server
    LSERVER_E_INTERNAL_ERROR    Internal error in license server
    LSERVER_E_SERVER_BUSY       License server is too busy to process request
    LSERVER_E_OUTOFMEMORY       Can't process request due to insufficient memory
    LSERVER_E_INVALID_SEQUENCE  Invalid calling sequence, must call
                                LSKeyPackEnumBegin().
*/
{
    DWORD status=ERROR_SUCCESS;

    TLSRpcKeyPackEnumNext(
                    phContext, 
                    lpKeyPack, 
                    &status
                );
    return status;
}

//+------------------------------------------------------------------------

error_status_t
LSKeyPackEnumEnd( 
    /* [in] */ PCONTEXT_HANDLE phContext 
    )
/*
Description:

    Routine to end an enumeration on key pack.

Arguments:

    IN phContext - client context handle.

Return Value:  
    LSERVER_S_SUCCESS
    LSERVER_E_INTERNAL_ERROR    Internal error occurred in license server
    TLS_E_INTERNAL              General error occurred in license server
    LSERVER_E_INVALID_HANDLE    Has not call LSKeyPackEnumBegin()
*/
{
    DWORD status=ERROR_SUCCESS;

    TLSRpcKeyPackEnumEnd(phContext, &status);
    return status;
}

//+------------------------------------------------------------------------

error_status_t
LSKeyPackAdd( 
    /* [in] */ PCONTEXT_HANDLE phContext,
    /* [ref][out][in] */ LPLSKeyPack lpKeypack
    )
/*
Description:

    Add a license key pack.

Arguments:

    IN phContext - client context handle.
    IN OUT lpKeyPack - key pack to be added.

Return Value:  

    LSERVER_S_SUCCESS
    LSERVER_E_INTERNAL_ERROR
    TLS_E_INTERNAL
    LSERVER_E_SERVER_BUSY
    LSERVER_E_DUPLICATE             Product already installed.
    LSERVER_E_INVALID_DATA
    LSERVER_E_CORRUPT_DATABASE

Note:

    Just return an error - unused
*/
{
    RpcRaiseException(RPC_S_CANNOT_SUPPORT);    // doesn't return

    return RPC_S_CANNOT_SUPPORT;
}

//+------------------------------------------------------------------------

error_status_t
LSKeyPackSetStatus( 
    /* [in] */ PCONTEXT_HANDLE phContext,
    /* [in] */ DWORD dwSetParam,
    /* [ref][in] */ LPLSKeyPack lpKeyPack
    )
/*
Description:

    Routine to activate/deactivated a key pack.
  
Arguments:

    IN phContext - client context handle
    IN dwSetParam - type of key pack status to be set.
    IN lpKeyPack - new key pack status.

Return Value:  

    LSERVER_S_SUCCESS
    LSERVER_E_INTERNAL_ERROR
    TLS_E_INTERNAL
    LSERVER_E_INVALID_DATA     
    LSERVER_E_SERVER_BUSY
    LSERVER_E_DATANOTFOUND      Key pack is not in server
    LSERVER_E_CORRUPT_DATABASE
*/
{
#if !defined(ENFORCE_LICENSING) || defined(PRIVATE_DBG)

    DWORD status=ERROR_SUCCESS;

    TLSRpcKeyPackSetStatus(
                    phContext, 
                    dwSetParam, 
                    lpKeyPack, 
                    &status
                );
    return status;

#else

    return TLSMapReturnCode(TLS_E_NOTSUPPORTED);

#endif
}


//+------------------------------------------------------------------------

error_status_t
LSLicenseEnumBegin( 
    /* [in] */ PCONTEXT_HANDLE phContext,
    /* [in] */ DWORD dwSearchParm,
    /* [in] */ BOOL bMatchAll,
    /* [ref][in] */ LPLSLicenseSearchParm lpSearchParm
    )
/*
Description:

    Begin enumeration of license issued based on search criterial

Arguments:

    IN phContext - client context handle
    IN dwSearchParm - license search criterial.
    IN bMatchAll - match all search criterial
    IN lpSearchParm - license(s) to be enumerated.

Return Value:  

    Same as LSKeyPackEnumBegin().
*/
{
    DWORD status=ERROR_SUCCESS;

    TLSRpcLicenseEnumBegin(
                    phContext,
                    dwSearchParm,
                    bMatchAll,
                    lpSearchParm,
                    &status
                );
    
    return status;
}

//+------------------------------------------------------------------------

error_status_t
LSLicenseEnumNext(  
    /* [in] */ PCONTEXT_HANDLE phContext,
    /* [ref][out] */ LPLSLicense lpLicense
    )
/*

Description:

Arguments:

    IN phContext - client context handle
    OUT lpLicense - license match search criterial.

Return Value:  

    Same as LSKeyPackEnumNext().

*/
{
    DWORD status=ERROR_SUCCESS;

    TLSRpcLicenseEnumNext(phContext, lpLicense, &status);
    return status;
}

//+------------------------------------------------------------------------

error_status_t
LSLicenseEnumEnd( 
    /* [in] */ PCONTEXT_HANDLE phContext 
    )
/*
Description:

    End enumeration of issued licenses.

Arguments:

    IN phContext - client context handle.

Return Value:  

    Same as LSKeyPackEnumEnd().
*/
{
    DWORD status=ERROR_SUCCESS;

    TLSRpcLicenseEnumEnd(phContext, &status);
    return status;
}

//+------------------------------------------------------------------------

error_status_t
LSLicenseSetStatus( 
    /* [in] */ PCONTEXT_HANDLE phContext,
    /* [in] */ DWORD dwSetParam,
    /* [in] */ LPLSLicense lpLicense
    )
/*
Description:

    Routine to set status of a issued license.

Arguments:

    IN phContext - client context handle.
    IN dwSetParam - 
    IN lpLicense -

Return Value:  

    Unused - just returns an error
*/
{
    RpcRaiseException(RPC_S_CANNOT_SUPPORT);    // doesn't return

    return RPC_S_CANNOT_SUPPORT;
}

//+------------------------------------------------------------------------

error_status_t
LSLicenseGetCert( 
    /* [in] */ PCONTEXT_HANDLE phContext,
    /* [ref][in] */ LPLSLicense lpLicense,
    /* [out] */ LPDWORD cbCert,
    /* [size_is][size_is][out] */ PBYTE __RPC_FAR *pbCert
    )
/*
Description:

    Retrieve actual certificate issued to client.

Arguments:

    IN phContext - client context handle
    IN lpLicense - 
    OUT cbCert - size of certificate.
    OUT pbCert - actual certificate.

Return Value:  

    LSERVER_S_SUCCESS
    LSERVER_E_INTERNAL_ERROR
    TLS_E_INTERNAL
    LSERVER_E_INVALID_DATA
    LSERVER_E_DATANOTFOUND
    LSERVER_E_CORRUPT_DATABASE
*/
{
    return LSERVER_S_SUCCESS;
}

//+------------------------------------------------------------------------

error_status_t
LSGetAvailableLicenses( 
    /* [in] */ PCONTEXT_HANDLE phContext,
    /* [in] */ DWORD dwSearchParm,
    /* [ref][in] */ LPLSKeyPack lplsKeyPack,
    /* [ref][out] */ LPDWORD lpdwAvail
    )
/*
Description:

    Retrieve number of available license for a product.

Arguments:

    IN phContext - client context.
    IN dwSearchParm - 
    IN lplsKeyPack -
    OUT lpdwAvail -

Return Value:  

    LSERVER_S_SUCCESS
    LSERVER_E_INTERNAL_ERROR
    TLS_E_INTERNAL
    LSERVER_E_DATANOTFOUND
    LSERVER_E_INVALID_DATA
    LSERVER_E_CORRUPT_DATABASE
*/
{
    DWORD status=ERROR_SUCCESS;

    TLSRpcGetAvailableLicenses(
                    phContext,
                    dwSearchParm,
                    lplsKeyPack,
                    lpdwAvail,
                    &status
                );

    return status;
}

//+------------------------------------------------------------------------

error_status_t 
LSGetServerCertificate( 
    /* [in] */ PCONTEXT_HANDLE phContext,
    /* [in] */ BOOL bSignCert,
    /* [size_is][size_is][out] */ LPBYTE __RPC_FAR *ppCertBlob,
    /* [ref][out] */ LPDWORD lpdwCertBlobLen
    )
/*
Description:

    Get License Server's signature or exchange certificate

Arguments:

    IN phContext - client context.
    IN bSignCert - TRUE if signature certificate, FALSE if exchange certificate
    OUT ppCertBlob - pointer to pointer to receive certificate.
    OUT lpdwCertBlobLen - size of certificate returned.

Return Value:  

    LSERVER_S_SUCCESS
    LSERVER_E_ACCESS_DENIED     Client doesn't have required privilege
    LSERVER_E_NO_CERTIFICATE    License Server hasn't register yet.
*/
{
#if ENFORCE_LICENSING

    DWORD status=ERROR_SUCCESS;

    TLSRpcGetServerCertificate( 
                    phContext,
                    bSignCert,
                    ppCertBlob,
                    lpdwCertBlobLen,
                    &status
                );

    return status;

#else

    return TLSMapReturnCode(TLS_E_NOTSUPPORTED);

#endif
}


//+------------------------------------------------------------------------

error_status_t 
LSRegisterLicenseKeyPack(
    /* [in] */ PCONTEXT_HANDLE phContext,
    /* [size_is][in] */ LPBYTE pbCHCertBlob,
    /* [in] */ DWORD cbCHCertBlobSize,
    /* [size_is][in] */ LPBYTE pbRootCertBlob,
    /* [in] */ DWORD cbRootCertBlob,
    /* [size_is][in] */ LPBYTE lpKeyPackBlob,
    /* [in] */ DWORD dwKeyPackBlobLen
    )
/*
Description:

    Register (Add) a license key pack into License Server.

Arguments:

    IN phContext - client context.
    IN pbCHCertBlob - CH's certificate.
    IN cbCHCertBlobSize - CH certificate size.
    IN pbRootCertBlob - Root's certificate.
    IN cbRootCertBlob - Size of Root's certificate.
    IN lpKeyPackBlob - pointer to encrypted license KeyPack blob.
    IN dwKeyPackBlobLen - size of keypack blob.

Return Value:  

    LSERVER_S_SUCCESS
    LSERVER_E_ACCESS_DENIED     Client doesn't have required privilege
    LSERVER_E_NO_CERTIFICATE    License Server hasn't register yet.
    LSERVER_E_INVALID_DATA      Can't verify any of the certificate or 
                              can't decode license keypack blob.
    LSERVER_E_SERVER_BUSY       Server is busy.
    LSERVER_E_DUPLICATE         KeyPack already register
    LSERVER_E_ERROR_GENERAL     General ODBC error.
*/
{
#if ENFORCE_LICENSING

    DWORD status=ERROR_SUCCESS;

    TLSRpcRegisterLicenseKeyPack( 
                        phContext,
                        pbCHCertBlob,
                        cbCHCertBlobSize,
                        pbRootCertBlob,
                        cbRootCertBlob,
                        lpKeyPackBlob,
                        dwKeyPackBlobLen,
                        &status
                    );
    return status;
            
#else

    return TLSMapReturnCode(TLS_E_NOTSUPPORTED);

#endif
}

//+------------------------------------------------------------------------

error_status_t 
LSInstallCertificate( 
    /* [in] */ PCONTEXT_HANDLE phContext,
    /* [in] */ DWORD dwCertType,
    /* [in] */ DWORD dwCertLevel,
    /* [in] */ DWORD cbSignatureCert,
    /* [size_is][in] */ PBYTE pbSignatureCert,
    /* [in] */ DWORD cbExchangeCert,
    /* [size_is][in] */ PBYTE pbExchangeCert
    )
/*

Description:

    Install CH, CA, or License Server's certificate issued by CA into
    License Server.

Arguments:


RETURN:

    ACCESS_DENIED                       No privilege
    LSERVER_E_INVALID_DATA              Can't verify certificate
    LSERVER_E_DUPLICATE                 Certificate already installed
    LSERVER_I_CERTIFICATE_OVERWRITE     Overwrite certificate.

*/
{
#if ENFORCE_LICENSING

    DWORD status=ERROR_SUCCESS;

    TLSRpcInstallCertificate( 
                    phContext,
                    dwCertType,
                    dwCertLevel,
                    cbSignatureCert,
                    pbSignatureCert,
                    cbExchangeCert,
                    pbExchangeCert,
                    &status
                );

    return status;

#else

    return TLSMapReturnCode(TLS_E_NOTSUPPORTED);

#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\license\tlserver\server\srvlist.cpp ===
//+-----------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996-1996
//
// File:        srvlist.cpp
//
// Contents:    List of registed server
//
// History:     09-09-98    HueiWang    Created
//
//-------------------------------------------------------------
#include "pch.cpp"
#include "srvlist.h"
#include "globals.h"
#include "srvdef.h"
#define STRSAFE_NO_DEPRECATE
#include "strsafe.h"


CTLServerMgr g_ServerMgr;

///////////////////////////////////////////////////////////////

DWORD
GetPageSize( VOID ) {

    static DWORD dwPageSize = 0;

    if ( !dwPageSize ) {

      SYSTEM_INFO sysInfo = { 0 };
        
      GetSystemInfo( &sysInfo ); // cannot fail.

      dwPageSize = sysInfo.dwPageSize;

    }

    return dwPageSize;

}

/*++**************************************************************
  NAME:      MyVirtualAlloc

  as Malloc, but automatically protects the last page of the 
  allocation.  This simulates pageheap behavior without requiring
  it.

  MODIFIES:  ppvData -- receives memory

  TAKES:     dwSize  -- minimum amount of data to get

  RETURNS:   TRUE when the function succeeds.
             FALSE otherwise.
  LASTERROR: not set
  Free with MyVirtualFree

  
 **************************************************************--*/

BOOL
MyVirtualAlloc( IN  DWORD  dwSize,
            OUT PVOID *ppvData )
 {

    PBYTE pbData;
    DWORD dwTotalSize;
    PVOID pvLastPage;

    // ensure that we allocate one extra page

    dwTotalSize = dwSize / GetPageSize();
    if( dwSize % GetPageSize() ) {
        dwTotalSize ++;
    }

    // this is the guard page
    dwTotalSize++;
    dwTotalSize *= GetPageSize();

    // do the alloc

    pbData = (PBYTE) VirtualAlloc( NULL, // don't care where
                                   dwTotalSize,
                                   MEM_COMMIT |
                                   MEM_TOP_DOWN,
                                   PAGE_READWRITE );
    
    if ( pbData ) {

      pbData += dwTotalSize;

      // find the LAST page.

      pbData -= GetPageSize();

      pvLastPage = pbData;

      // now, carve out a chunk for the caller:

      pbData -= dwSize;

      // last, protect the last page:

      if ( VirtualProtect( pvLastPage,
                           1, // protect the page containing the last byte
                           PAGE_NOACCESS,
                           &dwSize ) ) {

        *ppvData = pbData;
        return TRUE;

      } 

      VirtualFree( pbData, 0, MEM_RELEASE );

    }

    return FALSE;

}


VOID
MyVirtualFree( IN PVOID pvData ) 
{

    VirtualFree( pvData, 0, MEM_RELEASE ); 

}

///////////////////////////////////////////////////////////////

RPC_STATUS
TryLookupServer(PCONTEXT_HANDLE hBinding,
                LPTSTR pszLookupSetupId,
                LPTSTR *pszLsSetupId,
                LPTSTR *pszDomainName,
                LPTSTR *pszLsName,
                PDWORD pdwErrCode)
{
    RPC_STATUS status;
    DWORD      dwErrCode;

    status = TLSLookupServerFixed(hBinding,
                                  pszLookupSetupId,
                                  pszLsSetupId,
                                  pszDomainName,
                                  pszLsName,
                                  pdwErrCode);

    if(status != RPC_S_OK)
    {

        LPTSTR     lpszSetupId = NULL;
        LPTSTR     lpszDomainName = NULL;
        LPTSTR     lpszServerName = NULL;
        status = ERROR_NOACCESS;

        size_t cbError;
        try
        {
            if ( !MyVirtualAlloc( (LSERVER_MAX_STRING_SIZE+2) * sizeof( TCHAR ),
                              (PVOID*) &lpszSetupId ) )
            {
                return RPC_S_OUT_OF_MEMORY;
            }

            memset(lpszSetupId, 0, ( LSERVER_MAX_STRING_SIZE +2 ) * sizeof( TCHAR ));

            if ( !MyVirtualAlloc( (LSERVER_MAX_STRING_SIZE+2) * sizeof( TCHAR ),
                              (PVOID*) &lpszDomainName ) )
            {
                status = RPC_S_OUT_OF_MEMORY;
                goto cleanup;
            }

            memset(lpszDomainName, 0, ( LSERVER_MAX_STRING_SIZE +2 ) * sizeof( TCHAR ));

            if ( !MyVirtualAlloc( (MAX_COMPUTERNAME_LENGTH+2) * sizeof( TCHAR ),
                              (PVOID*) &lpszServerName ) )
            {
                status = RPC_S_OUT_OF_MEMORY;
                goto cleanup;
            }

            memset(lpszServerName, 0, ( MAX_COMPUTERNAME_LENGTH +2 ) * sizeof( TCHAR ));


            DWORD cbSetupId = LSERVER_MAX_STRING_SIZE+1;
            DWORD cbDomainName = LSERVER_MAX_STRING_SIZE+1;        
            DWORD cbServerName = MAX_COMPUTERNAME_LENGTH+1;
        
            status = TLSLookupServer(hBinding,
                                     pszLookupSetupId, 
                                     lpszSetupId,   
                                     &cbSetupId,
                                     lpszDomainName,
                                     &cbDomainName,
                                     lpszServerName,
                                     &cbServerName,
                                     pdwErrCode);

            if((status == RPC_S_OK) && (pdwErrCode != NULL) && (*pdwErrCode == ERROR_SUCCESS))
            {
                if (NULL != pszLsSetupId)
                {
                    size_t cb;

                    if (SUCCEEDED(StringCbLength(lpszSetupId,cbSetupId,&cb)))
                    {
                        *pszLsSetupId = (LPTSTR) MIDL_user_allocate(cb+sizeof(TCHAR));
                    
                        if (NULL != *pszLsSetupId)
                        {
                            lstrcpy(*pszLsSetupId,lpszSetupId);
                        }
                        else
                        {
                            status = RPC_S_OUT_OF_MEMORY;
                            goto cleanup;
                        }
                    }
                    else
                    {
                        status = RPC_S_INVALID_ARG;
                        goto cleanup;
                    }
                }

                if (NULL != pszDomainName)
                {
                    size_t cb;

                    if (SUCCEEDED(StringCbLength(lpszDomainName,cbDomainName,&cb)))
                    {
                        *pszDomainName = (LPTSTR) MIDL_user_allocate(cb+sizeof(TCHAR));
                    
                        if (NULL != *pszDomainName)
                        {
                            lstrcpy(*pszDomainName,lpszDomainName);
                        }
                        else
                        {
                            MIDL_user_free(*pszLsSetupId);
                            status = RPC_S_OUT_OF_MEMORY;
                            goto cleanup;
                        }
                    }
                    else
                    {
                        MIDL_user_free(*pszLsSetupId);						
                        status = RPC_S_INVALID_ARG;
                        goto cleanup;
                    }
                }

                if (NULL != pszLsName)
                {
                    size_t cb;

                    if (SUCCEEDED(StringCbLength(lpszServerName,cbServerName,&cb)))
                    {
                        *pszLsName = (LPTSTR) MIDL_user_allocate(cb+sizeof(TCHAR));
                    
                        if (NULL != *pszLsName)
                        {
                            lstrcpy(*pszLsName,lpszServerName);
                        }
                        else
                        {
                            MIDL_user_free(*pszLsSetupId);
                            MIDL_user_free(*pszDomainName);
                            status = RPC_S_OUT_OF_MEMORY;
                            goto cleanup;
                        }
                    }
                    else
                    {
                        MIDL_user_free(*pszLsSetupId);
                        MIDL_user_free(*pszDomainName);
                        status = RPC_S_INVALID_ARG;
                        goto cleanup;
                    }
                }
            }
        }
        catch (...)
        {
            status = ERROR_NOACCESS;
        }
cleanup:       
        if(lpszSetupId)
            MyVirtualFree(lpszSetupId);

        if(lpszDomainName)
            MyVirtualFree(lpszDomainName);

        if(lpszServerName)
            MyVirtualFree(lpszServerName);
    }

    return status;
}


RPC_STATUS
TryGetServerName(PCONTEXT_HANDLE hBinding,
                 LPTSTR *pszServer,
                 DWORD *pdwErrCode)
{
    RPC_STATUS status;

    status = TLSGetServerNameFixed(hBinding,pszServer,pdwErrCode);

    if (status != RPC_S_OK)
    {
        LPTSTR     lpszMachineName = NULL;

        try
        {            
            if ( !MyVirtualAlloc( ( MAX_COMPUTERNAME_LENGTH+1 ) * sizeof( TCHAR ),
                              (PVOID*) &lpszMachineName ) )
            {
                return RPC_S_OUT_OF_MEMORY;
            }

            DWORD      uSize = MAX_COMPUTERNAME_LENGTH+1 ;

            memset(lpszMachineName, 0, ( MAX_COMPUTERNAME_LENGTH+1 ) * sizeof( TCHAR ));

            status = TLSGetServerNameEx(hBinding, lpszMachineName, &uSize, pdwErrCode);

            if((status == RPC_S_OK) && (pdwErrCode != NULL) && (*pdwErrCode == ERROR_SUCCESS))
            {
                size_t cb;

                if (SUCCEEDED(StringCbLength(lpszMachineName,( MAX_COMPUTERNAME_LENGTH+1 ) * sizeof( TCHAR ),&cb)))
                {            
                    *pszServer = (LPTSTR) MIDL_user_allocate(cb+sizeof(TCHAR));

                    if (NULL != *pszServer)
                    {
                        lstrcpy(*pszServer,lpszMachineName);
                    }
                    else
                    {
                        status = RPC_S_OUT_OF_MEMORY;
                    }
                }
                else
                {
                    status = RPC_S_INVALID_ARG;
                }
            }            
        }
        catch(...)
        {
            status = ERROR_NOACCESS;
        }
        
        if(lpszMachineName)
            MyVirtualFree(lpszMachineName);
    }

    return status;
}

RPC_STATUS
TryGetServerScope(PCONTEXT_HANDLE hBinding,
                  LPTSTR *pszScope,
                  DWORD *pdwErrCode)
{
    RPC_STATUS status;

    status = TLSGetServerScopeFixed(hBinding,pszScope,pdwErrCode);

    if (status != RPC_S_OK)
    {
        LPTSTR lpszScope = NULL;
        DWORD     uSize = LSERVER_MAX_STRING_SIZE + 2;

        try
        {           
            if ( !MyVirtualAlloc( ( LSERVER_MAX_STRING_SIZE + 2 ) * sizeof( TCHAR ),
                             (PVOID*) &lpszScope ) )
            {
                return RPC_S_OUT_OF_MEMORY;
            }

            memset(lpszScope, 0, ( LSERVER_MAX_STRING_SIZE + 2 ) * sizeof( TCHAR ));

            status = TLSGetServerScope(hBinding, lpszScope, &uSize, pdwErrCode);
            if((status == RPC_S_OK) && (pdwErrCode != NULL) && (*pdwErrCode == ERROR_SUCCESS))
            {
                size_t cb;

                if (SUCCEEDED(StringCbLength(lpszScope, ( LSERVER_MAX_STRING_SIZE + 2 ) * sizeof( TCHAR ), &cb)))
                {            
                    *pszScope = (LPTSTR) MIDL_user_allocate(cb+sizeof(TCHAR));

                    if (NULL != *pszScope)
                    {
                        lstrcpy(*pszScope,lpszScope);
                    }
                    else
                    {
                        status = RPC_S_OUT_OF_MEMORY;
                    }
                }
                else
                {
                    status = RPC_S_INVALID_ARG;
                }
            }
            
        } 
        catch(...)
        {
            status = ERROR_NOACCESS;
        }

        if(lpszScope)
                MyVirtualFree(lpszScope);

    }

    return status;
}

DWORD
TLSResolveServerIdToServer(
    LPTSTR pszServerId,
    DWORD  cbServerName,
    LPTSTR pszServerName
    )
/*++

--*/
{
    DWORD dwStatus = ERROR_SUCCESS;
    TLS_HANDLE hEServer = NULL;
    TLServerInfo EServerInfo;
    DWORD dwErrCode;

    TCHAR *szSetupId = NULL;
    TCHAR *szDomainName = NULL;
    TCHAR *szServerName = NULL;

    dwStatus = TLSLookupServerById(
                                pszServerId, 
                                pszServerName
                            );

    if(dwStatus != ERROR_SUCCESS)
    {
        // try to resolve server name with enterprise server
        dwStatus = TLSLookupAnyEnterpriseServer(&EServerInfo);
        if(dwStatus == ERROR_SUCCESS)
        {
            hEServer = TLSConnectAndEstablishTrust(
                                                EServerInfo.GetServerName(), 
                                                NULL
                                            );
            if(hEServer != NULL)
            {
                dwStatus = TryLookupServer(
                                        hEServer, 
                                        pszServerId, 
                                        &szSetupId,   
                                        &szDomainName,
                                        &szServerName,
                                        &dwErrCode
                                    );

                if(dwStatus == ERROR_SUCCESS && dwErrCode == ERROR_SUCCESS)
                {
                    StringCbCopy(pszServerName,
                                 cbServerName,
                                 szServerName);

                    MIDL_user_free(szSetupId);
                    MIDL_user_free(szDomainName);
                    MIDL_user_free(szServerName);
                }
            }
        }
    }



    if(hEServer != NULL)
    {
        TLSDisconnectFromServer(hEServer);
    }

    return dwStatus;
}

///////////////////////////////////////////////////////////////
DWORD
TLSAnnounceServerToRemoteServerWithHandle(
    IN DWORD dwAnnounceType,
    IN TLS_HANDLE hHandle,
    IN LPTSTR pszLocalSetupId,
    IN LPTSTR pszLocalDomainName,
    IN LPTSTR pszLocalServerName,
    IN FILETIME* pftLocalLastShutdownTime
    )
/*++

Abstract:

    Announce to a license server that already connected.

Parameters:

    dwAnnounceType : Announcement type, currently define are 
                     startup, and response.
    hHandle : Connection handle to remote server.
    pszLocalSetupId : Local server's setup ID.
    pszLocalDomainName : Local server's domain name.
    pszLocalServerName : Local server name.
    pftLocalLastShutdownTime : Pointer to FILETIME, local server's 
                               last shutdown time.

Returns:

    ERROR_SUCCESS or error code.

--*/
{
    DWORD dwStatus;
    DWORD dwErrCode;
    TLServerInfo ServerInfo;

    if(hHandle == NULL)
    {
        SetLastError(dwStatus = ERROR_INVALID_PARAMETER);
        return dwStatus;
    }


    //
    // First, try to register to server list manager.
    //
    dwStatus = TLSRegisterServerWithHandle(
                                        hHandle, 
                                        &ServerInfo
                                    );
    if(dwStatus != ERROR_SUCCESS)
    {
        return dwStatus;
    }

    dwErrCode = LSERVER_E_LASTERROR + 1;

    //
    // RPC call to announce server
    //
    dwStatus = TLSAnnounceServer(
                            hHandle,
                            dwAnnounceType,
                            pftLocalLastShutdownTime,
                            pszLocalSetupId,
                            (pszLocalDomainName) ? _TEXT("") : pszLocalDomainName,
                            pszLocalServerName,
                            &dwErrCode
                        );

    if(dwStatus == ERROR_SUCCESS)
    {
        ServerInfo.m_dwPushAnnounceTimes++;

        //
        // Update how many time we have announce to
        // this server.
        TLSRegisterServerWithServerInfo(&ServerInfo);
    }

    if(dwStatus == ERROR_SUCCESS && dwErrCode >= LSERVER_ERROR_BASE)
    {
        TLSLogEvent(
                EVENTLOG_INFORMATION_TYPE,
                TLS_E_SERVERTOSERVER,
                TLS_E_UNEXPECTED_RETURN,
                ServerInfo.GetServerName(),
                (dwErrCode < LSERVER_E_LASTERROR) ? dwErrCode : LSERVER_ERROR_BASE
            );

        SetLastError(dwStatus = dwErrCode);
    }

    return dwStatus;
}

///////////////////////////////////////////////////////////////

DWORD
TLSAnnounceServerToRemoteServer(
    IN DWORD dwAnnounceType,
    IN LPTSTR pszRemoteSetupId,
    IN LPTSTR pszRemoteDomainName,
    IN LPTSTR pszRemoteServerName,
    IN LPTSTR pszLocalSetupId,
    IN LPTSTR pszLocalDomainName,
    IN LPTSTR pszLocalServerName,
    IN FILETIME* pftLocalLastShutdownTime
    )
/*++

Abstract:

    Similar to TLSAnnounceServerToRemoteServerWithHandle() except
    we haven't have make any connection to this server yet.

Parameter:

    dwAnnounceType : Announce type.
    pszRemoteSetupId : Remote server's setup ID.
    pszRemoteDomainName : Remote server's domain.
    pszRemoteServerName : Remote server's name.
    pszLocalSetupId : Local server setup ID.
    pszLocalDomainName : Local server's domain.
    pszLocalServerName : Local server's name.
    pftLocalLastShutdownTime : Local server last shutdown time.

Returns:

    ERROR_SUCCESS or error code.

--*/
{
    TLServerInfo RemoteServer;
    DWORD dwStatus = ERROR_SUCCESS;
    DWORD dwErrCode = ERROR_SUCCESS;

    HANDLE hHandle = NULL;

    //
    // Always try to register with local list.
    //
    dwStatus = TLSRegisterServerWithName(
                            pszRemoteSetupId,
                            pszRemoteDomainName,
                            pszRemoteServerName
                        );
    if(dwStatus != ERROR_SUCCESS && dwStatus != TLS_E_DUPLICATE_RECORD )
    {
        return dwStatus;
    }

    //
    // Query again to make sure we have it in our server list.
    //
    dwStatus = TLSLookupRegisteredServer(
                            pszRemoteSetupId,
                            pszRemoteDomainName,
                            pszRemoteServerName,
                            &RemoteServer
                        );
    if(dwStatus != ERROR_SUCCESS)
    {
        dwStatus = TLS_E_INTERNAL;
        TLSASSERT(FALSE);
        return dwStatus;
    }                            

    //
    // Establish trust with remote server.
    //
    hHandle = TLSConnectAndEstablishTrust(
                                    RemoteServer.GetServerName(), 
                                    NULL
                                );

    if(hHandle != NULL)
    {                        
        dwErrCode = LSERVER_E_LASTERROR + 1;

        //
        // Announce server
        //
        dwStatus = TLSAnnounceServer(
                                hHandle,
                                dwAnnounceType,
                                pftLocalLastShutdownTime,
                                pszLocalSetupId,
                                (pszLocalDomainName) ? _TEXT("") : pszLocalDomainName,
                                pszLocalServerName,
                                &dwErrCode
                            );

        if(dwStatus == ERROR_SUCCESS)
        {
            RemoteServer.m_dwPushAnnounceTimes++;

            // update announce time.
            TLSRegisterServerWithServerInfo(&RemoteServer);
        }

        if(dwStatus == ERROR_SUCCESS && dwErrCode >= LSERVER_ERROR_BASE)
        {
            TLSLogEvent(
                    EVENTLOG_INFORMATION_TYPE,
                    TLS_E_SERVERTOSERVER,
                    TLS_E_UNEXPECTED_RETURN,
                    RemoteServer.GetServerName(),
                    (dwErrCode <= LSERVER_E_LASTERROR) ? dwErrCode : LSERVER_ERROR_BASE
                );

            SetLastError(dwStatus = dwErrCode);
        }
    }

    if(hHandle != NULL)
    {
        TLSDisconnectFromServer(hHandle);
        hHandle = NULL;
    }

    return dwStatus;
}        

///////////////////////////////////////////////////////////////

TLS_HANDLE
TLSConnectAndEstablishTrust(
    IN LPTSTR pszServerName,
    IN HANDLE hHandle
    )
/*++

Abstract:

    Connect and establish trust with remote server.

Parameter:

    pszServerName : Name of the remote server if any.
    hHandle : Connection handle to this remote server if any.

Returns:

    Connection handle to remote server or NULL if error.

--*/
{
    DWORD dwStatus = ERROR_SUCCESS;
    DWORD dwErrCode = ERROR_SUCCESS;
    BOOL bCleanupContextHandle = FALSE;

    if(hHandle == NULL && pszServerName == NULL)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return NULL;
    }

    //
    // Use server name to connect
    //
    if(hHandle == NULL)
    {
        hHandle = TLSConnectToLsServer(pszServerName);

        // we make connection here so we need to cleanup
        bCleanupContextHandle = TRUE;  

        if(hHandle == NULL)
        {
            dwStatus = GetLastError();
        }
    }

    if(hHandle != NULL)
    {
        //
        // establish trust with remote server
        //
        dwStatus = TLSEstablishTrustWithServer(
                                        hHandle,
                                        g_hCryptProv,       // GLOBAL crypto provider
                                        CLIENT_TYPE_TLSERVER,
                                        &dwErrCode
                                    );

        if(dwStatus == ERROR_SUCCESS && dwErrCode >= LSERVER_ERROR_BASE)
        {
            //
            // BUGBUG : We still have lots of old license server running, 
            // ignore this error code for now.
            //
            if(dwErrCode != LSERVER_E_ACCESS_DENIED)
            {
                LPTSTR szServer = NULL;
                DWORD  dwCode;

                if(pszServerName == NULL)
                {
                    dwStatus = TryGetServerName(
                                            hHandle,
                                            &szServer,
                                            &dwCode
                                        );

                    if(dwStatus == RPC_S_OK  && dwCode == ERROR_SUCCESS && szServer != NULL)
                    {
                        pszServerName = szServer;
                    }
                }

                TLSLogEvent(
                        EVENTLOG_ERROR_TYPE,
                        TLS_E_SERVERTOSERVER,
                        TLS_E_ESTABLISHTRUST,
                        pszServerName,
                        dwErrCode
                    );

                if (NULL != szServer)
                {
                    MIDL_user_free(szServer);
                }
            }

            SetLastError(dwStatus = dwErrCode);
        }

        if(dwStatus != ERROR_SUCCESS && hHandle != NULL && bCleanupContextHandle == TRUE)
        {
            // only cleanup if we make the connection in this routine.
            TLSDisconnectFromServer(hHandle);
            hHandle = NULL;
        }
    }

    return (dwStatus == ERROR_SUCCESS) ? hHandle : NULL;
}

///////////////////////////////////////////////////////////////

TLS_HANDLE
TLSConnectToServerWithServerId(
    LPTSTR pszServerSetupId
    )

/*++

Abstract:

    Resolve a license server's unique ID to server name, then
    connect and establish trust relationship with the server.

Parameter:

    pszServerSetupId : Server's unique ID.

Returns:

    Server connection handle or NULL if error.    

--*/

{
    TLS_HANDLE hHandle = NULL;
    TCHAR szServer[MAX_COMPUTERNAME_LENGTH+2];

    if(TLSLookupServerById(pszServerSetupId, szServer) != ERROR_SUCCESS)
    {
        //
        // server might not be available
        //
        SetLastError(TLS_E_SERVERLOOKUP);
        goto cleanup;
    }

    hHandle = TLSConnectAndEstablishTrust(szServer, NULL);

cleanup:

    return hHandle;                        
}

///////////////////////////////////////////////////////////////

DWORD
TLSRetrieveServerInfo(
    IN TLS_HANDLE hHandle,
    OUT PTLServerInfo pServerInfo
    )
/*++

Abstract:

    Retrieve server information from remote server.

Parameter:

    hHandle : Connection handle to remote server.
    pServerInfo : Pointer to TLServerInfo to receive remote
                  server's information.

Return:

    ERROR_SUCCESS or error code.

--*/
{
    DWORD dwStatus;
    DWORD dwErrCode;
    DWORD dwBufSize;
    PBYTE pbServerPid = NULL;
    LPTSTR szServerName = NULL;
    LPTSTR szServerScope = NULL;

    if(hHandle == NULL)
    {
        SetLastError(dwStatus = ERROR_INVALID_PARAMETER);
        return dwStatus;
    }

    //
    // Retrieve Server name.
    //
    dwStatus = TryGetServerName(
                            hHandle,
                            &szServerName,
                            &dwErrCode
                        );

    if(dwStatus != ERROR_SUCCESS || dwErrCode != ERROR_SUCCESS)
    {
        if(dwStatus == ERROR_SUCCESS)
        {
            dwStatus = dwErrCode;
        }
        goto cleanup;
    }
    else
    {
        StringCbCopy(
              pServerInfo->m_szServerName,
              sizeof(pServerInfo->m_szServerName),
              szServerName);

        MIDL_user_free(szServerName);
    }

    //
    // Retrieve server's scope, currently, server scope = domain/workgroup name
    // except in the case of enterprise server.
    //
    dwStatus = TryGetServerScope(
                            hHandle,
                            &szServerScope,
                            &dwErrCode
                        );
    
    if(dwStatus != ERROR_SUCCESS || dwErrCode != ERROR_SUCCESS)
    {
        if(dwStatus == ERROR_SUCCESS)
        {
            dwStatus = dwErrCode;
        }
        goto cleanup;
    }
    else
    {
        StringCbCopy(
              pServerInfo->m_szDomainName,
              sizeof(pServerInfo->m_szDomainName),
              szServerScope);

        MIDL_user_free(szServerScope);
    }


    //
    // Get Server's ID
    //
    dwStatus = TLSGetServerPID(
                            hHandle,
                            &dwBufSize,
                            &pbServerPid,
                            &dwErrCode
                        );
    if(dwStatus != ERROR_SUCCESS || dwErrCode != ERROR_SUCCESS)
    {
        if(dwStatus == ERROR_SUCCESS)
        {
            dwStatus = dwErrCode;
        }
        goto cleanup;
    }

    if(pbServerPid == NULL || dwBufSize == 0)
    {
        // invalid return...
        // TLSASSERT(FALSE);
        
        dwStatus = ERROR_INVALID_DATA;
        goto cleanup;
    }

    StringCbCopyN(
            pServerInfo->m_szSetupId,
            sizeof(pServerInfo->m_szSetupId),
            (LPCTSTR)pbServerPid,
            min(sizeof(pServerInfo->m_szSetupId) - sizeof(TCHAR), dwBufSize)
        );    

    midl_user_free(pbServerPid);


    //
    // retrieve server version information
    //
    dwStatus = TLSGetVersion(
                        hHandle,
                        &(pServerInfo->m_dwTLSVersion)
                    );    

    if(dwStatus == ERROR_SUCCESS)
    {
        DWORD dwMajorVersion;
        DWORD dwMinorVersion;

        dwMajorVersion = GET_SERVER_MAJOR_VERSION(pServerInfo->m_dwTLSVersion);
        dwMinorVersion = GET_SERVER_MINOR_VERSION(pServerInfo->m_dwTLSVersion);
    
        if(dwMajorVersion < GET_SERVER_MAJOR_VERSION(TLS_CURRENT_VERSION))
        {
            pServerInfo->m_dwCapability = TLSERVER_OLDVERSION;
        }
        else if( dwMajorVersion >= GET_SERVER_MAJOR_VERSION(TLS_CURRENT_VERSION) && 
                 dwMinorVersion < GET_SERVER_MINOR_VERSION(TLS_CURRENT_VERSION) )
        {
            pServerInfo->m_dwCapability = TLSERVER_OLDVERSION;
        }

		// version 5.1 and above
        if(dwMajorVersion >= 0x5 && dwMinorVersion > 0)
        {
            pServerInfo->m_dwCapability |= TLSERVER_SUPPORTREPLICATION;
        }
    }

cleanup:

    return dwStatus;
}

///////////////////////////////////////////////////////////////

DWORD
TLSLookupAnyEnterpriseServer(
    OUT PTLServerInfo pServerInfo
    )
/*++

Abstract:

    Find any enterprise server in the registered server list.

Parameter:

    pServerInfo - Pointer to TLServerInfo to receive enterprise server
                  info.

Returns:

    ERROR_SUCCESS or error code.

--*/
{
    TLServerInfo* pServer = NULL;
    BOOL bFound = FALSE;

    TLSBeginEnumKnownServerList();

    while(bFound == FALSE)
    {
        pServer = TLSGetNextKnownServer();
        if(pServer == NULL)
        {
            break;
        }

        if(pServer->IsServerEnterpriseServer() == TRUE)
        {
            *pServerInfo = *pServer;
            bFound = TRUE;
        }
    }

    TLSEndEnumKnownServerList();

    return (bFound == TRUE) ? ERROR_SUCCESS : TLS_E_RECORD_NOTFOUND;
}


///////////////////////////////////////////////////////////////
//
// Various interface function to CTLServerMgr
//
///////////////////////////////////////////////////////////////

//------------------------------------------------------------
//
void
TLSBeginEnumKnownServerList()
{
    g_ServerMgr.ServerListEnumBegin();
}

//------------------------------------------------------------
//
const PTLServerInfo
TLSGetNextKnownServer()
{
    return g_ServerMgr.ServerListEnumNext();
}

//------------------------------------------------------------
//
void
TLSEndEnumKnownServerList()
{
    g_ServerMgr.ServerListEnumEnd();
}


//------------------------------------------------------------
//
DWORD
TLSLookupServerById(
    IN LPTSTR pszServerSetupId, 
    OUT LPTSTR pszServer
    )
/*++

Abstract:

    Loopup server name via server ID.

Parameter:

    pszServerSetupId : remote server's setup ID.
    pszServer : name of the server, must be MAX_COMPUTERNAMELENGTH+1.

Returns:
    
    ERROR_SUCCESS or error code.

Remark:

    Internal call, no error checking on buffer side.

++*/
{
    DWORD dwStatus = ERROR_SUCCESS;

    TLServerInfo ServerInfo;

    dwStatus = TLSLookupRegisteredServer(
                                    pszServerSetupId,
                                    NULL,
                                    NULL,
                                    &ServerInfo
                                );

    if(dwStatus == ERROR_SUCCESS)
    {
        _tcscpy(pszServer, ServerInfo.GetServerName());
    }

    return dwStatus;
}        

//------------------------------------------------------------
//
DWORD
TLSRegisterServerWithName(
    IN LPTSTR pszSetupId,
    IN LPTSTR pszDomainName,
    IN LPTSTR pszServerName
    )
/*++

Abstract:

    Register a server with local server list manager.

Parameter:

    pszSetupId : Remote server setup ID.
    pszDomainName : Remote server domain.
    pszServerName : Remote server name.

Returns:

    ERROR_SUCCESS or error code.

++*/
{
    TLS_HANDLE hHandle = NULL;
    TLServerInfo ServerInfo;
    DWORD dwStatus;

    //
    // Lookup server with local server list manager.
    //
    dwStatus = TLSLookupRegisteredServer(
                                    pszSetupId,
                                    pszDomainName,
                                    pszServerName,
                                    &ServerInfo
                                );

    if( (dwStatus == ERROR_SUCCESS && ServerInfo.GetServerVersion() != 0) )
    {
        //
        // this server already registeted
        //
        return dwStatus;
    }

    if(dwStatus != ERROR_SUCCESS && dwStatus != TLS_E_RECORD_NOTFOUND)
    {
        // Error...
        return dwStatus;
    }

    dwStatus = ERROR_SUCCESS;

    //
    // retrieve remote server information
    //
    hHandle = TLSConnectAndEstablishTrust(
                                    pszServerName,
                                    NULL
                                );
    if(hHandle != NULL)
    {
        dwStatus = TLSRetrieveServerInfo(
                                    hHandle,
                                    &ServerInfo
                                );

        if(dwStatus == ERROR_SUCCESS)
        {
            dwStatus = TLSRegisterServerWithServerInfo(&ServerInfo);
        }
    }

    //
    // close conection
    //
    if(hHandle != NULL)
    {
        TLSDisconnectFromServer(hHandle);
    }

    return dwStatus;
}

//-----------------------------------------------------------
//
DWORD
TLSRegisterServerWithHandle(
    IN TLS_HANDLE hHandle,
    OUT PTLServerInfo pServerInfo
    )
/*++

Abstract:

    Register a remote server with local server list manager, this
    differ from TLSRegisterServerWithName() in that it already has
    make a connection to server.

Parameter:

    hHandle - Connection handle to remote server.
    pServerInfo - return remote server's information.

Returns:

    ERROR_SUCCESS or error code.

++*/
{
    DWORD dwStatus;
    TLS_HANDLE hTrustHandle;
    TLServerInfo ServerInfo;

    if(hHandle == NULL)
    {
        SetLastError(dwStatus = ERROR_INVALID_PARAMETER);
        return dwStatus;
    }

    //
    // Establish trust with remote server.
    //
    hTrustHandle = TLSConnectAndEstablishTrust(
                                        NULL,
                                        hHandle
                                    );
    if(hTrustHandle == NULL)
    {
        dwStatus = GetLastError();
        return dwStatus;
    }

    //
    // Retrieve remote server information.
    //
    dwStatus = TLSRetrieveServerInfo(
                                hHandle,
                                &ServerInfo
                            );

    if(dwStatus == ERROR_SUCCESS)
    {
        if(pServerInfo != NULL)
        {
            *pServerInfo = ServerInfo;
        }

        dwStatus = TLSRegisterServerWithServerInfo(&ServerInfo);
    }

    return dwStatus;
}

//----------------------------------------------------------
DWORD
TLSRegisterServerWithServerInfo(
    IN PTLServerInfo pServerInfo
    )
/*++

Abstract:

    Register a server with local server list manager.

Parameter:

    pServerInfo : remote server information.

Returns:

    ERROR_SUCCESS or error code.

++*/
{
    return g_ServerMgr.AddServerToList(pServerInfo);
}


//------------------------------------------------------------
//
DWORD
TLSLookupRegisteredServer(
    IN LPTSTR pszSetupId,
    IN LPTSTR pszDomainName,
    IN LPTSTR pszServerName,
    OUT PTLServerInfo pServerInfo
    )
/*++

Abstract:

    Look up and retrieve remote server information from local
    server list manager.

Parameter:

    pszSetupId : remote server setup ID if any.
    pszDomainName : useless parameter, ignore
    pszServerName : remote server name if any.
    pServerInfo : Pointer to TLServerInfo to receive info. about
                  remote server.

Returns:

    ERROR_SUCCESS or error code.

Remark:

    Always try to resolve server with server's setup ID first
    then server name.
                    
++*/
{
    DWORD dwStatus;

    if(pszSetupId == NULL && pszServerName == NULL)
    {
        SetLastError(dwStatus = ERROR_INVALID_PARAMETER);
        return dwStatus;
    }

    if(pszSetupId)
    {
        dwStatus = g_ServerMgr.LookupBySetupId(
                                            pszSetupId,
                                            pServerInfo
                                        );
    }
    else if(pszServerName)
    {    
        dwStatus = g_ServerMgr.LookupByServerName(
                                                pszServerName,
                                                pServerInfo
                                        );
    }

    return dwStatus;
}
 
///////////////////////////////////////////////////////////////
//
// class CTLServerMgr
//
///////////////////////////////////////////////////////////////
CTLServerMgr::CTLServerMgr()
{
}

//-----------------------------------------------------
CTLServerMgr::~CTLServerMgr()
{
    PTLServerInfo pServer = NULL;
    m_ReadWriteLock.Acquire(WRITER_LOCK);

    //
    // Disconnect from Server
    //
    for( MapIdToInfo::iterator it = m_Handles.begin(); 
         it != m_Handles.end(); 
         it++ )   
    {
        pServer = (*it).second;

        if(pServer != NULL)
        {
            delete pServer;
        }
    }

    m_Handles.erase(m_Handles.begin(), m_Handles.end());

    m_ReadWriteLock.Release(WRITER_LOCK);
}

//----------------------------------------------------
DWORD
CTLServerMgr::AddServerToList(
    IN PTLServerInfo pServerInfo
    )
/*++

Abstract:

    Add a server into our server list.

Parameters:

    pServerInfo - Information about remote server.

Returns:

    ERROR_SUCCESS or error code.

--*/
{
    DWORD dwStatus = ERROR_SUCCESS;
    MapSetupIdToInfo findMap;
    MapIdToInfo::iterator it;

    if( pServerInfo == NULL )
    {
        SetLastError(dwStatus = ERROR_INVALID_PARAMETER);
        return dwStatus;
    }

    findMap.pszSetupId = pServerInfo->GetServerId();
    m_ReadWriteLock.Acquire(WRITER_LOCK);

    it = m_Handles.find(findMap);

    if(it == m_Handles.end())
    {    
        PTLServerInfo pServer = NULL;
        MapSetupIdToInfo serverMap;

        // make a copy of input
        pServer = new TLServerInfo;
        *pServer = *pServerInfo;
        serverMap.pszSetupId = pServer->GetServerId();

        // Insert into our list
        m_Handles[serverMap] = pServer;
    }
    else
    {
        dwStatus = TLS_E_DUPLICATE_RECORD;

        // update information
        *((*it).second) = *pServerInfo;
    }
    
    m_ReadWriteLock.Release(WRITER_LOCK);        

    return dwStatus;
}
       

//-----------------------------------------------------
DWORD
CTLServerMgr::AddServerToList(
    IN LPCTSTR pszSetupId,
    IN LPCTSTR pszDomainName,
    IN LPCTSTR pszServerName
    )
/*++

Abstract:

    Add a server into our server list.

Parameter:

    pszSetupId : remote server's ID.
    pszDomainName : remote server's domain.
    pszServerName : remote server name.

Returns:

    ERROR_SUCCESS or error code.

++*/
{
    DWORD dwStatus = ERROR_SUCCESS;

    if(pszSetupId == NULL || pszServerName == NULL)
    {
        SetLastError(dwStatus = ERROR_INVALID_PARAMETER);
        return dwStatus;
    }


    PTLServerInfo pServerInfo = NULL;       
    MapSetupIdToInfo serverMap;
    MapIdToInfo::iterator it;

    serverMap.pszSetupId = pszSetupId;
    m_ReadWriteLock.Acquire(WRITER_LOCK);

    it = m_Handles.find(serverMap);

    if(it == m_Handles.end())
    {    
        pServerInfo = new TLServerInfo(pszSetupId, pszDomainName, pszServerName);
        serverMap.pszSetupId = pServerInfo->GetServerId();

        // Win64 compiler error
        //m_Handles.insert( pair<MapSetupIdToInfo, PTLServerInfo>(serverMap, pServerHandle) );

        // Insert into our list
        m_Handles[serverMap] = pServerInfo;
    }
    else 
    {
        if(lstrcmpi((*it).second->GetServerName(), pszServerName) != 0)
        {
            // update server name
            (*it).second->UpdateServerName(pszServerName);
        }

        SetLastError(dwStatus = TLS_E_DUPLICATE_RECORD);
    }

    m_ReadWriteLock.Release(WRITER_LOCK);        
    return dwStatus;
}


//-----------------------------------------------------

DWORD
CTLServerMgr::LookupBySetupId(
    IN LPCTSTR pszSetupId,
    OUT PTLServerInfo pServerInfo
    )
/*++

Abstract:

    Lookup a server via its ID.

Parameters:

    pszSetupId : Remote server setup ID.
    pServerInfo : Pointer to TLServerInfo to receive
                  information about remote server.

Returns:

    ERROR_SUCCESS or error code.

++*/
{
    DWORD dwStatus = ERROR_SUCCESS;


    MapSetupIdToInfo serverMap;
    MapIdToInfo::iterator it;

    m_ReadWriteLock.Acquire(READER_LOCK);

    serverMap.pszSetupId = pszSetupId;
    it = m_Handles.find(serverMap);

    if(it != m_Handles.end())
    {
        *pServerInfo = *((*it).second);
    }
    else
    {
        dwStatus = TLS_E_RECORD_NOTFOUND;
    }

    m_ReadWriteLock.Release(READER_LOCK);
    return dwStatus;
}

//------------------------------------------------------

DWORD
CTLServerMgr::LookupByServerName(
    IN LPCTSTR pszServerName,
    OUT PTLServerInfo pServerInfo
    )
/*++

Abstract:

    Lookup server inforation via server name.

Parameters:

    pszServerName : Name of server.
    pServerInfo : Pointer to TLServerInfo to receive
                  information about remote server.

Returns:

    ERROR_SUCCESS or error code.

Remark:

    machine name might change from one boot to another,
    it is not reliable to query by server name.

++*/
{
    DWORD dwStatus = ERROR_SUCCESS;

    m_ReadWriteLock.Acquire(READER_LOCK);

    for( MapIdToInfo::iterator it = m_Handles.begin(); 
         it != m_Handles.end(); 
         it++ )   
    {
        if(_tcsicmp((*it).second->GetServerName(), pszServerName) == 0)
        {
            break;
        }
    }

    if(it != m_Handles.end())
    {
        *pServerInfo = *((*it).second);
    }
    else
    {
        dwStatus = TLS_E_RECORD_NOTFOUND;
    }

    m_ReadWriteLock.Release(READER_LOCK);
    return dwStatus;
}

//------------------------------------------------------

void
CTLServerMgr::ServerListEnumBegin()
/*++

Abstract:

    Begin a enumeration on local server list.

Parameter:

    None.

Returns:

    None.

Remark:

    This locks local server list into read only mode.

--*/
{
    m_ReadWriteLock.Acquire(READER_LOCK);

    enumIterator = m_Handles.begin();
}

//------------------------------------------------------

const PTLServerInfo
CTLServerMgr::ServerListEnumNext()
/*++

Abstract:

    Retrieve next server in local server list.

Parameter:

    None.

Returns:

    Pointer to a server information.

Remark:

    Must call ServerListEnumBegin().

--*/
{
    PTLServerInfo pServerInfo = NULL;

    if(enumIterator != m_Handles.end())
    {
        pServerInfo = (*enumIterator).second;
        enumIterator++;
    }
    
    return pServerInfo;
}

//------------------------------------------------------

void
CTLServerMgr::ServerListEnumEnd()
/*++

Abstract:

    End enumeration of local server list.

Parameter:

    None.

Returns:

    Pointer to a server information.

Remark:

    Must call ServerListEnumBegin().

--*/
{
    enumIterator = m_Handles.end();
    m_ReadWriteLock.Release(READER_LOCK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\license\tlserver\server\tlsrpc-s.c ===
#include <tlsrpc_s.c>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\license\tlserver\server\tlsbkup-s.c ===
#include <tlsbkup_s.c>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\license\tlserver\server\templic.h ===
//+--------------------------------------------------------------------------
//
// Copyright (c) 1997-1999 Microsoft Corporation
//
// File:       templic.h 
//
// Contents:    
//
// History:     
//
//---------------------------------------------------------------------------
#ifndef __TEMPLIC_H__
#define __TEMPLIC_H__
#include "server.h"


#ifdef __cplusplus
extern "C" {
#endif

DWORD 
TLSDBIssueTemporaryLicense( 
    IN PTLSDbWorkSpace pDbWkSpace,
    IN PTLSDBLICENSEREQUEST pRequest,
    IN FILETIME* pNotBefore,
    IN FILETIME* pNotAfter,
    IN OUT PTLSDBLICENSEDPRODUCT pLicensedProduct
);

DWORD
TLSDBAddTemporaryKeyPack( 
    IN PTLSDbWorkSpace pDbWkSpace,
    IN PTLSDBLICENSEREQUEST pRequest,
    IN OUT LPTLSLICENSEPACK lpTmpKeyPackAdd
);

DWORD
TLSDBGetTemporaryLicense(
    IN PTLSDbWorkSpace pDbWkSpace,
    IN PTLSDBLICENSEREQUEST pRequest,
    IN OUT PTLSLICENSEPACK pLicensePack
);


#ifdef __cplusplus
}
#endif


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\license\tlserver\server\tlscert.h ===
//+--------------------------------------------------------------------------
//
// Copyright (c) 1997-1999 Microsoft Corporation
//
// File:       tlscert.h 
//
// Contents:    
//
// History:     
//
//---------------------------------------------------------------------------
#ifndef __TLSCERT_H__
#define __TLSCERT_H__

#include "server.h"


#ifdef __cplusplus
extern "C" {
#endif

    DWORD
    TLSValidateServerCertficates(
        IN HCRYPTPROV hCryptProv,
        IN HCERTSTORE hCertStore,
        IN PBYTE pbSignCert,
        IN DWORD cbSignCert,
        IN PBYTE pbExchCert,
        IN DWORD cbExchCert,
        OUT FILETIME* pftExpireTime
    );

    DWORD
    TLSDestroyCryptContext(
        HCRYPTPROV hCryptProv
    );


    DWORD
    TLSLoadSavedCryptKeyFromLsa(
        OUT PBYTE* ppbSignKey,
        OUT PDWORD pcbSignKey,
        OUT PBYTE* ppbExchKey,
        OUT PDWORD pcbExchKey
    );

    DWORD
    TLSSaveCryptKeyToLsa(
        IN PBYTE pbSignKey,
        IN DWORD cbSignKey,
        IN PBYTE pbExchKey,
        IN DWORD cbExchKey
    );

    DWORD
    TLSCryptGenerateNewKeys(
        OUT PBYTE* pbSignKey, 
        OUT DWORD* cbSignKey, 
        OUT PBYTE* pbExchKey, 
        OUT DWORD* cbExchKey
    );

    DWORD
    TLSImportSavedKey(
        IN HCRYPTPROV hCryptProv, 
        IN PBYTE      pbSignKey,
        IN DWORD      cbSignKey,
        IN PBYTE      pbExchKey,
        IN DWORD      cbExchKey,
        OUT HCRYPTKEY* pSignKey, 
        OUT HCRYPTKEY* pExchKey
    );

    DWORD
    TLSLoadSelfSignCertificates(
        IN HCRYPTPROV hCryptProv,
        IN PBYTE pbSPK,
        IN DWORD cbSPK,
        OUT PDWORD pcbSignCert, 
        OUT PBYTE* ppbSignCert, 
        OUT PDWORD pcbExchCert, 
        OUT PBYTE* ppbExchCert
    );

    DWORD
    TLSLoadCHEndosedCertificate(
        PDWORD pcbSignCert, 
        PBYTE* ppbSignCert, 
        PDWORD pcbExchCert, 
        PBYTE* ppbExchCert
    );

    DWORD 
    TLSInstallLsCertificate( 
        DWORD cbLsSignCert, 
        PBYTE pbLsSignCert, 
        DWORD cbLsExchCert, 
        PBYTE pbLsExchCert
    );

    DWORD
    TLSUninstallLsCertificate();

    DWORD
    TLSServiceInitCryptoProv(
        IN BOOL bCreateNewKey,
        IN LPCTSTR pszKeyContainer,
        OUT HCRYPTPROV* phCryptProv,
        OUT HCRYPTKEY* phSignKey,
        OUT HCRYPTKEY* phExchKey
    );

    DWORD
    TLSInitCryptoProv(
        IN LPCTSTR pszKeyContainer,
        IN PBYTE pbSignKey,
        IN DWORD cbSignKey,
        IN PBYTE pbExchKey,
        IN DWORD cbExchKey,
        OUT HCRYPTPROV* phCryptProv,
        OUT HCRYPTKEY* phSignKey,
        OUT HCRYPTKEY* phExchKey
    );

    DWORD
    TLSVerifyCertChainInMomory( 
        IN HCRYPTPROV hCryptProv,
        IN PBYTE pbData, 
        IN DWORD cbData 
    );

    DWORD
    TLSRegDeleteKey(
        IN HKEY hRegKey,
        IN LPCTSTR pszSubKey
    );


    DWORD
    TLSTreeCopyRegKey(
        IN HKEY hSourceRegKey,
        IN LPCTSTR pszSourceSubKey,
        IN HKEY hDestRegKey,
        IN LPCTSTR pszDestSubKey
    );

#ifdef __cplusplus
}
#endif



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\license\tlserver\server\tlsjob.h ===
//+--------------------------------------------------------------------------
//
// Copyright (c) 1997-1999 Microsoft Corporation
//
// File:       tlsjob.h 
//
// Contents:    
//
// History:     
//
//---------------------------------------------------------------------------
#ifndef __TLSJOB_H__
#define __TLSJOB_H__

#include "server.h"
#include "jobmgr.h"
#include "workitem.h"
#include "locks.h"


//
// Default interval time is one hour for session and
// persistent job.
//
#ifndef __TEST_WORKMGR__

#define DEFAULT_JOB_INTERVAL        60*60       // Retry every hour
#define DEFAULT_JOB_RETRYTIMES      60*60*60    // 60 days

#define DEFAULT_PERSISTENT_JOB_INTERVAL     4*60*60 // 4 hour interval
#define DEFAULT_PERSISTENT_JOB_RETRYTIMES   6 * 60  // 60 days.

#else

#define DEFAULT_JOB_INTERVAL        2       // 10 seconds
#define DEFAULT_JOB_RETRYTIMES      6000

#endif

#define MAX_JOB_DESCRIPTION         254

//--------------------------------------------------------------
//
// currently defined type of work
//
#define WORKTYPE_PROCESSING         0x80000000
#define WORKTYPE_UNKNOWN            0x00000000

#define WORKTYPE_ANNOUNCE_SERVER    0x00000001
#define WORKTYPE_ANNOUNCETOESERVER  0x00000002
#define WORKTYPE_ANNOUNCE_RESPONSE  0x00000003
#define WORKTYPE_ANNOUNCE_LKP       0x00000004
#define WORKTYPE_SYNC_LKP           0x00000005 
#define WORKTYPE_RETURN_LKP         0x00000006
#define WORKTYPE_RETURN_LICENSE     0x00000007 

typedef enum {
    TLS_WORKOBJECT_RUNONCE=0,
    TLS_WORKOBJECT_SESSION,
    TLS_WORKOBJECT_PERSISTENT
} TLSWORKOBJECTTYPE;

//------------------------------------------------

template <  class T, 
            DWORD WORKTYPE, 
            TLSWORKOBJECTTYPE WORKOBJECTTYPE, 
            DWORD WORKINTERVAL = DEFAULT_JOB_INTERVAL, 
            DWORD WORKRESTARTTIME = INFINITE,
            DWORD RETRYTIMES = 0,
            DWORD MAXJOBDESCSIZE = MAX_JOB_DESCRIPTION >
class CTLSWorkObject : public virtual CWorkObject {

protected:

    TCHAR   m_szJobDescription[MAXJOBDESCSIZE + 1];

    T* m_pbWorkData;            // Work related data.
    DWORD m_cbWorkData;         // size of work related data.
    DWORD m_dwRetryTimes;       // number of retry times.
    DWORD m_dwWorkInterval;     // work interval
    DWORD m_dwWorkRestartTime;  // work restart time.


    //
    // Max. JetBlue bookmark - esent.h
    //
    BYTE   m_pbStorageJobId[JET_cbBookmarkMost+1];
    DWORD  m_cbStorageJobId;

    typedef CTLSWorkObject<
                    T, 
                    WORKTYPE, 
                    WORKOBJECTTYPE, 
                    WORKINTERVAL, 
                    WORKRESTARTTIME, 
                    RETRYTIMES,
                    MAXJOBDESCSIZE
    >  BASECAST;

public:

    //---------------------------------------------------------------
    static BOOL WINAPI
    DeleteWorkObject(
        IN CWorkObject* ptr
        )
    /*++

    Abstract:

        Class static function to delete a job and free its memory.

    Parameter:

        ptr : Pointer to CWorkObject.

    Return:

        TRUE/FALSE.

    Note:

        Both work manager and work storage operate on 
        CWorkObject class and its has no idea the actual derive 
        class, pointer to CWorkObject is not the actual pointer to 
        our derived class, trying to delete will cause error from
        heap manager.

    --*/
    {
        BASECAST* pJob = NULL;

        //
        // Cast it to our class to get the right
        // memory pointer, dynamic_cast will throw
        // exception if it can't cast to what we want.
        //
        pJob = dynamic_cast<BASECAST *>(ptr);
        pJob->EndJob();
        delete pJob;
        
        return ERROR_SUCCESS;
    }

    //---------------------------------------------
    virtual T*
    GetWorkData() { return m_pbWorkData; }

    virtual DWORD
    GetWorkDataSize() { return m_cbWorkData; }
    

    //---------------------------------------------
    CTLSWorkObject(
        IN DWORD bDestructorDelete = TRUE,
        IN T* pbData = NULL,
        IN DWORD cbData = 0
        ) :
    CWorkObject(bDestructorDelete),
    m_dwWorkInterval(WORKINTERVAL),
    m_pbWorkData(NULL),
    m_cbWorkData(0),
    m_dwRetryTimes(RETRYTIMES),
    m_dwWorkRestartTime(WORKRESTARTTIME),
    m_cbStorageJobId(0)
    /*++

    Abstract:

        Class constructor

    Parameter:

        See parameter list.

    Return:

        None or exception.

    --*/
    {
        DWORD dwStatus;
        BOOL bSuccess = FALSE;

        memset(m_pbStorageJobId, 0, sizeof(m_pbStorageJobId));
        
        if(pbData != NULL && cbData != 0)
        {
            bSuccess = SetWorkObjectData(
                                        pbData,
                                        cbData
                                    );

            if(bSuccess == FALSE)
            {
                dwStatus = GetLastError();
                TLSASSERT(FALSE);
                RaiseException(
                               dwStatus,
                               0,
                               0,
                               NULL
                               );
            }
        }
    }

    //---------------------------------------------
    ~CTLSWorkObject()
    {
        Cleanup();
    }

    //------------------------------------------------------------
    // 
    virtual BOOL
    IsWorkPersistent() 
    {
        return (WORKOBJECTTYPE == TLS_WORKOBJECT_PERSISTENT);
    }
        
    //------------------------------------------------------------
    // 
    virtual BOOL
    IsValid() 
    /*++

    Abstract:

        Verify if current work object is valid.

    Parameter:

        None.

    Return:

        TRUE/FALSE.

    --*/
    {
        if(VerifyWorkObjectData(TRUE, m_pbWorkData, m_cbWorkData) == FALSE)
        {
            return FALSE;
        }

        return CWorkObject::IsValid();
    }

    //------------------------------------------------------------
    // 
    virtual void
    Cleanup()
    /*++

    Abstract:

        Clean up/free memory allocated inside of this work object.

    Parameter:

        None.

    Returns:

        None.

    --*/        
    {
        if(m_pbWorkData != NULL && m_cbWorkData != 0)
        {
            //
            // Call derive class cleanup routine.
            //
            CleanupWorkObjectData(
                                &m_pbWorkData, 
                                &m_cbWorkData
                            );
        }

        m_pbWorkData = NULL;
        m_cbWorkData = 0;

        memset(m_pbStorageJobId, 0, sizeof(m_pbStorageJobId));
        m_cbStorageJobId = 0;

        CWorkObject::Cleanup();
    }

    //------------------------------------------------------------
    //
    virtual DWORD 
    GetWorkType()
    {
        return WORKTYPE;
    }

    //-----------------------------------------------------------
    //
    virtual BOOL
    SetWorkObjectData(
        IN T* pbData,
        IN DWORD cbData
        )
    /*++

    Abstract:

        Set work object associated data.

    Parameter:

        pbData : Pointer to data.
        cbData : size of data.

    Return:

        TRUE/FALSE.

    Note:

        This routine calls derive class supplied CopyWorkObjectData()
        to copy the data, how it allocate memory is derived class specific

    --*/
    {
        BOOL bSuccess = TRUE;

        if(pbData == NULL || cbData == 0)
        {
            bSuccess = FALSE;
            SetLastError(ERROR_INVALID_PARAMETER);
        }

        if(bSuccess == TRUE)
        {
            bSuccess = VerifyWorkObjectData(
                                        FALSE, 
                                        pbData, 
                                        cbData
                                    );
        }

        if(bSuccess == TRUE && m_pbWorkData != NULL && m_cbWorkData != 0)
        {
            bSuccess = CleanupWorkObjectData(
                                        &m_pbWorkData, 
                                        &m_cbWorkData
                                    );
        }

        if(bSuccess == TRUE)
        {
            bSuccess = CopyWorkObjectData(
                                    &m_pbWorkData, 
                                    &m_cbWorkData, 
                                    pbData,
                                    cbData
                                );
        }

        return bSuccess;
    }
    //--------------------------------------------------------------
    virtual BOOL
    SelfDestruct()
    /*++

    Abstract:

        Clean up and delete memory associated with this work object.

    Parameters:

        None.

    Return:

        TRUE/FALSE, use GetLastError() to get the error code.

    --*/
    {
        return DeleteWorkObject(this);
    }
    
    //--------------------------------------------------------------
    virtual BOOL
    SetJobId(
        IN PBYTE pbData, 
        IN DWORD cbData
        )
    /*++

    Abstract:

        Set work storage assigned Job ID to this work object, for 
        session/run once work object, this routine will never be invoked

    Parameters:

        pbData : Work storage assigned Job ID.
        cbData : size of Job ID.

    Return:

        TRUE/FALSE.

    --*/
    {
        BOOL bSuccess = TRUE;

        if(cbData >= JET_cbBookmarkMost)
        {
            TLSASSERT(cbData < JET_cbBookmarkMost);
            bSuccess = FALSE;
        }
        else
        {
            memcpy(m_pbStorageJobId, pbData, cbData);
            m_cbStorageJobId = cbData;
        }
                    
        return bSuccess;
    }

    //-----------------------------------------------------------
    virtual BOOL
    GetJobId(
        OUT PBYTE* ppbData, 
        OUT PDWORD pcbData
        )
    /*++

    Abstract:

        Get work storage assigned job ID.

    Parameter:

        ppbData : Pointer to pointer to buffer to receive the job ID.
        pcbData : Pointer to DWORD to receive size of data.

    Returns:

        TRUE/FALSE.

    Note:

        Base class simply return the pointer to object's job ID pointer,
        do not free the returned pointer.

    --*/
    {
        BOOL bSuccess = TRUE;

        if(ppbData != NULL && pcbData != NULL)
        {
            *ppbData = (m_cbStorageJobId > 0) ? m_pbStorageJobId : NULL;
            *pcbData = m_cbStorageJobId;
        }
        else
        {
            TLSASSERT(ppbData != NULL && pcbData != NULL);
            bSuccess = FALSE;
        } 

        return bSuccess;
    }


    //-----------------------------------------------------------
    //
    virtual BOOL
    GetWorkObjectData(
        IN OUT PBYTE* ppbData,
        IN OUT PDWORD pcbData
        )
    /*++

    Abstract:

        See GetWorkObjectData().

    Note:
        
        Needed by CWorkObject.

    --*/
    {
        return GetWorkObjectData(
                            (T **)ppbData,
                            pcbData
                        );
    }


    //-----------------------------------------------------------
    //
    virtual BOOL
    SetWorkObjectData(
        IN PBYTE pbData,
        IN DWORD cbData
        )
    /*++

    Abstract:

        See SetWorkObjectData().

    Note:

        Needed by CWorkObject.

    --*/
    {
        return CopyWorkObjectData(
                                &m_pbWorkData, 
                                &m_cbWorkData, 
                                (T *)pbData,
                                cbData
                            );
    }
    
    //-----------------------------------------------------------
    //
    virtual BOOL
    GetWorkObjectData(
        IN OUT T** ppbData,
        IN OUT PDWORD pcbData
        )
    /*++

    Abstract:

        Return work object related data.


    Parameter:

        ppbData :
        pcbData :

    return:
    
        Always TRUE.


    Note:

        Simply return pointer to object's work data, do not free
        the return pointer.

    --*/
    {
        if(ppbData != NULL)
        {
            *ppbData = m_pbWorkData;
        }

        if(pcbData != NULL)
        {
            *pcbData = m_cbWorkData;
        }

        return TRUE;
    }

    //----------------------------------------------------------
    virtual void
    EndJob() 
    /*++

    Abstract:

        End of job processing, work manager or storage manager will
        invoke object's EndJob() to inform it that job has completed.

    Parameter:

        None.

    Returns:

        None.

    --*/
    {
        Cleanup();
    }

    //----------------------------------------------------------
    virtual BOOL
    IsJobCompleted()
    /*++

    Abstract:

        Return whether work manager or work storage manager can delete
        this job from its queue.

    Parameter:

        None.

    Returns:

        TRUE/FALSE

    --*/
    {
        return IsJobCompleted( 
                            m_pbWorkData,
                            m_cbWorkData 
                        );
    }

    //----------------------------------------------------------
    virtual DWORD
    GetSuggestedScheduledTime()
    /*++

    Abstract:

        Return next time to invoke this job again.

    Parameter:

        None:

    Returns:

        Time relative to current time or INFINITE if no additional
        processing of this job is requred.

    --*/
    {
        return (IsJobCompleted() == TRUE) ? INFINITE : m_dwWorkInterval;
    }

    //----------------------------------------------------------
    virtual DWORD
    GetJobRestartTime() 
    { 
        return m_dwWorkRestartTime; 
    }

    //----------------------------------------------------------
    virtual void
    SetJobRestartTime(
        DWORD dwTime
        ) 
    /*++

    --*/
    { 
        m_dwWorkRestartTime = dwTime;
    }

    //----------------------------------------------------------
    virtual void
    SetJobInterval(
        IN DWORD dwInterval
    )
    /*++

    Abstract:

        Set work interval.

    Parameter:

        dwInterval : new work interval.

    Returns:

        None.

    --*/
    {
        m_dwWorkInterval = dwInterval;
        return;
    }

    //---------------------------------------------------------
    virtual DWORD
    GetJobInterval()
    /*++

    Abstract:

        Retrive work interval, in second, associated with this job.

    Parameter:

        None.

    Returns:

        Job interval associated with this job.

    --*/
    {
        return m_dwWorkInterval;
    }
    
    //--------------------------------------------------------
    virtual void 
    SetJobRetryTimes(
        IN DWORD dwRetries
        )
    /*++

    --*/
    {
        m_dwRetryTimes = dwRetries;
        return;
    }

    //--------------------------------------------------------
    virtual DWORD
    GetJobRetryTimes() { return m_dwRetryTimes; }
        
    //------------------------------------------------------------    
    //
    // General Execute() function, derived class should supply
    // its own UpdateJobNextScheduleTime() to update run interval
    //
    virtual DWORD
    Execute() 
    {
        DWORD dwStatus = ERROR_SUCCESS;

        dwStatus = ExecuteJob( m_pbWorkData, m_cbWorkData );

        return dwStatus;
    }

    //------------------------------------------------------------
    //  
    // Each Derived Class must supply following
    //
    virtual BOOL 
    VerifyWorkObjectData(
        IN BOOL bCallbyIsValid,
        IN T* pbData,
        IN DWORD cbData
    );

    virtual BOOL
    CopyWorkObjectData(
        OUT T** ppbDest,
        OUT DWORD* pcbDest,
        IN T* pbSrc,
        IN DWORD cbSrc
    );

    virtual BOOL
    CleanupWorkObjectData(
        IN OUT T** ppbData,
        IN OUT DWORD* pcbData
    );

    virtual BOOL
    IsJobCompleted(
        IN T* pbData,
        IN DWORD cbData
    );

    virtual DWORD
    ExecuteJob(
        IN T* pbData,
        IN DWORD cbData
    );

    virtual LPCTSTR
    GetJobDescription();
};


//-----------------------------------------------------------------------------
//
//
//  CWorkObject
//      |
//      +---- CTLSWorkObject <-- template class
//                  |
//                  +---- CAnnounceLserver   (Announce License Server)
//                  |
//                  +---- CAnnounceToEServer (Announe server to enterprise server)        
//                  |
//                  +---- CSsyncLicensePack (Synchronize Local License Pack)
//                  |
//                  +---- CReturnLicense (Return/Revoke Client License)
//                  |
//                  +---- CAnnounceResponse (Reponse to server announcement)
//
// CAnnounceLS, CSyncLKP, CAnnounceLKP is run once.
// CAnnounceLSToEServer is session work object
//

//-----------------------------------------------------------
//
// Announce License Server to other license server.
//
#define CURRENT_ANNOUNCESERVEWO_STRUCT_VER  0x00010000
#define ANNOUNCESERVER_DESCRIPTION          _TEXT("Announce License Server")
#define TLSERVER_ENUM_TIMEOUT               5*1000
#define TLS_ANNOUNCESERVER_INTERVAL         60  // one min. interval
#define TLS_ANNOUNCESERVER_RETRYTIMES       3

typedef struct __AnnounceServerWO {
    DWORD dwStructVersion;
    DWORD dwStructSize;
    DWORD dwRetryTimes;
    TCHAR m_szServerId[LSERVER_MAX_STRING_SIZE+2];
    TCHAR m_szScope[LSERVER_MAX_STRING_SIZE+2];
    TCHAR m_szServerName[LSERVER_MAX_STRING_SIZE+2];
    FILETIME m_ftLastShutdownTime;
} ANNOUNCESERVERWO, *PANNOUNCESERVERWO, *LPANNOUNCESERVERWO;

typedef CTLSWorkObject<
            ANNOUNCESERVERWO, 
            WORKTYPE_ANNOUNCE_SERVER, 
            TLS_WORKOBJECT_SESSION,
            TLS_ANNOUNCESERVER_INTERVAL,
            INFINITE,
            TLS_ANNOUNCESERVER_RETRYTIMES
    > CAnnounceLserver;

//-----------------------------------------------------------
//
// Announce License Server to Enterprise server
//
#define CURRENT_ANNOUNCETOESERVEWO_STRUCT_VER   0x00010000
#define ANNOUNCETOESERVER_DESCRIPTION           _TEXT("Announce License Server to Enterprise server")

typedef struct __AnnounceToEServerWO {
    DWORD dwStructVersion;
    DWORD dwStructSize;
    BOOL bCompleted;
    TCHAR m_szServerId[LSERVER_MAX_STRING_SIZE+2];
    TCHAR m_szServerName[LSERVER_MAX_STRING_SIZE+2];
    TCHAR m_szScope[LSERVER_MAX_STRING_SIZE+2];
    FILETIME m_ftLastShutdownTime;
} ANNOUNCETOESERVERWO, *PANNOUNCETOESERVERWO, *LPANNOUNCETOESERVERWO;

typedef CTLSWorkObject<
            ANNOUNCETOESERVERWO, 
            WORKTYPE_ANNOUNCETOESERVER, 
            TLS_WORKOBJECT_SESSION,     // session work object
            DEFAULT_JOB_INTERVAL        // retry every hour    
    > CAnnounceToEServer;

//-----------------------------------------------------------
//
// Response To Server Announce
//
#define CURRENT_ANNOUNCERESPONSEWO_STRUCT_VER   0x00010000
#define ANNOUNCERESPONSE_DESCRIPTION            _TEXT("Response Announce to %s")

typedef struct __AnnounceResponseWO {
    DWORD dwStructVersion;
    DWORD dwStructSize;
    BOOL bCompleted;
    TCHAR m_szTargetServerId[LSERVER_MAX_STRING_SIZE+2];

    TCHAR m_szLocalServerId[LSERVER_MAX_STRING_SIZE+2];
    TCHAR m_szLocalServerName[LSERVER_MAX_STRING_SIZE+2];
    TCHAR m_szLocalScope[LSERVER_MAX_STRING_SIZE+2];
    FILETIME m_ftLastShutdownTime;
} ANNOUNCERESPONSEWO, *PANNOUNCERESPONSEWO, *LPANNOUNCERESPONSEWO;

typedef CTLSWorkObject<
            ANNOUNCERESPONSEWO, 
            WORKTYPE_ANNOUNCE_RESPONSE, 
            TLS_WORKOBJECT_RUNONCE
    > CAnnounceResponse;


//---------------------------------------------------------
//
// Sync. license pack to remote server, this is used in
// announce newly registered license pack and push sync. 
// local license pack to a newly startup server.
//
//
#define CURRENT_SSYNCLICENSEKEYPACK_STRUCT_VER  0x00010000
#define SSYNCLICENSEKEYPACK_DESCRIPTION         _TEXT("Sync %s LKP with remote server %s")
#define SSYNCLKP_MAX_TARGET                     10
#define SSYNC_DBWORKSPACE_TIMEOUT               60*60*1000  // wait one hour for handle

typedef enum {
    SSYNC_ALL_LKP=1,
    SSYNC_ONE_LKP
} SSYNC_TYPE;

typedef struct __SsyncLocalLkpWO {
    DWORD dwStructVersion;
    DWORD dwStructSize;
    
    // Has job completed.
    BOOL bCompleted;

    // local server ID
    TCHAR m_szServerId[LSERVER_MAX_STRING_SIZE+2];  

    // local server name.
    TCHAR m_szServerName[LSERVER_MAX_STRING_SIZE+2]; 

    // type of sync, single license pack or all license pack
    SSYNC_TYPE dwSyncType; 

    // number of license server to push sync.
    DWORD dwNumServer; 

    // list of remote server
    TCHAR m_szTargetServer[SSYNCLKP_MAX_TARGET][MAX_COMPUTERNAME_LENGTH+2];

    // remote server sync. status, TRUE if skip this server
    // FALSE otherwise.
    BOOL m_bSsync[SSYNCLKP_MAX_TARGET];
    union {
        // remote server's last sync (shutdown) time 
        FILETIME m_ftStartSyncTime;

        // license keypack internal tracking ID if this job is
        // to push sync. one license pack
        DWORD dwKeyPackId;
    };
} SSYNCLICENSEPACK, *PSSYNCLICENSEPACK, *LPSSYNCLICENSEPACK;

typedef CTLSWorkObject<
                SSYNCLICENSEPACK,
                WORKTYPE_SYNC_LKP,
                TLS_WORKOBJECT_SESSION,
                DEFAULT_JOB_INTERVAL    
            > CSsyncLicensePack;
                
//---------------------------------------------------------
//
// Return license work object.  This is a persistent job
//
#define CURRENT_RETURNLICENSEWO_STRUCT_VER      0x00010000
#define RETURNLICENSE_RETRY_TIMES               DEFAULT_PERSISTENT_JOB_RETRYTIMES
#define RETURNLICENSE_DESCSIZE                  512
#define RETURNLICENSE_DESCRIPTION               _TEXT("%d Return License %d %d to %s")
#define RETURNLICENSE_RESTARTTIME               60      // default restart time in 1 min.

#define LICENSERETURN_UPGRADE                   0x00000001
#define LICENSERETURN_REVOKED                   0x00000002
#define LICENSERETURN_REVOKE_LKP                0x00000003


typedef struct __ReturnLicenseWO {
    DWORD dwStructVersion;
    DWORD dwStructSize;

    // number of retry.
    DWORD dwNumRetry;

    // remote server setup ID.
    TCHAR szTargetServerId[LSERVER_MAX_STRING_SIZE+2];

    // remote server name.
    TCHAR szTargetServerName[LSERVER_MAX_STRING_SIZE+2];

    // number of licenses in client's license
    DWORD dwQuantity;

    // internal keypack ID this license is allocated from.
    DWORD dwKeyPackId;

    // license internal tracking ID.
    DWORD dwLicenseId;

    // Reason for return, currently ignored.
    DWORD dwReturnReason;

    // product version.
    DWORD dwProductVersion;

    // client platform ID
    DWORD dwPlatformId;

    // Product family code.
    TCHAR szOrgProductID[LSERVER_MAX_STRING_SIZE + 2];
    
    // client's encrypted HWID
    DWORD cbEncryptedHwid;
    BYTE  pbEncryptedHwid[1024];    // max. client HWID size

    // product company
    TCHAR szCompanyName[LSERVER_MAX_STRING_SIZE + 2];

    // product ID.
    TCHAR szProductId[LSERVER_MAX_STRING_SIZE + 2];

    // user name that license was issued to.
    TCHAR szUserName[ MAXCOMPUTERNAMELENGTH + 2 ];

    // machine that license was issued to.
    TCHAR szMachineName[ MAXUSERNAMELENGTH + 2 ];
} RETURNLICENSEWO, *PRETURNLICENSEWO, *LPRETURNLICENSEWO;


typedef CTLSWorkObject<
            RETURNLICENSEWO,
            WORKTYPE_RETURN_LICENSE,
            TLS_WORKOBJECT_PERSISTENT,
            DEFAULT_PERSISTENT_JOB_INTERVAL,
            RETURNLICENSE_RESTARTTIME,
            DEFAULT_PERSISTENT_JOB_RETRYTIMES, 
            RETURNLICENSE_DESCSIZE
        > CReturnLicense;

//----------------------------------------------------

#ifdef __cplusplus
extern "C" {
#endif

    CWorkObject* WINAPI
    InitializeCReturnWorkObject(
        IN CWorkManager* pWkMgr,
        IN PBYTE pbWorkData,
        IN DWORD cbWorkData
    );

    DWORD
    TLSWorkManagerSchedule(
        IN DWORD dwTime,
        IN CWorkObject* pJob
    );

    void
    TLSWorkManagerShutdown();

    
    DWORD
    TLSWorkManagerInit();

    BOOL
    TLSWorkManagerSetJobDefaults(
        CWorkObject* pJob
    );

    DWORD
    TLSPushSyncLocalLkpToServer(
        IN LPTSTR pszSetupId,
        IN LPTSTR pszDomainName,
        IN LPTSTR pszLserverName,
        IN FILETIME* pSyncTime
    );

    DWORD
    TLSStartAnnounceToEServerJob(
        IN LPCTSTR pszServerId,
        IN LPCTSTR pszServerDomain,
        IN LPCTSTR pszServerName,
        IN FILETIME* pftFileTime
    );

    DWORD
    TLSStartAnnounceLicenseServerJob(
        IN LPCTSTR pszServerId,
        IN LPCTSTR pszServerDomain,
        IN LPCTSTR pszServerName,
        IN FILETIME* pftFileTime
    );

    DWORD
    TLSStartAnnounceResponseJob(
        IN LPTSTR pszTargetServerId,
        IN LPTSTR pszTargetServerDomain,
        IN LPTSTR pszTargetServerName,
        IN FILETIME* pftTime
    );

    BOOL
    TLSIsServerCompatible(
        IN DWORD dwLocalServerVersion,
        IN DWORD dwTargetServerVersion
    );

    BOOL
    TLSCanPushReplicateData(
        IN DWORD dwLocalServerVersion,
        IN DWORD dwTargetServerVersion
    );

    BOOL
    IsLicensePackRepl(
        TLSLICENSEPACK* pLicensePack
    );

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\license\tlserver\server\tlsjob.cpp ===
//+--------------------------------------------------------------------------
//
// Copyright (c) 1997-1999 Microsoft Corporation
//
// File:        tlsjob.cpp
//
// Contents:    Various license server job. 
//
// History:     
//
//---------------------------------------------------------------------------
#include "pch.cpp"
#include "tlsjob.h"
#include "jobmgr.h"
#include "wkstore.h"
#include "srvlist.h"
#include "kp.h"
#include "clilic.h"
#include "keypack.h"
#include "init.h"
#include <winsta.h>
#include <globals.h>
#define STRSAFE_NO_DEPRECATE
#include "strsafe.h"


/////////////////////////////////////////////////////////////
//
//
//
//
/////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////
// Various interface into global work manager 
//////////////////////////////////////////////////////////////
CWorkManager g_WorkManager;
CPersistentWorkStorage g_WorkStorage;

#define MAX_ERROR_MSG_SIZE 1024





DWORD
TLSWorkManagerInit()
/*++

Abstract:

    Initialize work manager.

Parameter:

    None.

returns:

    ERROR_SUCCESS or error code.

--*/
{
    DWORD dwStatus;
    WorkItemTable* pWkStorageTable = NULL;

    //
    // Initialize Work Storage table
    //
    pWkStorageTable = GetWorkItemStorageTable();
    if(pWkStorageTable == NULL)
    {
        dwStatus = GetLastError();
        goto cleanup;
    }

    //
    // Init Persistent work storage table
    //
    if(g_WorkStorage.AttachTable(pWkStorageTable) == FALSE)
    {
        dwStatus = GetLastError();
        goto cleanup;
    }

    //
    // Initialize Work Manager    
    //
    dwStatus = g_WorkManager.Startup(&g_WorkStorage);

cleanup:

    return dwStatus;
}    

//-----------------------------------------------------------
                             
void
TLSWorkManagerShutdown()
/*++

Abstract:

    Shutdown work manager.

Parameter:

    None:

Return:

    None.

--*/
{
    g_WorkManager.Shutdown();
}


//-----------------------------------------------------------

DWORD
TLSWorkManagerSchedule(
    IN DWORD dwTime,
    IN CWorkObject* pJob
    )
/*++

Abstract:

    Schedule a job to work manager.

Parameter:

    dwTime : Suggested time for work manager to process this job.
    pJob : Job to be processed/scheduled.

Returns:

    ERROR_SUCCESS or error code.

--*/
{
    return g_WorkManager.ScheduleJob(dwTime, pJob);
}

//-----------------------------------------------------------

BOOL
TLSWorkManagerSetJobDefaults(
    CWorkObject* pJob
    )
/*++

Abstract:

    Set job's interval and retry time.

Parameter:

    pJob : Job to be set.

Returns:

    TRUE/FALSE.

--*/
{
    DWORD dwInterval, dwRetries, dwRestart;
    DWORD dwStatus = ERROR_SUCCESS;

    if(pJob != NULL)
    {
        GetJobObjectDefaults(&dwInterval, &dwRetries, &dwRestart);
        pJob->SetJobInterval(dwInterval);
        pJob->SetJobRetryTimes(dwRetries);
        pJob->SetJobRestartTime(dwRestart);
    }
    else
    {
        SetLastError(ERROR_INVALID_PARAMETER);
    }

    return dwStatus == ERROR_SUCCESS;
}
    


//-----------------------------------------------------------
BOOL
CopyBinaryData(
    IN OUT PBYTE* ppbDestData,
    IN OUT DWORD* pcbDestData,
    IN PBYTE pbSrcData,
    IN DWORD cbSrcData
    )
/*++

Abstract:

    Internal routine to copy a binary data from one buffer 
    to another.

Parameters:

    ppbDestData: Pointer to pointer...
    pcbDestData:
    pbSrcData:
    cbSrcData:

Return:

    TRUE if successful, FALSE otherwise.

++*/
{
    PBYTE pbTarget = NULL;

    if( ppbDestData == NULL || pcbDestData == NULL ||
        pbSrcData == NULL || cbSrcData == 0 )
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    pbTarget = *ppbDestData;

    //
    // would be nice to get the actual size of memory allocated
    //
    if( *ppbDestData == NULL || LocalSize(*ppbDestData) < cbSrcData )
    {
        if(*ppbDestData == NULL)
        {
            pbTarget = (PBYTE)AllocateMemory(cbSrcData);
        }
        else
        {
            pbTarget = (PBYTE)ReallocateMemory(*ppbDestData, cbSrcData);
        }
    }
        
    if(pbTarget != NULL)
    {
        memcpy(
                pbTarget, 
                pbSrcData, 
                cbSrcData
            );

        *pcbDestData = cbSrcData;
        *ppbDestData = pbTarget;
    }

    return pbTarget != NULL;
}

//////////////////////////////////////////////////////////////////////////
//
// CAnnounceLsServer
//
//////////////////////////////////////////////////////////////////////////
BOOL
CAnnounceLserver::VerifyWorkObjectData(
    IN BOOL bCallByIsValid,             // invoke by IsValid() function.
    IN PANNOUNCESERVERWO pbData,
    IN DWORD cbData
    )
/*++

    Verify Announce License Server work object Data.

--*/
{
    BOOL bSuccess = FALSE;
    DWORD dwLen;

    if(pbData == NULL || cbData == 0 || cbData != pbData->dwStructSize)
    {
        TLSASSERT(FALSE);
        SetLastError(ERROR_INVALID_DATA);
        return FALSE;
    }


    //
    // NULL terminate string...
    //
    pbData->m_szServerId[LSERVER_MAX_STRING_SIZE+1] = _TEXT('\0');
    pbData->m_szServerName[LSERVER_MAX_STRING_SIZE+1] = _TEXT('\0');

    dwLen = _tcslen(pbData->m_szServerId);
    if(dwLen != 0 && dwLen < LSERVER_MAX_STRING_SIZE + 1)
    {
        dwLen = _tcslen(pbData->m_szServerName);
        if(dwLen != 0 && dwLen < LSERVER_MAX_STRING_SIZE + 1)
        {
            bSuccess = TRUE;
        }
    }

    if(bSuccess == FALSE)
    {
        SetLastError(ERROR_INVALID_DATA);
    }

    return bSuccess;
}

//------------------------------------------------------------------------
BOOL
CAnnounceLserver::CopyWorkObjectData(
    OUT PANNOUNCESERVERWO* ppbDest,
    OUT PDWORD pcbDest,
    IN PANNOUNCESERVERWO pbSrc,
    IN DWORD cbSrc
    )
/*++

    Copy Announce license server work object's data

--*/
{
    DWORD dwStatus = ERROR_SUCCESS;

    if(ppbDest == NULL || pcbDest == NULL)
    {
        SetLastError(dwStatus = ERROR_INVALID_PARAMETER);
        TLSASSERT(FALSE);
        goto cleanup;
    }

    if(CopyBinaryData(
                (PBYTE *)ppbDest,
                pcbDest,
                (PBYTE) pbSrc,
                cbSrc
            ) == FALSE)
    {           
        dwStatus = GetLastError();
    }

cleanup:

    return dwStatus == ERROR_SUCCESS;
}

//---------------------------------------------------------------------------
BOOL
CAnnounceLserver::CleanupWorkObjectData(
    IN OUT PANNOUNCESERVERWO* ppbData,
    IN OUT PDWORD pcbData
    )
/*++

    Cleanup Announce license server's work object data.

--*/
{
    if(ppbData != NULL && pcbData != NULL)
    {
        FreeMemory(*ppbData);
        *ppbData = NULL;
        *pcbData = 0;
    }

    return TRUE;
}

//---------------------------------------------------------------------------
BOOL
CAnnounceLserver::IsJobCompleted(
    IN PANNOUNCESERVERWO pbData,
    IN DWORD cbData
    )
/*++

    Determine if Announce License Server Job has completed.

--*/
{
    return (pbData == NULL) ? TRUE : (pbData->dwRetryTimes > GetJobRetryTimes());
}


//---------------------------------------------------------------------------
BOOL 
ServerEnumCallBack(
    TLS_HANDLE hHandle,
    LPCTSTR pszServerName,
    HANDLE dwUserData
    )
/*++

    See TLSAPI on license server enumeration.

++*/
{
    CAnnounceLserver* pWkObject = (CAnnounceLserver *)dwUserData;
    DWORD dwStatus = ERROR_SUCCESS;
    DWORD dwErrCode;

    TCHAR szRemoteServerId[LSERVER_MAX_STRING_SIZE+2];
    TCHAR szRemoteServerName[LSERVER_MAX_STRING_SIZE+2];

    if(pWkObject == NULL)
    {
        SetLastError(ERROR_INVALID_DATA);
        TLSASSERT(dwUserData != NULL);
        return FALSE;
    }
        
    BOOL bCancel;

    if(pWkObject->IsWorkManagerShuttingDown() == TRUE)
    {
        return TRUE;
    }

    //
    // Enumeration call ServerEnumCallBack() twice, once before actual connection 
    // and once after it successfully connect to remote server
    //
    if( lstrcmpi(pszServerName, pWkObject->GetWorkData()->m_szServerName) != 0 && hHandle != NULL)  
    {
        //
        // throw exception if fail to allocate memory
        //
        TLServerInfo ServerInfo;
        TLServerInfo ExistingServerInfo;
        TLS_HANDLE hTrustHandle;

        hTrustHandle = TLSConnectAndEstablishTrust(
                                            NULL, 
                                            hHandle
                                        );
        if(hTrustHandle != NULL)
        {                                
            dwStatus = TLSRetrieveServerInfo( 
                                        hTrustHandle, 
                                        &ServerInfo 
                                    );

            if( dwStatus == ERROR_SUCCESS &&
                lstrcmpi(ServerInfo.GetServerId(), pWkObject->GetWorkData()->m_szServerId) != 0 )
                // lstrcmpi(ServerInfo.GetServerName(), pWkObject->GetWorkData()->m_szServerName) != 0
            {
                // check to see if this server is already exists
                dwStatus = TLSLookupRegisteredServer(
                                                ServerInfo.GetServerId(),
                                                ServerInfo.GetServerDomain(),
                                                ServerInfo.GetServerName(),
                                                &ExistingServerInfo
                                            );

                if(dwStatus == ERROR_SUCCESS)
                {
                    ServerInfo = ExistingServerInfo;
                }
                else
                {
                    // register every server.
                    dwStatus = TLSRegisterServerWithServerInfo(&ServerInfo);
                    if(dwStatus == TLS_E_DUPLICATE_RECORD)
                    {
                        dwStatus = ERROR_SUCCESS;
                    }   
                }

                // let enforce talk to non-enforce, replication will be block later
                if( ServerInfo.IsAnnounced() == FALSE && dwStatus == ERROR_SUCCESS )
                {

                    DBGPrintf(
                            DBG_INFORMATION,
                            DBG_FACILITY_JOB,
                            DBGLEVEL_FUNCTION_TRACE,
                            _TEXT("%s - Announce to %s\n"),
                            pWkObject->GetJobDescription(),
                            ServerInfo.GetServerName()
                        );

                    dwStatus = TLSAnnounceServerToRemoteServer(
                                                        TLSANNOUNCE_TYPE_STARTUP,
                                                        ServerInfo.GetServerId(),
                                                        ServerInfo.GetServerDomain(),
                                                        ServerInfo.GetServerName(),
                                                        pWkObject->GetWorkData()->m_szServerId,
                                                        pWkObject->GetWorkData()->m_szScope,
                                                        pWkObject->GetWorkData()->m_szServerName,
                                                        &(pWkObject->GetWorkData()->m_ftLastShutdownTime)
                                                    );
                }
            }                
        }
    }    
    
    return (dwStatus == ERROR_SUCCESS) ? pWkObject->IsWorkManagerShuttingDown() : TRUE;
}

//---------------------------------------------------------------------------
DWORD
CAnnounceLserver::ExecuteJob(
    IN PANNOUNCESERVERWO pbData,
    IN DWORD cbData
    )
/*++

    Execute a announce license server job.

--*/
{
    DWORD dwStatus = ERROR_SUCCESS;

    DBGPrintf(
            DBG_INFORMATION,
            DBG_FACILITY_JOB,
            DBGLEVEL_FUNCTION_TRACE,
            _TEXT("%s ...\n"),
            GetJobDescription()
        );

    if(IsWorkManagerShuttingDown() == TRUE)
    {
        return TLS_I_WORKMANAGER_SHUTDOWN;
    }

    //
    // Enumerate all license server 
    // 
    dwStatus = EnumerateTlsServer(
                            ServerEnumCallBack,
                            this,
                            TLSERVER_ENUM_TIMEOUT,
                            FALSE
                        );  

    //
    // Discovery run twice so that if more than one server
    // start up at the same time, second loop will catch it.
    //
    pbData->dwRetryTimes++;

    DBGPrintf(
            DBG_INFORMATION,
            DBG_FACILITY_JOB,
            DBGLEVEL_FUNCTION_TRACE,
            _TEXT("%s ended...\n"),
            GetJobDescription()
        );
    
    return dwStatus;
}

//----------------------------------------------------------------------------------------------
LPCTSTR
CAnnounceLserver::GetJobDescription()
/*++

    Get announce license server job description, this is used 
    only at debug tracing.

--*/
{
    memset(m_szJobDescription, 0, sizeof(m_szJobDescription));

    _tcsncpy(
            m_szJobDescription,
            ANNOUNCESERVER_DESCRIPTION,
            sizeof(m_szJobDescription)/sizeof(m_szJobDescription[0]) - 1
        );

    return m_szJobDescription;
}

    
////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////
//
// CAnnounceTOEServer
//
//////////////////////////////////////////////////////////////////////////
BOOL
CAnnounceToEServer::VerifyWorkObjectData(
    IN BOOL bCallByIsValid,             // invoke by IsValid() function.
    IN PANNOUNCETOESERVERWO pbData,
    IN DWORD cbData
    )
/*++

    Verify Announce license server to enterprise server work object
    data.

--*/
{
    BOOL bSuccess = FALSE;
    DWORD dwLen;

    if(pbData == NULL || cbData != pbData->dwStructSize)
    {
        TLSASSERT(FALSE);   
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    //
    // NULL terminate string...
    //
    pbData->m_szServerId[LSERVER_MAX_STRING_SIZE+1] = _TEXT('\0');
    pbData->m_szServerName[LSERVER_MAX_STRING_SIZE+1] = _TEXT('\0');

    dwLen = _tcslen(pbData->m_szServerId);
    if(dwLen != 0 && dwLen < LSERVER_MAX_STRING_SIZE + 1)
    {
        dwLen = _tcslen(pbData->m_szServerName);
        if(dwLen != 0 && dwLen < LSERVER_MAX_STRING_SIZE + 1)
        {
            bSuccess = TRUE;
        }
    }

    if(bSuccess == FALSE)
    {
        SetLastError(ERROR_INVALID_DATA);
    }

    return bSuccess;
}

//------------------------------------------------------------------------
BOOL
CAnnounceToEServer::CopyWorkObjectData(
    OUT PANNOUNCETOESERVERWO* ppbDest,
    OUT PDWORD pcbDest,
    IN PANNOUNCETOESERVERWO pbSrc,
    IN DWORD cbSrc
    )
/*++

    Copy announce license server to enterprise server work 
    object data.

--*/
{
    DWORD dwStatus = ERROR_SUCCESS;

    if(ppbDest == NULL || pcbDest == NULL)
    {
        SetLastError(dwStatus = ERROR_INVALID_PARAMETER);
        TLSASSERT(FALSE);
        goto cleanup;
    }

    if(CopyBinaryData(
                (PBYTE *)ppbDest,
                pcbDest,
                (PBYTE) pbSrc,
                cbSrc
            ) == FALSE)
    {           
        dwStatus = GetLastError();
    }

cleanup:

    return dwStatus == ERROR_SUCCESS;
}

//---------------------------------------------------------------------------
BOOL
CAnnounceToEServer::CleanupWorkObjectData(
    IN OUT PANNOUNCETOESERVERWO* ppbData,
    IN OUT PDWORD pcbData
    )
/*++

    Cleanup announce license server to enterprise server work 
    object data.

--*/
{
    if(ppbData != NULL && pcbData != NULL)
    {
        FreeMemory(*ppbData);
        *ppbData = NULL;
        *pcbData = 0;
    }

    return TRUE;
}

//---------------------------------------------------------------------------
BOOL
CAnnounceToEServer::IsJobCompleted(
    IN PANNOUNCETOESERVERWO pbData,
    IN DWORD cbData
    )
/*++

    Detemine if announce license server to enterprise server
    is completed.

--*/
{
    return (pbData == NULL) ? TRUE : GetWorkData()->bCompleted;
}

//---------------------------------------------------------------------------
DWORD
CAnnounceToEServer::ExecuteJob(
    IN PANNOUNCETOESERVERWO pbData,
    IN DWORD cbData
    )
/*++

    Execute an announce license server to enterprise server work object.

--*/
{
    DWORD dwStatus = ERROR_SUCCESS;
    LPWSTR* pszEServerList = NULL;
    DWORD dwCount = 0;
    DWORD dwErrCode;
    BOOL bSkipServer;
    TCHAR szRemoteServerId[LSERVER_MAX_STRING_SIZE+2];
    TCHAR szRemoteServerName[LSERVER_MAX_STRING_SIZE+2];

    DBGPrintf(
            DBG_INFORMATION,
            DBG_FACILITY_JOB,
            DBGLEVEL_FUNCTION_TRACE,
            _TEXT("%s ...\n"),
            GetJobDescription()
        );


    TLSASSERT(pbData != NULL && cbData != 0);

    dwStatus = GetAllEnterpriseServers(
                                    &pszEServerList,
                                    &dwCount
                                );

    if(dwStatus == ERROR_SUCCESS && dwCount > 0 && pszEServerList != NULL)
    {

        for(DWORD index = 0; 
            index < dwCount && IsWorkManagerShuttingDown() == FALSE; 
            index++)
        {
            bSkipServer = TRUE;

            if(pszEServerList[index] == NULL)
            {
                continue;
            }

            //
            // check if we already have this server in our list
            //
            TLServerInfo ServerInfo;
            dwStatus = TLSLookupRegisteredServer(
                                                NULL,
                                                NULL,
                                                pszEServerList[index],
                                                &ServerInfo
                                            );

            if(dwStatus != ERROR_SUCCESS)
            {
                //
                // Get the actual server name.
                //
                TLS_HANDLE hTrustHandle = NULL;

                hTrustHandle = TLSConnectAndEstablishTrust(
                                                        pszEServerList[index], 
                                                        NULL
                                                    );
                if(hTrustHandle != NULL)
                {
                    if(IsWorkManagerShuttingDown() == TRUE)
                    {
                        // handle leak but we are shutting down
                        break;
                    }                    

                    dwStatus = TLSRetrieveServerInfo( 
                                                hTrustHandle, 
                                                &ServerInfo 
                                            );

                    if(dwStatus == ERROR_SUCCESS)
                    {
                        if( lstrcmpi(ServerInfo.GetServerName(), pbData->m_szServerName) != 0 )
                        {

                            if(IsWorkManagerShuttingDown() == TRUE)
                            {
                                // handle leak but we are shutting down
                                break;
                            }

                            dwStatus = TLSRegisterServerWithServerInfo(&ServerInfo);
                            if(dwStatus == ERROR_SUCCESS)
                            {
                                // at this point, if we gets duplicate record, that mean
                                // server is registered via announce and we already 
                                // sync. local license pack so skip it.
                                bSkipServer = FALSE;
                            }
                        }
                    }
                }

                if( hTrustHandle != NULL)
                {               
                    TLSDisconnectFromServer(hTrustHandle);
                }

                dwStatus = ERROR_SUCCESS;
                if(bSkipServer == TRUE)
                {
                    continue;
                }
            }
            else if(GetLicenseServerRole() & TLSERVER_ENTERPRISE_SERVER) 
            {
                // for enterprise server, other server will announce itself,
                // for domain server, we need to announce once a while
                // so that after enterprise restart, it still have our 
                // server
                if(dwStatus == ERROR_SUCCESS && ServerInfo.GetServerVersion() != 0)
                {
                    //
                    // we already 'push' sync. with this server
                    //
                    continue;
                }
            }

            DBGPrintf(
                    DBG_INFORMATION,
                    DBG_FACILITY_JOB,
                    DBGLEVEL_FUNCTION_TRACE,
                    _TEXT("%s - Announce to %s\n"),
                    GetJobDescription(),
                    pszEServerList[index]
                );

            if(IsWorkManagerShuttingDown() == TRUE)
            {
                // handle leak but we are shutting down
                break;
            }

            dwStatus = TLSAnnounceServerToRemoteServer(
                                                TLSANNOUNCE_TYPE_STARTUP,
                                                ServerInfo.GetServerId(),
                                                ServerInfo.GetServerDomain(),
                                                ServerInfo.GetServerName(),
                                                GetWorkData()->m_szServerId,
                                                GetWorkData()->m_szScope,
                                                GetWorkData()->m_szServerName,
                                                &(GetWorkData()->m_ftLastShutdownTime)
                                            );
        }

        //
        // Free memory
        //
        if(pszEServerList != NULL)
        {
            for( index = 0; index < dwCount; index ++)
            {
                if(pszEServerList[index] != NULL)
                {
                    LocalFree(pszEServerList[index]);
                }
            }

            LocalFree(pszEServerList);
        }                              
    }    
    //
    // Continue running in case user install a NT5 PDC
    //
    if(IsWorkManagerShuttingDown() == TRUE)
    {
        GetWorkData()->bCompleted = TRUE;
    }

    return dwStatus;
}

//--------------------------------------------------------------------
LPCTSTR
CAnnounceToEServer::GetJobDescription()
/*++

    Get announce license server to enterprise server
    job description, used only at debug tracing.

--*/
{
    memset(m_szJobDescription, 0, sizeof(m_szJobDescription));

    _tcsncpy(
            m_szJobDescription,
            ANNOUNCETOESERVER_DESCRIPTION,
            sizeof(m_szJobDescription)/sizeof(m_szJobDescription[0]) - 1
        );

    return m_szJobDescription;
}


////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////
//
// CReturnLicense
//
//////////////////////////////////////////////////////////////////////////

CWorkObject* WINAPI
InitializeCReturnWorkObject(
    IN CWorkManager* pWkMgr,
    IN PBYTE pbWorkData,
    IN DWORD cbWorkData
    )
/*++

Abstract:

    Create/initialize a Return License work object.

Parameters:

    pWkMgr : Pointer work manager.
    pbWorkData : Object's work data used to initialize return license.
    cbWorkData : size of work data.

Return:

    A pointer to CWorkObject or NULL if error.

--*/
{
    CReturnLicense* pRetLicense = NULL;
    DWORD dwStatus;

    DBGPrintf(
            DBG_INFORMATION,
            DBG_FACILITY_WORKMGR,
            DBGLEVEL_FUNCTION_TRACE,
            _TEXT("InitializeCReturnWorkObject() - initializing return license...\n")
        );

    pRetLicense = new CReturnLicense(
                                    TRUE, 
                                    (PRETURNLICENSEWO)pbWorkData, 
                                    cbWorkData
                                );

    //
    // TODO - fix this, bad design
    //
    pRetLicense->SetProcessingWorkManager(pWkMgr);
    TLSASSERT(pRetLicense->IsValid() == TRUE);

    return pRetLicense;
}
    
//--------------------------------------------------------
BOOL
CReturnLicense::VerifyWorkObjectData(
    IN BOOL bCallByIsValid,
    IN PRETURNLICENSEWO pbData,
    IN DWORD cbData
    )
/*++

    Verify a return license work object data.

--*/
{
    DWORD dwStatus = ERROR_SUCCESS;
    DWORD dwLen;
    DWORD dwNumLicensedProduct;

    if(pbData == NULL || cbData == 0 || pbData->cbEncryptedHwid == 0)
    {
        TLSASSERT(FALSE);
        SetLastError(dwStatus = ERROR_INVALID_PARAMETER);
    }

    if(dwStatus == ERROR_SUCCESS)
    {
        if( pbData->dwStructVersion < CURRENT_RETURNLICENSEWO_STRUCT_VER ||
            pbData->dwStructSize != cbData )
        {
            SetLastError(dwStatus = ERROR_INVALID_PARAMETER);
            TLSASSERT(FALSE);
        }
    }
    
    if(dwStatus == ERROR_SUCCESS)
    {
        //
        // NULL Terminate Target Server ID
        //
        pbData->szTargetServerId[LSERVER_MAX_STRING_SIZE+1] = _TEXT('\0');
        dwLen = _tcslen(pbData->szTargetServerId);

        if(dwLen == 0 || dwLen >= LSERVER_MAX_STRING_SIZE+1)
        {
            SetLastError(dwStatus = ERROR_INVALID_PARAMETER);
        }
    }

    if(dwStatus == ERROR_SUCCESS)
    {
        pbData->szTargetServerName[LSERVER_MAX_STRING_SIZE+1] = _TEXT('\0');
        dwLen = _tcslen(pbData->szTargetServerName);

        if(dwLen == 0 || dwLen >= LSERVER_MAX_STRING_SIZE+1)
        {
            SetLastError(dwStatus = ERROR_INVALID_PARAMETER);
        }
    }

    if(dwStatus == ERROR_SUCCESS)
    {
        pbData->szOrgProductID[LSERVER_MAX_STRING_SIZE+1] = _TEXT('\0');
        dwLen = _tcslen(pbData->szOrgProductID);
        if(dwLen == 0 || dwLen >= LSERVER_MAX_STRING_SIZE+1)
        {
            SetLastError(dwStatus = ERROR_INVALID_PARAMETER);
        }
    }

    if(dwStatus == ERROR_SUCCESS)
    {
        pbData->szCompanyName[LSERVER_MAX_STRING_SIZE+1] = _TEXT('\0');
        dwLen = _tcslen(pbData->szCompanyName);
        if(dwLen == 0 || dwLen >= LSERVER_MAX_STRING_SIZE+1)
        {
            SetLastError(dwStatus = ERROR_INVALID_PARAMETER);
        }
    }

    if(dwStatus == ERROR_SUCCESS)
    {
        pbData->szProductId[LSERVER_MAX_STRING_SIZE+1] = _TEXT('\0');
        dwLen = _tcslen(pbData->szProductId);
        if(dwLen == 0 || dwLen >= LSERVER_MAX_STRING_SIZE+1)
        {
            SetLastError(dwStatus = ERROR_INVALID_PARAMETER);
        }
    }

    if(dwStatus == ERROR_SUCCESS)
    {
        pbData->szUserName[MAXCOMPUTERNAMELENGTH+1] = _TEXT('\0');
        dwLen = _tcslen(pbData->szUserName);
        if(dwLen == 0 || dwLen >= MAXCOMPUTERNAMELENGTH+1)
        {
            SetLastError(dwStatus = ERROR_INVALID_PARAMETER);
        }
    }
     
    if(dwStatus == ERROR_SUCCESS)
    {
        pbData->szMachineName[MAXUSERNAMELENGTH+1] = _TEXT('\0');
        dwLen = _tcslen(pbData->szMachineName);
        if(dwLen == 0 || dwLen >= MAXUSERNAMELENGTH+1)
        {
            SetLastError(dwStatus = ERROR_INVALID_PARAMETER);
        }
    }

    return dwStatus == ERROR_SUCCESS;
}

//----------------------------------------------------------------------------------------------

BOOL
CReturnLicense::CopyWorkObjectData(
    IN OUT PRETURNLICENSEWO* ppbDest,
    IN OUT PDWORD pcbDest,
    IN PRETURNLICENSEWO pbSrc,
    IN DWORD cbSrc
    )
/*++

    Copy return license work object data.

--*/
{
    DWORD dwStatus = ERROR_SUCCESS;

    if(ppbDest == NULL || pcbDest == NULL)
    {
        SetLastError(dwStatus = ERROR_INVALID_PARAMETER);
        TLSASSERT(FALSE);
        goto cleanup;
    }

    if(CopyBinaryData(
                (PBYTE *)ppbDest,
                pcbDest,
                (PBYTE) pbSrc,
                cbSrc
            ) == FALSE)
    {           
        dwStatus = GetLastError();
    }

cleanup:
    return dwStatus == ERROR_SUCCESS;
}

//-------------------------------------------------------------------------

BOOL 
CReturnLicense::CleanupWorkObjectData(
    IN OUT PRETURNLICENSEWO* ppbData,
    IN OUT PDWORD pcbData    
    )
/*++

    Cleanup return license work object data.

--*/
{
    if(ppbData != NULL && pcbData != NULL)
    {
        FreeMemory(*ppbData);
        *ppbData = NULL;
        *pcbData = 0;
    }

    return TRUE;
}

//---------------------------------------------------------------------------

BOOL
CReturnLicense::IsJobCompleted(
    IN PRETURNLICENSEWO pbData,
    IN DWORD cbData
    )
/*++

    Determine if return license job is completed.

--*/
{
    return (pbData != NULL) ? (pbData->dwNumRetry >= m_dwRetryTimes) : TRUE;
}

RPC_STATUS
TryGetLastError(PCONTEXT_HANDLE hBinding,
                LPTSTR *pszBuffer,
                DWORD *pdwErrCode)
{
    RPC_STATUS status;

    status = TLSGetLastErrorFixed(hBinding,pszBuffer,pdwErrCode);

    if(status != RPC_S_OK)
    {
        LPTSTR     lpszError = NULL;
        status = ERROR_NOACCESS;
        size_t cbError;
        try
        {
            if ( !MyVirtualAlloc( (LSERVER_MAX_STRING_SIZE+1) * sizeof( TCHAR ),
                              (PVOID*) &lpszError ) )
            {
                return RPC_S_OUT_OF_MEMORY;
            }

            DWORD      uSize = LSERVER_MAX_STRING_SIZE +1 ;

            memset(lpszError, 0, ( LSERVER_MAX_STRING_SIZE +1 ) * sizeof( TCHAR ));


            status = TLSGetLastError(hBinding,uSize,lpszError,pdwErrCode);

            if((status == RPC_S_OK) && (pdwErrCode != NULL) && (*pdwErrCode == ERROR_SUCCESS))
            {
                if (SUCCEEDED(StringCbLength(lpszError,uSize,&cbError)))
                {
                    *pszBuffer = (LPTSTR)MIDL_user_allocate(cbError+sizeof(TCHAR));

                    if (NULL != *pszBuffer)
                    {
                        _tcscpy(*pszBuffer,lpszError);
                    }
                    else
                    {
                        status = RPC_S_OUT_OF_MEMORY;
                    }
                }
                else
                {
                    status = RPC_S_INVALID_ARG;
                }
            }
        }
        catch (...)
        {
            status = ERROR_NOACCESS;
        }
        
        if(lpszError)
            MyVirtualFree(lpszError);
    }

    return status;
}

//--------------------------------------------------------------------------------

DWORD
CReturnLicense::ExecuteJob(
    IN PRETURNLICENSEWO pbData,
    IN DWORD cbData
    )
/*++

    Execute a return license work object.

--*/
{
    DWORD dwStatus = ERROR_SUCCESS;
    TLServerInfo ServerInfo;
    TCHAR szServer[LSERVER_MAX_STRING_SIZE+2];
    TLSLicenseToBeReturn ToBeReturn;
    TLS_HANDLE hHandle = NULL;
    DWORD dwErrCode = ERROR_SUCCESS;

    // log an error
    TCHAR *szErrMsg = NULL;


    DBGPrintf(
            DBG_INFORMATION,
            DBG_FACILITY_JOB,
            DBGLEVEL_FUNCTION_TRACE,
            _TEXT("%s ...\n"),
            GetJobDescription()
        );
    
    //-------------------------------------------------------
    if(VerifyWorkObjectData(TRUE, pbData, cbData) == FALSE)
    {
        TLSASSERT(FALSE);
        //
        // this is invalid data, quitely abort operation
        //
        pbData->dwNumRetry = m_dwRetryTimes;
        SetLastError(dwStatus = ERROR_INVALID_DATA);
        goto cleanup;
    }

    if(IsWorkManagerShuttingDown() == TRUE)
    {
        SetLastError(dwStatus = TLS_I_WORKMANAGER_SHUTDOWN);
        goto cleanup;
    }

    dwStatus = TLSResolveServerIdToServer(        
                                pbData->szTargetServerId, 
                                sizeof(szServer),
                                szServer
                            );

    if(dwStatus != ERROR_SUCCESS)
    {
        // Server not register with this server, try using
        // whatever name we have 
        lstrcpy(szServer, pbData->szTargetServerName);
        dwStatus = ERROR_SUCCESS;
    }

    ToBeReturn.dwQuantity = pbData->dwQuantity;
    ToBeReturn.dwKeyPackId = pbData->dwKeyPackId;
    ToBeReturn.dwLicenseId = pbData->dwLicenseId;

    ToBeReturn.cbEncryptedHwid = pbData->cbEncryptedHwid;
    ToBeReturn.pbEncryptedHwid = pbData->pbEncryptedHwid;

    ToBeReturn.dwProductVersion = pbData->dwProductVersion;

    ToBeReturn.pszOrgProductId = pbData->szOrgProductID;
    ToBeReturn.pszCompanyName = pbData->szCompanyName;
    ToBeReturn.pszProductId = pbData->szProductId;
    ToBeReturn.pszUserName = pbData->szUserName;
    ToBeReturn.pszMachineName = pbData->szMachineName;
    ToBeReturn.dwPlatformID = pbData->dwPlatformId;

    if(IsWorkManagerShuttingDown() == TRUE)
    {
        SetLastError(dwStatus = TLS_I_WORKMANAGER_SHUTDOWN);
        goto cleanup;
    }

    hHandle = TLSConnectAndEstablishTrust(szServer, NULL);
    if(hHandle == NULL)
    {
        dwStatus = GetLastError();
        // TLSLogEvent(
        //        EVENTLOG_WARNING_TYPE,
        //        TLS_W_RETURNLICENSE,
        //        TLS_I_CONTACTSERVER,
        //        szServer
        //    );
    }
    else
    {
        if(IsWorkManagerShuttingDown() == TRUE)
        {
            SetLastError(dwStatus = TLS_I_WORKMANAGER_SHUTDOWN);
            goto cleanup;
        }

        // make a RPC call to return client license
        dwStatus = TLSReturnLicensedProduct(
                                    hHandle,
                                    &ToBeReturn,
                                    &dwErrCode
                                );

        if(dwStatus != ERROR_SUCCESS)
        {
            // retry again
            // TLSLogEvent(
            //        EVENTLOG_WARNING_TYPE,
            //        TLS_W_RETURNLICENSE,
            //        TLS_I_CONTACTSERVER,
            //        szServer
            //    );
        }
        else if(dwErrCode >= LSERVER_ERROR_BASE)
        {
            if(dwErrCode != LSERVER_E_DATANOTFOUND && dwErrCode != LSERVER_E_INVALID_DATA)
            {
                DWORD status;
                DWORD errCode;

                status = TryGetLastError(
                                    hHandle,
                                    &szErrMsg,
                                    &errCode
                                    );

                if(status == ERROR_SUCCESS)
                {
                    TLSLogEvent(
                            EVENTLOG_WARNING_TYPE,
                            TLS_W_RETURNLICENSE,
                            TLS_E_RETURNLICENSE,
                            ToBeReturn.pszMachineName,
                            ToBeReturn.pszUserName,
                            szErrMsg,
                            szServer
                        );

                    MIDL_user_free(szErrMsg);
                }
                else
                {
                    // server might be done at this instance, 
                    // log an error with error code
                    TLSLogEvent(
                            EVENTLOG_WARNING_TYPE,
                            TLS_W_RETURNLICENSE,
                            TLS_E_RETURNLICENSECODE,
                            ToBeReturn.pszMachineName,
                            ToBeReturn.pszUserName,
                            dwErrCode,
                            szServer
                        );
                }
            }
        }            
    }

    if(dwStatus == ERROR_SUCCESS && dwErrCode == ERROR_SUCCESS)
    {
        // successfully return license.
        pbData->dwNumRetry = m_dwRetryTimes;
    }
    else if(dwErrCode == LSERVER_E_INVALID_DATA || dwErrCode == LSERVER_E_DATANOTFOUND)
    {
        // server might be re-installed so all database entry is gone
        // delete this return license job
        pbData->dwNumRetry = m_dwRetryTimes;
    }
    else
    {
        pbData->dwNumRetry++;

        if(pbData->dwNumRetry >= m_dwRetryTimes)
        {
            TLSLogEvent(
                    EVENTLOG_WARNING_TYPE,
                    TLS_W_RETURNLICENSE,
                    TLS_E_RETURNLICENSETOOMANY,
                    ToBeReturn.pszMachineName,
                    ToBeReturn.pszUserName,
                    pbData->dwNumRetry
                );
        }
    }

cleanup:

    if(hHandle != NULL)
    {
        TLSDisconnectFromServer(hHandle);
        hHandle = NULL;
    }

    return dwStatus;
}

//----------------------------------------------------------------------------------------------

LPCTSTR
CReturnLicense::GetJobDescription()
/*++

    Get job description, use only at debug tracing.

--*/
{
    PRETURNLICENSEWO pbData = GetWorkData();

    memset(m_szJobDescription, 0, sizeof(m_szJobDescription));

    if(pbData)
    {
        _sntprintf(
                m_szJobDescription,
                sizeof(m_szJobDescription)/sizeof(m_szJobDescription[0]) - 1,
                RETURNLICENSE_DESCRIPTION,
                pbData->dwNumRetry,
                pbData->dwKeyPackId,
                pbData->dwLicenseId,
                pbData->szTargetServerName
            );
    }

    return m_szJobDescription;
}
    
//////////////////////////////////////////////////////////////////////////
//
// CSsyncLicensePack
//
//////////////////////////////////////////////////////////////////////////

BOOL
CSsyncLicensePack::VerifyWorkObjectData(
    IN BOOL bCallByIsValid,             // invoke by IsValid() function.
    IN PSSYNCLICENSEPACK pbData,
    IN DWORD cbData
    )
/*++

    Verify a sync. license pack work object data.

--*/
{
    BOOL bSuccess = TRUE;
    DWORD dwLen;

    if( pbData == NULL || cbData == 0 || cbData != pbData->dwStructSize ||
        (pbData->dwSyncType != SSYNC_ALL_LKP && pbData->dwSyncType != SSYNC_ONE_LKP) )
    {
        TLSASSERT(FALSE);
        SetLastError(ERROR_INVALID_DATA);
        bSuccess = FALSE;
    }
    else if(bCallByIsValid == FALSE)
    {
        for(DWORD index =0; 
            index < pbData->dwNumServer && bSuccess == TRUE; 
            index++)
        {
            //
            // NULL terminate string...
            //
            pbData->m_szTargetServer[index][MAX_COMPUTERNAME_LENGTH+1] = _TEXT('\0');

            dwLen = _tcslen(pbData->m_szTargetServer[index]);
            if(dwLen == 0 || dwLen >= MAX_COMPUTERNAME_LENGTH + 1)
            {
                SetLastError(ERROR_INVALID_DATA);
                bSuccess = FALSE;
            }
        }
    }

    return bSuccess;
}

//------------------------------------------------------------------------
BOOL
CSsyncLicensePack::CopyWorkObjectData(
    OUT PSSYNCLICENSEPACK* ppbDest,
    OUT PDWORD pcbDest,
    IN PSSYNCLICENSEPACK pbSrc,
    IN DWORD cbSrc
    )
/*++

    Copy a sync. license pack work object data.

--*/
{
    DWORD dwStatus = ERROR_SUCCESS;

    if(ppbDest == NULL || pcbDest == NULL)
    {
        SetLastError(dwStatus = ERROR_INVALID_PARAMETER);
        TLSASSERT(FALSE);
        goto cleanup;
    }

    if(CopyBinaryData(
                (PBYTE *)ppbDest,
                pcbDest,
                (PBYTE) pbSrc,
                cbSrc
            ) == FALSE)
    {           
        dwStatus = GetLastError();
    }

cleanup:

    return dwStatus == ERROR_SUCCESS;
}

//---------------------------------------------------------------------------
BOOL
CSsyncLicensePack::CleanupWorkObjectData(
    IN OUT PSSYNCLICENSEPACK* ppbData,
    IN OUT PDWORD pcbData
    )
/*++

    Cleanup a sync. license pack work object data.

--*/
{
    if(ppbData != NULL && pcbData != NULL)
    {
        FreeMemory(*ppbData);
        *ppbData = NULL;
        *pcbData = 0;
    }

    return TRUE;
}

//---------------------------------------------------------------------------
BOOL
CSsyncLicensePack::IsJobCompleted(
    IN PSSYNCLICENSEPACK pbData,
    IN DWORD cbData
    )
/*++

    Detemine if Job is completed.

--*/
{
    return (pbData == NULL) ? TRUE : pbData->bCompleted;
}

//---------------------------------------------------------------------------
void
_AnnounceLicensePackToServers(
    IN CWorkObject* ptr,
    IN PTLSLICENSEPACK pLicensePack,
    IN PDWORD pdwCount,
    IN TCHAR pszServerList[][MAX_COMPUTERNAME_LENGTH+2],
    IN BOOL* pbSsyncStatus
    )
/*++

Abstract:

    Sync. a license pack to list of remote server.

Parameter:

    ptr : pointer to work object that started this call.
    pLicensePack : Pointer to license keypack to sync. with 
                   list of remote server.
    pdwCount : On input, number of license server to push sync,
               on output, number of license server successfully sync.
    pszServerList : Pointer to list of remote server.
    pbSsyncStatus : Pointer to an array to receive push sync status.

Returns:

    None, all error are ignored.

--*/
{
    DWORD dwStatus = ERROR_SUCCESS;
    TLSReplRecord record;
    DWORD dwNumServer = *pdwCount;
    DWORD dwIndex;
    TLS_HANDLE hHandle;
    RPC_STATUS rpcStatus;
    BOOL fActAsEarlierVersion = FALSE;
    WORD wMinorVersion, wMajorVersion;
    TCHAR pszProductId[LSERVER_MAX_STRING_SIZE + 1];
    
    *pdwCount = 0;

    //
    // Setup replication record
    //
    record.dwReplCode = REPLICATIONCODE_SYNC;
    record.dwUnionType = UNION_TYPE_LICENSEPACK;
    record.w.ReplLicPack = *pLicensePack;

    //
    // Announce to all server in the list 
    //
    for( dwIndex = 0; 
         dwIndex < dwNumServer && ptr->IsWorkManagerShuttingDown() == FALSE; 
         dwIndex++ )
    {
        if(pbSsyncStatus[dwIndex] == FALSE)
        {
            hHandle = TLSConnectAndEstablishTrust(
                                                pszServerList[dwIndex],
                                                NULL
                                            );

            if(hHandle != NULL)
            {                                
                DWORD dwSupportFlags = 0;

                	dwStatus = TLSGetSupportFlags(
                        hHandle,
                        &dwSupportFlags
                );

                // License Keypack is not replicated if License server version < license Keypack version

	            if (((dwStatus == RPC_S_OK) && !(dwSupportFlags & SUPPORT_WHISTLER_CAL))
                    || (dwStatus != RPC_S_OK))
                {
                    // This LS doesn't support Whistler CALs

                    if (CompareTLSVersions(MAKELONG(pLicensePack->wMinorVersion,pLicensePack->wMajorVersion),MAKELONG(1,5)) >= 0)
                    {
                        POLICY_TS_MACHINE groupPolicy;

                        RegGetMachinePolicy(&groupPolicy);

                        //
                        // This is a Whistler or later CAL
                        //
                        if (groupPolicy.fPolicyPreventLicenseUpgrade
                            && groupPolicy.fPreventLicenseUpgrade)
                        {
                            //
                            // We'll never want to issue a CAL to this LS
                            //
                            
                            continue;
                        }
                        else
                        {
                            if( _tcsnicmp(pLicensePack->szProductId,
                                          TERMSERV_PRODUCTID_SKU,
                                          _tcslen(TERMSERV_PRODUCTID_SKU)) == 0 )
                            {
                                // 
                                // Per Seat
                                //
                                fActAsEarlierVersion = TRUE;

                                wMinorVersion = pLicensePack->wMinorVersion;
                                wMajorVersion = pLicensePack->wMajorVersion;
                                _tcscpy(pszProductId,pLicensePack->szProductId);

                                pLicensePack->wMajorVersion = 5;
                                pLicensePack->wMinorVersion = 0;
                                _tcscpy(pLicensePack->szProductId,_T("A02-5.00-S"));
                            }
                            else
                            {
                                //
                                // never replicate if it isn't per-seat
                                //

                                continue;
                            }
                        }
                    }
                }

                rpcStatus = TLSAnnounceLicensePack(
                                                hHandle,
                                                &record,
                                                &dwStatus
                                            );
                if (fActAsEarlierVersion)
                {
                    // Put it back to the original values

                    pLicensePack->wMajorVersion = wMajorVersion;
                    pLicensePack->wMinorVersion = wMinorVersion;
                    _tcscpy(pLicensePack->szProductId,pszProductId);
                }


                if(rpcStatus != RPC_S_OK)
                {
                    // this server might be down, mark it so that
                    // we don't retry again
                    pbSsyncStatus[dwIndex] = TRUE;
                } 
                else if(dwStatus == LSERVER_E_SERVER_BUSY)
                {
                    // retry only when server return busy status
                    pbSsyncStatus[dwIndex] = FALSE;
                }
                else
                {
                    // any error, just don't bother trying again
                    pbSsyncStatus[dwIndex] = TRUE;
                }
            }
            else
            {
                // server is not available, don't ssync again
                pbSsyncStatus[dwIndex] = TRUE;
            }

            if(hHandle != NULL)
            {
                TLSDisconnectFromServer(hHandle);
                hHandle = NULL;
            }
        }

        if(pbSsyncStatus[dwIndex] == TRUE)
        {
            (*pdwCount)++;
        }
    }           

    return;
}

//---------------------------------------------------------------------------
DWORD
_SsyncOneLocalLicensePack(
    IN CSsyncLicensePack* ptr,
    IN PSSYNCLICENSEPACK pSsyncLkp
    )
/*++

Abstract:

    Sync. one license pack to one remote server.

Parameter:

    Ptr : Pointer to CSsyncLicensePack work object.
    pSsyncLkp : Pinter to PSSYNCLICENSEPACK.

Returns:

    ERROR_SUCCESS or error code.

--*/
{
    DWORD dwStatus = ERROR_SUCCESS;
    PTLSDbWorkSpace pDbWkSpace = NULL;
    TLSLICENSEPACK LicensePackSearch;
    TLSLICENSEPACK LicensePack;
    DWORD dwSuccessCount = 0;

    //
    // Allocate DB Work Space.
    //
    pDbWkSpace = AllocateWorkSpace(SSYNC_DBWORKSPACE_TIMEOUT);
    if(pDbWkSpace == NULL)
    {
        SetLastError(dwStatus = TLS_I_SSYNCLKP_SERVER_BUSY);
        TLSLogInfoEvent(TLS_I_SSYNCLKP_SERVER_BUSY);
        goto cleanup;
    }

    LicensePackSearch.dwKeyPackId = pSsyncLkp->dwKeyPackId;

    //
    // retrieve license pack
    //
    dwStatus = TLSDBKeyPackFind(   
                            pDbWkSpace,
                            TRUE,
                            LICENSEDPACK_PROCESS_DWINTERNAL,
                            &LicensePackSearch,
                            &LicensePack
                        );

    if(dwStatus != ERROR_SUCCESS)
    {
        if(dwStatus != TLS_E_RECORD_NOTFOUND)
        {
            TLSLogEvent(
                    EVENTLOG_INFORMATION_TYPE,
                    TLS_W_SSYNCLKP,
                    dwStatus
                );
        }

        goto cleanup;
    }

    if(IsLicensePackRepl(&LicensePack) == FALSE)
    {
        goto cleanup;
    }

    if(ptr->IsWorkManagerShuttingDown() == TRUE)
    {
        SetLastError(dwStatus = TLS_I_SERVICE_STOP);
        goto cleanup;
    }

    //
    // Make sure local Server ID and Server Name is correct
    // 
    SAFESTRCPY(LicensePack.szInstallId, pSsyncLkp->m_szServerId);
    SAFESTRCPY(LicensePack.szTlsServerName, pSsyncLkp->m_szServerName);

    dwSuccessCount = pSsyncLkp->dwNumServer;
    _AnnounceLicensePackToServers(
                            ptr,
                            &LicensePack,
                            &dwSuccessCount,
                            pSsyncLkp->m_szTargetServer,
                            pSsyncLkp->m_bSsync
                        );

    if(dwSuccessCount != pSsyncLkp->dwNumServer)
    {
        TLSLogInfoEvent(TLS_I_SSYNCLKP_FAILED);
    }    

cleanup:

    if(pDbWkSpace != NULL)
    {
        ReleaseWorkSpace(&pDbWkSpace);
    }

    return dwStatus;
}

//----------------------------------------------------------------------------
DWORD
_SsyncAllLocalLicensePack(
    IN CSsyncLicensePack* ptr,
    IN PSSYNCLICENSEPACK pSsyncLkp
    )
/*++

    Sync. all local license pack to a remote server.

--*/
{
    DWORD dwStatus = ERROR_SUCCESS;
    PTLSDbWorkSpace pDbWkSpace = NULL;
    TLSLICENSEPACK LicensePackSearch;
    TLSLICENSEPACK LicensePack;
    DWORD dwSuccessCount = 0;
    BOOL SyncStatus[SSYNCLKP_MAX_TARGET];

    //
    // Allocate DB Work Space.
    //
    pDbWkSpace = AllocateWorkSpace(SSYNC_DBWORKSPACE_TIMEOUT);
    if(pDbWkSpace == NULL)
    {
        SetLastError(dwStatus = TLS_I_SSYNCLKP_SERVER_BUSY);
        TLSLogInfoEvent(TLS_I_SSYNCLKP_SERVER_BUSY);
        goto cleanup;
    }

    dwStatus = TLSDBKeyPackEnumBegin(
                                pDbWkSpace,
                                FALSE,
                                0,
                                NULL
                            );

    if(dwStatus == ERROR_SUCCESS)
    {
        while((dwStatus = TLSDBKeyPackEnumNext(pDbWkSpace, &LicensePack)) == ERROR_SUCCESS)
        {
            // unreliable, system time between two machine might not work,
            // force sync and let remote server update its data.
            if(CompareFileTime(
                        &LicensePack.ftLastModifyTime, 
                        &ptr->GetWorkData()->m_ftStartSyncTime
                    ) < 0)
            {
                continue;
            }

            if(ptr->IsWorkManagerShuttingDown() == TRUE)
            {
                break;
            }

            if(IsLicensePackRepl(&LicensePack) == FALSE)
            {
                continue;
            }

            //
            // Make sure local Server ID and Server Name is correct
            // 
            SAFESTRCPY(LicensePack.szInstallId, pSsyncLkp->m_szServerId);
            SAFESTRCPY(LicensePack.szTlsServerName, pSsyncLkp->m_szServerName);
            memset(SyncStatus, 0, sizeof(SyncStatus));

            dwSuccessCount = pSsyncLkp->dwNumServer;
            _AnnounceLicensePackToServers(
                                ptr,
                                &LicensePack,
                                &dwSuccessCount,
                                pSsyncLkp->m_szTargetServer,
                                SyncStatus
                            );
        }

        TLSDBKeyPackEnumEnd(pDbWkSpace);
    }

    //
    // ignore all error
    //
    dwStatus = ERROR_SUCCESS;    
cleanup:

    if(pDbWkSpace != NULL)
    {
        ReleaseWorkSpace(&pDbWkSpace);
    }

    return dwStatus;
}

//----------------------------------------------------------------------------

DWORD
CSsyncLicensePack::ExecuteJob(
    IN PSSYNCLICENSEPACK pSsyncLkp,
    IN DWORD cbSsyncLkp
    )
/*++

    Execute a CSsyncLicensePack work object.

--*/
{
    DWORD dwStatus = ERROR_SUCCESS;

    DBGPrintf(
            DBG_INFORMATION,
            DBG_FACILITY_JOB,
            DBGLEVEL_FUNCTION_TRACE,
            _TEXT("%s ...\n"),
            GetJobDescription()
        );

    TLSASSERT(pSsyncLkp != NULL && cbSsyncLkp != 0);
    if(VerifyWorkObjectData(FALSE, pSsyncLkp, cbSsyncLkp) == FALSE)
    {
        TLSASSERT(FALSE);
        SetLastError(ERROR_INVALID_DATA);
        pSsyncLkp->bCompleted = TRUE;
        return ERROR_INVALID_DATA;
    }

    if(pSsyncLkp->dwSyncType == SSYNC_ONE_LKP)
    {
        dwStatus = _SsyncOneLocalLicensePack(this, pSsyncLkp);
    }
    else
    {
        dwStatus = _SsyncAllLocalLicensePack(this, pSsyncLkp);
    }   

    if(dwStatus == TLS_I_SSYNCLKP_SERVER_BUSY || dwStatus == TLS_I_SSYNCLKP_FAILED)
    {
        // retry operation
        pSsyncLkp->bCompleted = FALSE;
    }
    else
    {
        pSsyncLkp->bCompleted = TRUE;
    }

    DBGPrintf(
            DBG_INFORMATION,
            DBG_FACILITY_JOB,
            DBGLEVEL_FUNCTION_TRACE,
            _TEXT("%s ended...\n"),
            GetJobDescription()
        );
    
    return dwStatus;
}

//--------------------------------------------------------------------------------------
LPCTSTR
CSsyncLicensePack::GetJobDescription()
/*++

    Get CSsyncLicensePack job description, use only
    by debug tracing.

--*/
{
    PSSYNCLICENSEPACK pbData = GetWorkData();
    memset(m_szJobDescription, 0, sizeof(m_szJobDescription));

    if(pbData != NULL)
    {
        _sntprintf(
                m_szJobDescription,
                sizeof(m_szJobDescription)/sizeof(m_szJobDescription[0]) - 1,
                SSYNCLICENSEKEYPACK_DESCRIPTION,
                (pbData->dwSyncType == SSYNC_ALL_LKP) ? _TEXT("ALL") : _TEXT("One"),
                pbData->m_szTargetServer
            );
    }

    return m_szJobDescription;
}



//////////////////////////////////////////////////////////////////////////
//
// CAnnounceResponse
//
//////////////////////////////////////////////////////////////////////////
BOOL
CAnnounceResponse::VerifyWorkObjectData(
    IN BOOL bCallByIsValid,             // invoke by IsValid() function.
    IN PANNOUNCERESPONSEWO pbData,
    IN DWORD cbData
    )
/*++

    Verify CAnnounceResponse work object data.

--*/
{
    BOOL bSuccess = TRUE;
    DWORD dwLen;

    if(pbData == NULL || cbData == 0 || cbData != pbData->dwStructSize)
    {
        bSuccess = FALSE;
    }

    if(bSuccess == TRUE)
    {
        pbData->m_szTargetServerId[LSERVER_MAX_STRING_SIZE+1] = _TEXT('\0');
        dwLen = _tcslen(pbData->m_szTargetServerId);
        if(dwLen == 0 || dwLen >= LSERVER_MAX_STRING_SIZE + 1)
        {
            bSuccess = FALSE;
        }
    }

    if(bSuccess == FALSE)
    {
        TLSASSERT(FALSE);
        SetLastError(ERROR_INVALID_DATA);
    }

    return bSuccess;
}

//------------------------------------------------------------------------
BOOL
CAnnounceResponse::CopyWorkObjectData(
    OUT PANNOUNCERESPONSEWO* ppbDest,
    OUT PDWORD pcbDest,
    IN PANNOUNCERESPONSEWO pbSrc,
    IN DWORD cbSrc
    )
/*++

    Copy CAnnounceResponse work object data.

--*/
{
    DWORD dwStatus = ERROR_SUCCESS;

    if(ppbDest == NULL || pcbDest == NULL)
    {
        SetLastError(dwStatus = ERROR_INVALID_PARAMETER);
        TLSASSERT(FALSE);
        goto cleanup;
    }

    if(CopyBinaryData(
                (PBYTE *)ppbDest,
                pcbDest,
                (PBYTE) pbSrc,
                cbSrc
            ) == FALSE)
    {           
        dwStatus = GetLastError();
    }

cleanup:

    return dwStatus == ERROR_SUCCESS;
}

//---------------------------------------------------------------------------
BOOL
CAnnounceResponse::CleanupWorkObjectData(
    IN OUT PANNOUNCERESPONSEWO* ppbData,
    IN OUT PDWORD pcbData
    )
/*++

    cleanup CAnnounceResponse work object data.

--*/
{
    if(ppbData != NULL && pcbData != NULL)
    {
        FreeMemory(*ppbData);
        *ppbData = NULL;
        *pcbData = 0;
    }

    return TRUE;
}

//---------------------------------------------------------------------------
BOOL
CAnnounceResponse::IsJobCompleted(
    IN PANNOUNCERESPONSEWO pbData,
    IN DWORD cbData
    )
/*++

    Detemine if job completed.

--*/
{
    return (pbData == NULL) ? TRUE : pbData->bCompleted;
}

//---------------------------------------------------------------------------
DWORD
CAnnounceResponse::ExecuteJob(
    IN PANNOUNCERESPONSEWO pbData,
    IN DWORD cbData
    )
/*++

    Execute a CAnnounceResponse work object.

--*/
{
    DWORD dwStatus = ERROR_SUCCESS;
    TLS_HANDLE hHandle = NULL;

    DBGPrintf(
            DBG_INFORMATION,
            DBG_FACILITY_JOB,
            DBGLEVEL_FUNCTION_TRACE,
            _TEXT("%s ...\n"),
            GetJobDescription()
        );

    TLServerInfo ServerInfo;

    dwStatus = TLSLookupRegisteredServer(
                                    pbData->m_szTargetServerId,
                                    NULL,
                                    NULL,
                                    &ServerInfo
                                );

    if(dwStatus == ERROR_SUCCESS)
    {
        DBGPrintf(
                DBG_INFORMATION,
                DBG_FACILITY_JOB,
                DBGLEVEL_FUNCTION_DETAILSIMPLE,
                _TEXT("Announcing server to %s...\n"),
                ServerInfo.GetServerName()
            );

        if(IsWorkManagerShuttingDown() == FALSE)
        {
            dwStatus = TLSAnnounceServerToRemoteServer(
                                            TLSANNOUNCE_TYPE_RESPONSE,
                                            ServerInfo.GetServerId(),
                                            ServerInfo.GetServerDomain(),
                                            ServerInfo.GetServerName(),
                                            pbData->m_szLocalServerId,
                                            pbData->m_szLocalScope,
                                            pbData->m_szLocalServerName,
                                            &(pbData->m_ftLastShutdownTime)
                                        );
        }
    }
    else
    {
        TLSASSERT(FALSE);
    }



    //
    // Discovery run once
    //
    pbData->bCompleted = TRUE;

    DBGPrintf(
            DBG_INFORMATION,
            DBG_FACILITY_JOB,
            DBGLEVEL_FUNCTION_TRACE,
            _TEXT("%s ended...\n"),
            GetJobDescription()
        );
    
    return dwStatus;
}

//----------------------------------------------------------------------------------------------
LPCTSTR
CAnnounceResponse::GetJobDescription()
/*++

    Retrieve CAnnounceResponse job description.

--*/
{
    memset(m_szJobDescription, 0, sizeof(m_szJobDescription));
    PANNOUNCERESPONSEWO pbData = GetWorkData();

    if(pbData != NULL)
    {
        _sntprintf(
                m_szJobDescription,
                sizeof(m_szJobDescription)/sizeof(m_szJobDescription[0]) - 1,
                ANNOUNCERESPONSE_DESCRIPTION,
                pbData->m_szTargetServerId
            );
    }

    return m_szJobDescription;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\license\tlserver\server\tlscert.cpp ===
//+--------------------------------------------------------------------------
//
// Copyright (c) 1997-1999 Microsoft Corporation
//
// File:       tlscert.cpp 
//
// Contents:   Certificate routines 
//
// History:     
//
//---------------------------------------------------------------------------
#include "pch.cpp"
#include "server.h"
#include "globals.h"
#include "tlscert.h"
#include "gencert.h"

#define MAX_KEY_CONTAINER_LENGTH    25
#ifdef IGNORE_EXPIRATION
#define LICENSE_EXPIRATION_IGNORE L"SOFTWARE\\Microsoft\\TermServLicensing\\IgnoreLicenseExpiration"
#endif

//////////////////////////////////////////////////////////////////

BOOL
VerifyCertValidity(
    IN PCCERT_CONTEXT pCertContext
    )

/*++

--*/

{    
    BOOL bValid;
    FILETIME ft;

#ifdef IGNORE_EXPIRATION
    LONG lRet;
    HKEY hKey = NULL;

    lRet = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                        LICENSE_EXPIRATION_IGNORE ,
                        0,
                        KEY_READ ,
                        &hKey );    

    if( ERROR_SUCCESS == lRet )
    { 
        bValid = TRUE;
        goto cleanup;
    }
#endif
    GetSystemTimeAsFileTime(&ft);

    bValid = (CompareFileTime(
                        &ft, 
                        &(pCertContext->pCertInfo->NotAfter)
                    ) < 0);

#ifdef IGNORE_EXPIRATION
cleanup:
    if(hKey)
    {
        RegCloseKey(hKey);
    }
#endif
    return bValid;
}

//////////////////////////////////////////////////////////////////

void
DeleteBadIssuerCertFromStore(
    IN HCERTSTORE hCertStore,
    IN PCCERT_CONTEXT pSubjectContext
    )

/*++

--*/

{
    PCCERT_CONTEXT pCertIssuer = NULL;
    DWORD dwFlags;
    DWORD dwStatus;
    BOOL bExpiredCert = FALSE;

    do {
        dwFlags = CERT_STORE_SIGNATURE_FLAG;
        pCertIssuer = CertGetIssuerCertificateFromStore(
                                            hCertStore,
                                            pSubjectContext,
                                            NULL,
                                            &dwFlags
                                        );

        if(pCertIssuer == NULL)
        {
            // can't find issuer certificate
            break;
        }

        bExpiredCert = (VerifyCertValidity(pCertIssuer) == FALSE);

        if(dwFlags != 0 || bExpiredCert == TRUE)
        {
            CertDeleteCertificateFromStore(pCertIssuer);
        }
        else
        {
            break;
        }

    } while(TRUE);

    return;
}

//////////////////////////////////////////////////////////////////

PCCERT_CONTEXT
GetIssuerCertificateFromStore(
    IN HCERTSTORE hCertStore,
    IN PCCERT_CONTEXT pSubjectContext,
    IN BOOL bDelBadIssuerCert
    )

/*++


--*/

{
    PCCERT_CONTEXT pCertIssuer = NULL;
    DWORD dwFlags;
    BOOL bExpiredCert = FALSE;

    SetLastError(ERROR_SUCCESS);

    do {
        dwFlags = CERT_STORE_SIGNATURE_FLAG;
        pCertIssuer = CertGetIssuerCertificateFromStore(
                                            hCertStore,
                                            pSubjectContext,
                                            pCertIssuer,
                                            &dwFlags
                                        );

        if(pCertIssuer == NULL)
        {
            // can't find issuer certificate
            break;
        }

        bExpiredCert = (VerifyCertValidity(pCertIssuer) == FALSE);

        if(dwFlags == 0 && bExpiredCert == FALSE)
        {
            //
            // find a good issuer's certificate
            //
            break;
        }

        //if(pCertIssuer != NULL)
        //{
        //    CertFreeCertificateContext(pCertIssuer);
        //}

    } while(TRUE);

    if(bDelBadIssuerCert == TRUE && pCertIssuer)
    {
        //
        // Only delete bad certificate if we can't find a good one.
        //
        DeleteBadIssuerCertFromStore(
                            hCertStore,
                            pSubjectContext
                        );
    }

    if(bExpiredCert == TRUE && pCertIssuer == NULL)
    {
        SetLastError(TLS_E_EXPIRE_CERT);
    }

    return pCertIssuer;
}            

//////////////////////////////////////////////////////////////////////////

DWORD
TLSVerifyCertChain( 
    IN HCRYPTPROV hCryptProv, 
    IN HCERTSTORE hCertStore,
    IN PCCERT_CONTEXT pSubjectContext,
    OUT FILETIME* pftMinExpireTime
    )

/*++


--*/

{
    DWORD dwStatus = ERROR_SUCCESS;
    PCCERT_CONTEXT pCertIssuer = NULL;
    PCCERT_CONTEXT pCurrentSubject;

    //
    // Increase reference count on Subject context.
    pCurrentSubject = CertDuplicateCertificateContext(
                                                pSubjectContext
                                            );

    while( TRUE )
    {
        pCertIssuer = GetIssuerCertificateFromStore(
                                            hCertStore, 
                                            pCurrentSubject,
                                            FALSE
                                        );
        if(!pCertIssuer)
        {
            // Could not find issuer's certificate or 
            // a good issuer's certificate
            dwStatus = GetLastError();
            break;
        }


        if(CompareFileTime(pftMinExpireTime, &(pCertIssuer->pCertInfo->NotAfter)) > 0)
        {
            *pftMinExpireTime = pCertIssuer->pCertInfo->NotAfter;
        }

        if(pCurrentSubject != NULL)
        {
            CertFreeCertificateContext(pCurrentSubject);
        }

        pCurrentSubject = pCertIssuer;
    }

    if(dwStatus == CRYPT_E_SELF_SIGNED)
    {
        dwStatus = ERROR_SUCCESS;
    }

    if(pCertIssuer != NULL)
    {
        CertFreeCertificateContext(pCertIssuer);
    }

    if(pCurrentSubject != NULL)
    {
        CertFreeCertificateContext(pCurrentSubject);
    }
  
    SetLastError(dwStatus);
    return dwStatus;
}

//////////////////////////////////////////////////////////////////

DWORD
VerifyLicenseServerCertificate(
    IN HCRYPTPROV hCryptProv,
    IN PCCERT_CONTEXT pCertContext,
    IN DWORD dwCertType
    )

/*++

--*/

{
    BOOL bFound=FALSE;
    PCERT_INFO pCertInfo = pCertContext->pCertInfo;
    PCERT_EXTENSION pCertExtension=pCertInfo->rgExtension;
    PCERT_PUBLIC_KEY_INFO pbPublicKey=NULL;
    DWORD dwStatus = ERROR_SUCCESS;
    DWORD dwSize = 0;

    //
    // Must have a CH root extension.
    //
    for(DWORD i=0; 
        i < pCertInfo->cExtension && bFound == FALSE; 
        i++, pCertExtension++)
    {
        bFound=(strcmp(pCertExtension->pszObjId, szOID_PKIX_HYDRA_CERT_ROOT) == 0);
    }

    if(bFound == TRUE)
    {
        //
        // Public Key must be the same
        //
        dwStatus = TLSExportPublicKey(
                                hCryptProv,
                                dwCertType,
                                &dwSize,
                                &pbPublicKey
                            );

        if(dwStatus == ERROR_SUCCESS)
        {
            bFound = CertComparePublicKeyInfo(
                                        X509_ASN_ENCODING, 
                                        pbPublicKey,
                                        &(pCertContext->pCertInfo->SubjectPublicKeyInfo)
                                    );

            if(bFound == FALSE)
            {
                dwStatus = TLS_E_MISMATCHPUBLICKEY;
            }
        }
    }
    else
    {
        dwStatus = TLS_E_INVALIDLSCERT;
    }
        
    FreeMemory(pbPublicKey);
    return dwStatus;
}

//////////////////////////////////////////////////////////////////////

DWORD
TLSVerifyServerCertAndChain(
    IN HCRYPTPROV hCryptProv,
    IN HCERTSTORE hCertStore,
    IN DWORD dwCertType,
    IN PBYTE pbCert,
    IN DWORD cbCert,
    IN OUT FILETIME* pExpiredTime
    )

/*++


--*/

{
    DWORD dwStatus = ERROR_SUCCESS;
    PCCERT_CONTEXT pCertContext = NULL;

    //
    // Verify License Server's own certificate
    //
    pCertContext = CertCreateCertificateContext(
                                        X509_ASN_ENCODING,
                                        pbCert,
                                        cbCert
                                    );
    if(pCertContext == NULL)
    {
        dwStatus = GetLastError();
        goto cleanup;
    }

    //
    // Verify License Server's certificate first
    //
    dwStatus = VerifyLicenseServerCertificate(
                                    hCryptProv,
                                    pCertContext,
                                    dwCertType
                                );

    if(dwStatus != ERROR_SUCCESS)
    {
        goto cleanup;
    }

    //
    // Verify Certificate Chain
    //
    dwStatus = TLSVerifyCertChain(
                            hCryptProv,
                            hCertStore,
                            pCertContext,
                            pExpiredTime
                        );
                                  
    if(dwStatus != ERROR_SUCCESS)
    {
        goto cleanup;
    }

cleanup:

    if(pCertContext != NULL)
    {
        CertFreeCertificateContext(pCertContext);
    }

    return dwStatus;
}

    

//////////////////////////////////////////////////////////////////
DWORD
TLSValidateServerCertficates(
    IN HCRYPTPROV hCryptProv,
    IN HCERTSTORE hCertStore,
    IN PBYTE pbSignCert,
    IN DWORD cbSignCert,
    IN PBYTE pbExchCert,
    IN DWORD cbExchCert,
    OUT FILETIME* pftExpireTime
    )

/*++


--*/

{
#if ENFORCE_LICENSING

    DWORD dwStatus;

    pftExpireTime->dwLowDateTime = 0xFFFFFFFF;
    pftExpireTime->dwHighDateTime = 0xFFFFFFFF;

    dwStatus = TLSVerifyServerCertAndChain(
                                    hCryptProv,
                                    hCertStore,
                                    AT_SIGNATURE,
                                    pbSignCert,
                                    cbSignCert,
                                    pftExpireTime
                                );

    if(TLS_ERROR(dwStatus) == TRUE)
    {
        goto cleanup;
    }


    dwStatus = TLSVerifyServerCertAndChain(
                                    hCryptProv,
                                    hCertStore,
                                    AT_KEYEXCHANGE,
                                    pbExchCert,
                                    cbExchCert,
                                    pftExpireTime
                                );

cleanup:

    return dwStatus;

#else

    return ERROR_SUCCESS;

#endif
}

//////////////////////////////////////////////////////////////////

DWORD
TLSDestroyCryptContext(
    HCRYPTPROV hCryptProv
    )

/*++


--*/

{
    DWORD dwStatus = E_FAIL;
    BOOL bSuccess;
    PBYTE pbData = NULL;
    DWORD cbData = 0;

    if(hCryptProv == NULL)
    {
        SetLastError(dwStatus = ERROR_INVALID_PARAMETER);
        goto cleanup;
    }

    //
    // Get the container name.
    // 
    bSuccess = CryptGetProvParam(
                            hCryptProv,
                            PP_CONTAINER,
                            NULL,
                            &cbData,
                            0
                        );

    if(bSuccess != FALSE)
    {
        dwStatus = GetLastError();
        goto cleanup;
    }

    pbData = (PBYTE)AllocateMemory(cbData + sizeof(TCHAR));
    if(pbData == NULL)
    {
        dwStatus = GetLastError();
        goto cleanup;
    }

    bSuccess = CryptGetProvParam(
                            hCryptProv,
                            PP_CONTAINER,
                            pbData,
                            &cbData,
                            0
                        );

    if(bSuccess == FALSE)
    {
        dwStatus = GetLastError();
        goto cleanup;
    }

    //
    // Release the context
    //
    bSuccess = CryptReleaseContext(
                            hCryptProv,
                            0
                        );
    if(bSuccess == FALSE)
    {
        dwStatus = GetLastError();
        goto cleanup;
    }

    //
    // Delete key set
    //
    bSuccess = CryptAcquireContext(
                        &hCryptProv, 
                        (LPCTSTR)pbData,
                        DEFAULT_CSP, 
                        PROVIDER_TYPE, 
                        CRYPT_DELETEKEYSET
                    );

    if(bSuccess == FALSE)
    {
        dwStatus = GetLastError();
    }
        
cleanup:

    FreeMemory(pbData);
    return dwStatus;
}
    
//////////////////////////////////////////////////////////////////

DWORD
InitCryptoProv(
    LPCTSTR pszKeyContainer,
    HCRYPTPROV* phCryptProv
    )
/*++

--*/
{
    DWORD dwStatus = ERROR_SUCCESS;
    TCHAR szKeyContainer[MAX_KEY_CONTAINER_LENGTH+1];
    LPCTSTR pszContainer;

    if(pszKeyContainer == NULL)
    {
        //
        // Randomly create a key container
        //
        memset(szKeyContainer, 0, sizeof(szKeyContainer));

        _sntprintf(
                    szKeyContainer,
                    MAX_KEY_CONTAINER_LENGTH,
                    _TEXT("TlsContainer%d"),
                    GetCurrentThreadId()
                );

        pszContainer = szKeyContainer;
    }
    else
    {
        pszContainer = pszKeyContainer;
    }


    //
    // Delete the key container, ignore error here
    //
    CryptAcquireContext(
                    phCryptProv, 
                    pszContainer, 
                    DEFAULT_CSP, 
                    PROVIDER_TYPE, 
                    CRYPT_DELETEKEYSET
                );


    //
    // Re-create key container
    //
    if(!CryptAcquireContext(
                    phCryptProv, 
                    pszContainer, 
                    DEFAULT_CSP, 
                    PROVIDER_TYPE, 
                    0))
    {
        // Create default key container.
        if(!CryptAcquireContext(
                        phCryptProv, 
                        pszContainer, 
                        DEFAULT_CSP, 
                        PROVIDER_TYPE, 
                        CRYPT_NEWKEYSET)) 
        {
            dwStatus = GetLastError();
        }    
    }

    return dwStatus;
}


//////////////////////////////////////////////////////////////////

DWORD
TLSLoadSavedCryptKeyFromLsa(
    OUT PBYTE* ppbSignKey,
    OUT PDWORD pcbSignKey,
    OUT PBYTE* ppbExchKey,
    OUT PDWORD pcbExchKey
    )
/*++

++*/
{
    DWORD dwStatus;
    PBYTE pbSKey = NULL;
    DWORD cbSKey = 0;
    PBYTE pbEKey = NULL;
    DWORD cbEKey = 0;
    
    
    dwStatus = RetrieveKey(
                        LSERVER_LSA_PRIVATEKEY_EXCHANGE, 
                        &pbEKey, 
                        &cbEKey
                    );

    if(dwStatus == ERROR_SUCCESS)
    {
        dwStatus = RetrieveKey(
                            LSERVER_LSA_PRIVATEKEY_SIGNATURE, 
                            &pbSKey, 
                            &cbSKey
                        );
    }

    if(dwStatus != ERROR_SUCCESS)
    {
        if(pbEKey != NULL)
        {
            LocalFree(pbEKey);
        }
        
        if(pbSKey != NULL)
        {
            LocalFree(pbSKey);
        }
    }
    else
    {
        *ppbSignKey = pbSKey;
        *pcbSignKey = cbEKey;

        *ppbExchKey = pbEKey;
        *pcbExchKey = cbEKey;
    }

    return dwStatus;
}

//////////////////////////////////////////////////////////////////

DWORD
TLSSaveCryptKeyToLsa(
    IN PBYTE pbSignKey,
    IN DWORD cbSignKey,
    IN PBYTE pbExchKey,
    IN DWORD cbExchKey
    )

/*++

--*/

{
    DWORD dwStatus;

    //
    // Save the key to LSA.
    //
    dwStatus = StoreKey(
                        LSERVER_LSA_PRIVATEKEY_SIGNATURE, 
                        pbSignKey, 
                        cbSignKey
                    );

    if(dwStatus == ERROR_SUCCESS)
    {
        dwStatus = StoreKey(
                            LSERVER_LSA_PRIVATEKEY_EXCHANGE, 
                            pbExchKey, 
                            cbExchKey
                        );
    }

    return dwStatus;
}


/////////////////////////////////////////////////////////////////////////////

DWORD
TLSCryptGenerateNewKeys(
    OUT PBYTE* pbSignKey, 
    OUT DWORD* cbSignKey, 
    OUT PBYTE* pbExchKey, 
    OUT DWORD* cbExchKey
    )
/*++

Abstract:

    Generate a new pair of public/private key.  First randomly create 
    a key container and use it to create new keys.

Parameters:

    *pbSignKey : Pointer to PBYTE to receive new signature key.
    *cbSignKey : Pointer to DWORD to receive size of new sign. key.
    *pbExchKey : Pointer to PBYTE to receive new exchange key.
    *cbExchKey : Pointer to DWORD to receive size of new exchange key.

Return:

    ERROR_SUCCESS or CRYPTO Error Code.

--*/
{
    TCHAR       szKeyContainer[MAX_KEY_CONTAINER_LENGTH+1];
    HCRYPTPROV  hCryptProv = NULL;
    HCRYPTKEY   hSignKey = NULL;
    HCRYPTKEY   hExchKey = NULL;
    DWORD dwStatus;

    *pbSignKey = NULL;
    *pbExchKey = NULL;

    //
    // Randomly create a key container
    //
    memset(szKeyContainer, 0, sizeof(szKeyContainer));

    _sntprintf(
                szKeyContainer,
                MAX_KEY_CONTAINER_LENGTH,
                _TEXT("TlsContainer%d"),
                GetCurrentThreadId()
            );
            
    //
    // Delete this key container, ignore error.
    //
    CryptAcquireContext(
                    &hCryptProv, 
                    szKeyContainer, 
                    DEFAULT_CSP, 
                    PROVIDER_TYPE, 
                    CRYPT_DELETEKEYSET
                );

    //
    // Open a default key container
    //
    if(!CryptAcquireContext(
                        &hCryptProv, 
                        szKeyContainer, 
                        DEFAULT_CSP, 
                        PROVIDER_TYPE, 
                        CRYPT_NEWKEYSET
                    ))
    {
        TLSLogEvent(
                EVENTLOG_ERROR_TYPE,
                TLS_E_GENERATEKEYS,
                TLS_E_CRYPT_ACQUIRE_CONTEXT,
                dwStatus = GetLastError()
            );

        goto cleanup;
    }    

    //
    // Generate a signature public/private key pair
    //
    if(!CryptGetUserKey(hCryptProv, AT_SIGNATURE, &hSignKey)) 
    {
        dwStatus=GetLastError();

        if( GetLastError() != NTE_NO_KEY || 
            !CryptGenKey(hCryptProv, AT_SIGNATURE, CRYPT_EXPORTABLE, &hSignKey))
        {
            TLSLogEvent(
                    EVENTLOG_ERROR_TYPE,
                    TLS_E_GENERATEKEYS,
                    TLS_E_CRYPT_CREATE_KEY,
                    dwStatus=GetLastError()
                );
            goto cleanup;
        }
    }

    dwStatus = ERROR_SUCCESS;

    //
    // export the public/private key of signature key
    //
    if( !CryptExportKey(hSignKey, NULL, PRIVATEKEYBLOB, 0, *pbSignKey, cbSignKey) && 
        GetLastError() != ERROR_MORE_DATA)
    {
        TLSLogEvent(
                EVENTLOG_ERROR_TYPE,
                TLS_E_GENERATEKEYS,
                TLS_E_EXPORT_KEY,
                dwStatus=GetLastError()
            );

        goto cleanup;
    }

    *pbSignKey=(PBYTE)AllocateMemory(*cbSignKey);
    if(*pbSignKey == NULL)
    {
        TLSLogErrorEvent(TLS_E_ALLOCATE_MEMORY);
        dwStatus=GetLastError();
        goto cleanup;
    }

    if(!CryptExportKey(hSignKey, NULL, PRIVATEKEYBLOB, 0, *pbSignKey, cbSignKey))
    {
        TLSLogEvent(
                EVENTLOG_ERROR_TYPE,    
                TLS_E_GENERATEKEYS,
                TLS_E_EXPORT_KEY,
                dwStatus=GetLastError()
            );

        goto cleanup;
    }

    //
    // Generate a exchange public/private key pair
    if(!CryptGetUserKey(hCryptProv, AT_KEYEXCHANGE, &hExchKey)) 
    {
        dwStatus=GetLastError();

        if( GetLastError() != NTE_NO_KEY || 
            !CryptGenKey(hCryptProv, AT_KEYEXCHANGE, CRYPT_EXPORTABLE, &hExchKey)) 
        {
            TLSLogEvent(
                    EVENTLOG_ERROR_TYPE,
                    TLS_E_GENERATEKEYS,
                    TLS_E_CRYPT_CREATE_KEY,
                    dwStatus=GetLastError()
                );
            goto cleanup;
        }
    }

    dwStatus = ERROR_SUCCESS;

    //
    // export the public/private key of exchange key
    //
    if( !CryptExportKey(hExchKey, NULL, PRIVATEKEYBLOB, 0, *pbExchKey, cbExchKey) && 
        GetLastError() != ERROR_MORE_DATA)
    {
        TLSLogEvent(
                EVENTLOG_ERROR_TYPE,
                TLS_E_GENERATEKEYS,
                TLS_E_EXPORT_KEY,
                dwStatus=GetLastError()
            );
        goto cleanup;
    }

    *pbExchKey=(PBYTE)AllocateMemory(*cbExchKey);
    if(*pbExchKey == NULL)
    {
        TLSLogErrorEvent(TLS_E_ALLOCATE_MEMORY);
        dwStatus = GetLastError();
        goto cleanup;
    }

    if(!CryptExportKey(hExchKey, NULL, PRIVATEKEYBLOB, 0, *pbExchKey, cbExchKey))
    {
        TLSLogEvent(
                EVENTLOG_ERROR_TYPE,
                TLS_E_GENERATEKEYS,
                TLS_E_EXPORT_KEY,
                dwStatus=GetLastError()
            );
        goto cleanup;
    }


cleanup:

    if(hSignKey != NULL)
    {
        CryptDestroyKey(hSignKey);
    }

    if(hExchKey != NULL)
    {
        CryptDestroyKey(hExchKey);
    }

    if(hCryptProv)
    {
        CryptReleaseContext(hCryptProv, 0);
    }

    hCryptProv=NULL;

    //
    // Delete key container and ignore error
    //
    CryptAcquireContext(
                    &hCryptProv, 
                    szKeyContainer, 
                    DEFAULT_CSP, 
                    PROVIDER_TYPE, 
                    CRYPT_DELETEKEYSET
                );

    if(dwStatus != ERROR_SUCCESS)
    {
        FreeMemory(*pbSignKey);
        FreeMemory(*pbExchKey);
    }

    return dwStatus;
}

/////////////////////////////////////////////////////////////////////////////

DWORD
TLSImportSavedKey(
    IN HCRYPTPROV hCryptProv, 
    IN PBYTE      pbSignKey,
    IN DWORD      cbSignKey,
    IN PBYTE      pbExchKey,
    IN DWORD      cbExchKey,
    OUT HCRYPTKEY* pSignKey, 
    OUT HCRYPTKEY* pExchKey
    )
/*

*/
{
    DWORD status=ERROR_SUCCESS;

    if(!CryptImportKey(
                    hCryptProv, 
                    pbSignKey, 
                    cbSignKey, 
                    NULL, 
                    0, 
                    pSignKey
                ))
    {
        status = GetLastError();
        goto cleanup;
    }

    if(!CryptImportKey(
                    hCryptProv, 
                    pbExchKey, 
                    cbExchKey, 
                    NULL, 
                    0, 
                    pExchKey
                ))
    {
        status = GetLastError();
    }

cleanup:

    if(status != ERROR_SUCCESS)
    {
        TLSLogEvent(
                EVENTLOG_ERROR_TYPE,
                TLS_E_SERVICEINIT,
                TLS_E_CRYPT_IMPORT_KEY,
                status
            );
    }
    return status;    
}

/////////////////////////////////////////////////////////////////////////////

DWORD
TLSLoadSelfSignCertificates(
    IN HCRYPTPROV hCryptProv,
    IN PBYTE pbSPK,
    IN DWORD cbSPK,
    OUT PDWORD pcbSignCert, 
    OUT PBYTE* ppbSignCert, 
    OUT PDWORD pcbExchCert, 
    OUT PBYTE* ppbExchCert
    )
/*

Abstract:

    Create a self-signed signature/exchange certificate.

Parameters:

    pcbSignCert : Pointer to DWORD to receive size of sign. certificate.
    ppbSignCert : Pointer to PBYTE to receive self-signed sign. certificate.
    pcbExchCert : Pointer to DWORD to receive size of exch. certificate.
    ppbExchCert : Pointer to PBYTE to receive self-signed exch. certificate.

Returns:

    
*/
{
    DWORD status;
    DWORD dwDisposition;
    DWORD cbSign=0;
    PBYTE pbSign=NULL;
    DWORD cbExch=0;
    PBYTE pbExch=NULL;

    do {
        //
        // Create Signature and Exchange certificate
        //
        status=TLSCreateSelfSignCertificate(
                                hCryptProv,
                                AT_SIGNATURE, 
                                pbSPK,
                                cbSPK,
                                0,
                                NULL,
                                &cbSign, 
                                &pbSign
                            );
        if(status != ERROR_SUCCESS)
        {
            status=TLS_E_CREATE_SELFSIGN_CERT;
            break;
        }

        status=TLSCreateSelfSignCertificate(
                                hCryptProv,
                                AT_KEYEXCHANGE, 
                                pbSPK,
                                cbSPK,
                                0,
                                NULL,
                                &cbExch, 
                                &pbExch
                            );
        if(status != ERROR_SUCCESS)
        {
            status=TLS_E_CREATE_SELFSIGN_CERT;
            break;
        }

    } while(FALSE);

    if(status == ERROR_SUCCESS)
    {
        *pcbSignCert = cbSign;
        *ppbSignCert = pbSign;
        *pcbExchCert = cbExch;
        *ppbExchCert = pbExch;
    }
    else
    {
        FreeMemory(pbExch);
        FreeMemory(pbSign);
    }

    return status;
}

////////////////////////////////////////////////////////////////

DWORD
TLSLoadCHEndosedCertificate(
    PDWORD pcbSignCert, 
    PBYTE* ppbSignCert, 
    PDWORD pcbExchCert, 
    PBYTE* ppbExchCert
    )
/*

*/
{
    LONG status;

#if ENFORCE_LICENSING

    DWORD cbSign=0;
    PBYTE pbSign=NULL;
    DWORD cbExch=0;
    PBYTE pbExch=NULL;
    
    //
    // look into registry to see if our certificate is there
    //
    HKEY hKey=NULL;
    LPTSTR lpSubkey=LSERVER_SERVER_CERTIFICATE_REGKEY;

    do {
        status=RegOpenKeyEx(
                        HKEY_LOCAL_MACHINE,
                        lpSubkey,
                        0,
                        KEY_ALL_ACCESS,
                        &hKey
                    );
        if(status != ERROR_SUCCESS)
        {
            break;
        }

        //
        // Load Signature certificate
        //
        status = RegQueryValueEx(
                            hKey,
                            LSERVER_SIGNATURE_CERT_KEY,
                            NULL,
                            NULL,
                            NULL,
                            &cbSign
                        );

        if(status != ERROR_MORE_DATA && status != ERROR_SUCCESS)
        {
            break;
        }

        if(!(pbSign=(PBYTE)AllocateMemory(cbSign)))
        {
            status = GetLastError();
            break;
        }

        status = RegQueryValueEx(
                            hKey,
                            LSERVER_SIGNATURE_CERT_KEY,
                            NULL,
                            NULL,
                            pbSign,
                            &cbSign
                        );

        if(status != ERROR_SUCCESS)
        {
            break;
        }

        //
        // Load Exchange certificate
        //
        status = RegQueryValueEx(
                            hKey,
                            LSERVER_EXCHANGE_CERT_KEY,
                            NULL,
                            NULL,
                            NULL,
                            &cbExch
                        );
        if(status != ERROR_MORE_DATA && status != ERROR_SUCCESS)
        {
            break;
        }

        if(!(pbExch=(PBYTE)AllocateMemory(cbExch)))
        {
            status = GetLastError();
            break;
        }

        status = RegQueryValueEx(
                            hKey,
                            LSERVER_EXCHANGE_CERT_KEY,
                            NULL,
                            NULL,
                            pbExch,
                            &cbExch
                        );
        if(status != ERROR_SUCCESS)
        {
            break;
        }
    } while(FALSE);

    //
    // Must have both certificate
    //
    if(status == ERROR_SUCCESS && pbExch && pbSign)
    {
        *pcbSignCert = cbSign;
        *ppbSignCert = pbSign;

        *pcbExchCert = cbExch;
        *ppbExchCert = pbExch;
    }
    else
    {
        FreeMemory(pbExch);
        FreeMemory(pbSign);
        status = TLS_E_NO_CERTIFICATE;
    }

    if(hKey)
    {
        RegCloseKey(hKey);
    }
#else

    //
    // Non enfoce version always return no certificate
    //
    status = TLS_E_NO_CERTIFICATE;

#endif

    return status;
}

/////////////////////////////////////////////////////////////////////////////

DWORD 
TLSInstallLsCertificate( 
    DWORD cbLsSignCert, 
    PBYTE pbLsSignCert, 
    DWORD cbLsExchCert, 
    PBYTE pbLsExchCert
    )
/*

*/
{
    HKEY hKey=NULL;
    LONG status=ERROR_SUCCESS;
    DWORD dwDisposition;
    PCCERT_CONTEXT pCertContext=NULL;
    DWORD cbNameBlob=0;
    LPTSTR pbNameBlob=NULL;

#if ENFORCE_LICENSING

    do {
        status = RegCreateKeyEx(
                            HKEY_LOCAL_MACHINE,
                            LSERVER_SERVER_CERTIFICATE_REGKEY,
                            0,
                            NULL,
                            REG_OPTION_NON_VOLATILE,
                            KEY_ALL_ACCESS,
                            NULL,
                            &hKey,
                            &dwDisposition
                        );
        if(status != ERROR_SUCCESS)
        {
            TLSLogEvent(
                    EVENTLOG_ERROR_TYPE,
                    TLS_E_STORELSCERTIFICATE,
                    TLS_E_ACCESS_REGISTRY,
                    status
                );
            break;
        }

        if(pbLsExchCert)
        {
            status = RegSetValueEx(
                                hKey, 
                                LSERVER_EXCHANGE_CERT_KEY, 
                                0, 
                                REG_BINARY, 
                                pbLsExchCert, 
                                cbLsExchCert
                            );
            if(status != ERROR_SUCCESS)
            {
                TLSLogEvent(
                        EVENTLOG_ERROR_TYPE,
                        TLS_E_STORELSCERTIFICATE,
                        TLS_E_ACCESS_REGISTRY,
                        status
                    );

                break;
            }
        }


        if(pbLsSignCert)
        {
            status = RegSetValueEx(
                                hKey, 
                                LSERVER_SIGNATURE_CERT_KEY, 
                                0, 
                                REG_BINARY, 
                                pbLsSignCert, 
                                cbLsSignCert
                            );
            if(status != ERROR_SUCCESS)
            {
                TLSLogEvent(
                        EVENTLOG_ERROR_TYPE,
                        TLS_E_STORELSCERTIFICATE,
                        TLS_E_ACCESS_REGISTRY,
                        status
                    );

                break;
            }

            //
            // extract Subject field in exchange certificate and save i registry
            // When issuing new license, we need to use this as Issuer.
            //

            pCertContext = CertCreateCertificateContext(
                                                X509_ASN_ENCODING,
                                                pbLsSignCert,
                                                cbLsSignCert
                                            );

            cbNameBlob=CertNameToStr(
                                X509_ASN_ENCODING,
                                &pCertContext->pCertInfo->Subject,
                                CERT_X500_NAME_STR | CERT_NAME_STR_CRLF_FLAG,
                                NULL,
                                0
                            );
            if(cbNameBlob)
            {
                pbNameBlob=(LPTSTR)AllocateMemory((cbNameBlob+1) * sizeof(TCHAR));
                if(pbNameBlob)
                {
                    CertNameToStr(
                            X509_ASN_ENCODING,
                            &pCertContext->pCertInfo->Subject,
                            CERT_X500_NAME_STR | CERT_NAME_STR_CRLF_FLAG,
                            pbNameBlob,
                            cbNameBlob
                        );
                }
            }

            status = RegSetValueEx(
                            hKey, 
                            LSERVER_CLIENT_CERTIFICATE_ISSUER, 
                            0, 
                            REG_BINARY, 
                            (PBYTE)pbNameBlob, 
                            cbNameBlob+sizeof(TCHAR)
                        );
            if(status != ERROR_SUCCESS)
            {
                TLSLogEvent(
                        EVENTLOG_ERROR_TYPE,
                        TLS_E_STORELSCERTIFICATE,
                        TLS_E_ACCESS_REGISTRY,
                        status
                    );

                break;        
            }
        }

        if(hKey)
        {
            //
            // Close registry, got error while try to load it again???
            //
            RegCloseKey(hKey);
            hKey = NULL;
        }


        //
        // Only reload certificate when we have both
        //
        if(pbLsSignCert && pbLsExchCert)
        {
            //
            // All RPC calls are blocked.
            //
            FreeMemory(g_pbSignatureEncodedCert);
            FreeMemory(g_pbExchangeEncodedCert);
            g_cbSignatureEncodedCert = 0;
            g_cbExchangeEncodedCert = 0;
            //TLSLoadServerCertificate();
        }
    } while(FALSE);

    FreeMemory(pbNameBlob);

    if(pCertContext)
    {
        CertFreeCertificateContext(pCertContext);
    }
        
    if(hKey)
    {
        RegCloseKey(hKey);
    }

#endif

    return status;
}

////////////////////////////////////////////////////////////////

DWORD
TLSUninstallLsCertificate()
{
    HKEY hKey=NULL;
    DWORD status;

    status=RegOpenKeyEx(
                    HKEY_LOCAL_MACHINE,
                    LSERVER_SERVER_CERTIFICATE_REGKEY,
                    0,
                    KEY_ALL_ACCESS,
                    &hKey
                );
    if(status == ERROR_SUCCESS)
    {
        //
        // Ignore error     
        RegDeleteValue(    
                    hKey,
                    LSERVER_SIGNATURE_CERT_KEY
                );

        RegDeleteValue(
                    hKey,
                    LSERVER_EXCHANGE_CERT_KEY
                );

        RegDeleteValue(
                    hKey,
                    LSERVER_CLIENT_CERTIFICATE_ISSUER
                );
    }

    if(hKey != NULL)
    {
        RegCloseKey(hKey);
    }

    //
    // Delete all certificate in registry store including all backup
    // ignore error on deleting backup store.
    //
    TLSRegDeleteKey(
                HKEY_LOCAL_MACHINE,
                LSERVER_SERVER_CERTIFICATE_REGKEY_BACKUP1
            );

    TLSRegDeleteKey(
                HKEY_LOCAL_MACHINE,
                LSERVER_SERVER_CERTIFICATE_REGKEY_BACKUP2
            );

    status = TLSRegDeleteKey(
                        HKEY_LOCAL_MACHINE,
                        LSERVER_SERVER_CERTIFICATE_REGKEY
                    );

    return status;
}

/////////////////////////////////////////////////////////////////////////////

DWORD
TLSInitCryptoProv(
    IN LPCTSTR pszKeyContainer,
    IN PBYTE pbSignKey,
    IN DWORD cbSignKey,
    IN PBYTE pbExchKey,
    IN DWORD cbExchKey,
    OUT HCRYPTPROV* phCryptProv,
    OUT HCRYPTKEY* phSignKey,
    OUT HCRYPTKEY* phExchKey
    )
/*

Abstract:

    Routine to create a clean Crypto. Prov, generate a new pair of keys and 
    import these keys into newly created Crypt. prov.

Parameters:

    pszKeyContainer : Name of the key container.
    phCryptProv : Pointer to HCRYPTPROV to receive new handle to Crypto. prov.
    
*/
{
    DWORD dwStatus;

    if( pbSignKey == NULL || cbSignKey == NULL || 
        pbExchKey == NULL || cbExchKey == NULL ||
        phCryptProv == NULL || phSignKey == NULL ||
        phExchKey == NULL )
    {
        SetLastError(dwStatus = ERROR_INVALID_PARAMETER);
    }
    else
    {
        //
        // Initialize a clean Crypt.
        //    
        dwStatus = InitCryptoProv(
                            pszKeyContainer,
                            phCryptProv
                        );

        if(dwStatus == ERROR_SUCCESS)
        {
            //
            // Import Key into Crypt.
            //
            dwStatus = TLSImportSavedKey(
                                    *phCryptProv, 
                                    pbSignKey,
                                    cbSignKey,
                                    pbExchKey,
                                    cbExchKey,
                                    phSignKey, 
                                    phExchKey
                                );
        }
    }

    return dwStatus;
}

//-----------------------------------------------------------

DWORD
TLSVerifyCertChainInMomory( 
    IN HCRYPTPROV hCryptProv,
    IN PBYTE pbData, 
    IN DWORD cbData 
    )
/*++

Abstract:

    Verify PKCS7 certificate chain in memory.

Parameters:

    pbData : Input PKCS7 ceritifcate chain.
    cbData : size of pbData

Returns:


++*/
{
    PCCERT_CONTEXT  pCertContext=NULL;
    PCCERT_CONTEXT  pCertPrevContext=NULL;

    HCERTSTORE      hCertStore=NULL;
    DWORD           dwStatus=ERROR_SUCCESS;
    DWORD           dwLastVerification;
    CRYPT_DATA_BLOB Serialized;
    FILETIME        ft;

    if(hCryptProv == NULL || pbData == NULL || cbData == NULL)
    {
        SetLastError(dwStatus = ERROR_INVALID_PARAMETER);
        goto cleanup;
    }        

    Serialized.pbData = pbData;
    Serialized.cbData = cbData;

    hCertStore=CertOpenStore(
                        szLICENSE_BLOB_SAVEAS_TYPE,
                        X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
                        hCryptProv,
                        CERT_STORE_NO_CRYPT_RELEASE_FLAG,
                        &Serialized
                    );

    if(!hCertStore)
    {
        dwStatus=GetLastError();
        goto cleanup;
    }

    //
    // Enumerate all certificates.
    //
    dwStatus = ERROR_SUCCESS;

    do {
        pCertPrevContext = pCertContext;
        pCertContext = CertEnumCertificatesInStore(
                                            hCertStore,
                                            pCertPrevContext
                                        );

        if(pCertContext == NULL)
        {
            dwStatus = GetLastError();
            if(dwStatus == CRYPT_E_NOT_FOUND)
            {
                dwStatus = ERROR_SUCCESS;
                break;
            }
        }

        dwStatus = TLSVerifyCertChain(
                                hCryptProv,
                                hCertStore,
                                pCertContext,
                                &ft
                            );
    } while (pCertContext != NULL && dwStatus == ERROR_SUCCESS);

cleanup:

    if(pCertContext != NULL)
    {
        CertFreeCertificateContext(pCertContext);
    }

    if(hCertStore)
    {
        CertCloseStore(
                    hCertStore, 
                    CERT_CLOSE_STORE_FORCE_FLAG
                );
    }

    return dwStatus;
}

/////////////////////////////////////////////////////////////////////////////

DWORD
TLSRegDeleteKey(
    IN HKEY hRegKey,
    IN LPCTSTR pszSubKey
    )
/*++

Abstract:

    Recursively delete entire registry key.

Parameter:

    HKEY : 
    pszSubKey :

Returns:

    ERROR_SUCCESS or error code.

++*/
{
    DWORD dwStatus;
    HKEY hSubKey = NULL;
    int index;

    DWORD dwNumSubKeys;
    DWORD dwMaxSubKeyLength;
    DWORD dwSubKeyLength;
    LPTSTR pszSubKeyName = NULL;

    DWORD dwMaxValueNameLen;
    LPTSTR pszValueName = NULL;
    DWORD dwValueNameLength;


    dwStatus = RegOpenKeyEx(
                            hRegKey,
                            pszSubKey,
                            0,
                            KEY_ALL_ACCESS,
                            &hSubKey
                        );

    if(dwStatus != ERROR_SUCCESS)
    {
        // key does not exist
        return dwStatus;
    }

    //
    // Query number of subkeys
    //
    dwStatus = RegQueryInfoKey(
                            hSubKey,
                            NULL,
                            NULL,
                            NULL,
                            &dwNumSubKeys,
                            &dwMaxSubKeyLength,
                            NULL,
                            NULL,
                            &dwMaxValueNameLen,
                            NULL,
                            NULL,
                            NULL
                        );

    if(dwStatus != ERROR_SUCCESS)
    {
        goto cleanup;
    }

    dwMaxValueNameLen++;
    pszValueName = (LPTSTR)AllocateMemory(dwMaxValueNameLen * sizeof(TCHAR));
    if(pszValueName == NULL)
    {
        goto cleanup;
    }

    if(dwNumSubKeys > 0)
    {
        // allocate buffer for subkeys.

        dwMaxSubKeyLength++;
        pszSubKeyName = (LPTSTR)AllocateMemory(dwMaxSubKeyLength * sizeof(TCHAR));
        if(pszSubKeyName == NULL)
        {
            goto cleanup;
        }


        //for(index = 0; index < dwNumSubKeys; index++)
        for(;dwStatus == ERROR_SUCCESS;)
        {
            // delete this subkey.
            dwSubKeyLength = dwMaxSubKeyLength;
            memset(pszSubKeyName, 0, dwMaxSubKeyLength * sizeof(TCHAR));

            // retrieve subkey name
            dwStatus = RegEnumKeyEx(
                                hSubKey,
                                (DWORD)0,
                                pszSubKeyName,
                                &dwSubKeyLength,
                                NULL,
                                NULL,
                                NULL,
                                NULL
                            );

            if(dwStatus == ERROR_SUCCESS)
            {
                dwStatus = TLSRegDeleteKey( hSubKey, pszSubKeyName );
            }

            // ignore any error and continue on
        }
    }

cleanup:

    for(dwStatus = ERROR_SUCCESS; pszValueName != NULL && dwStatus == ERROR_SUCCESS;)
    {
        dwValueNameLength = dwMaxValueNameLen;
        memset(pszValueName, 0, dwMaxValueNameLen * sizeof(TCHAR));

        dwStatus = RegEnumValue(
                            hSubKey,
                            0,
                            pszValueName,
                            &dwValueNameLength,
                            NULL,
                            NULL,
                            NULL,
                            NULL
                        );

        if(dwStatus == ERROR_SUCCESS)
        {
            RegDeleteValue(hSubKey, pszValueName);
        }
    }   
                            
    // close the key before trying to delete it.
    if(hSubKey != NULL)
    {
        RegCloseKey(hSubKey);
    }

    // try to delete this key, will fail if any of the subkey
    // failed to delete in loop
    dwStatus = RegDeleteKey(
                            hRegKey,
                            pszSubKey
                        );



    if(pszValueName != NULL)
    {
        FreeMemory(pszValueName);
    }

    if(pszSubKeyName != NULL)
    {
        FreeMemory(pszSubKeyName);
    }

    return dwStatus;   
}    

/////////////////////////////////////////////////////////////////////////////

DWORD
TLSTreeCopyRegKey(
    IN HKEY hSourceRegKey,
    IN LPCTSTR pszSourceSubKey,
    IN HKEY hDestRegKey,
    IN LPCTSTR pszDestSubKey
    )
/*++

Abstract:

    Tree copy of a registry key to another.

Parameters:

    hSourceRegKey : Source registry key.
    pszSourceSubKey : Source subkey name.
    hDestRegKey : Destination key.
    pszDestSubKey : Destination key name

Returns:

    ERROR_SUCCESS or WIN32 error code.

Note:

    This routine doesn't deal with security...

++*/
{
    DWORD dwStatus;
    HKEY hSourceSubKey = NULL;
    HKEY hDestSubKey = NULL;
    int index;

    DWORD dwNumSubKeys;
    DWORD dwMaxSubKeyLength;
    DWORD dwSubKeyLength;
    LPTSTR pszSubKeyName = NULL;

    DWORD dwMaxValueNameLen;
    LPTSTR pszValueName = NULL;
    DWORD dwValueNameLength;
    DWORD dwNumValues = 0;
    DWORD dwMaxValueLength;
    PBYTE pbValue = NULL;

    DWORD dwDisposition;

    DWORD cbSecurityDescriptor;
    PSECURITY_DESCRIPTOR pSecurityDescriptor = NULL;


    //
    // Open source registry key, must exist
    //
    dwStatus = RegOpenKeyEx(
                            hSourceRegKey,
                            pszSourceSubKey,
                            0,
                            KEY_ALL_ACCESS,
                            &hSourceSubKey
                        );

    if(dwStatus != ERROR_SUCCESS)
    {
        // key does not exist
        goto cleanup;
    }

    //
    // Query number of subkeys
    //
    dwStatus = RegQueryInfoKey(
                            hSourceSubKey,
                            NULL,
                            NULL,
                            NULL,
                            &dwNumSubKeys,  // number of subkey
                            &dwMaxSubKeyLength, // max. subkey length
                            NULL,
                            &dwNumValues,
                            &dwMaxValueNameLen, // max. value length
                            &dwMaxValueLength,  // max. value size.
                            &cbSecurityDescriptor,  // size of security descriptor
                            NULL
                        );

    if(dwStatus != ERROR_SUCCESS)
    {
        goto cleanup;
    }

    #if 0

    //
    // TODO - get this to work, currently, we don't need security
    //
    if(cbSecurityDescriptor > 0)
    {
        //
        // Retrieve security descriptor for this key.
        //
        pSecurityDescriptor = (PSECURITY_DESCRIPTOR)AllocateMemory(cbSecurityDescriptor * sizeof(BYTE));
        if(pSecurityDescriptor == NULL)
        {
            dwStatus = GetLastError();
            goto cleanup;
        }

        dwStatus = RegGetKeySecurity(
                                hSourceSubKey,
                                OWNER_SECURITY_INFORMATION | DACL_SECURITY_INFORMATION,
                                pSecurityDescriptor,
                                &cbSecurityDescriptor
                            );

        if(dwStatus != ERROR_SUCCESS)
        {
            goto cleanup;
        }
    }
    #endif

    //
    // Create destination key
    //
    dwStatus = RegCreateKeyEx(
                            hDestRegKey,
                            pszDestSubKey,
                            0,
                            NULL,
                            REG_OPTION_NON_VOLATILE,
                            KEY_ALL_ACCESS,
                            NULL,
                            &hDestSubKey,
                            &dwDisposition
                        );

    if(dwStatus != ERROR_SUCCESS)
    {
        goto cleanup;
    }

    #if 0
    
    //
    // TODO - get this to work, currently, we don't need security.
    //

    if(pSecurityDescriptor != NULL)
    {
        dwStatus = RegSetKeySecurity(
                                hDestRegKey,
                                OWNER_SECURITY_INFORMATION | DACL_SECURITY_INFORMATION,
                                pSecurityDescriptor
                            );
        if(dwStatus != ERROR_SUCCESS)
        {
            goto cleanup;
        }

        if(pSecurityDescriptor != NULL)
        {
            FreeMemory(pSecurityDescriptor);
            pSecurityDescriptor = NULL;
        }
    }

    #endif

    //
    // Copy all subkeys first, we are doing recursive so copy subkey first will
    // save us some memory.
    //  
    if(dwNumSubKeys > 0)
    {
        // allocate buffer for subkeys.
        dwMaxSubKeyLength++;
        pszSubKeyName = (LPTSTR)AllocateMemory(dwMaxSubKeyLength * sizeof(TCHAR));
        if(pszSubKeyName == NULL)
        {
            dwStatus = GetLastError();
            goto cleanup;
        }

        for(index = 0, dwStatus = ERROR_SUCCESS; 
            dwStatus == ERROR_SUCCESS;
            index++)
        {
            dwSubKeyLength = dwMaxSubKeyLength;
            memset(pszSubKeyName, 0, dwMaxSubKeyLength * sizeof(TCHAR));

            // retrieve subkey name
            dwStatus = RegEnumKeyEx(
                                hSourceSubKey,
                                (DWORD)index,
                                pszSubKeyName,
                                &dwSubKeyLength,
                                NULL,
                                NULL,
                                NULL,
                                NULL
                            );

            if(dwStatus == ERROR_SUCCESS)
            {
                dwStatus = TLSTreeCopyRegKey(
                                        hSourceSubKey,
                                        pszSubKeyName,
                                        hDestSubKey,
                                        pszSubKeyName
                                    );
            }
        }

        if(dwStatus == ERROR_NO_MORE_ITEMS)
        {
            dwStatus = ERROR_SUCCESS;
        }
    }

    if(pszSubKeyName != NULL)
    {
        FreeMemory(pszSubKeyName);
        pszSubKeyName = NULL;
    }

    if(dwNumValues > 0)
    {
        //
        // allocate space for value name.
        //
        dwMaxValueNameLen++;
        pszValueName = (LPTSTR)AllocateMemory(dwMaxValueNameLen * sizeof(TCHAR));
        if(pszValueName == NULL)
        {
            dwStatus = GetLastError();
            goto cleanup;
        }

        //
        // allocate buffer for value
        //
        dwMaxValueLength += 2 * sizeof(TCHAR);    // in case of string
        pbValue = (PBYTE)AllocateMemory(dwMaxValueLength * sizeof(BYTE));
        if(pbValue == NULL)
        {
            dwStatus = GetLastError();
            goto cleanup;
        }


        // 
        // Copy all value first
        //
        for(index=0, dwStatus = ERROR_SUCCESS; 
            pszValueName != NULL && dwStatus == ERROR_SUCCESS;
            index ++)
        {
            DWORD dwValueType = 0;
            DWORD cbValue = dwMaxValueLength;

            dwValueNameLength = dwMaxValueNameLen;
            memset(pszValueName, 0, dwMaxValueNameLen * sizeof(TCHAR));

            dwStatus = RegEnumValue(
                                hSourceSubKey,
                                index,
                                pszValueName,
                                &dwValueNameLength,
                                NULL,
                                &dwValueType,
                                pbValue,
                                &cbValue
                            );

            if(dwStatus == ERROR_SUCCESS)
            {
                //
                // Copy value
                //
                dwStatus = RegSetValueEx(
                                    hDestSubKey,
                                    pszValueName,
                                    0,
                                    dwValueType,
                                    pbValue,
                                    cbValue
                                );
            }
        }

        if(dwStatus == ERROR_NO_MORE_ITEMS)
        {
            dwStatus = ERROR_SUCCESS;
        }

        if(dwStatus != ERROR_SUCCESS)
        {
            goto cleanup;
        }
    }

cleanup:
                            
    // close the key before trying to delete it.
    if(hSourceSubKey != NULL)
    {
        RegCloseKey(hSourceSubKey);
    }

    if(hDestSubKey != NULL)
    {
        RegCloseKey(hDestSubKey);
    }

    if(pszValueName != NULL)
    {
        FreeMemory(pszValueName);
    }

    if(pszSubKeyName != NULL)
    {
        FreeMemory(pszSubKeyName);
    }

    if(pbValue != NULL)
    {
        FreeMemory(pbValue);
    }

    if(pSecurityDescriptor != NULL)
    {
        FreeMemory(pSecurityDescriptor);
        pSecurityDescriptor = NULL;
    }

    return dwStatus;   
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\license\tlserver\server\tlsbkup.cpp ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996-1999
//
// File:        tlsbkup.cpp
//
// Contents:    
//              Backup/restore of database
//
// History:     
//  5/28/99     Created         RobLeit
//---------------------------------------------------------------------------
#include "pch.cpp"
#include "globals.h"
#include "init.h"

#define STRSAFE_NO_DEPRECATE
#include <strsafe.h>

extern "C" VOID ServiceStop();

static BOOL g_fDoingBackupRestore = FALSE;
static CCriticalSection g_csBackupRestore;

////////////////////////////////////////////////////////////////////////////
extern "C" HRESULT WINAPI
ExportTlsDatabase(
    )
/*++


--*/
{
    RPC_STATUS rpcStatus;
    HRESULT hr = S_OK;
    TCHAR szExportedDb[MAX_PATH+1];
    TCHAR *pszExportedDbEnd;
    size_t cbRemaining;

    if (g_fDoingBackupRestore)
    {
        return HRESULT_FROM_WIN32(ERROR_BUSY);
    }

    g_csBackupRestore.Lock();

    if (g_fDoingBackupRestore)
    {
        g_csBackupRestore.UnLock();

        return HRESULT_FROM_WIN32(ERROR_BUSY);
    }

    // ignore all call if service is shutting down
    if( IsServiceShuttingdown() == TRUE )
    {
        g_csBackupRestore.UnLock();

        return HRESULT_FROM_WIN32(ERROR_BUSY);
    }

    g_fDoingBackupRestore = TRUE;

    // Tell RPC threads to stop handling clients

    ServiceSignalShutdown();

    // Stop listening to other RPC interfaces

    (VOID)RpcServerUnregisterIf(TermServLicensing_v1_0_s_ifspec,
                          NULL,     // UUID
                          TRUE);    // Wait for calls to complete

    
    (VOID)RpcServerUnregisterIf(HydraLicenseService_v1_0_s_ifspec,
                          NULL,     // UUID
                          TRUE);    // Wait for calls to complete

    // Release handles to database
    TLSPrepareForBackupRestore();

    hr = StringCbCopyEx(szExportedDb,sizeof(szExportedDb),g_szDatabaseDir,&pszExportedDbEnd, &cbRemaining,0);

    if (FAILED(hr))
    {
        goto cleanup;
    }

    hr = StringCbCopyEx(pszExportedDbEnd,cbRemaining,TLSBACKUP_EXPORT_DIR,&pszExportedDbEnd, &cbRemaining,0);

    if (FAILED(hr))
    {
        goto cleanup;
    }

    CreateDirectoryEx(g_szDatabaseDir,
                      szExportedDb,
                      NULL);     // Ignore errors, they'll show up in CopyFile

    hr = StringCbCopyEx(pszExportedDbEnd,cbRemaining,_TEXT("\\"),&pszExportedDbEnd, &cbRemaining,0);

    if (FAILED(hr))
    {
        goto cleanup;
    }

    hr = StringCbCopyEx(pszExportedDbEnd,cbRemaining,g_szDatabaseFname,NULL,NULL,0);

    if (FAILED(hr))
    {
        goto cleanup;
    }

    // Copy database file
    if (!CopyFile(g_szDatabaseFile,szExportedDb,FALSE))
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto cleanup;
    }

cleanup:

    // Restart RPC and work manager
    ServiceResetShutdownEvent();

    // Restart after backup
    hr = TLSRestartAfterBackupRestore(TRUE);
    if( ERROR_SUCCESS != hr )
    {
        // force a shutdown...
        ServiceSignalShutdown();
        ServiceStop();
    }
    else
    {

        // Begin listening again

        hr = RpcServerRegisterIf(TermServLicensing_v1_0_s_ifspec,
                        NULL,
                        NULL);

        if(SUCCEEDED(hr))
        {
            hr = RpcServerRegisterIf(HydraLicenseService_v1_0_s_ifspec,
                            NULL,
                            NULL);
        }
        if(FAILED(hr))
        {
            // force a shutdown...
            ServiceSignalShutdown();
            ServiceStop();
        }
    }

    g_fDoingBackupRestore = FALSE;

    g_csBackupRestore.UnLock();

    return hr;
}

////////////////////////////////////////////////////////////////////////////
extern "C" HRESULT WINAPI
ImportTlsDatabase(
    )
/*++


--*/
{
    HRESULT hr = S_OK;

    if (g_fDoingBackupRestore)
    {
        return HRESULT_FROM_WIN32(ERROR_BUSY);
    }

    g_csBackupRestore.Lock();

    if (g_fDoingBackupRestore)
    {
        g_csBackupRestore.UnLock();

        return HRESULT_FROM_WIN32(ERROR_BUSY);
    }

    // ignore all call if service is shutting down
    if( IsServiceShuttingdown() == TRUE )
    {
        g_csBackupRestore.UnLock();

        return HRESULT_FROM_WIN32(ERROR_BUSY);
    }


    g_fDoingBackupRestore = TRUE;

    // Tell RPC threads to stop handling clients

    ServiceSignalShutdown();

    // Stop listening to other RPC interfaces

    (VOID)RpcServerUnregisterIf(TermServLicensing_v1_0_s_ifspec,
                          NULL,     // UUID
                          TRUE);    // Wait for calls to complete

    
    (VOID)RpcServerUnregisterIf(HydraLicenseService_v1_0_s_ifspec,
                          NULL,     // UUID
                          TRUE);    // Wait for calls to complete

    TLSPrepareForBackupRestore();

    // Restart RPC
    ServiceResetShutdownEvent();

    // not restart after backup
    hr = TLSRestartAfterBackupRestore(FALSE);

    if( ERROR_SUCCESS != hr )
    {
        // force a shutdown...
        ServiceSignalShutdown();
        ServiceStop();
    }
    else
    {
        // Begin listening again

        hr = RpcServerRegisterIf(TermServLicensing_v1_0_s_ifspec,
                        NULL,
                        NULL);

        if(SUCCEEDED(hr))
        {
            hr = RpcServerRegisterIf(HydraLicenseService_v1_0_s_ifspec,
                            NULL,
                            NULL);
        }
        if(FAILED(hr))
        {
            // force a shutdown...
            ServiceSignalShutdown();
            ServiceStop();
        }
    }

    g_fDoingBackupRestore = FALSE;

    g_csBackupRestore.UnLock();

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\license\tlserver\server\wkstore.cpp ===
//+--------------------------------------------------------------------------
//
// Copyright (c) 1997-1999 Microsoft Corporation
//
// File:        wkstore.cpp
//
// Contents:    Persistent job store routine.    
//
// History:     
//
//---------------------------------------------------------------------------
#include "pch.cpp"
#include "server.h"
#include "jobmgr.h"
#include "tlsjob.h"
#include "wkstore.h"
#include "debug.h"


WORKOBJECTINITFUNC g_WorkObjectInitFunList[] = {
    {WORKTYPE_RETURN_LICENSE, InitializeCReturnWorkObject } 
};

DWORD g_NumWorkObjectInitFunList = sizeof(g_WorkObjectInitFunList) / sizeof(g_WorkObjectInitFunList[0]);



//---------------------------------------------------
//
CLASS_PRIVATE
CWorkObject* 
CPersistentWorkStorage::InitializeWorkObject(
    IN DWORD dwWorkType,
    IN PBYTE pbData,
    IN DWORD cbData
    )
/*++

--*/
{
    DBGPrintf(
            DBG_INFORMATION,
            DBG_FACILITY_WORKMGR,
            DBGLEVEL_FUNCTION_TRACE,
            _TEXT("CPersistentWorkStorage::InitializeWorkObject() initializing work %d\n"),
            dwWorkType
        );

    CWorkObject* ptr = NULL;
    DWORD dwStatus = ERROR_SUCCESS;

    for(DWORD index =0; index < g_NumWorkObjectInitFunList; index ++)
    {
        if(dwWorkType == g_WorkObjectInitFunList[index].m_WorkType)
        {
            ptr = (g_WorkObjectInitFunList[index].m_WorkInitFunc)(
                                                            GetWorkManager(),
                                                            pbData,
                                                            cbData
                                                        );

            break;
        }
    }

    if(index >= g_NumWorkObjectInitFunList)
    {
        SetLastError(dwStatus = TLS_E_WORKSTORAGE_UNKNOWNWORKTYPE);
    }
    else
    {
        TLSWorkManagerSetJobDefaults(ptr);
    }    


    if(dwStatus != ERROR_SUCCESS)
    {
        DBGPrintf(
                DBG_ERROR,
                DBG_FACILITY_WORKMGR,
                DBGLEVEL_FUNCTION_DETAILSIMPLE,
                _TEXT("CPersistentWorkStorage::InitializeWorkObject() return 0x%08x\n"),
                dwStatus
            );
    }

    return ptr;
}


//---------------------------------------------------
//
CLASS_PRIVATE BOOL
CPersistentWorkStorage::DeleteWorkObject(
    IN OUT CWorkObject* ptr
    )
/*++

--*/
{
    DWORD dwStatus = ERROR_SUCCESS;
    DWORD dwWorkType = 0;

    DBGPrintf(
            DBG_INFORMATION,
            DBG_FACILITY_WORKMGR,
            DBGLEVEL_FUNCTION_TRACE,
            _TEXT("CPersistentWorkStorage::DeleteWorkObject() deleting work %s\n"),
            ptr->GetJobDescription()
        );

    dwWorkType = ptr->GetWorkType();
    ptr->SelfDestruct();

    if(dwStatus != ERROR_SUCCESS)
    {
        DBGPrintf(
                DBG_ERROR,
                DBG_FACILITY_WORKMGR,
                DBGLEVEL_FUNCTION_DETAILSIMPLE,
                _TEXT("CPersistentWorkStorage::DeleteWorkObject() return 0x%08x\n"),
                dwStatus
            );
    }

    return dwStatus == ERROR_SUCCESS;
}

//---------------------------------------------------
//
CPersistentWorkStorage::CPersistentWorkStorage(
    IN WorkItemTable* pWkItemTable
    ) :
m_pWkItemTable(pWkItemTable),
m_dwNumJobs(0),
m_dwJobsInProcesssing(0),
m_dwNextJobTime(INFINITE),   
m_pNextWorkObject(NULL)
/*++

--*/
{
}

//---------------------------------------------------
//
CPersistentWorkStorage::~CPersistentWorkStorage()
{
    // just make sure we have shutdown
    // TLSASSERT(m_pWkItemTable == NULL); 
}

//---------------------------------------------------
//
BOOL
CPersistentWorkStorage::DeleteErrorJob(
    IN CWorkObject* ptr
    )
/*++

--*/
{
    BOOL bSuccess = TRUE;
    DWORD dwStatus = ERROR_SUCCESS;
    PBYTE pbBookmark;
    DWORD cbBookmark;
    DWORD dwTime;
    DWORD dwJobType;


    if(IsValidWorkObject(ptr) == FALSE)
    {
        SetLastError(dwStatus = ERROR_INVALID_PARAMETER);
        goto cleanup;
    }

    bSuccess = ptr->GetJobId(&pbBookmark, &cbBookmark);
    if(bSuccess == FALSE)
    {
        SetLastError(dwStatus = ERROR_INVALID_DATA);
        goto cleanup;
    }

    dwJobType = ptr->GetWorkType();

    m_hTableLock.Lock();

    bSuccess = UpdateWorkItemEntry(
                            m_pWkItemTable,
                            WORKITEM_DELETE,
                            pbBookmark,
                            cbBookmark,
                            INFINITE,
                            INFINITE,
                            dwJobType,
                            NULL,
                            0
                        );

    if(bSuccess == FALSE)
    {
        dwStatus = GetLastError();
    }
    
    m_hTableLock.UnLock();
    DeleteWorkObject(ptr);

cleanup:

    return bSuccess;
}

//---------------------------------------------------
//
CLASS_PRIVATE DWORD
CPersistentWorkStorage::GetCurrentBookmark(
    IN WorkItemTable* pTable,
    IN PBYTE pbData,
    IN OUT PDWORD pcbData
    )
/*++

    
--*/
{
    BOOL bSuccess = TRUE;
    DWORD dwStatus = ERROR_SUCCESS;

    if(pTable != NULL)
    {
        JET_ERR jbError;
        
        bSuccess = pTable->GetBookmark(pbData, pcbData);
        if(bSuccess == FALSE)
        {
            jbError = pTable->GetLastJetError();
            if(jbError == JET_errNoCurrentRecord)
            {
                *pcbData = 0;
                SetLastError(dwStatus = ERROR_NO_DATA);
            }
            else if(jbError == JET_errBufferTooSmall)
            {
                SetLastError(dwStatus = ERROR_INSUFFICIENT_BUFFER);
            }
            else
            {
                SetLastError(dwStatus = SET_JB_ERROR(jbError));
            }
        }
    }
    else
    {
        SetLastError(dwStatus = ERROR_INVALID_PARAMETER);
        TLSASSERT(FALSE); 
    }

    return dwStatus;
}

//-------------------------------------------------------------
//
CLASS_PRIVATE DWORD
CPersistentWorkStorage::GetCurrentBookmarkEx(
    IN WorkItemTable* pTable,
    IN OUT PBYTE* ppbData,
    IN OUT PDWORD pcbData
    )
/*++

--*/
{
    DWORD dwStatus = ERROR_SUCCESS;
    BOOL bSucess = TRUE;

    if(ppbData == NULL || pcbData == NULL || pTable == 0)
    {
        SetLastError(dwStatus = ERROR_INVALID_PARAMETER);   
        return dwStatus;
    }

    *ppbData = NULL;
    *pcbData = 0;

    dwStatus = GetCurrentBookmark(
                            pTable, 
                            *ppbData, 
                            pcbData
                        );
    

    if(dwStatus == ERROR_INSUFFICIENT_BUFFER)
    {
        *ppbData = (PBYTE)AllocateMemory(*pcbData);
        if(*ppbData != NULL)
        {
            dwStatus = GetCurrentBookmark(
                                    pTable, 
                                    *ppbData, 
                                    pcbData
                                );
        }
    }

    if(dwStatus != ERROR_SUCCESS)
    {
        if(*ppbData != NULL)
        {
            FreeMemory(*ppbData);
        }

        *ppbData = NULL;
        *pcbData = 0;
    }

    return dwStatus;
}

//------------------------------------------------------
CLASS_PRIVATE DWORD
CPersistentWorkStorage::SetCurrentBookmark(
    IN WorkItemTable* pTable,
    IN PBYTE pbData,
    IN DWORD cbData
    )
/*++

--*/
{
    BOOL bSuccess;
    DWORD dwStatus = ERROR_SUCCESS;

    if(pTable != NULL && pbData != NULL && cbData != 0)
    {
        bSuccess = pTable->GotoBookmark(pbData, cbData);
        if(bSuccess == FALSE)
        {
            if(pTable->GetLastJetError() == JET_errRecordDeleted)
            {
                SetLastError(dwStatus = ERROR_NO_DATA);
            }
            else
            {
                SetLastError(dwStatus = SET_JB_ERROR(pTable->GetLastJetError()));
            }
        }
    }
    else
    {
        SetLastError(dwStatus = ERROR_INVALID_PARAMETER);
        TLSASSERT(FALSE);
    }

    return dwStatus;
}

//---------------------------------------------------
//
BOOL
CPersistentWorkStorage::Shutdown()
{
    BOOL bSuccess = TRUE;

    //
    // CWorkManager will make sure 
    // no job is in processing state before calling this
    // routine and no job can be scheduled.
    //
    m_hTableLock.Lock();

    //
    // Timing.
    //
    TLSASSERT(m_dwJobsInProcesssing == 0);

    if(m_pWkItemTable != NULL)
    {
        bSuccess = m_pWkItemTable->CloseTable();
        m_pWkItemTable = NULL;
    }

    TLSASSERT(bSuccess == TRUE);
    
    m_pWkItemTable = NULL;
    m_dwNumJobs = 0;
    m_dwNextJobTime = INFINITE;

    if(m_pNextWorkObject != NULL)
    {
        DeleteWorkObject( m_pNextWorkObject );
        m_pNextWorkObject = NULL;   
    }

    m_hTableLock.UnLock();
    return bSuccess;
}

//---------------------------------------------------
//
DWORD
CPersistentWorkStorage::StartupUpdateExistingJobTime()
{
    BOOL bSuccess;
    DWORD dwStatus = ERROR_SUCCESS;
    DWORD dwTime;
    DWORD dwMinTime = INFINITE;

    // CWorkObject* ptr = NULL;

    BOOL bValidJob = TRUE;
    DWORD dwCurrentTime;
    
    m_hTableLock.Lock();
    
    // 
    //
    bSuccess = m_pWkItemTable->MoveToRecord(JET_MoveFirst);
    if(bSuccess == FALSE)
    {
        SetLastError(dwStatus = SET_JB_ERROR(m_pWkItemTable->GetLastJetError()));
    }

    while(dwStatus == ERROR_SUCCESS)
    {
        WORKITEMRECORD wkItem;

        //if(ptr != NULL)
        //{
        //    DeleteWorkObject(ptr);
        //    ptr = NULL;
        //}
        bValidJob = FALSE;

        //
        // fetch the record
        //
        bSuccess = m_pWkItemTable->FetchRecord(wkItem);
        if(bSuccess == FALSE)
        {
            SetLastError(dwStatus = SET_JB_ERROR(m_pWkItemTable->GetLastJetError()));
            continue;
        }

        if(wkItem.dwRestartTime != INFINITE && wkItem.dwScheduledTime >= m_dwStartupTime)
        {
            if(wkItem.dwScheduledTime < dwMinTime)
            {
                dwMinTime = wkItem.dwScheduledTime;
            }

            break;
        }

        //
        // invalid data
        //
        if(wkItem.cbData != 0 && wkItem.pbData != NULL)
        {
            if(wkItem.dwRestartTime != INFINITE)
            {
                wkItem.dwScheduledTime = wkItem.dwRestartTime + time(NULL);
                wkItem.dwJobType &= ~WORKTYPE_PROCESSING;
                bSuccess = m_pWkItemTable->UpdateRecord(
                                                    wkItem, 
                                                    WORKITEM_PROCESS_JOBTIME | WORKITEM_PROCESS_JOBTYPE
                                                );
                if(bSuccess == FALSE)
                {
                    SetLastError(dwStatus = SET_JB_ERROR(m_pWkItemTable->GetLastJetError()));
                    break;
                }

                if(wkItem.dwScheduledTime < dwMinTime)
                {
                    dwMinTime = wkItem.dwScheduledTime;
                }

                bValidJob = TRUE;
            }
        }

        if(bValidJob == FALSE)
        {
            m_pWkItemTable->DeleteRecord();
        }

        // move the record pointer
        bSuccess = m_pWkItemTable->MoveToRecord();
        if(bSuccess == FALSE)
        {
            JET_ERR jetErrCode;

            jetErrCode = m_pWkItemTable->GetLastJetError();
            if(jetErrCode != JET_errNoCurrentRecord)
            {
                SetLastError(dwStatus = SET_JB_ERROR(jetErrCode));
            }

            break;
        }
    }

    if(dwStatus == ERROR_SUCCESS)
    {
        bSuccess = m_pWkItemTable->MoveToRecord(JET_MoveFirst);
        if(bSuccess == FALSE)
        {
            SetLastError(dwStatus = SET_JB_ERROR(m_pWkItemTable->GetLastJetError()));
        }

        UpdateNextJobTime(dwMinTime); 
    }

    m_hTableLock.UnLock();

    //if(ptr != NULL)
    //{
    //    DeleteWorkObject(ptr);
    //    ptr = NULL;
    //}

    return dwStatus;
}

//---------------------------------------------------
//

BOOL
CPersistentWorkStorage::Startup(
    IN CWorkManager* pWkMgr
    )
/*++

--*/
{
    BOOL bSuccess;
    DWORD dwStatus = ERROR_SUCCESS;

    CWorkStorage::Startup(pWkMgr);

    if(IsGood() == TRUE)
    {
        //
        // loop thru all workitem and count number of job
        //
        m_hTableLock.Lock();

        m_dwStartupTime = time(NULL);


        //
        // Get number of job in queue
        //

        //
        // GetCount() will set index to time column
        m_dwNumJobs = m_pWkItemTable->GetCount(
                                        FALSE,
                                        0,
                                        NULL
                                    );

        if(m_dwNumJobs == 0)
        {
            UpdateNextJobTime(INFINITE);
        }
        else
        {   
            bSuccess = m_pWkItemTable->BeginTransaction();
            if(bSuccess == TRUE)
            {
                dwStatus = StartupUpdateExistingJobTime();
                    
                if(dwStatus == ERROR_SUCCESS)
                {
                    m_pWkItemTable->CommitTransaction();
                }
                else
                {
                    m_pWkItemTable->RollbackTransaction();
                }
            }
            else
            {
                dwStatus = GetLastError();
            }

            //
            // constructor set next job time to 0 so
            // work manager will immediately try to find next job
            //
            // Move to first record in table
            //bSuccess = m_pWkItemTable->MoveToRecord(JET_MoveFirst);
        }        

        m_hTableLock.UnLock();
    }
    else
    {
        SetLastError(dwStatus = ERROR_INVALID_PARAMETER);
    }

    return (dwStatus == ERROR_SUCCESS);
}

//----------------------------------------------------
//
CLASS_PRIVATE BOOL
CPersistentWorkStorage::IsValidWorkObject(
    CWorkObject* ptr
    )
/*++

--*/
{
    BOOL bSuccess = FALSE;
    DWORD dwJobType;
    PBYTE pbData;
    DWORD cbData;

    //
    // Validate input parameter
    //
    if(ptr == NULL)
    {
        TLSASSERT(FALSE);
        goto cleanup;
    }

    dwJobType = ptr->GetWorkType();
    if(dwJobType == WORK_TYPE_UNKNOWN)
    {
        TLSASSERT(FALSE);
        goto cleanup;
    }
        
    ptr->GetWorkObjectData(&pbData, &cbData);
    if(pbData == NULL || cbData == 0)
    {
        TLSASSERT(pbData != NULL && cbData != NULL);
        goto cleanup;
    }

    bSuccess = TRUE;

cleanup:

    return bSuccess;
}

//----------------------------------------------------
//
BOOL
CPersistentWorkStorage::IsGood()
{
    if( m_pWkItemTable == NULL || 
        m_hTableLock.IsGood() == FALSE ||
        GetWorkManager() == NULL )
    {
        return FALSE;
    }

    return m_pWkItemTable->IsValid();
}

//----------------------------------------------------
//
CLASS_PRIVATE BOOL
CPersistentWorkStorage::UpdateJobEntry(
    IN WorkItemTable* pTable,
    IN PBYTE pbBookmark,
    IN DWORD cbBookmark,
    IN WORKITEMRECORD& wkItem
    )
/*++

--*/
{
    BOOL bSuccess = TRUE;
    DWORD dwStatus = ERROR_SUCCESS;

    dwStatus = SetCurrentBookmark(
                            pTable,
                            pbBookmark,
                            cbBookmark
                        );


    if(dwStatus == ERROR_SUCCESS)
    {
        bSuccess = pTable->UpdateRecord(wkItem);
    }
    else
    {
        bSuccess = FALSE;
        TLSASSERT(dwStatus == ERROR_SUCCESS);
    }

    return bSuccess;
}

//----------------------------------------------------
//

CLASS_PRIVATE BOOL
CPersistentWorkStorage::AddJobEntry(
    IN WorkItemTable* pTable,
    IN WORKITEMRECORD& wkItem
    )
/*++


--*/
{
    BOOL bSuccess;

    bSuccess = pTable->InsertRecord(wkItem);
    if(bSuccess == TRUE)
    {
        m_dwNumJobs++;
    }

    return bSuccess;
}

//----------------------------------------------------
//

CLASS_PRIVATE BOOL
CPersistentWorkStorage::DeleteJobEntry(
    IN WorkItemTable* pTable,
    IN PBYTE pbBookmark,
    IN DWORD cbBookmark,
    IN WORKITEMRECORD& wkItem
    )
/*++


--*/
{
    BOOL bSuccess = TRUE;
    DWORD dwStatus = ERROR_SUCCESS;


    dwStatus = SetCurrentBookmark(
                            pTable,
                            pbBookmark,
                            cbBookmark
                        );


    if(dwStatus == ERROR_SUCCESS)
    {
        bSuccess = pTable->DeleteRecord();

        if(bSuccess == TRUE)
        {
            m_dwNumJobs--;
        }
    }
    else
    {
        bSuccess = FALSE;
        TLSASSERT(dwStatus == ERROR_SUCCESS);
    }

    return bSuccess;
}
                                 
//----------------------------------------------------
//
CLASS_PRIVATE BOOL
CPersistentWorkStorage::UpdateWorkItemEntry(
    IN WorkItemTable* pTable,
    IN WORKITEM_OPERATION opCode,
    IN PBYTE pbBookmark,
    IN DWORD cbBookmark,
    IN DWORD dwRestartTime,
    IN DWORD dwTime,
    IN DWORD dwJobType,
    IN PBYTE pbJobData,
    IN DWORD cbJobData
    )
/*++


--*/
{
    BOOL bSuccess = TRUE;
    DWORD dwStatus = ERROR_SUCCESS;
    WORKITEMRECORD item;
    PBYTE   pbCurrentBookmark=NULL;
    DWORD  cbCurrentBookmark=0;


    m_hTableLock.Lock();

    dwStatus = GetCurrentBookmarkEx(
                                pTable,
                                &pbCurrentBookmark,
                                &cbCurrentBookmark
                            );

    if(dwStatus != ERROR_SUCCESS && dwStatus != ERROR_NO_DATA)
    {
        goto cleanup;
    }

    bSuccess = pTable->BeginTransaction();
    if(bSuccess == FALSE)
    {
        dwStatus = GetLastError();
        goto cleanup;
    }


    item.dwScheduledTime = dwTime;
    item.dwRestartTime = dwRestartTime;
    item.dwJobType = dwJobType;
    item.cbData = cbJobData;
    item.pbData = pbJobData;

    switch(opCode)
    {
        case WORKITEM_ADD:
            TLSASSERT(cbJobData != 0 && pbJobData != NULL);
            m_pWkItemTable->SetInsertRepositionBookmark(
                                                (dwTime < (DWORD)m_dwNextJobTime)
                                            );

            bSuccess = AddJobEntry(
                                pTable,
                                item
                            );

            break;

        case WORKITEM_BEGINPROCESSING:
            item.dwJobType |= WORKTYPE_PROCESSING;
            //
            // FALL THRU
            //
            
        case WORKITEM_RESCHEDULE:
            TLSASSERT(cbJobData != 0 && pbJobData != NULL);
            bSuccess = UpdateJobEntry(
                                pTable,
                                pbBookmark,
                                cbBookmark,
                                item
                            );
            break;

        case WORKITEM_DELETE:
            bSuccess = DeleteJobEntry(
                                pTable,
                                pbBookmark,
                                cbBookmark,
                                item
                            );
            break;

        default:

            TLSASSERT(FALSE);
            bSuccess = FALSE;
    }

    if(bSuccess == TRUE)
    {
        pTable->CommitTransaction();
        dwStatus = ERROR_SUCCESS;

        //
        // constructor set time to first job 0 so that work manager can immediate kick off
        //
        if( (opCode != WORKITEM_ADD && opCode != WORKITEM_RESCHEDULE) || dwTime > (DWORD)m_dwNextJobTime ) 
        {
            if(pbCurrentBookmark != NULL && cbCurrentBookmark != 0)
            {
                dwStatus = SetCurrentBookmark(
                                    pTable,
                                    pbCurrentBookmark,
                                    cbCurrentBookmark
                                );

                if(dwStatus == ERROR_NO_DATA)
                {
                    // record already deleted
                    dwStatus = ERROR_SUCCESS;
                }
                else
                {
                    TLSASSERT(dwStatus == ERROR_SUCCESS);
                }
            }
        }
        else
        {
            UpdateNextJobTime(dwTime);
        }
    }
    else
    {
        SetLastError(dwStatus = SET_JB_ERROR(pTable->GetLastJetError()));
        pTable->RollbackTransaction();
        TLSASSERT(FALSE);
    }

cleanup:

    m_hTableLock.UnLock();

    if(pbCurrentBookmark != NULL)
    {
        FreeMemory(pbCurrentBookmark);
    }

    //
    // WORKITEMRECORD will try to cleanup memory
    //
    item.pbData = NULL;
    item.cbData = 0;

    return dwStatus == ERROR_SUCCESS;
}
  
//----------------------------------------------------
//
BOOL
CPersistentWorkStorage::AddJob(
    IN DWORD dwTime,
    IN CWorkObject* ptr
    )
/*++

--*/
{
    DWORD dwStatus = ERROR_SUCCESS;
    BOOL bSuccess = TRUE;
    PBYTE pbData;
    DWORD cbData;


    DBGPrintf(
            DBG_INFORMATION,
            DBG_FACILITY_WORKMGR,
            DBGLEVEL_FUNCTION_TRACE,
            _TEXT("CPersistentWorkStorage::AddJob() scheduling job %s at time %d\n"),
            ptr->GetJobDescription(),
            dwTime
        );

    if(IsValidWorkObject(ptr) == FALSE)
    {
        SetLastError(dwStatus = ERROR_INVALID_PARAMETER);
        goto cleanup;
    }

    bSuccess = ptr->GetWorkObjectData(&pbData, &cbData);
    if(bSuccess == FALSE)
    {
        SetLastError(dwStatus = ERROR_INVALID_PARAMETER);
        goto cleanup;
    }

    m_hTableLock.Lock();

    if(m_pWkItemTable != NULL)
    {
        bSuccess = UpdateWorkItemEntry(
                                m_pWkItemTable,
                                WORKITEM_ADD,
                                NULL,
                                0,
                                ptr->GetJobRestartTime(),
                                dwTime + time(NULL),
                                ptr->GetWorkType(),
                                pbData,
                                cbData
                            );

        if(bSuccess == FALSE)
        {
            dwStatus = GetLastError();
        }
    }
    
    m_hTableLock.UnLock();

cleanup:

    // Let Calling function delete it.
    // DeleteWorkObject(ptr);

    return dwStatus == ERROR_SUCCESS;
}

//----------------------------------------------------
//
BOOL
CPersistentWorkStorage::RescheduleJob(
    CWorkObject* ptr
    )
/*++

--*/
{
    BOOL bSuccess = TRUE;
    DWORD dwStatus = ERROR_SUCCESS;
    PBYTE pbData;
    DWORD cbData;
    PBYTE pbBookmark;
    DWORD cbBookmark;
    DWORD dwTime;
    DWORD dwJobType;

    DBGPrintf(
            DBG_INFORMATION,
            DBG_FACILITY_WORKMGR,
            DBGLEVEL_FUNCTION_TRACE,
            _TEXT("CPersistentWorkStorage::RescheduleJob() scheduling job %s\n"),
            ptr->GetJobDescription()
        );

    if(IsValidWorkObject(ptr) == FALSE)
    {
        SetLastError(dwStatus = ERROR_INVALID_PARAMETER);
        goto cleanup;
    }

    bSuccess = ptr->GetWorkObjectData(&pbData, &cbData);
    if(bSuccess == FALSE)
    {
        SetLastError(dwStatus = ERROR_INVALID_DATA);
        goto cleanup;
    }

    bSuccess = ptr->GetJobId(&pbBookmark, &cbBookmark);
    if(bSuccess == FALSE)
    {
        SetLastError(dwStatus = ERROR_INVALID_DATA);
        goto cleanup;
    }
    
    dwTime = ptr->GetSuggestedScheduledTime();
    dwJobType = ptr->GetWorkType();

    m_hTableLock.Lock();

    if(m_pWkItemTable != NULL)
    {
        bSuccess = UpdateWorkItemEntry(
                                m_pWkItemTable,
                                (dwTime == INFINITE) ?  WORKITEM_DELETE : WORKITEM_RESCHEDULE,
                                pbBookmark,
                                cbBookmark,
                                ptr->GetJobRestartTime(),
                                (dwTime == INFINITE) ? dwTime : dwTime + time(NULL),
                                dwJobType,
                                pbData,
                                cbData
                            );

        if(bSuccess == FALSE)
        {
            dwStatus = GetLastError();
        }
    }
    
    m_hTableLock.UnLock();

cleanup:

    DeleteWorkObject(ptr);
    return dwStatus == ERROR_SUCCESS;
}

//----------------------------------------------------
//
CLASS_PRIVATE DWORD
CPersistentWorkStorage::FindNextJob()
{
    DWORD dwStatus = ERROR_SUCCESS;
    BOOL bSuccess = TRUE;
    CWorkObject* ptr = NULL;
    JET_ERR jetErrCode;
    PBYTE pbBookmark = NULL;
    DWORD cbBookmark = 0;

    m_hTableLock.Lock();

    while(dwStatus == ERROR_SUCCESS)
    {
        WORKITEMRECORD wkItem;

        // move the record pointer
        bSuccess = m_pWkItemTable->MoveToRecord();
        if(bSuccess == FALSE)
        {
            jetErrCode = m_pWkItemTable->GetLastJetError();
            if(jetErrCode == JET_errNoCurrentRecord)
            {
                // end of table
                UpdateNextJobTime(INFINITE);
                SetLastError(dwStatus = ERROR_NO_DATA);
                continue;
            }
        }

        //
        // fetch the record
        //
        bSuccess = m_pWkItemTable->FetchRecord(wkItem);
        if(bSuccess == FALSE)
        {
            SetLastError(dwStatus = SET_JB_ERROR(m_pWkItemTable->GetLastJetError()));
            continue;
        }

        if(wkItem.dwJobType & WORKTYPE_PROCESSING)
        {
            // job is been processed, move to next one.
            continue;
        }

        dwStatus = GetCurrentBookmarkEx(
                                m_pWkItemTable,
                                &pbBookmark,
                                &cbBookmark
                            );

        if(dwStatus != ERROR_SUCCESS)
        {
            // Error...
            TLSASSERT(dwStatus == ERROR_SUCCESS);
            UpdateNextJobTime(INFINITE);
            break;
            
        }

        if(wkItem.dwScheduledTime > m_dwStartupTime)
        {
            if(pbBookmark != NULL && cbBookmark != 0)
            {
                FreeMemory( pbBookmark );
                pbBookmark = NULL;
                cbBookmark = 0;
            }       

            UpdateNextJobTime(wkItem.dwScheduledTime);
            break;
        }

        //
        // job is in queue before system startup, re-schedule
        //
        ptr = InitializeWorkObject(
                                wkItem.dwJobType,
                                wkItem.pbData,
                                wkItem.cbData
                            );

        
        if(ptr == NULL)
        {
            if(pbBookmark != NULL && cbBookmark != 0)
            {
                FreeMemory( pbBookmark );
                pbBookmark = NULL;
                cbBookmark = 0;
            }       

            //
            // something is wrong, delete this job
            // and move on to next job
            //
            m_pWkItemTable->DeleteRecord();
            continue;
        }

        //
        // Set Job's storage ID and re-schedule this job
        //
        ptr->SetJobId(pbBookmark, cbBookmark);
        bSuccess = RescheduleJob(ptr);
        if(bSuccess == FALSE)
        {
            dwStatus = GetLastError();
        }

        if(pbBookmark != NULL && cbBookmark != 0)
        {
            FreeMemory( pbBookmark );
            pbBookmark = NULL;
            cbBookmark = 0;
        }       
    }

    m_hTableLock.UnLock();

    return dwStatus;
}

//----------------------------------------------------
//
CLASS_PRIVATE CWorkObject*
CPersistentWorkStorage::GetCurrentJob(
    PDWORD pdwTime
    )
/*++

--*/
{
    DWORD dwStatus = ERROR_SUCCESS;
    BOOL bSuccess = TRUE;
    WORKITEMRECORD wkItem;
    CWorkObject* ptr = NULL;

    PBYTE pbBookmark=NULL;
    DWORD cbBookmark=0;


    TLSASSERT(IsGood() == TRUE);

    m_hTableLock.Lock();
    while(dwStatus == ERROR_SUCCESS)
    {
        //
        // fetch the record
        //
        bSuccess = m_pWkItemTable->FetchRecord(wkItem);
        TLSASSERT(bSuccess == TRUE);
        //TLSASSERT(!(wkItem.dwJobType & WORKTYPE_PROCESSING));

        if(bSuccess == FALSE)
        {
            SetLastError(dwStatus = SET_JB_ERROR(m_pWkItemTable->GetLastJetError()));
            break;
        }

        if( wkItem.dwScheduledTime < m_dwStartupTime || 
            wkItem.cbData == 0 || 
            wkItem.pbData == NULL )
        { 
            // FindNextJob() move record pointer one position down
            m_pWkItemTable->MoveToRecord(JET_MovePrevious);
            dwStatus = FindNextJob();

            continue;
        }

        if( wkItem.dwJobType & WORKTYPE_PROCESSING )
        {
            dwStatus = FindNextJob();
            continue;
        }

        ptr = InitializeWorkObject(
                                wkItem.dwJobType,
                                wkItem.pbData,
                                wkItem.cbData
                            );

        dwStatus = GetCurrentBookmarkEx(
                                m_pWkItemTable,
                                &pbBookmark,
                                &cbBookmark
                            );
        
        if(dwStatus != ERROR_SUCCESS)
        {
            // something is wrong, free up memory
            // and exit.
            SetLastError(dwStatus);

            // TLSASSERT(FALSE);

            DeleteWorkObject(ptr);  
            ptr = NULL;

            // grab next job
            dwStatus = FindNextJob();
            continue;
        }

        //
        // Set Job's storage ID
        //
        ptr->SetJobId(pbBookmark, cbBookmark);
        //ptr->SetScheduledTime(wkItem.dwScheduledTime);
        *pdwTime = wkItem.dwScheduledTime;

        if(pbBookmark != NULL && cbBookmark != 0)
        {
            FreeMemory( pbBookmark );
            pbBookmark = NULL;
            cbBookmark = 0;
        }       

        break;
    }

    m_hTableLock.UnLock();
    return ptr;
}
    
//-----------------------------------------------------
//
DWORD
CPersistentWorkStorage::GetNextJobTime()
{
    DWORD dwTime;
    dwTime = (DWORD)m_dwNextJobTime;

    return dwTime;
}

//-----------------------------------------------------
//
CWorkObject*
CPersistentWorkStorage::GetNextJob(
    PDWORD pdwTime
    )
/*++

--*/
{
    CWorkObject* ptr = NULL;

    if((DWORD)m_dwNextJobTime != INFINITE)
    {
        m_hTableLock.Lock();

        //
        // Fetch record where current bookmark points to,
        // it is possible that new job arrived after
        // WorkManager already calls GetNextJobTime(),
        // this is OK since in this case this new job 
        // needs immediate processing.
        //
        ptr = GetCurrentJob(pdwTime);

        //
        // reposition current record pointer
        //
        FindNextJob();        
        
        m_hTableLock.UnLock();
    }

    return ptr;
}

//-----------------------------------------------------
//
BOOL
CPersistentWorkStorage::ReturnJobToQueue(
    IN DWORD dwTime,
    IN CWorkObject* ptr
    )
/*++

--*/
{
    DWORD dwStatus = ERROR_SUCCESS;
    PBYTE pbBookmark;
    DWORD cbBookmark;
    DWORD dwJobType;
    PBYTE pbData;
    DWORD cbData;

    if(IsValidWorkObject(ptr) == FALSE)
    {
        SetLastError(dwStatus = ERROR_INVALID_PARAMETER);
        goto cleanup;
    }

    if(ptr->IsWorkPersistent() == FALSE)
    {
        SetLastError(dwStatus = ERROR_INVALID_DATA);
        TLSASSERT(FALSE);
        goto cleanup;
    }

    if(ptr->GetWorkObjectData(&pbData, &cbData) == FALSE)
    {
        SetLastError(dwStatus = ERROR_INVALID_DATA);
        goto cleanup;
    }

    if(ptr->GetJobId(&pbBookmark, &cbBookmark) == FALSE)
    {
        SetLastError(dwStatus = ERROR_INVALID_DATA);
        goto cleanup;
    }

    m_hTableLock.Lock();

    if(dwTime < (DWORD)m_dwNextJobTime)
    {
        // Position current record
        dwStatus = SetCurrentBookmark(
                                m_pWkItemTable,
                                pbBookmark,
                                cbBookmark
                            );

        TLSASSERT(dwStatus == ERROR_SUCCESS);
        if(dwStatus == ERROR_SUCCESS)
        {
            UpdateNextJobTime(dwTime);
        }
    }

    m_hTableLock.UnLock();

cleanup:

    DeleteWorkObject(ptr);

    return dwStatus == ERROR_SUCCESS;
}


//-----------------------------------------------------
//
BOOL
CPersistentWorkStorage::EndProcessingJob(
    IN ENDPROCESSINGJOB_CODE opCode,
    IN DWORD dwOriginalTime,
    IN CWorkObject* ptr
    )
/*++

Abstract:



Parameter:

    opCode : End Processing code.
    ptr : Job has completed processing or been 
          returned by workmanager due to time or 
          resource constraint.
    

Return:

    TRUE/FALSE

--*/
{
    BOOL bSuccess = TRUE;
    BYTE pbData = NULL;
    DWORD cbData = 0;

    DBGPrintf(
            DBG_INFORMATION,
            DBG_FACILITY_WORKMGR,
            DBGLEVEL_FUNCTION_TRACE,
            _TEXT("CPersistentWorkStorage::EndProcessingJob() - end processing %s opCode %d\n"),
            ptr->GetJobDescription(),
            opCode
        );

    if(ptr == NULL)
    {
        bSuccess = FALSE;
        SetLastError(ERROR_INVALID_PARAMETER);
        goto cleanup;
    }

    if(ptr->IsWorkPersistent() == FALSE)
    {
        SetLastError(ERROR_INVALID_DATA);
        TLSASSERT(FALSE);
        goto cleanup;
    }

    switch(opCode)
    {
        case ENDPROCESSINGJOB_SUCCESS:
            bSuccess = RescheduleJob(ptr);
            m_dwJobsInProcesssing--;
            break;

        case ENDPROCESSINGJOB_ERROR:
            bSuccess = DeleteErrorJob(ptr);
            m_dwJobsInProcesssing--;
            break;

        case ENDPROCESSINGJOB_RETURN:
            bSuccess = ReturnJobToQueue(dwOriginalTime, ptr);
            break;

        default:

            TLSASSERT(FALSE);
    }

cleanup:
    return bSuccess;
}

//-------------------------------------------------------
//
BOOL
CPersistentWorkStorage::BeginProcessingJob(
    IN CWorkObject* ptr
    )
/*++

Abstract:

    Work Manager call this to inform. storage that
    this job is about to be processed.


Parameter:

    ptr - Job to be process.

Return:

    TRUE/FALSE

--*/
{
    BOOL bSuccess = TRUE;
    DWORD dwStatus = ERROR_SUCCESS;
    PBYTE pbBookmark;
    DWORD cbBookmark;
    DWORD dwTime;
    PBYTE pbData;
    DWORD cbData;


    DBGPrintf(
            DBG_INFORMATION,
            DBG_FACILITY_WORKMGR,
            DBGLEVEL_FUNCTION_TRACE,
            _TEXT("CPersistentWorkStorage::BeginProcessingJob() - beginning processing %s\n"),
            ptr->GetJobDescription()
        );

    if(IsValidWorkObject(ptr) == FALSE)
    {
        SetLastError(dwStatus = ERROR_INVALID_PARAMETER);
        goto cleanup;
    }

    if(ptr->IsWorkPersistent() == FALSE)
    {
        SetLastError(dwStatus = ERROR_INVALID_DATA);
        TLSASSERT(FALSE);
        goto cleanup;
    }

    bSuccess = ptr->GetWorkObjectData(&pbData, &cbData);
    if(bSuccess == FALSE)
    {
        SetLastError(dwStatus = ERROR_INVALID_DATA);
        goto cleanup;
    }

    bSuccess = ptr->GetJobId(&pbBookmark, &cbBookmark);
    if(bSuccess == FALSE)
    {
        SetLastError(dwStatus = ERROR_INVALID_DATA);
        goto cleanup;
    }

    m_hTableLock.Lock();

    bSuccess = UpdateWorkItemEntry(
                            m_pWkItemTable,
                            WORKITEM_BEGINPROCESSING,
                            pbBookmark,
                            cbBookmark,
                            ptr->GetJobRestartTime(),
                            ptr->GetScheduledTime(),
                            ptr->GetWorkType(),
                            pbData,
                            cbData
                        );

    if(bSuccess == TRUE)
    {
        m_dwJobsInProcesssing ++;
    }
    else
    {
        dwStatus = GetLastError();
    }
    
    m_hTableLock.UnLock();

cleanup:

    return dwStatus == ERROR_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\license\tlserver\server\upgdb.h ===
//+--------------------------------------------------------------------------
//
// Copyright (c) 1997-1999 Microsoft Corporation
//
// File:       upgdb.h 
//
// Contents:    
//
// History:     
//
//---------------------------------------------------------------------------
#ifndef __UPGDB_H_
#define __UPGDB_H_
#include "server.h"


#ifdef __cplusplus
extern "C" {
#endif

DWORD 
TLSUpgradeDatabase(
    IN JBInstance& jbInstance,
    IN LPTSTR szDatabaseFile,
    IN LPTSTR szUserName,
    IN LPTSTR szPassword
);

DWORD
UpgradeKeyPackVersion(IN PTLSDbWorkSpace pDbWkSpace);

DWORD
TLSAddTermServCertificatePack(
    IN PTLSDbWorkSpace pDbWkSpace,
    IN BOOL bLogWarning
);


DWORD
TLSRemoveLicensesFromInvalidDatabase(
    IN PTLSDbWorkSpace pDbWkSpace
);

#ifdef __cplusplus
}
#endif


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\license\tlserver\server\utils.h ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996-1998
//
// File:        utils.cpp
//
// Contents:    Hydra License Server Service Control Manager Interface
//
// History:     12-09-97    HueiWang    Modified from MSDN RPC Service Sample
//
//---------------------------------------------------------------------------
#ifndef __LS_UTILS_H
#define __LS_UTILS_H

#include <windows.h>
#include <stdio.h>

#ifdef __cplusplus
extern "C" {
#endif

    void 
    TLSLogInfoEvent(
        DWORD
    );

    void 
    TLSLogWarningEvent(
        DWORD
    );

    void 
    TLSLogErrorEvent(
        DWORD
    );

    void 
    TLSLogEvent(
        DWORD, 
        DWORD,
        DWORD, ... 
    );

    void
    TLSLogEventString(
        IN DWORD dwType,
        IN DWORD dwEventId,
        IN WORD wNumString,
        IN LPCTSTR* lpStrings
    );

    BOOL 
    LoadResourceString(
        DWORD dwId, 
        LPTSTR szBuf, 
        DWORD dwBufSize
    );

    BOOL 
    APIENTRY
    TLSCheckTokenMembership(
        IN HANDLE TokenHandle OPTIONAL,
        IN PSID SidToCheck,
        OUT PBOOL IsMember
    );

    DWORD 
    IsAdmin(
        BOOL* bMember
    );

    void 
    UnixTimeToFileTime(
        time_t t, 
        LPFILETIME pft
    );

    BOOL
    FileTimeToLicenseDate(
        LPFILETIME pft,
        DWORD* t
    );

    BOOL
    TLSSystemTimeToFileTime(
        SYSTEMTIME* pSysTime,
        LPFILETIME pfTime
    );

    BOOL
    FileExists(
        IN  PCTSTR           FileName,
        OUT PWIN32_FIND_DATA FindData   OPTIONAL
    );

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\license\tlserver\server\upgdb.cpp ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996-1998
//
// File:        upgrade.cpp
//
// Contents:    All database upgrade related.
//
// History:     12-09-97    HueiWang    
//
//---------------------------------------------------------------------------
#include "pch.cpp"
#include "server.h"
#include "upgdb.h"
#include "globals.h"
#include "kp.h"
#include "keypack.h"
#include "lkpdesc.h"
#include "permlic.h"

//---------------------------------------------------------------------
DWORD
TLSCreateUpgradeDatabase(
    IN JBDatabase& jbDatabase
    )
/*++
Abstract:

    This routine create a empty license server database.

Parameters:

    jbDatabase : database handle.

Returns:

    Jet error code

++*/
{
    BOOL bSuccess;
    DWORD dwStatus=ERROR_SUCCESS;
    DWORD dwCurrentVersion=0;

    PBYTE pbSetupId = NULL;
    DWORD cbSetupId = 0;

    VersionTable* pverTable = NULL;
    LicPackTable* pLicPackTable = NULL;
    LicensedTable* pLicensedTable = NULL;
    LicPackDescTable* pLicPackDescTable = NULL;
    BackupSourceTable* pBckSrcTable = NULL;
    WorkItemTable* pWkItemTable = NULL;

    pverTable = new VersionTable(jbDatabase);    
    pLicPackTable = new LicPackTable(jbDatabase);    
    pLicensedTable = new LicensedTable(jbDatabase);
    pLicPackDescTable = new LicPackDescTable(jbDatabase);
    pBckSrcTable = new BackupSourceTable(jbDatabase);
    pWkItemTable = new WorkItemTable(jbDatabase); 
    

    //--------------------------------------------------------    
    TLSVersion version_search;
    TLSVersion version_found;
    DWORD dwDbVersion;
    BOOL bUpdateVersionRec = FALSE;

    if(pverTable == NULL || pLicPackTable == NULL || pLicensedTable == NULL || pLicPackDescTable == NULL || pBckSrcTable == NULL || pWkItemTable == NULL)
    {
        dwStatus = TLS_E_ALLOCATE_MEMORY;
        goto cleanup;
    }

   
    if(TLSIsBetaNTServer() == TRUE)
    {
        dwDbVersion = TLS_BETA_DBVERSION;
    }
    else
    {
        dwDbVersion = TLS_CURRENT_DBVERSION;
    }

    version_search.dwVersion = dwDbVersion;

    _tcsncpy(
            version_search.szInstallId, 
            (LPTSTR)g_pszServerPid, 
            min(sizeof(version_search.szInstallId)/sizeof(version_search.szInstallId[0]) - 1, g_cbServerPid/sizeof(TCHAR))
        );

    //version_search.pbDomainSid = g_pbDomainSid;
    //version_search.cbDomainSid = g_cbDomainSid;

    if(pverTable->OpenTable(FALSE, TRUE) == FALSE)
    {
        JET_ERR jetErr = pverTable->GetLastJetError();

        if( jetErr != JET_errObjectNotFound || 
            pverTable->OpenTable(TRUE, TRUE) == FALSE ||
            pverTable->InsertRecord(version_search) == FALSE )
        {
            SetLastError(
                    dwStatus = SET_JB_ERROR(pverTable->GetLastJetError())
                );
            goto cleanup;
        }

        dwCurrentVersion = 0;
    }
    else
    {
        // load the version table
        // must have at least entry in the table.
        bSuccess = pverTable->EnumerateBegin(
                                    FALSE, 
                                    ENUMERATE_COMPARE_NO_FIELDS, 
                                    NULL
                                );

        if(bSuccess == FALSE)
        {
            dwStatus = SET_JB_ERROR(pverTable->GetLastJetError());
            SetLastError(dwStatus);
            goto cleanup;
        }

        if(pverTable->EnumerateNext(version_found) != RECORD_ENUM_MORE_DATA)
        {
            SetLastError(dwStatus = TLS_E_INTERNAL);
            goto cleanup;
        }

        pverTable->EnumerateEnd();

        if( DATABASE_VERSION(version_found.dwVersion) > DATABASE_VERSION(dwDbVersion) &&
            DATABASE_VERSION(version_found.dwVersion) != W2K_RTM_JETBLUE_DBVERSION )
        {
            //
            // Database was created by in-compatible license server.
            //
            DBGPrintf(
                    DBG_ERROR,
                    DBG_FACILITY_UPGRADE,
                    DBGLEVEL_FUNCTION_ERROR,
                    _TEXT("Beta 3 database version 0x%08x, 0x%08x\n"),
                    version_found.dwVersion,
                    dwDbVersion
                );

            //
            // critical error, database version > what we can support
            //
            SetLastError(dwStatus = TLS_E_INCOMPATIBLEDATABSE);
            goto cleanup;
        }                

        if( TLSIsBetaNTServer() == FALSE && 
            DATABASE_VERSION(version_found.dwVersion) == W2K_BETA3_JETBLUE_DBVERSION )
        {
            //
            // 
            // Beta3 license database, wipe out and restart from scratch
            //
            DBGPrintf(
                    DBG_ERROR,
                    DBG_FACILITY_UPGRADE,
                    DBGLEVEL_FUNCTION_ERROR,
                    _TEXT("Beta 3 database version 0x%08x, 0x%08x\n"),
                    version_found.dwVersion,
                    dwDbVersion
                );

            dwStatus = TLS_E_BETADATABSE;
            goto cleanup;
        }                

        if(IS_ENFORCE_VERSION(version_found.dwVersion) != IS_ENFORCE_VERSION(dwDbVersion))
        {
            //
            // Enforce/non-enforce in-compatible, wipe out database and restart from
            // scratch
            //
            DBGPrintf(
                    DBG_ERROR,
                    DBG_FACILITY_UPGRADE,
                    DBGLEVEL_FUNCTION_ERROR,
                    _TEXT("Enforce/Non-enforce database 0x%08x, 0x%08x\n"),
                    version_found.dwVersion,
                    dwDbVersion
                );

            //#if ENFORCE_LICENSING
            //TLSLogWarningEvent(dwStatus = TLS_W_DB_ENFORCE_NONENFORCE);
            //#endif
            //bUpdateVersionRec = TRUE;
                
            dwStatus = TLS_E_INCOMPATIBLEDATABSE;
            goto cleanup;
        }

        //
        // Server ID
        // 
        if( _tcscmp(version_found.szInstallId, version_search.szInstallId) != 0 )
        {
            //
            // Check if this is pre-beta3 which uses GUID
            //
            dwStatus = RetrieveKey(
                                LSERVER_LSA_SETUPID,
                                &pbSetupId,
                                &cbSetupId
                            );

            if( dwStatus != ERROR_SUCCESS || 
                _tcscmp(version_found.szInstallId, (LPTSTR)pbSetupId) != 0 )
            {
                DBGPrintf(
                        DBG_ERROR,
                        DBG_FACILITY_UPGRADE,
                        DBGLEVEL_FUNCTION_ERROR,
                        _TEXT("Database does not belong to this machine\n")
                    );
                
                #if ENFORCE_LICENSING
                TLSLogWarningEvent(dwStatus = TLS_W_NOTOWNER_DATABASE);
                #endif

                bUpdateVersionRec = TRUE;
            }
        }

        if(bUpdateVersionRec == TRUE)
        {
            //
            // take ownership of this database, no other DB operation, current
            // record is still at version, update record.
            //
            if(pverTable->UpdateRecord(version_search) == FALSE)
            {
                SetLastError(
                        dwStatus = SET_JB_ERROR(pverTable->GetLastJetError())
                    );
                goto cleanup;
            }
        }

        dwCurrentVersion = DATABASE_VERSION(version_search.dwVersion);
    }

    //--------------------------------------------------------
    bSuccess = pLicPackTable->UpgradeTable(
                                dwCurrentVersion, 
                                DATABASE_VERSION(dwDbVersion)
                            );

    if(bSuccess == FALSE)
    {
        SetLastError(
                dwStatus = SET_JB_ERROR(pLicPackTable->GetLastJetError())
            );
        goto cleanup;
    }

    //--------------------------------------------------------
    bSuccess = pLicensedTable->UpgradeTable(
                                dwCurrentVersion, 
                                DATABASE_VERSION(dwDbVersion)
                            );
    if(bSuccess == FALSE)
    {
        SetLastError(
                dwStatus = SET_JB_ERROR(pLicensedTable->GetLastJetError())
            );

        goto cleanup;
    }


    //--------------------------------------------------------
    bSuccess = pLicPackDescTable->UpgradeTable(
                                dwCurrentVersion, 
                                DATABASE_VERSION(dwDbVersion)
                            ) ;

    if(bSuccess == FALSE)
    {
        SetLastError(
                dwStatus = SET_JB_ERROR(pLicPackDescTable->GetLastJetError())
            );
        goto cleanup;
    }

    //--------------------------------------------------------
    bSuccess = pBckSrcTable->UpgradeTable(
                                dwCurrentVersion, 
                                DATABASE_VERSION(dwDbVersion)
                            );

    if(bSuccess == FALSE)
    {
        SetLastError(
                dwStatus = SET_JB_ERROR(pBckSrcTable->GetLastJetError())
            );
        goto cleanup;
    }

    //--------------------------------------------------------
    bSuccess = pWkItemTable->UpgradeTable(
                                dwCurrentVersion, 
                                DATABASE_VERSION(dwDbVersion)
                            );

    if(bSuccess == FALSE)
    {
        SetLastError(
                dwStatus = SET_JB_ERROR(pWkItemTable->GetLastJetError())
            );
        goto cleanup;
    }


cleanup:

    if(pbSetupId != NULL)
    {
        LocalFree(pbSetupId);
    }

    //
    // We use global so don't free the memory
    //
    version_search.pbDomainSid = NULL;
    version_search.cbDomainSid = 0;
    
    if(pverTable)
    {
        pverTable->CloseTable();
        delete pverTable;
    }
    if(pLicPackTable)
    {
        delete pLicPackTable;
    }
    if(pLicensedTable)
    {
        delete pLicensedTable;
    }
    if(pLicPackDescTable)
    {
        delete pLicPackDescTable;
    }
    if(pBckSrcTable)
    {
        delete pBckSrcTable;
    }
    if(pWkItemTable)
    {
        delete pWkItemTable;
    }    

    return dwStatus;
}

//---------------------------------------------------------------------

BOOL
Upgrade236LicensePack(
    PTLSLICENSEPACK pLicensePack
    )
/*++

++*/
{
    DWORD dwMajorVersion;
    DWORD dwMinorVersion;
    BOOL bRequireUpgrade=FALSE;

    TCHAR szPreFix[MAX_SKU_PREFIX];
    TCHAR szPostFix[MAX_SKU_POSTFIX];
    DWORD dwPlatformType;

    memset(szPreFix, 0, sizeof(szPreFix));
    memset(szPostFix, 0, sizeof(szPostFix));
    LONG lRet =_stscanf(
            pLicensePack->szProductId,
            TERMSERV_PRODUCTID_SCAN_FORMAT,
            szPreFix,
            &dwMajorVersion,
            &dwMinorVersion,
            szPostFix
        );
    if(lRet != 4)
        goto cleanup;

    if(_tcscmp(szPreFix, TERMSERV_PRODUCTID_SKU) != 0)
    {
        //
        // Not our license pack
        //
        goto cleanup;
    }

    if(_tcscmp(szPostFix, TERMSERV_FULLVERSION_TYPE) == 0)
    {
        dwPlatformType = PLATFORMID_OTHERS;
    }
    else if(_tcscmp(szPostFix, TERMSERV_FREE_TYPE) == 0)
    {
        dwPlatformType = PLATFORMID_FREE;
    }
    else
    {
        // ignore this error...
        goto cleanup;
    }

    // fix entries caused by bug 402870.
    // Remote license pack must have remote bit in status and platformtype 
    if( pLicensePack->ucKeyPackStatus & LSKEYPACKSTATUS_REMOTE &&
        !(pLicensePack->dwPlatformType & LSKEYPACK_PLATFORM_REMOTE) ) 
    {
        pLicensePack->dwPlatformType |= LSKEYPACK_PLATFORM_REMOTE;
        bRequireUpgrade = TRUE;
        goto cleanup;
    }

    //
    // If platform type is correct, no need to upgrade
    //
    if( (pLicensePack->dwPlatformType & ~LSKEYPACK_PLATFORM_REMOTE) == dwPlatformType )
    {
        goto cleanup;
    }

    //
    // Update platform Type.
    //
    pLicensePack->dwPlatformType = dwPlatformType;
    if( pLicensePack->ucKeyPackStatus & LSKEYPACKSTATUS_REMOTE )
    {
        pLicensePack->dwPlatformType |= LSKEYPACK_PLATFORM_REMOTE;
    }

    bRequireUpgrade = TRUE;

cleanup:

    return bRequireUpgrade;
}

//----------------------------------------------------------

DWORD
TLSAddTermServCertificatePack(
    IN PTLSDbWorkSpace pDbWkSpace,
    IN BOOL bLogWarning
    )
/*++

Abstract:


    This routine add a sepecifc license pack to issuing/generating
    certificate for terminal server.

Parameter:
    
    pDbWkSpace : workspace handle.
    bLogWarning : Log low license count warning, ignore if enforce


Return:

    JET Error code.

++*/
{
    DWORD dwStatus=ERROR_SUCCESS;
    PTLSLICENSEPACK plicensePack = NULL;
    DWORD dwKpDescStatus = ERROR_SUCCESS;    

    struct tm convertTime;
    time_t expired_time;
    time_t activate_time;

    //
    // Set activation date to 1970 - client/server might not sync. up in time
    //
    memset(&convertTime, 0, sizeof(convertTime));
    convertTime.tm_year = 1980 - 1900;     // expire on 2036/1/1
    convertTime.tm_mday = 1;
    
    activate_time = mktime(&convertTime);
    if(activate_time == (time_t) -1)
    {
        DBGPrintf(
                DBG_ERROR,
                DBG_FACILITY_UPGRADE,
                DBGLEVEL_FUNCTION_ERROR,
                _TEXT("Can't calculate keypack activate time\n")
            );

       return TLS_E_UPGRADE_DATABASE; 
    }


    //
    // Expiration date
    //
    memset(&convertTime, 0, sizeof(convertTime));
    convertTime.tm_year = 2036 - 1900;     // expire on 2036/1/1
    convertTime.tm_mday = 1;
    
    expired_time = mktime(&convertTime);
    if(expired_time == (time_t) -1)
    {
        DBGPrintf(
                DBG_ERROR,
                DBG_FACILITY_UPGRADE,
                DBGLEVEL_FUNCTION_ERROR,
                _TEXT("Can't calculate keypack expiration time\n")
            );

       return TLS_E_UPGRADE_DATABASE; 
    }

    // Add a special keypack to hydra server
    LSKeyPack hsKeyPack;

    pDbWkSpace->BeginTransaction();

    memset(&hsKeyPack, 0, sizeof(LSKeyPack));
    hsKeyPack.ucKeyPackType = LSKEYPACKTYPE_FREE;
    SAFESTRCPY(hsKeyPack.szKeyPackId, HYDRAPRODUCT_HS_CERTIFICATE_KEYPACKID);

    if(!LoadResourceString(
                IDS_HS_COMPANYNAME, 
                hsKeyPack.szCompanyName, 
                sizeof(hsKeyPack.szCompanyName) / sizeof(hsKeyPack.szCompanyName[0])))
    {
        DBGPrintf(
                DBG_ERROR,
                DBG_FACILITY_UPGRADE,
                DBGLEVEL_FUNCTION_ERROR,
                _TEXT("Can't load resources for IDS_HS_COMPANYNAME\n")
            );

        SetLastError(dwStatus = TLS_E_UPGRADE_DATABASE);
        goto cleanup;
    }

    if(!LoadResourceString(
               IDS_HS_PRODUCTNAME,
               hsKeyPack.szProductName,
               sizeof(hsKeyPack.szProductName) / sizeof(hsKeyPack.szProductName[0])))
    {
        DBGPrintf(
                DBG_ERROR,
                DBG_FACILITY_UPGRADE,
                DBGLEVEL_FUNCTION_ERROR,
                _TEXT("Can't load resources for IDS_HS_PRODUCTNAME\n")
            );
        SetLastError(dwStatus = TLS_E_UPGRADE_DATABASE);
        goto cleanup;
    }

    if(!LoadResourceString(
                IDS_HS_PRODUCTDESC,
                hsKeyPack.szProductDesc,
                sizeof(hsKeyPack.szProductDesc) / sizeof(hsKeyPack.szProductDesc[0])))
    {
        DBGPrintf(
                DBG_ERROR,
                DBG_FACILITY_UPGRADE,
                DBGLEVEL_FUNCTION_ERROR,
                _TEXT("Can't load resources for IDS_HS_PRODUCTDESC\n")
            );
        SetLastError(dwStatus = TLS_E_UPGRADE_DATABASE);
        goto cleanup;
    }

    SAFESTRCPY(hsKeyPack.szProductId, HYDRAPRODUCT_HS_CERTIFICATE_SKU);

    hsKeyPack.ucKeyPackStatus = LSKEYPACKSTATUS_ACTIVE;
    hsKeyPack.dwActivateDate = activate_time;
    hsKeyPack.dwExpirationDate = expired_time;            

    hsKeyPack.wMajorVersion=HIWORD(HYDRACERT_PRODUCT_VERSION);
    hsKeyPack.wMinorVersion=LOWORD(HYDRACERT_PRODUCT_VERSION);
    hsKeyPack.dwPlatformType=CLIENT_PLATFORMID_WINDOWS_NT_FREE;
    hsKeyPack.ucLicenseType=LSKEYPACKLICENSETYPE_NEW;
    hsKeyPack.dwLanguageId=MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US);
    hsKeyPack.ucChannelOfPurchase=LSKEYPACKCHANNELOFPURCHASE_RETAIL;
    SAFESTRCPY(hsKeyPack.szBeginSerialNumber, _TEXT("0"));
    hsKeyPack.dwTotalLicenseInKeyPack = 0;
    hsKeyPack.dwProductFlags = 0;

    dwStatus = TLSDBLicenseKeyPackAdd(
                                pDbWkSpace, 
                                &hsKeyPack
                            );

    if(dwStatus == ERROR_SUCCESS)
    {
        hsKeyPack.ucKeyPackStatus = LSKEYPACKSTATUS_ACTIVE;
        hsKeyPack.dwActivateDate = activate_time;
        hsKeyPack.dwExpirationDate = expired_time;            

        dwStatus=TLSDBLicenseKeyPackSetStatus(
                                    pDbWkSpace, 
                                    LSKEYPACK_SET_ALLSTATUS, 
                                    &hsKeyPack
                                );

        #if DBG
        if(dwStatus != ERROR_SUCCESS)
        {
            TLSASSERT(FALSE);
        }

        if(hsKeyPack.dwKeyPackId != 1)
        {
            // this can only success in empty database.
            TLSASSERT(FALSE);
        }
        #endif
    }

    if(dwStatus != ERROR_SUCCESS)
    {
        DBGPrintf(
                DBG_ERROR,
                DBG_FACILITY_UPGRADE,
                DBGLEVEL_FUNCTION_ERROR,
                _TEXT("Can't add keypack or set status - %d\n"),
                dwStatus
            );
    }

    pDbWkSpace->CommitTransaction();

    //
    // Begin another transaction for upgrading 236 product
    //
    pDbWkSpace->BeginTransaction();

    plicensePack = new TLSLICENSEPACK;
    if(plicensePack == NULL)
    {
        SetLastError(dwStatus = TLS_E_ALLOCATE_MEMORY);
        goto cleanup;
    }

    memset(plicensePack, 0, sizeof(TLSLICENSEPACK));

    //
    // Terminal Server specific code...
    //
    dwStatus = TLSDBKeyPackEnumBegin(
                                pDbWkSpace,
                                FALSE,
                                LSKEYPACK_SEARCH_NONE,
                                plicensePack
                            );

    while(dwStatus == ERROR_SUCCESS)
    {
        dwStatus = TLSDBKeyPackEnumNext(
                                    pDbWkSpace,
                                    plicensePack
                                );

        if(dwStatus != ERROR_SUCCESS)
        {
            break;
        }

        if( Upgrade236LicensePack(plicensePack) == TRUE || 
            (plicensePack->ucAgreementType & LSKEYPACK_REMOTE_TYPE) )
        {
            BOOL bSuccess;
            LicPackTable& licpackTable=pDbWkSpace->m_LicPackTable;

            if( plicensePack->ucAgreementType & LSKEYPACK_REMOTE_TYPE ||
                plicensePack->ucKeyPackStatus & LSKEYPACKSTATUS_REMOTE )
            {
                plicensePack->dwPlatformType |= LSKEYPACK_PLATFORM_REMOTE;
                plicensePack->ucKeyPackStatus |= LSKEYPACKSTATUS_REMOTE;
                plicensePack->ucAgreementType &= ~LSKEYPACK_RESERVED_TYPE;
            }

            //
            // use the same timestamp for this record, tlsdb require update entry's timestamp 
            //
            bSuccess = licpackTable.UpdateRecord(
                                        *plicensePack,
                                        LICENSEDPACK_PROCESS_PLATFORMTYPE | LICENSEDPACK_PROCESS_MODIFYTIME | 
                                            LICENSEDPACK_PROCESS_AGREEMENTTYPE | LICENSEDPACK_PROCESS_KEYPACKSTATUS
                                    );

            if(bSuccess == FALSE)
            {
                dwStatus = SET_JB_ERROR(licpackTable.GetLastJetError());
            }
        }

#ifndef ENFORCE_LICENSING
        if(bLogWarning == FALSE)
        {
            DBGPrintf(
                    DBG_ERROR,
                    DBG_FACILITY_UPGRADE,
                    DBGLEVEL_FUNCTION_ERROR,
                    _TEXT("Ignore low license count warning...\n")
                );

            continue;
        }

        if(plicensePack->ucAgreementType & LSKEYPACK_REMOTE_TYPE)
        {
            // don't log warning for remote license pack.
            continue;
        }

        if(plicensePack->ucKeyPackStatus & LSKEYPACKSTATUS_REMOTE)
        {
            // don't log warning for remote license pack.
            continue;
        }

        //
        // log low license count warning message
        //
        if( plicensePack->ucAgreementType == LSKEYPACKTYPE_OPEN ||
            plicensePack->ucAgreementType == LSKEYPACKTYPE_RETAIL ||
            plicensePack->ucAgreementType == LSKEYPACKTYPE_SELECT )
        {
            if(plicensePack->dwNumberOfLicenses > g_LowLicenseCountWarning)
            {
                continue;
            }

            //
            LICPACKDESC kpDescSearch, kpDescFound;

            memset(&kpDescSearch, 0, sizeof(kpDescSearch));
            memset(&kpDescFound, 0, sizeof(kpDescFound));

            kpDescSearch.dwKeyPackId = plicensePack->dwKeyPackId;
            kpDescSearch.dwLanguageId = GetSystemDefaultLangID();

            dwKpDescStatus = TLSDBKeyPackDescFind(
                                            pDbWkSpace,
                                            TRUE,
                                            LSKEYPACK_SEARCH_KEYPACKID | LSKEYPACK_SEARCH_LANGID,
                                            &kpDescSearch,
                                            &kpDescFound
                                        );

            if( dwKpDescStatus == TLS_E_RECORD_NOTFOUND && 
                GetSystemDefaultLangID() != MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US) )
            {
                // use english description
                kpDescSearch.dwLanguageId = MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US);

                dwKpDescStatus = TLSDBKeyPackDescFind(
                                                pDbWkSpace,
                                                TRUE,
                                                LSKEYPACK_SEARCH_KEYPACKID | LSKEYPACK_SEARCH_LANGID,
                                                &kpDescSearch,
                                                &kpDescFound
                                            );
            }

            if(dwKpDescStatus != ERROR_SUCCESS)
            {
                // ignore this.
                continue;
            }

            if( _tcsicmp( plicensePack->szCompanyName, PRODUCT_INFO_COMPANY_NAME ) == 0 )
            {
                //
                // check with known termsrv product ID.
                //
                if( _tcsnicmp(  plicensePack->szProductId, 
                                TERMSERV_PRODUCTID_SKU, 
                                _tcslen(TERMSERV_PRODUCTID_SKU)) == 0 )
                {
                    TLSResetLogLowLicenseWarning(
                                            plicensePack->szCompanyName,
                                            TERMSERV_PRODUCTID_SKU, 
                                            MAKELONG(plicensePack->wMinorVersion, plicensePack->wMajorVersion),
                                            TRUE
                                        );
                }
                else if(_tcsnicmp(  plicensePack->szProductId, 
                                    TERMSERV_PRODUCTID_INTERNET_SKU, 
                                    _tcslen(TERMSERV_PRODUCTID_INTERNET_SKU)) == 0 )
                {
                    TLSResetLogLowLicenseWarning(
                                            plicensePack->szCompanyName,
                                            TERMSERV_PRODUCTID_INTERNET_SKU, 
                                            MAKELONG(plicensePack->wMinorVersion, plicensePack->wMajorVersion),
                                            TRUE
                                        );
                }
                else
                {
                    TLSResetLogLowLicenseWarning(
                                            plicensePack->szCompanyName,
                                            plicensePack->szProductId, 
                                            MAKELONG(plicensePack->wMinorVersion, plicensePack->wMajorVersion),
                                            TRUE
                                        );
                }
            }
            else
            {
                TLSResetLogLowLicenseWarning(
                                        plicensePack->szCompanyName,
                                        plicensePack->szProductId, 
                                        MAKELONG(plicensePack->wMinorVersion, plicensePack->wMajorVersion),
                                        TRUE
                                    );
            }


            {
                LPCTSTR pString[3];
                TCHAR szCount[25];
                
                memset(szCount, 0, sizeof(szCount));

                _sntprintf(
                        szCount, 
                        sizeof(szCount)/sizeof(szCount[0]) - 1,
                        _TEXT("%d"), 
                        plicensePack->dwNumberOfLicenses
                    );
                            
                pString[0] = g_szComputerName;
                pString[1] = szCount;
                pString[2] = kpDescFound.szProductDesc;

                TLSLogEventString(
                        EVENTLOG_WARNING_TYPE,
                        TLS_W_LOWLICENSECOUNT,
                        sizeof(pString)/sizeof(pString[0]),
                        pString
                    );
            }
        }
#endif        
    }

    if(dwStatus == TLS_I_NO_MORE_DATA)
    {
        dwStatus = ERROR_SUCCESS;
    }
    
    TLSDBKeyPackEnumEnd( pDbWkSpace );

cleanup:

    if(plicensePack != NULL)
    {
        delete plicensePack;
    }
    
    if(dwStatus == ERROR_SUCCESS)
    {
        pDbWkSpace->CommitTransaction();
    }
    else
    {
        pDbWkSpace->RollbackTransaction();
    }

    return dwStatus;
}

//-----------------------------------------------------------------------------
// Upgrade License Server Database
//-----------------------------------------------------------------------------
DWORD 
TLSUpgradeDatabase(
    IN JBInstance& jbInstance,
    IN LPTSTR szDatabaseFile,
    IN LPTSTR szUserName,
    IN LPTSTR szPassword
    )
/*++

++*/
{
    DWORD dwStatus=ERROR_SUCCESS;
    BOOL bSuccess;
    DWORD dwCurrentDbVersion;
    BOOL bCreateEmpty=FALSE;

    if(jbInstance.IsValid() == FALSE)
    {
        SetLastError(dwStatus = ERROR_INVALID_PARAMETER);
        return dwStatus;
    }


    JBSession jbSession(jbInstance);
    JBDatabase jbDatabase(jbSession);

    //
    // open version table to determine the current database version stamp.
    //
    VersionTable verTable(jbDatabase);

    TLSVersion version_search;
    TLSVersion version_found;

    //----------------------------------------------------------
    //
    // initialize a session, then database
    //
    bSuccess = jbSession.BeginSession(szUserName, szPassword);
    if(bSuccess == FALSE)
    {
        LPTSTR pString = NULL;

        TLSGetESEError(jbSession.GetLastJetError(), &pString);
        TLSLogEvent(
                EVENTLOG_ERROR_TYPE,
                TLS_E_DBGENERAL,
                TLS_E_JB_BEGINSESSION,
                jbSession.GetLastJetError(),
                (pString != NULL) ? pString : _TEXT("")
            );

        if(pString != NULL)
        {
            LocalFree(pString);
        }

        DBGPrintf(
                DBG_ERROR,
                DBG_FACILITY_UPGRADE,
                DBG_ALL_LEVEL,
                _TEXT("Can't start a jet session - %d\n"),
                jbSession.GetLastJetError()
            );
        SetLastError(dwStatus = TLS_E_UPGRADE_DATABASE);
        goto cleanup;
    }

    //
    // Open the database
    //
    bSuccess = jbDatabase.OpenDatabase(szDatabaseFile);
    if( bSuccess == FALSE )
    {
        JET_ERR jetErr = jbDatabase.GetLastJetError();

        if(jetErr == JET_errDatabaseCorrupted)
        {
            //
            // report corrupted database
            //
            TLSLogEvent(
                    EVENTLOG_ERROR_TYPE,
                    TLS_E_DBGENERAL,
                    TLS_E_CORRUPT_DATABASE
                );

            SetLastError(dwStatus = TLS_E_CORRUPT_DATABASE);
            jbSession.EndSession();
            goto cleanup;
        }
        else if(jetErr != JET_errFileNotFound)
        {
            LPTSTR pString = NULL;

            TLSGetESEError(jetErr, &pString);

            //
            // other type of error
            //
            TLSLogEvent(
                    EVENTLOG_ERROR_TYPE,
                    TLS_E_DBGENERAL,
                    TLS_E_JB_OPENDATABASE,
                    szDatabaseFile,
                    jbDatabase.GetLastJetError(),
                    (pString != NULL) ? pString : _TEXT("")
                );

            if(pString != NULL)
            {
                LocalFree(pString);
            }
                                
            dwStatus = SET_JB_ERROR(jetErr);
            SetLastError(dwStatus);
            jbSession.EndSession();
            goto cleanup;
        }

        //
        // database does not exist, create one
        //
        bSuccess = jbDatabase.CreateDatabase(szDatabaseFile);
        if(bSuccess == FALSE)
        {
            LPTSTR pString = NULL;

            TLSGetESEError(jbDatabase.GetLastJetError(), &pString);

            TLSLogEvent(
                    EVENTLOG_ERROR_TYPE,
                    TLS_E_DBGENERAL,
                    TLS_E_JB_CREATEDATABASE,
                    szDatabaseFile,
                    jbDatabase.GetLastJetError(),
                    (pString != NULL) ? pString : _TEXT("")
                );

            if(pString != NULL)
            {
                LocalFree(pString);
            }

            DBGPrintf(
                    DBG_ERROR,
                    DBG_FACILITY_JETBLUE,
                    DBGLEVEL_FUNCTION_ERROR,
                    _TEXT("Error : can't create new database - error code %d\n"),
                    jbDatabase.GetLastJetError()
                );

            dwStatus = SET_JB_ERROR(jbDatabase.GetLastJetError());
            SetLastError(dwStatus);
            jbSession.EndSession();
            goto cleanup;
        }

        bCreateEmpty=TRUE;
    }

    jbSession.BeginTransaction();

    //
    // Create/upgrade all the tables
    //
    dwStatus = TLSCreateUpgradeDatabase(
                                    jbDatabase
                                );

    if(TLS_ERROR(dwStatus) == TRUE)
    {
        jbSession.RollbackTransaction();
    }
    else
    {
        jbSession.CommitTransaction();
    }

    jbDatabase.CloseDatabase();
    jbSession.EndSession();

cleanup:

    if(TLS_ERROR(dwStatus) == TRUE)
    {
        return dwStatus;
    }

    return (bCreateEmpty) ? TLS_I_CREATE_EMPTYDATABASE : dwStatus;
}

//-----------------------------------------------------------------------------
// Upgrade 5.1 License Keypacks to 5.2
//-----------------------------------------------------------------------------
DWORD
UpgradeKeyPackVersion(IN PTLSDbWorkSpace pDbWkSpace)
{    
    DWORD dwStatus=ERROR_SUCCESS;       
    TLSLICENSEPACK LicPack;
    BOOL fCommit = TRUE;

    pDbWkSpace->BeginTransaction();

    memset(&LicPack, 0, sizeof(LicPack));

    TLSDBLockKeyPackTable();        
    
    dwStatus = TLSDBKeyPackEnumBegin( 
                                pDbWkSpace, 
                                TRUE, 
                                LSKEYPACK_SEARCH_NONE,
                                &LicPack 
                            );
    if(dwStatus != ERROR_SUCCESS)
    {
        goto cleanup;
    }
    
    while(dwStatus == ERROR_SUCCESS)
    {
        if(!(LicPack.ucAgreementType & LSKEYPACK_REMOTE_TYPE) && LicPack.wMajorVersion == 5 && LicPack.wMinorVersion == 1)
        {            
            LicPack.wMinorVersion = 2;

            LicPack.szProductId[7] = _T('2');                        

            dwStatus=TLSDBKeyPackSetValues(
                        pDbWkSpace, 
                        TRUE, 
                        LSKEYPACK_SEARCH_MINORVERSION | LSKEYPACK_SEARCH_PRODUCTID, 
                        &LicPack
                        );
            if(dwStatus != ERROR_SUCCESS)
            {
                fCommit = FALSE;
            }
        }

        dwStatus = TLSDBKeyPackEnumNext(
                            pDbWkSpace, 
                            &LicPack
                        );        
    }    

    if(fCommit)
    {
        COMMIT_TRANSACTION(pDbWkSpace);
    }
    else
    {
        ROLLBACK_TRANSACTION(pDbWkSpace);
    }

    TLSDBKeyPackEnumEnd(pDbWkSpace);      

cleanup:
        
    TLSDBUnlockKeyPackTable();
    
    if(dwStatus == TLS_I_NO_MORE_DATA)
        dwStatus = ERROR_SUCCESS;
    
    return dwStatus;     
}


//---------------------------------------------------------------------
DWORD
TLSLogRemoveLicenseEvent(
    IN PTLSDbWorkSpace pDbWkSpace,
    IN PTLSLICENSEPACK plicensePack,
    IN DWORD dwNumLicenses
    )
/*++

Abstract:

    Log a 'license has been removed' event.

Parameter:

    pDbWkSpace : DB work space handle.
    pLicensePack : Pointer to license pack that available licenses
                   are to be remove.
    dwNumLicenses : Number of licenses has been removed.

Returns:

    ERROR_SUCCESS or error code.

--*/
{
    DWORD dwKpDescStatus = ERROR_SUCCESS;

    //
    LICPACKDESC kpDescSearch, kpDescFound;

    memset(&kpDescSearch, 0, sizeof(kpDescSearch));
    memset(&kpDescFound, 0, sizeof(kpDescFound));

    kpDescSearch.dwKeyPackId = plicensePack->dwKeyPackId;
    kpDescSearch.dwLanguageId = GetSystemDefaultLangID();

    dwKpDescStatus = TLSDBKeyPackDescFind(
                                    pDbWkSpace,
                                    TRUE,
                                    LSKEYPACK_SEARCH_KEYPACKID | LSKEYPACK_SEARCH_LANGID,
                                    &kpDescSearch,
                                    &kpDescFound
                                );

    if( dwKpDescStatus == TLS_E_RECORD_NOTFOUND && 
        GetSystemDefaultLangID() != MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US) )
    {
        // use english description
        kpDescSearch.dwLanguageId = MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US);

        dwKpDescStatus = TLSDBKeyPackDescFind(
                                        pDbWkSpace,
                                        TRUE,
                                        LSKEYPACK_SEARCH_KEYPACKID | LSKEYPACK_SEARCH_LANGID,
                                        &kpDescSearch,
                                        &kpDescFound
                                    );

    }

    if(dwKpDescStatus == ERROR_SUCCESS || dwKpDescStatus == TLS_E_RECORD_NOTFOUND)
    {
        //
        // Log event.
        //
        TCHAR szNumLicenses[25];
        LPCTSTR pString[3];

        wsprintf(
                szNumLicenses, 
                _TEXT("%d"), 
                dwNumLicenses
            );

        pString[0] = szNumLicenses;
        pString[1] = (dwKpDescStatus == ERROR_SUCCESS) ? 
                                        kpDescFound.szProductDesc :
                                        plicensePack->szProductId;

        pString[2] = g_szComputerName;
                                    
        TLSLogEventString(
                EVENTLOG_WARNING_TYPE,
                TLS_W_REMOVELICENSES,
                sizeof(pString)/sizeof(pString[0]),
                pString
            );

        dwKpDescStatus = ERROR_SUCCESS;
    }    

    return dwKpDescStatus;
}

//---------------------------------------------------------------------
DWORD
TLSRemoveLicensesFromInvalidDatabase(
    IN PTLSDbWorkSpace pDbWkSpace
    )
/*++

Abstract:

    Remove available licenses from all license pack.

Parameter:

    pDbWkSpace : Pointer to DB work space handle.

Return:

    ERROR_SUCCESS or error code.

--*/
{
    DWORD dwStatus = ERROR_SUCCESS;

    if(pDbWkSpace == NULL)
    {
        dwStatus = ERROR_INVALID_PARAMETER;
        return dwStatus;
    }


    pDbWkSpace->BeginTransaction();

    // all license keypack inserted has the setup id on it.
    TLSLICENSEPACK found;    

    memset( &found, 0, sizeof(found) );

    dwStatus = TLSDBKeyPackEnumBegin(
                                pDbWkSpace,
                                FALSE,
                                LSKEYPACK_SEARCH_NONE,
                                &found
                            );

    if(dwStatus != ERROR_SUCCESS)
    {
        TLSASSERT(FALSE);
        goto cleanup;
    }

    while(dwStatus == ERROR_SUCCESS)
    {
        dwStatus = TLSDBKeyPackEnumNext(
                                    pDbWkSpace,
                                    &found
                                );

        if(dwStatus != ERROR_SUCCESS)
        {
            continue;
        }

        if( _tcsicmp(found.szKeyPackId, HYDRAPRODUCT_HS_CERTIFICATE_KEYPACKID) == 0 &&
            _tcsicmp(found.szProductId, HYDRAPRODUCT_HS_CERTIFICATE_SKU) == 0 )
        {
            // don't touch terminal server certificate keypack
            continue;
        }

        if( (found.ucAgreementType & LSKEYPACK_REMOTE_TYPE) ||
            (found.ucKeyPackStatus & LSKEYPACKSTATUS_REMOTE) )
        {
            #if 0
            // Don't bother about remote keypack
            // remote license keypack, delete it.
            dwStatus = TLSDBKeyPackDeleteEntry(
                                        pDbWkSpace,
                                        TRUE,
                                        &found
                                    );

            //
            // non-critical error if failed.
            //
            #endif

            dwStatus = ERROR_SUCCESS;
            continue;
        }

        UCHAR ucAgreementType = found.ucAgreementType & ~LSKEYPACK_RESERVED_TYPE;
        UCHAR ucKeyPackStatus = found.ucKeyPackStatus &  ~LSKEYPACKSTATUS_RESERVED;

        if(ucKeyPackStatus == LSKEYPACKSTATUS_RETURNED)
        {
            //
            // This license pack has been restored before.
            //
            continue;
        }

        // 
        // Select, retail, concurrent, open
        //
        if( ucAgreementType == LSKEYPACKTYPE_SELECT ||
            ucAgreementType == LSKEYPACKTYPE_RETAIL ||
            ucAgreementType == LSKEYPACKTYPE_OPEN )
        {
            DWORD dwNumLicenses = found.dwNumberOfLicenses;

            // 
            // Mark license pack returned so that no license can be issued
            // from this license pack.
            //
            found.ucKeyPackStatus = LSKEYPACKSTATUS_RETURNED;
            dwStatus = TLSDBKeyPackUpdateEntry(
                                            pDbWkSpace,
                                            TRUE,
                                            LSKEYPACK_EXSEARCH_KEYPACKSTATUS,
                                            &found
                                        );

            if(dwStatus != ERROR_SUCCESS)
            {
                DBGPrintf(
                        DBG_ERROR,
                        DBG_FACILITY_UPGRADE,
                        DBG_ALL_LEVEL,
                        _TEXT("TLSDBKeyPackUpdateEntry() failed  - %d\n"),
                        dwStatus
                    );

                TLSASSERT(FALSE);               
                continue;
            }
            
            // log an event
            dwStatus = TLSLogRemoveLicenseEvent(
                                            pDbWkSpace,
                                            &found,
                                            dwNumLicenses
                                        );

            if(dwStatus != ERROR_SUCCESS)
            {
                continue;
            }
        }
    }

    TLSDBKeyPackEnumEnd(pDbWkSpace);

    if(dwStatus == TLS_I_NO_MORE_DATA)
    {
        dwStatus = ERROR_SUCCESS;
    }
    else if(dwStatus != ERROR_SUCCESS)
    {
        goto cleanup;
    }

cleanup:

    if(TLS_ERROR(dwStatus) == TRUE)
    {
        pDbWkSpace->RollbackTransaction(); 
    }
    else
    {
        pDbWkSpace->CommitTransaction();
    }    

    return dwStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\license\tlserver\server\utils.cpp ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996-1998
//
// File:        utils.cpp
//
// Contents:    Hydra License Server Service Control Manager Interface
//
// History:     12-09-97    HueiWang    Modified from MSDN RPC Service Sample
//
//---------------------------------------------------------------------------
#include "pch.cpp"
#include <lm.h>
#include <time.h>

#include "utils.h"


/////////////////////////////////////////////////////////////////////////////
BOOL
FileExists(
    IN  PCTSTR           FileName,
    OUT PWIN32_FIND_DATA FindData   OPTIONAL
    )

/*++

Routine Description:

    Determine if a file exists and is accessible.
    Errormode is set (and then restored) so the user will not see
    any pop-ups.

Arguments:

    FileName - supplies full path of file to check for existance.

    FindData - if specified, receives find data for the file.

Return Value:

    TRUE if the file exists and is accessible.
    FALSE if not. GetLastError() returns extended error info.

--*/

{
    WIN32_FIND_DATA findData;
    HANDLE FindHandle;
    DWORD Error;

    FindHandle = FindFirstFile(FileName,&findData);
    if(FindHandle == INVALID_HANDLE_VALUE) 
    {
        Error = GetLastError();
    } 
    else 
    {
        FindClose(FindHandle);
        if(FindData) 
        {
            *FindData = findData;
        }
        Error = NO_ERROR;
    }

     SetLastError(Error);
    return (Error == NO_ERROR);
}

/*----------------------------------------------------------------------------
Routine Description:

    This function checks to see whether the specified sid is enabled in
    the specified token.

Arguments:

    TokenHandle - If present, this token is checked for the sid. If not
        present then the current effective token will be used. This must
        be an impersonation token.

    SidToCheck - The sid to check for presence in the token

    IsMember - If the sid is enabled in the token, contains TRUE otherwise
        false.

Return Value:

    TRUE - The API completed successfully. It does not indicate that the
        sid is a member of the token.

    FALSE - The API failed. A more detailed status code can be retrieved
        via GetLastError()


Note : Code modified from 5.0 \\rastaman\ntwin\src\base\advapi\security.c
----------------------------------------------------------------------------*/
BOOL
TLSCheckTokenMembership(
    IN HANDLE TokenHandle OPTIONAL,
    IN PSID SidToCheck,
    OUT PBOOL IsMember
    )
{
    HANDLE ProcessToken = NULL;
    HANDLE EffectiveToken = NULL;
    DWORD  Status = ERROR_SUCCESS;
    PISECURITY_DESCRIPTOR SecDesc = NULL;
    ULONG SecurityDescriptorSize;
    GENERIC_MAPPING GenericMapping = { STANDARD_RIGHTS_READ,
                                       STANDARD_RIGHTS_EXECUTE,
                                       STANDARD_RIGHTS_WRITE,
                                       STANDARD_RIGHTS_ALL };
    //
    // The size of the privilege set needs to contain the set itself plus
    // any privileges that may be used. The privileges that are used
    // are SeTakeOwnership and SeSecurity, plus one for good measure
    //
    BYTE PrivilegeSetBuffer[sizeof(PRIVILEGE_SET) + 3*sizeof(LUID_AND_ATTRIBUTES)];
    PPRIVILEGE_SET PrivilegeSet = (PPRIVILEGE_SET) PrivilegeSetBuffer;
    ULONG PrivilegeSetLength = sizeof(PrivilegeSetBuffer);
    ACCESS_MASK AccessGranted = 0;
    BOOL AccessStatus = FALSE;
    PACL Dacl = NULL;

    #define MEMBER_ACCESS 1

    *IsMember = FALSE;

    //
    // Get a handle to the token
    //
    if (TokenHandle != NULL)
    {
        EffectiveToken = TokenHandle;
    }
    else
    {
        if(!OpenThreadToken(GetCurrentThread(),
                            TOKEN_QUERY,
                            FALSE,              // don't open as self
                            &EffectiveToken))
        {
            //
            // if there is no thread token, try the process token
            //
            if((Status=GetLastError()) == ERROR_NO_TOKEN)
            {
                if(!OpenProcessToken(GetCurrentProcess(),
                                     TOKEN_QUERY | TOKEN_DUPLICATE,
                                     &ProcessToken))
                {
                    Status = GetLastError();
                }

                //
                // If we have a process token, we need to convert it to an
                // impersonation token
                //
                if (Status == ERROR_SUCCESS)
                {
                    BOOL Result;
                    Result = DuplicateToken(ProcessToken,
                                            SecurityImpersonation,
                                            &EffectiveToken);
                    CloseHandle(ProcessToken);
                    if (!Result)
                    {
                        return(FALSE);
                    }
                }
            }

            if (Status != ERROR_SUCCESS)
            {
                goto Cleanup;
            }
        }
    }

    //
    // Construct a security descriptor to pass to access check
    //

    //
    // The size is equal to the size of an SD + twice the length of the SID
    // (for owner and group) + size of the DACL = sizeof ACL + size of the
    // ACE, which is an ACE + length of
    // ths SID.
    //

    SecurityDescriptorSize = sizeof(SECURITY_DESCRIPTOR) +
                                sizeof(ACCESS_ALLOWED_ACE) +
                                sizeof(ACL) +
                                3 * GetLengthSid(SidToCheck);

    SecDesc = (PISECURITY_DESCRIPTOR) LocalAlloc(LMEM_ZEROINIT, SecurityDescriptorSize );
    if (SecDesc == NULL)
    {
        Status = ERROR_OUTOFMEMORY;
        goto Cleanup;
    }
    Dacl = (PACL) (SecDesc + 1);

    InitializeSecurityDescriptor(SecDesc, SECURITY_DESCRIPTOR_REVISION);

    //
    // Fill in fields of security descriptor
    //
    SetSecurityDescriptorOwner(SecDesc, SidToCheck, FALSE);
    SetSecurityDescriptorGroup(SecDesc, SidToCheck, FALSE);

    if(!InitializeAcl(  Dacl,
                        SecurityDescriptorSize - sizeof(SECURITY_DESCRIPTOR),
                        ACL_REVISION))
    {
        Status=GetLastError();
        goto Cleanup;
    }

    if(!AddAccessAllowedAce(Dacl, ACL_REVISION, MEMBER_ACCESS, SidToCheck))
    {
        Status=GetLastError();  
        goto Cleanup;
    }

    if(!SetSecurityDescriptorDacl(SecDesc, TRUE, Dacl, FALSE))
    {
        Status=GetLastError();
        goto Cleanup;
    }

    if(!AccessCheck(SecDesc,
                    EffectiveToken,
                    MEMBER_ACCESS,
                    &GenericMapping,
                    PrivilegeSet,
                    &PrivilegeSetLength,
                    &AccessGranted,
                    &AccessStatus))
    {
        Status=GetLastError();
        goto Cleanup;
    }

    //
    // if the access check failed, then the sid is not a member of the
    // token
    //
    if ((AccessStatus == TRUE) && (AccessGranted == MEMBER_ACCESS))
    {
        *IsMember = TRUE;
    }


Cleanup:
    if (TokenHandle == NULL && EffectiveToken != NULL)
    {
        CloseHandle(EffectiveToken);
    }

    if (SecDesc != NULL)
    {
        LocalFree(SecDesc);
    }

    return (Status == ERROR_SUCCESS) ? TRUE : FALSE;
}


/*------------------------------------------------------------------------

 BOOL IsAdmin(void)

  returns TRUE if user is an admin
          FALSE if user is not an admin
------------------------------------------------------------------------*/
DWORD 
IsAdmin(
    BOOL* bMember
    )
{
    PSID psidAdministrators;
    SID_IDENTIFIER_AUTHORITY siaNtAuthority = SECURITY_NT_AUTHORITY;
    DWORD dwStatus=ERROR_SUCCESS;

    do {
        if(!AllocateAndInitializeSid(&siaNtAuthority, 
                                     2, 
                                     SECURITY_BUILTIN_DOMAIN_RID,
                                     DOMAIN_ALIAS_RID_ADMINS,
                                     0, 0, 0, 0, 0, 0,
                                     &psidAdministrators))
        {
            dwStatus=GetLastError();
            continue;
        }

        // assume that we don't find the admin SID.
        if(!TLSCheckTokenMembership(NULL,
                                   psidAdministrators,
                                   bMember))
        {
            dwStatus=GetLastError();
        }

        FreeSid(psidAdministrators);

    } while(FALSE);

    return dwStatus;
}

/////////////////////////////////////////////////////////////////////////////

BOOL 
LoadResourceString(
    DWORD dwId, 
    LPTSTR szBuf, 
    DWORD dwBufSize
    )
{
    int dwRet;

    dwRet=LoadString(GetModuleHandle(NULL), dwId, szBuf, dwBufSize);

    return (dwRet != 0);
}    

/////////////////////////////////////////////////////////////////////////////

HRESULT 
LogEvent(
    LPTSTR lpszSource,
    DWORD  dwEventType,
    DWORD  dwIdEvent,
    WORD   cStrings,
    TCHAR **apwszStrings
    )
/*++

--*/
{
    HANDLE hAppLog=NULL;
    BOOL bSuccess=FALSE;
    WORD wElogType;

    wElogType = (WORD) dwEventType;
    if(hAppLog=RegisterEventSource(NULL, lpszSource)) 
    {
        bSuccess = ReportEvent(
                            hAppLog,
                            wElogType,
                            0,
                            dwIdEvent,
                            NULL,
                            cStrings,
                            0,
                            (const TCHAR **) apwszStrings,
                            NULL
                        );

        DeregisterEventSource(hAppLog);
    }

    return((bSuccess) ? ERROR_SUCCESS : GetLastError());
}

/////////////////////////////////////////////////////////////////////////////

void 
TLSLogInfoEvent(
    IN DWORD code
    )
/*++

--*/
{
    LogEvent(
            _TEXT(SZSERVICENAME), 
            EVENTLOG_INFORMATION_TYPE, 
            code, 
            0, 
            NULL
        );
}

/////////////////////////////////////////////////////////////////////////////

void 
TLSLogWarningEvent(
    IN DWORD code
    )
/*++

--*/
{
    LogEvent(
            _TEXT(SZSERVICENAME), 
            EVENTLOG_WARNING_TYPE, 
            code, 
            0, 
            NULL
        );
}

/////////////////////////////////////////////////////////////////////////////

void 
TLSLogErrorEvent(
    IN DWORD errCode
    )
/*++

--*/
{
    LogEvent(
            _TEXT(SZSERVICENAME), 
            EVENTLOG_ERROR_TYPE, 
            errCode, 
            0, 
            NULL
        );
}

/////////////////////////////////////////////////////////////////////////////

void
TLSLogEventString(
    IN DWORD dwEventType,
    IN DWORD dwEventId,
    IN WORD wNumString,
    IN LPCTSTR* lpStrings
    )
/*++


--*/
{
    HANDLE hAppLog=NULL;
    BOOL bSuccess=FALSE;
    WORD wElogType = (WORD) dwEventType;

    if(hAppLog=RegisterEventSource(NULL, _TEXT(SZSERVICENAME))) 
    {
        bSuccess = ReportEvent(
                            hAppLog,
                            wElogType,
                            0,
                            dwEventId,
                            NULL,
                            wNumString,
                            0,
                            (const TCHAR **) lpStrings,
                            NULL
                        );

        DeregisterEventSource(hAppLog);
    }

    return;
}

/////////////////////////////////////////////////////////////////////////////

void 
TLSLogEvent(
    IN DWORD type, 
    IN DWORD EventId,
    IN DWORD code, ...
    )
/*
*/
{
    va_list marker;
    va_start( marker, code );
    DWORD dwRet;
    LPTSTR lpszTemp = NULL;

    dwRet=FormatMessage( FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_HMODULE | 
                                FORMAT_MESSAGE_FROM_SYSTEM,
                         NULL,
                         code,
                         LANG_NEUTRAL,
                         (LPTSTR)&lpszTemp,
                         0,
                         &marker);

    if(dwRet != 0)
    {
        LogEvent(_TEXT(SZSERVICENAME), type, EventId, 1, &lpszTemp);
        if(lpszTemp)
        {
            LocalFree((HLOCAL)lpszTemp);
        }
    }   

    va_end( marker );
    return;
}

///////////////////////////////////////////////////////////////////////

BOOL
TLSSystemTimeToFileTime(
    SYSTEMTIME* pSysTime,
    LPFILETIME pfTime
    )
/*++

--*/
{
DoConvert:

    if(SystemTimeToFileTime(pSysTime, pfTime) == FALSE)
    {
        if(GetLastError() != ERROR_INVALID_PARAMETER)
        {
            TLSASSERT(FALSE);
            return FALSE;
        }

        if(pSysTime->wMonth == 2)
        {
            if(pSysTime->wDay > 29)
            {
                pSysTime->wDay = 29;
                goto DoConvert;
            }   
            else if(pSysTime->wDay == 29)
            {
                pSysTime->wDay = 28;
                goto DoConvert;
            }
        }
        else if ((pSysTime->wMonth == 9) ||
                 (pSysTime->wMonth == 4) ||
                 (pSysTime->wMonth == 6) ||
                 (pSysTime->wMonth == 11))
        {
            if (pSysTime->wDay > 30)
            {
                pSysTime->wDay = 30;
                goto DoConvert;
            }
        }
    }

    return TRUE;
}

///////////////////////////////////////////////////////////////////////
BOOL
FileTimeToLicenseDate(
    LPFILETIME pft,
    DWORD* t
    )
/*++

++*/
{
    SYSTEMTIME sysTime;
    struct tm gmTime;
    FILETIME localFt;
    time_t licenseTime;

    if(FileTimeToLocalFileTime(pft, &localFt) == FALSE)
    {
        return FALSE;
    }

    if(FileTimeToSystemTime(&localFt, &sysTime) == FALSE)
    {
        return FALSE;
    }

    if(sysTime.wYear >= 2038)
    {
        licenseTime = INT_MAX;
    }
    else
    {
        // Unix time support up to 2038/1/18
        // restrict any expiration data 
        memset(&gmTime, 0, sizeof(gmTime));
        gmTime.tm_sec = sysTime.wSecond;
        gmTime.tm_min = sysTime.wMinute;
        gmTime.tm_hour = sysTime.wHour;
        gmTime.tm_year = sysTime.wYear - 1900;
        gmTime.tm_mon = sysTime.wMonth - 1;
        gmTime.tm_mday = sysTime.wDay;
        gmTime.tm_isdst = -1;

        if((licenseTime = mktime(&gmTime)) == (time_t)-1)
        {
            SetLastError(ERROR_INVALID_PARAMETER);
        }
    }

    *t = (DWORD)licenseTime;

    return licenseTime != (time_t)-1;
}
    

///////////////////////////////////////////////////////////////////////

void 
UnixTimeToFileTime(
    time_t t, 
    LPFILETIME pft
    )   
{
    LARGE_INTEGER li;

    li.QuadPart = Int32x32To64(t, 10000000) + 116444736000000000;

    pft->dwHighDateTime = li.HighPart;
    pft->dwLowDateTime = li.LowPart;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\license\tlserver\server\wkspace.h ===
//+--------------------------------------------------------------------------
//
// Copyright (c) 1997-1999 Microsoft Corporation
//
// File:       wkspace.h 
//
// Contents:    
//
// History:     
//
//---------------------------------------------------------------------------
#ifndef __TLSDBWORKSPACE_H__
#define __TLSDBWORKSPACE_H__

#include "SrvDef.h"
//
// from TLSDb
//
#include "JBDef.h"
#include "JetBlue.h"
#include "TLSDb.h"
#include "backup.h"
#include "KPDesc.h"
#include "Licensed.h"
#include "licpack.h"
#include "version.h"
#include "workitem.h"

struct __TLSDbWorkSpace;

//
// Temporary define workspace to be 32
//
#define MAX_WORKSPACE   32

typedef CHandlePool<
    struct __TlsDbWorkSpace *, 
    MAX_WORKSPACE
> TLSDbWorkSpacePool;


//---------------------------------------------------------------------------
typedef struct __TlsDbWorkSpace {

    // one instance for all session
    static JBInstance g_JbInstance;

    //------------------------------------------------
    // 
    // JetBlue transaction is session based and no 
    // two thread can use same session
    //

    JBSession  m_JetSession;
    JBDatabase m_JetDatabase;

    //
    // These table should be kept open
    //
    LicPackTable            m_LicPackTable;
    LicensedTable           m_LicensedTable;

    //
    // LicPackDesc table is used by enumeration and 
    // adding license pack open as necessary.
    //
    LicPackDescTable        m_LicPackDescTable;


    //-----------------------------------------------
    BOOL
    BeginTransaction() 
    {
        BOOL bSuccess;
        bSuccess = m_JetDatabase.BeginTransaction();    
        return bSuccess;                     
    }

    //-----------------------------------------------
    BOOL
    CommitTransaction() 
    {
        BOOL bSuccess;
                                
        bSuccess = m_JetDatabase.CommitTransaction();
        
        return bSuccess;
    }

    //-----------------------------------------------
    BOOL
    RollbackTransaction() 
    {
        BOOL bSuccess;

        bSuccess = m_JetDatabase.RollbackTransaction();
        
        return bSuccess;
    }

    //-----------------------------------------------
    void
    Cleanup() 
    {
        m_LicPackTable.Cleanup();
        m_LicPackDescTable.Cleanup();
        m_LicensedTable.Cleanup();
    }


    //------------------------------------------------
    __TlsDbWorkSpace() :
        m_JetSession(g_JbInstance),
        m_JetDatabase(m_JetSession),
        m_LicPackTable(m_JetDatabase),
        m_LicPackDescTable(m_JetDatabase),
        m_LicensedTable(m_JetDatabase)
    /*
    */
    {
        //
        // Force apps to call InitWorkSpace...
        //
    }

    //------------------------------------------------
    ~__TlsDbWorkSpace() 
    {
        m_LicPackTable.CloseTable();
        m_LicPackDescTable.CloseTable();
        m_LicensedTable.CloseTable();

        m_JetDatabase.CloseDatabase();
        m_JetSession.EndSession();
    }

    //------------------------------------------------
    BOOL
    InitWorkSpace(
        BOOL bCreateIfNotExist,
        LPCTSTR szDatabaseFile,
        LPCTSTR szUserName=NULL,
        LPCTSTR szPassword=NULL,
        IN LPCTSTR szChkPointDirPath=NULL,
        IN LPCTSTR szTempDirPath=NULL,
        IN BOOL bUpdatable = FALSE
    );
            
} TLSDbWorkSpace, *LPTLSDbWorkSpace, *PTLSDbWorkSpace;

#ifdef __cplusplus
extern "C" {
#endif

    BOOL
    TLSJbInstanceInit(
        IN OUT JBInstance& jbInstance,
        IN LPCTSTR pszChkPointDirPath,
        IN LPCTSTR pszTempDirPath,
        IN LPCTSTR pszLogDirPath
    );

    TLSDbWorkSpace* 
    AllocateWorkSpace(
        DWORD dwWaitTime
    );

    void
    ReleaseWorkSpace(
        PTLSDbWorkSpace *p
    );

    // 
    BOOL
    InitializeWorkSpacePool( 
        int num_workspace, 
        LPCTSTR szDatabaseFile, 
        LPCTSTR szUserName,
        LPCTSTR szPassword,
        LPCTSTR szChkPointDirPath,
        LPCTSTR szTempDirPath,
        LPCTSTR szLogDirPath,
        BOOL bUpdatable
    );

    DWORD
    CloseWorkSpacePool();

    WorkItemTable*
    GetWorkItemStorageTable();
    
    DWORD
    GetNumberOfWorkSpaceHandle();

    BOOL
    TLSGetESEError(
        const JET_ERR jetErrCode,
        LPTSTR* pszString
    );

    BOOL
    IsValidAllocatedWorkspace(
        PTLSDbWorkSpace p
    );

#ifdef __cplusplus
}
#endif
    

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\license\tlserver\server\tlsrpc.cpp ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996-1996
//
// File:        tlsrpc.c
//
// Contents:    Various RPC function to accept client request
//
// History:     12-09-98    HueiWang    Created
//
//---------------------------------------------------------------------------
#include "pch.cpp"
#include "server.h"
#include "gencert.h"
#include "kp.h"
#include "keypack.h"
#include "clilic.h"
#include "postjob.h"
#include "srvlist.h"
#include "utils.h"
#include "misc.h"
#include "licreq.h"
#include "server.h"
#include "init.h"
#include "globals.h"
#include "db.h"
#include "tlscert.h"
#include "permlic.h"
#include "remotedb.h"
#include <winsta.h>

BOOL g_bLockValid = FALSE;

CCMutex g_AdminLock;
CCMutex g_RpcLock;
CCEvent g_ServerShutDown(TRUE, FALSE);

extern PSECURITY_DESCRIPTOR g_pSecDes;


/****************************************************************************/
// TSLSRPCAccessCheck
//
// Check if this RPC caller havs access right or not
/****************************************************************************/
BOOL TSLSRPCAccessCheck()
{
    RPC_STATUS rpcStatus;
    HANDLE hClientToken = NULL;
    DWORD dwStatus = ERROR_SUCCESS;
    GENERIC_MAPPING GenericMapping = { STANDARD_RIGHTS_READ,
                                       STANDARD_RIGHTS_EXECUTE,
                                       STANDARD_RIGHTS_WRITE,
                                       STANDARD_RIGHTS_ALL };

    BYTE PrivilegeSetBuffer[sizeof(PRIVILEGE_SET) + 3*sizeof(LUID_AND_ATTRIBUTES)];
    PPRIVILEGE_SET PrivilegeSet = (PPRIVILEGE_SET) PrivilegeSetBuffer;
    ULONG PrivilegeSetLength = sizeof(PrivilegeSetBuffer);
    ACCESS_MASK AccessGranted = 0;
    BOOL AccessStatus = FALSE;

    if(g_pSecDes == NULL)
    return TRUE;

    // Check the access right of this rpc call
    rpcStatus = RpcImpersonateClient(0);

    if (RPC_S_OK != rpcStatus) 
    {
        dwStatus = E_FAIL;
        DBGPrintf(
                DBG_INFORMATION,
                DBG_FACILITY_RPC,
                DBGLEVEL_FUNCTION_TRACE,
                _TEXT("RpcImpersonateClient() failed\n")
            );

        goto cleanup;
    }

    // get the impersonated token
    if (!OpenThreadToken(GetCurrentThread(), TOKEN_QUERY, FALSE, &hClientToken)) 
    {
        dwStatus = GetLastError();
        DBGPrintf(
                DBG_INFORMATION,
                DBG_FACILITY_RPC,
                DBGLEVEL_FUNCTION_TRACE,
                _TEXT("OpenThreadToken() failed\n")
            );

        RpcRevertToSelf();
        goto cleanup;
    }

    RpcRevertToSelf();
    
    if (!AccessCheck(g_pSecDes,
                    hClientToken,
                    STANDARD_RIGHTS_READ,
                    &GenericMapping,
                    PrivilegeSet,
                    &PrivilegeSetLength,
                    &AccessGranted,
                    &AccessStatus)) 
    {
        dwStatus = GetLastError();
        DBGPrintf(
                DBG_INFORMATION,
                DBG_FACILITY_RPC,
                DBGLEVEL_FUNCTION_TRACE,
                _TEXT("AccessCheck() failed\n")
            );

        
        goto cleanup;
    }
    
cleanup:
    if (hClientToken != NULL) 
    {
        CloseHandle(hClientToken);
    }

    return AccessStatus;
}


/////////////////////////////////////////////////////////////////////////////////
DWORD 
SecureModeCheck()
{
    DWORD dwStatus = ERROR_SUCCESS;
    BOOL AccessStatus = FALSE;
    BOOL fInDomain = FALSE;
    WCHAR *StringBinding = NULL;
    WCHAR *ServerAddress = NULL;
    RPC_BINDING_HANDLE ServerBinding = 0;


    POLICY_TS_MACHINE groupPolicy;
    RegGetMachinePolicy(&groupPolicy);
    BOOL bSecureLicensing = FALSE;    

    if( groupPolicy.fPolicySecureLicensing == 1 && groupPolicy.fSecureLicensing == 1)
    {
        bSecureLicensing = TRUE;
    }

    if(bSecureLicensing == TRUE)
    {
        dwStatus = TLSInDomain(&fInDomain, NULL);

        if(dwStatus == ERROR_SUCCESS && fInDomain == TRUE)
        {        
            // Check this rpc access right
            AccessStatus = TSLSRPCAccessCheck();
            if (!AccessStatus) 
            {
                // Determine client address.
                dwStatus = RpcBindingServerFromClient(0, &ServerBinding);
                if(dwStatus != RPC_S_OK)
                {
                    return TLS_E_ACCESS_DENIED;
                }
                dwStatus = RpcBindingToStringBinding(ServerBinding, &StringBinding);
                if( dwStatus != RPC_S_OK)
                {
                    return TLS_E_ACCESS_DENIED;
                }
                dwStatus = RpcStringBindingParse(StringBinding, NULL, NULL, &ServerAddress, NULL, NULL);

                if( dwStatus != RPC_S_OK)
                {        
                    return TLS_E_ACCESS_DENIED;
                }

                {
                    LPCTSTR rgString[] = {ServerAddress};

                    TLSLogEventString(
                        EVENTLOG_ERROR_TYPE,
                        TLS_E_LICENSE_ISSUANCE_ACCESS_DENIED,
                        1,
                        rgString);
                }
                return TLS_E_ACCESS_DENIED;
            }
            else
            {
                return ERROR_SUCCESS;
            }
        }
        else
        {
            return ERROR_SUCCESS;
        }
    }
    else
    {
        return ERROR_SUCCESS;
    }
}


BOOL 
VerifyLicenseRequest(
    PTLSLICENSEREQUEST pLicenseRequest
    )
/*++

--*/
{
    BOOL bValid = FALSE;

    if(pLicenseRequest == NULL)
    {
        DBGPrintf(
                DBG_INFORMATION,
                DBG_FACILITY_RPC,
                DBGLEVEL_FUNCTION_TRACE,
                _TEXT("VerifyLicenseRequest() invalid input\n")
            );

        goto cleanup;
    }

    if( pLicenseRequest->cbEncryptedHwid == 0 || 
        pLicenseRequest->pbEncryptedHwid == NULL)
    {
        DBGPrintf(
                DBG_INFORMATION,
                DBG_FACILITY_RPC,
                DBGLEVEL_FUNCTION_TRACE,
                _TEXT("VerifyLicenseRequest() invalid HWID\n")
            );


        goto cleanup;
    }

    if( pLicenseRequest->ProductInfo.cbCompanyName == 0 || 
        pLicenseRequest->ProductInfo.pbCompanyName == NULL )
    {
        DBGPrintf(
                DBG_INFORMATION,
                DBG_FACILITY_RPC,
                DBGLEVEL_FUNCTION_TRACE,
                _TEXT("VerifyLicenseRequest() invalid company name\n")
            );


        goto cleanup;
    }

    if( pLicenseRequest->ProductInfo.cbProductID == 0 || 
        pLicenseRequest->ProductInfo.pbProductID == NULL )
    {
        DBGPrintf(
                DBG_INFORMATION,
                DBG_FACILITY_RPC,
                DBGLEVEL_FUNCTION_TRACE,
                _TEXT("VerifyLicenseRequest() invalid product id\n")
            );


        goto cleanup;
    }

    bValid = TRUE;

cleanup:

    return bValid;
}


/////////////////////////////////////////////////////////////////////////////

BOOL 
WaitForMyTurnOrShutdown(
    HANDLE hHandle, 
    DWORD dwWaitTime
    )
/*


*/
{
    // 
    // Shutdown event is first one in the wait list
    // reason is when service thread signal shutdow, at the same time,
    // there might be a RPC call entering WaitForMultipleObjects() call and
    // it will return WAIT_OBJECT_0 and continue on, this is not desirable
    // since we want it to return can't get handle and exit RPC call immediately
    //
    HANDLE  waitHandles[2]={g_ServerShutDown.hEvent, hHandle};
    DWORD   dwStatus;

    //
    // Could be return shutting down...
    //
    dwStatus=WaitForMultipleObjects(
                        sizeof(waitHandles)/sizeof(waitHandles[0]), 
                        waitHandles, 
                        FALSE, 
                        dwWaitTime
                    );

    return (dwStatus == WAIT_OBJECT_0 + 1) || (dwStatus == WAIT_ABANDONED_0 + 1);
}

//////////////////////////////////////////////////////

HANDLE
GetServiceShutdownHandle()
{
    return g_ServerShutDown.hEvent;
}

void 
ServiceSignalShutdown()
{
    g_ServerShutDown.SetEvent();
}

void 
ServiceResetShutdownEvent()
{
    g_ServerShutDown.ResetEvent();
}

BOOL
IsServiceShuttingdown()
{
    if(g_bLockValid == FALSE)
        return TRUE;
    else
        return (WaitForSingleObject(g_ServerShutDown.hEvent, 0) == WAIT_OBJECT_0);
}


//////////////////////////////////////////////////////

BOOL 
AcquireRPCExclusiveLock(
    IN DWORD dwWaitTime
    )

/*++

Abstract:

    Acquire exclusive lock for RPC interface.

Parameter:

    dwWaitTime : Wait time.

Return:

    TRUE/FALSE

--*/

{
    return WaitForMyTurnOrShutdown(
                                g_RpcLock.hMutex,
                                dwWaitTime
                            );
}

//////////////////////////////////////////////////////

void
ReleaseRPCExclusiveLock()
{
    g_RpcLock.Unlock();
}

//////////////////////////////////////////////////////

BOOL
AcquireAdministrativeLock(
    IN DWORD dwWaitTime
    )
/*++

Abstract:

    Acquire lock for administrative action.

Parameter:

    dwWaitTime : Time to wait for the lock.

Returns:

    TRUE/FALSE.

--*/

{
    return WaitForMyTurnOrShutdown(
                                g_AdminLock.hMutex, 
                                dwWaitTime
                            );
}

//////////////////////////////////////////////////////

void
ReleaseAdministrativeLock()
/*++

--*/
{
    g_AdminLock.Unlock();
}


//-----------------------------------------------------------------------

DWORD 
TLSVerifyHydraCertificate(
    PBYTE pHSCert, 
    DWORD cbHSCert
    )
/*

*/
{
    DWORD dwStatus;

    dwStatus = TLSVerifyProprietyChainedCertificate(
                                        g_hCryptProv, 
                                        pHSCert, 
                                        cbHSCert
                                    );

    if(dwStatus != ERROR_SUCCESS)
    {
        Hydra_Server_Cert hCert;

        memset(&hCert, 0, sizeof(Hydra_Server_Cert));

        dwStatus=UnpackHydraServerCertificate(pHSCert, cbHSCert, &hCert);
        if(dwStatus == LICENSE_STATUS_OK)
        {
            dwStatus=LicenseVerifyServerCert(&hCert);

            if(hCert.PublicKeyData.pBlob)
                free(hCert.PublicKeyData.pBlob);

            if(hCert.SignatureBlob.pBlob)
                free(hCert.SignatureBlob.pBlob);
        }
    }

    return dwStatus;
}

//-------------------------------------------------------------------------
// 
//  General RPC routines
//

void * __RPC_USER 
MIDL_user_allocate(size_t size)
{
    void* ptr=AllocateMemory(size);

    // DBGPrintf(0xFFFFFFFF, _TEXT("Allocate 0x%08x, size %d\n"), ptr, size);
    return ptr;
}

void __RPC_USER 
MIDL_user_free(void *pointer)
{
    FreeMemory(pointer);
}


//-------------------------------------------------------------------------

BOOL 
ValidContextHandle(
    IN PCONTEXT_HANDLE phContext
    )
/*++
Description: 

    Verify client context handle.

Arguments:

    phContext - client context handle return from TLSRpcConnect().


Return:

    TRUE/FALSE

++*/
{
#if DBG

    BOOL bValid;
    LPCLIENTCONTEXT lpClientContext = (LPCLIENTCONTEXT)phContext;

    bValid = (lpClientContext->m_PreDbg[0] == 0xcdcdcdcd && lpClientContext->m_PreDbg[1] == 0xcdcdcdcd &&
              lpClientContext->m_PostDbg[0] == 0xcdcdcdcd && lpClientContext->m_PostDbg[1] == 0xcdcdcdcd);
    if(!bValid)
    {
        DBGPrintf(
                DBG_ERROR,
                DBG_FACILITY_RPC,
                DBGLEVEL_FUNCTION_TRACE,
                _TEXT("ValidContextHandle : Bad client context\n")
            );

        TLSASSERT(FALSE);
    }

    return bValid;

#else

    return TRUE;

#endif
}

//-------------------------------------------------------------------------

void 
__RPC_USER PCONTEXT_HANDLE_rundown(
    PCONTEXT_HANDLE phContext
    )
/*++

Description:

    Client context handle cleanup, called when client disconnect normally 
    or abnormally, see context handle rundown routine help on RPC

Argument:

    phContext - client context handle.

Returns:

    None

++*/
{
    DBGPrintf(
            DBG_INFORMATION,
            DBG_FACILITY_RPC,
            DBGLEVEL_FUNCTION_TRACE,
            _TEXT("PCONTEXT_HANDLE_rundown...\n")
        );

    TLSASSERT(phContext != NULL);

    if(g_bLockValid == FALSE)
    {
        return;
    }
        
    //
    // If service is shutting down, exit right away without freeing up memory,
    //
    // Durning shutdown, RPC wait until all call completed but it does not wait
    // until all open connection has 'rundown' if client is still in enumeration,
    // this will cause ReleaseWorkSpace() to assert.  Instead of using one more
    // HANDLE to wait until all open connection has been rundown, we return right
    // away to speed up shutdown time
    //
    if( phContext && ValidContextHandle(phContext) )
    {
        LPCLIENTCONTEXT lpClientContext = (LPCLIENTCONTEXT)phContext;

        DBGPrintf(
                DBG_INFORMATION,
                DBG_FACILITY_RPC,
                DBGLEVEL_FUNCTION_TRACE,
                _TEXT("Disconnect from %s\n"),
                lpClientContext->m_Client
            );            

        assert(lpClientContext->m_RefCount == 0);                          
    
        if( IsServiceShuttingdown() == FALSE )
        {
            switch(lpClientContext->m_ContextType)
            {
                case CONTEXTHANDLE_LICENSE_ENUM_TYPE:
                    {
                        PTLSDbWorkSpace pDbWkSpace = (PTLSDbWorkSpace)lpClientContext->m_ContextHandle;

                        if( IsValidAllocatedWorkspace(pDbWkSpace) == TRUE )
                        {
                            ReleaseWorkSpace(&pDbWkSpace);
                        }
                    }
                    break;

                case CONTEXTHANDLE_KEYPACK_ENUM_TYPE:
                    {
                        LPENUMHANDLE hEnum=(LPENUMHANDLE)lpClientContext->m_ContextHandle;

                        if( IsValidAllocatedWorkspace(hEnum->pbWorkSpace) == TRUE )
                        {
                            TLSDBLicenseKeyPackEnumEnd(hEnum);
                        }

                        lpClientContext->m_ContextType = CONTEXTHANDLE_EMPTY_TYPE;
                        lpClientContext->m_ContextHandle=NULL;
                    }
                    break;

                case CONTEXTHANDLE_HYDRA_REQUESTCERT_TYPE:
                    {
                        LPTERMSERVCERTREQHANDLE lpHandle=(LPTERMSERVCERTREQHANDLE)lpClientContext->m_ContextHandle;
                        midl_user_free(lpHandle->pCertRequest);
                        midl_user_free(lpHandle->pbChallengeData);
                        FreeMemory(lpHandle);
                    }
                    break;

                case CONTEXTHANDLE_CHALLENGE_SERVER_TYPE:
                case CONTEXTHANDLE_CHALLENGE_LRWIZ_TYPE:
                case CONTEXTHANDLE_CHALLENGE_TERMSRV_TYPE:
                    {
                        PTLSCHALLENGEDATA pChallengeData = (PTLSCHALLENGEDATA) lpClientContext->m_ContextHandle;
                        if(pChallengeData)
                        {
                            FreeMemory(pChallengeData->pbChallengeData);
                            FreeMemory(pChallengeData);
                        }
                    }
            }
        }
        else
        {
            DBGPrintf(
                DBG_INFORMATION,
                DBG_FACILITY_RPC,
                DBGLEVEL_FUNCTION_TRACE,
                _TEXT("PCONTEXT_HANDLE_rundown while shutting down...\n")
            );
        }                

        if( lpClientContext->m_Client )
        {
            FreeMemory(lpClientContext->m_Client);
        }

        midl_user_free(lpClientContext);
    }

    return;
}


//----------------------------------------------------------------------------------
DWORD
GetClientPrivilege(
    IN handle_t hRpcBinding
    )

/*++
Description:

    Return client's privilege level

Arguments:
    
    hRpcBinding - Client's RPC binding handle.

Return:

    Client's privilege level

++*/
{
    DWORD dwStatus = CLIENT_ACCESS_USER;
    BOOL bAdmin=FALSE;
    RPC_STATUS rpc_status;

    // If a value of zero is specified, the server impersonates the client that 
    // is being served by this server thread
    rpc_status = RpcImpersonateClient(hRpcBinding);

    if(rpc_status == RPC_S_OK)
    {
        IsAdmin(&bAdmin);
        dwStatus = (bAdmin) ? CLIENT_ACCESS_ADMIN : CLIENT_ACCESS_USER;

        rpc_status = RpcRevertToSelfEx(hRpcBinding);
    }

    return dwStatus;
}

//-------------------------------------------------------------------------------
error_status_t 
TLSRpcConnect( 
    /* [in] */ handle_t binding,
    /* [out] */ PCONTEXT_HANDLE __RPC_FAR *pphContext
    )
/*++

Description:

    Connect client and allocate/return client context handle.

Arguments:

    hRPCBinding - RPC binding handle
    pphContext - client context handle.

Returns via dwErrCode.

    RPC_S_ACCESS_DENIED or LSERVER_S_SUCCESS.

++*/
{
    DWORD status=ERROR_SUCCESS;
    DWORD dwPriv;
    error_status_t t;

    RPC_BINDING_HANDLE hClient=NULL;
    WCHAR * pszRpcStrBinding=NULL;

    LPTSTR pszClient=NULL;
       
    if(RpcBindingServerFromClient(binding, &hClient) == RPC_S_OK)
    {
        status = RpcBindingToStringBinding( hClient, &pszRpcStrBinding );
        RpcBindingFree(&hClient);

        if (status != RPC_S_OK)
        {
            goto cleanup;
        }        
    }

    //
    // need to load from resource file
    //
    pszClient = (LPTSTR)AllocateMemory(
                            (_tcslen((pszRpcStrBinding) ? pszRpcStrBinding : _TEXT("Unknown")) + 1) * sizeof(TCHAR)
                        );

    if(pszClient == NULL)
    {
        status = ERROR_OUTOFMEMORY;
        goto cleanup;
    }

    _tcscpy(pszClient,
            (pszRpcStrBinding) ? pszRpcStrBinding : _TEXT("Unknown")
        );

    if(pszRpcStrBinding)
    {
        RpcStringFree(&pszRpcStrBinding);
    }
        
    DBGPrintf(
        DBG_INFORMATION,
        DBG_FACILITY_RPC,
        DBGLEVEL_FUNCTION_TRACE,
        _TEXT("Connect from client %s\n"), 
        pszClient
    );

    dwPriv=GetClientPrivilege(binding);

    LPCLIENTCONTEXT lpContext;

    lpContext=(LPCLIENTCONTEXT)midl_user_allocate(sizeof(CLIENTCONTEXT));
    if(lpContext == NULL)
    {
        status = ERROR_OUTOFMEMORY;
        goto cleanup;
    }

    #if DBG
    lpContext->m_LastCall = RPC_CALL_CONNECT;
    lpContext->m_PreDbg[0] = 0xcdcdcdcd;
    lpContext->m_PreDbg[1] = 0xcdcdcdcd;
    lpContext->m_PostDbg[0] = 0xcdcdcdcd;
    lpContext->m_PostDbg[1] = 0xcdcdcdcd;
    #endif

    lpContext->m_Client = pszClient;

    lpContext->m_RefCount = 0;
    *pphContext=lpContext;
    lpContext->m_ContextType = CONTEXTHANDLE_EMPTY_TYPE;
    lpContext->m_ClientFlags = dwPriv;

cleanup:

    if(status != ERROR_SUCCESS)
    {
        FreeMemory(pszClient);
    }

    t = TLSMapReturnCode(status);

    return t;
}

//-------------------------------------------------------------------------------
error_status_t 
TLSRpcDisconnect( 
    /* [out][in] */ PPCONTEXT_HANDLE pphContext
    )
/*++

Description:

    Disconnect client and FreeMemory all memory allocated on the behalf of client         

Arguments:

    pphContext - pointer to client context handle

Returns:

    LSERVER_S_SUCCESS or ERROR_INVALID_HANDLE

++*/
{
    DWORD Status=ERROR_SUCCESS;

    if( (pphContext == NULL) || (!ValidContextHandle(*pphContext)) || (*pphContext == NULL) )
    {
        Status = ERROR_INVALID_HANDLE;
    }
    else
    {
        PCONTEXT_HANDLE_rundown(*pphContext);
        *pphContext = NULL;
    }          
    
    return TLSMapReturnCode(Status);
}

//-------------------------------------------------------------------------------

error_status_t 
TLSRpcGetVersion( 
    /* [in] */ PCONTEXT_HANDLE phContext,
    /* [ref][out][in] */ PDWORD pdwVersion
    )
/*++

++*/
{
    LPCLIENTCONTEXT lpContext = (LPCLIENTCONTEXT)phContext;

    if(lpContext == NULL || pdwVersion == NULL)
    {
        return RPC_S_INVALID_ARG;
    }

    InterlockedIncrement( &lpContext->m_RefCount );

    DBGPrintf(
            DBG_INFORMATION,
            DBG_FACILITY_RPC,
            DBGLEVEL_FUNCTION_TRACE,
            _TEXT("%s : TLSRpcGetVersion\n"),
            lpContext->m_Client
        );

    if(TLSIsBetaNTServer() == TRUE)
    {
        *pdwVersion = TLS_CURRENT_VERSION;
    }
    else
    {
        *pdwVersion = TLS_CURRENT_VERSION_RTM;
    }

    if(g_SrvRole & TLSERVER_ENTERPRISE_SERVER)
    {
        *pdwVersion |= TLS_VERSION_ENTERPRISE_BIT;
    }

    DBGPrintf(
            DBG_INFORMATION,
            DBG_FACILITY_RPC,
            DBGLEVEL_FUNCTION_DETAILSIMPLE,
            _TEXT("%s : TLSRpcGetVersion return 0x%08x\n"),
            lpContext->m_Client,
            *pdwVersion
        );

    InterlockedDecrement( &lpContext->m_RefCount );
    return RPC_S_OK;
}


//-------------------------------------------------------------------------------
error_status_t 
TLSRpcGetSupportFlags( 
    /* [in] */ PCONTEXT_HANDLE phContext,
    /* [ref][out] */ DWORD *pdwSupportFlags
    )
/*++

++*/
{
    error_status_t status = RPC_S_OK;

    LPCLIENTCONTEXT lpContext = (LPCLIENTCONTEXT)phContext;

    if(lpContext == NULL)
    {
        return RPC_S_INVALID_ARG;
    }

    InterlockedIncrement( &lpContext->m_RefCount );

    DBGPrintf(
            DBG_INFORMATION,
            DBG_FACILITY_RPC,
            DBGLEVEL_FUNCTION_TRACE,
            _TEXT("%s : TLSRpcGetSupportFlags\n"),
            lpContext->m_Client
        );

    if (NULL != pdwSupportFlags)
    {
        *pdwSupportFlags = ALL_KNOWN_SUPPORT_FLAGS;
    }
    else
    {
        status = ERROR_INVALID_PARAMETER;
    }

    InterlockedDecrement( &lpContext->m_RefCount );
    return status;
}

//-------------------------------------------------------------------------------

error_status_t 
TLSRpcSendServerCertificate( 
    /* [in] */ PCONTEXT_HANDLE phContext,
    /* [in] */ DWORD cbCert,
    /* [size_is][in] */ PBYTE pbCert,
    /* [ref][out][in] */ PDWORD dwErrCode
    )
/*++

Description:

    This routine is for License Server to identify hydra server, hydra server
    need to send its certificate in order to gain certificate request privilege.

Arguments:

    phContext - client context handle.
    cbCert - size of hydra server certificate.
    pbCert - hydra server's self-created certificate.
    dwErrCode - return code.

Returns via dwErrCode

    LSERVER_E_INVALID_DATA.

++*/
{
    DWORD status=ERROR_SUCCESS;

    BOOL fInDomain = FALSE;
    WCHAR *StringBinding = NULL;
    WCHAR *ServerAddress = NULL;
    RPC_BINDING_HANDLE ServerBinding = 0;
    
    status = SecureModeCheck();

    if(dwErrCode == NULL)
    {
        return RPC_S_INVALID_ARG;
    }

    if(status != ERROR_SUCCESS )
    {                    
        *dwErrCode = TLSMapReturnCode(status);
        return RPC_S_OK;        
    }

    LPCLIENTCONTEXT lpContext = (LPCLIENTCONTEXT)phContext;

    if(lpContext == NULL)
    {
        return RPC_S_INVALID_ARG;
    }
    InterlockedIncrement( &lpContext->m_RefCount );

    DBGPrintf(
            DBG_INFORMATION,
            DBG_FACILITY_RPC,
            DBGLEVEL_FUNCTION_TRACE,
            _TEXT("%s : TLSRpcSendServerCertificate\n"),
            lpContext->m_Client
        );

    if(pbCert == NULL || cbCert == 0 || 
       TLSVerifyHydraCertificate(pbCert, cbCert) != LICENSE_STATUS_OK)
    {
        DBGPrintf(
                DBG_WARNING,
                DBG_FACILITY_RPC,
                DBGLEVEL_FUNCTION_DETAILSIMPLE,
                _TEXT("TLSRpcSendServerCertificate : client %s send invalid certificate\n"),
                lpContext->m_Client
            );

        status = TLS_E_INVALID_DATA;
    }
    else
    {
        lpContext->m_ClientFlags |= CLIENT_ACCESS_REQUEST;
    }        

    // midl_user_free(pbCert);

    lpContext->m_LastError=status;
    InterlockedDecrement( &lpContext->m_RefCount );

    #if DBG
    lpContext->m_LastCall = RPC_CALL_SEND_CERTIFICATE;
    #endif

    *dwErrCode = TLSMapReturnCode(status);
    return RPC_S_OK;
}

//-------------------------------------------------------------------------------
error_status_t 
TLSRpcGetServerName( 
    /* [in] */ PCONTEXT_HANDLE phContext,
    /* [size_is][string][out][in] */ LPTSTR szMachineName,
    /* [out][in] */ PDWORD cbSize,
    /* [ref][out][in] */ PDWORD dwErrCode
    )
/*++

Description:

    Return server's machine name. 

    This function is deprecated.  Use TLSRpcGetServerNameFixed.

Arguments:

    phContext - Client context handle
    szMachineName - return server's machine name, must be at least
                    MAX_COMPUTERNAME_LENGTH + 1 in length

Return:

    TLS_E_INVALID_DATA - buffer size too small.

++*/
{
    TCHAR szComputerName[MAX_COMPUTERNAME_LENGTH+2];
    DWORD dwBufferSize=MAX_COMPUTERNAME_LENGTH+1;
    LPCLIENTCONTEXT lpContext = (LPCLIENTCONTEXT)phContext;   
    
    if(lpContext == NULL || dwErrCode == NULL)
    {
        return RPC_S_INVALID_ARG;
    }

    DBGPrintf(
            DBG_INFORMATION,
            DBG_FACILITY_RPC,
            DBGLEVEL_FUNCTION_TRACE,
            _TEXT("%s : TLSRpcGetServerName\n"),
            lpContext->m_Client
        );

    if ((!(lpContext->m_ClientFlags & CLIENT_ACCESS_LSERVER)) && (lpContext->m_ContextType != CONTEXTHANDLE_CHALLENGE_SERVER_TYPE))

    {
        *dwErrCode = TLSMapReturnCode(TLS_E_INVALID_DATA);

        return RPC_S_OK;
    }

    *dwErrCode = ERROR_SUCCESS;
    if(!GetComputerName(szComputerName, &dwBufferSize))
    {
        *dwErrCode = GetLastError();
    }

    //
    // return buffer must be big enough for NULL, 
    // dwBufferSize return does not include NULL.
    //
    if(*cbSize <= dwBufferSize)
    {
        DBGPrintf(
                DBG_WARNING,
                DBG_FACILITY_RPC,
                DBGLEVEL_FUNCTION_DETAILSIMPLE,
                _TEXT("TLSRpcGetServerName : Client %s invalid parameter\n"),
                lpContext->m_Client
            );

        *dwErrCode = TLSMapReturnCode(TLS_E_INVALID_DATA);
    }
    else
    {
        _tcsncpy(szMachineName, szComputerName, min(_tcslen(szComputerName), *cbSize));
        szMachineName[min(_tcslen(szComputerName), *cbSize - 1)] = _TEXT('\0');
    }

    *cbSize = _tcslen(szComputerName) + 1; // include NULL terminate string

    #if DBG
    lpContext->m_LastCall = RPC_CALL_GET_SERVERNAME;
    #endif

    return RPC_S_OK;
}

//-------------------------------------------------------------------------------
error_status_t 
TLSRpcGetServerNameEx( 
    /* [in] */ PCONTEXT_HANDLE phContext,
    /* [size_is][string][out][in] */ LPTSTR szMachineName,
    /* [out][in] */ PDWORD cbSize,
    /* [ref][out][in] */ PDWORD dwErrCode
    )
/*++

Description:

    Return server's machine name.

    This function is deprecated.  Use TLSRpcGetServerNameFixed.

Arguments:

    phContext - Client context handle
    szMachineName - return server's machine name, must be at least
                    MAX_COMPUTERNAME_LENGTH + 1 in length

Return:

    TLS_E_INVALID_DATA - buffer size too small.

++*/
{
    TCHAR szComputerName[MAX_COMPUTERNAME_LENGTH+2];
    DWORD dwBufferSize=MAX_COMPUTERNAME_LENGTH+1;
    LPCLIENTCONTEXT lpContext = (LPCLIENTCONTEXT)phContext;

    if(lpContext == NULL || dwErrCode == NULL)
    {
        return RPC_S_INVALID_ARG;
    }

    DBGPrintf(
            DBG_INFORMATION,
            DBG_FACILITY_RPC,
            DBGLEVEL_FUNCTION_TRACE,
            _TEXT("%s : TLSRpcGetServerNameEx\n"),
            lpContext->m_Client
        );

    *dwErrCode = ERROR_SUCCESS;
    if(!GetComputerName(szComputerName, &dwBufferSize))
    {
        *dwErrCode = GetLastError();
    }

    //
    // return buffer must be big enough for NULL, 
    // dwBufferSize return does not include NULL.
    //
    if(*cbSize <= dwBufferSize)
    {
        DBGPrintf(
                DBG_WARNING,
                DBG_FACILITY_RPC,
                DBGLEVEL_FUNCTION_DETAILSIMPLE,
                _TEXT("TLSRpcGetServerNameEx : Client %s invalid parameter\n"),
                lpContext->m_Client
            );

        *dwErrCode = TLSMapReturnCode(TLS_E_INVALID_DATA);
    }
    else
    {
        _tcsncpy(szMachineName, szComputerName, min(_tcslen(szComputerName), *cbSize));
        szMachineName[min(_tcslen(szComputerName), *cbSize - 1)] = _TEXT('\0');
    }

    *cbSize = _tcslen(szComputerName) + 1; // include NULL terminate string

    #if DBG
    lpContext->m_LastCall = RPC_CALL_GET_SERVERNAME;
    #endif

    return RPC_S_OK;
}

//---------------------------------------------------------------------------
error_status_t 
TLSRpcGetServerNameFixed( 
    /* [in] */ PCONTEXT_HANDLE phContext,
    /* [string][out] */ LPTSTR *pszMachineName,
    /* [ref][out][in] */ PDWORD pdwErrCode
    )
/*++

Description:

    Return server's machine name. 

Arguments:

    phContext - Client context handle
    pszMachineName - return server's machine name

Return:

++*/
{
    TCHAR szComputerName[MAX_COMPUTERNAME_LENGTH + 1];
    DWORD cchComputerName = sizeof(szComputerName) / sizeof(TCHAR);
   
    LPCLIENTCONTEXT lpContext = (LPCLIENTCONTEXT)phContext;   
    
    if((lpContext == NULL) || (NULL == pszMachineName) || (NULL == pdwErrCode))
    {
        return RPC_S_INVALID_ARG;
    }

    DBGPrintf(
            DBG_INFORMATION,
            DBG_FACILITY_RPC,
            DBGLEVEL_FUNCTION_TRACE,
            _TEXT("%s : TLSRpcGetServerNameFixed\n"),
            lpContext->m_Client
        );
    
    *pszMachineName = NULL;

    if(!GetComputerName(szComputerName, &cchComputerName))
    {
        *pdwErrCode = GetLastError();
    }
    else
    {
        *pszMachineName = (LPTSTR) MIDL_user_allocate((cchComputerName+1) * sizeof(TCHAR));

        if (NULL != *pszMachineName)
        {
            _tcscpy(*pszMachineName,szComputerName);
            *pdwErrCode = ERROR_SUCCESS;
        }
        else
        {
            *pdwErrCode = TLSMapReturnCode(TLS_E_ALLOCATE_MEMORY);
        }
    }

    #if DBG
    lpContext->m_LastCall = RPC_CALL_GET_SERVERNAME;
    #endif

    return RPC_S_OK;
}

//-------------------------------------------------------------------------------
error_status_t 
TLSRpcGetServerScope( 
    /* [in] */ PCONTEXT_HANDLE phContext,
    /* [size_is][string][out][in] */ LPTSTR szScopeName,
    /* [out][in] */ PDWORD cbSize,
    /* [ref][out][in] */ PDWORD dwErrCode
    )
/*++

Description:

    Return License Server's scope

    This function is deprecated.  Use TLSRpcGetServerScopeFixed.

Arguments:

    phContext - Client context
    szScopeName - return server's scope, must be at least 
                  MAX_COMPUTERNAME_LENGTH in length

Return:

    LSERVER_S_SUCCESS or error code from WideCharToMultiByte()
    TLS_E_INVALID_DATA - buffer size too small.

++*/
{
    LPCLIENTCONTEXT lpContext = (LPCLIENTCONTEXT)phContext;
    
    if(lpContext == NULL || dwErrCode == NULL)
    {
        return RPC_S_INVALID_ARG;
    }

    DBGPrintf(
            DBG_INFORMATION,
            DBG_FACILITY_RPC,
            DBGLEVEL_FUNCTION_TRACE,
            _TEXT("%s : TLSRpcGetServerScope\n"),
            lpContext->m_Client
        );

    *dwErrCode = ERROR_SUCCESS;
    if(*cbSize <= _tcslen(g_pszScope))
    {
        *dwErrCode = TLSMapReturnCode(TLS_E_INVALID_DATA);
    }
    else
    {
        _tcsncpy(szScopeName, g_pszScope, min(_tcslen(g_pszScope), *cbSize));
        szScopeName[min(_tcslen(g_pszScope), *cbSize-1)] = _TEXT('\0');
    }

    *cbSize = _tcslen(g_pszScope) + 1; // include NULL terminate string

    #if DBG
    lpContext->m_LastCall = RPC_CALL_GET_SERVERSCOPE;
    #endif
    
    return RPC_S_OK;
}

//-------------------------------------------------------------------------------
error_status_t 
TLSRpcGetServerScopeFixed( 
    /* [in] */ PCONTEXT_HANDLE phContext,
    /* [string][out] */ LPTSTR *pszScopeName,
    /* [ref][out][in] */ PDWORD pdwErrCode
    )
/*++

Description:

    Return License Server's scope

Arguments:

    phContext - Client context
    szScopeName - return server's scope

Return:

++*/
{
    LPCLIENTCONTEXT lpContext = (LPCLIENTCONTEXT)phContext;

    if((lpContext == NULL) || (NULL == pszScopeName) || (NULL == pdwErrCode))
    {
        return RPC_S_INVALID_ARG;
    }

    DBGPrintf(
            DBG_INFORMATION,
            DBG_FACILITY_RPC,
            DBGLEVEL_FUNCTION_TRACE,
            _TEXT("%s : TLSRpcGetServerScopeFixed\n"),
            lpContext->m_Client
        );

    *pszScopeName = (LPTSTR) MIDL_user_allocate((_tcslen(g_pszScope)+1) * sizeof(TCHAR));

    if (NULL != *pszScopeName)
    {
        _tcscpy(*pszScopeName, g_pszScope);
    }

    *pdwErrCode = ERROR_SUCCESS;

    #if DBG
    lpContext->m_LastCall = RPC_CALL_GET_SERVERSCOPE;
    #endif
    
    return RPC_S_OK;
}

//-------------------------------------------------------------------------------
error_status_t 
TLSRpcGetInfo( 
    /* [in] */ PCONTEXT_HANDLE phContext,
    /* [in] */ DWORD cbHSCert,
    /* [size_is][in] */ PBYTE pHSCert,
    /* [ref][out] */ DWORD __RPC_FAR *pcbLSCert,
    /* [size_is][size_is][out] */ BYTE __RPC_FAR *__RPC_FAR *pLSCert,
    /* [ref][out] */ DWORD __RPC_FAR *pcbLSSecretKey,
    /* [size_is][size_is][out] */ BYTE __RPC_FAR *__RPC_FAR *pLSSecretKey,
    /* [ref][out][in] */ PDWORD dwErrCode
    )
/*++

Description:

    Routine to exchange Hydra server's certificate and License server's
    certificate/private key for signing client machine's hardware ID.

Arguments:

    phContext - client context handle
    cbHSCert - size of Hydra Server's certificate
    pHSCert - Hydra Server's certificate
    pcbLSCert - return size of License Server's certificate
    pLSCert - return License Server's certificate
    pcbLSSecretKey - return size of License Server's private key.
    pLSSecretKey - retrun License Server's private key

Return Value:  

    LSERVER_S_SUCCESS           success
    LSERVER_E_INVALID_DATA      Invalid hydra server certificate
    LSERVER_E_OUTOFMEMORY       Can't allocate required memory
    TLS_E_INTERNAL              Internal error occurred in License Server

++*/
{  
    return TLSMapReturnCode(TLS_E_NOTSUPPORTED);;
}

//-------------------------------------------------------------------------------

#define RANDOM_CHALLENGE_DATA   _TEXT("TEST")

DWORD
TLSGenerateChallengeData( 
    IN DWORD ClientInfo, 
    OUT PDWORD pcbChallengeData, 
    IN OUT PBYTE* pChallengeData
    )
{
    DWORD hr=ERROR_SUCCESS;

    if( pcbChallengeData == NULL || pChallengeData == NULL )
    {
        SetLastError(hr=E_INVALIDARG);
        return hr;
    }

    *pcbChallengeData = (_tcslen(RANDOM_CHALLENGE_DATA) + 1) * sizeof(WCHAR);
    *pChallengeData=(PBYTE)midl_user_allocate(*pcbChallengeData);

    if(*pChallengeData)
    {
        memcpy(*pChallengeData, RANDOM_CHALLENGE_DATA, *pcbChallengeData);
    }
    else
    {
        SetLastError(hr=ERROR_OUTOFMEMORY);
    }

    return hr;
}

//++----------------------------------------------------------------------------
DWORD
TLSVerifyChallengeDataGetWantedLicenseLevel(
    IN const CHALLENGE_CONTEXT ChallengeContext,
    IN const DWORD cbChallengeData,
    IN const PBYTE pbChallengeData,
    OUT WORD* pwLicenseDetail
    )
/*++

--*/
{
    DWORD dwStatus = ERROR_SUCCESS;

    if(pwLicenseDetail == NULL)
    {
        return E_INVALIDARG;
    }

    DWORD dwChallengeDataSize = (_tcslen(RANDOM_CHALLENGE_DATA) + 1) * sizeof(WCHAR);
    PPlatformChallengeResponseData pChallengeResponse;

    if( cbChallengeData < dwChallengeDataSize || pbChallengeData == NULL )
    {
        //
        // Assume old client, new client always send back our challenge data
        //
        *pwLicenseDetail = LICENSE_DETAIL_SIMPLE;
    }
    else if( cbChallengeData == dwChallengeDataSize &&
        _tcsicmp( (LPCTSTR)pbChallengeData, RANDOM_CHALLENGE_DATA ) == 0 )
    {
        //
        // old client, set license chain to LICENSE_DETAIL_SIMPLE
        //
        *pwLicenseDetail = LICENSE_DETAIL_SIMPLE;
    }
    else
    {
        BOOL bValidStruct = TRUE;

        //
        // we still don't have a good challenge so ignore actual verification
        //
        pChallengeResponse = (PPlatformChallengeResponseData) pbChallengeData;

        bValidStruct = (pChallengeResponse->wVersion == CURRENT_PLATFORMCHALLENGE_VERSION);
        if( bValidStruct == TRUE )
        {
            bValidStruct = (pChallengeResponse->cbChallenge + offsetof(PlatformChallengeResponseData, pbChallenge) == cbChallengeData);
        }

        if (bValidStruct == TRUE )
        {
            if( pChallengeResponse->wClientType == WIN32_PLATFORMCHALLENGE_TYPE ||
                pChallengeResponse->wClientType == WIN16_PLATFORMCHALLENGE_TYPE ||
                pChallengeResponse->wClientType == WINCE_PLATFORMCHALLENGE_TYPE ||
                pChallengeResponse->wClientType == OTHER_PLATFORMCHALLENGE_TYPE )
            {
                bValidStruct = TRUE;
            }
            else
            {
                bValidStruct = FALSE;
            }
        }
        
        if( bValidStruct == TRUE )
        {
            if( pChallengeResponse->wLicenseDetailLevel == LICENSE_DETAIL_SIMPLE ||
                pChallengeResponse->wLicenseDetailLevel == LICENSE_DETAIL_MODERATE ||
                pChallengeResponse->wLicenseDetailLevel == LICENSE_DETAIL_DETAIL )
            {
                bValidStruct = TRUE;
            }
            else
            {
                bValidStruct = FALSE;
            }
        }

        //
        // For now, we simply let it go thru, assert or deny request once
        // we settle down of challenge
        //
        if( bValidStruct == FALSE )
        {
            // bad data, assume old client
            *pwLicenseDetail = LICENSE_DETAIL_SIMPLE;
        }
        //else if( pChallengeResponse->wClientType == WINCE_PLATFORMCHALLENGE_TYPE )
        //{
            //
            // UN-comment this to limit WINCE to get a self-signed certificate
            //
        //    *pwLicenseDetail = LICENSE_DETAIL_SIMPLE;
        //}
        else
        {
            *pwLicenseDetail = pChallengeResponse->wLicenseDetailLevel;
        }
    }

    return dwStatus;
}


//++----------------------------------------------------------------------------
error_status_t 
TLSRpcIssuePlatformChallenge( 
    /* [in] */ PCONTEXT_HANDLE phContext,
    /* [in] */ DWORD dwClientInfo,
    /* [ref][out] */ PCHALLENGE_CONTEXT pChallengeContext,
    /* [out] */ PDWORD pcbChallengeData,
    /* [size_is][size_is][out] */ BYTE __RPC_FAR *__RPC_FAR *pChallengeData,
    /* [ref][out][in] */ PDWORD dwErrCode
    )
/*++

Description:

    Issue a platform challenge to hydra client.

Arguments:

    phContext - client context handle
    dwClientInfo - client info.
    pChallengeContext - pointer to client challenge context.
    pcbChallengeData - size of challenge data.
    pChallengeData - random client challenge data.

Returns via dwErrCode:

    LSERVER_S_SUCCESS
    LSERVER_E_OUTOFMEMORY       Out of memory
    LSERVER_E_INVALID_DATA      Invalid client info.
    LSERVER_E_SERVER_BUSY       Server is busy

++*/
{    
    LPCLIENTCONTEXT lpContext = (LPCLIENTCONTEXT)phContext;

    if(lpContext == NULL || pcbChallengeData == NULL || pChallengeData == NULL)
    {
        return RPC_S_INVALID_ARG;
    }

    LPCLIENTCHALLENGECONTEXT lpChallenge=NULL;
    DWORD status=ERROR_SUCCESS;

    DBGPrintf(
            DBG_INFORMATION,
            DBG_FACILITY_RPC,
            DBGLEVEL_FUNCTION_TRACE,
            _TEXT("%s : TLSRpcIssuePlatformChallenge\n"),
            lpContext->m_Client
        );

    InterlockedIncrement( &lpContext->m_RefCount );

    do {
        status=TLSGenerateChallengeData(
                    dwClientInfo, 
                    pcbChallengeData, 
                    pChallengeData
                    );
        if(status != ERROR_SUCCESS)
        {
            break;
        }

        *pChallengeContext = dwClientInfo;
    } while (FALSE);

    if(status != ERROR_SUCCESS)
    {
        if(*pChallengeData)
        {
            midl_user_free(*pChallengeData);
            *pChallengeData = NULL;
        }

        *pcbChallengeData=0;
    }
    
    lpContext->m_LastError=status;

    #if DBG
    lpContext->m_LastCall = RPC_CALL_ISSUEPLATFORMCHLLENGE;
    #endif

    InterlockedDecrement( &lpContext->m_RefCount );
    *dwErrCode = TLSMapReturnCode(status);
    return RPC_S_OK;
}

//-------------------------------------------------------------------------------
error_status_t 
TLSRpcRequestNewLicense( 
    /* [in] */ PCONTEXT_HANDLE phContext,
    /* [in] */ const CHALLENGE_CONTEXT ChallengeContext,
    /* [in] */ TLSLICENSEREQUEST __RPC_FAR *pRequest,
    /* [string][in] */ LPTSTR szMachineName,
    /* [string][in] */ LPTSTR szUserName,
    /* [in] */ const DWORD cbChallengeResponse,
    /* [size_is][in] */ const PBYTE pbChallenge,
    /* [in] */ BOOL bAcceptTemporaryLicense,
    /* [out] */ PDWORD pcbLicense,
    /* [size_is][size_is][out] */ BYTE __RPC_FAR *__RPC_FAR *ppbLicense,
    /* [ref][out][in] */ PDWORD pdwErrCode
    )
/*++

Description:

    Routine to issue new license to hydra client based on product requested, 
    it returns existing license if client already has a license and the 
    license is not expired/returned/revoked, if request product has not been 
    installed, it will issue a temporary license, if license found is temporary 
    or expired, it will tried to upgrade/re-issue a new license with latest 
    version of requested product, if the existing license is temporary and 
    no license can be issued, it returns LSERVER_E_LICENSE_EXPIRED


Arguments:

    phContext - client context handle.
    ChallengeContext - client challenge context handle, return from 
                       call TLSRpcIssuePlatformChallenge()
    pRequest - product license request.
    pMachineName - client's machine name.
    pUserName - client user name.
    cbChallengeResponse - size of the client's response to license server's
                          platform challenge.
    pbChallenge - client's response to license server's platform challenge
    bAcceptTemporaryLicense - TRUE if client wants temp. license FALSE otherwise.
    pcbLicense - size of return license.
    ppLicense - return license, could be old license

Return Value:

    LSERVER_S_SUCCESS
    LSERVER_E_OUTOFMEMORY
    LSERVER_E_SERVER_BUSY       Server is busy to process request.
    LSERVER_E_INVALID_DATA      Invalid platform challenge response.
    LSERVER_E_NO_LICENSE        No license available.
    LSERVER_E_NO_PRODUCT        Request product is not installed on server.
    LSERVER_E_LICENSE_REJECTED  License request is rejected by cert. server
    LSERVER_E_LICENSE_REVOKED   Old license found and has been revoked
    LSERVER_E_LICENSE_EXPIRED   Request product's license has expired
    LSERVER_E_CORRUPT_DATABASE  Corrupted database.
    LSERVER_E_INTERNAL_ERROR    Internal error in license server
    LSERVER_I_PROXIMATE_LICENSE Closest match license returned.
    LSERVER_I_TEMPORARY_LICENSE Temporary license has been issued
    LSERVER_I_LICENSE_UPGRADED  Old license has been upgraded.
++*/
{
    DWORD dwSupportFlags = 0;
    
    return TLSRpcRequestNewLicenseEx( 
                                     phContext,
                                     &dwSupportFlags,
                                     ChallengeContext,
                                     pRequest,
                                     szMachineName,
                                     szUserName,
                                     cbChallengeResponse,
                                     pbChallenge,
                                     bAcceptTemporaryLicense,
                                     1,         // dwQuantity
                                     pcbLicense,
                                     ppbLicense,
                                     pdwErrCode
                                     );
}

error_status_t 
TLSRpcRequestNewLicenseEx(
    /* [in] */ PCONTEXT_HANDLE phContext,
    /* [in, out] */ DWORD *pdwSupportFlags,
    /* [in] */ const CHALLENGE_CONTEXT ChallengeContext,
    /* [in] */ TLSLICENSEREQUEST __RPC_FAR *pRequest,
    /* [string][in] */ LPTSTR szMachineName,
    /* [string][in] */ LPTSTR szUserName,
    /* [in] */ const DWORD cbChallengeResponse,
    /* [size_is][in] */ const PBYTE pbChallenge,
    /* [in] */ BOOL bAcceptTemporaryLicense,
    /* [in] */ DWORD dwQuantity,
    /* [out] */ PDWORD pcbLicense,
    /* [size_is][size_is][out] */ BYTE __RPC_FAR *__RPC_FAR *ppbLicense,
    /* [ref][out][in] */ PDWORD pdwErrCode
    )
/*++

Description:

    Routine to issue new license to hydra client based on product requested
    and input support flags.

    *pdwSupportFlags == 0:
        it returns existing license if client already has a license and the 
        license is not expired/returned/revoked, if request product has not
        been installed, it will issue a temporary license, if license found is
        temporary or expired, it will tried to upgrade/re-issue a new license
        with latest version of requested product, if the existing license is
        temporary and no license can be issued, it returns
        LSERVER_E_LICENSE_EXPIRED

    *pdwSupportFlags & SUPPORT_PER_SEAT_POST_LOGON:
        For non-per-seat licenses, it behaves as if the flag wasn't set.
        For per-seat licenses, if bAcceptTemporaryLicense is TRUE, it always
        returns a temporary license.  If bAcceptTemporaryLicense if FALSE, it
        returns LSERVER_E_NO_LICENSE.

Arguments:

    phContext - client context handle.
    pdwSupportFlags - on input, abilities supported by TS.  on output,
                      abilities supported by both TS and LS
    ChallengeContext - client challenge context handle, return from 
                       call TLSRpcIssuePlatformChallenge()
    pRequest - product license request.
    pMachineName - client's machine name.
    pUserName - client user name.
    cbChallengeResponse - size of the client's response to license server's
                          platform challenge.
    pbChallenge - client's response to license server's platform challenge
    bAcceptTemporaryLicense - TRUE if client wants temp. license FALSE
                              otherwise.
    dwQuantity - number of licenses to allocate
    pcbLicense - size of return license.
    ppLicense - return license, could be old license

Return Value:

    LSERVER_S_SUCCESS
    LSERVER_E_OUTOFMEMORY
    LSERVER_E_SERVER_BUSY       Server is busy to process request.
    LSERVER_E_INVALID_DATA      Invalid platform challenge response.
    LSERVER_E_NO_LICENSE        No license available.
    LSERVER_E_NO_PRODUCT        Request product is not installed on server.
    LSERVER_E_LICENSE_REJECTED  License request is rejected by cert. server
    LSERVER_E_LICENSE_REVOKED   Old license found and has been revoked
    LSERVER_E_LICENSE_EXPIRED   Request product's license has expired
    LSERVER_E_CORRUPT_DATABASE  Corrupted database.
    LSERVER_E_INTERNAL_ERROR    Internal error in license server
    LSERVER_I_PROXIMATE_LICENSE Closest match license returned.
    LSERVER_I_TEMPORARY_LICENSE Temporary license has been issued
    LSERVER_I_LICENSE_UPGRADED  Old license has been upgraded.
++*/
{
    return TLSRpcRequestNewLicenseExEx( 
                                     phContext,
                                     pdwSupportFlags,
                                     ChallengeContext,
                                     pRequest,
                                     szMachineName,
                                     szUserName,
                                     cbChallengeResponse,
                                     pbChallenge,
                                     bAcceptTemporaryLicense,
                                     FALSE,     // bAcceptFewerLicense
                                     &dwQuantity,
                                     pcbLicense,
                                     ppbLicense,
                                     pdwErrCode
                                     );
}

error_status_t 
TLSRpcRequestNewLicenseExEx(
    /* [in] */ PCONTEXT_HANDLE phContext,
    /* [in, out] */ DWORD *pdwSupportFlags,
    /* [in] */ const CHALLENGE_CONTEXT ChallengeContext,
    /* [in] */ TLSLICENSEREQUEST __RPC_FAR *pRequest,
    /* [string][in] */ LPTSTR szMachineName,
    /* [string][in] */ LPTSTR szUserName,
    /* [in] */ const DWORD cbChallengeResponse,
    /* [size_is][in] */ const PBYTE pbChallenge,
    /* [in] */ BOOL bAcceptTemporaryLicense,
    /* [in] */ BOOL bAcceptFewerLicenses,
    /* [in,out] */ DWORD *pdwQuantity,
    /* [out] */ PDWORD pcbLicense,
    /* [size_is][size_is][out] */ BYTE __RPC_FAR *__RPC_FAR *ppbLicense,
    /* [ref][out][in] */ PDWORD pdwErrCode
    )
/*++

Description:

    Routine to issue new license to hydra client based on product requested
    and input support flags.

    *pdwSupportFlags == 0:
        it returns existing license if client already has a license and the 
        license is not expired/returned/revoked, if request product has not
        been installed, it will issue a temporary license, if license found is
        temporary or expired, it will tried to upgrade/re-issue a new license
        with latest version of requested product, if the existing license is
        temporary and no license can be issued, it returns
        LSERVER_E_LICENSE_EXPIRED

    *pdwSupportFlags & SUPPORT_PER_SEAT_POST_LOGON:
        For non-per-seat licenses, it behaves as if the flag wasn't set.
        For per-seat licenses, if bAcceptTemporaryLicense is TRUE, it always
        returns a temporary license.  If bAcceptTemporaryLicense if FALSE, it
        returns LSERVER_E_NO_LICENSE.

Arguments:

    phContext - client context handle.
    pdwSupportFlags - on input, abilities supported by TS.  on output,
                      abilities supported by both TS and LS
    ChallengeContext - client challenge context handle, return from 
                       call TLSRpcIssuePlatformChallenge()
    pRequest - product license request.
    pMachineName - client's machine name.
    pUserName - client user name.
    cbChallengeResponse - size of the client's response to license server's
                          platform challenge.
    pbChallenge - client's response to license server's platform challenge
    bAcceptTemporaryLicense - TRUE if client wants temp. license FALSE
                              otherwise.
    bAcceptFewerLicenses - TRUE if succeeding with fewer licenses than
                           requested is acceptable
    pdwQuantity - on input, number of licenses to allocate.  on output,
                  number of licenses actually allocated
    pcbLicense - size of return license.
    ppLicense - return license, could be old license

Return Value:

    LSERVER_S_SUCCESS
    LSERVER_E_OUTOFMEMORY
    LSERVER_E_SERVER_BUSY       Server is busy to process request.
    LSERVER_E_INVALID_DATA      Invalid platform challenge response.
    LSERVER_E_NO_LICENSE        No license available.
    LSERVER_E_NO_PRODUCT        Request product is not installed on server.
    LSERVER_E_LICENSE_REJECTED  License request is rejected by cert. server
    LSERVER_E_LICENSE_REVOKED   Old license found and has been revoked
    LSERVER_E_LICENSE_EXPIRED   Request product's license has expired
    LSERVER_E_CORRUPT_DATABASE  Corrupted database.
    LSERVER_E_INTERNAL_ERROR    Internal error in license server
    LSERVER_I_PROXIMATE_LICENSE Closest match license returned.
    LSERVER_I_TEMPORARY_LICENSE Temporary license has been issued
    LSERVER_I_LICENSE_UPGRADED  Old license has been upgraded.
++*/
{
    PMHANDLE        hClient;
    DWORD           status=ERROR_SUCCESS;

    LPCLIENTCONTEXT lpContext = (LPCLIENTCONTEXT)phContext;

    if(lpContext == NULL)
    {
        return RPC_S_INVALID_ARG;
    }

    TCHAR szUnknown[LSERVER_MAX_STRING_SIZE+1];
    TCHAR szClientMachineName[LSERVER_MAX_STRING_SIZE];
    TCHAR szClientUserName[LSERVER_MAX_STRING_SIZE];
    TCHAR szCompanyName[LSERVER_MAX_STRING_SIZE+1];
    TCHAR szProductId[LSERVER_MAX_STRING_SIZE+1];

    TLSForwardNewLicenseRequest Forward;
    TLSDBLICENSEREQUEST LsLicenseRequest;
    CTLSPolicy* pPolicy=NULL;

    PMLICENSEREQUEST PMLicenseRequest;
    PPMLICENSEREQUEST pAdjustedRequest;
    BOOL bForwardRequest = TRUE;   

    #ifdef DBG
    DWORD dwStartTime=GetTickCount();
    #endif

    DBGPrintf(
            DBG_INFORMATION,
            DBG_FACILITY_RPC,
            DBGLEVEL_FUNCTION_TRACE,
            _TEXT("%s : TLSRpcRequestNewLicense\n"),
            lpContext->m_Client
        );

    InterlockedIncrement( &lpContext->m_RefCount );

    if ((NULL == pdwQuantity) || (0 == *pdwQuantity))
    {
        status = TLS_E_INVALID_DATA;
        goto cleanup;
    }

    status = SecureModeCheck();

    if(status != ERROR_SUCCESS )
    {                    
        goto cleanup;        
    }

    if(VerifyLicenseRequest(pRequest) == FALSE)
    {
        status = TLS_E_INVALID_DATA;
        goto cleanup;
    }

    if(NULL == pdwSupportFlags)
    {
        status = TLS_E_INVALID_DATA;
        goto cleanup;
    }

    *pdwSupportFlags &= ALL_KNOWN_SUPPORT_FLAGS;

    if(!(lpContext->m_ClientFlags & CLIENT_ACCESS_REQUEST))
    {
        status = TLS_E_ACCESS_DENIED;
        goto cleanup;
    }

    if(lpContext->m_ClientFlags == CLIENT_ACCESS_LSERVER)
    {
        //
        // do not forward any request or infinite loop might
        // occur.
        //
        bForwardRequest = FALSE;
    }

    Forward.m_ChallengeContext = ChallengeContext;
    Forward.m_pRequest = pRequest;
    Forward.m_szMachineName = szMachineName;
    Forward.m_szUserName = szUserName;
    Forward.m_cbChallengeResponse = cbChallengeResponse;
    Forward.m_pbChallengeResponse = pbChallenge;

    memset(szCompanyName, 0, sizeof(szCompanyName));
    memset(szProductId, 0, sizeof(szProductId));

    memcpy(
            szCompanyName,
            pRequest->ProductInfo.pbCompanyName,
            min(pRequest->ProductInfo.cbCompanyName, sizeof(szCompanyName)-sizeof(TCHAR))
        );

    memcpy(
            szProductId,
            pRequest->ProductInfo.pbProductID,
            min(pRequest->ProductInfo.cbProductID, sizeof(szProductId)-sizeof(TCHAR))
        );

    //
    // Acquire policy module, a default policy module will
    // be returned.
    //
    pPolicy = AcquirePolicyModule(
                            szCompanyName, //(LPCTSTR)pRequest->ProductInfo.pbCompanyName,
                            szProductId,    //(LPCTSTR)pRequest->ProductInfo.pbProductID
                            FALSE
                        );

    if(pPolicy == NULL)
    {
        status = TLS_E_INTERNAL;
        goto cleanup;
    }

    hClient = GenerateClientId();

    //
    // return error if string is too big.
    // 
    LoadResourceString(
            IDS_UNKNOWN_STRING, 
            szUnknown, 
            sizeof(szUnknown)/sizeof(szUnknown[0])
            );

    _tcsncpy(szClientMachineName, 
             (szMachineName) ? szMachineName : szUnknown,
             LSERVER_MAX_STRING_SIZE
            );

    szClientMachineName[LSERVER_MAX_STRING_SIZE-1] = 0;

    _tcsncpy(szClientUserName, 
             (szUserName) ? szUserName : szUnknown,
             LSERVER_MAX_STRING_SIZE
            );

    szClientUserName[LSERVER_MAX_STRING_SIZE-1] = 0;

    //
    // Convert request to PMLICENSEREQUEST
    //
    TlsLicenseRequestToPMLicenseRequest(
                        LICENSETYPE_LICENSE,
                        pRequest,
                        szClientMachineName,
                        szClientUserName,
                        *pdwSupportFlags,
                        &PMLicenseRequest
                    );

    //
    // Inform Policy module start of new license request
    //
    status = pPolicy->PMLicenseRequest(
                                hClient,
                                REQUEST_NEW,
                                (PVOID) &PMLicenseRequest,
                                (PVOID *) &pAdjustedRequest
                            );

    if(status != ERROR_SUCCESS)
    {
        goto cleanup;
    }

    if(pAdjustedRequest != NULL)
    {
        if(_tcsicmp(PMLicenseRequest.pszCompanyName,pAdjustedRequest->pszCompanyName) != 0)
        {                               
            // try to steal license from other company???
            TLSLogEvent(
                    EVENTLOG_ERROR_TYPE,
                    TLS_E_POLICYERROR,
                    status = TLS_E_POLICYMODULEERROR,
                    pPolicy->GetCompanyName(),
                    pPolicy->GetProductId()
                );

            goto cleanup;
        }
    }
    else
    {
        pAdjustedRequest = &PMLicenseRequest;
    }

    //
    // form DB request structure
    //
    status = TLSFormDBRequest(
                            pRequest->pbEncryptedHwid, 
                            pRequest->cbEncryptedHwid,
                            pAdjustedRequest->dwProductVersion,
                            pAdjustedRequest->pszCompanyName,
                            pAdjustedRequest->pszProductId,
                            pAdjustedRequest->dwLanguageId,
                            pAdjustedRequest->dwPlatformId,
                            pAdjustedRequest->pszMachineName,
                            pAdjustedRequest->pszUserName,
                            &LsLicenseRequest
                        );

    if(status != ERROR_SUCCESS)
    {
        goto cleanup;
    }

    LsLicenseRequest.pPolicy = pPolicy;
    LsLicenseRequest.hClient = hClient;
    LsLicenseRequest.pPolicyLicenseRequest = pAdjustedRequest;
    LsLicenseRequest.pClientLicenseRequest = &PMLicenseRequest;

    status = TLSVerifyChallengeDataGetWantedLicenseLevel(
                                ChallengeContext,
                                cbChallengeResponse,
                                pbChallenge,
                                &LsLicenseRequest.wLicenseDetail
                            );

    if( status == ERROR_SUCCESS )
    {
        status = TLSNewLicenseRequest(
                        bForwardRequest,
                        pdwSupportFlags,
                        &Forward,
                        &LsLicenseRequest,
                        bAcceptTemporaryLicense,
                        pAdjustedRequest->fTemporary,
                        TRUE,       // bFindLostLicense
                        bAcceptFewerLicenses,
                        pdwQuantity,
                        pcbLicense,
                        ppbLicense
                    );
    }    

cleanup:

    lpContext->m_LastError=status;
    InterlockedDecrement( &lpContext->m_RefCount );

    #if DBG
    lpContext->m_LastCall = RPC_CALL_ISSUENEWLICENSE;
    #endif

    #ifdef DBG
    DBGPrintf(
            DBG_INFORMATION,
            DBG_FACILITY_RPC,
            DBGLEVEL_FUNCTION_DETAILSIMPLE,
            _TEXT("\t%s : TLSRpcRequestNewLicense() takes %dms\n"),
            lpContext->m_Client,
            GetTickCount() - dwStartTime
        );
    #endif

    if(pdwErrCode)
    {
        *pdwErrCode = TLSMapReturnCode(status);
    }

    if(pPolicy)
    {
        pPolicy->PMLicenseRequest(
                            hClient,
                            REQUEST_COMPLETE,
                            UlongToPtr(status),
                            NULL
                        );
        
        ReleasePolicyModule(pPolicy);
    }

    return RPC_S_OK;
}

//-------------------------------------------------------------------------------
error_status_t 
TLSRpcUpgradeLicense( 
    /* [in] */ PCONTEXT_HANDLE phContext,
    /* [in] */ TLSLICENSEREQUEST __RPC_FAR *pRequest,
    /* [in] */ const CHALLENGE_CONTEXT ChallengeContext,
    /* [in] */ const DWORD cbChallengeResponse,
    /* [size_is][in] */ const PBYTE pbChallenge,
    /* [in] */ DWORD cbOldLicense,
    /* [size_is][in] */ PBYTE pbOldLicense,
    /* [out] */ PDWORD pcbNewLicense,
    /* [size_is][size_is][out] */ PBYTE __RPC_FAR *ppbNewLicense,
    /* [ref][out][in] */ PDWORD dwErrCode
    )
/*++

Description:

    Update an old license.

Arguments:


Return Value:  

    LSERVER_S_SUCCESS
    TLS_E_INTERNAL
    LSERVER_E_INTERNAL_ERROR
    LSERVER_E_INVALID_DATA      old license is invalid.
    LSERVER_E_NO_LICENSE        no available license
    LSERVER_E_NO_PRODUCT        request product not install in current server.
    LSERVER_E_CORRUPT_DATABASE  Corrupted database.
    LSERVER_E_LICENSE_REJECTED  License request rejected by cert. server.
    LSERVER_E_SERVER_BUSY

++*/
{
    DWORD dwSupportFlags = 0;

    return TLSRpcUpgradeLicenseEx( 
                                  phContext,
                                  &dwSupportFlags,
                                  pRequest,
                                  ChallengeContext,
                                  cbChallengeResponse,
                                  pbChallenge,
                                  cbOldLicense,
                                  pbOldLicense,
                                  1,    // dwQuantity
                                  pcbNewLicense,
                                  ppbNewLicense,
                                  dwErrCode
                                  );

}
//-------------------------------------------------------------------------------
error_status_t 
TLSRpcUpgradeLicenseEx( 
    /* [in] */ PCONTEXT_HANDLE phContext,
    /* [in,out] */ DWORD *pdwSupportFlags,
    /* [in] */ TLSLICENSEREQUEST __RPC_FAR *pRequest,
    /* [in] */ const CHALLENGE_CONTEXT ChallengeContext,
    /* [in] */ const DWORD cbChallengeResponse,
    /* [size_is][in] */ const PBYTE pbChallenge,
    /* [in] */ DWORD cbOldLicense,
    /* [size_is][in] */ PBYTE pbOldLicense,
    /* [in] */ DWORD dwQuantity,
    /* [out] */ PDWORD pcbNewLicense,
    /* [size_is][size_is][out] */ PBYTE __RPC_FAR *ppbNewLicense,
    /* [ref][out][in] */ PDWORD dwErrCode
    )
/*++

Description:

    Update an old license.  Behavior varies depending on product requested,
    the old license, and input support flags.

    *pdwSupportFlags == 0:
        it returns existing license if client already has a current-version
        license and the license is not expired/returned/revoked. if requested
        product has not been installed, it will issue a temporary license (if
        the client doesn't already have one). if old license is temporary
        or expired, it will try to upgrade/re-issue a new license
        with latest version of requested product. if the existing license is
        temporary and no license can be issued, it returns
        LSERVER_E_LICENSE_EXPIRED

    *pdwSupportFlags & SUPPORT_PER_SEAT_POST_LOGON:
        For non-per-seat licenses, it behaves as if the flag wasn't set.
        For per-seat licenses, if the old license isn't current-version
        temporary, it also behaves as if the flag wasn't set.
        Otherwise, it checks that the temporary license was marked as having
        been authenticated.  If so, it tries to issue a permanent license.
        If a license can't be issued, or if he temporary license wasn't marked,
        it returns the old license.

Arguments:

    phContext - client context handle.
    pdwSupportFlags - on input, abilities supported by TS.  on output,
                      abilities supported by both TS and LS
    pRequest - product license request.
    ChallengeContext - client challenge context handle, return from 
                       call TLSRpcIssuePlatformChallenge()
    cbChallengeResponse - size of the client's response to license server's
                          platform challenge.
    pbChallenge - client's response to license server's platform challenge
    cbOldLicense - size of old license.
    pbOldLicense - old license
    dwQuantity - number of licenses to allocate
    pcbNewLicense - size of return license.
    ppbNewLicense - return license, could be old license

Return Value:  

    LSERVER_S_SUCCESS
    TLS_E_INTERNAL
    LSERVER_E_INTERNAL_ERROR
    LSERVER_E_INVALID_DATA      old license is invalid.
    LSERVER_E_NO_LICENSE        no available license
    LSERVER_E_NO_PRODUCT        request product not install in current server.
    LSERVER_E_CORRUPT_DATABASE  Corrupted database.
    LSERVER_E_LICENSE_REJECTED  License request rejected by cert. server.
    LSERVER_E_SERVER_BUSY

++*/
{    
    DWORD status = ERROR_SUCCESS;
    BOOL bTemporaryLicense; 
    PMUPGRADEREQUEST pmRequestUpgrade;
    PMLICENSEREQUEST pmLicenseRequest;
    PPMLICENSEREQUEST pmAdjustedRequest;
    PPMLICENSEDPRODUCT ppmLicensedProduct=NULL;
    DWORD dwNumLicensedProduct=0;
    PLICENSEDPRODUCT pLicensedProduct=NULL;
    TLSDBLICENSEREQUEST LsLicenseRequest;
    PMHANDLE hClient;
    CTLSPolicy* pPolicy=NULL;
    DWORD dwNumPermLicense;
    DWORD dwNumTempLicense;
    TLSForwardUpgradeLicenseRequest Forward;
    LPCLIENTCONTEXT lpContext = (LPCLIENTCONTEXT)phContext;
    UCHAR ucMarked;

    if(lpContext == NULL || pRequest == NULL || pcbNewLicense == NULL || ppbNewLicense == NULL || dwErrCode == NULL)
    {
        return RPC_S_INVALID_ARG;
    }

    LICENSEDCLIENT license;
    LICENSEPACK keypack;
    DWORD index;
    BOOL bForwardRequest = TRUE;
    BOOL bRetry = TRUE;
    BOOL bRetryOld = FALSE;
    DWORD dwOriginalVersion = pRequest->ProductInfo.dwVersion;    
    BOOL fInDomain = FALSE;
    WCHAR *StringBinding = NULL;
    WCHAR *ServerAddress = NULL;
    RPC_BINDING_HANDLE ServerBinding = 0;

    DBGPrintf(
            DBG_INFORMATION,
            DBG_FACILITY_RPC,
            DBGLEVEL_FUNCTION_TRACE,
            _TEXT("%s : TLSRpcUpgradeLicense\n"),
            lpContext->m_Client
        );

    InterlockedIncrement( &lpContext->m_RefCount );

    if (1 != dwQuantity)
    {
        status = TLS_E_INVALID_DATA;
        goto cleanup;
    }

    if(VerifyLicenseRequest(pRequest) == FALSE)
    {
        status = TLS_E_INVALID_DATA;
        goto cleanup;
    }

    if(NULL == pdwSupportFlags)
    {
        status = TLS_E_INVALID_DATA;
        goto cleanup;
    }

    *pdwSupportFlags &= ALL_KNOWN_SUPPORT_FLAGS;

    if(!(lpContext->m_ClientFlags & CLIENT_ACCESS_REQUEST))
    {
        status = TLS_E_ACCESS_DENIED;
        goto cleanup;
    }

    if(lpContext->m_ClientFlags == CLIENT_ACCESS_LSERVER)
    {
        //
        // do not forward any request or infinite loop might
        // occur.
        //
        bForwardRequest = FALSE;
    }

    status = SecureModeCheck();

    if(status != ERROR_SUCCESS )
    {                    
        goto cleanup;        
    }

    //
    // Convert blob to licensed product structure
    //
    status = LSVerifyDecodeClientLicense(
                            pbOldLicense, 
                            cbOldLicense, 
                            g_pbSecretKey, 
                            g_cbSecretKey,
                            &dwNumLicensedProduct,
                            NULL
                        );

    if(status != LICENSE_STATUS_OK || dwNumLicensedProduct == 0)
    {
        status = TLS_E_INVALID_LICENSE;
        goto cleanup;
    }

    pLicensedProduct = (PLICENSEDPRODUCT)AllocateMemory(
                                                    dwNumLicensedProduct * sizeof(LICENSEDPRODUCT)
                                                );
    if(pLicensedProduct == NULL)
    {
        status = TLS_E_ALLOCATE_MEMORY;
        goto cleanup;
    }

    status = LSVerifyDecodeClientLicense(
                            pbOldLicense, 
                            cbOldLicense, 
                            g_pbSecretKey, 
                            g_cbSecretKey,
                            &dwNumLicensedProduct,
                            pLicensedProduct
                        );

    if(status != LICENSE_STATUS_OK)
    {
        status = TLS_E_INVALID_LICENSE;
        goto cleanup;
    }

    //
    // Verify licensed product array.
    //
    for(index = 1; index < dwNumLicensedProduct; index++)
    {
        //
        // licensed product array always sorted in decending order
        //

        //
        // Product ID in original request in licensed product must 
        // be the same otherwise invalid license.
        //
        if((pLicensedProduct+index)->cbOrgProductID != (pLicensedProduct+index-1)->cbOrgProductID)
        {
            status = TLS_E_INVALID_LICENSE;
            break;
        }

        if( memcmp(
                (pLicensedProduct+index)->pbOrgProductID, 
                (pLicensedProduct+index-1)->pbOrgProductID,
                (pLicensedProduct+index)->cbOrgProductID) != 0 )
        {
            status = TLS_E_INVALID_LICENSE;
            goto cleanup;
        }

        if( ((pLicensedProduct+index)->pLicensedVersion->dwFlags & LICENSED_VERSION_TEMPORARY) )
        {
            //
            // only latest licensed version can be temporary
            //
            status = TLS_E_INVALID_LICENSE;
            goto cleanup;
        }
    }

    //
    // Find the policy module
    // 
    hClient = GenerateClientId();

    TCHAR szCompanyName[LSERVER_MAX_STRING_SIZE+1];
    TCHAR szProductId[LSERVER_MAX_STRING_SIZE+1];

    memset(szCompanyName, 0, sizeof(szCompanyName));
    memset(szProductId, 0, sizeof(szProductId));

    memcpy(
            szCompanyName,
            pRequest->ProductInfo.pbCompanyName,
            min(pRequest->ProductInfo.cbCompanyName, sizeof(szCompanyName)-sizeof(TCHAR))
        );

    memcpy(
            szProductId,
            pRequest->ProductInfo.pbProductID,
            min(pRequest->ProductInfo.cbProductID, sizeof(szProductId)-sizeof(TCHAR))
        );

    //
    // Acquire policy module, a default policy module will
    // be returned.
    //
    pPolicy = AcquirePolicyModule(
                        szCompanyName,  // (LPCTSTR) pLicensedProduct->LicensedProduct.pProductInfo->pbCompanyName,
                        szProductId,     // (LPCTSTR) pLicensedProduct->pbOrgProductID
                        FALSE
                    );

    if(pPolicy == NULL)
    {
        //
        // Must have a policy module, default policy module always there
        //
        status = TLS_E_INTERNAL;
        goto cleanup;
    }
    
    BOOL bPreventLicenseUpgrade = FALSE;
    BOOL bDeleteExpired = FALSE;
    POLICY_TS_MACHINE groupPolicy;
    RegGetMachinePolicy(&groupPolicy);

    if( groupPolicy.fPolicyPreventLicenseUpgrade == 1 && groupPolicy.fPreventLicenseUpgrade == 1)
    {
        bPreventLicenseUpgrade = TRUE;
    }

    // If (1) Licensed version is greater than requested version, (2) it is permanent

    if( ((pLicensedProduct->pLicensedVersion->wMajorVersion == HIWORD(pRequest->ProductInfo.dwVersion)) ? 
        (pLicensedProduct->pLicensedVersion->wMinorVersion - LOWORD(pRequest->ProductInfo.dwVersion)) :
        (pLicensedProduct->pLicensedVersion->wMajorVersion - HIWORD(pRequest->ProductInfo.dwVersion))) > 0 && 
        (pLicensedProduct->pLicensedVersion->dwFlags & LICENSED_VERSION_TEMPORARY) == 0 )
    {
        // If reissuance of the greater expired permanent license fails, fall back to issuing the requested permanent license.
        bRetryOld = TRUE;

        DWORD dwNewVersion = MAKELONG(pLicensedProduct->pLicensedVersion->wMinorVersion, pLicensedProduct->pLicensedVersion->wMajorVersion);
        pRequest->ProductInfo.dwVersion = dwNewVersion;        
    }
        

RetryPermanent:

    //
    // Convert request to PMLICENSEREQUEST
    //
    TlsLicenseRequestToPMLicenseRequest(
                        LICENSETYPE_LICENSE,
                        pRequest,
                        pLicensedProduct->szLicensedClient,
                        pLicensedProduct->szLicensedUser,
                        *pdwSupportFlags,
                        &pmLicenseRequest
                    );

    //
    // generate PMUPGRADEREQUEST and pass it to Policy Module
    //
    memset(&pmRequestUpgrade, 0, sizeof(pmRequestUpgrade));

    ppmLicensedProduct = (PPMLICENSEDPRODUCT)AllocateMemory(sizeof(PMLICENSEDPRODUCT)*dwNumLicensedProduct);
    if(ppmLicensedProduct == NULL)
    {
        status = TLS_E_ALLOCATE_MEMORY;
        goto cleanup;
    }
    

    for(index=0; index < dwNumLicensedProduct; index++)
    {               
        ppmLicensedProduct[index].pbData = 
                        pLicensedProduct[index].pbPolicyData;

        ppmLicensedProduct[index].cbData = 
                        pLicensedProduct[index].cbPolicyData;

        ppmLicensedProduct[index].bTemporary = 
                        ((pLicensedProduct[index].pLicensedVersion->dwFlags & LICENSED_VERSION_TEMPORARY) != 0);

        // treat license issued from beta server as temporary
        if(ppmLicensedProduct[index].bTemporary == FALSE && TLSIsBetaNTServer() == FALSE)
        {
            if(IS_LICENSE_ISSUER_RTM(pLicensedProduct[index].pLicensedVersion->dwFlags) == FALSE)
            {
                ppmLicensedProduct[index].bTemporary = TRUE;
            }
        }        

        ppmLicensedProduct[index].ucMarked = 0;

        if (0 == index)
        {
            // for first license, check markings on license
            status = TLSCheckLicenseMarkRequest(
                            TRUE,   // forward request if necessary
                            pLicensedProduct,
                            cbOldLicense,
                            pbOldLicense,
                            &(ppmLicensedProduct[index].ucMarked)
                            );
            ucMarked = ppmLicensedProduct[index].ucMarked;
        }

        ppmLicensedProduct[index].LicensedProduct.dwProductVersion = 
                        pLicensedProduct[index].LicensedProduct.pProductInfo->dwVersion;

        ppmLicensedProduct[index].LicensedProduct.pszProductId = 
                        (LPTSTR)(pLicensedProduct[index].LicensedProduct.pProductInfo->pbProductID);

        ppmLicensedProduct[index].LicensedProduct.pszCompanyName = 
                        (LPTSTR)(pLicensedProduct[index].LicensedProduct.pProductInfo->pbCompanyName);

        ppmLicensedProduct[index].LicensedProduct.dwLanguageId = 
                        pLicensedProduct[index].LicensedProduct.dwLanguageID;

        ppmLicensedProduct[index].LicensedProduct.dwPlatformId = 
                        pLicensedProduct[index].LicensedProduct.dwPlatformID;

        ppmLicensedProduct[index].LicensedProduct.pszMachineName = 
                        pLicensedProduct[index].szLicensedClient;

        ppmLicensedProduct[index].LicensedProduct.pszUserName = 
                        pLicensedProduct[index].szLicensedUser;
    }

    pmRequestUpgrade.pbOldLicense = pbOldLicense;
    pmRequestUpgrade.cbOldLicense = cbOldLicense;
    pmRequestUpgrade.pUpgradeRequest = &pmLicenseRequest;

    pmRequestUpgrade.dwNumProduct = dwNumLicensedProduct;
    pmRequestUpgrade.pProduct = ppmLicensedProduct;

    // If (1) there are 2 or more licenses and (2) licensed version is greater than requested version, modify the index appropriately to determine Marked state

    index = 0;

    DWORD dwLicensedVersion = MAKELONG(pLicensedProduct->pLicensedVersion->wMinorVersion, pLicensedProduct->pLicensedVersion->wMajorVersion);

    if( dwNumLicensedProduct > 1 && (CompareTLSVersions(pRequest->ProductInfo.dwVersion, dwLicensedVersion) < 0 ) )
    {
        index = 1;
    }

    status = pPolicy->PMLicenseUpgrade(
                                hClient,
                                REQUEST_UPGRADE,
                                (PVOID)&pmRequestUpgrade,                                
                                (PVOID *) &pmAdjustedRequest,
                                index
                            );

    if(status != ERROR_SUCCESS)
    {
        goto cleanup;
    }

    if(pmAdjustedRequest != NULL)
    {
        if(_tcsicmp(
                    pmLicenseRequest.pszCompanyName, 
                    pmAdjustedRequest->pszCompanyName
                ) != 0)
        { 
            //                              
            // Try to steal license from other company???
            //
            TLSLogEvent(
                    EVENTLOG_ERROR_TYPE,
                    TLS_E_POLICYERROR,
                    status = TLS_E_POLICYMODULEERROR,
                    pPolicy->GetCompanyName(),
                    pPolicy->GetProductId()
                );

            goto cleanup;
        }
    }
    else
    {
        pmAdjustedRequest = &pmLicenseRequest;
    }

    for(index =0; index < dwNumLicensedProduct; index++)
    {
        DWORD tExpireDate;

        FileTimeToLicenseDate(&(pLicensedProduct[index].NotAfter),
            &tExpireDate);

        if( CompareTLSVersions(pmAdjustedRequest->dwProductVersion, pLicensedProduct[index].LicensedProduct.pProductInfo->dwVersion) <= 0 &&
            !(pLicensedProduct[index].pLicensedVersion->dwFlags & LICENSED_VERSION_TEMPORARY) &&
            _tcscmp(pmAdjustedRequest->pszProductId, (LPTSTR)(pLicensedProduct[index].LicensedProduct.pProductInfo->pbProductID)) == 0 &&
            tExpireDate-g_dwReissueLeaseLeeway >= ((DWORD)time(NULL)) )
        {
            if( TLSIsBetaNTServer() == TRUE ||
                IS_LICENSE_ISSUER_RTM(pLicensedProduct[index].pLicensedVersion->dwFlags) == TRUE )
            {
                //
                // Blob already contain perm. license that is >= version
                // requested.
                //
                *ppbNewLicense = (PBYTE)midl_user_allocate(cbOldLicense);
                if(*ppbNewLicense != NULL)
                {
                    memcpy(*ppbNewLicense, pbOldLicense, cbOldLicense);
                    *pcbNewLicense = cbOldLicense;
                    status = ERROR_SUCCESS;
                }
                else
                {
                    status = TLS_E_ALLOCATE_MEMORY;
                }

                goto cleanup;
            }
        }         
    }
    
    memset(&LsLicenseRequest, 0, sizeof(TLSDBLICENSEREQUEST));

    status = TLSFormDBRequest(
                            pRequest->pbEncryptedHwid, 
                            pRequest->cbEncryptedHwid,
                            pmAdjustedRequest->dwProductVersion,
                            pmAdjustedRequest->pszCompanyName,
                            pmAdjustedRequest->pszProductId,
                            pmAdjustedRequest->dwLanguageId,
                            pmAdjustedRequest->dwPlatformId,
                            pmAdjustedRequest->pszMachineName,
                            pmAdjustedRequest->pszUserName,
                            &LsLicenseRequest
                        );

    if(status != ERROR_SUCCESS)
    {
        goto cleanup;
    }

    LsLicenseRequest.pPolicy = pPolicy;
    LsLicenseRequest.hClient = hClient;
    LsLicenseRequest.pPolicyLicenseRequest = pmAdjustedRequest;
    LsLicenseRequest.pClientLicenseRequest = &pmLicenseRequest;
    
    memset(&keypack, 0, sizeof(keypack));

    status = TLSVerifyChallengeDataGetWantedLicenseLevel(
                                ChallengeContext,
                                cbChallengeResponse,
                                pbChallenge,
                                &LsLicenseRequest.wLicenseDetail
                            );

    if( status == ERROR_SUCCESS )
    {

        //
        // if client challenge context handle is 0xFFFFFFFF,
        // cbChallenge = 0 and pbChallenge is NULL.
        // client is old version, don't verify challenge
        //            
        Forward.m_pRequest = pRequest;
        Forward.m_ChallengeContext = ChallengeContext;
        Forward.m_cbChallengeResponse = cbChallengeResponse;
        Forward.m_pbChallengeResponse = pbChallenge;
        Forward.m_cbOldLicense = cbOldLicense;
        Forward.m_pbOldLicense = pbOldLicense;

        status = TLSUpgradeLicenseRequest(
                            bForwardRequest,
                            &Forward,
                            pdwSupportFlags,
                            &LsLicenseRequest,
                            pbOldLicense,
                            cbOldLicense,
                            dwNumLicensedProduct,
                            pLicensedProduct,
                            pmAdjustedRequest->fTemporary,
                            pcbNewLicense,
                            ppbNewLicense
                        );

        if(status != ERROR_SUCCESS && bRetryOld == TRUE)
        {           
            pRequest->ProductInfo.dwVersion = dwOriginalVersion;
            bRetryOld = FALSE;
            FreeMemory(ppmLicensedProduct);
            goto RetryPermanent;
        }

        // If (1) PreventUpgradePolicy is not enabled (2) Requested version is 5.0 and (3) There is no .NET Permanent

        else if(status != ERROR_SUCCESS && (bPreventLicenseUpgrade == FALSE ) && bRetry == TRUE &&
            (HIWORD(pRequest->ProductInfo.dwVersion) == 5 && LOWORD(pRequest->ProductInfo.dwVersion) == 0) &&
            !(((pLicensedProduct->pLicensedVersion->wMajorVersion == 5) && 
            (pLicensedProduct->pLicensedVersion->wMinorVersion == 1 || pLicensedProduct->pLicensedVersion->wMinorVersion == 2)) && 
            ((pLicensedProduct->pLicensedVersion->dwFlags & LICENSED_VERSION_TEMPORARY) == 0)))
        { 
            // If (1) client license is 5.0 temporary unmarked then don't upgrade.
            if( ((pLicensedProduct->pLicensedVersion->wMajorVersion == 5) && (pLicensedProduct->pLicensedVersion->wMinorVersion == 0)) &&
                ((pLicensedProduct->pLicensedVersion->dwFlags & LICENSED_VERSION_TEMPORARY) && !(ucMarked & MARK_FLAG_USER_AUTHENTICATED)) &&
                (dwNumLicensedProduct == 1) )
            {
                goto cleanup;
            }

            DWORD dwNewVersion = MAKELONG(2,5);
            pRequest->ProductInfo.dwVersion = dwNewVersion; 
            bRetry = FALSE;                
            FreeMemory(ppmLicensedProduct);
            goto RetryPermanent;
        }

        //If (1) PreventUpgradePolicy is enabled, (2) the Requested version is 5.0, (3) Client License is 5.1 or 5.2 temporary unmarked, reissue another 90 days.
	else if(status != ERROR_SUCCESS && (bPreventLicenseUpgrade == TRUE ) && (bRetry == TRUE) &&
            (HIWORD(pRequest->ProductInfo.dwVersion) == 5 && LOWORD(pRequest->ProductInfo.dwVersion) == 0) &&
            ((pLicensedProduct->pLicensedVersion->wMajorVersion == 5) && 
            (pLicensedProduct->pLicensedVersion->wMinorVersion == 1 || pLicensedProduct->pLicensedVersion->wMinorVersion == 2)) && 
            (pLicensedProduct->pLicensedVersion->dwFlags & LICENSED_VERSION_TEMPORARY) && !(ucMarked & MARK_FLAG_USER_AUTHENTICATED))
        {            
            DWORD dwNewVersion = MAKELONG(2,5);
            pRequest->ProductInfo.dwVersion = dwNewVersion; 
            bRetry = FALSE;                
            FreeMemory(ppmLicensedProduct);
            goto RetryPermanent;
        }
    
    }

cleanup:

    FreeMemory(ppmLicensedProduct);

    for(index =0; index < dwNumLicensedProduct; index++)
    {
        LSFreeLicensedProduct(pLicensedProduct+index);
    }

    FreeMemory(pLicensedProduct);

    lpContext->m_LastError=status;
    InterlockedDecrement( &lpContext->m_RefCount );

    #if DBG
    lpContext->m_LastCall = RPC_CALL_UPGRADELICENSE;
    #endif
    
    *dwErrCode = TLSMapReturnCode(status);

    if(pPolicy)
    {
        pPolicy->PMLicenseRequest(
                            hClient,
                            REQUEST_COMPLETE,
                            UlongToPtr (status),
                            NULL
                        );
        
        ReleasePolicyModule(pPolicy);
    }

    return RPC_S_OK;
}

//-----------------------------------------------------------------------------
error_status_t
TLSRpcCheckLicenseMark(
    /* [in] */ PCONTEXT_HANDLE phContext,
    /* [in] */ const DWORD  cbLicense,
    /* [in, size_is(cbLicense)] */ PBYTE   pbLicense,
    /* [out] */ UCHAR *pucMarkFlags,
    /* [in, out, ref] */ PDWORD pdwErrCode
    )
/*++

Description:

    Check markings on the passed in license

Arguments:

    phContext - client context handle
    cbLicense - size of license to be checked
    pbLicense - license to be checked
    pucMarkFlags - markings on license

Return via pdwErrCode:
    LSERVER_S_SUCCESS
    LSERVER_E_INVALID_DATA      Invalid parameter.
    LSERVER_E_INVALID_LICENSE   License passed in is bad
    LSERVER_E_DATANOTFOUND      license not found in database
    LSERVER_E_CORRUPT_DATABASE  Corrupt database
    LSERVER_E_INTERNAL_ERROR    Internal error in license server

Note:
    This function forwards the request to the issuing license server.  If
    the issuer isn't available, or doesn't have the license in the database,
    it searches in the local database for a license with the same HWID.

++*/
{
    DWORD status = ERROR_SUCCESS;
    LPCLIENTCONTEXT lpContext = (LPCLIENTCONTEXT)phContext;

    if(lpContext == NULL || pdwErrCode == NULL)
    {
        return RPC_S_INVALID_ARG;
    }

    DWORD dwNumLicensedProduct = 0;
    PLICENSEDPRODUCT pLicensedProduct=NULL;
    DWORD index;
    
    DBGPrintf(
            DBG_INFORMATION,
            DBG_FACILITY_RPC,
            DBGLEVEL_FUNCTION_TRACE,
            _TEXT("%s : TLSRpcCheckLicenseMark\n"),
            lpContext->m_Client
        );

    InterlockedIncrement( &lpContext->m_RefCount );

    status = SecureModeCheck();

    if(status != ERROR_SUCCESS )
    {                    
        goto cleanup;
    }

    if(!(lpContext->m_ClientFlags & CLIENT_ACCESS_LSERVER))
    {
        status = TLS_E_ACCESS_DENIED;
        goto cleanup;
    }

    if (NULL == pucMarkFlags)
    {
        status = TLS_E_INVALID_DATA;
        goto cleanup;
    }

    //
    // Convert blob to licensed product structure
    //
    status=LSVerifyDecodeClientLicense(
                            pbLicense, 
                            cbLicense, 
                            g_pbSecretKey, 
                            g_cbSecretKey,
                            &dwNumLicensedProduct,
                            NULL        // find size to allocate
                        );

    if(status != LICENSE_STATUS_OK || dwNumLicensedProduct == 0)
    {
        status = TLS_E_INVALID_LICENSE;
        goto cleanup;
    }

    pLicensedProduct = (PLICENSEDPRODUCT)AllocateMemory(
                               dwNumLicensedProduct * sizeof(LICENSEDPRODUCT)
                               );

    if(pLicensedProduct == NULL)
    {
        status = TLS_E_ALLOCATE_MEMORY;
        goto cleanup;
    }

    status=LSVerifyDecodeClientLicense(
                            pbLicense, 
                            cbLicense, 
                            g_pbSecretKey, 
                            g_cbSecretKey,
                            &dwNumLicensedProduct,
                            pLicensedProduct
                        );

    if(status != LICENSE_STATUS_OK)
    {
        status = TLS_E_INVALID_LICENSE;
        goto cleanup;
    }

    status = TLSCheckLicenseMarkRequest(
                       FALSE,       // don't forward the request
                       pLicensedProduct,
                       cbLicense,
                       pbLicense,
                       pucMarkFlags
                       );

cleanup:

    for(index =0; index < dwNumLicensedProduct; index++)
    {
        LSFreeLicensedProduct(pLicensedProduct+index);
    }

    FreeMemory(pLicensedProduct);

    lpContext->m_LastError=status;

    *pdwErrCode = TLSMapReturnCode(status);

    InterlockedDecrement( &lpContext->m_RefCount );

    return RPC_S_OK;
}

//-----------------------------------------------------------------------------
error_status_t
TLSRpcMarkLicense(
    /* [in] */ PCONTEXT_HANDLE phContext,
    /* [in] */ UCHAR ucMarkFlags,
    /* [in] */ const DWORD  cbLicense,
    /* [in, size_is(cbLicense)] */ PBYTE   pbLicense,
    /* [in, out, ref] */ PDWORD pdwErrCode
    )
/*++

Description:

    Set markings on the passed in license

Arguments:

    phContext - client context handle
    ucMarkFlags - markings on license
    cbLicense - size of license to be checked
    pbLicense - license to be checked

Return via pdwErrCode:
    LSERVER_S_SUCCESS
    LSERVER_E_INVALID_DATA      Invalid parameter.
    LSERVER_E_INVALID_LICENSE   License passed in is bad
    LSERVER_E_DATANOTFOUND      license not found in database
    LSERVER_E_CORRUPT_DATABASE  Corrupt database
    LSERVER_E_INTERNAL_ERROR    Internal error in license server

Note:
    This function forwards the request to the issuing license server.  The
    issuer modifies the database entry of the license to set the markings.

++*/
{
    DWORD status = ERROR_SUCCESS;

    LPCLIENTCONTEXT lpContext = (LPCLIENTCONTEXT)phContext;

    if(lpContext == NULL || pdwErrCode == NULL)
    {
        return RPC_S_INVALID_ARG;
    }

    BOOL bForwardRequest = TRUE;
    DWORD dwNumLicensedProduct = 0;
    PLICENSEDPRODUCT pLicensedProduct=NULL;
    DWORD index;      
   
    DBGPrintf(
            DBG_INFORMATION,
            DBG_FACILITY_RPC,
            DBGLEVEL_FUNCTION_TRACE,
            _TEXT("%s : TLSRpcMarkLicense\n"),
            lpContext->m_Client
        );

    InterlockedIncrement( &lpContext->m_RefCount );

    status = SecureModeCheck();

    if(status != ERROR_SUCCESS )
    {                    
        goto cleanup;        
    }

    if(!(lpContext->m_ClientFlags & CLIENT_ACCESS_REQUEST))
    {
        status = TLS_E_ACCESS_DENIED;
        goto cleanup;
    }

    if(lpContext->m_ClientFlags == CLIENT_ACCESS_LSERVER)
    {
        //
        // do not forward any request or infinite loop might
        // occur.
        //
        bForwardRequest = FALSE;
    }

    //
    // Convert blob to licensed product structure
    //
    status=LSVerifyDecodeClientLicense(
                            pbLicense, 
                            cbLicense, 
                            g_pbSecretKey, 
                            g_cbSecretKey,
                            &dwNumLicensedProduct,
                            NULL        // find size to allocate
                        );

    if(status != LICENSE_STATUS_OK || dwNumLicensedProduct == 0)
    {
        status = TLS_E_INVALID_LICENSE;
        goto cleanup;
    }

    pLicensedProduct = (PLICENSEDPRODUCT)AllocateMemory(
                               dwNumLicensedProduct * sizeof(LICENSEDPRODUCT)
                               );

    if(pLicensedProduct == NULL)
    {
        status = TLS_E_ALLOCATE_MEMORY;
        goto cleanup;
    }

    status=LSVerifyDecodeClientLicense(
                            pbLicense, 
                            cbLicense, 
                            g_pbSecretKey, 
                            g_cbSecretKey,
                            &dwNumLicensedProduct,
                            pLicensedProduct
                        );

    if(status != LICENSE_STATUS_OK)
    {
        status = TLS_E_INVALID_LICENSE;
        goto cleanup;
    }

    for(DWORD iarray = 0; iarray < dwNumLicensedProduct; iarray++ )
    { 
        if ((NULL != pLicensedProduct+iarray) && (NULL != (pLicensedProduct+iarray)->pLicensedVersion) && ((pLicensedProduct+iarray)->pLicensedVersion->dwFlags & LICENSED_VERSION_TEMPORARY))
        {
            //
            // Mark the first temporary license from the top
            //
            status = TLSMarkLicenseRequest(
                           bForwardRequest,
                           ucMarkFlags,
                           (pLicensedProduct+iarray),
                           cbLicense,
                           pbLicense
                           );     
        
            break;
        }
    }
    
cleanup:

    for(index =0; index < dwNumLicensedProduct; index++)
    {
        LSFreeLicensedProduct(pLicensedProduct+index);
    }

    FreeMemory(pLicensedProduct);

    lpContext->m_LastError=status;

    *pdwErrCode = TLSMapReturnCode(status);

    InterlockedDecrement( &lpContext->m_RefCount );

    return RPC_S_OK;
}

//-------------------------------------------------------------------------------
error_status_t 
TLSRpcAllocateConcurrentLicense( 
    /* [in] */ PCONTEXT_HANDLE phContext,
    /* [string][in] */ LPTSTR szHydraServer,
    /* [in] */ TLSLICENSEREQUEST __RPC_FAR *pRequest,
    /* [ref][out][in] */ LONG __RPC_FAR *pdwQuantity,
    /* [ref][out][in] */ PDWORD pdwErrCode
    )
/*++

Description:

    Allocate concurrent licenses base on product.

Arguments:

    phContext - client context handle
    szHydraServer - name of hydra server requesting concurrent licenses
    pRequest - product to request for concurrent license.
    dwQuantity - See note

Return via dwErrCode:
    LSERVER_S_SUCCESS
    LSERVER_E_INVALID_DATA      Invalid parameter.
    LSERVER_E_NO_PRODUCT        request product not installed
    LSERVER_E_NO_LICNESE        no available license for request product 
    LSERVER_E_LICENSE_REVOKED   Request license has been revoked
    LSERVER_E_LICENSE_EXPIRED   Request license has expired
    LSERVER_E_CORRUPT_DATABASE  Corrupt database
    LSERVER_E_INTERNAL_ERROR    Internal error in license server

Note:
    dwQuantity
    Input                       Output
    -------------------------   -----------------------------------------
    0                           Total number of concurrent license 
                                issued to hydra server.
    > 0, number of license      Actual number of license allocated
         requested
    < 0, number of license      Actual number of license returned, always
         to return              positive value.

++*/
{
    RpcRaiseException(RPC_S_CANNOT_SUPPORT);    // doesn't return

    return RPC_S_CANNOT_SUPPORT;
}

//-------------------------------------------------------------------------------
error_status_t 
TLSRpcGetLastError( 
    /* [in] */ PCONTEXT_HANDLE phContext,
    /* [ref][out][in] */ PDWORD cbBufferSize,
    /* [size_is][string][out][in] */ LPTSTR szBuffer,
    /* [ref][out][in] */ PDWORD dwErrCode
    )
/*++

Description:

    Return error description text for client's last LSXXX call

    This function is deprecated.  Use TLSRpcGetLastErrorFixed.

Arguments:

    IN phContext - Client context
    IN cbBufferSize - max. size of szBuffer
    IN OUT szBuffer - Pointer to a buffer to receive the 
                      null-terminated character string containing 
                      error description

Returns via dwErrCode:
    LSERVER_S_SUCCESS

    TLS_E_INTERNAL     No error or can't find corresponding error
                       description.

    Error code from WideCharToMultiByte().

++*/
{
    DWORD status=ERROR_SUCCESS;
    LPTSTR lpMsgBuf=NULL;

    LPCLIENTCONTEXT lpContext = (LPCLIENTCONTEXT)phContext;

    if(lpContext == NULL || dwErrCode == NULL)
    {
        return RPC_S_INVALID_ARG;
    }


    DBGPrintf(
            DBG_INFORMATION,
            DBG_FACILITY_RPC,
            DBGLEVEL_FUNCTION_TRACE,
            _TEXT("%s : TLSRpcGetLastError\n"),
            lpContext->m_Client
        );

    DWORD dwRet;
    dwRet=FormatMessage( 
                    FORMAT_MESSAGE_FROM_HMODULE | FORMAT_MESSAGE_FROM_SYSTEM | 
                            FORMAT_MESSAGE_IGNORE_INSERTS | FORMAT_MESSAGE_ALLOCATE_BUFFER,
                    NULL,
                    lpContext->m_LastError,
                    MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
                    (LPTSTR) &lpMsgBuf,
                    0,
                    NULL
                );
    if(dwRet == 0)
    {
        status = GetLastError();
    }
    else
    {
        _tcsncpy(
                szBuffer, 
                (LPTSTR)lpMsgBuf, 
                min(_tcslen((LPTSTR)lpMsgBuf), *cbBufferSize-1)
            );
        szBuffer[min(_tcslen((LPTSTR)lpMsgBuf), *cbBufferSize-1)] = _TEXT('\0');
        *cbBufferSize = _tcslen(szBuffer) + 1;
    }   

    if(lpMsgBuf)
        LocalFree(lpMsgBuf);

    #if DBG
    lpContext->m_LastCall = RPC_CALL_GET_LASTERROR;
    #endif
  
    lpContext->m_LastError=status;
    *dwErrCode = TLSMapReturnCode(status);
    return RPC_S_OK;
}

//-------------------------------------------------------------------------------
error_status_t 
TLSRpcGetLastErrorFixed( 
    /* [in] */ PCONTEXT_HANDLE phContext,
    /* [string][out] */ LPTSTR *pszBuffer,
    /* [ref][out][in] */ PDWORD pdwErrCode
    )
/*++

Description:

    Return error description text for client's last LSXXX call

Arguments:

    IN phContext - Client context
    OUT pszBuffer - Pointer to a buffer to receive the 
                      null-terminated character string containing 
                      error description

Returns via dwErrCode:
    LSERVER_S_SUCCESS

    TLS_E_INTERNAL     No error or can't find corresponding error
                       description.

++*/
{
    DWORD status=ERROR_SUCCESS;
    
    LPCLIENTCONTEXT lpContext = (LPCLIENTCONTEXT)phContext;

    if(lpContext == NULL || pdwErrCode == NULL)
    {
        return RPC_S_INVALID_ARG;
    }

    DBGPrintf(
            DBG_INFORMATION,
            DBG_FACILITY_RPC,
            DBGLEVEL_FUNCTION_TRACE,
            _TEXT("%s : TLSRpcGetLastErrorFixed\n"),
            lpContext->m_Client
        );

    if ((NULL == pszBuffer) || (NULL == pdwErrCode))
    {
        return RPC_S_INVALID_ARG;
    }

    DWORD dwRet;
    dwRet=FormatMessage( 
                    FORMAT_MESSAGE_FROM_HMODULE
                    | FORMAT_MESSAGE_FROM_SYSTEM
                    | FORMAT_MESSAGE_IGNORE_INSERTS
                    | FORMAT_MESSAGE_ALLOCATE_BUFFER,
                    NULL,
                    lpContext->m_LastError,
                    MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
                    (LPTSTR) &pszBuffer,
                    0,
                    NULL
                );
    if(dwRet == 0)
    {
        status = GetLastError();
    }        

    #if DBG
    lpContext->m_LastCall = RPC_CALL_GET_LASTERROR;
    #endif
  
    lpContext->m_LastError=status;
    *pdwErrCode = TLSMapReturnCode(status);
    return RPC_S_OK;
}

//-------------------------------------------------------------------------------
error_status_t 
TLSRpcKeyPackEnumBegin( 
    /* [in] */ PCONTEXT_HANDLE phContext,
    /* [in] */ DWORD dwSearchParm,
    /* [in] */ BOOL bMatchAll,
    /* [ref][in] */ LPLSKeyPackSearchParm lpSearchParm,
    /* [ref][out][in] */ PDWORD dwErrCode
    )
/*++

Description:

    Function to begin enumerate through all key pack installed on server
    based on search criterial.

Arguments:

    phContext - client context handle.
    dwSearchParm - search criterial.
    bMatchAll - match all search criterial.
    lpSearchParm - search parameter.

Return Value:  

LSERVER_S_SUCCESS
LSERVER_E_SERVER_BUSY       Server is too busy to process request
LSERVER_E_OUTOFMEMORY
TLS_E_INTERNAL
LSERVER_E_INTERNAL_ERROR    
LSERVER_E_INVALID_DATA      Invalid data in search parameter
LSERVER_E_INVALID_SEQUENCE  Invalid calling sequence, likely, previous
                            enumeration has not ended.
++*/
{

    DWORD status=ERROR_SUCCESS;

    LPCLIENTCONTEXT lpContext = (LPCLIENTCONTEXT)phContext;

    if(lpContext == NULL || dwErrCode == NULL)
    {
        return RPC_S_INVALID_ARG;
    }

    InterlockedIncrement( &lpContext->m_RefCount );

    DBGPrintf(
            DBG_INFORMATION,
            DBG_FACILITY_RPC,
            DBGLEVEL_FUNCTION_TRACE,
            _TEXT("%s : TLSRpcKeyPackEnumBegin\n"),
            lpContext->m_Client
        );

    //
    // This will use cached db connection, in-consistency may occurred,
    // visibility of changes in one connection may not appear right away
    // on another connection handle, this is expected behavoir for Jet and
    // so are we, user can always re-fresh.
    //
    do {
        if(lpContext->m_ContextType != CONTEXTHANDLE_EMPTY_TYPE)
        {
            SetLastError(status=TLS_E_INVALID_SEQUENCE);
            break;
        }

        LPENUMHANDLE hEnum;

        hEnum = TLSDBLicenseKeyPackEnumBegin( 
                                    bMatchAll, 
                                    dwSearchParm, 
                                    lpSearchParm 
                                );
        if(hEnum)
        {
            lpContext->m_ContextType = CONTEXTHANDLE_KEYPACK_ENUM_TYPE;
            lpContext->m_ContextHandle = (PVOID)hEnum;
        }
        else
        {
            status = GetLastError();
        }        
    } while(FALSE);

    lpContext->m_LastError=status;
    InterlockedDecrement( &lpContext->m_RefCount );

    #if DBG
    lpContext->m_LastCall = RPC_CALL_KEYPACKENUMBEGIN;
    #endif

    *dwErrCode = TLSMapReturnCode(status);    

    return RPC_S_OK;
}

//-------------------------------------------------------------------------------
error_status_t 
TLSRpcKeyPackEnumNext( 
    /* [in] */ PCONTEXT_HANDLE phContext,
    /* [ref][out] */ LPLSKeyPack lpKeyPack,
    /* [ref][out][in] */ PDWORD dwErrCode
    )
/*++

Description:

    Return next key pack that match search criterial

Arguments:

    phContext - client context handle
    lpKeyPack - key pack that match search criterial

Return Value:  

    LSERVER_S_SUCCESS
    LSERVER_I_NO_MORE_DATA      No more keypack match search criterial
    TLS_E_INTERNAL     General error in license server
    LSERVER_E_INTERNAL_ERROR    Internal error in license server
    LSERVER_E_SERVER_BUSY       License server is too busy to process request
    LSERVER_E_OUTOFMEMORY       Can't process request due to insufficient memory
    LSERVER_E_INVALID_SEQUENCE  Invalid calling sequence, must call
                                LSKeyPackEnumBegin().

++*/
{
    DWORD status = ERROR_SUCCESS;

    LPCLIENTCONTEXT lpContext = (LPCLIENTCONTEXT)phContext;

    if(lpContext == NULL || dwErrCode == NULL)
    {
        return RPC_S_INVALID_ARG;
    }

    BOOL bShowAll = FALSE;

    DBGPrintf(
            DBG_INFORMATION,
            DBG_FACILITY_RPC,
            DBGLEVEL_FUNCTION_TRACE,
            _TEXT("%s : TLSRpcKeyPackEnumNext\n"),
            lpContext->m_Client
        );


    InterlockedIncrement( &lpContext->m_RefCount );

    if(lpContext->m_ClientFlags == CLIENT_ACCESS_LSERVER)
    {
        bShowAll = TRUE;
    }

    // this one might cause access violation
    memset(lpKeyPack, 0, sizeof(LSKeyPack));

    if(lpContext->m_ContextType != CONTEXTHANDLE_KEYPACK_ENUM_TYPE)
    {
        SetLastError(status=TLS_E_INVALID_SEQUENCE);
    }
    else
    {
        do {
            LPENUMHANDLE hEnum=(LPENUMHANDLE)lpContext->m_ContextHandle;
            status=TLSDBLicenseKeyPackEnumNext( 
                                    hEnum, 
                                    lpKeyPack,
                                    bShowAll
                                );
        
        } while(status == TLS_I_MORE_DATA);
    }

    lpContext->m_LastError=GetLastError();
    InterlockedDecrement( &lpContext->m_RefCount );

    #if DBG
    lpContext->m_LastCall = RPC_CALL_KEYPACKENUMNEXT;
    #endif

    *dwErrCode = TLSMapReturnCode(status);

    return RPC_S_OK;
}

//-------------------------------------------------------------------------------
error_status_t 
TLSRpcKeyPackEnumEnd( 
    /* [in] */ PCONTEXT_HANDLE phContext,
    /* [ref][out][in] */ PDWORD dwErrCode
    )
/*++

++*/
{
    DWORD status=ERROR_SUCCESS;

    LPCLIENTCONTEXT lpContext = (LPCLIENTCONTEXT)phContext;

    if(lpContext == NULL || dwErrCode == NULL)
    {
        return RPC_S_INVALID_ARG;
    }

    DBGPrintf(
            DBG_INFORMATION,
            DBG_FACILITY_RPC,
            DBGLEVEL_FUNCTION_TRACE,
            _TEXT("%s : TLSRpcKeyPackEnumEnd\n"),
            lpContext->m_Client
        );

    InterlockedIncrement( &lpContext->m_RefCount );

    if(lpContext->m_ContextType != CONTEXTHANDLE_KEYPACK_ENUM_TYPE)
    {
        SetLastError(status=ERROR_INVALID_HANDLE);
    }
    else
    {
        LPENUMHANDLE hEnum=(LPENUMHANDLE)lpContext->m_ContextHandle;

        TLSDBLicenseKeyPackEnumEnd(hEnum);
        lpContext->m_ContextType = CONTEXTHANDLE_EMPTY_TYPE;
        lpContext->m_ContextHandle=NULL;
    }

    lpContext->m_LastError=GetLastError();
    InterlockedDecrement( &lpContext->m_RefCount );

    #if DBG
    lpContext->m_LastCall = RPC_CALL_KEYPACKENUMEND;
    #endif

    *dwErrCode = TLSMapReturnCode(status);
    return RPC_S_OK;
}

//-------------------------------------------------------------------------------
error_status_t 
TLSRpcKeyPackAdd( 
    /* [in] */ PCONTEXT_HANDLE phContext,
    /* [ref][out][in] */ LPLSKeyPack lpKeypack,
    /* [ref][out][in] */ PDWORD dwErrCode
    )
/*++

Description:

    Add a license key pack.

Arguments:

    phContext - client context handle.
    lpKeyPack - key pack to be added.
    
Return Value:  

    LSERVER_S_SUCCESS
    LSERVER_E_INTERNAL_ERROR
    TLS_E_INTERNAL
    LSERVER_E_SERVER_BUSY
    LSERVER_E_DUPLICATE             Product already installed.
    LSERVER_E_INVALID_DATA
    LSERVER_E_CORRUPT_DATABASE

Note:

    Just return an error - unused

++*/
{
    PTLSDbWorkSpace pDbWkSpace=NULL;
    DWORD status=ERROR_SUCCESS;

    LPCLIENTCONTEXT lpContext = (LPCLIENTCONTEXT)phContext;

    if(lpContext == NULL || dwErrCode == NULL)
    {
        return RPC_S_INVALID_ARG;
    }
    InterlockedIncrement( &lpContext->m_RefCount );

    DBGPrintf(
            DBG_INFORMATION,
            DBG_FACILITY_RPC,
            DBGLEVEL_FUNCTION_TRACE,
            _TEXT("%s : TLSRpcKeyPackAdd\n"),
            lpContext->m_Client
        );


    if(!(lpContext->m_ClientFlags & CLIENT_ACCESS_ADMIN))
    {
        status = TLS_E_ACCESS_DENIED;
    }
    else
    {
        if(!ALLOCATEDBHANDLE(pDbWkSpace, g_GeneralDbTimeout))
        {
            status=TLS_E_ALLOCATE_HANDLE;
        }
        else   
        {
            CLEANUPSTMT;

            BEGIN_TRANSACTION(pDbWkSpace);

            if(lpKeypack->ucKeyPackStatus == LSKEYPACKSTATUS_ADD_LICENSE ||
               lpKeypack->ucKeyPackStatus == LSKEYPACKSTATUS_REMOVE_LICENSE)
            {
                status = ERROR_INVALID_PARAMETER;
            }
            else
            {
                status = TLSDBLicenseKeyPackAdd( 
                                        USEHANDLE(pDbWkSpace), 
                                        lpKeypack 
                                    );
            }

            if(status == ERROR_SUCCESS)
            {
                if( _tcsicmp( lpKeypack->szCompanyName, PRODUCT_INFO_COMPANY_NAME ) == 0 )
                {
                    //
                    // check with known termsrv product ID.
                    //
                    if( _tcsnicmp(  lpKeypack->szProductId, 
                                    TERMSERV_PRODUCTID_SKU, 
                                    _tcslen(TERMSERV_PRODUCTID_SKU)) == 0 )
                    {
                        TLSResetLogLowLicenseWarning(
                                                lpKeypack->szCompanyName,
                                                TERMSERV_PRODUCTID_SKU, 
                                                MAKELONG(lpKeypack->wMinorVersion, lpKeypack->wMajorVersion),
                                                FALSE
                                            );
                    }
                    else if(_tcsnicmp(  lpKeypack->szProductId, 
                                        TERMSERV_PRODUCTID_INTERNET_SKU, 
                                        _tcslen(TERMSERV_PRODUCTID_INTERNET_SKU)) == 0 )
                    {
                        TLSResetLogLowLicenseWarning(
                                                lpKeypack->szCompanyName,
                                                TERMSERV_PRODUCTID_INTERNET_SKU, 
                                                MAKELONG(lpKeypack->wMinorVersion, lpKeypack->wMajorVersion),
                                                FALSE
                                            );
                    }
                    else
                    {
                        TLSResetLogLowLicenseWarning(
                                                lpKeypack->szCompanyName,
                                                lpKeypack->szProductId, 
                                                MAKELONG(lpKeypack->wMinorVersion, lpKeypack->wMajorVersion),
                                                FALSE
                                            );
                    }
                }
                else
                {
                    TLSResetLogLowLicenseWarning(
                                            lpKeypack->szCompanyName,
                                            lpKeypack->szProductId, 
                                            MAKELONG(lpKeypack->wMinorVersion, lpKeypack->wMajorVersion),
                                            FALSE
                                        );
                }
            }            

            if(TLS_ERROR(status))
            {
                ROLLBACK_TRANSACTION(pDbWkSpace);
            }
            else
            {
                COMMIT_TRANSACTION(pDbWkSpace);
            }
        
            FREEDBHANDLE(pDbWkSpace);
        }
    }

    //
    // Post a sync work object
    //
    if( status == ERROR_SUCCESS )
    {
        if( lpKeypack->ucKeyPackType != LSKEYPACKTYPE_FREE )
        {
            if(TLSAnnounceLKPToAllRemoteServer(
                                        lpKeypack->dwKeyPackId,
                                        0
                                    ) != ERROR_SUCCESS)
            {
                TLSLogWarningEvent(TLS_W_ANNOUNCELKP_FAILED);
            }
        }
    }

    #if DBG
    lpContext->m_LastCall = RPC_CALL_KEYPACKADD;
    #endif

    lpContext->m_LastError=status;
    InterlockedDecrement( &lpContext->m_RefCount );
    *dwErrCode = TLSMapReturnCode(status);

    return RPC_S_OK;

}

//-------------------------------------------------------------------------------
error_status_t 
TLSRpcKeyPackSetStatus( 
    /* [in] */ PCONTEXT_HANDLE phContext,
    /* [in] */ DWORD dwSetParm,
    /* [ref][in] */ LPLSKeyPack lpKeyPack,
    /* [ref][out][in] */ PDWORD dwErrCode
    )
/*++

Description:

    Routine to activate/deactivated a key pack.

Arguments:

    phContext - client context handle
    dwSetParam - type of key pack status to be set.
    lpKeyPack - new key pack status.

Return Value:  

    LSERVER_S_SUCCESS
    LSERVER_E_INTERNAL_ERROR
    TLS_E_INTERNAL
    LSERVER_E_INVALID_DATA     
    LSERVER_E_SERVER_BUSY
    LSERVER_E_DATANOTFOUND      Key pack is not in server
    LSERVER_E_CORRUPT_DATABASE

++*/
{
    PTLSDbWorkSpace pDbWkSpace=NULL;

    LPCLIENTCONTEXT lpContext = (LPCLIENTCONTEXT)phContext;

    if(lpContext == NULL || dwErrCode == NULL)
    {
        return RPC_S_INVALID_ARG;
    }

    DWORD status=ERROR_SUCCESS;
    
    InterlockedIncrement( &lpContext->m_RefCount );

    DBGPrintf(
            DBG_INFORMATION,
            DBG_FACILITY_RPC,
            DBGLEVEL_FUNCTION_TRACE,
            _TEXT("%s : TLSRpcKeyPackSetStatus\n"),
            lpContext->m_Client
        );
    

    if(!(lpContext->m_ClientFlags & CLIENT_ACCESS_ADMIN))
    {
        status = TLS_E_ACCESS_DENIED;
    }
    else if( (dwSetParm & ~(LSKEYPACK_SET_KEYPACKSTATUS | LSKEYPACK_SET_ACTIVATEDATE | LSKEYPACK_SET_EXPIREDATE)) &&
             !(lpContext->m_ClientFlags & CLIENT_ACCESS_LRWIZ) ) 
    {
        status = TLS_E_INVALID_DATA;
    }
    else
    {
        if(!ALLOCATEDBHANDLE(pDbWkSpace, g_GeneralDbTimeout))
        {
            status=TLS_E_ALLOCATE_HANDLE;
        }
        else   
        {
            CLEANUPSTMT;

            BEGIN_TRANSACTION(pDbWkSpace);

            status=TLSDBLicenseKeyPackSetStatus( 
                                    USEHANDLE(pDbWkSpace), 
                                    dwSetParm, 
                                    lpKeyPack 
                                );
        
            if(TLS_ERROR(status))
            {
                ROLLBACK_TRANSACTION(pDbWkSpace);
            }
            else
            {
                COMMIT_TRANSACTION(pDbWkSpace);
            }

            FREEDBHANDLE(pDbWkSpace);
        }
    }

    #if DBG
    lpContext->m_LastCall = RPC_CALL_KEYPACKSETSTATUS;
    #endif

    lpContext->m_LastError=status;
    InterlockedDecrement( &lpContext->m_RefCount );
    *dwErrCode = TLSMapReturnCode(status);

    return RPC_S_OK;
}

//-------------------------------------------------------------------------------
error_status_t 
TLSRpcLicenseEnumBegin( 
    /* [in] */ PCONTEXT_HANDLE phContext,
    /* [in] */ DWORD dwSearchParm,
    /* [in] */ BOOL bMatchAll,
    /* [ref][in] */ LPLSLicenseSearchParm lpSearchParm,
    /* [ref][out][in] */ PDWORD dwErrCode
    )
/*++

Description:

    Begin enumeration of license issued based on search criterial

Arguments:

    phContext - client context handle
    dwSearchParm - license search criterial.
    bMatchAll - match all search criterial
    lpSearchParm - license(s) to be enumerated.

Return Value:  

    Same as LSKeyPackEnumBegin().

++*/
{
    PTLSDbWorkSpace pDbWkSpace = NULL;
    DWORD status=ERROR_SUCCESS;
    LPCLIENTCONTEXT lpContext = (LPCLIENTCONTEXT)phContext;

    if(lpContext == NULL || dwErrCode == NULL)
    {
        return RPC_S_INVALID_ARG;
    }

    DBGPrintf(
            DBG_INFORMATION,
            DBG_FACILITY_RPC,
            DBGLEVEL_FUNCTION_TRACE,
            _TEXT("%s : TLSRpcLicenseEnumBegin\n"),
            lpContext->m_Client
        );

    InterlockedIncrement( &lpContext->m_RefCount );

    //
    // This will use cached db connection, in-consistency may occurred,
    // visibility of changes in one connection may not appear right away
    // on another connection handle, this is expected behavoir for Jet and
    // so are we, user can always re-fresh.
    //

    do {
        if(lpContext->m_ContextType != CONTEXTHANDLE_EMPTY_TYPE)
        {
            SetLastError(status=TLS_E_INVALID_SEQUENCE);
            break;
        }

        pDbWkSpace = AllocateWorkSpace(g_EnumDbTimeout);

        // allocate ODBC connections
        if(pDbWkSpace == NULL)
        {
            status=TLS_E_ALLOCATE_HANDLE;
            break;
        }

        LICENSEDCLIENT license;

        ConvertLSLicenseToLicense(lpSearchParm, &license);
        status = TLSDBLicenseEnumBegin( 
                            pDbWkSpace, 
                            bMatchAll, 
                            dwSearchParm & LICENSE_TABLE_EXTERN_SEARCH_MASK, 
                            &license 
                        );            

        if(status == ERROR_SUCCESS)
        {
            lpContext->m_ContextType = CONTEXTHANDLE_LICENSE_ENUM_TYPE;
            lpContext->m_ContextHandle = (PVOID)pDbWkSpace;
        }
    } while(FALSE);

    if(status != ERROR_SUCCESS)
    {
        if(pDbWkSpace)
        {
            ReleaseWorkSpace(&pDbWkSpace);
        }
    }

    #if DBG
    lpContext->m_LastCall = RPC_CALL_LICENSEENUMBEGIN;
    #endif

    InterlockedDecrement( &lpContext->m_RefCount );
    lpContext->m_LastError=status;
    *dwErrCode = TLSMapReturnCode(status);

    return RPC_S_OK;
}

//-------------------------------------------------------------------------------
error_status_t 
TLSRpcLicenseEnumNext( 
    /* [in] */ PCONTEXT_HANDLE phContext,
    /* [ref][out] */ LPLSLicense lpLicense,
    /* [ref][out][in] */ PDWORD dwErrCode
    )
/*++

Abstract:

    Fetch next record match enumeration criterial.

Parameters:

    phContext : Client context handle.
    lpLicense : return next record that match enumeration criterial.
    dwErrCode : error code.

Returns:

    Function returns RPC status, dwErrCode return error code.

Note:

    Must have call TLSRpcLicenseEnumBegin().

++*/
{
    DWORD status=ERROR_SUCCESS;
    LPCLIENTCONTEXT lpContext = (LPCLIENTCONTEXT)phContext;

    if(lpContext == NULL || dwErrCode == NULL)
    {
        return RPC_S_INVALID_ARG;
    }

    InterlockedIncrement( &lpContext->m_RefCount );

    DBGPrintf(
            DBG_INFORMATION,
            DBG_FACILITY_RPC,
            DBGLEVEL_FUNCTION_TRACE,
            _TEXT("%s : TLSRpcLicenseEnumNext\n"),
            lpContext->m_Client
        );

    if(lpContext->m_ContextType != CONTEXTHANDLE_LICENSE_ENUM_TYPE)
    {
        SetLastError(status=TLS_E_INVALID_SEQUENCE);
    }
    else
    {
        PTLSDbWorkSpace pDbWkSpace=(PTLSDbWorkSpace)lpContext->m_ContextHandle;

        LICENSEDCLIENT license;

        memset(lpLicense, 0, sizeof(LSLicense));

        status=TLSDBLicenseEnumNext( 
                            pDbWkSpace, 
                            &license
                        );
        if(status == ERROR_SUCCESS)
        {
            ConvertLicenseToLSLicense(&license, lpLicense);
        }                   
    }

    #if DBG
    lpContext->m_LastCall = RPC_CALL_LICENSEENUMNEXT;
    #endif
   
    lpContext->m_LastError=status;
    InterlockedDecrement( &lpContext->m_RefCount );
    *dwErrCode = TLSMapReturnCode(status);

    return RPC_S_OK;
}

//-------------------------------------------------------------------------------
error_status_t 
TLSRpcLicenseEnumNextEx( 
    /* [in] */ PCONTEXT_HANDLE phContext,
    /* [ref][out] */ LPLSLicenseEx lpLicense,
    /* [ref][out][in] */ PDWORD dwErrCode
    )
/*++

Abstract:

    Fetch next record match enumeration criterial.

Parameters:

    phContext : Client context handle.
    lpLicense : return next record that match enumeration criterial.
    dwErrCode : error code.

Returns:

    Function returns RPC status, dwErrCode return error code.

Note:

    Must have call TLSRpcLicenseEnumBegin().

++*/
{
    DWORD status=ERROR_SUCCESS;

    LPCLIENTCONTEXT lpContext = (LPCLIENTCONTEXT)phContext;
    
    if(lpContext == NULL || dwErrCode == NULL)
    {
        return RPC_S_INVALID_ARG;
    }
    InterlockedIncrement( &lpContext->m_RefCount );

    DBGPrintf(
            DBG_INFORMATION,
            DBG_FACILITY_RPC,
            DBGLEVEL_FUNCTION_TRACE,
            _TEXT("%s : TLSRpcLicenseEnumNextEx\n"),
            lpContext->m_Client
        );

    if(lpContext->m_ContextType != CONTEXTHANDLE_LICENSE_ENUM_TYPE)
    {
        SetLastError(status=TLS_E_INVALID_SEQUENCE);
    }
    else
    {
        PTLSDbWorkSpace pDbWkSpace=(PTLSDbWorkSpace)lpContext->m_ContextHandle;

        LICENSEDCLIENT license;

        memset(lpLicense, 0, sizeof(LSLicenseEx));

        status=TLSDBLicenseEnumNext( 
                            pDbWkSpace, 
                            &license
                        );
        if(status == ERROR_SUCCESS)
        {
            ConvertLicenseToLSLicenseEx(&license, lpLicense);
        }           
    }

    #if DBG
    lpContext->m_LastCall = RPC_CALL_LICENSEENUMNEXT;
    #endif
   
    lpContext->m_LastError=status;
    InterlockedDecrement( &lpContext->m_RefCount );
    *dwErrCode = TLSMapReturnCode(status);

    return RPC_S_OK;
}

//-------------------------------------------------------------------------------
error_status_t 
TLSRpcLicenseEnumEnd( 
    /* [in] */ PCONTEXT_HANDLE phContext,
    /* [ref][out][in] */ PDWORD dwErrCode
    )
/*++

Abstract:

    Terminate a enumeration.

Parameters:

    phContext :
    dwErrCode :

Returns:


Note

++*/
{
    DWORD status=ERROR_SUCCESS;
    LPCLIENTCONTEXT lpContext = (LPCLIENTCONTEXT)phContext;

    if(lpContext == NULL || dwErrCode == NULL)
    {
        return RPC_S_INVALID_ARG;
    }

    InterlockedIncrement( &lpContext->m_RefCount );

    DBGPrintf(
            DBG_INFORMATION,
            DBG_FACILITY_RPC,
            DBGLEVEL_FUNCTION_TRACE,
            _TEXT("%s : TLSRpcLicenseEnumEnd\n"),
            lpContext->m_Client
        );

    if(lpContext->m_ContextType != CONTEXTHANDLE_LICENSE_ENUM_TYPE)
    {
        SetLastError(status=ERROR_INVALID_HANDLE);
    }
    else
    {
        PTLSDbWorkSpace pDbWkSpace = (PTLSDbWorkSpace)lpContext->m_ContextHandle;

        TLSDBLicenseEnumEnd(pDbWkSpace);
        ReleaseWorkSpace(&pDbWkSpace);
        lpContext->m_ContextType = CONTEXTHANDLE_EMPTY_TYPE;
    }        

    #if DBG
    lpContext->m_LastCall = RPC_CALL_LICENSEENUMEND;
    #endif

    lpContext->m_LastError=status;
    InterlockedDecrement( &lpContext->m_RefCount );
    *dwErrCode = TLSMapReturnCode(status);
    return RPC_S_OK;
}

//-------------------------------------------------------------------------------
error_status_t 
TLSRpcLicenseSetStatus( 
    /* [in] */ PCONTEXT_HANDLE phContext,
    /* [in] */ DWORD dwSetParam,
    /* [in] */ LPLSLicense lpLicense,
    /* [ref][out][in] */ PDWORD dwErrCode
    )
/*++

++*/
{
    RpcRaiseException(RPC_S_CANNOT_SUPPORT);    // doesn't return

    return RPC_S_CANNOT_SUPPORT;
}

//-------------------------------------------------------------------------------
error_status_t 
TLSRpcGetAvailableLicenses( 
    /* [in] */ PCONTEXT_HANDLE phContext,
    /* [in] */ DWORD dwSearchParm,
    /* [ref][in] */ LPLSKeyPack lplsKeyPack,
    /* [ref][out] */ LPDWORD lpdwAvail,
    /* [ref][out][in] */ PDWORD dwErrCode
    )
/*++

++*/
{
    PTLSDbWorkSpace pDbWkSpace=NULL;

    LPCLIENTCONTEXT lpContext = (LPCLIENTCONTEXT)phContext;
    
    if(lpContext == NULL || dwErrCode == NULL)
    {
        return RPC_S_INVALID_ARG;
    }

    DWORD status=ERROR_SUCCESS;

    DBGPrintf(
            DBG_INFORMATION,
            DBG_FACILITY_RPC,
            DBGLEVEL_FUNCTION_TRACE,
            _TEXT("%s : TLSRpcGetAvailableLicenses\n"),
            lpContext->m_Client
        );


    InterlockedIncrement( &lpContext->m_RefCount );

    //
    // Don't use global cached DB connection handle, it is possible
    // to get in-consistent value using other DB handle, however, it is
    // also possible that during the time that this function return and
    // the time that client actually make the call to allocate license,
    // all available licenses were allocated by other client.
    //
    pDbWkSpace = AllocateWorkSpace(g_GeneralDbTimeout);
    if(pDbWkSpace == NULL)
    {
        status=TLS_E_ALLOCATE_HANDLE;
    }
    else
    {
        LICENSEPACK keypack;

        memset(&keypack, 0, sizeof(keypack));

        ConvertLsKeyPackToKeyPack(
                        lplsKeyPack, 
                        &keypack, 
                        NULL
                    );

        status = TLSDBKeyPackGetAvailableLicenses(
                                        pDbWkSpace,
                                        dwSearchParm,
                                        &keypack,
                                        lpdwAvail
                                    );

        //FreeTlsLicensePack(&keypack);
   
        ReleaseWorkSpace(&pDbWkSpace);
    }        
    
    lpContext->m_LastError=status;
    InterlockedDecrement( &lpContext->m_RefCount );
    *dwErrCode = TLSMapReturnCode(status);
    return RPC_S_OK;
}

//-------------------------------------------------------------------------------
error_status_t 
TLSRpcGetRevokeKeyPackList( 
    /* [in] */ PCONTEXT_HANDLE phContext,
    /* [out][in] */ PDWORD pcbNumberOfRange,
    /* [size_is][out] */ LPLSRange __RPC_FAR *ppRevokeRange,
    /* [ref][out][in] */ PDWORD pdwErrCode
    )
/*++

++*/
{
    RpcRaiseException(RPC_S_CANNOT_SUPPORT);    // doesn't return

    return RPC_S_CANNOT_SUPPORT;
}

//-------------------------------------------------------------------------------
error_status_t 
TLSRpcGetRevokeLicenseList( 
    /* [in] */ PCONTEXT_HANDLE phContext,
    /* [out][in] */ PDWORD pcbNumberOfRange,
    /* [size_is][out] */ LPLSRange __RPC_FAR *ppRevokeRange,
    /* [ref][out][in] */ PDWORD pdwErrCode
    )
/*++

++*/
{
    RpcRaiseException(RPC_S_CANNOT_SUPPORT);    // doesn't return

    return RPC_S_CANNOT_SUPPORT;
}

//-------------------------------------------------------------------------------
error_status_t 
TLSRpcReturnKeyPack( 
    /* [in] */ PCONTEXT_HANDLE phContext,
    /* [in] */ DWORD dwKeyPackId,
    /* [in] */ DWORD dwReturnReason,
    /* [ref][out][in] */ PDWORD pdwErrCode
    )
/*++

++*/
{
    RpcRaiseException(RPC_S_CANNOT_SUPPORT);    // doesn't return

    return RPC_S_CANNOT_SUPPORT;
}

//-------------------------------------------------------------------------------
error_status_t 
TLSRpcReturnLicense( 
    /* [in] */ PCONTEXT_HANDLE phContext,
    /* [in] */ DWORD dwKeyPackId,
    /* [in] */ DWORD dwLicenseId,
    /* [in] */ DWORD dwReturnReason,
    /* [ref][out][in] */ PDWORD pdwErrCode
    )
/*++

++*/
{
    RpcRaiseException(RPC_S_CANNOT_SUPPORT);    // doesn't return

    return RPC_S_CANNOT_SUPPORT;
}

//-------------------------------------------------------------------------------
error_status_t 
TLSRpcInstallCertificate( 
    /* [in] */ PCONTEXT_HANDLE phContext,
    /* [in] */ DWORD dwCertType,
    /* [in] */ DWORD dwCertLevel,
    /* [in] */ DWORD cbSignCert,
    /* [size_is][in] */ PBYTE pbSignCert,
    /* [in] */ DWORD cbExchCert,
    /* [size_is][in] */ PBYTE pbExchCert,
    /* [ref][out][in] */ PDWORD dwErrCode
    )
/*++

++*/
{
    LPCLIENTCONTEXT lpContext = (LPCLIENTCONTEXT)phContext;

    if(lpContext == NULL || dwErrCode == NULL)
    {
        return RPC_S_INVALID_ARG;
    }

    DWORD status=ERROR_SUCCESS;

    DBGPrintf(
            DBG_INFORMATION,
            DBG_FACILITY_RPC,
            DBGLEVEL_FUNCTION_TRACE,
            _TEXT("%s : TLSRpcInstallCertificate\n"),
            lpContext->m_Client
        );

    InterlockedIncrement( &lpContext->m_RefCount );

    DWORD cbLsSignCert=0;
    PBYTE pbLsSignCert=NULL;

    DWORD cbLsExchCert=0;
    PBYTE pbLsExchCert=NULL;

    if(!(lpContext->m_ClientFlags & CLIENT_ACCESS_ADMIN))
    {
        status = TLS_E_ACCESS_DENIED;
        goto cleanup;
    }

    if(pbSignCert == NULL || pbExchCert == NULL)
    {
        status = TLS_E_INVALID_DATA;
        goto cleanup;

    }

    //
    // Verify input data
    //
    status = TLSVerifyCertChainInMomory(
                                g_hCryptProv,
                                pbSignCert,
                                cbSignCert
                            );
    if(status != ERROR_SUCCESS)
    {
        status = TLS_E_INVALID_DATA;
    }

    //
    // Verify input data
    //
    status = TLSVerifyCertChainInMomory(
                                g_hCryptProv,
                                pbExchCert,
                                cbExchCert
                            );
    if(status != ERROR_SUCCESS)
    {
        status = TLS_E_INVALID_DATA;
    }

    //
    // Block RPC call to serialize install certificate
    //
    if(AcquireRPCExclusiveLock(INFINITE) == FALSE)
    {
        status=TLS_E_ALLOCATE_HANDLE;
        goto cleanup;
    }

    if(AcquireAdministrativeLock(INFINITE) == TRUE)
    {
        if(dwCertLevel == 0)
        {
            status = TLSSaveRootCertificatesToStore(
                                           g_hCryptProv,
                                           cbSignCert, 
                                           pbSignCert, 
                                           cbExchCert,
                                           pbExchCert
                                        );
        }
        else
        {
            status = TLSSaveCertificatesToStore(
                                            g_hCryptProv, 
                                            dwCertType, 
                                            dwCertLevel, 
                                            cbSignCert, 
                                            pbSignCert, 
                                            cbExchCert,
                                            pbExchCert
                                        );

            if(status == ERROR_SUCCESS && dwCertType == CERTIFICATE_CA_TYPE)
            {
                if(cbSignCert)
                {
                    status = IsCertificateLicenseServerCertificate(
                                                        g_hCryptProv,
                                                        AT_SIGNATURE,
                                                        cbSignCert,
                                                        pbSignCert,
                                                        &cbLsSignCert,
                                                        &pbLsSignCert
                                                    );
                }

                if(status == ERROR_SUCCESS && cbExchCert)
                {
                    status = IsCertificateLicenseServerCertificate(
                                                        g_hCryptProv,
                                                        AT_KEYEXCHANGE,
                                                        cbExchCert,
                                                        pbExchCert,
                                                        &cbLsExchCert,
                                                        &pbLsExchCert
                                                    );

                }

                //
                // Install what we have here.
                //
                if(status == ERROR_SUCCESS && (cbLsExchCert || pbLsExchCert))
                {
                    status = TLSInstallLsCertificate(
                                                cbLsSignCert, 
                                                pbLsSignCert, 
                                                cbLsExchCert, 
                                                pbLsExchCert
                                            );
                }

                #ifdef ENFORCE_LICENSING

                // enforce version, check what's installed and restore backup if necessary
                // non-enforce, just install, we won't use it anyway.
                if(status == ERROR_SUCCESS && (cbLsExchCert || pbLsExchCert))
                {
                    // reload certificate
                    if(TLSLoadVerifyLicenseServerCertificates() != ERROR_SUCCESS)
                    {
                        status = TLS_E_INVALID_DATA;

                        // delete the primary certificate registry key
                        TLSRegDeleteKey(
                                    HKEY_LOCAL_MACHINE,
                                    LSERVER_SERVER_CERTIFICATE_REGKEY
                                );

                        //
                        // reload certificate, if anything goes wrong, we will goes 
                        // back to unregister mode.
                        //
                        if(TLSLoadServerCertificate() == FALSE)
                        {
                            // critical error occurred
                            TLSLogErrorEvent(TLS_E_LOAD_CERTIFICATE);
                            
                            // initiate self-shutdown
                            GenerateConsoleCtrlEvent(CTRL_C_EVENT, 0);
                        }
                    }
                    else
                    {
                        DWORD dwStatus;

                        // make sure our backup is up to date.
                        dwStatus = TLSRestoreLicenseServerCertificate(
                                                            LSERVER_SERVER_CERTIFICATE_REGKEY,
                                                            LSERVER_SERVER_CERTIFICATE_REGKEY_BACKUP1
                                                        );
                        if(dwStatus != ERROR_SUCCESS)
                        {
                            TLSLogWarningEvent(TLS_W_BACKUPCERTIFICATE);

                            TLSRegDeleteKey(
                                    HKEY_LOCAL_MACHINE,
                                    LSERVER_SERVER_CERTIFICATE_REGKEY_BACKUP1
                                );
                        }
                                
                        dwStatus = TLSRestoreLicenseServerCertificate(
                                                            LSERVER_SERVER_CERTIFICATE_REGKEY,
                                                            LSERVER_SERVER_CERTIFICATE_REGKEY_BACKUP2
                                                        );
                        if(dwStatus != ERROR_SUCCESS)
                        {
                            TLSLogWarningEvent(TLS_W_BACKUPCERTIFICATE);

                            TLSRegDeleteKey(
                                    HKEY_LOCAL_MACHINE,
                                    LSERVER_SERVER_CERTIFICATE_REGKEY_BACKUP2
                                );
                        }
                    }
                }
                #endif

                if(pbLsSignCert)
                {
                    FreeMemory(pbLsSignCert);
                }

                if(pbLsExchCert)
                {
                    FreeMemory(pbLsExchCert);
                }
            }
        }
    
        ReleaseAdministrativeLock();
    }
    else
    {
        status=TLS_E_ALLOCATE_HANDLE;
    }

    ReleaseRPCExclusiveLock();

cleanup:

    lpContext->m_LastError=status;

    #if DBG
    lpContext->m_LastCall = RPC_CALL_INSTALL_SERV_CERT;
    #endif

    InterlockedDecrement( &lpContext->m_RefCount );
    *dwErrCode = TLSMapReturnCode(status);

    return RPC_S_OK;
}

//-------------------------------------------------------------------------------
error_status_t 
TLSRpcGetServerCertificate( 
    /* [in] */ PCONTEXT_HANDLE phContext,
    /* [in] */ BOOL bSignCert,
    /* [size_is][size_is][out] */ LPBYTE __RPC_FAR *ppCertBlob,
    /* [ref][out] */ LPDWORD lpdwCertBlobLen,
    /* [ref][out][in] */ PDWORD dwErrCode
    )
/*++

++*/
{
    LPCLIENTCONTEXT lpContext = (LPCLIENTCONTEXT)phContext;

    if(lpContext == NULL || dwErrCode == NULL)
    {
        return RPC_S_INVALID_ARG;
    }

    DWORD status=ERROR_SUCCESS;

    InterlockedIncrement( &lpContext->m_RefCount );

    DBGPrintf(
            DBG_INFORMATION,
            DBG_FACILITY_RPC,
            DBGLEVEL_FUNCTION_TRACE,
            _TEXT("%s : TLSRpcGetServerCertificate\n"),
            lpContext->m_Client
        );

    if(!(lpContext->m_ClientFlags & CLIENT_ACCESS_ADMIN))
    {
        status = TLS_E_ACCESS_DENIED;
    }
    else if(!g_pbExchangeEncodedCert || !g_cbExchangeEncodedCert ||
            !g_pbSignatureEncodedCert || !g_cbSignatureEncodedCert)
    {
        status = TLS_E_NO_CERTIFICATE;
    }
    else 
    {
        if(AcquireAdministrativeLock(INFINITE) == TRUE)
        {
            status = TLSSaveCertAsPKCS7( 
                                    (bSignCert) ? g_pbSignatureEncodedCert : g_pbExchangeEncodedCert,
                                    (bSignCert) ? g_cbSignatureEncodedCert : g_cbExchangeEncodedCert,
                                    ppCertBlob,
                                    lpdwCertBlobLen
                                );

            // hack so that we can continue testing...
            if(g_bHasHydraCert == FALSE)
            {
                if(g_pbServerSPK != NULL && g_cbServerSPK != 0)
                {
                    status = TLS_W_SELFSIGN_CERTIFICATE;
                }
                else
                {
                    status = TLS_W_TEMP_SELFSIGN_CERT;
                }
            }
        
            ReleaseAdministrativeLock();
        }
        else
        {
            status = TLS_E_ALLOCATE_HANDLE;
        }
    }

    lpContext->m_LastError=status;

    #if DBG
    lpContext->m_LastCall = RPC_CALL_GETSERV_CERT;
    #endif

    InterlockedDecrement( &lpContext->m_RefCount );
    *dwErrCode = TLSMapReturnCode(status);

    return RPC_S_OK;
}

//-------------------------------------------------------------------------------
void
MyFreeLicenseKeyPack(
    PLicense_KeyPack pLicenseKeyPack 
    )
/*
*/
{
    DWORD i;

    PKeyPack_Description pKpDesc;

    if( pLicenseKeyPack->pDescription )
    {
        for( i = 0, pKpDesc = pLicenseKeyPack->pDescription;
             i < pLicenseKeyPack->dwDescriptionCount;
             i++, pKpDesc++ )
        {
            if(pKpDesc->pDescription)
                LocalFree( pKpDesc->pDescription );

            if(pKpDesc->pbProductName)
                LocalFree( pKpDesc->pbProductName );
        }
    }

    if(pLicenseKeyPack->pDescription)
        LocalFree( pLicenseKeyPack->pDescription );

    if(pLicenseKeyPack->pbManufacturer && pLicenseKeyPack->cbManufacturer != 0)
        LocalFree( pLicenseKeyPack->pbManufacturer );

    if(pLicenseKeyPack->pbManufacturerData && pLicenseKeyPack->cbManufacturerData != 0)
        LocalFree( pLicenseKeyPack->pbManufacturerData );

    if(pLicenseKeyPack->pbProductId && pLicenseKeyPack->cbProductId != 0)
        LocalFree( pLicenseKeyPack->pbProductId );
    return;
}

//---------------------------------------------------------------------
error_status_t 
TLSRpcRegisterLicenseKeyPack( 
    /* [in] */ PCONTEXT_HANDLE phContext,
    /* [size_is][in] */ LPBYTE pbCHCertBlob,
    /* [in] */ DWORD cbCHCertBlobSize,
    /* [size_is][in] */ LPBYTE pbRootCertBlob,
    /* [in] */ DWORD cbRootCertBlob,
    /* [size_is][in] */ LPBYTE lpKeyPackBlob,
    /* [in] */ DWORD dwKeyPackBlobLen,
    /* [ref][out][in] */ PDWORD dwErrCode
    )
/*++

++*/
{
    LPCLIENTCONTEXT lpContext = (LPCLIENTCONTEXT)phContext;

    if(lpContext == NULL || dwErrCode == NULL)
    {
        return RPC_S_INVALID_ARG;
    }

    DWORD status=ERROR_SUCCESS;
    LSKeyPack keypack;

    DBGPrintf(
            DBG_INFORMATION,
            DBG_FACILITY_RPC,
            DBGLEVEL_FUNCTION_TRACE,
            _TEXT("%s : TLSRpcRegisterLicenseKeyPack\n"),
            lpContext->m_Client
        );

    PTLSDbWorkSpace pDbWkSpace;

    InterlockedIncrement( &lpContext->m_RefCount );
    if(!(lpContext->m_ClientFlags & CLIENT_ACCESS_ADMIN))
    {
        status = TLS_E_ACCESS_DENIED;
        goto cleanup;
    }


    if(!ALLOCATEDBHANDLE(pDbWkSpace, g_GeneralDbTimeout))
    {
        status=TLS_E_ALLOCATE_HANDLE;
    }
    else
    {
        License_KeyPack pLicenseKeyPack;
        LicensePackDecodeParm LkpDecodeParm;

        memset(
                &LkpDecodeParm,
                0,
                sizeof(LicensePackDecodeParm)
            );

        LkpDecodeParm.hCryptProv = g_hCryptProv;
        LkpDecodeParm.pbDecryptParm = (PBYTE)g_pszServerPid;
        LkpDecodeParm.cbDecryptParm = (lstrlen(g_pszServerPid) * sizeof(TCHAR));
        LkpDecodeParm.cbClearingHouseCert = cbCHCertBlobSize;
        LkpDecodeParm.pbClearingHouseCert = pbCHCertBlob;
        LkpDecodeParm.pbRootCertificate = pbRootCertBlob;
        LkpDecodeParm.cbRootCertificate = cbRootCertBlob;

        //
        // make code clean, always start a transaction
        //
        CLEANUPSTMT;
        BEGIN_TRANSACTION(pDbWkSpace);

        status = DecodeLicenseKeyPackEx(
                                &pLicenseKeyPack,
                                &LkpDecodeParm,
                                dwKeyPackBlobLen,
                                lpKeyPackBlob
                            );

        if(status != LICENSE_STATUS_OK)
        {
            status = TLS_E_DECODE_KEYPACKBLOB;
            DBGPrintf(
                    DBG_INFORMATION,
                    DBG_FACILITY_RPC,
                    DBGLEVEL_FUNCTION_DETAILSIMPLE,
                    _TEXT("Can't decode key pack blob - %d...\n"),
                    status);
        }
        else
        {
            status=TLSDBRegisterLicenseKeyPack(
                                USEHANDLE(pDbWkSpace), 
                                &pLicenseKeyPack,
                                &keypack
                            );

            MyFreeLicenseKeyPack(&pLicenseKeyPack);
        }        

        if(TLS_ERROR(status)) 
        {
            ROLLBACK_TRANSACTION(pDbWkSpace);
        }
        else
        {
            COMMIT_TRANSACTION(pDbWkSpace);
        }

        FREEDBHANDLE(pDbWkSpace);
    }

    //
    // Post a sync work object
    //
    if(status == ERROR_SUCCESS)
    {
        if(TLSAnnounceLKPToAllRemoteServer(
                                        keypack.dwKeyPackId,
                                        0
                                    ) != ERROR_SUCCESS)
        {
            TLSLogWarningEvent(TLS_W_ANNOUNCELKP_FAILED);
        }
    }

cleanup:

    lpContext->m_LastError=status;

    #if DBG
    lpContext->m_LastCall = RPC_CALL_REGISTER_LICENSE_PACK;
    #endif

    InterlockedDecrement( &lpContext->m_RefCount );
    *dwErrCode = TLSMapReturnCode(status);

    return RPC_S_OK;
}

////////////////////////////////////////////////////////////////////////////
error_status_t 
TLSRpcRequestTermServCert(
    /* [in] */ PCONTEXT_HANDLE phContext,
    /* [in] */ LPTLSHYDRACERTREQUEST pRequest,
    /* [ref][out][in] */ PDWORD pcbChallengeData,
    /* [size_is][out] */ PBYTE* ppbChallengeData,
    /* [ref][out][in] */ PDWORD pdwErrCode
    )
/*++

Abstract:

    Private routine to issue certificate to Terminal Server.

Parameter:

    phContext : Client context handle.
    pRequest : Terminal Server specific certificate request.
    pcbChallengeData : size of Server randomly generated challenge data 
                       to Terminal Server.
    ppbChallengeData : Server randomly generated challenge data to Terminal
                       server.

    pdwErrCode : Error code.

Returns:

    Function always return RPC_S_OK, actual error code is returned in
    pdwErrCode.

Note:

    Routine does not actually issue a license to Terminal Server, Terminal
    Server must call TLSRpcRetrieveTermServCert() to retrieve its own 
    license.

--*/
{
    LPCLIENTCONTEXT lpContext = (LPCLIENTCONTEXT)phContext;
    
    TLSASSERT(pdwErrCode != NULL);

    if(lpContext == NULL)
    {
        if(pRequest != NULL)
        {
            midl_user_free(pRequest);
        }
        *ppbChallengeData = NULL;
        *pcbChallengeData = 0;
        *pdwErrCode = TLSMapReturnCode(TLS_E_INVALID_DATA);
        return RPC_S_INVALID_ARG;
    }
    

    DWORD status=ERROR_SUCCESS;
    LPTERMSERVCERTREQHANDLE lpHandle=NULL;

    DBGPrintf(
            DBG_INFORMATION,
            DBG_FACILITY_RPC,
            DBGLEVEL_FUNCTION_TRACE,
            _TEXT("%s : TLSRpcRequestTermServCert\n"),
            lpContext->m_Client
        );

    *ppbChallengeData = NULL;
    *pcbChallengeData = 0;

    // verify client handle 
    InterlockedIncrement( &lpContext->m_RefCount );
    if(lpContext->m_ContextType != CONTEXTHANDLE_EMPTY_TYPE)
    {
        SetLastError(status=TLS_E_INVALID_SEQUENCE);
        goto cleanup;
    }

    lpHandle = (LPTERMSERVCERTREQHANDLE)AllocateMemory(
                                                sizeof(TERMSERVCERTREQHANDLE)
                                            );
    if(lpHandle == NULL)
    {
        SetLastError(status = ERROR_OUTOFMEMORY);
        goto cleanup;
    }

    //
    // Generate Challenge Data
    //
    lpHandle->pCertRequest = pRequest;
    status = TLSGenerateChallengeData( 
                        CLIENT_INFO_HYDRA_SERVER,
                        &lpHandle->cbChallengeData,
                        &lpHandle->pbChallengeData
                    );

    if(status != ERROR_SUCCESS)
    {
        goto cleanup;
    }

    // return challenge data
    *pcbChallengeData = lpHandle->cbChallengeData;
    *ppbChallengeData = (PBYTE)midl_user_allocate(*pcbChallengeData);
    if(*ppbChallengeData == NULL)
    {
        SetLastError(status = ERROR_OUTOFMEMORY);
        goto cleanup;
    }

    memcpy( *ppbChallengeData,
            lpHandle->pbChallengeData,
            lpHandle->cbChallengeData);

    lpContext->m_ContextHandle = (HANDLE)lpHandle;
    lpContext->m_ContextType = CONTEXTHANDLE_HYDRA_REQUESTCERT_TYPE;

cleanup:

    if(status != ERROR_SUCCESS)
    {
        // frees up memory.
        // Can't overwrite context type.
        //lpContext->m_ContextType = CONTEXTHANDLE_EMPTY_TYPE;

        if(lpHandle != NULL)
        {
            FreeMemory(lpHandle->pbChallengeData);
            FreeMemory(lpHandle);
        }

        if(*ppbChallengeData != NULL)
        {
            midl_user_free(*ppbChallengeData);
        }

        if(pRequest != NULL)
        {
            midl_user_free(pRequest);
        }

        *ppbChallengeData = NULL;
        *pcbChallengeData = 0;
    }

    InterlockedDecrement( &lpContext->m_RefCount );
    lpContext->m_LastError=status;

    #if DBG
    lpContext->m_LastCall = RPC_CALL_REQUEST_TERMSRV_CERT;
    #endif

    *pdwErrCode = TLSMapReturnCode(status);

    return RPC_S_OK;
}

////////////////////////////////////////////////////////////////////////////
error_status_t 
TLSRpcRetrieveTermServCert(
    /* [in] */ PCONTEXT_HANDLE phContext,
    /* [in] */ DWORD cbResponseData,
    /* [size_is][in] */ PBYTE pbResponseData,
    /* [ref][out][in] */ PDWORD pcbCert,
    /* [size_is][out] */ PBYTE* ppbCert,
    /* [ref][out][in] */ PDWORD pdwErrCode
    )
/*++

Abstract:

    Private routine to retrieve Terminal Server's license.

Parameters:

    phContext : client context handle.
    cbResponseData : size of Terminal Server responses data to 
                     license server's challenge.
    pbResponseData : Terminal Server responses data to license 
                     server's challenge.
    pcbCert : Size of Terminal Server's license in bytes.
    ppbCert : Terminal Server's license.
    pdwErrCode : error code if fail.

Returns:

    Function returns RPC_S_OK, actual error code returns in
    pdwErrCode.

Note:

    Must have call TLSRpcRequestTermServCert().


--*/
{
    LPCLIENTCONTEXT lpContext = (LPCLIENTCONTEXT)phContext;

    if(lpContext == NULL || pdwErrCode == NULL)
    {
        return RPC_S_INVALID_ARG;
    }

    DWORD status=ERROR_SUCCESS;
    LPTERMSERVCERTREQHANDLE lpHandle=NULL;
    CTLSPolicy* pPolicy=NULL;
    PMHANDLE hClient;

    PBYTE pbPkcs7=NULL;
    DWORD cbPkcs7=0;
    TLSDBLICENSEREQUEST LicenseRequest;
    DWORD dwQuantity = 1;
    TLSPRODUCTINFO ProductInfo;

    TCHAR szCompanyName[LSERVER_MAX_STRING_SIZE];
    TCHAR szMachineName[MAXCOMPUTERNAMELENGTH];
    TCHAR szUserName[MAXUSERNAMELENGTH];

    PTLSDbWorkSpace pDbWkSpace;

    PMLICENSEREQUEST PMLicenseRequest;
    PPMLICENSEREQUEST pAdjustedRequest;

    TLSDBLICENSEDPRODUCT LicensedProduct;

    DBGPrintf(
            DBG_INFORMATION,
            DBG_FACILITY_RPC,
            DBGLEVEL_FUNCTION_TRACE,
            _TEXT("%s : TLSRpcRetrieveTermServCert\n"),
            lpContext->m_Client
        );


    // verify client handle 
    InterlockedIncrement( &lpContext->m_RefCount );
    if(lpContext->m_ContextType != CONTEXTHANDLE_HYDRA_REQUESTCERT_TYPE)
    {
        SetLastError(status = TLS_E_INVALID_SEQUENCE);
        goto cleanup;
    }

    lpHandle = (LPTERMSERVCERTREQHANDLE)lpContext->m_ContextHandle;
    if( lpHandle == NULL || lpHandle->pCertRequest == NULL ||
        lpHandle->pCertRequest->pbEncryptedHwid == NULL ||
        lpHandle->pCertRequest->cbEncryptedHwid == 0 )
    {
        SetLastError(status = TLS_E_INVALID_SEQUENCE);
        goto cleanup;
    }

	
    //
    // Verify challenge response data
    //

    
    //
    // Request a license from specific key pack
    //

    memset(&LicenseRequest, 0, sizeof(TLSDBLICENSEREQUEST));

    if(!LoadResourceString(
                IDS_HS_COMPANYNAME,
                szCompanyName,
                sizeof(szCompanyName) / sizeof(szCompanyName[0])))
    {
        SetLastError(status = TLS_E_INTERNAL);
        goto cleanup;
    }    

    if(lpContext->m_Client == NULL)
    {
        if(!LoadResourceString(
                    IDS_HS_MACHINENAME,
                    LicenseRequest.szMachineName,
                    sizeof(LicenseRequest.szMachineName)/sizeof(LicenseRequest.szMachineName[0])))
        {
            SetLastError(status = TLS_E_INTERNAL);
            goto cleanup;
        }

        if(!LoadResourceString(
                    IDS_HS_USERNAME,
                    LicenseRequest.szUserName,
                    sizeof(LicenseRequest.szUserName)/sizeof(LicenseRequest.szUserName[0])))
        {
            SetLastError(status = TLS_E_INTERNAL);
            goto cleanup;
        }
    }
    else
    {
        SAFESTRCPY(LicenseRequest.szMachineName, lpContext->m_Client);
        SAFESTRCPY(LicenseRequest.szUserName, lpContext->m_Client);
    }

    LicenseRequest.dwProductVersion = HYDRACERT_PRODUCT_VERSION;
    LicenseRequest.pszProductId = HYDRAPRODUCT_HS_CERTIFICATE_SKU;
    LicenseRequest.pszCompanyName = szCompanyName;

    LicenseRequest.dwLanguageID = GetSystemDefaultLangID(); // ignore
    LicenseRequest.dwPlatformID = CLIENT_PLATFORMID_WINDOWS_NT_FREE; // WINDOWS
    LicenseRequest.pbEncryptedHwid = lpHandle->pCertRequest->pbEncryptedHwid;
    LicenseRequest.cbEncryptedHwid = lpHandle->pCertRequest->cbEncryptedHwid;

    status=LicenseDecryptHwid(
                        &LicenseRequest.hWid, 
                        LicenseRequest.cbEncryptedHwid,
                        LicenseRequest.pbEncryptedHwid,
                        g_cbSecretKey,
                        g_pbSecretKey
                    );

    if(status != ERROR_SUCCESS)
    {
        status = ERROR_INVALID_PARAMETER;
        goto cleanup;
    }

    LicenseRequest.pClientPublicKey = (PCERT_PUBLIC_KEY_INFO)lpHandle->pCertRequest->pSubjectPublicKeyInfo;
    LicenseRequest.clientCertRdn.type =  LSCERT_RDN_STRING_TYPE;
    LicenseRequest.clientCertRdn.szRdn = lpHandle->pCertRequest->szSubjectRdn;
    LicenseRequest.dwNumExtensions = lpHandle->pCertRequest->dwNumCertExtension;
    LicenseRequest.pExtensions = (PCERT_EXTENSION)lpHandle->pCertRequest->pCertExtensions;

    hClient = GenerateClientId();
    pPolicy = AcquirePolicyModule(NULL, NULL, FALSE);
    if(pPolicy == NULL)
    {
        SetLastError(status = TLS_E_INTERNAL);
        goto cleanup;
    }

    PMLicenseRequest.dwProductVersion = LicenseRequest.dwProductVersion;
    PMLicenseRequest.pszProductId = LicenseRequest.pszProductId;
    PMLicenseRequest.pszCompanyName = LicenseRequest.pszCompanyName;
    PMLicenseRequest.dwLanguageId = LicenseRequest.dwLanguageID;
    PMLicenseRequest.dwPlatformId = LicenseRequest.dwPlatformID;
    PMLicenseRequest.pszMachineName = LicenseRequest.szMachineName;
    PMLicenseRequest.pszUserName = LicenseRequest.szUserName;
    PMLicenseRequest.dwLicenseType = LICENSETYPE_LICENSE;

    //
    // Inform Policy module start of new license request
    //
    status = pPolicy->PMLicenseRequest(
                                hClient,
                                REQUEST_NEW,
                                (PVOID) &PMLicenseRequest,
                                (PVOID *) &pAdjustedRequest
                            );

    if(status != ERROR_SUCCESS)
    {
        goto cleanup;
    }
    
    LicenseRequest.pPolicy = pPolicy;
    LicenseRequest.hClient = hClient;

    LicenseRequest.pPolicyLicenseRequest = pAdjustedRequest;
    LicenseRequest.pClientLicenseRequest = &PMLicenseRequest;


    // Call issue new license from sepcific keypack
    if(!ALLOCATEDBHANDLE(pDbWkSpace, g_GeneralDbTimeout))
    {
        status = TLS_E_ALLOCATE_HANDLE;
        goto cleanup;
    }

    CLEANUPSTMT;
    BEGIN_TRANSACTION(pDbWkSpace);

    status = TLSDBIssuePermanentLicense( 
                                USEHANDLE(pDbWkSpace),
                                &LicenseRequest,
                                FALSE,      // bLatestVersion
                                FALSE,      // bAcceptFewerLicenses
                                &dwQuantity,
                                &LicensedProduct,
                                0
                            );    
    
    if(TLS_ERROR(status))
    {
        ROLLBACK_TRANSACTION(pDbWkSpace);
    }
    else
    {
        COMMIT_TRANSACTION(pDbWkSpace);
    }

    FREEDBHANDLE(pDbWkSpace);

    if(status == ERROR_SUCCESS)
    {
        LicensedProduct.pSubjectPublicKeyInfo = (PCERT_PUBLIC_KEY_INFO)lpHandle->pCertRequest->pSubjectPublicKeyInfo;

        //
        // Generate client certificate
        //
        status = TLSGenerateClientCertificate(
                                    g_hCryptProv,
                                    1,
                                    &LicensedProduct,
                                    LICENSE_DETAIL_DETAIL,
                                    &pbPkcs7,
                                    &cbPkcs7
                                );

        if(TLS_ERROR(status) == TRUE)
        {
            goto cleanup;
        }

        status = TLSChainProprietyCertificate(
                                    g_hCryptProv,
                                    (CanIssuePermLicense() == FALSE),
                                    pbPkcs7, 
                                    cbPkcs7, 
                                    ppbCert,
                                    pcbCert 
                                );

        if(status == ERROR_SUCCESS)
        {
            if(CanIssuePermLicense() == FALSE) 
            {
                status = TLS_W_SELFSIGN_CERTIFICATE;
            }
        }
    }

cleanup:

    FreeMemory(pbPkcs7);

    if(pPolicy)
    {
        ReleasePolicyModule(pPolicy);   
    }


    //
    // Free up Hydra Certificate Request handle, 
    // all_nodes attribute so single free.
    //
    if(lpHandle)
    {
        if(lpHandle->pCertRequest)
        {
            midl_user_free(lpHandle->pCertRequest);
        }
    
        if(lpHandle->pbChallengeData)
        {
            midl_user_free(lpHandle->pbChallengeData);
        }

        FreeMemory(lpHandle);
    }

    if(lpContext->m_ContextType == CONTEXTHANDLE_HYDRA_REQUESTCERT_TYPE)
    {
        //
        // force calling TLSRpcRequestTermServCert() again
        //
        lpContext->m_ContextType = CONTEXTHANDLE_EMPTY_TYPE;
        lpContext->m_ContextHandle = NULL;
    }

    InterlockedDecrement( &lpContext->m_RefCount );

    lpContext->m_LastError=status;

    #if DBG
    lpContext->m_LastCall = RPC_CALL_RETRIEVE_TERMSRV_CERT;
    #endif

    *pdwErrCode = TLSMapReturnCode(status);

    return RPC_S_OK;
}

////////////////////////////////////////////////////////////////////////////
error_status_t 
TLSRpcAuditLicenseKeyPack(
    /* [in] */ PCONTEXT_HANDLE phContext,
    /* [in] */ DWORD dwKeyPackId,
    /* [in] */ FILETIME ftStartTime,
    /* [in] */ FILETIME ftEndTime,
    /* [in] */ BOOL bResetCounter,
    /* [ref][out][in] */ LPTLSKeyPackAudit lplsAudit,
    /* [ref][out][in] */ PDWORD pdwErrCode
    )
/*++

    Not implemented yet!.

--*/
{
    RpcRaiseException(RPC_S_CANNOT_SUPPORT);    // doesn't return

    return RPC_S_CANNOT_SUPPORT;
}

////////////////////////////////////////////////////////////////////////////

error_status_t 
TLSRpcGetLSPKCS10CertRequest(
    /* [in] */ PCONTEXT_HANDLE phContext,
    /* [in] */ DWORD dwCertType,
    /* [ref][out][in] */ PDWORD pcbData,
    /* [size_is][size_is][out] */ PBYTE __RPC_FAR *ppbData,
    /* [ref][out][in] */ PDWORD dwErrCode
    )
/*

Abstract:


Note:

    No longer supported - doesn't make sense to give out our private key

*/
{
    
    RpcRaiseException(RPC_S_CANNOT_SUPPORT);    // doesn't return

    return RPC_S_CANNOT_SUPPORT;
}

////////////////////////////////////////////////////////////////////////////// 
//
// Replication function
//
////////////////////////////////////////////////////////////////////////////
error_status_t 
TLSRpcBeginReplication( 
    /* [in] */ PCONTEXT_HANDLE phContext,
    /* [string][in] */ LPTSTR pszLsSetupId,
    /* [string][in] */ LPTSTR pszLsServerName,
    /* [in] */ DWORD cbDomainSid,
    /* [size_is][in] */ PBYTE pbDomainSid,
    /* [ref][out][in] */ FILETIME __RPC_FAR *pftLastBackupTime,
    /* [ref][out][in] */ PDWORD pdwErrCode
    )
/*++

++*/
{
    RpcRaiseException(RPC_S_CANNOT_SUPPORT);    // doesn't return

    return RPC_S_CANNOT_SUPPORT;
}

////////////////////////////////////////////////////////////////////////////

error_status_t 
TLSRpcEndReplication( 
    /* [in] */ PCONTEXT_HANDLE phContext
    )
/*++

++*/
{
    return RPC_S_OK;
}

////////////////////////////////////////////////////////////////////////////

error_status_t 
TLSRpcReplicateRecord( 
    /* [in] */ PCONTEXT_HANDLE phContext,
    /* [ref][in] */ PTLSReplRecord pReplRecord,
    /* [ref][out][in] */ PDWORD pdwErrCode
    )
/*++

++*/
{
    RpcRaiseException(RPC_S_CANNOT_SUPPORT);    // doesn't return

    return RPC_S_CANNOT_SUPPORT;
}

////////////////////////////////////////////////////////////////////////////

error_status_t 
TLSRpcTableEnumBegin( 
    /* [in] */ PCONTEXT_HANDLE phContext,
    /* [in] */ DWORD dwSearchParam,
    /* [ref][in] */ PTLSReplRecord pRecord,
    /* [ref][out][in] */ PDWORD pdwErrCode
    )
/*++

++*/
{
    RpcRaiseException(RPC_S_CANNOT_SUPPORT);    // doesn't return

    return RPC_S_CANNOT_SUPPORT;
}

////////////////////////////////////////////////////////////////////////////

error_status_t 
TLSRpcTableEnumNext( 
    /* [in] */ PCONTEXT_HANDLE phContext,
    /* [ref][out][in] */ PTLSReplRecord pRecord,
    /* [ref][out][in] */ PDWORD pdwErrCode
    )
/*++

++*/
{
    RpcRaiseException(RPC_S_CANNOT_SUPPORT);    // doesn't return

    return RPC_S_CANNOT_SUPPORT;
}

////////////////////////////////////////////////////////////////////////////

error_status_t 
TLSRpcTableEnumEnd( 
    /* [in] */ PCONTEXT_HANDLE phContext
    )
/*++

++*/
{
    return RPC_S_OK;
}

////////////////////////////////////////////////////////////////////////////

error_status_t 
TLSRpcInstallPolicyModule(
    /* [in] */ PCONTEXT_HANDLE phContext,
    /* [string][in] */ LPTSTR pszCompanyName,
    /* [string][in] */ LPTSTR pszProductId,
    /* [string][in] */ LPTSTR pszPolicyDllName,
    /* [ref][out][in] */ PDWORD pdwErrCode
    )
/*++

++*/
{
    RpcRaiseException(RPC_S_CANNOT_SUPPORT);    // doesn't return

    return RPC_S_CANNOT_SUPPORT;
}

////////////////////////////////////////////////////////////////////////////

error_status_t 
TLSRpcAnnounceServer( 
    /* [in] */ PCONTEXT_HANDLE phContext,
    /* [in] */ DWORD dwAnnounceType,
    /* [in] */ FILETIME __RPC_FAR *pLastStartupTime,
    /* [string][in] */ LPTSTR pszSetupId,
    /* [string][in] */ LPTSTR pszDomainName,
    /* [string][in] */ LPTSTR pszLserverName,
    /* [ref][out][in] */ PDWORD pdwErrCode
    )
/*++

Abstract:

    Private routine for other license server to announce presence of
    itself.

Parameters:



Returns:


Note:


++*/
{    
    LPCLIENTCONTEXT lpContext = (LPCLIENTCONTEXT)phContext;

    if(lpContext == NULL || pdwErrCode == NULL)
    {
        return RPC_S_INVALID_ARG;
    }

    DWORD status = ERROR_SUCCESS;
    BOOL bSuccess = TRUE;
    
    DBGPrintf(
            DBG_INFORMATION,
            DBG_FACILITY_RPC,
            DBGLEVEL_FUNCTION_TRACE,
            _TEXT("%s : TLSRpcAnnounceServer\n"),
            lpContext->m_Client
        );

    status = SecureModeCheck();

    if(status != ERROR_SUCCESS )
    {                    
        *pdwErrCode = TLSMapReturnCode(status);
        return RPC_S_OK;
    }

    InterlockedIncrement( &lpContext->m_RefCount );
        
    //
    // Verify it is a license server
    //
    if(lpContext->m_ClientFlags != CLIENT_ACCESS_LSERVER)
    {
        status = TLS_E_ACCESS_DENIED;
    }

    if( status == ERROR_SUCCESS && 
        (dwAnnounceType == TLSANNOUNCE_TYPE_STARTUP || dwAnnounceType == TLSANNOUNCE_TYPE_RESPONSE) )
    {      
        status = TLSRegisterServerWithName(
                                    pszSetupId, 
                                    pszDomainName, 
                                    pszLserverName
                                );
        if(status == TLS_E_DUPLICATE_RECORD)
        {
            status = ERROR_SUCCESS;
        }
    }

    if(status == ERROR_SUCCESS)
    {
        if(dwAnnounceType == TLSANNOUNCE_TYPE_STARTUP)
        {
            //
            // Prevent loop back, use job to response announce
            //
            status = TLSStartAnnounceResponseJob(
                                            pszSetupId,
                                            pszDomainName,
                                            pszLserverName,
                                            &g_ftLastShutdownTime
                                        );
        }

        if(status == ERROR_SUCCESS)
        {
            // Create a CSSync workobject to sync. local LKP
            status = TLSPushSyncLocalLkpToServer(
                                pszSetupId,
                                pszDomainName,
                                pszLserverName,
                                pLastStartupTime
                            );
        }
        else
        {
            // reset error code, can't connect back to server -
            // server might be available anymore.
            status = ERROR_SUCCESS;
        }
    }

    lpContext->m_LastError=status;
    InterlockedDecrement( &lpContext->m_RefCount );

    #if DBG
    lpContext->m_LastCall = RPC_CALL_ANNOUNCE_SERVER;
    #endif

    *pdwErrCode = TLSMapReturnCode(status);
    return RPC_S_OK;
}

////////////////////////////////////////////////////////////////////////////

error_status_t 
TLSRpcLookupServer( 
    /* [in] */ PCONTEXT_HANDLE phContext,
    /* [string][in] */ LPTSTR pszLookupSetupId,
    /* [size_is][string][out][in] */ LPTSTR pszLsSetupId,
    /* [out][in] */ PDWORD pcbSetupId,
    /* [size_is][string][out][in] */ LPTSTR pszDomainName,
    /* [ref][out][in] */ PDWORD pcbDomainName,
    /* [size_is][string][out][in] */ LPTSTR pszMachineName,
    /* [ref][out][in] */ PDWORD pcbMachineName,
    /* [ref][out][in] */ PDWORD pdwErrCode
    )
/*++

Abstract:

    Look up a license server via a license server's setupId.

    This function is deprecated.  Use TLSRpcLookupServerFixed.

Parameters:


Returns:


Note:


++*/
{   
    DWORD dwStatus = ERROR_SUCCESS;
    LPCLIENTCONTEXT lpContext = (LPCLIENTCONTEXT)phContext;

    if(lpContext == NULL || pdwErrCode == NULL)
    {
        return RPC_S_INVALID_ARG;
    }

    DBGPrintf(
            DBG_INFORMATION,
            DBG_FACILITY_RPC,
            DBGLEVEL_FUNCTION_TRACE,
            _TEXT("%s : TLSRpcLookupServer\n"),
            lpContext->m_Client
        );

    dwStatus = SecureModeCheck();

    if(dwStatus != ERROR_SUCCESS )
    {                    
        *pdwErrCode = TLSMapReturnCode(dwStatus);
        return RPC_S_OK;        
    }

    
    InterlockedIncrement( &lpContext->m_RefCount );

    TLServerInfo ServerInfo;    

    if(_tcsicmp(pszLookupSetupId, g_pszServerPid) == 0)
    {
        _tcsncpy(
                pszLsSetupId,
                g_pszServerPid,
                min(_tcslen(g_pszServerPid), *pcbSetupId)
            );

        if(*pcbSetupId <= _tcslen(g_pszServerPid))
        {
            dwStatus = TLS_E_INVALID_DATA;
        }
        else
        {
            pszLsSetupId[min(_tcslen(g_pszServerPid), *pcbSetupId - 1)] = _TEXT('\0');
        }
        *pcbSetupId = _tcslen(g_pszServerPid) + 1;

        //--------------------------------------------------------------
        _tcsncpy(
                pszDomainName, 
                g_szScope,
                min(_tcslen(g_szScope), *pcbDomainName)
            );

        if(*pcbDomainName <= _tcslen(g_szScope))
        {
            dwStatus = TLS_E_INVALID_DATA;
        }
        else
        {
            pszDomainName[min(_tcslen(g_szScope), *pcbDomainName - 1)] = _TEXT('\0');
        }
        *pcbDomainName = _tcslen(g_szScope) + 1;

        //--------------------------------------------------------------
        _tcsncpy(
                pszMachineName,
                g_szComputerName,
                min(_tcslen(g_szComputerName), *pcbMachineName)
            );

        if(*pcbMachineName <= _tcslen(g_szComputerName))
        {
            dwStatus = TLS_E_INVALID_DATA;
        }
        else
        {
            pszMachineName[min(_tcslen(g_szComputerName), *pcbMachineName - 1)] = _TEXT('\0');
        }
        *pcbMachineName = _tcslen(g_szComputerName) + 1;

    }
    else
    {
        dwStatus = TLSLookupRegisteredServer(
                                    pszLookupSetupId,
                                    NULL,
                                    pszMachineName,
                                    &ServerInfo
                                );
        if(dwStatus == ERROR_SUCCESS)
        {
            _tcsncpy(
                    pszLsSetupId, 
                    ServerInfo.GetServerId(),
                    min(_tcslen(ServerInfo.GetServerId()), *pcbSetupId)
                );

            if(*pcbSetupId <= _tcslen(ServerInfo.GetServerId()))
            {
                dwStatus = TLS_E_INVALID_DATA;
            }
            else
            {
                pszLsSetupId[min(_tcslen(ServerInfo.GetServerId()), *pcbSetupId - 1)] = _TEXT('\0');
            }

            *pcbSetupId = _tcslen(ServerInfo.GetServerId()) + 1;

            //--------------------------------------------------------------
            _tcsncpy(
                    pszDomainName, 
                    ServerInfo.GetServerDomain(),
                    min(_tcslen(ServerInfo.GetServerDomain()), *pcbDomainName)
                );
            if(*pcbDomainName <= _tcslen(ServerInfo.GetServerDomain()))
            {
                dwStatus = TLS_E_INVALID_DATA;
            }
            else
            {
                pszDomainName[min(_tcslen(ServerInfo.GetServerDomain()), *pcbDomainName - 1)] = _TEXT('\0');
            }
            *pcbDomainName = _tcslen(ServerInfo.GetServerDomain()) + 1;

            //--------------------------------------------------------------
            _tcsncpy(
                    pszMachineName,
                    ServerInfo.GetServerName(),
                    min(_tcslen(ServerInfo.GetServerName()), *pcbMachineName)
                );

            if(*pcbMachineName <= _tcslen(ServerInfo.GetServerName()))
            {
                dwStatus = TLS_E_INVALID_DATA;
            }
            else
            {
                pszMachineName[min(_tcslen(ServerInfo.GetServerName()), *pcbMachineName - 1)] = _TEXT('\0');
            }
            *pcbMachineName = _tcslen(ServerInfo.GetServerName()) + 1;
        } 
    }   

    lpContext->m_LastError=dwStatus;
    InterlockedDecrement( &lpContext->m_RefCount );

    #if DBG
    lpContext->m_LastCall = RPC_CALL_SERVERLOOKUP;
    #endif

    *pdwErrCode = TLSMapReturnCode(dwStatus);
    return RPC_S_OK;
}

////////////////////////////////////////////////////////////////////////////

error_status_t 
TLSRpcLookupServerFixed( 
    /* [in] */ PCONTEXT_HANDLE phContext,
    /* [string][in] */ LPTSTR szLookupSetupId,
    /* [string][out] */ LPTSTR *pszLsSetupId,
    /* [string][out] */ LPTSTR *pszDomainName,
    /* [string][out] */ LPTSTR *pszMachineName,
    /* [ref][out][in] */ PDWORD pdwErrCode
    )
/*++

Abstract:

    Look up a license server via a license server's setupId.


Parameters:


Returns:


Note:


++*/
{    
    LPCLIENTCONTEXT lpContext = (LPCLIENTCONTEXT)phContext;

    if(lpContext == NULL || pdwErrCode == NULL)
    {
        return RPC_S_INVALID_ARG;
    }

    DBGPrintf(
            DBG_INFORMATION,
            DBG_FACILITY_RPC,
            DBGLEVEL_FUNCTION_TRACE,
            _TEXT("%s : TLSRpcLookupServerFixed\n"),
            lpContext->m_Client
        );

    InterlockedIncrement( &lpContext->m_RefCount );

    TLServerInfo ServerInfo;
    DWORD dwStatus = ERROR_SUCCESS;

    if(_tcsicmp(szLookupSetupId, g_pszServerPid) == 0)
    {
        *pszLsSetupId = (LPTSTR) MIDL_user_allocate((_tcslen(g_pszServerPid)+1)*sizeof(TCHAR));

        if (NULL != *pszLsSetupId)
        {
            _tcscpy(
                *pszLsSetupId,
                g_pszServerPid
            );
        }
        else
        {
            dwStatus = TLS_E_ALLOCATE_MEMORY;
        }

        //--------------------------------------------------------------
        *pszDomainName = (LPTSTR) MIDL_user_allocate((_tcslen(g_pszScope)+1)*sizeof(TCHAR));

        if (NULL != *pszDomainName)
        {
            _tcscpy(
                *pszDomainName,
                g_pszScope
            );
        }
        else
        {
            dwStatus = TLS_E_ALLOCATE_MEMORY;
        }

        //--------------------------------------------------------------
        *pszMachineName = (LPTSTR) MIDL_user_allocate((_tcslen(g_szComputerName)+1)*sizeof(TCHAR));

        if (NULL != *pszMachineName)
        {
            _tcscpy(
                *pszMachineName,
                g_szComputerName
            );
        }
        else
        {
            dwStatus = TLS_E_ALLOCATE_MEMORY;
        }
    }
    else
    {
        dwStatus = TLSLookupRegisteredServer(
                                    szLookupSetupId,
                                    NULL,
                                    NULL,
                                    &ServerInfo
                                );
        if(dwStatus == ERROR_SUCCESS)
        {
            *pszLsSetupId = (LPTSTR) MIDL_user_allocate((_tcslen(ServerInfo.GetServerId())+1)*sizeof(TCHAR));

            if (NULL != *pszLsSetupId)
            {
                _tcscpy(
                        *pszLsSetupId,
                        ServerInfo.GetServerId()
                        );
            }
            else
            {
                dwStatus = TLS_E_ALLOCATE_MEMORY;
            }


            //--------------------------------------------------------------
            *pszDomainName = (LPTSTR) MIDL_user_allocate((_tcslen(ServerInfo.GetServerDomain())+1)*sizeof(TCHAR));

            if (NULL != *pszDomainName)
            {
                _tcscpy(
                        *pszDomainName,
                        ServerInfo.GetServerDomain()
                        );
            }
            else
            {
                dwStatus = TLS_E_ALLOCATE_MEMORY;
            }

            //--------------------------------------------------------------
            *pszMachineName = (LPTSTR) MIDL_user_allocate((_tcslen(ServerInfo.GetServerName())+1)*sizeof(TCHAR));

            if (NULL != *pszMachineName)
            {
                _tcscpy(
                        *pszMachineName,
                        ServerInfo.GetServerName()
                        );
            }
            else
            {
                dwStatus = TLS_E_ALLOCATE_MEMORY;
            }
        } 
    }   

    lpContext->m_LastError=dwStatus;
    InterlockedDecrement( &lpContext->m_RefCount );

    #if DBG
    lpContext->m_LastCall = RPC_CALL_SERVERLOOKUP;
    #endif

    *pdwErrCode = TLSMapReturnCode(dwStatus);
    return RPC_S_OK;
}

////////////////////////////////////////////////////////////////////////////

error_status_t 
TLSRpcAnnounceLicensePack( 
    /* [in] */ PCONTEXT_HANDLE phContext,
    /* [in] */ PTLSReplRecord pReplRecord,
    /* [ref][out][in] */ PDWORD pdwErrCode
    )
/*++

Abstract:

    Private routine for one license server to announce it has particular
    License Pack.

Parameters:



Returns:


++*/
{   
    LPCLIENTCONTEXT lpContext = (LPCLIENTCONTEXT)phContext;

    if(lpContext == NULL || pReplRecord == NULL || pdwErrCode== NULL)
    {
        return RPC_S_INVALID_ARG;
    }

    DWORD dwStatus=ERROR_SUCCESS;
    PTLSDbWorkSpace pDbWkSpace=NULL;
    TLSLICENSEPACK LicPack;

    DBGPrintf(
            DBG_INFORMATION,
            DBG_FACILITY_RPC,
            DBGLEVEL_FUNCTION_TRACE,
            _TEXT("%s : TLSRpcAnnounceLicensePack\n"),
            lpContext->m_Client
        );

    InterlockedIncrement( &lpContext->m_RefCount );

    dwStatus = SecureModeCheck();

    if(dwStatus != ERROR_SUCCESS )
    {                    
        goto cleanup;        
    }

    if(lpContext->m_ClientFlags != CLIENT_ACCESS_LSERVER)
    {
        dwStatus = TLS_E_ACCESS_DENIED;
        goto cleanup;
    }

    if(pReplRecord->dwUnionType != UNION_TYPE_LICENSEPACK)
    {
        dwStatus = TLS_E_INVALID_DATA;
        goto cleanup;
    }

    if(!ALLOCATEDBHANDLE(pDbWkSpace, g_GeneralDbTimeout))
    {
        dwStatus = TLS_E_ALLOCATE_HANDLE;
        goto cleanup;
    }

    CLEANUPSTMT;
    BEGIN_TRANSACTION(pDbWkSpace);
    
    LicPack = pReplRecord->w.ReplLicPack;
    //
    // TODO - verify input parameters
    //
    dwStatus = TLSDBRemoteKeyPackAdd(
                            USEHANDLE(pDbWkSpace),
                            &LicPack
                        );

    if(TLS_ERROR(dwStatus) && dwStatus != TLS_E_DUPLICATE_RECORD)
    {
        ROLLBACK_TRANSACTION(pDbWkSpace);
    }
    else
    {
        COMMIT_TRANSACTION(pDbWkSpace);
    }

    FREEDBHANDLE(pDbWkSpace);
    
cleanup:

    lpContext->m_LastError=dwStatus;
    InterlockedDecrement( &lpContext->m_RefCount );

    #if DBG
    lpContext->m_LastCall = RPC_CALL_ANNOUNCELICENSEPACK;
    #endif

    *pdwErrCode = TLSMapReturnCode(dwStatus);

    return RPC_S_OK;
}

////////////////////////////////////////////////////////////////////////////

error_status_t 
TLSRpcReturnLicensedProduct( 
    /* [in] */ PCONTEXT_HANDLE phContext,
    /* [in] */ PTLSLicenseToBeReturn pClientLicense,
    /* [ref][out][in] */ PDWORD pdwErrCode
    )
/*++


++*/
{    
    LPCLIENTCONTEXT lpContext = (LPCLIENTCONTEXT)phContext;

    if(lpContext == NULL || pClientLicense == NULL || pdwErrCode == NULL)
    {
        return RPC_S_INVALID_ARG;
    }

    DWORD dwStatus=ERROR_SUCCESS;
    CTLSPolicy* pPolicy=NULL;
    PTLSDbWorkSpace pDbWorkSpace;
    PMHANDLE hClient;

    DBGPrintf(
            DBG_INFORMATION,
            DBG_FACILITY_RPC,
            DBGLEVEL_FUNCTION_TRACE,
            _TEXT("%s : TLSRpcReturnLicensedProduct\n"),
            lpContext->m_Client
        );

    InterlockedIncrement( &lpContext->m_RefCount );

    dwStatus = SecureModeCheck();

    if(dwStatus != ERROR_SUCCESS )
    {                    
        goto cleanup;        
    }

    if(lpContext->m_ClientFlags != CLIENT_ACCESS_LSERVER)
    {
        dwStatus = TLS_E_ACCESS_DENIED;
        goto cleanup;
    }


    pPolicy = AcquirePolicyModule(
                            pClientLicense->pszCompanyName,
                            pClientLicense->pszOrgProductId,
                            FALSE
                        );

    if(pPolicy == NULL)
    {
        dwStatus = GetLastError();
        goto cleanup;
    }

    hClient = GenerateClientId();

    if(!ALLOCATEDBHANDLE(pDbWkSpace, g_GeneralDbTimeout))
    {
        dwStatus=TLS_E_ALLOCATE_HANDLE;
        goto cleanup;
    }

    CLEANUPSTMT;
    BEGIN_TRANSACTION(pDbWorkSpace);
    
    dwStatus = TLSReturnClientLicensedProduct(
                                    USEHANDLE(pDbWkSpace),
                                    hClient,
                                    pPolicy,
                                    pClientLicense
                                );
    
    if(TLS_ERROR(dwStatus))
    {
        ROLLBACK_TRANSACTION(pDbWorkSpace);
    }
    else
    {
        COMMIT_TRANSACTION(pDbWorkSpace);
    }
    if (dwStatus == ERROR_SUCCESS)
    {
        TLSAnnounceLKPToAllRemoteServer(pClientLicense->dwKeyPackId,0);
    }

    FREEDBHANDLE(pDbWorkSpace);
            

cleanup:

    lpContext->m_LastError=dwStatus;
    InterlockedDecrement( &lpContext->m_RefCount );

    #if DBG
    lpContext->m_LastCall = RPC_CALL_RETURNLICENSE;
    #endif

    *pdwErrCode = TLSMapReturnCode(dwStatus);

    if(pPolicy)
    {
        pPolicy->PMLicenseRequest(
                            hClient,
                            REQUEST_COMPLETE,
                            UlongToPtr (dwStatus),
                            NULL
                        );
        
        ReleasePolicyModule(pPolicy);
    }

    return RPC_S_OK;
}

////////////////////////////////////////////////////////////////////////////

error_status_t 
TLSRpcChallengeServer(
    /* [in] */ PCONTEXT_HANDLE phContext,
    /* [in] */ DWORD dwClientType,
    /* [in] */ PTLSCHALLENGEDATA pClientChallenge,
    /* [out][in] */ PTLSCHALLENGERESPONSEDATA* pServerResponse,
    /* [out][in] */ PTLSCHALLENGEDATA* pServerChallenge,
    /* [ref][out][in] */ PDWORD pdwErrCode
    )
/*++

Abstract:

    Private routine for client to challenge server in order for client 
    confirm server's identity. License Server, in addition to response to 
    client's challenge, also generate random challenge data based on 
    client's self-declare type back to client.

Parameter:

    phContext : Client's context handle.
    dwClientType : Client self-pronounce type, valid values are ...
    pClientChallenge : Client challenge data.
    pServerResponse : Server's responses to client's challenge.
    pServerChallenge : Server's challenge to client.
    pdwErrCode : Error code if failed.

Returns:


Notes:

    Private routine for LrWiz and License Server to identify itself.

--*/
{    
    LPCLIENTCONTEXT lpContext = (LPCLIENTCONTEXT)phContext;

    if(lpContext == NULL || pdwErrCode == NULL)
    {
        return RPC_S_INVALID_ARG;
    }

    DWORD status=ERROR_SUCCESS;
    

    PTLSCHALLENGEDATA pChallenge=NULL;
    PTLSCHALLENGERESPONSEDATA pResponse = NULL;
    HCRYPTPROV hProv = NULL;

    DBGPrintf(
            DBG_INFORMATION,
            DBG_FACILITY_RPC,
            DBGLEVEL_FUNCTION_TRACE,
            _TEXT("%s : TLSRpcChallengeServer\n"),
            lpContext->m_Client
        );

    InterlockedIncrement( &lpContext->m_RefCount );

    //if(!(lpContext->m_ClientFlags & CLIENT_ACCESS_ADMIN))
    //{
    //    status = TLS_E_ACCESS_DENIED;
    //    goto cleanup;
    //}

    if(lpContext->m_ContextType != CONTEXTHANDLE_EMPTY_TYPE)
    {
        status = TLS_E_INVALID_SEQUENCE;
        goto cleanup;
    }

    //
    // Input parameters...
    //
    if( pClientChallenge == NULL || 
        pServerResponse == NULL ||
        pServerChallenge == NULL )
    {
        status = TLS_E_INVALID_DATA;
        goto cleanup;
    }

    //
    // Verify Data send by client
    //
    if( pClientChallenge->dwVersion != TLS_CURRENT_CHALLENGE_VERSION ||
        pClientChallenge->cbChallengeData == 0 ||
        pClientChallenge->pbChallengeData == NULL )
    {
        status = TLS_E_INVALID_DATA;
        goto cleanup;
    }

    pResponse = (PTLSCHALLENGERESPONSEDATA)midl_user_allocate(sizeof(TLSCHALLENGERESPONSEDATA));
    if(pResponse == NULL)
    {
        status = GetLastError();
        goto cleanup;
    }
                    
    pChallenge = (PTLSCHALLENGEDATA)AllocateMemory(sizeof(TLSCHALLENGEDATA));
    if(pChallenge == NULL)
    {
        status = GetLastError();
        goto cleanup;
    }

    *pServerChallenge = (PTLSCHALLENGEDATA)midl_user_allocate(sizeof(TLSCHALLENGEDATA));
    if(*pServerChallenge == NULL)
    {
        status = GetLastError();
        goto cleanup;
    }

    //
    // Generate Challenge response data
    //
    status = TLSGenerateChallengeResponseData(
                                        g_hCryptProv,
                                        dwClientType,
                                        pClientChallenge,
                                        &(pResponse->pbResponseData),
                                        &(pResponse->cbResponseData)
                                    );
    *pServerResponse = pResponse;

    if(status != ERROR_SUCCESS)
    {
        status = TLS_E_INVALID_DATA;
        goto cleanup;
    }

    //
    // Generate Server side challenge data
    //
    pChallenge->dwVersion = TLS_CURRENT_CHALLENGE_VERSION;

    if (CryptAcquireContext(&hProv,NULL,NULL,PROV_RSA_FULL,CRYPT_VERIFYCONTEXT)) {
        if (!CryptGenRandom(hProv,sizeof(pChallenge->dwRandom), (BYTE *) &pChallenge->dwRandom)) {
            status = TLS_E_INTERNAL;
            goto cleanup;
        }
    } else {
        status = TLS_E_INTERNAL;
        goto cleanup;
    }

    //
    // This must range from 1 to 128, as it's used as an offset into the
    // challenge data buffer
    //

    pChallenge->dwRandom %= RANDOM_CHALLENGE_DATASIZE;
    pChallenge->dwRandom++;

    status = TLSGenerateRandomChallengeData(
                                        g_hCryptProv,
                                        &(pChallenge->pbChallengeData),
                                        &(pChallenge->cbChallengeData)
                                    );

    // base on type, mark this handle...
    if(dwClientType == CLIENT_TYPE_LRWIZ)
    {
        lpContext->m_ContextType = CONTEXTHANDLE_CHALLENGE_LRWIZ_TYPE;
    }
    else
    {
        lpContext->m_ContextType = CONTEXTHANDLE_CHALLENGE_SERVER_TYPE;
    }

    (*pServerChallenge)->pbChallengeData = (PBYTE)midl_user_allocate(pChallenge->cbChallengeData);
    if((*pServerChallenge)->pbChallengeData == NULL)
    {
        status = GetLastError();
        goto cleanup;
    }

    (*pServerChallenge)->dwVersion = TLS_CURRENT_CHALLENGE_VERSION;
    (*pServerChallenge)->dwRandom = pChallenge->dwRandom;
    (*pServerChallenge)->cbChallengeData = pChallenge->cbChallengeData;
    memcpy(
            (*pServerChallenge)->pbChallengeData,
            pChallenge->pbChallengeData,
            pChallenge->cbChallengeData
        );

    lpContext->m_ContextHandle = (HANDLE)(pChallenge);    

cleanup:

    if(status != ERROR_SUCCESS)
    {
        if(pChallenge)
        {
            if(pChallenge->pbChallengeData)
            {
                FreeMemory(pChallenge->pbChallengeData);
            }
            
            if(pChallenge->pbReservedData)
            {
                FreeMemory(pChallenge->pbReservedData);
            }

            FreeMemory(pChallenge);
        }

        if(pResponse)
        {
            if(pResponse->pbResponseData)
            {
                FreeMemory(pResponse->pbResponseData);
            }

            if(pResponse->pbReservedData)
            {
                FreeMemory(pResponse->pbReservedData);
            }
            
            midl_user_free(pResponse);
        }
    }

    if (hProv)
        CryptReleaseContext(hProv,0);

    lpContext->m_LastError=status;
    InterlockedDecrement( &lpContext->m_RefCount );

    #if DBG
    lpContext->m_LastCall = RPC_CALL_CHALLENGESERVER;
    #endif

    *pdwErrCode = TLSMapReturnCode(status);
    return RPC_S_OK;
}

////////////////////////////////////////////////////////////////////////////

error_status_t 
TLSRpcResponseServerChallenge(
    /* [in] */ PCONTEXT_HANDLE phContext,
    /* [in] */ PTLSCHALLENGERESPONSEDATA pClientResponse,
    /* [ref][out][in] */ PDWORD pdwErrCode
    )
/*++

Abstract:

    Client's responses to Server challenge returned TLSRpcChallengeServer(),
    must have call TLSRpcChallengeServer().

Parameter:

    phContext:
    pClientResponses: Client's response to server's challenge.
    pdwErrCode : Return error code.


Returns:


Note:

--*/
{
    LPCLIENTCONTEXT lpContext = (LPCLIENTCONTEXT)phContext;
    
    if(lpContext == NULL || pdwErrCode == NULL)
    {
        return RPC_S_INVALID_ARG;
    }

    DWORD status=ERROR_SUCCESS;
    DWORD dwClientType;
    PTLSCHALLENGEDATA pServerToClientChallenge;

    DBGPrintf(
            DBG_INFORMATION,
            DBG_FACILITY_RPC,
            DBGLEVEL_FUNCTION_TRACE,
            _TEXT("%s : TLSRpcResponseServerChallenge\n"),
            lpContext->m_Client
        );

    InterlockedIncrement( &lpContext->m_RefCount );

    //if(!(lpContext->m_ClientFlags & CLIENT_ACCESS_ADMIN))
    //{
    //    status = TLS_E_ACCESS_DENIED;
    //    goto cleanup;
    //}

    if( pClientResponse == NULL ||
        pClientResponse->pbResponseData == NULL || 
        pClientResponse->cbResponseData == 0 )
    {
        status = TLS_E_INVALID_DATA;
        goto cleanup;
    }

    if(lpContext->m_ContextType != CONTEXTHANDLE_CHALLENGE_SERVER_TYPE &&
       lpContext->m_ContextType != CONTEXTHANDLE_CHALLENGE_LRWIZ_TYPE)
    {
        status = TLS_E_INVALID_SEQUENCE;
        goto cleanup;
    }

    if(lpContext->m_ContextHandle == NULL)
    {
        status = TLS_E_INTERNAL;
        goto cleanup;
    }

    if(lpContext->m_ContextType == CONTEXTHANDLE_CHALLENGE_LRWIZ_TYPE)
    {
        dwClientType = CLIENT_TYPE_LRWIZ;
    }
    else
    {
        dwClientType = CLIENT_TYPE_TLSERVER;
    }

    pServerToClientChallenge = (PTLSCHALLENGEDATA)lpContext->m_ContextHandle; 

    //
    // base on client type, verify challenge response data
    //
    status = TLSVerifyChallengeResponse(
                                g_hCryptProv,
                                dwClientType,
                                pServerToClientChallenge,
                                pClientResponse
                            );

    if(status != ERROR_SUCCESS)
    {
        status = TLS_E_INVALID_DATA;
    }
    else
    {
        if(dwClientType == CLIENT_TYPE_LRWIZ)
        {
            lpContext->m_ClientFlags |= CLIENT_ACCESS_LRWIZ;
        }        
        else
        {
            lpContext->m_ClientFlags |= CLIENT_ACCESS_LSERVER;
        }
    }

    if(pServerToClientChallenge != NULL)
    {
        FreeMemory(pServerToClientChallenge->pbChallengeData);
        FreeMemory(pServerToClientChallenge);
    }
        
    lpContext->m_ContextHandle = NULL;
    lpContext->m_ContextType = CONTEXTHANDLE_EMPTY_TYPE;

cleanup:

    lpContext->m_LastError=status;
    InterlockedDecrement( &lpContext->m_RefCount );

    #if DBG
    lpContext->m_LastCall = RPC_CALL_RESPONSESERVERCHALLENGE;
    #endif

    *pdwErrCode = TLSMapReturnCode(status);
    return RPC_S_OK;
}

////////////////////////////////////////////////////////////////////////////

error_status_t 
TLSRpcGetTlsPrivateData( 
    /* [in] */ PCONTEXT_HANDLE phContext,
    /* [in] */ DWORD dwPrivateDataType,
    /* [switch_is][in] */ PTLSPrivateDataUnion pSearchData,
    /* [ref][out][in] */ PDWORD pdwRetDataType,
    /* [switch_is][out] */ PTLSPrivateDataUnion __RPC_FAR *ppPrivateData,
    /* [ref][out][in] */ PDWORD pdwErrCode
    )

/*++

Abstract:

    Retrieve license server's private data, this include Server's
    unique ID, PID, and registered SPK if any.

Parameters:

    phContext : Client's context handle.
    dwPrivateDataType : Type of private data interested.
    pSearchData : Type of data to search, currently ignore.
    pdwRetDataType : Return data type.
    ppPrivateData : License Server's private data.
    pdwErrCode : Error Code.

Returns:


Note:

    Only LrWiz and License Server can invoke this RPC call.

--*/

{    
    LPCLIENTCONTEXT lpContext = (LPCLIENTCONTEXT)phContext;
    
    if(lpContext == NULL || pdwErrCode == NULL || pdwRetDataType == NULL)
    {
        return RPC_S_INVALID_ARG;
    }

    DWORD status=ERROR_SUCCESS;
    DWORD cbSource=0;
    PBYTE pbSource=NULL;

    DBGPrintf(
            DBG_INFORMATION,
            DBG_FACILITY_RPC,
            DBGLEVEL_FUNCTION_TRACE,
            _TEXT("%s : TLSRpcGetTlsPrivateData\n"),
            lpContext->m_Client
        );

    InterlockedIncrement( &lpContext->m_RefCount );

    //
    // relax restriction on who can get private data
    //
    if( dwPrivateDataType != TLS_PRIVATEDATA_PID && 
        dwPrivateDataType != TLS_PRIVATEDATA_UNIQUEID )
    {
        if(!(lpContext->m_ClientFlags & CLIENT_ACCESS_LRWIZ))
        {
            status = TLS_E_ACCESS_DENIED;
            goto cleanup;
        }
    }

    if( dwPrivateDataType < TLS_PRIVATEDATA_MIN ||
        dwPrivateDataType > TLS_PRIVATEDATA_MAX )
    {
        status = TLS_E_INVALID_DATA;
        goto cleanup;
    }

    //
    // Not supported yet...
    //
    if(dwPrivateDataType == TLS_PRIVATEDATA_INSTALLED_CERT)
    {
        status = TLS_E_NOTSUPPORTED;
        goto cleanup;
    }
        
    //
    // Don't really need this but we might need to support
    // re-generate of License Server ID
    //
    if(!AcquireAdministrativeLock(INFINITE))
    {
        status = TLS_E_ALLOCATE_HANDLE;
        goto cleanup;
    }

    switch(dwPrivateDataType)
    {
        case TLS_PRIVATEDATA_UNIQUEID:
            pbSource = (PBYTE)g_pszServerUniqueId;
            cbSource = g_cbServerUniqueId;
            break;

        case TLS_PRIVATEDATA_PID:
            pbSource = (PBYTE)g_pszServerPid;
            cbSource = g_cbServerPid;
            break;

        case TLS_PRIVATEDATA_SPK:
            pbSource = g_pbServerSPK;
            cbSource = g_cbServerSPK;
    }

    //
    // Currently, what you ask is what you get.
    //
    *pdwRetDataType = dwPrivateDataType;

    if( (dwPrivateDataType != TLS_PRIVATEDATA_SYSTEMLANGID) && 
        (pbSource == NULL || cbSource == 0) )
    {
        status = TLS_E_RECORD_NOTFOUND;
    }
    else
    {
        *ppPrivateData = (PTLSPrivateDataUnion)midl_user_allocate(sizeof(TLSPrivateDataUnion));
        if(*ppPrivateData != NULL)
        {
            memset(
                    *ppPrivateData,
                    0,
                    sizeof(TLSPrivateDataUnion)
                );

            if(*pdwRetDataType == TLS_PRIVATEDATA_SYSTEMLANGID)
            {
                (*ppPrivateData)->systemLangId = GetSystemDefaultLangID();
            }
            else if(*pdwRetDataType == TLS_PRIVATEDATA_SPK)
            {
                (*ppPrivateData)->SPK.cbSPK = cbSource;
                (*ppPrivateData)->SPK.pbSPK = pbSource;
				(*ppPrivateData)->SPK.pCertExtensions = g_pCertExtensions;

                //(*ppPrivateData)->SPK.pCertExtensions = (PTLSCERT_EXTENSIONS)midl_user_allocate(g_cbCertExtensions);
                //memcpy(
                //        (*ppPrivateData)->SPK.pCertExtensions,
                //        g_pCertExtensions,
                //        g_cbCertExtensions
                //    );
            }
            else
            {
                (*ppPrivateData)->BinaryData.cbData = cbSource;
                (*ppPrivateData)->BinaryData.pbData = pbSource;
            }
        }
        else
        {
            status = ERROR_OUTOFMEMORY;
        }
    }

    ReleaseAdministrativeLock();

cleanup:
    lpContext->m_LastError=status;
    InterlockedDecrement( &lpContext->m_RefCount );

    #if DBG
    lpContext->m_LastCall = RPC_CALL_GETPRIVATEDATA;
    #endif

    *pdwErrCode = TLSMapReturnCode(status);
    return RPC_S_OK;
}

////////////////////////////////////////////////////////////////////////////

error_status_t 
TLSRpcSetTlsPrivateData(
    /* [in] */ PCONTEXT_HANDLE phContext,
    /* [in] */ DWORD dwPrivateDataType,
    /* [switch_is][in] */ PTLSPrivateDataUnion pPrivateData,
    /* [ref][out][in] */ PDWORD pdwErrCode
    )

/*++

Abstract:

    Private routine for LrWiz to set license server's private data.

Parameter:

    phContext: Client context handle.
    dwPrivateDataType : Type of private data to set.
    pPrivateData : Private data to set/install.
    pdwErrCode : Server return code.
    
Returns:


Note:

    Only support installing of SPK/Extension at this time.

--*/
{
    LPCLIENTCONTEXT lpContext = (LPCLIENTCONTEXT)phContext;

    if(lpContext == NULL || pPrivateData == NULL || pdwErrCode == NULL)
    {
        return RPC_S_INVALID_ARG;
    }

    DWORD status=ERROR_SUCCESS;
    DWORD dwSpkVerifyResult;

    DBGPrintf(
            DBG_INFORMATION,
            DBG_FACILITY_RPC,
            DBGLEVEL_FUNCTION_TRACE,
            _TEXT("%s : TLSRpcDepositeSPK\n"),
            lpContext->m_Client
        );

    InterlockedIncrement( &lpContext->m_RefCount );

    if(!(lpContext->m_ClientFlags & CLIENT_ACCESS_LRWIZ))
    {
        status = TLS_E_ACCESS_DENIED;
        goto cleanup;
    }

    //
    // Only support SPK at this time
    //
    if(dwPrivateDataType != TLS_PRIVATEDATA_SPK)
    {
        status = TLS_E_INVALID_DATA;
        goto cleanup;
    }

    //
    // Lock all RPC calls related to issuing certificate
    //
    if(!AcquireRPCExclusiveLock(INFINITE))
    {
        status = TLS_E_ALLOCATE_HANDLE;
        goto cleanup;
    }

    do {
        //if(g_pbServerSPK != NULL && g_cbServerSPK != 0)
        //{
        //    status = TLS_E_SPKALREADYEXIST;
        //    break;
        //}

        if(AcquireAdministrativeLock(INFINITE))
        {
            status = TLSReGenSelfSignCert(
                                        g_hCryptProv,
                                        pPrivateData->SPK.pbSPK,
                                        pPrivateData->SPK.cbSPK,
                                        pPrivateData->SPK.pCertExtensions->cExtension,
                                        pPrivateData->SPK.pCertExtensions->rgExtension
                                    );            
            ReleaseAdministrativeLock();
        }
        else
        {
            status = TLS_E_ALLOCATE_HANDLE;
        }            
    } while(FALSE);

    ReleaseRPCExclusiveLock();

cleanup:

    lpContext->m_LastError=status;
    InterlockedDecrement( &lpContext->m_RefCount );

    #if DBG
    lpContext->m_LastCall = RPC_CALL_SETPRIVATEDATA;
    #endif

    *pdwErrCode = TLSMapReturnCode(status);

    return RPC_S_OK;
}

////////////////////////////////////////////////////////////////////////////

error_status_t 
TLSRpcTriggerReGenKey(
    /* [in] */ PCONTEXT_HANDLE phContext,
    /* [in] */ BOOL bRegenKey,
    /* [ref][out][in] */ PDWORD pdwErrCode
    )

/*++

Abstract:

    Private routine to force license server to re-generate its
    public/private key pair, all installed certificates/SPK are
    deleted, User are required to re-register license server.

Parameters:

    phContext : Client context handle.
    bKeepSPKAndExtension : For future use only.
    pdwErrCode : Return error code.

Returns:


++*/

{    
    LPCLIENTCONTEXT lpContext = (LPCLIENTCONTEXT)phContext;
    
    if(lpContext == NULL || pdwErrCode == NULL)
    {
        return RPC_S_INVALID_ARG;
    }

    DWORD status=ERROR_SUCCESS;

    DBGPrintf(
            DBG_INFORMATION,
            DBG_FACILITY_RPC,
            DBGLEVEL_FUNCTION_TRACE,
            _TEXT("%s : TLSRpcTriggerReGenKey\n"),
            lpContext->m_Client
        );

    InterlockedIncrement( &lpContext->m_RefCount );

    if(!(lpContext->m_ClientFlags & CLIENT_ACCESS_LRWIZ))
    {
        status = TLS_E_ACCESS_DENIED;
        goto cleanup;
    }

    LPCTSTR pString[1];

    pString[0] = lpContext->m_Client;
    
    TLSLogEventString(
            EVENTLOG_INFORMATION_TYPE,
            TLS_I_TRIGGER_REGENKEY,
            1,
            pString
        );

    //
    // Block ALL RPC calls
    //
    if(!AcquireRPCExclusiveLock(INFINITE))
    {
        status=TLS_E_ALLOCATE_HANDLE;
        goto cleanup;
    }

    do {
        if(!AcquireAdministrativeLock(INFINITE))
        {
            status = TLS_E_ALLOCATE_HANDLE;
            break;
        }
    
        status = TLSReGenKeysAndReloadServerCert(
                            bRegenKey
                        );
    
        ReleaseAdministrativeLock();

    } while(FALSE);

    ReleaseRPCExclusiveLock();

cleanup:
    lpContext->m_LastError=status;
    InterlockedDecrement( &lpContext->m_RefCount );

    #if DBG
    lpContext->m_LastCall = RPC_CALL_TRIGGERREGENKEY;
    #endif

    *pdwErrCode = TLSMapReturnCode(status);

    return RPC_S_OK;
}

////////////////////////////////////////////////////////////////////////////

error_status_t 
TLSRpcTelephoneRegisterLKP(
    /* [in] */ PCONTEXT_HANDLE phContext,
    /* [in] */ DWORD cbData,
    /* [size_is][in] */ PBYTE pbData,
    /* [ref][out] */ PDWORD pdwErrCode
    )

/*++

--*/

{
    DWORD           status=ERROR_SUCCESS;
    LPCLIENTCONTEXT lpContext = (LPCLIENTCONTEXT)phContext;

    if(lpContext == NULL || pdwErrCode == NULL)
    {
        return RPC_S_INVALID_ARG;
    }

    PTLSDbWorkSpace  pDbWkSpace;
    LSKeyPack keypack;

    DBGPrintf(
            DBG_INFORMATION,
            DBG_FACILITY_RPC,
            DBGLEVEL_FUNCTION_TRACE,
            _TEXT("%s : TLSRpcTelephoneRegisterLKP\n"),
            lpContext->m_Client
        );


    InterlockedIncrement( &lpContext->m_RefCount );
    if(!(lpContext->m_ClientFlags & CLIENT_ACCESS_LRWIZ))
    {
        status = TLS_E_ACCESS_DENIED;
        goto cleanup;
    }

    if(!ALLOCATEDBHANDLE(pDbWkSpace, g_GeneralDbTimeout))
    {
        status=TLS_E_ALLOCATE_HANDLE;
        goto cleanup;
    }

    CLEANUPSTMT;
    BEGIN_TRANSACTION(pDbWkSpace);

    status = TLSDBTelephoneRegisterLicenseKeyPack(
                                        USEHANDLE(pDbWkSpace),
                                        g_pszServerPid,
                                        pbData,
                                        cbData,
                                        &keypack
                                    );


    if(TLS_ERROR(status)) 
    {
        ROLLBACK_TRANSACTION(pDbWkSpace);
    }
    else
    {
        COMMIT_TRANSACTION(pDbWkSpace);
    }

    FREEDBHANDLE(pDbWkSpace);

    //
    // Post a sync work object
    //
    if(status == ERROR_SUCCESS)
    {
        if(TLSAnnounceLKPToAllRemoteServer(
                                        keypack.dwKeyPackId,
                                        0
                                    ) != ERROR_SUCCESS)
        {
            TLSLogWarningEvent(TLS_W_ANNOUNCELKP_FAILED);
        }
    }

cleanup:


    lpContext->m_LastError=status;
    InterlockedDecrement( &lpContext->m_RefCount );

    #if DBG
    lpContext->m_LastCall = RPC_CALL_TELEPHONEREGISTERLKP;
    #endif


    *pdwErrCode = TLSMapReturnCode(status);

    return RPC_S_OK;
}

////////////////////////////////////////////////////////////////////////////

error_status_t 
TLSRpcAllocateInternetLicense( 
    /* [in] */ PCONTEXT_HANDLE phContext,
    /* [in] */ const CHALLENGE_CONTEXT ChallengeContext,
    /* [in] */ const PTLSLICENSEREQUEST pRequest,
    /* [string][in] */ LPTSTR pMachineName,
    /* [string][in] */ LPTSTR pUserName,
    /* [in] */ const DWORD cbChallengeResponse,
    /* [size_is][in] */ const PBYTE pbChallengeResponse,
    /* [out] */ PDWORD pcbLicense,
    /* [size_is][size_is][out] */ BYTE __RPC_FAR *__RPC_FAR *pbLicense,
    /* [ref][out][in] */ PDWORD pdwErrCode
    )
/*++



--*/
{
    return TLSRpcRequestNewLicense(
                                phContext,
                                ChallengeContext,
                                pRequest,
                                pMachineName,
                                pUserName,
                                cbChallengeResponse,
                                pbChallengeResponse,
                                FALSE,
                                pcbLicense,
                                pbLicense,
                                pdwErrCode
                            );

}

////////////////////////////////////////////////////////////////////////////

error_status_t 
TLSRpcAllocateInternetLicenseEx( 
    /* [in] */ PCONTEXT_HANDLE phContext,
    /* [in] */ const CHALLENGE_CONTEXT ChallengeContext,
    /* [in] */ const PTLSLICENSEREQUEST pRequest,
    /* [string][in] */ LPTSTR pMachineName,
    /* [string][in] */ LPTSTR pUserName,
    /* [in] */ const DWORD cbChallengeResponse,
    /* [size_is][in] */ const PBYTE pbChallengeResponse,
    /* [ref][out] */ PTLSInternetLicense pInternetLicense,
    /* [ref][out] */ PDWORD pdwErrCode
    )
/*++

--*/
{
    PBYTE pbLicense = NULL;
    DWORD cbLicense = 0;
    DWORD dwStatus = ERROR_SUCCESS;
    DWORD index = 0;
    PLICENSEDPRODUCT pLicensedProduct = NULL;
    DWORD dwNumLicensedProduct = 0;
    LPCLIENTCONTEXT lpContext = (LPCLIENTCONTEXT)phContext;

    if(lpContext == NULL)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        goto cleanup;
    }

    DBGPrintf(
            DBG_INFORMATION,
            DBG_FACILITY_RPC,
            DBGLEVEL_FUNCTION_TRACE,
            _TEXT("%s : TLSRpcAllocateInternetLicenseEx\n"),
            lpContext->m_Client
        );

    //
    // Internally forward the request.
    //
    dwStatus = TLSRpcAllocateInternetLicense(
                                        phContext,
                                        ChallengeContext,
                                        pRequest,
                                        pMachineName,
                                        pUserName,
                                        cbChallengeResponse,
                                        pbChallengeResponse,
                                        &cbLicense,
                                        &pbLicense,
                                        pdwErrCode
                                    );

    if(*pdwErrCode >= LSERVER_ERROR_BASE)
    {
        goto cleanup;
    }

    //
    // decode the license.
    //
    dwStatus = LSVerifyDecodeClientLicense(
                            pbLicense, 
                            cbLicense, 
                            g_pbSecretKey, 
                            g_cbSecretKey,
                            &dwNumLicensedProduct,
                            pLicensedProduct
                        );

    //
    // Internet license can only have one licensed product
    //
    if(dwStatus != LICENSE_STATUS_OK || dwNumLicensedProduct == 0 || dwNumLicensedProduct > 1)
    {
        dwStatus = TLS_E_INTERNAL;
        goto cleanup;
    }

    pLicensedProduct = (PLICENSEDPRODUCT)AllocateMemory(
                                                    dwNumLicensedProduct * sizeof(LICENSEDPRODUCT)
                                                );
    if(pLicensedProduct == NULL)
    {
        dwStatus = TLS_E_ALLOCATE_MEMORY;
        goto cleanup;
    }

    dwStatus = LSVerifyDecodeClientLicense(
                            pbLicense, 
                            cbLicense, 
                            g_pbSecretKey, 
                            g_cbSecretKey,
                            &dwNumLicensedProduct,
                            pLicensedProduct
                        );

    if(dwStatus != LICENSE_STATUS_OK)
    {
        dwStatus = TLS_E_INTERNAL;
        goto cleanup;
    }

    //
    // Sets up returns. 
    //
    SAFESTRCPY(pInternetLicense->szServerId, pLicensedProduct->szIssuerId);
    SAFESTRCPY(pInternetLicense->szServerName, pLicensedProduct->szIssuer);
    pInternetLicense->ulSerialNumber = pLicensedProduct->ulSerialNumber;
    pInternetLicense->dwQuantity = pLicensedProduct->dwQuantity;

cleanup:

    if(NULL != lpContext)
    {
        lpContext->m_LastError=dwStatus;
        InterlockedDecrement( &lpContext->m_RefCount );
    

        #if DBG
        lpContext->m_LastCall = RPC_CALL_ALLOCATEINTERNETLICNESEEX;
        #endif
    }
    if(*pdwErrCode == ERROR_SUCCESS)
    {
        *pdwErrCode = TLSMapReturnCode(dwStatus);
    }

    if(pLicensedProduct != NULL)
    {
        for(index =0; index < dwNumLicensedProduct; index++)
        {
            LSFreeLicensedProduct(pLicensedProduct+index);
        }

        FreeMemory(pLicensedProduct);
    }

    if(pbLicense != NULL)
    {
        midl_user_free(pbLicense);
    }

    return RPC_S_OK;
}

////////////////////////////////////////////////////////////////////////////

error_status_t 
TLSRpcReturnInternetLicenseEx( 
    /* [in] */ PCONTEXT_HANDLE phContext,
    /* [in] */ const PTLSLICENSEREQUEST pRequest,
    /* [in] */ const ULARGE_INTEGER __RPC_FAR *pulSerialNumber,
    /* [in] */ DWORD dwQuantity,
    /* [ref][out][in] */ PDWORD pdwErrCode
    )
/*++

--*/
{
    DWORD dwStatus = ERROR_SUCCESS;
    TLSLicenseToBeReturn TobeReturn;
    LPCLIENTCONTEXT lpContext = (LPCLIENTCONTEXT)phContext;
    PTLSDbWorkSpace pDbWorkSpace = NULL;
    CTLSPolicy* pPolicy = NULL;
    PMHANDLE hClient;    

    PMLICENSEREQUEST PMLicenseRequest;
    PPMLICENSEREQUEST pAdjustedRequest;

    TCHAR szCompanyName[LSERVER_MAX_STRING_SIZE+2];
    TCHAR szProductId[LSERVER_MAX_STRING_SIZE+2];

    if(VerifyLicenseRequest(pRequest) == FALSE)
    {
        SetLastError(dwStatus = TLS_E_INVALID_DATA);
        goto cleanup;
    }

    if(lpContext == NULL || pdwErrCode == NULL)
    {
        SetLastError(dwStatus = ERROR_INVALID_PARAMETER);
        goto cleanup;
    }

    DBGPrintf(
            DBG_INFORMATION,
            DBG_FACILITY_RPC,
            DBGLEVEL_FUNCTION_TRACE,
            _TEXT("%s : TLSRpcReturnInternetLicenseEx\n"),
            lpContext->m_Client
        );

    InterlockedIncrement( &lpContext->m_RefCount );

    dwStatus = SecureModeCheck();

    if(dwStatus != ERROR_SUCCESS )
    {                    
        goto cleanup;        
    }

    if(!(lpContext->m_ClientFlags & CLIENT_ACCESS_REQUEST))
    {
        dwStatus = TLS_E_ACCESS_DENIED;
        goto cleanup;
    }

    memset(szCompanyName, 0, sizeof(szCompanyName));
    memset(szProductId, 0, sizeof(szProductId));

    memcpy(
            szCompanyName,
            pRequest->ProductInfo.pbCompanyName,
            min(pRequest->ProductInfo.cbCompanyName, sizeof(szCompanyName)-sizeof(TCHAR))
        );

    memcpy(
            szProductId,
            pRequest->ProductInfo.pbProductID,
            min(pRequest->ProductInfo.cbProductID, sizeof(szProductId)-sizeof(TCHAR))
        );

    //
    // Allocate policy module, must have the right policy module to
    // return license.
    //
    pPolicy = AcquirePolicyModule(
                            szCompanyName,
                            szProductId,
                            TRUE
                        );

    if(pPolicy == NULL)
    {
        dwStatus = GetLastError();
        goto cleanup;
    }

    hClient = GenerateClientId();


    //
    // Convert request to PMLICENSEREQUEST
    //
    TlsLicenseRequestToPMLicenseRequest(
                        LICENSETYPE_LICENSE,
                        pRequest,
                        _TEXT(""),
                        _TEXT(""),
                        0,
                        &PMLicenseRequest
                    );

    //
    // Ask policy module the actual product ID
    //
    dwStatus = pPolicy->PMLicenseRequest(
                                hClient,
                                REQUEST_NEW,
                                (PVOID) &PMLicenseRequest,
                                (PVOID *) &pAdjustedRequest
                            );

    memset(&TobeReturn, 0, sizeof(TobeReturn));

    TobeReturn.dwQuantity = dwQuantity;
    TobeReturn.dwKeyPackId = pulSerialNumber->HighPart;
    TobeReturn.dwLicenseId = pulSerialNumber->LowPart;
    TobeReturn.dwPlatformID = pAdjustedRequest->dwPlatformId;
    TobeReturn.cbEncryptedHwid = pRequest->cbEncryptedHwid;
    TobeReturn.pbEncryptedHwid = pRequest->pbEncryptedHwid;
    TobeReturn.dwProductVersion = pAdjustedRequest->dwProductVersion;
    TobeReturn.pszOrgProductId = szProductId;
    TobeReturn.pszCompanyName = szCompanyName;
    TobeReturn.pszProductId = pAdjustedRequest->pszProductId;

    //
    // Allocate DB handle
    //
    if(!ALLOCATEDBHANDLE(pDbWkSpace, g_GeneralDbTimeout))
    {
        dwStatus = TLS_E_ALLOCATE_HANDLE;
        goto cleanup;
    }

    CLEANUPSTMT;
    BEGIN_TRANSACTION(pDbWorkSpace);

    dwStatus = TLSReturnClientLicensedProduct(
                                    USEHANDLE(pDbWkSpace),
                                    hClient,
                                    pPolicy,
                                    &TobeReturn
                                );    
    
    if(TLS_ERROR(dwStatus))
    {
        ROLLBACK_TRANSACTION(pDbWorkSpace);
    }
    else
    {
        COMMIT_TRANSACTION(pDbWorkSpace);
    }

    if(dwStatus == ERROR_SUCCESS)
    {
        TLSAnnounceLKPToAllRemoteServer(TobeReturn.dwKeyPackId,0);
    }

    FREEDBHANDLE(pDbWorkSpace);
    
cleanup:

    if(NULL != lpContext)
    {
        lpContext->m_LastError=dwStatus;
        InterlockedDecrement( &lpContext->m_RefCount );

        #if DBG
        lpContext->m_LastCall = RPC_CALL_RETURNINTERNETLICENSEEX;
        #endif
    }
        *pdwErrCode = TLSMapReturnCode(dwStatus);

    if(pPolicy)
    {
        pPolicy->PMLicenseRequest(
                            hClient,
                            REQUEST_COMPLETE,
                            UlongToPtr (dwStatus),
                            NULL
                        );
        
        ReleasePolicyModule(pPolicy);
    }

    return RPC_S_OK;
}

////////////////////////////////////////////////////////////////////////////

error_status_t 
TLSRpcReturnInternetLicense( 
    /* [in] */ PCONTEXT_HANDLE phContext,
    /* [in] */ DWORD cbLicense,
    /* [size_is][in] */ PBYTE pbLicense,
    /* [ref][out][in] */ PDWORD pdwErrCode
    )
/*++

--*/
{
    DWORD dwStatus = ERROR_SUCCESS;
    DWORD index = 0;
    PLICENSEDPRODUCT pLicensedProduct = NULL;
    DWORD dwNumLicensedProduct = 0;
    TLSLicenseToBeReturn TobeReturn;
    LPCLIENTCONTEXT lpContext = (LPCLIENTCONTEXT)phContext;
    PTLSDbWorkSpace pDbWorkSpace = NULL;
    CTLSPolicy* pPolicy = NULL;
    PMHANDLE hClient;

    if(lpContext == NULL || pdwErrCode == NULL)
    {
        SetLastError(dwStatus = ERROR_INVALID_PARAMETER);
        goto cleanup;
    }

    DBGPrintf(
            DBG_INFORMATION,
            DBG_FACILITY_RPC,
            DBGLEVEL_FUNCTION_TRACE,
            _TEXT("%s : TLSRpcReturnInternetLicense\n"),
            lpContext->m_Client
        );

    InterlockedIncrement( &lpContext->m_RefCount );

    dwStatus = SecureModeCheck();

    if(dwStatus != ERROR_SUCCESS )
    {                    
        goto cleanup;        
    }

    if(!(lpContext->m_ClientFlags & CLIENT_ACCESS_REQUEST))
    {
        dwStatus = TLS_E_ACCESS_DENIED;
        goto cleanup;
    }
    
    // -------------------------------------------------------
    // decode the license.
    // -------------------------------------------------------
    dwStatus = LSVerifyDecodeClientLicense(
                            pbLicense, 
                            cbLicense, 
                            g_pbSecretKey, 
                            g_cbSecretKey,
                            &dwNumLicensedProduct,
                            pLicensedProduct
                        );

    // -------------------------------------------------------
    // Internet license can only have one licensed product
    // -------------------------------------------------------
    if(dwStatus != LICENSE_STATUS_OK || dwNumLicensedProduct == 0 || dwNumLicensedProduct > 1)
    {
        dwStatus = TLS_E_INVALID_LICENSE;
        goto cleanup;
    }

    pLicensedProduct = (PLICENSEDPRODUCT)AllocateMemory(
                                                    dwNumLicensedProduct * sizeof(LICENSEDPRODUCT)
                                                );
    if(pLicensedProduct == NULL)
    {
        dwStatus = TLS_E_ALLOCATE_MEMORY;
        goto cleanup;
    }

    dwStatus = LSVerifyDecodeClientLicense(
                            pbLicense, 
                            cbLicense, 
                            g_pbSecretKey, 
                            g_cbSecretKey,
                            &dwNumLicensedProduct,
                            pLicensedProduct
                        );

    if(dwStatus != LICENSE_STATUS_OK)
    {
        dwStatus = TLS_E_INVALID_LICENSE;
        goto cleanup;
    }


    TobeReturn.dwQuantity = pLicensedProduct->dwQuantity;
    TobeReturn.dwKeyPackId = pLicensedProduct->ulSerialNumber.HighPart;
    TobeReturn.dwLicenseId = pLicensedProduct->ulSerialNumber.LowPart;
    TobeReturn.dwPlatformID = pLicensedProduct->LicensedProduct.dwPlatformID;
    TobeReturn.cbEncryptedHwid = pLicensedProduct->LicensedProduct.cbEncryptedHwid;
    TobeReturn.pbEncryptedHwid = pLicensedProduct->LicensedProduct.pbEncryptedHwid;
    TobeReturn.dwProductVersion = MAKELONG(
                                pLicensedProduct->pLicensedVersion->wMinorVersion,
                                pLicensedProduct->pLicensedVersion->wMajorVersion
                            );

    TobeReturn.pszOrgProductId = (LPTSTR) pLicensedProduct->pbOrgProductID;
    TobeReturn.pszCompanyName = (LPTSTR) pLicensedProduct->LicensedProduct.pProductInfo->pbCompanyName;
    TobeReturn.pszProductId = (LPTSTR) pLicensedProduct->LicensedProduct.pProductInfo->pbProductID;
    TobeReturn.pszUserName = (LPTSTR) pLicensedProduct->szLicensedUser;
    TobeReturn.pszMachineName = pLicensedProduct->szLicensedClient;


    //
    // Allocate policy module, must have the right policy module to
    // return license.
    //
    pPolicy = AcquirePolicyModule(
                            TobeReturn.pszCompanyName,
                            TobeReturn.pszOrgProductId,
                            TRUE
                        );

    if(pPolicy == NULL)
    {
        dwStatus = GetLastError();
        goto cleanup;
    }

    hClient = GenerateClientId();

    //
    // Allocate DB handle
    //
    if(!ALLOCATEDBHANDLE(pDbWkSpace, g_GeneralDbTimeout))
    {
        dwStatus = TLS_E_ALLOCATE_HANDLE;
        goto cleanup;
    }

    CLEANUPSTMT;
    BEGIN_TRANSACTION(pDbWorkSpace);

    dwStatus = TLSReturnClientLicensedProduct(
                                    USEHANDLE(pDbWkSpace),
                                    hClient,
                                    pPolicy,
                                    &TobeReturn
                                );    
    
    if(TLS_ERROR(dwStatus))
    {
        ROLLBACK_TRANSACTION(pDbWorkSpace);
    }
    else
    {
        COMMIT_TRANSACTION(pDbWorkSpace);
    }
    if(dwStatus == ERROR_SUCCESS)
    {
        TLSAnnounceLKPToAllRemoteServer(TobeReturn.dwKeyPackId,0);
    }

    FREEDBHANDLE(pDbWorkSpace);
    
cleanup:

    if(NULL != lpContext)
    {
        lpContext->m_LastError=dwStatus;
        InterlockedDecrement( &lpContext->m_RefCount );

        #if DBG
        lpContext->m_LastCall = RPC_CALL_RETURNINTERNETLICENSE;
        #endif
    }

    *pdwErrCode = TLSMapReturnCode(dwStatus);

    if(pLicensedProduct != NULL)
    {
        for(index =0; index < dwNumLicensedProduct; index++)
        {
            LSFreeLicensedProduct(pLicensedProduct+index);
        }

        FreeMemory(pLicensedProduct);
    }

    if(pPolicy)
    {
        pPolicy->PMLicenseRequest(
                            hClient,
                            REQUEST_COMPLETE,
                            UlongToPtr (dwStatus),
                            NULL
                        );
        
        ReleasePolicyModule(pPolicy);
    }

    return RPC_S_OK;
}

void
FixupNameAttr(
              DWORD dwNameAttrCount,
              CERT_RDN_ATTR rgNameAttr[])
{

    for (DWORD i = 0; i < dwNameAttrCount; i++)
    {
        if (rgNameAttr[i].Value.cbData == 0)
            rgNameAttr[i].Value.pbData = NULL;
    }

}

//----------------------------------------------------------------------------

error_status_t 
TLSRpcGenerateCustomerCert( 
    /* [in] */ PCONTEXT_HANDLE phContext,
    /* [in] */ DWORD dwCertEncodingType,
    /* [in] */ DWORD dwNameAttrCount,
    /* [in, size_is(dwNameAttrCount)] */ CERT_RDN_ATTR rgNameAttr[],
    /* [out] */ DWORD *pcbCert,
    /* [out, size_is(,*pcbCert)] */ BYTE **ppbCert,
    /* [out] */ DWORD *pdwErrCode
    )
/*++

Description:

    This routine is for LRWiz to generate a certificate for a given customer

Arguments:

    phContext - client context handle.
    dwCertEncodingType - See CryptSignCertificate docs
    dwNameAttrCount - Number of Name Attributes
    rgNameAttr - Array of Name Attributes
    pcbCert - Number of bytes in returned cert
    ppbCert - Returned cert
    pdwErrCode - Returned error value

Returns via pdwErrCode

++*/
{
    DWORD                       status=ERROR_SUCCESS;
    LPCLIENTCONTEXT             lpContext = (LPCLIENTCONTEXT)phContext;
    CERT_RDN                    rgRDN[] = {dwNameAttrCount, rgNameAttr};
    CERT_NAME_INFO              Name = {1, rgRDN};
    CRYPT_ENCODE_PARA           encodeParam;
    CERT_REQUEST_INFO           CertReqInfo;
    PCERT_PUBLIC_KEY_INFO       pPubKeyInfo=NULL;
    DWORD                       cbPubKeyInfo=0;
    CERT_SIGNED_CONTENT_INFO	SignatureInfo;
    LPBYTE                      pbRequest=NULL;
    DWORD                       cbRequest=0;   
    
    if(lpContext == NULL || pdwErrCode == NULL)
    {
        status = TLS_E_INVALID_DATA;
        goto cleanup;
    }

    // BUGBUG: Must check that caller is admin, through proper impersonation

    if(!(lpContext->m_ClientFlags & CLIENT_ACCESS_ADMIN))
    {
        status = TLS_E_ACCESS_DENIED;
        goto cleanup;
    }

    InterlockedIncrement( &lpContext->m_RefCount );

    DBGPrintf(
            DBG_INFORMATION,
            DBG_FACILITY_RPC,
            DBGLEVEL_FUNCTION_TRACE,
            _TEXT("%s : TLSRpcGenerateCustomerCert\n"),
            lpContext->m_Client
        );

    *pcbCert = 0;
    *ppbCert = NULL;

    FixupNameAttr(dwNameAttrCount,rgNameAttr);

    memset(&CertReqInfo, 0, sizeof(CertReqInfo));
    CertReqInfo.dwVersion = CERT_REQUEST_V1;

    encodeParam.cbSize = sizeof(encodeParam);
    encodeParam.pfnAlloc = MIDL_user_allocate;
    encodeParam.pfnFree = MIDL_user_free;

    if(!CryptEncodeObjectEx( CRYPT_ASN_ENCODING,
                             X509_NAME,
                             &Name,
                             CRYPT_ENCODE_ALLOC_FLAG,
                             &encodeParam,
                             &CertReqInfo.Subject.pbData,
                             &CertReqInfo.Subject.cbData))
    {
        status = TLS_E_INVALID_DATA;
        
        goto cleanup;
    }

    //
    // now get the public key out
    //
    if(!CryptExportPublicKeyInfo(g_hCryptProv,
                                 dwCertEncodingType,
                                 X509_ASN_ENCODING,
                                 NULL,
                                 &cbPubKeyInfo))
    {
        status = TLS_E_NO_CERTIFICATE;
        
        goto cleanup;
    }

    pPubKeyInfo=(PCERT_PUBLIC_KEY_INFO) MIDL_user_allocate(cbPubKeyInfo);

    if ( NULL == pPubKeyInfo )
    {
        status = ERROR_OUTOFMEMORY;

        goto cleanup;
    }

    if(!CryptExportPublicKeyInfo(g_hCryptProv,
                                 dwCertEncodingType,
                                 X509_ASN_ENCODING,
                                 pPubKeyInfo,
                                 &cbPubKeyInfo))
    {
        status = TLS_E_NO_CERTIFICATE;
        
        goto cleanup;
    }    

    CertReqInfo.SubjectPublicKeyInfo = *pPubKeyInfo;

    //
    // Sign cert request
    //

    memset(&SignatureInfo, 0, sizeof(SignatureInfo));

    SignatureInfo.SignatureAlgorithm.pszObjId = szOID_OIWSEC_sha1RSASign;

    memset(&SignatureInfo.SignatureAlgorithm.Parameters, 0, sizeof(SignatureInfo.SignatureAlgorithm.Parameters));

    if(!CryptEncodeObjectEx(CRYPT_ASN_ENCODING,
                            X509_CERT_REQUEST_TO_BE_SIGNED,
                            &CertReqInfo,
                            CRYPT_ENCODE_ALLOC_FLAG,
                            &encodeParam,
                            &SignatureInfo.ToBeSigned.pbData,
                            &SignatureInfo.ToBeSigned.cbData))
    {
        status = TLS_E_INVALID_DATA;
        
        goto cleanup;
    }

    if(!CryptSignCertificate( g_hCryptProv,
                              dwCertEncodingType,
                              CRYPT_ASN_ENCODING,
                              SignatureInfo.ToBeSigned.pbData,
                              SignatureInfo.ToBeSigned.cbData,
                              &SignatureInfo.SignatureAlgorithm,
                              NULL,
                              NULL,
                              &SignatureInfo.Signature.cbData))
    {
        status = TLS_E_INVALID_DATA;
        
        goto cleanup;
    }

    SignatureInfo.Signature.pbData = (BYTE *) MIDL_user_allocate(SignatureInfo.Signature.cbData);

    if ( NULL == SignatureInfo.Signature.pbData )
    {
        status = ERROR_OUTOFMEMORY;

        goto cleanup;
    }

    if(!CryptSignCertificate( g_hCryptProv,
                              dwCertEncodingType,
                              CRYPT_ASN_ENCODING,
                              SignatureInfo.ToBeSigned.pbData,
                              SignatureInfo.ToBeSigned.cbData,
                              &SignatureInfo.SignatureAlgorithm,
                              NULL,
                              SignatureInfo.Signature.pbData,
                              &SignatureInfo.Signature.cbData))
    {
        status = TLS_E_INVALID_DATA;
        
        goto cleanup;
    }

    //
    // encode final signed request
    //

    if(!CryptEncodeObjectEx(CRYPT_ASN_ENCODING,
                            X509_CERT,
                            &SignatureInfo,
                            CRYPT_ENCODE_ALLOC_FLAG,
                            &encodeParam,
                            &pbRequest,
                            &cbRequest))
    {
        status = TLS_E_INVALID_DATA;
        
        goto cleanup;
    }

    *pcbCert = cbRequest;
    *ppbCert = pbRequest;

cleanup:
	if(CertReqInfo.Subject.pbData != NULL)
    {
        MIDL_user_free(CertReqInfo.Subject.pbData);
    }

	if(pPubKeyInfo != NULL)
    {
        MIDL_user_free(pPubKeyInfo);
    }

	if(SignatureInfo.ToBeSigned.pbData != NULL)
    {
        MIDL_user_free(SignatureInfo.ToBeSigned.pbData);
    }

	if(SignatureInfo.Signature.pbData != NULL)
    {
        MIDL_user_free(SignatureInfo.Signature.pbData);
    }

    lpContext->m_LastError=status;
    InterlockedDecrement( &lpContext->m_RefCount );

    *pdwErrCode = TLSMapReturnCode(status);
    return RPC_S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\license\tlserver\server\wkspace.cpp ===
//+--------------------------------------------------------------------------
//
// Copyright (c) 1997-1999 Microsoft Corporation
//
// File:       wkspace.cpp 
//
// Contents:   DB workspace 
//
// History:     
//
//---------------------------------------------------------------------------
#include "pch.cpp"
#include "TLSdef.h"
#include "server.h"
#include "wkspace.h"
#include "utils.h"
#include "globals.h"

/////////////////////////////////////////////////////////////
//
// Try to save some memory
//
//
JBInstance __TlsDbWorkSpace::g_JbInstance;
static TLSDbWorkSpacePool g_WorkSpacePool;

typedef map<PVOID, PVOID> ACQUIREDHANDLELIST;

CCriticalSection AcquiredHandleListLock;
ACQUIREDHANDLELIST AcquiredHandleList;

LONG g_lWorkSpacePoolDeleted = 0;

#if DBG
DWORD g_dwNumWorkSpaceAllocated = 0;
#endif

//-----------------------------------------------
// 
// Table for work item storage, 
//
//
JBSession g_WkItemSession(__TlsDbWorkSpace::g_JbInstance);
JBDatabase g_WkItemDatabase(g_WkItemSession);
WorkItemTable g_WkItemTable(g_WkItemDatabase);

//--------------------------------------------------------

BOOL
TLSGetESEError(
    const JET_ERR jetErrCode,
    LPTSTR* pszString
    )
/*++


--*/
{
    JBError jbError;

    return jbError.GetJBErrString( 
                            jetErrCode, 
                            pszString 
                        );
}

//--------------------------------------------------------

WorkItemTable*
GetWorkItemStorageTable()
{
    BOOL bSuccess = TRUE;

    //
    // verify session and database is correct.
    //
    if(g_WkItemSession.IsValid() == FALSE)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return NULL;
    }

    if(g_WkItemDatabase.IsValid() == FALSE)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return NULL;
    }

    if(g_WkItemTable.IsValid() == FALSE)
    {
        bSuccess = g_WkItemTable.OpenTable(
                                    TRUE,
                                    JET_bitTableUpdatable
                                );

        if(bSuccess == FALSE)
        {
            LPTSTR pString = NULL;

            SetLastError(SET_JB_ERROR(g_WkItemTable.GetLastJetError()));
            TLSGetESEError(g_WkItemTable.GetLastJetError(), &pString);

            TLSLogEvent(
                    EVENTLOG_ERROR_TYPE,
                    TLS_E_SERVICEINIT,
                    TLS_E_JB_OPENTABLE,
                    g_WkItemTable.GetTableName(),
                    g_WkItemTable.GetLastJetError(),
                    (pString != NULL) ? pString : _TEXT("")
                );

            if(pString != NULL)
            {
                LocalFree(pString);
            }
        }
    }

    return (bSuccess == TRUE) ? &g_WkItemTable : NULL;
}

//--------------------------------------------------------
DWORD
CloseWorkSpacePool()
{
    DWORD dwNumWkSpace = g_WorkSpacePool.GetNumberAvailable();
    TLSDbWorkSpace* jbWkSpace=NULL;
    DWORD dwErrCode=ERROR_SUCCESS;

    //
    // Mark workspace pool deleted, this is for backup/restore 
    // that it will close entire workspace pool but RPC context
    // rundown might happen after we close the workspace pool
    //
    InterlockedExchange(
                    &g_lWorkSpacePoolDeleted,
                    1
                );

    #if DBG
    DBGPrintf(
            DBG_INFORMATION,
            DBG_FACILITY_HANDLEPOOL,
            DBGLEVEL_FUNCTION_TRACE,
            _TEXT("CloseWorkSpace() - Total %d, Num Available %d\n"),
            g_dwNumWorkSpaceAllocated,
            dwNumWkSpace
        );
    #endif

    while(dwNumWkSpace)
    {
        jbWkSpace = NULL;
        dwErrCode=g_WorkSpacePool.AcquireHandle(
                            &jbWkSpace,
                            INFINITE
                        );

        if(jbWkSpace)
            delete jbWkSpace;

        dwNumWkSpace--;

        #if DBG
        g_dwNumWorkSpaceAllocated--;
        #endif
    }

    AcquiredHandleListLock.Lock();

    if(AcquiredHandleList.empty() != TRUE)
    {
        ACQUIREDHANDLELIST::iterator it;

        for(it = AcquiredHandleList.begin(); it != AcquiredHandleList.end(); it++)
        {
            if((*it).second != NULL)
            {
                jbWkSpace = (TLSDbWorkSpace*) (*it).second;
                delete jbWkSpace;

                #if DBG
                g_dwNumWorkSpaceAllocated--;

                DBGPrintf(
                        DBG_INFORMATION,
                        DBG_FACILITY_HANDLEPOOL,
                        DBGLEVEL_FUNCTION_TRACE,
                        _TEXT("Close Allocated WorkSpace()...\n")
                    );
                #endif
            }
            else
            {
                TLSASSERT(FALSE);
            }
        }

        AcquiredHandleList.erase(AcquiredHandleList.begin(), AcquiredHandleList.end());
    }
        
    AcquiredHandleListLock.UnLock();
    g_WkItemTable.CloseTable();
    g_WkItemDatabase.CloseDatabase();
    g_WkItemSession.EndSession();

    #if DBG
    if( 0 != g_dwNumWorkSpaceAllocated )
    {
        TLSASSERT(FALSE);
    }
    #endif

    //
    // Delete log file so that to prevent long database recovery
    //
    __TlsDbWorkSpace::g_JbInstance.JBTerminate(
                            JET_bitTermComplete, 
                            TRUE
                        );
    return ERROR_SUCCESS;
}

//--------------------------------------------------------
BOOL
IsValidAllocatedWorkspace(
    PTLSDbWorkSpace p
    )
/*++

Abstract:

    Verify an allocated workspace handle is in our
    allocated list.

--*/
{
    BOOL bSuccess = TRUE;

    ACQUIREDHANDLELIST::iterator it;


    AcquiredHandleListLock.Lock();

    it = AcquiredHandleList.find(p);
    bSuccess = (it != AcquiredHandleList.end());
    AcquiredHandleListLock.UnLock();

    return bSuccess;
}


//--------------------------------------------------------
void
ReleaseWorkSpace(
    PTLSDbWorkSpace *p
    )
/*
*/
{
    if( g_lWorkSpacePoolDeleted == 1 )
    {
        //
        // DB workspace pool has been deleted, acquired workspace
        // handle will be deleted via AcquireHandleList
        // 

        // overactive assert here... there is a race condition possible,
        // this assert is to verify that this if statement handles it.
        TLSASSERT(FALSE);
        return;
    }

    TLSASSERT(p != NULL && *p != NULL);

    if(p != NULL)
    {
        ACQUIREDHANDLELIST::iterator it;

        AcquiredHandleListLock.Lock();

        it = AcquiredHandleList.find(*p);
        if(it != AcquiredHandleList.end())
        {
            AcquiredHandleList.erase(it);
        }
        else
        {
            TLSASSERT(FALSE);
        }

        AcquiredHandleListLock.UnLock();
    }

    if(p)
    {
        DBGPrintf(
                DBG_INFORMATION,
                DBG_FACILITY_HANDLEPOOL,
                DBGLEVEL_FUNCTION_TRACE,
                _TEXT("Releasing workspace 0x%08x...\n"),
                *p
            );   
    
        if(*p)
        {
            (*p)->Cleanup();
            g_WorkSpacePool.ReleaseHandle(*p);
            *p = NULL;
        }
    }
}

//--------------------------------------------------------
TLSDbWorkSpace*
AllocateWorkSpace(
    DWORD dwWaitTime /* INFINITE */
    )
/*
*/
{
    TLSDbWorkSpace* jbWkSpace=NULL;
    BOOL bSuccess;

    DBGPrintf(
            DBG_INFORMATION,
            DBG_FACILITY_HANDLEPOOL,
            DBGLEVEL_FUNCTION_TRACE,
            _TEXT("Allocating a workspace...\n")
        );   
    
    bSuccess = g_WorkSpacePool.AcquireHandleEx(
                                    GetServiceShutdownHandle(),
                                    &jbWkSpace,
                                    dwWaitTime
                                );

    if(bSuccess == TRUE)
    {
        DBGPrintf(
                DBG_INFORMATION,
                DBG_FACILITY_HANDLEPOOL,
                DBGLEVEL_FUNCTION_TRACE,
                _TEXT("Allocated 0x%08x...\n"),
                jbWkSpace
            );

        AcquiredHandleListLock.Lock();
        AcquiredHandleList[jbWkSpace] = jbWkSpace;
        AcquiredHandleListLock.UnLock();
    }
    else
    {
        DBGPrintf(
                DBG_INFORMATION,
                DBG_FACILITY_HANDLEPOOL,
                DBGLEVEL_FUNCTION_TRACE,
                _TEXT("Can't allocate workspace - %d are in use...\n"),
                AcquiredHandleList.size()
            );
    }

    return jbWkSpace;
}


//--------------------------------------------------------
DWORD
GetNumberOfWorkSpaceHandle()
{
    return g_WorkSpacePool.GetNumberAvailable();
}

//--------------------------------------------------------
BOOL
TLSJbInitDatabaseEngine(
    IN JBSession& jbSession,
    IN JBDatabase& jbDatabase,
    IN LPCTSTR szDatabaseFile,
    IN LPCTSTR szUserName,
    IN LPCTSTR szPassword
    )
/*++

--*/
{
    BOOL bSuccess = TRUE;
    DWORD dwErrCode;

    if(jbSession.IsValid() == FALSE)
    {
        bSuccess = jbSession.BeginSession(
                                        szUserName, 
                                        szPassword
                                    );
        if(bSuccess == FALSE)
        {
            LPTSTR pString = NULL;

            TLSGetESEError(jbSession.GetLastJetError(), &pString);
            TLSLogEvent(
                    EVENTLOG_ERROR_TYPE,
                    TLS_E_DBGENERAL,
                    TLS_E_JB_BEGINSESSION,
                    jbSession.GetLastJetError(),
                    (pString != NULL) ? pString : _TEXT("")
                );

            if(pString != NULL)
            {
                LocalFree(pString);
            }

            DBGPrintf(
                    DBG_ERROR,
                    DBG_FACILITY_JETBLUE,
                    DBGLEVEL_FUNCTION_ERROR,
                    _TEXT("Error : Initialize JetBlue session  - error code %d\n"),
                    jbSession.GetLastJetError()
                );

            dwErrCode = SET_JB_ERROR(jbSession.GetLastJetError());
            SetLastError(dwErrCode);
            TLSASSERT(FALSE);

            goto cleanup;
        }
    }

    //
    // Open Database
    if(jbDatabase.IsValid() == FALSE)
    {
        bSuccess = jbDatabase.OpenDatabase(szDatabaseFile);
        if(bSuccess == FALSE)
        {
            JET_ERR errCode = jbDatabase.GetLastJetError();

            if(errCode != JET_errFileNotFound)
            {
                if(errCode == JET_errDatabaseCorrupted)
                {
                    TLSLogErrorEvent(TLS_E_CORRUPT_DATABASE);
                }
                else
                {
                    LPTSTR pString = NULL;

                    TLSGetESEError(errCode, &pString);

                    //
                    // other type of error
                    //
                    TLSLogEvent(
                            EVENTLOG_ERROR_TYPE,
                            TLS_E_DBGENERAL,
                            TLS_E_JB_OPENDATABASE,
                            szDatabaseFile,
                            errCode,
                            (pString != NULL) ? pString : _TEXT("")
                        );

                    if(pString != NULL)
                    {
                        LocalFree(pString);
                    }
                }

                DBGPrintf(
                        DBG_ERROR,
                        DBG_FACILITY_JETBLUE,
                        DBGLEVEL_FUNCTION_ERROR,
                        _TEXT("Error : Can't create database because OpenDatabase failed with %d\n"),
                        errCode
                    );

                dwErrCode = SET_JB_ERROR(errCode);
                SetLastError(dwErrCode);
                TLSASSERT(FALSE);

                return FALSE;
            }

            // create a new database file
            bSuccess = jbDatabase.CreateDatabase(szDatabaseFile);

            if(bSuccess == FALSE)
            {
                LPTSTR pString = NULL;

                TLSGetESEError(jbDatabase.GetLastJetError(), &pString);

                TLSLogEvent(
                        EVENTLOG_ERROR_TYPE,
                        TLS_E_DBGENERAL,
                        TLS_E_JB_CREATEDATABASE,
                        szDatabaseFile,
                        jbDatabase.GetLastJetError(),
                        (pString != NULL) ? pString : _TEXT("")
                    );

                if(pString != NULL)
                {
                    LocalFree(pString);
                }

                DBGPrintf(
                        DBG_ERROR,
                        DBG_FACILITY_JETBLUE,
                        DBGLEVEL_FUNCTION_ERROR,
                        _TEXT("Error : can't create new database - error code %d\n"),
                        jbDatabase.GetLastJetError()
                    );

                dwErrCode = SET_JB_ERROR(jbDatabase.GetLastJetError());
                SetLastError(dwErrCode);
            }
        }
    }

cleanup:

    return bSuccess;
}

//--------------------------------------------------------
BOOL
InitializeWorkSpacePool(
    IN int num_workspace,
    IN LPCTSTR szDatabaseFile,
    IN LPCTSTR szUserName,
    IN LPCTSTR szPassword,
    IN LPCTSTR szChkPointDirPath,
    IN LPCTSTR szTempDirPath,
    IN LPCTSTR szLogDirPath,
    IN BOOL bUpdatable
    )
/*
*/
{
    DWORD dwErrCode=ERROR_SUCCESS;
    int index=0;
    BOOL bSuccess=TRUE;
    BOOL bWkItemSuccess = TRUE;

    DBGPrintf(
            DBG_ERROR,
            DBG_FACILITY_JETBLUE,
            DBGLEVEL_FUNCTION_ERROR,
            _TEXT("InitializeWorkSpacePool()... %d\n"),
            num_workspace
        );

    if(__TlsDbWorkSpace::g_JbInstance.IsValid() == FALSE)
    {
        bSuccess = TLSJbInstanceInit(
                        __TlsDbWorkSpace::g_JbInstance,
                        szChkPointDirPath,
                        szTempDirPath,
                        szLogDirPath
                    );

        if(bSuccess != TRUE)
        {
            TLSASSERT(FALSE);
            goto cleanup;
        }
    }

    if(g_WkItemTable.IsValid() == FALSE)
    {
        //
        // Initialize session for WorkItemTable, critical 
        // error if this failed
        //
        bWkItemSuccess = TLSJbInitDatabaseEngine(
                                g_WkItemSession,
                                g_WkItemDatabase,
                                szDatabaseFile,
                                szUserName,
                                szPassword
                            );

        if(bWkItemSuccess == FALSE)
        {
            TLSASSERT(FALSE);
            goto cleanup;
        }
    }

    //
    // Allocate number of workspace
    //
    for(index=0; index < num_workspace; index++)
    {
        PTLSDbWorkSpace pJbWkSpace=NULL;

        pJbWkSpace = new TLSDbWorkSpace();
        if(pJbWkSpace == NULL)
        {
            break;
        }

        if(pJbWkSpace->InitWorkSpace(
                            TRUE, 
                            szDatabaseFile, 
                            szUserName, 
                            szPassword,
                            NULL,
                            NULL,
                            bUpdatable) == FALSE)
        {
            delete pJbWkSpace;
            break;
        }
                
        g_WorkSpacePool.ReleaseHandle(pJbWkSpace);

        #if DBG
        g_dwNumWorkSpaceAllocated++;
        #endif
    }

    //
    // WorkSpace pool has been initialized
    //
    InterlockedExchange(
                    &g_lWorkSpacePoolDeleted,
                    0
                );

cleanup:
    if(bWkItemSuccess == FALSE)
    {
        // critical error, can't initialize session for workitem table.
        SetLastError(TLS_E_INIT_WORKSPACE);
        return FALSE;
    }

    //
    // We need at least 3 workspace, one for update/insert
    // and two for enumeration
    //
    if(index < num_workspace)
    {           
        SetLastError(TLS_E_INIT_WORKSPACE);
    }

    return index >= num_workspace;
}


//--------------------------------------------------------
//
// Initialize DB workspace...
//
//--------------------------------------------------------
BOOL
TLSJbInstanceInit(
    IN OUT JBInstance& jbInstance,
    IN LPCTSTR szChkPointDirPath,
    IN LPCTSTR szTempDirPath,
    IN LPCTSTR szLogDirPath
    )
/*
*/ 
{
    //
    // Setup system parameters
    //
    BOOL bSuccess=TRUE;
    DWORD dwErrCode;


    if(jbInstance.IsValid() == TRUE)
    {
        jbInstance.SetLastJetError(JET_errAlreadyInitialized);
        goto cleanup;
    }

    //
    // Set JetBlue parameter and initialize it
    //
    if(szChkPointDirPath != NULL)
    {
        
        bSuccess =  jbInstance.SetSystemParameter(
                                        0,
                                        JET_paramSystemPath,
                                        0,
                                        (unsigned char *)szChkPointDirPath
                                    );

        if(bSuccess == FALSE)
        {
            dwErrCode = SET_JB_ERROR(jbInstance.GetLastJetError());
            SetLastError(dwErrCode);
            goto cleanup;
        }
    }                                       

    if(szTempDirPath != NULL)
    {
        bSuccess =  jbInstance.SetSystemParameter(
                                        0,
                                        JET_paramTempPath,
                                        0,
                                        (unsigned char *)szTempDirPath
                                    );

        if(bSuccess == FALSE)
        {
            dwErrCode = SET_JB_ERROR(jbInstance.GetLastJetError());
            SetLastError(dwErrCode);
            goto cleanup;
        }
    }                                       

    if(szLogDirPath != NULL)
    {
        
        bSuccess =  jbInstance.SetSystemParameter(
                                        0,
                                        JET_paramLogFilePath,
                                        0,
                                        (unsigned char *)szLogDirPath
                                    );

        if(bSuccess == FALSE)
        {
            dwErrCode = SET_JB_ERROR(jbInstance.GetLastJetError());
            SetLastError(dwErrCode);
            goto cleanup;
        }
    }                                       
   
    if( g_EsentMaxCacheSize != LSERVER_PARAMETERS_USE_ESENTDEFAULT )
    {
        //
        // Adjust memory usage, ESENT will failed on invalid parameter
        //
        bSuccess = jbInstance.SetSystemParameter(
                                            0,
                                            JET_paramCacheSizeMax,
                                            g_EsentMaxCacheSize,
                                            NULL
                                        );

        if(bSuccess == TRUE)
        {
            bSuccess = jbInstance.SetSystemParameter(
                                            0,
                                            JET_paramStartFlushThreshold,
                                            g_EsentStartFlushThreshold,
                                            NULL
                                        );

            if( bSuccess == TRUE )
            {
                bSuccess = jbInstance.SetSystemParameter(
                                                0,
                                                JET_paramStopFlushThreshold,
                                                g_EsentStopFlushThreadhold,
                                                NULL
                                            );
            }
        }

        #if DBG
        //
        // check build, assert.
        //
        if(bSuccess == FALSE)
        {
            dwErrCode = SET_JB_ERROR(jbInstance.GetLastJetError());
            TLSASSERT(FALSE);
        }
        #endif
    }

    //
    // The max. number of buffers to store old version of a record
    // (snapshot at the start of a transaction) Each version store is 16k
    // bytes.  A version store stores structures that hold information
    // derived from a snapshot of the database prior to an insert (20 bytes
    // roughly) or update (size of the record + 20 bytes).
    //

    if( g_EsentMaxVerPages != LSERVER_PARAMETERS_USE_ESENTDEFAULT )
    {
        bSuccess = jbInstance.SetSystemParameter(
                                                 0,
                                                 JET_paramMaxVerPages,
                                                 g_EsentMaxVerPages,
                                                 NULL
                                                 );

        if(bSuccess == FALSE)
        {
            dwErrCode = SET_JB_ERROR(jbInstance.GetLastJetError());
            SetLastError(dwErrCode);
            goto cleanup;
        }
    }

    bSuccess =  jbInstance.SetSystemParameter( 0, JET_paramDeleteOutOfRangeLogs, 1, NULL);

    if(bSuccess == FALSE)
    {
        dwErrCode = SET_JB_ERROR(jbInstance.GetLastJetError());
        SetLastError(dwErrCode);
        goto cleanup;
    }

    //
    // Don't let JET logs build up on the disk
    //

    bSuccess =  jbInstance.SetSystemParameter( 0, JET_paramCircularLog, 1, NULL);

    if(bSuccess == FALSE)
    {
        dwErrCode = SET_JB_ERROR(jbInstance.GetLastJetError());
        SetLastError(dwErrCode);
        goto cleanup;
    }

    //
    // We only use single instance for all the work space.
    //
    if(jbInstance.JBInitJetInstance() == FALSE)
    {
        LPTSTR pString = NULL;

        TLSGetESEError(jbInstance.GetLastJetError(), &pString);
        TLSLogEvent(
                EVENTLOG_ERROR_TYPE,
                TLS_E_DBGENERAL,
                TLS_E_INIT_JETBLUE,
                jbInstance.GetLastJetError(),
                (pString != NULL) ? pString : _TEXT("")
            );

        if(pString != NULL)
        {
            LocalFree(pString);
        }
    
        DBGPrintf(
                DBG_ERROR,
                DBG_FACILITY_JETBLUE,
                DBGLEVEL_FUNCTION_ERROR,
                _TEXT("Init. JetBlue Instance return error code %d\n"),
                jbInstance.GetLastJetError()
            );

        SetLastError(SET_JB_ERROR(jbInstance.GetLastJetError()));
    }

cleanup:
    return jbInstance.IsSuccess();
}


//--------------------------------------------------------
//
// TLSDbWorkSpace implementation
//
//--------------------------------------------------------
BOOL
__TlsDbWorkSpace::InitWorkSpace(
    BOOL bCreateIfNotExist,
    LPCTSTR szDatabaseFile,
    LPCTSTR szUserName,
    LPCTSTR szPassword,
    IN LPCTSTR szChkPointDirPath,
    IN LPCTSTR szTempDirPath,
    IN BOOL bUpdatable
    )
/*
*/
{
    BOOL bSuccess;
    DWORD dwErrCode;

    //
    // Initialize JetBlue Instance 
    if(g_JbInstance.IsValid() == FALSE)
    {
        SetLastError(TLS_E_INTERNAL);
        bSuccess = FALSE;
        goto cleanup;
    }

    DBGPrintf(
            DBG_ERROR,
            DBG_FACILITY_JETBLUE,
            DBGLEVEL_FUNCTION_ERROR,
            _TEXT("InitWorkSpace()...\n")
        );

    bSuccess = TLSJbInitDatabaseEngine(
                            m_JetSession,
                            m_JetDatabase,
                            szDatabaseFile,
                            szUserName,
                            szPassword
                        );

    if(bSuccess == FALSE)
    {
        goto cleanup;
    }


    //
    // Open all table we need 
    //
    bSuccess = m_LicPackTable.OpenTable(
                                    TRUE,
                                    (bUpdatable) ? JET_bitTableUpdatable : JET_bitTableReadOnly
                                );

    if(bSuccess == FALSE)
    {
        SetLastError(SET_JB_ERROR(m_LicPackTable.GetLastJetError()));

        LPTSTR pString = NULL;

        TLSGetESEError(m_LicPackTable.GetLastJetError(), &pString);

        TLSLogEvent(
                EVENTLOG_ERROR_TYPE,
                TLS_E_DBGENERAL,
                TLS_E_JB_OPENTABLE,
                m_LicPackTable.GetTableName(),
                m_LicPackTable.GetLastJetError(),
                (pString != NULL) ? pString : _TEXT("")
            );

        if(pString != NULL)
        {
            LocalFree(pString);
        }

        DBGPrintf(
                DBG_ERROR,
                DBG_FACILITY_JETBLUE,
                DBGLEVEL_FUNCTION_ERROR,
                _TEXT("Can't open table %s, error code %d\n"),
                m_LicPackTable.GetTableName(),
                m_LicPackTable.GetLastJetError()
            );

        goto cleanup;
    }


    bSuccess = m_LicPackDescTable.OpenTable(
                                    TRUE,
                                    (bUpdatable) ? JET_bitTableUpdatable : JET_bitTableReadOnly
                                );

    if(bSuccess == FALSE)
    {
        SetLastError(SET_JB_ERROR(m_LicPackDescTable.GetLastJetError()));

        LPTSTR pString = NULL;
        TLSGetESEError(m_LicPackDescTable.GetLastJetError(), &pString);

        TLSLogEvent(
                EVENTLOG_ERROR_TYPE,
                TLS_E_DBGENERAL,
                TLS_E_JB_OPENTABLE,
                m_LicPackDescTable.GetTableName(),
                m_LicPackDescTable.GetLastJetError(),
                (pString != NULL) ? pString : _TEXT("")
            );

        if(pString != NULL)
        {
            LocalFree(pString);
        }

        DBGPrintf(
                DBG_ERROR,
                DBG_FACILITY_JETBLUE,
                DBGLEVEL_FUNCTION_ERROR,
                _TEXT("Can't open table %s, error code %d\n"),
                m_LicPackDescTable.GetTableName(),
                m_LicPackDescTable.GetLastJetError()
            );

        goto cleanup;
    }

    bSuccess = m_LicensedTable.OpenTable(
                                    TRUE,
                                    (bUpdatable) ? JET_bitTableUpdatable : JET_bitTableReadOnly
                                );

    if(bSuccess == FALSE)
    {
        SetLastError(SET_JB_ERROR(m_LicensedTable.GetLastJetError()));

        LPTSTR pString = NULL;

        TLSGetESEError(m_LicensedTable.GetLastJetError(), &pString);

        TLSLogEvent(
                EVENTLOG_ERROR_TYPE,
                TLS_E_DBGENERAL,
                TLS_E_JB_OPENTABLE,
                m_LicensedTable.GetTableName(),
                m_LicensedTable.GetLastJetError(),
                (pString != NULL) ? pString : _TEXT("")
            );

        if(pString != NULL)
        {
            LocalFree(pString);
        }

        DBGPrintf(
                DBG_ERROR,
                DBG_FACILITY_JETBLUE,
                DBGLEVEL_FUNCTION_ERROR,
                _TEXT("Can't open table %s, error code %d\n"),
                m_LicensedTable.GetTableName(),
                m_LicensedTable.GetLastJetError()
            );

        goto cleanup;
    }

cleanup:
    return bSuccess;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\license\tlserver\setup\licenoc.h ===
/*
 *  Copyright (c) 1998  Microsoft Corporation
 *
 *  Module Name:
 *
 *      licenoc.h
 *
 *  Abstract:
 *
 *      This file contains the main OC code.
 *
 *  Author:
 *
 *      Breen Hagan (BreenH) Oct-02-98
 *
 *  Environment:
 *
 *      User Mode
 */

#ifndef _LSOC_LICENOC_H_
#define _LSOC_LICENOC_H_

#define     MESSAGE_SIZE  1024
#define     TITLE_SIZE   128
const DWORD     SECTIONSIZE = 256;
const TCHAR     COMPONENT_NAME[] = _T("LicenseServer");

typedef enum {
    kInstall,
    kUninstall,
    kStandaloneInstall,
    kStandaloneUninstall,
    kDoNothing,
} EInstall;

typedef enum {
    ePlainServer        = 0,
    eEnterpriseServer,
    eMaxServers
} EServerType;

#endif // _LSOC_LICENOC_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\license\tlserver\setup\licever.h ===
//+--------------------------------------------------------------------------
//
// Copyright (c) 1997-1999 Microsoft Corporation
//
// File:        licever.h
//
// Contents:    
//
// History:     
//
//---------------------------------------------------------------------------

/////////////////////////////////////////////////////////////////////////////
// VERSION INFO
#include <ntverp.h>


#define	VER_FILETYPE	VFT_APP
#define	VER_FILESUBTYPE	VFT2_UNKNOWN
#define VER_FILEDESCRIPTION_STR     "License Server Optional Component Setup"
#define VER_INTERNALNAME_STR        "licenoc"
#define VER_ORIGINALFILENAME_STR    "licenoc.dll"

#include "common.ver"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\license\tlserver\setup\dir.h ===
/*
 *  Copyright (c) 1998  Microsoft Corporation
 *
 *  Module Name:
 *
 *      dir.h
 *
 *  Abstract:
 *
 *      This file contains code to recursively create directories.
 *
 *  Author:
 *
 *      Breen Hagan (BreenH) Oct-02-98
 *
 *  Environment:
 *
 *      User Mode
 */

#ifndef _LSOC_DIR_H_
#define _LSOC_DIR_H_

/*
 *  Function Prototypes.
 */

DWORD
CheckDatabaseDirectory(
    IN LPCTSTR  pszDatabaseDir
    );

DWORD
CreateDatabaseDirectory(
    VOID
    );

LPCTSTR
GetDatabaseDirectory(
    VOID
    );

VOID
RemoveDatabaseDirectory(
    VOID
    );

VOID
SetDatabaseDirectory(
    IN LPCTSTR  pszDatabaseDir
    );

#endif // _LSOC_DIR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\license\tlserver\server\wkstore.h ===
//+--------------------------------------------------------------------------
//
// Copyright (c) 1997-1999 Microsoft Corporation
//
// File:        wkstore.h   
//
// Contents:    
//
// History:     
//
//---------------------------------------------------------------------------
#ifndef __WORKSTORAGE_H__
#define __WORKSTORAGE_H__

#include "tlsjob.h"

//--------------------------------------------------------------
//
// Work Object initialization function, each work object 
// must supply its own initialization routine to work 
// manager.
//
typedef CWorkObject* (WINAPI *PWorkObjectInitFunc)(
                                            CWorkManager* pWkMgr,
                                            PBYTE pbInitData, 
                                            DWORD cbInitData
                                        );   

typedef void (WINAPI *PWorkObjectDeleteFunc)(CWorkObject* ptr);
                    
//------------------------------------------------------
//
// Work object initialization routine
//
typedef struct _WorkObjectInitFunc {
    DWORD    m_WorkType;
    PWorkObjectInitFunc m_WorkInitFunc;
} WORKOBJECTINITFUNC;

typedef enum {
    WORKITEM_ADD=1,
    WORKITEM_BEGINPROCESSING,
    WORKITEM_RESCHEDULE,
    WORKITEM_DELETE
} WORKITEM_OPERATION;


class CPersistentWorkStorage : public CWorkStorage {
private:
    DWORD   m_dwStartupTime;
    CSafeCounter  m_dwNumJobs;
    CSafeCounter  m_dwJobsInProcesssing;


    //
    // m_hNextJobLock guard ...
    //
    CCriticalSection m_hTableLock;
    CSafeCounter      m_dwNextJobTime;
    CWorkObject*    m_pNextWorkObject;

    //PBYTE  m_pbCurrentBookmark;
    //DWORD  m_cbCurrentBookmark;

    //
    // Table must be updatable, 
    //
    WorkItemTable* m_pWkItemTable;

    void
    UpdateNextJobTime(DWORD dwTime) { m_dwNextJobTime=dwTime; }
    
    DWORD
    StartupUpdateExistingJobTime();

    //
    //
    //        
    BOOL 
    ReturnJobToQueue(
        IN DWORD dwTime,
        IN CWorkObject* ptr
    );

    //
    //
    //        
    BOOL
    DeleteErrorJob(
        IN CWorkObject* ptr
    );

    BOOL 
    UpdateJobEntry(
        IN WorkItemTable* pTable,
        IN PBYTE pbBookmark,
        IN DWORD cbBoolmark,
        IN WORKITEMRECORD& wkItem
    );

    BOOL
    AddJobEntry(
        IN WorkItemTable* pTable,
        IN WORKITEMRECORD& wkItem
    );

    BOOL
    DeleteJobEntry(
        IN WorkItemTable* pTable,
        IN PBYTE pbBookmark,
        IN DWORD cbBookmark,
        IN WORKITEMRECORD& wkItem
    );

    BOOL
    UpdateWorkItemEntry(
        IN WorkItemTable* pTable,
        IN WORKITEM_OPERATION opCode,
        IN PBYTE pbBookmark,
        IN DWORD cbBookmark,
        IN DWORD dwRestartTime,
        IN DWORD dwTime,
        IN DWORD dwJobType,
        IN PBYTE pbJobData,
        IN DWORD cbJobData
    );


    BOOL
    IsValidWorkObject(
        CWorkObject* ptr
    );

    DWORD
    GetCurrentBookmarkEx(
        IN WorkItemTable* pTable,
        IN OUT PBYTE* ppbData,
        IN OUT PDWORD pcbData
    );

    DWORD
    GetCurrentBookmark(
        IN WorkItemTable* pTable,
        IN PBYTE ppbData,
        IN OUT PDWORD pcbData
    );

    DWORD
    SetCurrentBookmark(
        IN WorkItemTable* pTable,
        IN PBYTE pbData, 
        IN DWORD cbData
    );

    BOOL
    RescheduleJob(
        CWorkObject* ptr
    );

    CWorkObject*
    GetCurrentJob(
        PDWORD pdwTime
    );

    DWORD
    FindNextJob();


    CWorkObject*
    InitializeWorkObject(
        DWORD dwWorkType,
        PBYTE pbData,
        DWORD cbData
    );

    BOOL
    DeleteWorkObject(
        CWorkObject* ptr
    );

public:
    CPersistentWorkStorage(
        WorkItemTable* pUpdateWkItemTable = NULL
    );

    ~CPersistentWorkStorage();

    //--------------------------------------------------------
    BOOL
    AttachTable(
        IN WorkItemTable* pWkTable
        )
    /*++

    --*/
    {
        if(pWkTable != NULL)
        {
            m_pWkItemTable = pWkTable;
        }
        else
        {
            SetLastError(ERROR_INVALID_PARAMETER);
        }

        return pWkTable != NULL;
    }

    //--------------------------------------------------------
    BOOL
    IsGood();

    //--------------------------------------------------------
    virtual BOOL 
    Startup(
        IN CWorkManager* pWkMgr
    );

    //--------------------------------------------------------
    virtual BOOL 
    Shutdown();

    //--------------------------------------------------------
    virtual BOOL
    AddJob(
        DWORD dwJobTime,
        CWorkObject* ptr
    );

    //--------------------------------------------------------
    virtual DWORD
    GetNextJobTime();

    //--------------------------------------------------------
    virtual CWorkObject*
    GetNextJob(
        PDWORD pdwTime
    );

    //--------------------------------------------------------
    virtual BOOL
    EndProcessingJob(
        IN ENDPROCESSINGJOB_CODE opCode,
        IN DWORD dwOriginalTime,
        IN CWorkObject* ptr
    );

    //--------------------------------------------------------
    virtual DWORD
    GetNumJobs() 
    { 
        return m_dwNumJobs; 
    }

    //-------------------------------------------------------
    virtual BOOL
    BeginProcessingJob(
        CWorkObject* pJob
    );
};




#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\license\tlserver\setup\licenoc.cpp ===
/*
 *  Copyright (c) 1998  Microsoft Corporation
 *
 *  Module Name:
 *
 *      licenoc.cpp
 *
 *  Abstract:
 *
 *      This file contains the main OC code.
 *
 *  Author:
 *
 *      Breen Hagan (BreenH) Oct-02-98
 *
 *  Environment:
 *
 *      User Mode
 */

#include "stdafx.h"
#include "pages.h"
#include "..\common\svcrole.h"
#include "upgdef.h"
#include "logfile.h"

/*
 *  Constants.
 */

const TCHAR gszLogFile[]            = _T("%SystemRoot%\\LicenOc.log");
const TCHAR *gInstallSectionNames[] = {
    _T("LicenseServer.Install"),
    _T("LicenseServer.Uninstall"),
    _T("LicenseServer.StandaloneInstall"),
    _T("LicenseServer.StandaloneUninstall"),
    _T("LicenseServer.DoNothing")
    };

/*
 *  Global variables.
 */

BOOL                    gNt4Upgrade         = FALSE;
BOOL                    gNtUpgrade;
BOOL                    gStandAlone;
BOOL                    gUnAttended;
EnablePage              *gEnableDlg         = NULL;
EServerType             gServerRole         = eEnterpriseServer;
HINSTANCE               ghInstance          = NULL;
PSETUP_INIT_COMPONENT   gpInitComponentData = NULL;

/*
 *  Function prototypes.
 */

HINF        GetComponentInfHandle(VOID);
DWORD       GetComponentVersion(VOID);
HINSTANCE   GetInstance(VOID);
EInstall    GetInstallSection(VOID);
LPCTSTR     GetInstallSectionName(VOID);
BOOL        GetSelectionState(UINT);
EServerType GetServerRole(VOID);
DWORD       OnPreinitialize(UINT_PTR);
DWORD       OnInitComponent(PSETUP_INIT_COMPONENT);
DWORD       OnSetLanguage(UINT_PTR);
DWORD       OnQueryImage(UINT_PTR, PDWORD);
DWORD       OnRequestPages(WizardPagesType, PSETUP_REQUEST_PAGES);
DWORD       OnWizardCreated(VOID);
DWORD       OnQueryState(UINT_PTR);
DWORD       OnQueryChangeSelState(UINT_PTR, UINT);
DWORD       OnCalcDiskSpace(LPCTSTR, UINT_PTR, HDSKSPC);
DWORD       OnQueueFileOps(LPCTSTR, HSPFILEQ);
DWORD       OnQueryStepCount(VOID);
DWORD       OnAboutToCommitQueue(VOID);
DWORD       OnCompleteInstallation(LPCTSTR);
DWORD       OnCleanup(VOID);
VOID        SetDatabaseDirectory(LPCTSTR);
DWORD       SetServerRole(UINT);

#define GetCurrentSelectionState()  GetSelectionState(OCSELSTATETYPE_CURRENT)
#define GetOriginalSelectionState() GetSelectionState(OCSELSTATETYPE_ORIGINAL)

/*
 *  Helper Functions.
 */

HINF
GetComponentInfHandle(
    VOID
    )
{
    return(gpInitComponentData->ComponentInfHandle);
}

DWORD
GetComponentVersion(
    VOID
    )
{
    return(OCMANAGER_VERSION);
}

HINSTANCE
GetInstance(
    VOID
    )
{
    return(ghInstance);
}


EInstall
GetInstallSection(
    VOID
    )
{
    BOOL    fCurrentState   = GetCurrentSelectionState();
    BOOL    fOriginalState  = GetOriginalSelectionState();

    //
    //  StandAlone Setup Matrix
    //
    //      Originally Selected, Currently Selected     ->  DoNothing
    //      Originally Selected, Currently Unselected   ->  Uninstall
    //      Originally Unselected, Currently Selected   ->  Install
    //      Originally Unselected, Currently Unselected ->  DoNothing
    //
    //  Gui Mode / Upgrade Matrix
    //
    //      Nt 4.0 any setup, Nt 5.0 w LS   ->  Install
    //      Nt 4.0 any setup, Nt 5.0 w/o LS ->  Uninstall
    //      Nt 5.0 w/ LS, Nt 5.0 w/ LS      ->  Install
    //      Nt 5.0 w/ LS, Nt 5.0 w/o LS     ->  Uninstall
    //      Nt 5.0 w/o LS, Nt 5.0 w/ LS     ->  Install
    //      Nt 5.0 w/o LS, Nt 5.0 w/o LS    ->  Uninstall
    //      Win9x, Nt5.0 w/ LS              ->  Install
    //      Win9x, Nt5.0 w/o LS             ->  Uninstall
    //

    //
    //  If this is a TS 4 installation, fOriginalState will be false,
    //  even though LS is installed. Handle this case first.
    //

    if (gNt4Upgrade) 
    {
        return(kInstall);        
    }

   if (gStandAlone)
   {
       if (fCurrentState == fOriginalState)
       {
           return(kDoNothing);
       }
       else
       {
           if (fCurrentState)
           {
               return (kStandaloneInstall);
           }
           else
           {
               return (kStandaloneUninstall);
           }
       }
   }
   else
   {
       if (fCurrentState)
       {
           return (kInstall);
       }
       else
       {
           return (kUninstall);        
       }
   }
}


LPCTSTR
GetInstallSectionName(
    VOID
    )
{
    LOGMESSAGE(
        _T("GetInstallSectionName: Returned %s"),
        gInstallSectionNames[(INT)GetInstallSection()]
        );

    return(gInstallSectionNames[(INT)GetInstallSection()]);
}

BOOL
GetSelectionState(
    UINT    StateType
    )
{
    return(gpInitComponentData->HelperRoutines.QuerySelectionState(
                gpInitComponentData->HelperRoutines.OcManagerContext,
                COMPONENT_NAME,
                StateType
                ));
}

EServerType
GetServerRole(
    VOID
    )
{
    return(gServerRole);
}

BOOL
InWin2000Domain(
    VOID
    )
{
    NET_API_STATUS dwErr;
    DSROLE_PRIMARY_DOMAIN_INFO_BASIC *pDomainInfo = NULL;
    PDOMAIN_CONTROLLER_INFO pdcInfo = NULL;
    BOOL fRet = FALSE;

    //
    // Check if we're in a workgroup
    //
    dwErr = DsRoleGetPrimaryDomainInformation(NULL,
                                              DsRolePrimaryDomainInfoBasic,
                                              (PBYTE *) &pDomainInfo);

    if ((dwErr != NO_ERROR) || (pDomainInfo == NULL))
    {
        return FALSE;
    }

    switch (pDomainInfo->MachineRole)
    {
        case DsRole_RoleStandaloneWorkstation:
        case DsRole_RoleStandaloneServer:
            DsRoleFreeMemory(pDomainInfo);

            return FALSE;
            break;      // just in case
    }

    DsRoleFreeMemory(pDomainInfo);

    dwErr = DsGetDcName(NULL,   // Computer Name
                        NULL,   // Domain Name
                        NULL,   // Domain GUID
                        NULL,   // Site Name
                        DS_DIRECTORY_SERVICE_PREFERRED,
                        &pdcInfo);

    if ((dwErr != NO_ERROR) || (pdcInfo == NULL))
    {
        return FALSE;
    }

    if (pdcInfo->Flags & DS_DS_FLAG)
    {
        fRet = TRUE;
    }

    NetApiBufferFree(pdcInfo);

    return fRet;
}

DWORD
SetServerRole(
    IN UINT newType
    )
{
    switch(newType) {
    case ePlainServer:
    case eEnterpriseServer:
        gServerRole = (EServerType)newType;
        break;

    default:
        // Set the appropriate default
        gServerRole = InWin2000Domain() ? eEnterpriseServer : ePlainServer;
        return(ERROR_INVALID_PARAMETER);
    }

    return(NO_ERROR);
}

/*
 *  DllMain
 *
 *  Initial entry point into the License Server OC dll.
 */

DWORD WINAPI
DllMain(
    IN HINSTANCE    hInstance,
    IN DWORD        dwReason,
    IN LPVOID       lpReserved
    )
{
    TCHAR   pszLogFile[MAX_PATH + 1];

    switch(dwReason) {
    case DLL_PROCESS_ATTACH:
        if (hInstance != NULL) {
            ghInstance = hInstance;
        } else {
            return(FALSE);
        }

        ExpandEnvironmentStrings(gszLogFile, pszLogFile, MAX_PATH);
        LOGINIT(pszLogFile, COMPONENT_NAME);
        break;

    case DLL_THREAD_ATTACH:
        break;

    case DLL_PROCESS_DETACH:
        break;

    case DLL_THREAD_DETACH:
        break;
    }

    UNREFERENCED_PARAMETER(lpReserved);
    return(TRUE);
}

/*
 *  EntryProc()
 *
 *  Entry point into OCBase class for OCManager.
 */

DWORD
EntryProc(
    IN LPCVOID      ComponentId,
    IN LPCVOID      SubcomponentId,
    IN UINT         Function,
    IN UINT_PTR     Param1,
    IN OUT PVOID    Param2
    )
{
    DWORD   dwRet;

    switch(Function) {
    case OC_PREINITIALIZE:
        LOGMESSAGE(_T("\r\nOnPreinitialize: Entered"));
        dwRet = OnPreinitialize(
                    Param1
                    );
        LOGMESSAGE(_T("OnPreinitialize: Returned"));
        break;

    case OC_INIT_COMPONENT:
        LOGMESSAGE(_T("\r\nOnInitComponent: Entered"));
        dwRet = OnInitComponent(
                    (PSETUP_INIT_COMPONENT)Param2
                    );
        LOGMESSAGE(_T("OnInitComponent: Returned"));
        break;

    case OC_SET_LANGUAGE:
        LOGMESSAGE(_T("\r\nOnSetLanguage: Entered"));
        dwRet = OnSetLanguage(
                    Param1
                    );
        LOGMESSAGE(_T("OnSetLanguage: Returned"));
        break;

    case OC_QUERY_IMAGE:
        LOGMESSAGE(_T("\r\nOnQueryImage: Entered"));
        dwRet = OnQueryImage(
                    Param1,
                    (PDWORD)Param2
                    );
        LOGMESSAGE(_T("OnQueryImage: Returned"));
        break;

    case OC_REQUEST_PAGES:
        LOGMESSAGE(_T("\r\nOnRequestPages: Entered"));
        dwRet = OnRequestPages(
                    (WizardPagesType)Param1,
                    (PSETUP_REQUEST_PAGES)Param2
                    );
        LOGMESSAGE(_T("OnRequestPages: Returned"));
        break;

    case OC_WIZARD_CREATED:
        LOGMESSAGE(_T("\r\nOnWizardCreated: Entered"));
        dwRet = OnWizardCreated();
        LOGMESSAGE(_T("OnWizardCreated: Returned"));
        break;

    case OC_QUERY_STATE:
        LOGMESSAGE(_T("\r\nOnQueryState: Entered"));
        dwRet = OnQueryState(
                    Param1
                    );
        LOGMESSAGE(_T("OnQueryState: Returned"));
        break;

    case OC_QUERY_CHANGE_SEL_STATE:
        LOGMESSAGE(_T("\r\nOnQueryChangeSelState: Entered"));
        dwRet = OnQueryChangeSelState(
                    Param1,
                    (UINT)((UINT_PTR)Param2)
                    );
        LOGMESSAGE(_T("OnQueryChangeSelState: Returned"));
        break;

    case OC_CALC_DISK_SPACE:
        LOGMESSAGE(_T("\r\nOnCalcDiskSpace: Entered"));
        dwRet = OnCalcDiskSpace(
                    (LPCTSTR)SubcomponentId,
                    Param1,
                    (HDSKSPC)Param2
                    );
        LOGMESSAGE(_T("OnCalcDiskSpace: Returned"));
        break;

    case OC_QUEUE_FILE_OPS:
        LOGMESSAGE(_T("\r\nOnQueueFileOps: Entered"));
        dwRet = OnQueueFileOps(
                    (LPCTSTR)SubcomponentId,
                    (HSPFILEQ)Param2
                    );
        LOGMESSAGE(_T("OnQueueFileOps: Returned"));
        break;

    case OC_QUERY_STEP_COUNT:
        LOGMESSAGE(_T("\r\nOnQueryStepCount: Entered"));
        dwRet = OnQueryStepCount();
        LOGMESSAGE(_T("OnQueryStepCount: Returned"));
        break;

    case OC_ABOUT_TO_COMMIT_QUEUE:
        LOGMESSAGE(_T("\r\nOnAboutToCommitQueue: Entered"));
        dwRet = OnAboutToCommitQueue();
        LOGMESSAGE(_T("OnAboutToCommitQueue: Returned"));
        break;

    case OC_COMPLETE_INSTALLATION:
        LOGMESSAGE(_T("\r\nOnCompleteInstallation: Entered"));
        dwRet = OnCompleteInstallation(
                    (LPCTSTR)SubcomponentId
                    );
        LOGMESSAGE(_T("OnCompleteInstallation: Returned"));
        break;

    case OC_CLEANUP:
        LOGMESSAGE(_T("\r\nOnCleanup: Entered"));
        dwRet = OnCleanup();
        break;

    default:
        LOGMESSAGE(_T("\r\nOC Manager calling for unknown function %ld\r\n"),
            Function);
        dwRet = 0;
    }

    UNREFERENCED_PARAMETER(ComponentId);
    return(dwRet);
}

/*
 *  OnPreinitialize()
 *
 *
 */

DWORD
OnPreinitialize(
    IN UINT_PTR Flags
    )
{

    UNREFERENCED_PARAMETER(Flags);
#ifdef UNICODE
    return(OCFLAG_UNICODE);
#else
    return(OCFLAG_ANSI);
#endif
}

/*
 *  OnInitComponent()
 *
 *
 */

DWORD
OnInitComponent(
    IN PSETUP_INIT_COMPONENT    pSetupInitComponent
    )
{
    BOOL        fErr;
    DWORDLONG   OperationFlags;

    if (pSetupInitComponent == NULL) {
        LOGMESSAGE(_T("OnInitComponent: Passed NULL PSETUP_INIT_COMPONENT"));
        return(ERROR_CANCELLED);
    }

    //
    //  Verify that the OC Manager and OC versions are compatible.
    //

    pSetupInitComponent->ComponentVersion = GetComponentVersion();
    if (pSetupInitComponent->ComponentVersion >
        pSetupInitComponent->OCManagerVersion)  {
        LOGMESSAGE(_T("OnInitComponent: Version mismatch."));
        return(ERROR_CALL_NOT_IMPLEMENTED);
    }

    //
    //  Copy setup data.
    //

    gpInitComponentData = (PSETUP_INIT_COMPONENT)LocalAlloc(
                                LPTR,
                                sizeof(SETUP_INIT_COMPONENT)
                                );
    if (gpInitComponentData == NULL) {
        LOGMESSAGE(_T("OnInitComponent: Can't allocate gpInitComponentData."));
        return(ERROR_CANCELLED);
    }

    CopyMemory(
        gpInitComponentData,
        pSetupInitComponent,
        sizeof(SETUP_INIT_COMPONENT)
        );

    //
    //  Open Inf file.
    //

    if (GetComponentInfHandle() == NULL) {
        return(ERROR_CANCELLED);
    }

    fErr = SetupOpenAppendInfFile(
                NULL,
                GetComponentInfHandle(),
                NULL
                );

    if (!fErr) {
        LOGMESSAGE(_T("OnInitComponent: SetupOpenAppendInfFile failed: %ld"),
            GetLastError());
        return(GetLastError());
    }

    //
    //  Set state variables.
    //

    OperationFlags  = gpInitComponentData->SetupData.OperationFlags;
    gStandAlone     = OperationFlags & SETUPOP_STANDALONE ? TRUE : FALSE;
    gUnAttended     = OperationFlags & SETUPOP_BATCH ? TRUE : FALSE;
    gNtUpgrade      = OperationFlags & SETUPOP_NTUPGRADE ? TRUE : FALSE;

    LOGMESSAGE(_T("OnInitComponent: gStandAlone = %s"),
        gStandAlone ? _T("TRUE") : _T("FALSE"));
    LOGMESSAGE(_T("OnInitComponent: gUnAttended = %s"),
        gUnAttended ? _T("TRUE") : _T("FALSE"));
    LOGMESSAGE(_T("OnInitComponent: gNtUpgrade = %s"),
        gNtUpgrade ? _T("TRUE") : _T("FALSE"));

    //
    //  Gather previous version's information from registry. If the role
    //  does not exist in the registry, SetServerRole will stay with the
    //  default.
    //

    SetServerRole(GetServerRoleFromRegistry());

    //
    //  Check for Nt4 Upgrade.
    //

    if (GetNT4DbConfig(NULL, NULL, NULL, NULL) == NO_ERROR) {
        LOGMESSAGE(_T("OnInitComponent: Nt4Upgrade"));
        gNt4Upgrade = TRUE;

        DeleteNT4ODBCDataSource();
    }

    //
    //  License Server will only use the directory in the registry during
    //  an Nt5 to Nt5 upgrade or stand alone setup from Add/Remove Programs.
    //

    if (gStandAlone || (gNtUpgrade && !gNt4Upgrade)) {
        LPCTSTR pszDbDirFromReg = GetDatabaseDirectoryFromRegistry();

        if (pszDbDirFromReg != NULL) {
            SetDatabaseDirectory(pszDbDirFromReg);
        }
    }

    return(NO_ERROR);
}

/*
 *  OnSetLanguage()
 *
 *
 */

DWORD
OnSetLanguage(
    IN UINT_PTR LanguageId
    )
{
    UNREFERENCED_PARAMETER(LanguageId);
    return((DWORD)FALSE);
}

/*
 *  OnQueryImage()
 *
 *
 */

DWORD
OnQueryImage(
    IN UINT_PTR     SubCompEnum,
    IN OUT PDWORD   Size
    )
{
    UNREFERENCED_PARAMETER(SubCompEnum);
    UNREFERENCED_PARAMETER(Size);
    return((DWORD)NULL);
}

/*
 *  OnRequestPages()
 *
 *
 */

DWORD
OnRequestPages(
    IN WizardPagesType          PageTypeEnum,
    IN OUT PSETUP_REQUEST_PAGES pRequestPages
    )
{
    const DWORD cUiPages = 1;
    BOOL        fErr;

    LOGMESSAGE(_T("OnRequestPages: Page Type %d"), PageTypeEnum);

    if (pRequestPages == NULL) {
        LOGMESSAGE(_T("OnRequestPages: pRequestPages == NULL"));
        return(0);
    }

    if ((!gStandAlone) || (PageTypeEnum != WizPagesEarly)) {
        return(0);
    }

    if (pRequestPages->MaxPages >= cUiPages) {
        gEnableDlg = new EnablePage;
        if (gEnableDlg == NULL) {
            goto CleanUp1;
        }

        fErr = gEnableDlg->Initialize();
        if (!fErr) {
            goto CleanUp1;
        }

        pRequestPages->Pages[0] = CreatePropertySheetPage(
                                    (LPPROPSHEETPAGE)gEnableDlg
                                    );

        if (pRequestPages->Pages[0] == NULL) {
            LOGMESSAGE(_T("OnRequestPages: Failed CreatePropertySheetPage!"));
            goto CleanUp0;
        }
    }

    return(cUiPages);

CleanUp0:
    delete gEnableDlg;

CleanUp1:
    SetLastError(ERROR_OUTOFMEMORY);
    LOGMESSAGE(_T("OnRequestPages: Out of Memory!"));
    return((DWORD)-1);
}

/*
 *  OnWizardCreated()
 *
 *
 */

DWORD
OnWizardCreated(
    VOID
    )
{
    return(NO_ERROR);
}

/*
 *  OnQueryState()
 *
 *
 */

DWORD
OnQueryState(
    IN UINT_PTR uState
    )
{
    UNREFERENCED_PARAMETER(uState);
    return(SubcompUseOcManagerDefault);
}

/*
 *  OnQueryChangeSelState()
 *
 *
 */

DWORD
OnQueryChangeSelState(
    IN UINT_PTR SelectionState,
    IN UINT     Flags
    )
{
    BOOL fDirectSelection;
    BOOL fRet;
    BOOL fSelect;

    UNREFERENCED_PARAMETER(Flags);

    if (Flags & OCQ_ACTUAL_SELECTION)
    {
        fDirectSelection = TRUE;
    }
    else
    {
        fDirectSelection = FALSE;
    }

    fRet = TRUE;
    fSelect = (SelectionState != 0);

    if (!fSelect && fDirectSelection && GetOriginalSelectionState())
    {
        DWORD dwStatus;
        HWND hWnd;
        int iRet;

        hWnd = gpInitComponentData->HelperRoutines.QueryWizardDialogHandle(gpInitComponentData->HelperRoutines.OcManagerContext);

        dwStatus = DisplayMessageBox(
                    hWnd,
                    IDS_STRING_LICENSES_GO_BYE_BYE,
                    IDS_MAIN_TITLE,
                    MB_YESNO,
                    &iRet
                    );

        if (dwStatus == ERROR_SUCCESS)
        {
            fRet = (iRet == IDYES);
        }
    }

    return((DWORD)fRet);
}

/*
 *  OnCalcDiskSpace()
 *
 *
 */

DWORD
OnCalcDiskSpace(
    IN LPCTSTR      SubcomponentId,
    IN UINT_PTR     AddComponent,
    IN OUT HDSKSPC  DiskSpaceHdr
    )
{
    BOOL        fErr;
    LPCTSTR     pSection;

    if ((SubcomponentId == NULL) ||
        (SubcomponentId[0] == NULL)) {
        return(0);
    }

    LOGMESSAGE(_T("OnCalcDiskSpace: %s"),
        AddComponent ? _T("Installing") : _T("Removing"));

    //
    //  There is no clear documentation on how this should work. If the
    //  size of the installation should be visible no matter what, then
    //  the section to install should be hardcoded, not determined by
    //  the current state.
    //

    pSection = gInstallSectionNames[kInstall];
    LOGMESSAGE(_T("OnCalcDiskSpace: Calculating for %s"), pSection);

    if (AddComponent != 0) {
        fErr = SetupAddInstallSectionToDiskSpaceList(
                    DiskSpaceHdr,
                    GetComponentInfHandle(),
                    NULL,
                    pSection,
                    NULL,
                    0
                    );
    } else {
        fErr = SetupRemoveInstallSectionFromDiskSpaceList(
                    DiskSpaceHdr,
                    GetComponentInfHandle(),
                    NULL,
                    pSection,
                    NULL,
                    0
                    );
    }

    if (fErr) {
        return(NO_ERROR);
    } else {
        LOGMESSAGE(_T("OnCalcDiskSpace: Error %ld"), GetLastError());
        return(GetLastError());
    }
}

/*
 *  OnQueueFileOps()
 *
 *
 */

DWORD
OnQueueFileOps(
    IN LPCTSTR      SubcomponentId,
    IN OUT HSPFILEQ FileQueueHdr
    )
{
    BOOL        fErr;
    DWORD       dwErr;
    EInstall    eInstallSection;
    LPCTSTR     pSection;

    if ((SubcomponentId == NULL) ||
        (SubcomponentId[0] == NULL)) {
        return(0);
    }

    pSection = GetInstallSectionName();
    LOGMESSAGE(_T("OnQueueFileOps: Queueing %s"), pSection);

    //
    //  Stop and remove the license server service, if needed. This must
    //  be done before queueing files for deletion.
    //

    eInstallSection = GetInstallSection();

    if (eInstallSection == kUninstall || eInstallSection == kStandaloneUninstall) {
        if (gServerRole == eEnterpriseServer) {
            if (UnpublishEnterpriseServer() != S_OK) {
                LOGMESSAGE(
                    _T("OnQueueFileOps: UnpublishEnterpriseServer() failed")
                    );
            }
        }

        dwErr = ServiceDeleteFromInfSection(
                    GetComponentInfHandle(),
                    pSection
                    );
        if (dwErr != ERROR_SUCCESS) {
            LOGMESSAGE(
                _T("OnQueueFileOps: Error deleting service: %ld"),
                dwErr
                );
        }
    }

    fErr = SetupInstallFilesFromInfSection(
                GetComponentInfHandle(),
                NULL,
                FileQueueHdr,
                pSection,
                NULL,
                eInstallSection == kUninstall ? 0 : SP_COPY_NEWER
                );

    if (fErr) {
        return(NO_ERROR);
    } else {
        LOGMESSAGE(_T("OnQueueFileOps: Error %ld"), GetLastError());
        return(GetLastError());
    }
}

/*
 *  OnQueryStepCount()
 *
 *  TODO: how many steps, when should we tick?
 */

DWORD
OnQueryStepCount(
    VOID
    )
{
    return(0);
}

/*
 *  OnAboutToCommitQueue()
 *
 *
 */

DWORD
OnAboutToCommitQueue(
    VOID
    )
{
    return(NO_ERROR);
}

/*
 *  OnCompleteInstallation()
 *
 *
 */

DWORD
OnCompleteInstallation(
    IN LPCTSTR  SubcomponentId
    )
{
    BOOL        fErr;
    DWORD       dwErr;
    EInstall    eInstallSection = GetInstallSection();
    LPCTSTR     pSection;
    TCHAR tchBuf[MESSAGE_SIZE] ={0};
    TCHAR tchTitle[TITLE_SIZE] = {0};

    if ((SubcomponentId == NULL) ||
        (SubcomponentId[0] == NULL)) {
        return(NO_ERROR);
    }

    //
    // This has to run even for "kDoNothing" - if the LS was previously
    // installed and is still installed
    //

    dwErr = MigrateLsaSecrets();

    if (dwErr != NO_ERROR) {
        LOGMESSAGE(
                   _T("OnCompleteInstallation: MigrateLsaSecrets: Error %ld"),
                   dwErr
                   );
        return(dwErr);
    }

    if(eInstallSection == kDoNothing)
    {
        LOGMESSAGE(_T("OnCompleteInstallation: Nothing to do"));
        return (NO_ERROR);
    }

    pSection = GetInstallSectionName();

    //
    //  In GUI mode setup and in unattended StandAlone setup, the wizard
    //  page does not display, and therefore the directory is not created.
    //  Create the default directory here.
    //

    if (eInstallSection == kInstall || eInstallSection == kStandaloneInstall) {
        if ((!gStandAlone) || (gUnAttended)) {
            CreateDatabaseDirectory();
        }
    }

    //
    //  SetupAPI correctly handles installing and removing files, and
    //  creating start menu links.

    fErr = SetupInstallFromInfSection(
                NULL,
                GetComponentInfHandle(),
                pSection,
                SPINST_INIFILES | SPINST_REGISTRY | SPINST_PROFILEITEMS,
                NULL,
                NULL,
                0,
                NULL,
                NULL,
                NULL,
                NULL
                );
    if (!fErr) {
        LOGMESSAGE(_T("OnCompleteInstallation: InstallFromInf failed %ld"),
            GetLastError());
        return(GetLastError());
    }    

    if (eInstallSection == kStandaloneInstall) 
    {
        CreateDatabaseDirectory();
        //
        //  Set service settings first and install the service.
        //
        dwErr = CreateRegistrySettings(GetDatabaseDirectory(), gServerRole);

        if (dwErr != NO_ERROR) {
            LOGMESSAGE(
                _T("OnCompleteInstallation: kStandaloneInstall: CreateRegistrySettings: Error %ld"),
                dwErr
                );
            return(dwErr);
        }

        fErr = SetupInstallServicesFromInfSection(
                GetComponentInfHandle(),
                pSection,
                0
                );
        if (!fErr) {
            LOGMESSAGE(
                _T("OnCompleteInstallation: kStandaloneInstall: InstallServices: Error %ld"),
                GetLastError()
                );
            return(GetLastError());
        }

        if (gServerRole == eEnterpriseServer) {
            if (PublishEnterpriseServer() != S_OK) {                

                LOGMESSAGE(_T("OnCompleteInstallation: kStandaloneInstall: PublishEnterpriseServer() failed. Setup will still complete."));                               

                LOGMESSAGE(_T("PublishEnterpriseServer: kStandaloneInstall: Uninstall, try logging on as a member of the Enterprise Admins or Domain Admins group and then run setup again."));

                if (!gUnAttended)
                {
                    LoadString( GetInstance(), IDS_INSUFFICIENT_PERMISSION, tchBuf, sizeof(tchBuf)/sizeof(TCHAR));

                    LoadString( GetInstance(), IDS_MAIN_TITLE, tchTitle, sizeof(tchTitle)/sizeof(TCHAR));

                    MessageBox( NULL, tchBuf, tchTitle, MB_OK | MB_ICONWARNING | MB_SETFOREGROUND | MB_TOPMOST);
                }                

            }
        }
        
        dwErr = ServiceStartFromInfSection(
                    GetComponentInfHandle(),
                    pSection
                    );
        if (dwErr != ERROR_SUCCESS) {
            LOGMESSAGE(
                _T("OnCompleteInstallation: kStandaloneInstall: Error starting service: %ld"),
                dwErr
                );
            return(dwErr);
        }    
    }

    
    //
    //  Perform installation and upgrade-specific tasks.
    //

    else if (eInstallSection == kInstall) 
    {        
        LOGMESSAGE(_T("OnCompleteInstallation: kInstall: Installing"));

        //
        //  Set service settings first and install the service.
        //

        dwErr = CreateRegistrySettings(GetDatabaseDirectory(), gServerRole);
        if (dwErr != NO_ERROR) 
        {
            LOGMESSAGE(
                _T("OnCompleteInstallation: kInstall: CreateRegistrySettings: Error %ld"),
                dwErr
                );
            return(dwErr);
        }

        fErr = SetupInstallServicesFromInfSection(
                GetComponentInfHandle(),
                pSection,
                0
                );
        if (!fErr) 
        {
            LOGMESSAGE(
                _T("OnCompleteInstallation: kInstall: InstallServices: Error %ld"),
                GetLastError()
                );
            return(GetLastError());
        }

        if (gServerRole == eEnterpriseServer) 
        {
            if (PublishEnterpriseServer() != S_OK) 
            {                

                LOGMESSAGE(_T("OnCompleteInstallation: kInstall: PublishEnterpriseServer() failed. Setup will still complete."));                               

                LOGMESSAGE(_T("PublishEnterpriseServer: kInstall: Uninstall, try logging on as a member of the Enterprise Admins or Domain Admins group and then run setup again."));

                if (!gUnAttended)
                {
                    LoadString( GetInstance(), IDS_INSUFFICIENT_PERMISSION, tchBuf, sizeof(tchBuf)/sizeof(TCHAR));

                    LoadString( GetInstance(), IDS_MAIN_TITLE, tchTitle, sizeof(tchTitle)/sizeof(TCHAR));

                    MessageBox( NULL, tchBuf, tchTitle, MB_OK | MB_ICONWARNING | MB_SETFOREGROUND | MB_TOPMOST);
                }                

            }
        }        

    } 
    else if (eInstallSection == kUninstall) 
    {
        CleanLicenseServerSecret();
        RemoveDatabaseDirectory();
        RemoveRegistrySettings();

        fErr = SetupInstallFromInfSection(
                NULL,
                GetComponentInfHandle(),
                pSection,
                SPINST_INIFILES | SPINST_REGISTRY | SPINST_PROFILEITEMS,
                NULL,
                NULL,
                0,
                NULL,
                NULL,
                NULL,
                NULL
                );
        if (!fErr) 
        {
                LOGMESSAGE(_T("OnCompleteInstallation: kUninstall: InstallFromInf failed %ld"),
                 GetLastError());
                return(GetLastError());        
        }
    }
    else if (eInstallSection == kStandaloneUninstall) 
    {
        CleanLicenseServerSecret();
        RemoveDatabaseDirectory();
        RemoveRegistrySettings();

        fErr = SetupInstallFromInfSection(
                NULL,
                GetComponentInfHandle(),
                pSection,
                SPINST_INIFILES | SPINST_REGISTRY | SPINST_PROFILEITEMS,
                NULL,
                NULL,
                0,
                NULL,
                NULL,
                NULL,
                NULL
                );
        if (!fErr) 
        {
                LOGMESSAGE(_T("OnCompleteInstallation: kStandaloneUninstall: InstallFromInf failed %ld"),
                 GetLastError());
                return(GetLastError());        
        }
    }

    return(NO_ERROR);
}

/*
 *  OnCleanup()
 *
 *
 */

DWORD
OnCleanup(
    VOID
    )
{
    if (gpInitComponentData != NULL) {
        LocalFree(gpInitComponentData);
    }

    if (gEnableDlg != NULL) {
        delete gEnableDlg;
    }

    LOGMESSAGE(_T("OnCleanup: Returned"));
    LOGCLOSE();

    return(NO_ERROR);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\license\tlserver\setup\dir.cpp ===
/*
 *  Copyright (c) 1998  Microsoft Corporation
 *
 *  Module Name:
 *
 *      dir.cpp
 *
 *  Abstract:
 *
 *      This file contains code to recursively create directories.
 *
 *  Author:
 *
 *      Breen Hagan (BreenH) Oct-02-98
 *
 *  Environment:
 *
 *      User Mode
 */

#include "stdafx.h"
#include "logfile.h"
#include <sddl.h>
#include "Aclapi.h"
#include "Accctrl.h"

/*
 *  Global variables.
 */

TCHAR   gszDatabaseDirectory[MAX_PATH + 1]  =
            _T("%SystemRoot%\\System32\\LServer");

/*
 *  Helper Functions.
 */

DWORD
CreateDirectoryRecursively(
    IN LPCTSTR  pszDirectory
    )
{
    TCHAR   Buffer[MAX_PATH + 1];
    PTCHAR  p,q;
    BOOL    fDone, br;
    DWORD   dwErr;
    SECURITY_ATTRIBUTES SA;
    SECURITY_INFORMATION    securityInfo;   
    PSECURITY_DESCRIPTOR    pSD = NULL;
    PACL pOldACL = NULL;

    ACL_SIZE_INFORMATION asiAclSize; 
	DWORD dwBufLength=sizeof(asiAclSize);
    ACCESS_ALLOWED_ACE *paaAllowedAce; 
    DWORD dwAcl_i;

    if (_tcslen(pszDirectory) > (MAX_PATH)) {
        return(ERROR_BAD_PATHNAME);
    }    

    if (ExpandEnvironmentStrings(pszDirectory, Buffer, MAX_PATH) > MAX_PATH) {
        return(ERROR_BAD_PATHNAME);
    }

    //
    // This is a string security descriptor.  Look up "Security Descriptor 
    // Definition Language" in MSDN for more details.
    //
    // This one says:
    //
    // D: <we are creating a DACL>
    // (A; <Allow ACE>
    // OICI; <Perform object and container inheritance, i.e., let files and 
    //        directories under this one have these attributes>
    // GA <Generic All Access--Full Control>
    // ;;;SY) <SYSTEM>
    // (A;OICI;GA;;;BA) <same for Builtin Administrators group>
    // (A;OICI;GA;;;CO) <same for creator/owner>
    // (A;OICI;GRGWGXDTSDCCLC;;;PU) <read access for Power Users>
    // 
    // We'll use it below to create our directory with the right permissions.

    TCHAR* pwszSD = _TEXT("D:(A;OICI;GA;;;SY)(A;OICI;GA;;;BA)(A;OICI;GA;;;CO)(A;OICI;GRGWGXDTSDCCLC;;;PU)");
    
    SA.nLength = sizeof(SECURITY_ATTRIBUTES);
    SA.bInheritHandle = FALSE;
    SA.lpSecurityDescriptor = NULL;

    br = ConvertStringSecurityDescriptorToSecurityDescriptor(pwszSD, 
            SDDL_REVISION_1, &(SA.lpSecurityDescriptor), NULL);

    if (br == 0) {
        dwErr = GetLastError();
        goto cleanup;
    }

    q = Buffer;

    if (q[1] == _T(':')) {

        //
        //  This is a "C:" style path. Put p past the colon and first
        //  backslash, if it exists.
        //

        if (q[2] == _T('\\')) {
            p = &(q[3]);
        } else {
            p = &(q[2]);
        }
    } else if (q[0] == _T('\\')) {

        //
        //  This path begins with a backslash. If the second character is
        //  also a backslash, this is a UNC path, which is not accepted.
        //

        if (q[1] == _T('\\')) {
            return(ERROR_BAD_PATHNAME);
        } else {
            p = &(q[1]);
        }
    } else {

        //
        //  This path is a relative path from the current directory.
        //

        p = q;
    }

    q = p;
    fDone = FALSE;

    do {           
           
        //
        // Locate the next path sep char. If there is none then
        // this is the deepest level of the path.
        //

        p = _tcschr(q, _T('\\'));
        if (p) {
            *p = (TCHAR)NULL;
        } else {
            fDone = TRUE;
        }

        if(fDone == TRUE)
        {
            BOOL bInherit = TRUE;
            //
            // Create this portion of the path.
            //
            if(CreateDirectory(Buffer,&SA)) {
                dwErr = NO_ERROR;
            }
            else
            {
                dwErr = GetLastError();
                if(dwErr == ERROR_ALREADY_EXISTS) {
                    dwErr = NO_ERROR;                    

                    if( GetNamedSecurityInfoW( (LPWSTR)Buffer,
                         SE_FILE_OBJECT,
                         DACL_SECURITY_INFORMATION,
                         NULL, // psidOwner
                         NULL, // psidGroup
                         &pOldACL, // pDacl
                         NULL, // pSacl
                         &pSD ) != ERROR_SUCCESS)
                    {
                        dwErr = GetLastError();
                        goto cleanup;
                    }

                    if(pOldACL == NULL)
                    {
                        goto cleanup;
                    }
            
                    if (GetAclInformation(pOldACL, 
                                (LPVOID)&asiAclSize, 
                                (DWORD)dwBufLength, 
                                (ACL_INFORMATION_CLASS)AclSizeInformation)) 
                    { 
    
                        for (dwAcl_i = 0; dwAcl_i < asiAclSize.AceCount; dwAcl_i++) 
                        {                             
                            if(GetAce( pOldACL, dwAcl_i, (LPVOID *)&paaAllowedAce)) 
                            {
                                if(!(paaAllowedAce->Header.AceFlags & INHERITED_ACE)) 
                                {
                                    //some permission already exist, we don't need to 
                                    //do anything (even if it is a different permission!)
                                    bInherit = FALSE;
                                    break;
                                }
                            }
                        }
                    }

                    if (bInherit)
                    {
                        // If the database had default security => inheritance from parent only then, set the security.
                        // No changes in case of custom security.
                        securityInfo = DACL_SECURITY_INFORMATION | PROTECTED_DACL_SECURITY_INFORMATION;
                                                          
                        SetFileSecurity(Buffer, securityInfo, SA.lpSecurityDescriptor);
                        
                    }                                                                                                    
                }
            }            
        }
        else 
        {
            if(CreateDirectory(Buffer, NULL)) {
                dwErr = NO_ERROR;                
            }  
            else {
                dwErr = GetLastError();
                if(dwErr == ERROR_ALREADY_EXISTS) {
                    dwErr = NO_ERROR;
                }
            }
        }
      
        if(dwErr == NO_ERROR) {

            //
            // Put back the path sep and move to the next component.
            //

            if (!fDone) {
                *p = TEXT('\\');
                q = p + sizeof(TCHAR);
            }
        } else {
            fDone = TRUE;
        }

    } while(!fDone);

cleanup:

    LocalFree(SA.lpSecurityDescriptor);
    SA.lpSecurityDescriptor = NULL;

    return(dwErr);
}

BOOL
ConcatenatePaths(
    IN OUT LPTSTR   Target,
    IN     LPCTSTR  Path,
    IN     UINT     TargetBufferSize,
    OUT    LPUINT   RequiredSize          OPTIONAL
    )

{
    UINT TargetLength,PathLength;
    BOOL TrailingBackslash,LeadingBackslash;
    UINT EndingLength;

    TargetLength = lstrlen(Target);
    PathLength = lstrlen(Path);

    //
    // See whether the target has a trailing backslash.
    //
    if(TargetLength && (Target[TargetLength-1] == TEXT('\\'))) {
        TrailingBackslash = TRUE;
        TargetLength--;
    } else {
        TrailingBackslash = FALSE;
    }

    //
    // See whether the path has a leading backshash.
    //
    if(Path[0] == TEXT('\\')) {
        LeadingBackslash = TRUE;
        PathLength--;
    } else {
        LeadingBackslash = FALSE;
    }

    //
    // Calculate the ending length, which is equal to the sum of
    // the length of the two strings modulo leading/trailing
    // backslashes, plus one path separator, plus a nul.
    //
    EndingLength = TargetLength + PathLength + 2;
    if(RequiredSize) {
        *RequiredSize = EndingLength;
    }

    if(!LeadingBackslash && (TargetLength < TargetBufferSize)) {
        Target[TargetLength++] = TEXT('\\');
    }

    if(TargetBufferSize > TargetLength) {
        lstrcpyn(Target+TargetLength,Path,TargetBufferSize-TargetLength);
    }

    //
    // Make sure the buffer is nul terminated in all cases.
    //
    if (TargetBufferSize) {
        Target[TargetBufferSize-1] = 0;
    }

    return(EndingLength <= TargetBufferSize);
}

VOID
Delnode(
    IN LPCTSTR  Directory
    )
{
    TCHAR           pszDirectory[MAX_PATH + 1];
    TCHAR           pszPattern[MAX_PATH + 1];
    WIN32_FIND_DATA FindData;
    HANDLE          FindHandle;

    LOGMESSAGE(_T("Delnode: Entered"));

    //
    //  Delete each file in the given directory, then remove the directory
    //  itself. If any directories are encountered along the way recurse to
    //  delete them as they are encountered.
    //
    //  Start by forming the search pattern, which is <currentdir>\*.
    //

    ExpandEnvironmentStrings(Directory, pszDirectory, MAX_PATH);
    LOGMESSAGE(_T("Delnode: Deleting %s"), pszDirectory);

    lstrcpyn(pszPattern, pszDirectory, MAX_PATH);
    ConcatenatePaths(pszPattern, _T("*"), MAX_PATH, NULL);

    //
    // Start the search.
    //

    FindHandle = FindFirstFile(pszPattern, &FindData);
    if(FindHandle != INVALID_HANDLE_VALUE) {

        do {

            //
            // Form the full name of the file or directory we just found.
            //

            lstrcpyn(pszPattern, pszDirectory, MAX_PATH);
            ConcatenatePaths(pszPattern, FindData.cFileName, MAX_PATH, NULL);

            //
            // Remove read-only atttribute if it's there.
            //

            if (FindData.dwFileAttributes & FILE_ATTRIBUTE_READONLY) {
                SetFileAttributes(pszPattern, FILE_ATTRIBUTE_NORMAL);
            }

            if (FindData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) {

                //
                // The current match is a directory.  Recurse into it unless
                // it's . or ...
                //

                if ((lstrcmp(FindData.cFileName,_T("."))) &&
                    (lstrcmp(FindData.cFileName,_T("..")))) {
                    Delnode(pszPattern);
                }

            } else {

                //
                // The current match is not a directory -- so delete it.
                //

                if (!DeleteFile(pszPattern)) {
                    LOGMESSAGE(_T("Delnode: %s not deleted: %d"), pszPattern,
                        GetLastError());
                }
            }

        } while(FindNextFile(FindHandle, &FindData));

        FindClose(FindHandle);
    }

    //
    // Remove the directory we just emptied out. Ignore errors.
    //

    RemoveDirectory(pszDirectory);
}

/*
 *  Exported Functions.
 */

/*
 *  CheckDatabaseDirectory()
 *
 *  CheckDatabaseDirectory is very hardcore about which paths it will accept.
 *
 *  Good Paths:
 *      <DriveLetter>:\AbsolutePathToDirectory
 *
 *  Bad Paths:
 *      Any path that is not like above, AND any path in the form above that
 *      is not on a fixed disk (e.g. no path to a floppy, CD-ROM, network
 *      share).
 */

DWORD
CheckDatabaseDirectory(
    IN LPCTSTR  pszDatabaseDir
    )
{
    BOOL    fBadChars;
    BOOL    fBadPath;
    UINT    DriveType;
    TCHAR   pszExpandedDir[MAX_PATH + 1];

    LOGMESSAGE(_T("CheckDatabaseDirectory: Entered"));
    LOGMESSAGE(_T("CheckDatabaseDirectory: Checking %s"), pszDatabaseDir);

    //
    //  NULL is not accepted.
    //

    if (pszDatabaseDir == NULL) {
        return(ERROR_INVALID_PARAMETER);
    }

    //
    //  A path greater than MAX_PATH will cause problems somewhere. This
    //  will also catch pathnames with no environment variables that are
    //  still too long.
    //

    if (ExpandEnvironmentStrings(pszDatabaseDir, pszExpandedDir, MAX_PATH) >
        MAX_PATH) {
        LOGMESSAGE(_T("CheckDatabaseDirectory: Path too long"));
        return(ERROR_BAD_PATHNAME);
    }

    //
    //  A path of less than three characters can't contain "<DriveLetter>:\".
    //  Also, don't allow anything but a letter, a colon, and a backslash.
    //

    fBadPath = FALSE;

    if (!fBadPath) {
        fBadPath = (_tcslen(pszExpandedDir) < 3);
    }
    if (!fBadPath) {
        fBadPath = !(_istalpha(pszExpandedDir[0]));
    }
    if (!fBadPath) {
        fBadPath = (pszExpandedDir[1] != _T(':'));
    }
    if (!fBadPath) {
        fBadPath = (pszExpandedDir[2] != _T('\\'));
    }

    if (fBadPath) {
        LOGMESSAGE(_T("CheckDatabaseDirectory: Not a C:\\ style directory"));
        return(ERROR_BAD_PATHNAME);
    }

    //
    //  Characters like < > * ? and , won't work. Check for that now.
    //  Also, check for additional colons after the first C:\....
    //

    fBadChars = FALSE;

    if (!fBadChars) {
        fBadChars = (_tcschr(pszExpandedDir, _T('<')) != NULL);
    }
    if (!fBadChars) {
        fBadChars = (_tcschr(pszExpandedDir, _T('>')) != NULL);
    }
    if (!fBadChars) {
        fBadChars = (_tcschr(pszExpandedDir, _T('*')) != NULL);
    }
    if (!fBadChars) {
        fBadChars = (_tcschr(pszExpandedDir, _T('?')) != NULL);
    }
    if (!fBadChars) {
        fBadChars = (_tcschr(&(pszExpandedDir[3]), _T(':')) != NULL);
    }

    if (fBadChars) {
        LOGMESSAGE(_T("CheckDatabaseDirectory: Invalid characters"));
        return(ERROR_BAD_PATHNAME);
    }

    //
    //  GetDriveType only works for paths in the form "C:\" or
    //  "C:\ExistingDir". As pszDatabaseDir probably doesn't exist, it can't
    //  be passed to GetDriveType. Set a NULL character passed the "C:\" to
    //  pass in only the drive letter.
    //

    pszExpandedDir[3] = (TCHAR)NULL;
    DriveType = GetDriveType(pszExpandedDir);

    if (DriveType == DRIVE_FIXED) {
        return(NO_ERROR);
    } else {
        LOGMESSAGE(_T("CheckDatabaseDirectory: Bad DriveType %d"), DriveType);
        return(ERROR_BAD_PATHNAME);
    }
}

/*
 *  CreateDatabaseDirectory()
 *
 *  Creates the specified database directory.
 */

DWORD
CreateDatabaseDirectory(
    VOID
    )
{
    return(CreateDirectoryRecursively(gszDatabaseDirectory));
}

/*
 *  GetDatabaseDirectory()
 *
 *  Returns the current database directory.
 */

LPCTSTR
GetDatabaseDirectory(
    VOID
    )
{
    return(gszDatabaseDirectory);
}

/*
 *  RemoveDatabaseDirectory()
 *
 *  Removes the entire database directory.
 */

VOID
RemoveDatabaseDirectory(
    VOID
    )
{
    Delnode(gszDatabaseDirectory);
}

/*
 *  SetDatabaseDirectory()
 *
 *  This function assumes pszDatabaseDir has been verified by a call to
 *  CheckDatabaseDir(), which verifies not NULL, within MAX_PATH, and on a
 *  fixed hard drive.
 */

VOID
SetDatabaseDirectory(
    IN LPCTSTR  pszDatabaseDir
    )
{
	if(pszDatabaseDir && (_tcslen(pszDatabaseDir) <= MAX_PATH ))
	{
		_tcscpy(gszDatabaseDirectory, pszDatabaseDir);
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\license\tlserver\setup\logfile.h ===
/*
 *  Copyright (c) 1998  Microsoft Corporation
 *
 *  Module Name:
 *
 *      logfile.h
 *
 *  Abstract:
 *
 *      This file contains code to log messages to a file.
 *
 *  Author:
 *
 *      Breen Hagan (BreenH) Oct-02-98
 *
 *  Environment:
 *
 *      User Mode
 */

#ifndef _LSOC_LOGFILE_H_
#define _LSOC_LOGFILE_H_

/*
 *  Constants.
 */

#define CRLF    "\r\n"

/*
 *  LogFile Class.
 */

class LogFile
{
public:

    //
    //  Constructor and destructor.
    //

LogFile(
    );

~LogFile(
    );

    //
    //  Standard functions.
    //

VOID
Close(
    VOID
    );

DWORD
Initialize(
    IN LPCTSTR  pszLogFile,
    IN LPCTSTR  pszLogModule
    );

DWORD
__cdecl
LogMessage(
    LPCTSTR pszFormat,
    ...
    );

private:
    BOOL    m_fInitialized;
    HANDLE  m_hFile;
    TCHAR   m_szLogFile[MAX_PATH + 1];
    TCHAR   m_szLogModule[MAX_PATH + 1];

};

    //
    //  The following permits a macro to reference a global variable for
    //  the log file without putting the 'extern ...' line in each source
    //  file. Because of this, however, logfile.h can not be included in
    //  a precompiled header.
    //

#ifndef _LSOC_LOGFILE_CPP_
extern LogFile  SetupLog;
#endif

#define LOGCLOSE        SetupLog.Close
#define LOGINIT(x, y)   SetupLog.Initialize(x, y)
#define LOGMESSAGE      SetupLog.LogMessage

#endif // _LSOC_LOGFILE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\license\tlserver\setup\logfile.cpp ===
/*
 *  Copyright (c) 1998  Microsoft Corporation
 *
 *  Module Name:
 *
 *      logfile.cpp
 *
 *  Abstract:
 *
 *      This file contains code to log messages to a file.
 *
 *  Author:
 *
 *      Breen Hagan (BreenH) Oct-02-98
 *
 *  Environment:
 *
 *      User Mode
 */

#define _LSOC_LOGFILE_CPP_

#include "stdafx.h"
#include "logfile.h"

/*
 *  Globals.
 */

LogFile SetupLog;

/*
 *  Constants.
 */

const UINT        LOG_ENTRY_SIZE             = 1024;
const UINT        S_SIZE                     = 1024;

/*
 *  Function prototypes.
 */

DWORD TCharStringToAnsiString(LPCTSTR, LPSTR);

/*
 *  Class LogFile.
 */

LogFile::LogFile(
    )
{
    m_fInitialized      = FALSE;
    m_szLogFile[0]      = (TCHAR)NULL;
    m_szLogModule[0]    = (TCHAR)NULL;
}

LogFile::~LogFile(
    )
{
}

VOID
LogFile::Close(
    VOID
    )
{
    if (m_fInitialized) {
        LogMessage(_T(CRLF));
        LogMessage(_T("**"));
        LogMessage(_T("** Closing Message Log for %s"), m_szLogModule);
        LogMessage(_T("**"));
        LogMessage(_T(CRLF));
        LogMessage(_T(CRLF));
        CloseHandle(m_hFile);
        m_fInitialized = FALSE;
    }
}

DWORD
LogFile::Initialize(
    IN LPCTSTR  pszLogFile,
    IN LPCTSTR  pszLogModule
    )
{
    OSVERSIONINFO   osVersion;
    TCHAR           pszDate[S_SIZE];
    TCHAR           pszTime[S_SIZE];

    //
    //  Initializing the log file twice is "A Bad Thing."
    //

    if (m_fInitialized) {
        LogMessage(_T("LogFile::Initialize called twice!"));
        return(ERROR_SUCCESS);
    }

    //
    //  Sanity checks. Pointless in a limited setting, but useful if this
    //  file is copied to other projects.
    //

    if ((pszLogFile == NULL) || (pszLogFile[0] == (TCHAR)NULL)) {
        return(ERROR_INVALID_PARAMETER);
    }

    if ((pszLogModule == NULL) || (pszLogModule[0] == (TCHAR)NULL)) {
        return(ERROR_INVALID_PARAMETER);
    }

    if ((_tcslen(pszLogFile) > MAX_PATH) ||
        (_tcslen(pszLogModule) > MAX_PATH)) {
        return(ERROR_INVALID_PARAMETER);
    }

    //
    //  Save the log file and module name.
    //

    _tcscpy(m_szLogFile, pszLogFile);
    _tcscpy(m_szLogModule, pszLogModule);

    //
    //  Open or create the log file.
    //

    m_hFile = CreateFile(
                pszLogFile,
                GENERIC_WRITE,
                0,
                NULL,
                OPEN_ALWAYS,
                0,
                NULL
                );
    if (m_hFile == INVALID_HANDLE_VALUE) {
        return(GetLastError());
    }

    m_fInitialized = TRUE;
    SetFilePointer(m_hFile, 0, NULL, FILE_END);

    //
    //  Get the current date and time for the log file.
    //

    _tstrdate(pszDate);
    _tstrtime(pszTime);

    LogMessage(_T("**"));
    LogMessage(_T("** Initializing Message Log for %s"), m_szLogModule);
    LogMessage(_T("** Date: %s Time: %s"), pszDate, pszTime);
    LogMessage(_T("**"));
    LogMessage(_T(CRLF));

    //
    //  Log information on the OS version.
    //

    osVersion.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);

    if (GetVersionEx(&osVersion) != 0) {

        LogMessage(
            _T("Version: %lu.%lu.%lu Platform: %lu, %s"),
            osVersion.dwMajorVersion,
            osVersion.dwMinorVersion,
            osVersion.dwBuildNumber,
            osVersion.dwPlatformId,
#ifdef DBG
            _T("Checked")
#else
            _T("Free")
#endif
            );
    }

    return(ERROR_SUCCESS);
}

/*
 *  LogFile::LogMessage()
 *
 *
 */

DWORD
__cdecl
LogFile::LogMessage(
    LPCTSTR pszFormat,
    ...
    )
{
    CHAR    cszOutput[LOG_ENTRY_SIZE];
    DWORD   cBytes;
    DWORD   cLength;
    TCHAR   tszOutput[LOG_ENTRY_SIZE];
    va_list vaList;

    if (!m_fInitialized) {
        return(ERROR_INVALID_HANDLE);
    }

    SetLastError(ERROR_SUCCESS);

    va_start(vaList, pszFormat);
    _vstprintf(tszOutput, pszFormat, vaList);
    va_end(vaList);

    cLength = TCharStringToAnsiString(tszOutput, cszOutput);

    if (cLength != (DWORD)-1) {
        WriteFile(m_hFile, cszOutput, cLength * sizeof(char), &cBytes, NULL);
        WriteFile(m_hFile, CRLF, strlen(CRLF) * sizeof(char), &cBytes, NULL);
    }

    return(GetLastError());
}

/*
 *
 *
 *
 */

DWORD
TCharStringToAnsiString(
    LPCTSTR tszStr,
    LPSTR   cszStr
    )
{
#ifdef UNICODE
    DWORD   cLength;

    cLength = WideCharToMultiByte(
                CP_ACP,
                0,
                tszStr,
                -1,
                NULL,
                0,
                NULL,
                NULL
                );

    if ((cLength == 0) || (cLength > S_SIZE)) {
        return((DWORD)-1);
    }

    cLength = WideCharToMultiByte(
                CP_ACP,
                0,
                tszStr,
                -1,
                cszStr,
                cLength,
                NULL,
                NULL
                );

    return(cLength);
#else
    _tcscpy(cszStr, tszStr);
    return(_tcslen(cszStr));
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\license\tlserver\setup\ocpage.cpp ===
/*
 *  Copyright (c) 1998  Microsoft Corporation
 *
 *  Module Name:
 *
 *      ocpage.cpp
 *
 *  Abstract:
 *
 *      This file defines an OC Manager Wizard Page base class.
 *
 *  Author:
 *
 *      Breen Hagan (BreenH) Oct-02-98
 *
 *  Environment:
 *
 *      User Mode
 */

#include "stdafx.h"
#include "logfile.h"

/*
 *  External Function Prototypes.
 */

HINSTANCE GetInstance();

INT_PTR CALLBACK
OCPage::PropertyPageDlgProc(
    HWND    hwndDlg,
    UINT    uMsg,
    WPARAM  wParam,
    LPARAM  lParam
    )
{
    OCPage  *pDlg;

    if (uMsg == WM_INITDIALOG) {
        pDlg = reinterpret_cast<OCPage*>(LPPROPSHEETPAGE(lParam)->lParam);
    } else {
        pDlg = reinterpret_cast<OCPage*>(GetWindowLongPtr(hwndDlg, DWLP_USER));
    }

    if (pDlg == NULL) {
        return(0);
    }

    switch(uMsg) {
    case WM_INITDIALOG:
        pDlg->SetDlgWnd(hwndDlg);
        SetWindowLongPtr(hwndDlg, DWLP_USER, (LONG_PTR)pDlg);
        return(pDlg->OnInitDialog(hwndDlg, wParam, lParam));

    case WM_NOTIFY:
        return(pDlg->OnNotify(hwndDlg, wParam, lParam));

    case WM_COMMAND:
        return(pDlg->OnCommand(hwndDlg, wParam, lParam));
    }

    return(0);
}


OCPage::OCPage ()
{
}

BOOL OCPage::Initialize ()
{
    dwFlags = PSP_USECALLBACK;

    pszHeaderTitle = MAKEINTRESOURCE(GetHeaderTitleResource());
    if (pszHeaderTitle) {
        dwFlags |= PSP_USEHEADERTITLE;
    }

    pszHeaderSubTitle = MAKEINTRESOURCE(GetHeaderSubTitleResource());
    if (pszHeaderSubTitle) {
        dwFlags |= PSP_USEHEADERSUBTITLE;
    }

    dwSize         = sizeof(PROPSHEETPAGE);
    hInstance      = GetInstance();
    pszTemplate    = MAKEINTRESOURCE(GetPageID());
    pfnDlgProc     = PropertyPageDlgProc;
    pfnCallback    = NULL;
    lParam         = (LPARAM)this;

    return(pszTemplate != NULL ? TRUE : FALSE);
}

OCPage::~OCPage()
{
}

BOOL
OCPage::OnNotify(
    HWND    hWndDlg,
    WPARAM  wParam,
    LPARAM  lParam
    )
{
    NMHDR *pnmh = (LPNMHDR) lParam;

    switch(pnmh->code)
    {
        case PSN_SETACTIVE:
            SetWindowLongPtr(hWndDlg, DWLP_MSGRESULT, CanShow() ? 0 : -1);
            PropSheet_SetWizButtons(GetParent(hWndDlg),
                PSWIZB_NEXT | PSWIZB_BACK);
            break;

        case PSN_WIZNEXT:
            SetWindowLongPtr(hWndDlg, DWLP_MSGRESULT, ApplyChanges() ? 0 : -1);
            break;

        case PSN_WIZBACK:
            SetWindowLongPtr(hWndDlg, DWLP_MSGRESULT, 0);
            break;

        default:
            return(FALSE);

    }

    UNREFERENCED_PARAMETER(lParam);
    UNREFERENCED_PARAMETER(wParam);
    return(TRUE);
}

BOOL
OCPage::OnCommand(
    HWND    hWndDlg,
    WPARAM  wParam,
    LPARAM  lParam
    )
{
    UNREFERENCED_PARAMETER(lParam);
    UNREFERENCED_PARAMETER(wParam);
    UNREFERENCED_PARAMETER(hWndDlg);
    return(TRUE);
}


BOOL OCPage::OnInitDialog(
    HWND    hWndDlg,
    WPARAM  wParam,
    LPARAM  lParam
    )
{
    UNREFERENCED_PARAMETER(lParam);
    UNREFERENCED_PARAMETER(wParam);
    UNREFERENCED_PARAMETER(hWndDlg);
    return(TRUE);
}

BOOL OCPage::ApplyChanges(
    )
{
    return(TRUE);
}

DWORD
OCPage::DisplayMessageBox(
    UINT        resText,
    UINT        resTitle,
    UINT        uType,
    int         *mbRetVal
    )
{
    return(::DisplayMessageBox(m_hDlgWnd, resText, resTitle, uType, mbRetVal));
}

DWORD
DisplayMessageBox(
    HWND        hWnd,
    UINT        resText,
    UINT        resTitle,
    UINT        uType,
    int         *mbRetVal
    )
{
    int     iRet;
    TCHAR   szResText[1024];
    TCHAR   szResTitle[1024];

    if (mbRetVal == NULL) {
        return(ERROR_INVALID_PARAMETER);
    }

    iRet = LoadString(
                GetInstance(),
                resText,
                szResText,
                1024
                );
    if (iRet == 0) {
        return(GetLastError());
    }

    iRet = LoadString(
                GetInstance(),
                resTitle,
                szResTitle,
                1024
                );
    if (iRet == 0) {
        return(GetLastError());
    }

    *mbRetVal = MessageBox(
                    hWnd,
                    szResText,
                    szResTitle,
                    uType
                    );

    return(*mbRetVal == 0 ? ERROR_OUTOFMEMORY : ERROR_SUCCESS);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\license\tlserver\setup\pages.cpp ===
/*
 *  Copyright (c) 1998  Microsoft Corporation
 *
 *  Module Name:
 *
 *      pages.cpp
 *
 *  Abstract:
 *
 *      This file defines the License Server Setup Wizard Page class.
 *
 *  Author:
 *
 *      Breen Hagan (BreenH) Oct-02-98
 *
 *  Environment:
 *
 *      User Mode
 */

#include "stdafx.h"
#include "pages.h"
#include "logfile.h"

extern BOOL gStandAlone;
extern BOOL gUnAttended;
TCHAR       gszInitialDir[MAX_PATH + 1];

BOOL        GetCurrentSelectionState(VOID);
BOOL        InWin2000Domain(VOID);
EInstall    GetInstallSection(VOID);
HINSTANCE   GetInstance(VOID);
EServerType GetServerRole(VOID);
DWORD       SetServerRole(UINT);

/*
 *  EnablePage::CanShow()
 *
 *  The page will only be displayed during standalone installations.
 */

BOOL
EnablePage::CanShow(
    )
{
    return((GetInstallSection() == kStandaloneInstall) && gStandAlone && !gUnAttended);
}

/*
 *  EnablePage::OnInitDialog()
 *
 *  Initializes the wizard page controls. If the machine is not a domain
 *  controller, the server type is reduced to plain server only.
 */

BOOL
EnablePage::OnInitDialog(
    HWND    hWndDlg,
    WPARAM  wParam,
    LPARAM  lParam
    )
{
    BOOL    fInDomain = InWin2000Domain();
    TCHAR   pszExpDir[MAX_PATH + 1];

    if (!fInDomain) {
        EnableWindow(
            GetDlgItem(GetDlgWnd(), IDC_RADIO_ENTERPRISE_SERVER),
            FALSE
            );
    }

    CheckRadioButton(
        GetDlgWnd(),
        IDC_RADIO_ENTERPRISE_SERVER,
        IDC_RADIO_PLAIN_SERVER,
        fInDomain ?
            (GetServerRole() == eEnterpriseServer ?
                IDC_RADIO_ENTERPRISE_SERVER :
                IDC_RADIO_PLAIN_SERVER
            ) :
            IDC_RADIO_PLAIN_SERVER
        );

    _tcscpy(gszInitialDir, GetDatabaseDirectory());
    ExpandEnvironmentStrings(gszInitialDir, pszExpDir, MAX_PATH);
    SetDlgItemText(GetDlgWnd(), IDC_EDIT_INSTALL_DIR, pszExpDir);

    UNREFERENCED_PARAMETER(lParam);
    UNREFERENCED_PARAMETER(wParam);
    UNREFERENCED_PARAMETER(hWndDlg);
    return(TRUE);
}

BOOL
EnablePage::OnCommand(
    HWND    hWndDlg,
    WPARAM  wParam,
    LPARAM  lParam
    )
{
    int iRet;

    if ((LOWORD(wParam) == IDC_BUTTON_BROWSE_DIR) &&
        (HIWORD(wParam) == BN_CLICKED))
    {
        BROWSEINFO brInfo;
        ZeroMemory(&brInfo, sizeof(brInfo));

        brInfo.hwndOwner = hWndDlg;

        TCHAR strText[1024];
        iRet = LoadString(
                    GetInstance(),
                    IDS_STRING_DIRECTORY_SELECT,
                    strText,
                    1024
                    );

        brInfo.lpszTitle = strText;

        LPITEMIDLIST pidl = SHBrowseForFolder(&brInfo);
        if (pidl) {
            TCHAR szDir[MAX_PATH + 1];
            SHGetPathFromIDList (pidl, szDir);
            SetDlgItemText(hWndDlg, IDC_EDIT_INSTALL_DIR, szDir);
        }
    }

    UNREFERENCED_PARAMETER(lParam);
    return(TRUE);
}

BOOL
EnablePage::ApplyChanges(
    )
{
    BOOL    fDirExists              = FALSE;
    DWORD   dwErr;
    int     iRet;
    TCHAR   szTxt[MAX_PATH + 1]         = _T("");
    TCHAR   szSubDir[]              = _T("\\LServer");
    TCHAR   szExpDir[MAX_PATH + 1];
    TCHAR   szExpInitDir[MAX_PATH + 1];

    if (GetDlgItemText(GetDlgWnd(), IDC_EDIT_INSTALL_DIR, szTxt,
        MAX_PATH) == 0) {

        //
        //  Complain about blank entries.
        //

        DisplayMessageBox(
            IDS_STRING_INVLID_INSTALLATION_DIRECTORY,
            IDS_MAIN_TITLE,
            MB_OK,
            &iRet
            );

        return(FALSE);
    }

    //
    //  Verify the string is not too long, expanding environment strings
    //  in the process.
    //

    if (ExpandEnvironmentStrings(szTxt, szExpDir, MAX_PATH) > MAX_PATH) {
        DisplayMessageBox(
            IDS_STRING_INVLID_INSTALLATION_DIRECTORY,
            IDS_MAIN_TITLE,
            MB_OK,
            &iRet
            );

        return(FALSE);
    }

    //
    //  If the entry is still the original default directory, no more
    //  verification is necessary.
    //

    ExpandEnvironmentStrings(gszInitialDir, szExpInitDir, MAX_PATH);
    if (_tcsicmp(szExpDir, szExpInitDir) == 0) {
        goto DirCreation;
    }

    //
    //  Check for directory existance before appending a subdirectory.
    //  This will prevent the user chosen directory of "C:\", for
    //  example, from prompting the user to create the directory.
    //

    fDirExists = SetCurrentDirectory(szExpDir);

    //
    //  The user has chosen a different directory. To protect its
    //  contents during uninstall, the TLServer subdirectory will be
    //  used.
    //

    if ((_tcslen(szExpDir) + _tcslen(szSubDir) + 1) > MAX_PATH) {
        DisplayMessageBox(
            IDS_STRING_INVLID_INSTALLATION_DIRECTORY,
            IDS_MAIN_TITLE,
            MB_OK,
            &iRet
            );

        return(FALSE);
    }

    _tcscat(szExpDir, szSubDir);
    _tcscat(szTxt, szSubDir);

    //
    //  Verify the user's directory choice is valid, e.g. no floppy
    //  drives, CD-ROMs, network paths, etc.
    //

    if (CheckDatabaseDirectory(szExpDir) != ERROR_SUCCESS) {
        DisplayMessageBox(
            IDS_STRING_INVLID_INSTALLATION_DIRECTORY,
            IDS_MAIN_TITLE,
            MB_OK,
            &iRet
            );

        return(FALSE);
    }

    //
    //  Prompt to create the directory if necessary.
    //

    if (!fDirExists) {
        DisplayMessageBox(
            IDS_STRING_CREATE_INSTALLATION_DIRECTORY,
            IDS_MAIN_TITLE,
            MB_OKCANCEL,
            &iRet
            );

        if (iRet != IDOK) {
            return(FALSE);
        }
    }

    //
    //  The selected directory has passed all the tests, but it may
    //  still not be created. If creation fails, let the user know,
    //  and let s/he choose another directory.
    //

DirCreation:
    SetDatabaseDirectory(szTxt);

    dwErr = CreateDatabaseDirectory();
    if (dwErr != ERROR_SUCCESS) {
        DisplayMessageBox(
            IDS_STRING_CANT_CREATE_INSTALLATION_DIRECTORY,
            IDS_MAIN_TITLE,
            MB_OK,
            &iRet
            );

        return(FALSE);
    }

    SetServerRole(IsDlgButtonChecked (
                    GetDlgWnd(), IDC_RADIO_ENTERPRISE_SERVER) == BST_CHECKED ?
                    eEnterpriseServer : ePlainServer);

    return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\license\tlserver\setup\ocpage.h ===
/*
 *  Copyright (c) 1998  Microsoft Corporation
 *
 *  Module Name:
 *
 *      ocpage.h
 *
 *  Abstract:
 *
 *      This file defines an OC Manager Wizard Page base class.
 *
 *  Author:
 *
 *      Breen Hagan (BreenH) Oct-02-98
 *
 *  Environment:
 *
 *      User Mode
 */

#ifndef _LSOC_OCPAGE_H_
#define _LSOC_OCPAGE_H_


class OCPage : public PROPSHEETPAGE
{
public:

    //
    //  Constructor and destructor.
    //

OCPage(
    );


virtual
~OCPage(
    );

    //
    //  Standard functions.
    //

HWND
GetDlgWnd(
    )
{
    return m_hDlgWnd;
}

BOOL
Initialize(
    );

BOOL
OnNotify(
    HWND    hWndDlg,
    WPARAM  wParam,
    LPARAM  lParam
    );

    //
    //  Virtual functions.
    //

virtual BOOL
ApplyChanges(
    );

virtual BOOL
CanShow(
    ) = 0;

virtual UINT
GetPageID(
    ) = 0;

virtual UINT
GetHeaderTitleResource(
    ) = 0;

virtual UINT
GetHeaderSubTitleResource(
    ) = 0;

virtual BOOL
OnCommand(
    HWND    hWndDlg,
    WPARAM  wParam,
    LPARAM  lParam
    );

virtual BOOL
OnInitDialog(
    HWND    hWndDlg,
    WPARAM  wParam,
    LPARAM  lParam
    );

    //
    //  Callback functions.
    //

static INT_PTR CALLBACK
PropertyPageDlgProc(
    HWND    hWndDlg,
    UINT    uMsg,
    WPARAM  wParam,
    LPARAM  lParam
    );

protected:
    HWND    m_hDlgWnd;

DWORD
DisplayMessageBox(
    UINT        resText,
    UINT        resTitle,
    UINT        uType,
    int         *mbRetVal
    );

VOID
SetDlgWnd(
    HWND    hwndDlg
    )
{
    m_hDlgWnd = hwndDlg;
}

};

DWORD
DisplayMessageBox(
    HWND        hWnd,
    UINT        resText,
    UINT        resTitle,
    UINT        uType,
    int         *mbRetVal
    );

#endif // _LSOC_OCPAGE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\license\tlserver\setup\pages.h ===
/*
 *  Copyright (c) 1998  Microsoft Corporation
 *
 *  Module Name:
 *
 *      pages.h
 *
 *  Abstract:
 *
 *      This file defines the License Server Setup Wizard Page class.
 *
 *  Author:
 *
 *      Breen Hagan (BreenH) Oct-02-98
 *
 *  Environment:
 *
 *      User Mode
 */

#ifndef __LSOC_PAGES_H__
#define __LSOC_PAGES_H__

#include "ocpage.h"

class EnablePage : public OCPage
{
private:

BOOL
CanShow(
    );

BOOL
OnInitDialog(
    HWND    hwndDlg,
    WPARAM  wParam,
    LPARAM  lParam
    );

BOOL
OnCommand(
    HWND    hWndDlg,
    WPARAM  wParam,
    LPARAM  lParam
    );

BOOL
ApplyChanges(
    );

UINT
GetPageID(
    )
{
    return(IDD_PROPPAGE_LICENSESERVICES);
}

UINT
GetHeaderTitleResource(
    )
{
    return(IDS_MAIN_TITLE);
}

UINT
GetHeaderSubTitleResource(
    )
{
    return(IDS_SUB_TITLE);
}

};

#endif // __LSOC_PAGES_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\license\tlserver\setup\registry.h ===
/*
 *  Copyright (c) 1998  Microsoft Corporation
 *
 *  Module Name:
 *
 *      registry.h
 *
 *  Abstract:
 *
 *      This file handles registry actions needed by License Server setup.
 *
 *  Author:
 *
 *      Breen Hagan (BreenH) Oct-02-98
 *
 *  Environment:
 *
 *      User Mode
 */

#ifndef _LSOC_REGISTRY_H_
#define _LSOC_REGISTRY_H_

/*
 *  Function Prototypes.
 */

DWORD
CreateRegistrySettings(
    LPCTSTR pszDatabaseDirectory,
    DWORD   dwServerRole
    );

LPCTSTR
GetDatabaseDirectoryFromRegistry(
    VOID
    );

DWORD
GetServerRoleFromRegistry(
    VOID
    );

DWORD
RemoveRegistrySettings(
    VOID
    );

#endif // _LSOC_REGISTRY_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\license\tlserver\setup\resource.h ===
//+--------------------------------------------------------------------------
//
// Copyright (c) 1997-1999 Microsoft Corporation
//
// File:       resource.h 
//
// Contents:    
//
// History:     
//
//---------------------------------------------------------------------------
#include <ntverp.h>

#define	VER_FILETYPE	VFT_APP
#define	VER_FILESUBTYPE	VFT2_UNKNOWN
#define VER_FILEDESCRIPTION_STR     "License Server Optional Component Setup"
#define VER_INTERNALNAME_STR        "licenoc"
#define VER_ORIGINALFILENAME_STR    "licenoc.dll"

#include "common.ver"

#define IDS_STRING_DIRECTORY_SELECT                     1
#define IDS_STRING_INVLID_INSTALLATION_DIRECTORY        2
#define IDS_STRING_CREATE_INSTALLATION_DIRECTORY        3
#define IDS_STRING_CANT_CREATE_INSTALLATION_DIRECTORY   4
#define IDS_MAIN_TITLE                                  5
#define IDS_SUB_TITLE                                   6
#define IDS_STRING_LICENSES_GO_BYE_BYE                  7
#define IDS_INSUFFICIENT_PERMISSION                     8

#define IDD_PROPPAGE_LICENSESERVICES    110
#define IDC_EDIT_INSTALL_DIR            1000
#define IDC_BUTTON_BROWSE_DIR           1001
#define IDC_RADIO_ENTERPRISE_SERVER     1002
#define IDC_RADIO_PLAIN_SERVER          1003
#define IDC_STATIC                      -1
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\license\tlserver\setup\registry.cpp ===
/*
 *  Copyright (c) 1998  Microsoft Corporation
 *
 *  Module Name:
 *
 *      registry.cpp
 *
 *  Abstract:
 *
 *      This file handles registry actions needed by License Server setup.
 *
 *  Author:
 *
 *      Breen Hagan (BreenH) Oct-02-98
 *
 *  Environment:
 *
 *      User Mode
 */

#include "stdafx.h"
#include "logfile.h"

/*
 *  Global variables.
 */


/*
 *  Constants.
 */

const TCHAR gszLSParamKey[] =
    _T("System\\CurrentControlSet\\Services\\TermServLicensing\\Parameters");
const TCHAR gszDatabasePathValue[]  = _T("DBPath");
const TCHAR gszServerRoleValue[]    = _T("Role");

/*
 *  Function prototypes.
 */


/*
 *  Function implementations.
 */

DWORD
CreateRegistrySettings(
    LPCTSTR pszDatabaseDirectory,
    DWORD   dwServerRole
    )
{
    DWORD   dwErr, dwDisposition;
    HKEY    hLSParamKey;

    LOGMESSAGE(_T("CreateRegistrySettings: Entered with %s, %ld"),
        pszDatabaseDirectory, dwServerRole);

    dwErr = RegCreateKeyEx(
                HKEY_LOCAL_MACHINE,
                gszLSParamKey,
                0,
                NULL,
                REG_OPTION_NON_VOLATILE,
                KEY_ALL_ACCESS,
                NULL,
                &hLSParamKey,
                &dwDisposition
                );
    if (dwErr != ERROR_SUCCESS) {
        LOGMESSAGE(_T("CreateRegistrySettings: RegCreateKeyEx: Error %ld"),
            dwErr);
        return(dwErr);
    }

    dwErr = RegSetValueEx(
                hLSParamKey,
                gszDatabasePathValue,
                0,
                REG_EXPAND_SZ,
                (LPBYTE)pszDatabaseDirectory,
                (_tcslen(pszDatabaseDirectory) + 1) * sizeof(TCHAR)
                );
    if (dwErr != ERROR_SUCCESS) {
        RegCloseKey(hLSParamKey);
        LOGMESSAGE(_T("CreateRegistrySettings: RegSetValueEx: %s: Error %ld"),
            _T("DatabasePath"), dwErr);
        return(dwErr);
    }

    dwErr = RegSetValueEx(
                hLSParamKey,
                gszServerRoleValue,
                0,
                REG_DWORD,
                (LPBYTE)&dwServerRole,
                sizeof(DWORD)
                );
    if (dwErr != ERROR_SUCCESS) {
        RegCloseKey(hLSParamKey);
        LOGMESSAGE(_T("CreateRegistrySettings: RegSetValueEx: %s: Error %ld"),
            _T("ServerRole"), dwErr);
        return(dwErr);
    }

    RegCloseKey(hLSParamKey);
    return(ERROR_SUCCESS);
}

LPCTSTR
GetDatabaseDirectoryFromRegistry(
    VOID
    )
{
    static TCHAR    pRegValue[MAX_PATH + 1];
    DWORD           dwErr, cbRegValue = (MAX_PATH * sizeof(TCHAR));
    HKEY            hLSParamKey;

    dwErr = RegOpenKeyEx(
                HKEY_LOCAL_MACHINE,
                gszLSParamKey,
                0,
                KEY_READ,
                &hLSParamKey
                );
    if (dwErr != ERROR_SUCCESS) {
        return(NULL);
    }

    dwErr = RegQueryValueEx(
                hLSParamKey,
                gszDatabasePathValue,
                NULL,
                NULL,
                (LPBYTE)pRegValue,
                &cbRegValue
                );
	RegCloseKey(hLSParamKey);
    if (dwErr != ERROR_SUCCESS) {		
        return(NULL);
    }
    return(pRegValue);
}

DWORD
GetServerRoleFromRegistry(
    VOID
    )
{
    DWORD   dwErr, dwValue, cbValue = sizeof(DWORD);
    HKEY    hLSParamKey;

    dwErr = RegOpenKeyEx(
                HKEY_LOCAL_MACHINE,
                gszLSParamKey,
                0,
                KEY_READ,
                &hLSParamKey
                );
    if (dwErr != ERROR_SUCCESS) {
        SetLastError(dwErr);
        return((DWORD)-1);
    }

    dwErr = RegQueryValueEx(
                hLSParamKey,
                gszServerRoleValue,
                NULL,
                NULL,
                (LPBYTE)&dwValue,
                &cbValue
                );
	RegCloseKey(hLSParamKey);
    if (dwErr != ERROR_SUCCESS) {
        SetLastError(dwErr);		
        return((DWORD)-1);
    }
    return(dwValue);
}

DWORD
RemoveRegistrySettings(
    VOID
    )
{
    DWORD   dwErr;
    HKEY    hLSParamKey;

    dwErr = RegOpenKeyEx(
                HKEY_LOCAL_MACHINE,
                gszLSParamKey,
                0,
                KEY_ALL_ACCESS,
                &hLSParamKey
                );
    if (dwErr != ERROR_SUCCESS) {
        return(dwErr);
    }

    dwErr = RegDeleteValue(
                hLSParamKey,
                gszDatabasePathValue
                );
    if (dwErr != ERROR_SUCCESS) {
        RegCloseKey(hLSParamKey);
        return(dwErr);
    }

    dwErr = RegDeleteValue(
                hLSParamKey,
                gszServerRoleValue
                );
    if (dwErr != ERROR_SUCCESS) {
        RegCloseKey(hLSParamKey);
        return(dwErr);
    }

    RegCloseKey(hLSParamKey);
    return(ERROR_SUCCESS);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\license\tlserver\setup\services.cpp ===
//+--------------------------------------------------------------------------
//
// Copyright (c) 1997-1999 Microsoft Corporation
//
// File:       services.cpp 
//
// Contents:    
//
// History:     
//
//---------------------------------------------------------------------------
#include "stdafx.h"
#include "logfile.h"

/*
 *  Constants.
 */

const UINT  SECTION_SIZE        = 256;
const TCHAR SERVICE_DEL_KEY[]   = _T("DelService");
const UINT  SERVICE_DEL_NAME    = 1;
const TCHAR SERVICE_START_KEY[] = _T("StartService");
const UINT  SERVICE_START_NAME  = 1;

/*
 *  Helper Functions.
 */

VOID
ProcessDelService(
    IN SC_HANDLE    schSCManager,
    IN LPCTSTR      pszServiceName
    )
{
    SC_HANDLE       schService;
    SERVICE_STATUS  ssStatus;

    schService = OpenService(schSCManager, pszServiceName, SERVICE_ALL_ACCESS);
    if (!schService) {
        LOGMESSAGE(_T("ProcessDelService: Can't open service %s"),
            pszServiceName);
        return;
    }

    if (ControlService(schService, SERVICE_CONTROL_STOP, &ssStatus)) {
        Sleep(1000);

        while(QueryServiceStatus(schService, &ssStatus)) {
            if (ssStatus.dwCurrentState == SERVICE_STOP_PENDING) {
                Sleep(1000);
            } else {
                break;
            }
        }

        if (ssStatus.dwCurrentState != SERVICE_STOPPED) {
            LOGMESSAGE(_T("ProcessDelService: Couldn't stop service %s"),
                pszServiceName);
        }
    } else {
        LOGMESSAGE(_T("ProcessDelService: Couldn't control service %s"),
            pszServiceName);
    }

    if (DeleteService(schService)) {
        LOGMESSAGE(_T("ProcessDelService: %s deleted"), pszServiceName);
    } else {
        LOGMESSAGE(_T("ProcessDelService: Couldn't delete service %s"),
            pszServiceName);
    }

    CloseServiceHandle(schService);
}

VOID
ProcessStartService(
    IN SC_HANDLE    schSCManager,
    IN LPCTSTR      pszServiceName
    )
{
    SC_HANDLE       schService;
    SERVICE_STATUS  ssStatus;

    schService = OpenService(schSCManager, pszServiceName, SERVICE_ALL_ACCESS);
    if (!schService) {
        LOGMESSAGE(_T("ProcessStartService: Can't open service %s"),
            pszServiceName);
        return;
    }

    if (StartService(schService, 0, NULL)) {
        Sleep(1000);

        while(QueryServiceStatus(schService, &ssStatus)) {
            if (ssStatus.dwCurrentState == SERVICE_START_PENDING) {
                Sleep(1000);
            } else {
                break;
            }
        }

        if (ssStatus.dwCurrentState == SERVICE_RUNNING) {
            LOGMESSAGE(_T("ProcessStartService: %s started"),
                pszServiceName);
        } else {
            LOGMESSAGE(_T("ProcessStartService: Couldn't start service %s"),
                pszServiceName);
        }
    } else {
        LOGMESSAGE(_T("ProcessStartService: Couldn't control service %s"),
            pszServiceName);
    }

    CloseServiceHandle(schService);
}

/*
 *  ServiceDeleteFromInfSection()
 *
 *  Handles service deletion from inf sections in the form of:
 *
 *  [SectionName]
 *  DelService  = Service1
 *  DelService  = Service2
 *
 *  where Service1 and Service2 are service names.
 */

DWORD
ServiceDeleteFromInfSection(
    IN HINF     hInf,
    IN LPCTSTR  pszSection
    )
{
    BOOL        fErr;
    BOOL        fFound;
    INFCONTEXT  infContext;
    SC_HANDLE   schSCManager;

    schSCManager = OpenSCManager(
                        NULL,
                        NULL,
                        SC_MANAGER_ALL_ACCESS
                        );
    if (!schSCManager) {
        LOGMESSAGE(_T("ServiceDeleteFromInfSection: Failed to open SC Manager"));
        return(GetLastError());
    }

    fFound = SetupFindFirstLine(
                hInf,
                pszSection,
                SERVICE_DEL_KEY,
                &infContext
                );

    while (fFound) {
        TCHAR   pszServiceName[SECTION_SIZE];

        fErr = SetupGetStringField(
                    &infContext,
                    SERVICE_DEL_NAME,
                    pszServiceName,
                    SECTION_SIZE,
                    NULL
                    );
        if (fErr) {
            ProcessDelService(schSCManager, pszServiceName);
        } else {
            LOGMESSAGE(_T("ServiceDeleteFromInfSection: Could not get service section."));
        }

        fFound = SetupFindNextMatchLine(
                    &infContext,
                    SERVICE_DEL_KEY,
                    &infContext
                    );
    }

    CloseServiceHandle(schSCManager);
    return(ERROR_SUCCESS);
}

/*
 *  ServiceStartFromInfSection()
 *
 *  Starts a service that has been installed by setupapi.
 *
 */

DWORD
ServiceStartFromInfSection(
    IN HINF     hInf,
    IN LPCTSTR  pszSection
    )
{
    BOOL        fErr;
    BOOL        fFound;
    INFCONTEXT  infContext;
    SC_HANDLE   schSCManager;

    schSCManager = OpenSCManager(
                        NULL,
                        NULL,
                        SC_MANAGER_ALL_ACCESS
                        );
    if (!schSCManager) {
        LOGMESSAGE(_T("ServiceStartFromInfSection: Failed to open SC Manager"));
        return(GetLastError());
    }

    fFound = SetupFindFirstLine(
                hInf,
                pszSection,
                SERVICE_START_KEY,
                &infContext
                );

    while (fFound) {
        TCHAR   pszServiceName[SECTION_SIZE];

        fErr = SetupGetStringField(
                    &infContext,
                    SERVICE_START_NAME,
                    pszServiceName,
                    SECTION_SIZE,
                    NULL
                    );
        if (fErr) {
            ProcessStartService(schSCManager, pszServiceName);
        } else {
            LOGMESSAGE(_T("ServiceStartFromInfSection: Could not get service section."));
        }

        fFound = SetupFindNextMatchLine(
                    &infContext,
                    SERVICE_START_KEY,
                    &infContext
                    );
    }

    CloseServiceHandle(schSCManager);
    return(ERROR_SUCCESS);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\license\tlserver\setup\services.h ===
//+--------------------------------------------------------------------------
//
// Copyright (c) 1997-1999 Microsoft Corporation
//
// File:       services.h 
//
// Contents:    
//
// History:     
//
//---------------------------------------------------------------------------
/*
 */

#ifndef _LSOC_SERVICES_H_
#define _LSOC_SERVICES_H_

DWORD
ServiceDeleteFromInfSection(
    IN HINF     hInf,
    IN LPCTSTR  pszSection
    );

DWORD
ServiceStartFromInfSection(
    IN HINF     hInf,
    IN LPCTSTR  pszSection
    );

#endif // _LSOC_SERVICES_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\license\tlserver\setup\stdafx.h ===
/*
 *  Copyright (c) 1996  Microsoft Corporation
 *
 *  Module Name:
 *
 *
 *  Abstract:
 *
 *
 *  Author:
 *
 *
 *  Environment:
 *
 *    User Mode
 */

#include <windows.h>

#include <stdio.h>
#include <tchar.h>
#include <time.h>

#include <setupapi.h>
#include <ocmanage.h>

#include <shellapi.h>
#include <shlobj.h>

#include <commdlg.h>

#include <dsrole.h>
#include <dsgetdc.h>

#include <esetup.h>

#include "licenoc.h"
#include "resource.h"
#include "ocpage.h"
#include "pages.h"
#include "dir.h"
#include "registry.h"
#include "services.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\license\tlserver\setup\stdafx.cpp ===
//+--------------------------------------------------------------------------
//
// Copyright (c) 1997-1999 Microsoft Corporation
//
//---------------------------------------------------------------------------
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

// EOF
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\license\tlserver\setup\sources.inc ===
!IF 0

Copyright (c) 1989  Microsoft Corporation

Module Name:

    sources.inc

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


Author:

    Makarand Patwardhan (makarp)

!ENDIF

TERMSRV_ROOT = ..\..\..\..
TL_SERVER_DIR = ..\..

INCLUDES=                                               \
        ..;                                             \
        $(TL_SERVER_DIR)\include;                    \
        $(TL_SERVER_DIR)\upg4to5;

MAJORCOMP=LicenOC

TARGETPATH=obj
TARGETTYPE=DYNLINK

DLLDEF=..\LicenOC.def
DLLBASE=0x2000000
DLLENTRY=_DllMainCRTStartup
USE_MSVCRT=1

C_DEFINES=$(C_DEFINES) -DLICENOC_SMALL_UPG

PRECOMPILED_INCLUDE = ..\stdafx.h
PRECOMPILED_SOURCEFILE = ..\stdafx.cpp
PRECOMPILED_CXX = 1

SOURCES=                    \
        ..\licenoc.cpp      \
        ..\licenoc.rc       \
        ..\registry.cpp     \
        ..\services.cpp     \
        ..\ocpage.cpp       \
        ..\pages.cpp        \
        ..\dir.cpp          \
        ..\logfile.cpp


TARGETLIBS=                                         \
        $(SDK_LIB_PATH)\activeds.lib    \
        $(SDK_LIB_PATH)\adsiid.lib      \
        $(SDK_LIB_PATH)\advapi32.lib    \
        $(SDK_LIB_PATH)\comctl32.lib    \
        $(SDK_LIB_PATH)\esent.lib       \
        $(SDK_LIB_PATH)\kernel32.lib    \
        $(SDK_LIB_PATH)\netapi32.lib    \
        $(SDK_LIB_PATH)\ntdsapi.lib     \
        $(SDK_LIB_PATH)\user32.lib      \
        $(SDK_LIB_PATH)\odbc32.lib      \
        $(SDK_LIB_PATH)\ole32.lib       \
        $(SDK_LIB_PATH)\oleaut32.lib    \
        $(SDK_LIB_PATH)\setupapi.lib    \
        $(SDK_LIB_PATH)\shell32.lib     \
        $(SDK_LIB_PATH)\uuid.lib        \
        $(TERMSRV_ROOT)\lib\$(O)\esetup.lib        \
        $(TERMSRV_ROOT)\lib\$(O)\upg4db.lib        \
        $(TERMSRV_ROOT)\lib\$(O)\common.lib


386_WARNING_LEVEL=-W4
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\license\tlserver\setup\inf\sources.inc ===
#
# Copyright (c) Microsoft Corporation.  All rights reserved.
#

#
# This file is designed to be included from 2 levels below
# (ie, daytona\srv, daytona\wks, cairo\srv, or cairo\wks).
#

SYNCHRONIZE_BLOCK=1

MAJORCOMP=setup
MINORCOMP=infs

TARGETNAME=inf
TARGETPATH=obj
TARGETTYPE=notarget

#
# No explicit sources because build doesn't understand .inf files.
#
SOURCES=

#
# Use NTTARGETFILE0 macros to cause the infs to get built during
# the compile phase. We do this so that we can disable MP build for
# this directory, using BLOCK and DRAIN.
#
NTTARGETFILE0=make_infs

NO_BROWSER_FILE=1
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\license\tlserver\setup\inf\makefile.inc ===
#
# Copyright (c) Microsoft Corporation.  All rights reserved.
#
#
# For daytona, this file is designed to be included from 3 levels below
# ie, dayona\$(LANGUAGE)inf\srv, or daytona\$(LANGUAGE)inf\wks
#
# Note: NEC98 builds go through this file twice, the second time
# with "ALT_PROJECT"=="NEC_98".  These latter produce a subset
# of binaries which are only used on NEC98 machines.
#

!IFNDEF LANGUAGE
LANGUAGE=usa
!ENDIF

_LNG=..\..\$(LANGUAGE)
_INX=..\..
_INF=obj\$(TARGET_DIRECTORY)


make_infs:$(_INF)\licenoc.inf

$(_INF)\licenoc.inf: $(_INX)\licenoc.inx $(_LNG)\licenoc.txt
    copy $(_INX)\$(@B).inx+$(_LNG)\$(@B).txt $@
    $(BINPLACE_CMD)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\license\tlserver\setup\inf\daytona\usainf\makefile.inc ===
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\license\tlserver\setup\inf\daytona\chsinf\makefile.inc ===
LANGUAGE=CHS
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\license\tlserver\setup\inf\daytona\jpninf\makefile.inc ===
LANGUAGE=JPN
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\license\tlserver\setup\inf\daytona\korinf\makefile.inc ===
LANGUAGE=KOR
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\license\tlserver\setup\inf\daytona\chtinf\makefile.inc ===
LANGUAGE=CHT
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\license\tlserver\tls236\resource.h ===
//+--------------------------------------------------------------------------
//
// Copyright (c) 1997-1999 Microsoft Corporation
//
// File:       resource.h 
//
// Contents:    
//
// History:     
//
//---------------------------------------------------------------------------
#ifndef __RESOURCE_H__

#define IDS_COMPANYNAME             200
#define IDS_EX_PRODUCTNAME          201
#define IDS_EX_PRODUCTDESC          202
#define IDS_EX_PRODUCTDESC51        203

#define IDS_S_PRODUCTNAME           205
#define IDS_S_PRODUCTDESC           206
#define IDS_S_PRODUCTDESC51         211


#define IDS_I_PRODUCTNAME           212
#define IDS_I_PRODUCTDESC           213


#define IDS_C_PRODUCTNAME           214
#define IDS_C_PRODUCTDESC51         215


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\license\tlserver\tls236\dllmain.c ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996-1996
//
// File:        
//
// Contents:    
//
// History:     
//
//---------------------------------------------------------------------------
#include <windows.h>
#include "license.h"
#include "tlsapi.h"

extern void InitPolicyModule(HMODULE hModule);

BOOL WINAPI 
DllMain(
    IN HINSTANCE hInstance,
    IN DWORD     reason,
    IN LPVOID    reserved
    )
/*++

++*/
{
    BOOL b;

    UNREFERENCED_PARAMETER(reserved);
    b = TRUE;

    switch(reason)
    {
        case DLL_PROCESS_ATTACH:
            InitPolicyModule( hInstance );
            break;

        case DLL_THREAD_ATTACH:
            break;

        case DLL_PROCESS_DETACH:
            break;

        case DLL_THREAD_DETACH:
            break;
    }

    return(b);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\license\tlserver\tls236\pch.cpp ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996-1997
//
// File:        pch.cpp
//
// Contents:    TLS236 policy module precompiled header
//
//---------------------------------------------------------------------------
#pragma warning(disable: 4018)
#pragma warning(disable: 4244)

#include "tlsassrt.h"

#include <windows.h>
#include <stdio.h>
#include <tchar.h>
#include <wincrypt.h>
#include "license.h"
#include "tlsapip.h"
#include "tls236.h"
#include "messages.h"
#include "resource.h"
#include "licekpak.h"

#pragma hdrstop
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\license\tlserver\tls236\request.cpp ===
//+--------------------------------------------------------------------------
//
// Copyright (c) 1997-1999 Microsoft Corporation
//
// File:        request.cpp
//
// Contents:    TLS236 policy module routines 
//
// History:     
//
//---------------------------------------------------------------------------
#include "pch.cpp"
#include <rpc.h>
#include <time.h>

#define STRSAFE_NO_DEPRECATE
#include <strsafe.h>

extern CClientMgr* g_ClientMgr;
HMODULE g_hInstance;

#define NUMBER_PRODUCTSTRING_RESOURCE   3
#define INDEX_COMPANYNAME               0
#define INDEX_PRODUCTNAME               1
#define INDEX_PRODUCTDESC               2


#define NUMBER_OF_CLIENT_OS             5
#define NUMBER_OF_TERMSRV_OS            4

#define DENY_BUILTIN                    0
#define ALLOW_BUILTIN                   1  


static char LicenseTable[NUMBER_OF_CLIENT_OS][NUMBER_OF_TERMSRV_OS] = 
{
	    {DENY_BUILTIN,  DENY_BUILTIN, DENY_BUILTIN, DENY_BUILTIN },
	    {ALLOW_BUILTIN, DENY_BUILTIN, DENY_BUILTIN, DENY_BUILTIN },
        {ALLOW_BUILTIN, DENY_BUILTIN, DENY_BUILTIN, DENY_BUILTIN },
	    {ALLOW_BUILTIN, DENY_BUILTIN, DENY_BUILTIN, DENY_BUILTIN },
        {ALLOW_BUILTIN, DENY_BUILTIN, DENY_BUILTIN, DENY_BUILTIN }
};

//
// Windows 2000
//
LPTSTR g_pszUSFreeKeyPackProductDesc[NUMBER_PRODUCTSTRING_RESOURCE] = {
    US_IDS_COMPANYNAME,
    US_IDS_EX_PRODUCTNAME,
    US_IDS_EX_PRODUCTDESC
};

LPTSTR g_pszLocalizedFreeKeyPackProductDesc[NUMBER_PRODUCTSTRING_RESOURCE] = {
    NULL,
    NULL,
    NULL
};
    
LPTSTR g_pszUSStandardKeyPackProductString[NUMBER_PRODUCTSTRING_RESOURCE] = {
    US_IDS_COMPANYNAME,
    US_IDS_S_PRODUCTNAME,
    US_IDS_S_PRODUCTDESC
};

LPTSTR g_pszLocalizedStandardKeyPackProductString[NUMBER_PRODUCTSTRING_RESOURCE] = {
    NULL,
    NULL,
    NULL
};


LPTSTR g_pszUSInternetKeyPackProductDesc [NUMBER_PRODUCTSTRING_RESOURCE] = {
    US_IDS_COMPANYNAME,
    US_IDS_I_PRODUCTNAME,
    US_IDS_I_PRODUCTDESC
};

LPTSTR g_pszLocalizedInternetKeyPackProductDesc [NUMBER_PRODUCTSTRING_RESOURCE] = {
    NULL,
    NULL,
    NULL,
};


//
// Whistler
//
   
LPTSTR g_pszUSStandardKeyPackProductString51[NUMBER_PRODUCTSTRING_RESOURCE] = {
    US_IDS_COMPANYNAME,
    US_IDS_S_PRODUCTNAME,
    US_IDS_S_PRODUCTDESC51
};

LPTSTR g_pszLocalizedStandardKeyPackProductString51[NUMBER_PRODUCTSTRING_RESOURCE] = {
    NULL,
    NULL,
    NULL
};


LPTSTR g_pszUSConcurrentKeyPackProductDesc51 [NUMBER_PRODUCTSTRING_RESOURCE] = {
    US_IDS_COMPANYNAME,
    US_IDS_C_PRODUCTNAME,
    US_IDS_C_PRODUCTDESC51
};

LPTSTR g_pszLocalizedConcurrentKeyPackProductDesc51 [NUMBER_PRODUCTSTRING_RESOURCE] = {
    NULL,
    NULL,
    NULL,
};




PMSUPPORTEDPRODUCT g_pszSupportedProduct[] = {
    { TERMSERV_PRODUCTID_CH, TERMSERV_PRODUCTID_SKU},
    { TERMSERV_INTERNET_CH, TERMSERV_INTERNET_SKU},
    { TERMSERV_CONCURRENT_CH, TERMSERV_CONCURRENT_SKU},
    { TERMSERV_WHISTLER_PRODUCTID_CH, TERMSERV_PRODUCTID_SKU}
};
    
DWORD g_dwNumSupportedProduct = sizeof(g_pszSupportedProduct)/sizeof(g_pszSupportedProduct[0]);

DWORD g_dwVersion=CURRENT_TLSA02_VERSION;

////////////////////////////////////////////////////////
LPTSTR
LoadProductDescFromResource(
    IN DWORD dwResId,
    IN DWORD dwMaxSize
    )
/*++

    Internal Routine

--*/
{
    LPTSTR pszString = NULL;

    pszString = (LPTSTR) MALLOC( sizeof(TCHAR) * (dwMaxSize + 1) );
    if(pszString != NULL)
    {
        if(LoadResourceString(dwResId, pszString, dwMaxSize + 1) == FALSE)
        {
            FREE(pszString);
        }
    }


    return pszString;
}

//-----------------------------------------------------
void
FreeProductDescString()
{
    for(int i=0; 
        i < sizeof(g_pszLocalizedFreeKeyPackProductDesc)/sizeof(g_pszLocalizedFreeKeyPackProductDesc[0]);
        i++)
    {
        if(g_pszLocalizedFreeKeyPackProductDesc[i] != NULL)
        {
            FREE(g_pszLocalizedFreeKeyPackProductDesc[i]);
            g_pszLocalizedFreeKeyPackProductDesc[i] = NULL;
        }
    }


    for(i=0; 
        i < sizeof(g_pszLocalizedStandardKeyPackProductString)/sizeof(g_pszLocalizedStandardKeyPackProductString[0]);
        i++)
    {
        if(g_pszLocalizedStandardKeyPackProductString[i] != NULL)
        {
            FREE(g_pszLocalizedStandardKeyPackProductString[i]);
            g_pszLocalizedStandardKeyPackProductString[i] = NULL;
        }
    }

    for(i=0; 
        i < sizeof(g_pszLocalizedInternetKeyPackProductDesc)/sizeof(g_pszLocalizedInternetKeyPackProductDesc[0]);
        i++)
    {
        if(g_pszLocalizedInternetKeyPackProductDesc[i] != NULL)
        {
            FREE(g_pszLocalizedInternetKeyPackProductDesc[i]);
            g_pszLocalizedInternetKeyPackProductDesc[i] = NULL;
        }
    }

    for(i=0; 
        i < sizeof(g_pszLocalizedConcurrentKeyPackProductDesc51)/sizeof(g_pszLocalizedConcurrentKeyPackProductDesc51[0]);
        i++)
    {
        if(g_pszLocalizedConcurrentKeyPackProductDesc51[i] != NULL)
        {
            FREE(g_pszLocalizedConcurrentKeyPackProductDesc51[i]);
            g_pszLocalizedConcurrentKeyPackProductDesc51[i] = NULL;
        }
    }

    return;
}


////////////////////////////////////////////////////////
void
InitPolicyModule(
    IN HMODULE hModule
    )
/*++

    Initialize policy module, ignore error if we can't find localized string, we always
    insert a english product desc.

--*/
{
    BOOL bSuccess = TRUE;
    g_hInstance = hModule;

    //
    // Build IN CAL product desc.
    //
    g_pszLocalizedFreeKeyPackProductDesc[INDEX_COMPANYNAME] = 
        LoadProductDescFromResource(
                                    IDS_COMPANYNAME,
                                    MAX_TERMSRV_PRODUCTID + 1
                                    );

    if(g_pszLocalizedFreeKeyPackProductDesc[INDEX_COMPANYNAME] == NULL)
    {
        bSuccess = FALSE;
        goto cleanup;
    }

    g_pszLocalizedFreeKeyPackProductDesc[INDEX_PRODUCTNAME] =
        LoadProductDescFromResource(
                                    IDS_EX_PRODUCTNAME,
                                    MAX_TERMSRV_PRODUCTID + 1
                                    );

    if(g_pszLocalizedFreeKeyPackProductDesc[INDEX_PRODUCTNAME] == NULL)
    {
        bSuccess = FALSE;
        goto cleanup;
    }


    g_pszLocalizedFreeKeyPackProductDesc[INDEX_PRODUCTDESC] = 
        LoadProductDescFromResource(
                                    IDS_EX_PRODUCTDESC,
                                    MAX_TERMSRV_PRODUCTID + 1
                                    );

    if(g_pszLocalizedFreeKeyPackProductDesc[INDEX_PRODUCTDESC] == NULL)
    {
        bSuccess = FALSE;
        goto cleanup;
    }
    
    //
    // FULL CAL product Desc.
    //
    g_pszLocalizedStandardKeyPackProductString[INDEX_COMPANYNAME] =
        LoadProductDescFromResource(
                                    IDS_COMPANYNAME,
                                    MAX_TERMSRV_PRODUCTID + 1
                                    );

    if(g_pszLocalizedStandardKeyPackProductString[INDEX_COMPANYNAME] == NULL)
    {
        bSuccess = FALSE;
        goto cleanup;
    }


    g_pszLocalizedStandardKeyPackProductString[INDEX_PRODUCTNAME] =
        LoadProductDescFromResource(
                                    IDS_S_PRODUCTNAME,
                                    MAX_TERMSRV_PRODUCTID + 1
                                    );

    if(g_pszLocalizedStandardKeyPackProductString[INDEX_PRODUCTNAME] == NULL)
    {
        bSuccess = FALSE;
        goto cleanup;
    }

    g_pszLocalizedStandardKeyPackProductString[INDEX_PRODUCTDESC] =
        LoadProductDescFromResource(
                                    IDS_S_PRODUCTDESC,
                                    MAX_TERMSRV_PRODUCTID + 1
                                    );

    if(g_pszLocalizedStandardKeyPackProductString[INDEX_PRODUCTDESC] == NULL)
    {
        bSuccess = FALSE;
        goto cleanup;
    }

    //
    // Internet CAL product Desc.
    //
    g_pszLocalizedInternetKeyPackProductDesc[INDEX_COMPANYNAME] =
        LoadProductDescFromResource(
                                    IDS_COMPANYNAME,
                                    MAX_TERMSRV_PRODUCTID + 1
                                    );

    if(g_pszLocalizedInternetKeyPackProductDesc[INDEX_COMPANYNAME] == NULL)
    {
        bSuccess = FALSE;
        goto cleanup;
    }

    g_pszLocalizedInternetKeyPackProductDesc[INDEX_PRODUCTNAME] =
        LoadProductDescFromResource(
                                    IDS_I_PRODUCTNAME,
                                    MAX_TERMSRV_PRODUCTID + 1
                                    );

    if(g_pszLocalizedInternetKeyPackProductDesc[INDEX_PRODUCTNAME] == NULL)
    {
        bSuccess = FALSE;
        goto cleanup;
    }


    g_pszLocalizedInternetKeyPackProductDesc[INDEX_PRODUCTDESC] =
        LoadProductDescFromResource(
                                    IDS_I_PRODUCTDESC,
                                    MAX_TERMSRV_PRODUCTID + 1
                                    );

    if(g_pszLocalizedInternetKeyPackProductDesc[INDEX_PRODUCTDESC] == NULL)
    {
        bSuccess = FALSE;
        goto cleanup;
    }
                                                                           

    //
    // Whistler FULL CAL product Desc.
    //
    g_pszLocalizedStandardKeyPackProductString51[INDEX_COMPANYNAME] = LoadProductDescFromResource(
                                                                IDS_COMPANYNAME,
                                                                MAX_TERMSRV_PRODUCTID + 1
                                                            );

    if(g_pszLocalizedStandardKeyPackProductString51[INDEX_COMPANYNAME] == NULL)
    {
        bSuccess = FALSE;
        goto cleanup;
    }


    g_pszLocalizedStandardKeyPackProductString51[INDEX_PRODUCTNAME] = LoadProductDescFromResource(
                                                                IDS_S_PRODUCTNAME,
                                                                MAX_TERMSRV_PRODUCTID + 1
                                                            );

    if(g_pszLocalizedStandardKeyPackProductString51[INDEX_PRODUCTNAME] == NULL)
    {
        bSuccess = FALSE;
        goto cleanup;
    }

    g_pszLocalizedStandardKeyPackProductString51[INDEX_PRODUCTDESC] = LoadProductDescFromResource(
                                                                IDS_S_PRODUCTDESC51,
                                                                MAX_TERMSRV_PRODUCTID + 1
                                                            );

    if(g_pszLocalizedStandardKeyPackProductString51[INDEX_PRODUCTDESC] == NULL)
    {
        bSuccess = FALSE;
        goto cleanup;
    }
    
                                                                        
    //
    // Whistler Concurrent CAL product Desc.
    //
    g_pszLocalizedConcurrentKeyPackProductDesc51[INDEX_COMPANYNAME] = LoadProductDescFromResource(
                                                                IDS_COMPANYNAME,
                                                                MAX_TERMSRV_PRODUCTID + 1
                                                            );

    if(g_pszLocalizedConcurrentKeyPackProductDesc51[INDEX_COMPANYNAME] == NULL)
    {
        bSuccess = FALSE;
        goto cleanup;
    }

    g_pszLocalizedConcurrentKeyPackProductDesc51[INDEX_PRODUCTNAME] = LoadProductDescFromResource(
                                                                IDS_C_PRODUCTNAME,
                                                                MAX_TERMSRV_PRODUCTID + 1
                                                            );

    if(g_pszLocalizedConcurrentKeyPackProductDesc51[INDEX_PRODUCTNAME] == NULL)
    {
        bSuccess = FALSE;
        goto cleanup;
    }


    g_pszLocalizedConcurrentKeyPackProductDesc51[INDEX_PRODUCTDESC] = LoadProductDescFromResource(
                                                                IDS_C_PRODUCTDESC51,
                                                                MAX_TERMSRV_PRODUCTID + 1
                                                            );

    if(g_pszLocalizedConcurrentKeyPackProductDesc51[INDEX_PRODUCTDESC] == NULL)
    {
        bSuccess = FALSE;
        goto cleanup;
    }


                                                                        
cleanup:

    if(bSuccess == FALSE)
    {
        FreeProductDescString();
    }
    
    return;
}

////////////////////////////////////////////////////////
BOOL
LoadResourceString(
    IN DWORD dwId,
    IN OUT LPTSTR szBuf,
    IN DWORD dwBufSize
    )
/*++

++*/
{
    int dwRet=0;

    dwRet = LoadString(
                    g_hInstance, 
                    dwId, 
                    szBuf, 
                    dwBufSize
                );
    
    return (dwRet != 0);
}

  
////////////////////////////////////////////////////////
DWORD
AddA02KeyPack(
    IN LPCTSTR pszProductCode,
    IN DWORD dwVersion, // NT version
    IN BOOL bFreeOnly   // add free license pack only
    )
/*++

++*/
{
    TCHAR szComputerName[MAX_COMPUTERNAME_LENGTH + 2];
    DWORD dwSize = MAX_COMPUTERNAME_LENGTH+1;
    TCHAR pszProductId[MAX_TERMSRV_PRODUCTID+1];
    TLS_HANDLE tlsHandle=NULL;
    DWORD dwStatus = ERROR_SUCCESS;
    DWORD dwLkpVersion=0;
    LPTSTR* pszDescs;
    LPTSTR* pszLocalizedDescs;

    

    //
    // Connect to license server
    //
    memset(szComputerName, 0, sizeof(szComputerName));    
    if(GetComputerName(szComputerName, &dwSize) == FALSE)
    {
        dwStatus = GetLastError();
        goto cleanup;
    }

    tlsHandle = TLSConnectToLsServer( szComputerName );
    if(tlsHandle == NULL)
    {
        dwStatus = GetLastError();
        goto cleanup;
    }

    //
    // Windows 2000 resource string
    //
    if(HIWORD(dwVersion) < WINDOWS_VERSION_NT5)
    {
        dwLkpVersion = HIWORD(dwVersion);
    }
    else
    {
        dwLkpVersion = WINDOWS_VERSION_BASE + (HIWORD(dwVersion) - WINDOWS_VERSION_NT5);
    }

    if(_tcsicmp(pszProductCode, TERMSERV_PRODUCTID_SKU) == 0)
    {
        //
        // Add a free keypack
        //
        if (HIWORD(dwVersion) == 5 && LOWORD(dwVersion) == 0)
        {
            _stprintf(
                    pszProductId, 
                    TERMSERV_PRODUCTID_FORMAT,
                    TERMSERV_PRODUCTID_SKU,
                    HIWORD(dwVersion),
                    0,
                    TERMSERV_FREE_TYPE
                );
        
            pszDescs = g_pszUSFreeKeyPackProductDesc;
            pszLocalizedDescs = g_pszLocalizedFreeKeyPackProductDesc;

            dwStatus = InsertLicensePack(
                        tlsHandle,
                        dwVersion,
                        dwLkpVersion,
                        PLATFORMID_FREE, 
                        LSKEYPACKTYPE_FREE,  // local license pack no replication
                        pszProductId,
                        pszProductId,
                        pszDescs,
                        pszLocalizedDescs
                    ); 
        }
        
        

        if(bFreeOnly)
        {
            goto cleanup;
        }

        //
        // Don't add this if enforce licenses.
        //
        #if !defined(ENFORCE_LICENSING) || defined(PRIVATE_DBG)

        //
        // Add a full version keypack, platform type is always 0xFF
        //        

        if (HIWORD(dwVersion) == 5 && (LOWORD(dwVersion) == 1 || LOWORD(dwVersion) == 2) ) 
        {
            _stprintf(
                pszProductId, 
                TERMSERV_PRODUCTID_FORMAT,
                TERMSERV_PRODUCTID_SKU,
                HIWORD(dwVersion),
                0,
                TERMSERV_FULLVERSION_TYPE
            );

            pszDescs = g_pszUSStandardKeyPackProductString51;
            pszLocalizedDescs = g_pszLocalizedStandardKeyPackProductString51;
        }
        else if (HIWORD(dwVersion) == 5 && LOWORD(dwVersion) == 0)
        {
            _stprintf(
                pszProductId, 
                TERMSERV_PRODUCTID_FORMAT,
                TERMSERV_PRODUCTID_SKU,
                HIWORD(dwVersion),
                0,
                TERMSERV_FULLVERSION_TYPE
            );

            pszDescs = g_pszUSStandardKeyPackProductString;
            pszLocalizedDescs = g_pszLocalizedStandardKeyPackProductString;
        }
        else
        {
            dwStatus = ERROR_INVALID_PARAMETER;
            goto cleanup;
        }



        dwStatus = InsertLicensePack(
                        tlsHandle,
                        dwVersion,
                        dwLkpVersion,
                        PLATFORMID_OTHERS,
                        LSKEYPACKTYPE_RETAIL,
                        pszProductId,
                        pszProductId,
                        pszDescs,
                        pszLocalizedDescs
                    );               
        #endif
    }
    else if(_tcsicmp(pszProductCode, TERMSERV_INTERNET_SKU) == 0)
    {
        //
        // Don't add this if enforce licenses.
        //
        #if !defined(ENFORCE_LICENSING) || defined(PRIVATE_DBG)
    
        //
        // Add internet package
        //

        if (HIWORD(dwVersion) == 5 && LOWORD(dwVersion) == 0)
        {
            _stprintf(
                    pszProductId,
                    TERMSERV_PRODUCTID_FORMAT,
                    TERMSERV_INTERNET_SKU,
                    HIWORD(dwVersion),
                    0,
                    TERMSERV_INTERNET_TYPE
                );
        
            pszDescs = g_pszUSInternetKeyPackProductDesc;
            pszLocalizedDescs = g_pszLocalizedInternetKeyPackProductDesc;
        }
        else
        {
            dwStatus = ERROR_INVALID_PARAMETER;
            goto cleanup;
        }


        dwStatus = InsertLicensePack(
                        tlsHandle,
                        dwVersion,
                        dwLkpVersion,
                        PLATFORMID_OTHERS,
                        LSKEYPACKTYPE_RETAIL,
                        pszProductId,
                        pszProductId,
                        pszDescs,
                        pszLocalizedDescs
                    );    
        #endif
    }
    else if(_tcsicmp(pszProductCode, TERMSERV_CONCURRENT_SKU) == 0)
    {
        //
        // Don't add this if enforce licenses.
        //
        #if !defined(ENFORCE_LICENSING) || defined(PRIVATE_DBG)
    
        //
        // Add Concurrent package
        //
        
        if (HIWORD(dwVersion) == 5 && LOWORD(dwVersion) == 1)
        {
            _stprintf(
                    pszProductId,
                    TERMSERV_PRODUCTID_FORMAT,
                    TERMSERV_CONCURRENT_SKU,
                    HIWORD(dwVersion),
                    0,
                    TERMSERV_CONCURRENT_TYPE
                );
        
            pszDescs = g_pszUSConcurrentKeyPackProductDesc51;
            pszLocalizedDescs = g_pszLocalizedConcurrentKeyPackProductDesc51;
        }       
        else
        {
            dwStatus = ERROR_INVALID_PARAMETER;
            goto cleanup;
        }

        dwStatus = InsertLicensePack(
                        tlsHandle,
                        dwVersion,
                        dwLkpVersion,
                        PLATFORMID_OTHERS,
                        LSKEYPACKTYPE_RETAIL,
                        pszProductId,
                        pszProductId,
                        pszDescs,
                        pszLocalizedDescs
                    );    
        #endif
    }

cleanup:

    if(tlsHandle != NULL)
    {
        TLSDisconnectFromServer(tlsHandle);
    }    

    return dwStatus;
}

////////////////////////////////////////////////////////
DWORD
InsertLicensePack(
    IN TLS_HANDLE tlsHandle,
    IN DWORD dwProdVersion,
    IN DWORD dwDescVersion,
    IN DWORD dwPlatformType,
    IN UCHAR ucAgreementType,
    IN LPTSTR pszProductId,
    IN LPTSTR pszKeyPackId,
    IN LPTSTR pszUsDesc[],
    IN LPTSTR pszLocalizedDesc[]
    )
/*++

pdwResourceId

    US Company Name
    US Product Name
    US Product Desc
    Localize Company Name
    Localize Product Name
    Localize Product Desc

++*/
{
    RPC_STATUS rpcStatus;
    BOOL bSuccess;
    DWORD dwStatus = ERROR_SUCCESS;
    TCHAR buffer[LSERVER_MAX_STRING_SIZE];
    struct tm expired_tm;
    LSKeyPack keypack;

    if(pszProductId == NULL || pszKeyPackId == NULL)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        goto cleanup;
    }
   
    memset(&keypack, 0, sizeof(keypack));
    keypack.ucKeyPackType = ucAgreementType;

    SAFESTRCPY(keypack.szKeyPackId, pszKeyPackId);
    SAFESTRCPY(keypack.szProductId, pszProductId);

    SAFESTRCPY(keypack.szCompanyName, pszUsDesc[INDEX_COMPANYNAME]);

    SAFESTRCPY(keypack.szProductName, pszUsDesc[INDEX_PRODUCTNAME]);
    SAFESTRCPY(keypack.szProductDesc, pszUsDesc[INDEX_PRODUCTDESC]);


    keypack.wMajorVersion = HIWORD(dwProdVersion);
    keypack.wMinorVersion = LOWORD(dwProdVersion);
    keypack.dwPlatformType = dwPlatformType;

    keypack.ucLicenseType = LSKEYPACKLICENSETYPE_NEW;
    keypack.dwLanguageId = MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US);
    keypack.ucChannelOfPurchase = LSKEYPACKCHANNELOFPURCHASE_RETAIL;
    SAFESTRCPY(
            keypack.szBeginSerialNumber, 
            _TEXT("0000001")
        );

    keypack.dwTotalLicenseInKeyPack = (ucAgreementType == LSKEYPACKTYPE_FREE) ? INT_MAX : 0;
    keypack.dwProductFlags = 0x00;

    keypack.ucKeyPackStatus = LSKEYPACKSTATUS_ACTIVE;
    keypack.dwActivateDate = (DWORD) time(NULL);

    memset(&expired_tm, 0, sizeof(expired_tm));
    expired_tm.tm_year = 2036 - 1900;     // expire on 2036/1/1
    expired_tm.tm_mday = 1;
    keypack.dwExpirationDate = mktime(&expired_tm);

    rpcStatus = TLSKeyPackAdd(
                        tlsHandle, 
                        &keypack, 
                        &dwStatus
                    );

    if(rpcStatus != RPC_S_OK)
    {
        dwStatus = GetLastError();
        goto cleanup;
    }

    if(dwStatus != ERROR_SUCCESS)
    {
        goto cleanup;
    }

    if(GetSystemDefaultLangID() != keypack.dwLanguageId)
    {
        if( pszLocalizedDesc[INDEX_COMPANYNAME] != NULL &&
            pszLocalizedDesc[INDEX_PRODUCTNAME] != NULL &&
            pszLocalizedDesc[INDEX_PRODUCTDESC] != NULL
          )
        {
            //  
            // Insert localize license pack description
            //
            keypack.dwLanguageId = GetSystemDefaultLangID();

            SAFESTRCPY(keypack.szCompanyName, pszLocalizedDesc[INDEX_COMPANYNAME]);            
            SAFESTRCPY(keypack.szProductName, pszLocalizedDesc[INDEX_PRODUCTNAME]);
            SAFESTRCPY(keypack.szProductDesc, pszLocalizedDesc[INDEX_PRODUCTDESC]);


            keypack.ucKeyPackStatus = LSKEYPACKSTATUS_ADD_DESC;

            rpcStatus = TLSKeyPackAdd(
                                tlsHandle, 
                                &keypack, 
                                &dwStatus
                            );

            if(rpcStatus != RPC_S_OK)
            {
                dwStatus = GetLastError();
                goto cleanup;
            }

            if(dwStatus != ERROR_SUCCESS)
            {
                goto cleanup;
            }
        }
    }

    //
    // Activate keypack
    //
    keypack.ucKeyPackStatus = LSKEYPACKSTATUS_ACTIVE; 
    keypack.dwActivateDate = (DWORD) time(NULL);

    memset(&expired_tm, 0, sizeof(expired_tm));
    expired_tm.tm_year = 2036 - 1900;     // expire on 2036/1/1
    expired_tm.tm_mday = 1;
    keypack.dwExpirationDate = mktime(&expired_tm);

    rpcStatus = TLSKeyPackSetStatus(
                        tlsHandle,
                        LSKEYPACK_SET_KEYPACKSTATUS | LSKEYPACK_SET_ACTIVATEDATE | LSKEYPACK_SET_EXPIREDATE, 
                        &keypack,
                        &dwStatus
                    );

    if(rpcStatus != RPC_S_OK)
    {
        dwStatus = GetLastError();
    }
    
cleanup:

    return dwStatus;
}

////////////////////////////////////////////////////////

BOOL
LicenseTypeFromLookupTable(
    IN DWORD dwClientVer,
	IN DWORD dwTermSrvVer,
    OUT PDWORD pdwCALType
    )
{
	if (dwClientVer < NUMBER_OF_CLIENT_OS && dwTermSrvVer < NUMBER_OF_TERMSRV_OS)
	{
		*pdwCALType = LicenseTable[dwClientVer][dwTermSrvVer];
		return TRUE;
	}
	else
	{
		return FALSE;
	}    
}


////////////////////////////////////////////////////////
POLICYSTATUS
AdjustNewLicenseRequest(
    IN CClient* pClient,
    IN PPMLICENSEREQUEST pRequest,
    IN OUT PPMLICENSEREQUEST* pAdjustedRequest,
    IN UCHAR ucMarkedTemp,
    OUT PDWORD pdwErrCode
    )
/*++

Abstract:

    AdjustNewLicenseRequest fine tune license request for product 236

Parameter:

    pClient - Pointer to CClient object.
    pRequest - Original request from TermSrv.
    pAdjustedRequest - 'Fine tuned' license request.
    ucMarkedTemp - Flags on the temporary license passed in (if any)
    pdwErrCode - error code

Return:

    ERROR_SUCCESS or error code.

++*/
{
    POLICYSTATUS dwStatus = POLICY_SUCCESS;
    DWORD dwTermSrvOSId;
    DWORD dwTermSrvProductVersion;
    LPTSTR pszProductType=NULL;
    TCHAR  pszProductId[MAX_TERMSRV_PRODUCTID+1];
    BOOL bTryInsert=FALSE;
    DWORD dwClientOSId;	
    DWORD dwLicType;
    DWORD dwTermSrvIndex = 0;
    DWORD dwClientIndex = 0;

    //
    // Allocate memory for adjusted product ID
    //
    *pAdjustedRequest = (PPMLICENSEREQUEST) pClient->AllocateMemory(
                                    MEMORY_LICENSE_REQUEST,
                                    sizeof(PMLICENSEREQUEST)
                                );
    if(*pAdjustedRequest == NULL)
    {
        dwStatus = POLICY_CRITICAL_ERROR;
        SetLastError( *pdwErrCode = ERROR_OUTOFMEMORY );
        goto cleanup;
    }
   
    // Following the OS Version change for .NET, to accomodate for Beta3 and interim builds of TS:
    // if a request comes in for 5.1 license, we change the request to 5.2.

    if((HIWORD(pRequest->dwProductVersion) == 5) && (LOWORD(pRequest->dwProductVersion) == 1))
    {
        pRequest->dwProductVersion = MAKELONG(2,5);
    }

    //
    // Fields we don't modify
    // 
    (*pAdjustedRequest)->dwProductVersion = pRequest->dwProductVersion;
    (*pAdjustedRequest)->pszCompanyName = pRequest->pszCompanyName;
    (*pAdjustedRequest)->dwLanguageId = pRequest->dwLanguageId;
    (*pAdjustedRequest)->pszMachineName = pRequest->pszMachineName;
    (*pAdjustedRequest)->pszUserName = pRequest->pszUserName;
    (*pAdjustedRequest)->dwSupportFlags = pRequest->dwSupportFlags;

    //
    // request platform ID is the OS ID
    //

    //
    // TermServ exists from NT40 so termsrv OS ID start 2, 
    // see platform.h
    //
    dwTermSrvOSId = HIWORD(pRequest->dwProductVersion) - 2; 

    if((HIWORD(pRequest->dwProductVersion) == 5) && (LOWORD(pRequest->dwProductVersion) == 0))
    {
	    dwTermSrvIndex = TERMSRV_OS_INDEX_WINNT_5_0;
    }
    else if((HIWORD(pRequest->dwProductVersion) == 5) && (LOWORD(pRequest->dwProductVersion) == 1))
    {
	    dwTermSrvIndex = TERMSRV_OS_INDEX_WINNT_5_1;
    }
    else if((HIWORD(pRequest->dwProductVersion) == 5) && (LOWORD(pRequest->dwProductVersion) == 2))
    {
	    dwTermSrvIndex = TERMSRV_OS_INDEX_WINNT_5_2;
    }
    else if((HIWORD(pRequest->dwProductVersion) > 5) || ((HIWORD(pRequest->dwProductVersion) == 5) && (LOWORD(pRequest->dwProductVersion) > 2)))
    {
	    dwTermSrvIndex = TERMSRV_OS_INDEX_WINNT_POST_5_2;
    }
    else
    {
        dwStatus = POLICY_NOT_SUPPORTED;
    }

    dwClientOSId = GetOSId(pRequest->dwPlatformId);	
		

    (*pAdjustedRequest)->fTemporary = FALSE;

    if(_tcsicmp(pRequest->pszProductId, TERMSERV_PRODUCTID_SKU) == 0)
    {

        switch(GetOSId(pRequest->dwPlatformId))
        {
            case CLIENT_OS_ID_WINNT_351:                    
            case CLIENT_OS_ID_WINNT_40:
            case CLIENT_OS_ID_OTHER:                
	            dwClientIndex = CLIENT_OS_INDEX_OTHER;                    
                break;

            case CLIENT_OS_ID_WINNT_50:					
            {
                if((GetImageRevision(pRequest->dwPlatformId)) == 0)
                {
	                dwClientIndex = CLIENT_OS_INDEX_WINNT_50;
                }
                else if((GetImageRevision(pRequest->dwPlatformId)) == CLIENT_OS_ID_MINOR_WINNT_51)
                {
	                dwClientIndex = CLIENT_OS_INDEX_WINNT_51;
                }
                else if((GetImageRevision(pRequest->dwPlatformId)) == CLIENT_OS_ID_MINOR_WINNT_52)
                {
	                dwClientIndex = CLIENT_OS_INDEX_WINNT_52;
                }
                else
                {
                    dwClientIndex = CLIENT_OS_INDEX_WINNT_POST_52;
                }
            }
                break;  

            case CLIENT_OS_ID_WINNT_POST_52:                    
                dwClientIndex = CLIENT_OS_INDEX_WINNT_POST_52;
                break;

            default: 
                {
                    dwClientIndex = CLIENT_OS_INDEX_OTHER;                    
                }
                break;
        }

        pszProductType = TERMSERV_FULLVERSION_TYPE;

        (*pAdjustedRequest)->dwPlatformId = PLATFORMID_OTHERS;

        dwTermSrvProductVersion = pRequest->dwProductVersion;

        if(LicenseTypeFromLookupTable(dwClientIndex, dwTermSrvIndex, &dwLicType))
        {	        			
	        if(dwLicType == ALLOW_BUILTIN)
	        {
		        pszProductType = TERMSERV_FREE_TYPE;
		        (*pAdjustedRequest)->dwPlatformId = PLATFORMID_FREE;

                //
		        // Add license pack if necessary
		        //

		        if(HIWORD(pRequest->dwProductVersion) != CURRENT_TLSA02_VERSION)
		        {                  
			        AddA02KeyPack( TERMSERV_PRODUCTID_SKU, pRequest->dwProductVersion, TRUE );
		        }
	        }
        }        
        if ((*pAdjustedRequest)->dwPlatformId != PLATFORMID_FREE)
        {        	    
	        if (pRequest->dwSupportFlags & SUPPORT_PER_SEAT_POST_LOGON)
	        {
		        // We're doing the Per-Seat Post-Logon fix for DoS

                if ( !(ucMarkedTemp & MARK_FLAG_USER_AUTHENTICATED))
		        {
			        // No previous temporary, or temporary wasn't marked
			        // as authenticated

			        (*pAdjustedRequest)->fTemporary = TRUE;
		        }
	        }
        }        	
    }
    else
    {
        if (_tcsicmp(pRequest->pszProductId, TERMSERV_CONCURRENT_SKU) == 0)
        {
            pszProductType = TERMSERV_CONCURRENT_TYPE;
        }
        else if (_tcsicmp(pRequest->pszProductId, TERMSERV_INTERNET_SKU) == 0)
        {
            pszProductType = TERMSERV_INTERNET_TYPE;
        }
        else
        {
            dwStatus = POLICY_NOT_SUPPORTED;
            SetLastError( *pdwErrCode = ERROR_INVALID_PARAMETER );
            goto cleanup;
        }

        dwTermSrvProductVersion = pRequest->dwProductVersion;
        
        (*pAdjustedRequest)->dwPlatformId = PLATFORMID_OTHERS;
    }

    _sntprintf(pszProductId,
               MAX_TERMSRV_PRODUCTID,
               TERMSERV_PRODUCTID_FORMAT,
               pRequest->pszProductId,
               HIWORD(dwTermSrvProductVersion),
               LOWORD(dwTermSrvProductVersion),
               pszProductType);

    //
    // allocate memory for product Id
    //
    (*pAdjustedRequest)->pszProductId = (LPTSTR)pClient->AllocateMemory(
                                                        MEMORY_STRING,
                                                        (_tcslen(pszProductId) + 1) * sizeof(TCHAR)
                                                    );

    if((*pAdjustedRequest)->pszProductId == NULL)
    {
        dwStatus = POLICY_CRITICAL_ERROR;
        SetLastError( *pdwErrCode = ERROR_OUTOFMEMORY );
        goto cleanup;
    }

    _tcscpy(
            (*pAdjustedRequest)->pszProductId,
            pszProductId
        );

cleanup:

    return dwStatus;
}    

////////////////////////////////////////////////////////

POLICYSTATUS
ProcessLicenseRequest(
    PMHANDLE client,
    PPMLICENSEREQUEST pbRequest,
    PPMLICENSEREQUEST* pbAdjustedRequest,
    PDWORD pdwErrCode
    )
/*++

++*/
{
    CClient* pClient;
    POLICYSTATUS dwStatus = POLICY_SUCCESS;

    //
    // find client's object, client handle manager will
    // create a new one.
    pClient = g_ClientMgr->FindClient((PMHANDLE)client);

    if(pClient == NULL)
    {
        dwStatus = POLICY_CRITICAL_ERROR;
        *pdwErrCode = TLSA02_E_INTERNALERROR;
        goto cleanup;
    }

    //
    // AdjustNewLicenseRequest
    //
    dwStatus = AdjustNewLicenseRequest(
                            pClient,
                            pbRequest,
                            pbAdjustedRequest,
                            NULL,       // no previous license
                            pdwErrCode
                        );

cleanup:

    return dwStatus;
}


//--------------------------------------------------------------

POLICYSTATUS
ProcessAllocateRequest(
    PMHANDLE client,
    DWORD dwSuggestType,
    PDWORD pdwKeyPackType,
    PDWORD pdwErrCode
    )    
/*++

    Default sequence is always FREE/RETAIL/OPEN/SELECT/TEMPORARY

++*/
{
    switch(dwSuggestType)
    {
        case LSKEYPACKTYPE_UNKNOWN:
            *pdwKeyPackType = LSKEYPACKTYPE_FREE;
            break;

        case LSKEYPACKTYPE_FREE:
            *pdwKeyPackType = LSKEYPACKTYPE_RETAIL;
            break;

        case LSKEYPACKTYPE_RETAIL:
            *pdwKeyPackType = LSKEYPACKTYPE_OPEN;
            break;

        case LSKEYPACKTYPE_OPEN:
            *pdwKeyPackType = LSKEYPACKTYPE_SELECT;
            break;

        case LSKEYPACKTYPE_SELECT:
            //
            // FALL THRU
            //
        default:
            //
            // No more keypack to look for, instruct license
            // server to terminate.
            //
            *pdwKeyPackType = LSKEYPACKTYPE_UNKNOWN;
            break;
    }        

    *pdwErrCode = ERROR_SUCCESS;
    return POLICY_SUCCESS;
}

//-------------------------------------------------------------
POLICYSTATUS WINAPI
ProcessKeyPackDesc(
    IN PMHANDLE client,
    IN PPMKEYPACKDESCREQ pDescReq,
    IN OUT PPMKEYPACKDESC* pDesc,
    IN OUT PDWORD pdwErrCode
    )
/*++

++*/
{
    CClient* pClient;
    POLICYSTATUS dwStatus=POLICY_SUCCESS;

    DWORD usLangId = MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US);
    BOOL bSuccess;
    DWORD dwMajorVersion;
    DWORD dwMinorVersion;
    DWORD dwDescVersion;

    TCHAR szPreFix[MAX_SKU_PREFIX];
    TCHAR szPostFix[MAX_SKU_POSTFIX];
    TCHAR szDesc[MAX_TERMSRV_PRODUCTID+1];

    DWORD i;

    LPTSTR* pszKeyPackDesc;
    LPTSTR* pszUSKeyPackDesc;


    if(pDescReq == NULL || pDesc == NULL)
    {
        dwStatus = POLICY_ERROR;
        *pdwErrCode = ERROR_INVALID_PARAMETER;
        goto cleanup;
    }

    //
    // find client's object, client handle manager will
    // create a new one.
    pClient = g_ClientMgr->FindClient((PMHANDLE)client);

    if(pClient == NULL)
    {
        dwStatus = POLICY_ERROR;
        *pdwErrCode = TLSA02_E_INTERNALERROR;
        goto cleanup;
    }

    for (i = 0; i < g_dwNumSupportedProduct; i++)
    {
        if(_tcsnicmp(
               pDescReq->pszProductId, 
               g_pszSupportedProduct[i].szTLSProductCode, 
               _tcslen(g_pszSupportedProduct[i].szTLSProductCode)) == 0)
        {
            break;
        }

    }

    if (i >= g_dwNumSupportedProduct)
    {
        //
        // This is not ours
        //
        dwStatus = POLICY_ERROR;
        SetLastError(*pdwErrCode = ERROR_INVALID_PARAMETER);
        goto cleanup;
    }

    LONG lRet = _stscanf(
            pDescReq->pszProductId,
            TERMSERV_PRODUCTID_SCAN_FORMAT,
            szPreFix,
            &dwMajorVersion,
            &dwMinorVersion,
            szPostFix
        );

    if(lRet != 4)
    {
        dwStatus = POLICY_ERROR;
        SetLastError(*pdwErrCode = ERROR_INVALID_PARAMETER);
        goto cleanup;
    }

    if(dwMajorVersion < WINDOWS_VERSION_NT5)
    {
        dwDescVersion = dwMajorVersion;
    }
    else
    {
        dwDescVersion = WINDOWS_VERSION_BASE + dwMajorVersion - WINDOWS_VERSION_NT5;
    }

    //
    // Detemine which resource string we should load,
    // string dependency on resource ID.
    //
    if(_tcsicmp(szPreFix, TERMSERV_PRODUCTID_SKU) == 0)
    {
        if(_tcsicmp(szPostFix, TERMSERV_FULLVERSION_TYPE) == 0)
        {
            if (dwMajorVersion == 5 && (dwMinorVersion == 1 || dwMinorVersion == 2))
            {
                pszKeyPackDesc = g_pszLocalizedStandardKeyPackProductString51;
                pszUSKeyPackDesc = g_pszUSStandardKeyPackProductString51;
            }
            else if (dwMajorVersion == 5 && dwMinorVersion == 0)
            {
                pszKeyPackDesc = g_pszLocalizedStandardKeyPackProductString;
                pszUSKeyPackDesc = g_pszUSStandardKeyPackProductString;
            }
            else
            {
                dwStatus = POLICY_ERROR;
                SetLastError(*pdwErrCode = ERROR_INVALID_PARAMETER);
                goto cleanup;
            }


            if( pDescReq->dwLangId == usLangId ||
                pszKeyPackDesc[INDEX_COMPANYNAME] == NULL ||
                pszKeyPackDesc[INDEX_PRODUCTNAME] == NULL ||
                pszKeyPackDesc[INDEX_PRODUCTDESC] == NULL )
            {
                //
                // resource not found, use english desc.
                pszKeyPackDesc = pszUSKeyPackDesc;

            }
        }
        else if(_tcsicmp(szPostFix, TERMSERV_FREE_TYPE) == 0)
        {
            if (dwMajorVersion == 5 && dwMinorVersion == 0)
            {
                pszKeyPackDesc = g_pszLocalizedFreeKeyPackProductDesc;
                pszUSKeyPackDesc = g_pszUSFreeKeyPackProductDesc;
            }
            else
            {
                dwStatus = POLICY_ERROR;
                SetLastError(*pdwErrCode = ERROR_INVALID_PARAMETER);
                goto cleanup;
            }


            if( pDescReq->dwLangId == usLangId ||
                pszKeyPackDesc[INDEX_COMPANYNAME] == NULL ||
                pszKeyPackDesc[INDEX_PRODUCTNAME] == NULL ||
                pszKeyPackDesc[INDEX_PRODUCTDESC] == NULL )
            {
                //
                // resource not found, use english desc.
                pszKeyPackDesc = pszUSKeyPackDesc;
            }
        }
        else
        {
            //
            // Something wrong, this is not ours
            //
            SetLastError(*pdwErrCode = ERROR_INVALID_PARAMETER);
            dwStatus = POLICY_ERROR;
            goto cleanup;
        }
    }
    else if(_tcsicmp(szPreFix, TERMSERV_INTERNET_SKU) == 0 && _tcsicmp(szPostFix, TERMSERV_INTERNET_TYPE) == 0)
    {
        if (dwMajorVersion == 5 && dwMinorVersion == 0)
        {
            pszKeyPackDesc = g_pszLocalizedInternetKeyPackProductDesc;
            pszUSKeyPackDesc = g_pszUSInternetKeyPackProductDesc;
        }
        else
        {
            dwStatus = POLICY_ERROR;
            SetLastError(*pdwErrCode = ERROR_INVALID_PARAMETER);
            goto cleanup;
        }


        if( pDescReq->dwLangId == usLangId ||
            pszKeyPackDesc[INDEX_COMPANYNAME] == NULL ||
            pszKeyPackDesc[INDEX_PRODUCTNAME] == NULL ||
            pszKeyPackDesc[INDEX_PRODUCTDESC] == NULL )
        {
            //
            // resource not found, use english desc.
            pszKeyPackDesc = pszUSKeyPackDesc;
        }
    }        
    else if(_tcsicmp(szPreFix, TERMSERV_CONCURRENT_SKU) == 0 && _tcsicmp(szPostFix, TERMSERV_CONCURRENT_TYPE) == 0)
    {
        if (dwMajorVersion == 5 && dwMinorVersion == 1)
        {
            pszKeyPackDesc = g_pszLocalizedConcurrentKeyPackProductDesc51;
            pszUSKeyPackDesc = g_pszUSConcurrentKeyPackProductDesc51;
        }
        else
        {
            dwStatus = POLICY_ERROR;
            SetLastError(*pdwErrCode = ERROR_INVALID_PARAMETER);
            goto cleanup;
        }

        if( pDescReq->dwLangId == usLangId ||
            pszKeyPackDesc[INDEX_COMPANYNAME] == NULL ||
            pszKeyPackDesc[INDEX_PRODUCTNAME] == NULL ||
            pszKeyPackDesc[INDEX_PRODUCTDESC] == NULL )
        {
            //
            // resource not found, use english desc.
            pszKeyPackDesc = g_pszUSConcurrentKeyPackProductDesc51;
        }
    }        
    else
    {
        //
        // Something wrong, this is not ours
        //
        SetLastError(*pdwErrCode = ERROR_INVALID_PARAMETER);
        dwStatus = POLICY_ERROR;
        goto cleanup;
    }    
    
    *pDesc = (PPMKEYPACKDESC)pClient->AllocateMemory(
                                        MEMORY_KEYPACKDESC,
                                        sizeof(PMKEYPACKDESC)
                                    );

    if(*pDesc == NULL)
    {
        SetLastError(*pdwErrCode = ERROR_OUTOFMEMORY);
        dwStatus = POLICY_CRITICAL_ERROR;
        goto cleanup;
    }

    SAFESTRCPY((*pDesc)->szCompanyName, pszKeyPackDesc[INDEX_COMPANYNAME]);                    
    SAFESTRCPY((*pDesc)->szProductName, pszKeyPackDesc[INDEX_PRODUCTNAME]);
    SAFESTRCPY((*pDesc)->szProductDesc, pszKeyPackDesc[INDEX_PRODUCTDESC]);


cleanup:

    if(dwStatus != POLICY_SUCCESS)
    {
        *pDesc = NULL;
    }

    return dwStatus;
}

//-------------------------------------------------------------
POLICYSTATUS
ProcessGenLicenses(
    PMHANDLE client,
    PPMGENERATELICENSE pGenLicense,
    PPMCERTEXTENSION *pCertExtension,
    PDWORD pdwErrCode
    )
/*++

++*/
{
    // No policy extension to return.
    *pCertExtension = NULL;
    *pdwErrCode = ERROR_SUCCESS;
    return POLICY_SUCCESS;
}

//--------------------------------------------------------------

POLICYSTATUS
ProcessComplete(
    PMHANDLE client,
    DWORD dwErrCode,
    PDWORD pdwErrCode
    )
/*++

++*/
{
    //
    // We don't store any data so ignore 
    // error code from license server
    //
    UNREFERENCED_PARAMETER(dwErrCode);

    //
    // Free memory allocated for the client
    //
    g_ClientMgr->DestroyClient( client );
    *pdwErrCode = ERROR_SUCCESS;
    return POLICY_SUCCESS;
}

//--------------------------------------------------------------

POLICYSTATUS WINAPI
PMLicenseRequest(
    PMHANDLE client,
    DWORD dwProgressCode, 
    PVOID pbProgressData, 
    PVOID* pbNewProgressData,
    PDWORD pdwErrCode
    )
/*++


++*/
{
    POLICYSTATUS dwStatus = POLICY_SUCCESS;

    switch( dwProgressCode )
    {
        case REQUEST_NEW:
            //
            // License Server ask to fine tune the request.
            //
            dwStatus = ProcessLicenseRequest(
                                    client,
                                    (PPMLICENSEREQUEST) pbProgressData,
                                    (PPMLICENSEREQUEST *) pbNewProgressData,
                                    pdwErrCode
                                );
            break;

        case REQUEST_KEYPACKTYPE:
            //
            // License Server ask for the license pack type
            //
            dwStatus = ProcessAllocateRequest(
                                    client,
                                #ifdef _WIN64
                                    PtrToUlong(pbProgressData),
                                #else
                                    (DWORD) pbProgressData,
                                #endif
                                    (PDWORD) pbNewProgressData,
                                    pdwErrCode
                                );
            break;

        case REQUEST_TEMPORARY:
            //
            // License Server ask if temporary license should be issued
            //
            *(BOOL *)pbNewProgressData = TRUE;
            *pdwErrCode = ERROR_SUCCESS;
            break;

        case REQUEST_KEYPACKDESC:
            //
            // License Server is requesting a keypack description.
            //
            dwStatus = ProcessKeyPackDesc(
                                    client,
                                    (PPMKEYPACKDESCREQ) pbProgressData,
                                    (PPMKEYPACKDESC *) pbNewProgressData,
                                    pdwErrCode
                                );
            break;
            
        case REQUEST_GENLICENSE:
            //
            // License Server ask for certificate extension
            //
            dwStatus = ProcessGenLicenses(
                                    client,
                                    (PPMGENERATELICENSE) pbProgressData,
                                    (PPMCERTEXTENSION *) pbNewProgressData,
                                    pdwErrCode
                                );

            break;

        case REQUEST_COMPLETE:
            //
            // Request complete
            //
            dwStatus = ProcessComplete(
                                    client,
                                #ifdef _WIN64
                                    PtrToUlong(pbNewProgressData),
                                #else
                                    (DWORD) pbNewProgressData,
                                #endif
                                    pdwErrCode
                                );
            break;

        default:
            //
            // This tell License Server to use default value
            //
            *pbNewProgressData = NULL;
            dwStatus = POLICY_ERROR;
            *pdwErrCode = ERROR_INVALID_PARAMETER;
    }

    return dwStatus;
}

//------------------------------------------------------------
typedef enum {
    UPGRADELICENSE_ERROR=0,
    UPGRADELICENSE_INVALID_LICENSE,
    UPGRADELICENSE_NEWLICENSE,
    UPGRADELICENSE_UPGRADE,
    UPGRADELICENSE_ALREADYHAVE
} UPGRADELICENSE_STATUS;

////////////////////////////////////////////////////////
UPGRADELICENSE_STATUS
RequireUpgradeType(
    PPMUPGRADEREQUEST pUpgrade
    )
/*++


++*/
{
    UPGRADELICENSE_STATUS dwRetCode = UPGRADELICENSE_UPGRADE;
    DWORD index;
    DWORD dwClientOSId;
    DWORD dwTermSrvOSId;
    DWORD dwClientMinorOSId;

    //
    // Verify input parameters
    //
    if(pUpgrade == NULL || pUpgrade->dwNumProduct == 0 || pUpgrade->pProduct == NULL)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        dwRetCode = UPGRADELICENSE_ERROR;
        goto cleanup;
    }

    //
    // Make sure we only upgrade to same product
    //
    if(_tcsnicmp(pUpgrade->pUpgradeRequest->pszProductId, TERMSERV_PRODUCTID_SKU, _tcslen(TERMSERV_PRODUCTID_SKU)) != 0)
    {
        dwRetCode = UPGRADELICENSE_ERROR;
        goto cleanup;
    }

    //
    // simple licensed product verification, 
    // licensed product is in decending order
    //
    for(index=0; index < pUpgrade->dwNumProduct-1; index++)
    {
        if( pUpgrade->pProduct[index].bTemporary == FALSE &&
            pUpgrade->pProduct[index+1].bTemporary == TRUE )
        {
            dwRetCode = UPGRADELICENSE_INVALID_LICENSE;
            break;
        }
    }

    if(dwRetCode == UPGRADELICENSE_INVALID_LICENSE)
    {
        goto cleanup;
    }                 

    for(index=0; index < pUpgrade->dwNumProduct; index ++)
    {
        // If Licensed product version is greater than request

        if( (CompareTLSVersions(pUpgrade->pProduct[index].LicensedProduct.dwProductVersion, pUpgrade->pUpgradeRequest->dwProductVersion) > 0))
        {           
                dwRetCode = UPGRADELICENSE_NEWLICENSE;  
                break;
        }
        //
        // If Licensed product version is older than request

        if(CompareTLSVersions(pUpgrade->pProduct[index].LicensedProduct.dwProductVersion, pUpgrade->pUpgradeRequest->dwProductVersion) < 0)
        {
            
            break;
        }
      
        if( (CompareTLSVersions(pUpgrade->pProduct[index].LicensedProduct.dwProductVersion, pUpgrade->pUpgradeRequest->dwProductVersion) == 0) &&
	        (pUpgrade->pProduct[index].bTemporary))
        {  
	        // we want to break out of loop in the case where we have same version as request but is a temporary license         

            break;
        }

        if ((CompareTLSVersions(pUpgrade->pProduct[index].LicensedProduct.dwProductVersion,
                pUpgrade->pUpgradeRequest->dwProductVersion) >= 0) &&
            (!(pUpgrade->pProduct[index].bTemporary)))
        {
            DWORD dwVersion = MAKELONG(1,5);

            if(pUpgrade->pProduct[index].LicensedProduct.dwProductVersion == dwVersion)
            {
                dwRetCode = UPGRADELICENSE_UPGRADE;
            }
            else
            {
                // we already have a license.
                dwRetCode = UPGRADELICENSE_ALREADYHAVE;
            }
            break;
        }

    }

    //
    // Win98 client connect to TS 5 to get a Full CAL, then upgrade to NT5, instruct 
    // license server to issue a Free CAL.
    //
    
    dwTermSrvOSId = HIWORD(pUpgrade->pUpgradeRequest->dwProductVersion) - 2;
    dwClientOSId = GetOSId(pUpgrade->pUpgradeRequest->dwPlatformId);	
    dwClientMinorOSId = GetImageRevision(pUpgrade->pUpgradeRequest->dwPlatformId);

    if(dwRetCode == UPGRADELICENSE_ALREADYHAVE)
    {
        //
        // do nothing.
    }
    else if(index >= pUpgrade->dwNumProduct || pUpgrade->pProduct[index].bTemporary == TRUE)
    {
        // all license is temp, ask for new license.
        dwRetCode = UPGRADELICENSE_NEWLICENSE;
    }
    else
    {
        // prev. licensed product is perm, ask for upgrade license
        // ClientOSId: HIBYTE(HIWORD) contains Major version and LOBYTE(LOWORD) contains Minor version
        // TermsrvOSId: LOBYTE(HIWORD) contains Major version and LOBYTE(LOWORD) contains Minor version

        if((HIBYTE(HIWORD(dwClientOSId)) == LOBYTE(HIWORD(dwTermSrvOSId)) ? LOBYTE(LOWORD(dwClientMinorOSId)) - LOBYTE(LOWORD(dwTermSrvOSId)) : \
            HIBYTE(HIWORD(dwClientOSId)) - LOBYTE(HIWORD(dwTermSrvOSId))) >= 0)

        { 
            dwRetCode = UPGRADELICENSE_NEWLICENSE;
        }
        else
        {
            dwRetCode = UPGRADELICENSE_UPGRADE;
        }
    }
    
cleanup:

    return dwRetCode;
}

////////////////////////////////////////////////////////
POLICYSTATUS
AdjustUpgradeLicenseRequest(
    IN CClient* pClient,
    IN PPMUPGRADEREQUEST pUpgradeRequest,
    IN PPMLICENSEREQUEST* pAdjustedRequest,
    OUT PDWORD pdwErrCode
    )
/*++


++*/
{
    POLICYSTATUS dwStatus = POLICY_SUCCESS;
    PPMLICENSEREQUEST pRequest;
    TCHAR  pszProductId[MAX_TERMSRV_PRODUCTID+1];

    if(pUpgradeRequest == NULL || pUpgradeRequest->pUpgradeRequest == NULL)
    {
        SetLastError(*pdwErrCode = ERROR_INVALID_PARAMETER);
        dwStatus = POLICY_ERROR;
        goto cleanup;
    }

    *pAdjustedRequest = (PPMLICENSEREQUEST) pClient->AllocateMemory(
                                                    MEMORY_LICENSE_REQUEST,
                                                    sizeof(PMLICENSEREQUEST)
                                                    );
    if(*pAdjustedRequest == NULL)
    {
        SetLastError(*pdwErrCode = ERROR_OUTOFMEMORY);
        dwStatus = POLICY_CRITICAL_ERROR;
        goto cleanup;
    }

    // Following the OS Version change for .NET, to accomodate for Beta3 and interim builds of TS:
    // if a request comes in for 5.1 license, we change the request to 5.2.

    pRequest = pUpgradeRequest->pUpgradeRequest;

    if((HIWORD(pRequest->dwProductVersion) == 5) && (LOWORD(pRequest->dwProductVersion) == 1))
    {
        pRequest->dwProductVersion = MAKELONG(2,5);
    }

    //
    // Fields we don't modify
    // 
    (*pAdjustedRequest)->dwProductVersion = pRequest->dwProductVersion;
    (*pAdjustedRequest)->pszCompanyName = pRequest->pszCompanyName;
    (*pAdjustedRequest)->dwLanguageId = pRequest->dwLanguageId;
    (*pAdjustedRequest)->pszMachineName = pRequest->pszMachineName;
    (*pAdjustedRequest)->pszUserName = pRequest->pszUserName;
    (*pAdjustedRequest)->dwSupportFlags = pRequest->dwSupportFlags;

    //
    // Change Request platform ID for upgrade
    //
    (*pAdjustedRequest)->dwPlatformId = PLATFORMID_OTHERS;

    if (pRequest->dwSupportFlags & SUPPORT_PER_SEAT_POST_LOGON)
    {
        // We're doing the Per-Seat Post-Logon fix for DoS

        (*pAdjustedRequest)->fTemporary = TRUE;
    }

    StringCbPrintf(
            pszProductId,
            sizeof(pszProductId),
            TERMSERV_PRODUCTID_FORMAT,
            TERMSERV_PRODUCTID_SKU,
            HIWORD(pRequest->dwProductVersion),
            LOWORD(pRequest->dwProductVersion),
            TERMSERV_FULLVERSION_TYPE
        );

    //
    // allocate memory for product Id
    //
    (*pAdjustedRequest)->pszProductId = (LPTSTR)pClient->AllocateMemory(
                                                        MEMORY_STRING,
                                                        (_tcslen(pszProductId) + 1) * sizeof(TCHAR)
                                                    );

    if((*pAdjustedRequest)->pszProductId == NULL)
    {
        SetLastError( *pdwErrCode = ERROR_OUTOFMEMORY );
        dwStatus = POLICY_CRITICAL_ERROR;
        goto cleanup;
    }

    _tcscpy(
            (*pAdjustedRequest)->pszProductId,
            pszProductId
        );

cleanup:

    return dwStatus;
}


////////////////////////////////////////////////////////
POLICYSTATUS
ProcessUpgradeRequest(
    PMHANDLE hClient,
    PPMUPGRADEREQUEST pUpgrade,
    PPMLICENSEREQUEST* pbAdjustedRequest,
    PDWORD pdwErrCode,
    DWORD dwIndex
    )
/*++

++*/
{
    POLICYSTATUS dwStatus = POLICY_SUCCESS;
    CClient* pClient;
    UPGRADELICENSE_STATUS upgradeStatus;

    //
    // find client's object, client handle manager will
    // create a new one.
    pClient = g_ClientMgr->FindClient(hClient);
    if(pClient == NULL)
    {
        *pdwErrCode = TLSA02_E_INTERNALERROR;
        dwStatus = POLICY_CRITICAL_ERROR;
        goto cleanup;
    }
    
    upgradeStatus = RequireUpgradeType(pUpgrade);

    switch(upgradeStatus)
    {
        case UPGRADELICENSE_NEWLICENSE:
            {

                UCHAR ucMarked = pUpgrade->pProduct[dwIndex].ucMarked;
               
                dwStatus = AdjustNewLicenseRequest(
                                        pClient,
                                        pUpgrade->pUpgradeRequest,
                                        pbAdjustedRequest,
                                        ucMarked,
                                        pdwErrCode
                                    );
            }
            break;

        case UPGRADELICENSE_UPGRADE:
            dwStatus = AdjustUpgradeLicenseRequest(
                                    pClient,
                                    pUpgrade,
                                    pbAdjustedRequest,
                                    pdwErrCode
                                );
            break;

        case UPGRADELICENSE_ALREADYHAVE:
            *pbAdjustedRequest = &(pUpgrade->pProduct->LicensedProduct);
            *pdwErrCode = ERROR_SUCCESS;
            break;

        default:
            SetLastError(*pdwErrCode = TLSA02_E_INVALIDDATA);
            dwStatus = POLICY_ERROR;
            
    }
    
cleanup:

    return dwStatus;
}

////////////////////////////////////////////////////////
POLICYSTATUS WINAPI
PMLicenseUpgrade(
    PMHANDLE hClient,
    DWORD dwProgressCode,
    PVOID pbProgressData,
    PVOID *ppbReturnData,    
    PDWORD pdwErrCode,
    DWORD dwIndex
    )
/*++

++*/
{   
    POLICYSTATUS dwStatus = POLICY_SUCCESS;

    switch(dwProgressCode)
    {
        case REQUEST_UPGRADE:
                dwStatus = ProcessUpgradeRequest(
                                        hClient,
                                        (PPMUPGRADEREQUEST) pbProgressData,
                                        (PPMLICENSEREQUEST *) ppbReturnData,                                        
                                        pdwErrCode,
                                        dwIndex
                                    );

                break;

        case REQUEST_COMPLETE:
                dwStatus = ProcessComplete(
                                        hClient,
                                    #ifdef _WIN64
                                        PtrToUlong(pbProgressData),
                                    #else
                                        (DWORD) (pbProgressData),
                                    #endif
                                        pdwErrCode
                                    );

                break;

        default:
            //
            // use default
            //
            *ppbReturnData = NULL;
            *pdwErrCode = ERROR_SUCCESS;
    }
        
    return dwStatus;
}


////////////////////////////////////////////////////////
POLICYSTATUS
PMReturnLicense(
	IN PMHANDLE hClient,
	IN ULARGE_INTEGER* pLicenseSerialNumber,
    IN PPMLICENSETOBERETURN pLicenseTobeReturn,
	OUT PDWORD pdwLicenseStatus,
    OUT PDWORD pdwErrCode
    )
/*++

Abstract

    Return module specific license return policy.

Parameters

    hClient - Client handle, assign by License Server.
    pLicenseSerialNumber - client license serial number.
    LicensePackId - License Pack where license was allocated from.
    LicensePackLicenseId - License serial number in license pack.
    pdwLicenseStatus - return what license server should
                       do with the license
    
Returns:

    Function returns ERROR_SUCCESS or any policy module specific
    error code, pdwLicenseStatus returns license return policy

    Currently defined code:

    LICENSE_RETURN_KEEP - keep license, no return to license pack
    LICENSE_RETURN_DELETE - delete license and return to license pack.

++*/
{
    POLICYSTATUS dwStatus = POLICY_SUCCESS;
    *pdwErrCode = ERROR_SUCCESS;

    if ((_tcsicmp(pLicenseTobeReturn->pszOrgProductId,
                  TERMSERV_INTERNET_SKU) == 0)
        || (_tcsicmp(pLicenseTobeReturn->pszOrgProductId,
                     TERMSERV_CONCURRENT_SKU) == 0))
    {
        *pdwLicenseStatus = LICENSE_RETURN_DELETE;
    }
    else if(_tcsicmp(pLicenseTobeReturn->pszOrgProductId,
                     TERMSERV_PRODUCTID_SKU) == 0)
    {
        // Always return license back to license pack
        *pdwLicenseStatus = (pLicenseTobeReturn->bTemp == TRUE) ?
            LICENSE_RETURN_DELETE : LICENSE_RETURN_KEEP;
    }
    else
    {
        *pdwErrCode = ERROR_INVALID_DATA;
        dwStatus = POLICY_ERROR;
    }

    return dwStatus;
}

////////////////////////////////////////////////////////

POLICYSTATUS WINAPI
PMInitialize(
    IN DWORD dwVersion,
    IN LPCTSTR pszCompanyName,
    IN LPCTSTR pszProductCode,
    IN OUT PDWORD pdwNumProduct,
    IN OUT PPMSUPPORTEDPRODUCT* ppszProduct,
    OUT PDWORD pdwErrCode
    )
/*++

Abstract:

    Initialize internal data use by this policy module.  License 
    Server calls PMInitialize() after all API is available.

Parameters:

    dwVersion - License Server version
    pszCompanyName : Name of the company as listed in license server's registry key.
    pszProductCode : Name of the product that license server assume this product supported.
    pdwNumProduct : Pointer to DWORD, on return, ploicy module will set product supported.
    ppszProduct : Pointer array to list of product supported by this policy module.

Returns:

    ERROR_SUCCESS or error code.

++*/
{
    POLICYSTATUS dwStatus = POLICY_SUCCESS;
    
    //
    // Initialize internal data here
    //

    if (CURRENT_TLSERVER_VERSION(dwVersion) < CURRENT_TLSA02_VERSION)
    {
        dwStatus = POLICY_CRITICAL_ERROR;
        *pdwErrCode = TLSA02_E_INVALIDDATA;
        goto cleanup;
    }

    g_ClientMgr = new CClientMgr;   
    if(g_ClientMgr != NULL)
    {
        g_dwVersion = dwVersion;

        if(pdwNumProduct != NULL && ppszProduct != NULL)
        {
            *pdwNumProduct = g_dwNumSupportedProduct;
            *ppszProduct = g_pszSupportedProduct;
        }
        else
        {
            //
            // Stop processing since this might be license server critical error.
            //
            dwStatus = POLICY_CRITICAL_ERROR;
            *pdwErrCode = TLSA02_E_INVALIDDATA;
        }
    }
    else
    {
        dwStatus = POLICY_CRITICAL_ERROR;
        *pdwErrCode = ERROR_OUTOFMEMORY;
    }   

cleanup:
    return dwStatus;
}


////////////////////////////////////////////////////////
void WINAPI
PMTerminate()
/*++

Abstract:

    Free all internal data allocated by this policy module.  License
    Server calls PMTerminate() before it unload this policy module.

Parameter:

    None.

Returns:

    None.

++*/
{
    if(g_ClientMgr)
    {
        //
        // Free internal data here
        //
        delete g_ClientMgr;
        g_ClientMgr = NULL;
    }

    FreeProductDescString();

    return;
}


////////////////////////////////////////////////////////

POLICYSTATUS WINAPI
PMInitializeProduct(
    IN LPCTSTR pszCompanyName,
    IN LPCTSTR pszCHProductCode,
    IN LPCTSTR pszTLSProductCode,
    OUT PDWORD pdwErrCode
    )
/*++

Abstract:

    Return list of product code that this policy module supported

Parameters:


Returns:

    ERROR_SUCCESS or error code.

Note:

    License Server will not free the memory, policy module will need to
    keep track.

++*/
{
    POLICYSTATUS dwStatus = POLICY_SUCCESS;

    for(DWORD index = 0; index < g_dwNumSupportedProduct; index ++)
    {
        if( _tcsicmp(pszCHProductCode, g_pszSupportedProduct[index].szCHSetupCode) == 0 &&
            _tcsicmp(pszTLSProductCode, g_pszSupportedProduct[index].szTLSProductCode) == 0)
        {
            break;
        }
    }

    if(index >= g_dwNumSupportedProduct)
    {
        *pdwErrCode = ERROR_INVALID_PARAMETER;
        dwStatus = POLICY_ERROR;
    }
    else
    {

        //
        // Ignore error here
        //
        AddA02KeyPack(
                pszTLSProductCode,
                MAKELONG(0, CURRENT_TLSERVER_VERSION(g_dwVersion)),
                FALSE
            );
    }

    *pdwErrCode = ERROR_SUCCESS;
    return dwStatus;
}

////////////////////////////////////////////////////////

POLICYSTATUS WINAPI
PMUnloadProduct(
    IN LPCTSTR pszCompanyName,
    IN LPCTSTR pszCHProductCode,
    IN LPCTSTR pszTLSProductCode,
    OUT PDWORD pdwErrCode
    )
/*++

Abstract:

    Return list of product code that this policy module supported

Parameters:


Returns:

    ERROR_SUCCESS or error code.

Note:

    License Server will not free the memory, policy module will need to
    keep track.

++*/
{
    *pdwErrCode = ERROR_SUCCESS;
    return POLICY_SUCCESS;
}

////////////////////////////////////////////////////////
POLICYSTATUS
ProcessRegisterLicensePack(
    IN PMHANDLE client,
    IN PPMREGISTERLICENSEPACK pmLicensePack,
    IN OUT PPMLSKEYPACK pmLsKeyPack,
    OUT PDWORD pdwErrCode
    )
/*++


--*/
{
    TCHAR* szUuid = NULL;
    BOOL bInternetPackage=FALSE;
    BOOL bConcurrentPackage=FALSE;

    CClient* pClient;
    POLICYSTATUS dwStatus = POLICY_SUCCESS;

    if( pmLicensePack->SourceType != REGISTER_SOURCE_INTERNET &&
        pmLicensePack->SourceType != REGISTER_SOURCE_PHONE )
    {
        dwStatus = POLICY_NOT_SUPPORTED;
        *pdwErrCode = ERROR_INVALID_PARAMETER;
        goto cleanup;
    }

    if( pmLicensePack->SourceType == REGISTER_SOURCE_INTERNET &&
        (pmLicensePack->dwDescriptionCount == 0 || pmLicensePack->pDescription == NULL) )
    {
        dwStatus = POLICY_ERROR;
        *pdwErrCode = ERROR_INVALID_PARAMETER;
        goto cleanup;
    }

    if(CompareFileTime(&pmLicensePack->ActiveDate, &pmLicensePack->ExpireDate) > 0)
    {
        dwStatus = POLICY_ERROR;
        *pdwErrCode = ERROR_INVALID_PARAMETER;
        goto cleanup;
    }

    //
    // find client's object, client handle manager will
    // create a new one.
    pClient = g_ClientMgr->FindClient((PMHANDLE)client);

    if(pClient == NULL)
    {
        dwStatus = POLICY_ERROR;
        *pdwErrCode = TLSA02_E_INTERNALERROR;
        goto cleanup;
    }

    bInternetPackage = (_tcsicmp(pmLicensePack->szProductId, TERMSERV_INTERNET_SKU) == 0);

    if (!bInternetPackage)
    {
        bConcurrentPackage = (_tcsicmp(pmLicensePack->szProductId, TERMSERV_CONCURRENT_SKU) == 0);
    }

    switch(pmLicensePack->dwKeyPackType)
    {
        case LICENSE_KEYPACK_TYPE_SELECT:
            pmLsKeyPack->keypack.ucKeyPackType = LSKEYPACKTYPE_SELECT;
            break;

        case LICENSE_KEYPACK_TYPE_MOLP:
            pmLsKeyPack->keypack.ucKeyPackType = LSKEYPACKTYPE_OPEN;
            break;

        case LICENSE_KEYPACK_TYPE_RETAIL:
            pmLsKeyPack->keypack.ucKeyPackType = LSKEYPACKTYPE_RETAIL;
            break;

        default:
            dwStatus = POLICY_ERROR;
            *pdwErrCode = ERROR_INVALID_PARAMETER;
            goto cleanup;
    }


    // we only use 0xFF

    pmLsKeyPack->keypack.dwPlatformType = PLATFORMID_OTHERS;
    pmLsKeyPack->keypack.ucLicenseType = (UCHAR)pmLicensePack->dwLicenseType;
    pmLsKeyPack->keypack.dwLanguageId = MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US);  // field ignore by license server.
    pmLsKeyPack->keypack.ucChannelOfPurchase = (pmLicensePack->dwDistChannel == LICENSE_DISTRIBUTION_CHANNEL_OEM) ? 
                                                    LSKEYPACKCHANNELOFPURCHASE_OEM : 
                                                    LSKEYPACKCHANNELOFPURCHASE_RETAIL;

    pmLsKeyPack->keypack.dwProductFlags = LSKEYPACKPRODUCTFLAG_UNKNOWN;

    pmLsKeyPack->IssueDate = pmLicensePack->IssueDate;
    pmLsKeyPack->ActiveDate = pmLicensePack->ActiveDate;
    pmLsKeyPack->ExpireDate = pmLicensePack->ExpireDate;

    //
    // Tel. registration does not pass us any begin serial number, ignore this field
    //
    _stprintf(
            pmLsKeyPack->keypack.szBeginSerialNumber, 
            _TEXT("%ld"), 
            0 // pmLicensePack->dwBeginSerialNum
        );

    pmLsKeyPack->keypack.wMajorVersion = HIWORD(pmLicensePack->dwProductVersion);
    pmLsKeyPack->keypack.wMinorVersion = LOWORD(pmLicensePack->dwProductVersion);
    _tcscpy(
        pmLsKeyPack->keypack.szCompanyName, 
        pmLicensePack->szCompanyName
    );


    //
    // KeyPackId, tel. registration does not pass any begin license serial number so to be able
    // to track duplicate, pmLicensePack->KeypackSerialNum.Data1 is the actual license pack 
    // serial number, all other field are ignored.
    //
    StringCbPrintf(
            pmLsKeyPack->keypack.szKeyPackId,
            sizeof(pmLsKeyPack->keypack.szKeyPackId),
            TERMSERV_KEYPACKID_FORMAT,
            pmLicensePack->szProductId,
            pmLsKeyPack->keypack.wMajorVersion,
            pmLsKeyPack->keypack.wMinorVersion,
            pmLsKeyPack->keypack.dwPlatformType,
            pmLicensePack->KeypackSerialNum.Data1
        );
            

    StringCbPrintf(
            pmLsKeyPack->keypack.szProductId,
            sizeof(pmLsKeyPack->keypack.szProductId),
            TERMSERV_PRODUCTID_FORMAT,
            pmLicensePack->szProductId,
            pmLsKeyPack->keypack.wMajorVersion,
            pmLsKeyPack->keypack.wMinorVersion,
            (!bInternetPackage)
                ? ((!bConcurrentPackage) ? TERMSERV_FULLVERSION_TYPE : TERMSERV_CONCURRENT_TYPE)
                : TERMSERV_INTERNET_TYPE
        );


    pmLsKeyPack->keypack.dwTotalLicenseInKeyPack = pmLicensePack->dwQuantity;
    pmLsKeyPack->keypack.dwNumberOfLicenses = pmLicensePack->dwQuantity;  

    //
    // Fill in list of product description
    //
    if( pmLicensePack->SourceType == REGISTER_SOURCE_INTERNET )
    {
        pmLsKeyPack->dwDescriptionCount = pmLicensePack->dwDescriptionCount;
        pmLsKeyPack->pDescription = pmLicensePack->pDescription;
    }
    else
    {
        LPTSTR *pszDescs;
        LPTSTR *pszLocalizedDescs;

        //
        // Verify version first...
        //

        if (pmLsKeyPack->keypack.wMajorVersion == 5 &&
            (pmLsKeyPack->keypack.wMinorVersion == 1 || pmLsKeyPack->keypack.wMinorVersion == 2))
        {
            if (bConcurrentPackage)
            {
                pszDescs = g_pszUSConcurrentKeyPackProductDesc51;
                pszLocalizedDescs = g_pszLocalizedConcurrentKeyPackProductDesc51;
            }
            else if (bInternetPackage)
            {
                *pdwErrCode = ERROR_INVALID_PARAMETER;
                dwStatus = POLICY_NOT_SUPPORTED;
                goto cleanup;
            }
            else
            {
                pszDescs = g_pszUSStandardKeyPackProductString51;
                pszLocalizedDescs = g_pszLocalizedStandardKeyPackProductString51;
            }
        }
        else if (pmLsKeyPack->keypack.wMajorVersion == 5 &&
                 pmLsKeyPack->keypack.wMinorVersion == 0)
        {
            if (bInternetPackage)
            {
                pszDescs = g_pszUSInternetKeyPackProductDesc;
                pszLocalizedDescs = g_pszLocalizedInternetKeyPackProductDesc;
            }            
            else if (bConcurrentPackage)
            {
                *pdwErrCode = ERROR_INVALID_PARAMETER;
                dwStatus = POLICY_NOT_SUPPORTED;
                goto cleanup;
            }
            else
            {
                pszDescs = g_pszUSStandardKeyPackProductString;
                pszLocalizedDescs = g_pszLocalizedStandardKeyPackProductString;
            }
        }
        else
        {
            *pdwErrCode = ERROR_INVALID_PARAMETER;
            dwStatus = POLICY_NOT_SUPPORTED;
            goto cleanup;
        }
        DWORD dwMakeLangID = MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US);
        DWORD dwGetLangID = GetSystemDefaultLangID();

        // one for english and one for localized version
        pmLsKeyPack->dwDescriptionCount = (dwGetLangID != dwMakeLangID)? 2 : 1;
        
        pmLsKeyPack->pDescription =
            (PPMREGISTERLKPDESC) pClient->AllocateMemory(
                                        MEMORY_LICENSEREGISTRATION,
                                        sizeof(PMREGISTERLKPDESC) * pmLsKeyPack->dwDescriptionCount
                                        );

        if(pmLsKeyPack->pDescription == NULL)
        {
            *pdwErrCode = ERROR_OUTOFMEMORY;
            dwStatus = POLICY_CRITICAL_ERROR;
            goto cleanup;
        }

        pmLsKeyPack->pDescription[0].Locale = MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US);

        if(pmLsKeyPack->dwDescriptionCount == 2)
        {
            pmLsKeyPack->pDescription[1].Locale = dwGetLangID;
        }

        if (bInternetPackage && (pmLsKeyPack->keypack.wMajorVersion == 5 &&
                 pmLsKeyPack->keypack.wMinorVersion == 0))
        {        
            _tcscpy(
                    pmLsKeyPack->pDescription[0].szProductName, 
                    g_pszUSInternetKeyPackProductDesc[INDEX_PRODUCTNAME]
                    );

            _tcscpy(
                    pmLsKeyPack->pDescription[0].szProductDesc, 
                    pszDescs[INDEX_PRODUCTDESC]
                    );
            
            if(pmLsKeyPack->dwDescriptionCount == 2)
            {
                _tcscpy(
                        pmLsKeyPack->pDescription[1].szProductName, 
                        g_pszLocalizedInternetKeyPackProductDesc[INDEX_PRODUCTNAME]
                        );

                _tcscpy(
                        pmLsKeyPack->pDescription[1].szProductDesc, 
                        pszLocalizedDescs[INDEX_PRODUCTDESC]
                        );
            }

        }
        else if (bConcurrentPackage && (pmLsKeyPack->keypack.wMajorVersion == 5 &&
                 pmLsKeyPack->keypack.wMinorVersion == 1))
        {
            
            _tcscpy(
                    pmLsKeyPack->pDescription[0].szProductName, 
                    g_pszUSConcurrentKeyPackProductDesc51[INDEX_PRODUCTNAME]
                    );

            _tcscpy(
                    pmLsKeyPack->pDescription[0].szProductDesc, 
                    pszDescs[INDEX_PRODUCTDESC]                    
                    );            
            if(pmLsKeyPack->dwDescriptionCount == 2)
            {            
                _tcscpy(
                        pmLsKeyPack->pDescription[1].szProductName, 
                        g_pszLocalizedConcurrentKeyPackProductDesc51[INDEX_PRODUCTNAME]
                        );

                _tcscpy(
                    pmLsKeyPack->pDescription[1].szProductDesc, 
                        pszLocalizedDescs[INDEX_PRODUCTDESC]                    
                        );
            }
        }
        else
        {
            if(bInternetPackage || bConcurrentPackage)
            {
                *pdwErrCode = ERROR_INVALID_PARAMETER;
                dwStatus = POLICY_NOT_SUPPORTED;
                goto cleanup;
            }

            if (pmLsKeyPack->keypack.wMajorVersion == 5 &&
                 pmLsKeyPack->keypack.wMinorVersion == 0)
            {

            
                _tcscpy(
                        pmLsKeyPack->pDescription[0].szProductName, 
                        g_pszUSStandardKeyPackProductString[INDEX_PRODUCTNAME]
                        );

                _tcscpy(
                        pmLsKeyPack->pDescription[0].szProductDesc, 
                        pszDescs[INDEX_PRODUCTDESC]                    
                        );

                if(pmLsKeyPack->dwDescriptionCount == 2)
                {

                    _tcscpy(
                            pmLsKeyPack->pDescription[1].szProductName, 
                            g_pszLocalizedStandardKeyPackProductString[INDEX_PRODUCTNAME]
                            );

                    _tcscpy(
                            pmLsKeyPack->pDescription[1].szProductDesc, 
                            pszLocalizedDescs[INDEX_PRODUCTDESC]                    
                            );
                }
            }
            else if(pmLsKeyPack->keypack.wMajorVersion == 5 &&
                 (pmLsKeyPack->keypack.wMinorVersion == 1 || pmLsKeyPack->keypack.wMinorVersion == 2) )
            {                             
                 _tcscpy(
                        pmLsKeyPack->pDescription[0].szProductName, 
                        g_pszUSStandardKeyPackProductString51[INDEX_PRODUCTNAME]
                        );

                _tcscpy(
                        pmLsKeyPack->pDescription[0].szProductDesc, 
                        pszDescs[INDEX_PRODUCTDESC]                    
                        );

                if(pmLsKeyPack->dwDescriptionCount == 2)
                {
                    _tcscpy(
                            pmLsKeyPack->pDescription[1].szProductName, 
                            g_pszLocalizedStandardKeyPackProductString51[INDEX_PRODUCTNAME]
                            );

                    _tcscpy(
                            pmLsKeyPack->pDescription[1].szProductDesc, 
                            pszLocalizedDescs[INDEX_PRODUCTDESC]                    
                            );
                }
            }

        }        
    }

cleanup:

    return dwStatus;
}

////////////////////////////////////////////////////////
POLICYSTATUS
CompleteRegisterLicensePack(
    IN PMHANDLE client,
    IN DWORD dwErrCode,
    OUT PDWORD pdwErrCode
    )
/*++

--*/
{
    UNREFERENCED_PARAMETER(dwErrCode);

    //
    // Free memory allocated for the client
    //
    g_ClientMgr->DestroyClient( client );
    *pdwErrCode = ERROR_SUCCESS;
    return POLICY_SUCCESS;
}

////////////////////////////////////////////////////////

POLICYSTATUS WINAPI
PMRegisterLicensePack(
    PMHANDLE client,
    DWORD dwProgressCode,
    PVOID pbProgressData,
    PVOID pbReturnData,
    PDWORD pdwErrCode
    )
/*++

--*/
{
    POLICYSTATUS dwStatus = POLICY_SUCCESS;

    switch(dwProgressCode)
    {
        case REGISTER_PROGRESS_NEW:
            dwStatus = ProcessRegisterLicensePack(
                                       client,
                                       (PPMREGISTERLICENSEPACK) pbProgressData,
                                       (PPMLSKEYPACK)pbReturnData,
                                       pdwErrCode
                                       );
            break;

        case REGISTER_PROGRESS_END:
            dwStatus = CompleteRegisterLicensePack(
                                       client,
                                       #ifdef _WIN64
                                           PtrToUlong(pbProgressData),
                                       #else
                                           (DWORD) pbProgressData,
                                       #endif
                                       pdwErrCode
                                       );
            break;

        default:
            *pdwErrCode = ERROR_INVALID_PARAMETER;
            dwStatus = POLICY_ERROR;

    }

    return dwStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\license\tlserver\tls236\tlsbkup-c.c ===
#include <tlsbkup_c.c>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\license\tlserver\tlsapi\cert.c ===
//+----------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996-1998
//
// File:        cert.c
//
// Contents:    Centralized server certificate management
//
// History:     02-09-00    RobLeit  Created
//
//-----------------------------------------------------------------------------
#include <windows.h>
#include "license.h"
#include "lscsp.h"

///////////////////////////////////////////////////////////////////////////////
LICENSE_STATUS
TLSGetTSCertificate(
    CERT_TYPE       CertType,
    LPBYTE          *ppbCertificate,
    LPDWORD         pcbCertificate)
{
    LICENSE_STATUS  Status;
    DWORD           dwSize;
    LSCSPINFO       CspData;

    if( CERT_TYPE_PROPRIETORY == CertType )
    {
        CspData = LsCspInfo_Certificate;
    }
    else if( CERT_TYPE_X509 == CertType )
    {
        CspData = LsCspInfo_X509Certificate;
    }
    else
    {
        return( LICENSE_STATUS_NO_CERTIFICATE );
    }

    Status = LsCsp_GetServerData( CspData, NULL, &dwSize );

    if( LICENSE_STATUS_OK != Status )
    {
        return( Status );
    }

    if( 0 == dwSize )
    {
        return( LICENSE_STATUS_INVALID_INPUT );
    }

    *ppbCertificate = LocalAlloc( LMEM_ZEROINIT, dwSize );

    if( NULL == *ppbCertificate )
    {
        return( LICENSE_STATUS_OUT_OF_MEMORY );
    }
    
    Status = LsCsp_GetServerData( CspData, *ppbCertificate, &dwSize );

    if( LICENSE_STATUS_OK != Status )
    {
        LocalFree( *ppbCertificate );
        return( Status );
    }

    *pcbCertificate = dwSize;

    return( LICENSE_STATUS_OK );
}

LICENSE_STATUS
TLSFreeTSCertificate(
    LPBYTE          pbCertificate)
{
    if (NULL != pbCertificate)
    {
        LocalFree(pbCertificate);

        return LICENSE_STATUS_OK;
    }
    else
    {
        return LICENSE_STATUS_INVALID_INPUT;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\license\tlserver\tls236\tls236.h ===
//+--------------------------------------------------------------------------
//
// Copyright (c) 1997-1999 Microsoft Corporation
//
// File:       tls236.h 
//
// Contents:    
//
// History:     
//
//---------------------------------------------------------------------------
#ifndef __TLSA02_H__
#define __TLSA02_H__

#include "tlsstl.h"    // STL

#include <stdio.h>
#include <tchar.h>
#include <assert.h>
#include "tlsapi.h"
#include "tlspol.h"
#include "ntverp.h"
#include "locks.h"


#define US_IDS_COMPANYNAME          _TEXT("Microsoft Corporation")

#define US_IDS_EX_PRODUCTNAME       _TEXT("Existing Windows Server - Terminal Services CAL Token (per device)")
#define US_IDS_EX_PRODUCTDESC       _TEXT("Existing Windows 2000 Server - Terminal Services CAL Token (per device)")

#define US_IDS_S_PRODUCTNAME        _TEXT("Windows Server - Terminal Server Per Device CAL Token")
#define US_IDS_S_PRODUCTDESC        _TEXT("Windows 2000 Server - Terminal Services CAL Token (per device)")
#define US_IDS_S_PRODUCTDESC51      _TEXT("Windows Server 2003 - Terminal Server Per Device CAL Token")

#define US_IDS_I_PRODUCTNAME        _TEXT("Windows Server - Terminal Services Internet Connector License Token")
#define US_IDS_I_PRODUCTDESC        _TEXT("Windows 2000 Server - Terminal Services Internet Connector License Token")


#define US_IDS_C_PRODUCTNAME        _TEXT("Windows Server - Terminal Server Per User CAL Token")
#define US_IDS_C_PRODUCTDESC51      _TEXT("Windows Server 2003 - Terminal Server Per User CAL Token")


//
// A02 Product ID
//
#define PLATFORMID_UPGRADE  1
#define PLATFORMID_FREE     2
#define PLATFORMID_OTHERS   0xFF    // also used for Concurrent and Internet

#define LSKEYPACK_LOCAL_TYPE    0x40 

//
// 236 is for NT4 TS client.
//
#define TERMSERV_PRODUCTID_CH       _TEXT("001")
#define TERMSERV_PRODUCTID_SKU      _TEXT("A02")
#define TERMSERV_FULLVERSION_TYPE   _TEXT("S")
#define TERMSERV_FREE_TYPE          _TEXT("EX")

//
// Internet Package
//
#define TERMSERV_INTERNET_CH        _TEXT("002")
#define TERMSERV_INTERNET_SKU       _TEXT("B96")
#define TERMSERV_INTERNET_TYPE      _TEXT("I")

//
// Concurrent Package
//
#define TERMSERV_CONCURRENT_CH     _TEXT("003")
#define TERMSERV_CONCURRENT_SKU    _TEXT("C50")
#define TERMSERV_CONCURRENT_TYPE   _TEXT("C")

//
// Whistler Package
//
#define TERMSERV_WHISTLER_PRODUCTID_CH      _TEXT("004")



#define TERMSERV_PRODUCTID_FORMAT        _TEXT("%3s-%ld.%02ld-%s")

#define TERMSERV_PRODUCTID_SCAN_FORMAT   _TEXT("%3s-%ld.%02ld-%9s")

#define MAX_TERMSRV_PRODUCTID       LSERVER_MAX_STRING_SIZE

//
// keypack ID is ProductID+MajorVersion+MinorVersion+SerialNumber
//
#define TERMSERV_KEYPACKID_FORMAT   _TEXT("%s%02d%02d%02d%d")

#define TLSA02_VERSION (MAKELONG(MAKEWORD(0, HIBYTE(VER_PRODUCTVERSION_W)), 0))

#define CURRENT_TLSA02_VERSION  HIBYTE(LOWORD(TLSA02_VERSION))

#define WINDOWS_VERSION_NT5         5
#define WINDOWS_VERSION_BASE        2000

#define MAX_SKU_PREFIX              10
#define MAX_SKU_POSTFIX             10

#define MALLOC(size)    LocalAlloc(LPTR, size)

#define FREE(ptr) \
    if(ptr)             \
    {                   \
        LocalFree(ptr); \
        ptr=NULL;       \
    }

#define SAFESTRCPY(dest, source) \
    {                               \
        _tcsncpy(dest, source, min(_tcslen(source), sizeof(dest)/sizeof(TCHAR))); \
        dest[min(_tcslen(source), (sizeof(dest)/sizeof(TCHAR) - 1))] = _TEXT('\0'); \
    }

#define STRBUFSIZE(x)   (sizeof(x) / sizeof(x[0]))

//---------------------------------------------------
typedef enum {
    MEMORY_UNKNOWN,
    MEMORY_GENERAL,
    MEMORY_STRING,
    MEMORY_KEYPACKDESC,
    MEMORY_LICENSE_REQUEST,
    MEMORY_CERTEXTENSION,
    MEMORY_LICENSEREGISTRATION
} MEMORYPOINTERTYPE;

//----------------------------------------------------
typedef struct __PointerType {
    MEMORYPOINTERTYPE m_MemoryType;
    HLOCAL m_Ptr;

    //-----------------------------------------
    __PointerType() : 
        m_MemoryType(MEMORY_UNKNOWN), 
        m_Ptr(NULL)
    {
    }
    
    //--------------------------------------
    __PointerType(
        MEMORYPOINTERTYPE ptrType,
        HLOCAL ptr
        ) :
        m_MemoryType(ptrType),
        m_Ptr(ptr)
    /*++
    ++*/
    {
    }

    //---------------------------------------
    PVOID
    GetPointer() 
    { 
        return m_Ptr; 
    }
} PointerType;

//----------------------------------------------
class CRefCounter {
private:

    long    m_RefCounter;

public:

    CRefCounter() : m_RefCounter(0) {}
    ~CRefCounter() 
    {
        if(DecRef() == 0)
        {
            delete this;
        }
    }

    long
    AddRef() { 
        return InterlockedIncrement(&m_RefCounter); 
    }

    long
    DecRef() { 
        return InterlockedDecrement(&m_RefCounter); 
    }
};
    
//---------------------------------------------
class CClient {
private:

    PMHANDLE  m_hClient;       // client handle

    //
    // list of memory allocated
    list<PointerType> m_AllocatedMemory;

public:

    CClient(PMHANDLE hClient);
    ~CClient();

    //-----------------------------------------
    HLOCAL 
    AllocateMemory(
        MEMORYPOINTERTYPE ptrType, 
        DWORD dwSize
    );

    //-----------------------------------------
    PMHANDLE
    GetPMHANDLE() {
        return m_hClient;
    }
};   

//------------------------------------------------------

class CClientMgr {
private:

    CCriticalSection m_HandleMapLock;
    typedef map<PMHANDLE, CClient*, less<PMHANDLE> > MapHandleToClient;
    MapHandleToClient m_HandleMap;

public:

    CClientMgr() {}
    ~CClientMgr();

    void
    Cleanup();

    CClient*
    FindClient(PMHANDLE hClient);

    BOOL
    DestroyClient(PMHANDLE hClient);
};

#ifdef __cplusplus
extern "C" {
#endif

void
InitPolicyModule(
    IN HMODULE
);
    
BOOL
LoadResourceString(
    IN DWORD dwId,
    IN OUT LPTSTR szBuf,
    IN DWORD dwBufSize
);

DWORD
AddA02KeyPack(
    DWORD dwVersion
);

DWORD
InsertLicensePack(
    IN TLS_HANDLE tlsHandle,
    IN DWORD dwProdVersion,
    IN DWORD dwDescVersion,
    IN DWORD dwPlatformType,
    IN UCHAR ucAgreementType,
    IN LPTSTR pszProductId,
    IN LPTSTR pszKeyPackId,
    IN LPTSTR pszUsDesc[],
    IN LPTSTR pszLocalizedDesc[]
);

POLICYSTATUS
ProcessUpgradeRequest(
    PMHANDLE hClient,
    PPMUPGRADEREQUEST pUpgrade,
    PPMLICENSEREQUEST* pbAdjustedRequest,
    PDWORD pdwErrCode,
    DWORD dwIndex
);


BOOL LicenseTypeFromLookupTable(
	IN DWORD dwClientVer,
	IN DWORD dwTermSrvVer,
	OUT PDWORD pdwCALType
);


#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\license\tlserver\tls236\tls236.cpp ===
//+--------------------------------------------------------------------------
//
// Copyright (c) 1997-1999 Microsoft Corporation
//
// File:       tls236.cpp
//
// Contents:    
//
// History:     
//
//---------------------------------------------------------------------------
#include "pch.cpp"

CClientMgr* g_ClientMgr=NULL;


////////////////////////////////////////////////////////
// 
// CClient Class
//
////////////////////////////////////////////////////////
CClient::CClient(
    IN PMHANDLE hClient
    ) :
    m_hClient(hClient)
/*++

Abstract:

    Constructor for CClient class.

Parameter:

    hClient : client handle

Return:

    None.

++*/
{
}


//------------------------------------------------------
CClient::~CClient()
/*++

Abstract:

    Destructor for CClient class

Parameter:

    None

Return:

    None

++*/
{
    for(list<PointerType>::iterator it = m_AllocatedMemory.begin(); 
        it != m_AllocatedMemory.end();
        it++)
    {
        HLOCAL ptr = (*it).GetPointer(); 
        FREE(ptr);
    }

    // m_AllocatedMemory.erase(m_AllocatedMemory.begin(), m_AllocatedMemory.end());
}

//------------------------------------------------------
HLOCAL
CClient::AllocateMemory(
    IN MEMORYPOINTERTYPE ptrType,
    IN DWORD dwSize
    )
/*++

Abstract:

    Allocate/store memory allocated into memory list.

Parameter:

    dwSize - Number of byte to allocate.

Return:

    Same as from LocalAlloc().

++*/
{
    HLOCAL ptr = NULL;
    DWORD dwStatus = ERROR_SUCCESS;

    ptr = MALLOC(dwSize);

    if(ptr != NULL)
    {
        //
        // Append to allocated list.
        //
        m_AllocatedMemory.push_back( PointerType(ptrType, ptr) );
    }

    if(dwStatus != ERROR_SUCCESS)
    {
        if(ptr != NULL)
        {
            FREE(ptr);
            ptr = NULL;
        }
    }

    return ptr;
}


////////////////////////////////////////////////////////
// 
// CClientMgr
//
////////////////////////////////////////////////////////
CClientMgr::~CClientMgr()
{
    Cleanup();
}

//------------------------------------------------------
void
CClientMgr::Cleanup()
/*++

++*/
{
    MapHandleToClient::iterator it;
    m_HandleMapLock.Lock();

    for(it = m_HandleMap.begin(); it != m_HandleMap.end(); it++)
    {
        assert( ((*it).second)->GetRefCount() == 1 );
    }

    m_HandleMapLock.UnLock();
    //
    // Always perform cleanup
    //
    // m_HandleMap.erase(m_HandleMap.begin(), m_HandleMap.end());
}

//------------------------------------------------------
CClient*
CClientMgr::FindClient(
    IN PMHANDLE hClient
    )
/*++

Abstract:

    Routine to find client object, add client object if not found.

Parameter:

    hClient - Client handle

Return:

++*/
{
    MapHandleToClient::iterator it;
    CClient*ptr = NULL;
    DWORD dwStatus = ERROR_SUCCESS;

    m_HandleMapLock.Lock();

    it = m_HandleMap.find(hClient);
    if( it == m_HandleMap.end() )
    {
        CClient* pClient;
        pClient = new CClient(hClient);
        if(pClient != NULL)
        {
            m_HandleMap[hClient] = pClient;

            // pair<PMHANDLE, CClient*> m(hClient, pClient);
            //m_HandleMap.insert( m );

            // m_HandleMap.insert( pair<PMHANDLE, CClient*>(hClient, pClient) );
            it = m_HandleMap.find(hClient);
            assert(it != m_HandleMap.end());
        }
    }

    if(it != m_HandleMap.end())
    {
        ptr = (*it).second;
    }    

    m_HandleMapLock.UnLock();
    return ptr;
}

//------------------------------------------------------
BOOL
CClientMgr::DestroyClient(
    IN PMHANDLE hClient
    )
/*++


++*/
{
    MapHandleToClient::iterator it;
    BOOL bSuccess = FALSE;

    m_HandleMapLock.Lock();

    it = m_HandleMap.find(hClient);
    if(it != m_HandleMap.end())
    {
        delete (*it).second;
        m_HandleMap.erase(it);
        bSuccess = TRUE;
    }

    m_HandleMapLock.UnLock();
    return bSuccess;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\license\tlserver\tls236\sources.inc ===
!IF 0

Copyright (c) 1989  Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


Author:


NOTE:   Commented description of this file is in \nt\bak\bin\sources.tpl

!ENDIF

!include $(LSERVER_ROOT)\lserver.mk

USE_MSVCRT=1
USE_STL=1

MAJORCOMP=hydra
MINORCOMP=tls236

TARGETNAME=$(MINORCOMP)
TARGETPATH=obj
TARGETTYPE=DYNLINK

SOURCES_OPTIONS=-c0

UMTYPE=windows

DLLDEF=..\tls236.def
COFFBASE=usermode
DLLENTRY=_DllMainCRTStartup
PRECOMPILED_INCLUDE=..\pch.cpp

PASS0_HEADERDIR=$(O)
MC_SOURCEDIR=$(O)

SOURCES= \
    ..\messages.mc \
    ..\tls236.rc \
    ..\dllmain.c \
    ..\request.cpp \
    ..\tls236.cpp \
    ..\tlsbkupc.cpp \
    ..\tlsbkup-c.c


TARGETLIBS=\
    $(TERMSRV_ROOT)\lib\$(O)\trust.lib \
    $(TERMSRV_ROOT)\lib\$(O)\tlsapip.lib \
    $(SDK_LIB_PATH)\rpcrt4.lib \
    $(SDK_LIB_PATH)\rpcns4.lib \
    $(SDK_LIB_PATH)\netapi32.lib \
    $(SDK_LIB_PATH)\advapi32.lib \
    $(SDK_LIB_PATH)\comctl32.lib \
    $(SDK_LIB_PATH)\gdi32.lib \
    $(SDK_LIB_PATH)\user32.lib \
    $(SDK_LIB_PATH)\shell32.lib \
    $(SDK_LIB_PATH)\kernel32.lib \
    $(SDK_LIB_PATH)\msvcprt.lib
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\license\tlserver\tls236\tlsbkupc.cpp ===
//+--------------------------------------------------------------------------
//
// Copyright (c) 1997-1999 Microsoft Corporation
//
// File:        tlsbkupc.cpp
//
// Contents:    
//
// History:     
//
//---------------------------------------------------------------------------
#include "pch.cpp"
#include "locks.h"
#include "tlsbkup.h"

#define STRSAFE_NO_DEPRECATE
#include <strsafe.h>

#define LSERVER_REGISTRY_BASE           _TEXT("SYSTEM\\CurrentControlSet\\Services\\")
#define LSERVER_PARAMETERS              _TEXT("Parameters")
#define LSERVER_PARAMETERS_DBPATH       _TEXT("DBPath")        // database file
#define LSERVER_PARAMETERS_DBFILE       _TEXT("DBFile")        // database file
#define SZSERVICENAME                   _TEXT("TermServLicensing")
#define LSERVER_DEFAULT_DBPATH          _TEXT("%SYSTEMROOT%\\SYSTEM32\\LSERVER\\")
#define LSERVER_DEFAULT_EDB             _TEXT("TLSLic.edb")
#define TLSBACKUP_EXPORT_DIR            _TEXT("Export")

TCHAR g_szDatabaseDir[MAX_PATH+1];
TCHAR g_szDatabaseFile[MAX_PATH+1];
TCHAR g_szExportedDb[MAX_PATH+1];
TCHAR g_szDatabaseFname[MAX_PATH+1];

CCriticalSection g_ImportExportLock;

DWORD GetDatabasePaths()
{
    DWORD Status;
    HKEY hKey = NULL;
    DWORD dwBuffer;
    TCHAR szDbPath[MAX_PATH+1];
    TCHAR *pszDatabaseEnd;
    size_t cbRemaining;
    HRESULT hr;

    //-------------------------------------------------------------------
    //
    // Open HKLM\system\currentcontrolset\sevices\termservlicensing\parameters
    //
    //-------------------------------------------------------------------
    Status = RegCreateKeyEx(
                        HKEY_LOCAL_MACHINE,
                        LSERVER_REGISTRY_BASE SZSERVICENAME _TEXT("\\") LSERVER_PARAMETERS,
                        0,
                        NULL,
                        REG_OPTION_NON_VOLATILE,
                        KEY_ALL_ACCESS,
                        NULL,
                        &hKey,
                        NULL
                    );

    if(Status != ERROR_SUCCESS)
    {
        return Status;
    }

    //-------------------------------------------------------------------
    //
    // Get database file location and file name
    //
    //-------------------------------------------------------------------
    dwBuffer = sizeof(szDbPath) / sizeof(szDbPath[0]);

    Status = RegQueryValueEx(
                        hKey,
                        LSERVER_PARAMETERS_DBPATH,
                        NULL,
                        NULL,
                        (LPBYTE)szDbPath,
                        &dwBuffer
                    );
    if(Status != ERROR_SUCCESS)
    {
        //
        // use default value, 
        //
        _tcscpy(
                szDbPath,
                LSERVER_DEFAULT_DBPATH
            );
    }

    //
    // Get database file name
    //
    dwBuffer = sizeof(g_szDatabaseFname) / sizeof(g_szDatabaseFname[0]);
    Status = RegQueryValueEx(
                        hKey,
                        LSERVER_PARAMETERS_DBFILE,
                        NULL,
                        NULL,
                        (LPBYTE)g_szDatabaseFname,
                        &dwBuffer
                    );
    if(Status != ERROR_SUCCESS)
    {
        //
        // Use default value.
        //
        _tcscpy(
                g_szDatabaseFname,
                LSERVER_DEFAULT_EDB
            );
    }

    RegCloseKey(hKey);

    //
    // Always expand DB Path.
    //
    
    Status = ExpandEnvironmentStrings(
                        szDbPath,
                        g_szDatabaseDir,
                        sizeof(g_szDatabaseDir) / sizeof(g_szDatabaseDir[0])
                    );

    if(Status == 0)
    {
        // can't expand environment variable, error out.
        return GetLastError();
    }

    Status = 0;

    if(g_szDatabaseDir[_tcslen(g_szDatabaseDir) - 1] != _TEXT('\\'))
    {
        // JetBlue needs this.
        StringCbCat(g_szDatabaseDir, sizeof(g_szDatabaseDir), _TEXT("\\"));
    } 

    //
    // Full path to database file
    //
    hr = StringCbCopyEx(g_szDatabaseFile,sizeof(g_szDatabaseFile),g_szDatabaseDir,&pszDatabaseEnd, &cbRemaining,0);

    if (FAILED(hr))
    {
        return HRESULT_CODE(hr);
    }

    hr = StringCbCopyEx(pszDatabaseEnd,cbRemaining,g_szDatabaseFname,NULL, NULL,0);

    if (FAILED(hr))
    {
        return HRESULT_CODE(hr);
    }

    hr = StringCbCopyEx(g_szExportedDb,sizeof(g_szExportedDb),g_szDatabaseDir,&pszDatabaseEnd, &cbRemaining,0);

    if (FAILED(hr))
    {
        return HRESULT_CODE(hr);
    }

    hr = StringCbCopyEx(pszDatabaseEnd,cbRemaining,TLSBACKUP_EXPORT_DIR,NULL, NULL,0);

    if (FAILED(hr))
    {
        return HRESULT_CODE(hr);
    }

    return Status;
}

HRESULT WINAPI
I_ExportTlsDatabaseC()
{
    DWORD dwRet = 0;
    LPTSTR pszStringBinding;
    TCHAR pComputer[MAX_COMPUTERNAME_LENGTH + 1];
    DWORD dwSize = sizeof(pComputer) / sizeof(TCHAR);
    RPC_STATUS Status = RPC_S_OK;
    HRESULT hr;
    TCHAR *pszDatabaseEnd;
    size_t cbRemaining;

    if (!GetComputerName(pComputer,&dwSize))
    {
        return GetLastError();
    }

    Status = RpcStringBindingCompose(NULL,TEXT("ncalrpc"),pComputer,NULL,NULL,&pszStringBinding);
    if (Status)
    {
        return Status;
    }

    Status = RpcBindingFromStringBinding(pszStringBinding,
                                         &TermServLicensingBackup_IfHandle);
    if (Status)
    {
        RpcStringFree(&pszStringBinding);

        goto TryCopyFile;
    }

    RpcTryExcept {
        dwRet = ExportTlsDatabase();
    }
    RpcExcept (I_RpcExceptionFilter(RpcExceptionCode())) {
        Status = RpcExceptionCode();
    }
    RpcEndExcept;

    RpcStringFree(&pszStringBinding);
    RpcBindingFree(&TermServLicensingBackup_IfHandle);

#if DBG
    {
        char szStatusCode[256];
        sprintf( szStatusCode, "I_ExportTlsDatabaseC() returns %d\n", Status );
        OutputDebugStringA( szStatusCode );
    }
#endif
    
    //
    // Only actually touch file when server is not available
    //

    if ( RPC_S_OK == Status)
    {
        return dwRet;
    }

TryCopyFile:

    Status = GetDatabasePaths();
    if (Status != 0)
    {
        return Status;
    }

    CreateDirectoryEx(g_szDatabaseDir,
                      g_szExportedDb,
                      NULL);     // Ignore errors, they'll show up in CopyFile

    hr = StringCbCatEx(g_szExportedDb, sizeof(g_szExportedDb), _TEXT("\\"), &pszDatabaseEnd, &cbRemaining,0);
    if (FAILED(hr))
    {
        return HRESULT_CODE(hr);
    }

    hr = StringCbCopyEx(pszDatabaseEnd,cbRemaining,g_szDatabaseFname,NULL, NULL,0);

    if (FAILED(hr))
    {
        return HRESULT_CODE(hr);
    }

    // Copy database file
    if (!CopyFile(g_szDatabaseFile,g_szExportedDb,FALSE))
    {
        return GetLastError();
    }

    return 0;   // Success
}

HRESULT WINAPI
ExportTlsDatabaseC()
{
    // avoid compiler error C2712
    // no need for multi-process save.
    CCriticalSectionLocker lock( g_ImportExportLock );

    return I_ExportTlsDatabaseC();
}

HRESULT WINAPI
I_ImportTlsDatabaseC()
{
    DWORD dwRet = 0;
    LPTSTR pszStringBinding;
    TCHAR pComputer[MAX_COMPUTERNAME_LENGTH + 1];
    DWORD dwSize = sizeof(pComputer) / sizeof(TCHAR);
    RPC_STATUS Status = RPC_S_OK;
    HANDLE hFile;
    SYSTEMTIME systime;
    FILETIME ft;
    HRESULT hr;
    TCHAR *pszDatabaseEnd;
    size_t cbRemaining;

    if (!GetComputerName(pComputer,&dwSize))
    {
        return GetLastError();
    }

    Status = RpcStringBindingCompose(NULL,TEXT("ncalrpc"),pComputer,NULL,NULL,&pszStringBinding);
    if (Status)
    {
        return Status;
    }

    Status = RpcBindingFromStringBinding(pszStringBinding,
                                         &TermServLicensingBackup_IfHandle);
    if (Status)
    {
        RpcStringFree(&pszStringBinding);

        goto TouchFile;
    }

    RpcTryExcept {
        dwRet = ImportTlsDatabase();
    }
    RpcExcept (I_RpcExceptionFilter(RpcExceptionCode())) {
        Status = RpcExceptionCode();
    }
    RpcEndExcept;

    RpcStringFree(&pszStringBinding);
    RpcBindingFree(&TermServLicensingBackup_IfHandle);

#if DBG
    {
        char szStatusCode[256];
        sprintf( szStatusCode, "I_ImportTlsDatabaseC() returns %d\n", Status );
        OutputDebugStringA( szStatusCode );
    }
#endif

    //
    // Only actually touch file when server is not available
    //

    if ( RPC_S_OK == Status )
    {
        return(dwRet);
    }

TouchFile:

    Status = GetDatabasePaths();
    if (Status != 0)
    {
        return Status;
    }

    hr = StringCbCatEx(g_szExportedDb, sizeof(g_szExportedDb), _TEXT("\\"), &pszDatabaseEnd, &cbRemaining,0);
    if (FAILED(hr))
    {
        return HRESULT_CODE(hr);
    }

    hr = StringCbCopyEx(pszDatabaseEnd,cbRemaining,g_szDatabaseFname,NULL, NULL,0);

    if (FAILED(hr))
    {
        return HRESULT_CODE(hr);
    }

    GetSystemTime(&systime);

    if (!SystemTimeToFileTime(&systime,&ft))
    {
        return GetLastError();
    }

    hFile = CreateFile(g_szExportedDb,
                       GENERIC_WRITE,
                       0,
                       NULL,
                       OPEN_EXISTING,
                       FILE_ATTRIBUTE_NORMAL,
                       NULL);

    if (hFile == INVALID_HANDLE_VALUE)
    {
        return GetLastError();
    }

    if (!SetFileTime(hFile,
                     NULL,      // Creation time
                     NULL,      // Last access time
                     &ft))      // Last write time
    {
        CloseHandle(hFile);

        return GetLastError();
    }

    CloseHandle(hFile);

    return 0;   // Success
}

HRESULT WINAPI
ImportTlsDatabaseC()
{
    // avoid compiler error C2712
    // no need for multi-process save.
    CCriticalSectionLocker lock( g_ImportExportLock );

    return I_ImportTlsDatabaseC();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\license\tlserver\tlsapi\dllmain.c ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996-1996
//
// File:        
//
// Contents:    
//
// History:     
//
//---------------------------------------------------------------------------
#include <windows.h>

BOOL WINAPI _CRT_INIT(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpReserved);

void TLSShutdown();

BOOL WINAPI DllMain(IN HINSTANCE hinstance,
                    IN DWORD     reason,
                    IN LPVOID    reserved)
{
    switch(reason)
    {
        case DLL_PROCESS_ATTACH:
            if (!_CRT_INIT(hinstance, reason, reserved))
            {
                return(FALSE);
            }

            DisableThreadLibraryCalls(hinstance);
            break;

        case DLL_PROCESS_DETACH:
            TLSShutdown();

            if (!_CRT_INIT(hinstance, reason, reserved))
            {
                return(FALSE);
            }
            break;

    }

    return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\license\tlserver\tlsapi\global.h ===
/*++

Copyright (c) 1994-1998  Microsoft Corporation

Module Name:

    global.h

Abstract:

    Global data definitions for tshare security.

Author:

    Madan Appiah (madana)  24-Jan-1998

Environment:

    User Mode - Win32

Revision History:

--*/

#ifndef _GLOBAL_H_
#define _GLOBAL_H_

//-----------------------------------------------------------------------------
//
// global data definitions.
//
//-----------------------------------------------------------------------------

#define CSP_MUTEX_NAME  L"Global\\LSCSPMUTEX658fe2e8"


extern LPBSAFE_PUB_KEY csp_pRootPublicKey;

extern BYTE csp_abPublicKeyModulus[92];

extern LPBYTE csp_abServerCertificate;
extern DWORD  csp_dwServerCertificateLen;

extern LPBYTE csp_abServerX509Cert;
extern DWORD  csp_dwServerX509CertLen;

extern LPBYTE csp_abServerPrivateKey;
extern DWORD  csp_dwServerPrivateKeyLen;

extern LPBYTE csp_abX509CertPrivateKey;
extern DWORD  csp_dwX509CertPrivateKeyLen;

extern LPBYTE csp_abX509CertID;
extern DWORD  csp_dwX509CertIDLen;

extern Hydra_Server_Cert    csp_hscData;

extern HINSTANCE g_hinst;

extern HANDLE csp_hMutex;

extern LONG csp_InitCount;

//-----------------------------------------------------------------------------
// 
// Crypto-related  definitions
//
//-----------------------------------------------------------------------------

#define RSA_KEY_LEN             512
#define CAPI_MAX_VERSION        2

#define RDN_COMMON_NAME         "cn="

//-----------------------------------------------------------------------------
//
// Macros
//
//-----------------------------------------------------------------------------

#define ACQUIRE_EXCLUSIVE_ACCESS( x )  \
if( x ) \
{ \
    WaitForSingleObject(x, INFINITE); \
}

#define RELEASE_EXCLUSIVE_ACCESS( x ) \
if( x ) \
{ \
    ReleaseMutex(x); \
}

#endif // _GLOBAL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\license\tlserver\tlsapi\global.c ===
/*++

Copyright (c) 1994-1998  Microsoft Corporation

Module Name:

    glodata.c

Abstract:

    Global data definitions for tshare security.

Author:

    Madan Appiah (madana)  24-Jan-1998

Environment:

    User Mode - Win32

Revision History:

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <ntlsa.h>
#include <windows.h>
#include <winbase.h>
#include <winerror.h>

#include <tchar.h>
#include <stdio.h>

#include "license.h"
#include "cryptkey.h"
#include "lscsp.h"
#include "tlsapip.h"
#include "certutil.h"
#include "hydrakey.h"

#include <md5.h>
#include <sha.h>
#include <rsa.h>

#include <secdbg.h>
#include "global.h"

#ifdef OS_WIN16
#include <string.h>
#endif // OS_WIN16

//
// global data definitions.
//


BYTE csp_abPublicKeyModulus[92] = HYDRA_ROOT_PUBLIC_KEY;

LPBSAFE_PUB_KEY csp_pRootPublicKey = NULL;
LPBYTE          csp_abServerCertificate = NULL;
DWORD           csp_dwServerCertificateLen = 0;
LPBYTE          csp_abServerX509Cert = NULL;
DWORD           csp_dwServerX509CertLen = 0;
LPBYTE          csp_abX509CertID = NULL;
DWORD           csp_dwX509CertIDLen = 0;

HANDLE          csp_hMutex = NULL;

LONG            csp_InitCount = 0;

Hydra_Server_Cert   csp_hscData;
HINSTANCE       g_hinst;

LPBYTE          csp_abServerPrivateKey = NULL;
DWORD           csp_dwServerPrivateKeyLen = 0;
LPBYTE          csp_abX509CertPrivateKey = NULL;
DWORD           csp_dwX509CertPrivateKeyLen = 0;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\license\tlserver\tlsapi\csp.c ===
/*++

File name:      

    csp.c

Description:    
    
    Contains routines to support cryptographic routines for termserv

Copyright:

    Microsoft Confidential
    Copyright (c) Microsoft Corporation 1991-1998
    All rights reserved

History:

    Frederick Chong( FredCh )   07/29/98    Added functions to install
                                            X509 certificate.
   
--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <ntlsa.h>
#include <windows.h>
#include <winbase.h>
#include <winerror.h>

#include <tchar.h>
#include <stdio.h>

#include "license.h"
#include "cryptkey.h"
#include "lscsp.h"
#include "tlsapip.h"
#include "certutil.h"
#include "hydrakey.h"
#include "tssec.h"

//
// Only include RNG functions from tssec
//
#define NO_INCLUDE_LICENSING 1
#include <tssec.h>


#include <md5.h>
#include <sha.h>
#include <rsa.h>

#include <secdbg.h>
#include "global.h"

#ifdef OS_WIN16
#include <string.h>
#endif // OS_WIN16

#include "licecert.h"

#define LS_DISCOVERY_TIMEOUT (1*1000)

//-----------------------------------------------------------------------------
//
// Internal Functions
//
//-----------------------------------------------------------------------------

NTSTATUS
OpenPolicy(
    LPWSTR      ServerName,
    DWORD       DesiredAccess,
    PLSA_HANDLE PolicyHandle );

void
InitLsaString(
    PLSA_UNICODE_STRING LsaString,
    LPWSTR String );

LICENSE_STATUS
GenerateRsaKeyPair(
    LPBYTE *     ppbPublicKey,
    LPDWORD      pcbPublicKey,
    LPBYTE *     ppbPrivateKey,
    LPDWORD      pcbPrivateKey,
    DWORD        dwKeyLen );

LICENSE_STATUS
Bsafe2CapiPubKey(
    PCERT_PUBLIC_KEY_INFO   pCapiPubKeyInfo,
    LPBYTE                  pbBsafePubKey,
    DWORD                   cbBsafePubKey );

VOID
FreeCapiPubKey(
    PCERT_PUBLIC_KEY_INFO   pCapiPubKeyInfo );

LICENSE_STATUS
RequestCertificate(     
    TLS_HANDLE              hServer,
    PCERT_PUBLIC_KEY_INFO   pPubKeyInfo,
    LPBYTE *                ppbCertificate,
    LPDWORD                 pcbCertificate,
    HWID *                  pHwid );

LICENSE_STATUS
GetSubjectRdn(
    LPTSTR   * ppSubjectRdn );

LICENSE_STATUS
GenerateMachineHWID(
    PHWID    pHwid );


LICENSE_STATUS
ReloadCSPCertificateAndData();

LICENSE_STATUS
CreateProprietaryKeyAndCert(
    PBYTE *ppbPrivateKey,
    DWORD *pcbPrivateKey,
    PBYTE *ppbServerCert,
    DWORD *pcbServerCert);

BOOL IsSystemService();

/*++

Function:

    LsCsp_DecryptEnvelopedData

Routine Description:

    Decrypt the client random that is encrypted by the server public key.

Arguments:

    dwCertType - The type of certificate that is used in the encryption.

    pbEnvelopedData - pointer to a buffer where the encrypted random key is
    passed in.

    cbEnvelopedDataLen - length of the random key passed in/out.

    pbData - pointer to a buffer where the decrypted data returned.

    pcbDataLen - pointer a DWORD location where the length of the above
    buffer is passed in and the length of the decrypted data is returned.

Return Value:

    TRUE - if the key is decrypted successfully.
    FALSE - otherwise.

--*/

BOOL
LsCsp_DecryptEnvelopedData(
    CERT_TYPE   CertType,
    LPBYTE      pbEnvelopedData,
    DWORD       cbEnvelopedDataLen,
    LPBYTE      pbData,
    LPDWORD     pcbDataLen
    )
{
    LPBSAFE_PRV_KEY pSrvPrivateKey = NULL;
    BOOL    bResult = TRUE;

    ACQUIRE_EXCLUSIVE_ACCESS(csp_hMutex);

    //
    // determine the correct private key to use for the decryption operation
    //

    if( CERT_TYPE_PROPRIETORY == CertType )
    {        
        pSrvPrivateKey = (LPBSAFE_PRV_KEY)csp_abServerPrivateKey;
    }
    else if( CERT_TYPE_X509 == CertType )
    {
        if( csp_abX509CertPrivateKey == NULL )
        {
            if( ReloadCSPCertificateAndData() != LICENSE_STATUS_OK )
            {
                ASSERT( FALSE );
            }
        }

        pSrvPrivateKey = (LPBSAFE_PRV_KEY)csp_abX509CertPrivateKey;
    }
    else
    {
        bResult = FALSE;
        goto ded_done;
    }
    
    if( NULL == pSrvPrivateKey )
    {
        bResult = FALSE;
        goto ded_done;
    }

    //
    // check to see the output buffer length pointer is valid.
    //

    if( pcbDataLen == NULL ) {
        bResult = FALSE;
        goto ded_done;
    }

    //
    // check to see the output buffer is valid and its length is sufficient.
    //

    if( (pbData == NULL) || (*pcbDataLen < pSrvPrivateKey->keylen) ) {
        *pcbDataLen = pSrvPrivateKey->keylen;
        bResult = FALSE;
        goto ded_done;
    }

    //
    // encrypted data length should be equal to server private key length.
    //

    if( cbEnvelopedDataLen != pSrvPrivateKey->keylen ) {
        *pcbDataLen = 0;
        bResult = FALSE;
        goto ded_done;
    }

    ASSERT( pbData != NULL );

    //
    // init the output buffer.
    //

    memset( pbData, 0x0, (UINT)pSrvPrivateKey->keylen );

    if( !BSafeDecPrivate(
            pSrvPrivateKey,
            pbEnvelopedData,
            pbData) ) {
        *pcbDataLen = 0;
        bResult = FALSE;
        goto ded_done;
    }

    //
    // successfully decrypted the client random.
    // set the encrypted data length before returning.
    //

    *pcbDataLen = pSrvPrivateKey->keylen;

ded_done:

    RELEASE_EXCLUSIVE_ACCESS( csp_hMutex ); 

    return( bResult );
}


BOOL
LsCsp_EncryptEnvelopedData(
    LPBYTE  pbData,
    DWORD   cbDataLen,
    LPBYTE  pbEnvelopedData,
    LPDWORD pcbEnvelopedDataLen
    )
{
    return FALSE;
}


/*++

Function:

    LsCsp_DumpBinaryData

Description:

    Display the binary data in the given buffer at the debugger output screen

Arguments:

    pBuffer - Buffer containing the binary data to be displayed.
    uLen - Length of th binary data

Return:

    Nothing.

--*/

#if DBG
#ifdef DUMP
VOID LsCsp_DumpBinaryData( PBYTE pBuffer, ULONG uLen )
{
    UNALIGNED CHAR  *p = (UNALIGNED CHAR *)pBuffer;
    CHAR     c;
    DWORD    dw;
    UINT     i = 0;

    DbgPrint("{\n  ");
    while( i < uLen ) {
        c = *p;
        dw = (DWORD)(c);
        DbgPrint( "0x%02X, ", dw & 0xFF );
        i++;
        p++;
        if ((i % 8) == 0)
            DbgPrint( "\n  " );
    }
    DbgPrint( "\n}\n" );
}
#endif
#endif


/*++

Function:

    LsCsp_GetBinaryData

Description:

    Retrieve binary data from the registry

Arguments:

    hKey - Handle to the registry key
    szValue - The registry value to read
    ppBuffer - Return pointer to the binary data
    pdwBufferLen - The length of the binary data.

Return:

    A LICENSE_STATUS return code.

--*/

LICENSE_STATUS
LsCsp_GetBinaryData( 
    HKEY        hKey, 
    LPTSTR      szValue, 
    LPBYTE *    ppBuffer, 
    LPDWORD     pdwBufferLen )
{
    LICENSE_STATUS Status = LICENSE_STATUS_OK;
    DWORD   dwType;
    DWORD   cbBuffer;
    LPBYTE  lpBuffer;

    ASSERT( ppBuffer != NULL );
    ASSERT( pdwBufferLen != NULL );
    ASSERT( szValue != NULL );
    ASSERT( hKey != NULL );

    *ppBuffer = NULL;
    cbBuffer = 0;

    if ( RegQueryValueEx(
                hKey,
                szValue,
                0,
                &dwType,
                (LPBYTE)NULL,
                &cbBuffer) != ERROR_SUCCESS ||
        dwType != REG_BINARY ||
        cbBuffer == 0 )
    {
        Status = LICENSE_STATUS_NO_CERTIFICATE;
        goto gbd_done;
    }
    lpBuffer = (LPBYTE)LocalAlloc( LPTR, cbBuffer );
    if (lpBuffer == NULL) {
        Status = LICENSE_STATUS_OUT_OF_MEMORY;
        goto gbd_done;
    }
    if ( RegQueryValueEx(
                hKey,
                szValue,
                0,
                &dwType,
                (LPBYTE)lpBuffer,
                &cbBuffer) != ERROR_SUCCESS ||
         dwType != REG_BINARY)
    {
        LocalFree( lpBuffer );
        Status = LICENSE_STATUS_NO_CERTIFICATE;
        goto gbd_done;
    }

    *ppBuffer = lpBuffer;
    *pdwBufferLen = cbBuffer;

gbd_done:

    return( Status );
}


/*++

Function:

    LsCsp_Initialize

Description:

    Initialize this library.

Arguments:

    Nothing.

Return:

    A LICENSE_STATUS return code.

--*/


LICENSE_STATUS
LsCsp_Initialize( void )
{
    DWORD   Status = LICENSE_STATUS_OK;
    DWORD   dwResult, dwDisp;

    if( InterlockedIncrement( &csp_InitCount ) > 1 )
    {
        //
        // already initialized
        //

        return( LICENSE_STATUS_OK );
    }

    //
    // Create a global mutex for sync.
    //
    csp_hMutex = CreateMutex(
                            NULL,
                            FALSE,
                            NULL
                        );

    if(NULL == csp_hMutex)
    {

#if DBG
    DbgPrint("LSCSP: CreateMutex() failed with error code %d\n", GetLastError());
#endif

        Status = LICENSE_STATUS_OUT_OF_MEMORY;
        goto ErrorExit;
    }

    //
    // initialize the Hydra Server Root Public key.
    //
    csp_pRootPublicKey = (LPBSAFE_PUB_KEY)csp_abPublicKeyModulus;
    csp_pRootPublicKey->magic = RSA1;
    csp_pRootPublicKey->keylen = 0x48;
    csp_pRootPublicKey->bitlen = 0x0200;
    csp_pRootPublicKey->datalen = 0x3f;
    csp_pRootPublicKey->pubexp = 0xc0887b5b;

#if DBG
#ifdef DUMP
    DbgPrint("Data0\n");
    LsCsp_DumpBinaryData( (LPBYTE)csp_pRootPublicKey, 92 );
#endif
#endif

    //
    // Initialize the proprietory certificate with the built in certificate
    //

    if( !LsCsp_UseBuiltInCert() )
    {
        Status = LICENSE_STATUS_NO_CERTIFICATE;
        goto ErrorExit;
    }

    //
    // Unpack and Validate the certificate
    //
    try {
        if (!UnpackServerCert(
                     csp_abServerCertificate,
                     csp_dwServerCertificateLen,
                     &csp_hscData )) {
            Status = LICENSE_STATUS_INVALID_CERTIFICATE;
            goto ErrorExit;
        }
        if (!ValidateServerCert( &csp_hscData )) {
            Status = LICENSE_STATUS_INVALID_CERTIFICATE;
        }
    } except( EXCEPTION_EXECUTE_HANDLER ) {
#if DBG
    DbgPrint("LSCSP: LsCsp_Initialize bad cert data!\n");
#endif
        Status = LICENSE_STATUS_INVALID_CERTIFICATE;
    }

    Status = ReloadCSPCertificateAndData();

    if (LICENSE_STATUS_NO_CERTIFICATE == Status)
    {
        //
        // No X509 certificate.  Not a failure, as the discovery 
        // thread will soon install it.
        //

        Status = LICENSE_STATUS_OK;
    }
    else if(LICENSE_STATUS_OUT_OF_MEMORY == Status)
    {
        //
        // out of memory at initialization time, 
        // this is critical error
        //
        goto ErrorExit;
    }

    //
    // Let initalization go thru if it can retrieve 
    // private key from LSA, this is OK since we will try to install
    // certificate again in LsCsp_InstallX509Certificate()
    //
    Status = LICENSE_STATUS_OK;
    goto i_done;

ErrorExit:

    LsCsp_Exit();

i_done:

    return( Status );
}


/*++

Function:

    LsCsp_Exit

Description:

    Free all resources used by this library.

Arguments:

    Nothing.

Return:

    A LICENSE_STATUS return code.

--*/

VOID LsCsp_Exit( void )
{
    if( InterlockedDecrement( &csp_InitCount ) > 0 )
    {
        //
        // someone is still using it.
        //

        return;
    }

    if ( csp_abServerPrivateKey)
    {
        LocalFree( csp_abServerPrivateKey );
    }
    csp_abServerPrivateKey = NULL;

    if ( csp_abServerCertificate )
    {
        LocalFree( csp_abServerCertificate );
    }
    csp_abServerCertificate = NULL;

    if( csp_abServerX509Cert )
    {
        LocalFree( csp_abServerX509Cert );
    }
    csp_abServerX509Cert = NULL;

    if( csp_abX509CertPrivateKey )
    {
        LocalFree( csp_abX509CertPrivateKey );
    }
    csp_abX509CertPrivateKey = NULL;

    if( csp_abX509CertID )
    {
        LocalFree( csp_abX509CertID );
    }
    csp_abX509CertID = NULL;

    if( csp_hMutex )
    {
        CloseHandle( csp_hMutex );
    }
    csp_hMutex = NULL;

    return;
}


/*++

Function:

   LsCsp_GetServerData

Routine Description:

   This function makes and return the microsoft terminal server certificate
   blob of data.

Arguments:

   dwInfoDesired - What type of information to return.

   pBlob - pointer to a location where the certificate blob data
   pointer is returned.

   pdwServerCertLen - pointer to a location where the length of the above data
   is returned.

Return Value:

   Windows Error Code.

--*/

LICENSE_STATUS
LsCsp_GetServerData(
    LSCSPINFO   Info,
    LPBYTE      pBlob,
    LPDWORD     pdwBlobLen
    )
{
    LICENSE_STATUS Status = LICENSE_STATUS_OK;
    DWORD  dwDataLen;
    LPBYTE pbData;

    ASSERT( pdwBlobLen != NULL );

    if ((Info == LsCspInfo_PrivateKey) || (Info == LsCspInfo_X509CertPrivateKey))
    {
        if (!IsSystemService())
        {
            return LICENSE_STATUS_NO_PRIVATE_KEY;
        }
    }

    ACQUIRE_EXCLUSIVE_ACCESS(csp_hMutex);

    switch (Info) {
    case LsCspInfo_Certificate:

        if( NULL == csp_abServerCertificate )
        {
            Status = LICENSE_STATUS_NO_CERTIFICATE;
            goto gsd_done;
        }

        pbData = csp_abServerCertificate;
        dwDataLen = csp_dwServerCertificateLen;
        break;

    case LsCspInfo_X509Certificate:

        //
        // We may not have an X509 certificate if the hydra server has not
        // requested one from the license server
        //

        if( NULL == csp_abServerX509Cert )
        {
            Status = LICENSE_STATUS_NO_CERTIFICATE;
            goto gsd_done;
        }

        pbData = csp_abServerX509Cert;
        dwDataLen = csp_dwServerX509CertLen;
        break;

    case LsCspInfo_X509CertID:

        //
        // we will not have a certificate ID if the X509 certificate is not present
        //

        if( NULL == csp_abX509CertID )
        {
            Status = LICENSE_STATUS_NO_CERTIFICATE;
            goto gsd_done;
        }

        pbData = csp_abX509CertID;
        dwDataLen = csp_dwX509CertIDLen;
        break;

    case LsCspInfo_PublicKey:
        pbData = csp_hscData.PublicKeyData.pBlob;
        dwDataLen = csp_hscData.PublicKeyData.wBlobLen;
        break;

    case LsCspInfo_PrivateKey:
        if( NULL == csp_abServerPrivateKey )
        {
            Status = LICENSE_STATUS_NO_PRIVATE_KEY;
            goto gsd_done;
        }

        pbData = csp_abServerPrivateKey;
        dwDataLen = csp_dwServerPrivateKeyLen;
        break;

    case LsCspInfo_X509CertPrivateKey:
        
        //
        // The X509 certificate private key may not have been created.
        //

        if( NULL == csp_abX509CertPrivateKey )
        {
            Status = LICENSE_STATUS_NO_PRIVATE_KEY;
            goto gsd_done;
        }

        pbData = csp_abX509CertPrivateKey;
        dwDataLen = csp_dwX509CertPrivateKeyLen;
        break;

    default:
        Status = LICENSE_STATUS_INVALID_INPUT;
        goto gsd_done;
    }

    if (pBlob != NULL) {
        if (*pdwBlobLen < dwDataLen) {
            *pdwBlobLen = dwDataLen;
            Status = LICENSE_STATUS_INSUFFICIENT_BUFFER;
        } else {
            memcpy(pBlob, pbData, dwDataLen);
            *pdwBlobLen = dwDataLen;
        }
    } else {
        *pdwBlobLen = dwDataLen;
    }

gsd_done:

    RELEASE_EXCLUSIVE_ACCESS( csp_hMutex ); 


    return( Status );
}

/*++

Function:

    LsCsp_ReadProprietaryDataFromStorage

Description:

    Read proprietary public/private info from registry/LSA secret
    
Arguments:

    None.
    
Return:

    LICENSE_STATUS
        
--*/

LICENSE_STATUS
LsCsp_ReadProprietaryDataFromStorage(PBYTE *ppbCert,
                                     DWORD *pcbCert,
                                     PBYTE *ppbPrivateKey,
                                     DWORD *pcbPrivateKey)
{
    LICENSE_STATUS Status;
    HKEY hKey = NULL;
    DWORD dwDisp;

    *ppbCert = *ppbPrivateKey = NULL;
    *pcbCert = *pcbPrivateKey = 0;

    //
    // Open the Registry
    //

    if( RegCreateKeyEx(
                       HKEY_LOCAL_MACHINE,
                       TEXT( HYDRA_CERT_REG_KEY ),
                       0,
                       NULL,
                       REG_OPTION_NON_VOLATILE,
                       KEY_READ,
                       NULL,
                       &hKey,
                       &dwDisp ) != ERROR_SUCCESS )
    {
        Status = LICENSE_STATUS_NO_CERTIFICATE;
        goto done;
    }

    if ( RegQueryValueEx(
                         hKey,
                         TEXT( HYDRA_CERTIFICATE_VALUE ),
                         NULL,  // lpReserved
                         NULL,  // lpType
                         NULL,  // lpData
                         pcbCert) != ERROR_SUCCESS )
    {
        Status = LICENSE_STATUS_NO_CERTIFICATE;
        goto done;
    }

    Status = LsCsp_RetrieveSecret(PRIVATE_KEY_NAME,
                                  NULL, // pbKey
                                  pcbPrivateKey);

    if (LICENSE_STATUS_OK != Status)
    {
        goto done;
    }

    *ppbCert = ( LPBYTE )LocalAlloc(LPTR,*pcbCert);

    if (NULL == *ppbCert)
    {
        Status = LICENSE_STATUS_OUT_OF_MEMORY;
        goto done;
    }

    *ppbPrivateKey = ( LPBYTE )LocalAlloc(LPTR,*pcbPrivateKey);
    if (NULL == *ppbPrivateKey)
    {
        Status = LICENSE_STATUS_OUT_OF_MEMORY;
        goto done;
    }

    if ( RegQueryValueEx(
                         hKey,
                         TEXT( HYDRA_CERTIFICATE_VALUE ),
                         NULL,  // lpReserved
                         NULL,  // lpType
                         *ppbCert,
                         pcbCert) != ERROR_SUCCESS )
    {
        Status = LICENSE_STATUS_NO_CERTIFICATE;
        goto done;
    }

    Status = LsCsp_RetrieveSecret(PRIVATE_KEY_NAME,
                                  *ppbPrivateKey,
                                  pcbPrivateKey);

done:
    if (NULL != hKey)
        RegCloseKey(hKey);

    if (Status != LICENSE_STATUS_OK)
    {
        if (NULL != *ppbCert)
        {
            LocalFree(*ppbCert);
            *ppbCert = NULL;
            *pcbCert = 0;
        }

        if (NULL != *ppbPrivateKey)
        {
            LocalFree(*ppbPrivateKey);
            *ppbPrivateKey = NULL;
            *pcbPrivateKey = 0;
        }
    }

    return Status;
}


/*++

Function:

    LsCsp_UseBuiltInCert

Description:

    Initialize the global variables with hardcoded certificate.
    
Arguments:

    None.
    
Return:

    TRUE if the initialization is successful.
        
--*/

BOOL
LsCsp_UseBuiltInCert( void )
{
    LICENSE_STATUS Status;

    ACQUIRE_EXCLUSIVE_ACCESS(csp_hMutex);

    //
    // Step 1, cleanup and initialization that happened
    //
    if (csp_abServerPrivateKey)
    {
        LocalFree( csp_abServerPrivateKey );
        csp_abServerPrivateKey = NULL;
    }

    if (csp_abServerCertificate)
    {
        LocalFree( csp_abServerCertificate );
        csp_abServerCertificate = NULL;
    }

    //
    // Step 2, check for stored key and certificate
    //
    Status = LsCsp_ReadProprietaryDataFromStorage(&csp_abServerCertificate, &csp_dwServerCertificateLen,&csp_abServerPrivateKey, &csp_dwServerPrivateKeyLen);

    if (LICENSE_STATUS_OK != Status)
    {
        PBYTE pbPrivateKey, pbCertificate;
        DWORD cbPrivateKey, cbCertificate;

        //
        // Step 3, if no stored info found, generate new info and store it
        //
        
        Status = CreateProprietaryKeyAndCert(&pbPrivateKey,&cbPrivateKey,&pbCertificate,&cbCertificate);
        
        if (LICENSE_STATUS_OK == Status)
        {
            LsCsp_SetServerData(LsCspInfo_PrivateKey,pbPrivateKey,cbPrivateKey);

            LsCsp_SetServerData(LsCspInfo_Certificate,pbCertificate,cbCertificate);
        }
    }

    RELEASE_EXCLUSIVE_ACCESS( csp_hMutex ); 
        
    return( Status == LICENSE_STATUS_OK );
}


/*++

Function:

    LsCsp_InstallX509Certificate

Routine Description:

   This function generates a private/public key pair and then finds a 
   license server to issue an X509 certificate for the public key.
   It then stores the private key and certificate.

Arguments:

   None.

Return Value:

   LSCSP return code.

--*/


LICENSE_STATUS
LsCsp_InstallX509Certificate(LPVOID lpParam)
{
    DWORD
        cbPubKey,
        cbPrivKey,
        cbCertificate;
    LICENSE_STATUS
        Status;
    LPBYTE
        pbPubKey = NULL,
        pbPrivKey = NULL,
        pbCertificate = NULL;
    CERT_PUBLIC_KEY_INFO   
        CapiPubKeyInfo;
    HWID
        Hwid;
    TLS_HANDLE
        hServer;

    //
    // before we go through the trouble of generating private and public
    // keys, check if the license server is available.
    //

    hServer = TLSConnectToAnyLsServer(LS_DISCOVERY_TIMEOUT);
    if (NULL == hServer)
    {
        return( LICENSE_STATUS_NO_LICENSE_SERVER );
    }

    memset(&CapiPubKeyInfo, 0, sizeof(CapiPubKeyInfo));

    //
    // acquire exclusive access
    //

    ACQUIRE_EXCLUSIVE_ACCESS(csp_hMutex);

    //
    // Try to reload the certificate again, some other thread might have
    // install the certificate already.
    //

    Status = ReloadCSPCertificateAndData();
    if( LICENSE_STATUS_OK == Status )
    {
        goto done;
    }

    //
    // Generate a private/public key pair
    //

    Status = GenerateRsaKeyPair( 
                        &pbPubKey, 
                        &cbPubKey, 
                        &pbPrivKey, 
                        &cbPrivKey, 
                        RSA_KEY_LEN );
    
    if( LICENSE_STATUS_OK != Status )
    {
#if DBG
        DbgPrint( "LSCSP: LsCsp_InstallX509Certificate: cannot generate RSA keypair\n" );
#endif

        goto done;
    }

    //
    // convert the Bsafe public key into a CAPI public key
    //

    Status = Bsafe2CapiPubKey( &CapiPubKeyInfo, pbPubKey, cbPubKey );

    if( LICENSE_STATUS_OK != Status )
    {
#if DBG
        DbgPrint( "LSCSP: LsCsp_InstallX509Certificate: cannot convert Bsafe Key to CAPI key\n" );
#endif
        goto done;
    }

    //
    // generate a new hardware ID
    //

    Status = GenerateMachineHWID( &Hwid );

    if( LICENSE_STATUS_OK != Status )
    {
#if DBG
        DbgPrint( "LSCSP: LsCsp_InstallX509Certificate: cannot generate certificate ID\n" );
#endif
        goto done;
    }

    //
    // sends the certificate request to the license server
    //

    Status = RequestCertificate( hServer, &CapiPubKeyInfo, &pbCertificate, &cbCertificate, &Hwid );

    TLSDisconnectFromServer( hServer );
    hServer = NULL;

    if( LICENSE_STATUS_OK != Status )
    {
#if DBG
        DbgPrint( "LSCSP: LsCsp_InstallX509Certificate: error requesting terminal server certificate: %x\n", Status );
#endif
        goto done;
    }

    //
    // store the certificate identifier
    //
    
    Status = LsCsp_SetServerData( 
                        LsCspInfo_X509CertID, 
                        ( LPBYTE )&Hwid, 
                        sizeof( Hwid ) );

    if( LICENSE_STATUS_OK != Status )
    {
#if DBG
        DbgPrint( "LSCSP: LsCsp_InstallX509Certificate: cannot store terminal server certificate ID : %d\n", Status );
#endif
        goto done;
    }
 
    //
    // Stores the certificate and resets the global variable pointing
    // to the X509 certificate.
    //

    Status = LsCsp_SetServerData( 
                        LsCspInfo_X509Certificate, 
                        pbCertificate, 
                        cbCertificate );

    if( LICENSE_STATUS_OK != Status )
    {
#if DBG
        DbgPrint( "LSCSP: LsCsp_InstallX509Certificate: cannot store terminal server certificate : %d\n", Status );
#endif
        goto done;
    }

    //
    // Stores the private key and resets the global variable pointing to the
    // private key.
    //

    Status = LsCsp_SetServerData(
                        LsCspInfo_X509CertPrivateKey,
                        pbPrivKey,
                        cbPrivKey );

    if( LICENSE_STATUS_OK != Status )
    {
#if DBG
        DbgPrint( "LSCSP: LsCsp_InstallX509Certificate: cannot store terminal server private key %d\n", Status );
#endif
        goto done;
    }

    //
    // Store the public key so we can verify at startup time
    //
    
    Status = LsCsp_StoreSecret(
                        X509_CERT_PUBLIC_KEY_NAME,
                        pbPubKey,
                        cbPubKey
                    );

    if( LICENSE_STATUS_OK != Status )
    {
#if DBG
        DbgPrint( "LSCSP: LsCsp_InstallX509Certificate: cannot store terminal server public key : %d\n", Status );
#endif
    }


done:

    if (NULL != hServer)
    {
        TLSDisconnectFromServer( hServer );
        hServer = NULL;
    }

    //
    // release exclusive access
    //

    RELEASE_EXCLUSIVE_ACCESS( csp_hMutex ); 


    if( pbCertificate )
    {
        LocalFree(pbCertificate);
    }

    if( pbPrivKey )
    {
        LocalFree( pbPrivKey );
    }

    if( pbPubKey )
    {
        LocalFree( pbPubKey );
    }

    FreeCapiPubKey( &CapiPubKeyInfo );

    return( Status );
}


/*++

Function:

    RequestCertificate

Routine Description:

    Request a certificate from the license server

Arguments:

    hServer - handle to license server
    pPubKeyInfo - The public key info to be included in the certificate
    ppbCertificate - The new certificate
    pcbCertificate - size of the certificate
    pHwid - The hardware ID that is used to identify the certificate

Return:

    LICENSE_STATUS return code

--*/

LICENSE_STATUS
RequestCertificate(     
    TLS_HANDLE              hServer,
    PCERT_PUBLIC_KEY_INFO   pPubKeyInfo,
    LPBYTE *                ppbCertificate,
    LPDWORD                 pcbCertificate,
    HWID *                  pHwid )
{
    LSHydraCertRequest
        CertRequest;
    LICENSE_STATUS
        Status;
    DWORD
        dwRpcCode,
        dwResult,
        cbChallengeData;
    LPBYTE
        pbChallengeData = NULL;

    if( ( NULL == ppbCertificate ) || 
        ( NULL == hServer ) || 
        ( NULL == pPubKeyInfo ) || 
        ( NULL == pcbCertificate ) )
    {
        return( LICENSE_STATUS_INVALID_INPUT );
    }

    *ppbCertificate = NULL;
    *pcbCertificate = 0;

    memset( &CertRequest, 0, sizeof( CertRequest ) );

    CertRequest.dwHydraVersion = 0x00050000;
    
    LsCsp_EncryptHwid( pHwid, NULL, &CertRequest.cbEncryptedHwid );

    CertRequest.pbEncryptedHwid = LocalAlloc( LPTR, CertRequest.cbEncryptedHwid );

    if( NULL == CertRequest.pbEncryptedHwid )
    {
        return LICENSE_STATUS_OUT_OF_MEMORY;
    }

    Status = LsCsp_EncryptHwid( 
                    pHwid, 
                    CertRequest.pbEncryptedHwid, 
                    &CertRequest.cbEncryptedHwid );

    if( LICENSE_STATUS_OK != Status )
    {
        goto done;
    }
    
    //
    // get the subject RDN
    //

    Status = GetSubjectRdn( &CertRequest.szSubjectRdn );

    if( LICENSE_STATUS_OK != Status )
    {
        goto done;
    }

    CertRequest.SubjectPublicKeyInfo = pPubKeyInfo;

    //
    // request an X509 certificate from the license server
    //

    dwRpcCode = TLSRequestTermServCert(hServer,
                                       &CertRequest,
                                       &cbChallengeData,
                                       &pbChallengeData,
                                       &dwResult );

    if( ( RPC_S_OK != dwRpcCode ) || ( LSERVER_S_SUCCESS != dwResult ) )
    {
        Status = LICENSE_STATUS_CERTIFICATE_REQUEST_ERROR;
        goto done;
    }

    dwRpcCode = TLSRetrieveTermServCert(
                            hServer,
                            cbChallengeData,
                            pbChallengeData,
                            pcbCertificate,
                            ppbCertificate,
                            &dwResult );


    if( ( RPC_S_OK != dwRpcCode ) || ( LSERVER_ERROR_BASE <= dwResult ) )
    {

        Status = LICENSE_STATUS_CERTIFICATE_REQUEST_ERROR;
    }

done:

    if( CertRequest.pbEncryptedHwid )
    {
        LocalFree( CertRequest.pbEncryptedHwid );
    }

    if( CertRequest.szSubjectRdn )
    {
        LocalFree( CertRequest.szSubjectRdn );
    }

    if( pbChallengeData )
    {
        LocalFree( pbChallengeData );
    }

    return( Status );
}


/*++

Function:

    GetSubjectRdn

Routine Description:

    Construct the subject RDN for a certificate request

Argument:

    ppSubjectRdn - Return pointer to the subject RDN

Return:

    LICENSE_STATUS_OK if successful or a LICENSE_STATUS error code.

--*/

LICENSE_STATUS
GetSubjectRdn(
    LPTSTR   * ppSubjectRdn )
{
    TCHAR
        ComputerName[ MAX_COMPUTERNAME_LENGTH + 1 ];
    DWORD
        RdnLen = 0,
        ComputerNameLen = MAX_COMPUTERNAME_LENGTH + 1;

    //
    // use the computer name uas the common name
    //

    GetComputerName( ComputerName, &ComputerNameLen );

    RdnLen += wcslen( TEXT( RDN_COMMON_NAME ) );
    RdnLen += ComputerNameLen + 1;
    RdnLen = RdnLen * sizeof( TCHAR );

    *ppSubjectRdn = LocalAlloc( LPTR, RdnLen );

    if( NULL == *ppSubjectRdn )
    {
        return( LICENSE_STATUS_OUT_OF_MEMORY );
    }

    wsprintf( *ppSubjectRdn, L"%s%s", TEXT( RDN_COMMON_NAME ), ComputerName );
    
    return( LICENSE_STATUS_OK );
}


/*++

Function:

    GenerateMachineHWID

Routine Description:

    Generate a hardware ID for this machine

Arguments:

    pHwid - Return value of the HWID

Return:

    LICENSE_STATUS_OK if successful or a LICENSE_STATUS error code

--*/

LICENSE_STATUS
GenerateMachineHWID(
    PHWID    pHwid )    
{
    
    OSVERSIONINFO 
        osvInfo;
    DWORD
        cbCertId;
    LPBYTE
        pbCertId = NULL;

    if( NULL == pHwid )
    {
        return( LICENSE_STATUS_INVALID_INPUT );
    }

    //
    // Create the HWID
    //

    memset( &osvInfo, 0, sizeof( OSVERSIONINFO ) );
    osvInfo.dwOSVersionInfoSize = sizeof( OSVERSIONINFO );
    GetVersionEx( &osvInfo );

    pHwid->dwPlatformID = osvInfo.dwPlatformId;

    if (TSRNG_GenerateRandomBits( (LPBYTE) &( pHwid->Data1 ), sizeof(DWORD))
        && TSRNG_GenerateRandomBits( (LPBYTE) &( pHwid->Data2 ), sizeof(DWORD))
        && TSRNG_GenerateRandomBits( (LPBYTE) &( pHwid->Data3 ), sizeof(DWORD))
        && TSRNG_GenerateRandomBits( (LPBYTE) &( pHwid->Data4 ), sizeof(DWORD))
        )
    {
        return( LICENSE_STATUS_OK );
    }
    else
    {
        return ( LICENSE_STATUS_UNSPECIFIED_ERROR );
    }
}


/*++

Function:

    LsCsp_EncryptHwid

Routine Description:

    Encrypt the given hardward ID using the secret key shared by terminal
    and license servers.
    
Arguments:

    pHwid - The Hardware ID
    pbEncryptedHwid - The encrypted HWID
    pcbEncryptedHwid - Length of the encrypted HWID

Return:

    LICENSE_STATUS_OK if successful or a LICENSE_STATUS error code otherwise.

--*/

LICENSE_STATUS
LsCsp_EncryptHwid(
    PHWID       pHwid,
    LPBYTE      pbEncryptedHwid,
    LPDWORD     pcbEncryptedHwid )
{
    LICENSE_STATUS
        Status;
    LPBYTE 
        pbSecretKey = NULL;
    DWORD
        cbSecretKey = 0;

    if( NULL == pcbEncryptedHwid )
    {
        return( LICENSE_STATUS_INVALID_INPUT );
    }

    if( ( NULL == pbEncryptedHwid ) || 
        ( sizeof( HWID ) > *pcbEncryptedHwid ) )
    {
        *pcbEncryptedHwid = sizeof( HWID );
        return( LICENSE_STATUS_INSUFFICIENT_BUFFER );
    }

    LicenseGetSecretKey( &cbSecretKey, NULL );

    pbSecretKey = LocalAlloc( LPTR, cbSecretKey );

    if( NULL == pbSecretKey )
    {
        return( LICENSE_STATUS_OUT_OF_MEMORY );
    }

    //
    // Get the secret key used for encrypting the HWID
    //

    Status = LicenseGetSecretKey( &cbSecretKey, pbSecretKey );

    if( LICENSE_STATUS_OK != Status )
    {
        goto done;
    }

    Status = LicenseEncryptHwid(
                    pHwid,
                    pcbEncryptedHwid,
                    pbEncryptedHwid,
                    cbSecretKey,
                    pbSecretKey );

done:

    if( pbSecretKey )
    {
        LocalFree( pbSecretKey );
    }

    return( Status );

}


/*++

Function:

    LsCsp_DecryptHwid

Routine Description:

    Decrypt the given hardware ID

Arguments:

    pHwid - The decrypted hardware ID
    pbEncryptedHwid - The encrypted hardware ID
    cbEncryptedHwid - Length of the encrypted hardware ID

Return:

    LICENSE_STATUS_OK if successful or a LICENSE_STATUS error code.

--*/

LICENSE_STATUS
LsCsp_DecryptHwid(
    PHWID       pHwid,
    LPBYTE      pbEncryptedHwid,
    LPDWORD     pcbEncryptedHwid )
{
    return( LICENSE_STATUS_OK );
}


/*++

Function:

    LsCsp_StoreSecret

Description:

    Use LSA to store a secret private key.

Arguments:

    ptszKeyName - Name used to identify the secret private key.
    pbKey - Points to the secret private key.
    cbKey - Length of the private key.

Return:

    A LICENSE_STATUS return code.

--*/

LICENSE_STATUS
LsCsp_StoreSecret(
    PTCHAR  ptszKeyName,
    BYTE *  pbKey,
    DWORD   cbKey )
{
    LSA_HANDLE 
        PolicyHandle;
    UNICODE_STRING 
        SecretKeyName;
    UNICODE_STRING 
        SecretData;
    DWORD 
        Status;
    
    if( ( NULL == ptszKeyName ) || ( 0xffff < cbKey) )
    {
        return( LICENSE_STATUS_INVALID_INPUT );
    }

    //
    // setup the UNICODE_STRINGs for the call.
    //
    
    InitLsaString( &SecretKeyName, ptszKeyName );

    SecretData.Buffer = ( LPWSTR )pbKey;
    SecretData.Length = ( USHORT )cbKey;
    SecretData.MaximumLength = ( USHORT )cbKey;

    Status = OpenPolicy( NULL, POLICY_CREATE_SECRET, &PolicyHandle );

    if( ERROR_SUCCESS != Status )
    {
        return ( LICENSE_STATUS_CANNOT_OPEN_SECRET_STORE );
    }

    Status = LsaStorePrivateData(
                PolicyHandle,
                &SecretKeyName,
                &SecretData
                );

    LsaClose( PolicyHandle );

    Status = LsaNtStatusToWinError( Status );

    if( ERROR_SUCCESS != Status )
    {
        return( LICENSE_STATUS_CANNOT_STORE_SECRET );
    }
    
    return( LICENSE_STATUS_OK );
}


/*++

Function:

    LsCsp_RetrieveSecret

Description:

    Retrieve the secret private key that is stored by LSA.

Arguments:

    ptszKeyName - The name used to identify the secret private key.
    ppbKey - Return value of the private key
    pcbKey - Length of the private key.

Return:

    A LICENSE_STATUS return code.

--*/

LICENSE_STATUS
LsCsp_RetrieveSecret(
    PTCHAR      ptszKeyName,
    PBYTE       pbKey,
    DWORD *     pcbKey )
{
    LSA_HANDLE 
        PolicyHandle;
    UNICODE_STRING 
        SecretKeyName;
    UNICODE_STRING * 
        pSecretData = NULL;
    DWORD 
        Status;
    LICENSE_STATUS
        LicenseStatus = LICENSE_STATUS_OK;

    if( ( NULL == ptszKeyName ) || ( NULL == pcbKey ) )
    {
        return( ERROR_INVALID_PARAMETER );
    }

    //
    // setup the UNICODE_STRINGs for the call.
    //

    InitLsaString( &SecretKeyName, ptszKeyName );

    Status = OpenPolicy( NULL, POLICY_GET_PRIVATE_INFORMATION, &PolicyHandle );

    if( ERROR_SUCCESS != Status )
    {
#if DBG
        DbgPrint( "LSCSP: cannot open LSA policy handle: %x\n", Status );
#endif
        return( LICENSE_STATUS_CANNOT_OPEN_SECRET_STORE );
    }

    Status = LsaNtStatusToWinError( LsaRetrievePrivateData(
                                            PolicyHandle,
                                            &SecretKeyName,
                                            &pSecretData ) );

    LsaClose( PolicyHandle );

    if (( ERROR_SUCCESS != Status ) || (NULL == pSecretData) || (pSecretData->Length == 0))
    {
#if DBG
        DbgPrint( "LSCSP: cannot retrieve LSA data: %x\n", Status );
#endif
        return( LICENSE_STATUS_CANNOT_RETRIEVE_SECRET );
    }

    if( NULL == pbKey )
    {
        *pcbKey = pSecretData->Length;
    }
    else
    {
        if( pSecretData->Length > *pcbKey )
        {
            LicenseStatus = LICENSE_STATUS_INSUFFICIENT_BUFFER;
        }
        else
        {
            CopyMemory( pbKey, pSecretData->Buffer, pSecretData->Length );
        }

        *pcbKey = pSecretData->Length;
    }

    SecureZeroMemory( pSecretData->Buffer, pSecretData->Length );
    LsaFreeMemory( pSecretData );

    return( LicenseStatus );
}


/*++

Function:

    OpenPolicy

Description:

    Obtain an LSA policy handle used to perform subsequent LSA operations.

Arguments:

    ServerName - The server which the handle should be obtained from.
    DesiredAccess - The access given to the handle
    PolicyHandle - The policy handle

Return:

    A Win32 return code.

--*/

NTSTATUS
OpenPolicy(
    LPWSTR ServerName,
    DWORD DesiredAccess,
    PLSA_HANDLE PolicyHandle )
{
    LSA_OBJECT_ATTRIBUTES ObjectAttributes;
    LSA_UNICODE_STRING ServerString;
    PLSA_UNICODE_STRING Server;

    //
    // Always initialize the object attributes to all zeroes.
    //
 
    SecureZeroMemory( &ObjectAttributes, sizeof( ObjectAttributes ) );

    if( NULL != ServerName ) 
    {
        //
        // Make a LSA_UNICODE_STRING out of the LPWSTR passed in
        //

        InitLsaString(&ServerString, ServerName);
        Server = &ServerString;

    } 
    else 
    {
        Server = NULL;
    }

    //
    // Attempt to open the policy.
    //
    
    return( LsaNtStatusToWinError( LsaOpenPolicy(
                                            Server,
                                            &ObjectAttributes,
                                            DesiredAccess,
                                            PolicyHandle ) ) );
}


/*++

Function:

    InitLsaString

Description:

    Initialize a UNICODE string to LSA UNICODE string format.

Arguments:

    LsaString - the LSA UNICODE string.
    String - UNICODE string

Return:

    Nothing.

--*/

void
InitLsaString(
    PLSA_UNICODE_STRING LsaString,
    LPWSTR String )
{
    DWORD StringLength;

    if( NULL == String ) 
    {
        LsaString->Buffer = NULL;
        LsaString->Length = 0;
        LsaString->MaximumLength = 0;
        return;
    }

    StringLength = lstrlenW( String );
    LsaString->Buffer = String;
    LsaString->Length = ( USHORT ) StringLength * sizeof( WCHAR );
    LsaString->MaximumLength=( USHORT )( StringLength + 1 ) * sizeof( WCHAR );
}


/*++

Function:

    LsCsp_SetServerData

Description:

    Saves the specified data.

Arguments:

    Info - The data type of the data to be saved.
    pBlob - Points to the data to be saved.
    dwBlobLen - Length of the data to be saved.

Return:

    A LICENSE_STATUS return code.

--*/

LICENSE_STATUS
LsCsp_SetServerData(
    LSCSPINFO   Info,
    LPBYTE      pBlob,
    DWORD       dwBlobLen )
{
    LICENSE_STATUS
        Status = LICENSE_STATUS_OK;
    DWORD
        dwResult,
        dwDisp,
        * pdwCspDataLen;
    LPTSTR
        lpRegValue;
    PWCHAR
        pwszKeyName;
    LPBYTE *
        ppCspData;
    HKEY
        hKey = NULL;

    ASSERT( dwBlobLen != 0 );
    ASSERT( pBlob != NULL );

    ACQUIRE_EXCLUSIVE_ACCESS(csp_hMutex);

        
    switch (Info) {

    case LsCspInfo_Certificate:

        //
        // set proprietory certificate data
        //

        lpRegValue = TEXT( HYDRA_CERTIFICATE_VALUE );
        ppCspData = &csp_abServerCertificate;
        pdwCspDataLen = &csp_dwServerCertificateLen;

        break;

    case LsCspInfo_X509Certificate:

        //
        // set X509 certificate data
        //

        lpRegValue = TEXT( HYDRA_X509_CERTIFICATE );
        ppCspData = &csp_abServerX509Cert;
        pdwCspDataLen = &csp_dwServerX509CertLen;

        break;
    
    case LsCspInfo_PrivateKey:

        //
        // set the private key that corresponds to the proprietory certificate
        //

        pwszKeyName = PRIVATE_KEY_NAME;
        ppCspData = &csp_abServerPrivateKey;
        pdwCspDataLen = &csp_dwServerPrivateKeyLen;

        break;

    case LsCspInfo_X509CertPrivateKey:

        //
        // set private key that corresponds to the X509 certificate
        //

        pwszKeyName = X509_CERT_PRIVATE_KEY_NAME;
        ppCspData = &csp_abX509CertPrivateKey;
        pdwCspDataLen = &csp_dwX509CertPrivateKeyLen;

        break;

    case LsCspInfo_X509CertID:

        //
        // Set the X509 certificate ID
        //

        lpRegValue = TEXT( HYDRA_X509_CERT_ID );
        ppCspData = &csp_abX509CertID;
        pdwCspDataLen = &csp_dwX509CertIDLen;

        break;

    default:

        Status = LICENSE_STATUS_INVALID_INPUT;
        goto i_done;
    }

    if( ( LsCspInfo_X509CertPrivateKey == Info ) ||
        ( LsCspInfo_PrivateKey == Info ) )
    {
        //
        // store secret key information
        //

        dwResult = LsCsp_StoreSecret( pwszKeyName, pBlob, dwBlobLen );

        if( ERROR_SUCCESS != dwResult )
        {
            Status = LICENSE_STATUS_WRITE_STORE_ERROR;
            goto i_done;
        }                   
    }
    else
    {
        //
        // Open the Registry
        //

        if( RegCreateKeyEx(
                    HKEY_LOCAL_MACHINE,
                    TEXT( HYDRA_CERT_REG_KEY ),
                    0,
                    NULL,
                    REG_OPTION_NON_VOLATILE,
                    KEY_WRITE,
                    NULL,
                    &hKey,
                    &dwDisp ) != ERROR_SUCCESS )
        {
            Status = LICENSE_STATUS_WRITE_STORE_ERROR;
            goto i_done;
        }

        //
        // Sets the value in the registry
        //

        if( ERROR_SUCCESS != RegSetValueEx(
                                    hKey,
                                    lpRegValue,
                                    0,      
                                    REG_BINARY,
                                    pBlob,
                                    dwBlobLen ) )
        {
            Status = LICENSE_STATUS_WRITE_STORE_ERROR;
            goto i_done;
        }
    }
    
    //
    // reset the global data with the new data that we have just set
    //

    if ( *ppCspData )
    {
        LocalFree( *ppCspData );
    }
    
    *ppCspData = ( LPBYTE )LocalAlloc( LPTR, dwBlobLen );

    if( NULL == *ppCspData )
    {
        Status = LICENSE_STATUS_OUT_OF_MEMORY;
        goto i_done;
    }

    memcpy( *ppCspData, pBlob, dwBlobLen );
    *pdwCspDataLen = dwBlobLen;
    
i_done:

    RELEASE_EXCLUSIVE_ACCESS( csp_hMutex ); 


    if( hKey )
    {
        RegCloseKey( hKey );
    }

    return( Status );
}


/*++

Function:

    LsCsp_NukeServerData

Description:

    Permanently deletes the specified server data.

Arguments:

    Info - The type of data to nuke.

Returns:

    A LICENSE_STATUS return code.

--*/

LICENSE_STATUS
LsCsp_NukeServerData(
    LSCSPINFO   Info )
{
    LICENSE_STATUS
        Status = LICENSE_STATUS_OK; 
    LPTSTR
        lpRegValue;
    PWCHAR
        pwszKeyName;
    HKEY
        hKey = NULL;
    LPBYTE *
        ppCspData;
    DWORD * 
        pdwCspDataLen;
    DWORD
        dwResult;

    ACQUIRE_EXCLUSIVE_ACCESS(csp_hMutex);


    switch (Info) {

    case LsCspInfo_X509Certificate:

        //
        // delete X509 certificate data
        //

        lpRegValue = TEXT( HYDRA_X509_CERTIFICATE );
        ppCspData = &csp_abServerX509Cert;
        pdwCspDataLen = &csp_dwServerX509CertLen;

        break;
    
    case LsCspInfo_X509CertPrivateKey:

        //
        // delete the private key that corresponds to the X509 certificate
        //

        pwszKeyName = X509_CERT_PRIVATE_KEY_NAME;
        ppCspData = &csp_abX509CertPrivateKey;
        pdwCspDataLen = &csp_dwX509CertPrivateKeyLen;

        break;

    case LsCspInfo_X509CertID:

        //
        // delete the X509 certificate ID
        //

        lpRegValue = TEXT( HYDRA_X509_CERT_ID );
        ppCspData = &csp_abX509CertID;
        pdwCspDataLen = &csp_dwX509CertIDLen;

        break;

    default:

        Status = LICENSE_STATUS_INVALID_INPUT;
        goto i_done;        
    }

    if( (LsCspInfo_X509CertPrivateKey == Info ) ||
        ( LsCspInfo_PrivateKey == Info ) )
    {
        //
        // delete secret info stored by LSA
        //

        dwResult = LsCsp_StoreSecret( pwszKeyName, NULL, 0 );

        if( ERROR_SUCCESS != dwResult )
        {
            Status = LICENSE_STATUS_WRITE_STORE_ERROR;
            goto i_done;
        }                   
    }
    else
    {
        //
        // Delete the data kept in the registry
        //

        if( RegOpenKeyEx(
                    HKEY_LOCAL_MACHINE,
                    TEXT( HYDRA_CERT_REG_KEY ),
                    0,
                    KEY_WRITE,
                    &hKey ) != ERROR_SUCCESS )
        {
            Status = LICENSE_STATUS_WRITE_STORE_ERROR;
            goto i_done;
        }

        //
        // Delete the value in the registry
        //

        if( ERROR_SUCCESS != RegDeleteValue( hKey, lpRegValue ) )  
        {
            Status = LICENSE_STATUS_WRITE_STORE_ERROR;
            goto i_done;
        }
    }

    if ( *ppCspData )
    {
        //
        // free the memory allocated for the global variable.
        //

        LocalFree( *ppCspData );
        *ppCspData = NULL;
        *pdwCspDataLen = 0;
    }
    
i_done:

    RELEASE_EXCLUSIVE_ACCESS( csp_hMutex ); 


    if( hKey )
    {
        RegCloseKey( hKey );
    }

    return( Status );
}


/*++

Function:

    GenerateKeyPair

Routine Description:

   This function generates a private/public key pair.

Arguments:

   ppbPublicKey - Return pointer to public Key
   pcbPublicKey - Size of public key
   ppbPrivateKey - Return pointer to private key
   pcbPrivateKey - size of private key
   dwKeyLen - Desired key length

Return Value:

   LICENSE_STATUS return code.

--*/

LICENSE_STATUS
GenerateRsaKeyPair(
    LPBYTE *     ppbPublicKey,
    LPDWORD      pcbPublicKey,
    LPBYTE *     ppbPrivateKey,
    LPDWORD      pcbPrivateKey,
    DWORD        dwKeyLen )
{
    DWORD
        dwBits = dwKeyLen;
    LICENSE_STATUS
        Status = LICENSE_STATUS_OK;

    *ppbPublicKey = NULL;
    *ppbPrivateKey = NULL;

    //
    // find out the size of the private and public key sizes and allocate
    // memory for them.
    //

    dwBits = BSafeComputeKeySizes( pcbPublicKey, pcbPrivateKey, &dwBits );

    *ppbPrivateKey = ( LPBYTE )LocalAlloc( LPTR, *pcbPrivateKey );

    if( NULL == *ppbPrivateKey )
    {
        Status = LICENSE_STATUS_OUT_OF_MEMORY;
        goto ErrorExit;
    }

    *ppbPublicKey = ( LPBYTE )LocalAlloc( LPTR, *pcbPublicKey );

    if( NULL == *ppbPublicKey )
    {
        Status = LICENSE_STATUS_OUT_OF_MEMORY;
        goto ErrorExit;
    }

    //
    // generate the private/public key pair
    //

    if( !BSafeMakeKeyPair( ( LPBSAFE_PUB_KEY )*ppbPublicKey,
                           ( LPBSAFE_PRV_KEY )*ppbPrivateKey,
                           dwKeyLen) )
    {
        Status = LICENSE_STATUS_CANNOT_MAKE_KEY_PAIR;
        goto ErrorExit;
    }

    return( Status ); 

ErrorExit:

    if( *ppbPublicKey )
    {
        LocalFree( *ppbPublicKey );
        *pcbPublicKey = 0;
        *ppbPublicKey = NULL;
    }

    if( *ppbPrivateKey )
    {
        LocalFree( *ppbPrivateKey );
        *pcbPrivateKey = 0;
        *ppbPrivateKey = NULL;
    }

    return( Status );
}


/*++

Function:

    Bsafe2CapiPubKey

Routine Description:

    Converts a Bsafe public key to a CAPI public key info structure

Arguments:

    pCapiPubKeyInfo - Pointer to the CAPI public key info structure
    pbBsafePubKey - Pointer to the Bsafe public key
    cbBsafePubKey - size of the Bsafe public key


Returns:

    LICENSE_STATUS return code.

--*/

LICENSE_STATUS
Bsafe2CapiPubKey(
    PCERT_PUBLIC_KEY_INFO   pCapiPubKeyInfo,
    LPBYTE                  pbBsafeKey,
    DWORD                   cbBsafeKey )
{
    PUBLICKEYSTRUC *
        pCapiPublicKey;
    RSAPUBKEY *
        pRsaPublicKey;
    LPBSAFE_PUB_KEY
        pBsafePubKey = ( LPBSAFE_PUB_KEY )pbBsafeKey;
    LPBYTE
        pbKeyMem = NULL,
        pbEncodedPubKey = NULL;
    DWORD
        cbKeyMem,
        dwError,
        cbEncodedPubKey = 0;
    LICENSE_STATUS
        Status;
    
    if( ( NULL == pbBsafeKey ) || ( 0 == cbBsafeKey ) )
    {
        return( LICENSE_STATUS_INVALID_INPUT );
    }

    cbKeyMem = sizeof( PUBLICKEYSTRUC ) + sizeof( RSAPUBKEY ) + pBsafePubKey->keylen;
    pbKeyMem = ( LPBYTE )LocalAlloc( LPTR, cbKeyMem );

    if( NULL == pbKeyMem )
    {
        return( LICENSE_STATUS_OUT_OF_MEMORY );
    }

    //
    // convert the Bsafe public key to a crypto API public key structure.  
    // Note: make this a key exchange public key
    //

    pCapiPublicKey = ( PUBLICKEYSTRUC * )pbKeyMem;

    pCapiPublicKey->bType = PUBLICKEYBLOB;
    pCapiPublicKey->bVersion = CAPI_MAX_VERSION;
    pCapiPublicKey->reserved = 0;
    pCapiPublicKey->aiKeyAlg = CALG_RSA_KEYX;

    pRsaPublicKey = ( RSAPUBKEY * )( pbKeyMem + sizeof( PUBLICKEYSTRUC ) );
    
    pRsaPublicKey->magic = RSA1;
    pRsaPublicKey->bitlen = pBsafePubKey->bitlen;
    pRsaPublicKey->pubexp = pBsafePubKey->pubexp;

    memcpy( pbKeyMem + sizeof( PUBLICKEYSTRUC ) + sizeof( RSAPUBKEY ), 
            pbBsafeKey + sizeof( BSAFE_PUB_KEY ), 
            pBsafePubKey->keylen );

    //
    // encode the public key structure
    //

    __try
    {
        if( CryptEncodeObject( X509_ASN_ENCODING, RSA_CSP_PUBLICKEYBLOB , pbKeyMem, 
                               NULL, &cbEncodedPubKey ) )
        {
            pbEncodedPubKey = ( LPBYTE )LocalAlloc( LPTR, cbEncodedPubKey );

            if( NULL == pbEncodedPubKey )
            {
                Status = LICENSE_STATUS_OUT_OF_MEMORY;
                goto done;
            }

            memset( pbEncodedPubKey, 0, cbEncodedPubKey );

            if( !CryptEncodeObject( X509_ASN_ENCODING, RSA_CSP_PUBLICKEYBLOB , pbKeyMem, 
                                    pbEncodedPubKey, &cbEncodedPubKey ) )
            {
                Status = LICENSE_STATUS_ASN_ERROR;
                goto done;
            }    
        }
    }
    __except( EXCEPTION_EXECUTE_HANDLER )
    {
        DWORD dwExceptionCode = GetExceptionCode();

#if DBG
        DbgPrint( "LICECSP:  cannot encode server key pair: 0x%x\n", dwExceptionCode );
#endif
        Status = LICENSE_STATUS_ASN_ERROR;
        goto done;
    }

    //
    // now we can initialize the CAPI public key info structure
    //

    memset( pCapiPubKeyInfo, 0, sizeof( CERT_PUBLIC_KEY_INFO ) );
    
    pCapiPubKeyInfo->Algorithm.pszObjId = szOID_RSA_MD5RSA;
    pCapiPubKeyInfo->Algorithm.Parameters.cbData = 0;
    pCapiPubKeyInfo->Algorithm.Parameters.pbData = NULL;

    pCapiPubKeyInfo->PublicKey.cbData = cbEncodedPubKey;
    pCapiPubKeyInfo->PublicKey.pbData = pbEncodedPubKey;

    Status = LICENSE_STATUS_OK;

done:

    if( pbKeyMem )
    {
        LocalFree( pbKeyMem );
    }

    return( Status );
}


/*++

Function:

    FreeCapiPubKey

Routine Description:

    Free the memory in a capi pub key structure

Arguments:

    pCapiPubKeyInfo - Pointer to the CAPI public key info structure

Returns:

    Windows return code.

--*/

VOID
FreeCapiPubKey(
    PCERT_PUBLIC_KEY_INFO   pCapiPubKeyInfo )
{
    if( pCapiPubKeyInfo->Algorithm.Parameters.pbData )
    {
        LocalFree( pCapiPubKeyInfo->Algorithm.Parameters.pbData );
        pCapiPubKeyInfo->Algorithm.Parameters.pbData = NULL;
    }

    if( pCapiPubKeyInfo->PublicKey.pbData )
    {
        LocalFree( pCapiPubKeyInfo->PublicKey.pbData );
        pCapiPubKeyInfo->PublicKey.pbData = NULL;
    }

    return;
}

//////////////////////////////////////////////////////////////////

DWORD
VerifyTermServCertificate(
    DWORD cbCertLen,
    PBYTE pbCert,
    DWORD cbPrivateKeyLen,
    PBYTE pbPrivateKey
    )
/*++

Function :
    
    VerifyTermServCertificate

Routine Description:

    Verify TermSrv's X509 Certificate issued License Server, caller
    must protect this call with critical section or mutex.

Arguments:

    cbCertLen : size of TermSrv certificate.
    pbCertLen : Pointer to TermSrv certificate to be verify.
    cbPrivateKeyLen : Size of TermSrv private key.
    pbPrivateKey : pointer to TermSrv private key.

Returns:

    TRUE/FALSE

--*/
{
    LICENSE_STATUS dwStatus = LICENSE_STATUS_OK;
    PBYTE pbPublicKeyInLsa = NULL;
    DWORD cbPublicKeyInLsa = 0;

    PBYTE pbPublicKeyInCert = NULL;
    DWORD cbPublicKeyInCert = 0;
    DWORD pfDates;

    CERT_PUBLIC_KEY_INFO CapiPubKeyInfoLsa;
    CERT_PUBLIC_KEY_INFO CapiPubKeyInfoCert;


    if(0 == cbCertLen || NULL == pbCert || 0 == cbPrivateKeyLen || NULL == pbPrivateKey)
    {
        ASSERT( 0 != cbCertLen && NULL != pbCert && 0 != cbPrivateKeyLen && NULL != pbPrivateKey );
        return LICENSE_STATUS_INVALID_INPUT;
    }

    //
    // try except here is to prevent memory leak
    //
    __try {

        memset(&CapiPubKeyInfoLsa, 0, sizeof(CapiPubKeyInfoLsa));
        memset(&CapiPubKeyInfoCert, 0, sizeof(CapiPubKeyInfoCert));


        // 
        // Load the public key from LSA
        //
    
        dwStatus = LsCsp_RetrieveSecret(
                                X509_CERT_PUBLIC_KEY_NAME,
                                NULL,
                                &cbPublicKeyInLsa
                            );

        if( LICENSE_STATUS_OK != dwStatus || 0 == cbPublicKeyInLsa )
        {

            #if DBG
            DbgPrint( "LSCSP: VerifyTermServCertificate() No public key...\n" );
            #endif

            dwStatus = LICENSE_STATUS_CANNOT_RETRIEVE_SECRET;
            goto cleanup;
        }

        // allocate memory
        pbPublicKeyInLsa = (PBYTE)LocalAlloc(LPTR, cbPublicKeyInLsa);
        if(NULL == pbPublicKeyInLsa)
        {
            dwStatus = LICENSE_STATUS_OUT_OF_MEMORY;
            goto cleanup;
        }

        dwStatus = LsCsp_RetrieveSecret(
                                X509_CERT_PUBLIC_KEY_NAME,
                                pbPublicKeyInLsa,
                                &cbPublicKeyInLsa
                            );

        if( LICENSE_STATUS_OK != dwStatus || 0 == cbPublicKeyInLsa )
        {
            dwStatus = LICENSE_STATUS_CANNOT_RETRIEVE_SECRET;
            goto cleanup;
        }


        //
        // Verify certificate and compare public key
        //

        //
        // Try to avoid calling VerifyCertChain() twice.
        //
        cbPublicKeyInCert = 1024;
        pbPublicKeyInCert = (PBYTE)LocalAlloc(LPTR, cbPublicKeyInCert);
        if(NULL == pbPublicKeyInCert)
        {
            dwStatus = LICENSE_STATUS_OUT_OF_MEMORY;
            goto cleanup;
        }

        pfDates = CERT_DATE_DONT_VALIDATE;
        dwStatus = VerifyCertChain(
                                pbCert,
                                cbCertLen,
                                pbPublicKeyInCert,
                                &cbPublicKeyInCert,
                                &pfDates
                            );

        if(LICENSE_STATUS_OK != dwStatus && LICENSE_STATUS_INSUFFICIENT_BUFFER != dwStatus)   
        {

            #if DBG
            DbgPrint( "LSCSP: VerifyCertChain() failed with error code %d\n", dwStatus );
            #endif

            goto cleanup;
        }

        if( dwStatus == LICENSE_STATUS_INSUFFICIENT_BUFFER )
        {
            if( NULL != pbPublicKeyInCert )
            {
                LocalFree(pbPublicKeyInCert);
            }

            pbPublicKeyInCert = (PBYTE)LocalAlloc(LPTR, cbPublicKeyInCert);
            if(NULL == pbPublicKeyInCert)
            {
                dwStatus = LICENSE_STATUS_OUT_OF_MEMORY;
                goto cleanup;
            }

            pfDates = CERT_DATE_DONT_VALIDATE;
            dwStatus = VerifyCertChain(
                                    pbCert,
                                    cbCertLen,
                                    pbPublicKeyInCert,
                                    &cbPublicKeyInCert,
                                    &pfDates
                                );

            if(LICENSE_STATUS_OK != dwStatus)
            {
                goto cleanup;
            }
        }

        dwStatus = Bsafe2CapiPubKey(
                                &CapiPubKeyInfoCert, 
                                pbPublicKeyInCert, 
                                cbPublicKeyInCert 
                            );  

        if(LICENSE_STATUS_OK != dwStatus)
        {
            #if DBG
            DbgPrint( 
                    "LSCSP: Bsafe2CapiPubKey() on public key in certificate failed with %d\n", 
                    dwStatus
                );
            #endif

            goto cleanup;
        }

        dwStatus = Bsafe2CapiPubKey(
                                &CapiPubKeyInfoLsa, 
                                pbPublicKeyInLsa, 
                                cbPublicKeyInLsa 
                            );  

        if(LICENSE_STATUS_OK != dwStatus)
        {
            #if DBG
            DbgPrint( 
                    "LSCSP: Bsafe2CapiPubKey() on public key in LSA failed with %d\n", 
                    dwStatus
                );
            #endif

            goto cleanup;
        }


        //
        // compare public key
        //
        if( CapiPubKeyInfoCert.PublicKey.cbData != CapiPubKeyInfoLsa.PublicKey.cbData )
        {

            #if DBG
            DbgPrint( 
                    "LSCSP: public key length mismatched %d %d\n", 
                    CapiPubKeyInfoCert.PublicKey.cbData, 
                    CapiPubKeyInfoLsa.PublicKey.cbData 
                );
            #endif

            dwStatus = LICENSE_STATUS_INVALID_CERTIFICATE;
        }
        else if( memcmp(
                        CapiPubKeyInfoCert.PublicKey.pbData, 
                        CapiPubKeyInfoLsa.PublicKey.pbData, 
                        CapiPubKeyInfoLsa.PublicKey.cbData
                    ) != 0 )
        {

            #if DBG
            DbgPrint( "LSCSP: public mismatched\n" );
            #endif

            dwStatus = LICENSE_STATUS_INVALID_CERTIFICATE;
        }
    }
    __except( EXCEPTION_EXECUTE_HANDLER ) {
        dwStatus = LICENSE_STATUS_INVALID_INPUT;
    }

cleanup:

    FreeCapiPubKey( &CapiPubKeyInfoCert );
    FreeCapiPubKey( &CapiPubKeyInfoLsa );

    if( NULL != pbPublicKeyInLsa )
    {
        LocalFree( pbPublicKeyInLsa );
    }

    if( NULL != pbPublicKeyInCert )
    {
        LocalFree( pbPublicKeyInCert );
    }

    return dwStatus;
}

//////////////////////////////////////////////////////////////////

LICENSE_STATUS
ReloadCSPCertificateAndData()
{
    BOOL bSuccess;

    DWORD Status = LICENSE_STATUS_OK;
    LPBYTE i_csp_abServerX509Cert = NULL;
    DWORD  i_csp_dwServerX509CertLen = 0;
    
    DWORD i_csp_dwX509CertPrivateKeyLen = 0;
    LPBYTE i_csp_abX509CertPrivateKey = NULL;

    LPBYTE i_csp_abX509CertID = NULL;
    DWORD i_csp_dwX509CertIDLen = 0;

    HKEY    hKey = NULL;
    DWORD   dwResult, dwDisp;


    //
    // Acquire exclusive access
    //
    ACQUIRE_EXCLUSIVE_ACCESS( csp_hMutex );

    //
    // Prevent re-loading of same certificate/private key
    //
    if( NULL == csp_abServerX509Cert || 0 == csp_dwServerX509CertLen ||
        NULL == csp_abX509CertPrivateKey || 0 == csp_dwX509CertPrivateKeyLen || 
        NULL == csp_abX509CertID || 0 == csp_dwX509CertIDLen )
    {

        //
        // Open the Registry
        //
        if( RegCreateKeyEx(
                        HKEY_LOCAL_MACHINE,
                        TEXT( HYDRA_CERT_REG_KEY ),
                        0,
                        NULL,
                        REG_OPTION_NON_VOLATILE,
                        KEY_READ | KEY_WRITE,
                        NULL,
                        &hKey,
                        &dwDisp ) != ERROR_SUCCESS )
        {
            Status = LICENSE_STATUS_NO_CERTIFICATE;
        }
        else
        {
            __try {

                //
                // Get the X509 certificate from the registry. 
                //

                Status = LsCsp_GetBinaryData( 
                                    hKey,
                                    TEXT( HYDRA_X509_CERTIFICATE ),
                                    &i_csp_abServerX509Cert,
                                    &i_csp_dwServerX509CertLen 
                                );

                if( LICENSE_STATUS_OK == Status && 0 != i_csp_dwServerX509CertLen )
                {
                    //
                    // Get the corresponding private key from the store.
                    // It is not OK if we have the X509 certificate but not the
                    // private key that goes with it.
                    //

                    Status = LsCsp_RetrieveSecret( 
                                            X509_CERT_PRIVATE_KEY_NAME, 
                                            NULL,
                                            &i_csp_dwX509CertPrivateKeyLen 
                                        );

                    if( LICENSE_STATUS_OK == Status )
                    {
                        i_csp_abX509CertPrivateKey = LocalAlloc( LPTR, i_csp_dwX509CertPrivateKeyLen );

                        if( NULL != i_csp_abX509CertPrivateKey )
                        {
                            Status = LsCsp_RetrieveSecret( 
                                                    X509_CERT_PRIVATE_KEY_NAME, 
                                                    i_csp_abX509CertPrivateKey,
                                                    &i_csp_dwX509CertPrivateKeyLen 
                                                );

                            if(LICENSE_STATUS_OK == Status)
                            {
                                //
                                // Get the certificate ID for the X509 certificate
                                //

                                Status = LsCsp_GetBinaryData(
                                                    hKey,
                                                    TEXT( HYDRA_X509_CERT_ID ),
                                                    &i_csp_abX509CertID,
                                                    &i_csp_dwX509CertIDLen 
                                                );
                            }
                        }
                        else // memory allocate 
                        {
                            Status = LICENSE_STATUS_OUT_OF_MEMORY;
                        }
                    }
                }
                else
                {
                    Status = LICENSE_STATUS_NO_CERTIFICATE;
                }

            }
            __except( EXCEPTION_EXECUTE_HANDLER ) {
                Status = LICENSE_STATUS_INVALID_INPUT;
            }
        }


        //
        // verify our certificate
        //
        if(LICENSE_STATUS_OK == Status)
        {
            Status = VerifyTermServCertificate(
                                        i_csp_dwServerX509CertLen, 
                                        i_csp_abServerX509Cert, 
                                        i_csp_dwX509CertPrivateKeyLen, 
                                        i_csp_abX509CertPrivateKey
                                    );

            if( LICENSE_STATUS_OK != Status )
            {
                //
                // Deleting the X509 certificate is enough.
                //
                RegDeleteValue( hKey, TEXT( HYDRA_X509_CERTIFICATE ) );
            }
        }
            
        if(LICENSE_STATUS_OK != Status)
        {
            if( NULL != i_csp_abServerX509Cert )
            {
                LocalFree( i_csp_abServerX509Cert );
            }
       
            if( NULL != i_csp_abX509CertPrivateKey )
            {
                LocalFree( i_csp_abX509CertPrivateKey );
            }

            if( NULL != i_csp_abX509CertID )
            {
                LocalFree( i_csp_abX509CertID );
            }
        }
        else 
        {
            csp_abServerX509Cert = i_csp_abServerX509Cert;
            csp_dwServerX509CertLen = i_csp_dwServerX509CertLen;

            csp_dwX509CertPrivateKeyLen = i_csp_dwX509CertPrivateKeyLen;
            csp_abX509CertPrivateKey = i_csp_abX509CertPrivateKey;

            csp_abX509CertID = i_csp_abX509CertID;
            csp_dwX509CertIDLen = i_csp_dwX509CertIDLen;
        }
    }

    RELEASE_EXCLUSIVE_ACCESS( csp_hMutex );

    if (hKey)
    {
        RegCloseKey(hKey);
    }

    return Status;
}

LICENSE_STATUS
CreateProprietaryKeyAndCert(
    PBYTE *ppbPrivateKey,
    DWORD *pcbPrivateKey,
    PBYTE *ppbServerCert,
    DWORD *pcbServerCert
    )
{
#define     MD5RSA      0x01;
#define     RSAKEY      0x01;

    LPBSAFE_PRV_KEY		PRV;
    Hydra_Server_Cert   Cert;
    DWORD               KeyLen = 512;
    DWORD               bits, j;
    DWORD               dwPubSize, dwPrivSize;
    BYTE                *kPublic;
    BYTE                *kPrivate;
    MD5_CTX             HashState;
    PBYTE               pbData, pbTemp = NULL;
    DWORD               dwTemp = 0;
    BYTE                pbHash[0x48];
    BYTE                Output[0x48];
    unsigned char prvmodulus[] =
    {
        0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00,
        0x3d, 0x3a, 0x5e, 0xbd,
        0x72, 0x43, 0x3e, 0xc9, 0x4d, 0xbb, 0xc1, 0x1e,
        0x4a, 0xba, 0x5f, 0xcb, 0x3e, 0x88, 0x20, 0x87,
        0xef, 0xf5, 0xc1, 0xe2, 0xd7, 0xb7, 0x6b, 0x9a,
        0xf2, 0x52, 0x45, 0x95, 0xce, 0x63, 0x65, 0x6b,
        0x58, 0x3a, 0xfe, 0xef, 0x7c, 0xe7, 0xbf, 0xfe,
        0x3d, 0xf6, 0x5c, 0x7d, 0x6c, 0x5e, 0x06, 0x09,
        0x1a, 0xf5, 0x61, 0xbb, 0x20, 0x93, 0x09, 0x5f,
        0x05, 0x6d, 0xea, 0x87, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x3f, 0xbd, 0x29, 0x20,
        0x57, 0xd2, 0x3b, 0xf1, 0x07, 0xfa, 0xdf, 0xc1,
        0x16, 0x31, 0xe4, 0x95, 0xea, 0xc1, 0x2a, 0x46,
        0x2b, 0xad, 0x88, 0x57, 0x55, 0xf0, 0x57, 0x58,
        0xc6, 0x6f, 0x95, 0xeb, 0x00, 0x00, 0x00, 0x00,
        0x83, 0xdd, 0x9d, 0xd0, 0x03, 0xb1, 0x5a, 0x9b,
        0x9e, 0xb4, 0x63, 0x02, 0x43, 0x3e, 0xdf, 0xb0,
        0x52, 0x83, 0x5f, 0x6a, 0x03, 0xe7, 0xd6, 0x78,
        0x45, 0x83, 0x6a, 0x5b, 0xc4, 0xcb, 0xb1, 0x93,
        0x00, 0x00, 0x00, 0x00, 0x65, 0x9d, 0x43, 0xe8,
        0x48, 0x17, 0xcd, 0x29, 0x7e, 0xb9, 0x26, 0x5c,
        0x79, 0x66, 0x58, 0x61, 0x72, 0x86, 0x6a, 0xa3,
        0x63, 0xad, 0x63, 0xb8, 0xe1, 0x80, 0x4c, 0x0f,
        0x36, 0x7d, 0xd9, 0xa6, 0x00, 0x00, 0x00, 0x00,
        0x75, 0x3f, 0xef, 0x5a, 0x01, 0x5f, 0xf6, 0x0e,
        0xd7, 0xcd, 0x59, 0x1c, 0xc6, 0xec, 0xde, 0xf3,
        0x5a, 0x03, 0x09, 0xff, 0xf5, 0x23, 0xcc, 0x90,
        0x27, 0x1d, 0xaa, 0x29, 0x60, 0xde, 0x05, 0x6e,
        0x00, 0x00, 0x00, 0x00, 0xc0, 0x17, 0x0e, 0x57,
        0xf8, 0x9e, 0xd9, 0x5c, 0xf5, 0xb9, 0x3a, 0xfc,
        0x0e, 0xe2, 0x33, 0x27, 0x59, 0x1d, 0xd0, 0x97,
        0x4a, 0xb1, 0xb1, 0x1f, 0xc3, 0x37, 0xd1, 0xd6,
        0xe6, 0x9b, 0x35, 0xab, 0x00, 0x00, 0x00, 0x00,
        0x87, 0xa7, 0x19, 0x32, 0xda, 0x11, 0x87, 0x55,
        0x58, 0x00, 0x16, 0x16, 0x25, 0x65, 0x68, 0xf8,
        0x24, 0x3e, 0xe6, 0xfa, 0xe9, 0x67, 0x49, 0x94,
        0xcf, 0x92, 0xcc, 0x33, 0x99, 0xe8, 0x08, 0x60,
        0x17, 0x9a, 0x12, 0x9f, 0x24, 0xdd, 0xb1, 0x24,
        0x99, 0xc7, 0x3a, 0xb8, 0x0a, 0x7b, 0x0d, 0xdd,
        0x35, 0x07, 0x79, 0x17, 0x0b, 0x51, 0x9b, 0xb3,
        0xc7, 0x10, 0x01, 0x13, 0xe7, 0x3f, 0xf3, 0x5f,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00
    };

    PRV = (LPBSAFE_PRV_KEY)prvmodulus;
    PRV->magic = RSA2;
    PRV->keylen = 0x48;
    PRV->bitlen = 0x0200;
    PRV->datalen = 0x3f;
    PRV->pubexp = 0xc0887b5b;

    Cert.dwVersion = 0x01;
    Cert.dwSigAlgID = MD5RSA;
    Cert.dwKeyAlgID = RSAKEY;

    bits = KeyLen;

    if (!BSafeComputeKeySizes(&dwPubSize, &dwPrivSize, &bits))
    {
        return LICENSE_STATUS_INVALID_INPUT;
    }

    if ((kPrivate = (BYTE *)LocalAlloc(LPTR,dwPrivSize)) == NULL)
    {
        return LICENSE_STATUS_OUT_OF_MEMORY;
    }

    if ((kPublic = (BYTE *)LocalAlloc(LPTR,dwPubSize)) == NULL)
    {
        LocalFree(kPrivate);
        return LICENSE_STATUS_OUT_OF_MEMORY;
    }

    if (!BSafeMakeKeyPair((LPBSAFE_PUB_KEY)kPublic,
                          (LPBSAFE_PRV_KEY)kPrivate,
                          KeyLen))
    {
        LocalFree(kPrivate);
        LocalFree(kPublic);
        return LICENSE_STATUS_OUT_OF_MEMORY;
    }

    // make proprietary format cert

    Cert.PublicKeyData.wBlobType = BB_RSA_KEY_BLOB;
    Cert.PublicKeyData.wBlobLen = (WORD)dwPubSize;
    if( NULL == (Cert.PublicKeyData.pBlob = (PBYTE)LocalAlloc(LPTR,dwPubSize) ) )
    {
        LocalFree(kPrivate);
        LocalFree(kPublic);
        return LICENSE_STATUS_OUT_OF_MEMORY;
    }

    memcpy(Cert.PublicKeyData.pBlob, kPublic, dwPubSize);

    dwTemp = 3*sizeof(DWORD) + 2*sizeof(WORD) + dwPubSize;
    if( NULL == (pbData = (PBYTE)LocalAlloc(LPTR,dwTemp)) )
    {
        LocalFree(kPrivate);
        LocalFree(kPublic);
        LocalFree(Cert.PublicKeyData.pBlob);
        return LICENSE_STATUS_OUT_OF_MEMORY;
    }

    pbTemp = pbData;
    memcpy(pbTemp, &Cert.dwVersion, sizeof(DWORD));
    pbTemp += sizeof(DWORD);
    memcpy(pbTemp, &Cert.dwSigAlgID, sizeof(DWORD));
    pbTemp += sizeof(DWORD);

	memcpy(pbTemp, &Cert.dwKeyAlgID, sizeof(DWORD));
    pbTemp += sizeof(DWORD);

    memcpy(pbTemp, &Cert.PublicKeyData.wBlobType, sizeof(WORD));
    pbTemp += sizeof(WORD);

    memcpy(pbTemp, &Cert.PublicKeyData.wBlobLen, sizeof(WORD));
    pbTemp += sizeof(WORD);

    memcpy(pbTemp, Cert.PublicKeyData.pBlob, Cert.PublicKeyData.wBlobLen);
    pbTemp += Cert.PublicKeyData.wBlobLen;

    // sign the cert

    MD5Init(&HashState);
    MD5Update(&HashState, pbData, dwTemp);
    MD5Final(&HashState);
	
    LocalFree(pbData);

	memset(pbHash, 0x00, 0x48);
	memset(pbHash, 0xff, 0x40);

    pbHash[0x40-1] = 0;
    pbHash[0x40-2] = 1;
    pbHash[16] = 0;
    memcpy(pbHash, HashState.digest, 16);

    BSafeDecPrivate(PRV, pbHash, Output);

	Cert.SignatureBlob.wBlobType = BB_RSA_SIGNATURE_BLOB;
    Cert.SignatureBlob.wBlobLen = 0x48;
    if( NULL == (Cert.SignatureBlob.pBlob = (PBYTE)LocalAlloc(LPTR,Cert.SignatureBlob.wBlobLen)) )
    {
        LocalFree(kPrivate);
        LocalFree(kPublic);
        LocalFree(Cert.PublicKeyData.pBlob);
        return LICENSE_STATUS_OUT_OF_MEMORY;
    }

    memcpy(Cert.SignatureBlob.pBlob, Output, Cert.SignatureBlob.wBlobLen);

    // Pack the Hydra_Server_Cert

    dwTemp = 3*sizeof(DWORD) + 4*sizeof(WORD) + dwPubSize + 0x48;

	if( NULL == (pbData = (PBYTE)LocalAlloc(LPTR,dwTemp)) )
    {
        LocalFree(kPrivate);
        LocalFree(kPublic);
        LocalFree(Cert.PublicKeyData.pBlob);
        return LICENSE_STATUS_OUT_OF_MEMORY;
    }

    pbTemp = pbData;
    memcpy(pbTemp, &Cert.dwVersion, sizeof(DWORD));
    pbTemp += sizeof(DWORD);

    memcpy(pbTemp, &Cert.dwSigAlgID, sizeof(DWORD));
    pbTemp += sizeof(DWORD);
    memcpy(pbTemp, &Cert.dwKeyAlgID, sizeof(DWORD));
    pbTemp += sizeof(DWORD);

	memcpy(pbTemp, &Cert.PublicKeyData.wBlobType, sizeof(WORD));
    pbTemp += sizeof(WORD);

    memcpy(pbTemp, &Cert.PublicKeyData.wBlobLen, sizeof(WORD));
    pbTemp += sizeof(WORD);

    memcpy(pbTemp, Cert.PublicKeyData.pBlob, Cert.PublicKeyData.wBlobLen);
    pbTemp += Cert.PublicKeyData.wBlobLen;

    memcpy(pbTemp, &Cert.SignatureBlob.wBlobType, sizeof(WORD));
    pbTemp += sizeof(WORD);

    memcpy(pbTemp, &Cert.SignatureBlob.wBlobLen, sizeof(WORD));
    pbTemp += sizeof(WORD);

    memcpy(pbTemp, Cert.SignatureBlob.pBlob, Cert.SignatureBlob.wBlobLen);

    *ppbPrivateKey = kPrivate;
    *pcbPrivateKey = dwPrivSize;

    *ppbServerCert = pbData;
    *pcbServerCert = dwTemp;

    LocalFree(kPublic);

    return LICENSE_STATUS_OK;
}

//***************************************************************************
//
//  IsSystemService
//
//  returns TRUE if we are running as local system
//
//***************************************************************************

BOOL IsSystemService()
{
    BOOL bOK = FALSE;

	// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	// Construct the local system SID
	// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    SID    LocalSystemSid = { SID_REVISION,
                              1,
                              SECURITY_NT_AUTHORITY,
                              SECURITY_LOCAL_SYSTEM_RID };

    if ( !CheckTokenMembership ( NULL, &LocalSystemSid, &bOK ) )
    {
        bOK = FALSE;
    }

	return bOK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\license\tlserver\tlsapi\sources.inc ===
!IF 0

Copyright (c) 1989  Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


Author:


NOTE:   Commented description of this file is in \nt\bak\bin\sources.tpl

!ENDIF

MISC_SOURCES=\
    ..\tlsapi.rc \
    ..\tlsapi.c \
    ..\efind.cpp \
    ..\tlsrpc-c.c \
    ..\cert.c \
    ..\tlsapip.c \
    ..\csp.c \
    ..\global.c
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\license\tlserver\tlsapi\secdbg.h ===
/*++

Copyright (c) 1994-1998  Microsoft Corporation

Module Name:

    secdbg.h

Abstract:

    Debug macro definition file.

Author:

    Madan Appiah (madana)  24-Jan-1998

Environment:

    User Mode - Win32

Revision History:

--*/

#ifndef _SECDBG_H_
#define _SECDBG_H_

//
// assert macros.
//

#ifndef OS_WIN16

NTSYSAPI
VOID
NTAPI
RtlAssert(
    PVOID FailedAssertion,
    PVOID FileName,
    DWORD LineNumber,
    PCHAR Message
    );

#define RTLASSERT( msg, exp)
//        RtlAssert( #exp, __FILE__, __LINE__, NULL )

#define RTLASSERTMSG( msg, exp)
//        RtlAssert( #exp, __FILE__, __LINE__, msg )

#else // OS_WIN16

#define RTLASSERT( msg, exp)
#define RTLASSERTMSG( msg, exp)

#endif // OS_WIN16


#if DBG

#undef ASSERT
#undef ASSERTMSG

#define ASSERT( exp ) \
    if (!(exp)) { \
        RTLASSERT( msg, exp); \
    } \


#define ASSERTMSG( msg, exp ) \
    if (!(exp)) { \
        RTLASSERT( msg, exp); \
    } \

#else

#ifndef ASSERT
#define ASSERT( exp )
#endif

#ifndef ASSERTMSG
#define ASSERTMSG( msg, exp )
#endif

#endif // DBG

#endif // _SECDBG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\license\tlserver\tlsapi\efind.cpp ===
/*
**	Copyright (c) 1998 Microsoft Corporation
**	All Rights Reserved
**
**
*/
#include <windows.h>
#include <objbase.h>
#include <winbase.h>
#include <wchar.h>

// Required by SSPI.H
#define SECURITY_WIN32
#include <sspi.h>

#include <dsgetdc.h>
#include <ntdsapi.h>
#include <lmcons.h>
#include <lmapibuf.h>
#include <activeds.h>
#include "lscommon.h"
#include "tlsrpc.h"
#include "tlsapi.h"
#include "tlsapip.h"

#define CWSTR_SIZE(x)       (sizeof(x) - (sizeof(WCHAR) * 2))
#define DWSTR_SIZE(x)       ((wcslen(x) + 1) * sizeof(WCHAR))

#define LICENSE_SETTINGS                L"TS-Enterprise-License-Server"
#define LICENSE_SETTINGS_FORMAT         L"LDAP://CN=%ws,CN=%ws,CN=%ws,%ws"
#define LICENSE_SETTINGS_SIZE           CWSTR_SIZE(LICENSE_SETTINGS)
#define LICENSE_SETTINGS_FORMAT_SIZE    CWSTR_SIZE(LICENSE_SETTINGS_FORMAT)
#define SITES               L"sites"
#define SITES_SIZE          CWSTR_SIZE(SITES)
#define CONFIG_CNTNR        L"ConfigurationNamingContext"
#define CONFIG_CNTNR_FORMAT L"LDAP://CN=%ws,%ws"
#define CONFIG_CNTNR_FORMAT_SIZE    CWSTR_SIZE(CONFIG_CNTNR_FORMAT)
#define ROOT_DSE_PATH       L"LDAP://RootDSE"
#define ADS_PATH            L"ADsPath"
#define SEARCH_FILTER       L"(CN=TS-Enterprise-LicenseServer)"
#define DNS_MACHINE_NAME    L"dNSHostName"
#define IS_DELETED          L"isDeleted"
#define SITE_SERVER         L"siteServer"

HRESULT GetLicenseServersFromReg(LPWSTR wszRegKey, LPWSTR *ppwszServerNames,DWORD *pcServers, LPWSTR **prgwszServers);

HRESULT
WriteLicenseServersToReg(LPWSTR wszRegKey, LPWSTR pwszServerNames,DWORD cchServers);

extern BOOL g_fInDomain;

extern "C" DWORD WINAPI 
TLSDisconnect( 
    TLS_HANDLE* pphContext
);

//
// Pre-fill the ADSI cache with only the attribute we want, then get it
// Only use if exactly one attribute is needed
//

HRESULT
GetWithGetInfoEx(
                 IADs *pADs,
                 LPWSTR wszAttribute,
                 VARIANT *pvar
                 )
{
    HRESULT hr;

    hr = ADsBuildVarArrayStr( &wszAttribute, 1, pvar );
    if( SUCCEEDED( hr ) )
    {
        hr = pADs->GetInfoEx( *pvar, 0L );
        if(SUCCEEDED(hr))
        {
            hr = VariantClear( pvar );
            if(SUCCEEDED(hr))
            {        
                BSTR bstrval = SysAllocString(wszAttribute);
                if(NULL == bstrval)
                    return E_OUTOFMEMORY;
         
                hr = pADs->Get( bstrval, pvar );            

                SysFreeString(bstrval);            
            }
        }
    }

    return hr;
}

//
// Pre-fill the ADSI cache with only the attributes we want, then get them
// Only use if exactly two attributes are needed
//

HRESULT
GetWithGetInfoEx2(
                 IADs *pADs,
                 LPWSTR wszAttribute1,
                 LPWSTR wszAttribute2,
                 VARIANT *pvar1,
                 VARIANT *pvar2,
                 HRESULT *phr2
                 )
{
    HRESULT hr;
    LPWSTR rgwszAttributes[] = {wszAttribute1,wszAttribute2};

    hr = ADsBuildVarArrayStr( rgwszAttributes, 2, pvar1 );
    if( SUCCEEDED( hr ) )
    {
        hr = pADs->GetInfoEx( *pvar1, 0L );
        if (SUCCEEDED(hr))
        {
            hr = VariantClear( pvar1 );

            if(SUCCEEDED(hr))
            {
                BSTR bstrval1 = SysAllocString(wszAttribute1);
                if(NULL == bstrval1)
                    return E_OUTOFMEMORY;

                BSTR bstrval2 = SysAllocString(wszAttribute2);
                if( NULL == bstrval2)
                {
                    SysFreeString(bstrval1);
                    return E_OUTOFMEMORY;
                }
                
                hr = pADs->Get( bstrval1, pvar1 );

                if (SUCCEEDED(hr))
                {
                    *phr2 = pADs->Get( bstrval2, pvar2 );
                }
            
                SysFreeString(bstrval1);
                SysFreeString(bstrval2);        
            }
        }
    }

    return hr;
}

HRESULT
GetExWithGetInfoEx(
                   IADs *pADs,
                   LPWSTR wszAttribute,
                   VARIANT *pvar
                   )
{
    HRESULT hr;

    hr = ADsBuildVarArrayStr( &wszAttribute, 1, pvar );
    if( SUCCEEDED( hr ) )
    {
        hr = pADs->GetInfoEx( *pvar, 0L );
        if(SUCCEEDED(hr))
        {
            hr = VariantClear( pvar );
            if(SUCCEEDED(hr))
            {
                BSTR bstrval = SysAllocString(wszAttribute);
                if(NULL == bstrval)
                    return E_OUTOFMEMORY;
                
                hr = pADs->GetEx( bstrval, pvar );                

                SysFreeString(bstrval);
            }
        }
    }

    return hr;
}

HRESULT GetLicenseSettingsObject(VARIANT *pvar,
                                 LPWSTR *ppwszLicenseSettings,
                                 LPWSTR *ppwszSiteName,
                                 IADs **ppADs)
{
    HRESULT          hr;
    DWORD            dwErr = 0;
    LPWSTR           pwszConfigContainer;
    IADs *           pADs = NULL;
    IDirectorySearch *pADsSearch = NULL;
    ADS_SEARCH_HANDLE hSearch = NULL;
    ADS_SEARCH_COLUMN Column;
    LPWSTR           pwszAdsPath = ADS_PATH;
    LPWSTR           pwszSitesPath = NULL;
    BOOL             fInDomain;

    if (g_fInDomain == -1)
    {
        dwErr = TLSInDomain(&fInDomain,NULL);
        if (dwErr != NO_ERROR)
            return HRESULT_FROM_WIN32(dwErr);
    } else
    {
        fInDomain = g_fInDomain;
    }

    if (!fInDomain)
    {
        return HRESULT_FROM_WIN32(ERROR_NO_SUCH_DOMAIN);
    }

    VariantInit(pvar);
    
    //
    // Obtain the path to the configuration container.
    //

    hr = ADsGetObject(ROOT_DSE_PATH, IID_IADs, (void **)&pADs);

    if (FAILED(hr)) {
#ifdef PRIVATEDEBUG
        wprintf(L"ADsGetObject ROOT_DSE_PATH failed 0x%lx\n",hr);
#endif
        goto CleanExit;
    }

    BSTR bstrval = SysAllocString(CONFIG_CNTNR);
    if(NULL == bstrval)
    {
        hr = E_OUTOFMEMORY;
        goto CleanExit;
    }
    hr = pADs->Get(bstrval, pvar);
    SysFreeString(bstrval);

    if (FAILED(hr)) {
#ifdef PRIVATEDEBUG
        wprintf(L"Get CONFIG_CNTNR failed 0x%lx\n",hr);
#endif
        goto CleanExit;
    }

    if (V_VT(pvar) != VT_BSTR) {
        hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
#ifdef PRIVATEDEBUG
        wprintf(L"bad variant 0x%lx\n",hr);
#endif
        goto CleanExit;
    }

    pwszConfigContainer = pvar->bstrVal;  // For sake of readability.

    //
    // Get the site name, if possible
    //

    dwErr = DsGetSiteName(NULL, ppwszSiteName);

    if (dwErr == 0)
    {
        //
        // Build the X.500 path to the LicenseSettings object.
        //

        *ppwszLicenseSettings =
            (LPWSTR)LocalAlloc(
                               LPTR,
                               LICENSE_SETTINGS_FORMAT_SIZE
                               + LICENSE_SETTINGS_SIZE
                               + DWSTR_SIZE(*ppwszSiteName)
                               + SITES_SIZE
                               + DWSTR_SIZE(pwszConfigContainer)
                               + sizeof(TCHAR));

        if (*ppwszLicenseSettings == NULL) {
            hr = E_OUTOFMEMORY;
            goto CleanExit;
        }

        swprintf(*ppwszLicenseSettings,
                 LICENSE_SETTINGS_FORMAT,
                 LICENSE_SETTINGS,
                 *ppwszSiteName,
                 SITES,
                 pwszConfigContainer);
        
        hr = ADsGetObject(*ppwszLicenseSettings, IID_IADs, (void **)ppADs);

        if (SUCCEEDED(hr))
        {
            // return this object
            goto CleanExit;
        }
    } 

    //
    // None in our site (or we don't know our site)
    // Search all sites in GC, take first one
    //

    pwszSitesPath =
        (LPWSTR)LocalAlloc(
                           LPTR,
                           CONFIG_CNTNR_FORMAT_SIZE
                               + SITES_SIZE
                               + DWSTR_SIZE(pwszConfigContainer)
                               + sizeof(TCHAR));

        if (pwszSitesPath == NULL) {
            hr = E_OUTOFMEMORY;
            goto CleanExit;
        }

        swprintf(pwszSitesPath,
                 CONFIG_CNTNR_FORMAT,
                 SITES,
                 pwszConfigContainer);

    hr = ADsGetObject(pwszSitesPath,
                      IID_IDirectorySearch,
                      (void **)&pADsSearch);
    if (FAILED(hr))
    {
#ifdef PRIVATEDEBUG
        wprintf(L"ADsGetObject ConfigContainer (%s) failed 0x%lx\n",pwszConfigContainer,hr);
#endif
        goto CleanExit;
    }

    hr = pADsSearch->ExecuteSearch(SEARCH_FILTER,&pwszAdsPath,1,&hSearch);
    if (FAILED(hr))
    {
#ifdef PRIVATEDEBUG
        wprintf(L"ExecuteSearch failed 0x%lx\n",hr);
#endif
        goto CleanExit;
    }

    hr = pADsSearch->GetNextRow(hSearch);

    if (hr == S_ADS_NOMORE_ROWS)
        hr = E_ADS_PROPERTY_NOT_SET;

    if (FAILED(hr))
    {
#ifdef PRIVATEDEBUG
        wprintf(L"GetNextRow failed 0x%lx\n",hr);
#endif
        goto CleanExit;
    }

    hr = pADsSearch->GetColumn(hSearch,pwszAdsPath,&Column);
    if (FAILED(hr))
    {
#ifdef PRIVATEDEBUG
        wprintf(L"GetColumn (%ws) failed 0x%lx\n",pwszAdsPath,hr);
#endif
        goto CleanExit;
    }

    hr = ADsGetObject(Column.pADsValues->CaseIgnoreString,
                      IID_IADs,
                      (void **)ppADs);

    pADsSearch->FreeColumn(&Column);

CleanExit:
    if (NULL != pADs) {
        pADs->Release();
    }

    if (NULL != pADsSearch) {
        if (hSearch != NULL) {
            pADsSearch->CloseSearchHandle(hSearch);
        }

        pADsSearch->Release();
    }

    if (NULL != pwszSitesPath)
    {
        LocalFree(pwszSitesPath);
    }

    return hr;
}

HRESULT
GetRandomServer(IADs *pADs,
                VARIANT *pvar
                )
{
    HRESULT          hr;
    VARIANT          var;
    SAFEARRAY        *psaServers;
    LONG             lLower, lUpper, lPos;

    VariantInit(&var);

    hr = GetExWithGetInfoEx(pADs,SITE_SERVER,&var);
    if (FAILED(hr))
    {
#ifdef PRIVATEDEBUG
        wprintf(L"GetEx (%ws) failed 0x%lx\n",LICENSE_SETTINGS,hr);
#endif
        goto CleanExit;
    }

    psaServers = V_ARRAY(&var);
    if (NULL == psaServers)
    {
        hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
#ifdef PRIVATEDEBUG
        wprintf(L"GetEx no array failed 0x%lx\n",hr);
#endif
        goto CleanExit;
    }

    hr= SafeArrayGetLBound( psaServers, 1, &lLower );
    if (FAILED(hr))
    {
#ifdef PRIVATEDEBUG
        wprintf(L"SafeArrayGetLBound failed 0x%lx\n",hr);
#endif
        goto CleanExit;
    }

    hr= SafeArrayGetUBound( psaServers, 1, &lUpper );
    if (FAILED(hr))
    {
#ifdef PRIVATEDEBUG
        wprintf(L"SafeArrayGetUBound failed 0x%lx\n",hr);
#endif
        goto CleanExit;
    }

    srand(GetTickCount());

    lPos = (rand() % (lUpper - lLower + 1)) + lLower;

    hr = SafeArrayGetElement( psaServers, &lPos, pvar );
#ifdef PRIVATEDEBUG
        wprintf(L"SafeArrayGetElement (%d) failed? 0x%lx\n",lPos,hr);
#endif

CleanExit:
    VariantClear(&var);

    return hr;
}

HRESULT
GetAllServers(IADs *pADs,
              VARIANT *pvar
              )
{
    HRESULT          hr;

    hr = GetExWithGetInfoEx(pADs,SITE_SERVER,pvar);
    if (FAILED(hr))
    {
#ifdef PRIVATEDEBUG
        wprintf(L"GetEx (%ws) failed 0x%lx\n",LICENSE_SETTINGS,hr);
#endif
    }

    return hr;
}

HRESULT
DnToFqdn(LPWSTR pwszDN, LPWSTR pwszFqdn)
{
    LPWSTR           pwszBindPath;
    HRESULT          hr, hr2;
    IADs *           pADs2        = NULL;
    VARIANT          var2;
    VARIANT          var3;

    VariantInit(&var2);
    VariantInit(&var3);

    //
    // Bind to the computer object referenced by the Site-Server property.
    //

    // LDAP:// + pwszDN + 1
    pwszBindPath = (LPWSTR) LocalAlloc(LPTR,
                              (wcslen(pwszDN) + 8) * sizeof(WCHAR));

    if (pwszBindPath == NULL) {
        hr = E_OUTOFMEMORY;
#ifdef PRIVATEDEBUG
        wprintf(L"LocalAlloc failed 0x%lx\n",hr);
#endif
        goto CleanExit;
    }

    wsprintf(pwszBindPath, L"LDAP://%ws", pwszDN);

    hr = ADsOpenObject(pwszBindPath,
                       NULL,
                       NULL,
                       ADS_SERVER_BIND,
                       IID_IADs,
                       (void **)&pADs2);

    LocalFree(pwszBindPath);

    if (FAILED(hr))
    {
#ifdef PRIVATEDEBUG
        wprintf(L"ADsOpenObject failed 0x%lx\n",hr);
#endif
        goto CleanExit;
    }

    //
    // Fetch the Machine-DNS-Name property.
    //

    hr = GetWithGetInfoEx2(pADs2,DNS_MACHINE_NAME, IS_DELETED, &var3, &var2, &hr2);

    if (FAILED(hr)) {
#ifdef PRIVATEDEBUG
        wprintf(L"Get failed 0x%lx\n",hr);
#endif
        goto CleanExit;
    }

    if (SUCCEEDED(hr2))
    {
        hr = VariantChangeType(&var2,&var2,0,VT_BOOL);
        
        if (FAILED(hr)) {
#ifdef PRIVATEDEBUG
            wprintf(L"VariantChangeType failed 0x%lx\n",hr);
#endif

            goto CleanExit;
        }

        if (V_BOOL(&var2))
        {
            // object has been deleted - pretend it isn't set
            hr = E_ADS_PROPERTY_NOT_SET;
#ifdef PRIVATEDEBUG
            wprintf(L"Object deleted\n");
#endif
            goto CleanExit;
        }
    }

    if (V_VT(&var3) != VT_BSTR) {
        hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
#ifdef PRIVATEDEBUG
        wprintf(L"Get bad data 0x%lx\n",hr);
#endif
        goto CleanExit;
    }

    wcscpy(pwszFqdn,V_BSTR(&var3));

CleanExit:
    VariantClear(&var2);
    VariantClear(&var3);

    if (NULL != pADs2) {
        pADs2->Release();
    }

    return hr;
}

//
// First call with fUseReg TRUE; if the returned server doesn't work
// call again with fUseReg FALSE
//

extern "C"
HRESULT
FindEnterpriseServer(TLS_HANDLE *phBinding)
{
    HRESULT             hr;
    LPWSTR              *rgwszServers = NULL;
    LPWSTR              pwszServerNames = NULL;
    DWORD               entriesread, i;

    if (phBinding == NULL)
    {
        hr = HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER);
        goto CleanExit;
    }

    *phBinding = NULL;

    hr = GetLicenseServersFromReg(ENTERPRISE_SERVER_MULTI,&pwszServerNames,&entriesread,&rgwszServers);
    if (FAILED(hr))
    {
        goto CleanExit;
    }

    for (i = 0; i < entriesread; i++)
    {
        TLS_HANDLE pContext=NULL;
        RPC_STATUS rpcStatus;
        DWORD dwVersion;

        if(!(pContext = TLSConnectToLsServer(rgwszServers[i])))
        {
            break;
        }

        rpcStatus = TLSGetVersion(pContext,&dwVersion);
        if (rpcStatus != RPC_S_OK)
        {
            TLSDisconnect(&pContext);
            continue;
        }

        //
        // No Beta <--> RTM server.
        //
        //
        // TLSIsBetaNTServer() returns TRUE if eval NT
        // IS_LSSERVER_RTM() returns TRUE if LS is an RTM.
        //
        if( TLSIsBetaNTServer() == IS_LSSERVER_RTM(dwVersion) )
        {
            continue;
        }

        if (!(dwVersion & TLS_VERSION_ENTERPRISE_BIT))
        {
            TLSDisconnect(&pContext);
            continue;
        }

        *phBinding = pContext;
        break;
    }

CleanExit:
    if (pwszServerNames)
        LocalFree(pwszServerNames);

    if (rgwszServers)
        LocalFree(rgwszServers);

    return hr;
}

extern "C"
HRESULT
GetAllEnterpriseServers(WCHAR ***ppszServers, DWORD *pdwCount)
{
    LPWSTR           pwszSiteName = NULL;
    IADs *           pADs         = NULL;
    VARIANT          var;
    VARIANT          var2;
    LPWSTR           pwszLicenseSettings = NULL;
    HRESULT          hr;
    VARIANT HUGEP    *pvar = NULL;
    LONG             lLower, lUpper;
    int              i;
    LPWSTR           pwszRegServers = NULL;
    LPWSTR           pwszRegServersTmp;
    DWORD            cchServer, cchServers;
    int              cServers = 0;

    if (ppszServers != NULL)
        *ppszServers = NULL;

	// We're going to use ADSI,  so initialize COM.  We don't
	// care about OLE 1.0 so disable OLE 1 DDE

	hr = CoInitialize(NULL);
    
    if (FAILED(hr))
    {
        return hr;
    }

    VariantInit(&var);
    VariantInit(&var2);
    
    hr = GetLicenseSettingsObject(&var,
                                  &pwszLicenseSettings,
                                  &pwszSiteName,
                                  &pADs);


    if (FAILED(hr)) {
#ifdef PRIVATEDEBUG
        wprintf(L"GetLicenseSettingsObject failed 0x%lx\n",hr);
#endif
        goto CleanExit;
    }

    hr = GetAllServers(pADs,&var2);

    if (FAILED(hr))
    {
#ifdef PRIVATEDEBUG
        wprintf(L"GetAllServers failed 0x%lx\n",hr);
#endif
        WriteLicenseServersToReg(ENTERPRISE_SERVER_MULTI,NULL,0);
        goto CleanExit;
    }

    hr = SafeArrayGetLBound( V_ARRAY(&var2), 1, &lLower );
    if (FAILED(hr))
    {
#ifdef PRIVATEDEBUG
        wprintf(L"SafeArrayGetLBound failed 0x%lx\n",hr);
#endif
        goto CleanExit;
    }

    hr = SafeArrayGetUBound( V_ARRAY(&var2), 1, &lUpper );
    if (FAILED(hr))
    {
#ifdef PRIVATEDEBUG
        wprintf(L"SafeArrayGetUBound failed 0x%lx\n",hr);
#endif
        goto CleanExit;
    }

    // Get a pointer to the elements of the safearray.
    hr = SafeArrayAccessData(V_ARRAY(&var2), (void HUGEP* FAR*)&pvar);

    if (FAILED(hr)) {
        goto CleanExit;
    }

    if (ppszServers != NULL) {
        *ppszServers = (WCHAR * *) LocalAlloc(LPTR,(lUpper-lLower+1) * sizeof(WCHAR *));

        if (*ppszServers == NULL) {
            hr = E_OUTOFMEMORY;
#ifdef PRIVATEDEBUG
            wprintf(L"LocalAlloc failed 0x%lx\n",hr);
#endif
            goto CleanExit;
        }
    }

    pwszRegServers = (LPWSTR) LocalAlloc(LPTR,2*sizeof(WCHAR));
    if (NULL == pwszRegServers)
    {
#ifdef PRIVATEDEBUG
        wprintf(L"Out of memory\n");
#endif
        hr = E_OUTOFMEMORY;
        
        goto CleanExit;
    }

    cchServers = 2;
    pwszRegServers[0] = pwszRegServers[1] = L'\0';

    for (i = 0; i < lUpper-lLower+1; i++)
    {
        WCHAR *szServer = (WCHAR *) LocalAlloc(LPTR,MAX_PATH*2);

        if (szServer == NULL) {
            hr = E_OUTOFMEMORY;
#ifdef PRIVATEDEBUG
            wprintf(L"LocalAlloc failed 0x%lx\n",hr);
#endif

            if (ppszServers != NULL) {
                for (int j = 0; j < cServers; j++)
                {
                    LocalFree((*ppszServers)[j]);
                }
                LocalFree(*ppszServers);
            }

            goto CleanExit;
        }

        hr = DnToFqdn(V_BSTR(pvar+cServers),szServer);

        if (FAILED(hr))
        {
#ifdef PRIVATEDEBUG
            wprintf(L"DnToFqdn failed 0x%lx\n",hr);
#endif

            LocalFree(szServer);

            continue;
        }

        cchServer = wcslen(szServer);

        pwszRegServersTmp = (LPWSTR) LocalReAlloc(pwszRegServers,(cchServers+cchServer+1)*sizeof(TCHAR),LHND);
        if (NULL == pwszRegServersTmp)
        {
#ifdef PRIVATEDEBUG
            wprintf(L"LocalReAlloc failed 0x%lx\n",hr);
#endif
            hr = E_OUTOFMEMORY;

            if (ppszServers != NULL) {
                for (int j = 0; j < cServers; j++)
                {
                    LocalFree((*ppszServers)[j]);
                }
                LocalFree(*ppszServers);
            }
            LocalFree(szServer);

            goto CleanExit;
        }
                    
        pwszRegServers = pwszRegServersTmp;
                    
        if (cchServers == 2)
        {
            wcscpy(pwszRegServers,szServer);
                        
            cchServers += cchServer;
        } else
        {
            wcscpy(pwszRegServers+cchServers-1,szServer);
                        
            cchServers += cchServer + 1;
                        
        }
        pwszRegServers[cchServers-1] = L'\0';

        if (ppszServers != NULL)
        {
            (*ppszServers)[cServers] = szServer;
        }

        cServers++;
    }

    if (pdwCount != NULL)
        *pdwCount = cServers;

    WriteLicenseServersToReg(ENTERPRISE_SERVER_MULTI,pwszRegServers,cchServers);

CleanExit:
    VariantClear(&var);
    VariantClear(&var2);

    if (pwszSiteName != NULL) {         // Allocated from DsGetSiteName
        NetApiBufferFree(pwszSiteName);
    }

    if (pwszLicenseSettings != NULL) {
        LocalFree(pwszLicenseSettings);
    }

    if (pvar != NULL) {
        SafeArrayUnaccessData(V_ARRAY(&var2));
    }

    if (NULL != pADs) {
        pADs->Release();
    }

    if (pwszRegServers) {
        LocalFree(pwszRegServers);
    }

    CoUninitialize();

    if ((ppszServers != NULL) && (FAILED(hr)))
        *ppszServers = NULL;

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\license\tlserver\tlsapi\tlsapi.cpp ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996-1998
//
// File:        tlsapi.cpp
//
// Contents:    
//
// History:     12-09-97    HueiWang    Created
//
//---------------------------------------------------------------------------
#include <windows.h>
#include <wincrypt.h>
#include <stdio.h>
#include <stdlib.h>
#include <tchar.h>
#include <rpc.h>
#include <ntsecapi.h>
#include <lmcons.h>
#include <lmserver.h>
#include <lmerr.h>
#include <lmapibuf.h>
#include <ntdsapi.h>
#include <dsrole.h>
#include <lmjoin.h>
#include <winldap.h>
#include <winsock2.h>
#include <dsgetdc.h>

//
// Only include RNG functions from tssec
//
#define NO_INCLUDE_LICENSING 1
#include <tssec.h>

#include "lscommon.h"
#include "tlsrpc.h"
#include "tlsapi.h"
#include "tlsapip.h"
#include "secstore.h"
#include "lscsp.h"
#include "license.h"

extern "C" DWORD WINAPI 
TLSConnect( 
    handle_t binding,
    TLS_HANDLE *pphContext
);

extern "C" DWORD WINAPI 
TLSDisconnect( 
    TLS_HANDLE* pphContext
);

extern "C" BOOL
IsSystemService();

#include <lmcons.h>         // Netxxx API includes
#include <lmserver.h>
#include <lmerr.h>
#include <lmapibuf.h>

#define DISCOVERY_INTERVAL (60 * 60 * 1000)

static HANDLE g_hCachingThreadExit = NULL;
static HANDLE g_hImmediateDiscovery = NULL;
static HANDLE g_hDiscoverySoon = NULL;

static BOOL g_fOffSiteLicenseServer = FALSE;

static PSEC_WINNT_AUTH_IDENTITY g_pRpcIdentity = NULL;

#define REG_DOMAIN_SERVER_MULTI L"DomainLicenseServerMulti"

#define TERMINAL_SERVICE_PARAM_DISCOVERY  "SYSTEM\\CurrentControlSet\\Services\\TermService\\Parameters\\LicenseServers"

// 2 second timeout
#define SERVER_NP_TIMEOUT (2 * 1000)

#define INSTALL_CERT_DELAY (5 * 1000)

BOOL g_fInDomain = -1;

LONG lLibUsage = 0;

typedef struct {
    TLS_HANDLE *hBinding;
    DWORD dwTimeout;            // In milliseconds - INFINITE for none
    LARGE_INTEGER timeInitial;  // As returned by QueryPerformanceCounter
} LS_ENUM_PARAM, *PLS_ENUM_PARAM;

void * MIDL_user_allocate(size_t size)
{
    return(HeapAlloc(GetProcessHeap(), 0, size));
}

void MIDL_user_free( void *pointer)
{
    HeapFree(GetProcessHeap(), 0, pointer);
}

#ifdef PRIVATEDEBUG
//
//  FUNCTIONS: StartTime()
//             EndTime()
//
//  USAGE:
//      StartTime();
//        // Do some work.
//      mseconds = EndTime();
//
//  RETURN VALUE:
//      Milliseconds between StartTime() and EndTime() calls.

LARGE_INTEGER TimeT;

void StartTimeT(void)
{
    QueryPerformanceCounter(&TimeT);
}

ULONG EndTimeT()
{
    LARGE_INTEGER liDiff;
    LARGE_INTEGER liFreq;

    QueryPerformanceCounter(&liDiff);

    liDiff.QuadPart -= TimeT.QuadPart;
    liDiff.QuadPart *= 1000; // Adjust to milliseconds, shouldn't overflow...

    (void)QueryPerformanceFrequency(&liFreq);

    return ((ULONG)(liDiff.QuadPart / liFreq.QuadPart));
}
#endif


//+------------------------------------------------------------------------
// Function:   ConnectToLsServer()
//
// Description:
//
//      Binding to sepecific hydra license server
//
// Arguments:
//
//      szLsServer - Hydra License Server name
//
// Return Value:
//
//      RPC binding handle or NULL if error, use GetLastError() to retrieve
//      error.
//-------------------------------------------------------------------------
static TLS_HANDLE WINAPI
ConnectLsServer( 
        LPTSTR szLsServer, 
        LPTSTR szProtocol, 
        LPTSTR szEndPoint, 
        DWORD dwAuthLevel )
{
    LPTSTR           szBindingString;
    RPC_BINDING_HANDLE hBinding=NULL;
    RPC_STATUS       status;
    TLS_HANDLE       pContext=NULL;
    BOOL             fSuccess;
    HKEY             hKey = NULL;
    DWORD            dwType;
    DWORD            cbData;
    DWORD            dwErr;
    DWORD            dwNumRetries = 1;    // default to one retry
    LPWSTR           pszServerPrincipalName = NULL;

#ifdef PRIVATEDEBUG
    if (NULL != szLsServer)
        wprintf(L"server=%s\n",szLsServer);
#endif

    //
    // If this isn't local
    //
    if ((NULL != szLsServer) && (NULL != szEndPoint))
    {
        TCHAR szPipeName[MAX_PATH+1];

        if (lstrlen(szLsServer) > ((sizeof(szPipeName) / sizeof(TCHAR)) - 26))
        {
#ifdef PRIVATEDEBUG
            wprintf(L"Server name too long\n");
#endif
            return NULL;
        }

        //
        // First check if license server named pipe exists
        //
        wsprintf(szPipeName,TEXT("\\\\%s\\pipe\\%s"),szLsServer,TEXT(SZSERVICENAME));

#ifdef PRIVATEDEBUG
        StartTimeT();
#endif

        fSuccess = WaitNamedPipe(szPipeName,SERVER_NP_TIMEOUT);

#ifdef PRIVATEDEBUG
        ULONG ulTime = EndTimeT();

        wprintf(L"WaitNamedPipe time == %lu\n",ulTime);
#endif

        if (!fSuccess)
        {
#ifdef PRIVATEDEBUG
            wprintf(L"WaitNamedPipe (%s) failed 0x%x\n",szPipeName,GetLastError());
#endif
            return NULL;
        }
    }
#ifdef PRIVATEDEBUG
    else
        wprintf(L"Not trying WaitNamedPipe\n");
#endif


    dwErr = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                         TEXT(LSERVER_DISCOVERY_PARAMETER_KEY),
                         0,
                         KEY_READ,
                         &hKey);

    if (dwErr == ERROR_SUCCESS)
    {
        cbData = sizeof(dwNumRetries);
        dwErr = RegQueryValueEx(hKey,
                            L"NumRetries",
                            NULL,
                            &dwType,
                            (PBYTE)&dwNumRetries,
                            &cbData);

        RegCloseKey(hKey);

    }

    status = RpcStringBindingCompose(0,
                                     szProtocol,
                                     szLsServer,
                                     szEndPoint,
                                     0,
                                     &szBindingString);

    if(status!=RPC_S_OK)
    {
#ifdef PRIVATEDEBUG
        wprintf(L"RpcStringBindingCompose failed 0x%x\n",status);
#endif
        return NULL;
    }

    status=RpcBindingFromStringBinding( szBindingString, &hBinding);
    RpcStringFree( &szBindingString );
    if(status != RPC_S_OK)
    {
#ifdef PRIVATEDEBUG
        wprintf(L"RpcBindingFromStringBinding failed 0x%x\n",status);
#endif
        return NULL;
    }

    status = RpcMgmtSetComTimeout(hBinding,RPC_C_BINDING_MIN_TIMEOUT);
    if (status != RPC_S_OK)
    {
#ifdef PRIVATEDEBUG
        wprintf(L"RpcMgmtSetComTimeout failed 0x%x\n",status);
#endif
        return NULL;
    }
    
    BOOL fRetry = TRUE;

    //
    // Find the principle name
    //
    status = RpcMgmtInqServerPrincName(hBinding,
                                        RPC_C_AUTHN_GSS_NEGOTIATE,
                                        &pszServerPrincipalName);

    if(status == RPC_S_OK)
    {
    
        status=RpcBindingSetAuthInfo(hBinding,
                                     pszServerPrincipalName,
                                     dwAuthLevel,
                                     RPC_C_AUTHN_GSS_NEGOTIATE,
                                     g_pRpcIdentity,
                                     0);

        RpcStringFree(&pszServerPrincipalName);
    }
    else
        goto Label;
        
    if(status == RPC_S_OK)
    {
retry:

        // Obtain context handle from server
        status = TLSConnect( hBinding, &pContext );

        if(status != ERROR_SUCCESS)
        {
            pContext = NULL;

            if( status == RPC_S_UNKNOWN_AUTHN_SERVICE || status == ERROR_ACCESS_DENIED && fRetry) 
            {
Label:
                fRetry = FALSE;
               //Try again with no security set
               status = RpcBindingSetAuthInfo(hBinding,
                                         0,
                                         dwAuthLevel,
                                         RPC_C_AUTHN_WINNT,
                                         g_pRpcIdentity,
                                         0);
               if(status == RPC_S_OK)
               {
                   // Obtain context handle from server
                   status = TLSConnect( hBinding, &pContext );
               }

            }


            if((status == RPC_S_CALL_FAILED)  || (status == RPC_S_CALL_FAILED_DNE))
            {
                //
                // Workaround for an RPC problem where the first RPC after
                // the LS starts, fails
                //

                if (dwNumRetries > 0)
                {
                    dwNumRetries--;
                    
                    goto retry;
                }
            }
        }
    }    

    //
    // Memory leak
    //
    if(hBinding != NULL)
    {
        RpcBindingFree(&hBinding);
    }

    SetLastError((status == RPC_S_OK) ? ERROR_SUCCESS : status);
    return pContext;
}

//+------------------------------------------------------------------------
// Function:   BindAnyServer()
//
// Description:
//
//          Call back routine for TLSConnectToAnyLsServer()
//
// Arguments:
//
//          See EnumerateTlsServer()
//
// Return Value:
//
//          Always TRUE to terminate server enumeration
//-------------------------------------------------------------------------
static BOOL 
BindAnyServer(
    TLS_HANDLE hRpcBinding, 
    LPCTSTR pszServerName,
    HANDLE dwUserData
    )
/*++

++*/
{
    
    PLS_ENUM_PARAM pParam = (PLS_ENUM_PARAM) dwUserData;
    TLS_HANDLE* hBinding = pParam->hBinding; 
    RPC_STATUS rpcStatus;
    HKEY hKey = NULL;
    DWORD dwBuffer = 0;
    DWORD cbBuffer = sizeof (DWORD);
    DWORD dwErrCode = 0;


    // Skip Windows 2000 License servers
        
    
    if (hRpcBinding != NULL)
    {        
        DWORD dwSupportFlags = 0;

        dwErrCode = TLSGetSupportFlags(
                hRpcBinding,
                &dwSupportFlags
        );

	    if ((dwErrCode == RPC_S_OK) && !(dwSupportFlags & SUPPORT_WHISTLER_CAL))
        {                    
            return FALSE;
        }            	                

        // If the call fails => Windows 2000 LS
        else if(dwErrCode != RPC_S_OK)
        {
            return FALSE;
        }

        *hBinding=hRpcBinding;

        return TRUE;
    }                         

    if (pParam->dwTimeout != INFINITE)
    {
        LARGE_INTEGER timeDiff;
        LARGE_INTEGER timeFreq;

        *hBinding=hRpcBinding;

        QueryPerformanceCounter(&timeDiff);

        timeDiff.QuadPart -= pParam->timeInitial.QuadPart;
        timeDiff.QuadPart *= 1000; // Adjust to milliseconds, shouldn't overflow

        (void)QueryPerformanceFrequency(&timeFreq);

        if (((ULONG)(timeDiff.QuadPart / timeFreq.QuadPart)) > pParam->dwTimeout)
        {
#ifdef PRIVATEDEBUG
            wprintf(L"BindAnyServer timed out\n");
#endif
            return TRUE;
        }
    }

    return FALSE;
}    

void
RandomizeArray(LPWSTR *rgwszServers, DWORD cServers)
{
    DWORD i;
    LPWSTR wszServerTmp;
    int val;

    if (cServers < 2)
        return;

    srand(GetTickCount());

    for (i = 0; i < cServers; i++)
    {
        val = rand() % (cServers - i);

        if (val == 0)
            continue;

        //
        // Swap # i with # (val+i)
        //
        wszServerTmp = rgwszServers[i];
        rgwszServers[i] = rgwszServers[val+i];
        rgwszServers[val+i] = wszServerTmp;
    }
}

HRESULT
GetLicenseServersFromReg(LPWSTR wszRegKey, LPWSTR *ppwszServerNames,DWORD *pcServers, LPWSTR **prgwszServers)
{
    HRESULT          hr = S_OK;
    HKEY             hKey = NULL;
    DWORD            dwType;
    DWORD            cbData = 0;
    LPWSTR           szServers=NULL, pchServer;
    DWORD            dwErr;
    DWORD            i,val;
    DWORD            iLocalComputer = (DWORD)(-1);
    WCHAR            szLocalComputerName[MAXCOMPUTERNAMELENGTH+1] = L"";
    DWORD            cbLocalComputerName=MAXCOMPUTERNAMELENGTH+1;

    *ppwszServerNames = NULL;
    *prgwszServers = NULL;

    dwErr = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                         TEXT(LSERVER_DISCOVERY_PARAMETER_KEY),
                         0,
                         KEY_READ,
                         &hKey);
    if (dwErr != ERROR_SUCCESS)
    {
        hr = HRESULT_FROM_WIN32(dwErr);
        goto CleanErr;
    }

    dwErr = RegQueryValueEx(hKey,
                            wszRegKey,
                            NULL,
                            &dwType,
                            NULL,
                            &cbData);
    if (dwErr != ERROR_SUCCESS)
    {
        hr = HRESULT_FROM_WIN32(dwErr);
        goto CleanErr;
    }

    if ((dwType != REG_MULTI_SZ) || (cbData < (2 * sizeof(WCHAR))))
    {
        hr = E_FAIL;
        goto CleanErr;
    }

    szServers = (LPWSTR) LocalAlloc(LPTR,cbData);
    if (NULL == szServers)
    {
        hr = E_OUTOFMEMORY;
        goto CleanErr;
    }

    dwErr = RegQueryValueEx(hKey,
                            wszRegKey,
                            NULL,
                            &dwType,
                            (PBYTE)szServers,
                            &cbData);
    if (dwErr != ERROR_SUCCESS)
    {
        hr = HRESULT_FROM_WIN32(dwErr);
        goto CleanErr;
    }

    for (i = 0, pchServer = szServers; (pchServer != NULL) && (*pchServer != L'\0'); pchServer = wcschr(pchServer,L'\0')+1, i++)
        ;

    if (i == 0)
    {
        hr = E_FAIL;
        goto CleanErr;
    }

    *pcServers = i;

    *prgwszServers = (LPWSTR *)LocalAlloc(LPTR,sizeof(LPWSTR) * (*pcServers));
    if (*prgwszServers == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto CleanErr;
    }

    // Don't treat error from this function as fatal
    GetComputerName(szLocalComputerName, &cbLocalComputerName);

    for (i = 0, pchServer = szServers; (i < (*pcServers)) && (pchServer != NULL) && (*pchServer != L'\0'); pchServer = wcschr(pchServer,L'\0')+1, i++) {

        (*prgwszServers)[i] = pchServer;

        if ((iLocalComputer == (DWORD)(-1)) && (wcscmp(pchServer,szLocalComputerName) == 0))
        {
            iLocalComputer = i;
        }
    }

    //
    // Put local computer at head of list
    //
    if (iLocalComputer != (DWORD)(-1))
    {
        if (iLocalComputer != 0)
        {
            //
            // Swap # iLocalComputer with # 0
            //
            pchServer = (*prgwszServers)[iLocalComputer];
            (*prgwszServers)[iLocalComputer] = (*prgwszServers)[0];
            (*prgwszServers)[0] = pchServer;
        }

        RandomizeArray((*prgwszServers)+1,(*pcServers) - 1);
    }
    else
    {
        RandomizeArray((*prgwszServers),*pcServers);
    }

    *ppwszServerNames = szServers;

CleanErr:
    if (FAILED(hr))
    {
        if (NULL != szServers)
        {
            LocalFree(szServers);
        }

        if (NULL != *prgwszServers)
        {
            LocalFree(*prgwszServers);
        }
    }

    if (hKey != NULL)
    {
        RegCloseKey(hKey);
    }

    return hr;
}

HRESULT
WriteLicenseServersToReg(LPWSTR wszRegKey, LPWSTR pwszServerNames,DWORD cchServers)
{
    HRESULT          hr = S_OK;
    HKEY             hKey = NULL;
    DWORD            dwType = REG_MULTI_SZ;
    DWORD            dwErr;
    DWORD            dwDisp;

    //
    // Delete the value
    //

    dwErr = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                         TEXT(LSERVER_DISCOVERY_PARAMETER_KEY),
                         0,
                         KEY_WRITE,
                         &hKey);
    if (dwErr == ERROR_SUCCESS)
    {
        RegDeleteValue(hKey,wszRegKey);       
    }

    if ((pwszServerNames == NULL) || (cchServers < 2))
    {
        hr = S_OK;
        goto CleanErr;
    }

    if(hKey != NULL)
    {
        RegCloseKey(hKey);
        hKey = NULL;
    }

    dwErr = RegCreateKeyEx(HKEY_LOCAL_MACHINE,
                           TEXT(LSERVER_DISCOVERY_PARAMETER_KEY),
                           0,
                           TEXT(""),
                           REG_OPTION_NON_VOLATILE,
                           KEY_WRITE,
                           NULL,
                           &hKey,
                           &dwDisp);
    if (dwErr != ERROR_SUCCESS)
    {
        hr = HRESULT_FROM_WIN32(dwErr);
        goto CleanErr;
    }

    dwErr = RegSetValueEx(hKey,
                          wszRegKey,
                          0,
                          dwType,
                          (CONST BYTE *)pwszServerNames,
                          cchServers*sizeof(WCHAR));
    if (dwErr != ERROR_SUCCESS)
    {
        hr = HRESULT_FROM_WIN32(dwErr);
        goto CleanErr;
    }


CleanErr:
    if (hKey != NULL)
    {
        RegCloseKey(hKey);
    }

    return hr;
}

//
// Free pszDomain using NetApiBufferFree
//

DWORD WINAPI
TLSInDomain(BOOL *pfInDomain, LPWSTR *pszDomain)
{
    NET_API_STATUS dwErr;
    DSROLE_PRIMARY_DOMAIN_INFO_BASIC *pDomainInfo = NULL;
    PDOMAIN_CONTROLLER_INFO pdcInfo = NULL;

    if (pfInDomain == NULL)
    {
        return ERROR_INVALID_PARAMETER;
    }

    *pfInDomain = FALSE;

    //
    // Check if we're in a workgroup
    //
    dwErr = DsRoleGetPrimaryDomainInformation(NULL,
                                              DsRolePrimaryDomainInfoBasic,
                                              (PBYTE *) &pDomainInfo);

    if ((dwErr != NO_ERROR) || (pDomainInfo == NULL))
    {
        return dwErr;
    }

    switch (pDomainInfo->MachineRole)
    {
        case DsRole_RoleStandaloneWorkstation:
        case DsRole_RoleStandaloneServer:
            DsRoleFreeMemory(pDomainInfo);

            if (NULL != pszDomain)
            {
                NETSETUP_JOIN_STATUS BufferType;

                dwErr = NetGetJoinInformation(NULL,pszDomain,&BufferType);
            }

            return dwErr;
            break;      // just in case
    }

    DsRoleFreeMemory(pDomainInfo);


    dwErr = DsGetDcName(NULL,   // Computer Name
                        NULL,   // Domain Name
                        NULL,   // Domain GUID
                        NULL,   // Site Name
                        DS_DIRECTORY_SERVICE_PREFERRED,
                        &pdcInfo);

    if ((dwErr != NO_ERROR) || (pdcInfo == NULL))
    {
        if (dwErr == ERROR_NO_SUCH_DOMAIN)
        {
            *pfInDomain = FALSE;
            return NO_ERROR;
        }
        else
        {
            if (pdcInfo == NULL)
                dwErr = ERROR_INTERNAL_ERROR;
            return dwErr;
        }
    }

    if (pdcInfo->Flags & DS_DS_FLAG)
    {
        *pfInDomain = TRUE;

    }

    if (pszDomain != NULL)
    {
        dwErr = NetApiBufferAllocate((wcslen(pdcInfo->DomainName)+1) * sizeof(WCHAR),
                                     (LPVOID *)pszDomain);

        if ((NERR_Success == dwErr) && (NULL != *pszDomain))
        {
            wcscpy(*pszDomain,pdcInfo->DomainName);
        }
    }

    if (pdcInfo != NULL)
        NetApiBufferFree(pdcInfo);

    return dwErr;
}

/*++

Function:

    LicenseServerCachingThread

Description:

    This is the thread that does the license server caching.

Arguments:

    lpParam - contains the exit event handle

Returns:

    Always 1

--*/

DWORD WINAPI
LicenseServerCachingThread(
    LPVOID lpParam )
{
    DWORD
        dwWaitStatus;
    HANDLE
        hExit = (HANDLE)lpParam;
    DWORD
        dwDiscoveryInterval = DISCOVERY_INTERVAL;
    HANDLE
        rgWaitHandles[] = {hExit,g_hImmediateDiscovery,g_hDiscoverySoon};
    BOOL
        bFoundServer;
    BOOL
        bSkipOne = FALSE;
    HANDLE
        hEvent;

    //
    // Yield our time slice to other threads now, so that the terminal server
    // service can start up quickly.  Refresh the license server cache when we
    // resume our time slice.
    //

    Sleep( 0 );

    while (1)
    {
        if (!bSkipOne)
        {
            bFoundServer = TLSRefreshLicenseServerCache(INFINITE);

            if ((!g_fOffSiteLicenseServer) && bFoundServer)
            {
                dwDiscoveryInterval = INFINITE;
            }
        }
        else
        {
            bSkipOne = FALSE;
        }

        dwWaitStatus = WaitForMultipleObjects(
                            sizeof(rgWaitHandles) / sizeof(HANDLE),
                            rgWaitHandles,
                            FALSE, // wait for any one event
                            dwDiscoveryInterval);

        if (WAIT_OBJECT_0 == dwWaitStatus)
        {
            // hExit was signalled
            goto done;
        }

        if ((WAIT_OBJECT_0+1) == dwWaitStatus)
        {
            // g_hImmediateDiscovery was signalled
            // reduce dwDiscoveryInterval

            dwDiscoveryInterval = DISCOVERY_INTERVAL;
        }

        if ((WAIT_OBJECT_0+2) == dwWaitStatus)
        {
            // g_hDiscoverySoon was signalled
            // reduce dwDiscoveryInterval, but wait one round

            dwDiscoveryInterval = DISCOVERY_INTERVAL;
            bSkipOne = TRUE;
        }

        // we timed out, or hImmediateDiscovery was signalled.  Re-start
        // discovery
    }

done:
    hEvent = g_hCachingThreadExit;
    g_hCachingThreadExit = NULL;

    CloseHandle(hEvent);

    hEvent = g_hImmediateDiscovery;
    g_hImmediateDiscovery = NULL;

    CloseHandle(hEvent);

    hEvent = g_hDiscoverySoon;
    g_hDiscoverySoon = NULL;

    CloseHandle(hEvent);

    return 1;
}

extern "C" void
TLSShutdown()
{
    if (0 < InterlockedDecrement(&lLibUsage))
    {
        //
        // Someone else is using it
        //
        return;
    }

    TLSStopDiscovery();

    if (NULL != g_pRpcIdentity)
    {
        PSEC_WINNT_AUTH_IDENTITY pRpcIdentity = g_pRpcIdentity;

        g_pRpcIdentity = NULL;

        if (NULL != pRpcIdentity->User)
        {
            LocalFree(pRpcIdentity->User);
        }

        LocalFree(pRpcIdentity);
    }

    //
    // Cleanup random number generator
    //
    TSRNG_Shutdown();

    LsCsp_Exit();
}

extern "C" DWORD WINAPI
TLSInit()
{
    LICENSE_STATUS status;
    BOOL fInDomain = FALSE;

    if (0 != InterlockedExchangeAdd(&lLibUsage,1))
    {
        //
        // Already been initialized
        //
        return ERROR_SUCCESS;
    }

    status = LsCsp_Initialize();
    if (LICENSE_STATUS_OK != status)
    {
        InterlockedDecrement(&lLibUsage);
        switch (status)
        {        
            case LICENSE_STATUS_OUT_OF_MEMORY:
                return ERROR_NOT_ENOUGH_MEMORY;

            case LICENSE_STATUS_NO_CERTIFICATE:
                return SCARD_E_CERTIFICATE_UNAVAILABLE;

            case LICENSE_STATUS_INVALID_CERTIFICATE:
                return CERT_E_MALFORMED;

            default:
                return E_FAIL;
        }
    }

    if ((NO_ERROR == TLSInDomain(&fInDomain, NULL))
        && (fInDomain)
        && (IsSystemService()))
    {

        // 
        // We're running as SYSTEM
        // Create an RPC identity for use as an RPC client
        //

        g_pRpcIdentity = (PSEC_WINNT_AUTH_IDENTITY) LocalAlloc(LPTR, sizeof(SEC_WINNT_AUTH_IDENTITY));

        if (NULL != g_pRpcIdentity)
        {
            g_pRpcIdentity->Flags = SEC_WINNT_AUTH_IDENTITY_UNICODE;

            g_pRpcIdentity->UserLength = MAX_COMPUTERNAME_LENGTH + 2;

            g_pRpcIdentity->User = (WCHAR *) LocalAlloc(LPTR, g_pRpcIdentity->UserLength * sizeof(WCHAR));

            if (NULL != g_pRpcIdentity->User)
            {
                if (GetComputerNameEx(ComputerNamePhysicalNetBIOS,g_pRpcIdentity->User,&(g_pRpcIdentity->UserLength)))
                {
                    if (g_pRpcIdentity->UserLength < MAX_COMPUTERNAME_LENGTH + 1)
                    {
                        g_pRpcIdentity->User[g_pRpcIdentity->UserLength++] = L'$';
                        g_pRpcIdentity->User[g_pRpcIdentity->UserLength] = 0;

                    }
                    else
                    {
                        LocalFree(g_pRpcIdentity->User);

                        LocalFree(g_pRpcIdentity);
                        g_pRpcIdentity = NULL;

                        InterlockedDecrement(&lLibUsage);

                        return E_FAIL;
                    }
                }
                else
                {
                    LocalFree(g_pRpcIdentity->User);

                    LocalFree(g_pRpcIdentity);
                    g_pRpcIdentity = NULL;

                    InterlockedDecrement(&lLibUsage);

                    return GetLastError();
                }
            }
            else
            {
                LocalFree(g_pRpcIdentity);
                g_pRpcIdentity = NULL;

                InterlockedDecrement(&lLibUsage);

                return ERROR_NOT_ENOUGH_MEMORY;
            }
        }
        else
        {
            InterlockedDecrement(&lLibUsage);
            return ERROR_NOT_ENOUGH_MEMORY;
        }
    }

    //
    // Init random number generator
    //
    TSRNG_Initialize();

    return ERROR_SUCCESS;
}

extern "C" DWORD WINAPI
TLSStartDiscovery()
{
    HANDLE hCachingThread = NULL;
    HANDLE hEvent;

    if (NULL != g_hCachingThreadExit)
    {
        // already started
        return ERROR_SUCCESS;
    }

    //
    // Create the event to signal thread exit
    //
        
    g_hCachingThreadExit = CreateEvent( NULL, FALSE, FALSE, NULL );
    
    if( NULL == g_hCachingThreadExit )
    {
        return GetLastError();
    }

    g_hImmediateDiscovery = CreateEvent(NULL,FALSE,FALSE,NULL);

    if (NULL == g_hImmediateDiscovery)
    {
        hEvent = g_hCachingThreadExit; 
        g_hCachingThreadExit = NULL;

        CloseHandle(hEvent);

        return GetLastError();
    }


    g_hDiscoverySoon = CreateEvent(NULL,FALSE,FALSE,NULL);

    if (NULL == g_hDiscoverySoon)
    {
        hEvent = g_hCachingThreadExit; 
        g_hCachingThreadExit = NULL;

        CloseHandle(hEvent);

        hEvent = g_hImmediateDiscovery; 
        g_hImmediateDiscovery = NULL;

        CloseHandle(hEvent);

        return GetLastError();
    }

    //
    // Create the caching thread
    //
        
    hCachingThread = CreateThread(
                                    NULL,
                                    0,
                                    LicenseServerCachingThread,
                                    ( LPVOID )g_hCachingThreadExit,
                                    0,
                                    NULL );

    if (hCachingThread == NULL)
    {
        hEvent = g_hCachingThreadExit; 
        g_hCachingThreadExit = NULL;

        CloseHandle(hEvent);

        hEvent = g_hImmediateDiscovery; 
        g_hImmediateDiscovery = NULL;

        CloseHandle(hEvent);

        hEvent = g_hDiscoverySoon; 
        g_hDiscoverySoon = NULL;

        CloseHandle(hEvent);

        return GetLastError();
    }

    CloseHandle(hCachingThread);

    return ERROR_SUCCESS;
}

extern "C" DWORD WINAPI
TLSStopDiscovery()
{
    //
    // Signal the thread to exit
    //

    if (NULL != g_hCachingThreadExit)
    {
        SetEvent( g_hCachingThreadExit );
    }

    return ERROR_SUCCESS;
}

//
// Number of DCs to allocate space for at a time
//
#define DC_LIST_CHUNK   10

//+------------------------------------------------------------------------
// Function:   
//
//      EnumerateLsServer()
//
// Description:
//
//      Routine to enumerate all hydra license server in network
//
// Arguments:
//
//      szScope - Scope limit, NULL if doen't care.
//      dwPlatformType - verify if license server have licenses for this platform, 
//                       LSKEYPACKPLATFORMTYPE_UNKNOWN if doesn't care.
//      fCallBack - call back routine when EnumerateServer() founds any server,
//      dwUserData - data to be pass to call back routine
//    
// Return Value:
//
//      RPC_S_OK or any RPC specific error code.
//
// NOTE: 
//
//      Enumeration terminate when either there is no more server or call back
//      routine return TRUE.
//
//-------------------------------------------------------------------------
DWORD WINAPI
EnumerateTlsServerInDomain(  
    IN LPCTSTR szDomain,                           
    IN TLSENUMERATECALLBACK fCallBack, 
    IN HANDLE dwUserData,
    IN DWORD dwTimeOut,
    IN BOOL fRegOnly,
    IN OUT BOOL *pfOffSite
    )
/*++

++*/
{   
    DWORD entriesread = 0;
    BOOL bCancel=FALSE;
    DWORD dwErrCode;
    LPWSTR pwszServerTmp = NULL;
    LPWSTR pwszServer = NULL;
    HRESULT hr;
    LPWSTR pwszServers = NULL;
    LPWSTR pwszServersTmp = NULL;
    DWORD cchServers = 0;
    DWORD cchServer;
    LPWSTR *rgwszServers = NULL;
    LPWSTR *rgwszServersTmp;
    LPWSTR pwszServerNames = NULL;
    DWORD dwErr = ERROR_SUCCESS, i;
    HANDLE hDcOpen = NULL;
    LPWSTR szSiteName = NULL;
    BOOL fOffSiteIn;
    BOOL fFoundOne = FALSE;
    BOOL fFoundOneOffSite = FALSE;
    DWORD cChunks = 0;
    DWORD cServersOnSite = 0;   
    

    if (fRegOnly)
    {
        //
        // check for a license server in the registry
        //
        hr = GetLicenseServersFromReg(REG_DOMAIN_SERVER_MULTI,&pwszServerNames,&entriesread,&rgwszServers);
        if (FAILED(hr))
        {
            dwErr = hr;
            goto Cleanup;
        }
    } 
    else
    {
        if (NULL == pfOffSite)
        {
            return ERROR_INVALID_PARAMETER;
        }

        fOffSiteIn = *pfOffSite;

        *pfOffSite = FALSE;

        dwErr = DsGetSiteName(NULL,&szSiteName);
        if(dwErr != ERROR_SUCCESS)
        {
#ifdef PRIVATEDEBUG
            wprintf(L"DsGetSiteName failed %x\n",dwErr);
#endif
            goto Cleanup;
        }

        dwErr = DsGetDcOpenW(szDomain,
                             fOffSiteIn ? DS_NOTIFY_AFTER_SITE_RECORDS: DS_ONLY_DO_SITE_NAME,
                             szSiteName,
                             NULL,       // DomainGuid
                             NULL,       // DnsForestName
                             0,          // Flags
                             &hDcOpen
                             );

        if(dwErr != ERROR_SUCCESS)
        {
#ifdef PRIVATEDEBUG
            wprintf(L"DsGetDcOpen failed %x\n",dwErr);
#endif
            goto Cleanup;
        }

        rgwszServers = (LPWSTR *) LocalAlloc(LPTR,
                                             DC_LIST_CHUNK * sizeof(LPWSTR));
        if (NULL == rgwszServers)
        {
#ifdef PRIVATEDEBUG
            wprintf(L"Out of memory\n");
#endif
            dwErr = E_OUTOFMEMORY;
            goto Cleanup;
        }

        cChunks = 1;

        //
        // Read the whole DC list
        //

        do
        {
            if (entriesread >= (cChunks * DC_LIST_CHUNK))
            {                
                cChunks++;

                rgwszServersTmp = (LPWSTR *)
                    LocalReAlloc(rgwszServers,
                                 DC_LIST_CHUNK * sizeof(LPWSTR) * cChunks,
                                 LHND);

                if (NULL == rgwszServersTmp)
                {
                    dwErr = E_OUTOFMEMORY;
                    goto Cleanup;
                }
                else
                {
                    rgwszServers = rgwszServersTmp;
                }
            }

            dwErr = DsGetDcNextW(hDcOpen,
                                 NULL,
                                 NULL,
                                 rgwszServers+entriesread);         

            
            if (ERROR_FILEMARK_DETECTED == dwErr)
            {                
                                
                // Now going off-site; use NULL ptr marker

                rgwszServers[entriesread] = NULL;

                cServersOnSite = entriesread;

                dwErr = ERROR_SUCCESS;

                fFoundOneOffSite = TRUE;
            }                  

            entriesread++;

        } while (ERROR_SUCCESS == dwErr);

        // don't count the final error
        entriesread--;

        if (!fFoundOneOffSite)
            cServersOnSite = entriesread;

        // Now randomize the two portions of the array

        RandomizeArray(rgwszServers,cServersOnSite);

        if (fFoundOneOffSite)
        {
            RandomizeArray(rgwszServers+cServersOnSite+1,
                           entriesread - cServersOnSite - 1);
        }

        // Now allocate memory for registry entry

        pwszServers = (LPWSTR) LocalAlloc(LPTR,2*sizeof(WCHAR));
        if (NULL == pwszServers)
        {
#ifdef PRIVATEDEBUG
            wprintf(L"Out of memory\n");
#endif
            dwErr = E_OUTOFMEMORY;
            goto Cleanup;
        }

        cchServers = 2;
        pwszServers[0] = pwszServers[1] = L'\0';
    }

    for(i=0; bCancel == FALSE; i++)
    {
        PCONTEXT_HANDLE pContext=NULL;
        RPC_STATUS rpcStatus;

        if (!fRegOnly)
        {
            if (fFoundOneOffSite && i == cServersOnSite)
            {
                if (fFoundOne)
                    break;

                // Now going off-site

                i++;
                *pfOffSite = TRUE;
            }
        }

        if (i >= entriesread)
            break;

        pwszServerTmp = rgwszServers[i];

        bCancel=fCallBack(pContext, pwszServerTmp, dwUserData);
        if(bCancel == TRUE)
            continue;

        if(!(pContext = TLSConnectToLsServer(pwszServerTmp)))
        {
            //
            // could be access denied.
            //
#ifdef PRIVATEDEBUG
    wprintf(L"Can't connect to %s\n",pwszServerTmp);
#endif

            continue;
        }        

#ifdef PRIVATEDEBUG
    wprintf(L"!!!Connected to %s\n",pwszServerTmp);
#endif
        do {
            //
            // Skip enterprise server
            //
            DWORD dwVersion;
            rpcStatus = TLSGetVersion( pContext, &dwVersion );
            if(rpcStatus != RPC_S_OK)
            {
                break;
            }

#if ENFORCE_LICENSING

            //
            // W2K Beta 3 to RC1 upgrade, don't connect to any non-enforce
            // server 5.2 or older
            //
            if(IS_ENFORCE_LSSERVER(dwVersion) == FALSE)
            {
                if( GET_LSSERVER_MAJOR_VERSION(dwVersion) <= 5 &&
                    GET_LSSERVER_MINOR_VERSION(dwVersion) <= 2 )
                {
                    continue;
                }
            }


            //
            // Prevent beta <-> RTM server talking to each other
            //

            //
            // TLSIsBetaNTServer() returns TRUE if eval NT
            // IS_LSSERVER_RTM() returns TRUE if LS is an RTM.
            //

            if( TLSIsBetaNTServer() == IS_LSSERVER_RTM(dwVersion) )
            {
                continue;
            }
#endif

            if(dwVersion & TLS_VERSION_ENTERPRISE_BIT)
            {
                continue;
            }           

            bCancel=fCallBack(pContext, pwszServerTmp, dwUserData);    

            if (!fRegOnly)
            {
                // 
                // Add to list of servers
                //
                cchServer = wcslen(pwszServerTmp);
                
                pwszServersTmp = (LPWSTR) LocalReAlloc(pwszServers,(cchServers+cchServer+1)*sizeof(TCHAR),LHND);
                if (NULL == pwszServersTmp)
                {
                    break;
                }
                
                pwszServers = pwszServersTmp;
                
                if (cchServers == 2)
                {
                    wcscpy(pwszServers,pwszServerTmp);
                    
                    cchServers += cchServer;
                } else
                {
                    wcscpy(pwszServers+cchServers-1,pwszServerTmp);
                    
                    cchServers += cchServer + 1;
                    
                }
                pwszServers[cchServers-1] = L'\0';
            }

            fFoundOne = TRUE;

        } while (FALSE);

        if(bCancel == FALSE && pContext != NULL)
        {
            TLSDisconnect(&pContext);
        }

    } // for loop

    if (!fRegOnly)
    {
        WriteLicenseServersToReg(REG_DOMAIN_SERVER_MULTI,pwszServers,cchServers);
    }

Cleanup:
    if (NULL != hDcOpen)
        DsGetDcCloseW(hDcOpen);

    if (NULL != rgwszServers)
    {
        if (!fRegOnly)
        {
            for (i = 0; i < entriesread; i++)
            {
                if (NULL != rgwszServers[i])
                {
                    NetApiBufferFree(rgwszServers[i]);
                }
            }
        }
        LocalFree(rgwszServers);
    }

    if (szSiteName)
        NetApiBufferFree(szSiteName);

    if (pwszServerNames)
        LocalFree(pwszServerNames);

    if (pwszServers)
        LocalFree(pwszServers);

    if (pwszServer)
        LocalFree(pwszServer);

    return dwErr;
}

DWORD WINAPI
EnumerateTlsServerInWorkGroup(  
    IN TLSENUMERATECALLBACK pfCallBack, 
    IN HANDLE dwUserData,
    IN DWORD dwTimeOut,
    IN BOOL fRegOnly
    )
/*++


++*/
{   
    DWORD dwStatus=ERROR_SUCCESS;

    TCHAR szServerMailSlotName[MAX_PATH+1];
    TCHAR szLocalMailSlotName[MAX_PATH+1];

    HANDLE hClientSlot = INVALID_HANDLE_VALUE;
    HANDLE hServerSlot = INVALID_HANDLE_VALUE;

    TCHAR szDiscMsg[MAX_MAILSLOT_MSG_SIZE+1];
    TCHAR szComputerName[MAXCOMPUTERNAMELENGTH+1];
    TCHAR szRandomMailSlotName[MAXCOMPUTERNAMELENGTH+1];

    DWORD cbComputerName=MAXCOMPUTERNAMELENGTH+1;

    DWORD cbWritten=0;
    DWORD cbRead=0;    
    BOOL bCancel = FALSE;
    DWORD dwErrCode;
    HRESULT hr;
    LPWSTR pwszServers = NULL;
    LPWSTR pwszServersTmp = NULL;
    DWORD cchServers = 0;
    DWORD cchServer;
    LPWSTR *rgwszServers = NULL;
    LPWSTR pwszServerNames = NULL;
    DWORD cServers = 0;
    DWORD i = 0;
    LPWSTR pwszServerTmp = szComputerName;


    if (!fRegOnly)
    {
        if(!GetComputerName(szComputerName, &cbComputerName))
        {
            dwStatus = GetLastError();
            goto cleanup;
        }

        if (0 == (1 & GetSystemMetrics(SM_NETWORK)))
        {
            // No network; try local machine
#ifdef PRIVATEDEBUG
            wprintf(L"No network, trying local computer=%s\n",szComputerName);
#endif
            dwStatus = ERROR_SUCCESS;
            goto TryServer;
        }

        wsprintf(
                 szRandomMailSlotName,
                 _TEXT("%08x"),
                 GetCurrentThreadId()
                 );
            
        _stprintf(
                  szLocalMailSlotName, 
                  _TEXT("\\\\.\\mailslot\\%s"), 
                  szRandomMailSlotName
                  );

        // 
        // Create local mail slot for server's response
        //
        hClientSlot=CreateMailslot( 
                                   szLocalMailSlotName, 
                                   0,
                                   (dwTimeOut == MAILSLOT_WAIT_FOREVER) ? 5 * 1000: dwTimeOut,
                                   NULL
                                   );

        if(hClientSlot == INVALID_HANDLE_VALUE)
        {
            dwStatus = GetLastError();
            goto cleanup;
        }

        //
        // Open server's mail slot
        //
        _stprintf(
                  szServerMailSlotName, 
                  _TEXT("\\\\%s\\mailslot\\%s"), 
                  _TEXT("*"), 
                  _TEXT(SERVERMAILSLOTNAME)
                  );

        hServerSlot=CreateFile(
                               szServerMailSlotName,
                               GENERIC_WRITE,             // only need write
                               FILE_SHARE_READ,
                               NULL,
                               OPEN_EXISTING,
                               FILE_ATTRIBUTE_NORMAL,
                               NULL
                               );
        if(hServerSlot == INVALID_HANDLE_VALUE)
        {
            dwStatus = GetLastError();
            goto cleanup;
        }

        //
        // Formulate discovery message
        //
        _stprintf(
                  szDiscMsg, 
                  _TEXT("%s %c%s%c %c%s%c"), 
                  _TEXT(LSERVER_DISCOVERY), 
                  _TEXT(LSERVER_OPEN_BLK), 
                  szComputerName,
                  _TEXT(LSERVER_CLOSE_BLK),
                  _TEXT(LSERVER_OPEN_BLK), 
                  szRandomMailSlotName,
                  _TEXT(LSERVER_CLOSE_BLK)
                  );

        if (!WriteFile(hServerSlot, szDiscMsg, (_tcslen(szDiscMsg) + 1) * sizeof(TCHAR), &cbWritten, NULL) ||
            (cbWritten != (_tcslen(szDiscMsg) + 1 ) * sizeof(TCHAR)))
        {
            dwStatus = GetLastError();
            
            if (dwStatus == ERROR_NETWORK_UNREACHABLE)
            {
                // No network; try local machine
#ifdef PRIVATEDEBUG
                wprintf(L"No network, trying local computer=%s\n",szComputerName);
#endif
                dwStatus = ERROR_SUCCESS;
                goto TryServer;
            }
            else
            {
                goto cleanup;            
            }
        }

        // Allocate for registry entry

        pwszServers = (LPWSTR) LocalAlloc(LPTR,2*sizeof(WCHAR));
        if (NULL == pwszServers)
        {
#ifdef PRIVATEDEBUG
            wprintf(L"Out of memory\n");
#endif
            
            dwStatus = E_OUTOFMEMORY;
            goto cleanup;
        }
        
        cchServers = 2;
        pwszServers[0] = pwszServers[1] = L'\0';
    } else
    {
        //
        // check for a license server in the registry
        //

        hr = GetLicenseServersFromReg(REG_DOMAIN_SERVER_MULTI,&pwszServerNames,&cServers,&rgwszServers);
        if (FAILED(hr))
        {
            dwStatus = hr;
            goto cleanup;
        }
    }

    do {
        if(fRegOnly)
        {
            if (i >= cServers)
            {
                break;
            }

            pwszServerTmp = rgwszServers[i++];
        } else
        {
            memset(szComputerName, 0, sizeof(szComputerName));
            if(!ReadFile(hClientSlot, szComputerName, sizeof(szComputerName) - sizeof(TCHAR), &cbRead, NULL))
            {
                dwStatus=GetLastError();
                break;
            }

#ifdef PRIVATEDEBUG
            wprintf(L"Trying server=%s\n",szComputerName);
#endif

        }

TryServer:

        bCancel=pfCallBack(NULL, pwszServerTmp, dwUserData);
        if(bCancel == TRUE)
        {
            continue;
        }

        PCONTEXT_HANDLE pContext=NULL;
        RPC_STATUS rpcStatus;

        if(!(pContext = TLSConnectToLsServer(pwszServerTmp)))
        {
            //
            // could be access denied.
            //
            continue;
        }

        do {            
            //
            // Skip enterprise server
            //
            DWORD dwVersion;
            rpcStatus = TLSGetVersion( pContext, &dwVersion );
            if(rpcStatus != RPC_S_OK)
            {
                continue;
            }

#if ENFORCE_LICENSING

            //
            // W2K Beta 3 to RC1 upgrade, don't connect to any non-enforce
            // server 5.2 or older
            //
            if(IS_ENFORCE_LSSERVER(dwVersion) == FALSE)
            {
                if( GET_LSSERVER_MAJOR_VERSION(dwVersion) <= 5 &&
                    GET_LSSERVER_MINOR_VERSION(dwVersion) <= 2 )
                {
                    continue;
                }
            }
            
            //
            // No Beta <--> RTM server.
            //
            //
            // TLSIsBetaNTServer() returns TRUE if eval NT
            // IS_LSSERVER_RTM() returns TRUE if LS is an RTM.
            //
            if( TLSIsBetaNTServer() == IS_LSSERVER_RTM(dwVersion) )
            {
                continue;
            }

#endif

            if(dwVersion & TLS_VERSION_ENTERPRISE_BIT)
            {
                continue;
            }           
        
            bCancel=pfCallBack(pContext, pwszServerTmp, dwUserData);    
            
            if (!fRegOnly)
            {
                // 
                // Add to list of servers
                //
                cchServer = wcslen(pwszServerTmp);
                    
                pwszServersTmp = (LPWSTR) LocalReAlloc(pwszServers,(cchServers+cchServer+1)*sizeof(TCHAR),LHND);
                if (NULL == pwszServersTmp)
                {
                    continue;
                }
                
                pwszServers = pwszServersTmp;
                
                if (cchServers == 2)
                {
                    wcscpy(pwszServers,pwszServerTmp);
                
                    cchServers += cchServer;
                } else
                {
                    wcscpy(pwszServers+cchServers-1,pwszServerTmp);
                    
                    cchServers += cchServer + 1;
                
                }
                pwszServers[cchServers-1] = L'\0';
            }
        } while (FALSE);

        if(bCancel == FALSE && pContext != NULL)
        {
            TLSDisconnectFromServer(pContext);
        }

    } while(bCancel == FALSE);

    if (!fRegOnly)
    {
        WriteLicenseServersToReg(REG_DOMAIN_SERVER_MULTI,pwszServers,cchServers);
    }


cleanup:    

    if(hClientSlot != INVALID_HANDLE_VALUE)
    {
        CloseHandle(hClientSlot);
    }

    if(hServerSlot != INVALID_HANDLE_VALUE)
    {
        CloseHandle(hServerSlot);
    }

    if (pwszServerNames)
        LocalFree(pwszServerNames);

    if (pwszServers)
        LocalFree(pwszServers);

    if (rgwszServers)
        LocalFree(rgwszServers);

    return dwStatus;
}

DWORD 
GetServersFromRegistry(
                       LPWSTR wszRegKey,
                       LPWSTR **prgszServers,
                       DWORD  *pcCount
                       )
{
    HKEY hParamKey = NULL;
    DWORD dwValueType;
    DWORD cbValue = 0, dwDisp;
    LONG lReturn;
    DWORD cbServer;
    DWORD cServers;
    DWORD cchServerMax;
    LPWSTR *rgszServers;
    DWORD i, j;

    *prgszServers = NULL;
    *pcCount = 0;

    lReturn = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                           wszRegKey,
                           0,
                           KEY_READ,
                           &hParamKey );

    if (ERROR_SUCCESS != lReturn)
        return lReturn;

    lReturn = RegQueryInfoKey(hParamKey,
                              NULL,
                              NULL,
                              NULL,
                              &cServers,
                              &cchServerMax,
                              NULL,
                              NULL,
                              NULL,
                              NULL,
                              NULL,
                              NULL);

    if (ERROR_SUCCESS != lReturn)
    {
        RegCloseKey( hParamKey );
        return lReturn;
    }

    if (0 == cServers)
    {
        RegCloseKey( hParamKey );
        return ERROR_NO_MORE_ITEMS;
    }

    rgszServers = (LPWSTR *) LocalAlloc(LPTR,cServers*sizeof(LPWSTR));
    if (NULL == rgszServers)
    {
        RegCloseKey( hParamKey );
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    // Add one for null terminator
    cchServerMax++;
    
    for (i = 0; i < cServers; i++)
    {
        rgszServers[i] = (LPWSTR) LocalAlloc(LPTR,cchServerMax * sizeof(WCHAR));

        if (NULL == rgszServers[i])
        {
            for (j = 0; j < i; j++)
            {
                LocalFree(rgszServers[j]);
            }
            LocalFree(rgszServers);

            RegCloseKey( hParamKey );
            return ERROR_NOT_ENOUGH_MEMORY;
        }

        cbServer = cchServerMax * sizeof(WCHAR);

        lReturn = RegEnumKeyEx(hParamKey,
                               i,
                               rgszServers[i],
                               &cbServer,
                               NULL,
                               NULL,
                               NULL,
                               NULL);

        if (ERROR_SUCCESS != lReturn)
        {
            for (j = 0; j <= i; j++)
            {
                LocalFree(rgszServers[j]);
            }
            LocalFree(rgszServers);

            RegCloseKey( hParamKey );

            return lReturn;
        }
    }

    *prgszServers = rgszServers;
    *pcCount = cServers;

    return ERROR_SUCCESS;
}

DWORD WINAPI
EnumerateTlsServerInRegistry(
    IN TLSENUMERATECALLBACK pfCallBack, 
    IN HANDLE dwUserData,
    IN DWORD dwTimeOut,
    LPWSTR wszRegKey
    )
/*++


++*/
{
    BOOL bCancel=FALSE;
    DWORD dwIndex = 0;
    DWORD cServers = 0;
    LPWSTR *rgszServers = NULL;
    DWORD lReturn;

    lReturn = GetServersFromRegistry(wszRegKey,
                                     &rgszServers,
                                     &cServers
                                     );

    if (ERROR_SUCCESS != lReturn)
    {
        return lReturn;
    }

    RandomizeArray(rgszServers,cServers);

    for (;dwIndex < cServers; dwIndex++)
    {
        PCONTEXT_HANDLE pContext=NULL;
        RPC_STATUS rpcStatus;

        bCancel=pfCallBack(pContext, rgszServers[dwIndex], dwUserData);
        if(bCancel == TRUE)
            continue;

        if(!(pContext = TLSConnectToLsServer(rgszServers[dwIndex])))
        {
            //
            // could be access denied, or the machine is gone
            //

            continue;
        }

        do {            
            //
            // Skip enterprise server
            //
            DWORD dwVersion;
            rpcStatus = TLSGetVersion( pContext, &dwVersion );
            if(rpcStatus != RPC_S_OK)
            {
                break;
            }

#if ENFORCE_LICENSING

            //
            // W2K Beta 3 to RC1 upgrade, don't connect to any non-enforce
            // server 5.2 or older
            //
            if(IS_ENFORCE_LSSERVER(dwVersion) == FALSE)
            {
                if( GET_LSSERVER_MAJOR_VERSION(dwVersion) <= 5 &&
                    GET_LSSERVER_MINOR_VERSION(dwVersion) <= 2 )
                {
                    // old License Server
                    continue;
                }
            }


            //
            // Prevent beta <-> RTM server talking to each other
            //

            //
            // TLSIsBetaNTServer() returns TRUE if eval NT
            // IS_LSSERVER_RTM() returns TRUE if LS is an RTM.
            //

            if( TLSIsBetaNTServer() == IS_LSSERVER_RTM(dwVersion) )
            {
                continue;
            }
#endif

            bCancel=pfCallBack(pContext, rgszServers[dwIndex], dwUserData);    

        } while (FALSE);

        if(bCancel == FALSE && pContext != NULL)
        {
            TLSDisconnect(&pContext);
        }

    } // for loop

    for (dwIndex = 0; dwIndex < cServers; dwIndex++)
    {
        LocalFree(rgszServers[dwIndex]);
    }
    LocalFree(rgszServers);

    return ERROR_SUCCESS;
}

DWORD WINAPI
EnumerateTlsServer(  
    IN TLSENUMERATECALLBACK pfCallBack, 
    IN HANDLE dwUserData,
    IN DWORD dwTimeOut,
    IN BOOL fRegOnly
    )
/*++


++*/
{
    DWORD dwErr;
    LPWSTR szDomain = NULL;
    BOOL fOffSite = FALSE;      // don't try to go off-site

    //
    // First check for a registry bypass of discovery
    //

    dwErr = EnumerateTlsServerInRegistry(
                                         pfCallBack,
                                         dwUserData,
                                         dwTimeOut,
                                         TEXT(TERMINAL_SERVICE_PARAM_DISCOVERY)
                                         );

    if ((!fRegOnly) || (g_fInDomain == -1))
    {
        //
        // Check even if set (for !fRegOnly), to get domain name
        //
        dwErr = TLSInDomain(&g_fInDomain, fRegOnly ? NULL : &szDomain);
        if (dwErr != NO_ERROR)
            return dwErr;
    }
    
    //
    // Reading registry failed, use full discovery
    //

    if(g_fInDomain)
    {
        dwErr = EnumerateTlsServerInDomain(
                                szDomain,
                                pfCallBack,
                                dwUserData,
                                dwTimeOut,
                                fRegOnly,
                                &fOffSite
                            );

        if ((dwErr == NO_ERROR) && !fRegOnly)
        {
            g_fOffSiteLicenseServer = fOffSite;
        }
    }
    else
    {
        dwErr = EnumerateTlsServerInWorkGroup(
                                              pfCallBack,
                                              dwUserData,
                                              dwTimeOut,
                                              fRegOnly
                                              );
    }

    if (NULL != szDomain)
    {
        NetApiBufferFree(szDomain);
    }

    if ((NULL != g_hImmediateDiscovery)
        && (dwErr != NO_ERROR) && fRegOnly)
    {
        SetEvent(g_hImmediateDiscovery);
    }

    if ((NULL != g_hDiscoverySoon)
        && (dwErr == NO_ERROR) && fOffSite && !fRegOnly)
    {
        SetEvent(g_hDiscoverySoon);
    }


    return dwErr;
}

TLS_HANDLE
ConnectAndCheckServer(LPWSTR szServer)
{
    TLS_HANDLE hBinding;
    DWORD dwVersion;
    RPC_STATUS rpcStatus;
    
    hBinding = TLSConnectToLsServer(szServer);

    if(hBinding == NULL)
    {
        goto done;
    }

    // Skip Windows 2000 License servers

        
    DWORD dwSupportFlags = 0;
    DWORD dwErrCode = 0;

        dwErrCode = TLSGetSupportFlags(
            hBinding,
            &dwSupportFlags
    );

	if ((dwErrCode == RPC_S_OK) && !(dwSupportFlags & SUPPORT_WHISTLER_CAL))
    {                    
        TLSDisconnect(&hBinding);
        goto done;
    }

    // If the call fails => Windows 2000 LS
    else if(dwErrCode != RPC_S_OK)
    {
        TLSDisconnect(&hBinding);
        goto done;
    }


    rpcStatus = TLSGetVersion( 
                              hBinding, 
                              &dwVersion 
                              );

    if(rpcStatus != RPC_S_OK)
    {
        TLSDisconnect(&hBinding);
        goto done;
    }
            
    if( TLSIsBetaNTServer() == IS_LSSERVER_RTM(dwVersion) )
    {
        TLSDisconnect(&hBinding);
        goto done;
    }

done:
    return hBinding;
}
 
//+------------------------------------------------------------------------
// Function:   TLSConnectToAnyLsServer()
//
// Description:
//
//      Routine to bind to any license server
//
// Arguments:
//      dwTimeout - INFINITE for going off-site
//
// Return Value:
//
//      RPC binding handle or NULL if error, use GetLastError() to retrieve
//      detail error.
//-------------------------------------------------------------------------
TLS_HANDLE WINAPI
TLSConnectToAnyLsServer(
    DWORD dwTimeout
    )
/*++

++*/
{
    TLS_HANDLE hBinding=NULL;
    HRESULT hr = S_OK;
    LPWSTR *rgszServers = NULL;
    DWORD cServers = 0;
    DWORD i;
    DWORD dwErr;
    BOOL fInDomain;
    LPWSTR szDomain = NULL;
    LPWSTR szServerFound = NULL;
    BOOL fRegOnly = (dwTimeout != INFINITE);
    LPWSTR pwszServerNames = NULL;
    BOOL fFreeServerNames = TRUE;

    // TODO: add error codes/handling to all of this

    //
    // First check for a registry bypass of discovery
    //

    dwErr = GetServersFromRegistry(
                                   TEXT(TERMINAL_SERVICE_PARAM_DISCOVERY),
                                   &rgszServers,
                                   &cServers
                                   );

    if (ERROR_SUCCESS == dwErr)
    {
        RandomizeArray(rgszServers,cServers);

        for (i = 0; i < cServers; i++)
        {
            hBinding = ConnectAndCheckServer(rgszServers[i]);

            if (NULL != hBinding)
            {
                szServerFound = rgszServers[i];
                goto found_one;
            }
        }

        if(NULL != rgszServers)
        {
            for (i = 0; i < cServers; i++)
            {
                LocalFree(rgszServers[i]);
            }
            LocalFree(rgszServers);
            
            rgszServers = NULL;
        }
    }
                                         
    //
    // Next try Site (Enterprise) license servers
    //

    if (!fRegOnly)
    {
        hr = GetAllEnterpriseServers(&rgszServers,&cServers);

        if (SUCCEEDED(hr))
        {
            RandomizeArray(rgszServers,cServers);
        }
    }
    else
    {
        // rgszServers[i] is an index into pwszServerNames; don't free
        fFreeServerNames = FALSE;

        hr = GetLicenseServersFromReg(ENTERPRISE_SERVER_MULTI,
                                      &pwszServerNames,
                                      &cServers,
                                      &rgszServers);
    }

    if (SUCCEEDED(hr))
    {
        for (i = 0; i < cServers; i++)
        {
            hBinding = ConnectAndCheckServer(rgszServers[i]);

            if (NULL != hBinding)
            {
                szServerFound = rgszServers[i];
                goto found_one;
            }
        }

        if(NULL != rgszServers)
        {
            if (fFreeServerNames)
            {
                for (i = 0; i < cServers; i++)
                {
                    LocalFree(rgszServers[i]);
                }
                LocalFree(rgszServers);
            }

            rgszServers = NULL;
        }
    }


    // 
    // No Site LS found, try Domain/Workgroup servers
    //

    dwErr = TLSInDomain(&fInDomain, &szDomain);
    if (dwErr != NO_ERROR)
    {
        return NULL;
    }

    LS_ENUM_PARAM param;

    param.hBinding = &hBinding;
    param.dwTimeout = INFINITE;
    QueryPerformanceCounter(&(param.timeInitial));

    fFreeServerNames = TRUE;

    if (fInDomain)
    {
        BOOL fOffSite = TRUE;

        dwErr = EnumerateTlsServerInDomain(
                                szDomain,
                                BindAnyServer,
                                &param,
                                INFINITE,
                                fRegOnly,
                                &fOffSite
                            );

        if (dwErr == NO_ERROR)
        {
            g_fOffSiteLicenseServer = fOffSite;
        }
    }
    else
    {
        dwErr = EnumerateTlsServerInWorkGroup(
                                              BindAnyServer,
                                              &param,
                                              MAILSLOT_WAIT_FOREVER,
                                              fRegOnly
                                              );        
    }

    if (NULL != szDomain)
    {
        NetApiBufferFree(szDomain);
    }

    if (hBinding != NULL)
        goto found_one;

    if (NULL != pwszServerNames)
    {
        LocalFree(pwszServerNames);
    }

    if ((NULL != g_hImmediateDiscovery)
        && fRegOnly)
    {
        SetEvent(g_hImmediateDiscovery);
    }
    else if ((NULL != g_hDiscoverySoon)
        && !fRegOnly && g_fOffSiteLicenseServer)
    {
        SetEvent(g_hDiscoverySoon);
    }

    return NULL;

found_one:

    if (NULL != pwszServerNames)
    {
        LocalFree(pwszServerNames);
    }

    if(NULL != rgszServers)
    {
        if (fFreeServerNames)
        {
            for (i = 0; i < cServers; i++)
            {
                LocalFree(rgszServers[i]);
            }
        }
        LocalFree(rgszServers);
    }

    return hBinding;
}

BOOL
TLSRefreshLicenseServerCache(
    IN DWORD dwTimeOut
    )
/*++

Abstract:

    Refresh license server cache in registry.

Parameter:

    dwTimeOut : Reserverd, should pass in INIFINITE for now

Returns:

    TRUE/FALSE

--*/
{
    BOOL bFoundServer = FALSE;
    TLS_HANDLE hBinding = NULL;

    hBinding = TLSConnectToAnyLsServer(dwTimeOut);

    if (NULL != hBinding)
    {
        bFoundServer = TRUE;

        TLSDisconnect(&hBinding);
    }

    return bFoundServer;
}

LICENSE_STATUS
InstallCertificate(LPVOID lpParam)
{
    Sleep(INSTALL_CERT_DELAY);

    return LsCsp_InstallX509Certificate(NULL);
}
   

//-------------------------------------------------------------------------

TLS_HANDLE WINAPI
TLSConnectToLsServer( 
    LPTSTR pszLsServer 
    )
/*++

++*/
{
    TCHAR szMachineName[MAX_COMPUTERNAME_LENGTH + 1] ;
    PCONTEXT_HANDLE pContext=NULL;
    DWORD cbMachineName=MAX_COMPUTERNAME_LENGTH;
    HANDLE hThread = NULL;
    static BOOL fLSFound = FALSE;

    memset(szMachineName, 0, sizeof(szMachineName));
    GetComputerName(szMachineName, &cbMachineName);
    if(pszLsServer == NULL || _tcsicmp(szMachineName, pszLsServer) == 0)
    {
        pContext=ConnectLsServer(
                            szMachineName, 
                            _TEXT(RPC_PROTOSEQLPC), 
                            NULL, 
                            RPC_C_AUTHN_LEVEL_DEFAULT
                        );
        if(GetLastError() >= LSERVER_ERROR_BASE)
        {
            return NULL;
        }
        // try to connect with TCP protocol, if local procedure failed
    }

    if(pContext == NULL)
    {
        pContext=ConnectLsServer(
                            pszLsServer, 
                            _TEXT(RPC_PROTOSEQNP), 
                            _TEXT(LSNAMEPIPE), 
                            RPC_C_AUTHN_LEVEL_PKT_PRIVACY
                        );

    }

    if (!fLSFound && (NULL != pContext))
    {
        fLSFound = TRUE;

        // Now that someone's connected, we can install a license
        hThread = CreateThread(NULL,
                               0,
                               InstallCertificate,
                               NULL,
                               0,
                               NULL);

        if (hThread != NULL)
        {
            CloseHandle(hThread);
        }
        else
        {
            // Can't create the thread; try again later
            fLSFound = FALSE;
        }

    }

    return (TLS_HANDLE) pContext;
}
//-------------------------------------------------------------------------
void WINAPI
TLSDisconnectFromServer( 
    TLS_HANDLE pHandle 
    )
/*++

++*/
{
    if(pHandle != NULL)
    {
        TLSDisconnect( &pHandle );
    }
}

//----------------------------------------------------------------------------
DWORD WINAPI
TLSConnect( 
    handle_t binding,
    TLS_HANDLE *ppHandle 
    )
/*++

++*/
{
    return TLSRpcConnect(binding, ppHandle);
}

//----------------------------------------------------------------------------
DWORD WINAPI
TLSDisconnect(
    TLS_HANDLE* pphHandle
    )
/*++

++*/
{
    RPC_STATUS rpc_status;

    rpc_status = TLSRpcDisconnect( pphHandle );
    if(rpc_status != RPC_S_OK)
    {
        RpcSmDestroyClientContext(pphHandle);
    }

    *pphHandle = NULL;

    return ERROR_SUCCESS;
}

//-------------------------------------------------------------------------
DWORD WINAPI
TLSGetVersion (
    IN TLS_HANDLE hHandle,
    OUT PDWORD pdwVersion
    )
/*++

++*/
{
    return TLSRpcGetVersion( hHandle, pdwVersion );
}

//----------------------------------------------------------------------------
DWORD WINAPI 
TLSSendServerCertificate( 
     TLS_HANDLE hHandle,
     DWORD cbCert,
     PBYTE pbCert,
     PDWORD pdwErrCode
    )
/*++

++*/
{
    return TLSRpcSendServerCertificate(
                                hHandle, 
                                cbCert, 
                                pbCert, 
                                pdwErrCode
                            );
}

//----------------------------------------------------------------------------
DWORD WINAPI 
TLSGetServerName( 
     TLS_HANDLE hHandle,
     LPTSTR szMachineName,
     PDWORD pcbSize,
     PDWORD pdwErrCode
    )
/*++

++*/
{
    return TLSRpcGetServerName(
                            hHandle, 
                            szMachineName, 
                            pcbSize, 
                            pdwErrCode
                        );
}

//----------------------------------------------------------------------------
DWORD WINAPI 
TLSGetServerNameEx( 
     TLS_HANDLE hHandle,
     LPTSTR szMachineName,
     PDWORD pcbSize,
     PDWORD pdwErrCode
    )
/*++

++*/
{
    RPC_STATUS rpc_status;

    rpc_status = TLSRpcGetServerNameEx(
                            hHandle, 
                            szMachineName, 
                            pcbSize, 
                            pdwErrCode
                        );

     if (rpc_status == RPC_S_PROCNUM_OUT_OF_RANGE)

    {
        rpc_status = TLSRpcGetServerName(
                            hHandle, 
                            szMachineName, 
                            pcbSize, 
                            pdwErrCode
                        );
    }

    return rpc_status;
}

//----------------------------------------------------------------------------
DWORD WINAPI 
TLSGetServerNameFixed( 
     TLS_HANDLE hHandle,
     LPTSTR *pszMachineName,
     PDWORD pdwErrCode
    )
/*++

++*/
{
    return TLSRpcGetServerNameFixed(
                            hHandle, 
                            pszMachineName, 
                            pdwErrCode
                        );
}

//----------------------------------------------------------------------------
DWORD WINAPI 
TLSGetServerScope( 
     TLS_HANDLE hHandle,
     LPTSTR szScopeName,
     PDWORD pcbSize,
     PDWORD pdwErrCode)
/*++

++*/
{
    return TLSRpcGetServerScope(
                            hHandle, 
                            szScopeName, 
                            pcbSize, 
                            pdwErrCode
                        );
}

//----------------------------------------------------------------------------
DWORD WINAPI 
TLSGetServerScopeFixed( 
     TLS_HANDLE hHandle,
     LPTSTR *pszScopeName,
     PDWORD pdwErrCode)
/*++

++*/
{
    return TLSRpcGetServerScopeFixed(
                            hHandle, 
                            pszScopeName, 
                            pdwErrCode
                        );
}

//----------------------------------------------------------------------------
DWORD WINAPI 
TLSIssuePlatformChallenge( 
     TLS_HANDLE hHandle,
     DWORD dwClientInfo,
     PCHALLENGE_CONTEXT pChallengeContext,
     PDWORD pcbChallengeData,
     PBYTE* pChallengeData,
     PDWORD pdwErrCode
    )
/*++

++*/
{
    return TLSRpcIssuePlatformChallenge(
                                hHandle, 
                                dwClientInfo, 
                                pChallengeContext, 
                                pcbChallengeData, 
                                pChallengeData, 
                                pdwErrCode
                            );
}

//----------------------------------------------------------------------------
DWORD WINAPI 
TLSIssueNewLicense( 
     TLS_HANDLE hHandle,
     CHALLENGE_CONTEXT ChallengeContext,
     LICENSEREQUEST  *pRequest,
     LPTSTR pMachineName,
     LPTSTR pUserName,
     DWORD cbChallengeResponse,
     PBYTE pbChallengeResponse,
     BOOL bAcceptTemporaryLicense,
     PDWORD pcbLicense,
     PBYTE* ppbLicense,
     PDWORD pdwErrCode
    )
/*++

++*/
{
    TLSLICENSEREQUEST rpcRequest;
    RequestToTlsRequest( pRequest, &rpcRequest );

    return TLSRpcRequestNewLicense(
                        hHandle, 
                        ChallengeContext, 
                        &rpcRequest, 
                        pMachineName, 
                        pUserName, 
                        cbChallengeResponse,
                        pbChallengeResponse,
                        bAcceptTemporaryLicense,
                        pcbLicense,
                        ppbLicense,
                        pdwErrCode
                    );
}

//----------------------------------------------------------------------------
DWORD WINAPI 
TLSIssueNewLicenseEx( 
     TLS_HANDLE hHandle,
     PDWORD pSupportFlags,
     CHALLENGE_CONTEXT ChallengeContext,
     LICENSEREQUEST  *pRequest,
     LPTSTR pMachineName,
     LPTSTR pUserName,
     DWORD cbChallengeResponse,
     PBYTE pbChallengeResponse,
     BOOL bAcceptTemporaryLicense,
     DWORD dwQuantity,
     PDWORD pcbLicense,
     PBYTE* ppbLicense,
     PDWORD pdwErrCode
    )
/*++

++*/
{
    DWORD dwStatus;
    TLSLICENSEREQUEST rpcRequest;
    RequestToTlsRequest( pRequest, &rpcRequest );

    dwStatus = TLSRpcRequestNewLicenseEx(
                        hHandle,
                        pSupportFlags,
                        ChallengeContext, 
                        &rpcRequest, 
                        pMachineName, 
                        pUserName, 
                        cbChallengeResponse,
                        pbChallengeResponse,
                        bAcceptTemporaryLicense,
                        dwQuantity,
                        pcbLicense,
                        ppbLicense,
                        pdwErrCode
                    );

    if (dwStatus == RPC_S_PROCNUM_OUT_OF_RANGE)
    {
        *pSupportFlags = 0;

        dwStatus = TLSRpcRequestNewLicense(
                        hHandle,
                        ChallengeContext, 
                        &rpcRequest, 
                        pMachineName, 
                        pUserName, 
                        cbChallengeResponse,
                        pbChallengeResponse,
                        bAcceptTemporaryLicense,
                        pcbLicense,
                        ppbLicense,
                        pdwErrCode
                    );
    }

    return(dwStatus);
}

//----------------------------------------------------------------------------
DWORD WINAPI 
TLSIssueNewLicenseExEx( 
     TLS_HANDLE hHandle,
     PDWORD pSupportFlags,
     CHALLENGE_CONTEXT ChallengeContext,
     LICENSEREQUEST  *pRequest,
     LPTSTR pMachineName,
     LPTSTR pUserName,
     DWORD cbChallengeResponse,
     PBYTE pbChallengeResponse,
     BOOL bAcceptTemporaryLicense,
     BOOL bAcceptFewerLicenses,
     DWORD *pdwQuantity,
     PDWORD pcbLicense,
     PBYTE* ppbLicense,
     PDWORD pdwErrCode
    )
/*++

++*/
{
    DWORD dwStatus;
    TLSLICENSEREQUEST rpcRequest;
    RequestToTlsRequest( pRequest, &rpcRequest );

    dwStatus = TLSRpcRequestNewLicenseExEx(
                        hHandle,
                        pSupportFlags,
                        ChallengeContext, 
                        &rpcRequest, 
                        pMachineName, 
                        pUserName, 
                        cbChallengeResponse,
                        pbChallengeResponse,
                        bAcceptTemporaryLicense,
                        bAcceptFewerLicenses,
                        pdwQuantity,
                        pcbLicense,
                        ppbLicense,
                        pdwErrCode
                    );

    if (dwStatus == RPC_S_PROCNUM_OUT_OF_RANGE)
    {
        dwStatus = TLSRpcRequestNewLicenseEx(
                        hHandle,
                        pSupportFlags,
                        ChallengeContext, 
                        &rpcRequest, 
                        pMachineName, 
                        pUserName, 
                        cbChallengeResponse,
                        pbChallengeResponse,
                        bAcceptTemporaryLicense,
                        *pdwQuantity,
                        pcbLicense,
                        ppbLicense,
                        pdwErrCode
                        );

        if (dwStatus == RPC_S_PROCNUM_OUT_OF_RANGE)
        {
            *pSupportFlags = 0;

            dwStatus = TLSRpcRequestNewLicense(
                        hHandle,
                        ChallengeContext, 
                        &rpcRequest, 
                        pMachineName, 
                        pUserName, 
                        cbChallengeResponse,
                        pbChallengeResponse,
                        bAcceptTemporaryLicense,
                        pcbLicense,
                        ppbLicense,
                        pdwErrCode
                        );
        }
    }

    return(dwStatus);
}

//----------------------------------------------------------------------------
DWORD WINAPI 
TLSUpgradeLicense( 
     TLS_HANDLE hHandle,
     LICENSEREQUEST *pRequest,
     CHALLENGE_CONTEXT ChallengeContext,
     DWORD cbChallengeResponse,
     PBYTE pbChallengeResponse,
     DWORD cbOldLicense,
     PBYTE pbOldLicense,
     PDWORD pcbNewLicense,
     PBYTE* ppbNewLicense,
     PDWORD pdwErrCode
    )
/*++

++*/
{
    TLSLICENSEREQUEST rpcRequest;
    RequestToTlsRequest( pRequest, &rpcRequest );

    return TLSRpcUpgradeLicense(
                         hHandle,
                         &rpcRequest,
                         ChallengeContext,
                         cbChallengeResponse,
                         pbChallengeResponse,
                         cbOldLicense,
                         pbOldLicense,
                         pcbNewLicense,
                         ppbNewLicense,
                         pdwErrCode
                    );
}

//----------------------------------------------------------------------------
DWORD WINAPI 
TLSUpgradeLicenseEx( 
     TLS_HANDLE hHandle,
     PDWORD pSupportFlags,
     LICENSEREQUEST *pRequest,
     CHALLENGE_CONTEXT ChallengeContext,
     DWORD cbChallengeResponse,
     PBYTE pbChallengeResponse,
     DWORD cbOldLicense,
     PBYTE pbOldLicense,
     DWORD dwQuantity,
     PDWORD pcbNewLicense,
     PBYTE* ppbNewLicense,
     PDWORD pdwErrCode
    )
/*++

++*/
{
    DWORD dwStatus;
    TLSLICENSEREQUEST rpcRequest;
    RequestToTlsRequest( pRequest, &rpcRequest );

    dwStatus = TLSRpcUpgradeLicenseEx(
                         hHandle,
                         pSupportFlags,
                         &rpcRequest,
                         ChallengeContext,
                         cbChallengeResponse,
                         pbChallengeResponse,
                         cbOldLicense,
                         pbOldLicense,
                         dwQuantity,
                         pcbNewLicense,
                         ppbNewLicense,
                         pdwErrCode
                    );

    if (dwStatus == RPC_S_PROCNUM_OUT_OF_RANGE)
    {
        *pSupportFlags = 0;

        dwStatus = TLSRpcUpgradeLicense(
                         hHandle,
                         &rpcRequest,
                         ChallengeContext,
                         cbChallengeResponse,
                         pbChallengeResponse,
                         cbOldLicense,
                         pbOldLicense,
                         pcbNewLicense,
                         ppbNewLicense,
                         pdwErrCode
                    );
    }

    return(dwStatus);
}

//----------------------------------------------------------------------------
DWORD WINAPI 
TLSAllocateConcurrentLicense( 
     TLS_HANDLE hHandle,
     LPTSTR szHydraServer,
     LICENSEREQUEST  *pRequest,
     LONG  *dwQuantity,
     PDWORD pdwErrCode
    )
/*++

++*/
{
    TLSLICENSEREQUEST rpcRequest;
    RequestToTlsRequest( pRequest, &rpcRequest );

    return TLSRpcAllocateConcurrentLicense(
                                     hHandle,
                                     szHydraServer,
                                     &rpcRequest,
                                     dwQuantity,
                                     pdwErrCode
                                );
}

//----------------------------------------------------------------------------
DWORD WINAPI 
TLSGetLastError( 
     TLS_HANDLE hHandle,
     DWORD cbBufferSize,
     LPTSTR pszBuffer,
     PDWORD pdwErrCode
    )
/*++

++*/
{
    return TLSRpcGetLastError( 
                            hHandle,
                            &cbBufferSize,
                            pszBuffer,
                            pdwErrCode
                        );
}

//----------------------------------------------------------------------------
DWORD WINAPI 
TLSGetLastErrorFixed( 
     TLS_HANDLE hHandle,
     LPTSTR *pszBuffer,
     PDWORD pdwErrCode
    )
/*++

++*/
{
    return TLSRpcGetLastErrorFixed( 
                            hHandle,
                            pszBuffer,
                            pdwErrCode
                        );
}

//----------------------------------------------------------------------------
DWORD WINAPI 
TLSKeyPackEnumBegin( 
     TLS_HANDLE hHandle,
     DWORD dwSearchParm,
     BOOL bMatchAll,
     LPLSKeyPackSearchParm lpSearchParm,
     PDWORD pdwErrCode
    )
/*++

++*/
{
    return TLSRpcKeyPackEnumBegin( 
                         hHandle,
                         dwSearchParm,
                         bMatchAll,
                         lpSearchParm,
                         pdwErrCode
                    );
}

//----------------------------------------------------------------------------
DWORD WINAPI 
TLSKeyPackEnumNext( 
    TLS_HANDLE hHandle,
    LPLSKeyPack lpKeyPack,
    PDWORD pdwErrCode
    )
/*++

++*/
{
    return TLSRpcKeyPackEnumNext( 
                    hHandle,
                    lpKeyPack,
                    pdwErrCode
                );
}

//----------------------------------------------------------------------------
DWORD WINAPI 
TLSKeyPackEnumEnd( 
     TLS_HANDLE hHandle,
     PDWORD pdwErrCode
    )
/*++

++*/
{
    return TLSRpcKeyPackEnumEnd(hHandle, pdwErrCode);
}


//----------------------------------------------------------------------------
DWORD WINAPI 
TLSLicenseEnumBegin( 
    TLS_HANDLE hHandle,
    DWORD dwSearchParm,
    BOOL bMatchAll,
    LPLSLicenseSearchParm lpSearchParm,
    PDWORD pdwErrCode
    )
/*++

++*/
{
    return TLSRpcLicenseEnumBegin( 
                            hHandle,
                            dwSearchParm,
                            bMatchAll,
                            lpSearchParm,
                            pdwErrCode
                        );
}

//----------------------------------------------------------------------------
DWORD WINAPI 
TLSLicenseEnumNext( 
    TLS_HANDLE hHandle,
    LPLSLicense lpLicense,
    PDWORD pdwErrCode
    )
/*++

++*/
{
    return TLSRpcLicenseEnumNext( 
                            hHandle,
                            lpLicense,
                            pdwErrCode
                        );
}

//----------------------------------------------------------------------------
DWORD WINAPI 
TLSLicenseEnumNextEx( 
    TLS_HANDLE hHandle,
    LPLSLicenseEx lpLicenseEx,
    PDWORD pdwErrCode
    )
/*++

++*/
{
    DWORD dwRet;

    if (NULL == lpLicenseEx)
    {
        return ERROR_INVALID_PARAMETER;
    }

    dwRet = TLSRpcLicenseEnumNextEx( 
                            hHandle,
                            lpLicenseEx,
                            pdwErrCode
                        );

    if (RPC_S_PROCNUM_OUT_OF_RANGE == dwRet)
    {
        LSLicense License;

        dwRet = TLSRpcLicenseEnumNext(
                            hHandle,
                            &License,
                            pdwErrCode
                            );

        if ((dwRet == RPC_S_OK)
            && (NULL != pdwErrCode)
            && (*pdwErrCode == ERROR_SUCCESS))
        {
            // older versions only support quantity == 1

            memcpy(lpLicenseEx,&License,sizeof(License));
            lpLicenseEx->dwQuantity = 1;
        }
    }

    return dwRet;
}

//----------------------------------------------------------------------------
DWORD WINAPI 
TLSLicenseEnumEnd( 
    TLS_HANDLE hHandle,
    PDWORD pdwErrCode
    )
/*++

++*/
{
    return TLSRpcLicenseEnumEnd(hHandle, pdwErrCode);
}


//----------------------------------------------------------------------------
DWORD WINAPI 
TLSGetAvailableLicenses( 
    TLS_HANDLE hHandle,
    DWORD dwSearchParm,
    LPLSKeyPack lplsKeyPack,
    LPDWORD lpdwAvail,
    PDWORD pdwErrCode
    )
/*++

++*/
{
    return TLSRpcGetAvailableLicenses( 
                        hHandle,
                        dwSearchParm,
                        lplsKeyPack,
                        lpdwAvail,
                        pdwErrCode
                    );
}

//----------------------------------------------------------------------------
DWORD WINAPI 
TLSGetRevokeKeyPackList( 
    TLS_HANDLE hHandle,
    PDWORD pcbNumberOfRange,
    LPLSRange  *ppRevokeRange,
    PDWORD pdwErrCode
    )
/*++

++*/
{
    return TLSRpcGetRevokeKeyPackList( 
                             hHandle,
                             pcbNumberOfRange,
                             ppRevokeRange,
                             pdwErrCode
                        );
}

//----------------------------------------------------------------------------
DWORD WINAPI 
TLSGetRevokeLicenseList( 
    TLS_HANDLE hHandle,
    PDWORD pcbNumberOfRange,
    LPLSRange  *ppRevokeRange,
    PDWORD pdwErrCode
    )
/*++

++*/
{
    return TLSRpcGetRevokeLicenseList( 
                             hHandle,
                             pcbNumberOfRange,
                             ppRevokeRange,
                             pdwErrCode
                        );
}


//----------------------------------------------------------------------------
DWORD WINAPI
TLSMarkLicense(
    TLS_HANDLE hHandle,
    UCHAR ucFlags,
    DWORD cbLicense,
    PBYTE pLicense,
    PDWORD pdwErrCode
    )
/*++

++*/
{
    return TLSRpcMarkLicense(
                            hHandle,
                            ucFlags,
                            cbLicense,
                            pLicense,
                            pdwErrCode
                        );
}

//----------------------------------------------------------------------------
DWORD WINAPI
TLSCheckLicenseMark(
    TLS_HANDLE hHandle,
    DWORD cbLicense,
    PBYTE pLicense,
    PUCHAR pucFlags,
    PDWORD pdwErrCode
    )
/*++

++*/
{
    return TLSRpcCheckLicenseMark(
                            hHandle,
                            cbLicense,
                            pLicense,
                            pucFlags,
                            pdwErrCode
                        );
}

//----------------------------------------------------------------------------
DWORD WINAPI
TLSGetSupportFlags(
    TLS_HANDLE hHandle,
    DWORD *pdwSupportFlags
    )
/*++

++*/
{
    return TLSRpcGetSupportFlags(
                            hHandle,
                            pdwSupportFlags
                        );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\license\tlserver\tlsapi\tlsrpc-c.c ===
#include <tlsrpc_c.c>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\license\tlserver\tlsapi\noenf\makefile.inc ===
#
# Copyright (c) 1997-1999 Microsoft Corporation
#

TAGET_DIRECTORY=*

PRIVLIB=$(LSERVER_LIB_PATH)\$(ALT_PROJECT_TARGET)\$(O)\tlsapip.lib
$(LSERVER_LIB_PATH)\$(ALT_PROJECT_TARGET)\$(TARGET_DIRECTORY)\tlsapi.lib : $(PRIVLIB)

$(PRIVLIB) $(PRIVLIB:.lib=.exp): $(O)\tlsapip.def $(LIBRARY_OBJS)
   -lib -out:$(PRIVLIB) @<<
$(LIBRARIAN_FLAGS)
-def:$(O)\tlsapip.def
$(LIBRARY_OBJS)
<<NOKEEP

$(O)\tlsapi.def: $(TLSAPI_ROOT)\tlsapi.def
    @echo Creating $@ from $**
    $(C_PREPROCESSOR) $** > $@

C_DEFINES=$(C_DEFINES) -DPRIVATE=
$(O)\tlsapip.def: $(O)\tlsapi.def
    $(C_PREPROCESSOR) $(O)\tlsapi.def > $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\license\tlserver\tlsapi\enforce\makefile.inc ===
#
# Copyright (c) 1997-1999 Microsoft Corporation
#

TAGET_DIRECTORY=*

PRIVLIB=$(LSERVER_LIB_PATH)\$(ALT_PROJECT_TARGET)\$(O)\tlsapip.lib
$(LSERVER_LIB_PATH)\$(ALT_PROJECT_TARGET)\$(TARGET_DIRECTORY)\tlsapi.lib : $(PRIVLIB)

$(PRIVLIB) $(PRIVLIB:.lib=.exp): $(O)\tlsapip.def $(LIBRARY_OBJS)
   -lib -out:$(PRIVLIB) @<<
$(LIBRARIAN_FLAGS)
-def:$(O)\tlsapip.def
$(LIBRARY_OBJS)
<<NOKEEP

$(O)\tlsapi.def: $(TLSAPI_ROOT)\tlsapi.def
    @echo Creating $@ from $**
    $(C_PREPROCESSOR) $** > $@

C_DEFINES=$(C_DEFINES) -DPRIVATE=
$(O)\tlsapip.def: $(O)\tlsapi.def
    $(C_PREPROCESSOR) $(O)\tlsapi.def > $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\license\tlserver\tlsapiex\tlsrpc-c.c ===
#include <tlsrpc_c.c>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\license\tlserver\tlsapiex\sources.inc ===
!IF 0

Copyright (c) 1989  Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


Author:


NOTE:   Commented description of this file is in \nt\bak\bin\sources.tpl

!ENDIF

MISC_SOURCES=\
    ..\tlsapipex.cpp \
    ..\tlsrpc-c.c
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\license\tlserver\tlsapi\tlsapip.cpp ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996-1998
//
// File:        tlsapip.cpp
//
// Contents:    Private API
//
// History:     09-09-97    HueiWang    Created
//
//---------------------------------------------------------------------------
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <tchar.h>
#include <rpc.h>
#include "lscommon.h"
#include <wincrypt.h>
#include "tlsrpc.h"
#include "tlsapi.h"
#include "tlsapip.h"

//----------------------------------------------------------------------------
BOOL
TLSIsLicenseEnforceEnable()
/*++

--*/
{
    #if ENFORCE_LICENSING
    return TRUE;
    #else
    return FALSE;
    #endif
}

//----------------------------------------------------------------------------
BOOL
TLSIsBetaNTServer()
/*++

Abstract:

    Detemine if base NT is a beta or RTM version.

Parameter:

    None.

Return:

    TRUE/FALSE

--*/
{
    BOOL bBetaNt = FALSE;
    DWORD dwStatus;
    DWORD cbData;
    DWORD cbType;
    HKEY hKey = NULL;

    __try {
        LARGE_INTEGER Time = USER_SHARED_DATA->SystemExpirationDate;

        if(Time.QuadPart)
        {
            bBetaNt = TRUE;

            // check our special registry key - force
            // issuing a RTM license.
            dwStatus = RegOpenKeyEx(
                                HKEY_LOCAL_MACHINE,
                                L"SOFTWARE\\Microsoft\\TermServLicensing",
                                0,
                                KEY_ALL_ACCESS,
                                &hKey
                            );

            if(dwStatus == ERROR_SUCCESS)
            {
                dwStatus = RegQueryValueEx(
                                    hKey,
                                    _TEXT("RunAsRTM"),
                                    NULL,
                                    &cbType,
                                    NULL,
                                    &cbData
                                );

                // for testing, force it to run as RTM version.
                // key must exist and must be DWORD type
                if(dwStatus == ERROR_SUCCESS && cbType == REG_DWORD)
                {
                    bBetaNt = FALSE;
                }
            }
        }
    }
    __except(EXCEPTION_EXECUTE_HANDLER) {
        ASSERT(FALSE);
    }

    if(hKey != NULL)
    {
        RegCloseKey(hKey);
    }

    return bBetaNt;
}

//----------------------------------------------------------------------------
DWORD WINAPI
TLSAllocateInternetLicenseEx(
    IN TLS_HANDLE hHandle,
    IN const CHALLENGE_CONTEXT ChallengeContext,
    IN const LICENSEREQUEST* pRequest,
    IN LPTSTR pszMachineName,
    IN LPTSTR pszUserName,
    IN const DWORD cbChallengeResponse,
    IN const PBYTE pbChallengeResponse,
    OUT PTLSInternetLicense pInternetLicense,
    OUT PDWORD pdwErrCode
    )
/*++

--*/
{
    TLSLICENSEREQUEST rpcRequest;
    RequestToTlsRequest( pRequest, &rpcRequest );

    return TLSRpcAllocateInternetLicenseEx(
                                hHandle,
                                ChallengeContext,
                                &rpcRequest,
                                pszMachineName,
                                pszUserName,
                                cbChallengeResponse,
                                pbChallengeResponse,
                                pInternetLicense,
                                pdwErrCode
                            );
}
//----------------------------------------------------------------------------

DWORD WINAPI
TLSReturnInternetLicenseEx(
    IN TLS_HANDLE hHandle,
    IN const LICENSEREQUEST* pRequest,
    IN const ULARGE_INTEGER* pulSerialNumber,
    IN const DWORD dwQuantity,
    OUT PDWORD pdwErrCode
    )
/*++

--*/
{
    TLSLICENSEREQUEST rpcRequest;
    RequestToTlsRequest( pRequest, &rpcRequest );
    
    return TLSRpcReturnInternetLicenseEx(
                                hHandle,
                                &rpcRequest,
                                pulSerialNumber,
                                dwQuantity,
                                pdwErrCode
                            );
}

//----------------------------------------------------------------------------

DWORD WINAPI 
TLSRegisterLicenseKeyPack( 
    TLS_HANDLE hHandle,
    LPBYTE pbCHCertBlob,
    DWORD cbCHCertBlobSize,
    LPBYTE pbRootCertBlob,
    DWORD cbRootCertBlob,
    LPBYTE lpKeyPackBlob,
    DWORD dwKeyPackBlobLen,
    PDWORD pdwErrCode
    )
/*++

++*/
{
    return TLSRpcRegisterLicenseKeyPack( 
                                hHandle,
                                pbCHCertBlob,
                                cbCHCertBlobSize,
                                pbRootCertBlob,
                                cbRootCertBlob,
                                lpKeyPackBlob,
                                dwKeyPackBlobLen,
                                pdwErrCode
                            );
}

//----------------------------------------------------------------------------

DWORD WINAPI
TLSTelephoneRegisterLKP(
    IN TLS_HANDLE hHandle,
    IN DWORD cbData,
    IN PBYTE pbData,
    OUT PDWORD pdwErrCode
    )

/*++


--*/

{
    return TLSRpcTelephoneRegisterLKP(
                                hHandle,
                                cbData,
                                pbData,
                                pdwErrCode
                            );
}

//----------------------------------------------------------------------------

DWORD WINAPI
RequestToTlsRequest( 
    const LICENSEREQUEST* lpRequest, 
    TLSLICENSEREQUEST* lpRpcRequest 
    )
/*++

++*/
{
    if(lpRequest == NULL || lpRpcRequest == NULL || lpRequest->pProductInfo == NULL)
        return ERROR_INVALID_PARAMETER;

    //
    // NOTE : No memory allocation, DO NOT FREE ...
    //
    lpRpcRequest->cbEncryptedHwid = lpRequest->cbEncryptedHwid;
    lpRpcRequest->pbEncryptedHwid = lpRequest->pbEncryptedHwid;
    lpRpcRequest->dwLanguageID = lpRequest->dwLanguageID;
    lpRpcRequest->dwPlatformID = lpRequest->dwPlatformID;
    lpRpcRequest->ProductInfo.dwVersion = lpRequest->pProductInfo->dwVersion;
    lpRpcRequest->ProductInfo.cbCompanyName = lpRequest->pProductInfo->cbCompanyName;
    lpRpcRequest->ProductInfo.pbCompanyName = lpRequest->pProductInfo->pbCompanyName;
    lpRpcRequest->ProductInfo.cbProductID = lpRequest->pProductInfo->cbProductID;
    lpRpcRequest->ProductInfo.pbProductID = lpRequest->pProductInfo->pbProductID;
    return ERROR_SUCCESS;
}

//----------------------------------------------------------------------------

DWORD WINAPI 
TLSReturnLicense( 
     TLS_HANDLE hHandle,
     DWORD dwKeyPackId,
     DWORD dwLicenseId,
     DWORD dwRetrunReason,
     PDWORD pdwErrCode
    )
/*++

++*/
{
    return TLSRpcReturnLicense( 
                         hHandle,
                         dwKeyPackId,
                         dwLicenseId,
                         dwRetrunReason,
                         pdwErrCode
                    );
}

//----------------------------------------------------------------------------

DWORD WINAPI 
TLSGetLSPKCS10CertRequest(
    TLS_HANDLE hHandle,
    DWORD dwCertType,
    PDWORD pcbData,
    PBYTE* ppbData,
    PDWORD pdwErrCode
    )
/*++

++*/
{
    return TLSRpcGetLSPKCS10CertRequest(
                            hHandle,
                            dwCertType,
                            pcbData,
                            ppbData,
                            pdwErrCode
                        );
}

//----------------------------------------------------------------------------
DWORD WINAPI
TLSRequestTermServCert( 
    TLS_HANDLE hHandle,
    LPLSHydraCertRequest pRequest,
    PDWORD cbChallengeData,
    PBYTE* pbChallengeData,
    PDWORD pdwErrCode
    )
/*++

++*/
{
    TLSHYDRACERTREQUEST CertRequest;

    CertRequest.dwHydraVersion = pRequest->dwHydraVersion;
    CertRequest.pbEncryptedHwid = pRequest->pbEncryptedHwid;
    CertRequest.cbEncryptedHwid = pRequest->cbEncryptedHwid;
    CertRequest.szSubjectRdn = pRequest->szSubjectRdn;
    CertRequest.pSubjectPublicKeyInfo = (TLSCERT_PUBLIC_KEY_INFO *)pRequest->SubjectPublicKeyInfo;
    CertRequest.dwNumCertExtension = pRequest->dwNumCertExtension;
    CertRequest.pCertExtensions = (TLSCERT_EXTENSION *)pRequest->pCertExtensions;

    return TLSRpcRequestTermServCert(
                                hHandle,
                                &CertRequest,
                                cbChallengeData,
                                pbChallengeData,
                                pdwErrCode
                            );
}

//----------------------------------------------------------------------------
DWORD WINAPI
TLSRetrieveTermServCert( 
    TLS_HANDLE hHandle,
    DWORD cbResponseData,
    PBYTE pbResponseData,
    PDWORD pcbCert,
    PBYTE* ppbCert,
    PDWORD pdwErrCode
    )
/*++

++*/
{
    return TLSRpcRetrieveTermServCert(
                                hHandle,
                                cbResponseData,
                                pbResponseData,
                                pcbCert,
                                ppbCert,
                                pdwErrCode
                            );
}

//----------------------------------------------------------------------------
DWORD WINAPI 
TLSInstallCertificate( 
     TLS_HANDLE hHandle,
     DWORD dwCertType,
     DWORD dwCertLevel,
     DWORD cbSingnatureCert,
     PBYTE pbSingnatureCert,
     DWORD cbExchangeCert,
     PBYTE pbExchangeCert,
     PDWORD pdwErrCode
    )
/*++

++*/
{
    return TLSRpcInstallCertificate( 
                         hHandle,
                         dwCertType,
                         dwCertLevel,
                         cbSingnatureCert,
                         pbSingnatureCert,
                         cbExchangeCert,
                         pbExchangeCert,
                         pdwErrCode
                    );
}

//----------------------------------------------------------------------------
DWORD WINAPI 
TLSGetServerCertificate( 
    TLS_HANDLE hHandle,
    BOOL bSignCert,
    LPBYTE  *ppbCertBlob,
    LPDWORD lpdwCertBlobLen,
    PDWORD pdwErrCode
    )
/*++

++*/
{
    return TLSRpcGetServerCertificate( 
                             hHandle,
                             bSignCert,
                             ppbCertBlob,
                             lpdwCertBlobLen,
                             pdwErrCode
                        );
}

//----------------------------------------------------------------------------
DWORD WINAPI 
TLSKeyPackAdd( 
    TLS_HANDLE hHandle,
    LPLSKeyPack lpKeypack,
    PDWORD pdwErrCode
    )
/*++

++*/
{
    return TLSRpcKeyPackAdd( 
                    hHandle,
                    lpKeypack,
                    pdwErrCode
                );
}

//----------------------------------------------------------------------------
DWORD WINAPI 
TLSKeyPackSetStatus( 
    TLS_HANDLE hHandle,
    DWORD dwSetParm,
    LPLSKeyPack lpKeyPack,
    PDWORD pdwErrCode
    )
/*++

++*/
{
    return TLSRpcKeyPackSetStatus( 
                            hHandle,
                            dwSetParm,
                            lpKeyPack,
                            pdwErrCode
                        );
}

//-----------------------------------------------------------------

DWORD WINAPI
TLSAnnounceServer(
    IN TLS_HANDLE hHandle,
    IN DWORD dwType,
    IN FILETIME* pftTime,
    IN LPTSTR pszSetupId,
    IN LPTSTR pszDomainName,
    IN LPTSTR pszMachineName,
    OUT PDWORD pdwErrCode
    )
/*++


++*/
{
    return TLSRpcAnnounceServer(
                        hHandle,
                        dwType,
                        pftTime,
                        pszSetupId,
                        pszDomainName,
                        pszMachineName,
                        pdwErrCode
                    );
}

//-----------------------------------------------------------------

DWORD WINAPI
TLSLookupServer(
    IN TLS_HANDLE hHandle,
    IN LPTSTR pszLookupSetupId,
    OUT LPTSTR pszLsSetupId,
    IN OUT PDWORD pcbSetupId,
    OUT LPTSTR pszDomainName,
    IN OUT PDWORD pcbDomainName,
    IN LPTSTR pszLsName,
    IN OUT PDWORD pcbMachineName,
    OUT PDWORD pdwErrCode
    )
/*++


++*/
{
    return TLSRpcLookupServer(
                        hHandle,
                        pszLookupSetupId,
                        pszLsSetupId,
                        pcbSetupId,
                        pszDomainName,
                        pcbDomainName,
                        pszLsName,
                        pcbMachineName,
                        pdwErrCode
                    );
}

//-----------------------------------------------------------------

DWORD WINAPI
TLSLookupServerFixed(
    IN TLS_HANDLE hHandle,
    IN LPTSTR pszLookupSetupId,
    OUT LPTSTR *pszLsSetupId,
    OUT LPTSTR *pszDomainName,
    OUT LPTSTR *pszLsName,
    IN OUT PDWORD pdwErrCode
    )
/*++


++*/
{
    return TLSRpcLookupServerFixed(
                        hHandle,
                        pszLookupSetupId,
                        pszLsSetupId,
                        pszDomainName,
                        pszLsName,
                        pdwErrCode
                    );
}

//-------------------------------------------------------

DWORD WINAPI
TLSAnnounceLicensePack(
    IN TLS_HANDLE hHandle,
    IN PTLSReplRecord pReplRecord,
    OUT PDWORD pdwErrCode
    )
/*++

++*/
{
    return TLSRpcAnnounceLicensePack(
                            hHandle,
                            pReplRecord,
                            pdwErrCode
                        );
}

//-------------------------------------------------------

DWORD WINAPI
TLSReturnLicensedProduct(
    IN TLS_HANDLE hHandle,
    IN PTLSLicenseToBeReturn pClientLicense,
    OUT PDWORD pdwErrCode
    )
/*++

++*/
{
    return TLSRpcReturnLicensedProduct(
                                hHandle,
                                pClientLicense,
                                pdwErrCode
                            );
}

//-------------------------------------------------------

DWORD WINAPI
TLSChallengeServer( 
    IN TLS_HANDLE hHandle,
    IN DWORD dwClientType,
    IN PTLSCHALLENGEDATA pClientChallenge,
    OUT PTLSCHALLENGERESPONSEDATA* ppServerResponse,
    OUT PTLSCHALLENGEDATA* ppServerChallenge,
    OUT PDWORD pdwErrCode
    )
/*++


--*/
{
    return TLSRpcChallengeServer(
                            hHandle,
                            dwClientType,
                            pClientChallenge,
                            ppServerResponse,
                            ppServerChallenge,
                            pdwErrCode
                        );
}

//-------------------------------------------------------

DWORD WINAPI
TLSResponseServerChallenge( 
    IN TLS_HANDLE hHandle,
    IN PTLSCHALLENGERESPONSEDATA pClientResponse,
    OUT PDWORD pdwErrCode
    )

/*++

--*/

{

    return TLSRpcResponseServerChallenge(
                                hHandle,
                                pClientResponse,
                                pdwErrCode
                            );
}

//------------------------------------------------------

DWORD WINAPI
TLSGetTlsPrivateData( 
    IN TLS_HANDLE hHandle,
    IN DWORD dwGetDataType,
    IN PTLSPrivateDataUnion pGetParm,
    OUT PDWORD pdwRetDataType,
    OUT PTLSPrivateDataUnion* ppRetData,
    OUT PDWORD pdwErrCode
    )
/*++

--*/
{
    return TLSRpcGetTlsPrivateData(
                                hHandle,
                                dwGetDataType,
                                pGetParm,
                                pdwRetDataType,
                                ppRetData,
                                pdwErrCode
                            );
}

//------------------------------------------------------

DWORD WINAPI
TLSTriggerReGenKey( 
    IN TLS_HANDLE hHandle,
    IN BOOL bKeepSPK,
    OUT PDWORD pdwErrCode
    )

/*++


--*/

{
    return TLSRpcTriggerReGenKey(
                            hHandle,
                            bKeepSPK,
                            pdwErrCode
                        );
}

//------------------------------------------------------
DWORD
GetPrivateBinaryDataFromServer(
    TLS_HANDLE hHandle,
    DWORD dwType,
    PDWORD pcbData,
    PBYTE* ppbData,
    PDWORD pdwErrCode
    )

/*++

--*/

{
    TLSPrivateDataUnion SearchParm;
    PTLSPrivateDataUnion pPrivateData = NULL;
    DWORD dwRetType;
    DWORD dwStatus;

    memset(
            &SearchParm, 
            0, 
            sizeof(TLSPrivateDataUnion)
        );

    dwStatus = TLSRpcGetTlsPrivateData(
                                hHandle,
                                dwType,
                                &SearchParm,
                                &dwRetType,
                                &pPrivateData,
                                pdwErrCode
                            );

    if(dwStatus != RPC_S_OK || *pdwErrCode != ERROR_SUCCESS)
    {
        goto cleanup;
    }

    if(dwRetType != dwType)
    {
        //
        // License Server error
        //
        *pdwErrCode = LSERVER_E_INVALID_RETURN;
        goto cleanup;
    }
     
    //
    // Copy over unique ID
    //
    *ppbData = (PBYTE)MIDL_user_allocate(pPrivateData->BinaryData.cbData);
    if(*ppbData != NULL)
    {
        memset(
                *ppbData, 
                0, 
                pPrivateData->BinaryData.cbData
            );

        *pcbData = pPrivateData->BinaryData.cbData;

        memcpy( 
            *ppbData,
            pPrivateData->BinaryData.pbData,
            pPrivateData->BinaryData.cbData
        );
    }
    else
    {
        *pdwErrCode = LSERVER_E_OUTOFMEMORY;
    }        

cleanup:

    if(pPrivateData != NULL)
    {
        midl_user_free(pPrivateData);
    }

    return dwStatus;
}  


//------------------------------------------------------

DWORD WINAPI
TLSGetServerPID(
    TLS_HANDLE hHandle,
    PDWORD pcbData,
    PBYTE* ppbData,
    PDWORD pdwErrCode
    )

/*++

--*/

{
    return GetPrivateBinaryDataFromServer(
                                        hHandle,
                                        TLS_PRIVATEDATA_PID,
                                        pcbData,
                                        ppbData,
                                        pdwErrCode
                                    );
}

//------------------------------------------------------

DWORD WINAPI
TLSGetServerSPK(
    TLS_HANDLE hHandle,
    PDWORD pcbData,
    PBYTE* ppbData,
    PDWORD pdwErrCode
    )

/*++

--*/

{
    TLSPrivateDataUnion SearchParm;
    PTLSPrivateDataUnion pPrivateData = NULL;
    DWORD dwRetType;
    DWORD dwStatus;

    memset(
            &SearchParm, 
            0, 
            sizeof(TLSPrivateDataUnion)
        );

    dwStatus = TLSRpcGetTlsPrivateData(
                                hHandle,
                                TLS_PRIVATEDATA_SPK,
                                &SearchParm,
                                &dwRetType,
                                &pPrivateData,
                                pdwErrCode
                            );

    if(dwStatus != RPC_S_OK || *pdwErrCode != ERROR_SUCCESS)
    {
        goto cleanup;
    }

    if(dwRetType != TLS_PRIVATEDATA_SPK)
    {
        //
        // License Server error
        //
        *pdwErrCode = LSERVER_E_INVALID_RETURN;
        goto cleanup;
    }
     
    //
    // Copy over Server's SPK.
    // Server never return CH's cert extension.
    //
    *ppbData = (PBYTE)MIDL_user_allocate(pPrivateData->SPK.cbSPK);
    if(*ppbData != NULL)
    {
        memset(
                *ppbData, 
                0, 
                pPrivateData->SPK.cbSPK
            );

        *pcbData = pPrivateData->SPK.cbSPK;

        memcpy( 
            *ppbData,
            pPrivateData->SPK.pbSPK,
            pPrivateData->SPK.cbSPK
        );
    }
    else
    {
        *pdwErrCode = LSERVER_E_OUTOFMEMORY;
    }        

cleanup:

    if(pPrivateData != NULL)
    {
        midl_user_free(pPrivateData);
    }

    return dwStatus;
}  


//-----------------------------------------------------------

DWORD WINAPI
TLSDepositeServerSPK(
    IN TLS_HANDLE hHandle,
    IN DWORD cbSPK,
    IN PBYTE pbSPK,
    IN PCERT_EXTENSIONS pCertExtensions,
    OUT PDWORD pdwErrCode
    )
/*++

--*/

{
    TLSPrivateDataUnion SetData;
    DWORD dwStatus;

    SetData.SPK.cbSPK = cbSPK;
    SetData.SPK.pbSPK = pbSPK;
    SetData.SPK.pCertExtensions = pCertExtensions;

    return TLSRpcSetTlsPrivateData( 
                            hHandle,
                            TLS_PRIVATEDATA_SPK,
                            &SetData,
                            pdwErrCode
                        );   
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\license\tlserver\tlsapiex\tlsapipex.cpp ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996-1998
//
// File:        tlsapip.cpp
//
// Contents:    Private API
//
// History:     09-09-97    HueiWang    Created
//
//---------------------------------------------------------------------------
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <tchar.h>
#include <rpc.h>
#include <lscommon.h>
#include <wincrypt.h>
#include "tlsrpc.h"
#include "tlsapip.h"

/*
void * MIDL_user_allocate(size_t size)
{
    return(HeapAlloc(GetProcessHeap(), 0, size));
}

void MIDL_user_free( void *pointer)
{
    HeapFree(GetProcessHeap(), 0, pointer);
}*/

DWORD WINAPI
TLSGenerateCustomerCert(
    IN TLS_HANDLE hHandle,
    DWORD dwCertEncodingType,
    DWORD dwNameAttrCount,
    CERT_RDN_ATTR rgNameAttr[],
    DWORD *pcbCert,
    BYTE **ppbCert,
    DWORD *pdwErrCode
    )
/*++

--*/

{
    return TLSRpcGenerateCustomerCert( 
                            hHandle,
                            dwCertEncodingType,
                            dwNameAttrCount,
                            rgNameAttr,
                            pcbCert,
                            ppbCert,
                            pdwErrCode
                        );   
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\license\tlserver\tlsdb\kpdesc.h ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996-1998
//
// File:        kpdesc.h
//
// Contents:    Licensed Pack Description Table
//
// History:     
//              
//---------------------------------------------------------------------------
#ifndef __TLS_KPDESC_H__
#define __TLS_KPDESC_H__

#include "JetBlue.h"
#include "TlsDb.h"

#define LICPACKDESCRECORD_TABLE_SEARCH_KEYPACKID      LSKEYPACK_SEARCH_KEYPACKID
#define LICPACKDESCRECORD_TABLE_SEARCH_LANGID         LSKEYPACK_SEARCH_LANGID
#define LICPACKDESCRECORD_TABLE_SEARCH_COMPANYNAME    LSKEYPACK_SEARCH_COMPANYNAME
#define LICPACKDESCRECORD_TABLE_SEARCH_PRODUCTNAME    LSKEYPACK_SEARCH_PRODUCTNAME
#define LICPACKDESCRECORD_TABLE_SEARCH_PRODUCTDESC    LSKEYPACK_SEARCH_PRODUCTDESC
 
#define LICPACKDESCRECORD_TABLE_PROCESS_KEYPACKID         LICPACKDESCRECORD_TABLE_SEARCH_KEYPACKID
#define LICPACKDESCRECORD_TABLE_PROCESS_LANGID            LICPACKDESCRECORD_TABLE_SEARCH_LANGID
#define LICPACKDESCRECORD_TABLE_PROCESS_COMPANYNAME       LICPACKDESCRECORD_TABLE_SEARCH_COMPANYNAME
#define LICPACKDESCRECORD_TABLE_PROCESS_PRODUCTNAME       LICPACKDESCRECORD_TABLE_SEARCH_PRODUCTNAME
#define LICPACKDESCRECORD_TABLE_PROCESS_PRODUCTDESC       LICPACKDESCRECORD_TABLE_SEARCH_PRODUCTDESC
#define LICPACKDESCRECORD_TABLE_PROCESS_LASTMODIFYTIME    0x80000000
#define LICPACKDESCRECORD_TABLE_PROCESS_ENTRYSTATUS       (LICPACKDESCRECORD_TABLE_PROCESS_LASTMODIFYTIME >> 1)
//
// Table definition for KeyPack Desc table
//
typedef TLSReplLicPackDesc LICPACKDESC;
typedef LICPACKDESC* LPLICPACKDESC;
typedef LICPACKDESC* PLICPACKDESC;

typedef LICPACKDESC LICPACKDESCRECORD;
typedef PLICPACKDESC PLICPACKDESCRECORD;
typedef LPLICPACKDESC LPLICPACKDESCRECORD;


#define LICPACKDESCRECORD_TABLE_NAME          _TEXT("LICPACKDESCRECORD")
#define LICPACKDESCRECORD_ID_COLUMN           _TEXT("InternalKeyPackId")
#define LICPACKDESCRECORD_LANGID              _TEXT("LangId")
#define LICPACKDESCRECORD_LASTMODIFYTIME      _TEXT("LastModifyTime")
#define LICPACKDESCRECORD_ENTRYSTATUS         _TEXT("EntryStatus")
#define LICPACKDESCRECORD_COMPANY_NAME        _TEXT("CompanyName")
#define LICPACKDESCRECORD_PRODUCT_NAME        _TEXT("ProductName")
#define LICPACKDESCRECORD_PRODUCT_DESC        _TEXT("ProductDesc")


//
// LICPACKDESCRECORD_KeyPackId_idx
//
#define LICPACKDESCRECORD_ID_INDEXNAME \
    LICPACKDESCRECORD_TABLE_NAME SEPERATOR LICPACKDESCRECORD_ID_COLUMN SEPERATOR INDEXNAME

//
// Primary Index on keyPack ID "+KeyPackId\0"
//
#define LICPACKDESCRECORD_ID_INDEXNAME_INDEXKEY \
    INDEX_SORT_ASCENDING LICPACKDESCRECORD_ID_COLUMN INDEX_END_COLNAME


//-------------------------------------------------------------
// Index structure for KeyPack description
//-------------------------------------------------------------
typedef struct __JBKPDescIndexKeyPackId : public JBKeyBase {
    //
    // Primay Index on KeyPack ID
    //
    DWORD dwKeyPackId;

    static LPCTSTR pszIndexName;
    static LPCTSTR pszIndexKey;

    //-----------------------------------------------
    __JBKPDescIndexKeyPackId(
        const LICPACKDESCRECORD& v
        ) : 
        JBKeyBase() 
    /*++
    ++*/
    {
        *this = v;
    }

    //-----------------------------------------------
    __JBKPDescIndexKeyPackId(
        const LICPACKDESCRECORD* v=NULL
        ) : 
        JBKeyBase() 
    /*++
    ++*/
    {
        if(v)
        {
            *this = *v;
        }
    }

    //-----------------------------------------------
    __JBKPDescIndexKeyPackId&
    operator=(const LICPACKDESCRECORD& v) {
        dwKeyPackId = v.dwKeyPackId;
        SetEmptyValue(FALSE);
        return *this;
    }

    //--------------------------------------------------------
    LPCTSTR
    GetIndexName() 
    {
        return pszIndexName;
    }

    //--------------------------------------------------------
    LPCTSTR
    GetIndexKey() 
    {
        return pszIndexKey;
    }

    //--------------------------------------------------------
    DWORD
    GetNumKeyComponents() { return 1; }

    //--------------------------------------------------------
    BOOL
    GetSearchKey(
        DWORD dwComponentIndex,
        PVOID* pbData,
        unsigned long* cbData,
        JET_GRBIT* grbit,
        DWORD dwSearchParm
        )
    /*++
    ++*/
    {
        if(dwComponentIndex >= GetNumKeyComponents())
        {
            JB_ASSERT(FALSE);
            return FALSE;
        }

        *pbData = &(dwKeyPackId);
        *cbData = sizeof(dwKeyPackId);
        *grbit = JET_bitNewKey;
        return TRUE;
    }

} TLSKpDescIndexKpId;


//-------------------------------------------------------------
//
// LICPACKDESCRECORD_KeyPackId_LangId_idx
//
#define LICPACKDESCRECORD_ID_LANGID_INDEXNAME \
    LICPACKDESCRECORD_TABLE_NAME SEPERATOR LICPACKDESCRECORD_ID_COLUMN SEPERATOR LICPACKDESCRECORD_LANGID SEPERATOR INDEXNAME

//
// "+KeyPackId\0+LangId\0"
//
#define LICPACKDESCRECORD_ID_LANGID_INDEXNAME_INDEXKEY \
    INDEX_SORT_ASCENDING LICPACKDESCRECORD_ID_COLUMN INDEX_END_COLNAME \
    INDEX_SORT_ASCENDING LICPACKDESCRECORD_LANGID INDEX_END_COLNAME

typedef struct __JBKPDescIndexKeyPackLangId : public JBKeyBase {
    //
    // Primary index on KeyPack and language Id
    //
    DWORD   dwKeyPackId;
    DWORD   dwLanguageId;

    static LPCTSTR pszIndexName;
    static LPCTSTR pszIndexKey;

    //---------------------------------------------------
    __JBKPDescIndexKeyPackLangId(
        const LICPACKDESCRECORD* v=NULL
        ) : 
        JBKeyBase() 
    /*++
    ++*/
    {
        if(v)
        {
            *this = *v;
        }
    }

    //---------------------------------------------------
    __JBKPDescIndexKeyPackLangId(
        const LICPACKDESCRECORD& v
        ) : 
        JBKeyBase() 
    /*++
    ++*/
    {
        *this = v;
    }

    //---------------------------------------------------
    __JBKPDescIndexKeyPackLangId&
    operator=(const LICPACKDESCRECORD& v) {
        dwKeyPackId = v.dwKeyPackId;
        dwLanguageId = v.dwLanguageId;

        SetEmptyValue(FALSE);
        return *this;
    }

    //--------------------------------------------------------
    LPCTSTR
    GetIndexName() 
    {
        return pszIndexName;
    }

    //--------------------------------------------------------
    LPCTSTR
    GetIndexKey() 
    {
        return pszIndexKey;
    }

    //--------------------------------------------------------
    DWORD
    GetNumKeyComponents() { return 2; }

    //--------------------------------------------------------
    BOOL
    GetSearchKey(
        DWORD dwComponentIndex,
        PVOID* pbData,
        unsigned long* cbData,
        JET_GRBIT* grbit,
        DWORD dwSearchParm
        )
    /*++
    ++*/
    {
        BOOL retCode = TRUE;

        if(dwComponentIndex >= GetNumKeyComponents())
        {
            JB_ASSERT(FALSE);
            return FALSE;
        }

        *cbData = 0;
        switch(dwComponentIndex)
        {
            case 0:
                *pbData = &dwKeyPackId;
                *cbData = sizeof(dwKeyPackId);
                *grbit = JET_bitNewKey;
                break;

            case 1:
                *pbData = &dwLanguageId;
                *cbData = sizeof(dwLanguageId);
                *grbit = 0;
                break;

            default:
                JB_ASSERT(FALSE);
                retCode = FALSE;
                break;
        }

        return retCode;
    }

} TLSKpDescIndexKpLangId;


/////////////////////////////////////////////////////////////////////////

// KeyPack_LastModifyTime_idx
//
#define LICPACKDESCRECORD_LASTMODIFYTIME_INDEXNAME \
    LICPACKDESCRECORD_TABLE_NAME SEPERATOR LICPACKDESCRECORD_LASTMODIFYTIME SEPERATOR INDEXNAME

//
// Index  "+LastModifyTime\0"
//
#define LICPACKDESCRECORD_LASTMODIFYTIME_INDEXNAME_INDEXKEY \
    INDEX_SORT_ASCENDING LICPACKDESCRECORD_LASTMODIFYTIME INDEX_END_COLNAME

typedef struct __LICPACKDESCRECORDIdxOnModifyTime : public JBKeyBase {
    FILETIME ftLastModifyTime;

    static LPCTSTR pszIndexName;
    static LPCTSTR pszIndexKey;

    //--------------------------------------------------------
    __LICPACKDESCRECORDIdxOnModifyTime(
        const LICPACKDESCRECORD& v
        ) : 
        JBKeyBase() 
    /*++
    ++*/
    {
        *this = v;
    }

    //--------------------------------------------------------
    __LICPACKDESCRECORDIdxOnModifyTime(
        const LICPACKDESCRECORD* v=NULL
        ) : 
        JBKeyBase() 
    /*++
    ++*/
    {
        if(v)
        {
            *this = *v;
        }
    }

    //--------------------------------------------------------
    __LICPACKDESCRECORDIdxOnModifyTime&
    operator=(const LICPACKDESCRECORD& v) {
        ftLastModifyTime = v.ftLastModifyTime;
        SetEmptyValue(FALSE);
        return *this;
    }

    //--------------------------------------------------------
    LPCTSTR
    GetIndexName() 
    {
        return pszIndexName;
    }

    //--------------------------------------------------------
    LPCTSTR
    GetIndexKey() 
    {
        return pszIndexKey;
    }

    //--------------------------------------------------------
    DWORD
    GetNumKeyComponents() { return 1; }

    //--------------------------------------------------------
    BOOL
    GetSearchKey(
        DWORD dwComponentIndex,
        PVOID* pbData,
        unsigned long* cbData,
        JET_GRBIT* grbit,
        DWORD dwSearchParm
        )
    /*++
    ++*/
    {
        if(dwComponentIndex >= GetNumKeyComponents())
        {
            JB_ASSERT(FALSE);
            return FALSE;
        }

        *pbData = &(ftLastModifyTime);
        *cbData = sizeof(ftLastModifyTime);
        *grbit = JET_bitNewKey;
        return TRUE;
    }
} TLSLICPACKDESCRECORDIndexLastModifyTime;


//
///////////////////////////////////////////////////////////////////////
//

//
///////////////////////////////////////////////////////////////////////
//
class LicPackDescTable : public TLSTable<LICPACKDESCRECORD>
{
private:

    static LPCTSTR pszTableName;
    
    TLSColumnUchar  ucEntryStatus;
    TLSColumnDword  dwKeyPackId;
    TLSColumnDword  dwLanguageId;    
    TLSColumnFileTime ftLastModifyTime;
    TLSColumnText   szCompanyName;
    TLSColumnText   szProductName;
    TLSColumnText   szProductDesc;

    BOOL
    ProcessSingleColumn(
        BOOL bFetch,
        TLSColumnBase& column,
        DWORD offset,
        PVOID pbData,
        DWORD cbData,
        PDWORD pcbDataReturn,
        LPCTSTR szColumnName
    );

    BOOL
    ProcessRecord(
        LICPACKDESCRECORD* v,
        BOOL bFetch,        // TRUE - fetch, FALSE insert
        DWORD dwParam,
        BOOL bUpdate
    );

public:
    virtual LPCTSTR
    GetTableName() 
    {
        return pszTableName;
    }

    //--------------------------------------------------------
    LicPackDescTable(
        JBDatabase& database
        ) : TLSTable<LICPACKDESCRECORD>(database)
    /*
    */
    {
    }

    //--------------------------------------------------------
    virtual BOOL
    ResolveToTableColumn();

    //--------------------------------------------------------
    virtual BOOL
    FetchRecord(
        LICPACKDESCRECORD& kpRecord,
        DWORD dwParam=PROCESS_ALL_COLUMNS
        )
    /*
    */
    {
        if(IsValid() == FALSE)
        {
            DebugOutput( 
                    _TEXT("Table %s is not valid...\n"),
                    GetTableName()
                );

            JB_ASSERT(FALSE);
            SetLastJetError(JET_errInvalidParameter);
            return FALSE;
        }

        //CCriticalSectionLocker Lock(GetTableLock());

        return ProcessRecord(&kpRecord, TRUE, dwParam, FALSE);
    }

    //--------------------------------------------------------
    virtual BOOL
    InsertRecord(
        LICPACKDESCRECORD& kpRecord,
        DWORD dwParam=PROCESS_ALL_COLUMNS
        )
    /*
    */
    {
        if(IsValid() == FALSE)
        {
            DebugOutput( 
                    _TEXT("Table %s is not valid...\n"),
                    GetTableName()
                );

            JB_ASSERT(FALSE);
            SetLastJetError(JET_errInvalidParameter);
            return FALSE;
        }

        //CCriticalSectionLocker Lock(GetTableLock());

        return ProcessRecord(&kpRecord, FALSE, dwParam, FALSE);
    }

    //-------------------------------------------------------
    virtual BOOL
    UpdateRecord(
        LICPACKDESCRECORD& kpRecord,
        DWORD dwParam=PROCESS_ALL_COLUMNS
        )
    /*
    */
    {
        if(IsValid() == FALSE)
        {
            DebugOutput( 
                    _TEXT("Table %s is not valid...\n"),
                    GetTableName()
                );

            JB_ASSERT(FALSE);
            SetLastJetError(JET_errInvalidParameter);
            return FALSE;
        }

        //CCriticalSectionLocker Lock(GetTableLock());

        return ProcessRecord(&kpRecord, FALSE, dwParam, TRUE);
    }

    //-------------------------------------------------------
    virtual BOOL
    Initialize() { return TRUE; }

    //-------------------------------------------------------
    virtual JBKeyBase*
    EnumerationIndex( 
        IN BOOL bMatchAll,
        IN DWORD dwParam,
        IN LICPACKDESCRECORD* kpDesc,
        IN OUT BOOL* bCompareKey
    );
    
    virtual BOOL
    EqualValue(
        LICPACKDESCRECORD& s1,
        LICPACKDESCRECORD& s2,
        BOOL bMatchAll,
        DWORD dwParam
    );
   
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\license\tlserver\tlsdb\backup.cpp ===
//+--------------------------------------------------------------------------
//
// Copyright (c) 1997-1999 Microsoft Corporation
//
// File:       backup.cpp 
//
// Contents:    
//
// History:     
//
//---------------------------------------------------------------------------
#include "backup.h"


LPCTSTR __BackupSourceIdxOnServerName::pszIndexName = BACKUPSOURCE_INDEX_LSERVERNAME_INDEXNAME;
LPCTSTR __BackupSourceIdxOnServerName::pszIndexKey = BACKUPSOURCE_INDEX_LSERVERNAME_INDEXKEY;

LPCTSTR __BackupSourceIdxOnSetupId::pszIndexName = BACKUPSOURCE_INDEX_LSSETUPID_INDEXNAME;
LPCTSTR __BackupSourceIdxOnSetupId::pszIndexKey = BACKUPSOURCE_INDEX_LSSETUPID_INDEXKEY;

LPCTSTR BackupSourceTable::pszTableName = BACKUPSOURCE_TABLE_NAME;

//----------------------------------------------------
CCriticalSection BackupSourceTable::g_TableLock;

//----------------------------------------------------
TLSJBIndex
BackupSourceTable::g_TableIndex[] =
{
    {
        BACKUPSOURCE_INDEX_LSERVERNAME_INDEXNAME,
        BACKUPSOURCE_INDEX_LSERVERNAME_INDEXKEY,
        -1,
        JET_bitIndexIgnoreNull,
        TLSTABLE_INDEX_DEFAULT_DENSITY
    },

    {
        BACKUPSOURCE_INDEX_LSSETUPID_INDEXNAME,
        BACKUPSOURCE_INDEX_LSSETUPID_INDEXKEY,
        -1,
        JET_bitIndexIgnoreNull,
        TLSTABLE_INDEX_DEFAULT_DENSITY
    }
};

int 
BackupSourceTable::g_NumTableIndex = sizeof(BackupSourceTable::g_TableIndex) / sizeof(BackupSourceTable::g_TableIndex[0]);

TLSJBColumn
BackupSourceTable::g_Columns[] =
{
    {
        BACKUPSOURCE_COLUMN_LSERVERNAME,
        JB_COLTYPE_TEXT,
        (MAX_JETBLUE_TEXT_LENGTH + 1)*sizeof(TCHAR),
        0,
        JBSTRING_NULL,
        _tcslen(JBSTRING_NULL),
        TLS_JETBLUE_COLUMN_CODE_PAGE,
        TLS_JETBLUE_COLUMN_COUNTRY_CODE,
        TLS_JETBLUE_COLUMN_LANGID
    },

    {
        BACKUPSOURCE_COLUMN_LSSETUPID,
        JB_COLTYPE_TEXT,
        (MAX_JETBLUE_TEXT_LENGTH + 1)*sizeof(TCHAR),
        0,
        JBSTRING_NULL,
        _tcslen(JBSTRING_NULL),
        TLS_JETBLUE_COLUMN_CODE_PAGE,
        TLS_JETBLUE_COLUMN_COUNTRY_CODE,
        TLS_JETBLUE_COLUMN_LANGID
    },

    {
        BACKUPSOURCE_COLUMN_DOMAINSID,
        JET_coltypLongBinary,
        TLSTABLE_MAX_BINARY_LENGTH,
        0,
        NULL,
        0,
        TLS_JETBLUE_COLUMN_CODE_PAGE,
        TLS_JETBLUE_COLUMN_COUNTRY_CODE,
        TLS_JETBLUE_COLUMN_LANGID
    },

    {
        BACKUPSOURCE_COLUMN_DBFILENAME,
        JB_COLTYPE_TEXT,
        (MAX_PATH + 1)*sizeof(TCHAR),
        0,
        NULL,
        0,
        TLS_JETBLUE_COLUMN_CODE_PAGE,
        TLS_JETBLUE_COLUMN_COUNTRY_CODE,
        TLS_JETBLUE_COLUMN_LANGID
    },

    {
        BACKUPSOURCE_COLUMN_LASTBACKUPTIME,
        JET_coltypBinary,
        sizeof(FILETIME),
        JET_bitColumnNotNULL,
        NULL,
        0,
        TLS_JETBLUE_COLUMN_CODE_PAGE,
        TLS_JETBLUE_COLUMN_COUNTRY_CODE,
        TLS_JETBLUE_COLUMN_LANGID
    },

    {
        BACKUPSOURCE_COLUMN_LASTRESTORETIME,
        JET_coltypBinary,
        sizeof(FILETIME),
        JET_bitColumnNotNULL,
        NULL,
        0,
        TLS_JETBLUE_COLUMN_CODE_PAGE,
        TLS_JETBLUE_COLUMN_COUNTRY_CODE,
        TLS_JETBLUE_COLUMN_LANGID
    }
};

int
BackupSourceTable::g_NumColumns=sizeof(BackupSourceTable::g_Columns) / sizeof(BackupSourceTable::g_Columns[0]);

//-------------------------------------------------------------
JBKeyBase* 
BackupSourceTable::EnumerationIndex( 
    BOOL bMatchAll,
    DWORD dwSearchParam,
    BACKUPSOURCERECORD* pRecord,
    BOOL* bCompareKey
    )
/*
*/
{
    JBKeyBase* index;

    if(dwSearchParam & BACKUPSOURCE_PROCESS_LSSETUPID)
    {
        index = new TLSBckSrcIdxSetupId(pRecord);
    }
    else
    {
        index = new TLSBckSrcIdxServerName(pRecord);
    }
           
    *bCompareKey = bMatchAll;
    return index;
}    

//------------------------------------------------------------
BOOL
BackupSourceTable::EqualValue(
    BACKUPSOURCERECORD& s1,
    BACKUPSOURCERECORD& s2,
    BOOL bMatchAll,
    DWORD dwParam
    )
/*
*/
{
    BOOL bRetCode = TRUE;


    if(dwParam & BACKUPSOURCE_PROCESS_LSSETUPID)
    {
        bRetCode = (_tcscmp(s1.szInstallId, s2.szInstallId) == 0);
        if(bRetCode != bMatchAll)
            goto cleanup;
    }

    if(dwParam & BACKUPSOURCE_PROCESS_SERVERNAME)
    {
        bRetCode = (_tcsicmp(s1.szTlsServerName, s2.szTlsServerName) == 0);
        if(bRetCode != bMatchAll)
            goto cleanup;
    }

    //if(dwParam & BACKUPSOURCE_PROCESS_DOMAINSID)
    //{
    //    bRetCode = EqualSid(s1.pbDomainSid, s2.pbDomainSid);
    //    if(bRetCode != bMatchAll)
    //        goto cleanup;
    //}

    if(dwParam & BACKUPSOURCE_PROCESS_FILENAME)
    {
        bRetCode = (_tcsicmp(s1.szFileName, s2.szFileName) == 0);
        if(bRetCode != bMatchAll)
            goto cleanup;
    }

    if(dwParam & BACKUPSOURCE_PROCESS_BACKUPTIME)
    {
        bRetCode = (CompareFileTime(&s1.ftLastBackupTime, &s2.ftLastBackupTime) == 0);
        if(bRetCode != bMatchAll)
            goto cleanup;
    }

    if(dwParam & BACKUPSOURCE_PROCESS_RESTORETIME)
    {
        bRetCode = (CompareFileTime(&s1.ftLastRestoreTime, &s2.ftLastRestoreTime) == 0);
    }

cleanup:
    return bRetCode;
}

//----------------------------------------------------
BOOL
BackupSourceTable::ResolveToTableColumn()
/*
*/
{
    m_JetErr = szInstallId.AttachToTable(
                            *this,
                            BACKUPSOURCE_COLUMN_LSSETUPID
                        );

    if(IsSuccess() == FALSE)
    {
        DebugOutput(
                _TEXT("Can't find column %s in table %s\n"),
                BACKUPSOURCE_COLUMN_LSSETUPID,
                GetTableName()
            );

        goto cleanup;
    }
    
    m_JetErr = szTlsServerName.AttachToTable(
                            *this,
                            BACKUPSOURCE_COLUMN_LSERVERNAME
                        );

    if(IsSuccess() == FALSE)
    {
        DebugOutput(
                _TEXT("Can't find column %s in table %s\n"),
                BACKUPSOURCE_COLUMN_LSERVERNAME,
                GetTableName()
            );

        goto cleanup;
    }

    m_JetErr = pbDomainSid.AttachToTable(
                            *this,
                            BACKUPSOURCE_COLUMN_DOMAINSID
                        );

    if(IsSuccess() == FALSE)
    {
        DebugOutput(
                _TEXT("Can't find column %s in table %s\n"),
                BACKUPSOURCE_COLUMN_DOMAINSID,
                GetTableName()
            );

        goto cleanup;
    }

    m_JetErr = szFileName.AttachToTable(
                            *this,
                            BACKUPSOURCE_COLUMN_DBFILENAME
                        );

    if(IsSuccess() == FALSE)
    {
        DebugOutput(
                _TEXT("Can't find column %s in table %s\n"),
                BACKUPSOURCE_PROCESS_FILENAME,
                GetTableName()
            );

        goto cleanup;
    }


    m_JetErr = ftLastBackupTime.AttachToTable(
                            *this,
                            BACKUPSOURCE_COLUMN_LASTBACKUPTIME
                        );

    if(IsSuccess() == FALSE)
    {
        DebugOutput(
                _TEXT("Can't find column %s in table %s\n"),
                BACKUPSOURCE_COLUMN_LASTBACKUPTIME,
                GetTableName()
            );

        goto cleanup;
    }

    m_JetErr = ftLastRestoreTime.AttachToTable(
                            *this,
                            BACKUPSOURCE_COLUMN_LASTRESTORETIME
                        );

    if(IsSuccess() == FALSE)
    {
        DebugOutput(
                _TEXT("Can't find column %s in table %s\n"),
                BACKUPSOURCE_COLUMN_LASTRESTORETIME,
                GetTableName()
            );
    }

cleanup:
    return IsSuccess();
}

//----------------------------------------------------
CLASS_PRIVATE BOOL
BackupSourceTable::ProcessSingleColumn(
    IN BOOL bFetch,
    IN TLSColumnBase& column,
    IN DWORD offset,
    IN PVOID pbData,
    IN DWORD cbData,
    IN PDWORD pcbDataReturn,
    IN LPCTSTR szColumnName
    )
/*

Abstract:

    Fetch/Insert/Update a particular column.

Parameter:

    bFetch - TRUE if fetch, FALSE if update/insert.
    column - Intended column for operation, reference pointer to TLSColumn
    szColumnName - name of the column, for debugging print purpose only

Returns:

    TRUE if successful, FALSE otherwise.
*/
{
    if(bFetch) 
    {
        m_JetErr = column.FetchColumnValue(
                                    pbData, 
                                    cbData, 
                                    offset, 
                                    pcbDataReturn
                                );
    }
    else
    {
        m_JetErr = column.InsertColumnValue(
                                    pbData, 
                                    cbData, 
                                    offset
                                );
    }

    REPORTPROCESSFAILED(
            bFetch,
            GetTableName(),
            szColumnName,
            m_JetErr
        );
    return IsSuccess();
}

//---------------------------------------------------------
CLASS_PRIVATE BOOL
BackupSourceTable::ProcessRecord(
    BACKUPSOURCERECORD* bkRecord,
    BOOL bFetch,
    DWORD dwParam,
    BOOL bUpdate
    )
/*
*/
{ 
    DWORD dwSize;

    if(bFetch == FALSE)
    {
        BeginUpdate(bUpdate);
    }
    else
    {
        SetLastJetError(JET_errSuccess);
    }

    if(IsSuccess() == FALSE)
        goto cleanup;            

    if(dwParam & BACKUPSOURCE_PROCESS_LSSETUPID)
    {
        ProcessSingleColumn(
                    bFetch,
                    szInstallId,
                    0,
                    bkRecord->szInstallId,
                    sizeof(bkRecord->szInstallId),
                    &dwSize,
                    BACKUPSOURCE_COLUMN_LSSETUPID
                );

    }

    if(IsSuccess() == FALSE)
        goto cleanup;            
    
    if(dwParam & BACKUPSOURCE_PROCESS_SERVERNAME)
    {
        ProcessSingleColumn(
                    bFetch,
                    szTlsServerName,
                    0,
                    bkRecord->szTlsServerName,
                    sizeof(bkRecord->szTlsServerName),
                    &dwSize,
                    BACKUPSOURCE_COLUMN_LSERVERNAME
                );

    }

    if(IsSuccess() == FALSE)
        goto cleanup;            

#if 0
    // no more domain SID
    if(dwParam & BACKUPSOURCE_PROCESS_DOMAINSID)
    {
        if(bFetch == TRUE)
        {
            DWORD size=0;

            m_JetErr = pbDomainSid.FetchColumnValue(
                                        NULL,
                                        0,
                                        0,
                                        &size
                                    );

            if(bkRecord->cbDomainSid < size || bkRecord->pbDomainSid == NULL)
            {
                FreeMemory(bkRecord->pbDomainSid);
                bkRecord->pbDomainSid = (PSID)AllocateMemory(bkRecord->cbDomainSid = size);
                if(bkRecord->pbDomainSid == NULL)
                {
                    SetLastJetError(JET_errOutOfMemory);
                    goto cleanup;
                }
            }

            m_JetErr = pbDomainSid.FetchColumnValue(
                                        bkRecord->pbDomainSid,
                                        bkRecord->cbDomainSid,
                                        0,
                                        &bkRecord->cbDomainSid
                                    );
        }
        else
        {
            ProcessSingleColumn(
                        bFetch,
                        pbDomainSid,
                        0,
                        bkRecord->pbDomainSid,
                        bkRecord->cbDomainSid,
                        &dwSize,
                        BACKUPSOURCE_COLUMN_DOMAINSID
                    );
        }
    }

    if(IsSuccess() == FALSE)
        goto cleanup;            
#endif

    if(dwParam & BACKUPSOURCE_PROCESS_FILENAME)
    {
        ProcessSingleColumn(
                    bFetch,
                    szFileName,
                    0,
                    bkRecord->szFileName,
                    sizeof(bkRecord->szFileName),
                    &dwSize,
                    BACKUPSOURCE_COLUMN_DBFILENAME
                );
    }

    if(IsSuccess() == FALSE)
        goto cleanup;            

    if(dwParam & BACKUPSOURCE_PROCESS_BACKUPTIME)
    {
        ProcessSingleColumn(
                    bFetch,
                    ftLastBackupTime,
                    0,
                    &(bkRecord->ftLastBackupTime),
                    sizeof(bkRecord->ftLastBackupTime),
                    &dwSize,
                    BACKUPSOURCE_COLUMN_LASTBACKUPTIME
                );
    }

    if(IsSuccess() == FALSE)
        goto cleanup;            

    if(dwParam & BACKUPSOURCE_PROCESS_RESTORETIME)
    {
        ProcessSingleColumn(
                    bFetch,
                    ftLastRestoreTime,
                    0,
                    &(bkRecord->ftLastRestoreTime),
                    sizeof(bkRecord->ftLastRestoreTime),
                    &dwSize,
                    BACKUPSOURCE_COLUMN_LASTRESTORETIME
                );
    }

cleanup:
    // 
    // For inserting/updating record
    if(bFetch == FALSE)
    {
        JET_ERR jetErr;
        jetErr = GetLastJetError();

        EndUpdate(IsSuccess() == FALSE);

        if(jetErr != JET_errSuccess  && IsSuccess() == FALSE)
            SetLastJetError(jetErr);
    }

    return IsSuccess();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\license\tlserver\tlsdb\backup.h ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996-1998
//
// File:        backup.h
//
// Contents:    backupsource Table
//
// History:     
//              
//---------------------------------------------------------------------------
#ifndef __BACKUP_SOURCE_H__
#define __BACKUP_SOURCE_H__
#include "tlsdb.h"


//
// re-direct define using what's in tlsdef.h just for backward compatibility
//
#define BACKUPSOURCE_PROCESS_LSSETUPID          0x00000001
#define BACKUPSOURCE_PROCESS_SERVERNAME         (BACKUPSOURCE_PROCESS_LSSETUPID << 1)
#define BACKUPSOURCE_PROCESS_DOMAINSID          (BACKUPSOURCE_PROCESS_LSSETUPID << 2)
#define BACKUPSOURCE_PROCESS_FILENAME           (BACKUPSOURCE_PROCESS_LSSETUPID << 3)
#define BACKUPSOURCE_PROCESS_BACKUPTIME         (BACKUPSOURCE_PROCESS_LSSETUPID << 4)
#define BACKUPSOURCE_PROCESS_RESTORETIME        (BACKUPSOURCE_PROCESS_LSSETUPID << 5)

//
// Licensed KeyPack Table
//
#define BACKUPSOURCE_TABLE_NAME                     _TEXT("BackupSource")

#define BACKUPSOURCE_COLUMN_LSERVERNAME             _TEXT("ServerName")
#define BACKUPSOURCE_COLUMN_LSSETUPID               _TEXT("TLSSetupId")
#define BACKUPSOURCE_COLUMN_DOMAINSID               _TEXT("TLSDomainSetupId")
#define BACKUPSOURCE_COLUMN_DBFILENAME              _TEXT("DbFileName")
#define BACKUPSOURCE_COLUMN_LASTBACKUPTIME          _TEXT("LastBackupTime")
#define BACKUPSOURCE_COLUMN_LASTRESTORETIME         _TEXT("LastRestoreTime")

typedef struct __BackSourceRecord {
    TCHAR       szInstallId[MAX_JETBLUE_TEXT_LENGTH+1];
    TCHAR       szTlsServerName[MAX_JETBLUE_TEXT_LENGTH+1];
    PSID        pbDomainSid;
    DWORD       cbDomainSid;
    TCHAR       szFileName[MAX_PATH+1];
    FILETIME    ftLastBackupTime;       // last backup time
    FILETIME    ftLastRestoreTime;      // last restore time

    __BackSourceRecord() : pbDomainSid(NULL), cbDomainSid(0) {}

    ~__BackSourceRecord() 
    {
        if(pbDomainSid != NULL)
        {
            FreeMemory(pbDomainSid);
        }
    }

    __BackSourceRecord(
        const __BackSourceRecord& v
        )
    /*++
    ++*/
    {
        *this = v;
    }

    __BackSourceRecord&
    operator=(const __BackSourceRecord& v)
    {
        BOOL bSuccess;

        if(this == &v)
            return *this;

        _tcscpy(szInstallId, v.szInstallId);
        _tcscpy(szTlsServerName, v.szTlsServerName);
        _tcscpy(szFileName, v.szFileName);
        ftLastBackupTime = v.ftLastBackupTime;
        ftLastRestoreTime = v.ftLastRestoreTime;

        bSuccess = TLSDBCopySid(
                        v.pbDomainSid,
                        v.cbDomainSid,
                        &pbDomainSid,
                        &cbDomainSid
                    );

        JB_ASSERT(bSuccess == TRUE);

        return *this;
    }
    
} BACKUPSOURCERECORD, *LPBACKUPSOURCERECORD, *PBACKUPSOURCERECORD;


//
//
// Index structure for backupsource Table
//
//

////////////////////////////////////////////////////////////////
//
//  Index on szInstallId
//
////////////////////////////////////////////////////////////////

// KeyPack_KeyPackId_idx
//
#define BACKUPSOURCE_INDEX_LSERVERNAME_INDEXNAME \
    BACKUPSOURCE_TABLE_NAME SEPERATOR BACKUPSOURCE_COLUMN_LSERVERNAME SEPERATOR INDEXNAME

//
// Primary Index on KeyPack ID "+KeyPackId\0"
//
#define BACKUPSOURCE_INDEX_LSERVERNAME_INDEXKEY \
    INDEX_SORT_ASCENDING BACKUPSOURCE_COLUMN_LSERVERNAME INDEX_END_COLNAME

typedef struct __BackupSourceIdxOnServerName : public JBKeyBase {
    TCHAR szTlsServerName[MAX_JETBLUE_TEXT_LENGTH+1];

    static LPCTSTR pszIndexName;
    static LPCTSTR pszIndexKey;

    //--------------------------------------------------------
    __BackupSourceIdxOnServerName(
        const BACKUPSOURCERECORD& v
        ) : 
        JBKeyBase() 
    /*++
    ++*/
    {
        *this = v;
    }

    //--------------------------------------------------------
    __BackupSourceIdxOnServerName(
        const BACKUPSOURCERECORD* v=NULL
        ) : 
        JBKeyBase() 
    /*++
    ++*/
    {
        if(v)
        {
            *this = *v;
        }
    }

    //--------------------------------------------------------
    __BackupSourceIdxOnServerName&
    operator=(const BACKUPSOURCERECORD& v) 
    {
        _tcscpy(szTlsServerName, v.szTlsServerName);
        SetEmptyValue(FALSE);
        return *this;
    }

    //--------------------------------------------------------
    LPCTSTR
    GetIndexName() 
    {
        return pszIndexName;
    }

    //--------------------------------------------------------
    LPCTSTR
    GetIndexKey() 
    {
        return pszIndexKey;
    }

    //--------------------------------------------------------
    DWORD
    GetNumKeyComponents() 
    { 
        return 1; 
    }

    //--------------------------------------------------------
    BOOL
    GetSearchKey(
        DWORD dwComponentIndex,
        PVOID* pbData,
        unsigned long* cbData,
        JET_GRBIT* grbit,
        DWORD dwSearchParm
        )
    /*++
    ++*/
    {
        if(dwComponentIndex >= GetNumKeyComponents())
        {
            JB_ASSERT(FALSE);
            return FALSE;
        }

        *pbData = szTlsServerName;
        *cbData = _tcslen(szTlsServerName) * sizeof(TCHAR);
        *grbit = JET_bitNewKey;
        return TRUE;
    }
} TLSBckSrcIdxServerName;


////////////////////////////////////////////////////////////////
//
//  Index on EntryLastModifyTime
//
//
////////////////////////////////////////////////////////////////

//
// Index name
//
#define BACKUPSOURCE_INDEX_LSSETUPID_INDEXNAME \
    BACKUPSOURCE_TABLE_NAME SEPERATOR BACKUPSOURCE_COLUMN_LSSETUPID SEPERATOR INDEXNAME

//
// Index key
//
#define BACKUPSOURCE_INDEX_LSSETUPID_INDEXKEY \
    INDEX_SORT_ASCENDING BACKUPSOURCE_COLUMN_LSSETUPID INDEX_END_COLNAME

typedef struct __BackupSourceIdxOnSetupId : public JBKeyBase {
    static LPCTSTR pszIndexName;
    static LPCTSTR pszIndexKey;

    TCHAR szInstallId[MAX_JETBLUE_TEXT_LENGTH+1];

    //--------------------------------------------------------
    __BackupSourceIdxOnSetupId(
        const BACKUPSOURCERECORD& v
        ) : 
        JBKeyBase() 
    /*++
    ++*/
    {
        *this = v;
    }

    //--------------------------------------------------------
    __BackupSourceIdxOnSetupId(
        const BACKUPSOURCERECORD* v=NULL
        ) : 
        JBKeyBase() 
    /*++
    ++*/
    {
        if(v)
        {
            *this = *v;
        }
    }

    //--------------------------------------------------------
    __BackupSourceIdxOnSetupId&
    operator=(const BACKUPSOURCERECORD& v) 
    {
        _tcscpy(szInstallId, v.szInstallId);
        SetEmptyValue(FALSE);
        return *this;
    }

    //--------------------------------------------------------
    LPCTSTR
    GetIndexName() 
    {
        return pszIndexName;
    }

    //--------------------------------------------------------
    LPCTSTR
    GetIndexKey() 
    {
        return pszIndexName;
    }

    //--------------------------------------------------------
    DWORD
    GetNumKeyComponents() 
    { 
        return 1; 
    }

    //--------------------------------------------------------
    BOOL
    GetSearchKey(
        DWORD dwComponentIndex,
        PVOID* pbData,
        unsigned long* cbData,
        JET_GRBIT* grbit,
        DWORD dwSearchParm
        )
    /*++
    ++*/
    {
        if(dwComponentIndex >= GetNumKeyComponents())
        {
            JB_ASSERT(FALSE);
            return FALSE;
        }

        *pbData = szInstallId;
        *cbData = _tcslen(szInstallId)*sizeof(TCHAR);
        *grbit = JET_bitNewKey;
        return TRUE;
    }
} TLSBckSrcIdxSetupId;


// -----------------------------------------------------------
//
//  LicensedPackStatus Table
//
// -----------------------------------------------------------
class BackupSourceTable : public TLSTable<BACKUPSOURCERECORD>  {
private:
    static LPCTSTR pszTableName;

    BOOL
    ProcessSingleColumn(
        BOOL bFetch,
        TLSColumnBase& column,
        DWORD offset,
        PVOID pbData,
        DWORD cbData,
        PDWORD pcbDataReturn,
        LPCTSTR szColumnName
    );

    BOOL
    ProcessRecord(
        BACKUPSOURCERECORD* v,
        BOOL bFetch,        // TRUE - fetch, FALSE insert
        DWORD dwParam,
        BOOL bUpdate
    );    

public:
    TLSColumnText   szInstallId;
    TLSColumnText   szTlsServerName;
    TLSColumnBinary pbDomainSid;
    TLSColumnText   szFileName;
    TLSColumnFileTime ftLastBackupTime;
    TLSColumnFileTime ftLastRestoreTime;

    //-----------------------------------------------------
    virtual LPCTSTR
    GetTableName() 
    {
        return pszTableName;
    }
    

    //-----------------------------------------------------
    BackupSourceTable(JBDatabase& database) : TLSTable<BACKUPSOURCERECORD>(database)
    /*
    */
    {
    }

    //-----------------------------------------------------
    virtual BOOL
    ResolveToTableColumn();

    //-----------------------------------------------------
    virtual BOOL
    FetchRecord(
        BACKUPSOURCERECORD& v,
        DWORD dwParam=PROCESS_ALL_COLUMNS
        )
    /*
    */
    {
        if(IsValid() == FALSE)
        {
            DebugOutput( 
                    _TEXT("Table %s is not valid...\n"),
                    GetTableName()
                );

            JB_ASSERT(FALSE);
            SetLastJetError(JET_errInvalidParameter);
            return FALSE;
        }

        //CCriticalSectionLocker Lock(GetTableLock());

        return ProcessRecord(&v, TRUE, dwParam, FALSE);
    }

    //-----------------------------------------------------
    virtual BOOL
    InsertRecord(
        BACKUPSOURCERECORD& v,
        DWORD dwParam=PROCESS_ALL_COLUMNS
        )
    /*
    */
    {
        if(IsValid() == FALSE)
        {
            DebugOutput( 
                    _TEXT("Table %s is not valid...\n"),
                    GetTableName()
                );

            JB_ASSERT(FALSE);
            SetLastJetError(JET_errInvalidParameter);
            return FALSE;
        }

        //CCriticalSectionLocker Lock(GetTableLock());

        return ProcessRecord(&v, FALSE, dwParam, FALSE);
    }

    //-----------------------------------------------------
    virtual BOOL
    UpdateRecord(
        BACKUPSOURCERECORD& v,
        DWORD dwParam=PROCESS_ALL_COLUMNS
        )
    /*
    */
    {
        if(IsValid() == FALSE)
        {
            DebugOutput( 
                    _TEXT("Table %s is not valid...\n"),
                    GetTableName()
                );

            JB_ASSERT(FALSE);
            SetLastJetError(JET_errInvalidParameter);
            return FALSE;
        }

        //CCriticalSectionLocker Lock(GetTableLock());

        return ProcessRecord(&v, FALSE, dwParam, TRUE);
    }

    //-------------------------------------------------------
    virtual BOOL
    Initialize() 
    { 
        return TRUE; 
    }

    //-------------------------------------------------------
    virtual JBKeyBase*
    EnumerationIndex( 
        IN BOOL bMatchAll,
        IN DWORD dwParam,
        IN BACKUPSOURCERECORD* kp,
        IN OUT BOOL* bCompareKey
    );
    
    virtual BOOL
    EqualValue(
        BACKUPSOURCERECORD& s1,
        BACKUPSOURCERECORD& s2,
        BOOL bMatchAll,
        DWORD dwParam
    );

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\license\tlserver\tlsdb\kpdtab.cpp ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996-1998
//
// File:        kpdtab.cpp
//
// Contents:    Licensed Pack Description Table
//
// History:     
//              
//---------------------------------------------------------------------------
#include "KpDesc.h"


LPCTSTR __JBKPDescIndexKeyPackId::pszIndexName = LICPACKDESCRECORD_ID_INDEXNAME;
LPCTSTR __JBKPDescIndexKeyPackId::pszIndexKey = LICPACKDESCRECORD_ID_INDEXNAME_INDEXKEY;
LPCTSTR __JBKPDescIndexKeyPackLangId::pszIndexName = LICPACKDESCRECORD_ID_LANGID_INDEXNAME;
LPCTSTR __JBKPDescIndexKeyPackLangId::pszIndexKey = LICPACKDESCRECORD_ID_LANGID_INDEXNAME_INDEXKEY;
LPCTSTR __LICPACKDESCRECORDIdxOnModifyTime::pszIndexName = LICPACKDESCRECORD_LASTMODIFYTIME_INDEXNAME;
LPCTSTR __LICPACKDESCRECORDIdxOnModifyTime::pszIndexKey = LICPACKDESCRECORD_LASTMODIFYTIME_INDEXNAME_INDEXKEY;


LPCTSTR LicPackDescTable::pszTableName = LICPACKDESCRECORD_TABLE_NAME;
CCriticalSection LicPackDescTable::g_TableLock;
//----------------------------------------------------------

TLSJBIndex 
LicPackDescTable::g_TableIndex[] = 
{
    {
        LICPACKDESCRECORD_ID_INDEXNAME,
        LICPACKDESCRECORD_ID_INDEXNAME_INDEXKEY,
        -1,
        JET_bitIndexIgnoreNull, //JET_bitIndexUnique,
        TLSTABLE_INDEX_DEFAULT_DENSITY
    },        

    {
        LICPACKDESCRECORD_ID_LANGID_INDEXNAME,
        LICPACKDESCRECORD_ID_LANGID_INDEXNAME_INDEXKEY,
        -1,
        JET_bitIndexPrimary,
        TLSTABLE_INDEX_DEFAULT_DENSITY
    }
};       

int LicPackDescTable::g_NumTableIndex = sizeof(LicPackDescTable::g_TableIndex) / sizeof(LicPackDescTable::g_TableIndex[0]);

TLSJBColumn 
LicPackDescTable::g_Columns[] = 
{
    {        
        LICPACKDESCRECORD_ENTRYSTATUS,
        JET_coltypUnsignedByte,
        0,
        JET_bitColumnFixed,
        NULL,
        0,
        TLS_JETBLUE_COLUMN_CODE_PAGE,
        TLS_JETBLUE_COLUMN_COUNTRY_CODE,
        TLS_JETBLUE_COLUMN_LANGID
    },

    {
        LICPACKDESCRECORD_ID_COLUMN,
        JET_coltypLong,
        0,
        JET_bitColumnFixed | JET_bitColumnNotNULL,
        NULL,
        0,
        TLS_JETBLUE_COLUMN_CODE_PAGE,
        TLS_JETBLUE_COLUMN_COUNTRY_CODE,
        TLS_JETBLUE_COLUMN_LANGID
    },
   
    {
        LICPACKDESCRECORD_LASTMODIFYTIME,
        JET_coltypBinary,
        sizeof(FILETIME),
        JET_bitColumnNotNULL,
        NULL,
        0,
        TLS_JETBLUE_COLUMN_CODE_PAGE,
        TLS_JETBLUE_COLUMN_COUNTRY_CODE,
        TLS_JETBLUE_COLUMN_LANGID
    },

    {
        LICPACKDESCRECORD_LANGID,
        JET_coltypLong,
        0,
        JET_bitColumnFixed | JET_bitColumnNotNULL,
        NULL,
        0,
        TLS_JETBLUE_COLUMN_CODE_PAGE,
        TLS_JETBLUE_COLUMN_COUNTRY_CODE,
        TLS_JETBLUE_COLUMN_LANGID
    },
    
    {
        LICPACKDESCRECORD_COMPANY_NAME,
        //JET_coltypLongText,
        JB_COLTYPE_TEXT,
        (MAX_JETBLUE_TEXT_LENGTH + 1)*sizeof(TCHAR),
        0,
        JBSTRING_NULL,
        _tcslen(JBSTRING_NULL),
        TLS_JETBLUE_COLUMN_CODE_PAGE,
        TLS_JETBLUE_COLUMN_COUNTRY_CODE,
        TLS_JETBLUE_COLUMN_LANGID
    },

    {
        LICPACKDESCRECORD_PRODUCT_NAME,
        //JET_coltypLongText,
        JB_COLTYPE_TEXT,
        (MAX_JETBLUE_TEXT_LENGTH + 1)*sizeof(TCHAR),
        0,
        JBSTRING_NULL,
        _tcslen(JBSTRING_NULL),
        TLS_JETBLUE_COLUMN_CODE_PAGE,
        TLS_JETBLUE_COLUMN_COUNTRY_CODE,
        TLS_JETBLUE_COLUMN_LANGID
    },
    
    {
        LICPACKDESCRECORD_PRODUCT_DESC,
        //JET_coltypLongText,
        JB_COLTYPE_TEXT,
        (MAX_JETBLUE_TEXT_LENGTH + 1)*sizeof(TCHAR),
        0,
        JBSTRING_NULL,
        _tcslen(JBSTRING_NULL),
        TLS_JETBLUE_COLUMN_CODE_PAGE,
        TLS_JETBLUE_COLUMN_COUNTRY_CODE,
        TLS_JETBLUE_COLUMN_LANGID
    },
};

int 
LicPackDescTable::g_NumColumns = sizeof(LicPackDescTable::g_Columns) / sizeof(LicPackDescTable::g_Columns[0]);

//--------------------------------------------------------------------------
BOOL
LicPackDescTable::ResolveToTableColumn()
/*
*/
{
    if(IsValid() == FALSE)
    {
        DebugOutput( 
                _TEXT("Table %s is not valid...\n"),
                GetTableName()
            );

        JB_ASSERT(FALSE);
        SetLastJetError(JET_errNotInitialized);
        goto cleanup;
    }

    m_JetErr = ucEntryStatus.AttachToTable(
                        *this,
                        LICPACKDESCRECORD_ENTRYSTATUS
                    );

    if(IsSuccess() == FALSE)
        goto cleanup;

    m_JetErr = dwKeyPackId.AttachToTable(
                        *this,
                        LICPACKDESCRECORD_ID_COLUMN
                    );
    if(IsSuccess() == FALSE)
        goto cleanup;

    m_JetErr = dwLanguageId.AttachToTable(
                        *this,
                        LICPACKDESCRECORD_LANGID
                    );
    if(IsSuccess() == FALSE)
        goto cleanup;

    
    m_JetErr = ftLastModifyTime.AttachToTable(
                        *this,
                        LICPACKDESCRECORD_LASTMODIFYTIME
                    );
    if(IsSuccess() == FALSE)
        goto cleanup;

    m_JetErr = szCompanyName.AttachToTable(
                        *this,
                        LICPACKDESCRECORD_COMPANY_NAME
                    );
    if(IsSuccess() == FALSE)
        goto cleanup;

    m_JetErr = szProductName.AttachToTable(
                        *this,
                        LICPACKDESCRECORD_PRODUCT_NAME
                    );
    if(IsSuccess() == FALSE)
        goto cleanup;

    m_JetErr = szProductDesc.AttachToTable(
                        *this,
                        LICPACKDESCRECORD_PRODUCT_DESC
                    );

cleanup:
    return IsSuccess();
}

//-------------------------------------------------------------------------
CLASS_PRIVATE BOOL
LicPackDescTable::ProcessSingleColumn(
    BOOL bFetch,
    TLSColumnBase& column,
    DWORD offset,
    PVOID pbData,
    DWORD cbData,
    PDWORD pcbDataReturn,
    LPCTSTR szColumnName
    )
/*
*/
{
    if(bFetch) 
    {
        m_JetErr = column.FetchColumnValue(
                                    pbData, 
                                    cbData, 
                                    offset, 
                                    pcbDataReturn
                                );
    }
    else
    {
        m_JetErr = column.InsertColumnValue(
                                    pbData,     
                                    cbData, 
                                    offset
                                );
    }

    REPORTPROCESSFAILED(
            bFetch,
            GetTableName(),
            szColumnName,
            m_JetErr
        );
    return IsSuccess();
}

//--------------------------------------------------------------------------
CLASS_PRIVATE BOOL
LicPackDescTable::ProcessRecord(
    LICPACKDESCRECORD* record,
    BOOL bFetch,
    DWORD dwParam,
    BOOL bUpdate
    )
/*
*/
{
    DWORD dwSize;

    if(bFetch == FALSE)
    {
        //BeginTransaction();
        BeginUpdate(bUpdate);

        if(!(dwParam & LICPACKDESCRECORD_TABLE_PROCESS_LASTMODIFYTIME))
        {
            JB_ASSERT(FALSE);
            dwParam |= LICPACKDESCRECORD_TABLE_PROCESS_LASTMODIFYTIME;
        }
    }
    else
    {
        SetLastJetError(JET_errSuccess);
    }

    if(IsSuccess() == FALSE)
        return FALSE;

    if(dwParam & LICPACKDESCRECORD_TABLE_PROCESS_ENTRYSTATUS)
    {
        ProcessSingleColumn(
                        bFetch, 
                        ucEntryStatus, 
                        0,
                        &(record->ucEntryStatus),
                        sizeof(record->ucEntryStatus),
                        &dwSize,
                        LICPACKDESCRECORD_ENTRYSTATUS
                    );
    }

    if(IsSuccess() == FALSE)
        goto cleanup;            

    if(dwParam & LICPACKDESCRECORD_TABLE_PROCESS_KEYPACKID)
    {
        ProcessSingleColumn(
                        bFetch, 
                        dwKeyPackId, 
                        0,
                        &(record->dwKeyPackId),
                        sizeof(record->dwKeyPackId),
                        &dwSize,
                        LICPACKDESCRECORD_ID_COLUMN
                    );
    }

    if(IsSuccess() == FALSE)
        goto cleanup;            
    
    if(dwParam & LICPACKDESCRECORD_TABLE_PROCESS_LANGID)
    {
        ProcessSingleColumn(
                        bFetch, 
                        dwLanguageId, 
                        0,
                        &(record->dwLanguageId),
                        sizeof(record->dwLanguageId),
                        &dwSize,
                        LICPACKDESCRECORD_LANGID
                    );
    }

    if(IsSuccess() == FALSE)
        goto cleanup;            

    if(dwParam & LICPACKDESCRECORD_TABLE_PROCESS_LASTMODIFYTIME)
    {
        ProcessSingleColumn(
                        bFetch, 
                        ftLastModifyTime, 
                        0,
                        &(record->ftLastModifyTime),
                        sizeof(record->ftLastModifyTime),
                        &dwSize,
                        LICPACKDESCRECORD_LASTMODIFYTIME
                    );
    }

    if(IsSuccess() == FALSE)
        goto cleanup;            

    if(dwParam & LICPACKDESCRECORD_TABLE_PROCESS_COMPANYNAME)
    {
        ProcessSingleColumn(
                        bFetch, 
                        szCompanyName, 
                        0,
                        record->szCompanyName,
                        sizeof(record->szCompanyName),
                        &dwSize,
                        LICPACKDESCRECORD_COMPANY_NAME
                    );
    }

    if(IsSuccess() == FALSE)
        goto cleanup;            

    if(dwParam & LICPACKDESCRECORD_TABLE_PROCESS_PRODUCTNAME)
    {
        ProcessSingleColumn(
                        bFetch, 
                        szProductName, 
                        0,
                        record->szProductName,
                        sizeof(record->szProductName),
                        &dwSize,
                        LICPACKDESCRECORD_PRODUCT_NAME
                    );
    }

    if(IsSuccess() == FALSE)
        goto cleanup;            

    if(dwParam & LICPACKDESCRECORD_TABLE_PROCESS_PRODUCTDESC)
    {
        ProcessSingleColumn(
                        bFetch, 
                        szProductDesc, 
                        0,
                        record->szProductDesc,
                        sizeof(record->szProductDesc),
                        &dwSize,
                        LICPACKDESCRECORD_PRODUCT_DESC
                    );
    }

cleanup:


    // 
    // For inserting/updating record
    if(bFetch == FALSE)
    {
        JET_ERR jetErr;
        jetErr = GetLastJetError();

        EndUpdate(IsSuccess() == FALSE);

        if(jetErr != JET_errSuccess  && IsSuccess() == FALSE)
            SetLastJetError(jetErr);
    }

    return IsSuccess();
}

//----------------------------------------------------------------------------
JBKeyBase*
LicPackDescTable::EnumerationIndex(
    BOOL bMatchAll,
    DWORD dwSearchParam,
    LICPACKDESCRECORD* kpDesc,
    BOOL* bCompareKey
    )
/*
*/
{
    JBKeyBase* index=NULL;

    *bCompareKey = bMatchAll;

    // derive a index to use
    //
    if( bMatchAll == TRUE && 
        dwSearchParam & LICPACKDESCRECORD_TABLE_SEARCH_KEYPACKID && 
        dwSearchParam & LICPACKDESCRECORD_TABLE_SEARCH_LANGID)
    {
        index = new TLSKpDescIndexKpLangId(kpDesc);
    }
    else 
    {
        index = new TLSKpDescIndexKpId(kpDesc);

        *bCompareKey = (bMatchAll && (dwSearchParam & LICPACKDESCRECORD_TABLE_SEARCH_KEYPACKID));
    }

    return index;
}

//---------------------------------------------------------------------------
BOOL
LicPackDescTable::EqualValue(
    LICPACKDESCRECORD& src,
    LICPACKDESCRECORD& dest,
    BOOL bMatchAll,
    DWORD dwParam
    )
/*
*/
{
    BOOL bRetCode = TRUE;

    if(dwParam & LICPACKDESCRECORD_TABLE_PROCESS_ENTRYSTATUS)
    {
        bRetCode = (src.ucEntryStatus == dest.ucEntryStatus);
        if(bMatchAll != bRetCode)
            goto cleanup;
    }

    if(dwParam & LICPACKDESCRECORD_TABLE_PROCESS_KEYPACKID)
    {
        bRetCode = (src.dwKeyPackId == dest.dwKeyPackId);

        //
        // bMatchAll == TRUE and bRetCode == FALSE -> return FALSE
        // bMatchAll == FALSE and bRetCode == TRUE -> return TRUE
        if(bMatchAll != bRetCode)
            goto cleanup;
    }

    if(dwParam & LICPACKDESCRECORD_TABLE_PROCESS_LANGID)
    {
        bRetCode = (src.dwLanguageId == dest.dwLanguageId);

        if(bMatchAll != bRetCode)
            goto cleanup;
    }

    if(dwParam & LICPACKDESCRECORD_TABLE_PROCESS_COMPANYNAME)
    {
        bRetCode = (_tcscmp(src.szCompanyName, dest.szCompanyName) == 0);

        if(bMatchAll != bRetCode)
            goto cleanup;
    }

    if(dwParam & LICPACKDESCRECORD_TABLE_PROCESS_PRODUCTNAME)
    {
        bRetCode = (_tcscmp(src.szProductName, dest.szProductName) == 0);

        if(bMatchAll != bRetCode)
            goto cleanup;
    }

    if(dwParam & LICPACKDESCRECORD_TABLE_PROCESS_PRODUCTDESC)
    {
        bRetCode = (_tcscmp(src.szProductDesc, dest.szProductDesc) == 0);
    }

cleanup:

    return bRetCode;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\license\tlserver\tlsdb\licensed.h ===
//+--------------------------------------------------------------------------
//
// Copyright (c) 1997-1999 Microsoft Corporation
//
// File:       licensed.h 
//
// Contents:    
//
// History:     
//
//---------------------------------------------------------------------------
#ifndef __TLS_LICENSED_H__
#define __TLS_LICENSED_H__

#include "JetBlue.h"
#include "TlsDb.h"

//
// Not exported - not defined in tlsdef.h
//
#define LICENSE_COLUMN_SEARCH_SYSTEMBOIS     0x00200000
#define LICENSE_COLUMN_SEARCH_VIDEOBIOS      0x00400000
#define LICENSE_COLUMN_SEARCH_FLOPPYBIOS     0x00800000
#define LICENSE_COLUMN_SEARCH_HARDDISKSIZE   0x01000000
#define LICENSE_COLUMN_SEARCH_RAMSIZE        0x02000000
#define LICENSE_COLUMN_SEARCH_HWID \
    (LICENSE_COLUMN_SEARCH_SYSTEMBOIS | LICENSE_COLUMN_SEARCH_VIDEOBIOS | \
     LICENSE_COLUMN_SEARCH_FLOPPYBIOS | LICENSE_COLUMN_SEARCH_HARDDISKSIZE | \
     LICENSE_COLUMN_SEARCH_RAMSIZE)

#define LICENSE_PROCESS_LICENSEID           LSLICENSE_SEARCH_LICENSEID
#define LICENSE_PROCESS_KEYPACKID           LSLICENSE_SEARCH_KEYPACKID          
#define LICENSE_PROCESS_MACHINENAME         LSLICENSE_SEARCH_MACHINENAME
#define LICENSE_PROCESS_USERNAME            LSLICENSE_SEARCH_USERNAME
#define LICENSE_PROCESS_ISSUEDATE           LSLICENSE_SEARCH_ISSUEDATE
#define LICENSE_PROCESS_EXPIREDATE          LSLICENSE_SEARCH_EXPIREDATE
#define LICENSE_PROCESS_NUMLICENSES         LSLICENSE_SEARCH_NUMLICENSES
#define LICENSE_PROCESS_LICENSESTATUS       LSLICENSE_EXSEARCH_LICENSESTATUS
#define LICENSE_PROCESS_SYSTEMBIOS          LICENSE_COLUMN_SEARCH_SYSTEMBOIS
#define LICENSE_PROCESS_VIDEOBIOS           LICENSE_COLUMN_SEARCH_VIDEOBIOS
#define LICENSE_PROCESS_FLOPPYBIOS          LICENSE_COLUMN_SEARCH_FLOPPYBIOS
#define LICENSE_PROCESS_HARDDISKSIZE        LICENSE_COLUMN_SEARCH_HARDDISKSIZE
#define LICENSE_PROCESS_RAMSIZE             LICENSE_COLUMN_SEARCH_RAMSIZE
#define LICENSE_PROCESS_MATCHHWID           0x04000000
#define LICENSE_PROCESS_HWID                LICENSE_COLUMN_SEARCH_HWID
#define LICENSE_PROCESS_LASTMODIFYTIME      0x08000000
#define LICENSE_PROCESS_KEYPACKLICENSEID    0x10000000
#define LICENSE_PROCESS_ENTRYSTATUS         LSLICENSE_SEARCH_ENTRY_STATUS

//
// Licensed table
//
#define LICENSE_TABLE_NAME                   _TEXT("IssuedLicense")
#define LICENSE_COLUMN_ID_COLUMN             _TEXT("InternalLicenseID")

#define LICENSE_COLUMN_KEYPACKID             _TEXT("InternalKeyPackId")
#define LICENSE_COLUMN_LICENSEID             _TEXT("KeyPackLicenseId")

#define LICENSE_COLUMN_LASTMODIFYTIME        _TEXT("LastModifyTime")

#define LICENSE_COLUMN_SYSTEMBIOS            _TEXT("SystemBIOS")
#define LICENSE_COLUMN_VIDEOBIOS             _TEXT("VideoBIOS")
#define LICENSE_COLUMN_FLOPPYBIOS            _TEXT("FloppyBIOS")
#define LICENSE_COLUMN_HARDDISKSIZE          _TEXT("HarddiskSize")
#define LICENSE_COLUMN_RAMSIZE               _TEXT("RAMSize")
#define LICENSE_COLUMN_MATCHHWID             _TEXT("MatchHint1")

#define LICENSE_COLUMN_MACHINENAME           _TEXT("MachineName")
#define LICENSE_COLUMN_USERNAME              _TEXT("UserName")
#define LICENSE_COLUMN_NUMLICENSES           _TEXT("NumLicenses")
#define LICENSE_COLUMN_ISSUEDATE             _TEXT("IssueDate")
#define LICENSE_COLUMN_EXPIREDATE            _TEXT("ExpireDate")
#define LICENSE_COLUMN_LICENSESTATUS         _TEXT("LicenseStatus")
#define LICENSE_COLUMN_ENTRYSTATUS           _TEXT("EntryStatus")

typedef TLSReplLicenseClient LICENSEDCLIENT;
typedef TLSReplLicenseClient* PLICENSEDCLIENT;
typedef TLSReplLicenseClient* LPLICENSEDCLIENT;

////////////////////////////////////////////////////////////
//
// Index structure for IssuedLicense table
//
////////////////////////////////////////////////////////////

// --------------------------------------------------------
//  Primary index on License ID - internal tracking number
// --------------------------------------------------------

//
// IssuedLicense_LicenseId_idx
//
#define LICENSE_ID_INDEXNAME \
    LICENSE_TABLE_NAME SEPERATOR LICENSE_COLUMN_ID_COLUMN SEPERATOR INDEXNAME

//
// Index key on license ID column - "+LicenseID"
//
#define LICENSE_ID_INDEXNAME_INDEXKEY \
    INDEX_SORT_ASCENDING LICENSE_COLUMN_ID_COLUMN INDEX_END_COLNAME

typedef struct __LicensedIndexOnLicenseId : public JBKeyBase {
    DWORD dwLicenseId;

    static LPCTSTR pszIndexName;
    static LPCTSTR pszIndexKey;

    //--------------------------------------------------------
    __LicensedIndexOnLicenseId(
        const LICENSEDCLIENT& v
        ) : 
        JBKeyBase() 
    /*++
    ++*/
    {
        *this = v;
    }

    //-------------------------------------------------------
    __LicensedIndexOnLicenseId(
        const LICENSEDCLIENT* v=NULL
        ) : 
        JBKeyBase() 
    /*++
    ++*/
    {
        if(v)
        {
            *this = *v;
        }
    }

    //-------------------------------------------------------
    __LicensedIndexOnLicenseId&
    operator=(const LICENSEDCLIENT& v) {
        dwLicenseId = v.dwLicenseId;

        SetEmptyValue(FALSE);
        return *this;
    }

    //--------------------------------------------------------
    inline LPCTSTR
    GetIndexName() 
    {
        return pszIndexName;
    }

    inline LPCTSTR
    GetIndexKey() 
    {
        return pszIndexKey;
    }

    DWORD
    GetNumKeyComponents() { return 1; }

    inline BOOL
    GetSearchKey(
        DWORD dwComponentIndex,
        PVOID* pbData,
        unsigned long* cbData,
        JET_GRBIT* grbit,
        DWORD dwSearchParm
        )
    /*
    */
    {
        if(dwComponentIndex >= GetNumKeyComponents())
        {
            JB_ASSERT(FALSE);
            return FALSE;
        }

        *pbData = &(dwLicenseId);
        *cbData = sizeof(dwLicenseId);
        *grbit = JET_bitNewKey;
        return TRUE;
    }

} TLSLicensedIndexLicenseId;



// ----------------------------------------------------------
//  Index on Issued License Pack Id (internal tracking number)
// ----------------------------------------------------------

//
// IssuedLicense_KeyPackId_idx
//
#define LICENSE_KEYPACKID_INDEXNAME \
    LICENSE_TABLE_NAME SEPERATOR LICENSE_COLUMN_KEYPACKID SEPERATOR INDEXNAME

//
// Index key on License KeyPack ID - "+KeyPackId"
//
#define LICENSE_KEYPACKID_INDEXNAME_INDEXKEY \
    INDEX_SORT_ASCENDING LICENSE_COLUMN_KEYPACKID INDEX_END_COLNAME   

typedef struct __LicensedIndexOnKeyPackId : public JBKeyBase{
    DWORD dwKeyPackId;

    static LPCTSTR pszIndexName;
    static LPCTSTR pszIndexKey;

    //----------------------------------------------
    __LicensedIndexOnKeyPackId(
        const LICENSEDCLIENT& v
        ) : 
        JBKeyBase() 
    /*++
    ++*/
    {
        *this = v;
    }

    //----------------------------------------------
    __LicensedIndexOnKeyPackId(
        const LICENSEDCLIENT* v=NULL
        ) : 
        JBKeyBase() 
    /*++
    ++*/
    {
        if(v)
        {
            *this = *v;
        }
    }

    __LicensedIndexOnKeyPackId&
    operator=(const LICENSEDCLIENT& v) {
        dwKeyPackId = v.dwKeyPackId;

        SetEmptyValue(FALSE);
        return *this;
    }

    //----------------------------------------------
    inline LPCTSTR
    GetIndexName() 
    {
        return pszIndexName;
    }

    inline LPCTSTR
    GetIndexKey() 
    {
        return pszIndexKey;
    }

    DWORD
    GetNumKeyComponents() { return 1; }

    inline BOOL
    GetSearchKey(
        DWORD dwComponentIndex,
        PVOID* pbData,
        unsigned long* cbData,
        JET_GRBIT* grbit,
        DWORD dwSearchParm
        )
    /*
    */
    {
        if(dwComponentIndex >= GetNumKeyComponents())
        {
            JB_ASSERT(FALSE);
            return FALSE;
        }

        *pbData = &(dwKeyPackId);
        *cbData = sizeof(dwKeyPackId);
        *grbit = JET_bitNewKey;
        return TRUE;
    }

} TLSLicensedIndexKeyPackId;


// ----------------------------------------------------------
//  Index on LastModifyTime
// ----------------------------------------------------------

//
// IssuedLicense_LastModifyTime_idx
//
#define LICENSE_LASTMODIFY_INDEXNAME \
    LICENSE_TABLE_NAME SEPERATOR LICENSE_COLUMN_LASTMODIFYTIME SEPERATOR INDEXNAME

//
// Index key - "+LastModifyTime"
//
#define LICENSE_LASTMODIFY_INDEXNAME_INDEXKEY \
    INDEX_SORT_ASCENDING LICENSE_COLUMN_LASTMODIFYTIME INDEX_END_COLNAME   

typedef struct __LicensedIndexOnLastModifyTime : public JBKeyBase {
    FILETIME ftLastModifyTime;

    static LPCTSTR pszIndexName;
    static LPCTSTR pszIndexKey;

    //----------------------------------------------
    __LicensedIndexOnLastModifyTime(
        const LICENSEDCLIENT& v
        ) : 
        JBKeyBase() 
    /*++
    ++*/
    {
        *this = v;
    }

    //----------------------------------------------
    __LicensedIndexOnLastModifyTime(
        const LICENSEDCLIENT* v=NULL
        ) : 
        JBKeyBase() 
    /*++
    ++*/
    {
        if(v)
        {
            *this = *v;
        }
    }

    __LicensedIndexOnLastModifyTime&
    operator=(const LICENSEDCLIENT& v) {
        ftLastModifyTime = v.ftLastModifyTime;

        SetEmptyValue(FALSE);
        return *this;
    }

    //----------------------------------------------
    inline LPCTSTR
    GetIndexName() 
    {
        return pszIndexName;
    }

    inline LPCTSTR
    GetIndexKey() 
    {
        return pszIndexKey;
    }

    DWORD
    GetNumKeyComponents() { return 1; }

    inline BOOL
    GetSearchKey(
        DWORD dwComponentIndex,
        PVOID* pbData,
        unsigned long* cbData,
        JET_GRBIT* grbit,
        DWORD dwSearchParm
        )
    /*
    */
    {
        if(dwComponentIndex >= GetNumKeyComponents())
        {
            JB_ASSERT(FALSE);
            return FALSE;
        }

        *pbData = &(ftLastModifyTime);
        *cbData = sizeof(ftLastModifyTime);
        *grbit = JET_bitNewKey;
        return TRUE;
    }

} TLSLicensedIndexLastModifyTime;


// ----------------------------------------------------------
//  Index on ExpireDate
// ----------------------------------------------------------

//
// IssuedLicense_ExpireDate_idx
//
#define LICENSE_EXPIREDATE_INDEXNAME \
    LICENSE_TABLE_NAME SEPERATOR LICENSE_COLUMN_EXPIREDATE SEPERATOR INDEXNAME

//
// Index key - "+ExpireDate"
//
#define LICENSE_EXPIREDATE_INDEXNAME_INDEXKEY \
    INDEX_SORT_ASCENDING LICENSE_COLUMN_EXPIREDATE INDEX_END_COLNAME   

typedef struct __LicensedIndexOnExpireDate : public JBKeyBase {
    DWORD ftExpireDate;

    static LPCTSTR pszIndexName;
    static LPCTSTR pszIndexKey;

    //----------------------------------------------
    __LicensedIndexOnExpireDate(
        const LICENSEDCLIENT& v
        ) : 
        JBKeyBase() 
    /*++
    ++*/
    {
        *this = v;
    }

    //----------------------------------------------
    __LicensedIndexOnExpireDate(
        const LICENSEDCLIENT* v=NULL
        ) : 
        JBKeyBase() 
    /*++
    ++*/
    {
        if(v)
        {
            *this = *v;
        }
    }

    __LicensedIndexOnExpireDate&
    operator=(const LICENSEDCLIENT& v) {
        ftExpireDate = v.ftExpireDate;

        SetEmptyValue(FALSE);
        return *this;
    }

    //----------------------------------------------
    inline LPCTSTR
    GetIndexName() 
    {
        return pszIndexName;
    }

    inline LPCTSTR
    GetIndexKey() 
    {
        return pszIndexKey;
    }

    DWORD
    GetNumKeyComponents() { return 1; }

    inline BOOL
    GetSearchKey(
        DWORD dwComponentIndex,
        PVOID* pbData,
        unsigned long* cbData,
        JET_GRBIT* grbit,
        DWORD dwSearchParm
        )
    /*
    */
    {
        if(dwComponentIndex >= GetNumKeyComponents())
        {
            JB_ASSERT(FALSE);
            return FALSE;
        }

        *pbData = &(ftExpireDate);
        *cbData = sizeof(ftExpireDate);
        *grbit = JET_bitNewKey;
        return TRUE;
    }

} TLSLicensedIndexExpireDate;


//-------------------------------------------------------------
// Index on client machine name
//-------------------------------------------------------------
//
// IssuedLicense_MachineName_idx
//
#define LICENSE_CLIENT_MACHINENAME_INDEXNAME \
    LICENSE_TABLE_NAME SEPERATOR LICENSE_COLUMN_MACHINENAME SEPERATOR INDEXNAME

//
// "+MachineName\0"
#define LICENSE_CLIENT_MACHINENAME_INDEXNAME_INDEXKEY \
    INDEX_SORT_ASCENDING LICENSE_COLUMN_MACHINENAME INDEX_END_COLNAME

typedef struct __LicensedIndexOnMachineName : public JBKeyBase {
    TCHAR szMachineName[ MAXCOMPUTERNAMELENGTH+1 ];

    static LPCTSTR pszIndexName;
    static LPCTSTR pszIndexKey;

    //-------------------------------------------------------
    __LicensedIndexOnMachineName(
        const LICENSEDCLIENT* v=NULL
        ) : 
        JBKeyBase() 
    /*++
    ++*/
    {
        if(v)
        {
            *this = *v;
        }
    }

    //-------------------------------------------------------
    __LicensedIndexOnMachineName(
        const LICENSEDCLIENT& v
        ) : 
        JBKeyBase() 
    /*++
    ++*/
    {
        *this = v;
    }

    //-------------------------------------------------------
    __LicensedIndexOnMachineName&
    operator=(const LICENSEDCLIENT& v) {
        _tcscpy(szMachineName, v.szMachineName);

        SetEmptyValue(FALSE);
        return *this;
    }

    //------------------------------------------
    inline LPCTSTR
    GetIndexName() 
    {
        return pszIndexName;
    }

    inline LPCTSTR
    GetIndexKey() 
    {
        return pszIndexKey;
    }

    DWORD
    GetNumKeyComponents() { return 1; }

    inline BOOL
    GetSearchKey(
        DWORD dwComponentIndex,
        PVOID* pbData,
        unsigned long* cbData,
        JET_GRBIT* grbit,
        DWORD dwSearchParm
        )
    /*
    */
    {
        if(dwComponentIndex >= GetNumKeyComponents())
        {
            JB_ASSERT(FALSE);
            return FALSE;
        }

        *pbData = &(szMachineName[0]);
        *cbData = _tcslen(szMachineName) * sizeof(TCHAR);
        *grbit = JET_bitNewKey;
        return TRUE;
    }

} TLSLicensedIndexMachineName;


//-------------------------------------------------------------
// Index on client UserName  name
//-------------------------------------------------------------
//
// IssuedLicense_UserName_idx
//
#define LICENSE_CLIENT_USERNAME_INDEXNAME \
    LICENSE_TABLE_NAME SEPERATOR LICENSE_COLUMN_USERNAME SEPERATOR INDEXNAME

//
// "+UserName\0"
#define LICENSE_CLIENT_USERNAME_INDEXNAME_INDEXKEY \
    INDEX_SORT_ASCENDING LICENSE_COLUMN_USERNAME INDEX_END_COLNAME

typedef struct __LicensedIndexOnUserName : public JBKeyBase {
    TCHAR szUserName[ MAXUSERNAMELENGTH+1 ];

    static LPCTSTR pszIndexName;
    static LPCTSTR pszIndexKey;

    //-------------------------------------------------------
    __LicensedIndexOnUserName(const LICENSEDCLIENT& v) : JBKeyBase() {
        *this = v;
    }

    //-------------------------------------------------------
    __LicensedIndexOnUserName(
        const LICENSEDCLIENT* v=NULL
        ) : 
        JBKeyBase() 
    /*++
    ++*/
    {
        *this = *v;
    }

    //-------------------------------------------------------
    __LicensedIndexOnUserName&
    operator=(const LICENSEDCLIENT& v) {
        _tcscpy(szUserName, v.szUserName);
        SetEmptyValue(FALSE);
        return *this;
    }

    inline LPCTSTR
    GetIndexName() 
    {
        return pszIndexName;
    }

    inline LPCTSTR
    GetIndexKey() 
    {
        return pszIndexKey;
    }

    DWORD
    GetNumKeyComponents() { return 1; }

    inline BOOL
    GetSearchKey(
        DWORD dwComponentIndex,
        PVOID* pbData,
        unsigned long* cbData,
        JET_GRBIT* grbit,
        DWORD dwSearchParm
        )
    /*
    */
    {
        if(dwComponentIndex >= GetNumKeyComponents())
        {
            JB_ASSERT(FALSE);
            return FALSE;
        }

        *pbData = &(szUserName[0]);
        *cbData = _tcslen(szUserName) * sizeof(TCHAR);
        *grbit = JET_bitNewKey;
        return TRUE;
    }

} TLSLicensedIndexUserName;

  
//-------------------------------------------------------------
//  Index on client's HWID
//-------------------------------------------------------------
        
//
// IssuedLicense_Hwid_idx 
//
#define LICENSE_CLIENT_HWID_INDEXNAME \
    LICENSE_TABLE_NAME SEPERATOR _TEXT("ClientHwid") SEPERATOR INDEXNAME

//
// Index Key on Client Hwid - "+SystemBIOS\0+VideoBIOS\0+FloppyBIOS\0+HarddiskSize\0+RAMSize\0"
//
#define LICENSE_CLIENT_HWID_INDEXNAME_INDEXKEY \
    INDEX_SORT_ASCENDING LICENSE_COLUMN_SYSTEMBIOS INDEX_END_COLNAME \
    INDEX_SORT_ASCENDING LICENSE_COLUMN_VIDEOBIOS INDEX_END_COLNAME \
    INDEX_SORT_ASCENDING LICENSE_COLUMN_FLOPPYBIOS INDEX_END_COLNAME \
    INDEX_SORT_ASCENDING LICENSE_COLUMN_HARDDISKSIZE INDEX_END_COLNAME \
    INDEX_SORT_ASCENDING LICENSE_COLUMN_RAMSIZE INDEX_END_COLNAME

#define LICENSE_CLIENT_HWID_INDEXNAME_INDEXKEY_COMPONENTS 5

typedef struct __LicensedIndexOnHwid : public JBKeyBase {
    //
    // Need to change LICENSE_CLIENT_HWID_INDEXNAME_INDEXKEY_COMPONENTS
    // if add/remove from this structure
    //
    LONG   dwSystemBiosChkSum;
    LONG   dwVideoBiosChkSum;
    LONG   dwFloppyBiosChkSum;
    LONG   dwHardDiskSize;
    LONG   dwRamSize;

    static LPCTSTR pszIndexName;
    static LPCTSTR pszIndexKey;

    //------------------------------------------------
    __LicensedIndexOnHwid(
        const LICENSEDCLIENT* v=NULL
        ) : 
        JBKeyBase() 
    /*++
    ++*/
    {
        if(v)
        {
            *this = *v;
        }
    }

    //------------------------------------------------
    __LicensedIndexOnHwid(
        const LICENSEDCLIENT& v
        ) : 
        JBKeyBase() 
    /*++
    ++*/
    {
        *this = v;
    }
    
    //------------------------------------------------
    __LicensedIndexOnHwid&
    operator=(const LICENSEDCLIENT hwid) {
        dwSystemBiosChkSum = hwid.dwSystemBiosChkSum;
        dwVideoBiosChkSum = hwid.dwVideoBiosChkSum;
        dwFloppyBiosChkSum = hwid.dwFloppyBiosChkSum;
        dwHardDiskSize = hwid.dwHardDiskSize;
        dwRamSize = hwid.dwRamSize;

        SetEmptyValue(FALSE);
        return *this;
    }

    //------------------------------------------------
    inline LPCTSTR
    GetIndexName() 
    {
        return pszIndexName;
    }

    inline LPCTSTR
    GetIndexKey() 
    {
        return pszIndexKey;
    }

    DWORD
    GetNumKeyComponents() { 
        return LICENSE_CLIENT_HWID_INDEXNAME_INDEXKEY_COMPONENTS; 
    }

    inline BOOL
    GetSearchKey(
        DWORD dwComponentIndex,
        PVOID* pbData,
        unsigned long* cbData,
        JET_GRBIT* grbit,
        DWORD dwSearchParam
        )
    /*
    */
    {
        BOOL retCode=TRUE;

        if(dwComponentIndex >= GetNumKeyComponents())
        {
            JB_ASSERT(FALSE);
            return FALSE;
        }

        *cbData = 0;
        *grbit = 0;

        switch(dwComponentIndex)
        {
            case 0:
                *pbData = &(dwSystemBiosChkSum);
                *cbData = sizeof(dwSystemBiosChkSum);
                *grbit = JET_bitNewKey;
                break;

            case 1:
                *pbData = &(dwVideoBiosChkSum);
                *cbData = sizeof(dwVideoBiosChkSum);
                break;

            case 2:
                *pbData = &(dwFloppyBiosChkSum);
                *cbData = sizeof(dwFloppyBiosChkSum);
                break;

            case 3:
                *pbData = &(dwHardDiskSize);
                *cbData = sizeof(dwHardDiskSize);
                break;

            case 4:
                *pbData = &(dwRamSize);
                *cbData = sizeof(dwRamSize);
                break;
        
            default:
                JB_ASSERT(FALSE);
                retCode = FALSE;
        }

        return retCode;
    }            

} TLSLicensedIndexHwid;

    
//------------------------------------------------------
// Index for matching client HWID
//------------------------------------------------------
        
//
// IssuedLicense_MatchHwid_idx
//
#define LICENSE_MATCHHWID_INDEXNAME \
    LICENSE_TABLE_NAME SEPERATOR _TEXT("MatchHwid") SEPERATOR INDEXNAME

//
// Index key on search hint column "+MatchHint1\0"
//
#define LICENSE_MATCHHWID_INDEXNAME_INDEXKEY \
    INDEX_SORT_ASCENDING LICENSE_COLUMN_MATCHHWID INDEX_END_COLNAME

typedef struct __LicensedIndexOnMatchHwid : public JBKeyBase {
    double dbLowerBound;

    static LPCTSTR pszIndexName;
    static LPCTSTR pszIndexKey;

    static int __cdecl compare(const void *p1, const void* p2) {
        return *(DWORD *)p1 - *(DWORD *)p2;
    }

    //------------------------------------------------
    __LicensedIndexOnMatchHwid(
        const LICENSEDCLIENT* v=NULL
        ) : 
        JBKeyBase() 
    /*++
    ++*/
    {
        if(v)
        {
            *this = *v;
        }
    }

    //------------------------------------------------
    __LicensedIndexOnMatchHwid(
        const LICENSEDCLIENT& v
        ) : 
        JBKeyBase() 
    /*++
    ++*/
    {
        *this = v;
    }

    //------------------------------------------------
    __LicensedIndexOnMatchHwid&
    operator=(const LICENSEDCLIENT& v) {
        //
        // Allow to mismatch, so lower bound of matching hint is 
        // Sum of all HWID minus two lagest value
        //
        LONG ptr[] = { 
            v.dwSystemBiosChkSum,
            v.dwVideoBiosChkSum,
            v.dwFloppyBiosChkSum,
            v.dwHardDiskSize,
            v.dwRamSize   
        };

        int count=sizeof(ptr) / sizeof(ptr[0]);
        qsort(ptr, count, sizeof(DWORD), __LicensedIndexOnMatchHwid::compare);

        dbLowerBound = (double) 0.0;

        for(int i=0; i < count - 2; i++)
        {
            dbLowerBound += (double)ptr[i];
        }

        SetEmptyValue(FALSE);
        return *this;
    }

    inline LPCTSTR
    GetIndexName() 
    {
        return pszIndexName;
    }

    inline LPCTSTR
    GetIndexKey() 
    {
        return pszIndexKey;
    }

    DWORD
    GetNumKeyComponents() { 
        return 1;
    }

    inline BOOL
    GetSearchKey(
        DWORD dwComponentIndex,
        PVOID* pbData,
        unsigned long* cbData,
        JET_GRBIT* grbit,
        DWORD dwSearchParm
        )
    /*
    */
    {
        if(dwComponentIndex >= GetNumKeyComponents())
        {
            JB_ASSERT(FALSE);
            return FALSE;
        }

        *pbData = &(dbLowerBound);
        *cbData = sizeof(dbLowerBound);
        *grbit = JET_bitNewKey;
        return TRUE;
    }

} TLSLicensedIndexMatchHwid;

    
//------------------------------------------------------------------------
class LicensedTable : public TLSTable<LICENSEDCLIENT> {
private:

    static LPCTSTR pszTableName;

    BOOL
    ProcessSingleColumn(
        BOOL bFetch,
        TLSColumnBase& column,
        DWORD offset,
        PVOID pbData,
        DWORD cbData,
        PDWORD pcbDataReturn,
        LPCTSTR szColumnName
    );

    BOOL
    ProcessRecord(
        LICENSEDCLIENT* v,
        BOOL bFetch,        // TRUE - fetch, FALSE insert
        DWORD dwParam,
        BOOL bUpdate
    );

public:
    TLSColumnUchar     ucEntryStatus;
    TLSColumnFileTime  ftLastModifyTime;

    TLSColumnDword  dwLicenseId;
    TLSColumnDword  dwKeyPackId;
    TLSColumnDword  dwKeyPackLicenseId;

    TLSColumnText   szMachineName;  
    TLSColumnText   szUserName;
    TLSColumnDword  ftIssueDate;
    TLSColumnDword  ftExpireDate;
    TLSColumnUchar  ucLicenseStatus;
    TLSColumnDword  dwNumLicenses;

    TLSColumnDword  dwSystemBiosChkSum;
    TLSColumnDword  dwVideoBiosChkSum;
    TLSColumnDword  dwFloppyBiosChkSum;
    TLSColumnDword  dwHardDiskSize;
    TLSColumnDword  dwRamSize;

    TLSColumnDouble dbLowerBound;

    //---------------------------------------------------------
    virtual LPCTSTR
    GetTableName() 
    {
        return pszTableName;
    }

    //-----------------------------------------------------
    LicensedTable(
        JBDatabase& database
        ) : TLSTable<LICENSEDCLIENT>(database) 
    /*
    */
    {
    }

    //-----------------------------------------------------
    virtual BOOL
    ResolveToTableColumn();

    //-----------------------------------------------------
    virtual BOOL
    FetchRecord(
        LICENSEDCLIENT& licensed,
        DWORD dwParam=PROCESS_ALL_COLUMNS
        )
    /*
    */
    {
        if(IsValid() == FALSE)
        {
            DebugOutput( 
                    _TEXT("Table %s is not valid...\n"),
                    GetTableName()
                );

            JB_ASSERT(FALSE);
            SetLastJetError(JET_errInvalidParameter);
            return FALSE;
        }

        //CCriticalSectionLocker Lock(GetTableLock());

        return ProcessRecord(&licensed, TRUE, dwParam, FALSE);
    }

    //-----------------------------------------------------
    virtual BOOL
    InsertRecord(
        LICENSEDCLIENT& licensed,
        DWORD dwParam=PROCESS_ALL_COLUMNS
        )
    /*
    */
    {
        if(IsValid() == FALSE)
        {
            DebugOutput( 
                    _TEXT("Table %s is not valid...\n"),
                    GetTableName()
                );

            JB_ASSERT(FALSE);
            SetLastJetError(JET_errInvalidParameter);
            return FALSE;
        }

        //CCriticalSectionLocker Lock(GetTableLock());

        return ProcessRecord(&licensed, FALSE, dwParam, FALSE);
    }

    //-------------------------------------------------------
    virtual BOOL
    UpdateRecord(
        LICENSEDCLIENT& licensed,
        DWORD dwParam=PROCESS_ALL_COLUMNS
        )
    /*
    */
    {
        if(IsValid() == FALSE)
        {
            DebugOutput( 
                    _TEXT("Table %s is not valid...\n"),
                    GetTableName()
                );

            JB_ASSERT(FALSE);
            SetLastJetError(JET_errInvalidParameter);
            return FALSE;
        }

        //CCriticalSectionLocker Lock(GetTableLock());

        return ProcessRecord(&licensed, FALSE, dwParam, TRUE);
    }

    //-------------------------------------------------------
    virtual BOOL
    Initialize() { return TRUE; }

    //-------------------------------------------------------
    virtual JBKeyBase*
    EnumerationIndex( 
        BOOL bMatchAll,
        DWORD dwParam,
        LICENSEDCLIENT* pLicensed,
        BOOL* bCompareKey
    );

    virtual BOOL
    EqualValue(
        LICENSEDCLIENT& s1,
        LICENSEDCLIENT& s2,
        BOOL bMatchAll,
        DWORD dwParam
    );

    virtual BOOL
    UpgradeTable(
        IN DWORD dwOldVersion,
        IN DWORD dwNewVersion
    );

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\license\tlserver\tlsdb\licpack.h ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996-1998
//
// File:        LicPack.h
//
// Contents:    LicensedPack Table
//
// History:     
//              
//---------------------------------------------------------------------------
#ifndef __LICENSEDPACK_H__
#define __LICENSEDPACK_H__

#include "tlsdb.h"

//
// re-direct define using what's in tlsdef.h just for backward compatibility
//
#define LICENSEDPACK_PROCESS_DWINTERNAL          LSKEYPACK_EXSEARCH_DWINTERNAL
#define LICENSEDPACK_PROCESS_MODIFYTIME          (LSKEYPACK_EXSEARCH_AVAILABLE << 1)

//
// Basic LicensedPack PROCESS Parameter
//
#define LICENSEDPACK_PROCESS_SZKEYPACKID         LSKEYPACK_SEARCH_KEYPACKID          // szKeyPackId
#define LICENSEDPACK_PROCESS_AGREEMENTTYPE       LSKEYPACK_SEARCH_KEYPACKTYPE        // ucKeyPackType
#define LICENSEDPACK_PROCESS_PRODUCTID           LSKEYPACK_SEARCH_PRODUCTID          // szProductId
#define LICENSEDPACK_PROCESS_MAJORVERSION        LSKEYPACK_SEARCH_MAJORVERSION       // wMajorVersion
#define LICENSEDPACK_PROCESS_MINORVERSION        LSKEYPACK_SEARCH_MINORVERSION       // wMinorVersion
#define LICENSEDPACK_PROCESS_PLATFORMTYPE        LSKEYPACK_SEARCH_PLATFORMTYPE       // dwPlatformType
#define LICENSEDPACK_PROCESS_LICENSETYPE         LSKEYPACK_SEARCH_LICENSETYPE        // ucLicenseType
#define LICENSEDPACK_PROCESS_COP                 LSKEYPACK_SEARCH_COP                // ucChannelOfPurchase
#define LICENSEDPACK_PROCESS_BSERIALNUMBER       LSKEYPACK_SEARCH_BSERIALNUMBER      // szBeginSerialNumber
#define LICENSEDPACK_PROCESS_TOTALLICENSES       LSKEYPACK_SEARCH_TOTALLICENSES      // dwTotalLicenseInKeyPack
#define LICENSEDPACK_PROCESS_PRODUCTFLAGS        LSKEYPACK_SEARCH_PRODUCTFLAGS       // dwProductFlags
#define LICENSEDPACK_PROCESS_COMPANYNAME         LSKEYPACK_SEARCH_COMPANYNAME        // szCompanyName
#define LICENSEDPACK_PROCESS_EXPIREDATE          LSKEYPACK_EXSEARCH_EXPIREDATE       // dwExpirationDate

//
// Additional attribute for LicensedPack
//
#define LICENSEDPACK_PROCESS_ATTRIBUTE          (LSKEYPACK_EXSEARCH_AVAILABLE << 2)
#define LICENSEDPACK_PROCESS_KEYPACKSTATUS      LSKEYPACK_EXSEARCH_KEYPACKSTATUS    // ucKeyPackStatus
#define LICENSEDPACK_PROCESS_AVAILABLE          LSKEYPACK_EXSEARCH_AVAILABLE        // dwNumberOfLicenses
#define LICENSEDPACK_PROCESS_ACTIVATEDATE       LSKEYPACK_EXSEARCH_ACTIVATEDATE     // dwActivateDate
#define LICENSEDPACK_PROCESS_EXPIREDATE         LSKEYPACK_EXSEARCH_EXPIREDATE       // dwExpirationDate
#define LICENSEDPACK_PROCESS_DOMAINSID          (LSKEYPACK_EXSEARCH_AVAILABLE << 3)
#define LICENSEDPACK_PROCESS_LSSETUPID          (LSKEYPACK_EXSEARCH_AVAILABLE << 4)    
#define LICENSEDPACK_PROCESS_DOMAINNAME         (LSKEYPACK_EXSEARCH_AVAILABLE << 5)
#define LICENSEDPACK_PROCESS_SERVERNAME         (LSKEYPACK_EXSEARCH_AVAILABLE << 6)
#define LICENSEDPACK_PROCESS_NEXTSERIALNUMBER   (LSKEYPACK_EXSEARCH_AVAILABLE << 7)
#define LICENSEDPACK_PROCESS_ENTRYSTATUS        (LSKEYPACK_EXSEARCH_AVAILABLE << 8)

#define LICENSEDPACK_ALLOCATE_LICENSE_UPDATE_FIELD \
    (LICENSEDPACK_PROCESS_AVAILABLE | LICENSEDPACK_PROCESS_NEXTSERIALNUMBER | LICENSEDPACK_PROCESS_MODIFYTIME)

#define LICENSEDPACK_FIND_PRODUCT \
    (LSKEYPACK_SEARCH_KEYPACKID | LSKEYPACK_SEARCH_COMPANYNAME | \
     LSKEYPACK_SEARCH_PRODUCTID | LSKEYPACK_SEARCH_MAJORVERSION | \
     LSKEYPACK_SEARCH_MINORVERSION | LSKEYPACK_SEARCH_PLATFORMTYPE)

#define LICENSEDPACK_FIND_LICENSEPACK \
    (LSKEYPACK_SEARCH_KEYPACKTYPE | LSKEYPACK_SEARCH_MAJORVERSION | \
     LSKEYPACK_SEARCH_MINORVERSION | LSKEYPACK_SEARCH_COMPANYNAME | \
     LSKEYPACK_SEARCH_PLATFORMTYPE)

//
// Licensed KeyPack Property Table Name
//
#define LICENSEDPACK_TABLE_NAME                  _TEXT("LicensedPack")

//
// Additional LicensedPack Column
//
#define LICENSEDPACK_COLUMN_KEYPACKID            _TEXT("InternalKeyPackId")
#define LICENSEDPACK_COLUMN_LASTMODIFYTIME       _TEXT("LastModifyTime")

//
// KeyPack property as defined in backend doc.
//
#define LICENSEDPACK_COLUMN_LPID                  _TEXT("LPID")                   // license pack ID
#define LICENSEDPACK_COLUMN_AGREEMENTTYPE         _TEXT("AgreementType")          // SELECT/MOLP/FREE
#define LICENSEDPACK_COLUMN_COMPANYNAME           _TEXT("CompanyName")
#define LICENSEDPACK_COLUMN_PRODUCTID             _TEXT("ProductID")
#define LICENSEDPACK_COLUMN_MAJORVERSION          _TEXT("ProductMajorVersion")
#define LICENSEDPACK_COLUMN_MINORVERSION          _TEXT("ProductMinorVersion")
#define LICENSEDPACK_COLUMN_PLATFORMTYPE          _TEXT("PlatformType")
#define LICENSEDPACK_COLUMN_LICENSETYPE           _TEXT("LicenseType")
#define LICENSEDPACK_COLUMN_COP                   _TEXT("ChannelOfPurchase")
#define LICENSEDPACK_COLUMN_BSERIALNUMBER         _TEXT("BeginSerialNumber")
#define LICENSEDPACK_COLUMN_TOTALLICENSES         _TEXT("TotalLicenses")
#define LICENSEDPACK_COLUMN_PRODUCTFLAGS          _TEXT("ProductFlag")
#define LICENSEDPACK_COLUMN_EXPIREDATE            _TEXT("ExpirationDate")

#define LICENSEDPACK_COLUMN_ATTRIBUTE             _TEXT("KeyPackAttribute")
#define LICENSEDPACK_COLUMN_KEYPACKSTATUS         _TEXT("KeyPackStatus")
#define LICENSEDPACK_COLUMN_AVAILABLE             _TEXT("NumberLicenses")
#define LICENSEDPACK_COLUMN_NEXTSERIALNUMBER      _TEXT("NextSerialNumber")
#define LICENSEDPACK_COLUMN_ACTIVATEDATE          _TEXT("ActivationDate")
#define LICENSEDPACK_COLUMN_EXPIREDATE            _TEXT("ExpirationDate")
#define LICENSEDPACK_COLUMN_DOMAINSETUPID         _TEXT("TLSDomainSetupId")
#define LICENSEDPACK_COLUMN_LSSETUPID             _TEXT("TLSSetupId")
#define LICENSEDPACK_COLUMN_DOMAINNAME            _TEXT("DomainName")
#define LICENSEDPACK_COLUMN_LSERVERNAME           _TEXT("ServerName")
#define LICENSEDPACK_COLUMN_ENTRYSTATUS           _TEXT("EntryStatus")

typedef struct __LicensePack : public TLSReplLicensePack 
{
    void
    Cleanup() 
    { 
        if(pbDomainSid != NULL)
        {
            FreeMemory(pbDomainSid);
        }
    }
    
    __LicensePack() 
    {
        pbDomainSid = NULL;
        cbDomainSid = 0;
    }

    ~__LicensePack() 
    {
        Cleanup();
    }

    __LicensePack&
    operator=(
        const TLSReplLicensePack& v
        )
    /*++

    ++*/
    {
        BOOL bSuccess;
        PBYTE pbOldData=pbDomainSid;
        DWORD cbOldData=cbDomainSid;

        *(TLSReplLicensePack *)this = v;

        pbDomainSid = pbOldData;
        cbDomainSid = cbOldData;

        bSuccess = TLSDBCopySid(
                            (PSID)v.pbDomainSid,
                            v.cbDomainSid,
                            (PSID *)&pbDomainSid,
                            &cbDomainSid
                        );

        JB_ASSERT(bSuccess);

        return *this;
    }

    __LicensePack&
    operator=(const __LicensePack& v)
    /*++
    ++*/
    {
        BOOL bSuccess;
        PBYTE pbOldData=pbDomainSid;
        DWORD cbOldData=cbDomainSid;

        if(this == &v)
            return *this;

        *(TLSReplLicensePack *)this = *(TLSReplLicensePack *)&v;

        pbDomainSid = pbOldData;
        cbDomainSid = cbOldData;

        bSuccess = TLSDBCopySid(
                            (PSID)v.pbDomainSid,
                            v.cbDomainSid,
                            (PSID *)&pbDomainSid,
                            &cbDomainSid
                        );

        JB_ASSERT(bSuccess);

        return *this;
    }

} LICENSEPACK, *LPLICENSEPACK, *PLICENSEPACK;

typedef LICENSEPACK TLSLICENSEPACK;
typedef LPLICENSEPACK LPTLSLICENSEPACK;
typedef PLICENSEPACK PTLSLICENSEPACK;

////////////////////////////////////////////////////////////////
//
//  Primary Index on KeyPack ID (internal tracking number)
//
////////////////////////////////////////////////////////////////

//
// LicensedPack_KeyPackId_idx
//
#define LICENSEDPACK_INDEX_INTERNALKEYPACKID_INDEXNAME \
    LICENSEDPACK_TABLE_NAME SEPERATOR LICENSEDPACK_COLUMN_KEYPACKID SEPERATOR INDEXNAME

//
// Index Key "+KeyPackId\0"
//
#define LICENSEDPACK_INDEX_INTERNALKEYPACKID_INDEXKEY \
    INDEX_SORT_ASCENDING LICENSEDPACK_COLUMN_KEYPACKID INDEX_END_COLNAME

typedef struct __LicensedPackIdxOnInternalKpId : public JBKeyBase {
    //
    // Primary Index on internal KeyPack tracking ID
    //
    DWORD dwKeyPackId;

    static LPCTSTR pszIndexName;
    static LPCTSTR pszIndexKey;
    

    //--------------------------------------------------------
    __LicensedPackIdxOnInternalKpId(
        const LICENSEPACK& v
        ) : 
        JBKeyBase() 
    /*++
    ++*/
    {
        *this = v;
    }

    //--------------------------------------------------------
    __LicensedPackIdxOnInternalKpId(
        const LICENSEPACK* v=NULL
        ) : 
        JBKeyBase() 
    /*++
    ++*/
    {
        if(v)
        {
            *this = *v;
        }
    }

    //--------------------------------------------------------
    __LicensedPackIdxOnInternalKpId&
    operator=(const LICENSEPACK& v) 
    {
        dwKeyPackId = v.dwKeyPackId;
        SetEmptyValue(FALSE);
        return *this;
    }

    //--------------------------------------------------------
    LPCTSTR
    GetIndexName() 
    {
        return pszIndexName;
    }

    //--------------------------------------------------------
    LPCTSTR
    GetIndexKey() 
    {
        return pszIndexKey;
    }

    //--------------------------------------------------------
    DWORD
    GetNumKeyComponents() { return 1; }

    //--------------------------------------------------------
    BOOL
    GetSearchKey(
        DWORD dwComponentIndex,
        PVOID* pbData,
        unsigned long* cbData,
        JET_GRBIT* grbit,
        DWORD dwSearchParm
        )
    /*++
    ++*/
    {
        if(dwComponentIndex >= GetNumKeyComponents())
        {
            JB_ASSERT(FALSE);
            return FALSE;
        }

        *pbData = &(dwKeyPackId);
        *cbData = sizeof(dwKeyPackId);
        *grbit = JET_bitNewKey;
        return TRUE;
    }
} TLSLicensedPackIdxInternalKpId;


////////////////////////////////////////////////////////////////
//
//  Index on EntryLastModifyTime
//
//
////////////////////////////////////////////////////////////////

//
// LicensedPack_LastModifyTime_idx
//
#define LICENSEDPACK_INDEX_LASTMODIFYTIME_INDEXNAME \
    LICENSEDPACK_TABLE_NAME SEPERATOR LICENSEDPACK_COLUMN_LASTMODIFYTIME SEPERATOR INDEXNAME

//
// Index key "+LastModifyTime\0"
//
#define LICENSEDPACK_INDEX_LASTMODIFYTIME_INDEXKEY \
    INDEX_SORT_ASCENDING LICENSEDPACK_COLUMN_LASTMODIFYTIME INDEX_END_COLNAME

typedef struct __LicensedPackIdxOnModifyTime : public JBKeyBase {
    FILETIME ftLastModifyTime;

    static LPCTSTR pszIndexName;
    static LPCTSTR pszIndexKey;

    //--------------------------------------------------------
    __LicensedPackIdxOnModifyTime(
        const LICENSEPACK& v
        ) : 
        JBKeyBase() 
    /*++
    ++*/
    {
        *this = v;
    }

    //--------------------------------------------------------
    __LicensedPackIdxOnModifyTime(
        const LICENSEPACK* v=NULL
        ) : 
        JBKeyBase() 
    /*++
    ++*/
    {
        if(v)
        {
            *this = *v;
        }
    }

    //--------------------------------------------------------
    __LicensedPackIdxOnModifyTime&
    operator=(const LICENSEPACK& v) 
    {
        ftLastModifyTime = v.ftLastModifyTime;
        SetEmptyValue(FALSE);
        return *this;
    }

    //--------------------------------------------------------
    LPCTSTR
    GetIndexName() 
    {
        return pszIndexName;
    }

    //--------------------------------------------------------
    LPCTSTR
    GetIndexKey() 
    {
        return pszIndexKey;
    }

    //--------------------------------------------------------
    DWORD
    GetNumKeyComponents() { return 1; }

    //--------------------------------------------------------
    BOOL
    GetSearchKey(
        DWORD dwComponentIndex,
        PVOID* pbData,
        unsigned long* cbData,
        JET_GRBIT* grbit,
        DWORD dwSearchParm
        )
    /*++
    ++*/
    {
        if(dwComponentIndex >= GetNumKeyComponents())
        {
            JB_ASSERT(FALSE);
            return FALSE;
        }

        *pbData = &(ftLastModifyTime);
        *cbData = sizeof(ftLastModifyTime);
        *grbit = JET_bitNewKey;
        return TRUE;
    }
} TLSLicensedPackIdxLastModifyTime;


////////////////////////////////////////////////////////////////
//
//  Index on Company name
//
//
////////////////////////////////////////////////////////////////

//
// KeyPack_CompanyName_idx
//
#define LICENSEDPACK_INDEX_COMPANYNAME_INDEXNAME \
    LICENSEDPACK_TABLE_NAME SEPERATOR LICENSEDPACK_COLUMN_COMPANYNAME SEPERATOR INDEXNAME

//
// Index on key "+CompanyName\0"
//
#define LICENSEDPACK_INDEX_COMPANYNAME_INDEXKEY \
    INDEX_SORT_ASCENDING LICENSEDPACK_COLUMN_COMPANYNAME INDEX_END_COLNAME

typedef struct __LicensedPackIdxOnCompanyName : public JBKeyBase {
    TCHAR szCompanyName[ MAX_JETBLUE_TEXT_LENGTH + 1 ];

    static LPCTSTR pszIndexName;
    static LPCTSTR pszIndexKey;

    //-------------------------------------------------
    __LicensedPackIdxOnCompanyName( 
        const LICENSEPACK& v
        ) : JBKeyBase() 
    /*++
    ++*/
    {
        *this = v;
    }

    //-------------------------------------------------
    __LicensedPackIdxOnCompanyName( 
        const LICENSEPACK* v=NULL
        ) : JBKeyBase() 
    /*++
    ++*/
    {
        if(v)
        {
            *this = *v;
        }
    }

    //-------------------------------------------------
    __LicensedPackIdxOnCompanyName&
    operator=(const LICENSEPACK& v) {
        SetEmptyValue(FALSE);
        _tcscpy(szCompanyName, v.szCompanyName);
        return *this;
    }

    //--------------------------------------------------------
    LPCTSTR
    GetIndexName() 
    {
        return pszIndexName;
    }

    //--------------------------------------------------------
    LPCTSTR
    GetIndexKey() 
    {
        return pszIndexKey;
    }

    //--------------------------------------------------------
    DWORD
    GetNumKeyComponents() { return 1; }


    //--------------------------------------------------------
    BOOL
    GetSearchKey(
        DWORD dwComponentIndex,
        PVOID* pbData,
        unsigned long* cbData,
        JET_GRBIT* grbit,
        DWORD dwSearchParm
        )
    /*++
    ++*/
    {
        if(dwComponentIndex >= GetNumKeyComponents())
        {
            JB_ASSERT(FALSE);
            return FALSE;
        }

        *pbData = &(szCompanyName[0]);
        *cbData = _tcslen(szCompanyName) * sizeof(TCHAR);
        *grbit = JET_bitNewKey;
        return TRUE;
    }

} TLSLicensedPackIdxCompany;


////////////////////////////////////////////////////////////////
//
//  Index on Product ID
//
//
////////////////////////////////////////////////////////////////
//
// LicensedPack_ProductId_idx
//
#define LICENSEDPACK_INDEX_PRODUCTID_INDEXNAME \
    LICENSEDPACK_TABLE_NAME SEPERATOR LICENSEDPACK_COLUMN_PRODUCTID SEPERATOR INDEXNAME

//
// Index on key "+ProductId\0"
//
#define LICENSEDPACK_INDEX_PRODUCTID_INDEXKEY \
    INDEX_SORT_ASCENDING LICENSEDPACK_COLUMN_PRODUCTID INDEX_END_COLNAME

typedef struct __LicensedPackIdxOnProductId : public JBKeyBase {
    TCHAR szProductId[ MAX_JETBLUE_TEXT_LENGTH + 1 ];

    static LPCTSTR pszIndexName;
    static LPCTSTR pszIndexKey;

    //--------------------------------------------------------
    __LicensedPackIdxOnProductId(
        const LICENSEPACK& v
        ) : 
        JBKeyBase() 
    /*++
    ++*/
    {
        *this = v;
    }

    //--------------------------------------------------------
    __LicensedPackIdxOnProductId(
        const LICENSEPACK* v=NULL
        ) : 
        JBKeyBase() 
    /*++
    ++*/
    {
        if(v)
        {
            *this = *v;
        }
    }

    //--------------------------------------------------------
    __LicensedPackIdxOnProductId&
    operator=(const LICENSEPACK& v) {
        SetEmptyValue(FALSE);
        _tcscpy(szProductId, v.szProductId);
        return *this;
    }

    //--------------------------------------------------------
    LPCTSTR
    GetIndexName() 
    {
        return pszIndexName;
    }

    //--------------------------------------------------------
    LPCTSTR
    GetIndexKey() 
    {
        return pszIndexKey;
    }

    //--------------------------------------------------------
    DWORD
    GetNumKeyComponents() { return 1; }


    //--------------------------------------------------------
    BOOL
    GetSearchKey(
        DWORD dwComponentIndex,
        PVOID* pbData,
        unsigned long* cbData,
        JET_GRBIT* grbit,
        DWORD dwSearchParm
        )
    /*++
    ++*/
    {
        if(dwComponentIndex >= GetNumKeyComponents())
        {
            JB_ASSERT(FALSE);
            return FALSE;
        }

        *pbData = &(szProductId[0]);
        *cbData = _tcslen(szProductId) * sizeof(TCHAR);
        *grbit = JET_bitNewKey;
        return TRUE;
    }

} TLSLicensedPackIdxProductId;


////////////////////////////////////////////////////////////////
//
//  Index on KeyPack ID
//
//
////////////////////////////////////////////////////////////////
//
// KeyPack_LPID_idx
//
#define LICENSEDPACK_INDEX_KEYPACKID_INDEXNAME \
    LICENSEDPACK_TABLE_NAME SEPERATOR LICENSEDPACK_COLUMN_LPID SEPERATOR INDEXNAME

//
// Index on key "+lpid\0"
//
#define LICENSEDPACK_INDEX_KEYPACKID_INDEXKEY \
    INDEX_SORT_ASCENDING LICENSEDPACK_COLUMN_LPID INDEX_END_COLNAME

typedef struct __LicensedPackIdxOnKeyPackId : public JBKeyBase {

    TCHAR szKeyPackId[ MAX_JETBLUE_TEXT_LENGTH + 1 ];

    static LPCTSTR pszIndexName;
    static LPCTSTR pszIndexKey;


    //----------------------------------------------
    __LicensedPackIdxOnKeyPackId(
        const LICENSEPACK& v
        ) : 
        JBKeyBase() 
    /*++
    ++*/
    {
        *this = v;
    }

    //----------------------------------------------
    __LicensedPackIdxOnKeyPackId(
        const LICENSEPACK* v=NULL
        ) : 
        JBKeyBase() 
    /*++
    ++*/
    {
        if(v)
        {
            *this = *v;
        }
    }

    //----------------------------------------------
    __LicensedPackIdxOnKeyPackId&
    operator=(const LICENSEPACK& v) {
        SetEmptyValue(FALSE);
        _tcscpy(szKeyPackId, v.szKeyPackId);
        return *this;
    }

    //--------------------------------------------------------
    LPCTSTR
    GetIndexName() 
    {
        return pszIndexName;
    }

    //--------------------------------------------------------
    LPCTSTR
    GetIndexKey() 
    {
        return pszIndexKey;
    }

    //--------------------------------------------------------
    DWORD
    GetNumKeyComponents() { return 1; }

    //--------------------------------------------------------
    BOOL
    GetSearchKey(
        DWORD dwComponentIndex,
        PVOID* pbData,
        unsigned long* cbData,
        JET_GRBIT* grbit,
        DWORD dwSearchParm
        )
    /*++
    ++*/
    {
        if(dwComponentIndex >= GetNumKeyComponents())
        {
            JB_ASSERT(FALSE);
            return FALSE;
        }

        *pbData = &(szKeyPackId[0]);
        *cbData = _tcslen(szKeyPackId) * sizeof(TCHAR);
        *grbit = JET_bitNewKey;
        return TRUE;
    }
} TLSLicensedPackIdxKeyPackId;


//
////////////////////////////////////////////////////////////////
//

////////////////////////////////////////////////////////////////
//
//  Index for searching Installed License Pack
//  Max. 255 bytes per key so must looping 
//
////////////////////////////////////////////////////////////////

//
// Index name KeyPack_InstalledProduct_idx
// 
#define LICENSEDPACK_INDEX_INSTALLEDPRODUCT_INDEXNAME \
    LICENSEDPACK_TABLE_NAME SEPERATOR _TEXT("InstalledProduct") SEPERATOR INDEXNAME

//
// Number of Component in this key
#define LICENSEDPACK_INSTALLEDPRODUCT_KEY_COMPONENTS    6

//
//
// Index Key "+LPID\0+MajorVersion\0+MinorVersion\0+PlatformType\0+CompanyName\0+ProductId\0"
//
#define LICENSEDPACK_INDEX_INSTALLEDPRODUCT_INDEXKEY \
    INDEX_SORT_ASCENDING LICENSEDPACK_COLUMN_LPID INDEX_END_COLNAME \
    INDEX_SORT_ASCENDING LICENSEDPACK_COLUMN_MAJORVERSION INDEX_END_COLNAME \
    INDEX_SORT_ASCENDING LICENSEDPACK_COLUMN_MINORVERSION INDEX_END_COLNAME \
    INDEX_SORT_ASCENDING LICENSEDPACK_COLUMN_PLATFORMTYPE INDEX_END_COLNAME \
    INDEX_SORT_ASCENDING LICENSEDPACK_COLUMN_COMPANYNAME INDEX_END_COLNAME \
    INDEX_SORT_ASCENDING LICENSEDPACK_COLUMN_PRODUCTID INDEX_END_COLNAME 


typedef struct __LicensedPackIdxOnInstalledProduct : public JBKeyBase {
    //
    // Index for searching duplicate KeyPack
    //

    //
    // Adding or removing member must modify GetNumKeyComponents()
    //
    TCHAR szKeyPackId[LSERVER_MAX_STRING_SIZE + 1];

    WORD  wMajorVersion;
    WORD  wMinorVersion;
    DWORD dwPlatformType;

    TCHAR szCompanyName[LSERVER_MAX_STRING_SIZE + 1];
    TCHAR szProductId[LSERVER_MAX_STRING_SIZE + 1];

    static LPCTSTR pszIndexName;
    static LPCTSTR pszIndexKey;

    //---------------------------------------------------------------
    __LicensedPackIdxOnInstalledProduct(
        const LICENSEPACK& v
        ) : 
        JBKeyBase() 
    /*++
    ++*/
    {
        *this = v;
    }

    //---------------------------------------------------------------
    __LicensedPackIdxOnInstalledProduct(
        const LICENSEPACK* v=NULL
        ) : 
        JBKeyBase() 
    /*++
    ++*/
    {
        if(v)
        {
            *this = *v;
        }
    }

    //---------------------------------------------------------------
    __LicensedPackIdxOnInstalledProduct&
    operator=(const LICENSEPACK& v) {
        _tcscpy(szKeyPackId, v.szKeyPackId);
        _tcscpy(szCompanyName, v.szCompanyName);
        _tcscpy(szProductId, v.szProductId);
        wMajorVersion = v.wMajorVersion;
        wMinorVersion = v.wMinorVersion;
        dwPlatformType = v.dwPlatformType;
        SetEmptyValue(FALSE);
        return *this;
    }

    //--------------------------------------------------------
    LPCTSTR
    GetIndexName() 
    {
        return pszIndexName;
    }

    //--------------------------------------------------------
    LPCTSTR
    GetIndexKey() 
    {
        return pszIndexKey;
    }

    //--------------------------------------------------------
    DWORD
    GetNumKeyComponents() { 
        return LICENSEDPACK_INSTALLEDPRODUCT_KEY_COMPONENTS;
    }

    //--------------------------------------------------------
    BOOL
    GetSearchKey(
        DWORD dwComponentIndex,
        PVOID* pbData,
        unsigned long* cbData,
        JET_GRBIT* grbit,
        DWORD dwSearchParm
        )
    /*++
    ++*/
    {
        BOOL retCode=TRUE;
        *cbData = 0;
        *grbit = 0;

        if(dwComponentIndex >= GetNumKeyComponents())
        {
            JB_ASSERT(FALSE);
            return FALSE;
        }

        switch(dwComponentIndex)
        {
            case 0:
                //
                // hopefully, this will reduce the number of record needed to
                // loop thru.
                //
                *pbData = &(szKeyPackId[0]);
                *cbData = _tcslen(szKeyPackId) * sizeof(TCHAR);
                *grbit = JET_bitNewKey;
                break;

            case 1:
                *pbData = &(wMajorVersion);
                *cbData = sizeof(wMajorVersion);
                break;
        
            case 2:
                *pbData = &(wMinorVersion);
                *cbData = sizeof(wMinorVersion);
                break;

            case 3:
                *pbData = &(dwPlatformType);
                *cbData = sizeof(dwPlatformType);
                break;

            case 4:
                *pbData = &(szCompanyName[0]);
                *cbData = _tcslen(szCompanyName) * sizeof(TCHAR);
                break;

            case 5:
                *pbData = &(szProductId[0]);
                *cbData = _tcslen(szProductId) * sizeof(TCHAR);
                break;

            default:
                JB_ASSERT(FALSE);
                retCode = FALSE;
                break;
        }

        return retCode;
    }
} TLSLicensedPackIdxInstalledProduct;



////////////////////////////////////////////////////////////////
//
//  Index for Allocated license
//
////////////////////////////////////////////////////////////////

//
// Index name for allocating license - KeyPack_AllocateLicense_idx
//
#define LICENSEDPACK_INDEX_ALLOCATELICENSE_INDEXNAME \
    LICENSEDPACK_TABLE_NAME SEPERATOR _TEXT("AllocateLicense") SEPERATOR INDEXNAME

#define LICENSEDPACK_ALLOCATELICENSE_KEY_COMPONENTS 6

//
// Index key for allocating license
// "+KeyPackType\0+ProductMajorVersion\0+ProductMinorVersion\0+PlatformType+CompanyName\0+ProductID\0"
//
#define LICENSEDPACK_INDEX_ALLOCATELICENSE_INDEXKEY \
    INDEX_SORT_ASCENDING LICENSEDPACK_COLUMN_AGREEMENTTYPE INDEX_END_COLNAME \
    INDEX_SORT_ASCENDING LICENSEDPACK_COLUMN_MAJORVERSION INDEX_END_COLNAME \
    INDEX_SORT_ASCENDING LICENSEDPACK_COLUMN_MINORVERSION INDEX_END_COLNAME \
    INDEX_SORT_ASCENDING LICENSEDPACK_COLUMN_PLATFORMTYPE INDEX_END_COLNAME \
    INDEX_SORT_ASCENDING LICENSEDPACK_COLUMN_COMPANYNAME INDEX_END_COLNAME \
    INDEX_SORT_ASCENDING LICENSEDPACK_COLUMN_PRODUCTID INDEX_END_COLNAME 


typedef struct __LicensedPackIdxOnAllocLicense : public JBKeyBase {
    //
    // Index for allocating licenses
    //
    UCHAR ucAgreementType;
    WORD  wMajorVersion;
    WORD  wMinorVersion;
    DWORD dwPlatformType;

    TCHAR szCompanyName[LSERVER_MAX_STRING_SIZE + 1];
    TCHAR szProductId[LSERVER_MAX_STRING_SIZE + 1];

    static LPCTSTR pszIndexName;
    static LPCTSTR pszIndexKey;

    //------------------------------------------------------
    __LicensedPackIdxOnAllocLicense(
        const LICENSEPACK* v=NULL
        ) : JBKeyBase() 
    /*++
    ++*/
    {
        if(v)
        {
            *this = *v;
        }
    }

    //------------------------------------------------------
    __LicensedPackIdxOnAllocLicense(
        const LICENSEPACK& v
        ) : 
        JBKeyBase() 
    /*++
    ++*/
    {
        *this = v;
    }
  
    __LicensedPackIdxOnAllocLicense&
    operator=(const LICENSEPACK& v) {
        ucAgreementType = v.ucAgreementType;
        _tcscpy(szCompanyName, v.szCompanyName);
        _tcscpy(szProductId, v.szProductId);
        wMajorVersion = v.wMajorVersion;
        wMinorVersion = v.wMinorVersion;
        dwPlatformType = v.dwPlatformType;

        SetEmptyValue(FALSE);
        return *this;
    }

    //--------------------------------------------------------
    LPCTSTR
    GetIndexName() 
    {
        return pszIndexName;
    }

    //--------------------------------------------------------
    LPCTSTR
    GetIndexKey() 
    {
        return pszIndexKey;
    }

    //--------------------------------------------------------
    DWORD
    GetNumKeyComponents() { 
        return LICENSEDPACK_ALLOCATELICENSE_KEY_COMPONENTS;
    }
    

    //--------------------------------------------------------------
    inline BOOL
    GetSearchKey(
        DWORD dwComponentIndex,
        PVOID* pbData,
        unsigned long* cbData,
        JET_GRBIT* grbit,
        DWORD dwSearchParm
        )
    /*
    */
    {
        BOOL retCode=TRUE;

        if(dwComponentIndex >= GetNumKeyComponents())
        {
            JB_ASSERT(FALSE);
            return FALSE;
        }

        *cbData = 0;
        *grbit = 0;

        switch(dwComponentIndex)
        {
            case 0:
                *pbData = &(ucAgreementType);
                *cbData = sizeof(ucAgreementType);
                *grbit = JET_bitNewKey;
                break;

            case 1:
                *pbData = &(wMajorVersion);
                *cbData = sizeof(wMajorVersion);
                break;
        
            case 2:
                *pbData = &(wMinorVersion);
                *cbData = sizeof(wMinorVersion);
                break;

            case 3:
                *pbData = &(dwPlatformType);
                *cbData = sizeof(dwPlatformType);
                break;

            case 4:
                *pbData = &(szCompanyName[0]);
                *cbData = _tcslen(szCompanyName) * sizeof(TCHAR);
                break;

            case 5:
                *pbData = &(szProductId[0]);
                *cbData = _tcslen(szProductId) * sizeof(TCHAR);
                break;

            default:
                JB_ASSERT(FALSE);
                retCode = FALSE;
                break;
        }

        return retCode;
    }
} TLSLicensedPackIdxAllocateLicense;


//------------------------------------------------------------

// -----------------------------------------------------------
//  LicensedPack Table Structure
// -----------------------------------------------------------
class LicPackTable : public TLSTable<LICENSEPACK>  {
private:

    static LPCTSTR pszTableName;

    BOOL
    ProcessSingleColumn(
        BOOL bFetch,
        TLSColumnBase& column,
        DWORD offset,
        PVOID pbData,
        DWORD cbData,
        PDWORD pcbDataReturn,
        LPCTSTR szColumnName
    );

    BOOL
    ProcessRecord(
        LICENSEPACK* v,
        BOOL bFetch,        // TRUE - fetch, FALSE insert
        DWORD dwParam,
        BOOL bUpdate
    );    

public:
    TLSColumnUchar      ucEntryStatus;

    //
    // Additional License Pack Property.
    //
    TLSColumnDword      dwKeyPackId;
    TLSColumnFileTime   ftLastModifyTime;

    TLSColumnDword      dwAttribute;
    TLSColumnDword      dwNextSerialNumber;
    TLSColumnDword      dwActivateDate;
    TLSColumnDword      dwExpirationDate;
    TLSColumnDword      dwNumberOfLicenses;
    TLSColumnUchar      ucKeyPackStatus;
    TLSColumnBinary     pbDomainSid;
    TLSColumnText       szInstallId;
    TLSColumnText       szDomainName;
    TLSColumnText       szTlsServerName;

    //
    // Standard License Pack Property
    //
    TLSColumnText       szKeyPackId;
    TLSColumnUchar      ucAgreementType;
    TLSColumnText       szCompanyName;
    TLSColumnText       szProductId;
    TLSColumnShort      wMajorVersion;
    TLSColumnShort      wMinorVersion;
    TLSColumnDword      dwPlatformType;
    TLSColumnUchar      ucLicenseType;
    TLSColumnUchar      ucChannelOfPurchase;
    TLSColumnText       szBeginSerialNumber;
    TLSColumnDword      dwTotalLicenseInKeyPack;
    TLSColumnDword      dwProductFlags;

    //-----------------------------------------------------
    virtual LPCTSTR
    GetTableName() 
    {
        return pszTableName;
    }
    

    //-----------------------------------------------------
    LicPackTable(
        JBDatabase& database
        ) : 
        TLSTable<LICENSEPACK> (database)
    /*
    */
    {
    }

    //-----------------------------------------------------
    virtual BOOL
    ResolveToTableColumn();

    //-----------------------------------------------------
    virtual BOOL
    FetchRecord(
        LICENSEPACK& kp,
        DWORD dwParam=PROCESS_ALL_COLUMNS
        )
    /*
    */
    {
        if(IsValid() == FALSE)
        {
            DebugOutput( 
                    _TEXT("Table %s is not valid...\n"),
                    GetTableName()
                );

            JB_ASSERT(FALSE);
            SetLastJetError(JET_errInvalidParameter);
            return FALSE;
        }

        //CCriticalSectionLocker Lock(GetTableLock());

        return ProcessRecord(&kp, TRUE, dwParam, FALSE);
    }

    //-----------------------------------------------------
    virtual BOOL
    InsertRecord(
        LICENSEPACK& kp,
        DWORD dwParam=PROCESS_ALL_COLUMNS
        )
    /*
    */
    {
        if(IsValid() == FALSE)
        {
            DebugOutput( 
                    _TEXT("Table %s is not valid...\n"),
                    GetTableName()
                );

            JB_ASSERT(FALSE);
            SetLastJetError(JET_errInvalidParameter);
            return FALSE;
        }

        //CCriticalSectionLocker Lock(GetTableLock());

        return ProcessRecord(&kp, FALSE, dwParam, FALSE);
    }

    //-------------------------------------------------------
    virtual BOOL
    UpdateRecord(
        LICENSEPACK& kp,
        DWORD dwParam=PROCESS_ALL_COLUMNS
        )
    /*
    */
    {
        if(IsValid() == FALSE)
        {
            DebugOutput( 
                    _TEXT("Table %s is not valid...\n"),
                    GetTableName()
                );

            JB_ASSERT(FALSE);
            SetLastJetError(JET_errInvalidParameter);
            return FALSE;
        }

        //CCriticalSectionLocker Lock(GetTableLock());

        return ProcessRecord(&kp, FALSE, dwParam, TRUE);
    }

    //-------------------------------------------------------
    virtual BOOL
    Initialize() 
    { 
        return TRUE; 
    }

    //-------------------------------------------------------
    virtual JBKeyBase*
    EnumerationIndex( 
        IN BOOL bMatchAll,
        IN DWORD dwParam,
        IN LICENSEPACK* kp,
        IN OUT BOOL* bCompareKey
    );
    
    virtual BOOL
    EqualValue(
        LICENSEPACK& s1,
        LICENSEPACK& s2,
        BOOL bMatchAll,
        DWORD dwParam
    );
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\license\tlserver\tlsdb\licpack.cpp ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996-1998
//
// File:        LicPack.cpp
//
// Contents:    LicensedPack Table
//
// History:     
//              
//---------------------------------------------------------------------------

#include "LicPack.h"

LPCTSTR __LicensedPackIdxOnInternalKpId::pszIndexName = LICENSEDPACK_INDEX_INTERNALKEYPACKID_INDEXNAME;
LPCTSTR __LicensedPackIdxOnInternalKpId::pszIndexKey = LICENSEDPACK_INDEX_INTERNALKEYPACKID_INDEXKEY;

LPCTSTR __LicensedPackIdxOnModifyTime::pszIndexName = LICENSEDPACK_INDEX_LASTMODIFYTIME_INDEXNAME;
LPCTSTR __LicensedPackIdxOnModifyTime::pszIndexKey = LICENSEDPACK_INDEX_LASTMODIFYTIME_INDEXKEY;

LPCTSTR __LicensedPackIdxOnCompanyName::pszIndexName = LICENSEDPACK_INDEX_COMPANYNAME_INDEXNAME;
LPCTSTR __LicensedPackIdxOnCompanyName::pszIndexKey = LICENSEDPACK_INDEX_COMPANYNAME_INDEXKEY;

LPCTSTR __LicensedPackIdxOnProductId::pszIndexName = LICENSEDPACK_INDEX_PRODUCTID_INDEXNAME;
LPCTSTR __LicensedPackIdxOnProductId::pszIndexKey = LICENSEDPACK_INDEX_PRODUCTID_INDEXKEY;

LPCTSTR __LicensedPackIdxOnKeyPackId::pszIndexName = LICENSEDPACK_INDEX_KEYPACKID_INDEXNAME;
LPCTSTR __LicensedPackIdxOnKeyPackId::pszIndexKey = LICENSEDPACK_INDEX_KEYPACKID_INDEXKEY;

LPCTSTR __LicensedPackIdxOnInstalledProduct::pszIndexName = LICENSEDPACK_INDEX_INSTALLEDPRODUCT_INDEXNAME;
LPCTSTR __LicensedPackIdxOnInstalledProduct::pszIndexKey = LICENSEDPACK_INDEX_INSTALLEDPRODUCT_INDEXKEY;

LPCTSTR __LicensedPackIdxOnAllocLicense::pszIndexName = LICENSEDPACK_INDEX_ALLOCATELICENSE_INDEXNAME;
LPCTSTR __LicensedPackIdxOnAllocLicense::pszIndexKey = LICENSEDPACK_INDEX_ALLOCATELICENSE_INDEXKEY;


//----------------------------------------------------
CCriticalSection LicPackTable::g_TableLock;
LPCTSTR LicPackTable::pszTableName = LICENSEDPACK_TABLE_NAME;

//////////////////////////////////////////////////////////////////////////
//
// Index definition for KeyPack table
//
TLSJBIndex
LicPackTable::g_TableIndex[] = 
{
    {
        LICENSEDPACK_INDEX_INTERNALKEYPACKID_INDEXNAME,
        LICENSEDPACK_INDEX_INTERNALKEYPACKID_INDEXKEY,
        -1,
        JET_bitIndexPrimary,
        TLSTABLE_INDEX_DEFAULT_DENSITY
    },        

    {
        LICENSEDPACK_INDEX_LASTMODIFYTIME_INDEXNAME,
        LICENSEDPACK_INDEX_LASTMODIFYTIME_INDEXKEY,
        -1,
        JET_bitIndexIgnoreNull,
        TLSTABLE_INDEX_DEFAULT_DENSITY
    },
    
    {
        LICENSEDPACK_INDEX_COMPANYNAME_INDEXNAME,
        LICENSEDPACK_INDEX_COMPANYNAME_INDEXKEY,
        -1,
        JET_bitIndexIgnoreNull,
        TLSTABLE_INDEX_DEFAULT_DENSITY
    },

    {
        LICENSEDPACK_INDEX_PRODUCTID_INDEXNAME,
        LICENSEDPACK_INDEX_PRODUCTID_INDEXKEY,
        -1,
        JET_bitIndexIgnoreNull,
        TLSTABLE_INDEX_DEFAULT_DENSITY
    },

    {
        LICENSEDPACK_INDEX_KEYPACKID_INDEXNAME,
        LICENSEDPACK_INDEX_KEYPACKID_INDEXKEY,
        -1,
        JET_bitIndexIgnoreNull,
        TLSTABLE_INDEX_DEFAULT_DENSITY
    },
        
    {
        LICENSEDPACK_INDEX_INSTALLEDPRODUCT_INDEXNAME,
        LICENSEDPACK_INDEX_INSTALLEDPRODUCT_INDEXKEY,
        -1,
        JET_bitIndexIgnoreNull,
        TLSTABLE_INDEX_DEFAULT_DENSITY
    },

    {                
        LICENSEDPACK_INDEX_ALLOCATELICENSE_INDEXNAME,
        LICENSEDPACK_INDEX_ALLOCATELICENSE_INDEXKEY,
        -1,
        JET_bitIndexIgnoreNull,
        TLSTABLE_INDEX_DEFAULT_DENSITY
    }
};

int
LicPackTable::g_NumTableIndex = sizeof(LicPackTable::g_TableIndex) / sizeof(LicPackTable::g_TableIndex[0]);

//////////////////////////////////////////////////////////////////////////
//
// Column Definition for KeyPack table
//
TLSJBColumn
LicPackTable::g_Columns[] = 
{
    {        
        LICENSEDPACK_COLUMN_ENTRYSTATUS,
        JET_coltypUnsignedByte,
        0,
        JET_bitColumnFixed,
        NULL,
        0,
        TLS_JETBLUE_COLUMN_CODE_PAGE,
        TLS_JETBLUE_COLUMN_COUNTRY_CODE,
        TLS_JETBLUE_COLUMN_LANGID
    },

    //
    // Internal tracking KeyPackID
    {
        LICENSEDPACK_COLUMN_KEYPACKID,
        JET_coltypLong,
        0,
        JET_bitColumnFixed | JET_bitColumnNotNULL,
        NULL,
        0,
        TLS_JETBLUE_COLUMN_CODE_PAGE,
        TLS_JETBLUE_COLUMN_COUNTRY_CODE,
        TLS_JETBLUE_COLUMN_LANGID
    },

    //
    // Last Modify Time
    {
        LICENSEDPACK_COLUMN_LASTMODIFYTIME,
        JET_coltypBinary,
        sizeof(FILETIME),
        JET_bitColumnNotNULL,
        NULL,
        0,
        TLS_JETBLUE_COLUMN_CODE_PAGE,
        TLS_JETBLUE_COLUMN_COUNTRY_CODE,
        TLS_JETBLUE_COLUMN_LANGID
    },


    //
    // LICENSEDPACK_COLUMN_ATTRIBUTE
    {
        LICENSEDPACK_COLUMN_ATTRIBUTE,
        JET_coltypLong,
        0,
        JET_bitColumnFixed,
        NULL,
        0,
        TLS_JETBLUE_COLUMN_CODE_PAGE,
        TLS_JETBLUE_COLUMN_COUNTRY_CODE,
        TLS_JETBLUE_COLUMN_LANGID
    },
        
    //
    // LICENSEDPACK_COLUMN_KEYPACKSTATUS
    {        
        LICENSEDPACK_COLUMN_KEYPACKSTATUS,
        JET_coltypUnsignedByte,
        0,
        JET_bitColumnFixed | JET_bitColumnNotNULL,
        NULL,
        0,
        TLS_JETBLUE_COLUMN_CODE_PAGE,
        TLS_JETBLUE_COLUMN_COUNTRY_CODE,
        TLS_JETBLUE_COLUMN_LANGID
    },

    //
    // LICENSEDPACK_COLUMN_AVAILABLE
    {
        LICENSEDPACK_COLUMN_AVAILABLE,
        JET_coltypLong,
        0,
        JET_bitColumnFixed | JET_bitColumnNotNULL,
        NULL,
        0,
        TLS_JETBLUE_COLUMN_CODE_PAGE,
        TLS_JETBLUE_COLUMN_COUNTRY_CODE,
        TLS_JETBLUE_COLUMN_LANGID
    },

    //
    // LICENSEDPACK_COLUMN_NEXTSERIALNUMBER
    {
        LICENSEDPACK_COLUMN_NEXTSERIALNUMBER,
        JET_coltypLong,
        0,
        JET_bitColumnFixed | JET_bitColumnNotNULL,
        NULL,
        0,
        TLS_JETBLUE_COLUMN_CODE_PAGE,
        TLS_JETBLUE_COLUMN_COUNTRY_CODE,
        TLS_JETBLUE_COLUMN_LANGID
    },

    //
    // LICENSEDPACK_COLUMN_ACTIVATEDATE
    {
        LICENSEDPACK_COLUMN_ACTIVATEDATE,
        JET_coltypLong,
        0,
        JET_bitColumnFixed | JET_bitColumnNotNULL,
        NULL,
        0,
        TLS_JETBLUE_COLUMN_CODE_PAGE,
        TLS_JETBLUE_COLUMN_COUNTRY_CODE,
        TLS_JETBLUE_COLUMN_LANGID
    },

    //
    // LICENSEDPACK_COLUMN_EXPIREDATE
    {
        LICENSEDPACK_COLUMN_EXPIREDATE,
        JET_coltypLong,
        0,
        JET_bitColumnFixed | JET_bitColumnNotNULL,
        NULL,
        0,
        TLS_JETBLUE_COLUMN_CODE_PAGE,
        TLS_JETBLUE_COLUMN_COUNTRY_CODE,
        TLS_JETBLUE_COLUMN_LANGID
    },

    //
    // LICENSEDPACK_COLUMN_DOMAINSETUPID
    {
        LICENSEDPACK_COLUMN_DOMAINSETUPID,
        JET_coltypLongBinary,
        TLSTABLE_MAX_BINARY_LENGTH,
        0,
        NULL,
        0,
        TLS_JETBLUE_COLUMN_CODE_PAGE,
        TLS_JETBLUE_COLUMN_COUNTRY_CODE,
        TLS_JETBLUE_COLUMN_LANGID
    },

    //
    // LICENSEDPACK_COLUMN_LSSETUPID
    {
        LICENSEDPACK_COLUMN_LSSETUPID,
        JB_COLTYPE_TEXT,
        (MAX_JETBLUE_TEXT_LENGTH + 1)*sizeof(TCHAR),
        0,
        NULL,
        0,
        TLS_JETBLUE_COLUMN_CODE_PAGE,
        TLS_JETBLUE_COLUMN_COUNTRY_CODE,
        TLS_JETBLUE_COLUMN_LANGID
    },

    //
    // LICENSEDPACK_COLUMN_DOMAINNAME
    {
        LICENSEDPACK_COLUMN_DOMAINNAME,
        JB_COLTYPE_TEXT,
        (MAX_JETBLUE_TEXT_LENGTH + 1)*sizeof(TCHAR),
        0,
        NULL,
        0,
        TLS_JETBLUE_COLUMN_CODE_PAGE,
        TLS_JETBLUE_COLUMN_COUNTRY_CODE,
        TLS_JETBLUE_COLUMN_LANGID
    },

    //
    // LICENSEDPACK_COLUMN_LSERVERNAME
    {
        LICENSEDPACK_COLUMN_LSERVERNAME,
        JB_COLTYPE_TEXT,
        (MAX_JETBLUE_TEXT_LENGTH + 1)*sizeof(TCHAR),
        0,
        NULL,
        0,
        TLS_JETBLUE_COLUMN_CODE_PAGE,
        TLS_JETBLUE_COLUMN_COUNTRY_CODE,
        TLS_JETBLUE_COLUMN_LANGID
    },


    //
    // Standard License Pack Property.
    //

    //
    // License Pack ID
    {
        LICENSEDPACK_COLUMN_LPID,
        JB_COLTYPE_TEXT, 
        (MAX_JETBLUE_TEXT_LENGTH + 1)*sizeof(TCHAR),
        0,
        JBSTRING_NULL,
        _tcslen(JBSTRING_NULL),
        TLS_JETBLUE_COLUMN_CODE_PAGE,
        TLS_JETBLUE_COLUMN_COUNTRY_CODE,
        TLS_JETBLUE_COLUMN_LANGID
    },

    //
    // KeyPack type
    {
        LICENSEDPACK_COLUMN_AGREEMENTTYPE,
        JET_coltypUnsignedByte,
        0,
        JET_bitColumnFixed | JET_bitColumnNotNULL,
        NULL,
        0,
        TLS_JETBLUE_COLUMN_CODE_PAGE,
        TLS_JETBLUE_COLUMN_COUNTRY_CODE,
        TLS_JETBLUE_COLUMN_LANGID
    },

    //
    // CompanyName
    {
        LICENSEDPACK_COLUMN_COMPANYNAME,
        // JET_coltypLongText,
        JB_COLTYPE_TEXT,
        (MAX_JETBLUE_TEXT_LENGTH + 1)*sizeof(TCHAR),
        0,
        JBSTRING_NULL,
        _tcslen(JBSTRING_NULL),
        TLS_JETBLUE_COLUMN_CODE_PAGE,
        TLS_JETBLUE_COLUMN_COUNTRY_CODE,
        TLS_JETBLUE_COLUMN_LANGID
    },

    //
    // Product ID
    {
        LICENSEDPACK_COLUMN_PRODUCTID,
        //JET_coltypLongText,
        JB_COLTYPE_TEXT,
        (MAX_JETBLUE_TEXT_LENGTH + 1)*sizeof(TCHAR),
        0,
        JBSTRING_NULL,
        _tcslen(JBSTRING_NULL),
        TLS_JETBLUE_COLUMN_CODE_PAGE,
        TLS_JETBLUE_COLUMN_COUNTRY_CODE,
        TLS_JETBLUE_COLUMN_LANGID
    },

    //
    // Major Version
    {
        LICENSEDPACK_COLUMN_MAJORVERSION,
        JET_coltypShort,
        0,
        JET_bitColumnFixed | JET_bitColumnNotNULL,
        NULL,
        0,
        TLS_JETBLUE_COLUMN_CODE_PAGE,
        TLS_JETBLUE_COLUMN_COUNTRY_CODE,
        TLS_JETBLUE_COLUMN_LANGID
    },
    
    //
    // Minor Version
    {
        LICENSEDPACK_COLUMN_MINORVERSION,
        JET_coltypShort,
        0,
        JET_bitColumnFixed | JET_bitColumnNotNULL,
        NULL,
        0,
        TLS_JETBLUE_COLUMN_CODE_PAGE,
        TLS_JETBLUE_COLUMN_COUNTRY_CODE,
        TLS_JETBLUE_COLUMN_LANGID
    },

    //
    // Platform Type
    {
        LICENSEDPACK_COLUMN_PLATFORMTYPE,
        JET_coltypLong,
        0,
        JET_bitColumnFixed | JET_bitColumnNotNULL,
        NULL,
        0,
        TLS_JETBLUE_COLUMN_CODE_PAGE,
        TLS_JETBLUE_COLUMN_COUNTRY_CODE,
        TLS_JETBLUE_COLUMN_LANGID
    },
 
    //
    // License Type
    {
        LICENSEDPACK_COLUMN_LICENSETYPE,
        JET_coltypUnsignedByte,
        0,
        JET_bitColumnFixed | JET_bitColumnNotNULL,
        NULL,
        0,
        TLS_JETBLUE_COLUMN_CODE_PAGE,
        TLS_JETBLUE_COLUMN_COUNTRY_CODE,
        TLS_JETBLUE_COLUMN_LANGID
    },

    //
    // ChannelOfPurchase
    {
        LICENSEDPACK_COLUMN_COP,
        JET_coltypUnsignedByte,
        0,
        JET_bitColumnFixed | JET_bitColumnNotNULL,
        NULL,
        0,
        TLS_JETBLUE_COLUMN_CODE_PAGE,
        TLS_JETBLUE_COLUMN_COUNTRY_CODE,
        TLS_JETBLUE_COLUMN_LANGID
    },

    //
    //  Begin Serial Number
    {
        LICENSEDPACK_COLUMN_BSERIALNUMBER,
        //JET_coltypLongText,
        JB_COLTYPE_TEXT,
        (MAX_JETBLUE_TEXT_LENGTH + 1)*sizeof(TCHAR),
        0,
        JBSTRING_NULL,
        _tcslen(JBSTRING_NULL),
        TLS_JETBLUE_COLUMN_CODE_PAGE,
        TLS_JETBLUE_COLUMN_COUNTRY_CODE,
        TLS_JETBLUE_COLUMN_LANGID
    },

    //
    //   Total license in License Pack
    {
        LICENSEDPACK_COLUMN_TOTALLICENSES,
        JET_coltypLong,
        0,
        JET_bitColumnFixed | JET_bitColumnNotNULL,
        NULL,
        0,
        TLS_JETBLUE_COLUMN_CODE_PAGE,
        TLS_JETBLUE_COLUMN_COUNTRY_CODE,
        TLS_JETBLUE_COLUMN_LANGID
    },

    //
    //  Product specific Flag   
    {
        LICENSEDPACK_COLUMN_PRODUCTFLAGS,
        JET_coltypLong,
        0,
        JET_bitColumnFixed | JET_bitColumnNotNULL,
        NULL,
        0,
        TLS_JETBLUE_COLUMN_CODE_PAGE,
        TLS_JETBLUE_COLUMN_COUNTRY_CODE,
        TLS_JETBLUE_COLUMN_LANGID
    }
};

int
LicPackTable::g_NumColumns = sizeof(LicPackTable::g_Columns) / sizeof(LicPackTable::g_Columns[0]);


//-----------------------------------------------------

BOOL
LicPackTable::ResolveToTableColumn()
/*
*/
{
    m_JetErr = ucEntryStatus.AttachToTable(
                        *this,
                        LICENSEDPACK_COLUMN_ENTRYSTATUS
                    );

    if(IsSuccess() == FALSE)
        goto cleanup;

    m_JetErr = dwKeyPackId.AttachToTable(
                        *this,
                        LICENSEDPACK_COLUMN_KEYPACKID
                    );

    if(IsSuccess() == FALSE)
        goto cleanup;

    m_JetErr = ftLastModifyTime.AttachToTable(
                        *this,
                        LICENSEDPACK_COLUMN_LASTMODIFYTIME
                    );

    if(IsSuccess() == FALSE)
        goto cleanup;

    m_JetErr = dwAttribute.AttachToTable(
                        *this,
                        LICENSEDPACK_COLUMN_ATTRIBUTE
                    );

    if(IsSuccess() == FALSE)
        goto cleanup;

    m_JetErr = ucKeyPackStatus.AttachToTable(
                        *this,
                        LICENSEDPACK_COLUMN_KEYPACKSTATUS
                    );

    if(IsSuccess() == FALSE)
        goto cleanup;

    m_JetErr = dwNumberOfLicenses.AttachToTable(
                        *this,
                        LICENSEDPACK_COLUMN_AVAILABLE
                    );

    if(IsSuccess() == FALSE)
        goto cleanup;

    m_JetErr = dwNextSerialNumber.AttachToTable(
                        *this,
                        LICENSEDPACK_COLUMN_NEXTSERIALNUMBER
                    );

    if(IsSuccess() == FALSE)
        goto cleanup;

    m_JetErr = dwActivateDate.AttachToTable(
                        *this,
                        LICENSEDPACK_COLUMN_ACTIVATEDATE
                    );

    if(IsSuccess() == FALSE)
        goto cleanup;

    m_JetErr = dwExpirationDate.AttachToTable(
                        *this,
                        LICENSEDPACK_COLUMN_EXPIREDATE
                    );

    if(IsSuccess() == FAL